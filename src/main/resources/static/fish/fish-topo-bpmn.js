(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["fishTopoBpmn"] = factory();
	else
		root["fishTopoBpmn"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Export fishTopo as CommonJS module
	 */
	module.exports = __webpack_require__(2);
	//兼容IE8 引入VML 如果不需要兼容IE8请删除
	__webpack_require__(159);
	


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * BPMN对象
	 * @class fish.topo.FishTopoBpmn
	 */
	
	/**
	 * @event click
	 * 节点或者线段的click事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *      this.fishTopoBpmn.on("click",function(e) {
	    *          var target = e.target;
	    *          if(FishTopoBpmn.Bpmn.isFlow(target)) { //判断类型
	    *              var lineNode = e.target;
	    *              that.fishTopoBpmn.bindLineDelete(lineNode); //给线段增加删除图标
	    *              //todo
	    *          }
	    *      }
	    */
	
	   /**
	    * @event dblclick
	    * 节点或者线段的双击事件
	    * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	    *
	    * **使用范例**：
	    *
	    *      @example
	    *          //双击弹出节点对应的json
	    *          this.fishTopoBpmn.on("dblclick",function(e) {
	    *              var target = e.target;
	    *
	    *              if(FishTopoBpmn.Bpmn.isFlow(target)) {
	    *                  console.log("dblclick line");
	    *              }
	    *              else{
	    *                  var json = nodeModel.option;
	    *                  fish.popupView({
	    *                      url: "views/dialog/ExportJsonDlg.js",
	    *                      viewOption:{bpmnJson:JSON.stringify(json,null,4)},
	    *                      callback: function(popup,view) {
	    *                          console.log("OK");
	    *                      },
	    *                      close: function(msg) {
	    *                          console.log("return value: " + msg);
	    *                      }
	    *                  });
	    *              }
	    *          });
	    */
	
	   /**
	    * @event create
	    * 节点与线段创建完毕的事件
	    * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	    *
	    * **使用范例**：
	    *
	    *      @example
	    *          this.fishTopoBpmn.on("create", function(e) {
	    *              if(FishTopoBpmn.Bpmn.isFlow(e.target)) {
	    *                  var line = e.target;
	    *                  console.log("连线创建完毕，从" + line.startNode.model.get("properties.name") + " 至 " + line.endNode.model.get("properties.name"));
	    *              } else {
	    *                  var node = e.target;
	    *                  console.log("节点：" + node.model.get("properties.name") + " 创建完毕");
	    *              }
	    *          });
	    */
	
	   /**
	    * @event delete
	    * 节点与线段删除完毕的事件
	    * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	    *
	    * **使用范例**：
	    *
	    *      @example
	    *          //节点删除完毕事件
	    *          this.fishTopoBpmn.on("delete", function(event) {
	    *              console.log("删除的是：" + event.target);
	    *          });
	    */
	
	   
	       var graphic = __webpack_require__(3);
	       var ExtensionAPI = __webpack_require__(63);
	       var Point = __webpack_require__(64);
	       var Eventful = __webpack_require__(11);
	       var zrender = __webpack_require__(65);
	       var zrUtil = __webpack_require__(4);
	       var BoundingRect = __webpack_require__(26);
	       var BpmnUtil = __webpack_require__(76);
	       var util = __webpack_require__(77);
	       var BPMNModel = __webpack_require__(82);
	       var BPMNNode = __webpack_require__(79);
	       var GroupNode = __webpack_require__(110);
	       var OperationNode = __webpack_require__(111);
	       var BpmnConnectionManager = __webpack_require__(114);
	       var Connector = __webpack_require__(105);
	       var textContain = __webpack_require__(25);
	       var LineOperationManager = __webpack_require__(117);
	       var Guidelines = __webpack_require__(118);
	       var promise = __webpack_require__(119);
	       var Bpmn = __webpack_require__(104);
	       var keyCode = {ENTER:13, ESCAPE:27};
	       __webpack_require__(158);
	       BpmnUtil.registerBPMNNode();
	
	       function FishTopoBpmn(dom, opts) {
	           this.id;
	           this.group;
	           this._dom = dom;
	           this._zr = zrender.init(dom, {
	               renderer: opts.renderer || 'canvas',
	               devicePixelRatio: opts.devicePixelRatio
	           });
	           this.allNodes = []; //存放所有节点
	           this.subProcessNode = [];  //存放子节点
	           this.domArray = []; //存放节点的位置信息，拖动的时候用到
	           this.overlapArray = []; // 存放节点的位置信息，判断重叠用到，除去了子流程里面的节点
	           this.selectedNode = null;  //选中的节点
	           this.isNode = false;
	           this.nowZoom = 1;
	           this.rect;  // 对齐线和移动框节点
	           this.operationNode;
	           this.step = 0;//前进后退计步数
	           this.stepJson = [];//存放每步的json
	           this.opts = opts;
	           this.selectedNodes = [];
	           this.lineOpt = {};  //初始的线段配置信息
	           this._api = new ExtensionAPI(this);
	           this.conPointsGroup = new graphic.Group();  //存放所有节点的连接点
	           this.conControlsGroup = new graphic.Group();  //存放所有节点的控制点
	           /**
	            * @cfg {Boolean} forbidEdit 是否禁用编辑功能
	            */
	           this.forbidEdit = opts.forbidEdit === undefined ? false : opts.forbidEdit;
	           this.mouseMode = 'default',                 //当前画布上鼠标的操作模式，default为正常点击、拖拽等操作，drag-select为框选操作
	           this.connectionManager = new BpmnConnectionManager();
	           this.lineOperationManager = new LineOperationManager(this.connectionManager,this._api);
	           this.model = new BPMNModel({});
	           this.model.set(Bpmn.RESOURCE_ID, util.getUUID());
	           this.model.set(Bpmn.BPMN_TYPE, Bpmn.TEMPLATE);
	           this.cursorMap = {
	               tl: 'nw-resize',
	               tr: 'ne-resize',
	               bl: 'sw-resize',
	               br: 'se-resize',
	               mtr:'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAAYFBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD6T+iNAAAAH3RSTlMA7sUMoYXnEkYYzaaTjQiAQCweBcG7fvnULh2ZdjMy6Fzd7wAAALJJREFUGNN1kFkOwzAIBQHvW/Y6Sbfc/5Y1ltqoljIf2BohBA8qU096xeV5L/+uFH4SpsGAGSKmThCyMz64Ud38Te0meIpHcTP1ndTKvqzSUuQILFMQJAUwIngBLCd0UrJhSRGqzHHU3FcHBVMokqxS38YNGQLQbhmgZZ23sVEXnXVmS467Fq0892SSLaW5SHrN9rz9bXv9EHIB+E9pdMG7Ys48Z2cjxo7FL3k8kPIE13wAmEUIO2ML9YMAAAAASUVORK5CYII=) 10 10, auto'
	           }; // 节点控制点鼠标信息(上左，上右，下左，下右，旋转)
	           this.cursorMaps = [
	               'n-resize',
	               'ne-resize',
	               'e-resize',
	               'se-resize',
	               's-resize',
	               'sw-resize',
	               'w-resize',
	               'nw-resize'
	           ]
	           this.cursorOffset = {
	               tr: 1,
	               br: 3,
	               bl: 5,
	               tl: 7
	           }
	           Eventful.call(this);
	       }
	
	       var fishTopoProto = FishTopoBpmn.prototype;
	
	       /**
	        * 获取 fishTopo 实例容器的 dom 节点
	        * @return {HTMLElement}
	        */
	       fishTopoProto.getDom = function() {
	           return this._dom;
	       };
	
	       /**
	        * @private
	        */
	       fishTopoProto.getZr = function() {
	           return this._zr;
	       };
	       /**
	        * 获取 fishTopo 实例容器的宽度。
	        * @return {number}
	        */
	       fishTopoProto.getWidth = function() {
	           return this._zr.getWidth();
	       };
	
	       /**
	        * 获取 fishTopo 实例容器的高度。
	        * @return {number}
	        */
	       fishTopoProto.getHeight = function() {
	           return this._zr.getHeight();
	       };
	
	
	       /**
	        * 当前实例是否已经被释放。
	        * @return {boolean}
	        */
	       fishTopoProto.isDisposed = function() {
	           return this._disposed;
	       };
	
	       /**
	        * Dispose instance
	        */
	       fishTopoProto.dispose = function() {
	           this._disposed = true;
	
	           this._zr.dispose();
	
	           instances[this.id] = null;
	       };
	
	
	       /**
	        * 调整尺寸  在窗口大小发生改变时需要手工调用
	        * @param {number} width 宽度
	        * @param {number} height 高度
	        */
	       fishTopoProto.resize = function(width, height) {
	           this.getDom().style.width = width + 'px';
	           this.getDom().style.height = height + 'px';
	           this._zr.resize();
	           this._zr.remove(this.group);
	           this.group = new graphic.Group();
	           if (this.opts.showGridLine == true || this.opts.showGridLine == "true") {
	               this.gridLine(0.2);
	               this._zr.add(this.group);
	           }
	       };
	
	       /** @private 初始化 */
	       fishTopoProto.init = function() {
	           this.group = new graphic.Group();
	           if (this.opts.showGridLine == true || this.opts.showGridLine == "true") {
	               this.gridLine(0.2);
	               this._zr.add(this.group);
	           }
	
	           //mouseup 会在各个node或线的点击事件之前执行  在选中节点或线前 先清空选中效果
	           this._zr.on("mouseup", function(e) {
	               // 1. 清空节点的选中效果
	               // this._removeOperationNode();
	               // 2. 点击的线 ，则直接返回
	               var shape = e.target;
	               if (shape && shape.connector instanceof Connector) {
	                   return;
	               }
	               this.connectionManager.clearSelectCon();
	               if (shape && shape._isLineOperationIcon && shape._isLineOperationIcon == true) {
	                   return;
	               }
	           }.bind(this));
	           //派发不是节点或线 的画布点击事件
	           this._zr.on("click", function(e) {
	               // 如果点击了控制点，则不会取消选中状态(控制点不在节点范围内)
	               var target = e.target || {};
	               var type = target.type;
	               if (type !== 'ConnectControlLine' && type !== 'ConnectControl') {
	                   this.hideConnectorPoint();
	                   this.hideConnectorControl();
	                   this._removeOperationNode();
	                   this.lineOperationManager.hideAllLineOperation();
	                   var shape = e.target;
	                   //点击的线
	                   if (shape && shape.parent && shape.parent.resourceId) {
	                       return;
	                   } else {
	                       var params = {};
	                       params.event = e;
	                       params.type = "click";
	                       params.target = this;
	                       this._api.trigger(params.type, params);
	                   }
	               }
	           }.bind(this));
	
	           this._zr.on("mousedown", function (e) {
	               if (this.mouseMode === 'drag-select' && (!e.target || (e.target && e.target.type === 'grid-line') || (e.target && e.target.name === 'subprocess-rect'))) {
	                   this._dragSelect(e.target, e.offsetX, e.offsetY);
	               }
	           }.bind(this));
	
	           this.on('conPointsGroup:click', function(argument) {
	               this.lineOperationManager.bindOperation(argument.lineNode);
	           }.bind(this))
	       };
	
	       fishTopoProto._releaseSelectNode = function (flag) {
	           if (this.dragSelectRect) {
	               var nodes = this.dragSelectRect.children().filter(function (v) {
	                   return v.name !== "GROUP_RECT_NAME";
	               });
	               var startX = this.dragSelectRect.position[0];
	               var startY = this.dragSelectRect.position[1];
	               for (var i = 0; i < nodes.length; i++) {
	                   var item = nodes[i];
	                   var nodeX = Bpmn.isFlow(item) ? 0 : item.getRect().x;
	                   var nodeY = Bpmn.isFlow(item) ? 0 : item.getRect().y;
	                   this.dragSelectRect.remove(item);
	                   if (item.originParent && !flag) {
	                       item.originParent.add(item);
	                   } else {
	                       this._zr.add(item);
	                   }
	                   if (!Bpmn.isFlow(item)) {
	                       if (item.originParent && !flag) {
	                           item.setPosition(nodeX+startX-BpmnUtil.parentX(item.originParent), nodeY+startY-BpmnUtil.parentY(item.originParent));
	                       } else {
	                           item.setPosition(nodeX+startX, nodeY+startY);
	                       }
	                       this.connectionManager.refreshLineByNode(item);
	                   }
	                   if (item.originParent) {
	                       item.originParent = null;
	                   }
	               }
	               this.dragSelectRect.off("mousedown");
	               this._zr.remove(this.dragSelectRect);
	           }
	       }
	
	       fishTopoProto._dragSelect = function (node, x, y) {
	           this._releaseSelectNode();  //还原选中的节点
	           this.dragSelectRect = new GroupNode({
	               shape:{ width: 0, height: 0},
	               position:[x, y],
	               style: {
	                   lineDash:[2,2],
	                   fill: "rgba(239,222,221,0.7)",
	                   stroke: 'rgba(0, 0, 0, 1)'
	               }
	           });
	           this.dragSelectRect.type = "dragSelect";
	           this._zr.add(this.dragSelectRect);
	           this.dragSelectRect.on('mousedown', function(e) {
	               this.newDrag(this.dragSelectRect, e.event.clientX, e.event.clientY);
	               e.cancelBubble = true;
	           }.bind(this));
	
	           var moveHandler = function (event) {
	               if (Math.abs(event.offsetX - x) <= 1 && Math.abs(event.offsetY - y) <= 1) {
	                   return;
	               }
	               var posX = x <= event.offsetX ? x : event.offsetX;
	               var posY = y <= event.offsetY ? y : event.offsetY;
	               var width = Math.abs(event.offsetX - x);
	               var height = Math.abs(event.offsetY - y);
	               this.dragSelectRect.setProperties({shape: {width:width, height: height}, position: [posX, posY]});
	           }.bind(this);
	           this._zr.on('mousemove', moveHandler);
	
	           var endDragHandler = function (event) {
	               this._zr.off('mousemove', moveHandler);
	               this._zr.off('mouseup', endDragHandler);
	               this._zr.off("globalout", endDragHandler);
	               if (Math.abs(event.offsetX - x) <= 1 && Math.abs(event.offsetY - y) <= 1) {
	                   if (node && node.parent && Bpmn.isSubProcess(node.parent)) {
	                       this.nodeClickHandler(node.parent);
	                       this._trigger('selectNode', {target: node.parent});
	                   }
	                   return;
	               }
	               var ts = this;
	               var startX = this.dragSelectRect.position[0];
	               var startY = this.dragSelectRect.position[1];
	               var width = this.dragSelectRect.options.shape.width;
	               var height = this.dragSelectRect.options.shape.height;
	               var cnt = 0;
	               this.allNodes.forEach(function (item) {
	                   var rect = item.getRect();
	                   var nodeWidth = rect.width;
	                   var nodeHeight = rect.height;
	                   var nodeX = item.parent ? rect.x+BpmnUtil.parentX(item.parent) : rect.x;
	                   var nodeY = item.parent ? rect.y+BpmnUtil.parentY(item.parent) : rect.y;
	                   if (((Bpmn.isEvent(item) || Bpmn.isGateway(item)) &&
	                       nodeX-nodeWidth >= startX && nodeY-nodeWidth >= startY &&
	                       nodeX+nodeWidth <= startX+width && nodeY+nodeWidth <= startY+height) ||
	                       (!(Bpmn.isEvent(item) || Bpmn.isGateway(item)) &&
	                       nodeX-nodeWidth/2 >= startX && nodeY-nodeHeight/2 >= startY &&
	                       nodeX+nodeWidth/2 <= startX+width && nodeY+nodeHeight/2 <= startY+height)) {
	                       if (item.slotEvent && item.slotEvent.length > 0) {
	                           for (var n = 0; n < item.slotEvent.length; n++) {
	                               var slotEventPosition2 = [item.slotEvent[n].position[0] + (nodeX-startX) - zrUtil.clone(item.position[0]) - item.getBoundingRect().width / 2, item.slotEvent[n].position[1] + (nodeY-startY) - zrUtil.clone(item.position[1]) - item.getBoundingRect().height / 2];
	                               item.slotEvent[n].attr("position", slotEventPosition2);
	                               that.connectionManager.refreshLineByNode(item.slotEvent[n]);
	                           }
	                       }
	                       if (item.parent) {
	                           item.originParent = item.parent;
	                           item.parent.remove(item);
	                       } else {
	                           ts._zr.remove(item);
	                       }
	                       ts.dragSelectRect.add(item);
	                       ts.selectedNodes.push(item);
	                       item.setPosition(nodeX-startX, nodeY-startY);
	                       cnt++;
	                   }
	               });
	               if (!cnt) {
	                   this.dragSelectRect.off("mousedown");
	                   this._zr.remove(this.dragSelectRect);
	               } else {
	                   this.dragSelectRect.childOfName("GROUP_RECT_NAME").attr("style", {
	                       fill: "rgba(0,0,0,0)"
	                   });
	                   this.connectionManager.connectors.forEach(function (item) {
	                       var startNode = ts.dragSelectRect.children().find(function (v) {
	                           return v.id === item.startNode.id;
	                       });
	                       var endNode = ts.dragSelectRect.children().find(function (v) {
	                           return v.id === item.endNode.id;
	                       });
	                       if (startNode && endNode) {
	                           ts._zr.remove(item);
	                           ts.dragSelectRect.add(item);
	                           ts.connectionManager.refreshLineByNode(item.startNode);
	                       }
	                   });
	               }
	           }.bind(this);
	           this._zr.on('mouseup', endDragHandler);
	           this._zr.on("globalout", endDragHandler);
	       }
	
	       /**
	        * 根据传过来的值  设置节点模型
	        * @param {Object} shape  节点或线
	        * @param {Object} option 模型数据
	        * @param {number} width 宽度(仅用于调整画布大小)
	        * @param {number} height 高度(仅用于调整画布大小)
	        */
	       fishTopoProto.setShapeModel = function(shape, option, width, height) {
	           if (this.forbidEdit === true) {
	               return;
	           }
	           if (Bpmn.isTemplate(shape)) {
	               this.model.mergeOption(option);
	               if (width > 0 && height > 0) {
	                   this.resize(width, height);
	               }
	           } else if (Bpmn.isFlow(shape)) {
	               this.connectionManager.setModel(shape, option);
	           } else {
	               if (shape.bpmnInfo.name.indexOf("Task") !== -1) {
	                   option.properties.position = 'center';
	               }
	               if (shape.bpmnInfo.name === 'Comment') {
	                   option.properties.position = 'left';
	               }
	               shape.setModel(option);
	           }
	       };
	
	       /**
	        * 获取父
	        */
	       fishTopoProto._getParentZr = function(node) {
	           var parentZr = null;
	           if (node && node.parent) {
	               parentZr = node.parent;
	           } else {
	               parentZr = this._zr;
	           }
	           return parentZr;
	       }
	
	       /**
	        * 清空当前实例，会移除实例中所有的节点与线
	        * @method clear
	        */
	       fishTopoProto.clear = function(isNoCount) {
	           this.allNodes = [];
	
	           this.subProcessNode = [];
	
	           this.domArray = [];
	
	           this.overlapArray = [];
	
	           this.hideConnectorPoint();  //隐藏所有节点上的连接点
	
	           this.selectedNode = null;
	           this.rect = null;
	           this.connectionManager.connectors = [];
	           this._zr.clear();
	           this._zr.add(this.group); // 画网格线  代码放这比较恶心 后面改
	           if (isNoCount != true) {
	               this.stepCounter();
	           }
	       };
	
	       /**
	        * 设置是否显示网络线
	        * @param  {Boolean} isForbidden 是否显示网络线
	        */
	       fishTopoProto.forbidGridLine = function(isForbidden) {
	           this.opts.showGridLine = !isForbidden;
	           if (isForbidden == true) {
	               this._zr.remove(this.group);
	           } else {
	               this._zr.remove(this.group);
	               this.group = new graphic.Group();
	               this.gridLine(0.2);
	               this._zr.add(this.group);
	           }
	       };
	
	       /**
	        * 导出json
	        * @return {string} json字符串
	        */
	       fishTopoProto.toJson = function() {
	           return BpmnUtil.toJson(this.model, this.allNodes, this.connectionManager.connectors);
	       };
	
	       /**
	        * 导入json
	        * @param  {string} json json格式的字符串
	        */
	       fishTopoProto.fromJson = function(json) {
	           BpmnUtil.fromJson(this, json);
	       };
	
	       //背景网格线
	       fishTopoProto.gridLine = function(opacity) {
	           var pixel = this.opts.gridLineSpacing;
	           var widthLen = parseInt(this.getWidth() / pixel);
	           for (var x = 0; x <= widthLen; x++) {
	               var lineX = new graphic.Line({
	                   shape: {
	                       x1: x * pixel,
	                       y1: 0,
	                       x2: x * pixel,
	                       y2: this.getHeight()
	                   },
	                   style: {
	                       lineDash: [1],
	                       opacity: opacity
	                   },
	                   z: -1,
	                   draggable: false,
	                   cursor: 'default'
	               });
	               lineX.type = "grid-line";
	               this.group.add(lineX);
	           }
	
	           var heightLen = parseInt(this.getHeight() / pixel, pixel);
	           for (var y = 0; y <= heightLen; y++) {
	               var lineY = new graphic.Line({
	                   shape: {
	                       x1: 0,
	                       y1: y * pixel,
	                       x2: this.getWidth(),
	                       y2: y * pixel
	                   },
	                   style: {
	                       lineDash: [1],
	                       opacity: opacity
	                   },
	                   z: -1,
	                   draggable: false,
	                   cursor: 'default'
	               });
	               lineY.type = "grid-line";
	               this.group.add(lineY);
	           }
	       };
	
	       fishTopoProto._removeOperationNode = function() {
	           if (this.operationNode) {
	               this._zr.remove(this.operationNode);
	               this.operationNode.cleanup();
	               this.operationNode = null;
	           }
	       }
	
	       /**
	        * 通过界面拖动 增加节点
	        * @param {string} itemType 创建节点的类型（已有预定义类型包括StartNoneEvent、EndNoneEvent、UserTask、ManualTask、ScriptTask、MailTask、CatchTimerEvent、CatchSignalEvent、ThrowSignalEvent、InclusiveGateway、ExclusiveGateway、ParallelGateway、SubProcess）
	        * @param {number} x        节点创建的x坐标
	        * @param {number} y        节点创建的y坐标
	        * @param {Object} options 选项
	        * @param {Object} [options.name] 节点下面显示名称
	        * @param {Array} [options.operationIcons] 设置选中节点时 显示的操作小图标， 默认提供了 删除、直线、折线、曲线4种图标，也可以自定图标 eg.
	        * <pre>
	        *          operationIcons: [{ name: 'DEL' },
	        *              { name: 'STRAIGHT' },
	        *              { name: 'JAGGED' },
	        *              { name: 'CURVE' },
	        *              {
	        *                  name: "custom1",
	        *                  iconPath: "img/host.png",
	        *                  callback: function(e) { alert(e.data.name + " clicked") }  //e.node是当前的节点
	        *              }
	        *          ]
	        * </pre>
	        * @param {Object} userData 用户传递的业务数据
	        *
	        * **使用范例**：
	        *
	        *      @example
	        *      fishTopo.addNode(itemType, x, y, {
	        *                      name: itemType,   //节点的名称
	        *                      operationIcons:[{name:'DEL'},{ name: 'STRAIGHT' },{name:'JAGGED'},{ name: 'CURVE' }],
	        *                      // 增加节点操作图标 上面分别是"删除、直线、折线、曲线"，
	        *                      // 也可以增加自定图标 如{name: "custom1", iconPath: "img/host.png", callback: function(e) { alert(e.data.name + " clicked") }} //e.node是当前的节点
	        *                      userData:{businessData:'我是业务数据,通过Bpmn.getUserData可获取'}
	        *                      // 增加节点的自定义业务，可以通过Bpmn.getUserData(node)获取
	        *                  });
	        */
	       fishTopoProto.addNode = function(itemType, x, y, options) {
	           var that = this;
	           //判断是否在范围内
	           if (x >= 0 && y >= 0) {
	               var model = new BPMNModel({});
	               model.set(Bpmn.BPMN_TYPE, itemType);
	               model.set("bounds.upperLeft", {x: x, y: y});
	               if (options) {
	                   model.set("properties", options);
	               }
	               this._triggerAsync('beforeCreateNode', {target: null}, model).then(function (res) {
	                   if (res) {
	                       that.asyncAddNodeByModel(model, true);
	                   }
	               });
	           }
	       };
	
	       //添加一个流程图片段
	       fishTopoProto.addShapes = function(childShapes, x, y) {
	           if (x < 0 || y < 0) {
	               return;
	           }
	           //先拿到老的画布json数据
	           var cloneChildShapes = JSON.parse(JSON.stringify(childShapes));
	           var canvasData = this.toJson();
	           var oldChildShapes = JSON.parse(JSON.stringify(canvasData.childShapes));
	
	           //计算出要添加shapes的宽高
	           var allUpperLeftX = [], allUpperLeftY = [], allLowerRightX = [], allLowerRightY = [];
	           for (var i = 0; i < cloneChildShapes.length; i++) {
	               var node = cloneChildShapes[i];
	               if (node.stencil.type !== Bpmn.SEQUENCE_FLOW) {
	                   allUpperLeftX.push(node.bounds.upperLeft.x);
	                   allUpperLeftY.push(node.bounds.upperLeft.y);
	                   allLowerRightX.push(node.bounds.lowerRight.x);
	                   allLowerRightY.push(node.bounds.lowerRight.y);
	               }
	           }
	           var minX = Math.min.apply(Math, allUpperLeftX);
	           var minY = Math.min.apply(Math, allUpperLeftY);
	           var maxX = Math.max.apply(Math, allLowerRightX);
	           var maxY = Math.max.apply(Math, allLowerRightY);
	           var shapesWidth = maxX - minX;
	           var shapesHeight = maxY - minY;
	
	           //判断往画布里还是子进程里添加shapes
	           var insertPos = 'canvas';
	           function JudgeInSubProcess(subProcess, x, y) {
	               if (subProcess.length > 0) {
	                   for (var i = 0; i < subProcess.length; i++) {
	                       if (x > BpmnUtil.parentX(subProcess[i]) && x < BpmnUtil.parentX(subProcess[i]) + subProcess[i].getRect().width
	                        && y > BpmnUtil.parentY(subProcess[i]) && y < BpmnUtil.parentY(subProcess[i]) + subProcess[i].getRect().height) {
	                           if (subProcess[i].children() && subProcess[i].children().length > 0) {
	                               var newSubProcess = subProcess[i].children().filter(function (item) {
	                                   return item.bpmnInfo && item.nodeType === 'SubProcess'
	                               });
	                               var node = JudgeInSubProcess(newSubProcess, x, y);
	                           }
	                           return node || subProcess[i];
	                       }
	                   }
	               }
	               return null;
	           }
	
	           var _subProcess = JudgeInSubProcess(this.subProcessNode, x, y);
	           if (_subProcess) {
	               insertPos = _subProcess.resourceId;
	           }
	
	           //计算出shapes里每个shape的新位置， 并插入到画布或者某个子进程的childShapes里
	           var newChildShapes = [];
	           if (insertPos === 'canvas') {
	               for (var i = 0; i < cloneChildShapes.length; i++) {
	                   var item = cloneChildShapes[i];
	                   if (item.stencil.type !== Bpmn.SEQUENCE_FLOW) {
	                       item.bounds.upperLeft.x = item.bounds.upperLeft.x - minX + x;
	                       item.bounds.lowerRight.x = item.bounds.lowerRight.x - minX + x;
	                       item.bounds.upperLeft.y = item.bounds.upperLeft.y - minY + y;
	                       item.bounds.lowerRight.y = item.bounds.lowerRight.y - minY + y;
	                   } else {
	                       item.dockers = [];
	                   }
	               }
	               //画布里还存在其他节点
	               if (oldChildShapes.length > 0) {
	                   for (var j = 0; j < oldChildShapes.length; j++) {
	                       var node = oldChildShapes[j];
	                       if (node.stencil.type === Bpmn.SEQUENCE_FLOW) {
	                           node.dockers = [];
	                           continue;
	                       }
	                       if (node.bounds.lowerRight.x >= x && node.bounds.lowerRight.y >= y ) {
	                           //判断需要修改位置的节点
	                           if (node.bounds.upperLeft.x <= x ) {
	                               //节点位置向下移动
	                               node.bounds.upperLeft.y = node.bounds.upperLeft.y + shapesHeight;
	                               node.bounds.lowerRight.y = node.bounds.lowerRight.y + shapesHeight;
	                           } else {
	                               //节点位置向右移动
	                               node.bounds.upperLeft.x = node.bounds.upperLeft.x + shapesWidth;
	                               node.bounds.lowerRight.x = node.bounds.lowerRight.x + shapesWidth;
	                           }
	                       }
	                   }
	               }
	               newChildShapes = oldChildShapes.concat(cloneChildShapes);
	               canvasData.childShapes = newChildShapes;
	           } else {
	               for (var m = 0; m < cloneChildShapes.length; m++) {
	                   var item = cloneChildShapes[m];
	                   if (item.stencil.type !== Bpmn.SEQUENCE_FLOW) {
	                       item.bounds.upperLeft.x = item.bounds.upperLeft.x - minX + (x - BpmnUtil.parentX(_subProcess));
	                       item.bounds.lowerRight.x = item.bounds.lowerRight.x - minX + (x - BpmnUtil.parentX(_subProcess));
	                       item.bounds.upperLeft.y = item.bounds.upperLeft.y - minY + (y - BpmnUtil.parentY(_subProcess));
	                       item.bounds.lowerRight.y = item.bounds.lowerRight.y - minY + (y - BpmnUtil.parentY(_subProcess));
	                   } else {
	                       item.dockers = [];
	                   }
	               }
	               var newX, newY;
	               //修改所在子进程节点的宽高和它的位置信息
	               for (var n = 0; n < oldChildShapes.length; n++) {
	                   var node = oldChildShapes[n];
	                   if (node.resourceId === insertPos) {
	                       newX = node.bounds.upperLeft.x;
	                       newY = node.bounds.upperLeft.y;
	                       if (node.bounds.lowerRight.x - x < shapesWidth) {
	                           node.bounds.lowerRight.x = shapesWidth + x + 10;
	                       }
	                       if (node.bounds.lowerRight.y - y < shapesHeight) {
	                           node.bounds.lowerRight.y = shapesHeight + y + 10;
	                       }
	                       //插入的子进程节点里确保没有其他节点，若存在其他节点将会清空
	                       node.childShapes = [].concat(cloneChildShapes);
	                   }
	               }
	               //撑开子进程节点可能会影响它周围的节点，因此需要修改周围节点的位置信息
	               for (var k = 0; k < oldChildShapes.length; k++) {
	                   var node = oldChildShapes[k];
	                   if (node.resourceId === insertPos) {
	                       continue;
	                   }
	                   if (node.stencil.type === Bpmn.SEQUENCE_FLOW) {
	                       node.dockers = [];
	                       continue;
	                   }
	                   if (node.bounds.lowerRight.x >= newX && node.bounds.lowerRight.y >= newY ) {
	                       //判断需要修改位置的节点
	                       if (node.bounds.upperLeft.x <= newX ) {
	                           //节点位置向下移动
	                           node.bounds.upperLeft.y = node.bounds.upperLeft.y + shapesHeight;
	                           node.bounds.lowerRight.y = node.bounds.lowerRight.y + shapesHeight;
	                       } else {
	                           //节点位置向右移动
	                           node.bounds.upperLeft.x = node.bounds.upperLeft.x + shapesWidth;
	                           node.bounds.lowerRight.x = node.bounds.lowerRight.x + shapesWidth;
	                       }
	                   }
	               }
	               canvasData.childShapes = oldChildShapes;
	           }
	           //重新渲染整个画布
	           this.fromJson(canvasData);
	           this.stepCounter();
	       }
	
	       fishTopoProto._JudgeNodeInWhichSubProcess = function (subProcess, node) {
	           if (subProcess.length > 0) {
	               for (var i = 0; i < subProcess.length; i++) {
	                   var boundingRect = new BoundingRect(
	                       BpmnUtil.parentX(subProcess[i]),
	                       BpmnUtil.parentY(subProcess[i]),
	                       subProcess[i].getRect().width,
	                       subProcess[i].getRect().height
	                   );
	                   if (boundingRect.contain(node.x, node.y)) {
	                       var newNode;
	                       if (subProcess[i].children() && subProcess[i].children().length > 0) {
	                           var newSubProcess = subProcess[i].children().filter(function (item) {
	                               return item.bpmnInfo && item.nodeType === 'SubProcess'
	                           });
	                           newNode = this._JudgeNodeInWhichSubProcess(newSubProcess, node);
	                       }
	                       return newNode || subProcess[i];
	                   }
	               }
	           }
	           return null;
	       }
	       /**
	        * 根据模型增加节点(同步)
	        * @private
	        * @param {Object} model [description]
	        * @return {Object} 创建完成的节点
	        */
	       fishTopoProto.addNodeByModel = function(model, isFromDrag, isNoCount) {
	           var that = this;
	           var Shape = BPMNNode.getClass(model.get(Bpmn.BPMN_TYPE));
	
	           if (Shape) {
	               var node = new Shape(model, this._api);
	               var _subProcess = that._JudgeNodeInWhichSubProcess(that.subProcessNode, {x: node.getRect().x, y: node.getRect().y});
	               that.addNodeToShape(node, isFromDrag, isNoCount, _subProcess);
	               return node;
	           }
	       };
	
	       /**
	        * 根据模型增加节点(异步)
	        * @private
	        * @param {Object} model [description]
	        * @return {Object} 创建完成的节点
	        */
	       fishTopoProto.asyncAddNodeByModel = function(model, isFromDrag, isNoCount) {
	           var that = this;
	           var Shape = BPMNNode.getClass(model.get(Bpmn.BPMN_TYPE));
	
	           if (Shape) {
	               var node = new Shape(model, this._api);
	               var _subProcess = that._JudgeNodeInWhichSubProcess(that.subProcessNode, {x: node.getRect().x, y: node.getRect().y});
	               this._triggerAsync('beforeAddNode', {target: _subProcess}, node).then(function (res) {
	                   if (res) {
	                       that.addNodeToShape(node, isFromDrag, isNoCount, _subProcess);
	                   }
	               });
	           }
	       };
	
	       fishTopoProto.addNodeToShape = function (node, isFromDrag, isNoCount, _subProcess) {
	           var that = this;
	           var mesArray;
	           if (that.subProcessNode.length == 0) {
	               that._zr.add(node);
	               mesArray = {
	                   id: node.id,
	                   position: [node.getRect().x, node.getRect().y],
	                   width: node.getRect().width,
	                   height: node.getRect().height
	               };
	               if (!Bpmn.isSlotEvent(node)) {
	                   that.overlapArray.push(mesArray);
	               }
	           } else {
	               that._zr.add(node);
	               mesArray = {
	                   id: node.id,
	                   position: [node.getRect().x, node.getRect().y],
	                   width: node.getRect().width,
	                   height: node.getRect().height
	               };
	               if (!Bpmn.isSlotEvent(node)) {
	                   that.overlapArray.push(mesArray);
	               }
	               if (isFromDrag) {
	                   var offsetX = 0, offsetY = 0;
	                   if (_subProcess) {
	                       if (_subProcess.parent && Bpmn.isSubProcess(_subProcess.parent)) {
	                           offsetX = BpmnUtil.parentX(_subProcess.parent);
	                           offsetY = BpmnUtil.parentY(_subProcess.parent);
	                       }
	                       var groupNodePositionX = _subProcess.getRect().width / 2 + (node.getRect().x - (_subProcess.getRect().x + offsetX));
	                       var groupNodePositionY = _subProcess.getRect().height / 2 + (node.getRect().y - (_subProcess.getRect().y + offsetY));
	                       node.setPosition(groupNodePositionX, groupNodePositionY);
	                       _subProcess.add(node);
	                       that._zr.remove(node);
	                       for (var j = 0; j < that.overlapArray.length; j++) {
	                           if (node.id == that.overlapArray[j].id) {
	                               that.overlapArray.splice(j, 1);
	                           }
	                       }
	                   }
	               }
	           }
	           //2.如果是子节点 则加入到子节点数组中
	           if (Bpmn.isSubProcess(node)) {
	               that.subProcessNode.push(node);
	           }
	           that.allNodes.push(node);
	           //放入节点位置信息 用于拖拽
	           mesArray.position = [node.getRect().x, node.getRect().y];
	           that.domArray.push(mesArray);
	
	           //侦听节点的事件 并把事件给取消掉 防止 如果父是子节点侦听到
	           node.on('mousedown', function(e) {
	               if (!(that.forbidEdit == true ||
	                   (this.parent && this.parent.type === "dragSelect") ||
	                   (that.mouseMode === "drag-select" && Bpmn.isSubProcess(this)))) {
	                   that.newDrag(this, e.event.clientX, e.event.clientY);
	               }
	               //如果选择的是事件节点，则为其他task绑定插槽
	               if (Bpmn.isSlotEvent(this)) {
	                   that.bindEventNode();
	               }
	               if (that.mouseMode !== "drag-select") {
	                   e.cancelBubble = true;
	               }
	           });
	           node.on('click', function(e) {
	               that.nodeClickHandler(this);
	               that._trigger('selectNode', {target: node});
	               e.cancelBubble = true;
	           });
	           //添加tip
	           if (Bpmn.isActivity(node)) {
	               that.creatTip(node);
	           }
	           node.on("mouseover", function() {
	               if (this.alarm && this.alarm.isShow == true) {
	
	                   this.alarm.show();
	                   this.alarm.eachChild(function(child) {
	                       child.show();
	                   });
	                   //根据字内容更改tip外框的大小
	                   var text = this.alarm.childOfName("Text");
	                   var groupWidth = text.getBoundingRect().width + 4;
	                   var groupHeight = text.getBoundingRect().height + 8;
	                   var points = [
	                       [0, 0],
	                       [groupWidth, 0],
	                       [groupWidth, groupHeight],
	                       [groupWidth / 2 - 3, groupHeight],
	                       [groupWidth / 2, groupHeight + 3],
	                       [groupWidth / 2 + 3, groupHeight],
	                       [0, groupHeight],
	                       [0, 0]
	                   ];
	                   var Polyline = this.alarm.childOfName("Polyline");
	                   Polyline.attr("shape", {points: points});
	                   var groupPosition = [BpmnUtil.parentX(node) + node.getBoundingRect().width - this.alarm.getBoundingRect().width / 2, BpmnUtil.parentY(node) - this.alarm.getBoundingRect().height - 3];
	                   this.alarm.attr("position", groupPosition);
	               }
	           });
	           node.on("mouseout", function() {
	               if (this.alarm) {
	                   this.alarm.hide();
	                   this.alarm.eachChild(function(child) {
	                       child.hide();
	                   });
	               }
	           });
	           if (isNoCount != true) {
	               that.stepCounter();
	           }
	           that._trigger('afterCreateNode', {target: node});
	       }
	
	       /**
	        * 选中场景中的某个节点,并且触发selectNode事件
	        * @param {Object} node 待选中的节点对象
	        * @since V2.3.0
	        *  **使用范例：**
	        * @example
	        * fishTopo.selectNode(node);
	        */
	
	       fishTopoProto.selectNode = function(node) {
	           if (node) {
	               this.nodeClickHandler(node);
	               this._trigger('selectNode', {target: node});
	           }
	       };
	
	       /**
	        * 根据name获取节点
	        * @param  {String} name 在创建节点中  name属性设置的值
	        * @return {Object}      name对应的节点
	        */
	       fishTopoProto.childOfName = function(name) {
	           var arrResult = [];
	           for (var i = 0; i < this.allNodes.length; i++) {
	               if (this.allNodes[i].model.get("properties.name") == name) {
	                   arrResult.push(this.allNodes[i]);
	               }
	           }
	           if (arrResult.length > 1) {
	               return arrResult;
	           } else {
	               return arrResult[0];
	           }
	       };
	
	       /**
	        * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(e){ return e.position[0] > 100; });
	        * @param  {Function} cb      回调函数
	        * @param  {Object}   context 回调函数执行的上下文
	        * @return {Array}           返回查找到的对象
	        */
	       fishTopoProto.findElements = function(cb, context) {
	           var childrenNode = this.allNodes;
	           var childrenLine = this.connectionManager.connectors;
	           var arr = [];
	           for (var i = 0; i < childrenNode.length; i++) {
	               var child = childrenNode[i];
	               if (cb.call(context, child, i)) {
	                   arr.push(child);
	               }
	           }
	           for (var j = 0; j < childrenLine.length; j++) {
	               var childLine = childrenLine[j];
	               if (cb.call(context, childLine, j)) {
	                   arr.push(childLine);
	               }
	           }
	           return arr;
	       };
	
	       /**
	        * @private
	        * 根据模型增加线
	        */
	       fishTopoProto.addConnectorByModel = function(model, parentZr) {
	           //找出 startNode 与 endNode
	           var startNode = null,
	               endNode = null;
	           zrUtil.each(this.allNodes, function(node) {
	               //startNode: 从allNode中找出outgoing为 线的id的起始节点
	               var nodeOutgoing = node.model.get("outgoing");
	               if (nodeOutgoing.indexOf(model.get("resourceId")) !== -1) {
	                   startNode = node;
	               }
	               //endNode : 从allNode中找出 id 为线的outgoing的结束节点
	               var connectorOutgoing = model.get("outgoing");
	               if (connectorOutgoing.indexOf(node.resourceId) !== -1) {
	                   endNode = node;
	               }
	           });
	           if (startNode && endNode) {
	               var connector = this.connectionManager.connectorCreateByOptions(startNode, endNode, {model: model,isFromModel:true}, this._api);
	               if (parentZr) {
	                   parentZr.add(connector);
	               } else {
	
	                   this._zr.add(connector);
	               }
	               this.connectionManager.connectorForbidEdit(this.forbidEdit);
	               this._createConnectorDragEvents(connector);
	               connector.on("mousedown", function(e) {
	                   this.lineOperationManager.isEdit = !this.forbidEdit;
	                   // 取消节点的选中
	                   this.hideConnectorPoint();
	                   this.hideConnectorControl();
	                   this._removeOperationNode();
	                   this.isNode = false;
	               }.bind(this));
	           }
	
	       };
	
	       /**
	        * 创建连线的小图标操作
	        * @param {string} key 小图标的名称
	        * @param {Object} options 小图标选项
	        * @param {String} [options.icon] 小图标路径
	        * @param {Object} [options.lineNode] 线段实例
	        * @param {Function} [options.callback] 点击后的回调
	        *
	        * **使用范例**：
	        *
	        *      @example
	        *      fishTopoBpmn.addIcon("icon1",{  //线上图标的名称
	        *                    icon:"bpmn2.0/icons/activity/list/mail.send.png", //线上图标的路径
	        *                     lineNode:lineNode,  //线
	        *                     callback:function(lineNode){  //回调
	        *                          alert(JSON.stringify(lineNode))
	        *                      },
	        *                  });*
	        */
	       fishTopoProto.addIcon = function(key, options) {
	           this.lineOperationManager.addIcon(key, options);
	       };
	
	       /**
	        * 创建连线的默认删除操作
	        * @param  {Object} lineNode 线
	        *
	        *  **使用范例**：
	        *
	        *      @example
	        *      fishTopoBpmn.bindLineDelete(lineNode);
	        */
	       fishTopoProto.bindLineDelete = function(lineNode,options) {
	           //创建删除
	           this.lineOperationManager.addDeleteIcon(lineNode,options);
	       };
	       /**
	        * @private
	        * 返回 连向该节点的节点数组：nodeArray[0]  以及该节点连向的节点数组 nodeArray[0]
	        */
	       fishTopoProto.checkLineNode = function(node) {
	           var startArray = [],
	               endArray = [];
	           var lineArray = this.connectionManager.connectors;
	           for (var i = 0, len = lineArray.length; i < len; i++) {
	               if (lineArray[i].startNode == node) {
	                   endArray.push(lineArray[i].endNode);
	               }
	           }
	           for (var j = 0, lenEnd = lineArray.length; j < lenEnd; j++) {
	               if (lineArray[j].endNode == node) {
	                   startArray.push(lineArray[j].startNode);
	               }
	           }
	           return [startArray, endArray];
	       };
	
	       /**
	        * @private
	        * 计算在subprocess内的节点的真实位置
	        */
	       fishTopoProto.calculateNodeRectInGroup = function(node) {
	           var rect = util.getRect(node);
	           if (node.parent && Bpmn.isSubProcess(node.parent)) {
	               rect.boundingRect.x += BpmnUtil.parentX(node.parent);
	               rect.boundingRect.y += BpmnUtil.parentY(node.parent);
	               rect.x += BpmnUtil.parentX(node.parent);
	               rect.y += BpmnUtil.parentY(node.parent);
	           }
	           return {
	               rect: rect,
	               parentNode: BpmnUtil.getParentNode(node)
	           }
	       }
	
	       /**
	        * @private
	        * 依次从节点递归至最外层的subprocess，计算节点最终的包围盒
	        */
	       fishTopoProto.calculateRect = function(node, nodeRect) {
	           if (!nodeRect) {
	               nodeRect = this.calculateNodeRectInGroup(node).rect;
	           }
	           if (!nodeRect.rotation) {
	               nodeRect.rotation = node.rotation;
	           } else {
	               nodeRect.rotation += node.rotation;
	           }
	           // 如果父节点旋转了，需要更新子节点的中心点
	           if (node.parent && Bpmn.isSubProcess(node.parent)) {
	               var rotation = node.parent.rotation;
	               if (Math.abs(rotation) > 0) {
	                   var center = this.calculateNodeRectInGroup(node.parent).rect;
	                   var point = {
	                       x: nodeRect.x,
	                       y: nodeRect.y
	                   }
	                   var nPoint = util.calculatePoints(point, center, rotation);
	                   nodeRect.x = nPoint.x;
	                   nodeRect.y = nPoint.y;
	                   nodeRect.boundingRect.x = nodeRect.x - nodeRect.width / 2;
	                   nodeRect.boundingRect.y = nodeRect.y - nodeRect.height / 2;
	               }
	               return this.calculateRect(node.parent, nodeRect);
	           } else {
	               return nodeRect;
	           }
	       }
	
	       fishTopoProto.createConnectorPoint = function(point, pos, lineType) {
	           var me = this;
	           var pointInstance = new graphic.Circle({
	               shape: {
	                   cx: point.x,
	                   cy: point.y,
	                   r: 4
	               },
	               style: {
	                   fill: '#FFFF33',
	                   stroke:'#000000'
	               },
	               z : 2,
	               cursor: 'crosshair',
	               draggable: true,
	               lineType: lineType
	           });
	           pointInstance.type = 'ConnectPoint';
	           pointInstance.pos = pos;                //记录是节点上哪个位置的连接点
	           var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	           zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	               pointInstance.on(eveName, function(e) {
	                   var params = {};
	                   params.event = e;
	                   params.type = "ConnectPoint:" + eveName;
	                   me.conPointsGroup.trigger(params.type, params);
	               });
	           });
	           this.conPointsGroup.add(pointInstance);
	       }
	
	       fishTopoProto.hideConnectorPoint = function() {
	           this.conPointsGroup.removeAll();  //隐藏所有节点上的连接点
	           this.conPointsGroup.off();        //清空所有事件
	           this._zr.remove(this.conPointsGroup);
	       }
	
	       fishTopoProto.filterConnectPoint = function(targetNodes, lineType) {
	           var that = this;
	           var nodes = targetNodes;
	           nodes.forEach(function(item) {
	               var calculateRect = that.calculateRect(item);
	               var connectorPoint = util.getConnectorPoints(calculateRect, { rotation: calculateRect.rotation });
	               that.createConnectorPoint(connectorPoint.left, "left", lineType);
	               that.createConnectorPoint(connectorPoint.right, "right", lineType);
	               that.createConnectorPoint(connectorPoint.top, "top", lineType);
	               that.createConnectorPoint(connectorPoint.bottom, "bottom", lineType);
	           });
	       }
	
	       fishTopoProto.showConnectorPoint = function(lineType, lineOpt, ifCurrentNode) {
	           var that = this;
	           this.hideConnectorPoint();
	           if (lineOpt) {
	               this.lineOpt = lineOpt;  //缓存线段的配置信息
	           }
	           if (lineType) {
	               this.lineType = lineType; // 缓存线段类型
	           }
	           if (!this.lineType) {
	               this.lineType = 'jagged'; // 线段默认折线类型
	           }
	           if (!ifCurrentNode) {
	               ifCurrentNode = false;
	           }
	           var targetNodes = ifCurrentNode ? [that.selectedNode] : that.allNodes;
	           // 让所有画布中的节点/当前节点显示连接点
	           this.filterConnectPoint(targetNodes, this.lineType);
	
	           function findConnectorNode(x, y, offset, pos) {
	               var node, endPos = null;
	               that.allNodes.forEach(function(item) {
	                   var calculateRect = that.calculateRect(item);
	                   var connectorPoint = util.getConnectorPoints(calculateRect, { rotation: calculateRect.rotation });
	                   if (pos) {
	                       if (Math.abs(connectorPoint[pos].x - x) <= offset && Math.abs(connectorPoint[pos].y - y) <= offset) {
	                           node = item;
	                       }
	                   } else {
	                       if (Math.abs(connectorPoint["left"].x - x) <= offset && Math.abs(connectorPoint["left"].y - y) <= offset) {
	                           endPos = "left";
	                           node = item;
	                       } else if (Math.abs(connectorPoint["top"].x - x) <= offset && Math.abs(connectorPoint["top"].y - y) <= offset) {
	                           endPos = "top";
	                           node = item;
	                       } else if (Math.abs(connectorPoint["right"].x - x) <= offset && Math.abs(connectorPoint["right"].y - y) <= offset) {
	                           endPos = "right";
	                           node = item;
	                       } else if (Math.abs(connectorPoint["bottom"].x - x) <= offset && Math.abs(connectorPoint["bottom"].y - y) <= offset) {
	                           endPos = "bottom";
	                           node = item;
	                       }
	                   }
	               });
	               return {
	                   node: node,
	                   endPos: endPos
	               };
	           }
	           this.conPointsGroup.on("ConnectPoint:dragstart", function(e) {
	               // 如果是当前节点显示连接点，需要在拖动剪头时让画布中的其他节点显示连接点
	               if (ifCurrentNode) {
	                   that.filterConnectPoint(that.allNodes, that.lineType);
	               }
	               var x = e.event.offsetX;
	               var y = e.event.offsetY;
	               var arrow = e.event.target;
	               that.startPos = arrow.pos;
	               that.selectConnNode = findConnectorNode(arrow.shape.cx, arrow.shape.cy, 0, that.startPos).node;
	               arrow.hide();
	               that.lineOperationManager.hideAllLineOperation();
	               that.reverseConnect = false;   //是否反向连线的标识
	               that.originNode = null;
	               var point = new Point(x, y);
	               var connector = that.connectionManager.manageTempConnector(that.selectConnNode, point, arrow.lineType, that.startPos);
	               that._zr.add(connector);
	           });
	           this.conPointsGroup.on("ConnectPoint:drag", function(e) {
	               var arrow = e.event.target;
	               that._handleLineDrag('drag', e, arrow.lineType);
	           });
	           this.conPointsGroup.on("ConnectPoint:dragend", function(e) {
	               var arrow = e.event.target;
	               that._handleLineDrag('dragend', e, arrow.lineType);
	           });
	           this._zr.add(this.conPointsGroup);
	       }
	
	       /**
	        * 处理连线和连接点drag事件
	        * @method _handleLineDrag
	        * @param  {String} dragType drag类型
	        * @param  {Object} e   event事件对象
	        * @param  {String} lineType 连线类型
	        */
	       fishTopoProto._handleLineDrag = function(dragType, e, lineType) {
	            var that = this;
	            var x = e.event.offsetX;
	            var y = e.event.offsetY;
	            function findConnectorNode(x, y, offset, pos) {
	                var node, endPos = null;
	                that.allNodes.forEach(function(item) {
	                    var calculateRect = that.calculateRect(item);
	                    var connectorPoint = util.getConnectorPoints(calculateRect, { rotation: calculateRect.rotation });
	                    if (pos) {
	                        if (Math.abs(connectorPoint[pos].x - x) <= offset && Math.abs(connectorPoint[pos].y - y) <= offset) {
	                            node = item;
	                        }
	                    } else {
	                        if (Math.abs(connectorPoint["left"].x - x) <= offset && Math.abs(connectorPoint["left"].y - y) <= offset) {
	                            endPos = "left";
	                            node = item;
	                        } else if (Math.abs(connectorPoint["top"].x - x) <= offset && Math.abs(connectorPoint["top"].y - y) <= offset) {
	                            endPos = "top";
	                            node = item;
	                        } else if (Math.abs(connectorPoint["right"].x - x) <= offset && Math.abs(connectorPoint["right"].y - y) <= offset) {
	                            endPos = "right";
	                            node = item;
	                        } else if (Math.abs(connectorPoint["bottom"].x - x) <= offset && Math.abs(connectorPoint["bottom"].y - y) <= offset) {
	                            endPos = "bottom";
	                            node = item;
	                        }
	                    }
	                });
	                return {
	                    node: node,
	                    endPos: endPos
	                };
	            }
	            var point = new Point(x, y);
	            if (dragType === 'drag') {
	            if (that.reverseConnect) {
	                that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, lineType, that.endPos);
	            } else {
	                that.connectionManager.manageTempConnector(that.selectConnNode, point, lineType, that.startPos);
	            }
	            that.conPointsGroup.children().forEach(function (v) {
	                v.attr({style:{fill: "#FFFF33"},scale:[1,1],origin:[v.shape.cx,v.shape.cy],cursor:'crosshair'});
	                if (Math.abs(v.shape.cx - x) <= 10 && Math.abs(v.shape.cy - y) <= 10) {
	                    var res = findConnectorNode(x, y, 10);
	                    if (that.reverseConnect) {
	                        that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, lineType, that.endPos, res.endPos, res.node);
	                    } else {
	                        that.connectionManager.manageTempConnector(that.selectConnNode, point, lineType, that.startPos, res.endPos, res.node);
	                    }
	                    v.attr({style:{fill: "#ff0000"},scale:[1.5,1.5],origin:[v.shape.cx,v.shape.cy],cursor:'pointer'});
	                }
	            })
	            }
	            if (dragType === 'dragend') {
	            var res = findConnectorNode(x, y, 10);
	            var targetNode = res.node;
	            var start;
	            var end;
	            var endPos = res.endPos || 'left';
	            var startPos;
	            var canConnect = false;       //两个节点是否可以连线的标识
	            //删除临时线
	            that.connectionManager.removeTempConnector(that._zr);
	            if (that.selectConnNode.parent && Bpmn.isSubProcess(that.selectConnNode.parent)) {
	                if (targetNode && Bpmn.isSlotEvent(that.selectConnNode)) {
	                    // 当前节点是边界节点可连线
	                    canConnect = true;
	                }
	                if (targetNode && targetNode.parent && Bpmn.isSubProcess(targetNode.parent) && targetNode.parent.id === that.selectConnNode.parent.id) {
	                    // 起始节点都在同一个子节点内则可以连线
	                    canConnect = true;
	                }
	            } else {
	                if (targetNode && !targetNode.parent) {
	                    canConnect = true;
	                }
	                if (targetNode && targetNode.parent && Bpmn.isSubProcess(targetNode.parent) && Bpmn.isSlotEvent(targetNode)) {
	                    // 目标节点是边界节点可连线
	                    canConnect = true;
	                }
	            }
	            //2.如果找到目标结点 则画线
	            if (canConnect && (that.selectConnNode.id !== targetNode.id)) {
	                var connectOptions = {
	                    style: {
	                        lineType: lineType
	                    }
	                }
	                var finalOpt = util.mergeOpt(connectOptions, that.lineOpt, true);
	                start = that.reverseConnect ? targetNode : that.selectConnNode;
	                end = that.reverseConnect ? that.selectConnNode : targetNode;
	                startPos = that.reverseConnect ? endPos : that.startPos;
	                endPos = that.reverseConnect ? that.endPos : endPos;
	                that._createConnectorByNodes(start, end, finalOpt, startPos, endPos);
	                that.hideConnectorPoint();      //隐藏所有节点上的连接点
	                that.hideConnectorControl();      //隐藏所有节点上的控制点
	            } else {
	                if (that.originNode) {
	                    //如果连线失败，且原始线段存在，则还原原始线段
	                    start = that.reverseConnect ? that.originNode : that.selectConnNode;
	                    end = that.reverseConnect ? that.selectConnNode : that.originNode;
	                    startPos = that.reverseConnect ? that.originPos : that.startPos;
	                    endPos = that.reverseConnect ? that.endPos : that.originPos;
	                    that._createConnectorByNodes(start, end, { style: that.lineOpt }, startPos, endPos);
	                    that.hideConnectorPoint();      //隐藏所有节点上的连接点
	                } else {
	                    //还原所有连接点的颜色
	                    that.conPointsGroup.children().forEach(function (v) {
	                        v.attr({style:{fill: "#FFFF33"},scale:[1,1],origin:[v.shape.cx,v.shape.cy],cursor:'crosshair'});
	                    });
	                }
	            }
	            }
	        }
	
	       fishTopoProto.showConnectorControl = function() {
	            var that = this;
	            var pixel = that.opts.gridLineSpacing;
	            this.hideConnectorControl();
	            // 让当前节点显示控制点
	            var calculateRect = this.calculateRect(this.selectedNode);
	            var node = {
	                id: this.selectedNode.id,
	                rotation: calculateRect.rotation
	            }
	            var connectorPoint = util.getConnectorControls(calculateRect, node);
	            var params = this.returnConnectorControlParam(this.selectedNode);
	            if (params.scaleable) {
	                that.createConnectorControl(connectorPoint.tl, "tl", node);
	                that.createConnectorControl(connectorPoint.tr, "tr", node);
	                that.createConnectorControl(connectorPoint.bl, "bl", node);
	                that.createConnectorControl(connectorPoint.br, "br", node);
	            }
	            if (params.rotatable) {
	                that.createConnectorControl(connectorPoint.mtr, "mtr", node);
	                that.createConnectorControl({ top: connectorPoint.mtr, bottom: connectorPoint.tc }, "mtr,tc", node);
	            }
	
	            function findControlNode (id) {
	                var node = null;
	                that.allNodes.forEach(function(item) {
	                    if (item.id === id) {
	                            node = item;
	                    }
	                });
	                return node;
	            }
	
	            this.conControlsGroup.on("ConnectControl:dragstart", function(e) {
	                // 首先清除其他所有节点的控制点和连接点
	                var cursor = e.event.target.cursor;
	                var pos = e.event.target.pos;
	                var posMap = {
	                    'tl': 'br',
	                    'tr': 'bl',
	                    'bl': 'tr',
	                    'br': 'tl'
	                };
	                that.selectConnNode = findControlNode(e.nodeId);
	                if (cursor && pos !== 'mtr') {
	                    var originNode = that.conControlsGroup.children().find(function (node) {
	                        return node.pos === posMap[pos];
	                    });
	                    var currentNode = that.conControlsGroup.children().find(function (node) {
	                        return node.pos === pos;
	                    });
	                    var boundingRect = that.selectConnNode.getBoundingRect();
	                    that.oppositeShape = zrUtil.clone(originNode.shape);
	                    that.currentShape = zrUtil.clone(currentNode.shape);
	                    var rect = zrUtil.clone(that.calculateRect(that.selectConnNode));
	                    var diagonal = Math.sqrt(Math.pow(rect.width, 2) + Math.pow(rect.height, 2));// 对角线长度
	                    that.diagonal = diagonal;
	                    that.originRect = zrUtil.clone(rect);
	                    that.ifPointCenter = boundingRect.x < -1; // 判断中心点是否在节点中心(原形在中心，矩形在左上角)
	                    // 移除node高亮
	                    that.selectConnNode.selectStyle && that._api.getZr().removeHover(that.selectConnNode);
	                }
	            });
	            this.conControlsGroup.on("ConnectControl:drag", function(e) {
	                var cursor = e.event.target.cursor;
	                var targetPos = e.event.target.pos;
	                var currentNode = that.selectConnNode;
	                var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;
	                var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;
	                var rectOrigin = util.getRect(currentNode, true);
	                if (targetPos === 'mtr') {
	                    if (currentNode.parent && Bpmn.isSubProcess(currentNode.parent)) {
	                        x -= BpmnUtil.parentX(currentNode.parent);
	                        y -= BpmnUtil.parentY(currentNode.parent);
	                    }
	                    // 旋转
	                    var m = parseInt(((x -currentNode.position[0]) / pixel), 10);
	                    var n = parseInt(((y -currentNode.position[1]) / pixel), 10);
	                    var r_x = pixel * m;
	                    var r_y = pixel * n;
	                    var origins = {
	                        x: rectOrigin.x - currentNode.position[0],
	                        y: rectOrigin.y - currentNode.position[1]
	                    }
	                    var rotation = Math.atan2(r_y, r_x);
	                    that.selectedNode.attr({
	                        'origin': [origins.x, origins.y],
	                        'rotation': -rotation
	                    });
	                    var calculateRect = that.calculateRect(that.selectedNode);
	                    var connectorPoint = util.getConnectorPoints(calculateRect, { rotation: calculateRect.rotation });
	                    var controlPoint = util.getConnectorControls(calculateRect, { rotation: calculateRect.rotation });
	                    // 节点连线点，控制点位置更新
	                    that.conPointsGroup.children().forEach(function (item) {
	                        var pos = item.pos;
	                        if (item.type === 'ConnectPoint') {
	                            item.setShape({ cx: connectorPoint[pos].x, cy: connectorPoint[pos].y });
	                        }
	                    });
	                    that.conControlsGroup.children().forEach(function (item) {
	                        var pos = item.pos;
	                        if (item.type === 'ConnectControl') {
	                            if (pos === 'mtr') {
	                                item.attr('position', [0, 0]);
	                                item.attr('rotation', 0);
	                            }
	                            item.setShape({ x: controlPoint[pos].x - 4, y: controlPoint[pos].y - 4 });
	                            item.attr({
	                                'origin': [item.shape.x + 4, item.shape.y + 4],
	                                'rotation': -rotation
	                            });
	                        } else if (item.type === 'ConnectControlLine') {
	                            item.setShape({ x1: controlPoint.mtr.x, x2: controlPoint.tc.x, y1: controlPoint.mtr.y, y2: controlPoint.tc.y });
	                        }
	                    });
	                } else {
	                    // 缩放(缩放点需要结合旋转角度计算)
	                    var ratio = 1,
	                        center = [],
	                        centerPoint = {},
	                        width0, height0;
	                    var cursorsY = ['n-resize', 's-resize'];
	                    var positionOrg = {
	                        'tl': 'br',
	                        'tr': 'bl',
	                        'bl': 'tr',
	                        'br': 'tl'
	                    }
	
	                    var scaleNodes = that.conControlsGroup.children().filter(function (node) {
	                        return node.type === 'ConnectControl' && node.pos !== 'mtr'
	                    });
	                    var currentControlNode = scaleNodes.find(function(node) {
	                        return node.pos === targetPos;
	                    });
	
	                    if (x <= 8) {
	                        x = 8;
	                    }
	                    if (y <= 8) {
	                        y = 8;
	                    }
	
	                    if (cursorsY.includes(cursor)) {
	                        // 获取y轴比例即可
	                        var startY = currentControlNode.shape.y + 4;
	                        ratio = Math.abs(parseInt(((y - that.oppositeShape.y - 4) / pixel), 10)) / Math.abs(parseInt(((startY - that.oppositeShape.y) / pixel), 10));
	                    } else {
	                        // 获取x轴比例即可
	                        var startX = currentControlNode.shape.x + 4;
	                        ratio = Math.abs(parseInt(((x - that.oppositeShape.x - 4) / pixel), 10)) / Math.abs(parseInt(((startX - that.oppositeShape.x) / pixel), 10));
	                    }
	                    if (!/^[0-9]+.?[0-9]*/.test(ratio)) {
	                        ratio = 1;
	                    }
	                    currentNode.updateShape(ratio);
	
	                    var rectScale = util.getRect(currentNode);
	                    centerPoint = that.ifPointCenter ? { x: that.originRect.x, y: that.originRect.y } : { x: that.originRect.boundingRect.x, y: that.originRect.boundingRect.y };
	                    var diagonalNew = Math.sqrt(Math.pow(rectScale.width, 2) + Math.pow(rectScale.height, 2));// 对角线长度
	                    switch (cursor) {
	                        // 上,左上
	                        case 'n-resize':
	                        case 'nw-resize':
	                            width0 = (that.oppositeShape.x + 4 - centerPoint.x) * diagonalNew / that.diagonal;
	                            height0 = (that.oppositeShape.y + 4 - centerPoint.y) * diagonalNew / that.diagonal;
	                            center.push(that.oppositeShape.x - width0 + 4, that.oppositeShape.y - height0 + 4);
	                            break;
	                        // 右,右上
	                        case 'e-resize':
	                        case 'ne-resize':
	                            width0 = (centerPoint.x - that.oppositeShape.x - 4) * diagonalNew / that.diagonal;
	                            height0 = (that.oppositeShape.y + 4 - centerPoint.y) * diagonalNew / that.diagonal;
	                            center.push(that.oppositeShape.x + width0 + 4, that.oppositeShape.y - height0 + 4);
	                            break;
	                        // 下，右下
	                        case 's-resize':
	                        case 'se-resize':
	                            width0 = (centerPoint.x - that.oppositeShape.x - 4) * diagonalNew / that.diagonal;
	                            height0 = (centerPoint.y - that.oppositeShape.y - 4) * diagonalNew / that.diagonal;
	                            center.push(that.oppositeShape.x + width0 + 4, that.oppositeShape.y + height0 + 4);
	                            break;
	                        // 左,左下
	                        case 'w-resize':
	                        case 'sw-resize':
	                            width0 = (that.oppositeShape.x + 4 - centerPoint.x) * diagonalNew / that.diagonal;
	                            height0 = (centerPoint.y - that.oppositeShape.y - 4) * diagonalNew / that.diagonal;
	                            center.push(that.oppositeShape.x - width0 + 4, that.oppositeShape.y + height0 + 4);
	                            break;
	                        default:
	                            break;
	                    }
	
	                    if (currentNode.parent && Bpmn.isSubProcess(currentNode.parent)) {
	                        var parentRect = that.calculateRect(currentNode.parent);
	                        var newPosition = util.calculatePoints(center, parentRect, -parentRect.rotation);
	                        center = [newPosition[0] - parentRect.boundingRect.x, newPosition[1] - parentRect.boundingRect.y];
	                    }
	
	                    var originScale = {
	                        x: rectScale.x - center[0],
	                        y: rectScale.y - center[1]
	                    }
	                    currentNode.attr({
	                        'position': center,
	                        'origin': [originScale.x, originScale.y]
	                    });
	
	                    // 此时节点包围盒需要重新计算
	                    var rectNow = that.calculateRect(currentNode);
	                    var connectorPointScale = util.getConnectorPoints(rectNow, { rotation: rectNow.rotation });
	                    var controlPointScale = util.getConnectorControls(rectNow, { rotation: rectNow.rotation });
	                    that.conControlsGroup.children().forEach(function(item) {
	                        var pos = item.pos;
	                        if (pos === targetPos) {
	                            item.attr('position', [0, 0]);
	                        }
	                        if (item.type === 'ConnectControl' && pos !== positionOrg[targetPos]) {
	                            item.setShape({ x: controlPointScale[pos].x - 4, y: controlPointScale[pos].y - 4 });
	                            item.attr('origin', [controlPointScale[pos].x, controlPointScale[pos].y]);
	                        } else if (item.type === 'ConnectControlLine') {
	                            item.setShape({ x1: controlPointScale.mtr.x, x2: controlPointScale.tc.x, y1: controlPointScale.mtr.y, y2: controlPointScale.tc.y });
	
	                        }
	                    });
	                    that.conPointsGroup.children().forEach(function(item) {
	                        var pos = item.pos;
	                        if (item.type === 'ConnectPoint') {
	                            item.setShape({ cx: connectorPointScale[pos].x, cy: connectorPointScale[pos].y });
	                        }
	                    });
	                }
	                that.operationNode.refreshPostion(that.selectedNode, that.calculateRect(that.selectedNode));
	                if (that.selectedNode.slotEvent && that.selectedNode.slotEvent.length > 0) {
	                    // 更新事件节点
	                    that.updateSlotEvent(that.selectedNode);
	                }
	                // 1.5 刷新连线
	                that.connectionManager.refreshLineByNode(that.selectedNode);
	            });
	            this.conControlsGroup.on("ConnectControl:dragend", function(e) {
	                // 更新节点position
	                var targetPos = e.event.target.pos;
	                var node = that.selectConnNode;
	                var pixel = that.opts.gridLineSpacing;
	                var position = node.position;
	                var origin = node.origin;
	                // position origin取整
	                that.selectConnNode.attr('position', [parseInt(position[0], 10), parseInt(position[1], 10)]);
	                if (Array.isArray(origin)) {
	                    that.selectConnNode.attr('origin', [parseInt(origin[0], 10), parseInt(origin[1], 10)]);
	                }
	                if (targetPos !== 'mtr') {
	                    node.updateShape(1, true, pixel);
	                }
	                if (node.slotEvent && node.slotEvent.length > 0) {
	                    // 更新事件节点
	                    that.updateSlotEvent(node);
	                }
	                if (node.model) {
	                    // 更新model，支持序列化/反序列化
	                    node.model.set("options.rotation", node.rotation);
	                    node.model.set("options.origin", node.origin);
	                    var elementType = node.model.option.elementType;
	                    if (elementType === 'Image') {
	                        node.model.set("options.style", node.style);
	                    } else {
	                        node.model.set("options.shape", node.shape);
	                    }
	                }
	                // 1.4 触发点击
	                that.nodeClickHandler(node);
	                that.stepCounter();
	                that.oppositeShape = null;
	                that.currentShape = null;
	                that.diagonal = null;
	                that.originRect = null;
	                that.ifPointCenter = null;
	            });
	            this._zr.add(this.conControlsGroup);
	        }
	
	       fishTopoProto.getRotatedCornerCursor = function(node, pos) {
	           var that = this;
	           var rotation = node.rotation;
	           if (pos === 'mtr') {
	               return that.cursorMap[pos];
	           }
	           if (Math.abs(rotation) > 0) {
	               var angle = -rotation / (Math.PI/180);
	               var n = Math.round((angle % 360) / 45);
	               if (n < 0) {
	                   n += 8; // full circle ahead
	               }
	               n += that.cursorOffset[pos];
	               n %= 8;
	               return that.cursorMaps[n];
	           }
	           return that.cursorMap[pos];
	       }
	
	       fishTopoProto.createConnectorControl = function(point, pos, node) {
	           var me = this;
	           var posArr = pos.split(',');
	           if (posArr.length < 2) {
	               var controlCursor = me.getRotatedCornerCursor(node, pos);
	               var pointInstance = new graphic.Rect({
	                   shape:{
	                       x: point.x - 4,
	                       y: point.y - 4,
	                       width: 8,
	                       height: 8
	                   },
	                   style: {
	                       fill: '#ffffff',
	                       stroke:'#000000'
	                   },
	                   z: 2,
	                   rotation: node.rotation,
	                   origin: [point.x, point.y],
	                   cursor: controlCursor,
	                   draggable: true
	               });
	               pointInstance.type = 'ConnectControl';
	               pointInstance.pos = pos;// 记录是节点上哪个位置的连接点
	               var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	               zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	                   pointInstance.on(eveName, function(e) {
	                       var params = {};
	                       params.event = e;
	                       params.type = "ConnectControl:" + eveName;
	                       params.nodeId = node.id;
	                       params.cursor = controlCursor;
	                       me.conControlsGroup.trigger(params.type, params);
	                   });
	               });
	               this.conControlsGroup.add(pointInstance);
	           } else {
	               // 旋转点与节点之间需要连线
	               var line = new graphic.Line({
	                   shape: {
	                       x1: point.top.x,
	                       y1: point.top.y,
	                       x2: point.bottom.x,
	                       y2: point.bottom.y
	                   },
	                   style: {
	                       lineWidth: 1
	                   },
	                   z: 1,
	                   draggable: false,
	                   cursor: 'default'
	               });
	               line.type = 'ConnectControlLine';
	               line.nodeId = node.id;
	               this.conControlsGroup.add(line);
	           }
	       }
	
	       fishTopoProto.returnConnectorControlParam = function(node) {
	           var scaleFlag = false;
	           var rotateFlag = false;
	           if (this.opts.scaleable) {
	               scaleFlag = true;
	           }
	           if (node.model.get("properties.scaleable")) {
	               scaleFlag = true;
	           } else {
	               scaleFlag = false;
	           }
	           if (node.scaleable) {
	               scaleFlag = true;
	           } else if (!node.scaleable && !node.model.get("properties.scaleable")) {
	               scaleFlag = false;
	           }
	
	           if (this.opts.rotatable) {
	               rotateFlag = true;
	           }
	           if (node.model.get("properties.rotatable")) {
	               rotateFlag = true;
	           } else {
	               rotateFlag = false;
	           }
	           if (node.rotatable) {
	               rotateFlag = true;
	           } else if (!node.rotatable && !node.model.get("properties.rotatable")) {
	               rotateFlag = false;
	           }
	           return {
	               scaleable: scaleFlag,
	               rotatable: rotateFlag
	           }
	       }
	
	       fishTopoProto.hideConnectorControl = function() {
	           this.conControlsGroup.removeAll();  //隐藏所有节点上的连接点
	           this.conControlsGroup.off();        //清空所有事件
	           this._zr.remove(this.conControlsGroup);
	       }
	
	       /**
	        * 点击连线按钮时创建除选中节点外其余节点边框上的连接点
	        */
	       fishTopoProto.createLineConnectorPoint = function(point, pos, lineType) {
	           var pointInstance = new graphic.Circle({
	               shape: {
	                   cx: point.x,
	                   cy: point.y,
	                   r: 4
	               },
	               style: {
	                   fill: '#FFFF33',
	                   stroke:'#000000'
	               },
	               z : 4,
	               draggable: true,
	               lineType: lineType
	           });
	           pointInstance.type = 'ConnectPoint';
	           pointInstance.pos = pos;                //记录是节点上哪个位置的连接点
	
	           this.conPointsGroup.add(pointInstance);
	       }
	
	       /**
	        * @private
	        * 初始化 操作的虚线框
	        */
	       fishTopoProto.initOperationNode = function(node) {
	           var that = this;
	           this.operationNode = new OperationNode(node, this._zr, this._api, this.forbidEdit);
	           function findConnectorNode(x, y, offset, pos) {
	               var node, endPos = null;
	               that.allNodes.forEach(function(item) {
	                   var canShowPoint = false;
	                   if (item !== that.selectedNode) {
	                       if (that.selectedNode.parent && Bpmn.isSubProcess(that.selectedNode.parent)) {
	                           if(item.parent && Bpmn.isSubProcess(item.parent) && item.parent.id === that.selectedNode.parent.id){
	                               canShowPoint = true;
	                           }
	                           if (Bpmn.isSlotEvent(that.selectedNode)) {
	                               canShowPoint = true;
	                           }
	                       } else {
	                           if (!(item.parent && Bpmn.isSubProcess(item.parent))) {
	                               canShowPoint = true;
	                           }
	                           if (item.parent && Bpmn.isSubProcess(item.parent) && Bpmn.isSlotEvent(item)) {
	                               canShowPoint = true;
	                           }
	                       }
	                   }
	                   if (canShowPoint) {
	                       var realNodeCal = that.calculateRect(item);
	                       var connectorPoint = util.getConnectorPoints(realNodeCal, { rotation: realNodeCal.rotation });
	                       if (pos) {
	                           if (Math.abs(connectorPoint[pos].x - x) <= offset && Math.abs(connectorPoint[pos].y - y) <= offset) {
	                               node = item;
	                           }
	                       } else {
	                           if (Math.abs(connectorPoint["left"].x - x) <= offset && Math.abs(connectorPoint["left"].y - y) <= offset) {
	                               endPos = "left";
	                               node = item;
	                           } else if (Math.abs(connectorPoint["top"].x - x) <= offset && Math.abs(connectorPoint["top"].y - y) <= offset) {
	                               endPos = "top";
	                               node = item;
	                           } else if (Math.abs(connectorPoint["right"].x - x) <= offset && Math.abs(connectorPoint["right"].y - y) <= offset) {
	                               endPos = "right";
	                               node = item;
	                           } else if (Math.abs(connectorPoint["bottom"].x - x) <= offset && Math.abs(connectorPoint["bottom"].y - y) <= offset) {
	                               endPos = "bottom";
	                               node = item;
	                           }
	                       }
	                   }
	               });
	               return {
	                   node: node,
	                   endPos: endPos
	               };
	           }
	           // 侦听 箭头 拖拽开始事件
	           this.operationNode.on(OperationNode.ARROW_DRAGSTART, function(e) {
	               that.hideConnectorPoint();
	               that.filterConnectPoint(that.allNodes, e.event.target.lineType);
	               that._zr.add(that.conPointsGroup);
	               var x = e.event.offsetX;
	               var y = e.event.offsetY;
	               //拖拽开始先把 箭头图标 给隐藏
	               var arrow = e.event.target;
	               if (e.data) {
	                   that.lineOpt = e.data;  //缓存线段的配置信息
	               }
	               arrow.hide();
	               var rEndPoint = new Point(x, y);
	               var connector = that.connectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType);
	               that._zr.add(connector);
	           });
	
	           // 侦听 箭头 拖拽事件
	           this.operationNode.on(OperationNode.ARROW_DRAG, function(e) {
	               var x = e.event.offsetX;
	               var y = e.event.offsetY;
	               var rEndPoint = new Point(x, y);
	               var arrow = e.event.target;
	               that.connectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType);
	               that.conPointsGroup.children().forEach(function (v) {
	                   v.attr({style:{fill: "#FFFF33"},scale:[1,1],origin:[v.shape.cx,v.shape.cy],cursor:'crosshair'});
	                   if (Math.abs(v.shape.cx - x) <= 10 && Math.abs(v.shape.cy - y) <= 10) {
	                       var res = findConnectorNode(x, y, 10);
	                       that.connectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType, 'right', res.endPos, res.node);
	                       v.attr({style:{fill: "#ff0000"},scale:[1.5,1.5],origin:[v.shape.cx,v.shape.cy],cursor:'pointer'});
	                   }
	               })
	           });
	
	           //侦听 箭头 拖拽结束事件 画线
	           this.operationNode.on(OperationNode.ARROW_DRAGEND, function(e) {
	               var x = e.event.offsetX;
	               var y = e.event.offsetY;
	               var targetNode = null;
	               //拖拽结束先把 箭头图标 给显示
	               var arrow = e.event.target;
	               arrow.show();
	
	               var res = findConnectorNode(x, y, 10);
	               var start;
	               var end;
	               var endPos = res.endPos || 'left';
	               var startPos;
	               var canConnect = false;       //两个节点是否可以连线的标识
	               targetNode = res.node;
	               arrow = e.event.target;
	               //删除临时线
	               that.connectionManager.removeTempConnector(that._zr);
	               if (that.selectedNode.parent && Bpmn.isSubProcess(that.selectedNode.parent)) {
	                    if (targetNode && Bpmn.isSlotEvent(that.selectedNode)) {
	                        // 当前节点是边界节点可连线
	                        canConnect = true;
	                    }
	                   if (targetNode && targetNode.parent && Bpmn.isSubProcess(targetNode.parent) && targetNode.parent.id === that.selectedNode.parent.id) {
	                       // 起始节点都在同一个子节点内则可以连线
	                       canConnect = true;
	                   }
	               } else {
	                   if (targetNode && !targetNode.parent) {
	                       canConnect = true;
	                   }
	                   if (targetNode && targetNode.parent && Bpmn.isSubProcess(targetNode.parent) && Bpmn.isSlotEvent(targetNode)) {
	                       // 目标节点是边界节点可连线
	                       canConnect = true;
	                   }
	               }
	               //2.如果找到目标结点 则画线
	               if (canConnect && (that.selectedNode.id !== targetNode.id)) {
	                   var connectOptions;
	                   start = that.selectedNode;
	                   end = targetNode;
	                   startPos = 'right';
	                   if (e.data) {
	                       connectOptions = e.data;
	                   } else {
	                       connectOptions = {
	                           style: {
	                               lineType: arrow.lineType
	                           }
	                       }
	                   }
	                   that._createConnectorByNodes(start, end, connectOptions, startPos, endPos);
	               }
	               that.hideConnectorPoint();      //隐藏所有节点上的连接点
	               // 连线成功/失败，当前节点依然是选中状态，需要重新计算虚线和图标位置
	               var node = that.selectedNode;
	               var shapeRect = that.calculateRect(node);
	               // 显示当前节点的连接点
	               that.showConnectorPoint(undefined, undefined, true);
	               that.operationNode.refreshPostion(node, shapeRect);
	           });
	           //删除按钮点击事件
	           this.operationNode.on("OperationNode:deleteClick", function() {
	               that.removeNode(that.selectedNode);
	           });
	           //注释按钮点击事件
	           this.operationNode.on("OperationNode:commentClick", function() {
	               var start = that.selectedNode;
	               if (!start.hasComment) {
	                   var endX, endY;
	                   if (start.bpmnInfo.name.indexOf('Event') !== -1 || start.bpmnInfo.name.indexOf('Gateway') !== -1) {
	                       endX = start.position[0] + 40;
	                       endY = start.position[1] - 80;
	                   } else if (start.nodeType === "SubProcess") {
	                       endX = start.position[0] + 200;
	                       endY = start.position[1] - 80;
	                   } else {
	                       endX = start.position[0] + 120;
	                       endY = start.position[1] - 80;
	                   }
	                   var model = new BPMNModel({});
	                   model.set(Bpmn.BPMN_TYPE, 'Comment');
	                   model.set("bounds.upperLeft", {x: endX, y: endY});
	                   model.set("properties", {
	                       name: "comment",
	                       operationIcons: [{name:'DEL', callback: function(e) {
	                           start.hasComment = false;
	                           that.remove(end);
	                       }}]
	                   });
	                   var end = that.addNodeByModel(model, true);
	                   model = new BPMNModel({});
	                   model.set("resourceId", util.getUUID());
	                   model.set("style.lineType", "straight");
	                   model.set("style.lineDash", [3]);
	                   model.set("style.stroke", "#000");
	                   model.set("symbol.type", "none");
	                   model.set("stencil.type", "SequenceFlow");
	                   var connector = that.connectionManager.connectorCreateByOptions(start, end, {model: model}, that._api);
	                   that._zr.add(connector);
	                   start.hasComment = true;
	               }
	           });
	           this._zr.add(this.operationNode);
	       };
	
	       fishTopoProto.findNodeChildIds = function (node, childIds) {
	           childIds.push(node.id);
	           node.children().filter(function (v) {
	               var pos = this.allNodes.findIndex(function (item) {
	                   return item.id === v.id
	               });
	               return pos !== -1
	           }.bind(this)).forEach(function (sub) {
	               if (Bpmn.isSubProcess(sub)) {
	                   this.findNodeChildIds(sub, childIds);
	               } else {
	                   childIds.push(sub.id);
	               }
	           }.bind(this));
	       }
	
	       /**
	        * 移除场景中的某个节点
	        * @param  {Object} selectedNode 待删除的节点
	        */
	       fishTopoProto.remove = fishTopoProto.removeNode = function(delNode) {
	           var parentZr = this._getParentZr(delNode), _this = this;
	           if (delNode instanceof Connector) {
	               this._triggerAsync('beforeDeleteLine', {target: delNode}, delNode).then(function (res) {
	                   if (res) {
	                       // 1.1 删除线段上的操作图标
	                       zrUtil.each(delNode.icons, function(lineOperationIcon) {
	                           parentZr.remove(lineOperationIcon);
	                       })
	                       // 1.2 删除当前选中线段
	                       _this.connectionManager.deleteLine(parentZr);
	                       _this._trigger('afterDeleteLine', {target: delNode});
	                       _this.stepCounter();
	                   }
	               });
	           } else {
	               this._triggerAsync('beforeDeleteNode', {target: delNode}, delNode).then(function (res) {
	                   if (res) {
	                       parentZr.remove(delNode);
	                       var childIds = [];
	                       if (Bpmn.isSubProcess(delNode)) {
	                           _this.findNodeChildIds(delNode, childIds);
	                       } else {
	                           childIds.push(delNode.id);
	                       }
	                       //2.从allNodes数组中删除
	                       _this.allNodes = _this.allNodes.filter(function (v) {
	                           return childIds.indexOf(v.id) === -1
	                       });
	                       _this.domArray = _this.domArray.filter(function (v) {
	                           return childIds.indexOf(v.id) === -1
	                       });
	                       for (var k = 0; k < _this.overlapArray.length; k++) {
	                           if (delNode.id == _this.overlapArray[k].id) {
	                               _this.overlapArray.splice(k, 1);
	                           }
	                       }
	                       if (Bpmn.isSubProcess(delNode)) {
	                           for (var m = 0; m < _this.subProcessNode.length; m++) {
	                               if (delNode.id == _this.subProcessNode[m].id) {
	                                   _this.subProcessNode.splice(m, 1);
	                               }
	                           }
	                       }
	                       // 删除节点操作
	                       _this._removeOperationNode();
	                       //3.将此节点交联的线也删除
	                       _this.connectionManager.deleteSelectCon(delNode, Bpmn.isSlotEvent(delNode) ? _this._zr : parentZr);
	                       //如果删除节点是task节点，需要将依附它的事件节点删除
	                       if (Bpmn.isActivity(delNode) || Bpmn.isSubProcess(delNode)) {
	                           if (delNode.slotEvent && delNode.slotEvent.length > 0) {
	                               for (var m = 0; m < delNode.slotEvent.length; m++) {
	                                   if (delNode.slotEvent[m].parent) {
	                                       if (Bpmn.isSubProcess(delNode.slotEvent[m].parent)) {
	                                           delNode.slotEvent[m].parent.remove(delNode.slotEvent[m]);
	                                       }
	                                   } else {
	                                       _this._zr.remove(delNode.slotEvent[m]);
	                                   }
	                                   for (var n = 0; n < _this.allNodes.length; n++) {
	                                       if (delNode.slotEvent[m].id == _this.allNodes[n].id) {
	                                           _this.allNodes.splice(n, 1);
	                                       }
	                                   }
	                                   for (var a = 0; a < _this.domArray.length; a++) {
	                                       if (delNode.slotEvent[m].id == _this.domArray[a].id) {
	                                           _this.domArray.splice(a, 1);
	                                       }
	                                   }
	                               }
	                           }
	                       }
	                       //4.如果删除的是事件节点，需要将绑定它的task节点的标识删除
	                       if (Bpmn.isSlotEvent(delNode)) {
	                           for (var b = 0; b < _this.allNodes.length; b++) {
	                               if (_this.allNodes[b].isCanSlot) {
	                                   if (_this.allNodes[b].slotEvent && _this.allNodes[b].slotEvent.length > 0) {
	                                       for (var c = 0; c < _this.allNodes[b].slotEvent.length; c++) {
	                                           if (delNode.id == _this.allNodes[b].slotEvent[c].id) {
	                                               _this.allNodes[b].slotEvent.splice(c, 1);
	                                           }
	                                       }
	                                   }
	                               }
	                           }
	                       }
	                       _this._trigger('afterDeleteNode', {target: delNode});
	                       _this.stepCounter();
	                   }
	               });
	           }
	       };
	       fishTopoProto.removeSelectedNodes = function() {
	           var that = this;
	           if (this.selectedNodes.length) {
	               var childs = that.dragSelectRect.children().filter(function (v) {
	                   return v.name !== "GROUP_RECT_NAME" && !Bpmn.isFlow(v);
	               });
	               var lines = that.dragSelectRect.children().filter(function (v) {
	                   return v.name !== "GROUP_RECT_NAME" && Bpmn.isFlow(v);
	               });
	               that.connectionManager.connectors.forEach(function (v) {
	                   var startNode = childs.find(function(node) {
	                       return node.id === v.startNode.id
	                   });
	                   var endNode = childs.find(function(node) {
	                       return node.id === v.endNode.id
	                   });
	                   var ifExist = lines.findIndex(function(line) {
	                       return line.id === v.id
	                   });
	                   if ((startNode || endNode) && ifExist === -1) {
	                       that.connectionManager.removeLine(v, v.parent ? v.parent : that._zr);
	                   }
	               });
	               this.selectedNodes.forEach(function(item) {
	                   that.removeNode(item);
	               });
	               this.selectedNodes = [];
	               this.dragSelectRect.off("mousedown");
	               this._zr.remove(this.dragSelectRect);
	           } else {
	               that.removeNode(that.selectedNode);
	           }
	       };
	       fishTopoProto._createConnectorByNodes = function(startNode, endNode, lineType, startPos, endPos) {
	           var _this = this;
	           this._triggerAsync('beforeCreateLine', {target: startNode}, [startNode, endNode]).then(function (res) {
	               if (res) {
	                   var connector = _this.connectionManager.connectorCreate(startNode, endNode, lineType, _this._api, startPos, endPos);
	                   if (startNode.parent && endNode.parent && startNode.parent.resourceId === endNode.parent.resourceId) {
	                       endNode.parent.add(connector);
	                   } else {
	                       _this._zr.add(connector);
	                   }
	                   _this.connectionManager.connectorForbidEdit();
	                   _this._createConnectorDragEvents(connector);
	                   connector.on("mousedown", zrUtil.bind(function(e) {
	                       this.lineOperationManager.isEdit = !this.forbidEdit;
	                       this.isNode = false;
	                       // 取消节点的选中
	                       this.hideConnectorPoint();
	                       this.hideConnectorControl();
	                       this._removeOperationNode();
	                    //    this.showConnectorPoint(e.target.style.lineType);
	                   }, _this));
	                   _this._trigger('afterCreateLine', {target: connector});
	                   _this.stepCounter();
	                   return connector;
	               }
	           })
	       };
	
	       fishTopoProto._createConnectorDragEvents = function(connector) {
	            var that = this;
	            connector.on("dragstart", function (e) {
	                var x = e.event.offsetX;
	                var y = e.event.offsetY;
	                var opt = this.opt;
	                var lineType = opt.style.lineType;
	                var dockers = opt.dockers;
	                var startPoint = dockers[0];
	                var endPoint = dockers[dockers.length - 1];
	                var startDiff = Math.abs(x - startPoint.x) + Math.abs(y - startPoint.y);
	                var endDiff = Math.abs(x - endPoint.x) + Math.abs(y - endPoint.y);
	                if (startDiff > 15 && endDiff > 15) {
	                    return;
	                }
	                var point = new Point(x, y);
	                that.showConnectorPoint(undefined, undefined);
	                that.reverseConnect = false;   //是否反向连线的标识
	                that.selectConnNode = connector.startNode;
	                that.lineOpt = opt.style; //缓存线段的配置信息
	                if (endDiff <= 15) {
	                    that.selectConnNode = connector.startNode;
	                    that.startPos = opt.style.sPos;
	                    that.originNode = this.endNode;
	                    that.originPos = opt.style.ePos;
	                }
	                if (startDiff <= 15) {
	                    that.reverseConnect = true;
	                    that.selectConnNode = connector.endNode;
	                    that.endPos = opt.style.ePos;
	                    that.originNode = this.startNode;
	                    that.originPos = opt.style.sPos;
	                }
	                that.connectionManager.deleteByLine(this, that._zr);
	                var connectorLine;
	                if (that.reverseConnect) {
	                    connectorLine = that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, lineType, that.endPos);
	                } else {
	                    connectorLine = that.connectionManager.manageTempConnector(that.selectConnNode, point, lineType, that.startPos);
	                }
	                that._zr.add(connectorLine);
	                connectorLine.setSelectedStyle();
	            });
	            connector.on("drag", function (e) {
	                that._handleLineDrag('drag', e, this.opt.style.lineType);
	            });
	            connector.on("dragend", function (e) {
	                that._handleLineDrag('dragend', e, this.opt.style.lineType);
	                that.hideConnectorPoint();
	                that.hideConnectorControl();
	            });
	       }
	
	       fishTopoProto._triggerAsync = function(type, event, data) {
	           return this._trigger(type, event, data, true);
	       }
	       fishTopoProto._trigger = function(type, event, data, async) {
	           var callback = this.opts[type];
	
	           if (data === void 0) data = {};
	           if (event === null) {
	               event = {type:type, target:this}
	           } else {
	               event.type = type;
	           }
	           event.data = data;
	           this._api.trigger(event.type, event);
	           if (async) {
	               return promise.resolve(zrUtil.isFunction(callback) ? callback.apply(this, [event].concat(data)) : true)
	               .then(function (value) {
	                   return !(value === false);
	               }).catch(function (error) {
	                   console.log(error);
	               });
	           } else {
	               return !(zrUtil.isFunction(callback) && callback.apply(this, [event].concat(data)) === false);
	           }
	       }
	
	       /**
	        * @private
	        * 鼠标点下 将操作框 移到对应的节点上
	        * @param  {Object} node [description]
	        * @return {Object}      [description]
	        */
	       fishTopoProto.nodeClickHandler = function(node) {
	            var ifShowPoint = node.type !== 'dragSelect';
	            if (node.parent && node.parent.type === "dragSelect") {
	                ifShowPoint = false;
	            }
	            // 1. 隐藏连线点
	            this.hideConnectorPoint();
	            // 2. 隐藏控制点
	            this.hideConnectorControl();
	            // 3. 隐藏操作node
	            this._removeOperationNode();
	            this._trigger('editOperationIcons', {target: node}, node.operationIcons);
	            if (this.forbidEdit === true) {
	                return;
	            }
	            this.selectedNode = node;
	            var shapeRect = this.calculateRect(node);
	            if (!this.operationNode) {
	                this.initOperationNode(node);
	            }
	            this.rect && this.rect.attr("style", {
	                stroke: "rgba(0, 0, 0, 1)"
	            });
	
	            if (ifShowPoint) {
	                // 显示当前节点的连接点
	                this.showConnectorPoint(undefined, undefined, true);
	                var params = this.returnConnectorControlParam(node);
	                if (params.scaleable || params.rotatable) {
	                    // 显示当前节点的控制点
	                    this.showConnectorControl();
	                }
	            }
	            this.operationNode.refreshPostion(node, shapeRect);
	        };
	
	       /**
	        * 初始化虚框对齐线
	        * @private
	        * @param  {Object} node [description]
	        * @param  {Object} shapeList [description]
	        */
	       fishTopoProto.initVirtualLine = function(node, shapeList) {
	           Guidelines.createGuidelines(this._zr);
	           this.rect = new graphic.Polyline({
	               position: [shapeList.x, shapeList.y],
	               shape: {
	                   points: shapeList.points
	               },
	               style: {
	                   lineDash: [2]
	               },
	               rotation: node.rotation,
	               z: 3
	           });
	           this._zr.add(this.rect);
	       };
	       //绑定事件节点
	       fishTopoProto.bindEventNode = function() {
	           //mousedown的时候为每个task创建插槽
	           for (var i = 0; i < this.allNodes.length; i++) {
	               if (this.allNodes[i].isCanSlot) {
	                   this.creatSlot(this.allNodes[i]);
	               }
	           }
	           //mouseup的时候删除插槽
	           this._zr.on("mouseup", function() {
	               for (var i = 0; i < this.allNodes.length; i++) {
	                   if (this.allNodes[i].isCanSlot) {
	                       if (this.allNodes[i].slot && this.allNodes[i].slot.length > 0) {
	                           for (var m = 0; m < this.allNodes[i].slot.length; m++) {
	                               this.allNodes[i].remove(this.allNodes[i].slot[m]);
	                           }
	                       }
	                   }
	               }
	           }.bind(this))
	
	       };
	
	       /**
	        * @private
	        */
	       fishTopoProto.creatSlot = function(node) {
	           //给task创建8个插槽
	           node.slot = [];
	           var position = util.getSoltPoints(node);
	           for (var j = 0; j < 8; j++) {
	               var Circle = new graphic.Circle({
	                   position: position[j],
	                   shape: {
	                       cx: 0,
	                       cy: 0,
	                       r: 10
	                   },
	                   style: {
	                       lineWidth: 1,
	                       stroke: 'rgba(0,0,0,0.6)',
	                       fill: 'transparent'
	                   }
	               });
	               node.slot.push(Circle);
	               node.add(Circle);
	           }
	       };
	
	       fishTopoProto.updateSlotEvent = function(node) {
	           if (node.slotEvent && node.slotEvent.length > 0) {
	               var position = util.getSoltPoints(node);
	               for (var n = 0; n < node.slotEvent.length; n++) {
	                   var index = node.slotEvent[n].index;
	                   var slotEventPosition2 = position[index];
	                   if (!Bpmn.isSubProcess(node)) {
	                       slotEventPosition2 = [position[index][0] + node.position[0], position[index][1] + node.position[1]]
	                   }
	                   node.slotEvent[n].attr("position", slotEventPosition2);
	                   this.connectionManager.refreshLineByNode(node.slotEvent[n]);
	               }
	           }
	       }
	
	       fishTopoProto._posInWhichSubprocess = function(containerNodes, node) {
	           if (containerNodes.length > 0) {
	               for (var i = 0; i < containerNodes.length; i++) {
	                   var containerNode = containerNodes[i];
	                   var rect = containerNode.getRect();
	                   var nodeWidth = rect.width;
	                   var nodeHeight = rect.height;
	                   var nodeX = BpmnUtil.parentX(containerNode);
	                   var nodeY = BpmnUtil.parentY(containerNode);
	                   if (node.x >= nodeX && node.y >= nodeY &&
	                       node.x+node.width <= nodeX+nodeWidth && node.y+node.height <= nodeY+nodeHeight) {
	                       var newNode;
	                       if (containerNode.children() && containerNode.children().length > 0) {
	                           var newContainer = containerNode.children().filter(function (item) {
	                               return item.bpmnInfo && item.nodeType === 'SubProcess'
	                           });
	                           newNode = this._posInWhichSubprocess(newContainer, node);
	                       }
	                       return newNode || containerNode;
	                   }
	               }
	           }
	           return null;
	       }
	
	       fishTopoProto.getDragSelectContainer = function () {
	           var LeftUpperPosX = [];
	           var LeftUpperPosY = [];
	           var RightLowerPosX = [];
	           var RightLowerPosY = [];
	           this.dragSelectRect.children().filter(function (v) {
	               return v.name !== "GROUP_RECT_NAME" && !Bpmn.isFlow(v);
	           }).forEach(function (item) {
	               var rect = item.getRect();
	               var nodeWidth = rect.width;
	               var nodeHeight = rect.height;
	               var nodeX = rect.x;
	               var nodeY = rect.y;
	
	               if (Bpmn.isEvent(item) || Bpmn.isGateway(item)) {
	                   LeftUpperPosX.push(nodeX - nodeWidth);
	                   LeftUpperPosY.push(nodeY - nodeHeight);
	                   RightLowerPosX.push(nodeX + nodeWidth);
	                   RightLowerPosY.push(nodeY + nodeHeight);
	               } else {
	                   LeftUpperPosX.push(nodeX - nodeWidth/2);
	                   LeftUpperPosY.push(nodeY - nodeHeight/2);
	                   RightLowerPosX.push(nodeX + nodeWidth/2);
	                   RightLowerPosY.push(nodeY + nodeHeight/2);
	               }
	           });
	           return {
	               x: Math.min.apply(Math, LeftUpperPosX),
	               y: Math.min.apply(Math, LeftUpperPosY),
	               width: Math.max.apply(Math, RightLowerPosX) - Math.min.apply(Math, LeftUpperPosX),
	               height: newHeight = Math.max.apply(Math, RightLowerPosY) - Math.min.apply(Math, LeftUpperPosY)
	           }
	       }
	
	       /**
	        * @private
	        * mousedown后 开始拖动
	        */
	       fishTopoProto.newDrag = function(dom, sX, sY) {
	           var that = this;
	           that.selectedNode = dom;
	           that.isNode = true;
	           var pixel = this.opts.gridLineSpacing;
	           var shapeList = this.calculateRect(dom);
	           var domArray = that.domArray;
	           //zrender不支持键盘事件，只能侦听body元素上的了
	           document.body.onkeydown = function (e) {
	               var ev = e || window.event;
	               //判断 delete按键
	               if (ev.keycode == 46 || ev.charCode == 46 || ev.which == 46) {
	                   //1.如果是节点,移除事件,进行删除  如果是子节点 通过parent删除
	                   if (that.isNode == true) {
	                       that.selectedNode.off();
	                       if (that.selectedNode.parent) {
	                           if (Bpmn.isSubProcess(that.selectedNode.parent)) {
	                               that.selectedNode.parent.remove(that.selectedNode);
	                           }
	                       } else {
	                           that._zr.remove(that.selectedNode);
	                       }
	                       //2.删除维护的节点数组
	                       for (var i = 0; i < that.allNodes.length; i++) {
	                           if (that.selectedNode.id == that.allNodes[i].id) {
	                               that.allNodes.splice(i, 1);
	                           }
	                       }
	                       for (var j = 0; j < domArray.length; j++) {
	                           if (that.selectedNode.id == domArray[j].id) {
	                               domArray.splice(j, 1);
	                           }
	                       }
	                       for (var k = 0; k < that.overlapArray.length; k++) {
	                           if (that.selectedNode.id == that.overlapArray[k].id) {
	                               that.overlapArray.splice(k, 1);
	                           }
	                       }
	                       //3.移去操作框
	                       if (that.operationNode) {
	                           that._zr.remove(that.operationNode);
	                           that.operationNode = null;
	                       }
	                       //3.删除对应的线
	                       that.connectionManager.deleteSelectCon(that.selectedNode, that._zr);
	                   } else { //否则直接删除线
	                       that.connectionManager.deleteLine(that._zr);
	                   }
	                   // 4.删除连接点和控制点
	                   that.hideConnectorPoint();
	                   that.hideConnectorControl();
	                   that.stepCounter();
	               }
	           }
	
	           //初始化 对齐线
	           var startX, startY, rectPositionX, rectPositionY;
	           startX = sX;
	           startY = sY;
	        //    if (dom.parent && Bpmn.isSubProcess(dom.parent)) {
	        //        rectPositionX = shapeList.x + BpmnUtil.parentX(dom.parent);
	        //        rectPositionY = shapeList.y + BpmnUtil.parentY(dom.parent);
	        //    } else {
	        //        rectPositionX = shapeList.x;
	        //        rectPositionY = shapeList.y;
	        //    }
	            rectPositionX = shapeList.x;
	            rectPositionY = shapeList.y;
	           if (!that.rect) {
	               that.initVirtualLine(dom, shapeList);
	               that.rect.attr("position", [rectPositionX, rectPositionY]);
	           } else {
	               that.rect.attr({
	                   "position": [rectPositionX, rectPositionY],
	                   "rotation": shapeList.rotation || dom.rotation
	               });
	               that.rect.setShape({points: shapeList.points});
	               that.rect.show();
	           }
	           var nowRectPosition = [rectPositionX, rectPositionY];
	           var nowDragRectPosition, dragRectPositionX, dragRectPositionY, dragRect;
	           var dgRect, startContainer;
	           if (dom.type === "dragSelect") {
	               dragRect = this.getDragSelectContainer();
	               dragRectPositionX = dragRect.x + dragRect.width/2 + this.dragSelectRect.position[0];
	               dragRectPositionY = dragRect.y + dragRect.height/2 + this.dragSelectRect.position[1];
	               nowDragRectPosition = [dragRectPositionX, dragRectPositionY];
	
	               dgRect = that.dragSelectRect.getRect();
	               startContainer = that._posInWhichSubprocess(that.subProcessNode, {
	                   x: dgRect.x - dgRect.width/2,
	                   y: dgRect.y - dgRect.height/2,
	                   width: dgRect.width,
	                   height: dgRect.height
	               });
	           }
	
	           var isLap = 0;
	           var isMove = 0;
	           var moveFunction = function(e) {
	               moveDrag(e);
	           };
	           var upFunction = function(e) {
	               endDrag(e);
	           };
	           this._zr.on('mousemove', moveFunction);
	
	           //开始移动,节点移动时取消所有节点的选中状态
	           function moveDrag(e) {
	               that._removeOperationNode();
	               that.hideConnectorPoint();
	               that.hideConnectorControl();
	               //以10个像素为单位进行移动
	               var maxRectPosition = [that.getWidth() - (that.rect.shape.points[1][0] - that.rect.shape.points[0][0]) / 2, that.getHeight() - (that.rect.shape.points[2][1] - that.rect.shape.points[1][1]) / 2];
	               var minRectPosition = [(that.rect.shape.points[1][0] - that.rect.shape.points[0][0]) / 2, (that.rect.shape.points[2][1] - that.rect.shape.points[1][1]) / 2];
	               for (var n = 0; n < Math.abs(parseInt((e.event.clientX - startX) / pixel)); n++) {
	                   isMove = 1;
	                   if (e.event.clientX - startX < 0) {
	                       nowRectPosition[0] = rectPositionX - pixel * (n);
	                       if (dom.type === "dragSelect") {
	                           nowDragRectPosition[0] = dragRectPositionX - pixel * (n);
	                       }
	                   } else {
	                       nowRectPosition[0] = rectPositionX + pixel * (n);
	                       if (dom.type === "dragSelect") {
	                           nowDragRectPosition[0] = dragRectPositionX + pixel * (n);
	                       }
	                   }
	                   if (nowRectPosition[0] < minRectPosition[0]) {
	                       nowRectPosition[0] = minRectPosition[0];
	                   }
	                   if (nowRectPosition[0] > maxRectPosition[0]) {
	                       nowRectPosition[0] = maxRectPosition[0];
	                   }
	               }
	               for (var m = 0; m < Math.abs(parseInt((e.event.clientY - startY) / pixel)); m++) {
	                   isMove = 1;
	                   if (e.event.clientY - startY < 0) {
	                       nowRectPosition[1] = rectPositionY - pixel * (m);
	                       if (dom.type === "dragSelect") {
	                           nowDragRectPosition[1] = dragRectPositionY - pixel * (m);
	                       }
	                   } else {
	                       nowRectPosition[1] = rectPositionY + pixel * (m);
	                       if (dom.type === "dragSelect") {
	                           nowDragRectPosition[1] = dragRectPositionY + pixel * (m);
	                       }
	                   }
	                   if (nowRectPosition[1] < minRectPosition[1]) {
	                       nowRectPosition[1] = minRectPosition[1];
	                   }
	                   if (nowRectPosition[1] > maxRectPosition[1]) {
	                       nowRectPosition[1] = maxRectPosition[1];
	                   }
	               }
	               that.rect.attr('position', nowRectPosition);
	
	               function resultSuccess() {
	                   isLap = 0;
	                   that.rect.attr("style", {
	                       stroke: "rgba(0, 0, 0, 1)"
	                   });
	               }
	
	               function resultFalse() {
	                   isLap = 1;
	                   that.rect.attr("style", {
	                       stroke: "rgba(255, 0, 0, 1)"
	                   });
	               }
	
	               function isChild(node, subNode) {
	                   if (subNode.parent) {
	                       if (subNode.parent.id === node.id) {
	                           return true;
	                       } else {
	                           return isChild(node, subNode.parent);
	                       }
	                   }
	                   return false;
	               }
	
	               that.containerNode = null;
	               if (dom.type === "dragSelect") {
	                   var subNode = that._posInWhichSubprocess(that.subProcessNode, {
	                       x: nowDragRectPosition[0] - dragRect.width/2,
	                       y: nowDragRectPosition[1] - dragRect.height/2,
	                       width: dragRect.width,
	                       height: dragRect.height
	                   });
	                   var targetContainer = that._JudgeNodeInWhichSubProcess(that.subProcessNode, {x: e.event.offsetX, y: e.event.offsetY});
	                   if (!startContainer && targetContainer) {
	                       resultFalse();
	                   } else {
	                       resultSuccess();
	                   }
	                   that.resetBackground();
	                   if (startContainer && !subNode) {
	                       //改变画布颜色
	                       that.containerNode = 'zr';
	                       that.setBackground("#b6e3f5");
	                   } else {
	                       that.allNodes.filter(function (v) {
	                           return Bpmn.isSubProcess(v);
	                       }).forEach(function (item) {
	                           if (subNode && subNode.id === item.id) {
	                               resultSuccess();
	                               that.containerNode = item;
	                               if (!startContainer || (startContainer && startContainer.id !== item.id)) {
	                                   item.children().forEach(function (v) {
	                                       if (v.name === "subprocess-rect") {
	                                           if (!v.initStyle) {
	                                               var initFill = v.style.fill;
	                                               v.attr("initStyle", initFill);
	                                           }
	                                           v.attr("style", {
	                                               fill:'#b6e3f5'
	                                           });
	                                       }
	                                   });
	                               }
	                           } else {
	                               item.children().forEach(function (v) {
	                                   if (v.name === "subprocess-rect") {
	                                       if (!v.initStyle) {
	                                           var initFill = v.style.fill;
	                                           v.attr("initStyle", initFill);
	                                           v.attr("style", {
	                                               fill: v.initStyle
	                                           });
	                                       } else {
	                                           v.attr("style", {
	                                               fill: v.initStyle
	                                           });
	                                       }
	                                   }
	                               });
	                           }
	                       });
	                   }
	                   return true;
	               }
	
	               Guidelines.judgeAlignment(nowRectPosition, domArray, that.getWidth(), that.getHeight());
	               var targetSub = that._JudgeNodeInWhichSubProcess(that.subProcessNode, {x: nowRectPosition[0], y: nowRectPosition[1]});
	               for (var l = 0, len = that.allNodes.length; l < len; l++) {
	                   var posX, posY;
	                   var currentNode = that.allNodes[l];
	                   var rectDom = currentNode.getRect();
	                   var canCompare = true;
	                   resultSuccess();
	
	                   if ((currentNode.id === dom.id) || (Bpmn.isSubProcess(dom) && isChild(dom, currentNode))) {
	                       continue;
	                   }
	                   that.resetBackground();
	                   if (Bpmn.isSubProcess(currentNode)) {
	                       currentNode.children().forEach(function (v) {
	                           if (v.name === "subprocess-rect") {
	                               if (!v.initStyle) {
	                                   var initFill = v.style.fill;
	                                   v.attr("initStyle", initFill);
	                                   v.attr("style", {
	                                       fill: v.initStyle
	                                   });
	                               } else {
	                                   v.attr("style", {
	                                       fill: v.initStyle
	                                   });
	                               }
	                           }
	                       });
	                       if (targetSub && targetSub.id === currentNode.id) {
	                           that.containerNode = currentNode;
	                           if (!dom.parent || (dom.parent && targetSub.id !== dom.parent.id)) {
	                               currentNode.children().forEach(function (v) {
	                                   if (v.name === "subprocess-rect") {
	                                       if (!v.initStyle) {
	                                           var initFill = v.style.fill;
	                                           v.attr("initStyle", initFill);
	                                       }
	                                       v.attr("style", {
	                                           fill:'#b6e3f5'
	                                       });
	                                   }
	                               })
	                           }
	                       }
	                       canCompare = false;
	                   }
	                   if (dom.parent && !targetSub) {
	                       //改变画布颜色
	                       that.containerNode = 'zr';
	                       that.setBackground("#b6e3f5");
	                   }
	                   if (currentNode.parent && Bpmn.isSubProcess(currentNode.parent)) {
	                       posX = rectDom.x + BpmnUtil.parentX(currentNode.parent);
	                       posY = rectDom.y + BpmnUtil.parentY(currentNode.parent);
	                   } else {
	                       posX = rectDom.x;
	                       posY = rectDom.y;
	                   }
	                   if (canCompare) {
	                       if (shapeList.width > rectDom.width) {
	                           //移动的位置 减去当前节点的位置 小于拖拽节点高度及宽度一半， 则有重叠 标红
	                           if (shapeList.height > rectDom.height) {
	                               if (Math.abs(nowRectPosition[0] - posX) < (rectDom.width+shapeList.width) / 2 && Math.abs(nowRectPosition[1] - posY) < (rectDom.height+shapeList.height) / 2) {
	                                   resultFalse();
	                                   break;
	                               } else {
	                                   resultSuccess();
	                               }
	                           } else {
	                               if (Math.abs(nowRectPosition[0] - posX) < (rectDom.width+shapeList.width) / 2 && Math.abs(nowRectPosition[1] - posY) < (rectDom.height+shapeList.height) / 2) {
	                                   resultFalse();
	                                   break;
	                               } else {
	                                   resultSuccess();
	                               }
	                           }
	                       } else {
	                           if (shapeList.height > rectDom.height) {
	                               if (Math.abs(nowRectPosition[0] - posX) < (rectDom.width+shapeList.width) / 2 && Math.abs(nowRectPosition[1] - posY) < (rectDom.height+shapeList.height) / 2) {
	                                   resultFalse();
	                                   break;
	                               } else {
	                                   resultSuccess();
	                               }
	                           } else {
	                               if (Math.abs(nowRectPosition[0] - posX) < (rectDom.width+shapeList.width) / 2 && Math.abs(nowRectPosition[1] - posY) < (rectDom.height+shapeList.height) / 2) {
	                                   resultFalse();
	                                   break;
	                               } else {
	                                   resultSuccess();
	                               }
	                           }
	                       }
	                   }
	               }
	
	               //判断事件节点是否可以依附，可以依附显示绿框
	               if (Bpmn.isSlotEvent(dom)) {
	                   for (var i = 0; i < that.allNodes.length; i++) {
	                       if (that.allNodes[i].isCanSlot) {
	                           if (that.allNodes[i].slot && that.allNodes[i].slot.length > 0) {
	                               for (var a = 0; a < that.allNodes[i].slot.length; a++) {
	                                   var slotPosition = [that.allNodes[i].slot[a].position[0] + that.allNodes[i].position[0], that.allNodes[i].slot[a].position[1] + that.allNodes[i].position[1]];
	                                   if (nowRectPosition[0] == slotPosition[0] && nowRectPosition[1] == slotPosition[1]) {
	                                       that.rect.attr("style", {
	                                           stroke: "rgba(0, 255, 0, 1)"
	                                       });
	                                       isLap = 0;
	                                       break;
	                                   }
	                               }
	                           }
	                       }
	                   }
	               }
	           }
	
	           function endDrag() {
	               that._zr.off('mousemove', moveFunction);
	               that._zr.off('mouseup', upFunction);
	               that._zr.off('globalout', upFunction);
	               if (dom.parent) {
	                   dom.parent.off("globalout", upFunction);
	               }
	               that.rect.hide();
	               Guidelines.virtualXLine.attr("shape", {
	                   x2: 0
	               });
	               Guidelines.virtualYLine.attr("shape", {
	                   y2: 0
	               });
	
	               //处理单击子节点内的某一个节点时，当前的容器节点不为该子节点的bug（为null）
	               if (!that.containerNode && dom.parent && Bpmn.isSubProcess(dom.parent)) {
	                   that.containerNode = dom.parent;
	               } else if (that.containerNode === 'zr') {
	                   that.containerNode = null;
	               }
	               var removeLine = false;
	               var groupNodePositionX = null, groupNodePositionY = null;
	               if (isLap == 0) {
	                   if (that.containerNode) {
	                       // 将当前节点和父节点摆正，再计算当前节点到父节点两边的垂直距离
	                       var parentRect = that.calculateRect(that.containerNode);
	                       var rotation = -parentRect.rotation;
	                       var newPosition = nowRectPosition;
	                       if (Math.abs(rotation) > 0) {
	                           newPosition = util.calculatePoints(nowRectPosition, parentRect, rotation);
	                       }
	                       groupNodePositionX = newPosition[0] - parentRect.boundingRect.x;
	                       groupNodePositionY = newPosition[1] - parentRect.boundingRect.y;
	                   }
	                   var posX = typeof groupNodePositionX === 'number' ? groupNodePositionX : nowRectPosition[0];
	                   var posY = typeof groupNodePositionY === 'number' ? groupNodePositionY : nowRectPosition[1];
	                   dom.setPosition(posX, posY);
	                   that.updateSlotEvent(dom);
	                   if (that.containerNode) {
	                       if (dom.parent && that.containerNode.id !== dom.parent.id) {
	                           dom.parent.remove(dom);
	                           that.containerNode.add(dom);
	                           removeLine = true;
	                       } else if (!dom.parent && dom.type !== "dragSelect") {
	                           that._zr.remove(dom);
	                           that.containerNode.add(dom);
	                           removeLine = true;
	                           for (var j = 0; j < that.overlapArray.length; j++) {
	                               if (dom.id == that.overlapArray[j].id) {
	                                   that.overlapArray.splice(j, 1);
	                               }
	                           }
	                       } else if (dom.type === "dragSelect") {
	                           var nodes = that.dragSelectRect.children().filter(function (v) {
	                               return v.name !== "GROUP_RECT_NAME" && !Bpmn.isFlow(v);
	                           });
	                           var lines = that.dragSelectRect.children().filter(function (v) {
	                               return v.name !== "GROUP_RECT_NAME" && Bpmn.isFlow(v);
	                           });
	
	                           that.connectionManager.connectors.forEach(function (v) {
	                               var startNode = nodes.find(function(node) {
	                                   return node.id === v.startNode.id
	                               });
	                               var endNode = nodes.find(function(node) {
	                                   return node.id === v.endNode.id
	                               });
	                               var ifExist = lines.findIndex(function(line) {
	                                   return line.id === v.id
	                               });
	                               if ((startNode || endNode) && ifExist === -1) {
	                                   that.connectionManager.removeLine(v, v.parent ? v.parent : that._zr);
	                               }
	                           });
	                           lines.forEach(function (line) {
	                               that.dragSelectRect.remove(line);
	                               that.containerNode.add(line);
	                           });
	                           var width = startContainer && startContainer.id === that.containerNode.id ? dgRect.width : dragRect.width;
	                           var height = startContainer && startContainer.id === that.containerNode.id ? dgRect.height : dragRect.height;
	                           for (var i = 0; i < nodes.length; i++) {
	                               var item = nodes[i];
	                               var nodeX = item.getRect().x;
	                               var nodeY = item.getRect().y;
	                               var nowX, nowY;
	                               if (startContainer && startContainer.id === that.containerNode.id) {
	                                   nowX = nowRectPosition[0];
	                                   nowY = nowRectPosition[1];
	                               } else {
	                                   nowX = nowDragRectPosition[0];
	                                   nowY = nowDragRectPosition[1];
	                               }
	                               var offsetX = nowX - BpmnUtil.parentX(that.containerNode) - width/2;
	                               var offsetY = nowY - BpmnUtil.parentY(that.containerNode) - height/2;
	                               var posx = nodeX + offsetX;
	                               var posy = nodeY + offsetY;
	                               if (item.slotEvent && item.slotEvent.length > 0) {
	                                   for (var n = 0; n < item.slotEvent.length; n++) {
	                                       var slotEventPosition2 = [item.slotEvent[n].position[0] + posx - zrUtil.clone(item.position[0]) - item.getBoundingRect().width / 2, item.slotEvent[n].position[1] + posy - zrUtil.clone(item.position[1]) - item.getBoundingRect().height / 2];
	                                       item.slotEvent[n].attr("position", slotEventPosition2);
	                                       that.connectionManager.refreshLineByNode(item.slotEvent[n]);
	                                   }
	                               }
	                               that.dragSelectRect.remove(item);
	                               that.containerNode.add(item);
	                               item.setPosition(posx, posy);
	                               if (item.originParent) {
	                                   item.originParent = null;
	                               }
	                               for (var m = 0; m < that.overlapArray.length; m++) {
	                                   if (item.id == that.overlapArray[m].id) {
	                                       that.overlapArray.splice(m, 1);
	                                   }
	                               }
	                               for (var n = 0; n < that.domArray.length; n++) {
	                                   if (item.id == that.domArray[n].id) {
	                                       that.domArray[n].position = [nodeX + (nowDragRectPosition[0] - width/2), nodeY + (nowDragRectPosition[1] - height/2)];
	                                   }
	                               }
	                               that.connectionManager.refreshLineByNode(item);
	                           }
	                           that.dragSelectRect.off("mousedown");
	                           that._zr.remove(that.dragSelectRect);
	                       }
	                       that.containerNode.children().forEach(function (v) {
	                           if (v.name === "subprocess-rect") {
	                               if (!v.initStyle) {
	                                   var initFill = v.style.fill;
	                                   v.attr("initStyle", initFill);
	                                   v.attr("style", {
	                                       fill: v.initStyle
	                                   });
	                               } else {
	                                   v.attr("style", {
	                                       fill: v.initStyle
	                                   });
	                               }
	                           }
	                       })
	                   } else if (dom.parent) {
	                       dom.parent.remove(dom);
	                       that._zr.add(dom);
	                       removeLine = true;
	                       if (!Bpmn.isSlotEvent(dom)) {
	                           that.overlapArray.push({
	                               id: dom.id,
	                               position: [nowRectPosition[0], nowRectPosition[1]],
	                               width: dom.getRect().width,
	                               height: dom.getRect().height
	                           });
	                       }
	                   }
	                   if (dom.type !== "dragSelect") {
	                       for (var b = 0; b < that.domArray.length; b++) {
	                           if (dom.id == that.domArray[b].id) {
	                               that.domArray[b].position = [nowRectPosition[0], nowRectPosition[1]];
	                           }
	                       }
	                       if (!that.containerNode && !dom.parent) {
	                           for (var j = 0; j < that.overlapArray.length; j++) {
	                               if (dom.id == that.overlapArray[j].id) {
	                                   that.overlapArray[j] = {
	                                       id: dom.id,
	                                       position: [nowRectPosition[0], nowRectPosition[1]],
	                                       width: dom.getRect().width,
	                                       height: dom.getRect().height
	                                   };
	                               }
	                           }
	                       }
	                   } else if (!that.containerNode) {
	                       var childs = that.dragSelectRect.children().filter(function (v) {
	                           return v.name !== "GROUP_RECT_NAME" && !Bpmn.isFlow(v);
	                       });
	                       var lines = that.dragSelectRect.children().filter(function (v) {
	                           return v.name !== "GROUP_RECT_NAME" && Bpmn.isFlow(v);
	                       });
	                       that.connectionManager.connectors.forEach(function (v) {
	                           var startNode = childs.find(function(node) {
	                               return node.id === v.startNode.id
	                           });
	                           var endNode = childs.find(function(node) {
	                               return node.id === v.endNode.id
	                           });
	                           var ifExist = lines.findIndex(function(line) {
	                               return line.id === v.id
	                           });
	                           if ((startNode || endNode) && ifExist === -1) {
	                               that.connectionManager.removeLine(v, v.parent ? v.parent : that._zr);
	                           }
	                       });
	                       var rectWidth = that.dragSelectRect.options.shape.width;
	                       var rectHeight = that.dragSelectRect.options.shape.height;
	                       for (var i = 0; i < childs.length; i++) {
	                           var node = childs[i];
	                           var x = node.getRect().x;
	                           var y = node.getRect().y;
	                           for (var p = 0; p < that.domArray.length; p++) {
	                               if (node.id == that.domArray[p].id) {
	                                   that.domArray[p].position = [x + (nowRectPosition[0] - rectWidth/2), y + (nowRectPosition[1] - rectHeight/2)];
	                               }
	                           }
	                           for (var q = 0; q < that.overlapArray.length; q++) {
	                               if (node.id == that.overlapArray[q].id) {
	                                   that.overlapArray[q].position = [x + (nowRectPosition[0] - rectWidth/2), y + (nowRectPosition[1] - rectHeight/2)];
	                               }
	                           }
	                       }
	                       if (startContainer) {
	                           that._releaseSelectNode(true);
	                       }
	                   }
	               } else if (that.containerNode) {
	                   that.containerNode.children().forEach(function (v) {
	                       if (v.name === "subprocess-rect") {
	                           if (!v.initStyle) {
	                               var initFill = v.style.fill;
	                               v.attr("initStyle", initFill);
	                               v.attr("style", {
	                                   fill: v.initStyle
	                               });
	                           } else {
	                               v.attr("style", {
	                                   fill: v.initStyle
	                               });
	                           }
	                       }
	                   });
	               }
	               that.resetBackground();
	               that.containerNode = null;
	
	               if (isMove == 1) {
	                   if (removeLine) {
	                       that.connectionManager.connectors.filter(function (v) {
	                           return v.startNode.id === dom.id || v.endNode.id === dom.id
	                       }).forEach(function (item) {
	                           that.connectionManager.removeLine(item, item.parent ? item.parent : that._zr);
	                       })
	                   } else {
	                       that.connectionManager.refreshLineByNode(dom);
	                   }
	                   that.nodeClickHandler(dom);
	                   that.stepCounter();
	               }
	
	               //将事件节点与task节点绑定或解绑
	               if (Bpmn.isSlotEvent(dom) && isLap == 0) {
	                   var newRectPosition = [];
	                   if (dom.parent) {
	                       if (Bpmn.isSubProcess(dom.parent)) {
	                           newRectPosition[0] = nowRectPosition[0] - BpmnUtil.parentX(dom.parent);
	                           newRectPosition[1] = nowRectPosition[1] - BpmnUtil.parentY(dom.parent);
	                       }
	                   } else {
	                       newRectPosition = nowRectPosition;
	                   }
	                   for (var i = 0; i < that.allNodes.length; i++) {
	                       if (that.allNodes[i].isCanSlot) {
	                           if (that.allNodes[i].slot && that.allNodes[i].slot.length > 0) {
	                               var unbind = true, exist = false, index;
	                               for (var c = 0; c < that.allNodes[i].slot.length; c++) {
	                                   var slotPosition = [that.allNodes[i].slot[c].position[0] + that.allNodes[i].position[0], that.allNodes[i].slot[c].position[1] + that.allNodes[i].position[1]];
	                                   if (nowRectPosition[0] == slotPosition[0] && nowRectPosition[1] == slotPosition[1]) {
	                                       unbind = false;
	                                       index = c;
	                                       break;
	                                   }
	                               }
	                               for (var k = 0; k < that.allNodes[i].slotEvent.length; k++) {
	                                   if (dom.id == that.allNodes[i].slotEvent[k].id) {
	                                       exist = true;
	                                       that.allNodes[i].slotEvent[k].index = index;
	                                       if (unbind) {
	                                           that.allNodes[i].slotEvent.splice(k, 1);
	                                       }
	                                   }
	                               }
	                               if (!exist && !unbind) {
	                                   // 标记slotEvent与node slot数组关联
	                                   dom.index = index;
	                                   that.allNodes[i].slotEvent.push(dom);
	                               } else if (exist && unbind) {
	                                   delete dom.index;
	                               }
	                           }
	                       }
	                   }
	               }
	           }
	
	           this._zr.on("mouseup", upFunction);
	           this._zr.on("globalout", upFunction);
	       };
	
	       fishTopoProto.setBackground = function (color) {
	           this.zrBackground = new graphic.Rect({
	               shape: {
	                   width: this._zr.getWidth(),
	                   height: this._zr.getHeight()
	               },
	               style: {
	                   fill: color
	               },
	               cursor: 'default',
	               z: -1
	           });
	           this._zr.add(this.zrBackground);
	       }
	
	       fishTopoProto.resetBackground = function () {
	           if (this.zrBackground) {
	               this._zr.remove(this.zrBackground);
	           }
	       }
	
	       /**
	        * @private
	        */
	       fishTopoProto.creatTip = function(node) {
	           //创建task内容的提示
	           var group = new graphic.Group();
	           group.isShow = false;
	           var name = node.model.get("properties.name") || "";
	           var showName;
	           if (name.length > 64) {
	               showName = name.substr(0, 64) + '..';
	           } else {
	               showName = name;
	           }
	           var text = new graphic.Text({
	               style: {
	                   text: showName,
	                   textFont: '16px Microsoft YaHei',
	                   fill: "#000000",
	                   textBaseline: "top" //垂直对齐
	               },
	               position: [2, 0],
	               z: 2
	           });
	           text.name = "Text";
	           group.add(text);
	           var Polyline = new graphic.Polyline({
	               style: {
	                   fill: '#f9f9f9',
	                   stroke: '#bbbbbb'
	               },
	               z: 1
	           });
	           Polyline.name = "Polyline";
	           group.add(Polyline);
	           // var groupPosition = [node.position[0] - node.getBoundingRect().width/2 - (group.getBoundingRect().width - 6), node.position[1]- node.getBoundingRect().height / 2 - group.getBoundingRect().height - 3];
	           // group.attr("position", groupPosition);
	           this._zr.add(group);
	           node.alarm = group;
	           group.hide();
	           group.eachChild(function(child) {
	               child.hide();
	           });
	       };
	
	       fishTopoProto.stepCounter = function() {
	           this.stepJson.splice(this.step, this.stepJson.length - (this.step));
	           this.step += 1;
	           var json = this.toJson();
	           this.stepJson.push(JSON.stringify(json));
	       };
	
	       /**
	        * 放大或者缩小
	        * @param  {String|Number} type 当为字符串时 "enlarge"放大  "narrowing"缩小  当为数值时 缩放的比例  建议0.3-1.7
	        */
	       fishTopoProto.zrScale = function (type) {
	           if (type == "narrowing") {
	               var zoomDelta1 = -0.07;
	               this.zoom(zoomDelta1, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	           }
	           if (type == "enlarge") {
	               var zoomDelta = 0.07;
	               this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	           }
	           if (!isNaN(type)) {
	               var target = this.group;
	               if (target) {
	                   var zoomScale = type / this._zoom;
	                   this._zoom = type;
	                   this.nowZoom = type;
	                   this.setScale(this._zr.getWidth() / 2, this._zr.getHeight() / 2, zoomScale);
	               }
	           }
	       };
	
	       /**
	        * @private
	        */
	       fishTopoProto.zoom = function (zoomDelta, zoomX, zoomY) {
	           var target = this.group;
	           if (target) {
	               var newZoom = this._zoom = this._zoom || 1;
	               newZoom += zoomDelta;
	               newZoom = Number(newZoom.toFixed(2));
	               var zoomScale = newZoom / this._zoom;
	               if (newZoom > 1.7 || newZoom < 0.3) {
	                   return;
	               }
	               this._zoom = newZoom;
	               this.nowZoom = newZoom;
	               this.setScale(zoomX, zoomY, zoomScale);
	           }
	       };
	
	       /**
	        * @private
	        */
	       fishTopoProto.setScale = function (zoomX, zoomY, zoomScale) {
	           var self = this;
	           var nodes = this.findElements(function(e){return true;});
	           var target = this.group;
	           nodes.push(target);
	           nodes.forEach(function (v) {
	               var pos = v.position;
	               var scale = v.scale;
	               scale[0] *= zoomScale;
	               scale[1] *= zoomScale;
	               v.attr("scale", [scale[0], scale[1]]);
	           });
	       };
	
	       /**
	        * @private
	        * 节点上文字编辑
	        */
	       fishTopoProto.nodeEdit = function (thisNode) {
	           var lineText = thisNode.childOfName('lineText');
	           if (this.forbidEdit === true) {
	               return;
	           }
	           var OFFSET_MULTIPLE = 0.55; //文本框宽度、高度的偏移系数
	           var isNotSetText = false;
	           var nodeRect = util.getRect(thisNode);
	           var textarea = this.createTextArea();
	           var nodeText = zrUtil.clone(thisNode.model.get("properties.name"));
	           var textRect = (thisNode instanceof Connector) && lineText ? textContain.getBoundingRect(lineText.style.text, "12px") : textContain.getBoundingRect(nodeText, "12px");
	           var textareaMinWidth = 0.6 * nodeRect.width;
	           var textareaWidth = (textRect.width == 0 ? textareaMinWidth : ((thisNode instanceof Connector) && (textRect.width > 60) ? 1.2 * textRect.width : 2 * textRect.width)) * this.nowZoom;
	           var textareaHeight = (2 * textRect.height || 24) * this.nowZoom;
	           textarea.style.width = textareaWidth + "px";
	           textarea.style.height = textareaHeight + "px";
	           var textareaMaxWidth = 1.2 * nodeRect.width * this.nowZoom;
	           textarea.style.maxWidth = textareaMaxWidth + "px";
	           textarea.style.lineHeight = (1.2 * textRect.lineHeight || 14.4) + "px";
	           textarea.style.border = "1px dashed #2e2e2e";
	           textarea.innerHTML = thisNode.model.get("properties.name");
	           this.setShapeModel(thisNode, {properties: {name: ""}});
	           this._dom.appendChild(textarea);
	           this._dom.style.position = "relative";
	           var offestI = 1;
	           var offestP = 0;
	           var posX = 0, posY = 0;
	           if (thisNode instanceof Connector) {//连线
	               if (thisNode.parent && Bpmn.isSubProcess(thisNode.parent)) {
	                   posX = BpmnUtil.parentX(thisNode.parent);
	                   posY = BpmnUtil.parentY(thisNode.parent);
	               }
	               if (lineText) { //有文本时
	                   textarea.style.top = (lineText.position[1] + posY + textRect.height / 2 - textareaHeight / 2) * this.nowZoom + this.group
	                       .position[1] + "px";
	                   textarea.style.left = (lineText.position[0] + posX - textareaWidth / 2) * this.nowZoom +
	                       this.group.position[0] + "px";
	               } else {
	                   var lineMiddlePos = thisNode.middle();
	                   textarea.style.top = (lineMiddlePos[1] + posY + textRect.height / 2 - textareaHeight / 2) * this.nowZoom + this.group
	                       .position[1] + "px";
	                   textarea.style.left = (lineMiddlePos[0] + posX - textareaWidth / 2) * this.nowZoom +
	                       this.group.position[0] + "px";
	               }
	           } else { //节点
	               if (thisNode.parent && Bpmn.isSubProcess(thisNode.parent)) {
	                   posX = nodeRect.x + BpmnUtil.parentX(thisNode.parent);
	                   posY = nodeRect.y + BpmnUtil.parentY(thisNode.parent);
	               } else {
	                   posX = nodeRect.x;
	                   posY = nodeRect.y;
	               }
	               textarea.style.top = (posY - textareaHeight / 2 + offestP * (nodeRect.height - textRect.height /
	                   2)) * this.nowZoom + this.group.position[1] + "px";
	               textarea.style.left = (posX - offestI * (textareaWidth < textareaMaxWidth ? textareaWidth : textareaMaxWidth) / 2) * this.nowZoom +
	                   this.group.position[0] + "px";
	           }
	           textarea.focus();
	           textarea.select();
	           textarea.onkeyup = function() {
	               if (event.keyCode == keyCode.ESCAPE) {
	                   isNotSetText = true;
	                   textarea.blur();
	               } else {
	                   var textRect = textContain.getBoundingRect(textarea.value, "12px");
	                   this._textareaResize(textRect, textarea, textarea.style.maxWidth);
	               }
	           }.bind(this);
	
	           textarea.onblur = function() {
	               if (!isNotSetText) {
	                   var text = this.handleWrap(textarea.value, textarea.style.maxWidth);
	                   this.setShapeModel(thisNode, {properties: {name: text}});
	                   this._trigger('afterEditNode', {target: thisNode});
	               } else {
	                   this.setShapeModel(thisNode, {properties: {name: nodeText}});
	               }
	               textarea.remove();
	           }.bind(this);
	       };
	
	       /**
	        * @private
	        * 创建文本域
	        */
	       fishTopoProto.createTextArea = function () {
	           var textarea = document.createElement("textarea");
	           textarea.style.position = "absolute";
	           textarea.style.padding = "6px";
	           textarea.style.resize = "none";
	           textarea.style.whiteSpace = "pre";
	           textarea.style.lineHeight = "125%";
	           textarea.style.overflow = "hidden";
	           textarea.style.border = "0";
	           textarea.spellcheck = false;
	           return textarea;
	       };
	
	       /**
	        * @private
	        * 处理textarea自动换行
	        */
	       fishTopoProto.handleWrap = function (value, width) {
	           var spanNode = document.createElement("span");
	           spanNode.style.position = "absolute";
	           spanNode.style.overflow = "hidden";
	           spanNode.style.border = "0";
	           spanNode.style.padding = "0";
	           spanNode.style.left = "0";
	           spanNode.style.top = "0";
	           this._dom.appendChild(spanNode);
	           var content = value.split("\n");
	           var result = "";
	           content.forEach(function (val, i) {
	               var valLength = val.length;
	               if (valLength == 0) {
	                   //result += "\n";
	               } else {
	                   var pre = "",
	                       innerVal, tempWidth, conWidth;
	                   for (var innerI = 0; innerI < valLength; innerI++) {
	                       innerVal = val.charAt(innerI);
	                       spanNode.innerHTML = spanNode.innerHTML + innerVal;
	                       tempWidth = spanNode.clientWidth; //获取添加字符后隐藏域的宽度
	                       conWidth = Number(width.substring(0, width.length - 2));
	                       if (tempWidth > conWidth) {
	                           result += pre; //如果追加字符后隐藏域宽度大于TextArea宽度，则表明该字符为下一行字符，
	                           result += "\n";
	                           spanNode.innerHTML = innerVal;
	                           pre = innerVal;
	                       } else if (innerI == valLength - 1) {
	                           result += pre + innerVal; //最后一个字符
	                           if (i < content.length - 1) {
	                               result += "\n";
	                           }
	                           spanNode.innerHTML = "";
	                           pre = "";
	                       } else {
	                           pre += innerVal; //依次追加到pre变量中
	                       }
	
	                   }
	               }
	           });
	           this._dom.removeChild(spanNode);
	           return result;
	       };
	
	       /**
	        * @private
	        * 文本域自适应高宽
	        */
	       fishTopoProto._textareaResize = function (textRect, textarea, width) {
	           var minWidth = 0;
	           textarea.style.width = 0;
	           textarea.style.width = (1.1 * textRect.width) * this.nowZoom + "px";
	           if (width < 60) {
	               minWidth = width;
	           } else {
	               minWidth = 60
	           }
	           if (textRect.width <= minWidth) {
	               textarea.style.width = minWidth + "px";
	           }
	           textarea.style.height = "0px";
	           textarea.style.height = textarea.scrollHeight + 'px';
	           if (textarea.scrollHeight <= 0) {
	               textarea.style.height = "12px";
	           }
	       }
	
	       zrUtil.mixin(FishTopoBpmn, Eventful);
	
	       // ---------对外暴露fishTopoBpmn------------------
	       var idBase = new Date() - 0;
	       var instances = {};
	       var DOM_ATTRIBUTE_KEY = '_fishTopoBpmn_instance_';
	
	       /**
	        * fishTopoBpmn全局对象，如果是amd方式加载，则直接返回
	        * @class fishTopoBpmn
	        * @singleton
	        */
	       var fishTopoBpmn = {
	           /**
	            * 版本号
	            * @type {String}
	            */
	           version: '3.2.0',
	           dependencies: {
	               zrender: '3.0.4'
	           }
	       };
	
	       /**
	        * 初始化dom元素为 bpmn对象
	        * @member fishTopoBpmn
	        * @param {HTMLElement} dom  一个div元素
	        * @param {Object} opts  传递的选项参数
	        * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'
	        * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化
	        * @return {fish.topo.FishTopoBpmn}
	        */
	       fishTopoBpmn.init = function(dom, opts) {
	           if (!dom) {
	               throw new Error('Initialize failed: invalid dom.');
	           }
	
	           opts = opts || {};
	           // Default value
	           zrUtil.defaults(opts, {
	               type: "bpmn",
	               showGridLine: true,
	               gridLineSpacing: 10,
	               beforeDeleteNode: null,  //删除节点之前的事件
	               beforeCreateNode:null,   //创建节点之前的事件
	               beforeDeleteLine: null,  //删除连线之前的事件
	               beforeCreateLine:null,    //创建连线之前的事件
	               scaleable: false,
	               rotatable: false
	           });
	
	           var fishTopoBpmn = new FishTopoBpmn(dom, opts);
	           fishTopoBpmn.init();
	
	           fishTopoBpmn.id = 'ft_' + idBase++;
	           instances[fishTopoBpmn.id] = fishTopoBpmn;
	
	           dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBpmn.id);
	
	           return fishTopoBpmn;
	       };
	
	
	       /**
	        * 获取 dom 容器上的实例。
	        * @member fishTopoBpmn
	        * @param  {HTMLElement} dom 一个div元素
	        * @return {fish.topo.FishTopoBpmn}
	        */
	       fishTopoBpmn.getInstanceByDom = function(dom) {
	           var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
	           return instances[key];
	       };
	
	       /**
	        * 销毁实例，实例销毁后无法再被使用。
	        * @member fishTopoBpmn
	        * @param  {Object|string} chart fishTopoBpmn实例 或 fishTopoBpmn的id
	        */
	       fishTopoBpmn.dispose = function(chart) {
	           var topo;
	           if (zrUtil.isDom(chart)) {
	               topo = fishTopoBpmn.getInstanceByDom(chart);
	           } else if (typeof chart === 'string') {
	               topo = instances[chart];
	           }
	           if ((topo instanceof fishTopoBpmn) && !topo.isDisposed()) {
	               topo.dispose();
	           }
	       };
	       //暴露出去的类 方便用户扩展图元
	       fishTopoBpmn.Bpmn = Bpmn;
	       fishTopoBpmn.BPMNNode = BPMNNode;
	       fishTopoBpmn.graphic = graphic;
	       fishTopoBpmn.BoundingRect = BoundingRect;
	       fishTopoBpmn.BPMNModel = BPMNModel;
	
	       fishTopoBpmn.util = {};
	       zrUtil.each([
	               'map', 'each', 'filter', 'indexOf', 'inherits',
	               'reduce', 'filter', 'bind', 'curry', 'isArray',
	               'isString', 'isObject', 'isFunction', 'extend'
	           ],
	           function(name) {
	               fishTopoBpmn.util[name] = zrUtil[name];
	           }
	       );
	       module.exports = fishTopoBpmn;
	   


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var pathTool = __webpack_require__(5);
	    var round = Math.round;
	    var Path = __webpack_require__(6);
	    var colorTool = __webpack_require__(19);
	    var matrix = __webpack_require__(13);
	    var vector = __webpack_require__(14);
	    var Gradient = __webpack_require__(41);
	    var Draggable = __webpack_require__(42);
	
	    var graphic = {};
	    graphic.Util = zrUtil;
	    graphic.Group = __webpack_require__(43);
	
	    graphic.Image = __webpack_require__(44);
	
	    graphic.Text = __webpack_require__(45);
	
	    graphic.textContain = __webpack_require__(25);
	
	    graphic.Circle = __webpack_require__(46);
	
	    graphic.Sector = __webpack_require__(47);
	
	    graphic.Ring = __webpack_require__(50);
	
	    graphic.Polygon = __webpack_require__(51);
	
	    graphic.Polyline = __webpack_require__(55);
	
	    graphic.Rect = __webpack_require__(56);
	
	    graphic.Line = __webpack_require__(57);
	
	    graphic.BezierCurve = __webpack_require__(58);
	
	    graphic.Arc = __webpack_require__(59);
	
	    graphic.LinearGradient = __webpack_require__(60);
	
	    graphic.RadialGradient = __webpack_require__(61);
	
	    graphic.BoundingRect = __webpack_require__(26);
	    graphic.States = __webpack_require__(62);
	    /**
	     * Extend shape with parameters
	     */
	    graphic.extendShape = function (opts) {
	        return Path.extend(opts);
	    };
	
	    /**
	     * Extend path
	     */
	    graphic.extendPath = function (pathData, opts) {
	        return pathTool.extendFromString(pathData, opts);
	    };
	
	    /**
	     * Create a path element from path data string
	     * @param {string} pathData
	     * @param {Object} opts
	     * @param {module:zrender/core/BoundingRect} rect
	     * @param {string} [layout=cover] 'center' or 'cover'
	     */
	    graphic.makePath = function (pathData, opts, rect, layout) {
	        var path = pathTool.createFromString(pathData, opts);
	        Draggable.call(path);
	        var boundingRect = path.getBoundingRect();
	        if (rect) {
	            var aspect = boundingRect.width / boundingRect.height;
	
	            if (layout === 'center') {
	                // Set rect to center, keep width / height ratio.
	                var width = rect.height * aspect;
	                var height;
	                if (width <= rect.width) {
	                    height = rect.height;
	                }
	                else {
	                    width = rect.width;
	                    height = width / aspect;
	                }
	                var cx = rect.x + rect.width / 2;
	                var cy = rect.y + rect.height / 2;
	
	                rect.x = cx - width / 2;
	                rect.y = cy - height / 2;
	                rect.width = width;
	                rect.height = height;
	            }
	
	            this.resizePath(path, rect);
	        }
	
	        zrUtil.inherits(path, Draggable);
	        return path;
	    };
	
	    graphic.mergePath = pathTool.mergePath;
	
	    /**
	     * Resize a path to fit the rect
	     * @param {module:zrender/graphic/Path} path
	     * @param {Object} rect
	     */
	    graphic.resizePath = function (path, rect) {
	        if (!path.applyTransform) {
	            return;
	        }
	
	        var pathRect = path.getBoundingRect();
	
	        var m = pathRect.calculateTransform(rect);
	
	        path.applyTransform(m);
	    };
	
	    /**
	     * Sub pixel optimize line for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x1]
	     * @param {number} [param.shape.y1]
	     * @param {number} [param.shape.x2]
	     * @param {number} [param.shape.y2]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeLine = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	
	        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
	            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
	        }
	        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
	            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
	        }
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize rect for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x]
	     * @param {number} [param.shape.y]
	     * @param {number} [param.shape.width]
	     * @param {number} [param.shape.height]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeRect = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	        var originX = shape.x;
	        var originY = shape.y;
	        var originWidth = shape.width;
	        var originHeight = shape.height;
	        shape.x = subPixelOptimize(shape.x, lineWidth, true);
	        shape.y = subPixelOptimize(shape.y, lineWidth, true);
	        shape.width = Math.max(
	            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,
	            originWidth === 0 ? 0 : 1
	        );
	        shape.height = Math.max(
	            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,
	            originHeight === 0 ? 0 : 1
	        );
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize for canvas
	     *
	     * @param {number} position Coordinate, such as x, y
	     * @param {number} lineWidth Should be nonnegative integer.
	     * @param {boolean=} positiveOrNegative Default false (negative).
	     * @return {number} Optimized position.
	     */
	    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {
	        // Assure that (position + lineWidth / 2) is near integer edge,
	        // otherwise line will be fuzzy in canvas.
	        var doubledPosition = round(position * 2);
	        return (doubledPosition + round(lineWidth)) % 2 === 0
	            ? doubledPosition / 2
	            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
	    };
	
	    /**
	     * @private
	     */
	    function doSingleEnterHover(el) {
	        if (el.__isHover) {
	            return;
	        }
	        if (el.__hoverStlDirty) {
	            var stroke = el.style.stroke;
	            var fill = el.style.fill;
	
	            // Create hoverStyle on mouseover
	            var hoverStyle = el.__hoverStl;
	            var lift = colorTool.lift;
	            hoverStyle.fill = hoverStyle.fill
	                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));
	            hoverStyle.stroke = hoverStyle.stroke
	                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));
	
	            var normalStyle = {};
	            for (var name in hoverStyle) {
	                if (hoverStyle.hasOwnProperty(name)) {
	                    normalStyle[name] = el.style[name];
	                }
	            }
	
	            el.__normalStl = normalStyle;
	
	            el.__hoverStlDirty = false;
	        }
	        el.setStyle(el.__hoverStl);
	        el.z2 += 1;
	
	        el.__isHover = true;
	    }
	
	    /**
	     * @inner
	     */
	    function doSingleLeaveHover(el) {
	        if (!el.__isHover) {
	            return;
	        }
	
	        var normalStl = el.__normalStl;
	        normalStl && el.setStyle(normalStl);
	        el.z2 -= 1;
	
	        el.__isHover = false;
	    }
	
	    /**
	     * @inner
	     */
	    function doEnterHover(el) {
	        (el.type === 'group' || el.type === 'GroupNode')
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleEnterHover(child);
	                }
	            })
	            : doSingleEnterHover(el);
	    }
	    graphic.doEnterHover = doEnterHover;
	    function doLeaveHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleLeaveHover(child);
	                }
	            })
	            : doSingleLeaveHover(el);
	    }
	    graphic.doLeaveHover = doLeaveHover;
	    /**
	     * @inner
	     */
	    function setElementHoverStl(el, hoverStl) {
	        // If element has sepcified hoverStyle, then use it instead of given hoverStyle
	        // Often used when item group has a label element and it's hoverStyle is different
	        el.__hoverStl = el.hoverStyle || hoverStl || {};
	        el.__hoverStlDirty = true;
	    }
	    graphic.setElementHoverStl = setElementHoverStl;
	    /**
	     * @inner
	     */
	    function onElementMouseOver() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function onElementMouseOut() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doLeaveHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function enterEmphasis() {
	        this.__isEmphasis = true;
	        doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function leaveEmphasis() {
	        this.__isEmphasis = false;
	        doLeaveHover(this);
	    }
	
	    /**
	     * Set hover style of element
	     * @param {module:zrender/Element} el
	     * @param {Object} [hoverStyle]
	     */
	    graphic.setHoverStyle = function (el, hoverStyle) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    setElementHoverStl(child, hoverStyle);
	                }
	            })
	            : setElementHoverStl(el, hoverStyle);
	        // Remove previous bound handlers
	        el.on('mouseover', onElementMouseOver)
	          .on('mouseout', onElementMouseOut);
	
	        // Emphasis, normal can be triggered manually
	        el.on('emphasis', enterEmphasis)
	          .on('normal', leaveEmphasis);
	    };
	
	    graphic.setNormalStyle = function(el, options) {
	        if (el.__normalStl) {
	            for (var name in options) {
	                if (el.__normalStl.hasOwnProperty(name)) {
	                    el.__normalStl[name] = options[name];
	                }
	            }
	        }
	    };
	
	    /**
	     * Set text option in the style
	     * @param {Object} textStyle
	     * @param {module:echarts/model/Model} labelModel
	     * @param {string} color
	     */
	    graphic.setText = function (textStyle, labelModel, color) {
	        var labelPosition = labelModel.getShallow('position') || 'inside';
	        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;
	        var textStyleModel = labelModel.getModel('textStyle');
	        zrUtil.extend(textStyle, {
	            textDistance: labelModel.getShallow('distance') || 5,
	            textFont: textStyleModel.getFont(),
	            textPosition: labelPosition,
	            textFill: textStyleModel.getTextColor() || labelColor
	        });
	    };
	
	    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {
	        var postfix = isUpdate ? 'Update' : '';
	        var duration = animatableModel
	            && animatableModel.getShallow('animationDuration' + postfix);
	        var animationEasing = animatableModel
	            && animatableModel.getShallow('animationEasing' + postfix);
	
	        animatableModel && animatableModel.getShallow('animation')
	            ? el.animateTo(props, duration, animationEasing, cb)
	            : (el.attr(props), cb && cb());
	    }
	    /**
	     * Update graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);
	
	    /**
	     * Init graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.initProps = zrUtil.curry(animateOrSetProps, false);
	
	    /**
	     * Get transform matrix of target (param target),
	     * in coordinate of its ancestor (param ancestor)
	     *
	     * @param {module:zrender/mixin/Transformable} target
	     * @param {module:zrender/mixin/Transformable} ancestor
	     */
	    graphic.getTransform = function (target, ancestor) {
	        var mat = matrix.identity([]);
	
	        while (target && target !== ancestor) {
	            matrix.mul(mat, target.getLocalTransform(), mat);
	            target = target.parent;
	        }
	
	        return mat;
	    };
	
	    /**
	     * Apply transform to an vertex.
	     * @param {Array.<number>} vertex [x, y]
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {Array.<number>} [x, y]
	     */
	    graphic.applyTransform = function (vertex, transform, invert) {
	        if (invert) {
	            transform = matrix.invert([], transform);
	        }
	        return vector.applyTransform([], vertex, transform);
	    };
	
	    /**
	     * @param {string} direction 'left' 'right' 'top' 'bottom'
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
	     */
	    graphic.transformDirection = function (direction, transform, invert) {
	
	        // Pick a base, ensure that transform result will not be (0, 0).
	        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[0]);
	        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[2]);
	
	        var vertex = [
	            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,
	            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0
	        ];
	
	        vertex = graphic.applyTransform(vertex, transform, invert);
	
	        return Math.abs(vertex[0]) > Math.abs(vertex[1])
	            ? (vertex[0] > 0 ? 'right' : 'left')
	            : (vertex[1] > 0 ? 'bottom' : 'top');
	    };
	
	    module.exports = graphic;
	


/***/ }),
/* 4 */
/***/ (function(module, exports) {

	/**
	 * @module zrender/core/util
	 */
	// 用于处理merge时无法遍历Date等对象的问题
	var BUILTIN_OBJECT = {
	  '[object Function]': 1,
	  '[object RegExp]': 1,
	  '[object Date]': 1,
	  '[object Error]': 1,
	  '[object CanvasGradient]': 1,
	  '[object CanvasPattern]': 1,
	  // For node-canvas
	  '[object Image]': 1,
	  '[object Canvas]': 1
	};
	var TYPED_ARRAY = {
	  '[object Int8Array]': 1,
	  '[object Uint8Array]': 1,
	  '[object Uint8ClampedArray]': 1,
	  '[object Int16Array]': 1,
	  '[object Uint16Array]': 1,
	  '[object Int32Array]': 1,
	  '[object Uint32Array]': 1,
	  '[object Float32Array]': 1,
	  '[object Float64Array]': 1
	};
	var objToString = Object.prototype.toString;
	var arrayProto = Array.prototype;
	var nativeForEach = arrayProto.forEach;
	var nativeFilter = arrayProto.filter;
	var nativeSlice = arrayProto.slice;
	var nativeMap = arrayProto.map;
	var nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.
	
	var methods = {};
	
	function $override(name, fn) {
	  methods[name] = fn;
	}
	/**
	 * Those data types can be cloned:
	 *     Plain object, Array, TypedArray, number, string, null, undefined.
	 * Those data types will be assgined using the orginal data:
	 *     BUILTIN_OBJECT
	 * Instance of user defined class will be cloned to a plain object, without
	 * properties in prototype.
	 * Other data types is not supported (not sure what will happen).
	 *
	 * Caution: do not support clone Date, for performance consideration.
	 * (There might be a large number of date in `series.data`).
	 * So date should not be modified in and out of echarts.
	 *
	 * @param {*} source
	 * @return {*} new
	 */
	
	
	function clone(source) {
	  if (source == null || typeof source != 'object') {
	    return source;
	  }
	
	  var result = source;
	  var typeStr = objToString.call(source);
	
	  if (typeStr === '[object Array]') {
	    result = [];
	
	    for (var i = 0, len = source.length; i < len; i++) {
	      result[i] = clone(source[i]);
	    }
	  } else if (TYPED_ARRAY[typeStr]) {
	    var Ctor = source.constructor;
	
	    if (source.constructor.from) {
	      result = Ctor.from(source);
	    } else {
	      result = new Ctor(source.length);
	
	      for (var i = 0, len = source.length; i < len; i++) {
	        result[i] = clone(source[i]);
	      }
	    }
	  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
	    result = {};
	
	    for (var key in source) {
	      if (source.hasOwnProperty(key)) {
	        result[key] = clone(source[key]);
	      }
	    }
	  }
	
	  return result;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} target
	 * @param {*} source
	 * @param {boolean} [overwrite=false]
	 */
	
	
	function merge(target, source, overwrite) {
	  // We should escapse that source is string
	  // and enter for ... in ...
	  if (!isObject(source) || !isObject(target)) {
	    return overwrite ? clone(source) : target;
	  }
	
	  for (var key in source) {
	    if (source.hasOwnProperty(key)) {
	      var targetProp = target[key];
	      var sourceProp = source[key];
	
	      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
	        // 如果需要递归覆盖，就递归调用merge
	        merge(targetProp, sourceProp, overwrite);
	      } else if (overwrite || !(key in target)) {
	        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	        // NOTE，在 target[key] 不存在的时候也是直接覆盖
	        target[key] = clone(source[key], true);
	      }
	    }
	  }
	
	  return target;
	}
	/**
	 * @param {Array} targetAndSources The first item is target, and the rests are source.
	 * @param {boolean} [overwrite=false]
	 * @return {*} target
	 */
	
	
	function mergeAll(targetAndSources, overwrite) {
	  var result = targetAndSources[0];
	
	  for (var i = 1, len = targetAndSources.length; i < len; i++) {
	    result = merge(result, targetAndSources[i], overwrite);
	  }
	
	  return result;
	}
	/**
	 * @param {*} target
	 * @param {*} source
	 * @memberOf module:zrender/core/util
	 */
	
	
	function extend(target, source) {
	  for (var key in source) {
	    if (source.hasOwnProperty(key)) {
	      target[key] = source[key];
	    }
	  }
	
	  return target;
	}
	/**
	 * @param {*} target
	 * @param {*} source
	 * @param {boolean} [overlay=false]
	 * @memberOf module:zrender/core/util
	 */
	
	
	function defaults(target, source, overlay) {
	  for (var key in source) {
	    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
	      target[key] = source[key];
	    }
	  }
	
	  return target;
	}
	
	var createCanvas = function () {
	  return methods.createCanvas();
	};
	
	methods.createCanvas = function () {
	  return document.createElement('canvas');
	}; // FIXME
	
	
	var _ctx;
	
	function getContext() {
	  if (!_ctx) {
	    // Use util.createCanvas instead of createCanvas
	    // because createCanvas may be overwritten in different environment
	    _ctx = createCanvas().getContext('2d');
	  }
	
	  return _ctx;
	}
	/**
	 * 查询数组中元素的index
	 * @memberOf module:zrender/core/util
	 */
	
	
	function indexOf(array, value) {
	  if (array) {
	    if (array.indexOf) {
	      return array.indexOf(value);
	    }
	
	    for (var i = 0, len = array.length; i < len; i++) {
	      if (array[i] === value) {
	        return i;
	      }
	    }
	  }
	
	  return -1;
	}
	/**
	 * 构造类继承关系
	 *
	 * @memberOf module:zrender/core/util
	 * @param {Function} clazz 源类
	 * @param {Function} baseClazz 基类
	 */
	
	
	function inherits(clazz, baseClazz) {
	  var clazzPrototype = clazz.prototype;
	
	  function F() {}
	
	  F.prototype = baseClazz.prototype;
	  clazz.prototype = new F();
	
	  for (var prop in clazzPrototype) {
	    clazz.prototype[prop] = clazzPrototype[prop];
	  }
	
	  clazz.prototype.constructor = clazz;
	  clazz.superClass = baseClazz;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Object|Function} target
	 * @param {Object|Function} sorce
	 * @param {boolean} overlay
	 */
	
	
	function mixin(target, source, overlay) {
	  target = 'prototype' in target ? target.prototype : target;
	  source = 'prototype' in source ? source.prototype : source;
	  defaults(target, source, overlay);
	}
	/**
	 * Consider typed array.
	 * @param {Array|TypedArray} data
	 */
	
	
	function isArrayLike(data) {
	  if (!data) {
	    return;
	  }
	
	  if (typeof data == 'string') {
	    return false;
	  }
	
	  return typeof data.length == 'number';
	}
	/**
	 * 数组或对象遍历
	 * @memberOf module:zrender/core/util
	 * @param {Object|Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 */
	
	
	function each(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.forEach && obj.forEach === nativeForEach) {
	    obj.forEach(cb, context);
	  } else if (obj.length === +obj.length) {
	    for (var i = 0, len = obj.length; i < len; i++) {
	      cb.call(context, obj[i], i, obj);
	    }
	  } else {
	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        cb.call(context, obj[key], key, obj);
	      }
	    }
	  }
	}
	/**
	 * 数组映射
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 * @return {Array}
	 */
	
	
	function map(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.map && obj.map === nativeMap) {
	    return obj.map(cb, context);
	  } else {
	    var result = [];
	
	    for (var i = 0, len = obj.length; i < len; i++) {
	      result.push(cb.call(context, obj[i], i, obj));
	    }
	
	    return result;
	  }
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {Object} [memo]
	 * @param {*} [context]
	 * @return {Array}
	 */
	
	
	function reduce(obj, cb, memo, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.reduce && obj.reduce === nativeReduce) {
	    return obj.reduce(cb, memo, context);
	  } else {
	    for (var i = 0, len = obj.length; i < len; i++) {
	      memo = cb.call(context, memo, obj[i], i, obj);
	    }
	
	    return memo;
	  }
	}
	/**
	 * 数组过滤
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 * @return {Array}
	 */
	
	
	function filter(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.filter && obj.filter === nativeFilter) {
	    return obj.filter(cb, context);
	  } else {
	    var result = [];
	
	    for (var i = 0, len = obj.length; i < len; i++) {
	      if (cb.call(context, obj[i], i, obj)) {
	        result.push(obj[i]);
	      }
	    }
	
	    return result;
	  }
	}
	/**
	 * 数组项查找
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 * @return {*}
	 */
	
	
	function find(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  for (var i = 0, len = obj.length; i < len; i++) {
	    if (cb.call(context, obj[i], i, obj)) {
	      return obj[i];
	    }
	  }
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Function} func
	 * @param {*} context
	 * @return {Function}
	 */
	
	
	function bind(func, context) {
	  var args = nativeSlice.call(arguments, 2);
	  return function () {
	    return func.apply(context, args.concat(nativeSlice.call(arguments)));
	  };
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Function} func
	 * @return {Function}
	 */
	
	
	function curry(func) {
	  var args = nativeSlice.call(arguments, 1);
	  return function () {
	    return func.apply(this, args.concat(nativeSlice.call(arguments)));
	  };
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isArray(value) {
	  return objToString.call(value) === '[object Array]';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isFunction(value) {
	  return typeof value === 'function';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isString(value) {
	  return objToString.call(value) === '[object String]';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return type === 'function' || !!value && type == 'object';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isBuiltInObject(value) {
	  return !!BUILTIN_OBJECT[objToString.call(value)];
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isDom(value) {
	  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';
	}
	/**
	 * Whether is exactly NaN. Notice isNaN('a') returns true.
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function eqNaN(value) {
	  return value !== value;
	}
	/**
	 * If value1 is not null, then return value1, otherwise judget rest of values.
	 * Low performance.
	 * @memberOf module:zrender/core/util
	 * @return {*} Final value
	 */
	
	
	function retrieve(values) {
	  for (var i = 0, len = arguments.length; i < len; i++) {
	    if (arguments[i] != null) {
	      return arguments[i];
	    }
	  }
	}
	
	function retrieve2(value0, value1) {
	  return value0 != null ? value0 : value1;
	}
	
	function retrieve3(value0, value1, value2) {
	  return value0 != null ? value0 : value1 != null ? value1 : value2;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Array} arr
	 * @param {number} startIndex
	 * @param {number} endIndex
	 * @return {Array}
	 */
	
	
	function slice() {
	  return Function.call.apply(nativeSlice, arguments);
	}
	/**
	 * Normalize css liked array configuration
	 * e.g.
	 *  3 => [3, 3, 3, 3]
	 *  [4, 2] => [4, 2, 4, 2]
	 *  [4, 3, 2] => [4, 3, 2, 3]
	 * @param {number|Array.<number>} val
	 * @return {Array.<number>}
	 */
	
	
	function normalizeCssArray(val) {
	  if (typeof val === 'number') {
	    return [val, val, val, val];
	  }
	
	  var len = val.length;
	
	  if (len === 2) {
	    // vertical | horizontal
	    return [val[0], val[1], val[0], val[1]];
	  } else if (len === 3) {
	    // top | horizontal | bottom
	    return [val[0], val[1], val[2], val[1]];
	  }
	
	  return val;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {boolean} condition
	 * @param {string} message
	 */
	
	
	function assert(condition, message) {
	  if (!condition) {
	    throw new Error(message);
	  }
	}
	
	var primitiveKey = '__ec_primitive__';
	/**
	 * Set an object as primitive to be ignored traversing children in clone or merge
	 */
	
	function setAsPrimitive(obj) {
	  obj[primitiveKey] = true;
	}
	
	function isPrimitive(obj) {
	  return obj[primitiveKey];
	}
	/**
	 * @constructor
	 * @param {Object} obj Only apply `ownProperty`.
	 */
	
	
	function HashMap(obj) {
	  obj && each(obj, function (value, key) {
	    this.set(key, value);
	  }, this);
	} // Add prefix to avoid conflict with Object.prototype.
	
	
	var HASH_MAP_PREFIX = '_ec_';
	var HASH_MAP_PREFIX_LENGTH = 4;
	HashMap.prototype = {
	  constructor: HashMap,
	  // Do not provide `has` method to avoid defining what is `has`.
	  // (We usually treat `null` and `undefined` as the same, different
	  // from ES6 Map).
	  get: function (key) {
	    return this[HASH_MAP_PREFIX + key];
	  },
	  set: function (key, value) {
	    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly
	    // used in this case: `var someVal = map.set('a', genVal());`
	
	    return value;
	  },
	  // Although util.each can be performed on this hashMap directly, user
	  // should not use the exposed keys, who are prefixed.
	  each: function (cb, context) {
	    context !== void 0 && (cb = bind(cb, context));
	
	    for (var prefixedKey in this) {
	      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));
	    }
	  },
	  // Do not use this method if performance sensitive.
	  removeKey: function (key) {
	    delete this[HASH_MAP_PREFIX + key];
	  }
	};
	
	function createHashMap(obj) {
	  return new HashMap(obj);
	}
	
	function noop() {}
	
	exports.$override = $override;
	exports.clone = clone;
	exports.merge = merge;
	exports.mergeAll = mergeAll;
	exports.extend = extend;
	exports.defaults = defaults;
	exports.createCanvas = createCanvas;
	exports.getContext = getContext;
	exports.indexOf = indexOf;
	exports.inherits = inherits;
	exports.mixin = mixin;
	exports.isArrayLike = isArrayLike;
	exports.each = each;
	exports.map = map;
	exports.reduce = reduce;
	exports.filter = filter;
	exports.find = find;
	exports.bind = bind;
	exports.curry = curry;
	exports.isArray = isArray;
	exports.isFunction = isFunction;
	exports.isString = isString;
	exports.isObject = isObject;
	exports.isBuiltInObject = isBuiltInObject;
	exports.isDom = isDom;
	exports.eqNaN = eqNaN;
	exports.retrieve = retrieve;
	exports.retrieve2 = retrieve2;
	exports.retrieve3 = retrieve3;
	exports.slice = slice;
	exports.normalizeCssArray = normalizeCssArray;
	exports.assert = assert;
	exports.setAsPrimitive = setAsPrimitive;
	exports.isPrimitive = isPrimitive;
	exports.createHashMap = createHashMap;
	exports.noop = noop;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	var PathProxy = __webpack_require__(29);
	
	var transformPath = __webpack_require__(40);
	
	// command chars
	var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
	var mathSqrt = Math.sqrt;
	var mathSin = Math.sin;
	var mathCos = Math.cos;
	var PI = Math.PI;
	
	var vMag = function (v) {
	  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	};
	
	var vRatio = function (u, v) {
	  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	};
	
	var vAngle = function (u, v) {
	  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
	};
	
	function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
	  var psi = psiDeg * (PI / 180.0);
	  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;
	  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;
	  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
	
	  if (lambda > 1) {
	    rx *= mathSqrt(lambda);
	    ry *= mathSqrt(lambda);
	  }
	
	  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
	  var cxp = f * rx * yp / ry;
	  var cyp = f * -ry * xp / rx;
	  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;
	  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;
	  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
	  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
	  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
	  var dTheta = vAngle(u, v);
	
	  if (vRatio(u, v) <= -1) {
	    dTheta = PI;
	  }
	
	  if (vRatio(u, v) >= 1) {
	    dTheta = 0;
	  }
	
	  if (fs === 0 && dTheta > 0) {
	    dTheta = dTheta - 2 * PI;
	  }
	
	  if (fs === 1 && dTheta < 0) {
	    dTheta = dTheta + 2 * PI;
	  }
	
	  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
	}
	
	function createPathProxyFromString(data) {
	  if (!data) {
	    return [];
	  } // command string
	
	
	  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');
	  var n; // create pipes so that we can split the data
	
	  for (n = 0; n < cc.length; n++) {
	    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
	  } // create array
	
	
	  var arr = cs.split('|'); // init context point
	
	  var cpx = 0;
	  var cpy = 0;
	  var path = new PathProxy();
	  var CMD = PathProxy.CMD;
	  var prevCmd;
	
	  for (n = 1; n < arr.length; n++) {
	    var str = arr[n];
	    var c = str.charAt(0);
	    var off = 0;
	    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
	    var cmd;
	
	    if (p.length > 0 && p[0] === '') {
	      p.shift();
	    }
	
	    for (var i = 0; i < p.length; i++) {
	      p[i] = parseFloat(p[i]);
	    }
	
	    while (off < p.length && !isNaN(p[off])) {
	      if (isNaN(p[0])) {
	        break;
	      }
	
	      var ctlPtx;
	      var ctlPty;
	      var rx;
	      var ry;
	      var psi;
	      var fa;
	      var fs;
	      var x1 = cpx;
	      var y1 = cpy; // convert l, H, h, V, and v to L
	
	      switch (c) {
	        case 'l':
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'L':
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'm':
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.M;
	          path.addData(cmd, cpx, cpy);
	          c = 'l';
	          break;
	
	        case 'M':
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.M;
	          path.addData(cmd, cpx, cpy);
	          c = 'L';
	          break;
	
	        case 'h':
	          cpx += p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'H':
	          cpx = p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'v':
	          cpy += p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'V':
	          cpy = p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'C':
	          cmd = CMD.C;
	          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
	          cpx = p[off - 2];
	          cpy = p[off - 1];
	          break;
	
	        case 'c':
	          cmd = CMD.C;
	          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
	          cpx += p[off - 2];
	          cpy += p[off - 1];
	          break;
	
	        case 'S':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.C) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cmd = CMD.C;
	          x1 = p[off++];
	          y1 = p[off++];
	          cpx = p[off++];
	          cpy = p[off++];
	          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	          break;
	
	        case 's':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.C) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cmd = CMD.C;
	          x1 = cpx + p[off++];
	          y1 = cpy + p[off++];
	          cpx += p[off++];
	          cpy += p[off++];
	          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	          break;
	
	        case 'Q':
	          x1 = p[off++];
	          y1 = p[off++];
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, x1, y1, cpx, cpy);
	          break;
	
	        case 'q':
	          x1 = p[off++] + cpx;
	          y1 = p[off++] + cpy;
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, x1, y1, cpx, cpy);
	          break;
	
	        case 'T':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.Q) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	          break;
	
	        case 't':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.Q) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	          break;
	
	        case 'A':
	          rx = p[off++];
	          ry = p[off++];
	          psi = p[off++];
	          fa = p[off++];
	          fs = p[off++];
	          x1 = cpx, y1 = cpy;
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.A;
	          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
	          break;
	
	        case 'a':
	          rx = p[off++];
	          ry = p[off++];
	          psi = p[off++];
	          fa = p[off++];
	          fs = p[off++];
	          x1 = cpx, y1 = cpy;
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.A;
	          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
	          break;
	      }
	    }
	
	    if (c === 'z' || c === 'Z') {
	      cmd = CMD.Z;
	      path.addData(cmd);
	    }
	
	    prevCmd = cmd;
	  }
	
	  path.toStatic();
	  return path;
	} // TODO Optimize double memory cost problem
	
	
	function createPathOptions(str, opts) {
	  var pathProxy = createPathProxyFromString(str);
	  opts = opts || {};
	
	  opts.buildPath = function (path) {
	    if (path.setData) {
	      path.setData(pathProxy.data); // Svg and vml renderer don't have context
	
	      var ctx = path.getContext();
	
	      if (ctx) {
	        path.rebuildPath(ctx);
	      }
	    } else {
	      var ctx = path;
	      pathProxy.rebuildPath(ctx);
	    }
	  };
	
	  opts.applyTransform = function (m) {
	    transformPath(pathProxy, m);
	    this.dirty(true);
	  };
	
	  return opts;
	}
	/**
	 * Create a Path object from path string data
	 * http://www.w3.org/TR/SVG/paths.html#PathData
	 * @param  {Object} opts Other options
	 */
	
	
	function createFromString(str, opts) {
	  return new Path(createPathOptions(str, opts));
	}
	/**
	 * Create a Path class from path string data
	 * @param  {string} str
	 * @param  {Object} opts Other options
	 */
	
	
	function extendFromString(str, opts) {
	  return Path.extend(createPathOptions(str, opts));
	}
	/**
	 * Merge multiple paths
	 */
	// TODO Apply transform
	// TODO stroke dash
	// TODO Optimize double memory cost problem
	
	
	function mergePath(pathEls, opts) {
	  var pathList = [];
	  var len = pathEls.length;
	
	  for (var i = 0; i < len; i++) {
	    var pathEl = pathEls[i];
	
	    if (!pathEl.path) {
	      pathEl.createPathProxy();
	    }
	
	    if (pathEl.__dirtyPath) {
	      pathEl.buildPath(pathEl.path, pathEl.shape, true);
	    }
	
	    pathList.push(pathEl.path);
	  }
	
	  var pathBundle = new Path(opts); // Need path proxy.
	
	  pathBundle.createPathProxy();
	
	  pathBundle.buildPath = function (path) {
	    path.appendPath(pathList); // Svg and vml renderer don't have context
	
	    var ctx = path.getContext();
	
	    if (ctx) {
	      path.rebuildPath(ctx);
	    }
	  };
	
	  return pathBundle;
	}
	
	exports.createFromString = createFromString;
	exports.extendFromString = extendFromString;
	exports.mergePath = mergePath;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	var Displayable = __webpack_require__(7);
	
	var zrUtil = __webpack_require__(4);
	
	var PathProxy = __webpack_require__(29);
	
	var pathContain = __webpack_require__(32);
	
	var Pattern = __webpack_require__(39);
	
	var getCanvasPattern = Pattern.prototype.getCanvasPattern;
	var abs = Math.abs;
	var pathProxyForDraw = new PathProxy(true);
	/**
	 * @alias module:zrender/graphic/Path
	 * @extends module:zrender/graphic/Displayable
	 * @constructor
	 * @param {Object} opts
	 */
	
	function Path(opts) {
	  Displayable.call(this, opts);
	  /**
	   * @type {module:zrender/core/PathProxy}
	   * @readOnly
	   */
	
	  this.path = null;
	}
	
	Path.prototype = {
	  constructor: Path,
	  type: 'path',
	  __dirtyPath: true,
	  strokeContainThreshold: 5,
	  brush: function (ctx, prevEl) {
	    var style = this.style;
	    var path = this.path || pathProxyForDraw;
	    var hasStroke = style.hasStroke();
	    var hasFill = style.hasFill();
	    var fill = style.fill;
	    var stroke = style.stroke;
	    var hasFillGradient = hasFill && !!fill.colorStops;
	    var hasStrokeGradient = hasStroke && !!stroke.colorStops;
	    var hasFillPattern = hasFill && !!fill.image;
	    var hasStrokePattern = hasStroke && !!stroke.image;
	    style.bind(ctx, this, prevEl);
	    this.setTransform(ctx);
	
	    if (this.__dirty) {
	      var rect; // Update gradient because bounding rect may changed
	
	      if (hasFillGradient) {
	        rect = rect || this.getBoundingRect();
	        this._fillGradient = style.getGradient(ctx, fill, rect);
	      }
	
	      if (hasStrokeGradient) {
	        rect = rect || this.getBoundingRect();
	        this._strokeGradient = style.getGradient(ctx, stroke, rect);
	      }
	    } // Use the gradient or pattern
	
	
	    if (hasFillGradient) {
	      // PENDING If may have affect the state
	      ctx.fillStyle = this._fillGradient;
	    } else if (hasFillPattern) {
	      ctx.fillStyle = getCanvasPattern.call(fill, ctx);
	    }
	
	    if (hasStrokeGradient) {
	      ctx.strokeStyle = this._strokeGradient;
	    } else if (hasStrokePattern) {
	      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
	    }
	
	    var lineDash = style.lineDash;
	    var lineDashOffset = style.lineDashOffset;
	    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy
	
	    var scale = this.getGlobalScale();
	    path.setScale(scale[0], scale[1]); // Proxy context
	    // Rebuild path in following 2 cases
	    // 1. Path is dirty
	    // 2. Path needs javascript implemented lineDash stroking.
	    //    In this case, lineDash information will not be saved in PathProxy
	
	    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
	      path.beginPath(ctx); // Setting line dash before build path
	
	      if (lineDash && !ctxLineDash) {
	        path.setLineDash(lineDash);
	        path.setLineDashOffset(lineDashOffset);
	      }
	
	      this.buildPath(path, this.shape, false); // Clear path dirty flag
	
	      if (this.path) {
	        this.__dirtyPath = false;
	      }
	    } else {
	      // Replay path building
	      ctx.beginPath();
	      this.path.rebuildPath(ctx);
	    }
	
	    hasFill && path.fill(ctx);
	
	    if (lineDash && ctxLineDash) {
	      ctx.setLineDash(lineDash);
	      ctx.lineDashOffset = lineDashOffset;
	    }
	
	    hasStroke && path.stroke(ctx);
	
	    if (lineDash && ctxLineDash) {
	      // PENDING
	      // Remove lineDash
	      ctx.setLineDash([]);
	    }
	
	    this.restoreTransform(ctx); // Draw rect text
	
	    if (style.text != null) {
	      this.drawRectText(ctx, this.getBoundingRect());
	    }
	  },
	  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
	  // Like in circle
	  buildPath: function (ctx, shapeCfg, inBundle) {},
	  createPathProxy: function () {
	    this.path = new PathProxy();
	  },
	  getBoundingRect: function () {
	    var rect = this._rect;
	    var style = this.style;
	    var needsUpdateRect = !rect;
	
	    if (needsUpdateRect) {
	      var path = this.path;
	
	      if (!path) {
	        // Create path on demand.
	        path = this.path = new PathProxy();
	      }
	
	      if (this.__dirtyPath) {
	        path.beginPath();
	        this.buildPath(path, this.shape, false);
	      }
	
	      rect = path.getBoundingRect();
	    }
	
	    this._rect = rect;
	
	    if (style.hasStroke()) {
	      // Needs update rect with stroke lineWidth when
	      // 1. Element changes scale or lineWidth
	      // 2. Shape is changed
	      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
	
	      if (this.__dirty || needsUpdateRect) {
	        rectWithStroke.copy(rect); // FIXME Must after updateTransform
	
	        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical
	
	        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill
	
	        if (!style.hasFill()) {
	          w = Math.max(w, this.strokeContainThreshold || 4);
	        } // Consider line width
	        // Line scale can't be 0;
	
	
	        if (lineScale > 1e-10) {
	          rectWithStroke.width += w / lineScale;
	          rectWithStroke.height += w / lineScale;
	          rectWithStroke.x -= w / lineScale / 2;
	          rectWithStroke.y -= w / lineScale / 2;
	        }
	      } // Return rect with stroke
	
	
	      return rectWithStroke;
	    }
	
	    return rect;
	  },
	  contain: function (x, y) {
	    var localPos = this.transformCoordToLocal(x, y);
	    var rect = this.getBoundingRect();
	    var style = this.style;
	    x = localPos[0];
	    y = localPos[1];
	
	    if (rect.contain(x, y)) {
	      var pathData = this.path.data;
	
	      if (style.hasStroke()) {
	        var lineWidth = style.lineWidth;
	        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;
	
	        if (lineScale > 1e-10) {
	          // Only add extra hover lineWidth when there are no fill
	          if (!style.hasFill()) {
	            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
	          }
	
	          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {
	            return true;
	          }
	        }
	      }
	
	      if (style.hasFill()) {
	        return pathContain.contain(pathData, x, y);
	      }
	    }
	
	    return false;
	  },
	
	  /**
	   * @param  {boolean} dirtyPath
	   */
	  dirty: function (dirtyPath) {
	    if (dirtyPath == null) {
	      dirtyPath = true;
	    } // Only mark dirty, not mark clean
	
	
	    if (dirtyPath) {
	      this.__dirtyPath = dirtyPath;
	      this._rect = null;
	    }
	
	    this.__dirty = true;
	    this.__zr && this.__zr.refresh(); // Used as a clipping path
	
	    if (this.__clipTarget) {
	      this.__clipTarget.dirty();
	    }
	  },
	
	  /**
	   * Alias for animate('shape')
	   * @param {boolean} loop
	   */
	  animateShape: function (loop) {
	    return this.animate('shape', loop);
	  },
	  // Overwrite attrKV
	  attrKV: function (key, value) {
	    // FIXME
	    if (key === 'shape') {
	      this.setShape(value);
	      this.__dirtyPath = true;
	      this._rect = null;
	    } else {
	      Displayable.prototype.attrKV.call(this, key, value);
	    }
	  },
	
	  /**
	   * @param {Object|string} key
	   * @param {*} value
	   */
	  setShape: function (key, value) {
	    var shape = this.shape; // Path from string may not have shape
	
	    if (shape) {
	      if (zrUtil.isObject(key)) {
	        for (var name in key) {
	          if (key.hasOwnProperty(name)) {
	            shape[name] = key[name];
	          }
	        }
	      } else {
	        shape[key] = value;
	      }
	
	      this.dirty(true);
	    }
	
	    return this;
	  },
	  getLineScale: function () {
	    var m = this.transform; // Get the line scale.
	    // Determinant of `m` means how much the area is enlarged by the
	    // transformation. So its square root can be used as a scale factor
	    // for width.
	
	    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
	  }
	};
	/**
	 * 扩展一个 Path element, 比如星形，圆等。
	 * Extend a path element
	 * @param {Object} props
	 * @param {string} props.type Path type
	 * @param {Function} props.init Initialize
	 * @param {Function} props.buildPath Overwrite buildPath method
	 * @param {Object} [props.style] Extended default style config
	 * @param {Object} [props.shape] Extended default shape config
	 */
	
	Path.extend = function (defaults) {
	  var Sub = function (opts) {
	    Path.call(this, opts);
	
	    if (defaults.style) {
	      // Extend default style
	      this.style.extendFrom(defaults.style, false);
	    } // Extend default shape
	
	
	    var defaultShape = defaults.shape;
	
	    if (defaultShape) {
	      this.shape = this.shape || {};
	      var thisShape = this.shape;
	
	      for (var name in defaultShape) {
	        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {
	          thisShape[name] = defaultShape[name];
	        }
	      }
	    }
	
	    defaults.init && defaults.init.call(this, opts);
	  };
	
	  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象
	
	  for (var name in defaults) {
	    // Extending prototype values and methods
	    if (name !== 'style' && name !== 'shape') {
	      Sub.prototype[name] = defaults[name];
	    }
	  }
	
	  return Sub;
	};
	
	zrUtil.inherits(Path, Displayable);
	var _default = Path;
	module.exports = _default;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(4);
	
	var Style = __webpack_require__(8);
	
	var Element = __webpack_require__(9);
	
	var RectText = __webpack_require__(23);
	
	/**
	 * 可绘制的图形基类
	 * Base class of all displayable graphic objects
	 * @module zrender/graphic/Displayable
	 */
	
	/**
	 * @alias module:zrender/graphic/Displayable
	 * @extends module:zrender/Element
	 * @extends module:zrender/graphic/mixin/RectText
	 */
	function Displayable(opts) {
	  opts = opts || {};
	  Element.call(this, opts); // Extend properties
	
	  for (var name in opts) {
	    if (opts.hasOwnProperty(name) && name !== 'style') {
	      this[name] = opts[name];
	    }
	  }
	  /**
	   * @type {module:zrender/graphic/Style}
	   */
	
	
	  this.style = new Style(opts.style, this);
	  this._rect = null; // Shapes for cascade clipping.
	
	  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted
	  // Stateful.call(this, opts);
	}
	
	Displayable.prototype = {
	  constructor: Displayable,
	  type: 'displayable',
	
	  /**
	   * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
	   * Dirty flag. From which painter will determine if this displayable object needs brush
	   * @name module:zrender/graphic/Displayable#__dirty
	   * @type {boolean}
	   */
	  __dirty: true,
	
	  /**
	   * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
	   * If ignore drawing of the displayable object. Mouse event will still be triggered
	   * @name module:/zrender/graphic/Displayable#invisible
	   * @type {boolean}
	   * @default false
	   */
	  invisible: false,
	
	  /**
	   * @name module:/zrender/graphic/Displayable#z
	   * @type {number}
	   * @default 0
	   */
	  z: 0,
	
	  /**
	   * @name module:/zrender/graphic/Displayable#z
	   * @type {number}
	   * @default 0
	   */
	  z2: 0,
	
	  /**
	   * z层level，决定绘画在哪层canvas中
	   * @name module:/zrender/graphic/Displayable#zlevel
	   * @type {number}
	   * @default 0
	   */
	  zlevel: 0,
	
	  /**
	   * 是否可拖拽
	   * @name module:/zrender/graphic/Displayable#draggable
	   * @type {boolean}
	   * @default false
	   */
	  draggable: false,
	
	  /**
	   * 是否正在拖拽
	   * @name module:/zrender/graphic/Displayable#draggable
	   * @type {boolean}
	   * @default false
	   */
	  dragging: false,
	
	  /**
	   * 是否相应鼠标事件
	   * @name module:/zrender/graphic/Displayable#silent
	   * @type {boolean}
	   * @default false
	   */
	  silent: false,
	
	  /**
	   * If enable culling
	   * @type {boolean}
	   * @default false
	   */
	  culling: false,
	
	  /**
	   * Mouse cursor when hovered
	   * @name module:/zrender/graphic/Displayable#cursor
	   * @type {string}
	   */
	  cursor: 'pointer',
	
	  /**
	   * If hover area is bounding rect
	   * @name module:/zrender/graphic/Displayable#rectHover
	   * @type {string}
	   */
	  rectHover: false,
	
	  /**
	   * Render the element progressively when the value >= 0,
	   * usefull for large data.
	   * @type {number}
	   */
	  progressive: -1,
	  beforeBrush: function (ctx) {},
	  afterBrush: function (ctx) {},
	
	  /**
	   * 图形绘制方法
	   * @param {CanvasRenderingContext2D} ctx
	   */
	  // Interface
	  brush: function (ctx, prevEl) {},
	
	  /**
	   * 获取最小包围盒
	   * @return {module:zrender/core/BoundingRect}
	   */
	  // Interface
	  getBoundingRect: function () {},
	
	  /**
	   * 判断坐标 x, y 是否在图形上
	   * If displayable element contain coord x, y
	   * @param  {number} x
	   * @param  {number} y
	   * @return {boolean}
	   */
	  contain: function (x, y) {
	    return this.rectContain(x, y);
	  },
	
	  /**
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  traverse: function (cb, context) {
	    cb.call(context, this);
	  },
	
	  /**
	   * 判断坐标 x, y 是否在图形的包围盒上
	   * If bounding rect of element contain coord x, y
	   * @param  {number} x
	   * @param  {number} y
	   * @return {boolean}
	   */
	  rectContain: function (x, y) {
	    var coord = this.transformCoordToLocal(x, y);
	    var rect = this.getBoundingRect();
	    return rect.contain(coord[0], coord[1]);
	  },
	
	  /**
	   * 标记图形元素为脏，并且在下一帧重绘
	   * Mark displayable element dirty and refresh next frame
	   */
	  dirty: function () {
	    this.__dirty = true;
	    this._rect = null;
	    this.__zr && this.__zr.refresh();
	  },
	
	  /**
	   * 图形是否会触发事件
	   * If displayable object binded any event
	   * @return {boolean}
	   */
	  // TODO, 通过 bind 绑定的事件
	  // isSilent: function () {
	  //     return !(
	  //         this.hoverable || this.draggable
	  //         || this.onmousemove || this.onmouseover || this.onmouseout
	  //         || this.onmousedown || this.onmouseup || this.onclick
	  //         || this.ondragenter || this.ondragover || this.ondragleave
	  //         || this.ondrop
	  //     );
	  // },
	
	  /**
	   * Alias for animate('style')
	   * @param {boolean} loop
	   */
	  animateStyle: function (loop) {
	    return this.animate('style', loop);
	  },
	  attrKV: function (key, value) {
	    if (key !== 'style') {
	      Element.prototype.attrKV.call(this, key, value);
	    } else {
	      this.style.set(value);
	    }
	  },
	
	  /**
	   * @param {Object|string} key
	   * @param {*} value
	   */
	  setStyle: function (key, value) {
	    this.style.set(key, value);
	    this.dirty(false);
	    return this;
	  },
	
	  /**
	   * Use given style object
	   * @param  {Object} obj
	   */
	  useStyle: function (obj) {
	    this.style = new Style(obj, this);
	    this.dirty(false);
	    return this;
	  }
	};
	zrUtil.inherits(Displayable, Element);
	zrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);
	
	var _default = Displayable;
	module.exports = _default;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
	// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);
	
	var Style = function (opts, host) {
	  this.extendFrom(opts, false);
	  this.host = host;
	};
	
	function createLinearGradient(ctx, obj, rect) {
	  var x = obj.x == null ? 0 : obj.x;
	  var x2 = obj.x2 == null ? 1 : obj.x2;
	  var y = obj.y == null ? 0 : obj.y;
	  var y2 = obj.y2 == null ? 0 : obj.y2;
	
	  if (!obj.global) {
	    x = x * rect.width + rect.x;
	    x2 = x2 * rect.width + rect.x;
	    y = y * rect.height + rect.y;
	    y2 = y2 * rect.height + rect.y;
	  }
	
	  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
	  return canvasGradient;
	}
	
	function createRadialGradient(ctx, obj, rect) {
	  var width = rect.width;
	  var height = rect.height;
	  var min = Math.min(width, height);
	  var x = obj.x == null ? 0.5 : obj.x;
	  var y = obj.y == null ? 0.5 : obj.y;
	  var r = obj.r == null ? 0.5 : obj.r;
	
	  if (!obj.global) {
	    x = x * width + rect.x;
	    y = y * height + rect.y;
	    r = r * min;
	  }
	
	  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
	  return canvasGradient;
	}
	
	Style.prototype = {
	  constructor: Style,
	
	  /**
	   * @type {module:zrender/graphic/Displayable}
	   */
	  host: null,
	
	  /**
	   * @type {string}
	   */
	  fill: '#000',
	
	  /**
	   * @type {string}
	   */
	  stroke: null,
	
	  /**
	   * @type {number}
	   */
	  opacity: 1,
	
	  /**
	   * @type {Array.<number>}
	   */
	  lineDash: null,
	
	  /**
	   * @type {number}
	   */
	  lineDashOffset: 0,
	
	  /**
	   * @type {number}
	   */
	  shadowBlur: 0,
	
	  /**
	   * @type {number}
	   */
	  shadowOffsetX: 0,
	
	  /**
	   * @type {number}
	   */
	  shadowOffsetY: 0,
	
	  /**
	   * @type {number}
	   */
	  lineWidth: 1,
	
	  /**
	   * If stroke ignore scale
	   * @type {Boolean}
	   */
	  strokeNoScale: false,
	  // Bounding rect text configuration
	  // Not affected by element transform
	
	  /**
	   * @type {string}
	   */
	  text: null,
	
	  /**
	   * If `fontSize` or `fontFamily` exists, `font` will be reset by
	   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
	   * So do not visit it directly in upper application (like echarts),
	   * but use `contain/text#makeFont` instead.
	   * @type {string}
	   */
	  font: null,
	
	  /**
	   * The same as font. Use font please.
	   * @deprecated
	   * @type {string}
	   */
	  textFont: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * @type {string}
	   */
	  fontStyle: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * @type {string}
	   */
	  fontWeight: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * Should be 12 but not '12px'.
	   * @type {number}
	   */
	  fontSize: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * @type {string}
	   */
	  fontFamily: null,
	
	  /**
	   * Reserved for special functinality, like 'hr'.
	   * @type {string}
	   */
	  textTag: null,
	
	  /**
	   * @type {string}
	   */
	  textFill: '#000',
	
	  /**
	   * @type {string}
	   */
	  textStroke: null,
	
	  /**
	   * @type {number}
	   */
	  textWidth: null,
	
	  /**
	   * Only for textBackground.
	   * @type {number}
	   */
	  textHeight: null,
	
	  /**
	   * textStroke may be set as some color as a default
	   * value in upper applicaion, where the default value
	   * of textStrokeWidth should be 0 to make sure that
	   * user can choose to do not use text stroke.
	   * @type {number}
	   */
	  textStrokeWidth: 0,
	
	  /**
	   * @type {number}
	   */
	  textLineHeight: null,
	
	  /**
	   * 'inside', 'left', 'right', 'top', 'bottom'
	   * [x, y]
	   * Based on x, y of rect.
	   * @type {string|Array.<number>}
	   * @default 'inside'
	   */
	  textPosition: 'inside',
	
	  /**
	   * If not specified, use the boundingRect of a `displayable`.
	   * @type {Object}
	   */
	  textRect: null,
	
	  /**
	   * [x, y]
	   * @type {Array.<number>}
	   */
	  textOffset: null,
	
	  /**
	   * @type {string}
	   */
	  textAlign: null,
	
	  /**
	   * @type {string}
	   */
	  textVerticalAlign: null,
	
	  /**
	   * @type {number}
	   */
	  textDistance: 5,
	
	  /**
	   * @type {string}
	   */
	  textShadowColor: 'transparent',
	
	  /**
	   * @type {number}
	   */
	  textShadowBlur: 0,
	
	  /**
	   * @type {number}
	   */
	  textShadowOffsetX: 0,
	
	  /**
	   * @type {number}
	   */
	  textShadowOffsetY: 0,
	
	  /**
	   * @type {string}
	   */
	  textBoxShadowColor: 'transparent',
	
	  /**
	   * @type {number}
	   */
	  textBoxShadowBlur: 0,
	
	  /**
	   * @type {number}
	   */
	  textBoxShadowOffsetX: 0,
	
	  /**
	   * @type {number}
	   */
	  textBoxShadowOffsetY: 0,
	
	  /**
	   * Whether transform text.
	   * Only useful in Path and Image element
	   * @type {boolean}
	   */
	  transformText: false,
	
	  /**
	   * Text rotate around position of Path or Image
	   * Only useful in Path and Image element and transformText is false.
	   */
	  textRotation: 0,
	
	  /**
	   * Text origin of text rotation, like [10, 40].
	   * Based on x, y of rect.
	   * Useful in label rotation of circular symbol.
	   * By default, this origin is textPosition.
	   * Can be 'center'.
	   * @type {string|Array.<number>}
	   */
	  textOrigin: null,
	
	  /**
	   * @type {string}
	   */
	  textBackgroundColor: null,
	
	  /**
	   * @type {string}
	   */
	  textBorderColor: null,
	
	  /**
	   * @type {number}
	   */
	  textBorderWidth: 0,
	
	  /**
	   * @type {number}
	   */
	  textBorderRadius: 0,
	
	  /**
	   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
	   * @type {number|Array.<number>}
	   */
	  textPadding: null,
	
	  /**
	   * Text styles for rich text.
	   * @type {Object}
	   */
	  rich: null,
	
	  /**
	   * {outerWidth, outerHeight, ellipsis, placeholder}
	   * @type {Object}
	   */
	  truncate: null,
	
	  /**
	   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
	   * @type {string}
	   */
	  blend: null,
	
	  /**
	   * @param {CanvasRenderingContext2D} ctx
	   */
	  bind: function (ctx, el, prevEl) {
	    var style = this;
	    var prevStyle = prevEl && prevEl.style;
	    var firstDraw = !prevStyle;
	
	    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	      var prop = STYLE_COMMON_PROPS[i];
	      var styleName = prop[0];
	
	      if (firstDraw || style[styleName] !== prevStyle[styleName]) {
	        // FIXME Invalid property value will cause style leak from previous element.
	        ctx[styleName] = style[styleName] || prop[1];
	      }
	    }
	
	    if (firstDraw || style.fill !== prevStyle.fill) {
	      ctx.fillStyle = style.fill;
	    }
	
	    if (firstDraw || style.stroke !== prevStyle.stroke) {
	      ctx.strokeStyle = style.stroke;
	    }
	
	    if (firstDraw || style.opacity !== prevStyle.opacity) {
	      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
	    }
	
	    if (firstDraw || style.blend !== prevStyle.blend) {
	      ctx.globalCompositeOperation = style.blend || 'source-over';
	    }
	
	    if (this.hasStroke()) {
	      var lineWidth = style.lineWidth;
	      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
	    }
	  },
	  hasFill: function () {
	    var fill = this.fill;
	    return fill != null && fill !== 'none';
	  },
	  hasStroke: function () {
	    var stroke = this.stroke;
	    return stroke != null && stroke !== 'none' && this.lineWidth > 0;
	  },
	
	  /**
	   * Extend from other style
	   * @param {zrender/graphic/Style} otherStyle
	   * @param {boolean} overwrite true: overwrirte any way.
	   *                            false: overwrite only when !target.hasOwnProperty
	   *                            others: overwrite when property is not null/undefined.
	   */
	  extendFrom: function (otherStyle, overwrite) {
	    if (otherStyle) {
	      for (var name in otherStyle) {
	        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {
	          this[name] = otherStyle[name];
	        }
	      }
	    }
	  },
	
	  /**
	   * Batch setting style with a given object
	   * @param {Object|string} obj
	   * @param {*} [obj]
	   */
	  set: function (obj, value) {
	    if (typeof obj === 'string') {
	      this[obj] = value;
	    } else {
	      this.extendFrom(obj, true);
	    }
	  },
	
	  /**
	   * Clone
	   * @return {zrender/graphic/Style} [description]
	   */
	  clone: function () {
	    var newStyle = new this.constructor();
	    newStyle.extendFrom(this, true);
	    return newStyle;
	  },
	  getGradient: function (ctx, obj, rect) {
	    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
	    var canvasGradient = method(ctx, obj, rect);
	    var colorStops = obj.colorStops;
	
	    for (var i = 0; i < colorStops.length; i++) {
	      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
	    }
	
	    return canvasGradient;
	  }
	};
	var styleProto = Style.prototype;
	
	for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	  var prop = STYLE_COMMON_PROPS[i];
	
	  if (!(prop[0] in styleProto)) {
	    styleProto[prop[0]] = prop[1];
	  }
	} // Provide for others
	
	
	Style.getGradient = styleProto.getGradient;
	var _default = Style;
	module.exports = _default;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	var guid = __webpack_require__(10);
	
	var Eventful = __webpack_require__(11);
	
	var Transformable = __webpack_require__(12);
	
	var Animatable = __webpack_require__(15);
	
	var zrUtil = __webpack_require__(4);
	
	/**
	 * @alias module:zrender/Element
	 * @constructor
	 * @extends {module:zrender/mixin/Animatable}
	 * @extends {module:zrender/mixin/Transformable}
	 * @extends {module:zrender/mixin/Eventful}
	 */
	var Element = function (opts) {
	  // jshint ignore:line
	  Transformable.call(this, opts);
	  Eventful.call(this, opts);
	  Animatable.call(this, opts);
	  /**
	   * 画布元素ID
	   * @type {string}
	   */
	
	  this.id = opts.id || guid();
	};
	
	Element.prototype = {
	  /**
	   * 元素类型
	   * Element type
	   * @type {string}
	   */
	  type: 'element',
	
	  /**
	   * 元素名字
	   * Element name
	   * @type {string}
	   */
	  name: '',
	
	  /**
	   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
	   * ZRender instance will be assigned when element is associated with zrender
	   * @name module:/zrender/Element#__zr
	   * @type {module:zrender/ZRender}
	   */
	  __zr: null,
	
	  /**
	   * 图形是否忽略，为true时忽略图形的绘制以及事件触发
	   * If ignore drawing and events of the element object
	   * @name module:/zrender/Element#ignore
	   * @type {boolean}
	   * @default false
	   */
	  ignore: false,
	
	  /**
	   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
	   * 该路径会继承被裁减对象的变换
	   * @type {module:zrender/graphic/Path}
	   * @see http://www.w3.org/TR/2dcontext/#clipping-region
	   * @readOnly
	   */
	  clipPath: null,
	
	  /**
	   * Drift element
	   * @param  {number} dx dx on the global space
	   * @param  {number} dy dy on the global space
	   */
	  drift: function (dx, dy) {
	    switch (this.draggable) {
	      case 'horizontal':
	        dy = 0;
	        break;
	
	      case 'vertical':
	        dx = 0;
	        break;
	    }
	
	    var m = this.transform;
	
	    if (!m) {
	      m = this.transform = [1, 0, 0, 1, 0, 0];
	    }
	
	    m[4] += dx;
	    m[5] += dy;
	    this.decomposeTransform();
	    this.dirty(false);
	  },
	
	  /**
	   * Hook before update
	   */
	  beforeUpdate: function () {},
	
	  /**
	   * Hook after update
	   */
	  afterUpdate: function () {},
	
	  /**
	   * Update each frame
	   */
	  update: function () {
	    this.updateTransform();
	  },
	
	  /**
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  traverse: function (cb, context) {},
	
	  /**
	   * @protected
	   */
	  attrKV: function (key, value) {
	    if (key === 'position' || key === 'scale' || key === 'origin') {
	      // Copy the array
	      if (value) {
	        var target = this[key];
	
	        if (!target) {
	          target = this[key] = [];
	        }
	
	        target[0] = value[0];
	        target[1] = value[1];
	      }
	    } else {
	      this[key] = value;
	    }
	  },
	
	  /**
	   * Hide the element
	   */
	  hide: function () {
	    this.ignore = true;
	    this.__zr && this.__zr.refresh();
	  },
	
	  /**
	   * Show the element
	   */
	  show: function () {
	    this.ignore = false;
	    this.__zr && this.__zr.refresh();
	  },
	
	  /**
	   * @param {string|Object} key
	   * @param {*} value
	   */
	  attr: function (key, value) {
	    if (typeof key === 'string') {
	      this.attrKV(key, value);
	    } else if (zrUtil.isObject(key)) {
	      for (var name in key) {
	        if (key.hasOwnProperty(name)) {
	          this.attrKV(name, key[name]);
	        }
	      }
	    }
	
	    this.dirty(false);
	    return this;
	  },
	
	  /**
	   * @param {module:zrender/graphic/Path} clipPath
	   */
	  setClipPath: function (clipPath) {
	    var zr = this.__zr;
	
	    if (zr) {
	      clipPath.addSelfToZr(zr);
	    } // Remove previous clip path
	
	
	    if (this.clipPath && this.clipPath !== clipPath) {
	      this.removeClipPath();
	    }
	
	    this.clipPath = clipPath;
	    clipPath.__zr = zr;
	    clipPath.__clipTarget = this;
	    this.dirty(false);
	  },
	
	  /**
	   */
	  removeClipPath: function () {
	    var clipPath = this.clipPath;
	
	    if (clipPath) {
	      if (clipPath.__zr) {
	        clipPath.removeSelfFromZr(clipPath.__zr);
	      }
	
	      clipPath.__zr = null;
	      clipPath.__clipTarget = null;
	      this.clipPath = null;
	      this.dirty(false);
	    }
	  },
	
	  /**
	   * Add self from zrender instance.
	   * Not recursively because it will be invoked when element added to storage.
	   * @param {module:zrender/ZRender} zr
	   */
	  addSelfToZr: function (zr) {
	    this.__zr = zr; // 添加动画
	
	    var animators = this.animators;
	
	    if (animators) {
	      for (var i = 0; i < animators.length; i++) {
	        zr.animation.addAnimator(animators[i]);
	      }
	    }
	
	    if (this.clipPath) {
	      this.clipPath.addSelfToZr(zr);
	    }
	  },
	
	  /**
	   * Remove self from zrender instance.
	   * Not recursively because it will be invoked when element added to storage.
	   * @param {module:zrender/ZRender} zr
	   */
	  removeSelfFromZr: function (zr) {
	    this.__zr = null; // 移除动画
	
	    var animators = this.animators;
	
	    if (animators) {
	      for (var i = 0; i < animators.length; i++) {
	        zr.animation.removeAnimator(animators[i]);
	      }
	    }
	
	    if (this.clipPath) {
	      this.clipPath.removeSelfFromZr(zr);
	    }
	  }
	};
	zrUtil.mixin(Element, Animatable);
	zrUtil.mixin(Element, Transformable);
	zrUtil.mixin(Element, Eventful);
	var _default = Element;
	module.exports = _default;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	/**
	 * zrender: 生成唯一id
	 *
	 * @author errorrik (errorrik@gmail.com)
	 */
	var idStart = 0x0907;
	
	function _default() {
	  return idStart++;
	}
	
	module.exports = _default;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	/**
	 * 事件扩展
	 * @module zrender/mixin/Eventful
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	var arrySlice = Array.prototype.slice;
	/**
	 * 事件分发器
	 * @alias module:zrender/mixin/Eventful
	 * @constructor
	 */
	
	var Eventful = function () {
	  this._$handlers = {};
	};
	
	Eventful.prototype = {
	  constructor: Eventful,
	
	  /**
	   * 单次触发绑定，trigger后销毁
	   *
	   * @param {string} event 事件名
	   * @param {Function} handler 响应函数
	   * @param {Object} context
	   */
	  one: function (event, handler, context) {
	    var _h = this._$handlers;
	
	    if (!handler || !event) {
	      return this;
	    }
	
	    if (!_h[event]) {
	      _h[event] = [];
	    }
	
	    for (var i = 0; i < _h[event].length; i++) {
	      if (_h[event][i].h === handler) {
	        return this;
	      }
	    }
	
	    _h[event].push({
	      h: handler,
	      one: true,
	      ctx: context || this
	    });
	
	    return this;
	  },
	
	  /**
	   * 绑定事件
	   * @param {string} event 事件名
	   * @param {Function} handler 事件处理函数
	   * @param {Object} [context]
	   */
	  on: function (event, handler, context) {
	    var _h = this._$handlers;
	
	    if (!handler || !event) {
	      return this;
	    }
	
	    if (!_h[event]) {
	      _h[event] = [];
	    }
	
	    for (var i = 0; i < _h[event].length; i++) {
	      if (_h[event][i].h === handler) {
	        return this;
	      }
	    }
	
	    _h[event].push({
	      h: handler,
	      one: false,
	      ctx: context || this
	    });
	
	    return this;
	  },
	
	  /**
	   * 是否绑定了事件
	   * @param  {string}  event
	   * @return {boolean}
	   */
	  isSilent: function (event) {
	    var _h = this._$handlers;
	    return _h[event] && _h[event].length;
	  },
	
	  /**
	   * 解绑事件
	   * @param {string} event 事件名
	   * @param {Function} [handler] 事件处理函数
	   */
	  off: function (event, handler) {
	    var _h = this._$handlers;
	
	    if (!event) {
	      this._$handlers = {};
	      return this;
	    }
	
	    if (handler) {
	      if (_h[event]) {
	        var newList = [];
	
	        for (var i = 0, l = _h[event].length; i < l; i++) {
	          if (_h[event][i]['h'] != handler) {
	            newList.push(_h[event][i]);
	          }
	        }
	
	        _h[event] = newList;
	      }
	
	      if (_h[event] && _h[event].length === 0) {
	        delete _h[event];
	      }
	    } else {
	      delete _h[event];
	    }
	
	    return this;
	  },
	
	  /**
	   * 事件分发
	   *
	   * @param {string} type 事件类型
	   */
	  trigger: function (type) {
	    if (this._$handlers[type]) {
	      var args = arguments;
	      var argLen = args.length;
	
	      if (argLen > 3) {
	        args = arrySlice.call(args, 1);
	      }
	
	      var _h = this._$handlers[type];
	      var len = _h.length;
	
	      for (var i = 0; i < len;) {
	        // Optimize advise from backbone
	        switch (argLen) {
	          case 1:
	            _h[i]['h'].call(_h[i]['ctx']);
	
	            break;
	
	          case 2:
	            _h[i]['h'].call(_h[i]['ctx'], args[1]);
	
	            break;
	
	          case 3:
	            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
	
	            break;
	
	          default:
	            // have more than 2 given arguments
	            _h[i]['h'].apply(_h[i]['ctx'], args);
	
	            break;
	        }
	
	        if (_h[i]['one']) {
	          _h.splice(i, 1);
	
	          len--;
	        } else {
	          i++;
	        }
	      }
	    }
	
	    return this;
	  },
	
	  /**
	   * 带有context的事件分发, 最后一个参数是事件回调的context
	   * @param {string} type 事件类型
	   */
	  triggerWithContext: function (type) {
	    if (this._$handlers[type]) {
	      var args = arguments;
	      var argLen = args.length;
	
	      if (argLen > 4) {
	        args = arrySlice.call(args, 1, args.length - 1);
	      }
	
	      var ctx = args[args.length - 1];
	      var _h = this._$handlers[type];
	      var len = _h.length;
	
	      for (var i = 0; i < len;) {
	        // Optimize advise from backbone
	        switch (argLen) {
	          case 1:
	            _h[i]['h'].call(ctx);
	
	            break;
	
	          case 2:
	            _h[i]['h'].call(ctx, args[1]);
	
	            break;
	
	          case 3:
	            _h[i]['h'].call(ctx, args[1], args[2]);
	
	            break;
	
	          default:
	            // have more than 2 given arguments
	            _h[i]['h'].apply(ctx, args);
	
	            break;
	        }
	
	        if (_h[i]['one']) {
	          _h.splice(i, 1);
	
	          len--;
	        } else {
	          i++;
	        }
	      }
	    }
	
	    return this;
	  }
	}; // 对象可以通过 onxxxx 绑定事件
	
	/**
	 * @event module:zrender/mixin/Eventful#onclick
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmouseover
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmouseout
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmousemove
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmousewheel
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmousedown
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmouseup
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondrag
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragstart
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragend
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragenter
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragleave
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragover
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondrop
	 * @type {Function}
	 * @default null
	 */
	
	var _default = Eventful;
	module.exports = _default;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	var matrix = __webpack_require__(13);
	
	var vector = __webpack_require__(14);
	
	/**
	 * 提供变换扩展
	 * @module zrender/mixin/Transformable
	 * @author pissang (https://www.github.com/pissang)
	 */
	var mIdentity = matrix.identity;
	var EPSILON = 5e-5;
	
	function isNotAroundZero(val) {
	  return val > EPSILON || val < -EPSILON;
	}
	/**
	 * @alias module:zrender/mixin/Transformable
	 * @constructor
	 */
	
	
	var Transformable = function (opts) {
	  opts = opts || {}; // If there are no given position, rotation, scale
	
	  if (!opts.position) {
	    /**
	     * 平移
	     * @type {Array.<number>}
	     * @default [0, 0]
	     */
	    this.position = [0, 0];
	  }
	
	  if (opts.rotation == null) {
	    /**
	     * 旋转
	     * @type {Array.<number>}
	     * @default 0
	     */
	    this.rotation = 0;
	  }
	
	  if (!opts.scale) {
	    /**
	     * 缩放
	     * @type {Array.<number>}
	     * @default [1, 1]
	     */
	    this.scale = [1, 1];
	  }
	  /**
	   * 旋转和缩放的原点
	   * @type {Array.<number>}
	   * @default null
	   */
	
	
	  this.origin = this.origin || null;
	};
	
	var transformableProto = Transformable.prototype;
	transformableProto.transform = null;
	/**
	 * 判断是否需要有坐标变换
	 * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
	 */
	
	transformableProto.needLocalTransform = function () {
	  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
	};
	
	transformableProto.updateTransform = function () {
	  var parent = this.parent;
	  var parentHasTransform = parent && parent.transform;
	  var needLocalTransform = this.needLocalTransform();
	  var m = this.transform;
	
	  if (!(needLocalTransform || parentHasTransform)) {
	    m && mIdentity(m);
	    return;
	  }
	
	  m = m || matrix.create();
	
	  if (needLocalTransform) {
	    this.getLocalTransform(m);
	  } else {
	    mIdentity(m);
	  } // 应用父节点变换
	
	
	  if (parentHasTransform) {
	    if (needLocalTransform) {
	      matrix.mul(m, parent.transform, m);
	    } else {
	      matrix.copy(m, parent.transform);
	    }
	  } // 保存这个变换矩阵
	
	
	  this.transform = m;
	  this.invTransform = this.invTransform || matrix.create();
	  matrix.invert(this.invTransform, m);
	};
	
	transformableProto.getLocalTransform = function (m) {
	  return Transformable.getLocalTransform(this, m);
	};
	/**
	 * 将自己的transform应用到context上
	 * @param {CanvasRenderingContext2D} ctx
	 */
	
	
	transformableProto.setTransform = function (ctx) {
	  var m = this.transform;
	  var dpr = ctx.dpr || 1;
	
	  if (m) {
	    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
	  } else {
	    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	  }
	};
	
	transformableProto.restoreTransform = function (ctx) {
	  var dpr = ctx.dpr || 1;
	  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	};
	
	var tmpTransform = [];
	/**
	 * 分解`transform`矩阵到`position`, `rotation`, `scale`
	 */
	
	transformableProto.decomposeTransform = function () {
	  if (!this.transform) {
	    return;
	  }
	
	  var parent = this.parent;
	  var m = this.transform;
	
	  if (parent && parent.transform) {
	    // Get local transform and decompose them to position, scale, rotation
	    matrix.mul(tmpTransform, parent.invTransform, m);
	    m = tmpTransform;
	  }
	
	  var sx = m[0] * m[0] + m[1] * m[1];
	  var sy = m[2] * m[2] + m[3] * m[3];
	  var position = this.position;
	  var scale = this.scale;
	
	  if (isNotAroundZero(sx - 1)) {
	    sx = Math.sqrt(sx);
	  }
	
	  if (isNotAroundZero(sy - 1)) {
	    sy = Math.sqrt(sy);
	  }
	
	  if (m[0] < 0) {
	    sx = -sx;
	  }
	
	  if (m[3] < 0) {
	    sy = -sy;
	  }
	
	  position[0] = m[4];
	  position[1] = m[5];
	  scale[0] = sx;
	  scale[1] = sy;
	  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
	};
	/**
	 * Get global scale
	 * @return {Array.<number>}
	 */
	
	
	transformableProto.getGlobalScale = function () {
	  var m = this.transform;
	
	  if (!m) {
	    return [1, 1];
	  }
	
	  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
	  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
	
	  if (m[0] < 0) {
	    sx = -sx;
	  }
	
	  if (m[3] < 0) {
	    sy = -sy;
	  }
	
	  return [sx, sy];
	};
	/**
	 * 变换坐标位置到 shape 的局部坐标空间
	 * @method
	 * @param {number} x
	 * @param {number} y
	 * @return {Array.<number>}
	 */
	
	
	transformableProto.transformCoordToLocal = function (x, y) {
	  var v2 = [x, y];
	  var invTransform = this.invTransform;
	
	  if (invTransform) {
	    vector.applyTransform(v2, v2, invTransform);
	  }
	
	  return v2;
	};
	/**
	 * 变换局部坐标位置到全局坐标空间
	 * @method
	 * @param {number} x
	 * @param {number} y
	 * @return {Array.<number>}
	 */
	
	
	transformableProto.transformCoordToGlobal = function (x, y) {
	  var v2 = [x, y];
	  var transform = this.transform;
	
	  if (transform) {
	    vector.applyTransform(v2, v2, transform);
	  }
	
	  return v2;
	};
	/**
	 * @static
	 * @param {Object} target
	 * @param {Array.<number>} target.origin
	 * @param {number} target.rotation
	 * @param {Array.<number>} target.position
	 * @param {Array.<number>} [m]
	 */
	
	
	Transformable.getLocalTransform = function (target, m) {
	  m = m || [];
	  mIdentity(m);
	  var origin = target.origin;
	  var scale = target.scale || [1, 1];
	  var rotation = target.rotation || 0;
	  var position = target.position || [0, 0];
	
	  if (origin) {
	    // Translate to origin
	    m[4] -= origin[0];
	    m[5] -= origin[1];
	  }
	
	  matrix.scale(m, m, scale);
	
	  if (rotation) {
	    matrix.rotate(m, m, rotation);
	  }
	
	  if (origin) {
	    // Translate back from origin
	    m[4] += origin[0];
	    m[5] += origin[1];
	  }
	
	  m[4] += position[0];
	  m[5] += position[1];
	  return m;
	};
	
	var _default = Transformable;
	module.exports = _default;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	/**
	 * 3x2矩阵操作类
	 * @exports zrender/tool/matrix
	 */
	var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
	/**
	 * 创建一个单位矩阵
	 * @return {Float32Array|Array.<number>}
	 */
	
	function create() {
	  var out = new ArrayCtor(6);
	  identity(out);
	  return out;
	}
	/**
	 * 设置矩阵为单位矩阵
	 * @param {Float32Array|Array.<number>} out
	 */
	
	
	function identity(out) {
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 1;
	  out[4] = 0;
	  out[5] = 0;
	  return out;
	}
	/**
	 * 复制矩阵
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} m
	 */
	
	
	function copy(out, m) {
	  out[0] = m[0];
	  out[1] = m[1];
	  out[2] = m[2];
	  out[3] = m[3];
	  out[4] = m[4];
	  out[5] = m[5];
	  return out;
	}
	/**
	 * 矩阵相乘
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} m1
	 * @param {Float32Array|Array.<number>} m2
	 */
	
	
	function mul(out, m1, m2) {
	  // Consider matrix.mul(m, m2, m);
	  // where out is the same as m2.
	  // So use temp variable to escape error.
	  var out0 = m1[0] * m2[0] + m1[2] * m2[1];
	  var out1 = m1[1] * m2[0] + m1[3] * m2[1];
	  var out2 = m1[0] * m2[2] + m1[2] * m2[3];
	  var out3 = m1[1] * m2[2] + m1[3] * m2[3];
	  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
	  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
	  out[0] = out0;
	  out[1] = out1;
	  out[2] = out2;
	  out[3] = out3;
	  out[4] = out4;
	  out[5] = out5;
	  return out;
	}
	/**
	 * 平移变换
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 * @param {Float32Array|Array.<number>} v
	 */
	
	
	function translate(out, a, v) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  out[4] = a[4] + v[0];
	  out[5] = a[5] + v[1];
	  return out;
	}
	/**
	 * 旋转变换
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 * @param {number} rad
	 */
	
	
	function rotate(out, a, rad) {
	  var aa = a[0];
	  var ac = a[2];
	  var atx = a[4];
	  var ab = a[1];
	  var ad = a[3];
	  var aty = a[5];
	  var st = Math.sin(rad);
	  var ct = Math.cos(rad);
	  out[0] = aa * ct + ab * st;
	  out[1] = -aa * st + ab * ct;
	  out[2] = ac * ct + ad * st;
	  out[3] = -ac * st + ct * ad;
	  out[4] = ct * atx + st * aty;
	  out[5] = ct * aty - st * atx;
	  return out;
	}
	/**
	 * 缩放变换
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 * @param {Float32Array|Array.<number>} v
	 */
	
	
	function scale(out, a, v) {
	  var vx = v[0];
	  var vy = v[1];
	  out[0] = a[0] * vx;
	  out[1] = a[1] * vy;
	  out[2] = a[2] * vx;
	  out[3] = a[3] * vy;
	  out[4] = a[4] * vx;
	  out[5] = a[5] * vy;
	  return out;
	}
	/**
	 * 求逆矩阵
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 */
	
	
	function invert(out, a) {
	  var aa = a[0];
	  var ac = a[2];
	  var atx = a[4];
	  var ab = a[1];
	  var ad = a[3];
	  var aty = a[5];
	  var det = aa * ad - ab * ac;
	
	  if (!det) {
	    return null;
	  }
	
	  det = 1.0 / det;
	  out[0] = ad * det;
	  out[1] = -ab * det;
	  out[2] = -ac * det;
	  out[3] = aa * det;
	  out[4] = (ac * aty - ad * atx) * det;
	  out[5] = (ab * atx - aa * aty) * det;
	  return out;
	}
	
	exports.create = create;
	exports.identity = identity;
	exports.copy = copy;
	exports.mul = mul;
	exports.translate = translate;
	exports.rotate = rotate;
	exports.scale = scale;
	exports.invert = invert;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
	/**
	 * 创建一个向量
	 * @param {number} [x=0]
	 * @param {number} [y=0]
	 * @return {Vector2}
	 */
	
	function create(x, y) {
	  var out = new ArrayCtor(2);
	
	  if (x == null) {
	    x = 0;
	  }
	
	  if (y == null) {
	    y = 0;
	  }
	
	  out[0] = x;
	  out[1] = y;
	  return out;
	}
	/**
	 * 复制向量数据
	 * @param {Vector2} out
	 * @param {Vector2} v
	 * @return {Vector2}
	 */
	
	
	function copy(out, v) {
	  out[0] = v[0];
	  out[1] = v[1];
	  return out;
	}
	/**
	 * 克隆一个向量
	 * @param {Vector2} v
	 * @return {Vector2}
	 */
	
	
	function clone(v) {
	  var out = new ArrayCtor(2);
	  out[0] = v[0];
	  out[1] = v[1];
	  return out;
	}
	/**
	 * 设置向量的两个项
	 * @param {Vector2} out
	 * @param {number} a
	 * @param {number} b
	 * @return {Vector2} 结果
	 */
	
	
	function set(out, a, b) {
	  out[0] = a;
	  out[1] = b;
	  return out;
	}
	/**
	 * 向量相加
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	
	function add(out, v1, v2) {
	  out[0] = v1[0] + v2[0];
	  out[1] = v1[1] + v2[1];
	  return out;
	}
	/**
	 * 向量缩放后相加
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @param {number} a
	 */
	
	
	function scaleAndAdd(out, v1, v2, a) {
	  out[0] = v1[0] + v2[0] * a;
	  out[1] = v1[1] + v2[1] * a;
	  return out;
	}
	/**
	 * 向量相减
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	
	function sub(out, v1, v2) {
	  out[0] = v1[0] - v2[0];
	  out[1] = v1[1] - v2[1];
	  return out;
	}
	/**
	 * 向量长度
	 * @param {Vector2} v
	 * @return {number}
	 */
	
	
	function len(v) {
	  return Math.sqrt(lenSquare(v));
	}
	
	var length = len; // jshint ignore:line
	
	/**
	 * 向量长度平方
	 * @param {Vector2} v
	 * @return {number}
	 */
	
	function lenSquare(v) {
	  return v[0] * v[0] + v[1] * v[1];
	}
	
	var lengthSquare = lenSquare;
	/**
	 * 向量乘法
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	function mul(out, v1, v2) {
	  out[0] = v1[0] * v2[0];
	  out[1] = v1[1] * v2[1];
	  return out;
	}
	/**
	 * 向量除法
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	
	function div(out, v1, v2) {
	  out[0] = v1[0] / v2[0];
	  out[1] = v1[1] / v2[1];
	  return out;
	}
	/**
	 * 向量点乘
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @return {number}
	 */
	
	
	function dot(v1, v2) {
	  return v1[0] * v2[0] + v1[1] * v2[1];
	}
	/**
	 * 向量缩放
	 * @param {Vector2} out
	 * @param {Vector2} v
	 * @param {number} s
	 */
	
	
	function scale(out, v, s) {
	  out[0] = v[0] * s;
	  out[1] = v[1] * s;
	  return out;
	}
	/**
	 * 向量归一化
	 * @param {Vector2} out
	 * @param {Vector2} v
	 */
	
	
	function normalize(out, v) {
	  var d = len(v);
	
	  if (d === 0) {
	    out[0] = 0;
	    out[1] = 0;
	  } else {
	    out[0] = v[0] / d;
	    out[1] = v[1] / d;
	  }
	
	  return out;
	}
	/**
	 * 计算向量间距离
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @return {number}
	 */
	
	
	function distance(v1, v2) {
	  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
	}
	
	var dist = distance;
	/**
	 * 向量距离平方
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @return {number}
	 */
	
	function distanceSquare(v1, v2) {
	  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	}
	
	var distSquare = distanceSquare;
	/**
	 * 求负向量
	 * @param {Vector2} out
	 * @param {Vector2} v
	 */
	
	function negate(out, v) {
	  out[0] = -v[0];
	  out[1] = -v[1];
	  return out;
	}
	/**
	 * 插值两个点
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @param {number} t
	 */
	
	
	function lerp(out, v1, v2, t) {
	  out[0] = v1[0] + t * (v2[0] - v1[0]);
	  out[1] = v1[1] + t * (v2[1] - v1[1]);
	  return out;
	}
	/**
	 * 矩阵左乘向量
	 * @param {Vector2} out
	 * @param {Vector2} v
	 * @param {Vector2} m
	 */
	
	
	function applyTransform(out, v, m) {
	  var x = v[0];
	  var y = v[1];
	  out[0] = m[0] * x + m[2] * y + m[4];
	  out[1] = m[1] * x + m[3] * y + m[5];
	  return out;
	}
	/**
	 * 求两个向量最小值
	 * @param  {Vector2} out
	 * @param  {Vector2} v1
	 * @param  {Vector2} v2
	 */
	
	
	function min(out, v1, v2) {
	  out[0] = Math.min(v1[0], v2[0]);
	  out[1] = Math.min(v1[1], v2[1]);
	  return out;
	}
	/**
	 * 求两个向量最大值
	 * @param  {Vector2} out
	 * @param  {Vector2} v1
	 * @param  {Vector2} v2
	 */
	
	
	function max(out, v1, v2) {
	  out[0] = Math.max(v1[0], v2[0]);
	  out[1] = Math.max(v1[1], v2[1]);
	  return out;
	}
	
	exports.create = create;
	exports.copy = copy;
	exports.clone = clone;
	exports.set = set;
	exports.add = add;
	exports.scaleAndAdd = scaleAndAdd;
	exports.sub = sub;
	exports.len = len;
	exports.length = length;
	exports.lenSquare = lenSquare;
	exports.lengthSquare = lengthSquare;
	exports.mul = mul;
	exports.div = div;
	exports.dot = dot;
	exports.scale = scale;
	exports.normalize = normalize;
	exports.distance = distance;
	exports.dist = dist;
	exports.distanceSquare = distanceSquare;
	exports.distSquare = distSquare;
	exports.negate = negate;
	exports.lerp = lerp;
	exports.applyTransform = applyTransform;
	exports.min = min;
	exports.max = max;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	var Animator = __webpack_require__(16);
	
	var log = __webpack_require__(21);
	
	var _util = __webpack_require__(4);
	
	var isString = _util.isString;
	var isFunction = _util.isFunction;
	var isObject = _util.isObject;
	var isArrayLike = _util.isArrayLike;
	var indexOf = _util.indexOf;
	
	/**
	 * @alias modue:zrender/mixin/Animatable
	 * @constructor
	 */
	var Animatable = function () {
	  /**
	   * @type {Array.<module:zrender/animation/Animator>}
	   * @readOnly
	   */
	  this.animators = [];
	};
	
	Animatable.prototype = {
	  constructor: Animatable,
	
	  /**
	   * 动画
	   *
	   * @param {string} path The path to fetch value from object, like 'a.b.c'.
	   * @param {boolean} [loop] Whether to loop animation.
	   * @return {module:zrender/animation/Animator}
	   * @example:
	   *     el.animate('style', false)
	   *         .when(1000, {x: 10} )
	   *         .done(function(){ // Animation done })
	   *         .start()
	   */
	  animate: function (path, loop) {
	    var target;
	    var animatingShape = false;
	    var el = this;
	    var zr = this.__zr;
	
	    if (path) {
	      var pathSplitted = path.split('.');
	      var prop = el; // If animating shape
	
	      animatingShape = pathSplitted[0] === 'shape';
	
	      for (var i = 0, l = pathSplitted.length; i < l; i++) {
	        if (!prop) {
	          continue;
	        }
	
	        prop = prop[pathSplitted[i]];
	      }
	
	      if (prop) {
	        target = prop;
	      }
	    } else {
	      target = el;
	    }
	
	    if (!target) {
	      log('Property "' + path + '" is not existed in element ' + el.id);
	      return;
	    }
	
	    var animators = el.animators;
	    var animator = new Animator(target, loop);
	    animator.during(function (target) {
	      el.dirty(animatingShape);
	    }).done(function () {
	      // FIXME Animator will not be removed if use `Animator#stop` to stop animation
	      animators.splice(indexOf(animators, animator), 1);
	    });
	    animators.push(animator); // If animate after added to the zrender
	
	    if (zr) {
	      zr.animation.addAnimator(animator);
	    }
	
	    return animator;
	  },
	
	  /**
	   * 停止动画
	   * @param {boolean} forwardToLast If move to last frame before stop
	   */
	  stopAnimation: function (forwardToLast) {
	    var animators = this.animators;
	    var len = animators.length;
	
	    for (var i = 0; i < len; i++) {
	      animators[i].stop(forwardToLast);
	    }
	
	    animators.length = 0;
	    return this;
	  },
	
	  /**
	   * Caution: this method will stop previous animation.
	   * So do not use this method to one element twice before
	   * animation starts, unless you know what you are doing.
	   * @param {Object} target
	   * @param {number} [time=500] Time in ms
	   * @param {string} [easing='linear']
	   * @param {number} [delay=0]
	   * @param {Function} [callback]
	   * @param {Function} [forceAnimate] Prevent stop animation and callback
	   *        immediently when target values are the same as current values.
	   *
	   * @example
	   *  // Animate position
	   *  el.animateTo({
	   *      position: [10, 10]
	   *  }, function () { // done })
	   *
	   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	   *  el.animateTo({
	   *      shape: {
	   *          width: 500
	   *      },
	   *      style: {
	   *          fill: 'red'
	   *      }
	   *      position: [10, 10]
	   *  }, 100, 100, 'cubicOut', function () { // done })
	   */
	  // TODO Return animation key
	  animateTo: function (target, time, delay, easing, callback, forceAnimate) {
	    // animateTo(target, time, easing, callback);
	    if (isString(delay)) {
	      callback = easing;
	      easing = delay;
	      delay = 0;
	    } // animateTo(target, time, delay, callback);
	    else if (isFunction(easing)) {
	        callback = easing;
	        easing = 'linear';
	        delay = 0;
	      } // animateTo(target, time, callback);
	      else if (isFunction(delay)) {
	          callback = delay;
	          delay = 0;
	        } // animateTo(target, callback)
	        else if (isFunction(time)) {
	            callback = time;
	            time = 500;
	          } // animateTo(target)
	          else if (!time) {
	              time = 500;
	            } // Stop all previous animations
	
	
	    this.stopAnimation();
	
	    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start
	    // if there is nothing to animate
	
	
	    var animators = this.animators.slice();
	    var count = animators.length;
	
	    function done() {
	      count--;
	
	      if (!count) {
	        callback && callback();
	      }
	    } // No animators. This should be checked before animators[i].start(),
	    // because 'done' may be executed immediately if no need to animate.
	
	
	    if (!count) {
	      callback && callback();
	    } // Start after all animators created
	    // Incase any animator is done immediately when all animation properties are not changed
	
	
	    for (var i = 0; i < animators.length; i++) {
	      animators[i].done(done).start(easing, forceAnimate);
	    }
	  },
	
	  /**
	   * @private
	   * @param {string} path=''
	   * @param {Object} source=this
	   * @param {Object} target
	   * @param {number} [time=500]
	   * @param {number} [delay=0]
	   *
	   * @example
	   *  // Animate position
	   *  el._animateToShallow({
	   *      position: [10, 10]
	   *  })
	   *
	   *  // Animate shape, style and position in 100ms, delayed 100ms
	   *  el._animateToShallow({
	   *      shape: {
	   *          width: 500
	   *      },
	   *      style: {
	   *          fill: 'red'
	   *      }
	   *      position: [10, 10]
	   *  }, 100, 100)
	   */
	  _animateToShallow: function (path, source, target, time, delay) {
	    var objShallow = {};
	    var propertyCount = 0;
	
	    for (var name in target) {
	      if (!target.hasOwnProperty(name)) {
	        continue;
	      }
	
	      if (source[name] != null) {
	        if (isObject(target[name]) && !isArrayLike(target[name])) {
	          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);
	        } else {
	          objShallow[name] = target[name];
	          propertyCount++;
	        }
	      } else if (target[name] != null) {
	        // Attr directly if not has property
	        // FIXME, if some property not needed for element ?
	        if (!path) {
	          this.attr(name, target[name]);
	        } else {
	          // Shape or style
	          var props = {};
	          props[path] = {};
	          props[path][name] = target[name];
	          this.attr(props);
	        }
	      }
	    }
	
	    if (propertyCount > 0) {
	      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
	    }
	
	    return this;
	  }
	};
	var _default = Animatable;
	module.exports = _default;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	var Clip = __webpack_require__(17);
	
	var color = __webpack_require__(19);
	
	var _util = __webpack_require__(4);
	
	var isArrayLike = _util.isArrayLike;
	
	/**
	 * @module echarts/animation/Animator
	 */
	var arraySlice = Array.prototype.slice;
	
	function defaultGetter(target, key) {
	  return target[key];
	}
	
	function defaultSetter(target, key, value) {
	  target[key] = value;
	}
	/**
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} percent
	 * @return {number}
	 */
	
	
	function interpolateNumber(p0, p1, percent) {
	  return (p1 - p0) * percent + p0;
	}
	/**
	 * @param  {string} p0
	 * @param  {string} p1
	 * @param  {number} percent
	 * @return {string}
	 */
	
	
	function interpolateString(p0, p1, percent) {
	  return percent > 0.5 ? p1 : p0;
	}
	/**
	 * @param  {Array} p0
	 * @param  {Array} p1
	 * @param  {number} percent
	 * @param  {Array} out
	 * @param  {number} arrDim
	 */
	
	
	function interpolateArray(p0, p1, percent, out, arrDim) {
	  var len = p0.length;
	
	  if (arrDim == 1) {
	    for (var i = 0; i < len; i++) {
	      out[i] = interpolateNumber(p0[i], p1[i], percent);
	    }
	  } else {
	    var len2 = len && p0[0].length;
	
	    for (var i = 0; i < len; i++) {
	      for (var j = 0; j < len2; j++) {
	        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
	      }
	    }
	  }
	} // arr0 is source array, arr1 is target array.
	// Do some preprocess to avoid error happened when interpolating from arr0 to arr1
	
	
	function fillArr(arr0, arr1, arrDim) {
	  var arr0Len = arr0.length;
	  var arr1Len = arr1.length;
	
	  if (arr0Len !== arr1Len) {
	    // FIXME Not work for TypedArray
	    var isPreviousLarger = arr0Len > arr1Len;
	
	    if (isPreviousLarger) {
	      // Cut the previous
	      arr0.length = arr1Len;
	    } else {
	      // Fill the previous
	      for (var i = arr0Len; i < arr1Len; i++) {
	        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
	      }
	    }
	  } // Handling NaN value
	
	
	  var len2 = arr0[0] && arr0[0].length;
	
	  for (var i = 0; i < arr0.length; i++) {
	    if (arrDim === 1) {
	      if (isNaN(arr0[i])) {
	        arr0[i] = arr1[i];
	      }
	    } else {
	      for (var j = 0; j < len2; j++) {
	        if (isNaN(arr0[i][j])) {
	          arr0[i][j] = arr1[i][j];
	        }
	      }
	    }
	  }
	}
	/**
	 * @param  {Array} arr0
	 * @param  {Array} arr1
	 * @param  {number} arrDim
	 * @return {boolean}
	 */
	
	
	function isArraySame(arr0, arr1, arrDim) {
	  if (arr0 === arr1) {
	    return true;
	  }
	
	  var len = arr0.length;
	
	  if (len !== arr1.length) {
	    return false;
	  }
	
	  if (arrDim === 1) {
	    for (var i = 0; i < len; i++) {
	      if (arr0[i] !== arr1[i]) {
	        return false;
	      }
	    }
	  } else {
	    var len2 = arr0[0].length;
	
	    for (var i = 0; i < len; i++) {
	      for (var j = 0; j < len2; j++) {
	        if (arr0[i][j] !== arr1[i][j]) {
	          return false;
	        }
	      }
	    }
	  }
	
	  return true;
	}
	/**
	 * Catmull Rom interpolate array
	 * @param  {Array} p0
	 * @param  {Array} p1
	 * @param  {Array} p2
	 * @param  {Array} p3
	 * @param  {number} t
	 * @param  {number} t2
	 * @param  {number} t3
	 * @param  {Array} out
	 * @param  {number} arrDim
	 */
	
	
	function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
	  var len = p0.length;
	
	  if (arrDim == 1) {
	    for (var i = 0; i < len; i++) {
	      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
	    }
	  } else {
	    var len2 = p0[0].length;
	
	    for (var i = 0; i < len; i++) {
	      for (var j = 0; j < len2; j++) {
	        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
	      }
	    }
	  }
	}
	/**
	 * Catmull Rom interpolate number
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @param  {number} t2
	 * @param  {number} t3
	 * @return {number}
	 */
	
	
	function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
	  var v0 = (p2 - p0) * 0.5;
	  var v1 = (p3 - p1) * 0.5;
	  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
	}
	
	function cloneValue(value) {
	  if (isArrayLike(value)) {
	    var len = value.length;
	
	    if (isArrayLike(value[0])) {
	      var ret = [];
	
	      for (var i = 0; i < len; i++) {
	        ret.push(arraySlice.call(value[i]));
	      }
	
	      return ret;
	    }
	
	    return arraySlice.call(value);
	  }
	
	  return value;
	}
	
	function rgba2String(rgba) {
	  rgba[0] = Math.floor(rgba[0]);
	  rgba[1] = Math.floor(rgba[1]);
	  rgba[2] = Math.floor(rgba[2]);
	  return 'rgba(' + rgba.join(',') + ')';
	}
	
	function getArrayDim(keyframes) {
	  var lastValue = keyframes[keyframes.length - 1].value;
	  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;
	}
	
	function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
	  var getter = animator._getter;
	  var setter = animator._setter;
	  var useSpline = easing === 'spline';
	  var trackLen = keyframes.length;
	
	  if (!trackLen) {
	    return;
	  } // Guess data type
	
	
	  var firstVal = keyframes[0].value;
	  var isValueArray = isArrayLike(firstVal);
	  var isValueColor = false;
	  var isValueString = false; // For vertices morphing
	
	  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
	  var trackMaxTime; // Sort keyframe as ascending
	
	  keyframes.sort(function (a, b) {
	    return a.time - b.time;
	  });
	  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe
	
	  var kfPercents = []; // Value of each keyframe
	
	  var kfValues = [];
	  var prevValue = keyframes[0].value;
	  var isAllValueEqual = true;
	
	  for (var i = 0; i < trackLen; i++) {
	    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string
	
	    var value = keyframes[i].value; // Check if value is equal, deep check if value is array
	
	    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
	      isAllValueEqual = false;
	    }
	
	    prevValue = value; // Try converting a string to a color array
	
	    if (typeof value == 'string') {
	      var colorArray = color.parse(value);
	
	      if (colorArray) {
	        value = colorArray;
	        isValueColor = true;
	      } else {
	        isValueString = true;
	      }
	    }
	
	    kfValues.push(value);
	  }
	
	  if (!forceAnimate && isAllValueEqual) {
	    return;
	  }
	
	  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value
	
	  for (var i = 0; i < trackLen - 1; i++) {
	    if (isValueArray) {
	      fillArr(kfValues[i], lastValue, arrDim);
	    } else {
	      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
	        kfValues[i] = lastValue;
	      }
	    }
	  }
	
	  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when
	  // animation playback is sequency
	
	  var lastFrame = 0;
	  var lastFramePercent = 0;
	  var start;
	  var w;
	  var p0;
	  var p1;
	  var p2;
	  var p3;
	
	  if (isValueColor) {
	    var rgba = [0, 0, 0, 0];
	  }
	
	  var onframe = function (target, percent) {
	    // Find the range keyframes
	    // kf1-----kf2---------current--------kf3
	    // find kf2 and kf3 and do interpolation
	    var frame; // In the easing function like elasticOut, percent may less than 0
	
	    if (percent < 0) {
	      frame = 0;
	    } else if (percent < lastFramePercent) {
	      // Start from next key
	      // PENDING start from lastFrame ?
	      start = Math.min(lastFrame + 1, trackLen - 1);
	
	      for (frame = start; frame >= 0; frame--) {
	        if (kfPercents[frame] <= percent) {
	          break;
	        }
	      } // PENDING really need to do this ?
	
	
	      frame = Math.min(frame, trackLen - 2);
	    } else {
	      for (frame = lastFrame; frame < trackLen; frame++) {
	        if (kfPercents[frame] > percent) {
	          break;
	        }
	      }
	
	      frame = Math.min(frame - 1, trackLen - 2);
	    }
	
	    lastFrame = frame;
	    lastFramePercent = percent;
	    var range = kfPercents[frame + 1] - kfPercents[frame];
	
	    if (range === 0) {
	      return;
	    } else {
	      w = (percent - kfPercents[frame]) / range;
	    }
	
	    if (useSpline) {
	      p1 = kfValues[frame];
	      p0 = kfValues[frame === 0 ? frame : frame - 1];
	      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
	      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
	
	      if (isValueArray) {
	        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
	      } else {
	        var value;
	
	        if (isValueColor) {
	          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
	          value = rgba2String(rgba);
	        } else if (isValueString) {
	          // String is step(0.5)
	          return interpolateString(p1, p2, w);
	        } else {
	          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
	        }
	
	        setter(target, propName, value);
	      }
	    } else {
	      if (isValueArray) {
	        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
	      } else {
	        var value;
	
	        if (isValueColor) {
	          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
	          value = rgba2String(rgba);
	        } else if (isValueString) {
	          // String is step(0.5)
	          return interpolateString(kfValues[frame], kfValues[frame + 1], w);
	        } else {
	          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
	        }
	
	        setter(target, propName, value);
	      }
	    }
	  };
	
	  var clip = new Clip({
	    target: animator._target,
	    life: trackMaxTime,
	    loop: animator._loop,
	    delay: animator._delay,
	    onframe: onframe,
	    ondestroy: oneTrackDone
	  });
	
	  if (easing && easing !== 'spline') {
	    clip.easing = easing;
	  }
	
	  return clip;
	}
	/**
	 * @alias module:zrender/animation/Animator
	 * @constructor
	 * @param {Object} target
	 * @param {boolean} loop
	 * @param {Function} getter
	 * @param {Function} setter
	 */
	
	
	var Animator = function (target, loop, getter, setter) {
	  this._tracks = {};
	  this._target = target;
	  this._loop = loop || false;
	  this._getter = getter || defaultGetter;
	  this._setter = setter || defaultSetter;
	  this._clipCount = 0;
	  this._delay = 0;
	  this._doneList = [];
	  this._onframeList = [];
	  this._clipList = [];
	};
	
	Animator.prototype = {
	  /**
	   * 设置动画关键帧
	   * @param  {number} time 关键帧时间，单位是ms
	   * @param  {Object} props 关键帧的属性值，key-value表示
	   * @return {module:zrender/animation/Animator}
	   */
	  when: function (time
	  /* ms */
	  , props) {
	    var tracks = this._tracks;
	
	    for (var propName in props) {
	      if (!props.hasOwnProperty(propName)) {
	        continue;
	      }
	
	      if (!tracks[propName]) {
	        tracks[propName] = []; // Invalid value
	
	        var value = this._getter(this._target, propName);
	
	        if (value == null) {
	          // zrLog('Invalid property ' + propName);
	          continue;
	        } // If time is 0
	        //  Then props is given initialize value
	        // Else
	        //  Initialize value from current prop value
	
	
	        if (time !== 0) {
	          tracks[propName].push({
	            time: 0,
	            value: cloneValue(value)
	          });
	        }
	      }
	
	      tracks[propName].push({
	        time: time,
	        value: props[propName]
	      });
	    }
	
	    return this;
	  },
	
	  /**
	   * 添加动画每一帧的回调函数
	   * @param  {Function} callback
	   * @return {module:zrender/animation/Animator}
	   */
	  during: function (callback) {
	    this._onframeList.push(callback);
	
	    return this;
	  },
	  pause: function () {
	    for (var i = 0; i < this._clipList.length; i++) {
	      this._clipList[i].pause();
	    }
	
	    this._paused = true;
	  },
	  resume: function () {
	    for (var i = 0; i < this._clipList.length; i++) {
	      this._clipList[i].resume();
	    }
	
	    this._paused = false;
	  },
	  isPaused: function () {
	    return !!this._paused;
	  },
	  _doneCallback: function () {
	    // Clear all tracks
	    this._tracks = {}; // Clear all clips
	
	    this._clipList.length = 0;
	    var doneList = this._doneList;
	    var len = doneList.length;
	
	    for (var i = 0; i < len; i++) {
	      doneList[i].call(this);
	    }
	  },
	
	  /**
	   * 开始执行动画
	   * @param  {string|Function} [easing]
	   *         动画缓动函数，详见{@link module:zrender/animation/easing}
	   * @param  {boolean} forceAnimate
	   * @return {module:zrender/animation/Animator}
	   */
	  start: function (easing, forceAnimate) {
	    var self = this;
	    var clipCount = 0;
	
	    var oneTrackDone = function () {
	      clipCount--;
	
	      if (!clipCount) {
	        self._doneCallback();
	      }
	    };
	
	    var lastClip;
	
	    for (var propName in this._tracks) {
	      if (!this._tracks.hasOwnProperty(propName)) {
	        continue;
	      }
	
	      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);
	
	      if (clip) {
	        this._clipList.push(clip);
	
	        clipCount++; // If start after added to animation
	
	        if (this.animation) {
	          this.animation.addClip(clip);
	        }
	
	        lastClip = clip;
	      }
	    } // Add during callback on the last clip
	
	
	    if (lastClip) {
	      var oldOnFrame = lastClip.onframe;
	
	      lastClip.onframe = function (target, percent) {
	        oldOnFrame(target, percent);
	
	        for (var i = 0; i < self._onframeList.length; i++) {
	          self._onframeList[i](target, percent);
	        }
	      };
	    } // This optimization will help the case that in the upper application
	    // the view may be refreshed frequently, where animation will be
	    // called repeatly but nothing changed.
	
	
	    if (!clipCount) {
	      this._doneCallback();
	    }
	
	    return this;
	  },
	
	  /**
	   * 停止动画
	   * @param {boolean} forwardToLast If move to last frame before stop
	   */
	  stop: function (forwardToLast) {
	    var clipList = this._clipList;
	    var animation = this.animation;
	
	    for (var i = 0; i < clipList.length; i++) {
	      var clip = clipList[i];
	
	      if (forwardToLast) {
	        // Move to last frame before stop
	        clip.onframe(this._target, 1);
	      }
	
	      animation && animation.removeClip(clip);
	    }
	
	    clipList.length = 0;
	  },
	
	  /**
	   * 设置动画延迟开始的时间
	   * @param  {number} time 单位ms
	   * @return {module:zrender/animation/Animator}
	   */
	  delay: function (time) {
	    this._delay = time;
	    return this;
	  },
	
	  /**
	   * 添加动画结束的回调
	   * @param  {Function} cb
	   * @return {module:zrender/animation/Animator}
	   */
	  done: function (cb) {
	    if (cb) {
	      this._doneList.push(cb);
	    }
	
	    return this;
	  },
	
	  /**
	   * @return {Array.<module:zrender/animation/Clip>}
	   */
	  getClips: function () {
	    return this._clipList;
	  }
	};
	var _default = Animator;
	module.exports = _default;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	var easingFuncs = __webpack_require__(18);
	
	/**
	 * 动画主控制器
	 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
	 * @config life(1000) 动画时长
	 * @config delay(0) 动画延迟时间
	 * @config loop(true)
	 * @config gap(0) 循环的间隔时间
	 * @config onframe
	 * @config easing(optional)
	 * @config ondestroy(optional)
	 * @config onrestart(optional)
	 *
	 * TODO pause
	 */
	function Clip(options) {
	  this._target = options.target; // 生命周期
	
	  this._life = options.life || 1000; // 延时
	
	  this._delay = options.delay || 0; // 开始时间
	  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒
	
	  this._initialized = false; // 是否循环
	
	  this.loop = options.loop == null ? false : options.loop;
	  this.gap = options.gap || 0;
	  this.easing = options.easing || 'Linear';
	  this.onframe = options.onframe;
	  this.ondestroy = options.ondestroy;
	  this.onrestart = options.onrestart;
	  this._pausedTime = 0;
	  this._paused = false;
	}
	
	Clip.prototype = {
	  constructor: Clip,
	  step: function (globalTime, deltaTime) {
	    // Set startTime on first step, or _startTime may has milleseconds different between clips
	    // PENDING
	    if (!this._initialized) {
	      this._startTime = globalTime + this._delay;
	      this._initialized = true;
	    }
	
	    if (this._paused) {
	      this._pausedTime += deltaTime;
	      return;
	    }
	
	    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始
	
	    if (percent < 0) {
	      return;
	    }
	
	    percent = Math.min(percent, 1);
	    var easing = this.easing;
	    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
	    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;
	    this.fire('frame', schedule); // 结束
	
	    if (percent == 1) {
	      if (this.loop) {
	        this.restart(globalTime); // 重新开始周期
	        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
	
	        return 'restart';
	      } // 动画完成将这个控制器标识为待删除
	      // 在Animation.update中进行批量删除
	
	
	      this._needsRemove = true;
	      return 'destroy';
	    }
	
	    return null;
	  },
	  restart: function (globalTime) {
	    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
	    this._startTime = globalTime - remainder + this.gap;
	    this._pausedTime = 0;
	    this._needsRemove = false;
	  },
	  fire: function (eventType, arg) {
	    eventType = 'on' + eventType;
	
	    if (this[eventType]) {
	      this[eventType](this._target, arg);
	    }
	  },
	  pause: function () {
	    this._paused = true;
	  },
	  resume: function () {
	    this._paused = false;
	  }
	};
	var _default = Clip;
	module.exports = _default;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

	/**
	 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
	 * @see http://sole.github.io/tween.js/examples/03_graphs.html
	 * @exports zrender/animation/easing
	 */
	var easing = {
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  linear: function (k) {
	    return k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quadraticIn: function (k) {
	    return k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quadraticOut: function (k) {
	    return k * (2 - k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quadraticInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k;
	    }
	
	    return -0.5 * (--k * (k - 2) - 1);
	  },
	  // 三次方的缓动（t^3）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  cubicIn: function (k) {
	    return k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  cubicOut: function (k) {
	    return --k * k * k + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  cubicInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k * k;
	    }
	
	    return 0.5 * ((k -= 2) * k * k + 2);
	  },
	  // 四次方的缓动（t^4）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quarticIn: function (k) {
	    return k * k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quarticOut: function (k) {
	    return 1 - --k * k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quarticInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k * k * k;
	    }
	
	    return -0.5 * ((k -= 2) * k * k * k - 2);
	  },
	  // 五次方的缓动（t^5）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quinticIn: function (k) {
	    return k * k * k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quinticOut: function (k) {
	    return --k * k * k * k * k + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quinticInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k * k * k * k;
	    }
	
	    return 0.5 * ((k -= 2) * k * k * k * k + 2);
	  },
	  // 正弦曲线的缓动（sin(t)）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  sinusoidalIn: function (k) {
	    return 1 - Math.cos(k * Math.PI / 2);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  sinusoidalOut: function (k) {
	    return Math.sin(k * Math.PI / 2);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  sinusoidalInOut: function (k) {
	    return 0.5 * (1 - Math.cos(Math.PI * k));
	  },
	  // 指数曲线的缓动（2^t）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  exponentialIn: function (k) {
	    return k === 0 ? 0 : Math.pow(1024, k - 1);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  exponentialOut: function (k) {
	    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  exponentialInOut: function (k) {
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if ((k *= 2) < 1) {
	      return 0.5 * Math.pow(1024, k - 1);
	    }
	
	    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
	  },
	  // 圆形曲线的缓动（sqrt(1-t^2)）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  circularIn: function (k) {
	    return 1 - Math.sqrt(1 - k * k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  circularOut: function (k) {
	    return Math.sqrt(1 - --k * k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  circularInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return -0.5 * (Math.sqrt(1 - k * k) - 1);
	    }
	
	    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	  },
	  // 创建类似于弹簧在停止前来回振荡的动画
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  elasticIn: function (k) {
	    var s;
	    var a = 0.1;
	    var p = 0.4;
	
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if (!a || a < 1) {
	      a = 1;
	      s = p / 4;
	    } else {
	      s = p * Math.asin(1 / a) / (2 * Math.PI);
	    }
	
	    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  elasticOut: function (k) {
	    var s;
	    var a = 0.1;
	    var p = 0.4;
	
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if (!a || a < 1) {
	      a = 1;
	      s = p / 4;
	    } else {
	      s = p * Math.asin(1 / a) / (2 * Math.PI);
	    }
	
	    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  elasticInOut: function (k) {
	    var s;
	    var a = 0.1;
	    var p = 0.4;
	
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if (!a || a < 1) {
	      a = 1;
	      s = p / 4;
	    } else {
	      s = p * Math.asin(1 / a) / (2 * Math.PI);
	    }
	
	    if ((k *= 2) < 1) {
	      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
	    }
	
	    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
	  },
	  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  backIn: function (k) {
	    var s = 1.70158;
	    return k * k * ((s + 1) * k - s);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  backOut: function (k) {
	    var s = 1.70158;
	    return --k * k * ((s + 1) * k + s) + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  backInOut: function (k) {
	    var s = 1.70158 * 1.525;
	
	    if ((k *= 2) < 1) {
	      return 0.5 * (k * k * ((s + 1) * k - s));
	    }
	
	    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	  },
	  // 创建弹跳效果
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  bounceIn: function (k) {
	    return 1 - easing.bounceOut(1 - k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  bounceOut: function (k) {
	    if (k < 1 / 2.75) {
	      return 7.5625 * k * k;
	    } else if (k < 2 / 2.75) {
	      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
	    } else if (k < 2.5 / 2.75) {
	      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
	    } else {
	      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
	    }
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  bounceInOut: function (k) {
	    if (k < 0.5) {
	      return easing.bounceIn(k * 2) * 0.5;
	    }
	
	    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
	  }
	};
	var _default = easing;
	module.exports = _default;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	var LRU = __webpack_require__(20);
	
	var kCSSColorTable = {
	  'transparent': [0, 0, 0, 0],
	  'aliceblue': [240, 248, 255, 1],
	  'antiquewhite': [250, 235, 215, 1],
	  'aqua': [0, 255, 255, 1],
	  'aquamarine': [127, 255, 212, 1],
	  'azure': [240, 255, 255, 1],
	  'beige': [245, 245, 220, 1],
	  'bisque': [255, 228, 196, 1],
	  'black': [0, 0, 0, 1],
	  'blanchedalmond': [255, 235, 205, 1],
	  'blue': [0, 0, 255, 1],
	  'blueviolet': [138, 43, 226, 1],
	  'brown': [165, 42, 42, 1],
	  'burlywood': [222, 184, 135, 1],
	  'cadetblue': [95, 158, 160, 1],
	  'chartreuse': [127, 255, 0, 1],
	  'chocolate': [210, 105, 30, 1],
	  'coral': [255, 127, 80, 1],
	  'cornflowerblue': [100, 149, 237, 1],
	  'cornsilk': [255, 248, 220, 1],
	  'crimson': [220, 20, 60, 1],
	  'cyan': [0, 255, 255, 1],
	  'darkblue': [0, 0, 139, 1],
	  'darkcyan': [0, 139, 139, 1],
	  'darkgoldenrod': [184, 134, 11, 1],
	  'darkgray': [169, 169, 169, 1],
	  'darkgreen': [0, 100, 0, 1],
	  'darkgrey': [169, 169, 169, 1],
	  'darkkhaki': [189, 183, 107, 1],
	  'darkmagenta': [139, 0, 139, 1],
	  'darkolivegreen': [85, 107, 47, 1],
	  'darkorange': [255, 140, 0, 1],
	  'darkorchid': [153, 50, 204, 1],
	  'darkred': [139, 0, 0, 1],
	  'darksalmon': [233, 150, 122, 1],
	  'darkseagreen': [143, 188, 143, 1],
	  'darkslateblue': [72, 61, 139, 1],
	  'darkslategray': [47, 79, 79, 1],
	  'darkslategrey': [47, 79, 79, 1],
	  'darkturquoise': [0, 206, 209, 1],
	  'darkviolet': [148, 0, 211, 1],
	  'deeppink': [255, 20, 147, 1],
	  'deepskyblue': [0, 191, 255, 1],
	  'dimgray': [105, 105, 105, 1],
	  'dimgrey': [105, 105, 105, 1],
	  'dodgerblue': [30, 144, 255, 1],
	  'firebrick': [178, 34, 34, 1],
	  'floralwhite': [255, 250, 240, 1],
	  'forestgreen': [34, 139, 34, 1],
	  'fuchsia': [255, 0, 255, 1],
	  'gainsboro': [220, 220, 220, 1],
	  'ghostwhite': [248, 248, 255, 1],
	  'gold': [255, 215, 0, 1],
	  'goldenrod': [218, 165, 32, 1],
	  'gray': [128, 128, 128, 1],
	  'green': [0, 128, 0, 1],
	  'greenyellow': [173, 255, 47, 1],
	  'grey': [128, 128, 128, 1],
	  'honeydew': [240, 255, 240, 1],
	  'hotpink': [255, 105, 180, 1],
	  'indianred': [205, 92, 92, 1],
	  'indigo': [75, 0, 130, 1],
	  'ivory': [255, 255, 240, 1],
	  'khaki': [240, 230, 140, 1],
	  'lavender': [230, 230, 250, 1],
	  'lavenderblush': [255, 240, 245, 1],
	  'lawngreen': [124, 252, 0, 1],
	  'lemonchiffon': [255, 250, 205, 1],
	  'lightblue': [173, 216, 230, 1],
	  'lightcoral': [240, 128, 128, 1],
	  'lightcyan': [224, 255, 255, 1],
	  'lightgoldenrodyellow': [250, 250, 210, 1],
	  'lightgray': [211, 211, 211, 1],
	  'lightgreen': [144, 238, 144, 1],
	  'lightgrey': [211, 211, 211, 1],
	  'lightpink': [255, 182, 193, 1],
	  'lightsalmon': [255, 160, 122, 1],
	  'lightseagreen': [32, 178, 170, 1],
	  'lightskyblue': [135, 206, 250, 1],
	  'lightslategray': [119, 136, 153, 1],
	  'lightslategrey': [119, 136, 153, 1],
	  'lightsteelblue': [176, 196, 222, 1],
	  'lightyellow': [255, 255, 224, 1],
	  'lime': [0, 255, 0, 1],
	  'limegreen': [50, 205, 50, 1],
	  'linen': [250, 240, 230, 1],
	  'magenta': [255, 0, 255, 1],
	  'maroon': [128, 0, 0, 1],
	  'mediumaquamarine': [102, 205, 170, 1],
	  'mediumblue': [0, 0, 205, 1],
	  'mediumorchid': [186, 85, 211, 1],
	  'mediumpurple': [147, 112, 219, 1],
	  'mediumseagreen': [60, 179, 113, 1],
	  'mediumslateblue': [123, 104, 238, 1],
	  'mediumspringgreen': [0, 250, 154, 1],
	  'mediumturquoise': [72, 209, 204, 1],
	  'mediumvioletred': [199, 21, 133, 1],
	  'midnightblue': [25, 25, 112, 1],
	  'mintcream': [245, 255, 250, 1],
	  'mistyrose': [255, 228, 225, 1],
	  'moccasin': [255, 228, 181, 1],
	  'navajowhite': [255, 222, 173, 1],
	  'navy': [0, 0, 128, 1],
	  'oldlace': [253, 245, 230, 1],
	  'olive': [128, 128, 0, 1],
	  'olivedrab': [107, 142, 35, 1],
	  'orange': [255, 165, 0, 1],
	  'orangered': [255, 69, 0, 1],
	  'orchid': [218, 112, 214, 1],
	  'palegoldenrod': [238, 232, 170, 1],
	  'palegreen': [152, 251, 152, 1],
	  'paleturquoise': [175, 238, 238, 1],
	  'palevioletred': [219, 112, 147, 1],
	  'papayawhip': [255, 239, 213, 1],
	  'peachpuff': [255, 218, 185, 1],
	  'peru': [205, 133, 63, 1],
	  'pink': [255, 192, 203, 1],
	  'plum': [221, 160, 221, 1],
	  'powderblue': [176, 224, 230, 1],
	  'purple': [128, 0, 128, 1],
	  'red': [255, 0, 0, 1],
	  'rosybrown': [188, 143, 143, 1],
	  'royalblue': [65, 105, 225, 1],
	  'saddlebrown': [139, 69, 19, 1],
	  'salmon': [250, 128, 114, 1],
	  'sandybrown': [244, 164, 96, 1],
	  'seagreen': [46, 139, 87, 1],
	  'seashell': [255, 245, 238, 1],
	  'sienna': [160, 82, 45, 1],
	  'silver': [192, 192, 192, 1],
	  'skyblue': [135, 206, 235, 1],
	  'slateblue': [106, 90, 205, 1],
	  'slategray': [112, 128, 144, 1],
	  'slategrey': [112, 128, 144, 1],
	  'snow': [255, 250, 250, 1],
	  'springgreen': [0, 255, 127, 1],
	  'steelblue': [70, 130, 180, 1],
	  'tan': [210, 180, 140, 1],
	  'teal': [0, 128, 128, 1],
	  'thistle': [216, 191, 216, 1],
	  'tomato': [255, 99, 71, 1],
	  'turquoise': [64, 224, 208, 1],
	  'violet': [238, 130, 238, 1],
	  'wheat': [245, 222, 179, 1],
	  'white': [255, 255, 255, 1],
	  'whitesmoke': [245, 245, 245, 1],
	  'yellow': [255, 255, 0, 1],
	  'yellowgreen': [154, 205, 50, 1]
	};
	
	function clampCssByte(i) {
	  // Clamp to integer 0 .. 255.
	  i = Math.round(i); // Seems to be what Chrome does (vs truncation).
	
	  return i < 0 ? 0 : i > 255 ? 255 : i;
	}
	
	function clampCssAngle(i) {
	  // Clamp to integer 0 .. 360.
	  i = Math.round(i); // Seems to be what Chrome does (vs truncation).
	
	  return i < 0 ? 0 : i > 360 ? 360 : i;
	}
	
	function clampCssFloat(f) {
	  // Clamp to float 0.0 .. 1.0.
	  return f < 0 ? 0 : f > 1 ? 1 : f;
	}
	
	function parseCssInt(str) {
	  // int or percentage.
	  if (str.length && str.charAt(str.length - 1) === '%') {
	    return clampCssByte(parseFloat(str) / 100 * 255);
	  }
	
	  return clampCssByte(parseInt(str, 10));
	}
	
	function parseCssFloat(str) {
	  // float or percentage.
	  if (str.length && str.charAt(str.length - 1) === '%') {
	    return clampCssFloat(parseFloat(str) / 100);
	  }
	
	  return clampCssFloat(parseFloat(str));
	}
	
	function cssHueToRgb(m1, m2, h) {
	  if (h < 0) {
	    h += 1;
	  } else if (h > 1) {
	    h -= 1;
	  }
	
	  if (h * 6 < 1) {
	    return m1 + (m2 - m1) * h * 6;
	  }
	
	  if (h * 2 < 1) {
	    return m2;
	  }
	
	  if (h * 3 < 2) {
	    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
	  }
	
	  return m1;
	}
	
	function lerpNumber(a, b, p) {
	  return a + (b - a) * p;
	}
	
	function setRgba(out, r, g, b, a) {
	  out[0] = r;
	  out[1] = g;
	  out[2] = b;
	  out[3] = a;
	  return out;
	}
	
	function copyRgba(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  return out;
	}
	
	var colorCache = new LRU(20);
	var lastRemovedArr = null;
	
	function putToCache(colorStr, rgbaArr) {
	  // Reuse removed array
	  if (lastRemovedArr) {
	    copyRgba(lastRemovedArr, rgbaArr);
	  }
	
	  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
	}
	/**
	 * @param {string} colorStr
	 * @param {Array.<number>} out
	 * @return {Array.<number>}
	 * @memberOf module:zrender/util/color
	 */
	
	
	function parse(colorStr, rgbaArr) {
	  if (!colorStr) {
	    return;
	  }
	
	  rgbaArr = rgbaArr || [];
	  var cached = colorCache.get(colorStr);
	
	  if (cached) {
	    return copyRgba(rgbaArr, cached);
	  } // colorStr may be not string
	
	
	  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.
	
	  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.
	
	  if (str in kCSSColorTable) {
	    copyRgba(rgbaArr, kCSSColorTable[str]);
	    putToCache(colorStr, rgbaArr);
	    return rgbaArr;
	  } // #abc and #abc123 syntax.
	
	
	  if (str.charAt(0) === '#') {
	    if (str.length === 4) {
	      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
	
	      if (!(iv >= 0 && iv <= 0xfff)) {
	        setRgba(rgbaArr, 0, 0, 0, 1);
	        return; // Covers NaN.
	      }
	
	      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);
	      putToCache(colorStr, rgbaArr);
	      return rgbaArr;
	    } else if (str.length === 7) {
	      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
	
	      if (!(iv >= 0 && iv <= 0xffffff)) {
	        setRgba(rgbaArr, 0, 0, 0, 1);
	        return; // Covers NaN.
	      }
	
	      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);
	      putToCache(colorStr, rgbaArr);
	      return rgbaArr;
	    }
	
	    return;
	  }
	
	  var op = str.indexOf('('),
	      ep = str.indexOf(')');
	
	  if (op !== -1 && ep + 1 === str.length) {
	    var fname = str.substr(0, op);
	    var params = str.substr(op + 1, ep - (op + 1)).split(',');
	    var alpha = 1; // To allow case fallthrough.
	
	    switch (fname) {
	      case 'rgba':
	        if (params.length !== 4) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        alpha = parseCssFloat(params.pop());
	      // jshint ignore:line
	      // Fall through.
	
	      case 'rgb':
	        if (params.length !== 3) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	
	      case 'hsla':
	        if (params.length !== 4) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        params[3] = parseCssFloat(params[3]);
	        hsla2rgba(params, rgbaArr);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	
	      case 'hsl':
	        if (params.length !== 3) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        hsla2rgba(params, rgbaArr);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	
	      default:
	        return;
	    }
	  }
	
	  setRgba(rgbaArr, 0, 0, 0, 1);
	  return;
	}
	/**
	 * @param {Array.<number>} hsla
	 * @param {Array.<number>} rgba
	 * @return {Array.<number>} rgba
	 */
	
	
	function hsla2rgba(hsla, rgba) {
	  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1
	  // NOTE(deanm): According to the CSS spec s/l should only be
	  // percentages, but we don't bother and let float or percentage.
	
	  var s = parseCssFloat(hsla[1]);
	  var l = parseCssFloat(hsla[2]);
	  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	  var m1 = l * 2 - m2;
	  rgba = rgba || [];
	  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
	
	  if (hsla.length === 4) {
	    rgba[3] = hsla[3];
	  }
	
	  return rgba;
	}
	/**
	 * @param {Array.<number>} rgba
	 * @return {Array.<number>} hsla
	 */
	
	
	function rgba2hsla(rgba) {
	  if (!rgba) {
	    return;
	  } // RGB from 0 to 255
	
	
	  var R = rgba[0] / 255;
	  var G = rgba[1] / 255;
	  var B = rgba[2] / 255;
	  var vMin = Math.min(R, G, B); // Min. value of RGB
	
	  var vMax = Math.max(R, G, B); // Max. value of RGB
	
	  var delta = vMax - vMin; // Delta RGB value
	
	  var L = (vMax + vMin) / 2;
	  var H;
	  var S; // HSL results from 0 to 1
	
	  if (delta === 0) {
	    H = 0;
	    S = 0;
	  } else {
	    if (L < 0.5) {
	      S = delta / (vMax + vMin);
	    } else {
	      S = delta / (2 - vMax - vMin);
	    }
	
	    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
	    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
	    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
	
	    if (R === vMax) {
	      H = deltaB - deltaG;
	    } else if (G === vMax) {
	      H = 1 / 3 + deltaR - deltaB;
	    } else if (B === vMax) {
	      H = 2 / 3 + deltaG - deltaR;
	    }
	
	    if (H < 0) {
	      H += 1;
	    }
	
	    if (H > 1) {
	      H -= 1;
	    }
	  }
	
	  var hsla = [H * 360, S, L];
	
	  if (rgba[3] != null) {
	    hsla.push(rgba[3]);
	  }
	
	  return hsla;
	}
	/**
	 * @param {string} color
	 * @param {number} level
	 * @return {string}
	 * @memberOf module:zrender/util/color
	 */
	
	
	function lift(color, level) {
	  var colorArr = parse(color);
	
	  if (colorArr) {
	    for (var i = 0; i < 3; i++) {
	      if (level < 0) {
	        colorArr[i] = colorArr[i] * (1 - level) | 0;
	      } else {
	        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
	      }
	    }
	
	    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
	  }
	}
	/**
	 * @param {string} color
	 * @return {string}
	 * @memberOf module:zrender/util/color
	 */
	
	
	function toHex(color) {
	  var colorArr = parse(color);
	
	  if (colorArr) {
	    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
	  }
	}
	/**
	 * Map value to color. Faster than lerp methods because color is represented by rgba array.
	 * @param {number} normalizedValue A float between 0 and 1.
	 * @param {Array.<Array.<number>>} colors List of rgba color array
	 * @param {Array.<number>} [out] Mapped gba color array
	 * @return {Array.<number>} will be null/undefined if input illegal.
	 */
	
	
	function fastLerp(normalizedValue, colors, out) {
	  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
	    return;
	  }
	
	  out = out || [];
	  var value = normalizedValue * (colors.length - 1);
	  var leftIndex = Math.floor(value);
	  var rightIndex = Math.ceil(value);
	  var leftColor = colors[leftIndex];
	  var rightColor = colors[rightIndex];
	  var dv = value - leftIndex;
	  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
	  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
	  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
	  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
	  return out;
	}
	/**
	 * @deprecated
	 */
	
	
	var fastMapToColor = fastLerp;
	/**
	 * @param {number} normalizedValue A float between 0 and 1.
	 * @param {Array.<string>} colors Color list.
	 * @param {boolean=} fullOutput Default false.
	 * @return {(string|Object)} Result color. If fullOutput,
	 *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
	 * @memberOf module:zrender/util/color
	 */
	
	function lerp(normalizedValue, colors, fullOutput) {
	  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
	    return;
	  }
	
	  var value = normalizedValue * (colors.length - 1);
	  var leftIndex = Math.floor(value);
	  var rightIndex = Math.ceil(value);
	  var leftColor = parse(colors[leftIndex]);
	  var rightColor = parse(colors[rightIndex]);
	  var dv = value - leftIndex;
	  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');
	  return fullOutput ? {
	    color: color,
	    leftIndex: leftIndex,
	    rightIndex: rightIndex,
	    value: value
	  } : color;
	}
	/**
	 * @deprecated
	 */
	
	
	var mapToColor = lerp;
	/**
	 * @param {string} color
	 * @param {number=} h 0 ~ 360, ignore when null.
	 * @param {number=} s 0 ~ 1, ignore when null.
	 * @param {number=} l 0 ~ 1, ignore when null.
	 * @return {string} Color string in rgba format.
	 * @memberOf module:zrender/util/color
	 */
	
	function modifyHSL(color, h, s, l) {
	  color = parse(color);
	
	  if (color) {
	    color = rgba2hsla(color);
	    h != null && (color[0] = clampCssAngle(h));
	    s != null && (color[1] = parseCssFloat(s));
	    l != null && (color[2] = parseCssFloat(l));
	    return stringify(hsla2rgba(color), 'rgba');
	  }
	}
	/**
	 * @param {string} color
	 * @param {number=} alpha 0 ~ 1
	 * @return {string} Color string in rgba format.
	 * @memberOf module:zrender/util/color
	 */
	
	
	function modifyAlpha(color, alpha) {
	  color = parse(color);
	
	  if (color && alpha != null) {
	    color[3] = clampCssFloat(alpha);
	    return stringify(color, 'rgba');
	  }
	}
	/**
	 * @param {Array.<number>} arrColor like [12,33,44,0.4]
	 * @param {string} type 'rgba', 'hsva', ...
	 * @return {string} Result color. (If input illegal, return undefined).
	 */
	
	
	function stringify(arrColor, type) {
	  if (!arrColor || !arrColor.length) {
	    return;
	  }
	
	  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
	
	  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
	    colorStr += ',' + arrColor[3];
	  }
	
	  return type + '(' + colorStr + ')';
	}
	
	exports.parse = parse;
	exports.lift = lift;
	exports.toHex = toHex;
	exports.fastLerp = fastLerp;
	exports.fastMapToColor = fastMapToColor;
	exports.lerp = lerp;
	exports.mapToColor = mapToColor;
	exports.modifyHSL = modifyHSL;
	exports.modifyAlpha = modifyAlpha;
	exports.stringify = stringify;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	// Simple LRU cache use doubly linked list
	// @module zrender/core/LRU
	
	/**
	 * Simple double linked list. Compared with array, it has O(1) remove operation.
	 * @constructor
	 */
	var LinkedList = function () {
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	  this.head = null;
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	
	  this.tail = null;
	  this._len = 0;
	};
	
	var linkedListProto = LinkedList.prototype;
	/**
	 * Insert a new value at the tail
	 * @param  {} val
	 * @return {module:zrender/core/LRU~Entry}
	 */
	
	linkedListProto.insert = function (val) {
	  var entry = new Entry(val);
	  this.insertEntry(entry);
	  return entry;
	};
	/**
	 * Insert an entry at the tail
	 * @param  {module:zrender/core/LRU~Entry} entry
	 */
	
	
	linkedListProto.insertEntry = function (entry) {
	  if (!this.head) {
	    this.head = this.tail = entry;
	  } else {
	    this.tail.next = entry;
	    entry.prev = this.tail;
	    entry.next = null;
	    this.tail = entry;
	  }
	
	  this._len++;
	};
	/**
	 * Remove entry.
	 * @param  {module:zrender/core/LRU~Entry} entry
	 */
	
	
	linkedListProto.remove = function (entry) {
	  var prev = entry.prev;
	  var next = entry.next;
	
	  if (prev) {
	    prev.next = next;
	  } else {
	    // Is head
	    this.head = next;
	  }
	
	  if (next) {
	    next.prev = prev;
	  } else {
	    // Is tail
	    this.tail = prev;
	  }
	
	  entry.next = entry.prev = null;
	  this._len--;
	};
	/**
	 * @return {number}
	 */
	
	
	linkedListProto.len = function () {
	  return this._len;
	};
	/**
	 * Clear list
	 */
	
	
	linkedListProto.clear = function () {
	  this.head = this.tail = null;
	  this._len = 0;
	};
	/**
	 * @constructor
	 * @param {} val
	 */
	
	
	var Entry = function (val) {
	  /**
	   * @type {}
	   */
	  this.value = val;
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	
	  this.next;
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	
	  this.prev;
	};
	/**
	 * LRU Cache
	 * @constructor
	 * @alias module:zrender/core/LRU
	 */
	
	
	var LRU = function (maxSize) {
	  this._list = new LinkedList();
	  this._map = {};
	  this._maxSize = maxSize || 10;
	  this._lastRemovedEntry = null;
	};
	
	var LRUProto = LRU.prototype;
	/**
	 * @param  {string} key
	 * @param  {} value
	 * @return {} Removed value
	 */
	
	LRUProto.put = function (key, value) {
	  var list = this._list;
	  var map = this._map;
	  var removed = null;
	
	  if (map[key] == null) {
	    var len = list.len(); // Reuse last removed entry
	
	    var entry = this._lastRemovedEntry;
	
	    if (len >= this._maxSize && len > 0) {
	      // Remove the least recently used
	      var leastUsedEntry = list.head;
	      list.remove(leastUsedEntry);
	      delete map[leastUsedEntry.key];
	      removed = leastUsedEntry.value;
	      this._lastRemovedEntry = leastUsedEntry;
	    }
	
	    if (entry) {
	      entry.value = value;
	    } else {
	      entry = new Entry(value);
	    }
	
	    entry.key = key;
	    list.insertEntry(entry);
	    map[key] = entry;
	  }
	
	  return removed;
	};
	/**
	 * @param  {string} key
	 * @return {}
	 */
	
	
	LRUProto.get = function (key) {
	  var entry = this._map[key];
	  var list = this._list;
	
	  if (entry != null) {
	    // Put the latest used entry in the tail
	    if (entry !== list.tail) {
	      list.remove(entry);
	      list.insertEntry(entry);
	    }
	
	    return entry.value;
	  }
	};
	/**
	 * Clear the cache
	 */
	
	
	LRUProto.clear = function () {
	  this._list.clear();
	
	  this._map = {};
	};
	
	var _default = LRU;
	module.exports = _default;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	var _config = __webpack_require__(22);
	
	var debugMode = _config.debugMode;
	
	var log = function () {};
	
	if (debugMode === 1) {
	  log = function () {
	    for (var k in arguments) {
	      throw new Error(arguments[k]);
	    }
	  };
	} else if (debugMode > 1) {
	  log = function () {
	    for (var k in arguments) {
	      console.log(arguments[k]);
	    }
	  };
	}
	
	var _default = log;
	module.exports = _default;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

	var dpr = 1; // If in browser environment
	
	if (typeof window !== 'undefined') {
	  dpr = Math.max(window.devicePixelRatio || 1, 1);
	}
	/**
	 * config默认配置项
	 * @exports zrender/config
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	
	/**
	 * debug日志选项：catchBrushException为true下有效
	 * 0 : 不生成debug数据，发布用
	 * 1 : 异常抛出，调试用
	 * 2 : 控制台输出，调试用
	 */
	
	
	var debugMode = 0; // retina 屏幕优化
	
	var devicePixelRatio = dpr;
	exports.debugMode = debugMode;
	exports.devicePixelRatio = devicePixelRatio;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	var textHelper = __webpack_require__(24);
	
	var BoundingRect = __webpack_require__(26);
	
	/**
	 * Mixin for drawing text in a element bounding rect
	 * @module zrender/mixin/RectText
	 */
	var tmpRect = new BoundingRect();
	
	var RectText = function () {};
	
	RectText.prototype = {
	  constructor: RectText,
	
	  /**
	   * Draw text in a rect with specified position.
	   * @param  {CanvasRenderingContext2D} ctx
	   * @param  {Object} rect Displayable rect
	   */
	  drawRectText: function (ctx, rect) {
	    var style = this.style;
	    rect = style.textRect || rect; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true);
	    var text = style.text; // Convert to string
	
	    text != null && (text += '');
	
	    if (!textHelper.needDrawText(text, style)) {
	      return;
	    } // FIXME
	
	
	    ctx.save(); // Transform rect to view space
	
	    var transform = this.transform;
	
	    if (!style.transformText) {
	      if (transform) {
	        tmpRect.copy(rect);
	        tmpRect.applyTransform(transform);
	        rect = tmpRect;
	      }
	    } else {
	      this.setTransform(ctx);
	    } // transformText and textRotation can not be used at the same time.
	
	
	    textHelper.renderText(this, ctx, text, style, rect);
	    ctx.restore();
	  }
	};
	var _default = RectText;
	module.exports = _default;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	var _util = __webpack_require__(4);
	
	var retrieve2 = _util.retrieve2;
	var retrieve3 = _util.retrieve3;
	var each = _util.each;
	var normalizeCssArray = _util.normalizeCssArray;
	var isString = _util.isString;
	var isObject = _util.isObject;
	
	var textContain = __webpack_require__(25);
	
	var roundRectHelper = __webpack_require__(28);
	
	var imageHelper = __webpack_require__(27);
	
	// TODO: Have not support 'start', 'end' yet.
	var VALID_TEXT_ALIGN = {
	  left: 1,
	  right: 1,
	  center: 1
	};
	var VALID_TEXT_VERTICAL_ALIGN = {
	  top: 1,
	  bottom: 1,
	  middle: 1
	};
	/**
	 * @param {module:zrender/graphic/Style} style
	 * @return {module:zrender/graphic/Style} The input style.
	 */
	
	function normalizeTextStyle(style) {
	  normalizeStyle(style);
	  each(style.rich, normalizeStyle);
	  return style;
	}
	
	function normalizeStyle(style) {
	  if (style) {
	    style.font = textContain.makeFont(style);
	    var textAlign = style.textAlign;
	    textAlign === 'middle' && (textAlign = 'center');
	    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.
	
	    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
	    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');
	    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';
	    var textPadding = style.textPadding;
	
	    if (textPadding) {
	      style.textPadding = normalizeCssArray(style.textPadding);
	    }
	  }
	}
	/**
	 * @param {CanvasRenderingContext2D} ctx
	 * @param {string} text
	 * @param {module:zrender/graphic/Style} style
	 * @param {Object|boolean} [rect] {x, y, width, height}
	 *                  If set false, rect text is not used.
	 */
	
	
	function renderText(hostEl, ctx, text, style, rect) {
	  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);
	}
	
	function renderPlainText(hostEl, ctx, text, style, rect) {
	  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);
	  var textPadding = style.textPadding;
	  var contentBlock = hostEl.__textCotentBlock;
	
	  if (!contentBlock || hostEl.__dirty) {
	    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);
	  }
	
	  var outerHeight = contentBlock.outerHeight;
	  var textLines = contentBlock.lines;
	  var lineHeight = contentBlock.lineHeight;
	  var boxPos = getBoxPosition(outerHeight, style, rect);
	  var baseX = boxPos.baseX;
	  var baseY = boxPos.baseY;
	  var textAlign = boxPos.textAlign;
	  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.
	
	  applyTextRotation(ctx, style, rect, baseX, baseY);
	  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
	  var textX = baseX;
	  var textY = boxY;
	  var needDrawBg = needDrawBackground(style);
	
	  if (needDrawBg || textPadding) {
	    // Consider performance, do not call getTextWidth util necessary.
	    var textWidth = textContain.getWidth(text, font);
	    var outerWidth = textWidth;
	    textPadding && (outerWidth += textPadding[1] + textPadding[3]);
	    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
	    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
	
	    if (textPadding) {
	      textX = getTextXForPadding(baseX, textAlign, textPadding);
	      textY += textPadding[0];
	    }
	  }
	
	  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be "middle". Otherwise, if using "top", the
	  // text will offset downward a little bit in font "Microsoft YaHei".
	
	  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.
	
	  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);
	  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');
	  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);
	  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.
	
	  textY += lineHeight / 2;
	  var textStrokeWidth = style.textStrokeWidth;
	  var textStroke = getStroke(style.textStroke, textStrokeWidth);
	  var textFill = getFill(style.textFill);
	
	  if (textStroke) {
	    setCtx(ctx, 'lineWidth', textStrokeWidth);
	    setCtx(ctx, 'strokeStyle', textStroke);
	  }
	
	  if (textFill) {
	    setCtx(ctx, 'fillStyle', textFill);
	  }
	
	  for (var i = 0; i < textLines.length; i++) {
	    // Fill after stroke so the outline will not cover the main part.
	    textStroke && ctx.strokeText(textLines[i], textX, textY);
	    textFill && ctx.fillText(textLines[i], textX, textY);
	    textY += lineHeight;
	  }
	}
	
	function renderRichText(hostEl, ctx, text, style, rect) {
	  var contentBlock = hostEl.__textCotentBlock;
	
	  if (!contentBlock || hostEl.__dirty) {
	    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);
	  }
	
	  drawRichText(hostEl, ctx, contentBlock, style, rect);
	}
	
	function drawRichText(hostEl, ctx, contentBlock, style, rect) {
	  var contentWidth = contentBlock.width;
	  var outerWidth = contentBlock.outerWidth;
	  var outerHeight = contentBlock.outerHeight;
	  var textPadding = style.textPadding;
	  var boxPos = getBoxPosition(outerHeight, style, rect);
	  var baseX = boxPos.baseX;
	  var baseY = boxPos.baseY;
	  var textAlign = boxPos.textAlign;
	  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.
	
	  applyTextRotation(ctx, style, rect, baseX, baseY);
	  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
	  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
	  var xLeft = boxX;
	  var lineTop = boxY;
	
	  if (textPadding) {
	    xLeft += textPadding[3];
	    lineTop += textPadding[0];
	  }
	
	  var xRight = xLeft + contentWidth;
	  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
	
	  for (var i = 0; i < contentBlock.lines.length; i++) {
	    var line = contentBlock.lines[i];
	    var tokens = line.tokens;
	    var tokenCount = tokens.length;
	    var lineHeight = line.lineHeight;
	    var usedWidth = line.width;
	    var leftIndex = 0;
	    var lineXLeft = xLeft;
	    var lineXRight = xRight;
	    var rightIndex = tokenCount - 1;
	    var token;
	
	    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {
	      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');
	      usedWidth -= token.width;
	      lineXLeft += token.width;
	      leftIndex++;
	    }
	
	    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {
	      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');
	      usedWidth -= token.width;
	      lineXRight -= token.width;
	      rightIndex--;
	    } // The other tokens are placed as textAlign 'center' if there is enough space.
	
	
	    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;
	
	    while (leftIndex <= rightIndex) {
	      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.
	
	      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');
	      lineXLeft += token.width;
	      leftIndex++;
	    }
	
	    lineTop += lineHeight;
	  }
	}
	
	function applyTextRotation(ctx, style, rect, x, y) {
	  // textRotation only apply in RectText.
	  if (rect && style.textRotation) {
	    var origin = style.textOrigin;
	
	    if (origin === 'center') {
	      x = rect.width / 2 + rect.x;
	      y = rect.height / 2 + rect.y;
	    } else if (origin) {
	      x = origin[0] + rect.x;
	      y = origin[1] + rect.y;
	    }
	
	    ctx.translate(x, y); // Positive: anticlockwise
	
	    ctx.rotate(-style.textRotation);
	    ctx.translate(-x, -y);
	  }
	}
	
	function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
	  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of
	  // the bias of "Microsoft YaHei".
	
	  var textVerticalAlign = token.textVerticalAlign;
	  var y = lineTop + lineHeight / 2;
	
	  if (textVerticalAlign === 'top') {
	    y = lineTop + token.height / 2;
	  } else if (textVerticalAlign === 'bottom') {
	    y = lineTop + lineHeight - token.height / 2;
	  }
	
	  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
	  var textPadding = token.textPadding;
	
	  if (textPadding) {
	    x = getTextXForPadding(x, textAlign, textPadding);
	    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
	  }
	
	  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
	  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');
	  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
	  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
	  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be "middle". Otherwise, if using "top", the
	  // text will offset downward a little bit in font "Microsoft YaHei".
	
	  setCtx(ctx, 'textBaseline', 'middle');
	  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);
	  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
	  var textFill = getFill(tokenStyle.textFill || style.textFill);
	  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.
	
	  if (textStroke) {
	    setCtx(ctx, 'lineWidth', textStrokeWidth);
	    setCtx(ctx, 'strokeStyle', textStroke);
	    ctx.strokeText(token.text, x, y);
	  }
	
	  if (textFill) {
	    setCtx(ctx, 'fillStyle', textFill);
	    ctx.fillText(token.text, x, y);
	  }
	}
	
	function needDrawBackground(style) {
	  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;
	} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}
	// shape: {x, y, width, height}
	
	
	function drawBackground(hostEl, ctx, style, x, y, width, height) {
	  var textBackgroundColor = style.textBackgroundColor;
	  var textBorderWidth = style.textBorderWidth;
	  var textBorderColor = style.textBorderColor;
	  var isPlainBg = isString(textBackgroundColor);
	  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);
	  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');
	  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);
	  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);
	
	  if (isPlainBg || textBorderWidth && textBorderColor) {
	    ctx.beginPath();
	    var textBorderRadius = style.textBorderRadius;
	
	    if (!textBorderRadius) {
	      ctx.rect(x, y, width, height);
	    } else {
	      roundRectHelper.buildPath(ctx, {
	        x: x,
	        y: y,
	        width: width,
	        height: height,
	        r: textBorderRadius
	      });
	    }
	
	    ctx.closePath();
	  }
	
	  if (isPlainBg) {
	    setCtx(ctx, 'fillStyle', textBackgroundColor);
	    ctx.fill();
	  } else if (isObject(textBackgroundColor)) {
	    var image = textBackgroundColor.image;
	    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);
	
	    if (image && imageHelper.isImageReady(image)) {
	      ctx.drawImage(image, x, y, width, height);
	    }
	  }
	
	  if (textBorderWidth && textBorderColor) {
	    setCtx(ctx, 'lineWidth', textBorderWidth);
	    setCtx(ctx, 'strokeStyle', textBorderColor);
	    ctx.stroke();
	  }
	}
	
	function onBgImageLoaded(image, textBackgroundColor) {
	  // Replace image, so that `contain/text.js#parseRichText`
	  // will get correct result in next tick.
	  textBackgroundColor.image = image;
	}
	
	function getBoxPosition(blockHeiht, style, rect) {
	  var baseX = style.x || 0;
	  var baseY = style.y || 0;
	  var textAlign = style.textAlign;
	  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord
	
	  if (rect) {
	    var textPosition = style.textPosition;
	
	    if (textPosition instanceof Array) {
	      // Percent
	      baseX = rect.x + parsePercent(textPosition[0], rect.width);
	      baseY = rect.y + parsePercent(textPosition[1], rect.height);
	    } else {
	      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);
	      baseX = res.x;
	      baseY = res.y; // Default align and baseline when has textPosition
	
	      textAlign = textAlign || res.textAlign;
	      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
	    } // textOffset is only support in RectText, otherwise
	    // we have to adjust boundingRect for textOffset.
	
	
	    var textOffset = style.textOffset;
	
	    if (textOffset) {
	      baseX += textOffset[0];
	      baseY += textOffset[1];
	    }
	  }
	
	  return {
	    baseX: baseX,
	    baseY: baseY,
	    textAlign: textAlign,
	    textVerticalAlign: textVerticalAlign
	  };
	}
	
	function setCtx(ctx, prop, value) {
	  // FIXME ??? performance try
	  // if (ctx.__currentValues[prop] !== value) {
	  // ctx[prop] = ctx.__currentValues[prop] = value;
	  ctx[prop] = value; // }
	
	  return ctx[prop];
	}
	/**
	 * @param {string} [stroke] If specified, do not check style.textStroke.
	 * @param {string} [lineWidth] If specified, do not check style.textStroke.
	 * @param {number} style
	 */
	
	
	function getStroke(stroke, lineWidth) {
	  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?
	  : stroke.image || stroke.colorStops ? '#000' : stroke;
	}
	
	function getFill(fill) {
	  return fill == null || fill === 'none' ? null // TODO pattern and gradient?
	  : fill.image || fill.colorStops ? '#000' : fill;
	}
	
	function parsePercent(value, maxValue) {
	  if (typeof value === 'string') {
	    if (value.lastIndexOf('%') >= 0) {
	      return parseFloat(value) / 100 * maxValue;
	    }
	
	    return parseFloat(value);
	  }
	
	  return value;
	}
	
	function getTextXForPadding(x, textAlign, textPadding) {
	  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
	}
	/**
	 * @param {string} text
	 * @param {module:zrender/Style} style
	 * @return {boolean}
	 */
	
	
	function needDrawText(text, style) {
	  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
	}
	
	exports.normalizeTextStyle = normalizeTextStyle;
	exports.renderText = renderText;
	exports.getStroke = getStroke;
	exports.getFill = getFill;
	exports.needDrawText = needDrawText;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var BoundingRect = __webpack_require__(26);
	
	var imageHelper = __webpack_require__(27);
	
	var _util = __webpack_require__(4);
	
	var getContext = _util.getContext;
	var extend = _util.extend;
	var retrieve2 = _util.retrieve2;
	var retrieve3 = _util.retrieve3;
	var textWidthCache = {};
	var textWidthCacheCounter = 0;
	var TEXT_CACHE_MAX = 5000;
	var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
	var DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.
	
	var methods = {};
	
	function $override(name, fn) {
	  methods[name] = fn;
	}
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @return {number} width
	 */
	
	
	function getWidth(text, font) {
	  font = font || DEFAULT_FONT;
	  var key = text + ':' + font;
	
	  if (textWidthCache[key]) {
	    return textWidthCache[key];
	  }
	
	  var textLines = (text + '').split('\n');
	  var width = 0;
	
	  for (var i = 0, l = textLines.length; i < l; i++) {
	    // textContain.measureText may be overrided in SVG or VML
	    width = Math.max(measureText(textLines[i], font).width, width);
	  }
	
	  if (textWidthCacheCounter > TEXT_CACHE_MAX) {
	    textWidthCacheCounter = 0;
	    textWidthCache = {};
	  }
	
	  textWidthCacheCounter++;
	  textWidthCache[key] = width;
	  return width;
	}
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @param {string} [textAlign='left']
	 * @param {string} [textVerticalAlign='top']
	 * @param {Array.<number>} [textPadding]
	 * @param {Object} [rich]
	 * @param {Object} [truncate]
	 * @return {Object} {x, y, width, height, lineHeight}
	 */
	
	
	function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
	  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);
	}
	
	function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {
	  var contentBlock = parsePlainText(text, font, textPadding, truncate);
	  var outerWidth = getWidth(text, font);
	
	  if (textPadding) {
	    outerWidth += textPadding[1] + textPadding[3];
	  }
	
	  var outerHeight = contentBlock.outerHeight;
	  var x = adjustTextX(0, outerWidth, textAlign);
	  var y = adjustTextY(0, outerHeight, textVerticalAlign);
	  var rect = new BoundingRect(x, y, outerWidth, outerHeight);
	  rect.lineHeight = contentBlock.lineHeight;
	  return rect;
	}
	
	function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
	  var contentBlock = parseRichText(text, {
	    rich: rich,
	    truncate: truncate,
	    font: font,
	    textAlign: textAlign,
	    textPadding: textPadding
	  });
	  var outerWidth = contentBlock.outerWidth;
	  var outerHeight = contentBlock.outerHeight;
	  var x = adjustTextX(0, outerWidth, textAlign);
	  var y = adjustTextY(0, outerHeight, textVerticalAlign);
	  return new BoundingRect(x, y, outerWidth, outerHeight);
	}
	/**
	 * @public
	 * @param {number} x
	 * @param {number} width
	 * @param {string} [textAlign='left']
	 * @return {number} Adjusted x.
	 */
	
	
	function adjustTextX(x, width, textAlign) {
	  // FIXME Right to left language
	  if (textAlign === 'right') {
	    x -= width;
	  } else if (textAlign === 'center') {
	    x -= width / 2;
	  }
	
	  return x;
	}
	/**
	 * @public
	 * @param {number} y
	 * @param {number} height
	 * @param {string} [textVerticalAlign='top']
	 * @return {number} Adjusted y.
	 */
	
	
	function adjustTextY(y, height, textVerticalAlign) {
	  if (textVerticalAlign === 'middle') {
	    y -= height / 2;
	  } else if (textVerticalAlign === 'bottom') {
	    y -= height;
	  }
	
	  return y;
	}
	/**
	 * @public
	 * @param {stirng} textPosition
	 * @param {Object} rect {x, y, width, height}
	 * @param {number} distance
	 * @return {Object} {x, y, textAlign, textVerticalAlign}
	 */
	
	
	function adjustTextPositionOnRect(textPosition, rect, distance) {
	  var x = rect.x;
	  var y = rect.y;
	  var height = rect.height;
	  var width = rect.width;
	  var halfHeight = height / 2;
	  var textAlign = 'left';
	  var textVerticalAlign = 'top';
	
	  switch (textPosition) {
	    case 'left':
	      x -= distance;
	      y += halfHeight;
	      textAlign = 'right';
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'right':
	      x += distance + width;
	      y += halfHeight;
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'top':
	      x += width / 2;
	      y -= distance;
	      textAlign = 'center';
	      textVerticalAlign = 'bottom';
	      break;
	
	    case 'bottom':
	      x += width / 2;
	      y += height + distance;
	      textAlign = 'center';
	      break;
	
	    case 'inside':
	      x += width / 2;
	      y += halfHeight;
	      textAlign = 'center';
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'insideLeft':
	      x += distance;
	      y += halfHeight;
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'insideRight':
	      x += width - distance;
	      y += halfHeight;
	      textAlign = 'right';
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'insideTop':
	      x += width / 2;
	      y += distance;
	      textAlign = 'center';
	      break;
	
	    case 'insideBottom':
	      x += width / 2;
	      y += height - distance;
	      textAlign = 'center';
	      textVerticalAlign = 'bottom';
	      break;
	
	    case 'insideTopLeft':
	      x += distance;
	      y += distance;
	      break;
	
	    case 'insideTopRight':
	      x += width - distance;
	      y += distance;
	      textAlign = 'right';
	      break;
	
	    case 'insideBottomLeft':
	      x += distance;
	      y += height - distance;
	      textVerticalAlign = 'bottom';
	      break;
	
	    case 'insideBottomRight':
	      x += width - distance;
	      y += height - distance;
	      textAlign = 'right';
	      textVerticalAlign = 'bottom';
	      break;
	  }
	
	  return {
	    x: x,
	    y: y,
	    textAlign: textAlign,
	    textVerticalAlign: textVerticalAlign
	  };
	}
	/**
	 * Show ellipsis if overflow.
	 *
	 * @public
	 * @param  {string} text
	 * @param  {string} containerWidth
	 * @param  {string} font
	 * @param  {number} [ellipsis='...']
	 * @param  {Object} [options]
	 * @param  {number} [options.maxIterations=3]
	 * @param  {number} [options.minChar=0] If truncate result are less
	 *                  then minChar, ellipsis will not show, which is
	 *                  better for user hint in some cases.
	 * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
	 * @return {string}
	 */
	
	
	function truncateText(text, containerWidth, font, ellipsis, options) {
	  if (!containerWidth) {
	    return '';
	  }
	
	  var textLines = (text + '').split('\n');
	  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME
	  // It is not appropriate that every line has '...' when truncate multiple lines.
	
	  for (var i = 0, len = textLines.length; i < len; i++) {
	    textLines[i] = truncateSingleLine(textLines[i], options);
	  }
	
	  return textLines.join('\n');
	}
	
	function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
	  options = extend({}, options);
	  options.font = font;
	  var ellipsis = retrieve2(ellipsis, '...');
	  options.maxIterations = retrieve2(options.maxIterations, 2);
	  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME
	  // Other languages?
	
	  options.cnCharWidth = getWidth('国', font); // FIXME
	  // Consider proportional font?
	
	  var ascCharWidth = options.ascCharWidth = getWidth('a', font);
	  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
	  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.
	
	  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.
	
	  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
	    contentWidth -= ascCharWidth;
	  }
	
	  var ellipsisWidth = getWidth(ellipsis);
	
	  if (ellipsisWidth > contentWidth) {
	    ellipsis = '';
	    ellipsisWidth = 0;
	  }
	
	  contentWidth = containerWidth - ellipsisWidth;
	  options.ellipsis = ellipsis;
	  options.ellipsisWidth = ellipsisWidth;
	  options.contentWidth = contentWidth;
	  options.containerWidth = containerWidth;
	  return options;
	}
	
	function truncateSingleLine(textLine, options) {
	  var containerWidth = options.containerWidth;
	  var font = options.font;
	  var contentWidth = options.contentWidth;
	
	  if (!containerWidth) {
	    return '';
	  }
	
	  var lineWidth = getWidth(textLine, font);
	
	  if (lineWidth <= containerWidth) {
	    return textLine;
	  }
	
	  for (var j = 0;; j++) {
	    if (lineWidth <= contentWidth || j >= options.maxIterations) {
	      textLine += options.ellipsis;
	      break;
	    }
	
	    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
	    textLine = textLine.substr(0, subLength);
	    lineWidth = getWidth(textLine, font);
	  }
	
	  if (textLine === '') {
	    textLine = options.placeholder;
	  }
	
	  return textLine;
	}
	
	function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
	  var width = 0;
	  var i = 0;
	
	  for (var len = text.length; i < len && width < contentWidth; i++) {
	    var charCode = text.charCodeAt(i);
	    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
	  }
	
	  return i;
	}
	/**
	 * @public
	 * @param {string} font
	 * @return {number} line height
	 */
	
	
	function getLineHeight(font) {
	  // FIXME A rough approach.
	  return getWidth('国', font);
	}
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @return {Object} width
	 */
	
	
	function measureText(text, font) {
	  return methods.measureText(text, font);
	} // Avoid assign to an exported variable, for transforming to cjs.
	
	
	methods.measureText = function (text, font) {
	  var ctx = getContext();
	  ctx.font = font || DEFAULT_FONT;
	  return ctx.measureText(text);
	};
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @param {Object} [truncate]
	 * @return {Object} block: {lineHeight, lines, height, outerHeight}
	 *  Notice: for performance, do not calculate outerWidth util needed.
	 */
	
	
	function parsePlainText(text, font, padding, truncate) {
	  text != null && (text += '');
	  var lineHeight = getLineHeight(font);
	  var lines = text ? text.split('\n') : [];
	  var height = lines.length * lineHeight;
	  var outerHeight = height;
	
	  if (padding) {
	    outerHeight += padding[0] + padding[2];
	  }
	
	  if (text && truncate) {
	    var truncOuterHeight = truncate.outerHeight;
	    var truncOuterWidth = truncate.outerWidth;
	
	    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
	      text = '';
	      lines = [];
	    } else if (truncOuterWidth != null) {
	      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
	        minChar: truncate.minChar,
	        placeholder: truncate.placeholder
	      }); // FIXME
	      // It is not appropriate that every line has '...' when truncate multiple lines.
	
	      for (var i = 0, len = lines.length; i < len; i++) {
	        lines[i] = truncateSingleLine(lines[i], options);
	      }
	    }
	  }
	
	  return {
	    lines: lines,
	    height: height,
	    outerHeight: outerHeight,
	    lineHeight: lineHeight
	  };
	}
	/**
	 * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
	 * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
	 *
	 * @public
	 * @param {string} text
	 * @param {Object} style
	 * @return {Object} block
	 * {
	 *      width,
	 *      height,
	 *      lines: [{
	 *          lineHeight,
	 *          width,
	 *          tokens: [[{
	 *              styleName,
	 *              text,
	 *              width,      // include textPadding
	 *              height,     // include textPadding
	 *              textWidth, // pure text width
	 *              textHeight, // pure text height
	 *              lineHeihgt,
	 *              font,
	 *              textAlign,
	 *              textVerticalAlign
	 *          }], [...], ...]
	 *      }, ...]
	 * }
	 * If styleName is undefined, it is plain text.
	 */
	
	
	function parseRichText(text, style) {
	  var contentBlock = {
	    lines: [],
	    width: 0,
	    height: 0
	  };
	  text != null && (text += '');
	
	  if (!text) {
	    return contentBlock;
	  }
	
	  var lastIndex = STYLE_REG.lastIndex = 0;
	  var result;
	
	  while ((result = STYLE_REG.exec(text)) != null) {
	    var matchedIndex = result.index;
	
	    if (matchedIndex > lastIndex) {
	      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
	    }
	
	    pushTokens(contentBlock, result[2], result[1]);
	    lastIndex = STYLE_REG.lastIndex;
	  }
	
	  if (lastIndex < text.length) {
	    pushTokens(contentBlock, text.substring(lastIndex, text.length));
	  }
	
	  var lines = contentBlock.lines;
	  var contentHeight = 0;
	  var contentWidth = 0; // For `textWidth: 100%`
	
	  var pendingList = [];
	  var stlPadding = style.textPadding;
	  var truncate = style.truncate;
	  var truncateWidth = truncate && truncate.outerWidth;
	  var truncateHeight = truncate && truncate.outerHeight;
	
	  if (stlPadding) {
	    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
	    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
	  } // Calculate layout info of tokens.
	
	
	  for (var i = 0; i < lines.length; i++) {
	    var line = lines[i];
	    var lineHeight = 0;
	    var lineWidth = 0;
	
	    for (var j = 0; j < line.tokens.length; j++) {
	      var token = line.tokens[j];
	      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.
	
	      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.
	
	      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.
	
	      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified
	      // as box height of the block.
	      tokenStyle.textHeight, getLineHeight(font));
	      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
	      token.height = tokenHeight;
	      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);
	      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
	      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';
	
	      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
	        return {
	          lines: [],
	          width: 0,
	          height: 0
	        };
	      }
	
	      token.textWidth = getWidth(token.text, font);
	      var tokenWidth = tokenStyle.textWidth;
	      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate
	      // line when box width is needed to be auto.
	
	      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {
	        token.percentWidth = tokenWidth;
	        pendingList.push(token);
	        tokenWidth = 0; // Do not truncate in this case, because there is no user case
	        // and it is too complicated.
	      } else {
	        if (tokenWidthNotSpecified) {
	          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling
	          // `getBoundingRect()` will not get correct result.
	
	          var textBackgroundColor = tokenStyle.textBackgroundColor;
	          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:
	          // (1) If image is not loaded, it will be loaded at render phase and call
	          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded
	          // image, and then the right size will be calculated here at the next tick.
	          // See `graphic/helper/text.js`.
	          // (2) If image loaded, and `textBackgroundColor.image` is image src string,
	          // use `imageHelper.findExistImage` to find cached image.
	          // `imageHelper.findExistImage` will always be called here before
	          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`
	          // which ensures that image will not be rendered before correct size calcualted.
	
	          if (bgImg) {
	            bgImg = imageHelper.findExistImage(bgImg);
	
	            if (imageHelper.isImageReady(bgImg)) {
	              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
	            }
	          }
	        }
	
	        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
	        tokenWidth += paddingW;
	        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;
	
	        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
	          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
	            token.text = '';
	            token.textWidth = tokenWidth = 0;
	          } else {
	            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
	              minChar: truncate.minChar
	            });
	            token.textWidth = getWidth(token.text, font);
	            tokenWidth = token.textWidth + paddingW;
	          }
	        }
	      }
	
	      lineWidth += token.width = tokenWidth;
	      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
	    }
	
	    line.width = lineWidth;
	    line.lineHeight = lineHeight;
	    contentHeight += lineHeight;
	    contentWidth = Math.max(contentWidth, lineWidth);
	  }
	
	  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);
	  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);
	
	  if (stlPadding) {
	    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
	    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
	  }
	
	  for (var i = 0; i < pendingList.length; i++) {
	    var token = pendingList[i];
	    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.
	
	    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
	  }
	
	  return contentBlock;
	}
	
	function pushTokens(block, str, styleName) {
	  var isEmptyStr = str === '';
	  var strs = str.split('\n');
	  var lines = block.lines;
	
	  for (var i = 0; i < strs.length; i++) {
	    var text = strs[i];
	    var token = {
	      styleName: styleName,
	      text: text,
	      isLineHolder: !text && !isEmptyStr
	    }; // The first token should be appended to the last line.
	
	    if (!i) {
	      var tokens = (lines[lines.length - 1] || (lines[0] = {
	        tokens: []
	      })).tokens; // Consider cases:
	      // (1) ''.split('\n') => ['', '\n', ''], the '' at the first item
	      // (which is a placeholder) should be replaced by new token.
	      // (2) A image backage, where token likes {a|}.
	      // (3) A redundant '' will affect textAlign in line.
	      // (4) tokens with the same tplName should not be merged, because
	      // they should be displayed in different box (with border and padding).
	
	      var tokensLen = tokens.length;
	      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the "lineHolder" or
	      // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
	      (text || !tokensLen || isEmptyStr) && tokens.push(token);
	    } // Other tokens always start a new line.
	    else {
	        // If there is '', insert it as a placeholder.
	        lines.push({
	          tokens: [token]
	        });
	      }
	  }
	}
	
	function makeFont(style) {
	  // FIXME in node-canvas fontWeight is before fontStyle
	  // Use `fontSize` `fontFamily` to check whether font properties are defined.
	  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.
	  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;
	}
	
	exports.DEFAULT_FONT = DEFAULT_FONT;
	exports.$override = $override;
	exports.getWidth = getWidth;
	exports.getBoundingRect = getBoundingRect;
	exports.adjustTextX = adjustTextX;
	exports.adjustTextY = adjustTextY;
	exports.adjustTextPositionOnRect = adjustTextPositionOnRect;
	exports.truncateText = truncateText;
	exports.getLineHeight = getLineHeight;
	exports.measureText = measureText;
	exports.parsePlainText = parsePlainText;
	exports.parseRichText = parseRichText;
	exports.makeFont = makeFont;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(14);
	
	var matrix = __webpack_require__(13);
	
	/**
	 * @module echarts/core/BoundingRect
	 */
	var v2ApplyTransform = vec2.applyTransform;
	var mathMin = Math.min;
	var mathMax = Math.max;
	/**
	 * @alias module:echarts/core/BoundingRect
	 */
	
	function BoundingRect(x, y, width, height) {
	  if (width < 0) {
	    x = x + width;
	    width = -width;
	  }
	
	  if (height < 0) {
	    y = y + height;
	    height = -height;
	  }
	  /**
	   * @type {number}
	   */
	
	
	  this.x = x;
	  /**
	   * @type {number}
	   */
	
	  this.y = y;
	  /**
	   * @type {number}
	   */
	
	  this.width = width;
	  /**
	   * @type {number}
	   */
	
	  this.height = height;
	}
	
	BoundingRect.prototype = {
	  constructor: BoundingRect,
	
	  /**
	   * @param {module:echarts/core/BoundingRect} other
	   */
	  union: function (other) {
	    var x = mathMin(other.x, this.x);
	    var y = mathMin(other.y, this.y);
	    this.width = mathMax(other.x + other.width, this.x + this.width) - x;
	    this.height = mathMax(other.y + other.height, this.y + this.height) - y;
	    this.x = x;
	    this.y = y;
	  },
	
	  /**
	   * @param {Array.<number>} m
	   * @methods
	   */
	  applyTransform: function () {
	    var lt = [];
	    var rb = [];
	    var lb = [];
	    var rt = [];
	    return function (m) {
	      // In case usage like this
	      // el.getBoundingRect().applyTransform(el.transform)
	      // And element has no transform
	      if (!m) {
	        return;
	      }
	
	      lt[0] = lb[0] = this.x;
	      lt[1] = rt[1] = this.y;
	      rb[0] = rt[0] = this.x + this.width;
	      rb[1] = lb[1] = this.y + this.height;
	      v2ApplyTransform(lt, lt, m);
	      v2ApplyTransform(rb, rb, m);
	      v2ApplyTransform(lb, lb, m);
	      v2ApplyTransform(rt, rt, m);
	      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
	      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
	      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
	      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
	      this.width = maxX - this.x;
	      this.height = maxY - this.y;
	    };
	  }(),
	
	  /**
	   * Calculate matrix of transforming from self to target rect
	   * @param  {module:zrender/core/BoundingRect} b
	   * @return {Array.<number>}
	   */
	  calculateTransform: function (b) {
	    var a = this;
	    var sx = b.width / a.width;
	    var sy = b.height / a.height;
	    var m = matrix.create(); // 矩阵右乘
	
	    matrix.translate(m, m, [-a.x, -a.y]);
	    matrix.scale(m, m, [sx, sy]);
	    matrix.translate(m, m, [b.x, b.y]);
	    return m;
	  },
	
	  /**
	   * @param {(module:echarts/core/BoundingRect|Object)} b
	   * @return {boolean}
	   */
	  intersect: function (b) {
	    if (!b) {
	      return false;
	    }
	
	    if (!(b instanceof BoundingRect)) {
	      // Normalize negative width/height.
	      b = BoundingRect.create(b);
	    }
	
	    var a = this;
	    var ax0 = a.x;
	    var ax1 = a.x + a.width;
	    var ay0 = a.y;
	    var ay1 = a.y + a.height;
	    var bx0 = b.x;
	    var bx1 = b.x + b.width;
	    var by0 = b.y;
	    var by1 = b.y + b.height;
	    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
	  },
	  contain: function (x, y) {
	    var rect = this;
	    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
	  },
	
	  /**
	   * @return {module:echarts/core/BoundingRect}
	   */
	  clone: function () {
	    return new BoundingRect(this.x, this.y, this.width, this.height);
	  },
	
	  /**
	   * Copy from another rect
	   */
	  copy: function (other) {
	    this.x = other.x;
	    this.y = other.y;
	    this.width = other.width;
	    this.height = other.height;
	  },
	  plain: function () {
	    return {
	      x: this.x,
	      y: this.y,
	      width: this.width,
	      height: this.height
	    };
	  }
	};
	/**
	 * @param {Object|module:zrender/core/BoundingRect} rect
	 * @param {number} rect.x
	 * @param {number} rect.y
	 * @param {number} rect.width
	 * @param {number} rect.height
	 * @return {module:zrender/core/BoundingRect}
	 */
	
	BoundingRect.create = function (rect) {
	  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
	};
	
	var _default = BoundingRect;
	module.exports = _default;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	var LRU = __webpack_require__(20);
	
	var globalImageCache = new LRU(50);
	/**
	 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
	 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
	 */
	
	function findExistImage(newImageOrSrc) {
	  if (typeof newImageOrSrc === 'string') {
	    var cachedImgObj = globalImageCache.get(newImageOrSrc);
	    return cachedImgObj && cachedImgObj.image;
	  } else {
	    return newImageOrSrc;
	  }
	}
	/**
	 * Caution: User should cache loaded images, but not just count on LRU.
	 * Consider if required images more than LRU size, will dead loop occur?
	 *
	 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
	 * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
	 * @param {module:zrender/Element} [hostEl] For calling `dirty`.
	 * @param {Function} [cb] params: (image, cbPayload)
	 * @param {Object} [cbPayload] Payload on cb calling.
	 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
	 */
	
	
	function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
	  if (!newImageOrSrc) {
	    return image;
	  } else if (typeof newImageOrSrc === 'string') {
	    // Image should not be loaded repeatly.
	    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
	      return image;
	    } // Only when there is no existent image or existent image src
	    // is different, this method is responsible for load.
	
	
	    var cachedImgObj = globalImageCache.get(newImageOrSrc);
	    var pendingWrap = {
	      hostEl: hostEl,
	      cb: cb,
	      cbPayload: cbPayload
	    };
	
	    if (cachedImgObj) {
	      image = cachedImgObj.image;
	      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
	    } else {
	      !image && (image = new Image());
	      image.onload = imageOnLoad;
	      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
	        image: image,
	        pending: [pendingWrap]
	      });
	      image.src = image.__zrImageSrc = newImageOrSrc;
	    }
	
	    return image;
	  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas
	  else {
	      return newImageOrSrc;
	    }
	}
	
	function imageOnLoad() {
	  var cachedImgObj = this.__cachedImgObj;
	  this.onload = this.__cachedImgObj = null;
	
	  for (var i = 0; i < cachedImgObj.pending.length; i++) {
	    var pendingWrap = cachedImgObj.pending[i];
	    var cb = pendingWrap.cb;
	    cb && cb(this, pendingWrap.cbPayload);
	    pendingWrap.hostEl.dirty();
	  }
	
	  cachedImgObj.pending.length = 0;
	}
	
	function isImageReady(image) {
	  return image && image.width && image.height;
	}
	
	exports.findExistImage = findExistImage;
	exports.createOrUpdateImage = createOrUpdateImage;
	exports.isImageReady = isImageReady;

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	function buildPath(ctx, shape) {
	  var x = shape.x;
	  var y = shape.y;
	  var width = shape.width;
	  var height = shape.height;
	  var r = shape.r;
	  var r1;
	  var r2;
	  var r3;
	  var r4; // Convert width and height to positive for better borderRadius
	
	  if (width < 0) {
	    x = x + width;
	    width = -width;
	  }
	
	  if (height < 0) {
	    y = y + height;
	    height = -height;
	  }
	
	  if (typeof r === 'number') {
	    r1 = r2 = r3 = r4 = r;
	  } else if (r instanceof Array) {
	    if (r.length === 1) {
	      r1 = r2 = r3 = r4 = r[0];
	    } else if (r.length === 2) {
	      r1 = r3 = r[0];
	      r2 = r4 = r[1];
	    } else if (r.length === 3) {
	      r1 = r[0];
	      r2 = r4 = r[1];
	      r3 = r[2];
	    } else {
	      r1 = r[0];
	      r2 = r[1];
	      r3 = r[2];
	      r4 = r[3];
	    }
	  } else {
	    r1 = r2 = r3 = r4 = 0;
	  }
	
	  var total;
	
	  if (r1 + r2 > width) {
	    total = r1 + r2;
	    r1 *= width / total;
	    r2 *= width / total;
	  }
	
	  if (r3 + r4 > width) {
	    total = r3 + r4;
	    r3 *= width / total;
	    r4 *= width / total;
	  }
	
	  if (r2 + r3 > height) {
	    total = r2 + r3;
	    r2 *= height / total;
	    r3 *= height / total;
	  }
	
	  if (r1 + r4 > height) {
	    total = r1 + r4;
	    r1 *= height / total;
	    r4 *= height / total;
	  }
	
	  ctx.moveTo(x + r1, y);
	  ctx.lineTo(x + width - r2, y);
	  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);
	  ctx.lineTo(x + width, y + height - r3);
	  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);
	  ctx.lineTo(x + r4, y + height);
	  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);
	  ctx.lineTo(x, y + r1);
	  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
	}
	
	exports.buildPath = buildPath;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	var curve = __webpack_require__(30);
	
	var vec2 = __webpack_require__(14);
	
	var bbox = __webpack_require__(31);
	
	var BoundingRect = __webpack_require__(26);
	
	var _config = __webpack_require__(22);
	
	var dpr = _config.devicePixelRatio;
	
	/**
	 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
	 * 可以用于 isInsidePath 判断以及获取boundingRect
	 *
	 * @module zrender/core/PathProxy
	 * @author Yi Shen (http://www.github.com/pissang)
	 */
	// TODO getTotalLength, getPointAtLength
	var CMD = {
	  M: 1,
	  L: 2,
	  C: 3,
	  Q: 4,
	  A: 5,
	  Z: 6,
	  // Rect
	  R: 7
	}; // var CMD_MEM_SIZE = {
	//     M: 3,
	//     L: 3,
	//     C: 7,
	//     Q: 5,
	//     A: 9,
	//     R: 5,
	//     Z: 1
	// };
	
	var min = [];
	var max = [];
	var min2 = [];
	var max2 = [];
	var mathMin = Math.min;
	var mathMax = Math.max;
	var mathCos = Math.cos;
	var mathSin = Math.sin;
	var mathSqrt = Math.sqrt;
	var mathAbs = Math.abs;
	var hasTypedArray = typeof Float32Array != 'undefined';
	/**
	 * @alias module:zrender/core/PathProxy
	 * @constructor
	 */
	
	var PathProxy = function (notSaveData) {
	  this._saveData = !(notSaveData || false);
	
	  if (this._saveData) {
	    /**
	     * Path data. Stored as flat array
	     * @type {Array.<Object>}
	     */
	    this.data = [];
	  }
	
	  this._ctx = null;
	};
	/**
	 * 快速计算Path包围盒（并不是最小包围盒）
	 * @return {Object}
	 */
	
	
	PathProxy.prototype = {
	  constructor: PathProxy,
	  _xi: 0,
	  _yi: 0,
	  _x0: 0,
	  _y0: 0,
	  // Unit x, Unit y. Provide for avoiding drawing that too short line segment
	  _ux: 0,
	  _uy: 0,
	  _len: 0,
	  _lineDash: null,
	  _dashOffset: 0,
	  _dashIdx: 0,
	  _dashSum: 0,
	
	  /**
	   * @readOnly
	   */
	  setScale: function (sx, sy) {
	    this._ux = mathAbs(1 / dpr / sx) || 0;
	    this._uy = mathAbs(1 / dpr / sy) || 0;
	  },
	  getContext: function () {
	    return this._ctx;
	  },
	
	  /**
	   * @param  {CanvasRenderingContext2D} ctx
	   * @return {module:zrender/core/PathProxy}
	   */
	  beginPath: function (ctx) {
	    this._ctx = ctx;
	    ctx && ctx.beginPath();
	    ctx && (this.dpr = ctx.dpr); // Reset
	
	    if (this._saveData) {
	      this._len = 0;
	    }
	
	    if (this._lineDash) {
	      this._lineDash = null;
	      this._dashOffset = 0;
	    }
	
	    return this;
	  },
	
	  /**
	   * @param  {number} x
	   * @param  {number} y
	   * @return {module:zrender/core/PathProxy}
	   */
	  moveTo: function (x, y) {
	    this.addData(CMD.M, x, y);
	    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
	    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
	    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
	    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
	
	    this._x0 = x;
	    this._y0 = y;
	    this._xi = x;
	    this._yi = y;
	    return this;
	  },
	
	  /**
	   * @param  {number} x
	   * @param  {number} y
	   * @return {module:zrender/core/PathProxy}
	   */
	  lineTo: function (x, y) {
	    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment
	    || this._len < 5;
	    this.addData(CMD.L, x, y);
	
	    if (this._ctx && exceedUnit) {
	      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
	    }
	
	    if (exceedUnit) {
	      this._xi = x;
	      this._yi = y;
	    }
	
	    return this;
	  },
	
	  /**
	   * @param  {number} x1
	   * @param  {number} y1
	   * @param  {number} x2
	   * @param  {number} y2
	   * @param  {number} x3
	   * @param  {number} y3
	   * @return {module:zrender/core/PathProxy}
	   */
	  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
	    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
	
	    if (this._ctx) {
	      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
	    }
	
	    this._xi = x3;
	    this._yi = y3;
	    return this;
	  },
	
	  /**
	   * @param  {number} x1
	   * @param  {number} y1
	   * @param  {number} x2
	   * @param  {number} y2
	   * @return {module:zrender/core/PathProxy}
	   */
	  quadraticCurveTo: function (x1, y1, x2, y2) {
	    this.addData(CMD.Q, x1, y1, x2, y2);
	
	    if (this._ctx) {
	      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
	    }
	
	    this._xi = x2;
	    this._yi = y2;
	    return this;
	  },
	
	  /**
	   * @param  {number} cx
	   * @param  {number} cy
	   * @param  {number} r
	   * @param  {number} startAngle
	   * @param  {number} endAngle
	   * @param  {boolean} anticlockwise
	   * @return {module:zrender/core/PathProxy}
	   */
	  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
	    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
	    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
	    this._xi = mathCos(endAngle) * r + cx;
	    this._yi = mathSin(endAngle) * r + cx;
	    return this;
	  },
	  // TODO
	  arcTo: function (x1, y1, x2, y2, radius) {
	    if (this._ctx) {
	      this._ctx.arcTo(x1, y1, x2, y2, radius);
	    }
	
	    return this;
	  },
	  // TODO
	  rect: function (x, y, w, h) {
	    this._ctx && this._ctx.rect(x, y, w, h);
	    this.addData(CMD.R, x, y, w, h);
	    return this;
	  },
	
	  /**
	   * @return {module:zrender/core/PathProxy}
	   */
	  closePath: function () {
	    this.addData(CMD.Z);
	    var ctx = this._ctx;
	    var x0 = this._x0;
	    var y0 = this._y0;
	
	    if (ctx) {
	      this._needsDash() && this._dashedLineTo(x0, y0);
	      ctx.closePath();
	    }
	
	    this._xi = x0;
	    this._yi = y0;
	    return this;
	  },
	
	  /**
	   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
	   * stroke 同样
	   * @param {CanvasRenderingContext2D} ctx
	   * @return {module:zrender/core/PathProxy}
	   */
	  fill: function (ctx) {
	    ctx && ctx.fill();
	    this.toStatic();
	  },
	
	  /**
	   * @param {CanvasRenderingContext2D} ctx
	   * @return {module:zrender/core/PathProxy}
	   */
	  stroke: function (ctx) {
	    ctx && ctx.stroke();
	    this.toStatic();
	  },
	
	  /**
	   * 必须在其它绘制命令前调用
	   * Must be invoked before all other path drawing methods
	   * @return {module:zrender/core/PathProxy}
	   */
	  setLineDash: function (lineDash) {
	    if (lineDash instanceof Array) {
	      this._lineDash = lineDash;
	      this._dashIdx = 0;
	      var lineDashSum = 0;
	
	      for (var i = 0; i < lineDash.length; i++) {
	        lineDashSum += lineDash[i];
	      }
	
	      this._dashSum = lineDashSum;
	    }
	
	    return this;
	  },
	
	  /**
	   * 必须在其它绘制命令前调用
	   * Must be invoked before all other path drawing methods
	   * @return {module:zrender/core/PathProxy}
	   */
	  setLineDashOffset: function (offset) {
	    this._dashOffset = offset;
	    return this;
	  },
	
	  /**
	   *
	   * @return {boolean}
	   */
	  len: function () {
	    return this._len;
	  },
	
	  /**
	   * 直接设置 Path 数据
	   */
	  setData: function (data) {
	    var len = data.length;
	
	    if (!(this.data && this.data.length == len) && hasTypedArray) {
	      this.data = new Float32Array(len);
	    }
	
	    for (var i = 0; i < len; i++) {
	      this.data[i] = data[i];
	    }
	
	    this._len = len;
	  },
	
	  /**
	   * 添加子路径
	   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
	   */
	  appendPath: function (path) {
	    if (!(path instanceof Array)) {
	      path = [path];
	    }
	
	    var len = path.length;
	    var appendSize = 0;
	    var offset = this._len;
	
	    for (var i = 0; i < len; i++) {
	      appendSize += path[i].len();
	    }
	
	    if (hasTypedArray && this.data instanceof Float32Array) {
	      this.data = new Float32Array(offset + appendSize);
	    }
	
	    for (var i = 0; i < len; i++) {
	      var appendPathData = path[i].data;
	
	      for (var k = 0; k < appendPathData.length; k++) {
	        this.data[offset++] = appendPathData[k];
	      }
	    }
	
	    this._len = offset;
	  },
	
	  /**
	   * 填充 Path 数据。
	   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
	   */
	  addData: function (cmd) {
	    if (!this._saveData) {
	      return;
	    }
	
	    var data = this.data;
	
	    if (this._len + arguments.length > data.length) {
	      // 因为之前的数组已经转换成静态的 Float32Array
	      // 所以不够用时需要扩展一个新的动态数组
	      this._expandData();
	
	      data = this.data;
	    }
	
	    for (var i = 0; i < arguments.length; i++) {
	      data[this._len++] = arguments[i];
	    }
	
	    this._prevCmd = cmd;
	  },
	  _expandData: function () {
	    // Only if data is Float32Array
	    if (!(this.data instanceof Array)) {
	      var newData = [];
	
	      for (var i = 0; i < this._len; i++) {
	        newData[i] = this.data[i];
	      }
	
	      this.data = newData;
	    }
	  },
	
	  /**
	   * If needs js implemented dashed line
	   * @return {boolean}
	   * @private
	   */
	  _needsDash: function () {
	    return this._lineDash;
	  },
	  _dashedLineTo: function (x1, y1) {
	    var dashSum = this._dashSum;
	    var offset = this._dashOffset;
	    var lineDash = this._lineDash;
	    var ctx = this._ctx;
	    var x0 = this._xi;
	    var y0 = this._yi;
	    var dx = x1 - x0;
	    var dy = y1 - y0;
	    var dist = mathSqrt(dx * dx + dy * dy);
	    var x = x0;
	    var y = y0;
	    var dash;
	    var nDash = lineDash.length;
	    var idx;
	    dx /= dist;
	    dy /= dist;
	
	    if (offset < 0) {
	      // Convert to positive offset
	      offset = dashSum + offset;
	    }
	
	    offset %= dashSum;
	    x -= offset * dx;
	    y -= offset * dy;
	
	    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
	      idx = this._dashIdx;
	      dash = lineDash[idx];
	      x += dx * dash;
	      y += dy * dash;
	      this._dashIdx = (idx + 1) % nDash; // Skip positive offset
	
	      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
	        continue;
	      }
	
	      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));
	    } // Offset for next lineTo
	
	
	    dx = x - x1;
	    dy = y - y1;
	    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	  },
	  // Not accurate dashed line to
	  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
	    var dashSum = this._dashSum;
	    var offset = this._dashOffset;
	    var lineDash = this._lineDash;
	    var ctx = this._ctx;
	    var x0 = this._xi;
	    var y0 = this._yi;
	    var t;
	    var dx;
	    var dy;
	    var cubicAt = curve.cubicAt;
	    var bezierLen = 0;
	    var idx = this._dashIdx;
	    var nDash = lineDash.length;
	    var x;
	    var y;
	    var tmpLen = 0;
	
	    if (offset < 0) {
	      // Convert to positive offset
	      offset = dashSum + offset;
	    }
	
	    offset %= dashSum; // Bezier approx length
	
	    for (t = 0; t < 1; t += 0.1) {
	      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
	      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
	      bezierLen += mathSqrt(dx * dx + dy * dy);
	    } // Find idx after add offset
	
	
	    for (; idx < nDash; idx++) {
	      tmpLen += lineDash[idx];
	
	      if (tmpLen > offset) {
	        break;
	      }
	    }
	
	    t = (tmpLen - offset) / bezierLen;
	
	    while (t <= 1) {
	      x = cubicAt(x0, x1, x2, x3, t);
	      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier
	      // Bad result if dash is long
	
	      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
	      t += lineDash[idx] / bezierLen;
	      idx = (idx + 1) % nDash;
	    } // Finish the last segment and calculate the new offset
	
	
	    idx % 2 !== 0 && ctx.lineTo(x3, y3);
	    dx = x3 - x;
	    dy = y3 - y;
	    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	  },
	  _dashedQuadraticTo: function (x1, y1, x2, y2) {
	    // Convert quadratic to cubic using degree elevation
	    var x3 = x2;
	    var y3 = y2;
	    x2 = (x2 + 2 * x1) / 3;
	    y2 = (y2 + 2 * y1) / 3;
	    x1 = (this._xi + 2 * x1) / 3;
	    y1 = (this._yi + 2 * y1) / 3;
	
	    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
	  },
	
	  /**
	   * 转成静态的 Float32Array 减少堆内存占用
	   * Convert dynamic array to static Float32Array
	   */
	  toStatic: function () {
	    var data = this.data;
	
	    if (data instanceof Array) {
	      data.length = this._len;
	
	      if (hasTypedArray) {
	        this.data = new Float32Array(data);
	      }
	    }
	  },
	
	  /**
	   * @return {module:zrender/core/BoundingRect}
	   */
	  getBoundingRect: function () {
	    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
	    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
	    var data = this.data;
	    var xi = 0;
	    var yi = 0;
	    var x0 = 0;
	    var y0 = 0;
	
	    for (var i = 0; i < data.length;) {
	      var cmd = data[i++];
	
	      if (i == 1) {
	        // 如果第一个命令是 L, C, Q
	        // 则 previous point 同绘制命令的第一个 point
	        //
	        // 第一个命令为 Arc 的情况下会在后面特殊处理
	        xi = data[i];
	        yi = data[i + 1];
	        x0 = xi;
	        y0 = yi;
	      }
	
	      switch (cmd) {
	        case CMD.M:
	          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	          // 在 closePath 的时候使用
	          x0 = data[i++];
	          y0 = data[i++];
	          xi = x0;
	          yi = y0;
	          min2[0] = x0;
	          min2[1] = y0;
	          max2[0] = x0;
	          max2[1] = y0;
	          break;
	
	        case CMD.L:
	          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
	          xi = data[i++];
	          yi = data[i++];
	          break;
	
	        case CMD.C:
	          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
	          xi = data[i++];
	          yi = data[i++];
	          break;
	
	        case CMD.Q:
	          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
	          xi = data[i++];
	          yi = data[i++];
	          break;
	
	        case CMD.A:
	          // TODO Arc 判断的开销比较大
	          var cx = data[i++];
	          var cy = data[i++];
	          var rx = data[i++];
	          var ry = data[i++];
	          var startAngle = data[i++];
	          var endAngle = data[i++] + startAngle; // TODO Arc 旋转
	
	          var psi = data[i++];
	          var anticlockwise = 1 - data[i++];
	
	          if (i == 1) {
	            // 直接使用 arc 命令
	            // 第一个命令起点还未定义
	            x0 = mathCos(startAngle) * rx + cx;
	            y0 = mathSin(startAngle) * ry + cy;
	          }
	
	          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
	          xi = mathCos(endAngle) * rx + cx;
	          yi = mathSin(endAngle) * ry + cy;
	          break;
	
	        case CMD.R:
	          x0 = xi = data[i++];
	          y0 = yi = data[i++];
	          var width = data[i++];
	          var height = data[i++]; // Use fromLine
	
	          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
	          break;
	
	        case CMD.Z:
	          xi = x0;
	          yi = y0;
	          break;
	      } // Union
	
	
	      vec2.min(min, min, min2);
	      vec2.max(max, max, max2);
	    } // No data
	
	
	    if (i === 0) {
	      min[0] = min[1] = max[0] = max[1] = 0;
	    }
	
	    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	  },
	
	  /**
	   * Rebuild path from current data
	   * Rebuild path will not consider javascript implemented line dash.
	   * @param {CanvasRenderingContext2D} ctx
	   */
	  rebuildPath: function (ctx) {
	    var d = this.data;
	    var x0, y0;
	    var xi, yi;
	    var x, y;
	    var ux = this._ux;
	    var uy = this._uy;
	    var len = this._len;
	
	    for (var i = 0; i < len;) {
	      var cmd = d[i++];
	
	      if (i == 1) {
	        // 如果第一个命令是 L, C, Q
	        // 则 previous point 同绘制命令的第一个 point
	        //
	        // 第一个命令为 Arc 的情况下会在后面特殊处理
	        xi = d[i];
	        yi = d[i + 1];
	        x0 = xi;
	        y0 = yi;
	      }
	
	      switch (cmd) {
	        case CMD.M:
	          x0 = xi = d[i++];
	          y0 = yi = d[i++];
	          ctx.moveTo(xi, yi);
	          break;
	
	        case CMD.L:
	          x = d[i++];
	          y = d[i++]; // Not draw too small seg between
	
	          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
	            ctx.lineTo(x, y);
	            xi = x;
	            yi = y;
	          }
	
	          break;
	
	        case CMD.C:
	          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
	          xi = d[i - 2];
	          yi = d[i - 1];
	          break;
	
	        case CMD.Q:
	          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
	          xi = d[i - 2];
	          yi = d[i - 1];
	          break;
	
	        case CMD.A:
	          var cx = d[i++];
	          var cy = d[i++];
	          var rx = d[i++];
	          var ry = d[i++];
	          var theta = d[i++];
	          var dTheta = d[i++];
	          var psi = d[i++];
	          var fs = d[i++];
	          var r = rx > ry ? rx : ry;
	          var scaleX = rx > ry ? 1 : rx / ry;
	          var scaleY = rx > ry ? ry / rx : 1;
	          var isEllipse = Math.abs(rx - ry) > 1e-3;
	          var endAngle = theta + dTheta;
	
	          if (isEllipse) {
	            ctx.translate(cx, cy);
	            ctx.rotate(psi);
	            ctx.scale(scaleX, scaleY);
	            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
	            ctx.scale(1 / scaleX, 1 / scaleY);
	            ctx.rotate(-psi);
	            ctx.translate(-cx, -cy);
	          } else {
	            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
	          }
	
	          if (i == 1) {
	            // 直接使用 arc 命令
	            // 第一个命令起点还未定义
	            x0 = mathCos(theta) * rx + cx;
	            y0 = mathSin(theta) * ry + cy;
	          }
	
	          xi = mathCos(endAngle) * rx + cx;
	          yi = mathSin(endAngle) * ry + cy;
	          break;
	
	        case CMD.R:
	          x0 = xi = d[i];
	          y0 = yi = d[i + 1];
	          ctx.rect(d[i++], d[i++], d[i++], d[i++]);
	          break;
	
	        case CMD.Z:
	          ctx.closePath();
	          xi = x0;
	          yi = y0;
	      }
	    }
	  }
	};
	PathProxy.CMD = CMD;
	var _default = PathProxy;
	module.exports = _default;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	var _vector = __webpack_require__(14);
	
	var v2Create = _vector.create;
	var v2DistSquare = _vector.distSquare;
	
	/**
	 * 曲线辅助模块
	 * @module zrender/core/curve
	 * @author pissang(https://www.github.com/pissang)
	 */
	var mathPow = Math.pow;
	var mathSqrt = Math.sqrt;
	var EPSILON = 1e-8;
	var EPSILON_NUMERIC = 1e-4;
	var THREE_SQRT = mathSqrt(3);
	var ONE_THIRD = 1 / 3; // 临时变量
	
	var _v0 = v2Create();
	
	var _v1 = v2Create();
	
	var _v2 = v2Create();
	
	function isAroundZero(val) {
	  return val > -EPSILON && val < EPSILON;
	}
	
	function isNotAroundZero(val) {
	  return val > EPSILON || val < -EPSILON;
	}
	/**
	 * 计算三次贝塞尔值
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function cubicAt(p0, p1, p2, p3, t) {
	  var onet = 1 - t;
	  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
	}
	/**
	 * 计算三次贝塞尔导数值
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function cubicDerivativeAt(p0, p1, p2, p3, t) {
	  var onet = 1 - t;
	  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
	}
	/**
	 * 计算三次贝塞尔方程根，使用盛金公式
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} val
	 * @param  {Array.<number>} roots
	 * @return {number} 有效根数目
	 */
	
	
	function cubicRootAt(p0, p1, p2, p3, val, roots) {
	  // Evaluate roots of cubic functions
	  var a = p3 + 3 * (p1 - p2) - p0;
	  var b = 3 * (p2 - p1 * 2 + p0);
	  var c = 3 * (p1 - p0);
	  var d = p0 - val;
	  var A = b * b - 3 * a * c;
	  var B = b * c - 9 * a * d;
	  var C = c * c - 3 * b * d;
	  var n = 0;
	
	  if (isAroundZero(A) && isAroundZero(B)) {
	    if (isAroundZero(b)) {
	      roots[0] = 0;
	    } else {
	      var t1 = -c / b; //t1, t2, t3, b is not zero
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    }
	  } else {
	    var disc = B * B - 4 * A * C;
	
	    if (isAroundZero(disc)) {
	      var K = B / A;
	      var t1 = -b / a + K; // t1, a is not zero
	
	      var t2 = -K / 2; // t2, t3
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        roots[n++] = t2;
	      }
	    } else if (disc > 0) {
	      var discSqrt = mathSqrt(disc);
	      var Y1 = A * b + 1.5 * a * (-B + discSqrt);
	      var Y2 = A * b + 1.5 * a * (-B - discSqrt);
	
	      if (Y1 < 0) {
	        Y1 = -mathPow(-Y1, ONE_THIRD);
	      } else {
	        Y1 = mathPow(Y1, ONE_THIRD);
	      }
	
	      if (Y2 < 0) {
	        Y2 = -mathPow(-Y2, ONE_THIRD);
	      } else {
	        Y2 = mathPow(Y2, ONE_THIRD);
	      }
	
	      var t1 = (-b - (Y1 + Y2)) / (3 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    } else {
	      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
	      var theta = Math.acos(T) / 3;
	      var ASqrt = mathSqrt(A);
	      var tmp = Math.cos(theta);
	      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
	      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
	      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        roots[n++] = t2;
	      }
	
	      if (t3 >= 0 && t3 <= 1) {
	        roots[n++] = t3;
	      }
	    }
	  }
	
	  return n;
	}
	/**
	 * 计算三次贝塞尔方程极限值的位置
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {Array.<number>} extrema
	 * @return {number} 有效数目
	 */
	
	
	function cubicExtrema(p0, p1, p2, p3, extrema) {
	  var b = 6 * p2 - 12 * p1 + 6 * p0;
	  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
	  var c = 3 * p1 - 3 * p0;
	  var n = 0;
	
	  if (isAroundZero(a)) {
	    if (isNotAroundZero(b)) {
	      var t1 = -c / b;
	
	      if (t1 >= 0 && t1 <= 1) {
	        extrema[n++] = t1;
	      }
	    }
	  } else {
	    var disc = b * b - 4 * a * c;
	
	    if (isAroundZero(disc)) {
	      extrema[0] = -b / (2 * a);
	    } else if (disc > 0) {
	      var discSqrt = mathSqrt(disc);
	      var t1 = (-b + discSqrt) / (2 * a);
	      var t2 = (-b - discSqrt) / (2 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        extrema[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        extrema[n++] = t2;
	      }
	    }
	  }
	
	  return n;
	}
	/**
	 * 细分三次贝塞尔曲线
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @param  {Array.<number>} out
	 */
	
	
	function cubicSubdivide(p0, p1, p2, p3, t, out) {
	  var p01 = (p1 - p0) * t + p0;
	  var p12 = (p2 - p1) * t + p1;
	  var p23 = (p3 - p2) * t + p2;
	  var p012 = (p12 - p01) * t + p01;
	  var p123 = (p23 - p12) * t + p12;
	  var p0123 = (p123 - p012) * t + p012; // Seg0
	
	  out[0] = p0;
	  out[1] = p01;
	  out[2] = p012;
	  out[3] = p0123; // Seg1
	
	  out[4] = p0123;
	  out[5] = p123;
	  out[6] = p23;
	  out[7] = p3;
	}
	/**
	 * 投射点到三次贝塞尔曲线上，返回投射距离。
	 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x3
	 * @param {number} y3
	 * @param {number} x
	 * @param {number} y
	 * @param {Array.<number>} [out] 投射点
	 * @return {number}
	 */
	
	
	function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
	  // http://pomax.github.io/bezierinfo/#projections
	  var t;
	  var interval = 0.005;
	  var d = Infinity;
	  var prev;
	  var next;
	  var d1;
	  var d2;
	  _v0[0] = x;
	  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
	  // PENDING
	
	  for (var _t = 0; _t < 1; _t += 0.05) {
	    _v1[0] = cubicAt(x0, x1, x2, x3, _t);
	    _v1[1] = cubicAt(y0, y1, y2, y3, _t);
	    d1 = v2DistSquare(_v0, _v1);
	
	    if (d1 < d) {
	      t = _t;
	      d = d1;
	    }
	  }
	
	  d = Infinity; // At most 32 iteration
	
	  for (var i = 0; i < 32; i++) {
	    if (interval < EPSILON_NUMERIC) {
	      break;
	    }
	
	    prev = t - interval;
	    next = t + interval; // t - interval
	
	    _v1[0] = cubicAt(x0, x1, x2, x3, prev);
	    _v1[1] = cubicAt(y0, y1, y2, y3, prev);
	    d1 = v2DistSquare(_v1, _v0);
	
	    if (prev >= 0 && d1 < d) {
	      t = prev;
	      d = d1;
	    } else {
	      // t + interval
	      _v2[0] = cubicAt(x0, x1, x2, x3, next);
	      _v2[1] = cubicAt(y0, y1, y2, y3, next);
	      d2 = v2DistSquare(_v2, _v0);
	
	      if (next <= 1 && d2 < d) {
	        t = next;
	        d = d2;
	      } else {
	        interval *= 0.5;
	      }
	    }
	  } // t
	
	
	  if (out) {
	    out[0] = cubicAt(x0, x1, x2, x3, t);
	    out[1] = cubicAt(y0, y1, y2, y3, t);
	  } // console.log(interval, i);
	
	
	  return mathSqrt(d);
	}
	/**
	 * 计算二次方贝塞尔值
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function quadraticAt(p0, p1, p2, t) {
	  var onet = 1 - t;
	  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
	}
	/**
	 * 计算二次方贝塞尔导数值
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function quadraticDerivativeAt(p0, p1, p2, t) {
	  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
	}
	/**
	 * 计算二次方贝塞尔方程根
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @param  {Array.<number>} roots
	 * @return {number} 有效根数目
	 */
	
	
	function quadraticRootAt(p0, p1, p2, val, roots) {
	  var a = p0 - 2 * p1 + p2;
	  var b = 2 * (p1 - p0);
	  var c = p0 - val;
	  var n = 0;
	
	  if (isAroundZero(a)) {
	    if (isNotAroundZero(b)) {
	      var t1 = -c / b;
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    }
	  } else {
	    var disc = b * b - 4 * a * c;
	
	    if (isAroundZero(disc)) {
	      var t1 = -b / (2 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    } else if (disc > 0) {
	      var discSqrt = mathSqrt(disc);
	      var t1 = (-b + discSqrt) / (2 * a);
	      var t2 = (-b - discSqrt) / (2 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        roots[n++] = t2;
	      }
	    }
	  }
	
	  return n;
	}
	/**
	 * 计算二次贝塞尔方程极限值
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @return {number}
	 */
	
	
	function quadraticExtremum(p0, p1, p2) {
	  var divider = p0 + p2 - 2 * p1;
	
	  if (divider === 0) {
	    // p1 is center of p0 and p2
	    return 0.5;
	  } else {
	    return (p0 - p1) / divider;
	  }
	}
	/**
	 * 细分二次贝塞尔曲线
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @param  {Array.<number>} out
	 */
	
	
	function quadraticSubdivide(p0, p1, p2, t, out) {
	  var p01 = (p1 - p0) * t + p0;
	  var p12 = (p2 - p1) * t + p1;
	  var p012 = (p12 - p01) * t + p01; // Seg0
	
	  out[0] = p0;
	  out[1] = p01;
	  out[2] = p012; // Seg1
	
	  out[3] = p012;
	  out[4] = p12;
	  out[5] = p2;
	}
	/**
	 * 投射点到二次贝塞尔曲线上，返回投射距离。
	 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x
	 * @param {number} y
	 * @param {Array.<number>} out 投射点
	 * @return {number}
	 */
	
	
	function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
	  // http://pomax.github.io/bezierinfo/#projections
	  var t;
	  var interval = 0.005;
	  var d = Infinity;
	  _v0[0] = x;
	  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
	  // PENDING
	
	  for (var _t = 0; _t < 1; _t += 0.05) {
	    _v1[0] = quadraticAt(x0, x1, x2, _t);
	    _v1[1] = quadraticAt(y0, y1, y2, _t);
	    var d1 = v2DistSquare(_v0, _v1);
	
	    if (d1 < d) {
	      t = _t;
	      d = d1;
	    }
	  }
	
	  d = Infinity; // At most 32 iteration
	
	  for (var i = 0; i < 32; i++) {
	    if (interval < EPSILON_NUMERIC) {
	      break;
	    }
	
	    var prev = t - interval;
	    var next = t + interval; // t - interval
	
	    _v1[0] = quadraticAt(x0, x1, x2, prev);
	    _v1[1] = quadraticAt(y0, y1, y2, prev);
	    var d1 = v2DistSquare(_v1, _v0);
	
	    if (prev >= 0 && d1 < d) {
	      t = prev;
	      d = d1;
	    } else {
	      // t + interval
	      _v2[0] = quadraticAt(x0, x1, x2, next);
	      _v2[1] = quadraticAt(y0, y1, y2, next);
	      var d2 = v2DistSquare(_v2, _v0);
	
	      if (next <= 1 && d2 < d) {
	        t = next;
	        d = d2;
	      } else {
	        interval *= 0.5;
	      }
	    }
	  } // t
	
	
	  if (out) {
	    out[0] = quadraticAt(x0, x1, x2, t);
	    out[1] = quadraticAt(y0, y1, y2, t);
	  } // console.log(interval, i);
	
	
	  return mathSqrt(d);
	}
	
	exports.cubicAt = cubicAt;
	exports.cubicDerivativeAt = cubicDerivativeAt;
	exports.cubicRootAt = cubicRootAt;
	exports.cubicExtrema = cubicExtrema;
	exports.cubicSubdivide = cubicSubdivide;
	exports.cubicProjectPoint = cubicProjectPoint;
	exports.quadraticAt = quadraticAt;
	exports.quadraticDerivativeAt = quadraticDerivativeAt;
	exports.quadraticRootAt = quadraticRootAt;
	exports.quadraticExtremum = quadraticExtremum;
	exports.quadraticSubdivide = quadraticSubdivide;
	exports.quadraticProjectPoint = quadraticProjectPoint;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(14);
	
	var curve = __webpack_require__(30);
	
	/**
	 * @author Yi Shen(https://github.com/pissang)
	 */
	var mathMin = Math.min;
	var mathMax = Math.max;
	var mathSin = Math.sin;
	var mathCos = Math.cos;
	var PI2 = Math.PI * 2;
	var start = vec2.create();
	var end = vec2.create();
	var extremity = vec2.create();
	/**
	 * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
	 * @module zrender/core/bbox
	 * @param {Array<Object>} points 顶点数组
	 * @param {number} min
	 * @param {number} max
	 */
	
	function fromPoints(points, min, max) {
	  if (points.length === 0) {
	    return;
	  }
	
	  var p = points[0];
	  var left = p[0];
	  var right = p[0];
	  var top = p[1];
	  var bottom = p[1];
	  var i;
	
	  for (i = 1; i < points.length; i++) {
	    p = points[i];
	    left = mathMin(left, p[0]);
	    right = mathMax(right, p[0]);
	    top = mathMin(top, p[1]);
	    bottom = mathMax(bottom, p[1]);
	  }
	
	  min[0] = left;
	  min[1] = top;
	  max[0] = right;
	  max[1] = bottom;
	}
	/**
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	
	function fromLine(x0, y0, x1, y1, min, max) {
	  min[0] = mathMin(x0, x1);
	  min[1] = mathMin(y0, y1);
	  max[0] = mathMax(x0, x1);
	  max[1] = mathMax(y0, y1);
	}
	
	var xDim = [];
	var yDim = [];
	/**
	 * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x3
	 * @param {number} y3
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
	  var cubicExtrema = curve.cubicExtrema;
	  var cubicAt = curve.cubicAt;
	  var i;
	  var n = cubicExtrema(x0, x1, x2, x3, xDim);
	  min[0] = Infinity;
	  min[1] = Infinity;
	  max[0] = -Infinity;
	  max[1] = -Infinity;
	
	  for (i = 0; i < n; i++) {
	    var x = cubicAt(x0, x1, x2, x3, xDim[i]);
	    min[0] = mathMin(x, min[0]);
	    max[0] = mathMax(x, max[0]);
	  }
	
	  n = cubicExtrema(y0, y1, y2, y3, yDim);
	
	  for (i = 0; i < n; i++) {
	    var y = cubicAt(y0, y1, y2, y3, yDim[i]);
	    min[1] = mathMin(y, min[1]);
	    max[1] = mathMax(y, max[1]);
	  }
	
	  min[0] = mathMin(x0, min[0]);
	  max[0] = mathMax(x0, max[0]);
	  min[0] = mathMin(x3, min[0]);
	  max[0] = mathMax(x3, max[0]);
	  min[1] = mathMin(y0, min[1]);
	  max[1] = mathMax(y0, max[1]);
	  min[1] = mathMin(y3, min[1]);
	  max[1] = mathMax(y3, max[1]);
	}
	/**
	 * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	
	function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
	  var quadraticExtremum = curve.quadraticExtremum;
	  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero
	
	  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);
	  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);
	  var x = quadraticAt(x0, x1, x2, tx);
	  var y = quadraticAt(y0, y1, y2, ty);
	  min[0] = mathMin(x0, x2, x);
	  min[1] = mathMin(y0, y2, y);
	  max[0] = mathMax(x0, x2, x);
	  max[1] = mathMax(y0, y2, y);
	}
	/**
	 * 从圆弧中计算出最小包围盒，写入`min`和`max`中
	 * @method
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x
	 * @param {number} y
	 * @param {number} rx
	 * @param {number} ry
	 * @param {number} startAngle
	 * @param {number} endAngle
	 * @param {number} anticlockwise
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	
	function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
	  var vec2Min = vec2.min;
	  var vec2Max = vec2.max;
	  var diff = Math.abs(startAngle - endAngle);
	
	  if (diff % PI2 < 1e-4 && diff > 1e-4) {
	    // Is a circle
	    min[0] = x - rx;
	    min[1] = y - ry;
	    max[0] = x + rx;
	    max[1] = y + ry;
	    return;
	  }
	
	  start[0] = mathCos(startAngle) * rx + x;
	  start[1] = mathSin(startAngle) * ry + y;
	  end[0] = mathCos(endAngle) * rx + x;
	  end[1] = mathSin(endAngle) * ry + y;
	  vec2Min(min, start, end);
	  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]
	
	  startAngle = startAngle % PI2;
	
	  if (startAngle < 0) {
	    startAngle = startAngle + PI2;
	  }
	
	  endAngle = endAngle % PI2;
	
	  if (endAngle < 0) {
	    endAngle = endAngle + PI2;
	  }
	
	  if (startAngle > endAngle && !anticlockwise) {
	    endAngle += PI2;
	  } else if (startAngle < endAngle && anticlockwise) {
	    startAngle += PI2;
	  }
	
	  if (anticlockwise) {
	    var tmp = endAngle;
	    endAngle = startAngle;
	    startAngle = tmp;
	  } // var number = 0;
	  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
	
	
	  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
	    if (angle > startAngle) {
	      extremity[0] = mathCos(angle) * rx + x;
	      extremity[1] = mathSin(angle) * ry + y;
	      vec2Min(min, extremity, min);
	      vec2Max(max, extremity, max);
	    }
	  }
	}
	
	exports.fromPoints = fromPoints;
	exports.fromLine = fromLine;
	exports.fromCubic = fromCubic;
	exports.fromQuadratic = fromQuadratic;
	exports.fromArc = fromArc;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	var PathProxy = __webpack_require__(29);
	
	var line = __webpack_require__(33);
	
	var cubic = __webpack_require__(34);
	
	var quadratic = __webpack_require__(35);
	
	var arc = __webpack_require__(36);
	
	var _util = __webpack_require__(37);
	
	var normalizeRadian = _util.normalizeRadian;
	
	var curve = __webpack_require__(30);
	
	var windingLine = __webpack_require__(38);
	
	var CMD = PathProxy.CMD;
	var PI2 = Math.PI * 2;
	var EPSILON = 1e-4;
	
	function isAroundEqual(a, b) {
	  return Math.abs(a - b) < EPSILON;
	} // 临时数组
	
	
	var roots = [-1, -1, -1];
	var extrema = [-1, -1];
	
	function swapExtrema() {
	  var tmp = extrema[0];
	  extrema[0] = extrema[1];
	  extrema[1] = tmp;
	}
	
	function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
	  // Quick reject
	  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
	    return 0;
	  }
	
	  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
	
	  if (nRoots === 0) {
	    return 0;
	  } else {
	    var w = 0;
	    var nExtrema = -1;
	    var y0_, y1_;
	
	    for (var i = 0; i < nRoots; i++) {
	      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon
	
	      var unit = t === 0 || t === 1 ? 0.5 : 1;
	      var x_ = curve.cubicAt(x0, x1, x2, x3, t);
	
	      if (x_ < x) {
	        // Quick reject
	        continue;
	      }
	
	      if (nExtrema < 0) {
	        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
	
	        if (extrema[1] < extrema[0] && nExtrema > 1) {
	          swapExtrema();
	        }
	
	        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
	
	        if (nExtrema > 1) {
	          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
	        }
	      }
	
	      if (nExtrema == 2) {
	        // 分成三段单调函数
	        if (t < extrema[0]) {
	          w += y0_ < y0 ? unit : -unit;
	        } else if (t < extrema[1]) {
	          w += y1_ < y0_ ? unit : -unit;
	        } else {
	          w += y3 < y1_ ? unit : -unit;
	        }
	      } else {
	        // 分成两段单调函数
	        if (t < extrema[0]) {
	          w += y0_ < y0 ? unit : -unit;
	        } else {
	          w += y3 < y0_ ? unit : -unit;
	        }
	      }
	    }
	
	    return w;
	  }
	}
	
	function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
	  // Quick reject
	  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
	    return 0;
	  }
	
	  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
	
	  if (nRoots === 0) {
	    return 0;
	  } else {
	    var t = curve.quadraticExtremum(y0, y1, y2);
	
	    if (t >= 0 && t <= 1) {
	      var w = 0;
	      var y_ = curve.quadraticAt(y0, y1, y2, t);
	
	      for (var i = 0; i < nRoots; i++) {
	        // Remove one endpoint.
	        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
	        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
	
	        if (x_ < x) {
	          // Quick reject
	          continue;
	        }
	
	        if (roots[i] < t) {
	          w += y_ < y0 ? unit : -unit;
	        } else {
	          w += y2 < y_ ? unit : -unit;
	        }
	      }
	
	      return w;
	    } else {
	      // Remove one endpoint.
	      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
	      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
	
	      if (x_ < x) {
	        // Quick reject
	        return 0;
	      }
	
	      return y2 < y0 ? unit : -unit;
	    }
	  }
	} // TODO
	// Arc 旋转
	
	
	function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
	  y -= cy;
	
	  if (y > r || y < -r) {
	    return 0;
	  }
	
	  var tmp = Math.sqrt(r * r - y * y);
	  roots[0] = -tmp;
	  roots[1] = tmp;
	  var diff = Math.abs(startAngle - endAngle);
	
	  if (diff < 1e-4) {
	    return 0;
	  }
	
	  if (diff % PI2 < 1e-4) {
	    // Is a circle
	    startAngle = 0;
	    endAngle = PI2;
	    var dir = anticlockwise ? 1 : -1;
	
	    if (x >= roots[0] + cx && x <= roots[1] + cx) {
	      return dir;
	    } else {
	      return 0;
	    }
	  }
	
	  if (anticlockwise) {
	    var tmp = startAngle;
	    startAngle = normalizeRadian(endAngle);
	    endAngle = normalizeRadian(tmp);
	  } else {
	    startAngle = normalizeRadian(startAngle);
	    endAngle = normalizeRadian(endAngle);
	  }
	
	  if (startAngle > endAngle) {
	    endAngle += PI2;
	  }
	
	  var w = 0;
	
	  for (var i = 0; i < 2; i++) {
	    var x_ = roots[i];
	
	    if (x_ + cx > x) {
	      var angle = Math.atan2(y, x_);
	      var dir = anticlockwise ? 1 : -1;
	
	      if (angle < 0) {
	        angle = PI2 + angle;
	      }
	
	      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
	        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
	          dir = -dir;
	        }
	
	        w += dir;
	      }
	    }
	  }
	
	  return w;
	}
	
	function containPath(data, lineWidth, isStroke, x, y) {
	  var w = 0;
	  var xi = 0;
	  var yi = 0;
	  var x0 = 0;
	  var y0 = 0;
	
	  for (var i = 0; i < data.length;) {
	    var cmd = data[i++]; // Begin a new subpath
	
	    if (cmd === CMD.M && i > 1) {
	      // Close previous subpath
	      if (!isStroke) {
	        w += windingLine(xi, yi, x0, y0, x, y);
	      } // 如果被任何一个 subpath 包含
	      // if (w !== 0) {
	      //     return true;
	      // }
	
	    }
	
	    if (i == 1) {
	      // 如果第一个命令是 L, C, Q
	      // 则 previous point 同绘制命令的第一个 point
	      //
	      // 第一个命令为 Arc 的情况下会在后面特殊处理
	      xi = data[i];
	      yi = data[i + 1];
	      x0 = xi;
	      y0 = yi;
	    }
	
	    switch (cmd) {
	      case CMD.M:
	        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	        // 在 closePath 的时候使用
	        x0 = data[i++];
	        y0 = data[i++];
	        xi = x0;
	        yi = y0;
	        break;
	
	      case CMD.L:
	        if (isStroke) {
	          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
	          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
	        }
	
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.C:
	        if (isStroke) {
	          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
	        }
	
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.Q:
	        if (isStroke) {
	          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
	        }
	
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.A:
	        // TODO Arc 判断的开销比较大
	        var cx = data[i++];
	        var cy = data[i++];
	        var rx = data[i++];
	        var ry = data[i++];
	        var theta = data[i++];
	        var dTheta = data[i++]; // TODO Arc 旋转
	
	        var psi = data[i++];
	        var anticlockwise = 1 - data[i++];
	        var x1 = Math.cos(theta) * rx + cx;
	        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令
	
	        if (i > 1) {
	          w += windingLine(xi, yi, x1, y1, x, y);
	        } else {
	          // 第一个命令起点还未定义
	          x0 = x1;
	          y0 = y1;
	        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
	
	
	        var _x = (x - cx) * ry / rx + cx;
	
	        if (isStroke) {
	          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
	            return true;
	          }
	        } else {
	          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
	        }
	
	        xi = Math.cos(theta + dTheta) * rx + cx;
	        yi = Math.sin(theta + dTheta) * ry + cy;
	        break;
	
	      case CMD.R:
	        x0 = xi = data[i++];
	        y0 = yi = data[i++];
	        var width = data[i++];
	        var height = data[i++];
	        var x1 = x0 + width;
	        var y1 = y0 + height;
	
	        if (isStroke) {
	          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          // FIXME Clockwise ?
	          w += windingLine(x1, y0, x1, y1, x, y);
	          w += windingLine(x0, y1, x0, y0, x, y);
	        }
	
	        break;
	
	      case CMD.Z:
	        if (isStroke) {
	          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          // Close a subpath
	          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含
	          // FIXME subpaths may overlap
	          // if (w !== 0) {
	          //     return true;
	          // }
	        }
	
	        xi = x0;
	        yi = y0;
	        break;
	    }
	  }
	
	  if (!isStroke && !isAroundEqual(yi, y0)) {
	    w += windingLine(xi, yi, x0, y0, x, y) || 0;
	  }
	
	  return w !== 0;
	}
	
	function contain(pathData, x, y) {
	  return containPath(pathData, 0, false, x, y);
	}
	
	function containStroke(pathData, lineWidth, x, y) {
	  return containPath(pathData, lineWidth, true, x, y);
	}
	
	exports.contain = contain;
	exports.containStroke = containStroke;

/***/ }),
/* 33 */
/***/ (function(module, exports) {

	/**
	 * 线段包含判断
	 * @param  {number}  x0
	 * @param  {number}  y0
	 * @param  {number}  x1
	 * @param  {number}  y1
	 * @param  {number}  lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {boolean}
	 */
	function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth;
	  var _a = 0;
	  var _b = x0; // Quick reject
	
	  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
	    return false;
	  }
	
	  if (x0 !== x1) {
	    _a = (y0 - y1) / (x0 - x1);
	    _b = (x0 * y1 - x1 * y0) / (x0 - x1);
	  } else {
	    return Math.abs(x - x0) <= _l / 2;
	  }
	
	  var tmp = _a * x - y + _b;
	
	  var _s = tmp * tmp / (_a * _a + 1);
	
	  return _s <= _l / 2 * _l / 2;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	var curve = __webpack_require__(30);
	
	/**
	 * 三次贝塞尔曲线描边包含判断
	 * @param  {number}  x0
	 * @param  {number}  y0
	 * @param  {number}  x1
	 * @param  {number}  y1
	 * @param  {number}  x2
	 * @param  {number}  y2
	 * @param  {number}  x3
	 * @param  {number}  y3
	 * @param  {number}  lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {boolean}
	 */
	function containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth; // Quick reject
	
	  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
	    return false;
	  }
	
	  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
	  return d <= _l / 2;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	var _curve = __webpack_require__(30);
	
	var quadraticProjectPoint = _curve.quadraticProjectPoint;
	
	/**
	 * 二次贝塞尔曲线描边包含判断
	 * @param  {number}  x0
	 * @param  {number}  y0
	 * @param  {number}  x1
	 * @param  {number}  y1
	 * @param  {number}  x2
	 * @param  {number}  y2
	 * @param  {number}  lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {boolean}
	 */
	function containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth; // Quick reject
	
	  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
	    return false;
	  }
	
	  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
	  return d <= _l / 2;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	var _util = __webpack_require__(37);
	
	var normalizeRadian = _util.normalizeRadian;
	var PI2 = Math.PI * 2;
	/**
	 * 圆弧描边包含判断
	 * @param  {number}  cx
	 * @param  {number}  cy
	 * @param  {number}  r
	 * @param  {number}  startAngle
	 * @param  {number}  endAngle
	 * @param  {boolean}  anticlockwise
	 * @param  {number} lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {Boolean}
	 */
	
	function containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth;
	  x -= cx;
	  y -= cy;
	  var d = Math.sqrt(x * x + y * y);
	
	  if (d - _l > r || d + _l < r) {
	    return false;
	  }
	
	  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
	    // Is a circle
	    return true;
	  }
	
	  if (anticlockwise) {
	    var tmp = startAngle;
	    startAngle = normalizeRadian(endAngle);
	    endAngle = normalizeRadian(tmp);
	  } else {
	    startAngle = normalizeRadian(startAngle);
	    endAngle = normalizeRadian(endAngle);
	  }
	
	  if (startAngle > endAngle) {
	    endAngle += PI2;
	  }
	
	  var angle = Math.atan2(y, x);
	
	  if (angle < 0) {
	    angle += PI2;
	  }
	
	  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	var PI2 = Math.PI * 2;
	
	function normalizeRadian(angle) {
	  angle %= PI2;
	
	  if (angle < 0) {
	    angle += PI2;
	  }
	
	  return angle;
	}
	
	exports.normalizeRadian = normalizeRadian;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

	function windingLine(x0, y0, x1, y1, x, y) {
	  if (y > y0 && y > y1 || y < y0 && y < y1) {
	    return 0;
	  } // Ignore horizontal line
	
	
	  if (y1 === y0) {
	    return 0;
	  }
	
	  var dir = y1 < y0 ? 1 : -1;
	  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon
	
	  if (t === 1 || t === 0) {
	    dir = y1 < y0 ? 0.5 : -0.5;
	  }
	
	  var x_ = t * (x1 - x0) + x0;
	  return x_ > x ? dir : 0;
	}
	
	module.exports = windingLine;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	var Pattern = function (image, repeat) {
	  // Should do nothing more in this constructor. Because gradient can be
	  // declard by `color: {image: ...}`, where this constructor will not be called.
	  this.image = image;
	  this.repeat = repeat; // Can be cloned
	
	  this.type = 'pattern';
	};
	
	Pattern.prototype.getCanvasPattern = function (ctx) {
	  return ctx.createPattern(this.image, this.repeat || 'repeat');
	};
	
	var _default = Pattern;
	module.exports = _default;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	var PathProxy = __webpack_require__(29);
	
	var _vector = __webpack_require__(14);
	
	var v2ApplyTransform = _vector.applyTransform;
	var CMD = PathProxy.CMD;
	var points = [[], [], []];
	var mathSqrt = Math.sqrt;
	var mathAtan2 = Math.atan2;
	
	function _default(path, m) {
	  var data = path.data;
	  var cmd;
	  var nPoint;
	  var i;
	  var j;
	  var k;
	  var p;
	  var M = CMD.M;
	  var C = CMD.C;
	  var L = CMD.L;
	  var R = CMD.R;
	  var A = CMD.A;
	  var Q = CMD.Q;
	
	  for (i = 0, j = 0; i < data.length;) {
	    cmd = data[i++];
	    j = i;
	    nPoint = 0;
	
	    switch (cmd) {
	      case M:
	        nPoint = 1;
	        break;
	
	      case L:
	        nPoint = 1;
	        break;
	
	      case C:
	        nPoint = 3;
	        break;
	
	      case Q:
	        nPoint = 2;
	        break;
	
	      case A:
	        var x = m[4];
	        var y = m[5];
	        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
	        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
	        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx
	
	        data[i] *= sx;
	        data[i++] += x; // cy
	
	        data[i] *= sy;
	        data[i++] += y; // Scale rx and ry
	        // FIXME Assume psi is 0 here
	
	        data[i++] *= sx;
	        data[i++] *= sy; // Start angle
	
	        data[i++] += angle; // end angle
	
	        data[i++] += angle; // FIXME psi
	
	        i += 2;
	        j = i;
	        break;
	
	      case R:
	        // x0, y0
	        p[0] = data[i++];
	        p[1] = data[i++];
	        v2ApplyTransform(p, p, m);
	        data[j++] = p[0];
	        data[j++] = p[1]; // x1, y1
	
	        p[0] += data[i++];
	        p[1] += data[i++];
	        v2ApplyTransform(p, p, m);
	        data[j++] = p[0];
	        data[j++] = p[1];
	    }
	
	    for (k = 0; k < nPoint; k++) {
	      var p = points[k];
	      p[0] = data[i++];
	      p[1] = data[i++];
	      v2ApplyTransform(p, p, m); // Write back
	
	      data[j++] = p[0];
	      data[j++] = p[1];
	    }
	  }
	}
	
	module.exports = _default;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	/**
	 * @param {Array.<Object>} colorStops
	 */
	var Gradient = function (colorStops) {
	  this.colorStops = colorStops || [];
	};
	
	Gradient.prototype = {
	  constructor: Gradient,
	  addColorStop: function (offset, color) {
	    this.colorStops.push({
	      offset: offset,
	      color: color
	    });
	  }
	};
	var _default = Gradient;
	module.exports = _default;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	// TODO Draggable for group
	// FIXME Draggable on element which has parent rotation or scale
	function Draggable() {
	  this.on('mousedown', this._dragStart, this);
	  this.on('mousemove', this._drag, this);
	  this.on('mouseup', this._dragEnd, this);
	  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;
	  // this._draggingTarget = null;
	  // this._x = 0;
	  // this._y = 0;
	}
	
	Draggable.prototype = {
	  constructor: Draggable,
	  _dragStart: function (e) {
	    var draggingTarget = e.target;
	
	    if (draggingTarget && draggingTarget.draggable) {
	      this._draggingTarget = draggingTarget;
	      draggingTarget.dragging = true;
	      this._x = e.offsetX;
	      this._y = e.offsetY;
	      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);
	    }
	  },
	  _drag: function (e) {
	    var draggingTarget = this._draggingTarget;
	
	    if (draggingTarget) {
	      var x = e.offsetX;
	      var y = e.offsetY;
	      var dx = x - this._x;
	      var dy = y - this._y;
	      this._x = x;
	      this._y = y;
	      draggingTarget.drift(dx, dy, e);
	      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);
	      var dropTarget = this.findHover(x, y, draggingTarget).target;
	      var lastDropTarget = this._dropTarget;
	      this._dropTarget = dropTarget;
	
	      if (draggingTarget !== dropTarget) {
	        if (lastDropTarget && dropTarget !== lastDropTarget) {
	          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);
	        }
	
	        if (dropTarget && dropTarget !== lastDropTarget) {
	          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);
	        }
	      }
	    }
	  },
	  _dragEnd: function (e) {
	    var draggingTarget = this._draggingTarget;
	
	    if (draggingTarget) {
	      draggingTarget.dragging = false;
	    }
	
	    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);
	
	    if (this._dropTarget) {
	      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);
	    }
	
	    this._draggingTarget = null;
	    this._dropTarget = null;
	  }
	};
	
	function param(target, e) {
	  return {
	    target: target,
	    topTarget: e && e.topTarget
	  };
	}
	
	var _default = Draggable;
	module.exports = _default;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(4);
	
	var Element = __webpack_require__(9);
	
	var BoundingRect = __webpack_require__(26);
	
	/**
	 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
	 * @module zrender/graphic/Group
	 * @example
	 *     var Group = require('zrender/container/Group');
	 *     var Circle = require('zrender/graphic/shape/Circle');
	 *     var g = new Group();
	 *     g.position[0] = 100;
	 *     g.position[1] = 100;
	 *     g.add(new Circle({
	 *         style: {
	 *             x: 100,
	 *             y: 100,
	 *             r: 20,
	 *         }
	 *     }));
	 *     zr.add(g);
	 */
	
	/**
	 * @alias module:zrender/graphic/Group
	 * @constructor
	 * @extends module:zrender/mixin/Transformable
	 * @extends module:zrender/mixin/Eventful
	 */
	var Group = function (opts) {
	  opts = opts || {};
	  Element.call(this, opts);
	
	  for (var key in opts) {
	    if (opts.hasOwnProperty(key)) {
	      this[key] = opts[key];
	    }
	  }
	
	  this._children = [];
	  this.__storage = null;
	  this.__dirty = true;
	};
	
	Group.prototype = {
	  constructor: Group,
	  isGroup: true,
	
	  /**
	   * @type {string}
	   */
	  type: 'group',
	
	  /**
	   * 所有子孙元素是否响应鼠标事件
	   * @name module:/zrender/container/Group#silent
	   * @type {boolean}
	   * @default false
	   */
	  silent: false,
	
	  /**
	   * @return {Array.<module:zrender/Element>}
	   */
	  children: function () {
	    return this._children.slice();
	  },
	
	  /**
	   * 获取指定 index 的儿子节点
	   * @param  {number} idx
	   * @return {module:zrender/Element}
	   */
	  childAt: function (idx) {
	    return this._children[idx];
	  },
	
	  /**
	   * 获取指定名字的儿子节点
	   * @param  {string} name
	   * @return {module:zrender/Element}
	   */
	  childOfName: function (name) {
	    var children = this._children;
	
	    for (var i = 0; i < children.length; i++) {
	      if (children[i].name === name) {
	        return children[i];
	      }
	    }
	  },
	
	  /**
	   * @return {number}
	   */
	  childCount: function () {
	    return this._children.length;
	  },
	
	  /**
	   * 添加子节点到最后
	   * @param {module:zrender/Element} child
	   */
	  add: function (child) {
	    if (child && child !== this && child.parent !== this) {
	      this._children.push(child);
	
	      this._doAdd(child);
	    }
	
	    return this;
	  },
	
	  /**
	   * 添加子节点在 nextSibling 之前
	   * @param {module:zrender/Element} child
	   * @param {module:zrender/Element} nextSibling
	   */
	  addBefore: function (child, nextSibling) {
	    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
	      var children = this._children;
	      var idx = children.indexOf(nextSibling);
	
	      if (idx >= 0) {
	        children.splice(idx, 0, child);
	
	        this._doAdd(child);
	      }
	    }
	
	    return this;
	  },
	  _doAdd: function (child) {
	    if (child.parent) {
	      child.parent.remove(child);
	    }
	
	    child.parent = this;
	    var storage = this.__storage;
	    var zr = this.__zr;
	
	    if (storage && storage !== child.__storage) {
	      storage.addToStorage(child);
	
	      if (child instanceof Group) {
	        child.addChildrenToStorage(storage);
	      }
	    }
	
	    zr && zr.refresh();
	  },
	
	  /**
	   * 移除子节点
	   * @param {module:zrender/Element} child
	   */
	  remove: function (child) {
	    var zr = this.__zr;
	    var storage = this.__storage;
	    var children = this._children;
	    var idx = zrUtil.indexOf(children, child);
	
	    if (idx < 0) {
	      return this;
	    }
	
	    children.splice(idx, 1);
	    child.parent = null;
	
	    if (storage) {
	      storage.delFromStorage(child);
	
	      if (child instanceof Group) {
	        child.delChildrenFromStorage(storage);
	      }
	    }
	
	    zr && zr.refresh();
	    return this;
	  },
	
	  /**
	   * 移除所有子节点
	   */
	  removeAll: function () {
	    var children = this._children;
	    var storage = this.__storage;
	    var child;
	    var i;
	
	    for (i = 0; i < children.length; i++) {
	      child = children[i];
	
	      if (storage) {
	        storage.delFromStorage(child);
	
	        if (child instanceof Group) {
	          child.delChildrenFromStorage(storage);
	        }
	      }
	
	      child.parent = null;
	    }
	
	    children.length = 0;
	    return this;
	  },
	
	  /**
	   * 遍历所有子节点
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  eachChild: function (cb, context) {
	    var children = this._children;
	
	    for (var i = 0; i < children.length; i++) {
	      var child = children[i];
	      cb.call(context, child, i);
	    }
	
	    return this;
	  },
	
	  /**
	   * 深度优先遍历所有子孙节点
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  traverse: function (cb, context) {
	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      cb.call(context, child);
	
	      if (child.type === 'group') {
	        child.traverse(cb, context);
	      }
	    }
	
	    return this;
	  },
	  addChildrenToStorage: function (storage) {
	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      storage.addToStorage(child);
	
	      if (child instanceof Group) {
	        child.addChildrenToStorage(storage);
	      }
	    }
	  },
	  delChildrenFromStorage: function (storage) {
	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      storage.delFromStorage(child);
	
	      if (child instanceof Group) {
	        child.delChildrenFromStorage(storage);
	      }
	    }
	  },
	  dirty: function () {
	    this.__dirty = true;
	    this.__zr && this.__zr.refresh();
	    return this;
	  },
	
	  /**
	   * @return {module:zrender/core/BoundingRect}
	   */
	  getBoundingRect: function (includeChildren) {
	    // TODO Caching
	    var rect = null;
	    var tmpRect = new BoundingRect(0, 0, 0, 0);
	    var children = includeChildren || this._children;
	    var tmpMat = [];
	
	    for (var i = 0; i < children.length; i++) {
	      var child = children[i];
	
	      if (child.ignore || child.invisible) {
	        continue;
	      }
	
	      var childRect = child.getBoundingRect();
	      var transform = child.getLocalTransform(tmpMat); // TODO
	      // The boundingRect cacluated by transforming original
	      // rect may be bigger than the actual bundingRect when rotation
	      // is used. (Consider a circle rotated aginst its center, where
	      // the actual boundingRect should be the same as that not be
	      // rotated.) But we can not find better approach to calculate
	      // actual boundingRect yet, considering performance.
	
	      if (transform) {
	        tmpRect.copy(childRect);
	        tmpRect.applyTransform(transform);
	        rect = rect || tmpRect.clone();
	        rect.union(tmpRect);
	      } else {
	        rect = rect || childRect.clone();
	        rect.union(childRect);
	      }
	    }
	
	    return rect || tmpRect;
	  }
	};
	zrUtil.inherits(Group, Element);
	var _default = Group;
	module.exports = _default;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	var Displayable = __webpack_require__(7);
	
	var BoundingRect = __webpack_require__(26);
	
	var zrUtil = __webpack_require__(4);
	
	var imageHelper = __webpack_require__(27);
	
	/**
	 * @alias zrender/graphic/Image
	 * @extends module:zrender/graphic/Displayable
	 * @constructor
	 * @param {Object} opts
	 */
	function ZImage(opts) {
	  Displayable.call(this, opts);
	}
	
	ZImage.prototype = {
	  constructor: ZImage,
	  type: 'image',
	  brush: function (ctx, prevEl) {
	    var style = this.style;
	    var src = style.image; // Must bind each time
	
	    style.bind(ctx, this, prevEl);
	    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);
	
	    if (!image || !imageHelper.isImageReady(image)) {
	      return;
	    } // 图片已经加载完成
	    // if (image.nodeName.toUpperCase() == 'IMG') {
	    //     if (!image.complete) {
	    //         return;
	    //     }
	    // }
	    // Else is canvas
	
	
	    var x = style.x || 0;
	    var y = style.y || 0;
	    var width = style.width;
	    var height = style.height;
	    var aspect = image.width / image.height;
	
	    if (width == null && height != null) {
	      // Keep image/height ratio
	      width = height * aspect;
	    } else if (height == null && width != null) {
	      height = width / aspect;
	    } else if (width == null && height == null) {
	      width = image.width;
	      height = image.height;
	    } // 设置transform
	
	
	    this.setTransform(ctx);
	
	    if (style.sWidth && style.sHeight) {
	      var sx = style.sx || 0;
	      var sy = style.sy || 0;
	      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
	    } else if (style.sx && style.sy) {
	      var sx = style.sx;
	      var sy = style.sy;
	      var sWidth = width - sx;
	      var sHeight = height - sy;
	      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
	    } else {
	      ctx.drawImage(image, x, y, width, height);
	    }
	
	    this.restoreTransform(ctx); // Draw rect text
	
	    if (style.text != null) {
	      this.drawRectText(ctx, this.getBoundingRect());
	    }
	  },
	  getBoundingRect: function () {
	    var style = this.style;
	
	    if (!this._rect) {
	      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
	    }
	
	    return this._rect;
	  }
	};
	zrUtil.inherits(ZImage, Displayable);
	var _default = ZImage;
	module.exports = _default;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	var Displayable = __webpack_require__(7);
	
	var zrUtil = __webpack_require__(4);
	
	var textContain = __webpack_require__(25);
	
	var textHelper = __webpack_require__(24);
	
	/**
	 * @alias zrender/graphic/Text
	 * @extends module:zrender/graphic/Displayable
	 * @constructor
	 * @param {Object} opts
	 */
	var Text = function (opts) {
	  // jshint ignore:line
	  Displayable.call(this, opts);
	};
	
	Text.prototype = {
	  constructor: Text,
	  type: 'text',
	  brush: function (ctx, prevEl) {
	    var style = this.style; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.
	
	    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
	    var text = style.text; // Convert to string
	
	    text != null && (text += ''); // Always bind style
	
	    style.bind(ctx, this, prevEl);
	
	    if (!textHelper.needDrawText(text, style)) {
	      return;
	    }
	
	    this.setTransform(ctx);
	    textHelper.renderText(this, ctx, text, style);
	    this.restoreTransform(ctx);
	  },
	  getBoundingRect: function () {
	    var style = this.style; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true);
	
	    if (!this._rect) {
	      var text = style.text;
	      text != null ? text += '' : text = '';
	      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);
	      rect.x += style.x || 0;
	      rect.y += style.y || 0;
	
	      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {
	        var w = style.textStrokeWidth;
	        rect.x -= w / 2;
	        rect.y -= w / 2;
	        rect.width += w;
	        rect.height += w;
	      }
	
	      this._rect = rect;
	    }
	
	    return this._rect;
	  }
	};
	zrUtil.inherits(Text, Displayable);
	var _default = Text;
	module.exports = _default;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	/**
	 * 圆形
	 * @module zrender/shape/Circle
	 */
	var _default = Path.extend({
	  type: 'circle',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r: 0
	  },
	  buildPath: function (ctx, shape, inBundle) {
	    // Better stroking in ShapeBundle
	    // Always do it may have performence issue ( fill may be 2x more cost)
	    if (inBundle) {
	      ctx.moveTo(shape.cx + shape.r, shape.cy);
	    } // else {
	    //     if (ctx.allocate && !ctx.data.length) {
	    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);
	    //     }
	    // }
	    // Better stroking in ShapeBundle
	    // ctx.moveTo(shape.cx + shape.r, shape.cy);
	
	
	    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	var fixClipWithShadow = __webpack_require__(48);
	
	/**
	 * 扇形
	 * @module zrender/graphic/shape/Sector
	 */
	var _default = Path.extend({
	  type: 'sector',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r0: 0,
	    r: 0,
	    startAngle: 0,
	    endAngle: Math.PI * 2,
	    clockwise: true
	  },
	  brush: fixClipWithShadow(Path.prototype.brush),
	  buildPath: function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var r0 = Math.max(shape.r0 || 0, 0);
	    var r = Math.max(shape.r, 0);
	    var startAngle = shape.startAngle;
	    var endAngle = shape.endAngle;
	    var clockwise = shape.clockwise;
	    var unitX = Math.cos(startAngle);
	    var unitY = Math.sin(startAngle);
	    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
	    ctx.lineTo(unitX * r + x, unitY * r + y);
	    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);
	
	    if (r0 !== 0) {
	      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	    }
	
	    ctx.closePath();
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	var env = __webpack_require__(49);
	
	// Fix weird bug in some version of IE11 (like 11.0.9600.178**),
	// where exception "unexpected call to method or property access"
	// might be thrown when calling ctx.fill or ctx.stroke after a path
	// whose area size is zero is drawn and ctx.clip() is called and
	// shadowBlur is set. See #4572, #3112, #5777.
	// (e.g.,
	//  ctx.moveTo(10, 10);
	//  ctx.lineTo(20, 10);
	//  ctx.closePath();
	//  ctx.clip();
	//  ctx.shadowBlur = 10;
	//  ...
	//  ctx.fill();
	// )
	var shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];
	
	function _default(orignalBrush) {
	  // version string can be: '11.0'
	  return env.browser.ie && env.browser.version >= 11 ? function () {
	    var clipPaths = this.__clipPaths;
	    var style = this.style;
	    var modified;
	
	    if (clipPaths) {
	      for (var i = 0; i < clipPaths.length; i++) {
	        var clipPath = clipPaths[i];
	        var shape = clipPath && clipPath.shape;
	        var type = clipPath && clipPath.type;
	
	        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {
	          for (var j = 0; j < shadowTemp.length; j++) {
	            // It is save to put shadowTemp static, because shadowTemp
	            // will be all modified each item brush called.
	            shadowTemp[j][2] = style[shadowTemp[j][0]];
	            style[shadowTemp[j][0]] = shadowTemp[j][1];
	          }
	
	          modified = true;
	          break;
	        }
	      }
	    }
	
	    orignalBrush.apply(this, arguments);
	
	    if (modified) {
	      for (var j = 0; j < shadowTemp.length; j++) {
	        style[shadowTemp[j][0]] = shadowTemp[j][2];
	      }
	    }
	  } : orignalBrush;
	}
	
	module.exports = _default;

/***/ }),
/* 49 */
/***/ (function(module, exports) {

	/**
	 * echarts设备环境识别
	 *
	 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
	 * @author firede[firede@firede.us]
	 * @desc thanks zepto.
	 */
	var env = {};
	
	if (typeof navigator === 'undefined') {
	  // In node
	  env = {
	    browser: {},
	    os: {},
	    node: true,
	    // Assume canvas is supported
	    canvasSupported: true,
	    svgSupported: true
	  };
	} else {
	  env = detect(navigator.userAgent);
	}
	
	var _default = env; // Zepto.js
	// (c) 2010-2013 Thomas Fuchs
	// Zepto.js may be freely distributed under the MIT license.
	
	function detect(ua) {
	  var os = {};
	  var browser = {}; // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
	  // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
	  // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	  // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	  // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
	  // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
	  // var touchpad = webos && ua.match(/TouchPad/);
	  // var kindle = ua.match(/Kindle\/([\d.]+)/);
	  // var silk = ua.match(/Silk\/([\d._]+)/);
	  // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
	  // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
	  // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
	  // var playbook = ua.match(/PlayBook/);
	  // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
	
	  var firefox = ua.match(/Firefox\/([\d.]+)/); // var safari = webkit && ua.match(/Mobile\//) && !chrome;
	  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
	
	  var ie = ua.match(/MSIE\s([\d.]+)/) // IE 11 Trident/7.0; rv:11.0
	  || ua.match(/Trident\/.+?rv:(([\d.]+))/);
	  var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+
	
	  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:
	  // - discern (more) between multiple browsers on android
	  // - decide if kindle fire in silk mode is android or not
	  // - Firefox on Android doesn't specify the Android version
	  // - possibly devide in os, device and browser hashes
	  // if (browser.webkit = !!webkit) browser.version = webkit[1];
	  // if (android) os.android = true, os.version = android[2];
	  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
	  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
	  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	  // if (webos) os.webos = true, os.version = webos[2];
	  // if (touchpad) os.touchpad = true;
	  // if (blackberry) os.blackberry = true, os.version = blackberry[2];
	  // if (bb10) os.bb10 = true, os.version = bb10[2];
	  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
	  // if (playbook) browser.playbook = true;
	  // if (kindle) os.kindle = true, os.version = kindle[1];
	  // if (silk) browser.silk = true, browser.version = silk[1];
	  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
	  // if (chrome) browser.chrome = true, browser.version = chrome[1];
	
	  if (firefox) {
	    browser.firefox = true;
	    browser.version = firefox[1];
	  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
	  // if (webview) browser.webview = true;
	
	
	  if (ie) {
	    browser.ie = true;
	    browser.version = ie[1];
	  }
	
	  if (edge) {
	    browser.edge = true;
	    browser.version = edge[1];
	  } // It is difficult to detect WeChat in Win Phone precisely, because ua can
	  // not be set on win phone. So we do not consider Win Phone.
	
	
	  if (weChat) {
	    browser.weChat = true;
	  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
	  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
	  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
	  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
	  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));
	
	
	  return {
	    browser: browser,
	    os: os,
	    node: false,
	    // 原生canvas支持，改极端点了
	    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
	    canvasSupported: !!document.createElement('canvas').getContext,
	    svgSupported: typeof SVGRect !== 'undefined',
	    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
	    // works on most browsers
	    // IE10/11 does not support touch event, and MS Edge supports them but not by
	    // default, so we dont check navigator.maxTouchPoints for them here.
	    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
	    // <http://caniuse.com/#search=pointer%20event>.
	    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer
	    // events currently. So we dont use that on other browsers unless tested sufficiently.
	    // Although IE 10 supports pointer event, it use old style and is different from the
	    // standard. So we exclude that. (IE 10 is hardly used on touch device)
	    && (browser.edge || browser.ie && browser.version >= 11)
	  };
	}
	
	module.exports = _default;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	/**
	 * 圆环
	 * @module zrender/graphic/shape/Ring
	 */
	var _default = Path.extend({
	  type: 'ring',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r: 0,
	    r0: 0
	  },
	  buildPath: function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var PI2 = Math.PI * 2;
	    ctx.moveTo(x + shape.r, y);
	    ctx.arc(x, y, shape.r, 0, PI2, false);
	    ctx.moveTo(x + shape.r0, y);
	    ctx.arc(x, y, shape.r0, 0, PI2, true);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	var polyHelper = __webpack_require__(52);
	
	/**
	 * 多边形
	 * @module zrender/shape/Polygon
	 */
	var _default = Path.extend({
	  type: 'polygon',
	  shape: {
	    points: null,
	    smooth: false,
	    smoothConstraint: null
	  },
	  buildPath: function (ctx, shape) {
	    polyHelper.buildPath(ctx, shape, true);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	var smoothSpline = __webpack_require__(53);
	
	var smoothBezier = __webpack_require__(54);
	
	function buildPath(ctx, shape, closePath) {
	  var points = shape.points;
	  var smooth = shape.smooth;
	
	  if (points && points.length >= 2) {
	    if (smooth && smooth !== 'spline') {
	      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
	      ctx.moveTo(points[0][0], points[0][1]);
	      var len = points.length;
	
	      for (var i = 0; i < (closePath ? len : len - 1); i++) {
	        var cp1 = controlPoints[i * 2];
	        var cp2 = controlPoints[i * 2 + 1];
	        var p = points[(i + 1) % len];
	        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
	      }
	    } else {
	      if (smooth === 'spline') {
	        points = smoothSpline(points, closePath);
	      }
	
	      ctx.moveTo(points[0][0], points[0][1]);
	
	      for (var i = 1, l = points.length; i < l; i++) {
	        ctx.lineTo(points[i][0], points[i][1]);
	      }
	    }
	
	    closePath && ctx.closePath();
	  }
	}
	
	exports.buildPath = buildPath;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	var _vector = __webpack_require__(14);
	
	var v2Distance = _vector.distance;
	
	/**
	 * Catmull-Rom spline 插值折线
	 * @module zrender/shape/util/smoothSpline
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	/**
	 * @inner
	 */
	function interpolate(p0, p1, p2, p3, t, t2, t3) {
	  var v0 = (p2 - p0) * 0.5;
	  var v1 = (p3 - p1) * 0.5;
	  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
	}
	/**
	 * @alias module:zrender/shape/util/smoothSpline
	 * @param {Array} points 线段顶点数组
	 * @param {boolean} isLoop
	 * @return {Array}
	 */
	
	
	function _default(points, isLoop) {
	  var len = points.length;
	  var ret = [];
	  var distance = 0;
	
	  for (var i = 1; i < len; i++) {
	    distance += v2Distance(points[i - 1], points[i]);
	  }
	
	  var segs = distance / 2;
	  segs = segs < len ? len : segs;
	
	  for (var i = 0; i < segs; i++) {
	    var pos = i / (segs - 1) * (isLoop ? len : len - 1);
	    var idx = Math.floor(pos);
	    var w = pos - idx;
	    var p0;
	    var p1 = points[idx % len];
	    var p2;
	    var p3;
	
	    if (!isLoop) {
	      p0 = points[idx === 0 ? idx : idx - 1];
	      p2 = points[idx > len - 2 ? len - 1 : idx + 1];
	      p3 = points[idx > len - 3 ? len - 1 : idx + 2];
	    } else {
	      p0 = points[(idx - 1 + len) % len];
	      p2 = points[(idx + 1) % len];
	      p3 = points[(idx + 2) % len];
	    }
	
	    var w2 = w * w;
	    var w3 = w * w2;
	    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
	  }
	
	  return ret;
	}
	
	module.exports = _default;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	var _vector = __webpack_require__(14);
	
	var v2Min = _vector.min;
	var v2Max = _vector.max;
	var v2Scale = _vector.scale;
	var v2Distance = _vector.distance;
	var v2Add = _vector.add;
	var v2Clone = _vector.clone;
	var v2Sub = _vector.sub;
	
	/**
	 * 贝塞尔平滑曲线
	 * @module zrender/shape/util/smoothBezier
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	/**
	 * 贝塞尔平滑曲线
	 * @alias module:zrender/shape/util/smoothBezier
	 * @param {Array} points 线段顶点数组
	 * @param {number} smooth 平滑等级, 0-1
	 * @param {boolean} isLoop
	 * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
	 *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
	 *                           整个折线的包围盒做一个并集用来约束控制点。
	 * @param {Array} 计算出来的控制点数组
	 */
	function _default(points, smooth, isLoop, constraint) {
	  var cps = [];
	  var v = [];
	  var v1 = [];
	  var v2 = [];
	  var prevPoint;
	  var nextPoint;
	  var min, max;
	
	  if (constraint) {
	    min = [Infinity, Infinity];
	    max = [-Infinity, -Infinity];
	
	    for (var i = 0, len = points.length; i < len; i++) {
	      v2Min(min, min, points[i]);
	      v2Max(max, max, points[i]);
	    } // 与指定的包围盒做并集
	
	
	    v2Min(min, min, constraint[0]);
	    v2Max(max, max, constraint[1]);
	  }
	
	  for (var i = 0, len = points.length; i < len; i++) {
	    var point = points[i];
	
	    if (isLoop) {
	      prevPoint = points[i ? i - 1 : len - 1];
	      nextPoint = points[(i + 1) % len];
	    } else {
	      if (i === 0 || i === len - 1) {
	        cps.push(v2Clone(points[i]));
	        continue;
	      } else {
	        prevPoint = points[i - 1];
	        nextPoint = points[i + 1];
	      }
	    }
	
	    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length
	
	    v2Scale(v, v, smooth);
	    var d0 = v2Distance(point, prevPoint);
	    var d1 = v2Distance(point, nextPoint);
	    var sum = d0 + d1;
	
	    if (sum !== 0) {
	      d0 /= sum;
	      d1 /= sum;
	    }
	
	    v2Scale(v1, v, -d0);
	    v2Scale(v2, v, d1);
	    var cp0 = v2Add([], point, v1);
	    var cp1 = v2Add([], point, v2);
	
	    if (constraint) {
	      v2Max(cp0, cp0, min);
	      v2Min(cp0, cp0, max);
	      v2Max(cp1, cp1, min);
	      v2Min(cp1, cp1, max);
	    }
	
	    cps.push(cp0);
	    cps.push(cp1);
	  }
	
	  if (isLoop) {
	    cps.push(cps.shift());
	  }
	
	  return cps;
	}
	
	module.exports = _default;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	var polyHelper = __webpack_require__(52);
	
	/**
	 * @module zrender/graphic/shape/Polyline
	 */
	var _default = Path.extend({
	  type: 'polyline',
	  shape: {
	    points: null,
	    smooth: false,
	    smoothConstraint: null
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    polyHelper.buildPath(ctx, shape, false);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	var roundRectHelper = __webpack_require__(28);
	
	/**
	 * 矩形
	 * @module zrender/graphic/shape/Rect
	 */
	var _default = Path.extend({
	  type: 'rect',
	  shape: {
	    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
	    // r缩写为1         相当于 [1, 1, 1, 1]
	    // r缩写为[1]       相当于 [1, 1, 1, 1]
	    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
	    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
	    r: 0,
	    x: 0,
	    y: 0,
	    width: 0,
	    height: 0
	  },
	  buildPath: function (ctx, shape) {
	    var x = shape.x;
	    var y = shape.y;
	    var width = shape.width;
	    var height = shape.height;
	
	    if (!shape.r) {
	      ctx.rect(x, y, width, height);
	    } else {
	      roundRectHelper.buildPath(ctx, shape);
	    }
	
	    ctx.closePath();
	    return;
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	/**
	 * 直线
	 * @module zrender/graphic/shape/Line
	 */
	var _default = Path.extend({
	  type: 'line',
	  shape: {
	    // Start point
	    x1: 0,
	    y1: 0,
	    // End point
	    x2: 0,
	    y2: 0,
	    percent: 1
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    var x1 = shape.x1;
	    var y1 = shape.y1;
	    var x2 = shape.x2;
	    var y2 = shape.y2;
	    var percent = shape.percent;
	
	    if (percent === 0) {
	      return;
	    }
	
	    ctx.moveTo(x1, y1);
	
	    if (percent < 1) {
	      x2 = x1 * (1 - percent) + x2 * percent;
	      y2 = y1 * (1 - percent) + y2 * percent;
	    }
	
	    ctx.lineTo(x2, y2);
	  },
	
	  /**
	   * Get point at percent
	   * @param  {number} percent
	   * @return {Array.<number>}
	   */
	  pointAt: function (p) {
	    var shape = this.shape;
	    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	var vec2 = __webpack_require__(14);
	
	var _curve = __webpack_require__(30);
	
	var quadraticSubdivide = _curve.quadraticSubdivide;
	var cubicSubdivide = _curve.cubicSubdivide;
	var quadraticAt = _curve.quadraticAt;
	var cubicAt = _curve.cubicAt;
	var quadraticDerivativeAt = _curve.quadraticDerivativeAt;
	var cubicDerivativeAt = _curve.cubicDerivativeAt;
	
	/**
	 * 贝塞尔曲线
	 * @module zrender/shape/BezierCurve
	 */
	var out = [];
	
	function someVectorAt(shape, t, isTangent) {
	  var cpx2 = shape.cpx2;
	  var cpy2 = shape.cpy2;
	
	  if (cpx2 === null || cpy2 === null) {
	    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
	  } else {
	    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];
	  }
	}
	
	var _default = Path.extend({
	  type: 'bezier-curve',
	  shape: {
	    x1: 0,
	    y1: 0,
	    x2: 0,
	    y2: 0,
	    cpx1: 0,
	    cpy1: 0,
	    // cpx2: 0,
	    // cpy2: 0
	    // Curve show percent, for animating
	    percent: 1
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    var x1 = shape.x1;
	    var y1 = shape.y1;
	    var x2 = shape.x2;
	    var y2 = shape.y2;
	    var cpx1 = shape.cpx1;
	    var cpy1 = shape.cpy1;
	    var cpx2 = shape.cpx2;
	    var cpy2 = shape.cpy2;
	    var percent = shape.percent;
	
	    if (percent === 0) {
	      return;
	    }
	
	    ctx.moveTo(x1, y1);
	
	    if (cpx2 == null || cpy2 == null) {
	      if (percent < 1) {
	        quadraticSubdivide(x1, cpx1, x2, percent, out);
	        cpx1 = out[1];
	        x2 = out[2];
	        quadraticSubdivide(y1, cpy1, y2, percent, out);
	        cpy1 = out[1];
	        y2 = out[2];
	      }
	
	      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
	    } else {
	      if (percent < 1) {
	        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
	        cpx1 = out[1];
	        cpx2 = out[2];
	        x2 = out[3];
	        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
	        cpy1 = out[1];
	        cpy2 = out[2];
	        y2 = out[3];
	      }
	
	      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
	    }
	  },
	
	  /**
	   * Get point at percent
	   * @param  {number} t
	   * @return {Array.<number>}
	   */
	  pointAt: function (t) {
	    return someVectorAt(this.shape, t, false);
	  },
	
	  /**
	   * Get tangent at percent
	   * @param  {number} t
	   * @return {Array.<number>}
	   */
	  tangentAt: function (t) {
	    var p = someVectorAt(this.shape, t, true);
	    return vec2.normalize(p, p);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	/**
	 * 圆弧
	 * @module zrender/graphic/shape/Arc
	 */
	var _default = Path.extend({
	  type: 'arc',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r: 0,
	    startAngle: 0,
	    endAngle: Math.PI * 2,
	    clockwise: true
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var r = Math.max(shape.r, 0);
	    var startAngle = shape.startAngle;
	    var endAngle = shape.endAngle;
	    var clockwise = shape.clockwise;
	    var unitX = Math.cos(startAngle);
	    var unitY = Math.sin(startAngle);
	    ctx.moveTo(unitX * r + x, unitY * r + y);
	    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(4);
	
	var Gradient = __webpack_require__(41);
	
	/**
	 * x, y, x2, y2 are all percent from 0 to 1
	 * @param {number} [x=0]
	 * @param {number} [y=0]
	 * @param {number} [x2=1]
	 * @param {number} [y2=0]
	 * @param {Array.<Object>} colorStops
	 * @param {boolean} [globalCoord=false]
	 */
	var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
	  // Should do nothing more in this constructor. Because gradient can be
	  // declard by `color: {type: 'linear', colorStops: ...}`, where
	  // this constructor will not be called.
	  this.x = x == null ? 0 : x;
	  this.y = y == null ? 0 : y;
	  this.x2 = x2 == null ? 1 : x2;
	  this.y2 = y2 == null ? 0 : y2; // Can be cloned
	
	  this.type = 'linear'; // If use global coord
	
	  this.global = globalCoord || false;
	  Gradient.call(this, colorStops);
	};
	
	LinearGradient.prototype = {
	  constructor: LinearGradient
	};
	zrUtil.inherits(LinearGradient, Gradient);
	var _default = LinearGradient;
	module.exports = _default;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(4);
	
	var Gradient = __webpack_require__(41);
	
	/**
	 * x, y, r are all percent from 0 to 1
	 * @param {number} [x=0.5]
	 * @param {number} [y=0.5]
	 * @param {number} [r=0.5]
	 * @param {Array.<Object>} [colorStops]
	 * @param {boolean} [globalCoord=false]
	 */
	var RadialGradient = function (x, y, r, colorStops, globalCoord) {
	  // Should do nothing more in this constructor. Because gradient can be
	  // declard by `color: {type: 'radial', colorStops: ...}`, where
	  // this constructor will not be called.
	  this.x = x == null ? 0.5 : x;
	  this.y = y == null ? 0.5 : y;
	  this.r = r == null ? 0.5 : r; // Can be cloned
	
	  this.type = 'radial'; // If use global coord
	
	  this.global = globalCoord || false;
	  Gradient.call(this, colorStops);
	};
	
	RadialGradient.prototype = {
	  constructor: RadialGradient
	};
	zrUtil.inherits(RadialGradient, Gradient);
	var _default = RadialGradient;
	module.exports = _default;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(4);
	
	var Style = __webpack_require__(8);
	
	var _vector = __webpack_require__(14);
	
	var vec2Copy = _vector.copy;
	
	/**
	 * States machine for managing graphic states
	 */
	
	/**
	 * @typedef {Object} IGraphicState
	 * @property {number} [zlevel]
	 * @property {number} [z]
	 * @property {Array.<number>} {position}
	 * @property {Array.<number>|number} {rotation}
	 * @property {Array.<number>} {scale}
	 * @property {Object} style
	 *
	 * @property {Function} onenter
	 * @property {Function} onleave
	 * @property {Function} ontransition
	 * @property {Array.<IGraphicStateTransition|string>} transition
	 *           Transition object or a string descriptor like '* 30 0 Linear'
	 */
	var transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];
	/**
	 * @module zrender/graphic/States~TransitionObject
	 */
	
	var TransitionObject = function (opts) {
	  if (typeof opts == 'string') {
	    this._fromStr(opts);
	  } else if (opts) {
	    opts.property && (this.property = opts.property);
	    opts.duration != null && (this.duration = opts.duration);
	    opts.easing && (this.easing = opts.easing);
	    opts.delay && (this.delay = opts.delay);
	  }
	
	  if (this.property !== '*') {
	    this.property = this.property.split(',');
	  } else {
	    this.property = transitionProperties;
	  }
	};
	
	TransitionObject.prototype = {
	  constructor: TransitionObject,
	
	  /**
	   * List of all transition properties. Splitted by comma. Must not have spaces in the string.
	   * e.g. 'position,style.color'. '*' will match all the valid properties.
	   * @type {string}
	   * @default *
	   */
	  property: '*',
	
	  /**
	   * @type {string}
	   * @default 'Linear'
	   */
	  easing: 'Linear',
	
	  /**
	   * @type {number}
	   * @default 'number'
	   */
	  duration: 500,
	
	  /**
	   * @type {number}
	   */
	  delay: 0,
	  _fromStr: function (str) {
	    var arr = str.split(/\s+/g);
	    this.property = arr[0];
	    this.duration = +arr[1];
	    this.delay = +arr[2];
	    this.easing = arr[3];
	  }
	};
	/**
	 * @alias module:zrender/graphic/States
	 */
	
	var GraphicStates = function (opts) {
	  opts = opts || {};
	  this._states = {};
	  /**
	   * Target element
	   * @type {zrender/graphic/Displayable|zrender/container/Group}
	   */
	
	  this._el = opts.el;
	  this._subStates = [];
	  this._transitionAnimators = [];
	
	  if (opts.initialState) {
	    this._initialState = opts.initialState;
	  }
	
	  var optsStates = opts.states;
	
	  if (optsStates) {
	    for (var name in optsStates) {
	      if (optsStates.hasOwnProperty(name)) {
	        var state = optsStates[name];
	
	        this._addState(name, state);
	      }
	    }
	  }
	
	  this.setState(this._initialState);
	};
	
	GraphicStates.prototype = {
	  constructor: GraphicStates,
	
	  /**
	   * All other state will be extended from initial state
	   * @type {string}
	   * @private
	   */
	  _initialState: 'normal',
	
	  /**
	   * Current state
	   * @type {string}
	   * @private
	   */
	  _currentState: '',
	  el: function () {
	    return this._el;
	  },
	  _addState: function (name, state) {
	    this._states[name] = state;
	
	    if (state.transition) {
	      state.transition = new TransitionObject(state.transition);
	    } // Extend from initial state
	
	
	    if (name !== this._initialState) {
	      this._extendFromInitial(state);
	    } else {
	      var el = this._el; // setState 的时候自带的 style 和 shape 都会被直接覆盖
	      // 所以这边先把自带的 style 和 shape 扩展到初始状态中
	
	      zrUtil.merge(state.style, el.style, false, false);
	
	      if (state.shape) {
	        zrUtil.merge(state.shape, el.shape, false, true);
	      } else {
	        state.shape = zrUtil.clone(el.shape, true);
	      }
	
	      for (var name in this._states) {
	        if (this._states.hasOwnProperty(name)) {
	          this._extendFromInitial(this._states[name]);
	        }
	      }
	    }
	  },
	  _extendFromInitial: function (state) {
	    var initialState = this._states[this._initialState];
	
	    if (initialState && state !== initialState) {
	      zrUtil.merge(state, initialState, false, true);
	    }
	  },
	  setState: function (name, silent) {
	    if (name === this._currentState && !this.transiting()) {
	      return;
	    }
	
	    var state = this._states[name];
	
	    if (state) {
	      this._stopTransition();
	
	      if (!silent) {
	        var prevState = this._states[this._currentState];
	
	        if (prevState) {
	          prevState.onleave && prevState.onleave.call(this);
	        }
	
	        state.onenter && state.onenter.call(this);
	      }
	
	      this._currentState = name;
	
	      if (this._el) {
	        var el = this._el; // Setting attributes
	
	        if (state.zlevel != null) {
	          el.zlevel = state.zlevel;
	        }
	
	        if (state.z != null) {
	          el.z = state.z;
	        } // SRT
	
	
	        state.position && vec2Copy(el.position, state.position);
	        state.scale && vec2Copy(el.scale, state.scale);
	
	        if (state.rotation != null) {
	          el.rotation = state.rotation;
	        } // Style
	
	
	        if (state.style) {
	          var initialState = this._states[this._initialState];
	          el.style = new Style();
	
	          if (initialState) {
	            el.style.extendFrom(initialState.style, false);
	          }
	
	          if ( // Not initial state
	          name != this._initialState // Not copied from initial state in _extendFromInitial method
	          && initialState.style !== state.style) {
	            el.style.extendFrom(state.style, true);
	          }
	        }
	
	        if (state.shape) {
	          el.shape = zrUtil.clone(state.shape, true);
	        }
	
	        el.dirty();
	      }
	    }
	
	    for (var i = 0; i < this._subStates.length; i++) {
	      this._subStates.setState(name);
	    }
	  },
	  getState: function () {
	    return this._currentState;
	  },
	  transitionState: function (target, done) {
	    if (target === this._currentState && !this.transiting()) {
	      return;
	    }
	
	    var state = this._states[target];
	    var styleShapeReg = /$[style|shape]\./;
	    var self = this; // Animation 去重
	
	    var propPathMap = {};
	
	    if (state) {
	      self._stopTransition();
	
	      var el = self._el;
	
	      if (state.transition && el && el.__zr) {
	        // El can be animated
	        var transitionCfg = state.transition;
	        var property = transitionCfg.property;
	        var animatingCount = 0;
	
	        var animationDone = function () {
	          animatingCount--;
	
	          if (animatingCount === 0) {
	            self.setState(target);
	            done && done();
	          }
	        };
	
	        for (var i = 0; i < property.length; i++) {
	          var propName = property[i]; // Animating all the properties in style or shape
	
	          if (propName === 'style' || propName === 'shape') {
	            if (state[propName]) {
	              for (var key in state[propName]) {
	                if (!state[propName].hasOwnProperty(key)) {
	                  continue;
	                }
	
	                var path = propName + '.' + key;
	
	                if (propPathMap[path]) {
	                  continue;
	                }
	
	                propPathMap[path] = 1;
	                animatingCount += self._animProp(state, propName, key, transitionCfg, animationDone);
	              }
	            }
	          } else {
	            if (propPathMap[propName]) {
	              continue;
	            }
	
	            propPathMap[propName] = 1; // Animating particular property in style or style
	
	            if (propName.match(styleShapeReg)) {
	              // remove 'style.', 'shape.' prefix
	              var subProp = propName.slice(0, 5);
	              propName = propName.slice(6);
	              animatingCount += self._animProp(state, subProp, propName, transitionCfg, animationDone);
	            } else {
	              animatingCount += self._animProp(state, '', propName, transitionCfg, animationDone);
	            }
	          }
	        } // No transition properties
	
	
	        if (animatingCount === 0) {
	          self.setState(target);
	          done && done();
	        }
	      } else {
	        self.setState(target);
	        done && done();
	      }
	    }
	
	    var subStates = self._subStates;
	
	    for (var i = 0; i < subStates.length; i++) {
	      subStates.transitionState(target);
	    }
	  },
	
	  /**
	   * Do transition animation of particular property
	   * @param {Object} state
	   * @param {string} subPropKey
	   * @param {string} key
	   * @param {Object} transitionCfg
	   * @param {Function} done
	   * @private
	   */
	  _animProp: function (state, subPropKey, key, transitionCfg, done) {
	    var el = this._el;
	    var stateObj = subPropKey ? state[subPropKey] : state;
	    var elObj = subPropKey ? el[subPropKey] : el;
	    var availableProp = stateObj && key in stateObj && elObj && key in elObj;
	    var transitionAnimators = this._transitionAnimators;
	
	    if (availableProp) {
	      var obj = {};
	
	      if (stateObj[key] === elObj[key]) {
	        return 0;
	      }
	
	      obj[key] = stateObj[key];
	      var animator = el.animate(subPropKey).when(transitionCfg.duration, obj).delay(transitionCfg.dealy).done(function () {
	        var idx = zrUtil.indexOf(transitionAnimators, 1);
	
	        if (idx > 0) {
	          transitionAnimators.splice(idx, 1);
	        }
	
	        done();
	      }).start(transitionCfg.easing);
	      transitionAnimators.push(animator);
	      return 1;
	    }
	
	    return 0;
	  },
	  _stopTransition: function () {
	    var transitionAnimators = this._transitionAnimators;
	
	    for (var i = 0; i < transitionAnimators.length; i++) {
	      transitionAnimators[i].stop();
	    }
	
	    transitionAnimators.length = 0;
	  },
	  transiting: function () {
	    return this._transitionAnimators.length > 0;
	  },
	  addSubStates: function (states) {
	    this._subStates.push(states);
	  },
	  removeSubStates: function (states) {
	    var idx = zrUtil.indexOf(this._subStates, states);
	
	    if (idx >= 0) {
	      this._subStates.splice(states, 1);
	    }
	  }
	};
	var _default = GraphicStates;
	module.exports = _default;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var apiList = [
	        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',
	        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',
	        "remove", "_getParentZr"
	    ];
	
	    function ExtensionAPI(instance) {
	        zrUtil.each(apiList, function (name) {
	            this[name] = zrUtil.bind(instance[name], instance);
	        }, this);
	    }
	
	    module.exports = ExtensionAPI;
	


/***/ }),
/* 64 */
/***/ (function(module, exports) {

	
	
	    /**
	      * Creates an instance of Point
	      *
	      *
	      * @constructor
	      * @this {Point}
	      * @param {Number} x The x coordinate of point.
	      * @param {Number} y The y coordinate of point.
	      * Note: Even if it is named Point this class should be named Dot as Dot is closer
	      * then Point from math perspective.
	      **/
	    function Point(x, y){
	        /**The x coordinate of point*/
	        this.x = x;
	
	        /**The y coordinate of point*/
	        this.y = y;
	
	
	    }
	
	    /**Creates a {Point} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Point} a newly constructed Point
	     **/
	    Point.load = function(o){
	        var newPoint = new Point(Number(o.x), Number(o.y));
	        return newPoint;
	    };
	
	
	    /**Creates an array of points from an array of {JSONObject}s
	     *@param {Array} v - the array of JSONObjects
	     *@return an {Array} of {Point}s
	     **/
	    Point.loadArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(Point.load(v[i]));
	        }
	        return newPoints;
	    };
	
	
	    /**Clones an array of points
	     *@param {Array} v - the array of {Point}s
	     *@return an {Array} of {Point}s
	     **/
	    Point.cloneArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(v[i].clone());
	        }
	        return newPoints;
	    };
	
	    Point.prototype = {
	        constructor : Point,
	
	        transform:function(matrix){
	            var oldX = this.x;
	            var oldY = this.y;
	            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];
	            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];
	        },
	
	        /**Tests if this point is similar to other point
	         *@param {Point} anotherPoint - the other point
	         **/
	        equals:function(anotherPoint){
	            if(! (anotherPoint instanceof Point) ){
	                return false;
	            }
	            return (this.x == anotherPoint.x)
	            && (this.y == anotherPoint.y)
	        },
	
	        /**Clone current Point
	         **/
	        clone: function(){
	            var newPoint = new Point(this.x, this.y);
	            return newPoint;
	        },
	
	        add: function(point) {
	            this.x = this.x + point.x;
	            this.y = this.y + point.y;
	            return this;
	        },
	
	        /**Tests to see if a point (x, y) is within a range of current Point
	         *@param {Numeric} x - the x coordinate of tested point
	         *@param {Numeric} y - the x coordinate of tested point
	         *@param {Numeric} radius - the radius of the vicinity
	         **/
	        near:function(x, y, radius){
	            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));
	
	            return (distance <= radius);
	        },
	
	        contains: function(x,y){
	            return this.x == x && this.y == y;
	        },
	
	        toString:function(){
	            return '[' + this.x + ',' + this.y + ']';
	        },
	
	        getPoints:function(){
	            return [this];
	        }
	    };
	    module.exports = Point;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	var guid = __webpack_require__(10);
	
	var env = __webpack_require__(49);
	
	var zrUtil = __webpack_require__(4);
	
	var Handler = __webpack_require__(66);
	
	var Storage = __webpack_require__(67);
	
	var Painter = __webpack_require__(69);
	
	var Animation = __webpack_require__(72);
	
	var HandlerProxy = __webpack_require__(74);
	
	/*!
	* ZRender, a high performance 2d drawing library.
	*
	* Copyright (c) 2013, Baidu Inc.
	* All rights reserved.
	*
	* LICENSE
	* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	*/
	var useVML = !env.canvasSupported;
	var painterCtors = {
	  canvas: Painter
	};
	var instances = {}; // ZRender实例map索引
	
	/**
	 * @type {string}
	 */
	
	var version = '3.7.4';
	/**
	 * Initializing a zrender instance
	 * @param {HTMLElement} dom
	 * @param {Object} opts
	 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	 * @param {number} [opts.devicePixelRatio]
	 * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
	 * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
	 * @return {module:zrender/ZRender}
	 */
	
	function init(dom, opts) {
	  var zr = new ZRender(guid(), dom, opts);
	  instances[zr.id] = zr;
	  return zr;
	}
	/**
	 * Dispose zrender instance
	 * @param {module:zrender/ZRender} zr
	 */
	
	
	function dispose(zr) {
	  if (zr) {
	    zr.dispose();
	  } else {
	    for (var key in instances) {
	      if (instances.hasOwnProperty(key)) {
	        instances[key].dispose();
	      }
	    }
	
	    instances = {};
	  }
	
	  return this;
	}
	/**
	 * Get zrender instance by id
	 * @param {string} id zrender instance id
	 * @return {module:zrender/ZRender}
	 */
	
	
	function getInstance(id) {
	  return instances[id];
	}
	
	function registerPainter(name, Ctor) {
	  painterCtors[name] = Ctor;
	}
	
	function delInstance(id) {
	  delete instances[id];
	}
	/**
	 * @module zrender/ZRender
	 */
	
	/**
	 * @constructor
	 * @alias module:zrender/ZRender
	 * @param {string} id
	 * @param {HTMLElement} dom
	 * @param {Object} opts
	 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	 * @param {number} [opts.devicePixelRatio]
	 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
	 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
	 */
	
	
	var ZRender = function (id, dom, opts) {
	  opts = opts || {};
	  /**
	   * @type {HTMLDomElement}
	   */
	
	  this.dom = dom;
	  /**
	   * @type {string}
	   */
	
	  this.id = id;
	  var self = this;
	  var storage = new Storage();
	  var rendererType = opts.renderer; // TODO WebGL
	
	  if (useVML) {
	    if (!painterCtors.vml) {
	      throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
	    }
	
	    rendererType = 'vml';
	  } else if (!rendererType || !painterCtors[rendererType]) {
	    rendererType = 'canvas';
	  }
	
	  var painter = new painterCtors[rendererType](dom, storage, opts);
	  this.storage = storage;
	  this.painter = painter;
	  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;
	  this.handler = new Handler(storage, painter, handerProxy, painter.root);
	  /**
	   * @type {module:zrender/animation/Animation}
	   */
	
	  this.animation = new Animation({
	    stage: {
	      update: zrUtil.bind(this.flush, this)
	    }
	  });
	  this.animation.start();
	  /**
	   * @type {boolean}
	   * @private
	   */
	
	  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画
	  // FIXME 有点ugly
	
	  var oldDelFromStorage = storage.delFromStorage;
	  var oldAddToStorage = storage.addToStorage;
	
	  storage.delFromStorage = function (el) {
	    oldDelFromStorage.call(storage, el);
	    el && el.removeSelfFromZr(self);
	  };
	
	  storage.addToStorage = function (el) {
	    oldAddToStorage.call(storage, el);
	    el.addSelfToZr(self);
	  };
	};
	
	ZRender.prototype = {
	  constructor: ZRender,
	
	  /**
	   * 获取实例唯一标识
	   * @return {string}
	   */
	  getId: function () {
	    return this.id;
	  },
	
	  /**
	   * 添加元素
	   * @param  {module:zrender/Element} el
	   */
	  add: function (el) {
	    this.storage.addRoot(el);
	    this._needsRefresh = true;
	  },
	
	  /**
	   * 删除元素
	   * @param  {module:zrender/Element} el
	   */
	  remove: function (el) {
	    this.storage.delRoot(el);
	    this._needsRefresh = true;
	  },
	
	  /**
	   * Change configuration of layer
	   * @param {string} zLevel
	   * @param {Object} config
	   * @param {string} [config.clearColor=0] Clear color
	   * @param {string} [config.motionBlur=false] If enable motion blur
	   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
	  */
	  configLayer: function (zLevel, config) {
	    this.painter.configLayer(zLevel, config);
	    this._needsRefresh = true;
	  },
	
	  /**
	   * Repaint the canvas immediately
	   */
	  refreshImmediately: function () {
	    // var start = new Date();
	    // Clear needsRefresh ahead to avoid something wrong happens in refresh
	    // Or it will cause zrender refreshes again and again.
	    this._needsRefresh = false;
	    this.painter.refresh();
	    /**
	     * Avoid trigger zr.refresh in Element#beforeUpdate hook
	     */
	
	    this._needsRefresh = false; // var end = new Date();
	    // var log = document.getElementById('log');
	    // if (log) {
	    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);
	    // }
	  },
	
	  /**
	   * Mark and repaint the canvas in the next frame of browser
	   */
	  refresh: function () {
	    this._needsRefresh = true;
	  },
	
	  /**
	   * Perform all refresh
	   */
	  flush: function () {
	    if (this._needsRefresh) {
	      this.refreshImmediately();
	    }
	
	    if (this._needsRefreshHover) {
	      this.refreshHoverImmediately();
	    }
	  },
	
	  /**
	   * Add element to hover layer
	   * @param  {module:zrender/Element} el
	   * @param {Object} style
	   */
	  addHover: function (el, style) {
	    if (this.painter.addHover) {
	      this.painter.addHover(el, style);
	      this.refreshHover();
	    }
	  },
	
	  /**
	   * Add element from hover layer
	   * @param  {module:zrender/Element} el
	   */
	  removeHover: function (el) {
	    if (this.painter.removeHover) {
	      this.painter.removeHover(el);
	      this.refreshHover();
	    }
	  },
	
	  /**
	   * Clear all hover elements in hover layer
	   * @param  {module:zrender/Element} el
	   */
	  clearHover: function () {
	    if (this.painter.clearHover) {
	      this.painter.clearHover();
	      this.refreshHover();
	    }
	  },
	
	  /**
	   * Refresh hover in next frame
	   */
	  refreshHover: function () {
	    this._needsRefreshHover = true;
	  },
	
	  /**
	   * Refresh hover immediately
	   */
	  refreshHoverImmediately: function () {
	    this._needsRefreshHover = false;
	    this.painter.refreshHover && this.painter.refreshHover();
	  },
	
	  /**
	   * Resize the canvas.
	   * Should be invoked when container size is changed
	   * @param {Object} [opts]
	   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
	   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
	   */
	  resize: function (opts) {
	    opts = opts || {};
	    this.painter.resize(opts.width, opts.height);
	    this.handler.resize();
	  },
	
	  /**
	   * Stop and clear all animation immediately
	   */
	  clearAnimation: function () {
	    this.animation.clear();
	  },
	
	  /**
	   * Get container width
	   */
	  getWidth: function () {
	    return this.painter.getWidth();
	  },
	
	  /**
	   * Get container height
	   */
	  getHeight: function () {
	    return this.painter.getHeight();
	  },
	
	  /**
	   * Export the canvas as Base64 URL
	   * @param {string} type
	   * @param {string} [backgroundColor='#fff']
	   * @return {string} Base64 URL
	   */
	  // toDataURL: function(type, backgroundColor) {
	  //     return this.painter.getRenderedCanvas({
	  //         backgroundColor: backgroundColor
	  //     }).toDataURL(type);
	  // },
	
	  /**
	   * Converting a path to image.
	   * It has much better performance of drawing image rather than drawing a vector path.
	   * @param {module:zrender/graphic/Path} e
	   * @param {number} width
	   * @param {number} height
	   */
	  pathToImage: function (e, dpr) {
	    return this.painter.pathToImage(e, dpr);
	  },
	
	  /**
	   * Set default cursor
	   * @param {string} [cursorStyle='default'] 例如 crosshair
	   */
	  setCursorStyle: function (cursorStyle) {
	    this.handler.setCursorStyle(cursorStyle);
	  },
	
	  /**
	   * Find hovered element
	   * @param {number} x
	   * @param {number} y
	   * @return {Object} {target, topTarget}
	   */
	  findHover: function (x, y) {
	    return this.handler.findHover(x, y);
	  },
	
	  /**
	   * Bind event
	   *
	   * @param {string} eventName Event name
	   * @param {Function} eventHandler Handler function
	   * @param {Object} [context] Context object
	   */
	  on: function (eventName, eventHandler, context) {
	    this.handler.on(eventName, eventHandler, context);
	  },
	
	  /**
	   * Unbind event
	   * @param {string} eventName Event name
	   * @param {Function} [eventHandler] Handler function
	   */
	  off: function (eventName, eventHandler) {
	    this.handler.off(eventName, eventHandler);
	  },
	
	  /**
	   * Trigger event manually
	   *
	   * @param {string} eventName Event name
	   * @param {event=} event Event object
	   */
	  trigger: function (eventName, event) {
	    this.handler.trigger(eventName, event);
	  },
	
	  /**
	   * Clear all objects and the canvas.
	   */
	  clear: function () {
	    this.storage.delRoot();
	    this.painter.clear();
	  },
	
	  /**
	   * Dispose self.
	   */
	  dispose: function () {
	    this.animation.stop();
	    this.clear();
	    this.storage.dispose();
	    this.painter.dispose();
	    this.handler.dispose();
	    this.animation = this.storage = this.painter = this.handler = null;
	    delInstance(this.id);
	  }
	};
	exports.version = version;
	exports.init = init;
	exports.dispose = dispose;
	exports.getInstance = getInstance;
	exports.registerPainter = registerPainter;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(4);
	
	var vec2 = __webpack_require__(14);
	
	var Draggable = __webpack_require__(42);
	
	var Eventful = __webpack_require__(11);
	
	/**
	 * Handler
	 * @module zrender/Handler
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (shenyi.914@gmail.com)
	 */
	var SILENT = 'silent';
	
	function makeEventPacket(eveType, targetInfo, event) {
	  return {
	    type: eveType,
	    event: event,
	    // target can only be an element that is not silent.
	    target: targetInfo.target,
	    // topTarget can be a silent element.
	    topTarget: targetInfo.topTarget,
	    cancelBubble: false,
	    offsetX: event.zrX,
	    offsetY: event.zrY,
	    gestureEvent: event.gestureEvent,
	    pinchX: event.pinchX,
	    pinchY: event.pinchY,
	    pinchScale: event.pinchScale,
	    wheelDelta: event.zrDelta,
	    zrByTouch: event.zrByTouch,
	    which: event.which
	  };
	}
	
	function EmptyProxy() {}
	
	EmptyProxy.prototype.dispose = function () {};
	
	var handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
	/**
	 * @alias module:zrender/Handler
	 * @constructor
	 * @extends module:zrender/mixin/Eventful
	 * @param {module:zrender/Storage} storage Storage instance.
	 * @param {module:zrender/Painter} painter Painter instance.
	 * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
	 * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
	 */
	
	var Handler = function (storage, painter, proxy, painterRoot) {
	  Eventful.call(this);
	  this.storage = storage;
	  this.painter = painter;
	  this.painterRoot = painterRoot;
	  proxy = proxy || new EmptyProxy();
	  /**
	   * Proxy of event. can be Dom, WebGLSurface, etc.
	   */
	
	  this.proxy = proxy; // Attach handler
	
	  proxy.handler = this;
	  /**
	   * {target, topTarget, x, y}
	   * @private
	   * @type {Object}
	   */
	
	  this._hovered = {};
	  /**
	   * @private
	   * @type {Date}
	   */
	
	  this._lastTouchMoment;
	  /**
	   * @private
	   * @type {number}
	   */
	
	  this._lastX;
	  /**
	   * @private
	   * @type {number}
	   */
	
	  this._lastY;
	  Draggable.call(this);
	  util.each(handlerNames, function (name) {
	    proxy.on && proxy.on(name, this[name], this);
	  }, this);
	};
	
	Handler.prototype = {
	  constructor: Handler,
	  mousemove: function (event) {
	    var x = event.zrX;
	    var y = event.zrY;
	    var lastHovered = this._hovered;
	    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call
	    // (like 'setOption' or 'dispatchAction') in event handlers, we should find
	    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.
	    // See #6198.
	
	    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
	      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
	      lastHoveredTarget = lastHovered.target;
	    }
	
	    var hovered = this._hovered = this.findHover(x, y);
	    var hoveredTarget = hovered.target;
	    var proxy = this.proxy;
	    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element
	
	    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
	      this.dispatchToElement(lastHovered, 'mouseout', event);
	    } // Mouse moving on one element
	
	
	    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element
	
	    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
	      this.dispatchToElement(hovered, 'mouseover', event);
	    }
	  },
	  mouseout: function (event) {
	    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application
	    // at the same level of painter.getViewportRoot() (e.g., tooltip
	    // dom created by echarts), where 'globalout' event should not
	    // be triggered when mouse enters these doms. (But 'mouseout'
	    // should be triggered at the original hovered element as usual).
	
	    var element = event.toElement || event.relatedTarget;
	    var innerDom;
	
	    do {
	      element = element && element.parentNode;
	    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));
	
	    !innerDom && this.trigger('globalout', {
	      event: event
	    });
	  },
	
	  /**
	   * Resize
	   */
	  resize: function (event) {
	    this._hovered = {};
	  },
	
	  /**
	   * Dispatch event
	   * @param {string} eventName
	   * @param {event=} eventArgs
	   */
	  dispatch: function (eventName, eventArgs) {
	    var handler = this[eventName];
	    handler && handler.call(this, eventArgs);
	  },
	
	  /**
	   * Dispose
	   */
	  dispose: function () {
	    this.proxy.dispose();
	    this.storage = this.proxy = this.painter = null;
	  },
	
	  /**
	   * 设置默认的cursor style
	   * @param {string} [cursorStyle='default'] 例如 crosshair
	   */
	  setCursorStyle: function (cursorStyle) {
	    var proxy = this.proxy;
	    proxy.setCursor && proxy.setCursor(cursorStyle);
	  },
	
	  /**
	   * 事件分发代理
	   *
	   * @private
	   * @param {Object} targetInfo {target, topTarget} 目标图形元素
	   * @param {string} eventName 事件名称
	   * @param {Object} event 事件对象
	   */
	  dispatchToElement: function (targetInfo, eventName, event) {
	    targetInfo = targetInfo || {};
	    var el = targetInfo.target;
	
	    if (el && el.silent) {
	      return;
	    }
	
	    var eventHandler = 'on' + eventName;
	    var eventPacket = makeEventPacket(eventName, targetInfo, event);
	
	    while (el) {
	      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
	      el.trigger(eventName, eventPacket);
	      el = el.parent;
	
	      if (eventPacket.cancelBubble) {
	        break;
	      }
	    }
	
	    if (!eventPacket.cancelBubble) {
	      // 冒泡到顶级 zrender 对象
	      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层
	      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
	
	      this.painter && this.painter.eachOtherLayer(function (layer) {
	        if (typeof layer[eventHandler] == 'function') {
	          layer[eventHandler].call(layer, eventPacket);
	        }
	
	        if (layer.trigger) {
	          layer.trigger(eventName, eventPacket);
	        }
	      });
	    }
	  },
	
	  /**
	   * @private
	   * @param {number} x
	   * @param {number} y
	   * @param {module:zrender/graphic/Displayable} exclude
	   * @return {model:zrender/Element}
	   * @method
	   */
	  findHover: function (x, y, exclude) {
	    var list = this.storage.getDisplayList();
	    var out = {
	      x: x,
	      y: y
	    };
	
	    for (var i = list.length - 1; i >= 0; i--) {
	      var hoverCheckResult;
	
	      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode
	      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
	        !out.topTarget && (out.topTarget = list[i]);
	
	        if (hoverCheckResult !== SILENT) {
	          out.target = list[i];
	          break;
	        }
	      }
	    }
	
	    return out;
	  }
	}; // Common handlers
	
	util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
	  Handler.prototype[name] = function (event) {
	    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
	    var hovered = this.findHover(event.zrX, event.zrY);
	    var hoveredTarget = hovered.target;
	
	    if (name === 'mousedown') {
	      this._downEl = hoveredTarget;
	      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup
	
	      this._upEl = hoveredTarget;
	    } else if (name === 'mosueup') {
	      this._upEl = hoveredTarget;
	    } else if (name === 'click') {
	      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,
	      // including the case that `mousedown` - `mousemove` - `mouseup`,
	      // which should be filtered, otherwise it will bring trouble to
	      // pan and zoom.
	      || !this._downPoint // Arbitrary value
	      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
	        return;
	      }
	
	      this._downPoint = null;
	    }
	
	    this.dispatchToElement(hovered, name, event);
	  };
	});
	
	function isHover(displayable, x, y) {
	  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
	    var el = displayable;
	    var isSilent;
	
	    while (el) {
	      // If clipped by ancestor.
	      // FIXME: If clipPath has neither stroke nor fill,
	      // el.clipPath.contain(x, y) will always return false.
	      if (el.clipPath && !el.clipPath.contain(x, y)) {
	        return false;
	      }
	
	      if (el.silent) {
	        isSilent = true;
	      }
	
	      el = el.parent;
	    }
	
	    return isSilent ? SILENT : true;
	  }
	
	  return false;
	}
	
	util.mixin(Handler, Eventful);
	util.mixin(Handler, Draggable);
	var _default = Handler;
	module.exports = _default;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(4);
	
	var env = __webpack_require__(49);
	
	var Group = __webpack_require__(43);
	
	var timsort = __webpack_require__(68);
	
	/**
	 * Storage内容仓库模块
	 * @module zrender/Storage
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 * @author errorrik (errorrik@gmail.com)
	 * @author pissang (https://github.com/pissang/)
	 */
	// Use timsort because in most case elements are partially sorted
	// https://jsfiddle.net/pissang/jr4x7mdm/8/
	function shapeCompareFunc(a, b) {
	  if (a.zlevel === b.zlevel) {
	    if (a.z === b.z) {
	      // if (a.z2 === b.z2) {
	      //     // FIXME Slow has renderidx compare
	      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
	      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
	      //     return a.__renderidx - b.__renderidx;
	      // }
	      return a.z2 - b.z2;
	    }
	
	    return a.z - b.z;
	  }
	
	  return a.zlevel - b.zlevel;
	}
	/**
	 * 内容仓库 (M)
	 * @alias module:zrender/Storage
	 * @constructor
	 */
	
	
	var Storage = function () {
	  // jshint ignore:line
	  this._roots = [];
	  this._displayList = [];
	  this._displayListLen = 0;
	};
	
	Storage.prototype = {
	  constructor: Storage,
	
	  /**
	   * @param  {Function} cb
	   *
	   */
	  traverse: function (cb, context) {
	    for (var i = 0; i < this._roots.length; i++) {
	      this._roots[i].traverse(cb, context);
	    }
	  },
	
	  /**
	   * 返回所有图形的绘制队列
	   * @param {boolean} [update=false] 是否在返回前更新该数组
	   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
	   *
	   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
	   * @return {Array.<module:zrender/graphic/Displayable>}
	   */
	  getDisplayList: function (update, includeIgnore) {
	    includeIgnore = includeIgnore || false;
	
	    if (update) {
	      this.updateDisplayList(includeIgnore);
	    }
	
	    return this._displayList;
	  },
	
	  /**
	   * 更新图形的绘制队列。
	   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
	   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
	   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
	   */
	  updateDisplayList: function (includeIgnore) {
	    this._displayListLen = 0;
	    var roots = this._roots;
	    var displayList = this._displayList;
	
	    for (var i = 0, len = roots.length; i < len; i++) {
	      this._updateAndAddDisplayable(roots[i], null, includeIgnore);
	    }
	
	    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {
	    //     displayList[i].__renderidx = i;
	    // }
	    // displayList.sort(shapeCompareFunc);
	
	    env.canvasSupported && timsort(displayList, shapeCompareFunc);
	  },
	  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
	    if (el.ignore && !includeIgnore) {
	      return;
	    }
	
	    el.beforeUpdate();
	
	    if (el.__dirty) {
	      el.update();
	    }
	
	    el.afterUpdate();
	    var userSetClipPath = el.clipPath;
	
	    if (userSetClipPath) {
	      // FIXME 效率影响
	      if (clipPaths) {
	        clipPaths = clipPaths.slice();
	      } else {
	        clipPaths = [];
	      }
	
	      var currentClipPath = userSetClipPath;
	      var parentClipPath = el; // Recursively add clip path
	
	      while (currentClipPath) {
	        // clipPath 的变换是基于使用这个 clipPath 的元素
	        currentClipPath.parent = parentClipPath;
	        currentClipPath.updateTransform();
	        clipPaths.push(currentClipPath);
	        parentClipPath = currentClipPath;
	        currentClipPath = currentClipPath.clipPath;
	      }
	    }
	
	    if (el.isGroup) {
	      var children = el._children;
	
	      for (var i = 0; i < children.length; i++) {
	        var child = children[i]; // Force to mark as dirty if group is dirty
	        // FIXME __dirtyPath ?
	
	        if (el.__dirty) {
	          child.__dirty = true;
	        }
	
	        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
	      } // Mark group clean here
	
	
	      el.__dirty = false;
	    } else {
	      el.__clipPaths = clipPaths;
	      this._displayList[this._displayListLen++] = el;
	    }
	  },
	
	  /**
	   * 添加图形(Shape)或者组(Group)到根节点
	   * @param {module:zrender/Element} el
	   */
	  addRoot: function (el) {
	    if (el.__storage === this) {
	      return;
	    }
	
	    if (el instanceof Group) {
	      el.addChildrenToStorage(this);
	    }
	
	    this.addToStorage(el);
	
	    this._roots.push(el);
	  },
	
	  /**
	   * 删除指定的图形(Shape)或者组(Group)
	   * @param {string|Array.<string>} [el] 如果为空清空整个Storage
	   */
	  delRoot: function (el) {
	    if (el == null) {
	      // 不指定el清空
	      for (var i = 0; i < this._roots.length; i++) {
	        var root = this._roots[i];
	
	        if (root instanceof Group) {
	          root.delChildrenFromStorage(this);
	        }
	      }
	
	      this._roots = [];
	      this._displayList = [];
	      this._displayListLen = 0;
	      return;
	    }
	
	    if (el instanceof Array) {
	      for (var i = 0, l = el.length; i < l; i++) {
	        this.delRoot(el[i]);
	      }
	
	      return;
	    }
	
	    var idx = util.indexOf(this._roots, el);
	
	    if (idx >= 0) {
	      this.delFromStorage(el);
	
	      this._roots.splice(idx, 1);
	
	      if (el instanceof Group) {
	        el.delChildrenFromStorage(this);
	      }
	    }
	  },
	  addToStorage: function (el) {
	    el.__storage = this;
	    el.dirty(false);
	    return this;
	  },
	  delFromStorage: function (el) {
	    if (el) {
	      el.__storage = null;
	    }
	
	    return this;
	  },
	
	  /**
	   * 清空并且释放Storage
	   */
	  dispose: function () {
	    this._renderList = this._roots = null;
	  },
	  displayableSortFunc: shapeCompareFunc
	};
	var _default = Storage;
	module.exports = _default;

/***/ }),
/* 68 */
/***/ (function(module, exports) {

	// https://github.com/mziccard/node-timsort
	var DEFAULT_MIN_MERGE = 32;
	var DEFAULT_MIN_GALLOPING = 7;
	var DEFAULT_TMP_STORAGE_LENGTH = 256;
	
	function minRunLength(n) {
	  var r = 0;
	
	  while (n >= DEFAULT_MIN_MERGE) {
	    r |= n & 1;
	    n >>= 1;
	  }
	
	  return n + r;
	}
	
	function makeAscendingRun(array, lo, hi, compare) {
	  var runHi = lo + 1;
	
	  if (runHi === hi) {
	    return 1;
	  }
	
	  if (compare(array[runHi++], array[lo]) < 0) {
	    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
	      runHi++;
	    }
	
	    reverseRun(array, lo, runHi);
	  } else {
	    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
	      runHi++;
	    }
	  }
	
	  return runHi - lo;
	}
	
	function reverseRun(array, lo, hi) {
	  hi--;
	
	  while (lo < hi) {
	    var t = array[lo];
	    array[lo++] = array[hi];
	    array[hi--] = t;
	  }
	}
	
	function binaryInsertionSort(array, lo, hi, start, compare) {
	  if (start === lo) {
	    start++;
	  }
	
	  for (; start < hi; start++) {
	    var pivot = array[start];
	    var left = lo;
	    var right = start;
	    var mid;
	
	    while (left < right) {
	      mid = left + right >>> 1;
	
	      if (compare(pivot, array[mid]) < 0) {
	        right = mid;
	      } else {
	        left = mid + 1;
	      }
	    }
	
	    var n = start - left;
	
	    switch (n) {
	      case 3:
	        array[left + 3] = array[left + 2];
	
	      case 2:
	        array[left + 2] = array[left + 1];
	
	      case 1:
	        array[left + 1] = array[left];
	        break;
	
	      default:
	        while (n > 0) {
	          array[left + n] = array[left + n - 1];
	          n--;
	        }
	
	    }
	
	    array[left] = pivot;
	  }
	}
	
	function gallopLeft(value, array, start, length, hint, compare) {
	  var lastOffset = 0;
	  var maxOffset = 0;
	  var offset = 1;
	
	  if (compare(value, array[start + hint]) > 0) {
	    maxOffset = length - hint;
	
	    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    lastOffset += hint;
	    offset += hint;
	  } else {
	    maxOffset = hint + 1;
	
	    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    var tmp = lastOffset;
	    lastOffset = hint - offset;
	    offset = hint - tmp;
	  }
	
	  lastOffset++;
	
	  while (lastOffset < offset) {
	    var m = lastOffset + (offset - lastOffset >>> 1);
	
	    if (compare(value, array[start + m]) > 0) {
	      lastOffset = m + 1;
	    } else {
	      offset = m;
	    }
	  }
	
	  return offset;
	}
	
	function gallopRight(value, array, start, length, hint, compare) {
	  var lastOffset = 0;
	  var maxOffset = 0;
	  var offset = 1;
	
	  if (compare(value, array[start + hint]) < 0) {
	    maxOffset = hint + 1;
	
	    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    var tmp = lastOffset;
	    lastOffset = hint - offset;
	    offset = hint - tmp;
	  } else {
	    maxOffset = length - hint;
	
	    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    lastOffset += hint;
	    offset += hint;
	  }
	
	  lastOffset++;
	
	  while (lastOffset < offset) {
	    var m = lastOffset + (offset - lastOffset >>> 1);
	
	    if (compare(value, array[start + m]) < 0) {
	      offset = m;
	    } else {
	      lastOffset = m + 1;
	    }
	  }
	
	  return offset;
	}
	
	function TimSort(array, compare) {
	  var minGallop = DEFAULT_MIN_GALLOPING;
	  var length = 0;
	  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
	  var stackLength = 0;
	  var runStart;
	  var runLength;
	  var stackSize = 0;
	  length = array.length;
	
	  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
	    tmpStorageLength = length >>> 1;
	  }
	
	  var tmp = [];
	  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
	  runStart = [];
	  runLength = [];
	
	  function pushRun(_runStart, _runLength) {
	    runStart[stackSize] = _runStart;
	    runLength[stackSize] = _runLength;
	    stackSize += 1;
	  }
	
	  function mergeRuns() {
	    while (stackSize > 1) {
	      var n = stackSize - 2;
	
	      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
	        if (runLength[n - 1] < runLength[n + 1]) {
	          n--;
	        }
	      } else if (runLength[n] > runLength[n + 1]) {
	        break;
	      }
	
	      mergeAt(n);
	    }
	  }
	
	  function forceMergeRuns() {
	    while (stackSize > 1) {
	      var n = stackSize - 2;
	
	      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
	        n--;
	      }
	
	      mergeAt(n);
	    }
	  }
	
	  function mergeAt(i) {
	    var start1 = runStart[i];
	    var length1 = runLength[i];
	    var start2 = runStart[i + 1];
	    var length2 = runLength[i + 1];
	    runLength[i] = length1 + length2;
	
	    if (i === stackSize - 3) {
	      runStart[i + 1] = runStart[i + 2];
	      runLength[i + 1] = runLength[i + 2];
	    }
	
	    stackSize--;
	    var k = gallopRight(array[start2], array, start1, length1, 0, compare);
	    start1 += k;
	    length1 -= k;
	
	    if (length1 === 0) {
	      return;
	    }
	
	    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
	
	    if (length2 === 0) {
	      return;
	    }
	
	    if (length1 <= length2) {
	      mergeLow(start1, length1, start2, length2);
	    } else {
	      mergeHigh(start1, length1, start2, length2);
	    }
	  }
	
	  function mergeLow(start1, length1, start2, length2) {
	    var i = 0;
	
	    for (i = 0; i < length1; i++) {
	      tmp[i] = array[start1 + i];
	    }
	
	    var cursor1 = 0;
	    var cursor2 = start2;
	    var dest = start1;
	    array[dest++] = array[cursor2++];
	
	    if (--length2 === 0) {
	      for (i = 0; i < length1; i++) {
	        array[dest + i] = tmp[cursor1 + i];
	      }
	
	      return;
	    }
	
	    if (length1 === 1) {
	      for (i = 0; i < length2; i++) {
	        array[dest + i] = array[cursor2 + i];
	      }
	
	      array[dest + length2] = tmp[cursor1];
	      return;
	    }
	
	    var _minGallop = minGallop;
	    var count1, count2, exit;
	
	    while (1) {
	      count1 = 0;
	      count2 = 0;
	      exit = false;
	
	      do {
	        if (compare(array[cursor2], tmp[cursor1]) < 0) {
	          array[dest++] = array[cursor2++];
	          count2++;
	          count1 = 0;
	
	          if (--length2 === 0) {
	            exit = true;
	            break;
	          }
	        } else {
	          array[dest++] = tmp[cursor1++];
	          count1++;
	          count2 = 0;
	
	          if (--length1 === 1) {
	            exit = true;
	            break;
	          }
	        }
	      } while ((count1 | count2) < _minGallop);
	
	      if (exit) {
	        break;
	      }
	
	      do {
	        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
	
	        if (count1 !== 0) {
	          for (i = 0; i < count1; i++) {
	            array[dest + i] = tmp[cursor1 + i];
	          }
	
	          dest += count1;
	          cursor1 += count1;
	          length1 -= count1;
	
	          if (length1 <= 1) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest++] = array[cursor2++];
	
	        if (--length2 === 0) {
	          exit = true;
	          break;
	        }
	
	        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
	
	        if (count2 !== 0) {
	          for (i = 0; i < count2; i++) {
	            array[dest + i] = array[cursor2 + i];
	          }
	
	          dest += count2;
	          cursor2 += count2;
	          length2 -= count2;
	
	          if (length2 === 0) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest++] = tmp[cursor1++];
	
	        if (--length1 === 1) {
	          exit = true;
	          break;
	        }
	
	        _minGallop--;
	      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	      if (exit) {
	        break;
	      }
	
	      if (_minGallop < 0) {
	        _minGallop = 0;
	      }
	
	      _minGallop += 2;
	    }
	
	    minGallop = _minGallop;
	    minGallop < 1 && (minGallop = 1);
	
	    if (length1 === 1) {
	      for (i = 0; i < length2; i++) {
	        array[dest + i] = array[cursor2 + i];
	      }
	
	      array[dest + length2] = tmp[cursor1];
	    } else if (length1 === 0) {
	      throw new Error(); // throw new Error('mergeLow preconditions were not respected');
	    } else {
	      for (i = 0; i < length1; i++) {
	        array[dest + i] = tmp[cursor1 + i];
	      }
	    }
	  }
	
	  function mergeHigh(start1, length1, start2, length2) {
	    var i = 0;
	
	    for (i = 0; i < length2; i++) {
	      tmp[i] = array[start2 + i];
	    }
	
	    var cursor1 = start1 + length1 - 1;
	    var cursor2 = length2 - 1;
	    var dest = start2 + length2 - 1;
	    var customCursor = 0;
	    var customDest = 0;
	    array[dest--] = array[cursor1--];
	
	    if (--length1 === 0) {
	      customCursor = dest - (length2 - 1);
	
	      for (i = 0; i < length2; i++) {
	        array[customCursor + i] = tmp[i];
	      }
	
	      return;
	    }
	
	    if (length2 === 1) {
	      dest -= length1;
	      cursor1 -= length1;
	      customDest = dest + 1;
	      customCursor = cursor1 + 1;
	
	      for (i = length1 - 1; i >= 0; i--) {
	        array[customDest + i] = array[customCursor + i];
	      }
	
	      array[dest] = tmp[cursor2];
	      return;
	    }
	
	    var _minGallop = minGallop;
	
	    while (true) {
	      var count1 = 0;
	      var count2 = 0;
	      var exit = false;
	
	      do {
	        if (compare(tmp[cursor2], array[cursor1]) < 0) {
	          array[dest--] = array[cursor1--];
	          count1++;
	          count2 = 0;
	
	          if (--length1 === 0) {
	            exit = true;
	            break;
	          }
	        } else {
	          array[dest--] = tmp[cursor2--];
	          count2++;
	          count1 = 0;
	
	          if (--length2 === 1) {
	            exit = true;
	            break;
	          }
	        }
	      } while ((count1 | count2) < _minGallop);
	
	      if (exit) {
	        break;
	      }
	
	      do {
	        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
	
	        if (count1 !== 0) {
	          dest -= count1;
	          cursor1 -= count1;
	          length1 -= count1;
	          customDest = dest + 1;
	          customCursor = cursor1 + 1;
	
	          for (i = count1 - 1; i >= 0; i--) {
	            array[customDest + i] = array[customCursor + i];
	          }
	
	          if (length1 === 0) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest--] = tmp[cursor2--];
	
	        if (--length2 === 1) {
	          exit = true;
	          break;
	        }
	
	        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
	
	        if (count2 !== 0) {
	          dest -= count2;
	          cursor2 -= count2;
	          length2 -= count2;
	          customDest = dest + 1;
	          customCursor = cursor2 + 1;
	
	          for (i = 0; i < count2; i++) {
	            array[customDest + i] = tmp[customCursor + i];
	          }
	
	          if (length2 <= 1) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest--] = array[cursor1--];
	
	        if (--length1 === 0) {
	          exit = true;
	          break;
	        }
	
	        _minGallop--;
	      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	      if (exit) {
	        break;
	      }
	
	      if (_minGallop < 0) {
	        _minGallop = 0;
	      }
	
	      _minGallop += 2;
	    }
	
	    minGallop = _minGallop;
	
	    if (minGallop < 1) {
	      minGallop = 1;
	    }
	
	    if (length2 === 1) {
	      dest -= length1;
	      cursor1 -= length1;
	      customDest = dest + 1;
	      customCursor = cursor1 + 1;
	
	      for (i = length1 - 1; i >= 0; i--) {
	        array[customDest + i] = array[customCursor + i];
	      }
	
	      array[dest] = tmp[cursor2];
	    } else if (length2 === 0) {
	      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');
	    } else {
	      customCursor = dest - (length2 - 1);
	
	      for (i = 0; i < length2; i++) {
	        array[customCursor + i] = tmp[i];
	      }
	    }
	  }
	
	  this.mergeRuns = mergeRuns;
	  this.forceMergeRuns = forceMergeRuns;
	  this.pushRun = pushRun;
	}
	
	function sort(array, compare, lo, hi) {
	  if (!lo) {
	    lo = 0;
	  }
	
	  if (!hi) {
	    hi = array.length;
	  }
	
	  var remaining = hi - lo;
	
	  if (remaining < 2) {
	    return;
	  }
	
	  var runLength = 0;
	
	  if (remaining < DEFAULT_MIN_MERGE) {
	    runLength = makeAscendingRun(array, lo, hi, compare);
	    binaryInsertionSort(array, lo, hi, lo + runLength, compare);
	    return;
	  }
	
	  var ts = new TimSort(array, compare);
	  var minRun = minRunLength(remaining);
	
	  do {
	    runLength = makeAscendingRun(array, lo, hi, compare);
	
	    if (runLength < minRun) {
	      var force = remaining;
	
	      if (force > minRun) {
	        force = minRun;
	      }
	
	      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
	      runLength = force;
	    }
	
	    ts.pushRun(lo, runLength);
	    ts.mergeRuns();
	    remaining -= runLength;
	    lo += runLength;
	  } while (remaining !== 0);
	
	  ts.forceMergeRuns();
	}
	
	module.exports = sort;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	var _config = __webpack_require__(22);
	
	var devicePixelRatio = _config.devicePixelRatio;
	
	var util = __webpack_require__(4);
	
	var log = __webpack_require__(21);
	
	var BoundingRect = __webpack_require__(26);
	
	var timsort = __webpack_require__(68);
	
	var Layer = __webpack_require__(70);
	
	var requestAnimationFrame = __webpack_require__(71);
	
	var Image = __webpack_require__(44);
	
	/**
	 * Default canvas painter
	 * @module zrender/Painter
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	// PENDIGN
	// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
	//
	// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
	var MAX_PROGRESSIVE_LAYER_NUMBER = 5;
	
	function parseInt10(val) {
	  return parseInt(val, 10);
	}
	
	function isLayerValid(layer) {
	  if (!layer) {
	    return false;
	  }
	
	  if (layer.__builtin__) {
	    return true;
	  }
	
	  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {
	    return false;
	  }
	
	  return true;
	}
	
	function preProcessLayer(layer) {
	  layer.__unusedCount++;
	}
	
	function postProcessLayer(layer) {
	  if (layer.__unusedCount == 1) {
	    layer.clear();
	  }
	}
	
	var tmpRect = new BoundingRect(0, 0, 0, 0);
	var viewRect = new BoundingRect(0, 0, 0, 0);
	
	function isDisplayableCulled(el, width, height) {
	  tmpRect.copy(el.getBoundingRect());
	
	  if (el.transform) {
	    tmpRect.applyTransform(el.transform);
	  }
	
	  viewRect.width = width;
	  viewRect.height = height;
	  return !tmpRect.intersect(viewRect);
	}
	
	function isClipPathChanged(clipPaths, prevClipPaths) {
	  if (clipPaths == prevClipPaths) {
	    // Can both be null or undefined
	    return false;
	  }
	
	  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
	    return true;
	  }
	
	  for (var i = 0; i < clipPaths.length; i++) {
	    if (clipPaths[i] !== prevClipPaths[i]) {
	      return true;
	    }
	  }
	}
	
	function doClip(clipPaths, ctx) {
	  for (var i = 0; i < clipPaths.length; i++) {
	    var clipPath = clipPaths[i];
	    clipPath.setTransform(ctx);
	    ctx.beginPath();
	    clipPath.buildPath(ctx, clipPath.shape);
	    ctx.clip(); // Transform back
	
	    clipPath.restoreTransform(ctx);
	  }
	}
	
	function createRoot(width, height) {
	  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
	
	  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';
	  return domRoot;
	}
	/**
	 * @alias module:zrender/Painter
	 * @constructor
	 * @param {HTMLElement} root 绘图容器
	 * @param {module:zrender/Storage} storage
	 * @param {Object} opts
	 */
	
	
	var Painter = function (root, storage, opts) {
	  this.type = 'canvas'; // In node environment using node-canvas
	
	  var singleCanvas = !root.nodeName // In node ?
	  || root.nodeName.toUpperCase() === 'CANVAS';
	  this._opts = opts = util.extend({}, opts || {});
	  /**
	   * @type {number}
	   */
	
	  this.dpr = opts.devicePixelRatio || devicePixelRatio;
	  /**
	   * @type {boolean}
	   * @private
	   */
	
	  this._singleCanvas = singleCanvas;
	  /**
	   * 绘图容器
	   * @type {HTMLElement}
	   */
	
	  this.root = root;
	  var rootStyle = root.style;
	
	  if (rootStyle) {
	    rootStyle['-webkit-tap-highlight-color'] = 'transparent';
	    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';
	    root.innerHTML = '';
	  }
	  /**
	   * @type {module:zrender/Storage}
	   */
	
	
	  this.storage = storage;
	  /**
	   * @type {Array.<number>}
	   * @private
	   */
	
	  var zlevelList = this._zlevelList = [];
	  /**
	   * @type {Object.<string, module:zrender/Layer>}
	   * @private
	   */
	
	  var layers = this._layers = {};
	  /**
	   * @type {Object.<string, Object>}
	   * @type {private}
	   */
	
	  this._layerConfig = {};
	
	  if (!singleCanvas) {
	    this._width = this._getSize(0);
	    this._height = this._getSize(1);
	    var domRoot = this._domRoot = createRoot(this._width, this._height);
	    root.appendChild(domRoot);
	  } else {
	    if (opts.width != null) {
	      root.width = opts.width;
	    }
	
	    if (opts.height != null) {
	      root.height = opts.height;
	    } // Use canvas width and height directly
	
	
	    var width = root.width;
	    var height = root.height;
	    this._width = width;
	    this._height = height; // Create layer if only one given canvas
	    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height
	
	    var mainLayer = new Layer(root, this, 1);
	    mainLayer.initContext(); // FIXME Use canvas width and height
	    // mainLayer.resize(width, height);
	
	    layers[0] = mainLayer;
	    zlevelList.push(0);
	    this._domRoot = root;
	  } // Layers for progressive rendering
	
	
	  this._progressiveLayers = [];
	  /**
	   * @type {module:zrender/Layer}
	   * @private
	   */
	
	  this._hoverlayer;
	  this._hoverElements = [];
	};
	
	Painter.prototype = {
	  constructor: Painter,
	  getType: function () {
	    return 'canvas';
	  },
	
	  /**
	   * If painter use a single canvas
	   * @return {boolean}
	   */
	  isSingleCanvas: function () {
	    return this._singleCanvas;
	  },
	
	  /**
	   * @return {HTMLDivElement}
	   */
	  getViewportRoot: function () {
	    return this._domRoot;
	  },
	  getViewportRootOffset: function () {
	    var viewportRoot = this.getViewportRoot();
	
	    if (viewportRoot) {
	      return {
	        offsetLeft: viewportRoot.offsetLeft || 0,
	        offsetTop: viewportRoot.offsetTop || 0
	      };
	    }
	  },
	
	  /**
	   * 刷新
	   * @param {boolean} [paintAll=false] 强制绘制所有displayable
	   */
	  refresh: function (paintAll) {
	    var list = this.storage.getDisplayList(true);
	    var zlevelList = this._zlevelList;
	
	    this._paintList(list, paintAll); // Paint custum layers
	
	
	    for (var i = 0; i < zlevelList.length; i++) {
	      var z = zlevelList[i];
	      var layer = this._layers[z];
	
	      if (!layer.__builtin__ && layer.refresh) {
	        layer.refresh();
	      }
	    }
	
	    this.refreshHover();
	
	    if (this._progressiveLayers.length) {
	      this._startProgessive();
	    }
	
	    return this;
	  },
	  addHover: function (el, hoverStyle) {
	    if (el.__hoverMir) {
	      return;
	    }
	
	    var elMirror = new el.constructor({
	      style: el.style,
	      shape: el.shape
	    });
	    elMirror.__from = el;
	    el.__hoverMir = elMirror;
	    elMirror.setStyle(hoverStyle);
	
	    this._hoverElements.push(elMirror);
	  },
	  removeHover: function (el) {
	    var elMirror = el.__hoverMir;
	    var hoverElements = this._hoverElements;
	    var idx = util.indexOf(hoverElements, elMirror);
	
	    if (idx >= 0) {
	      hoverElements.splice(idx, 1);
	    }
	
	    el.__hoverMir = null;
	  },
	  clearHover: function (el) {
	    var hoverElements = this._hoverElements;
	
	    for (var i = 0; i < hoverElements.length; i++) {
	      var from = hoverElements[i].__from;
	
	      if (from) {
	        from.__hoverMir = null;
	      }
	    }
	
	    hoverElements.length = 0;
	  },
	  refreshHover: function () {
	    var hoverElements = this._hoverElements;
	    var len = hoverElements.length;
	    var hoverLayer = this._hoverlayer;
	    hoverLayer && hoverLayer.clear();
	
	    if (!len) {
	      return;
	    }
	
	    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel
	    // FIXME?
	
	    if (!hoverLayer) {
	      hoverLayer = this._hoverlayer = this.getLayer(1e5);
	    }
	
	    var scope = {};
	    hoverLayer.ctx.save();
	
	    for (var i = 0; i < len;) {
	      var el = hoverElements[i];
	      var originalEl = el.__from; // Original el is removed
	      // PENDING
	
	      if (!(originalEl && originalEl.__zr)) {
	        hoverElements.splice(i, 1);
	        originalEl.__hoverMir = null;
	        len--;
	        continue;
	      }
	
	      i++; // Use transform
	      // FIXME style and shape ?
	
	      if (!originalEl.invisible) {
	        el.transform = originalEl.transform;
	        el.invTransform = originalEl.invTransform;
	        el.__clipPaths = originalEl.__clipPaths; // el.
	
	        this._doPaintEl(el, hoverLayer, true, scope);
	      }
	    }
	
	    hoverLayer.ctx.restore();
	  },
	  _startProgessive: function () {
	    var self = this;
	
	    if (!self._furtherProgressive) {
	      return;
	    } // Use a token to stop progress steps triggered by
	    // previous zr.refresh calling.
	
	
	    var token = self._progressiveToken = +new Date();
	    self._progress++;
	    requestAnimationFrame(step);
	
	    function step() {
	      // In case refreshed or disposed
	      if (token === self._progressiveToken && self.storage) {
	        self._doPaintList(self.storage.getDisplayList());
	
	        if (self._furtherProgressive) {
	          self._progress++;
	          requestAnimationFrame(step);
	        } else {
	          self._progressiveToken = -1;
	        }
	      }
	    }
	  },
	  _clearProgressive: function () {
	    this._progressiveToken = -1;
	    this._progress = 0;
	    util.each(this._progressiveLayers, function (layer) {
	      layer.__dirty && layer.clear();
	    });
	  },
	  _paintList: function (list, paintAll) {
	    if (paintAll == null) {
	      paintAll = false;
	    }
	
	    this._updateLayerStatus(list);
	
	    this._clearProgressive();
	
	    this.eachBuiltinLayer(preProcessLayer);
	
	    this._doPaintList(list, paintAll);
	
	    this.eachBuiltinLayer(postProcessLayer);
	  },
	  _doPaintList: function (list, paintAll) {
	    var currentLayer;
	    var currentZLevel;
	    var ctx; // var invTransform = [];
	
	    var scope;
	    var progressiveLayerIdx = 0;
	    var currentProgressiveLayer;
	    var width = this._width;
	    var height = this._height;
	    var layerProgress;
	    var frame = this._progress;
	
	    function flushProgressiveLayer(layer) {
	      var dpr = ctx.dpr || 1;
	      ctx.save();
	      ctx.globalAlpha = 1;
	      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame
	
	      currentLayer.__dirty = true;
	      ctx.setTransform(1, 0, 0, 1, 0, 0);
	      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
	      ctx.restore();
	    }
	
	    for (var i = 0, l = list.length; i < l; i++) {
	      var el = list[i];
	      var elZLevel = this._singleCanvas ? 0 : el.zlevel;
	      var elFrame = el.__frame; // Flush at current context
	      // PENDING
	
	      if (elFrame < 0 && currentProgressiveLayer) {
	        flushProgressiveLayer(currentProgressiveLayer);
	        currentProgressiveLayer = null;
	      } // Change draw layer
	
	
	      if (currentZLevel !== elZLevel) {
	        if (ctx) {
	          ctx.restore();
	        } // Reset scope
	
	
	        scope = {}; // Only 0 zlevel if only has one canvas
	
	        currentZLevel = elZLevel;
	        currentLayer = this.getLayer(currentZLevel);
	
	        if (!currentLayer.__builtin__) {
	          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);
	        }
	
	        ctx = currentLayer.ctx;
	        ctx.save(); // Reset the count
	
	        currentLayer.__unusedCount = 0;
	
	        if (currentLayer.__dirty || paintAll) {
	          currentLayer.clear();
	        }
	      }
	
	      if (!(currentLayer.__dirty || paintAll)) {
	        continue;
	      }
	
	      if (elFrame >= 0) {
	        // Progressive layer changed
	        if (!currentProgressiveLayer) {
	          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];
	          currentProgressiveLayer.ctx.save();
	          currentProgressiveLayer.renderScope = {};
	
	          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {
	            // flushProgressiveLayer(currentProgressiveLayer);
	            // Quick jump all progressive elements
	            // All progressive element are not dirty, jump over and flush directly
	            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;
	
	            continue;
	          }
	
	          layerProgress = currentProgressiveLayer.__progress;
	
	          if (!currentProgressiveLayer.__dirty) {
	            // Keep rendering
	            frame = layerProgress;
	          }
	
	          currentProgressiveLayer.__progress = frame + 1;
	        }
	
	        if (elFrame === frame) {
	          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
	        }
	      } else {
	        this._doPaintEl(el, currentLayer, paintAll, scope);
	      }
	
	      el.__dirty = false;
	    }
	
	    if (currentProgressiveLayer) {
	      flushProgressiveLayer(currentProgressiveLayer);
	    } // Restore the lastLayer ctx
	
	
	    ctx && ctx.restore(); // If still has clipping state
	    // if (scope.prevElClipPaths) {
	    //     ctx.restore();
	    // }
	
	    this._furtherProgressive = false;
	    util.each(this._progressiveLayers, function (layer) {
	      if (layer.__maxProgress >= layer.__progress) {
	        this._furtherProgressive = true;
	      }
	    }, this);
	  },
	  _doPaintEl: function (el, currentLayer, forcePaint, scope) {
	    var ctx = currentLayer.ctx;
	    var m = el.transform;
	
	    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element
	    !el.invisible // Ignore transparent element
	    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas
	    // Draw a scale 0 element can cause all following draw wrong
	    // And setTransform with scale 0 will cause set back transform failed.
	    && !(m && !m[0] && !m[3]) // Ignore culled element
	    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
	      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements
	
	      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {
	        // If has previous clipping state, restore from it
	        if (scope.prevElClipPaths) {
	          scope.prevClipLayer.ctx.restore();
	          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored
	
	          scope.prevEl = null;
	        } // New clipping state
	
	
	        if (clipPaths) {
	          ctx.save();
	          doClip(clipPaths, ctx);
	          scope.prevClipLayer = currentLayer;
	          scope.prevElClipPaths = clipPaths;
	        }
	      }
	
	      el.beforeBrush && el.beforeBrush(ctx);
	      el.brush(ctx, scope.prevEl || null);
	      scope.prevEl = el;
	      el.afterBrush && el.afterBrush(ctx);
	    }
	  },
	
	  /**
	   * 获取 zlevel 所在层，如果不存在则会创建一个新的层
	   * @param {number} zlevel
	   * @return {module:zrender/Layer}
	   */
	  getLayer: function (zlevel) {
	    if (this._singleCanvas) {
	      return this._layers[0];
	    }
	
	    var layer = this._layers[zlevel];
	
	    if (!layer) {
	      // Create a new layer
	      layer = new Layer('zr_' + zlevel, this, this.dpr);
	      layer.__builtin__ = true;
	
	      if (this._layerConfig[zlevel]) {
	        util.merge(layer, this._layerConfig[zlevel], true);
	      }
	
	      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document
	      // Or excanvas will get 0px clientWidth and clientHeight
	
	      layer.initContext();
	    }
	
	    return layer;
	  },
	  insertLayer: function (zlevel, layer) {
	    var layersMap = this._layers;
	    var zlevelList = this._zlevelList;
	    var len = zlevelList.length;
	    var prevLayer = null;
	    var i = -1;
	    var domRoot = this._domRoot;
	
	    if (layersMap[zlevel]) {
	      log('ZLevel ' + zlevel + ' has been used already');
	      return;
	    } // Check if is a valid layer
	
	
	    if (!isLayerValid(layer)) {
	      log('Layer of zlevel ' + zlevel + ' is not valid');
	      return;
	    }
	
	    if (len > 0 && zlevel > zlevelList[0]) {
	      for (i = 0; i < len - 1; i++) {
	        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
	          break;
	        }
	      }
	
	      prevLayer = layersMap[zlevelList[i]];
	    }
	
	    zlevelList.splice(i + 1, 0, zlevel);
	    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.
	    // (It can be a WebGL layer and assigned to a ZImage element)
	    // But it still under management of zrender.
	
	    if (!layer.virtual) {
	      if (prevLayer) {
	        var prevDom = prevLayer.dom;
	
	        if (prevDom.nextSibling) {
	          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
	        } else {
	          domRoot.appendChild(layer.dom);
	        }
	      } else {
	        if (domRoot.firstChild) {
	          domRoot.insertBefore(layer.dom, domRoot.firstChild);
	        } else {
	          domRoot.appendChild(layer.dom);
	        }
	      }
	    }
	  },
	  // Iterate each layer
	  eachLayer: function (cb, context) {
	    var zlevelList = this._zlevelList;
	    var z;
	    var i;
	
	    for (i = 0; i < zlevelList.length; i++) {
	      z = zlevelList[i];
	      cb.call(context, this._layers[z], z);
	    }
	  },
	  // Iterate each buildin layer
	  eachBuiltinLayer: function (cb, context) {
	    var zlevelList = this._zlevelList;
	    var layer;
	    var z;
	    var i;
	
	    for (i = 0; i < zlevelList.length; i++) {
	      z = zlevelList[i];
	      layer = this._layers[z];
	
	      if (layer.__builtin__) {
	        cb.call(context, layer, z);
	      }
	    }
	  },
	  // Iterate each other layer except buildin layer
	  eachOtherLayer: function (cb, context) {
	    var zlevelList = this._zlevelList;
	    var layer;
	    var z;
	    var i;
	
	    for (i = 0; i < zlevelList.length; i++) {
	      z = zlevelList[i];
	      layer = this._layers[z];
	
	      if (!layer.__builtin__) {
	        cb.call(context, layer, z);
	      }
	    }
	  },
	
	  /**
	   * 获取所有已创建的层
	   * @param {Array.<module:zrender/Layer>} [prevLayer]
	   */
	  getLayers: function () {
	    return this._layers;
	  },
	  _updateLayerStatus: function (list) {
	    var layers = this._layers;
	    var progressiveLayers = this._progressiveLayers;
	    var elCountsLastFrame = {};
	    var progressiveElCountsLastFrame = {};
	    this.eachBuiltinLayer(function (layer, z) {
	      elCountsLastFrame[z] = layer.elCount;
	      layer.elCount = 0;
	      layer.__dirty = false;
	    });
	    util.each(progressiveLayers, function (layer, idx) {
	      progressiveElCountsLastFrame[idx] = layer.elCount;
	      layer.elCount = 0;
	      layer.__dirty = false;
	    });
	    var progressiveLayerCount = 0;
	    var currentProgressiveLayer;
	    var lastProgressiveKey;
	    var frameCount = 0;
	
	    for (var i = 0, l = list.length; i < l; i++) {
	      var el = list[i];
	      var zlevel = this._singleCanvas ? 0 : el.zlevel;
	      var layer = layers[zlevel];
	      var elProgress = el.progressive;
	
	      if (layer) {
	        layer.elCount++;
	        layer.__dirty = layer.__dirty || el.__dirty;
	      } /////// Update progressive
	
	
	      if (elProgress >= 0) {
	        // Fix wrong progressive sequence problem.
	        if (lastProgressiveKey !== elProgress) {
	          lastProgressiveKey = elProgress;
	          frameCount++;
	        }
	
	        var elFrame = el.__frame = frameCount - 1;
	
	        if (!currentProgressiveLayer) {
	          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
	          currentProgressiveLayer = progressiveLayers[idx];
	
	          if (!currentProgressiveLayer) {
	            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);
	            currentProgressiveLayer.initContext();
	          }
	
	          currentProgressiveLayer.__maxProgress = 0;
	        }
	
	        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
	        currentProgressiveLayer.elCount++;
	        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);
	
	        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
	          // Should keep rendering this  layer because progressive rendering is not finished yet
	          layer.__dirty = true;
	        }
	      } else {
	        el.__frame = -1;
	
	        if (currentProgressiveLayer) {
	          currentProgressiveLayer.__nextIdxNotProg = i;
	          progressiveLayerCount++;
	          currentProgressiveLayer = null;
	        }
	      }
	    }
	
	    if (currentProgressiveLayer) {
	      progressiveLayerCount++;
	      currentProgressiveLayer.__nextIdxNotProg = i;
	    } // 层中的元素数量有发生变化
	
	
	    this.eachBuiltinLayer(function (layer, z) {
	      if (elCountsLastFrame[z] !== layer.elCount) {
	        layer.__dirty = true;
	      }
	    });
	    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
	    util.each(progressiveLayers, function (layer, idx) {
	      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
	        el.__dirty = true;
	      }
	
	      if (layer.__dirty) {
	        layer.__progress = 0;
	      }
	    });
	  },
	
	  /**
	   * 清除hover层外所有内容
	   */
	  clear: function () {
	    this.eachBuiltinLayer(this._clearLayer);
	    return this;
	  },
	  _clearLayer: function (layer) {
	    layer.clear();
	  },
	
	  /**
	   * 修改指定zlevel的绘制参数
	   *
	   * @param {string} zlevel
	   * @param {Object} config 配置对象
	   * @param {string} [config.clearColor=0] 每次清空画布的颜色
	   * @param {string} [config.motionBlur=false] 是否开启动态模糊
	   * @param {number} [config.lastFrameAlpha=0.7]
	   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	   */
	  configLayer: function (zlevel, config) {
	    if (config) {
	      var layerConfig = this._layerConfig;
	
	      if (!layerConfig[zlevel]) {
	        layerConfig[zlevel] = config;
	      } else {
	        util.merge(layerConfig[zlevel], config, true);
	      }
	
	      var layer = this._layers[zlevel];
	
	      if (layer) {
	        util.merge(layer, layerConfig[zlevel], true);
	      }
	    }
	  },
	
	  /**
	   * 删除指定层
	   * @param {number} zlevel 层所在的zlevel
	   */
	  delLayer: function (zlevel) {
	    var layers = this._layers;
	    var zlevelList = this._zlevelList;
	    var layer = layers[zlevel];
	
	    if (!layer) {
	      return;
	    }
	
	    layer.dom.parentNode.removeChild(layer.dom);
	    delete layers[zlevel];
	    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
	  },
	
	  /**
	   * 区域大小变化后重绘
	   */
	  resize: function (width, height) {
	    var domRoot = this._domRoot; // FIXME Why ?
	
	    domRoot.style.display = 'none'; // Save input w/h
	
	    var opts = this._opts;
	    width != null && (opts.width = width);
	    height != null && (opts.height = height);
	    width = this._getSize(0);
	    height = this._getSize(1);
	    domRoot.style.display = ''; // 优化没有实际改变的resize
	
	    if (this._width != width || height != this._height) {
	      domRoot.style.width = width + 'px';
	      domRoot.style.height = height + 'px';
	
	      for (var id in this._layers) {
	        if (this._layers.hasOwnProperty(id)) {
	          this._layers[id].resize(width, height);
	        }
	      }
	
	      util.each(this._progressiveLayers, function (layer) {
	        layer.resize(width, height);
	      });
	      this.refresh(true);
	    }
	
	    this._width = width;
	    this._height = height;
	    return this;
	  },
	
	  /**
	   * 清除单独的一个层
	   * @param {number} zlevel
	   */
	  clearLayer: function (zlevel) {
	    var layer = this._layers[zlevel];
	
	    if (layer) {
	      layer.clear();
	    }
	  },
	
	  /**
	   * 释放
	   */
	  dispose: function () {
	    this.root.innerHTML = '';
	    this.root = this.storage = this._domRoot = this._layers = null;
	  },
	
	  /**
	   * Get canvas which has all thing rendered
	   * @param {Object} opts
	   * @param {string} [opts.backgroundColor]
	   * @param {number} [opts.pixelRatio]
	   */
	  getRenderedCanvas: function (opts) {
	    opts = opts || {};
	
	    if (this._singleCanvas) {
	      return this._layers[0].dom;
	    }
	
	    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
	    imageLayer.initContext();
	    imageLayer.clearColor = opts.backgroundColor;
	    imageLayer.clear();
	    var displayList = this.storage.getDisplayList(true);
	    var scope = {};
	    var zlevel;
	    var self = this;
	
	    function findAndDrawOtherLayer(smaller, larger) {
	      var zlevelList = self._zlevelList;
	
	      if (smaller == null) {
	        smaller = -Infinity;
	      }
	
	      var intermediateLayer;
	
	      for (var i = 0; i < zlevelList.length; i++) {
	        var z = zlevelList[i];
	        var layer = self._layers[z];
	
	        if (!layer.__builtin__ && z > smaller && z < larger) {
	          intermediateLayer = layer;
	          break;
	        }
	      }
	
	      if (intermediateLayer && intermediateLayer.renderToCanvas) {
	        imageLayer.ctx.save();
	        intermediateLayer.renderToCanvas(imageLayer.ctx);
	        imageLayer.ctx.restore();
	      }
	    }
	
	    for (var i = 0; i < displayList.length; i++) {
	      var el = displayList[i];
	
	      if (el.zlevel !== zlevel) {
	        findAndDrawOtherLayer(zlevel, el.zlevel);
	        zlevel = el.zlevel;
	      }
	
	      this._doPaintEl(el, imageLayer, true, scope);
	    }
	
	    findAndDrawOtherLayer(zlevel, Infinity);
	    return imageLayer.dom;
	  },
	
	  /**
	   * 获取绘图区域宽度
	   */
	  getWidth: function () {
	    return this._width;
	  },
	
	  /**
	   * 获取绘图区域高度
	   */
	  getHeight: function () {
	    return this._height;
	  },
	  _getSize: function (whIdx) {
	    var opts = this._opts;
	    var wh = ['width', 'height'][whIdx];
	    var cwh = ['clientWidth', 'clientHeight'][whIdx];
	    var plt = ['paddingLeft', 'paddingTop'][whIdx];
	    var prb = ['paddingRight', 'paddingBottom'][whIdx];
	
	    if (opts[wh] != null && opts[wh] !== 'auto') {
	      return parseFloat(opts[wh]);
	    }
	
	    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.
	
	    var stl = document.defaultView.getComputedStyle(root);
	    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
	  },
	  pathToImage: function (path, dpr) {
	    dpr = dpr || this.dpr;
	    var canvas = document.createElement('canvas');
	    var ctx = canvas.getContext('2d');
	    var rect = path.getBoundingRect();
	    var style = path.style;
	    var shadowBlurSize = style.shadowBlur;
	    var shadowOffsetX = style.shadowOffsetX;
	    var shadowOffsetY = style.shadowOffsetY;
	    var lineWidth = style.hasStroke() ? style.lineWidth : 0;
	    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
	    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
	    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
	    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
	    var width = rect.width + leftMargin + rightMargin;
	    var height = rect.height + topMargin + bottomMargin;
	    canvas.width = width * dpr;
	    canvas.height = height * dpr;
	    ctx.scale(dpr, dpr);
	    ctx.clearRect(0, 0, width, height);
	    ctx.dpr = dpr;
	    var pathTransform = {
	      position: path.position,
	      rotation: path.rotation,
	      scale: path.scale
	    };
	    path.position = [leftMargin - rect.x, topMargin - rect.y];
	    path.rotation = 0;
	    path.scale = [1, 1];
	    path.updateTransform();
	
	    if (path) {
	      path.brush(ctx);
	    }
	
	    var ImageShape = Image;
	    var imgShape = new ImageShape({
	      style: {
	        x: 0,
	        y: 0,
	        image: canvas
	      }
	    });
	
	    if (pathTransform.position != null) {
	      imgShape.position = path.position = pathTransform.position;
	    }
	
	    if (pathTransform.rotation != null) {
	      imgShape.rotation = path.rotation = pathTransform.rotation;
	    }
	
	    if (pathTransform.scale != null) {
	      imgShape.scale = path.scale = pathTransform.scale;
	    }
	
	    return imgShape;
	  }
	};
	var _default = Painter;
	module.exports = _default;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(4);
	
	var _config = __webpack_require__(22);
	
	var devicePixelRatio = _config.devicePixelRatio;
	
	var Style = __webpack_require__(8);
	
	var Pattern = __webpack_require__(39);
	
	/**
	 * @module zrender/Layer
	 * @author pissang(https://www.github.com/pissang)
	 */
	function returnFalse() {
	  return false;
	}
	/**
	 * 创建dom
	 *
	 * @inner
	 * @param {string} id dom id 待用
	 * @param {Painter} painter painter instance
	 * @param {number} number
	 */
	
	
	function createDom(id, painter, dpr) {
	  var newDom = util.createCanvas();
	  var width = painter.getWidth();
	  var height = painter.getHeight();
	  var newDomStyle = newDom.style; // 没append呢，请原谅我这样写，清晰~
	
	  newDomStyle.position = 'absolute';
	  newDomStyle.left = 0;
	  newDomStyle.top = 0;
	  newDomStyle.width = width + 'px';
	  newDomStyle.height = height + 'px';
	  newDom.width = width * dpr;
	  newDom.height = height * dpr; // id不作为索引用，避免可能造成的重名，定义为私有属性
	
	  newDom.setAttribute('data-zr-dom-id', id);
	  return newDom;
	}
	/**
	 * @alias module:zrender/Layer
	 * @constructor
	 * @extends module:zrender/mixin/Transformable
	 * @param {string} id
	 * @param {module:zrender/Painter} painter
	 * @param {number} [dpr]
	 */
	
	
	var Layer = function (id, painter, dpr) {
	  var dom;
	  dpr = dpr || devicePixelRatio;
	
	  if (typeof id === 'string') {
	    dom = createDom(id, painter, dpr);
	  } // Not using isDom because in node it will return false
	  else if (util.isObject(id)) {
	      dom = id;
	      id = dom.id;
	    }
	
	  this.id = id;
	  this.dom = dom;
	  var domStyle = dom.style;
	
	  if (domStyle) {
	    // Not in node
	    dom.onselectstart = returnFalse; // 避免页面选中的尴尬
	
	    domStyle['-webkit-user-select'] = 'none';
	    domStyle['user-select'] = 'none';
	    domStyle['-webkit-touch-callout'] = 'none';
	    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	    domStyle['padding'] = 0;
	    domStyle['margin'] = 0;
	    domStyle['border-width'] = 0;
	  }
	
	  this.domBack = null;
	  this.ctxBack = null;
	  this.painter = painter;
	  this.config = null; // Configs
	
	  /**
	   * 每次清空画布的颜色
	   * @type {string}
	   * @default 0
	   */
	
	  this.clearColor = 0;
	  /**
	   * 是否开启动态模糊
	   * @type {boolean}
	   * @default false
	   */
	
	  this.motionBlur = false;
	  /**
	   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	   * @type {number}
	   * @default 0.7
	   */
	
	  this.lastFrameAlpha = 0.7;
	  /**
	   * Layer dpr
	   * @type {number}
	   */
	
	  this.dpr = dpr;
	};
	
	Layer.prototype = {
	  constructor: Layer,
	  elCount: 0,
	  __dirty: true,
	  initContext: function () {
	    this.ctx = this.dom.getContext('2d');
	    this.ctx.__currentValues = {};
	    this.ctx.dpr = this.dpr;
	  },
	  createBackBuffer: function () {
	    var dpr = this.dpr;
	    this.domBack = createDom('back-' + this.id, this.painter, dpr);
	    this.ctxBack = this.domBack.getContext('2d');
	    this.ctxBack.__currentValues = {};
	
	    if (dpr != 1) {
	      this.ctxBack.scale(dpr, dpr);
	    }
	  },
	
	  /**
	   * @param  {number} width
	   * @param  {number} height
	   */
	  resize: function (width, height) {
	    var dpr = this.dpr;
	    var dom = this.dom;
	    var domStyle = dom.style;
	    var domBack = this.domBack;
	    domStyle.width = width + 'px';
	    domStyle.height = height + 'px';
	    dom.width = width * dpr;
	    dom.height = height * dpr;
	
	    if (domBack) {
	      domBack.width = width * dpr;
	      domBack.height = height * dpr;
	
	      if (dpr != 1) {
	        this.ctxBack.scale(dpr, dpr);
	      }
	    }
	  },
	
	  /**
	   * 清空该层画布
	   * @param {boolean} clearAll Clear all with out motion blur
	   */
	  clear: function (clearAll) {
	    var dom = this.dom;
	    var ctx = this.ctx;
	    var width = dom.width;
	    var height = dom.height;
	    var clearColor = this.clearColor;
	    var haveMotionBLur = this.motionBlur && !clearAll;
	    var lastFrameAlpha = this.lastFrameAlpha;
	    var dpr = this.dpr;
	
	    if (haveMotionBLur) {
	      if (!this.domBack) {
	        this.createBackBuffer();
	      }
	
	      this.ctxBack.globalCompositeOperation = 'copy';
	      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
	    }
	
	    ctx.clearRect(0, 0, width, height);
	
	    if (clearColor) {
	      var clearColorGradientOrPattern; // Gradient
	
	      if (clearColor.colorStops) {
	        // Cache canvas gradient
	        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
	          x: 0,
	          y: 0,
	          width: width,
	          height: height
	        });
	        clearColor.__canvasGradient = clearColorGradientOrPattern;
	      } // Pattern
	      else if (clearColor.image) {
	          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
	        }
	
	      ctx.save();
	      ctx.fillStyle = clearColorGradientOrPattern || clearColor;
	      ctx.fillRect(0, 0, width, height);
	      ctx.restore();
	    }
	
	    if (haveMotionBLur) {
	      var domBack = this.domBack;
	      ctx.save();
	      ctx.globalAlpha = lastFrameAlpha;
	      ctx.drawImage(domBack, 0, 0, width, height);
	      ctx.restore();
	    }
	  }
	};
	var _default = Layer;
	module.exports = _default;

/***/ }),
/* 71 */
/***/ (function(module, exports) {

	var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
	window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {
	  setTimeout(func, 16);
	};
	
	module.exports = _default;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(4);
	
	var _event = __webpack_require__(73);
	
	var Dispatcher = _event.Dispatcher;
	
	var requestAnimationFrame = __webpack_require__(71);
	
	var Animator = __webpack_require__(16);
	
	/**
	 * 动画主类, 调度和管理所有动画控制器
	 *
	 * @module zrender/animation/Animation
	 * @author pissang(https://github.com/pissang)
	 */
	// TODO Additive animation
	// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
	// https://developer.apple.com/videos/wwdc2014/#236
	
	/**
	 * @typedef {Object} IZRenderStage
	 * @property {Function} update
	 */
	
	/**
	 * @alias module:zrender/animation/Animation
	 * @constructor
	 * @param {Object} [options]
	 * @param {Function} [options.onframe]
	 * @param {IZRenderStage} [options.stage]
	 * @example
	 *     var animation = new Animation();
	 *     var obj = {
	 *         x: 100,
	 *         y: 100
	 *     };
	 *     animation.animate(node.position)
	 *         .when(1000, {
	 *             x: 500,
	 *             y: 500
	 *         })
	 *         .when(2000, {
	 *             x: 100,
	 *             y: 100
	 *         })
	 *         .start('spline');
	 */
	var Animation = function (options) {
	  options = options || {};
	  this.stage = options.stage || {};
	
	  this.onframe = options.onframe || function () {}; // private properties
	
	
	  this._clips = [];
	  this._running = false;
	  this._time;
	  this._pausedTime;
	  this._pauseStart;
	  this._paused = false;
	  Dispatcher.call(this);
	};
	
	Animation.prototype = {
	  constructor: Animation,
	
	  /**
	   * 添加 clip
	   * @param {module:zrender/animation/Clip} clip
	   */
	  addClip: function (clip) {
	    this._clips.push(clip);
	  },
	
	  /**
	   * 添加 animator
	   * @param {module:zrender/animation/Animator} animator
	   */
	  addAnimator: function (animator) {
	    animator.animation = this;
	    var clips = animator.getClips();
	
	    for (var i = 0; i < clips.length; i++) {
	      this.addClip(clips[i]);
	    }
	  },
	
	  /**
	   * 删除动画片段
	   * @param {module:zrender/animation/Clip} clip
	   */
	  removeClip: function (clip) {
	    var idx = util.indexOf(this._clips, clip);
	
	    if (idx >= 0) {
	      this._clips.splice(idx, 1);
	    }
	  },
	
	  /**
	   * 删除动画片段
	   * @param {module:zrender/animation/Animator} animator
	   */
	  removeAnimator: function (animator) {
	    var clips = animator.getClips();
	
	    for (var i = 0; i < clips.length; i++) {
	      this.removeClip(clips[i]);
	    }
	
	    animator.animation = null;
	  },
	  _update: function () {
	    var time = new Date().getTime() - this._pausedTime;
	
	    var delta = time - this._time;
	    var clips = this._clips;
	    var len = clips.length;
	    var deferredEvents = [];
	    var deferredClips = [];
	
	    for (var i = 0; i < len; i++) {
	      var clip = clips[i];
	      var e = clip.step(time, delta); // Throw out the events need to be called after
	      // stage.update, like destroy
	
	      if (e) {
	        deferredEvents.push(e);
	        deferredClips.push(clip);
	      }
	    } // Remove the finished clip
	
	
	    for (var i = 0; i < len;) {
	      if (clips[i]._needsRemove) {
	        clips[i] = clips[len - 1];
	        clips.pop();
	        len--;
	      } else {
	        i++;
	      }
	    }
	
	    len = deferredEvents.length;
	
	    for (var i = 0; i < len; i++) {
	      deferredClips[i].fire(deferredEvents[i]);
	    }
	
	    this._time = time;
	    this.onframe(delta);
	    this.trigger('frame', delta);
	
	    if (this.stage.update) {
	      this.stage.update();
	    }
	  },
	  _startLoop: function () {
	    var self = this;
	    this._running = true;
	
	    function step() {
	      if (self._running) {
	        requestAnimationFrame(step);
	        !self._paused && self._update();
	      }
	    }
	
	    requestAnimationFrame(step);
	  },
	
	  /**
	   * 开始运行动画
	   */
	  start: function () {
	    this._time = new Date().getTime();
	    this._pausedTime = 0;
	
	    this._startLoop();
	  },
	
	  /**
	   * 停止运行动画
	   */
	  stop: function () {
	    this._running = false;
	  },
	
	  /**
	   * Pause
	   */
	  pause: function () {
	    if (!this._paused) {
	      this._pauseStart = new Date().getTime();
	      this._paused = true;
	    }
	  },
	
	  /**
	   * Resume
	   */
	  resume: function () {
	    if (this._paused) {
	      this._pausedTime += new Date().getTime() - this._pauseStart;
	      this._paused = false;
	    }
	  },
	
	  /**
	   * 清除所有动画片段
	   */
	  clear: function () {
	    this._clips = [];
	  },
	
	  /**
	   * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
	   * @param  {Object} target
	   * @param  {Object} options
	   * @param  {boolean} [options.loop=false] 是否循环播放动画
	   * @param  {Function} [options.getter=null]
	   *         如果指定getter函数，会通过getter函数取属性值
	   * @param  {Function} [options.setter=null]
	   *         如果指定setter函数，会通过setter函数设置属性值
	   * @return {module:zrender/animation/Animation~Animator}
	   */
	  // TODO Gap
	  animate: function (target, options) {
	    options = options || {};
	    var animator = new Animator(target, options.loop, options.getter, options.setter);
	    this.addAnimator(animator);
	    return animator;
	  }
	};
	util.mixin(Animation, Dispatcher);
	var _default = Animation;
	module.exports = _default;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	var Eventful = __webpack_require__(11);
	
	exports.Dispatcher = Eventful;
	
	var env = __webpack_require__(49);
	
	/**
	 * 事件辅助类
	 * @module zrender/core/event
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;
	var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
	
	function getBoundingClientRect(el) {
	  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
	  return el.getBoundingClientRect ? el.getBoundingClientRect() : {
	    left: 0,
	    top: 0
	  };
	} // `calculate` is optional, default false
	
	
	function clientToLocal(el, e, out, calculate) {
	  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative
	  // to the padding edge of the target element. The only browser using this convention
	  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
	  // not support the properties.
	  // (see http://www.jacklmoore.com/notes/mouse-position/)
	  // In zr painter.dom, padding edge equals to border edge.
	  // FIXME
	  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and
	  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y
	  // is too complex. So css-transfrom dont support in this case temporarily.
	
	  if (calculate || !env.canvasSupported) {
	    defaultGetZrXY(el, e, out);
	  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
	  // ancestor element, so we should make sure el is positioned (e.g., not position:static).
	  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
	  // zoom-factor, overflow / opacity layers, transforms ...)
	  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
	  // <https://bugs.jquery.com/ticket/8523#comment:14>
	  // BTW3, In ff, offsetX/offsetY is always 0.
	  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
	      out.zrX = e.layerX;
	      out.zrY = e.layerY;
	    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
	    else if (e.offsetX != null) {
	        out.zrX = e.offsetX;
	        out.zrY = e.offsetY;
	      } // For some other device, e.g., IOS safari.
	      else {
	          defaultGetZrXY(el, e, out);
	        }
	
	  return out;
	}
	
	function defaultGetZrXY(el, e, out) {
	  // This well-known method below does not support css transform.
	  var box = getBoundingClientRect(el);
	  out.zrX = e.clientX - box.left;
	  out.zrY = e.clientY - box.top;
	}
	/**
	 * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.
	 * `calculate` is optional, default false.
	 */
	
	
	function normalizeEvent(el, e, calculate) {
	  e = e || window.event;
	
	  if (e.zrX != null) {
	    return e;
	  }
	
	  var eventType = e.type;
	  var isTouch = eventType && eventType.indexOf('touch') >= 0;
	
	  if (!isTouch) {
	    clientToLocal(el, e, e, calculate);
	    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
	  } else {
	    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];
	    touch && clientToLocal(el, touch, e, calculate);
	  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;
	  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js
	  // If e.which has been defined, if may be readonly,
	  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which
	
	
	  var button = e.button;
	
	  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
	    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
	  }
	
	  return e;
	}
	
	function addEventListener(el, name, handler) {
	  if (isDomLevel2) {
	    el.addEventListener(name, handler);
	  } else {
	    el.attachEvent('on' + name, handler);
	  }
	}
	
	function removeEventListener(el, name, handler) {
	  if (isDomLevel2) {
	    el.removeEventListener(name, handler);
	  } else {
	    el.detachEvent('on' + name, handler);
	  }
	}
	/**
	 * preventDefault and stopPropagation.
	 * Notice: do not do that in zrender. Upper application
	 * do that if necessary.
	 *
	 * @memberOf module:zrender/core/event
	 * @method
	 * @param {Event} e : event对象
	 */
	
	
	var stop = isDomLevel2 ? function (e) {
	  e.preventDefault();
	  e.stopPropagation();
	  e.cancelBubble = true;
	} : function (e) {
	  e.returnValue = false;
	  e.cancelBubble = true;
	};
	
	function notLeftMouse(e) {
	  // If e.which is undefined, considered as left mouse event.
	  return e.which > 1;
	} // 做向上兼容
	
	
	exports.clientToLocal = clientToLocal;
	exports.normalizeEvent = normalizeEvent;
	exports.addEventListener = addEventListener;
	exports.removeEventListener = removeEventListener;
	exports.stop = stop;
	exports.notLeftMouse = notLeftMouse;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	var _event = __webpack_require__(73);
	
	var addEventListener = _event.addEventListener;
	var removeEventListener = _event.removeEventListener;
	var normalizeEvent = _event.normalizeEvent;
	
	var zrUtil = __webpack_require__(4);
	
	var Eventful = __webpack_require__(11);
	
	var env = __webpack_require__(49);
	
	var GestureMgr = __webpack_require__(75);
	
	var TOUCH_CLICK_DELAY = 300;
	var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
	var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];
	var pointerEventNames = {
	  pointerdown: 1,
	  pointerup: 1,
	  pointermove: 1,
	  pointerout: 1
	};
	var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {
	  var nm = name.replace('mouse', 'pointer');
	  return pointerEventNames[nm] ? nm : name;
	});
	
	function eventNameFix(name) {
	  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;
	}
	
	function processGesture(proxy, event, stage) {
	  var gestureMgr = proxy._gestureMgr;
	  stage === 'start' && gestureMgr.clear();
	  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);
	  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.
	
	  if (gestureInfo) {
	    var type = gestureInfo.type;
	    event.gestureEvent = type;
	    proxy.handler.dispatchToElement({
	      target: gestureInfo.target
	    }, type, gestureInfo.event);
	  }
	} // function onMSGestureChange(proxy, event) {
	//     if (event.translationX || event.translationY) {
	//         // mousemove is carried by MSGesture to reduce the sensitivity.
	//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
	//     }
	//     if (event.scale !== 1) {
	//         event.pinchX = event.offsetX;
	//         event.pinchY = event.offsetY;
	//         event.pinchScale = event.scale;
	//         proxy.handler.dispatchToElement(event.target, 'pinch', event);
	//     }
	// }
	
	/**
	 * Prevent mouse event from being dispatched after Touch Events action
	 * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
	 * 1. Mobile browsers dispatch mouse events 300ms after touchend.
	 * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
	 * Result: Blocking Mouse Events for 700ms.
	 */
	
	
	function setTouchTimer(instance) {
	  instance._touching = true;
	  clearTimeout(instance._touchTimer);
	  instance._touchTimer = setTimeout(function () {
	    instance._touching = false;
	  }, 700);
	}
	
	var domHandlers = {
	  /**
	   * Mouse move handler
	   * @inner
	   * @param {Event} event
	   */
	  mousemove: function (event) {
	    event = normalizeEvent(this.dom, event);
	    this.trigger('mousemove', event);
	  },
	
	  /**
	   * Mouse out handler
	   * @inner
	   * @param {Event} event
	   */
	  mouseout: function (event) {
	    event = normalizeEvent(this.dom, event);
	    var element = event.toElement || event.relatedTarget;
	
	    if (element != this.dom) {
	      while (element && element.nodeType != 9) {
	        // 忽略包含在root中的dom引起的mouseOut
	        if (element === this.dom) {
	          return;
	        }
	
	        element = element.parentNode;
	      }
	    }
	
	    this.trigger('mouseout', event);
	  },
	
	  /**
	   * Touch开始响应函数
	   * @inner
	   * @param {Event} event
	   */
	  touchstart: function (event) {
	    // Default mouse behaviour should not be disabled here.
	    // For example, page may needs to be slided.
	    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
	    // mouse event in upper applicatoin.
	
	    event.zrByTouch = true;
	    this._lastTouchMoment = new Date();
	    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should
	    // be triggered, and must before `mousedown` triggered.
	
	    domHandlers.mousemove.call(this, event);
	    domHandlers.mousedown.call(this, event);
	    setTouchTimer(this);
	  },
	
	  /**
	   * Touch移动响应函数
	   * @inner
	   * @param {Event} event
	   */
	  touchmove: function (event) {
	    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
	    // mouse event in upper applicatoin.
	
	    event.zrByTouch = true;
	    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether
	    // there is gestrue event, because mouse move and pinch may
	    // be used at the same time.
	
	    domHandlers.mousemove.call(this, event);
	    setTouchTimer(this);
	  },
	
	  /**
	   * Touch结束响应函数
	   * @inner
	   * @param {Event} event
	   */
	  touchend: function (event) {
	    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
	    // mouse event in upper applicatoin.
	
	    event.zrByTouch = true;
	    processGesture(this, event, 'end');
	    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
	    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
	    // we can conveniently implement "hover style" in both PC and touch device just
	    // by listening to `mouseover` to add "hover style" and listening to `mouseout`
	    // to remove "hover style" on an element, without any additional code for
	    // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
	    // style" will remain for user view)
	    // click event should always be triggered no matter whether
	    // there is gestrue event. System click can not be prevented.
	
	    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
	      domHandlers.click.call(this, event);
	    }
	
	    setTouchTimer(this);
	  },
	  pointerdown: function (event) {
	    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {
	    //     this._msGesture.addPointer(event.pointerId);
	    // }
	  },
	  pointermove: function (event) {
	    // FIXME
	    // pointermove is so sensitive that it always triggered when
	    // tap(click) on touch screen, which affect some judgement in
	    // upper application. So, we dont support mousemove on MS touch
	    // device yet.
	    if (!isPointerFromTouch(event)) {
	      domHandlers.mousemove.call(this, event);
	    }
	  },
	  pointerup: function (event) {
	    domHandlers.mouseup.call(this, event);
	  },
	  pointerout: function (event) {
	    // pointerout will be triggered when tap on touch screen
	    // (IE11+/Edge on MS Surface) after click event triggered,
	    // which is inconsistent with the mousout behavior we defined
	    // in touchend. So we unify them.
	    // (check domHandlers.touchend for detailed explanation)
	    if (!isPointerFromTouch(event)) {
	      domHandlers.mouseout.call(this, event);
	    }
	  }
	};
	
	function isPointerFromTouch(event) {
	  var pointerType = event.pointerType;
	  return pointerType === 'pen' || pointerType === 'touch';
	} // function useMSGuesture(handlerProxy, event) {
	//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
	// }
	// Common handlers
	
	
	zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
	  domHandlers[name] = function (event) {
	    event = normalizeEvent(this.dom, event);
	    this.trigger(name, event);
	  };
	});
	/**
	 * 为控制类实例初始化dom 事件处理函数
	 *
	 * @inner
	 * @param {module:zrender/Handler} instance 控制类实例
	 */
	
	function initDomHandler(instance) {
	  zrUtil.each(touchHandlerNames, function (name) {
	    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	  });
	  zrUtil.each(pointerHandlerNames, function (name) {
	    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	  });
	  zrUtil.each(mouseHandlerNames, function (name) {
	    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
	  });
	
	  function makeMouseHandler(fn, instance) {
	    return function () {
	      if (instance._touching) {
	        return;
	      }
	
	      return fn.apply(instance, arguments);
	    };
	  }
	}
	
	function HandlerDomProxy(dom) {
	  Eventful.call(this);
	  this.dom = dom;
	  /**
	   * @private
	   * @type {boolean}
	   */
	
	  this._touching = false;
	  /**
	   * @private
	   * @type {number}
	   */
	
	  this._touchTimer;
	  /**
	   * @private
	   * @type {module:zrender/core/GestureMgr}
	   */
	
	  this._gestureMgr = new GestureMgr();
	  this._handlers = {};
	  initDomHandler(this);
	
	  if (env.pointerEventsSupported) {
	    // Only IE11+/Edge
	    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
	    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
	    // at the same time.
	    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
	    // screen, which do not occurs in pointer event.
	    // So we use pointer event to both detect touch gesture and mouse behavior.
	    mountHandlers(pointerHandlerNames, this); // FIXME
	    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
	    // which does not prevent defuault behavior occasionally (which may cause view port
	    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.
	    // So we have to not to use MSGesture and not to support touchmove and pinch on MS
	    // touch screen. And we only support click behavior on MS touch screen now.
	    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
	    // We dont support touch on IE on win7.
	    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
	    // if (typeof MSGesture === 'function') {
	    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
	    //     dom.addEventListener('MSGestureChange', onMSGestureChange);
	    // }
	  } else {
	    if (env.touchEventsSupported) {
	      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
	      // addEventListener(root, 'mouseout', this._mouseoutHandler);
	    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface
	    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
	    // mouse event can not be handle in those devices.
	    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
	    // mouseevent after touch event triggered, see `setTouchTimer`.
	
	
	    mountHandlers(mouseHandlerNames, this);
	  }
	
	  function mountHandlers(handlerNames, instance) {
	    zrUtil.each(handlerNames, function (name) {
	      addEventListener(dom, eventNameFix(name), instance._handlers[name]);
	    }, instance);
	  }
	}
	
	var handlerDomProxyProto = HandlerDomProxy.prototype;
	
	handlerDomProxyProto.dispose = function () {
	  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);
	
	  for (var i = 0; i < handlerNames.length; i++) {
	    var name = handlerNames[i];
	    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
	  }
	};
	
	handlerDomProxyProto.setCursor = function (cursorStyle) {
	  this.dom.style.cursor = cursorStyle || 'default';
	};
	
	zrUtil.mixin(HandlerDomProxy, Eventful);
	var _default = HandlerDomProxy;
	module.exports = _default;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	var eventUtil = __webpack_require__(73);
	
	/**
	 * Only implements needed gestures for mobile.
	 */
	var GestureMgr = function () {
	  /**
	   * @private
	   * @type {Array.<Object>}
	   */
	  this._track = [];
	};
	
	GestureMgr.prototype = {
	  constructor: GestureMgr,
	  recognize: function (event, target, root) {
	    this._doTrack(event, target, root);
	
	    return this._recognize(event);
	  },
	  clear: function () {
	    this._track.length = 0;
	    return this;
	  },
	  _doTrack: function (event, target, root) {
	    var touches = event.touches;
	
	    if (!touches) {
	      return;
	    }
	
	    var trackItem = {
	      points: [],
	      touches: [],
	      target: target,
	      event: event
	    };
	
	    for (var i = 0, len = touches.length; i < len; i++) {
	      var touch = touches[i];
	      var pos = eventUtil.clientToLocal(root, touch, {});
	      trackItem.points.push([pos.zrX, pos.zrY]);
	      trackItem.touches.push(touch);
	    }
	
	    this._track.push(trackItem);
	  },
	  _recognize: function (event) {
	    for (var eventName in recognizers) {
	      if (recognizers.hasOwnProperty(eventName)) {
	        var gestureInfo = recognizers[eventName](this._track, event);
	
	        if (gestureInfo) {
	          return gestureInfo;
	        }
	      }
	    }
	  }
	};
	
	function dist(pointPair) {
	  var dx = pointPair[1][0] - pointPair[0][0];
	  var dy = pointPair[1][1] - pointPair[0][1];
	  return Math.sqrt(dx * dx + dy * dy);
	}
	
	function center(pointPair) {
	  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
	}
	
	var recognizers = {
	  pinch: function (track, event) {
	    var trackLen = track.length;
	
	    if (!trackLen) {
	      return;
	    }
	
	    var pinchEnd = (track[trackLen - 1] || {}).points;
	    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
	
	    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
	      var pinchScale = dist(pinchEnd) / dist(pinchPre);
	      !isFinite(pinchScale) && (pinchScale = 1);
	      event.pinchScale = pinchScale;
	      var pinchCenter = center(pinchEnd);
	      event.pinchX = pinchCenter[0];
	      event.pinchY = pinchCenter[1];
	      return {
	        type: 'pinch',
	        target: track[0].target,
	        event: event
	      };
	    }
	  } // Only pinch currently.
	
	};
	var _default = GestureMgr;
	module.exports = _default;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var util = __webpack_require__(77);
	    var BPMNNode = __webpack_require__(79);
	    var BPMNModel = __webpack_require__(82);
	    var StartEventNode = __webpack_require__(84);
	    var EndEventNode = __webpack_require__(86);
	    var UserTaskNode = __webpack_require__(87);
	    var ManualTaskNode = __webpack_require__(89);
	    var ScriptTaskNode = __webpack_require__(90);
	    var MailTaskNode = __webpack_require__(91);
	    var ServiceTaskNode = __webpack_require__(92);
	    var SmsTaskNode = __webpack_require__(93);
	    var CommentNode = __webpack_require__(94);
	    var CatchTimerEventNode = __webpack_require__(95);
	    var CatchSignalEventNode = __webpack_require__(96);
	    var ThrowSignalEventNode = __webpack_require__(97);
	    var CatchMessageEventNode = __webpack_require__(98);
	    var InclusiveGatewayNode = __webpack_require__(99);
	    var ExclusiveGatewayNode = __webpack_require__(101);
	    var ParallelGatewayNode = __webpack_require__(102);
	    var SubPrcessNode = __webpack_require__(103);
	    var Bpmn = __webpack_require__(104);
	    /**
	     * 根据结点数组 导出JSON格式的数据
	     *
	     * @param {Array} nodes 结点数组
	     * @param {String} bpmnModel bpmn的model
	     * @param {Array} connectors 所有连线
	     * @return {JSON} JSON格式的数据
	     */
	    function toJson(bpmnModel, nodes, connectors) {
	        var jsonArr = [];
	        for(var i = 0; i < nodes.length;i++){
	            var node = nodes[i];
	            //去掉子流程里面的节点
	            if (node.parent && Bpmn.isSubProcess(node.parent)) {
	                continue;
	            }
	            if( node && node.toJSON) {
	                jsonArr.push(node.toJSON());
	            }
	        }
	        //增加线
	        for(var j = 0; j < connectors.length;j++){
	            var connector = connectors[j];
	            //去掉子流程里面的线段
	            if (connector.parent && Bpmn.isSubProcess(connector.parent)) {
	                continue;
	            }
	            if( connector && connector.toJSON) {
	                jsonArr.push(connector.toJSON());
	            }
	        }
	        bpmnModel.set("childShapes", jsonArr);
	
	
	        return bpmnModel.option;
	    }
	
	    /**
	     * 根据 JSON 生成节点
	     * @param  {[type]} fishTopoBpmn [description]
	     * @param  {[type]} json         [description]
	     * @return {[type]}              [description]
	     */
	    function fromJson(fishTopoBpmn, json) {
	        // 1.清空画布
	        fishTopoBpmn.clear(true);
	
	        // 2.先创建节点  遍历形状 获取模型
	        var bpmnModel = new BPMNModel(json);
	
	        fishTopoBpmn.model = bpmnModel;
	
	        var bpmnWidth = bpmnModel.get("properties.width");
	        var bpmnHeight = bpmnModel.get("properties.height");
	        if (bpmnWidth > 0 && bpmnHeight > 0) {
	            fishTopoBpmn.resize(bpmnWidth,bpmnHeight);
	        }
	        function loopAddSubNode(node, model) {
	            if (node.nodeType === Bpmn.SUB_PROCESS) {
	                var subShapes = model.get("childShapes");
	                for (var j = 0; j < subShapes.length; j++) {
	                    var subModel = new BPMNModel(subShapes[j]);
	                    if(Bpmn.isFlowModel(subModel)) {
	                        fishTopoBpmn.addConnectorByModel(subModel, node);
	                    } else {
	                        var superUpperLeft = model.get("bounds.upperLeft");
	                        var subUpperLeft = subModel.get("bounds.upperLeft");
	                        var subLowerRight = subModel.get("bounds.lowerRight");
	                        subModel.set("bounds.upperLeft", { x: subUpperLeft.x + superUpperLeft.x, y: subUpperLeft.y + superUpperLeft.y });
	                        subModel.set("bounds.lowerRight", { x: subLowerRight.x + superUpperLeft.x, y: subLowerRight.y + superUpperLeft.y });
	                        var subNode = fishTopoBpmn.addNodeByModel(subModel,true,true);
	                        loopAddSubNode(subNode, subModel);
	                    }
	                }
	            }
	        }
	        var childShapes = bpmnModel.get("childShapes");
	        var connectors = [];
	        for (var i = 0; i < childShapes.length; i++) {
	            var shape = childShapes[i];
	            var type = shape.stencil.type;
	            if (type === Bpmn.SEQUENCE_FLOW) {
	                connectors.push(shape);
	            } else {
	                var model = new BPMNModel(shape);
	                var createdNode = fishTopoBpmn.addNodeByModel(model,false,true);
	                loopAddSubNode(createdNode, model);
	            }
	        }
	        // 3. 再创建线
	        for(var k = 0, len = connectors.length; k < len; k++) {
	            var modelLine = new BPMNModel(connectors[k]); // shape
	            fishTopoBpmn.addConnectorByModel(modelLine);
	        }
	
	        // 4.创建事件插槽
	        for (var m = 0; m < childShapes.length; m++) {
	            if (childShapes[m].properties.slotEvent) {
	                for(var n = 0;n < childShapes[m].properties.slotEvent.length; n++){
	                    findNodeById(fishTopoBpmn,childShapes[m].resourceId).slotEvent.push(findNodeById(fishTopoBpmn,childShapes[m].properties.slotEvent[n]))
	                }
	            }
	
	        }
	
	    }
	
	    /**
	     * 根据id在fishTopoBpmn中查找
	     * @param  {[type]} fishTopoBpmn  [description]
	     * @param  {[type]} nodeId [description]
	     * @return {[type]}        [description]
	     */
	    function findNodeById(fishTopoBpmn, nodeId) {
	        var node;
	        for (var i = fishTopoBpmn.allNodes.length - 1; i >= 0; i--) {
	            if (fishTopoBpmn.allNodes[i].model.get("resourceId") == nodeId) {
	                node = fishTopoBpmn.allNodes[i];
	            }
	        }
	        return node;
	    }
	
	
	
	    function registerBPMNNode () {
	        BPMNNode.registerClass(StartEventNode, "StartNoneEvent");
	        BPMNNode.registerClass(EndEventNode, "EndNoneEvent");
	        BPMNNode.registerClass(UserTaskNode, "UserTask");
	        BPMNNode.registerClass(ManualTaskNode, "ManualTask");
	        BPMNNode.registerClass(ScriptTaskNode, "ScriptTask");
	        BPMNNode.registerClass(MailTaskNode, "MailTask");
	        BPMNNode.registerClass(ServiceTaskNode, "ServiceTask");
	        BPMNNode.registerClass(SmsTaskNode, "SmsTask");
	        BPMNNode.registerClass(CommentNode, "Comment");
	        BPMNNode.registerClass(CatchTimerEventNode, "CatchTimerEvent");
	        BPMNNode.registerClass(CatchMessageEventNode, "CatchMessageEvent");
	        BPMNNode.registerClass(CatchSignalEventNode, "CatchSignalEvent");
	        BPMNNode.registerClass(ThrowSignalEventNode, "ThrowSignalEvent");
	        BPMNNode.registerClass(InclusiveGatewayNode, "InclusiveGateway");
	        BPMNNode.registerClass(ExclusiveGatewayNode, "ExclusiveGateway");
	        BPMNNode.registerClass(ParallelGatewayNode, "ParallelGateway");
	        BPMNNode.registerClass(SubPrcessNode, "SubProcess");
	    }
	
	    function parentX(node) {
	        if (node.parent && Bpmn.isSubProcess(node.parent)) {
	            return node.position[0] + parentX(node.parent)
	        } else {
	            return node.position[0]
	        }
	    }
	
	    function parentY(node) {
	        if (node.parent && Bpmn.isSubProcess(node.parent)) {
	            return node.position[1] + parentY(node.parent)
	        } else {
	            return node.position[1]
	        }
	    }
	
	    function getParentNode(node) {
	        if (node.parent && Bpmn.isSubProcess(node.parent)) {
	            return getParentNode(node.parent);
	        } else {
	            return node;
	        }
	    }
	
	    function isHover(node, x, y) {
	        var cx , cy;
	        if(node.parent){
	            if(Bpmn.isSubProcess(node.parent)){
	                cx = x - parentX(node.parent);
	                cy = y - parentY(node.parent);
	                return node.rectContain(cx, cy)
	            }
	        }else{
	            return node.rectContain(x, y);
	        }
	
	     }
	
	    function findHover(list, x, y, excludes) {
	        for (var i = list.length - 1; i >= 0 ; i--) {
	            if (isExclude(excludes,list[i]) //list[i] !== exclude
	             // getDisplayList may include ignored item in VML mode
	             && !list[i].ignore
	             && isHover(list[i], x, y)) {
	                return list[i];
	            }
	        }
	    }
	
	
	    function isExclude(excludes, node) {
	        return zrUtil.indexOf(excludes,node) == -1;
	     }
	
	
	
	
	    var BpmnUtil = {
	        toJson: toJson,
	        fromJson: fromJson,
	        registerBPMNNode: registerBPMNNode,
	        findHover: findHover,
	        parentX: parentX,
	        parentY: parentY,
	        getParentNode: getParentNode,
	        getUUID: util.getUUID
	    };
	    module.exports = BpmnUtil;
	


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 工具方法类
	 * @author wang.xiaohu
	 */
	
	    var Point = __webpack_require__(64);
	    var Line = __webpack_require__(78);
	    var BoundingRect = __webpack_require__(26);
	    var zrUtil = __webpack_require__(4);
	    /**
	     * 构造类继承关系
	     *
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    function getUUID() {
	        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),
	            uuid = new Array(36),
	            rnd = 0,
	            r;
	        for (var i = 0; i < 36; i++) {
	            if (i == 8 || i == 13 || i == 18 || i == 23) {
	                uuid[i] = '-';
	            } else if (i == 14) {
	                uuid[i] = '4';
	            } else {
	                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
	                r = rnd & 0xf;
	                rnd = rnd >> 4;
	                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
	            }
	        }
	        return "sid-" + uuid.join('');
	    }
	
	
	    /**
	     * 计算两点之间的距离
	     *@param {Point} p1 - first {Point}
	     *@param {Point} p2 - second {Point}
	     *@return {Number} - the distance between those 2 points. It is always positive.
	     **/
	    function distance(p1, p2) {
	        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
	    }
	
	    /**
	     * 返回一条折线 最长的两个点
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    function getMaxLineLength(points) {
	        var m = distance(points[0], points[1]);
	        var result = [points[0], points[1]];
	        for (var i = 1; i < points.length - 1; i++) {
	
	            if (m < distance(points[i], points[i + 1])) {
	                m = distance(points[i], points[i + 1])
	                result = [points[i], points[i + 1]];
	            }
	        }
	
	        return result;
	    }
	
	    /**Returns the length of a Polyline that would be created with a set of points
	     *@param {Array} v - an {Array} of {Points}
	     *@return {Number} - a positive number equal with total length*/
	    function getPolylineLength(v) {
	        var l = 0;
	        for (var i = 0; i < v.length - 1; i++) {
	            l += distance(v[i], v[i + 1]);
	        }
	
	        return l;
	    }
	
	
	    /**Returns the max of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the maximum number from the vector or NaN if vector is empty
	     **/
	    function max(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m < v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	
	    /**Returns the min of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the minimum number from the vector or NaN if vector is empty
	     *@author alex@scriptoid.com
	     **/
	    function min(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m > v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	    /**
	     * 判断 点数组 是否正交直线路径
	     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function orthogonalPath(v) {
	        if (v.length <= 1) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 1; i++) {
	            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	
	
	    /**
	     *Test to see if 2 {Line}s intersects. They are considered finite segments
	     *and not the infinite lines from geometry
	     *@param {Line} l1 - fist line/segment
	     *@param {Line} l2 - last line/segment
	     *@return {Boolean} true - if the lines intersect or false if not
	     **/
	    function lineIntersectsLine(l1, l2) {
	        // check for two vertical lines
	        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {
	            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,
	                // then check segment bounds for overlapping
	                l1.contains(l2.startPoint.x, l2.startPoint.y) ||
	                l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                // lines are paralel
	                false;
	        }
	        // if one line is vertical, and another line is not vertical
	        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {
	            // let assume l2 is vertical, otherwise exchange them
	            if (l1.startPoint.x == l1.endPoint.x) {
	                var l = l1;
	                l1 = l2;
	                l2 = l;
	            }
	            // finding intersection of 'infinite' lines
	            // equation of the first line is y = ax + b, second: x = c
	            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b = l1.startPoint.y - a * l1.startPoint.x;
	            var x0 = l2.startPoint.x;
	            var y0 = a * x0 + b;
	            return l1.contains(x0, y0) && l2.contains(x0, y0);
	        }
	
	        // check normal case - both lines are not vertical
	        else {
	            //line equation is : y = a*x + b, b = y - a * x
	            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;
	
	            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);
	            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;
	
	            if (a1 == a2) { //paralel lines
	                return b1 == b2 ?
	                    // for coincide lines, check for segment bounds overlapping
	                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                    // not coincide paralel lines have no chance to intersect
	                    false;
	            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment
	
	                /*
	                 * if one of the lines are vertical, then x0 is equal to their x,
	                 * otherwise:
	                 * y1 = a1 * x + b1
	                 * y2 = a2 * x + b2
	                 * => x0 = (b2 - b1) / (a1 - a2)
	                 * => y0 = a1 * x0 + b1
	                 **/
	                x0 = (b2 - b1) / (a1 - a2);
	                y0 = a1 * x0 + b1;
	                return l1.contains(x0, y0) && l2.contains(x0, y0);
	            }
	        }
	    }
	
	    /**
	     *
	     *Tests if a a polyline defined by a set of points intersects a rectangle
	     *@param {Array} points - and {Array} of {Point}s
	     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)
	     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false
	     *
	     *@return true - if line intersects the rectangle, false - if not
	     **/
	    function polylineIntersectsRectangle(points, bounds, closedPolyline) {
	
	
	        //get the 4 lines/segments represented by the bounds
	        var lines = [];
	        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));
	        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));
	        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));
	        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));
	
	        for (var k = 0; k < points.length - 1; k++) {
	            //create a line out of each 2 consecutive points
	            var tempLine = new Line(points[k], points[k + 1]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var i = 0; i < lines.length; i++) {
	                if (lineIntersectsLine(tempLine, lines[i])) {
	                    return true;
	                }
	            }
	        }
	
	        //check the closed figure - that is last point connected to the first
	        if (closedPolyline) {
	            //create a line out of each 2 consecutive points
	            var tempLine1 = new Line(points[points.length - 1], points[0]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var j = 0; j < lines.length; j++) {
	                if (lineIntersectsLine(tempLine1, lines[j])) {
	                    return true;
	                }
	            }
	        }
	
	        return false;
	    }
	
	    /**
	     * 计算路径的分数
	     * Score a ortogonal path made out of Points
	     *Iterates over a set of points (minimum 3)
	     *For each 3 points (i, i+1, i+2) :
	     *  - if the 3rd one is after the 2nd on the same line we add +1
	     *  - if the 3rd is up or down related to the 2nd we do not do anything +0
	     *  - if the 3rd goes back we imediatelly return -1
	     *@param {Array} v - an array of {Point}s
	     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine
	     *  The bigger the number the smooth the path is
	     **/
	    function scorePath(v) {
	        if (v.length <= 2) {
	            return -1;
	        }
	
	        var score = 0;
	        for (var i = 1; i < v.length - 1; i++) {
	            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else { //not on same vertical nor horizontal
	                score--;
	            }
	        }
	
	        return score;
	    }
	
	    /**
	     * 返回数字符号（+ -)
	     * Returns the sign of a number
	     *@param {Number} x - the number
	     *@returns {Number}
	     *@see <a href="http://en.wikipedia.org/wiki/Sign_function">http://en.wikipedia.org/wiki/Sign_function</a>
	     **/
	    function signum(x) {
	        if (x > 0)
	            return 1;
	        else if (x < 0)
	            return -1;
	        else
	            return 0;
	    }
	
	    /**
	     * 判断 点数组 是不是有效路径（没有回路）
	     *Tests if a vector of points is a valid path (not going back)
	     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function forwardPath(v) {
	        if (v.length <= 2) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 2; i++) {
	            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            }
	        }
	
	        return true;
	    }
	
	    /**
	     * 将[x:0,y:0]转化为[0, 0]  给zrender使用
	     * @param  {[type]} points [description]
	     * @param  {[type]} isRevert [description]
	     * @return {[type]}        [description]
	     */
	    function traslatePoints(points, isRevert) {
	        var newPoints = [];
	        if (isRevert) {
	            for (var i = 0; i < points.length; i++) {
	                var point = points[i];
	                newPoints.push(new Point(point[0], point[1]));
	            }
	            return newPoints;
	        } else {
	            for (var j = 0; j < points.length; j++) {
	                var point1 = points[j];
	                newPoints.push([point1.x, point1.y]);
	            }
	            return newPoints;
	        }
	
	
	    }
	
	    function rotationMatrix(angle) {
	        var mReturn = [
	            [Math.cos(angle), -Math.sin(angle), 0],
	            [Math.sin(angle), Math.cos(angle), 0],
	            [0, 0, 1]
	        ];
	        return mReturn;
	    }
	
	    function translationMatrix(dx, dy) {
	        return [
	            [1, 0, dx],
	            [0, 1, dy],
	            [0, 0, 1]
	        ];
	    }
	
	    function scaleMatrix(sx, sy) {
	        if (sy == null) {
	            sy = sx;
	        }
	        return [
	            [sx, 0, 0],
	            [0, sy, 0],
	            [0, 0, 1]
	        ];
	    }
	
	    /** It will return the end point of a line on a given angle (clockwise).
	     * @param {Point} startPoint - the start of the line
	     * @param {Number} length - the length of the line
	     * @param {Number} angle - the angle of the line in radians
	     * @return {Point} - the endPoint of the line
	     */
	    function getEndPoint(startPoint, length, angle) {
	        var endPoint = startPoint.clone();
	        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));
	        endPoint.y -= length;
	        endPoint.transform(rotationMatrix(angle));
	        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));
	        return endPoint;
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} rect [description]
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getConnectorPoints(rect, node) {
	        node = node || {};
	        var boundingRect = zrUtil.clone(rect.boundingRect || rect);
	        var rotation = node.rotation;
	        var points = {
	            left: new Point(boundingRect.x, boundingRect.y + boundingRect.height / 2), //矩形 左中的位置
	            top: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y), //矩形 上中的位置
	            right: new Point(boundingRect.x + boundingRect.width, boundingRect.y + boundingRect.height / 2), //矩形 右中的位置
	            bottom: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y + boundingRect.height), //矩形 下中的位置
	            center: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y + boundingRect.height / 2) //中间位置
	
	        };
	        if (Object.keys(node).length > 0 && Math.abs(rotation) > 0) {
	            var rectNew = rect.boundingRect ? rect : getRect(node);
	            var center = { x: rectNew.x, y: rectNew.y }; // 中心点
	            Object.keys(points).forEach(function(key) {
	                var value = points[key];
	                var x0 = center.x - value.x;
	                var y0 = center.y - value.y;
	                var sin = Math.sin(-rotation);
	                var cos = Math.cos(-rotation);
	                var position_n_x = center.x - (x0 * cos - y0 * sin);
	                var position_n_y = center.y - (x0 * sin + y0 * cos);
	                points[key].x = position_n_x;
	                points[key].y = position_n_y;
	            });
	        }
	        return points;
	    }
	
	    /**
	     * 获取节点外面四个控制点和旋转点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getConnectorControls(rect, node) {
	        node = node || {};
	        var boundingRect = zrUtil.clone(rect.boundingRect);
	        var rotation = node.rotation;
	        var controls = {
	            tl: new Point(boundingRect.x, boundingRect.y), //矩形 左上角位置
	            tc: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y - 4), //矩形 上中位置
	            tr: new Point(boundingRect.x + boundingRect.width, boundingRect.y), //矩形 右上角位置
	            bl: new Point(boundingRect.x, boundingRect.y + boundingRect.height), //矩形 左下角
	            br: new Point(boundingRect.x + boundingRect.width, boundingRect.y + boundingRect.height), //矩形 右下角位置
	            mtr: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y - 20) // 旋转点位置
	        };
	        if (Object.keys(node).length > 0 && Math.abs(rotation) > 0) {
	            var rectNew = rect;
	            var center = { x: rectNew.x, y: rectNew.y }; // 中心点
	            Object.keys(controls).forEach(function(key) {
	                var value = controls[key];
	                var x0 = center.x - value.x;
	                var y0 = center.y - value.y;
	                var sin = Math.sin(-rotation);
	                var cos = Math.cos(-rotation);
	                var position_n_x = center.x - (x0 * cos - y0 * sin);
	                var position_n_y = center.y - (x0 * sin + y0 * cos);
	                controls[key].x = position_n_x;
	                controls[key].y = position_n_y;
	            });
	        }
	        return controls;
	    }
	
	    /**
	     * 根据中心点和旋转弧度，计算旋转后的点坐标
	     * @param  {[object|array]} points [原坐标]
	     * @param  {[object]}       center [中心点]
	     * @param  {[number]}       rotation [旋转弧度]
	     * @return {[type]}      [description]
	     */
	    function calculatePoints(points, center, rotation) {
	        var x = Array.isArray(points) ? points[0] : points.x;
	        var y = Array.isArray(points) ? points[1] : points.y;
	        var x0 = center.x - x;
	        var y0 = center.y - y;
	        var sin = Math.sin(-rotation);
	        var cos = Math.cos(-rotation);
	        var position_n_x = center.x - (x0 * cos - y0 * sin);
	        var position_n_y = center.y - (x0 * sin + y0 * cos);
	        if (Array.isArray(points)) {
	            return [position_n_x, position_n_y];
	        }
	        return {
	            x: position_n_x,
	            y: position_n_y
	        }
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getSoltPoints(node) {
	        return [
	            //top
	            [Math.round(node.getRect().width / 3 /10)*10, 0 ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],
	            //right
	            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],
	            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],
	            //bottom
	            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],
	            //left
	            [0, Math.round(node.getRect().height / 3 /10)*10 ],
	            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]
	
	        ]
	    }
	
	    /**
	     * 计算 p1 p2两点所连接的直线的角度
	     * @param  {[type]} p1 [description]
	     * @param  {[type]} p2 [description]
	     * @return {[type]}    [description]
	     */
	    function tangentRotation(p1, p2) {
	        return -Math.PI / 2 - Math.atan2(
	            p2.y - p1.y, p2.x - p1.x
	        );
	    }
	
	    /**
	     * 判断3点是否在一条直线上
	     * Tests if 3 points are coliniar with matrix determinants.
	     * If the determinat of matrix
	     * /         \
	     * | x1 y1 1 |
	     * | x2 y2 1 |
	     * | x3 y3 1 |
	     * \         /
	     * is zero it means that the points are colinear
	     *@param {Point} p1 - first point
	     *@param {Point} p2 - second point
	     *@param {Point} p3 - third point
	     * @param {Number} precission
	     *@return {Boolean} - true if coliniar and false if not
	     *@author Alex
	     *@see http://en.wikipedia.org/wiki/Determinant
	     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html
	     **/
	    function collinearity(p1, p2, p3, precission) {
	        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);
	
	        if (precission) {
	            return Math.abs(determinant) <= precission;
	        } else {
	            return determinant === 0;
	        }
	    }
	
	
	    /**
	     * 四舍五入 保存decimals的小数
	     **/
	    function enhancedRound(number, decimals) {
	        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	    }
	
	    /**
	     * 获取两点之间的长度
	     **/
	    function getLength(startPoint, endPoint) {
	        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));
	    }
	
	    /**
	     * 获取角度
	     * @param  {[type]} centerPoint  [description]
	     * @param  {[type]} outsidePoint [description]
	     * @param  {[type]} round        [description]
	     * @return {[type]}              [description]
	     */
	    function getAngle(centerPoint, outsidePoint, round) {
	        centerPoint.x = enhancedRound(centerPoint.x, 5);
	        centerPoint.y = enhancedRound(centerPoint.y, 5);
	        outsidePoint.x = enhancedRound(outsidePoint.x, 5);
	        outsidePoint.y = enhancedRound(outsidePoint.y, 5);
	        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));
	        angle = -angle;
	
	        //endAngle+=90;
	        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {
	            angle += Math.PI * 2;
	        }
	        while (angle >= Math.PI * 2) {
	            angle -= Math.PI * 2;
	        }
	        if (isNaN(angle)) { //Nan
	            angle = 0; //we are at center point;
	        }
	        if (round) {
	            angle = Math.round(angle / round) * round
	        }
	        return angle;
	    }
	
	    /**
	     * 获取父节点的position[0]
	     * @param  {object} node  [节点]
	     * @param  {string} parentKey [判断是否有指定父节点的key,对于group是type；对于subprocess是nodeType]
	     * @param  {string} parentValue  [判断是否有指定父节点的value,对于group是GroupNode；对于subprocess是SubProcess]
	     * @return {number}              父节点的position[0]
	     */
	    function getParentX(node, parentKey, parentValue) {
	        if (!parentKey) {
	            parentKey = 'type';
	        }
	        if (!parentValue) {
	            parentValue = 'GroupNode';
	        }
	        if (node.parent && node.parent[parentKey] === parentValue) {
	            return node.position[0] + getParentX(node.parent)
	        } else {
	            return node.position[0]
	        }
	    }
	
	    /**
	     * 获取父节点的position[1]
	     * @param  {object} node  [节点]
	     * @param  {string} parentKey [判断是否有指定父节点的key,对于group是type；对于subprocess是nodeType]
	     * @param  {string} parentValue  [判断是否有指定父节点的value,对于group是GroupNode；对于subprocess是SubProcess]
	     * @return {number}              父节点的position[1]
	     */
	    function getParentY(node, parentKey, parentValue) {
	        if (!parentKey) {
	            parentKey = 'type';
	        }
	        if (!parentValue) {
	            parentValue = 'GroupNode';
	        }
	        if (node.parent && node.parent[parentKey] === parentValue) {
	            return node.position[1] + getParentY(node.parent)
	        } else {
	            return node.position[1]
	        }
	    }
	
	    function getRect(node, isCalcParent) {
	        var clipPath = node.clipPath;
	        var boundingRect = node.getBoundingRect();
	        // 节点裁剪后，以裁剪节点包围盒为准
	        if (clipPath) {
	            boundingRect = clipPath.getBoundingRect();
	        }
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];
	        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];
	        points[2] = [boundingRect.width / 2, boundingRect.height / 2];
	        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];
	        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];
	
	        var positionX = node.position[0];
	        var positionY = node.position[1];
	        //这里要循环判断一把 有没有父节点 并且父节点不是根节点 然后进行相加
	        if (node.parent && isCalcParent) {
	            if (node.parent.type === 'GroupNode' || node.parent.nodeType === 'SubProcess') {
	                positionX += getParentX(node.parent);
	                positionY += getParentY(node.parent);
	            }
	        }
	
	        var boundRect = new BoundingRect(
	                Number(positionX + boundingRect.x),   //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半
	                Number(positionY + boundingRect.y),
	                Number(boundingRect.width),
	                Number(boundingRect.height)
	            );
	        //中心点
	        var cx = Number(positionX) + Number(boundingRect.width) / 2 + Number(boundingRect.x);
	        var cy = Number(positionY) + Number(boundingRect.height) / 2 + Number(boundingRect.y);
	        return {
	            x: Number(cx),
	            y: Number(cy),
	            width: Number(boundingRect.width),
	            height: Number(boundingRect.height),
	            points: points,
	            boundingRect: boundRect
	        };
	    }
	
	    var StackedMap = {
	        createNew: function() {
	            var stack = [];
	
	            return {
	                add: function(key, value) {
	                    var arrKey = this.get(key);
	                    arrKey.push(value)
	
	                },
	                // 获取起始点有offset间隔的arrKey
	                getsimilar: function(key) {
	                    var value = [];
	                    var keyArr = key.split(',');
	                    stack.forEach(function(item) {
	                        var itemKeyArr = item.key.split(',');
	                        if (itemKeyArr[0].indexOf(keyArr[0]) > -1 && itemKeyArr[1].indexOf(keyArr[1]) > -1) {
	                            value = value.concat(item.value);
	                        }
	                    });
	                    if (value.length <= 0) {
	                        stack.push({ key: key, value: value });  
	                    }
	                    return value;
	                },
	                get: function(key) {
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            return stack[i].value;
	                        }
	                    }
	                    //如果没有找到的话，则创建一个新的数组
	                    var value = [];
	                    stack.push({ key: key, value: value });
	                    return value;
	                },
	                keys: function() {
	                    var keys = [];
	                    for (var i = 0; i < stack.length; i++) {
	                        keys.push(stack[i].key);
	                    }
	                    return keys;
	                },
	                top: function() {
	                    return stack[stack.length - 1];
	                },
	                remove: function(key) {
	                    var idx = -1;
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            idx = i;
	                            break;
	                        }
	                    }
	                    return stack.splice(idx, 1)[0];
	                },
	                removeItem: function(key, item) {
	                    var arrKey = this.get(key);
	                    var index = zrUtil.indexOf(arrKey, item);
	                    arrKey.splice(index, 1);
	
	                },
	                removeTop: function() {
	                    return stack.splice(stack.length - 1, 1)[0];
	                },
	                length: function() {
	                    return stack.length;
	                },
	                clear: function() {
	                    stack.splice(0, stack.length);
	                }
	            };
	        }
	    };
	
	    function randomColor() {
	        var arrHex = ["0", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d"],
	            strHex = "#",
	            index;
	        for (var i = 0; i < 6; i++) {
	            index = Math.round(Math.random() * 15);
	            strHex += arrHex[index];
	        }
	        return strHex;
	    }
	
	    function isUndefined(obj) {
	        return obj === void 0;
	    }
	
	    function collinearReduction (v) {
	        var r = [];
	
	        if(v.length < 3){
	            return Point.cloneArray(v);
	        }
	
	        r.push( v[0].clone() );
	        for(var i=1; i < v.length-1; i++){
	            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )
	            {
	                continue;
	            }
	            else{
	                r.push( v[i].clone() );
	            }
	        }
	        r.push( v[v.length-1].clone() );
	
	        return r;
	    }
	
	    // By default, Underscore uses ERB-style template delimiters, change the
	    // following template settings to use alternative delimiters.
	    var templateSettings = {
	        evaluate: /<%([\s\S]+?)%>/g,
	        interpolate: /<%=([\s\S]+?)%>/g,
	        escape: /<%-([\s\S]+?)%>/g
	    };
	
	    // When customizing `templateSettings`, if you don't want to define an
	    // interpolation, evaluation or escaping regex, we need one that is
	    // guaranteed not to match.
	    var noMatch = /(.)^/;
	
	    // Certain characters need to be escaped so that they can be put into a
	    // string literal.
	    var escapes = {
	        "'": "'",
	        '\\': '\\',
	        '\r': 'r',
	        '\n': 'n',
	        '\u2028': 'u2028',
	        '\u2029': 'u2029'
	    };
	
	    var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
	
	    var escapeChar = function(match) {
	        return '\\' + escapes[match];
	    };
	
	    // JavaScript micro-templating, similar to John Resig's implementation.
	    // Underscore templating handles arbitrary delimiters, preserves whitespace,
	    // and correctly escapes quotes within interpolated code.
	    // NB: `oldSettings` only exists for backwards compatibility.
	    function template(text, settings, oldSettings) {
	        if (!settings && oldSettings) settings = oldSettings;
	        settings = settings || {};
	        settings = zrUtil.defaults(settings, templateSettings, true);
	
	        // Combine delimiters into one regular expression via alternation.
	        var matcher = RegExp([
	            (settings.escape || noMatch).source,
	            (settings.interpolate || noMatch).source,
	            (settings.evaluate || noMatch).source
	        ].join('|') + '|$', 'g');
	
	        // Compile the template source, escaping string literals appropriately.
	        var index = 0;
	        var source = "__p+='";
	        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	            source += text.slice(index, offset).replace(escaper, escapeChar);
	            index = offset + match.length;
	
	            if (escape) {
	                source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	            } else if (interpolate) {
	                source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	            } else if (evaluate) {
	                source += "';\n" + evaluate + "\n__p+='";
	            }
	
	            // Adobe VMs need the match returned to produce the correct offest.
	            return match;
	        });
	        source += "';\n";
	
	        // If a variable is not specified, place data values in local scope.
	        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	
	        source = "var __t,__p='',__j=Array.prototype.join," +
	            "print=function(){__p+=__j.call(arguments,'');};\n" +
	            source + 'return __p;\n';
	
	        try {
	            var render = new Function(settings.variable || 'obj', source);
	        } catch (e) {
	            e.source = source;
	            throw e;
	        }
	
	        var template = function(data) {
	            return render.call(this, data);
	        };
	
	        // Provide the compiled source as a convenience for precompilation.
	        var argument = settings.variable || 'obj';
	        template.source = 'function(' + argument + '){\n' + source + '}';
	
	        return template;
	    }
	
	    function isEmpty(obj) {
	        if (obj == null) return true;
	        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;
	    }
	    function mergeOpt(target, source, overwrite, exclude) {
	        // We should escapse that source is string
	        // and enter for ... in ...
	        if (!zrUtil.isObject(source) || !zrUtil.isObject(target)) {
	          return overwrite ? zrUtil.clone(source) : target;
	        }
	
	        for (var key in source) {
	          if (source.hasOwnProperty(key)) {
	            var targetProp = target[key];
	            var sourceProp = source[key];
	
	            if (zrUtil.isObject(sourceProp) && zrUtil.isObject(targetProp) && !zrUtil.isArray(sourceProp) && !zrUtil.isArray(targetProp) && !zrUtil.isDom(sourceProp) && !zrUtil.isDom(targetProp) && !zrUtil.isBuiltInObject(sourceProp) && !zrUtil.isBuiltInObject(targetProp) && !zrUtil.isPrimitive(sourceProp) && !zrUtil.isPrimitive(targetProp)) {
	              // 如果需要递归覆盖，就递归调用merge
	              mergeOpt(targetProp, sourceProp, overwrite, exclude);
	            } else if (overwrite || !(key in target)) {
	              // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	              // NOTE，在 target[key] 不存在的时候也是直接覆盖
	                if (key !== exclude) {
	                    target[key] = zrUtil.clone(source[key], true);
	                }
	            }
	          }
	        }
	        return target;
	    }
	    function Class() {}
	    Class.extend = function(proto) {
	        var base = function() {},
	            member,
	            that = this,
	            subclass = proto && proto.init ? proto.init : function () {
	                that.apply(this, arguments);
	            },
	            fn;
	
	        base.prototype = that.prototype;
	        fn = subclass.fn = subclass.prototype = new base();
	
	        for (member in proto) {
	            if (proto[member] != null && proto[member].constructor === Object) {
	                // Merge object members
	                fn[member] = zrUtil.mergeAll([{}, base.prototype[member], proto[member]],true);
	            } else {
	                fn[member] = proto[member];
	            }
	        }
	
	        fn.constructor = subclass;
	        subclass.extend = that.extend;
	
	        return subclass;
	    };
	
	    module.exports = {
	        inherits: inherits,
	        getUUID: getUUID,
	        distance: distance,
	        getPolylineLength: getPolylineLength,
	        max: max,
	        min: min,
	        isEmpty: isEmpty,
	        mergeOpt: mergeOpt,
	        orthogonalPath: orthogonalPath,
	        polylineIntersectsRectangle: polylineIntersectsRectangle,
	        scorePath: scorePath,
	        forwardPath: forwardPath,
	        traslatePoints: traslatePoints,
	        getEndPoint: getEndPoint,
	        getConnectorPoints: getConnectorPoints,
	        getConnectorControls: getConnectorControls,
	        calculatePoints: calculatePoints,
	        tangentRotation: tangentRotation,
	        collinearity: collinearity,
	        translationMatrix: translationMatrix,
	        scaleMatrix: scaleMatrix,
	        round: enhancedRound,
	        getLength: getLength,
	        getAngle: getAngle,
	        getParentX: getParentX,
	        getParentY: getParentY,
	        getRect: getRect,
	        StackedMap: StackedMap,
	        getMaxLineLength: getMaxLineLength,
	        randomColor: randomColor,
	        template: template,
	        isUndefined: isUndefined,
	        getSoltPoints:getSoltPoints,
	        collinearReduction: collinearReduction,
	        Class:Class
	    };
	


/***/ }),
/* 78 */
/***/ (function(module, exports) {

	
	
	    /**
	      * Creates an instance of a Line. A Line is actually a segment and not a pure
	      * geometrical Line
	      *
	      * @constructor
	      * @this {Line}
	      * @param {Point} startPoint - starting point of the line
	      * @param {Point} endPoint - the ending point of the line
	      **/
	    function Line(startPoint, endPoint){
	        /**Starting {@link Point} of the line*/
	        this.startPoint = startPoint;
	
	        /**Ending {@link Point} of the line*/
	        this.endPoint = endPoint;
	
	        /**Serialization type*/
	        this.oType = 'Line'; //object type used for JSON deserialization
	    }
	
	    /**Creates a {Line} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Line} a newly constructed Line
	     **/
	    Line.load = function(o){
	        var newLine = new Line(
	            Point.load(o.startPoint),
	            Point.load(o.endPoint)
	        );
	
	        return newLine;
	    };
	
	    Line.prototype = {
	        contructor: Line,
	
	
	
	        clone:function(){
	            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());
	            return ret;
	        },
	
	        equals:function(anotherLine){
	            if(!anotherLine instanceof Line){
	                return false;
	            }
	            return this.startPoint.equals(anotherLine.startPoint)
	            && this.endPoint.equals(anotherLine.endPoint)
	        },
	
	        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)
	         * Algorithm: Compute line's equation and see if (x, y) verifies it.
	         * @param {Number} x - the X coordinates
	         * @param {Number} y - the Y coordinates
	         **/
	        contains: function(x, y){
	            // if the point is inside rectangle bounds of the segment
	            if (Math.min(this.startPoint.x, this.endPoint.x) <= x
	                && x <= Math.max(this.startPoint.x, this.endPoint.x)
	                && Math.min(this.startPoint.y, this.endPoint.y) <= y
	                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {
	
	                // check for vertical line
	                if (this.startPoint.x == this.endPoint.x) {
	                    return x == this.startPoint.x;
	                } else { // usual (not vertical) line can be represented as y = a * x + b
	                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);
	                    var b = this.startPoint.y - a * this.startPoint.x;
	                    return y == a * x + b;
	                }
	            } else {
	                return false;
	            }
	        },
	
	        /*
	         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)
	         *@param {Number} x - the x coordinates
	         *@param {Number} y - the y coordinates
	         *@param {Number} radius - the radius to search for
	         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	         *@see "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	         **/
	        near:function(x,y,radius){
	
	            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle
	                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)
	                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))
	                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;
	            }
	
	            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle
	                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)
	                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))
	                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;
	            }
	
	
	            var startX = Math.min(this.endPoint.x,this.startPoint.x);
	            var startY = Math.min(this.endPoint.y,this.startPoint.y);
	            var endX = Math.max(this.endPoint.x,this.startPoint.x);
	            var endY = Math.max(this.endPoint.y,this.startPoint.y);
	
	            /*We will compute the distance from point to the line
	             * by using the algorithm from
	             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	             * */
	
	            //First we need to find a,b,c of the line equation ax + by + c = 0
	            var a = this.endPoint.y - this.startPoint.y;
	            var b = this.startPoint.x - this.endPoint.x;
	            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);
	
	            //Secondly we get the distance "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );
	
	            //Thirdly we get coordinates of closest line's point to target point
	            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates
	            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	
	            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment
	                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment
	
	            return  r;
	
	        },
	
	        /**we need to create a new array each time, or we will affect the actual shape*/
	        getPoints:function(){
	            var points = [];
	            points.push(this.startPoint);
	            points.push(this.endPoint);
	            return points;
	        },
	
	        /**Return the {Point} corresponding the t certain t value
	         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/
	        getPoint: function(t){
	            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;
	            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;
	
	            return new Point(Xp, Yp);
	        },
	
	        // /**
	        //  * Returns the middle of the line
	        //  * @return {Point} the middle point
	        //  * */
	        // getMiddle : function(){
	        //     return Util.getMiddle(this.startPoint, this.endPoint);
	        // },
	
	
	        // getLength : function(){
	        //     return Util.getLength(this.startPoint, this.endPoint);
	        // },
	
	        // /**
	        //  *Get bounds for this line
	        //  *@author Alex Gheorghiu <alex@scriptoid.com>
	        //  **/
	        // getBounds:function(){
	        //     return Util.getBounds(this.getPoints());
	        // },
	
	        /**String representation*/
	        toString:function(){
	            return 'line(' + this.startPoint + ',' + this.endPoint + ')';
	        }
	    };
	    module.exports = Line;
	
	


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * BPMN节点类  所有的BPMN形状都继承与它，用户自定义节点可以继承它并注册即可使用
	 * @class fish.topo.FishTopoBpmn.BPMNNode
	 */
	
	
		var Node = __webpack_require__(80);
		var zrUtil = __webpack_require__(4);
		var graphic = __webpack_require__(3);
	    var clazzUtil = __webpack_require__(81);
		//创建Node类 所有形状都继承Node
		function BPMNNode(model, api) {
			Node.call(this);
			this.model = model;
			this.options =
			{
				outline: {
					enable: true, // 是否有外框
					radius: true, // 是否圆角
					initVisible: false
				},
				text: {
					color: '#000000', // 文本颜色
					lineHeight: 24 // 文本行高
				}
			};
			this.bpmnInfo = {type: -1, name:"BPMNDiagram", displayName:"Task" };    //节点信息
			var resourceId = model.get("resourceId");
			if(resourceId && resourceId != "") {
				this.resourceId = resourceId;
			}
	
	        //判断是否有operationNode
	        var prop = model.get("properties");
	        if (prop.operationIcons) {
	            this.operationIcons = prop.operationIcons;
	        }
			this.initEvent(api);
	    }
	    
	    function utf8Length(str) {
	        var m = encodeURIComponent(str).match(/%[89ABab]/g);
	        return str.length + (m ? m.length : 0);
	    }
	
	    BPMNNode.prototype.initEvent = function(api) {
	        var that = this;
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'
	
	
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            that.on(eveName, function (e) {
		            var params = {};
		            params.event = e;
		            params.type = eveName;
		            params.target = that;
		            api.trigger(eveName, params);
	            }, this);
	        });
	    };
	
	    /**
	     * 获取当前节点的包围和 相关参数
	     * @returns {{x:Number, y:Number, width:Number, height:Number, points:Array, boundingRect:Object}}
	     * @returns {Number} return.x 当前节点的中心点x值
	     * @returns {Number} return.y 当前节点的中心点y值
	     * @returns {Number} return.width 当前节点的宽度
	     * @returns {Number} return.height 当前节点的高度
	     * @returns {Array} return.points 当前节点的包围和 [左上角坐标，右上角坐标，右下角坐标，右下角坐标] 用于节点选中时包围虚线框
	     * @returns {Object} return.boundingRect 当前节点的包围矩形
	     */
	    BPMNNode.prototype.getRect = function() {
	    };
	
	    /**
	     * 返回当前节点的包围矩形
	     * @return {Object} 当前节点的包围矩形  一般不包括下面的文字
	     */
	    BPMNNode.prototype.getBoundingRect = function() {
	    };
	
	    /**
	     * 设置图元的位置
	     * @param {Number} x x坐标
	     * @param {Number} y y坐标
	     */
	    BPMNNode.prototype.setPosition  = function(x, y) {
	    };
	
	    /**
	     * @private
	     * 查看当前节点是否 包括x ,y 坐标
	     * @param  {number} x x坐标
	     * @param  {number} y y坐标
	     * @return {Boolean}   是否在范围内
	     */
	    BPMNNode.prototype.rectContain = function(x, y) {
	    	var rect = this.getRect();
	        return rect.boundingRect.contain(x,y);
	    };
	
	    /**
	     * 返回json对象
	     * @return {String} json对象
	     */
		BPMNNode.prototype.toJSON = function() {
			this.model.set("resourceId", this.resourceId);
			this.model.set("properties.type", this.bpmnInfo.type);
			this.model.set("stencil.type", this.bpmnInfo.name);  //stencil.id
	
	        if (this.slotEvent && this.slotEvent.length > 0) {
	            var arrSlotEvent = [];
	            for (var i = this.slotEvent.length - 1; i >= 0; i--) {
	                arrSlotEvent.push(this.slotEvent[i].resourceId)
	            }
	            this.model.set("properties.slotEvent", arrSlotEvent);
	        }
	        this.model.set("properties.type", this.bpmnInfo.type);
	
	        var rect = this.getRect().boundingRect;
	        this.model.set("bounds.upperLeft.x", parseInt(rect.x));
	        this.model.set("bounds.upperLeft.y", parseInt(rect.y));
	        this.model.set("bounds.lowerRight.x", parseInt(rect.x + rect.width));
	        this.model.set("bounds.lowerRight.y", parseInt(rect.y + rect.height));
			return this.model.option;
		};
	
		/**
	     * @private
	     * 根据属性设置模型数据
	     * @param {Object} option 模型数据
	     */
	    BPMNNode.prototype.setModel = function(option) {
	        var that = this, pos;
	        var originText = this.model.get("properties.name");
	        this.model.mergeOption(option);
	
	        function parentX(node) {
	            if (node.parent && node.parent.nodeType == "SubProcess") {
	                return node.position[0] + parentX(node.parent)
	            } else {
	                return node.position[0]
	            }
	        }
	    
	        function parentY(node) {
	            if (node.parent && node.parent.nodeType == "SubProcess") {
	                return node.position[1] + parentY(node.parent)
	            } else {
	                return node.position[1]
	            }
	        }
	
	        if(!option.properties.name && option.properties.name != '' && option.properties.name != '0') {
	            return;
	        }
	        if(originText != option.properties.name) {
	            var title = this.childOfName("Title");
	            var nameByteLength = utf8Length(option.properties.name);
	            var showName;
	            if(nameByteLength > 15){
	                showName = option.properties.name.substr(0,6)+'..';
	                if(this.alarm){
	                    this.alarm.isShow = true;
	                }
	            }else{
	                showName = option.properties.name;
	                if(this.alarm){
	                    this.alarm.isShow = false;
	                }
	
	            }
	            title.attr("style",{text:showName});
	            pos = option.properties.position ? option.properties.position : 'init';
	            that.refreshText(pos);
	           if(this.alarm) {
	                var name = option.properties.name;
	                var text = this.alarm.childOfName("Text");
	                text.attr("style",{text:name});
	                var groupWidth = text.getBoundingRect().width+4;
	                var groupHeight = text.getBoundingRect().height+8;
	                var points = [
	                    [0,0],
	                    [groupWidth,0],
	                    [groupWidth,groupHeight],
	                    [groupWidth-3,groupHeight],
	                    [groupWidth-6,groupHeight+3],
	                    [groupWidth-9,groupHeight],
	                    [0,groupHeight],
	                    [0,0]
	                ];
	                var Polyline = this.alarm.childOfName("Polyline");
	                Polyline.attr("shape",{points:points});
	                var posX = parentX(this), posY = parentY(this);
	                var groupPosition = [posX + this.getBoundingRect().width - (this.alarm.getBoundingRect().width-6), posY - this.alarm.getBoundingRect().height - 3];
	                this.alarm.attr("position",groupPosition);
	           }
	        }
	    };
	
	
		zrUtil.inherits(BPMNNode,Node);
	
	    /**
	     * 注册BPMN节点的类，只有注册过后，才能在BPMN编辑器中添加
	     * @method registerClass
	     * @param {Object} Clazz 继承了BPMNNode的实现类
	     * @param {String} componentType 注册类的名称
	     *
	     * **使用范例**：
	     *
	     *     @example
	     *     BPMNNode.registerClass(CustomNode, "CustomNode");
	     */
		clazzUtil.enableClassManagement(BPMNNode, {
	        registerWhenExtend: true
	    });
		module.exports = BPMNNode;
	
	
	


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var graphic = __webpack_require__(3);
	    var util = __webpack_require__(77)
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    function Node() {
	        this.resourceId = util.getUUID(); // 生成节点ID
	        graphic.Group.call(this);
	    }
	
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.render = function() {};
	
	    /**
	     * 由父类实现
	     * @param  {[type]} json [description]
	     * @return {[type]}      [description]
	     */
	    Node.prototype.getRect = function(json) {};
	
	    /**
	     * drawText
	     * @description 画一个文本
	     * @param {string} name
	     * @param {string} color
	     */
	    Node.prototype.drawText = function(name, color, position) {
	        var textName = this.bpmnInfo.name, x, y;
	        if(name != null){
	            textName = name;
	        }
	        var text = new graphic.Text({
	            style: {
	                text: textName,
	                color: color ? color : this.options.text.color,
	                textFont: '12px Microsoft YaHei'
	            },
	            zlevel: 20
	        });
	        //文字绘制的位置 
	        position = position ? position : 'init';
	        switch (position) {
	            //节点下方居中位置
	            case 'init': 
	                //x = 中心点.x - 起始位置.x - 文字宽度的一半
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                //y = 中心点.y - 起始位置.y + 偏移值（6）
	                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;
	                break;
	            //节点内部居中位置
	            case 'center':
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            //节点内部居左位置
	            case 'left': 
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width + 6;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            default: break;
	        }
	        text.attr("style", { x: x, y: y });
	        return {
	            text: text,
	            rect: text.getBoundingRect()
	        };
	    };
	    /**
	     * refreshText
	     * @description 刷新文本
	     */
	    Node.prototype.refreshText = function(pos) {
	        var text = this.childOfName("Title"), x, y;
	        pos = pos ? pos : 'init';
	        switch (pos) {
	            case 'init': 
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;
	                break;
	            case 'center':
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            case 'left':
	                x = 2;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            default: break;
	        }
	        text.attr("style", { x: x, y: y });
	    };
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.toJSON = function() {};
	
	    graphic.Util.inherits(Node, graphic.Group);
	    module.exports = Node;
	


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var zrUtil = __webpack_require__(4);
	
	    var clazz = {};
	
	    var TYPE_DELIMITER = '.';
	    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';
	    /**
	     * @public
	     */
	    var parseClassType = clazz.parseClassType = function (componentType) {
	        var ret = {main: '', sub: ''};
	        if (componentType) {
	            componentType = componentType.split(TYPE_DELIMITER);
	            ret.main = componentType[0] || '';
	            ret.sub = componentType[1] || '';
	        }
	        return ret;
	    };
	    /**
	     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数
	     */
	    clazz.enableClassExtend = function (RootClass, preConstruct) {
	        RootClass.extend = function (proto) {
	            var ExtendedClass = function () {
	                preConstruct && preConstruct.apply(this, arguments);
	                RootClass.apply(this, arguments);
	            };
	
	            zrUtil.extend(ExtendedClass.prototype, proto);
	
	            ExtendedClass.extend = this.extend;
	            ExtendedClass.superCall = superCall;
	            ExtendedClass.superApply = superApply;
	            zrUtil.inherits(ExtendedClass, this);
	            ExtendedClass.superClass = this;
	
	            return ExtendedClass;
	        };
	    };
	
	    // superCall should have class info, which can not be fetch from 'this'.
	    // Consider this case:
	    // class A has method f,
	    // class B inherits class A, overrides method f, f call superApply('f'),
	    // class C inherits class B, do not overrides method f,
	    // then when method of class C is called, dead loop occured.
	    function superCall(context, methodName) {
	        var args = zrUtil.slice(arguments, 2);
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    function superApply(context, methodName, args) {
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    /**
	     * @param {Object} entity
	     * @param {Object} options
	     * @param {boolean} [options.registerWhenExtend]
	     * @public
	     */
	    clazz.enableClassManagement = function (entity, options) {
	        options = options || {};
	
	        /**
	         * Component model classes
	         * key: componentType,
	         * value:
	         *     componentClass, when componentType is 'xxx'
	         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
	         * @type {Object}
	         */
	        var storage = {};
	
	        entity.registerClass = function (Clazz, componentType) {
	            if (componentType) {
	                componentType = parseClassType(componentType);
	
	                if (!componentType.sub) {
	                    if (storage[componentType.main]) {
	                        //已经注册过了，直接返回
	                        return;
	                    }
	                    storage[componentType.main] = Clazz;
	                }
	                else if (componentType.sub !== IS_CONTAINER) {
	                    var container = makeContainer(componentType);
	                    container[componentType.sub] = Clazz;
	                }
	            }
	            return Clazz;
	        };
	
	        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {
	            var Clazz = storage[componentTypeMain];
	
	            if (Clazz && Clazz[IS_CONTAINER]) {
	                Clazz = subType ? Clazz[subType] : null;
	            }
	
	            if (throwWhenNotFound && !Clazz) {
	                throw new Error(
	                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'
	                );
	            }
	
	            return Clazz;
	        };
	
	        entity.getClassesByMainType = function (componentType) {
	            componentType = parseClassType(componentType);
	
	            var result = [];
	            var obj = storage[componentType.main];
	
	            if (obj && obj[IS_CONTAINER]) {
	                zrUtil.each(obj, function (o, type) {
	                    type !== IS_CONTAINER && result.push(o);
	                });
	            }
	            else {
	                result.push(obj);
	            }
	
	            return result;
	        };
	
	        entity.hasClass = function (componentType) {
	            // Just consider componentType.main.
	            componentType = parseClassType(componentType);
	            return !!storage[componentType.main];
	        };
	
	        /**
	         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
	         */
	        entity.getAllClassMainTypes = function () {
	            var types = [];
	            zrUtil.each(storage, function (obj, type) {
	                types.push(type);
	            });
	            return types;
	        };
	
	        /**
	         * If a main type is container and has sub types
	         * @param  {string}  componentType
	         * @return {boolean}
	         */
	        entity.hasSubTypes = function (componentType) {
	            componentType = parseClassType(componentType);
	            var obj = storage[componentType.main];
	            return obj && obj[IS_CONTAINER];
	        };
	
	        entity.parseClassType = parseClassType;
	
	        function makeContainer(componentType) {
	            var container = storage[componentType.main];
	            if (!container || !container[IS_CONTAINER]) {
	                container = storage[componentType.main] = {};
	                container[IS_CONTAINER] = true;
	            }
	            return container;
	        }
	
	        if (options.registerWhenExtend) {
	            var originalExtend = entity.extend;
	            if (originalExtend) {
	                entity.extend = function (proto) {
	                    var ExtendedClass = originalExtend.call(this, proto);
	                    return entity.registerClass(ExtendedClass, proto.type);
	                };
	            }
	        }
	
	        return entity;
	    };
	
	    module.exports = clazz;
	


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * BPMN model
	 *
	 */
	
	
	    var Model = __webpack_require__(83);
	    var BPMNModel = Model.extend({
	
	        type: 'BPMN',
	        /**
	         * @type {Object}
	         * @protected
	         */
	        defaultOption: {
	            resourceId: "",  //资源ID
	
	            properties: {
	                type: -1,  //类型
	                name: null, //名称
	                notes: "",  //备注
	                //no: ""
	                extProperties: {}  //扩展属性
	            },
	
	            stencil: {type: "BPMNDiagram"},
	
	            childShapes: [],    //子形状
	
	            outgoing: [],  // 下一个要连接的形状
	
	            bounds: {
	                upperLeft: {x:0, y:0},  //左上角坐标
	                lowerRight: {x:0, y:0} //右下角坐标
	            }
	        }
	    });
	    module.exports = BPMNModel;
	
	


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 节点等的模型
	 * 里面存的数据用来处理序列化和反序列化
	 * @class fish.topo.model
	 */
	
	
	    var zrUtil = __webpack_require__(4);
	    var clazzUtil = __webpack_require__(81);
	
	    function Model(option, parentModel,  extraOpt) {
	        this.parentModel = parentModel;
	        this.option = option;
	
	        // Simple optimization
	        if (this.init) {
	            if (arguments.length <= 3) {
	                this.init(option, parentModel,  extraOpt);
	            }
	            else {
	                this.init.apply(this, arguments);
	            }
	        }
	    }
	
	    Model.prototype = {
	
	        constructor: Model,
	
	        /**
	         * Model 的初始化函数
	         * @private
	         * @param {Object} option
	         */
	        init: function (option) {
	            zrUtil.merge(option, this.getDefaultOption());
	        },
	
	        getDefaultOption: function () {
	            if (!this.hasOwnProperty('__defaultOption')) {
	                var optList = [];
	                var Class = this.constructor;
	                while (Class) {
	                    var opt = Class.prototype.defaultOption;
	                    opt && optList.push(opt);
	                    Class = Class.superClass;
	                }
	
	                var defaultOption = {};
	                for (var i = optList.length - 1; i >= 0; i--) {
	                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);
	                }
	                this.__defaultOption = defaultOption;
	            }
	            return this.__defaultOption;
	        },
	
	        /**
	         * @private
	         */
	        mergeOption: function (option) {
	            zrUtil.merge(this.option, option, true);
	        },
	
	        /**
	         * 获取model的某个属性的值
	         * @param {string} path model中的属性
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.get("options.text");
	         */
	        get: function (path, ignoreParent) {
	            if (!path) {
	                return this.option;
	            }
	
	            if (typeof path === 'string') {
	                path = path.split('.');
	            }
	
	            var obj = this.option;
	            var parentModel = this.parentModel;
	            for (var i = 0; i < path.length; i++) {
	                // obj could be number/string/... (like 0)
	                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;
	                if (obj == null) {
	                    break;
	                }
	            }
	            if (obj == null && parentModel && !ignoreParent) {
	                obj = parentModel.get(path);
	            }
	            return obj;
	        },
	
	        /**
	         * 设置model的某个属性的值
	         * @param {string} path model中的属性
	         * @param {String} value 所需要设置的值
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.set("options.text","例子");
	         */
	        set: function (path, value) {
	            var obj = this.option;
	
	            if (path.indexOf(".") == -1) {
	                obj[path] = value;
	            } else {
	                var fieldArray  = path.split('.');
	                var n = fieldArray.length;
	                var currentRef = obj;
	                var fieldName;
	
	                for (var i = 0; i < n - 1; i++) {
	                    fieldName = fieldArray[i];
	                    if(currentRef[fieldName] == null) {
	                        currentRef[fieldName] = {};
	                    }
	                    currentRef = currentRef[fieldName];
	                }
	                fieldName = fieldArray[n-1];
	                currentRef[fieldName] = value;
	            }
	        },
	
	        /**
	         * @private
	         */
	        getShallow: function (key, ignoreParent) {
	            var option = this.option;
	            var val = option && option[key];
	            var parentModel = this.parentModel;
	            if (val == null && parentModel && !ignoreParent) {
	                val = parentModel.getShallow(key);
	            }
	            return val;
	        },
	
	        /**
	         * @private
	         */
	        getModel: function (path, parentModel) {
	            var obj = this.get(path, true);
	            var thisParentModel = this.parentModel;
	            var model = new Model(
	                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))
	            );
	            return model;
	        },
	
	        /**
	         *清空model的option
	         * @private
	         */
	        isEmpty: function () {
	            return this.option == null;
	        },
	
	        restoreData: function () {},
	
	        /**
	         * @private
	         */
	        clone: function () {
	            var Ctor = this.constructor;
	            return new Ctor(zrUtil.clone(this.option));
	        }
	    };
	
	    // Enable Model.extend.
	    clazzUtil.enableClassExtend(Model);
	
	    module.exports = Model;
	


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	
		var EventNode = __webpack_require__(85);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
		function StartEventNode(model, api) {
			EventNode.call(this, model, api);
	        this.itemSize = 18;
	        this.model = model;
			this.bpmnInfo = {type: 29, name:"StartNoneEvent" };    //节点信息
	        this.render(model);
		}
	
	    StartEventNode.prototype.render = function(model) {
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-0.5
	            },
	            style: {
	                fill: '#000'
	            },
	            z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-2
	            },
	            style: {
	                fill: '#fff'
	            },
	            z:2
	        });
	        circle1.name = "Circle1";
	        this.add(circle1);
	        this.position = [model.get("bounds.upperLeft.x") + this.itemSize, model.get("bounds.upperLeft.y") + this.itemSize];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	
	    };
	
		zrUtil.inherits(StartEventNode, EventNode);
		module.exports = StartEventNode;
	


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var BPMNNode = __webpack_require__(79);
	    var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(26);
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    //
	    function EventNode(model,api) {
	        BPMNNode.call(this, model, api);
	        this.bpmnInfo = {type: -1, name:"EventNode" };    //节点信息
	        this.model = model;
	
	    }
	
	    EventNode.prototype.render = function() {
	
	    };
	
	
	    EventNode.prototype.getRect = function() {
	        // body...
	        var boundingRect = this.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	
	        //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半
	        var boundRect = new BoundingRect(this.position[0] - boundingRect.width/2 ,
	                                         this.position[1] - boundingRect.height/2,
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0],
	            y: this.position[1],
	            width: boundingRect.width/2,
	            height: boundingRect.height/2,
	            points: points,
	            boundingRect: boundRect
	        };
	
	    };
	    EventNode.prototype.setPosition = function(pX,pY) {
	        // body...
	        this.attr('position',[pX,pY]);
	    };
	
	    EventNode.prototype.getBoundingRect = function() {
	        var circle = this.childOfName("Circle");
	        return circle.getBoundingRect();
	    };
	
	    EventNode.prototype.updateShape = function(ratio, ifParse) {
	        var circle = this.childOfName("Circle");
	        var circle1 = this.childOfName("Circle1");
	        var scaleRatio = Number(ratio);
	        var shape = circle.shape;
	        var shape1 = circle1.shape;
	        var newR = Number(shape.r * scaleRatio);
	        var newR1 = Number(shape1.r * scaleRatio);
	        if (ifParse) {
	            newR = parseInt(newR, 10);
	            newR1 = parseInt(newR1, 10);
	        }
	        circle.setShape({
	            r: newR
	        });
	        circle1.setShape({
	            r: newR1
	        });
	    };
	
	
	    zrUtil.inherits(EventNode,BPMNNode);
	    module.exports = EventNode;
	


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	
		var EventNode = __webpack_require__(85);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
		function EndEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.itemSize = 18;
	        this.model = model;
			this.bpmnInfo = {type: 31, name:"EndNoneEvent" };
	        this.render(model);
		}
	
	    EndEventNode.prototype.render = function(model) {
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-0.5
	            },
	            style: {
	                fill: '#000'
	            },
	            z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-5
	            },
	            style: {
	                fill: '#fff'
	            },
	            z:2
	        });
	        circle1.name = "Circle1";
	        this.add(circle1);
	        this.position = [model.get("bounds.upperLeft.x") + this.itemSize, model.get("bounds.upperLeft.y") + this.itemSize];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	
	    };
	
		zrUtil.inherits(EndEventNode, EventNode);
		module.exports = EndEventNode;
	


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	
		var TaskNode = __webpack_require__(88);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 * <g pointer-events="fill" minimumSize="85 55" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6D" title="User task">
	 *   <rect id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Dtext_frame" anchors="bottom top right left" x="1.000000059837755" y="1.0162024924" width="72" height="22.000000000000004" rx="7" ry="7" stroke="none" stroke-width="0" fill="none">
	 *   </rect>
	 *   <rect id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Dbg_frame" resize="vertical horizontal" x="5.98377549e-8" y="0.0162024924" width="85" height="55" rx="7" ry="7" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9">
	 *   </rect>
	 *   <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Darea_state" anchors="bottom" x="5.98377549e-8" y="45.0162024924" width="85" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style="">
	 *   </rect>
	 *   <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Dtext_name" x="52" y="35" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 52 35)" oryx:fontSize="12" text-anchor="middle">
	 *       <tspan x="52" y="35" dy="5">Task
	 *       </tspan>
	 *   </text>
	 *   <g id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6DuserTask" transform="translate(5.000000, 5.000000)" fill="#4990E2">
	 *       <path anchors="top left" d=" M4.689754749837755 0.7547497214000001  C3.124908639837755 1.5094994424 2.536902989837755 2.8359404524 3.0388532998377547 5.3878194723999995  C3.540803599837755 7.9396985024 4.256854379837756 7.9729218124 4.689754749837755 8.9207625924  C5.122655119837755 9.868603372399999 4.8340548898377556 10.6706224924 3.8239538798377546 11.1080874924  C2.813852879837755 11.5455524924 1.1967550949999999e-7 12.8579473924 5.98377549e-8 13.5870556924  C0 14.3161639924 1.226551289837755 14.2432530924 2.3088023698377547 14.2432530924  C3.391053449837755 14.2432530924 9.090909149837755 14.2432530924 9.090909149837755 14.2432530924  L9.163059219837754 0.5237704804000001  C9.163059219837754 0.5237704804000001 6.254600859837756 0 4.689754749837755 0.7547497214000001  z" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6DPath-14">
	 *       </path>
	 *       <path anchors="top left" d=" M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6DPath-14-Copy">
	 *       </path>
	 *   </g>
	 * </g>
	 */
	
	    function UserTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "M765.573741 718.489888c-14.999622-112.659873-119.671567-196.438974-237.776452-196.438974-118.912273 0-220.514299 85.277222-238.20317 198.770066-11.840676 76.071559 54.585199 71.326489 54.585199 71.326489l360.734878 0C704.913173 792.148491 776.608052 801.364387 765.573741 718.489888zM690.249195 365.718379c0 89.911776-72.889077 162.810063-162.79676 162.810063-89.908706 0-162.797783-72.898287-162.797783-162.810063 0-89.916892 72.889077-162.80597 162.797783-162.80597C617.360118 202.912409 690.249195 275.801487 690.249195 365.718379z";
	        this.bpmnInfo = {type: 0, name:"UserTask" };    //节点信息
	        this.render(model);
	    }
	
	    UserTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#fff',
	                stroke: '#000'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconRect = {x:5, y: 5, width: 15, height:15};
	        var pathIcon = graphic.makePath(this.iconPath, {style: {fill: '#fff', stroke: '#000'},z:2}, iconRect);
	        this.add(pathIcon);
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"), '', 'center');
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
	
	
		zrUtil.inherits(UserTaskNode,TaskNode);
		module.exports = UserTaskNode;
	


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	
		var BPMNNode = __webpack_require__(79);
		var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(26);
		//创建Node类 所有形状都继承Node
		//
		function TaskNode(model, api) {
	
			BPMNNode.call(this, model, api);
			this.bpmnInfo = {type: -1, name:"TaskNode" };    //节点信息
	        this.model = model;
	        this.slot = [];
	        this.slotEvent = [];
	        this.isCanSlot = true;  //用于控制本节点是否可以被插槽
		}
	
	    TaskNode.prototype.render = function() {
	
	    };
	
	    TaskNode.prototype.getRect = function() {
	        var boundingRect = this.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	
	        var boundRect = new BoundingRect(this.position[0] ,
	                                         this.position[1],
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0]+boundingRect.width/2,
	            y: this.position[1]+boundingRect.height/2,
	            width: boundingRect.width,
	            height: boundingRect.height,
	            points: points,
	            boundingRect: boundRect
	        };
	    };
	
	    TaskNode.prototype.getBoundingRect = function() {
	        var rect = this.childOfName("Rect");
	        return rect.getBoundingRect();
	    };
	
	    TaskNode.prototype.setPosition = function(pX,pY) {
	        var boundingRect = this.getBoundingRect();
	        this.attr('position',[pX-boundingRect.width/2,pY-boundingRect.height/2]);
	
	    };
	
	    TaskNode.prototype.updateShape = function(ratio, ifParse) {
	        var rect = this.childOfName("Rect");
	        var scaleRatio = Number(ratio);
	        var shape = rect.shape;
	        var newW = Number(shape.width * scaleRatio);
	        var newH = Number(newW * shape.height / shape.width);
	        if (ifParse) {
	            newW = parseInt(newW, 10);
	            newH = parseInt(newH, 10);
	        }
	        rect.setShape({
	            width: newW,
	            height: newH
	        });
	        this.refreshText();
	    };
	
		zrUtil.inherits(TaskNode,BPMNNode);
		module.exports = TaskNode;
	


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	//ManualTask节点
	
		var TaskNode = __webpack_require__(88);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 *  <g pointer-events="fill" minimumSize="82 42" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825" title="Manual task">
	 *     <rect id="sid-A9545224-4CAE-450D-893D-12CFA7E68825text_frame" anchors="bottom top right left" x="1" y="1" width="74" height="39" rx="10" ry="10" stroke="none" stroke-width="0" fill="none"></rect>
	 *     <rect id="sid-A9545224-4CAE-450D-893D-12CFA7E68825bg_frame" resize="vertical horizontal" x="0" y="0" width="80" height="40" rx="10" ry="10" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9"></rect>
	 *     <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825area_state" anchors="bottom" x="0" y="30" width="80" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style=""></rect>
	 *     <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825text_name" x="43" y="24" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 43 24)" oryx:fontSize="12" text-anchor="middle"><tspan x="43" y="24" dy="5">Task</tspan></text>
	 *     <g id="sid-A9545224-4CAE-450D-893D-12CFA7E68825manualTask" transform="translate(3,1) scale(0.8)">
	 *     <path anchors="top left" style="fill:#d1b575;stroke=none" d="m 17,9.3290326 c -0.0069,0.5512461 -0.455166,1.0455894 -0.940778,1.0376604 l -5.792746,0 c 0.0053,0.119381 0.0026,0.237107 0.0061,0.355965 l 5.154918,0 c 0.482032,-0.0096 0.925529,0.49051 0.919525,1.037574 -0.0078,0.537128 -0.446283,1.017531 -0.919521,1.007683 l -5.245273,0 c -0.01507,0.104484 -0.03389,0.204081 -0.05316,0.301591 l 2.630175,0 c 0.454137,-0.0096 0.872112,0.461754 0.866386,0.977186 C 13.619526,14.554106 13.206293,15.009498 12.75924,15 L 3.7753054,15 C 3.6045812,15 3.433552,14.94423 3.2916363,14.837136 c -0.00174,0 -0.00436,0 -0.00609,0 C 1.7212035,14.367801 0.99998255,11.458641 1,11.458641 L 1,7.4588393 c 0,0 0.6623144,-1.316333 1.8390583,-2.0872584 1.1767614,-0.7711868 6.8053358,-2.40497 7.2587847,-2.8052901 0.453484,-0.40032 1.660213,1.4859942 0.04775,2.4010487 C 8.5332315,5.882394 8.507351,5.7996113 8.4370292,5.7936859 l 6.3569748,-0.00871 c 0.497046,-0.00958 0.952273,0.5097676 0.94612,1.0738232 -0.0053,0.556126 -0.456176,1.0566566 -0.94612,1.0496854 l -4.72435,0 c 0.01307,0.1149374 0.0244,0.2281319 0.03721,0.3498661 l 5.952195,0 c 0.494517,-0.00871 0.947906,0.5066305 0.940795,1.0679848 z" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825_sid-A9545224-4CAE-450D-893D-12CFA7E68825_17"></path>
	 *     </g>
	 * </g>
	 */
	    function ManualTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "m 17,9.3290326 c -0.0069,0.5512461 -0.455166,1.0455894 -0.940778,1.0376604 l -5.792746,0 c 0.0053,0.119381 0.0026,0.237107 0.0061,0.355965 l 5.154918,0 c 0.482032,-0.0096 0.925529,0.49051 0.919525,1.037574 -0.0078,0.537128 -0.446283,1.017531 -0.919521,1.007683 l -5.245273,0 c -0.01507,0.104484 -0.03389,0.204081 -0.05316,0.301591 l 2.630175,0 c 0.454137,-0.0096 0.872112,0.461754 0.866386,0.977186 C 13.619526,14.554106 13.206293,15.009498 12.75924,15 L 3.7753054,15 C 3.6045812,15 3.433552,14.94423 3.2916363,14.837136 c -0.00174,0 -0.00436,0 -0.00609,0 C 1.7212035,14.367801 0.99998255,11.458641 1,11.458641 L 1,7.4588393 c 0,0 0.6623144,-1.316333 1.8390583,-2.0872584 1.1767614,-0.7711868 6.8053358,-2.40497 7.2587847,-2.8052901 0.453484,-0.40032 1.660213,1.4859942 0.04775,2.4010487 C 8.5332315,5.882394 8.507351,5.7996113 8.4370292,5.7936859 l 6.3569748,-0.00871 c 0.497046,-0.00958 0.952273,0.5097676 0.94612,1.0738232 -0.0053,0.556126 -0.456176,1.0566566 -0.94612,1.0496854 l -4.72435,0 c 0.01307,0.1149374 0.0244,0.2281319 0.03721,0.3498661 l 5.952195,0 c 0.494517,-0.00871 0.947906,0.5066305 0.940795,1.0679848 z";
	      //  this.iconPath2 = "M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z";
	        this.bpmnInfo = {type: 4, name:"ManualTask" };    //节点信息
	        this.render(model);
	    }
	
	    ManualTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#fff',
	                stroke: '#000'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 15, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#fff', stroke: '#000'},z:2}, iconrect));
	
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"), '', 'center');
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ManualTaskNode,TaskNode);
		module.exports = ManualTaskNode;
	


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	//ScriptTask节点
	
		var TaskNode = __webpack_require__(88);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 *  <g pointer-events="fill" minimumSize="82 42" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D" title="Script task">
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_frame" anchors="bottom top right left" x="1" y="1" width="74" height="39" rx="10" ry="10" stroke="none" stroke-width="0" fill="none"></rect>
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dbg_frame" resize="vertical horizontal" x="0" y="0" width="80" height="40" rx="10" ry="10" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9"></rect>
	 *     <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Darea_state" anchors="bottom" x="0" y="30" width="80" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style=""></rect>
	 *     <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_name" x="43" y="24" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 43 24)" oryx:fontSize="12" text-anchor="middle"><tspan x="43" y="24" dy="5">Task</tspan></text>
	 *     <g id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5DscriptTask" transform="translate(2,2) scale(0.8)">
	 *     <path anchors="top left" d="m 5,2 0,0.094 c 0.23706,0.064 0.53189,0.1645 0.8125,0.375 0.5582,0.4186 1.05109,1.228 1.15625,2.5312 l 8.03125,0 1,0 1,0 c 0,-3 -2,-3 -2,-3 l -10,0 z M 4,3 4,13 2,13 c 0,3 2,3 2,3 l 9,0 c 0,0 2,0 2,-3 L 15,6 6,6 6,5.5 C 6,4.1111 5.5595,3.529 5.1875,3.25 4.8155,2.971 4.5,3 4.5,3 L 4,3 z" style="fill:#72a7d0;stroke:none" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D_sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D_17"></path>
	 *     </g>
	 * </g>
	 */
	    function ScriptTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "m 5,2 0,0.094 c 0.23706,0.064 0.53189,0.1645 0.8125,0.375 0.5582,0.4186 1.05109,1.228 1.15625,2.5312 l 8.03125,0 1,0 1,0 c 0,-3 -2,-3 -2,-3 l -10,0 z M 4,3 4,13 2,13 c 0,3 2,3 2,3 l 9,0 c 0,0 2,0 2,-3 L 15,6 6,6 6,5.5 C 6,4.1111 5.5595,3.529 5.1875,3.25 4.8155,2.971 4.5,3 4.5,3 L 4,3 z";
	      //  this.iconPath2 = "M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z";
	        this.bpmnInfo = {type: 7, name:"ScriptTask" };    //节点信息
	        this.render(model);
	    }
	
	    ScriptTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#fff',
	                stroke: '#000'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 15, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#fff', stroke: '#000'},z:2}, iconrect));
	
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"), '', 'center');
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ScriptTaskNode,TaskNode);
		module.exports = ScriptTaskNode;
	


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	//MailTask节点
	
		var TaskNode = __webpack_require__(88);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 *  <g pointer-events="fill" minimumSize="82 42" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D" title="Script task">
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_frame" anchors="bottom top right left" x="1" y="1" width="74" height="39" rx="10" ry="10" stroke="none" stroke-width="0" fill="none"></rect>
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dbg_frame" resize="vertical horizontal" x="0" y="0" width="80" height="40" rx="10" ry="10" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9"></rect>
	 *     <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Darea_state" anchors="bottom" x="0" y="30" width="80" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style=""></rect>
	 *     <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_name" x="43" y="24" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 43 24)" oryx:fontSize="12" text-anchor="middle"><tspan x="43" y="24" dy="5">Task</tspan></text>
	 *     <g id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5DscriptTask" transform="translate(2,2) scale(0.8)">
	 *        <path anchors="top left" d="M0.332638936,1.17391304 L8.98125126,6.65217391" id="sid-09B97C5E-BEA8-40A2-9F22-3064A2745DBELine" stroke="#FFFFFF" stroke-linecap="square"></path>
	 *        <path anchors="top left" d="M17.5500302,1.17391304 L8.90141792,6.65217391" id="sid-09B97C5E-BEA8-40A2-9F22-3064A2745DBELine-Copy-4" stroke="#FFFFFF" stroke-linecap="square"></path>
	 *	   </g>
	 * </g>
	 */
	    function MailTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "M49.013,51.003c1.847,1.303,7.414,5.174,16.702,11.61S82.118,74.005,87.061,77.48c0.543,0.381,1.697,1.209,3.462,2.485c1.765,1.277,3.232,2.31,4.399,3.097c1.168,0.787,2.58,1.67,4.237,2.647c1.657,0.977,3.219,1.711,4.685,2.198c1.467,0.49,2.825,0.733,4.074,0.733H108h0.082c1.249,0,2.607-0.243,4.074-0.733c1.466-0.487,3.029-1.222,4.685-2.198c1.656-0.978,3.068-1.86,4.236-2.647s2.634-1.82,4.399-3.097s2.92-2.104,3.463-2.485c4.996-3.476,17.707-12.302,38.129-26.479c3.965-2.769,7.277-6.11,9.939-10.021C179.67,37.071,181,32.97,181,28.679c0-3.585-1.291-6.654-3.871-9.207c-2.58-2.553-5.636-3.829-9.165-3.829H48.035c-4.182,0-7.4,1.412-9.654,4.236C36.127,22.704,35,26.235,35,30.471c0,3.422,1.494,7.13,4.481,11.122S45.646,48.722,49.013,51.003z M172.852,59.72c-17.814,12.057-31.34,21.427-40.572,28.108c-3.096,2.281-5.608,4.061-7.537,5.336c-1.928,1.277-4.494,2.58-7.699,3.911c-3.204,1.331-6.191,1.996-8.961,1.996H108h-0.082c-2.77,0-5.758-0.665-8.962-1.996s-5.771-2.634-7.699-3.911c-1.928-1.275-4.44-3.055-7.536-5.336c-7.333-5.377-20.83-14.747-40.492-28.108c-3.096-2.063-5.839-4.427-8.229-7.088v64.688c0,3.586,1.276,6.654,3.829,9.207c2.553,2.554,5.622,3.83,9.207,3.83h119.929c3.584,0,6.653-1.276,9.206-3.83c2.554-2.554,3.829-5.621,3.829-9.207V52.632C178.664,55.238,175.949,57.602,172.852,59.72z";
	      //  this.iconPath2 = "M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z";
	        this.bpmnInfo = {type: 8, name:"MailTask" };    //节点信息
	        this.render(model);
	    }
	
	    MailTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#fff',
	                stroke: '#000'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 15, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#fff', stroke: '#000'},z:2}, iconrect));
	
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"), '', 'center');
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(MailTaskNode,TaskNode);
		module.exports = MailTaskNode;
	


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	
		var TaskNode = __webpack_require__(88);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    
	    function ServiceTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "M891.84 410.072c-8.936-33.48-22.192-65.232-39.192-94.584l74.512-112.4-106.272-106.184-112.344 74.456c-29.384-16.944-61.144-30.256-94.648-39.2L587.08 0l-150.16 0-26.816 132.16c-33.504 8.944-65.264 22.256-94.648 39.2l-112.4-74.456L96.832 203.08l74.52 112.4c-17 29.352-30.256 61.112-39.2 94.648L0 436.888l0 150.192 132.16 26.824c8.944 33.504 22.192 65.264 39.2 94.648l-74.52 112.408 106.216 106.152 112.4-74.456c29.384 16.936 61.144 30.256 94.648 39.192L436.92 1024l150.16 0 26.824-132.16c33.504-8.936 65.264-22.256 94.648-39.192l112.344 74.456 106.272-106.152-74.512-112.408c17-29.384 30.256-61.144 39.192-94.648L1024 587.08 1024 436.888 891.84 410.072 891.84 410.072zM689.8 512c0 98.152-79.584 177.8-177.8 177.8S334.208 610.152 334.208 512c0-98.176 79.584-177.792 177.792-177.792S689.8 413.824 689.8 512z";
	        this.bpmnInfo = {type: 12, name:"ServiceTask" };    //节点信息
	        this.render(model);
	    }
	
	    ServiceTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#fff',
	                stroke: '#000'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 15, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#fff', stroke: '#000'},z:2}, iconrect));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"), '', 'center');
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ServiceTaskNode,TaskNode);
		module.exports = ServiceTaskNode;
	


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	
		var TaskNode = __webpack_require__(88);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    
	    function SmsTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "M959.907775 439.894775c0 195.140399-200.607924 352.909655-447.964568 352.909655-21.76163 0-43.083238-1.203408-64.080457-3.499707-41.555441-4.701069-109.897969 121.601522-300.828486 147.517775 100.164281-117.992321 106.727767-206.485795 74.250074-228.301659C125.053646 643.782396 64.091202 547.553751 64.091202 439.894775c0-194.757682 200.607924-352.717274 447.852004-352.717274C759.299851 87.177502 959.907775 245.13607 959.907775 439.894775z";
	        this.bpmnInfo = {type: 11, name:"SmsTask" };    //节点信息
	        this.render(model);
	    }
	
	    SmsTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#fff',
	                stroke: '#000'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 15, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#fff', stroke: '#000'},z:2}, iconrect));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"), '', 'center');
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(SmsTaskNode,TaskNode);
		module.exports = SmsTaskNode;
	


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	
		var BPMNNode = __webpack_require__(79);
		var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(26);
	    var graphic = __webpack_require__(3);
	    var imageUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAADIElEQVR4Xu2XwU3DUBQEX/pBaYpG6IKiOEYcKYAGuIYjIkI4UjzxRJ6cv/6uZ0e2cph+uyZw2PXT9/CTADuXIAESYJHAy+KJ9Q98zszr+td24yWBa94A5w2wnWbmuEHu7iITYHeT/37gBEiARQJ9AhYRPe6B3gCPu90qzRNgFYyPe8mtAjzNzPvjPn7NE2DnDiRAAiwS+O9fQJ+ARXzuA70B3Pvg7RIAR+wOSAD3Pni7BMARuwMSwL0P3i4BcMTugARw74O3SwAcsTsgAdz74O0SAEfsDkgA9z54uwTAEbsDEsC9D94uAXDE7oAEcO+Dt0sAHLE7IAHc++DtEgBH7A5IAPc+eLsEwBG7AxLAvQ/eLgFwxO6ABHDvg7dLAByxOyAB3Pvg7RIAR+wOSAD3Pni7BMARuwMSwL0P3i4BcMTugARw74O3SwAcsTsgAdz74O0SAEfsDkgA9z54uwTAEbsDEsC9D94uAXDE7oAEcO+Dt0sAHLE7IAHc++DtEgBH7A5IAPc+eLsEwBG7AxLAvQ/eLgFwxO6ABHDvg7dLAByxOyAB3Pvg7RIAR+wOSAD3Pni7BMARuwMSwL0P3i4BcMTugARw74O3SwAcsTsgAdz74O0SAEfsDkgA9z54uwTAEbsDEsC9D94uAXDE7oAEcO+Dt0sAHLE7IAHc++DtEgBH7A5IAPc+eLsEwBG7AxLAvQ/eLgFwxO6ABHDvg7dLAByxOyAB3Pvg7RIAR+wOSAD3Pni7BMARuwMSwL0P3i4BcMTugARw74O3SwAcsTsgAdz74O0SAEfsDkgA9z54uwTAEbsDEsC9D94uAXDE7oAEcO+Dt0sAHLE7IAHc++DtEgBH7A5IAPc+eLsEwBG7AxLAvQ/eLgFwxO6ABHDvg7dLAByxOyAB3Pvg7RIAR+wOSAD3Pni7BMARuwMSwL0P3i4BcMTugFsFeJuZL+ARP2bmGbi3Ky8I3CoABfQ0M0fq8u79IZAAO7chARJgkcB58cT6B/oErM/0zxt7A9wJtDUmAazL3KnXNQLcqUoxWxBIgC2oizITQDTGFlUSYAvqosxvSbnygcc7wDsAAAAASUVORK5CYII=";
	
	    function CommentNode(model,api) {
	        BPMNNode.call(this, model, api);
	        this.bpmnInfo = {type: 21, name:"Comment" };
	        this.model = model;
	        this.render(model);
	    }
	
	    CommentNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0,
	                y: 0,
	                width: 100,
	                height: 40
	            },
	            style: {
	                opacity: 0
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	        var line = new graphic.Line({
	            shape: {x1:0,  y1:0, x2:10, y2:0},
	            style: {lineWidth:1, stroke: "#000"}
	        });
	        this.add(line);
	        var line1 = new graphic.Line({
	            shape: {x1:0,  y1:0, x2:0, y2:40},
	            style: {lineWidth:1, stroke: "#000"}
	        });
	        this.add(line1);
	        var line2 = new graphic.Line({
	            shape: {x1:0,  y1:40, x2:10, y2:40},
	            style: {lineWidth:1, stroke: "#000"}
	        });
	        this.add(line2);
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"), '', 'left');
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
	    CommentNode.prototype.getRect = function(json) {
	        var boundingRect = this.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	
	        var boundRect = new BoundingRect(this.position[0] ,
	                                         this.position[1],
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0]+boundingRect.width/2,
	            y: this.position[1]+boundingRect.height/2,
	            width: boundingRect.width,
	            height: boundingRect.height,
	            points: points,
	            boundingRect: boundRect
	        };
	    };
	    CommentNode.prototype.setPosition = function(pX,pY) {
	        var boundingRect = this.getBoundingRect();
	        this.attr('position',[pX-boundingRect.width/2,pY-boundingRect.height/2]);
	    };
	
	    CommentNode.prototype.getBoundingRect = function() {
	        var rect = this.childOfName("Rect");
	        return rect.getBoundingRect();
	    };
	
	    CommentNode.prototype.updateShape = function(ratio, ifParse) {
	        var rect = this.childOfName("Rect");
	        var scaleRatio = Number(ratio);
	        var shape = rect.shape;
	        var newW = Number(shape.width * scaleRatio);
	        var newH = Number(newW * shape.height / shape.width);
	        if (ifParse) {
	            newW = parseInt(newW, 10);
	            newH = parseInt(newH, 10);
	        }
	        rect.setShape({
	            width: newW,
	            height: newH
	        });
	    };
	
		zrUtil.inherits(CommentNode, BPMNNode);
		module.exports = CommentNode;
	


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	//边界事件---捕获定时器事件节点
	
		var EventNode = __webpack_require__(85);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bbg_frame" cx="16" cy="16" r="15" stroke="#585858" fill="#ffffff" stroke-width="1" style="stroke-dasharray: 5.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2_non_interrupting" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1" style="stroke-dasharray: 4.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe" cx="16" cy="16" r="15" stroke="#585858" fill="none" stroke-width="1"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1"></circle>
	 *    <path id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bpath1" transform="translate(6,6)" d="M 10 0 C 4.4771525 0 0 4.4771525 0 10 C 0 15.522847 4.4771525 20 10 20 C 15.522847 20 20 15.522847 20 10 C 20 4.4771525 15.522847 1.1842379e-15 10 0 z M 9.09375 1.03125 C 9.2292164 1.0174926 9.362825 1.0389311 9.5 1.03125 L 9.5 3.5 L 10.5 3.5 L 10.5 1.03125 C 15.063526 1.2867831 18.713217 4.9364738 18.96875 9.5 L 16.5 9.5 L 16.5 10.5 L 18.96875 10.5 C 18.713217 15.063526 15.063526 18.713217 10.5 18.96875 L 10.5 16.5 L 9.5 16.5 L 9.5 18.96875 C 4.9364738 18.713217 1.2867831 15.063526 1.03125 10.5 L 3.5 10.5 L 3.5 9.5 L 1.03125 9.5 C 1.279102 5.0736488 4.7225326 1.4751713 9.09375 1.03125 z M 9.5 5 L 9.5 8.0625 C 8.6373007 8.2844627 8 9.0680195 8 10 C 8 11.104569 8.8954305 12 10 12 C 10.931981 12 11.715537 11.362699 11.9375 10.5 L 14 10.5 L 14 9.5 L 11.9375 9.5 C 11.756642 8.7970599 11.20294 8.2433585 10.5 8.0625 L 10.5 5 L 9.5 5 z " fill="#585858" stroke="none"></path>
	 * </g>
	 */
	
		function CatchTimerEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.startIcon = 'M 10 0 C 4.4771525 0 0 4.4771525 0 10 C 0 15.522847 4.4771525 20 10 20 C 15.522847 20 20 15.522847 20 10 C 20 4.4771525 15.522847 1.1842379e-15 10 0 z M 9.09375 1.03125 C 9.2292164 1.0174926 9.362825 1.0389311 9.5 1.03125 L 9.5 3.5 L 10.5 3.5 L 10.5 1.03125 C 15.063526 1.2867831 18.713217 4.9364738 18.96875 9.5 L 16.5 9.5 L 16.5 10.5 L 18.96875 10.5 C 18.713217 15.063526 15.063526 18.713217 10.5 18.96875 L 10.5 16.5 L 9.5 16.5 L 9.5 18.96875 C 4.9364738 18.713217 1.2867831 15.063526 1.03125 10.5 L 3.5 10.5 L 3.5 9.5 L 1.03125 9.5 C 1.279102 5.0736488 4.7225326 1.4751713 9.09375 1.03125 z M 9.5 5 L 9.5 8.0625 C 8.6373007 8.2844627 8 9.0680195 8 10 C 8 11.104569 8.8954305 12 10 12 C 10.931981 12 11.715537 11.362699 11.9375 10.5 L 14 10.5 L 14 9.5 L 11.9375 9.5 C 11.756642 8.7970599 11.20294 8.2433585 10.5 8.0625 L 10.5 5 L 9.5 5 z';
	        this.itemSize = 10;
			this.bpmnInfo = {type: 43, name:"CatchTimerEvent" };    //节点信息
	        this.render(model);
		}
	
	    CatchTimerEventNode.prototype.render = function(model) {
	
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-0.5
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:3
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-3
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:3
	        });
	        circle1.name = "Circle1";
	        this.add(circle1);
	
	        var itemSize = this.itemSize+6;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {stroke:'#000'},z:3}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+this.itemSize , model.get("bounds.upperLeft.y")+this.itemSize];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	        this.z = 3;
	    };
	
		zrUtil.inherits(CatchTimerEventNode, EventNode);
		module.exports = CatchTimerEventNode;
	


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	//边界事件---捕获信号量事件
	
		var EventNode = __webpack_require__(85);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bbg_frame" cx="16" cy="16" r="15" stroke="#585858" fill="#ffffff" stroke-width="1" style="stroke-dasharray: 5.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2_non_interrupting" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1" style="stroke-dasharray: 4.5, 3"></circle>
	 *    <path id="sid-3CC33924-73F3-4D13-A2A9-0242530680DEsignalCatching" stroke="#585858" d=" M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z" style="fill:none;stroke-width:1.4;stroke-miterlimit:4;stroke-dasharray:none"></path>
	 * </g>
	 */
	
		function CatchSignalEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.startIcon = 'M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z';
	        this.itemSize = 10;
			this.bpmnInfo = {type: 72, name:"CatchSignalEvent" };    //节点信息
	        this.render(model);
		}
	
	    CatchSignalEventNode.prototype.render = function(model) {
	
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-0.5
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:3
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-3
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:3
	        });
	        circle1.name = "Circle1";
	        this.add(circle1);
	
	        var itemSize = this.itemSize;
	        var rect = {x:-itemSize/2, y: -itemSize/2-2, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {stroke:'#000',fill:'#ffffff'},z:3}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+this.itemSize , model.get("bounds.upperLeft.y")+this.itemSize];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	        this.z = 3;
	    };
	
		zrUtil.inherits(CatchSignalEventNode, EventNode);
		module.exports = CatchSignalEventNode;
	


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	//边界事件---ThrowSignalEvent节点
	
		var EventNode = __webpack_require__(85);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bbg_frame" cx="16" cy="16" r="15" stroke="#585858" fill="#ffffff" stroke-width="1" style="stroke-dasharray: 5.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2_non_interrupting" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1" style="stroke-dasharray: 4.5, 3"></circle>
	 *    <path id="sid-3CC33924-73F3-4D13-A2A9-0242530680DEsignalCatching" stroke="#585858" d=" M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z" style="fill:none;stroke-width:1.4;stroke-miterlimit:4;stroke-dasharray:none"></path>
	 * </g>
	 */
	
		function ThrowSignalEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.startIcon = 'M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z';
	        this.itemSize = 10;
			this.bpmnInfo = {type: 75, name:"ThrowSignalEvent" };    //节点信息
	        this.render(model);
		}
	
	    ThrowSignalEventNode.prototype.render = function(model) {
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-0.5
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:3
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-3
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:3
	        });
	        circle1.name = "Circle1";
	        this.add(circle1);
	
	        var itemSize = this.itemSize;
	        var rect = {x:-itemSize/2, y: -itemSize/2-2, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {stroke:'#000',fill:'#000000'},z:3}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+this.itemSize , model.get("bounds.upperLeft.y")+this.itemSize];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	        this.z = 3;
	    };
	
		zrUtil.inherits(ThrowSignalEventNode, EventNode);
		module.exports = ThrowSignalEventNode;
	


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	//边界事件---捕获定时器事件节点
	
		var EventNode = __webpack_require__(85);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
		function CatchMessageEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.startIcon = "M664.356571 633.344l-50.797714 0 228.827429 146.980571L181.613714 780.324571l228.827429-146.980571-50.834286 0-203.190857 130.450286L156.416 359.094857l359.021714 242.578286 352.146286-235.300571 0 397.458286L664.356571 633.344zM156.416 299.922286 156.416 243.675429l711.168 0 0 71.314286-351.378286 222.171429L156.416 299.922286z";
	        this.itemSize = 18;
			this.bpmnInfo = {type: 100, name:"CatchMessageEvent" };    //节点信息
	        this.render(model);
		}
	
	    CatchMessageEventNode.prototype.render = function(model) {
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-0.5
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-3
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:2
	        });
	        circle1.name = "Circle1";
	        this.add(circle1);
	
	        var itemSize = this.itemSize;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {stroke:'#fff'},z:2}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+this.itemSize , model.get("bounds.upperLeft.y")+this.itemSize];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(CatchMessageEventNode, EventNode);
		module.exports = CatchMessageEventNode;
	


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	//InclusiveGateWay节点
	
		var GatewayNode = __webpack_require__(100);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <path d=" M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Rectangle-1" fill="#F6A623"></path>
	 *    <path d=" M19.851221564 27.782256064000002  C24.231410964 27.782256064000002 27.782256064000002 24.231410964 27.782256064000002 19.851221564  C27.782256064000002 15.471032163999999 24.231410964 11.920187063999999 19.851221564 11.920187063999999  C15.471032163999999 11.920187063999999 11.920187063999999 15.471032163999999 11.920187063999999 19.851221564  C11.920187063999999 24.231410964 15.471032163999999 27.782256064000002 19.851221564 27.782256064000002  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Oval-4" fill="#FFFFFF"></path>
	 * </g>
	 */
	
		function InclusiveGatewayNode(model, api) {
			GatewayNode.call(this, model, api);
	        this.startIcon = 'M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z';
	        this.nextIcon = 'M507.7383 49.463867C327.38957 48.865055 154.337045 165.397235 85.887695 332.095705 13.82828 497.171875 51.26921 702.2376 177.31836 830.98145 298.5502 961.4774 498.29297 1009.3747 665.5781 948.3174 838.948 889.28065 966.9399 719.02055 973.89745 535.7715 985.56715 355.706145 879.6298 176.060825 717.4209 97.625 653.90365 65.927975 582.97465 49.398509 512 49.5 510.57905 49.480728 509.15835 49.468582 507.7383 49.463867zM520.41405 99.450195C696.9503 100.419315 863.2164 228.12953 908.87305 398.964845 957.3881 562.41865 891.7662 751.6676 750.9199 848.47755 604.61365 956.01475 387.64963 948.23445 249.48828 830.3994 110.28125 719.40945 60.452365 514.11165 131.875 351.308595 193.77873 200.80243 349.16891 97.58941 512 99.5 514.8069 99.451185 517.6119 99.43481 520.41405 99.450195z';
	        this.itemSize = 20;
			this.bpmnInfo = {type: 20, name:"InclusiveGateway" };    //节点信息
	        this.render(model);
		}
	
	    InclusiveGatewayNode.prototype.render = function(model) {
	        var itemSize = this.itemSize*2;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        var path = graphic.makePath(this.startIcon, {style: {stroke: '#000', fill: '#fff'},z:2}, rect,"center");
	        path.name = 'Path';
	        this.add(path);
	        var itemSize1 = this.itemSize;
	        var rect1 = {x:-itemSize1/2, y: -itemSize1/2, width: itemSize1, height:itemSize1};
	        this.add(graphic.makePath(this.nextIcon, {style: {stroke: '#000'},z:2}, rect1,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+itemSize1 , model.get("bounds.upperLeft.y")+itemSize1];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(InclusiveGatewayNode, GatewayNode);
		module.exports = InclusiveGatewayNode;
	


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	//所有GateWay节点的基类
	
	    var BPMNNode = __webpack_require__(79);
	    var graphic = __webpack_require__(3);
	    var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(26);
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    //
	    function GatewayNode(model, api) {
	        BPMNNode.call(this, model, api);
	        this.bpmnInfo = {type: -1, name:"GatewayNode" };    //节点信息
	        this.model = model;
	    }
	
	    GatewayNode.prototype.render = function() {
	
	    };
	
	    GatewayNode.prototype.getRect = function() {
	        var boundingRect = this.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	        var boundRect = new BoundingRect(this.position[0] - boundingRect.width/2 ,
	                                         this.position[1] - boundingRect.height/2,
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0],
	            y: this.position[1],
	            width: boundingRect.width/2,
	            height: boundingRect.height/2,
	            points: points,
	            boundingRect: boundRect
	        };
	
	    };
	    GatewayNode.prototype.setPosition = function(pX,pY) {
	        // body...
	        this.attr('position',[pX,pY]);
	    };
	    GatewayNode.prototype.getBoundingRect = function() {
	        var path = this.childOfName("Path");
	        return path.getBoundingRect();
	    };
	    GatewayNode.prototype.updateShape = function(ratio, ifParse) {
	        var scaleRatio = Number(ratio);
	        var getBoundingRect = this.getBoundingRect();
	        var path = this.childOfName("Path");
	        var width = getBoundingRect.width * scaleRatio;
	        var height = getBoundingRect.height * scaleRatio;
	        if (ifParse) {
	            width = parseInt(width, 10);
	            height = parseInt(height, 10);
	        }
	        var rect = {x:-width/2, y: -height/2, width: width, height:height};
	        graphic.resizePath(path, rect);
	    };
	
	    zrUtil.inherits(GatewayNode,BPMNNode);
	    module.exports = GatewayNode;
	


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	//ExclusiveGateWay节点
	
		var GatewayNode = __webpack_require__(100);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <path d=" M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Rectangle-1" fill="#F6A623"></path>
	 *    <path d=" M8.275862069 11.965517269000001  L1.499999999 11.965517269000001  L0 11.965517269000001  L0 8.965517239  L1.499999999 8.965517239  L8.275862069 8.965517239  L8.275862069 1.499999999  L8.275862069 0  L11.275862069 0  L11.275862069 1.499999999  L11.275862069 8.965517239  L18.741379269 8.965517239  L20.241379269 8.965517239  L20.241379269 11.965517269000001  L18.741379269 11.965517269000001  L11.275862069 11.965517269000001  L11.275862069 18.741379269  L11.275862069 20.241379269  L8.275862069 20.241379269  L8.275862069 18.741379269  L8.275862069 11.965517269000001  z" id="sid-1B88D2DF-A08F-4837-91F2-91F67ACAB29ALine-Copy"></path>
	 * </g>
	 */
	
		function ExclusiveGatewayNode(model, api) {
			GatewayNode.call(this, model, api);
	        this.startIcon = 'M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z';
	        this.nextIcon = 'M19.904129064000003 17.676993964000005  L24.997457864000005 12.583664864000003  L26.058118064000006 11.523004664000002  L28.179438464 13.644324964000003  L27.118778264 14.704985164000002  L22.025449364000004 19.798314364  L27.118778264 24.891643464000005  L28.179438464 25.952303664000006  L26.058118064000006 28.073623964000003  L24.997457864000005 27.012963764000006  L19.904129064000003 21.919634764  L14.810800164000003 27.012963764000006  L13.750140064000002 28.073623964000003  L11.628819664000003 25.952303664000006  L12.689479764000003 24.891643464000005  L17.782808764000002 19.798314364  L12.689479764000003 14.704985164000002  L11.628819664000003 13.644324964000003  L13.750140064000002 11.523004664000002  L14.810800164000003 12.583664864000003  L19.904129064000003 17.676993964000005  z';
	        this.itemSize = 20;
			this.bpmnInfo = {type: 17, name:"ExclusiveGateway" };    //节点信息
	        this.render(model);
		}
	
	    ExclusiveGatewayNode.prototype.render = function(model) {
	        var itemSize = this.itemSize*2;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        var path = graphic.makePath(this.startIcon, {style: {stroke: '#000', fill: '#fff'},z:2}, rect,"center");
	        path.name = 'Path';
	        this.add(path);
	        var itemSize1 = this.itemSize;
	        var rect1 = {x:-itemSize1/2, y: -itemSize1/2, width: itemSize1, height:itemSize1};
	        this.add(graphic.makePath(this.nextIcon, {style: {stroke: '#000'},z:2}, rect1,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+itemSize1 , model.get("bounds.upperLeft.y")+itemSize1];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ExclusiveGatewayNode, GatewayNode);
		module.exports = ExclusiveGatewayNode;
	


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	//ParallelGateWay节点
	
		var GatewayNode = __webpack_require__(100);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <path d=" M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Rectangle-1" fill="#F6A623"></path>
	 *    <path d=" M19.904129064000003 17.676993964000005  L24.997457864000005 12.583664864000003  L26.058118064000006 11.523004664000002  L28.179438464 13.644324964000003  L27.118778264 14.704985164000002  L22.025449364000004 19.798314364  L27.118778264 24.891643464000005  L28.179438464 25.952303664000006  L26.058118064000006 28.073623964000003  L24.997457864000005 27.012963764000006  L19.904129064000003 21.919634764  L14.810800164000003 27.012963764000006  L13.750140064000002 28.073623964000003  L11.628819664000003 25.952303664000006  L12.689479764000003 24.891643464000005  L17.782808764000002 19.798314364  L12.689479764000003 14.704985164000002  L11.628819664000003 13.644324964000003  L13.750140064000002 11.523004664000002  L14.810800164000003 12.583664864000003  L19.904129064000003 17.676993964000005  z" id="sid-8FCD6C01-B973-4C9C-A90B-3D2ADFC75217Line" fill="#FFFFFF"></path>
	 * </g>
	 */
	
		function ParallelGatewayNode(model, api) {
			GatewayNode.call(this, model, api);
	        this.startIcon = 'M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z';
	        this.nextIcon = 'M8.275862069 11.965517269000001  L1.499999999 11.965517269000001  L0 11.965517269000001  L0 8.965517239  L1.499999999 8.965517239  L8.275862069 8.965517239  L8.275862069 1.499999999  L8.275862069 0  L11.275862069 0  L11.275862069 1.499999999  L11.275862069 8.965517239  L18.741379269 8.965517239  L20.241379269 8.965517239  L20.241379269 11.965517269000001  L18.741379269 11.965517269000001  L11.275862069 11.965517269000001  L11.275862069 18.741379269  L11.275862069 20.241379269  L8.275862069 20.241379269  L8.275862069 18.741379269  L8.275862069 11.965517269000001  z';
	        this.itemSize = 20;
			this.bpmnInfo = {type: 20, name:"ParallelGateway" };    //节点信息
	        this.render(model);
		}
	
	    ParallelGatewayNode.prototype.render = function(model) {
	        var itemSize = this.itemSize*2;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        var path = graphic.makePath(this.startIcon, {style: {stroke: '#000', fill: '#fff'},z:2}, rect,"center");
	        path.name = 'Path';
	        this.add(path);
	        var itemSize1 = this.itemSize;
	        var rect1 = {x:-itemSize1/2, y: -itemSize1/2, width: itemSize1, height:itemSize1};
	        this.add(graphic.makePath(this.nextIcon, {style: {stroke: '#000'},z:2}, rect1,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+itemSize1 , model.get("bounds.upperLeft.y")+itemSize1];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ParallelGatewayNode, GatewayNode);
		module.exports = ParallelGatewayNode;
	


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	//子流程
	
	    var Bpmn = __webpack_require__(104);
		var BPMNNode = __webpack_require__(79);
		var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(26);
	    var graphic = __webpack_require__(3);
	    var Connector = __webpack_require__(105);
		//创建Node类 所有形状都继承Node
		//
		function SubProcessNode(model, api) {
	
			BPMNNode.call(this, model, api);
			this.bpmnInfo = {type: -1, name:"SubProcess" };    //节点信息
	        this.model = model;
	        this.slot = [];
	        this.slotEvent = [];
	        this.isCanSlot = true;
	        var width,height;
	        width = model.get("bounds.lowerRight.x")-model.get("bounds.upperLeft.x");
	        height = model.get("bounds.lowerRight.y")-model.get("bounds.upperLeft.y");
	        if(!width || width <= 0){
	            width = 160;
	        }
	        if(!height || height <= 0){
	            height = 100;
	        }
	
	        this.rectSize = {width:width, height:height};
	        this.render(model);
		}
	
	
	    SubProcessNode.prototype.initEvent = function(api) {
	        var that = this;
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'
	
	
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            that.on(eveName, function (e) {
	                var params = {};
	                params.event = e;
	                var current = e.target;
	                if (current.parent &&  current.parent instanceof Connector) {
	                    return;
	                }
	                params.type = eveName;
	                params.target = that;
	                api.trigger(eveName, params);
	            }, this);
	        });
	    };
	
	
	    SubProcessNode.prototype.render = function(model) {
	    	var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	                fill: '#f9f9f9',
	                stroke: '#bbbbbb'
	            },
	            z:0
	        });
	        rect.name = "subprocess-rect";
	        this.add(rect);
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
	
	    SubProcessNode.prototype.getRect = function() {
	        // body...
	        var boundingRect = this.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	
	        var boundRect = new BoundingRect(this.position[0] ,
	                                         this.position[1],
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0]+boundingRect.width/2,
	            y: this.position[1]+boundingRect.height/2,
	            width: boundingRect.width,
	            height: boundingRect.height,
	            points: points,
	            boundingRect: boundRect
	        };
	    };
	
	    SubProcessNode.prototype.setPosition = function(pX,pY) {
	        // body...
	        var boundingRect = this.getBoundingRect();
	        this.attr('position',[pX-boundingRect.width/2,pY-boundingRect.height/2]);
	
	    };
	
	
	    SubProcessNode.prototype.refresh = function(opt) {
	        var rect = this.childOfName("subprocess-rect");
	        rect.setShape(opt.shape);
	        this.attr('position',opt.position);
	        this.refreshText();
	    };
	
	    SubProcessNode.prototype.getBoundingRect = function() {
	        var rect = this.childOfName("subprocess-rect");
	        return rect.getBoundingRect();
	    };
	
	    SubProcessNode.prototype.toJSON = function() {
	        this.model.set("resourceId", this.resourceId);
	        this.model.set("properties.type", this.bpmnInfo.type);
	        this.model.set("stencil.type", this.bpmnInfo.name);  //stencil.id
	        if (this.slotEvent && this.slotEvent.length > 0) {
	            var arrSlotEvent = [];
	            for (var i = this.slotEvent.length - 1; i >= 0; i--) {
	                arrSlotEvent.push(this.slotEvent[i].resourceId)
	            }
	            this.model.set("properties.slotEvent", arrSlotEvent);
	        }
	            // var rect = this.getRect();
	            // this.model.set("bounds.upperLeft.x", rect.x);
	            // this.model.set("bounds.upperLeft.y", rect.y);
	            // this.model.set("bounds.lowerRight.x", rect.x + rect.boundingRect.width);
	            // this.model.set("bounds.lowerRight.y", rect.y + rect.boundingRect.height);
	        function parentX(node) {
	            var rect = node.getRect().boundingRect;
	            if (node.parent && Bpmn.isSubProcess(node.parent)) {
	                return rect.x + parentX(node.parent)
	            } else {
	                return rect.x
	            }
	        }
	
	        function parentY(node) {
	            var rect = node.getRect().boundingRect;
	            if (node.parent && Bpmn.isSubProcess(node.parent)) {
	                return rect.y + parentY(node.parent)
	            } else {
	                return rect.y
	            }
	        }
	
	        var rect = this.getRect().boundingRect;
	
	        this.model.set("bounds.upperLeft.x", parseInt(rect.x));
	        this.model.set("bounds.upperLeft.y", parseInt(rect.y));
	        this.model.set("bounds.lowerRight.x", parseInt(rect.x + rect.width));
	        this.model.set("bounds.lowerRight.y", parseInt(rect.y + rect.height));
	
	
	
	        // 加入子流程的 节点
	        var arrChildShapes = [];
	        this.eachChild(function(child){
	            if (child instanceof BPMNNode || child instanceof Connector) {
	                arrChildShapes.push(child.toJSON());
	            }
	        });
	
	
	
	        this.model.set("childShapes", arrChildShapes);
	        return this.model.option;
	    };
	
	    SubProcessNode.prototype.updateShape = function(ratio, ifParse, pixel) {
	        var rect = this.childOfName("subprocess-rect");
	        var scaleRatio = Number(ratio);
	        var shape = rect.shape;
	        var newW = Number(shape.width * scaleRatio);
	        var newH = Number(newW * shape.height / shape.width);
	        if (ifParse) {
	            var w = parseInt(newW / pixel, 10);
	            var h = parseInt(newH / pixel, 10);
	            newW = w * pixel - 1;
	            newH = h * pixel - 1;
	        }
	        rect.setShape({
	            width: newW,
	            height: newH
	        });
	        this.refreshText();
	    };
	
	    SubProcessNode.prototype.nodeType = "SubProcess";
	
		zrUtil.inherits(SubProcessNode,BPMNNode);
		module.exports = SubProcessNode;
	


/***/ }),
/* 104 */
/***/ (function(module, exports) {

	/**
	 * BPMN静态方法类
	 * @class fish.topo.FishTopoBpmn.Bpmn
	 */
	
		var Bpmn = {
			BPMN_TYPE:"stencil.type",
			BPMN_SCRIPT_TASK: "ScriptTask",
			BPMN_EVENT_SUB_PROCESS: "SubProcessTask",
			BPMN_TASK:"Task",
			TEMPLATE: "BPMNDiagram",
			RESOURCE_ID: "resourceId",
			SEQUENCE_FLOW: "SequenceFlow",
			SUB_PROCESS: "SubProcess",
			USER_DATA: "properties.userData",
	
			START_EVENT: "StartNoneEvent",
			END_EVENT: "EndNoneEvent",
			USER_TASK: "UserTask",
			MANUAL_TASK: "ManualTask",
			SCRIPT_TASK: "ScriptTask",
			MAIL_TASK: "MailTask",
			SERVICE_TASK: "ServiceTask",
			SMS_TASK: "SmsTask",
			COMMENT: "Comment",
			CATCH_TIMER_EVENT: "CatchTimerEvent",
			CATCH_SIGNAL_EVENT: "CatchSignalEvent",
			THROW_SIGNAL_EVENT: "ThrowSignalEvent",
			CATCH_MESSAGE_EVENT: "CatchMessageEvent",
			INCLUSIVE_GATEWAY: "InclusiveGateway",
			EXCLUSIVE_GATEWAY: "ExclusiveGateway",
			PARALLEL_GATEWAY: "ParallelGateway",
	
			/**
			 * 判断节点是否 BPMN模板 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isTemplate: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype === Bpmn.TEMPLATE;
			},
	
			/**
			 * 判断节点是否 Activity 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isActivity: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return (bpmntype.indexOf("Task") != -1 || bpmntype === Bpmn.COMMENT);
			},
	
			/**
			 * 判断节点是否 子流程 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isSubProcess: function(node) {
				var bpmntype = node.nodeType;
				return  bpmntype == Bpmn.SUB_PROCESS
			},
	
			/**
			 * 判断节点是否 网关 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isGateway: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype.indexOf("Gateway") != -1;
			},
	
			/**
			 * 判断节点是否 线段 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isFlow: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype === Bpmn.SEQUENCE_FLOW;
			},
	
			/**
			 * @private
			 * 判断模型是否 线段 类型
			 * @param  {Object}  model 需要判断类型的模型
			 * @return {Boolean}      是 否
			 */
			isFlowModel: function(model) {
				var bpmntype = model.get(Bpmn.BPMN_TYPE);
				return bpmntype === Bpmn.SEQUENCE_FLOW;
			},
	
			/**
			 * 判断节点是否 事件 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isEvent: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype.indexOf("Event") != -1;
			},
	
			/**
			 * 判断节点是否 插糟事件 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isSlotEvent: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype == Bpmn.CATCH_TIMER_EVENT || bpmntype == Bpmn.CATCH_SIGNAL_EVENT || bpmntype == Bpmn.THROW_SIGNAL_EVENT;
			},
	
			/**
			 * 判断节点是否 注释 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isComment: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype === Bpmn.COMMENT;
			},
	
			/**
			 * 获取当前节点的类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {String}      节点的类型
			 */
			getType: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype;
			},
	
			/**
			 * 返回当前节点的样式选项
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Object}      样式对象
			 */
			getStyle: function(node) {
				return node.model.option.style;
			},
	
			/**
			 * 返回当前节点的属性选项
			 * @param  {Object}  node 需要判断类型的节点
			 * @return  {Object}      属性对象
			 */
			getProp: function(node) {
				return node.model.option.properties;
			},
	
			/**
			 * 获取用户自定义的数据
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Object}   用户自定义的数据
			 */
			getUserData: function(node) {
				var model = node.model;
				return model.get(Bpmn.USER_DATA);
			},
	
			/**
			 * 设置用户的自定义数据
			 * @param  {Object}  node 需要判断类型的节点
			 * @param {Object} userData 用户的自定义数据
			 */
			setUserData: function(node, userData) {
				var model = node.model;
				model.set(Bpmn.USER_DATA, userData);
			}
		};
	
		module.exports = Bpmn;
	


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连接线
	 * @author wang.xiaohu
	 */
	
	    var Util = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var vec2 = __webpack_require__(14);
	    var graphic = __webpack_require__(3);
	    var Node = __webpack_require__(80);
	    var symbolUtil = __webpack_require__(106);
	    var Handle = __webpack_require__(107);
	    var EffectLine = __webpack_require__(108);
	    var ConnectionPoint = __webpack_require__(109);
	    var Point = __webpack_require__(64);
	    var Model = __webpack_require__(83);
	
	    Connector.TYPE_STRAIGHT = 'straight';
	    Connector.TYPE_JAGGED = 'jagged';
	    Connector.TYPE_CURVE = 'curve';
	    Connector.TYPE_CHAIN = 'chain';
	    Connector.RADIUS = 3;
	    Connector.START_NODE = "startNode";
	    Connector.END_NODE = "endNode";
	    Connector.LEFT = "left";
	    Connector.RIGHT = "right";
	    Connector.TOP = "top";
	    Connector.BOTTOM = "bottom";
	    Connector.BOTTOM = "bottom";
	    Connector.SEPERATOR = "-";
	    Connector.NORMAL_COLOR = "#000";
	    Connector.SELECTED_COLOR = '#74B7E0';
	    Connector.CHILD_NAME = ['lineText', 'lineImage'];
	    /**
	     * 构造函数
	     * @param {[type]} options [description]
	     */
	    function Connector(options) {
	        Node.call(this);
	        this.opt = options || {};
	        if (this.opt.model) {
	            this.resourceId = this.opt.model.get("resourceId");
	            this.model = this.opt.model;
	            this.opt = this.opt.model.option;
	        } else {
	            this.resourceId = Util.getUUID(); // 生成节点ID
	            this.model = new Model({});
	        }
	        var defaultOptions = {
	            symbol: { type: "arrow", size: 10, color: Connector.NORMAL_COLOR, both:false, offset:0 }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	            style: { lineWidth: 1, stroke: Connector.NORMAL_COLOR, lineType: Connector.TYPE_STRAIGHT }, //样式
	            hoverStyle: { lineWidth: 2, stroke: Connector.SELECTED_COLOR }, //移上去的样式
	            arrowHoverStyle: { fill: Connector.SELECTED_COLOR},
	            shape: { points: null, smooth: false, smoothConstraint: null }, //形状
	            position: { startPos:null, endPos:null,  //指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	                        startOffset:[0,0],  // 起始线段离节点的偏移
	                        endOffset:[0,0],    // 终止线段离节点的偏移
	                        escapeDistance:[30,30], // 第一条折线的长度，最后一条折线的长度
	                        points:null    //不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	                    },
	            autoChangePosition: false,
	            textContextMenu: null,
	            isEdit: true, //是否可编辑
	            text: {
	                text: null,
	                textFill: '#000000', // 文本颜色
	                textFont: '12px Microsoft YaHei',
	                textPos: 'center',
	                textRotateable: true
	            },
	            image: {
	                image: null,
	                width: 50,
	                height: 50,
	                // style: {
	                //     // image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAAyCAYAAAAA9rgCAAAEZklEQVRoQ+2aXYgbVRTHz/8muwSJWPx4sFgoaBUrWorUL8SK9UGhFCt2URRhQai6uLDZyR0DhTaIZu/NZPdNrYL4haKlflDwoSgUVKrYIhRaP7B92Ibtg1JfIqzZnRy5y0Rmx2R3MqlJZpN5nDnn3v/vnnvnnvsBavBora8HcFutVtvS6HsvvxNCnAdwipnPZLPZv4JaEXyhtS4SkdXLUCG1zQoh9lmW9Z7ffhmw1nqWiDaELDAWZsyct237QF3sv8Ba6++I6M5YULQu8j4p5dfGbQlYKXUAwP7Wy4mNxy8Abjdjug78IYDHffLLzPySbdtvxAbJE+o4zmbXdUeCARRC3GFZ1g91YNMCN/rgDkkpR+IGW9ertd5JREcC+kellG8vAWut2f8xONDjCN6MaQBsojmIcAz79KBLewnIYAz30hguFou7mXkTgN+FELOTk5NfhR1dsevSWuuPiWhPAPBTKeWjYaBjBayUOmFSwSZgz0spX1sNOjbATbKkZXzJZPKqTCZzcSXo2AArpSYBOCvBALgrm81+vyaAi8XiKDO/tRKMEOJmy7J+XhPApVJph+u6XzaDAfBrpVLZks/n5zsOPDMzs25hYWEjM/9h23Z5tR9J2O9a60+IaHcj+0Qi8WCY6emSjOFCoXC/EGIPgHuIaCMRrfOJOk1ER4noODMfb7cBtNbPEdGrvvLnvDX662Eari1gpVQWgJkTt4WpzEteCul0+pWxsbFKWJ+g3fT09JWu625i5oupVGp2fHz877BlRQbWWheI6MWwFfntAPwI4CnLss5E8W/Hpx3gZZsDEUScFkKMdBr6kgEz828APgdweHFx8cL8/PxcOp3eWqvVHgbwUJOdz8NSysciNFZkl8jA3o7mdq/mopTyi1WmA2k2QoM2AJ7NZrMHIxO06BgZuMV6lsy11k8T0TsB33IymdyeyWTORSmzVZ+OAnvQJsom2v7nAynlk62Kj2LfcWDHca6u1WrfENFNfsHM/LJt2/uiQLTi03FgL8rPENGbQaHMvCFMYlIoFLYJIcwy8VYAmwF8S0QnmfmUlPLsKv+ShlvP//sWj9ba5MU7Goi7V0ppAP7zTE1NmZODJwA8sgLUR8zs2LZ9opFNVyJshCildplprIlwk4YeNWe6ruuWhRAPMPMogGtCdt8qETmu6zq5XO5Pv0/XgL2ubfLfvSEhopj9RET7pZSH6s5dBfagTZR3RaCZMwsSAOeY2SxY7iai6xqVMzQ0tH5iYuKCV193xnCgmzX8iTVphLPM/P7w8PDBOoQvei8w8ziAG/y+9RPCngE2QnzHmSbVvKUB7GcA3q1UKkfy+fxisx7hraQMuJnrLyOiYwB21u91dL1LNxKulLo8mUxeW61W1ycSifOpVKrcyhLQlFkqlbZWq9UrcrncsZ75aUUYt2279GSE26ZaoYAB8OAwzdc91vyBuFKqvy61KKX67tpSf11M81Kx/rl66MtR++dyqQ+6f64P+6DX7AXxfwANvfFgWcCyjAAAAABJRU5ErkJggg==",
	                //     // width:50,
	                //     // height:50
	                // },
	                imagePos: 'center',
	                imageRotateable: true // 图片是否跟随线段旋转
	            },
	            z: 0
	        }
	
	        this.options = Util.mergeOpt(defaultOptions, this.opt, true, 'textContextMenu');
	        this.handles = [];
	        this.conPointsGroup = new graphic.Group();
	        this.startNode = null;
	        this.endNode = null;
	        this.line = null;
	        this.groupCurve = new graphic.Group();
	        this.icons = []; // 用于存储线段上面的操作图标
	        this.render();
	    }
	
	        /**
	     * 创建连线节点
	     * @param  {[Object]} options [节点参数]
	     * @param  {[String]} type [节点类型] 'text' 'image'
	     */
	    Connector.prototype.createLineNode = function(options, type) {
	        var that = this;
	        var text = null;
	        if (!type) {
	            type = 'text';
	        }
	        var nodeName = zrUtil.find(Connector.CHILD_NAME, function(name) {
	            return name.toLocaleLowerCase().indexOf(type) > -1;
	        });
	        if (zrUtil.isArray(options[type]) && this.options.style.lineType == Connector.TYPE_CHAIN) {
	            options[type].forEach(function (v, i) {
	                var content = that.drawText(nodeName+"-"+i, v, 0, 0, type);
	                if (zrUtil.isString(v)) {
	                    var obj = {};
	                    obj[type] = v;
	                    obj[type+'Id'] = content.text.id;
	                    that.options[type][type][i] = obj;
	                } else {
	                    that.options[type][type][i].textId = content.text.id;
	                }
	                that.add(content.text);
	                that.createNodeContextMenu(content.text);
	            });
	        } else {
	            text = this.drawText(nodeName, options, 0, 0, type);
	            this.add(text.text);
	        }
	        if (text) {
	            that.createNodeContextMenu(text.text);
	        }
	    }
	
	    Connector.prototype.ifLineNodeRotateable = function(type) {
	        if (!type) {
	            type = 'text';
	        }
	        if (this.options.style.lineType == Connector.TYPE_STRAIGHT) {
	            if ((type === 'text' && this.options.text.textRotateable) || (type === 'image' && this.options.image.imageRotateable))
	            return true;
	        }
	        return false;
	    }
	
	    /**
	     * 更新连线的文字/图片节点
	     * @param  {[Object]} lineNode [节点]
	     * @param  {[Object]} options [节点参数]
	     * @param  {[String]} type [节点类型] 'text' 'image'
	     */
	    Connector.prototype.refreshLineNode = function(lineNode, options, type) {
	        var self = this, lineNodeArr = [], nodeName = Connector.CHILD_NAME[0];
	        if (!type) {
	            type = 'text';
	        }
	        nodeName = zrUtil.find(Connector.CHILD_NAME, function(name) {
	            return name.toLocaleLowerCase().indexOf(type) > -1;
	        });
	        if (this.options.style.lineType == Connector.TYPE_CHAIN && zrUtil.isArray(options[type])) {
	            options[type].forEach(function (v, i) {
	                lineNodeArr.push(self.childOfName(nodeName+'-'+i));
	            });
	        } else if (!lineNode && options[type]) {
	            var text = this.drawText(nodeName, options, 0, 0, type);
	            this.add(text.text);
	            lineNode = this.childOfName(nodeName);
	        }
	        if (lineNodeArr.length > 0) {
	            var cnt = lineNodeArr.length,
	                distance = this.turningPoints[1].x - this.turningPoints[0].x,
	                gap = parseInt(distance/cnt),
	                pos = -(gap) * parseInt(cnt/2);
	
	                lineNodeArr.forEach(function (v, i) {
	                var textPoint = self.getTextPostion(options, v), way = '';
	
	                var rate = self.getTextRotation(textPoint, v);
	                if (Math.abs(rate) === 0) {
	                    rate = 0;
	                } else {
	                    way = rate > 0 ? 'plus' : 'minus';
	                }
	                rate = Math.abs(rate);
	                var deg = (180*rate)/Math.PI;
	                var rotation = null, length = null;
	                if (type === 'text') {
	                    v.setStyle("text", zrUtil.isString(options[type][i]) ? options[type][i] : options[type][i].text);
	                    // 更新文字矩形包围盒
	                    var textBoundingRect = self.getTextBoundingRect(v.style);
	                    v.setShape({
	                        width: textBoundingRect.width,
	                        height: textBoundingRect.height
	                    });
	                }
	
	                if (way) {
	                    rotation = deg > 90 ? ((deg-45)*Math.PI)/180 : ((45+deg)*Math.PI)/180;
	                    rotation = way === 'minus' ? -(rotation) : rotation;
	                } else {
	                    rotation = (45*Math.PI)/180
	                }
	                v.attr('rotation', rotation);
	
	                if (deg === 90) {
	                    textPoint[1] -= pos;
	                } else {
	                    textPoint[0] += pos;
	                    if (rate !== 0) {
	                        length = Math.tan(deg*Math.PI/180)*pos;
	                        if (pos > 0) {
	                            textPoint[1] -= way === 'plus' ? length : -(length);
	                        } else {
	                            textPoint[1] += way === 'plus' ? -(length) : (length);
	                        }
	                    }
	                }
	
	                v.attr("position", textPoint);
	                pos += gap;
	            });
	        }
	        if (lineNode) {
	            if (type === 'text') {
	                lineNode.setStyle("text", options[type]);
	                var textRect = this.getTextBoundingRect(options);
	                lineNode.setShape({
	                    width: textRect.width,
	                    height: textRect.height
	                });
	            }
	            var textPoint = this.getTextPostion(options, lineNode);
	            if (this.ifLineNodeRotateable(type)) { //#187
	                lineNode.attr('rotation', this.getTextRotation(textPoint, lineNode));
	            }
	            lineNode.attr("position", textPoint);
	        }
	    }
	
	
	    /**
	     * 重新画线，如果传空则根据turningPoints 重新画线
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    Connector.prototype.refresh = function(arrPoints) {
	        var that = this;
	        if (arrPoints) {
	            this.turningPoints = arrPoints;
	        }
	        //将[x:0,y:0]转化为[0, 0]  给zrender使用
	        var points = Util.traslatePoints(this.turningPoints);
	
	        if ((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {
	            this.modifyCurve(this.turningPoints);
	        } else {
	            this.line.attr('shape', { points: points });
	        }
	
	        // 更新线段文字/图片节点
	        Connector.CHILD_NAME.forEach(function(name) {
	            var lineNode = that.childOfName(name);
	            var type = name === Connector.CHILD_NAME[0] ? 'text' : 'image';
	            that.refreshLineNode(lineNode, that.options[type], type);
	        });
	
	        this.refreshFromToSymbol(points);
	        this.refreshHandles();
	    };
	    /**
	     * 创建线上节点的右击监听
	     * @return {[type]} [description]
	     */
	    Connector.prototype.createNodeContextMenu = function (node) {
	        if (node && this.opt.textContextMenu) {
	            var textContextMenu = this.opt.textContextMenu;
	            node.on("contextmenu",function(e) {
	                e.event.preventDefault();
	                e.event.stopPropagation();
	                textContextMenu.buildMenu(e.event,this);
	            })
	        }
	    }
	    /**
	     * 渲染
	     * @return {[type]} [description]
	     */
	    Connector.prototype.render = function() {
	        var that = this;
	        //1.创建箭头
	        this.renderFromToSymbol();
	
	        //2.创建线
	        this.curveLine = new graphic.BezierCurve({
	            //position: this.options.position,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.groupCurve.add(this.curveLine);
	        this.add(this.groupCurve);
	        this.add(this.conPointsGroup);
	        this.polyLine = new graphic.Polyline({
	            //position: this.options.position,
	            shape: this.options.shape,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.add(this.polyLine);
	
	        if ((this.options.style.lineType == Connector.TYPE_CURVE)) {
	            this.line = this.groupCurve;
	            this.createHoverStyle(this.curveLine);
	            this.polyLine.hide();
	        } else {
	            this.line = this.polyLine;
	            this.createHoverStyle(this.polyLine);
	            this.curveLine.hide();
	        }
	
	        //3.侦听线事件
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click']; //'click', 'dblclick', 'mouseover', 'mouseout'
	        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	            this.line.on(eveName, zrUtil.bind(function(e) {
	                e.cancelBubble = true;
	                var params = {};
	                params.event = e;
	                params.type = "Connector:" + eveName;
	                params.target = that;
	                this.trigger(params.type, params);
	                if (this.options.isEdit == false) {
	                    return; }
	                that.setSelectedStyle(this);
	                if (this.handles.length < 1) {
	                    this.shapeSetHandle();
	                }
	
	            }, this));
	        }, this);
	
	        //4.创建线上文本
	        if (this.options.text.text) {
	            this.createLineNode(this.options.text, 'text');
	        }
	        // // 5.创建线上图片节点
	        if (this.options.image.image) {
	            this.createLineNode(this.options.image, 'image');
	        }
	    };
	
	    Connector.prototype.renderFromToSymbol = function(options) {
	        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle
	        if (symbolTo) {
	            this.add(symbolTo);
	        }
	        //如果双向箭头 则再创建首箭头
	        if (this.options.symbol.both) {
	            var symbolFrom = this.createSymbol('fromSymbol', this.options); //arrow,triangle
	            if (symbolFrom) {
	                this.add(symbolFrom);
	            }
	        }
	    }
	
	    Connector.prototype.refreshFromToSymbol = function(points) {
	        var symbolTo = this.childOfName('toSymbol');
	        var symbolFrom = this.childOfName('fromSymbol');
	        var position = [], offset = this.options.symbol.offset;
	        if (symbolTo) {
	            if (this.options.effect && this.options.effect.show) {
	                new EffectLine(symbolTo, this.options, this.groupCurve, this.polyLine);
	            } else {
	                position = points[points.length - 1];
	                if (this.options.style.lineType !== Connector.TYPE_CURVE) {
	                    var distance = vec2.distance(points[points.length - 1], points[points.length - 2]);
	                    if (offset <= distance) {
	                        position = vec2.lerp(
	                            [], points[points.length - 1], points[points.length - 2],
	                            offset / distance);
	                    } else {
	                        position = points[points.length - 1];
	                    }
	                }
	                symbolTo.attr('position', position);
	                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]));
	            }
	        }
	
	        if (symbolFrom) {
	            position = points[0];
	            if (this.options.style.lineType !== Connector.TYPE_CURVE) {
	                var distanceFrom = vec2.distance(points[0], points[1]);
	                if (offset <= distanceFrom) {
	                    position = vec2.lerp(
	                        [], points[0], points[1],
	                        offset / distanceFrom);
	                } else {
	                    position = points[0];
	                }
	            }
	            symbolFrom.attr('position', position);
	            symbolFrom.attr('rotation', Util.tangentRotation(this.turningPoints[1], this.turningPoints[0]));
	        }
	    }
	    /**
	     * 设置style
	     * @param {object} options 样式对象
	     * @param {boolean} notSaveModel 设置样式是否保存到模型中,默认是false
	     */
	    Connector.prototype.setStyle = function(options,notSaveModel) {
	        var lineOpt = {};
	        var symbolTo = null;
	        var notLineKeys = ['text', 'image', 'symbol'];
	        // if (options.color) {
	        //     if (this.options.style.lineType == Connector.TYPE_CURVE) {
	        //         this.groupCurve.eachChild(function(curve) {
	        //             curve.attr("style", { stroke: options.color });
	        //             graphic.setNormalStyle(curve, { stroke: options.color });
	        //         });
	        //     } else {
	        //         this.polyLine.attr("style", { stroke: options.color });
	        //         graphic.setNormalStyle(this.polyLine, { stroke: options.color });
	        //     }
	        //     symbolTo = this.childOfName('toSymbol');
	        //     if (symbolTo) {
	        //         symbolTo.attr("style", { fill: options.color });
	        //         graphic.setNormalStyle(symbolTo, { fill: options.color });
	        //     }
	        //     if(!notSaveModel) {
	        //         this.options.style.stroke = options.color;
	        //         this.model.set("options.style.stroke", options.color);
	        //         this.model.set("options.symbol.color", options.color);
	        //         this.options.symbol.color = options.color;
	        //     }
	        // }
	
	        if (options.text) {
	            var lineText = this.childOfName(Connector.CHILD_NAME[0]);
	            //开始没有创建文本，后来传进来text了，需要先创建文本
	            if (!lineText && options.text.text) {
	                var text = this.drawText(Connector.CHILD_NAME[0], options.text, 0, 0);
	                this.add(text.text);
	                lineText = this.childOfName(Connector.CHILD_NAME[0]);
	            }
	
	            if (options.text.text || options.text.text == "") {
	                lineText.setStyle("text", options.text.text);
	                this.options.text.text = options.text.text;
	            }
	            var textPoint = this.getTextPostion(options.text);
	            lineText.attr("position", textPoint);
	            if (options.text.textPos) {
	                this.options.text.textPos = options.text.textPos;
	            }
	            if (options.text.offset) { //#187
	                this.options.text.offset = options.text.offset;
	            }
	
	            if (options.text.color) {
	                lineText.attr("style", {
	                    textFill: options.text.color
	                });
	                this.options.text.textFill = options.text.color;
	            }
	
	            if (options.text.textFont) {
	                lineText.attr("style", {
	                    textFont:options.text.textFont
	                });
	                this.options.text.textFont = options.text.textFont;
	            }
	
	            if (options.text.textFill) {
	                lineText.attr("style", {
	                    textFill: options.text.textFill
	                });
	                this.options.text.textFill = options.text.textFill;
	            }
	            this.model.set("options.text", options.text);
	        }
	
	        if (options.image) {
	            var lineImage = this.childOfName(Connector.CHILD_NAME[1]);
	            //开始没有创建图片，后来传进来image了，需要先创建图片
	            if (!lineImage && options.image.image) {
	                var image = this.drawText(Connector.CHILD_NAME[1], options.image, 0, 0, 'image');
	                this.add(image.text);
	                lineImage = this.childOfName(Connector.CHILD_NAME[1]);
	            }
	            var imagePoint = this.getTextPostion(options.image, lineImage);
	            lineImage.attr("position", imagePoint);
	            Object.keys(options).forEach(function(key) {
	                this.options.image[key] = options[key];
	            }.bind(this));
	            if (options.image.offset) { //#187
	                this.options.image.offset = options.image.offset;
	            }
	            this.model.set("options.image", options.image);
	        }
	
	        if (options.symbol) {
	            if (options.symbol.type) {
	                this.options.symbol.type = options.symbol.type;
	                this.model.set("options.symbol.type", options.symbol.type);
	            }
	            if (options.symbol.size) {
	                this.options.symbol.size = options.symbol.size;
	                this.model.set("options.symbol.size", options.symbol.size);
	            }
	            if (options.symbol.color) {
	                this.options.symbol.color = options.symbol.color;
	                this.model.set("options.symbol.color", options.symbol.color);
	            }
	            if (options.symbol.z) {
	                this.options.symbol.z = options.symbol.z;
	                this.model.set("options.symbol.z", options.symbol.z);
	            }
	
	            symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) {
	                this.remove(symbolTo);
	            }
	            var symbol = this.createSymbol("toSymbol", this.model.get("options"))
	            if (symbol) {
	                this.add(symbol);
	            }
	        }
	        Object.keys(options).forEach(function(key) {
	            if (notLineKeys.indexOf(key) < 0) {
	                lineOpt[key] = options[key];
	            }
	        });
	        if (JSON.stringify(lineOpt) !== '{}') {
	            if (lineOpt.color) {
	                lineOpt.stroke = lineOpt.color;
	            }
	            if (lineOpt.stroke) {
	                lineOpt.color = lineOpt.stroke;
	            }
	            if (this.options.style.lineType == Connector.TYPE_CURVE) {
	                this.groupCurve.eachChild(function(curve) {
	                    curve.attr("style", lineOpt);
	                    graphic.setNormalStyle(curve, lineOpt);
	                });
	            } else {
	                this.polyLine.attr("style", lineOpt);
	                graphic.setNormalStyle(this.polyLine, lineOpt);
	            }
	            symbolTo = this.childOfName('toSymbol');
	            if (symbolTo && lineOpt.color) {
	                symbolTo.attr("style", { fill: lineOpt.color });
	                graphic.setNormalStyle(symbolTo, { fill: lineOpt.color });
	            }
	            if(!notSaveModel) {
	                Object.keys(lineOpt).forEach(function(key) {
	                    this.options.style[key] = lineOpt[key];
	                    this.model.set("options.style"+ key, lineOpt[key]);
	                }.bind(this));
	                if (lineOpt.color) {
	                    this.options.symbol.color = lineOpt.color;
	                }
	            }
	        }
	        this.refresh();
	    };
	
	    /**
	     * 设置选中style
	     */
	    Connector.prototype.setSelectedStyle = function() {
	        // 选中的连线层级是最高的
	        var symbolTo;
	        this.setStyle(this.options.hoverStyle, true);
	        if (this.options.style.lineType == Connector.TYPE_CURVE) {
	            this.groupCurve.eachChild(function(curve) {
	                curve.attr("z", this.options.z + 2);
	            }.bind(this));
	        } else {
	            this.polyLine.attr('z', this.options.z + 2);
	        }
	        symbolTo = this.childOfName('toSymbol');
	        if (symbolTo) {
	            symbolTo.attr("z", this.options.z + 2);
	        }
	    };
	
	    /**
	     * 设置取消选中style
	     */
	    Connector.prototype.removeSelectedStyle = function() {
	        var symbolTo;
	        this.setStyle({color:this.options.style.stroke,lineWidth:this.options.style.lineWidth},true);
	        if (this.options.style.lineType == Connector.TYPE_CURVE) {
	            this.groupCurve.eachChild(function(curve) {
	                curve.attr("z", this.options.z);
	            }.bind(this));
	        } else {
	            this.polyLine.attr('z', this.options.z);
	        }
	        symbolTo = this.childOfName('toSymbol');
	        if (symbolTo) {
	            symbolTo.attr("z", this.options.z);
	        }
	    };
	
	    /**
	     * 获取线段节点的位置
	     * @param  {Object} text {text:'', color:'', textPos:''}
	     * @return {Object}      {x,y}
	     */
	    Connector.prototype.getTextPostion = function(text, node) {
	        var textPostion = [];
	        var textRect = text.image && node ? node.getBoundingRect() : this.getTextBoundingRect(text);
	        var textWidth = textRect.width;
	        var textHeight = textRect.height || 12;
	        var pos;
	        if (text && (text.textPos || text.imagePos)) {
	            var offset = text.offset || 0;
	            var arrOffset = offset;
	            pos = text.textPos || text.imagePos;
	            if (!zrUtil.isArray(offset)) {
	                arrOffset = [offset, 0];
	            }
	            var pointsOrigin = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]]);
	            var points = [], beizierPoints =[];
	              var angle = Util.getAngle(pointsOrigin[0], pointsOrigin[1]);
	            var length, newPoint;
	            if (this.options.style.lineType == Connector.TYPE_CURVE) {
	                beizierPoints = this.getPointsFromCurve();
	            }
	            pointsOrigin.forEach(function(item) {
	                var itemCopy = new Point(item.x, pointsOrigin[1].x >= pointsOrigin[0].x ? item.y - textHeight / 2 : item.y + textHeight / 2);
	                points.push(itemCopy);
	            });
	            switch(pos) {
	                case 'start':
	                    if (this.options.style.lineType === Connector.TYPE_STRAIGHT) {
	                        length = arrOffset[0];
	                        newPoint = Util.getEndPoint(points[0], length, angle);
	                        textPostion = [newPoint.x, newPoint.y + arrOffset[1]];
	                    } else {
	                        textPostion = [this.turningPoints[0].x - textWidth / 2 + arrOffset[0], this.turningPoints[0].y + arrOffset[1] - textHeight / 2];
	                    }
	                    break;
	                case 'end':
	                    if (this.options.style.lineType === Connector.TYPE_STRAIGHT && !this.options.text.textRotateable) {
	                        length = Util.distance(points[0], points[1]);
	                        newPoint = Util.getEndPoint(points[0], length, angle);
	                        textPostion = [newPoint.x  - textWidth + arrOffset[0], newPoint.y + arrOffset[1]];
	                    } else {
	                        length = Util.distance(points[0], points[1]) - textWidth + arrOffset[0];
	                        newPoint = Util.getEndPoint(points[0], length, angle);
	                        textPostion = [newPoint.x, newPoint.y + arrOffset[1]];
	                    }
	                    break;
	                default:
	                    var midPoint = this.middle(text);
	                    if (this.ifLineNodeRotateable(text.image ? 'image' : 'text')) {
	                          var rotate = this.getTextRotation(text);
	                          var positionBefore = [midPoint[0] - textWidth / 2, midPoint[1] - textHeight / 2];
	                          textPostion = Util.calculatePoints(positionBefore, {x: midPoint[0], y: midPoint[1]}, rotate);
	                    } else if (this.options.style.lineType == Connector.TYPE_CURVE) {
	                        // 曲线的文字position单独计算
	                        var arr = [];
	                        beizierPoints.forEach(function(item) {
	                            arr = arr.concat(item);
	                        });
	                        var index = Math.round(arr.length / 2);
	                        textPostion = [arr[index].x - textWidth / 2, arr[index].y -textHeight / 2];
	                    } else {
	                        textPostion = [midPoint[0] + arrOffset[0], midPoint[1] + arrOffset[1]];
	                        if (this.options.style.lineType !== Connector.TYPE_CHAIN) {
	                            textPostion = [textPostion[0] - textWidth / 2, textPostion[1] - textHeight / 2];
	                        }
	                    }
	                    break;
	            }
	        } else {
	            var position = this.middle(text);
	            textPostion = [position[0] - textWidth / 2, position[1]];
	        }
	
	        return textPostion;
	    };
	
	    /**
	     * 获取线段的旋转角度
	     * @param  {Object} textPostion {x,y}
	     * @return {Number}             角度值
	     */
	    Connector.prototype.getTextRotation = function(options) {
	        //计算出极坐标的角度
	        var points = Util.getMaxLineLength(this.turningPoints);
	        var midPoint = this.middle(options);
	        var angle = -Math.atan2(points[1].y - midPoint[1], points[1].x - midPoint[0]); //,Math.PI/2
	        return angle;
	    };
	
	    Connector.prototype.createHoverStyle = function(el) {
	        if (this.options.hoverStyle && this.options.isEdit) {
	            graphic.setElementHoverStl(el, this.options.hoverStyle);
	
	            var symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) { graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle); }
	
	            el.on('mouseover', zrUtil.bind(function() {
	                graphic.doEnterHover(el);
	                if (symbolTo) { graphic.doEnterHover(symbolTo); }
	
	                this.groupCurve.eachChild(function(line) {
	                    graphic.doEnterHover(line);
	                });
	            }, this))
	            .on('mousemove', zrUtil.bind(function(e) {
	                var startPoint = this.turningPoints[0];
	                var endPoint = this.turningPoints[this.turningPoints.length - 1];
	                var startDiff = Math.abs(e.event.offsetX - startPoint.x) + Math.abs(e.event.offsetY - startPoint.y);
	                var endDiff = Math.abs(e.event.offsetX - endPoint.x) + Math.abs(e.event.offsetY - endPoint.y);
	                if (startDiff <= 15 || endDiff <= 15) {
	                    el.cursor = 'move';
	                    el.draggable = true;
	                } else {
	                    el.cursor = 'pointer';
	                    el.draggable = false;
	                }
	            }, this))
	            .on('mouseout', zrUtil.bind(function() {
	                graphic.doLeaveHover(el);
	                if (symbolTo) { graphic.doLeaveHover(symbolTo); }
	                this.groupCurve.eachChild(function(line) {
	                    graphic.doLeaveHover(line);
	                });
	            }, this));
	        }
	    };
	    /**
	     * 创建Node的连接点
	     * @private
	     *
	     * @return {[type]} [description]
	     */
	    Connector.prototype.createAllconnectionPoint = function() {
	        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);
	        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length - 1].clone(), ConnectionPoint.TYPE_CONNECTOR);
	    };
	
	    /**
	     * 创建连接点
	     * @private
	     * @param  {[type]} shape [description]
	     * @param  {[type]} point [description]
	     * @param  {[type]} type  [description]
	     * @return {[type]}       [description]
	     */
	    Connector.prototype.connectionPointCreate = function(shape, point, type) {
	        var conPoint = new ConnectionPoint(this, point, type, this.options);
	        this.conPointsGroup.add(conPoint.shape);
	    };
	
	    /**
	     * 清空控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.clearHandles = function() {
	        for (var i = 0; i < this.handles.length; i++) {
	            this.remove(this.handles[i].handleShape);
	        }
	        this.handles = [];
	        if (this.conPointsGroup) {
	            this.conPointsGroup.removeAll();
	        }
	        //恢复原来的颜色
	        this.removeSelectedStyle();
	    };
	
	    /**
	     * 更新控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.refreshHandles = function() {
	        var points = this.turningPoints;
	        var beizierPoints = [];
	        var x, y, type;
	        if (this.handles.length > 0) {
	            if (this.options.style.lineType == Connector.TYPE_CURVE) {
	                // 获取曲线的路径点集合
	                beizierPoints = this.getPointsFromCurve();
	            }
	            for(var i = 0; i < this.handles.length; i++) {
	                var associatedPoint = this.handles[i].associatedPoint;
	                type = this.handles[i].type;
	                var index = points.findIndex(function(item) {
	                    return item.x == associatedPoint.x && item.y == associatedPoint.y;
	                });
	                if (index > 1) {
	                    if (type == 'h') {
	                        x = points[index - 1].x;
	                        y = (points[index - 1].y + points[index].y) / 2;
	                    } else if (type == 'v') {
	                        x = (points[index - 1].x + points[index].x) / 2;
	                        y = points[index - 1].y;
	                    }
	                    if (this.options.style.lineType == Connector.TYPE_CURVE && beizierPoints.length > 0) {
	                        var beizierPoint = zrUtil.find(beizierPoints[index - 2], function(point) {
	                            var dValue;
	                            if (type === 'h') {
	                                dValue = Math.abs(point.y - y);
	                            } else if (type === 'v') {
	                                dValue = Math.abs(point.x - x);
	                            }
	                            return dValue < 1;
	                        });
	                        if (beizierPoint) {
	                            x = beizierPoint.x;
	                            y = beizierPoint.y;
	                        }
	                    }
	                    this.handles[i].update(x, y);
	                }
	            }
	        }
	    }
	
	    /**
	     * 创建拆线 线断的控制点
	     * 曲线控制点位置计算精确
	     * @return {[type]} [description]
	     */
	    Connector.prototype.shapeSetHandle = function() {
	        var points = this.turningPoints;
	        // 获取曲线的路径点集合
	        var beizierPoints = this.getPointsFromCurve();
	        var type;
	        for (var i = 1; i < points.length - 2; i++) {
	            var h;
	            var x, y;
	            //是否在一条线上
	            var isCollineaityFirst = Util.collinearity(points[i - 1], points[i], points[i + 1]);
	            var isCollineaitySecond = Util.collinearity(points[i], points[i + 1], points[i + 2]);
	            if ((!isCollineaityFirst && (!isCollineaitySecond || points[i + 1].equals(points[i + 2]))) || ((!isCollineaityFirst || points[i - 1].equals(points[i])) && !isCollineaitySecond)) {
	
	                if (points[i].x === points[i + 1].x) { //same vertical
	                    x = points[i].x;
	                    y = (points[i].y + points[i + 1].y) / 2;
	                    type = 'h';
	                } else if (points[i].y === points[i + 1].y) { // same horizontal
	                    x = (points[i].x + points[i + 1].x) / 2;
	                    y = points[i].y;
	                    type = 'v';
	                }
	                if (x && y) {
	                    if (this.options.style.lineType == Connector.TYPE_CURVE && beizierPoints.length > 0) {
	                        var beizierPoint = zrUtil.find(beizierPoints[i - 1], function(point) {
	                            var dValue;
	                            if (type === 'h') {
	                                dValue = Math.abs(point.y - y);
	                            } else if (type === 'v') {
	                                dValue = Math.abs(point.x - x);
	                            }
	                            return dValue < 1;
	                        });
	                        if (beizierPoint) {
	                            x = beizierPoint.x;
	                            y = beizierPoint.y;
	                        }
	                    }
	                    h = new Handle(type, x, y, this);
	                    h.associatedPoint = points[i + 1]; // 连线控制点与this.turningPoints关联
	                }
	                if (h) {
	                    this.add(h.handleShape);
	                    this.handles.push(h);
	                }
	
	            }
	        }
	    };
	
	
	    /**
	     * 创建箭头
	     * @param  {[type]} name       [description]
	     * @param  {[type]} options [description]
	     * @return {[type]}            [description]
	     */
	    Connector.prototype.createSymbol = function(name, options) {
	        var symbolType = options.symbol.type;
	        var symbolSize = options.symbol.size;
	        if (symbolType === 'none') {
	            return;
	        }
	
	        if (!zrUtil.isArray(symbolSize)) {
	            symbolSize = [symbolSize, symbolSize];
	        }
	
	        var symbolZIndex = options.z;
	
	        if (options.symbol.z) { symbolZIndex = options.symbol.z }
	
	        var symbolPath = symbolUtil.createSymbol(
	            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,
	            symbolSize[0], symbolSize[1], symbolZIndex, options.symbol.color
	        );
	        symbolPath.name = name;
	
	        return symbolPath;
	    };
	
	    Connector.prototype.draw = function(name, content) {
	
	    }
	
	    /**
	     * 绘制线段上的文本
	     * 用矩形代替文本
	     * @param  {[type]} content [description]
	     * @param  {[type]} name [description]
	     * @param  {[type]} x       [description]
	     * @param  {[type]} y       [description]
	     * @param  {[type]} color   [description]
	     * @return {[type]}         [description]
	     */
	    Connector.prototype.drawText = function(name, content, x, y, type) {
	        if (!type) {
	            type = 'text';
	        }
	        var opt = zrUtil.isString(content) ? (type === 'text' ? {text:content, x:x, y:y} : {image:content, x:x, y:y})
	                                           : zrUtil.defaults({x:x, y:y}, content, true);
	
	        var textStyle = zrUtil.defaults(zrUtil.clone(this.options.text), opt, true);
	        var node;
	        if (type === 'text') {
	            var textBoundingRect = this.getTextBoundingRect(textStyle);
	            textStyle = zrUtil.defaults(textStyle, { fill: '#F9F9F9', transformText: true }, true);
	            node = new graphic.Rect({
	                shape: { width: textBoundingRect.width, height: textBoundingRect.height },
	                style: textStyle,
	                zlevel: 20,
	                name : name
	            });
	        } else {
	            node = new graphic.Image({
	                type: 'LinkImage',
	                style: textStyle,
	                zlevel: 20,
	                name : name
	            });
	        }
	        return {
	            text: node,
	            rect: node.getBoundingRect()
	        };
	    };
	     /**
	     * 获取线段文本包围盒
	     * @param  {[type]} content [description]
	     * @return {[type]}         [description]
	     */
	    Connector.prototype.getTextBoundingRect = function(text) {
	        var textRect = graphic.textContain.getBoundingRect(text.text, text.textFont);
	        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	        var textHeight = textRect.height || 12;
	        return {
	            width: textWidth,
	            height: textHeight
	        }
	    };
	
	    /**
	     * 获取线段的中间值
	     * @return {[type]} text
	     */
	    Connector.prototype.middle = function() {
	
	        if (this.options.style.lineType == Connector.TYPE_STRAIGHT || this.options.style.lineType == Connector.TYPE_CHAIN) {
	            var points = Util.getMaxLineLength(this.turningPoints);
	            //如果是求线段上的文字的中间值
	            // if(text) {
	            //     //取出字的长度，计算角度，
	            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	            //     var angle = Util.getAngle(points[0],points[1]);
	            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;
	            //     var newPoint = Util.getEndPoint(points[0], length, angle);
	            //     return [newPoint.x, newPoint.y];
	            // } else {
	            //     var middleX = (points[0].x + points[1].x)/2;
	            //     var middleY = (points[0].y + points[1].y) /2;
	            //     return [middleX, middleY];
	            // }
	            var middleX = (points[0].x + points[1].x) / 2;
	            var middleY = (points[0].y + points[1].y) / 2;
	            return [middleX, middleY];
	        } else if (this.options.style.lineType == Connector.TYPE_JAGGED) {
	
	            //find total distance
	            var distance = this.getLength();
	
	            //find between what turning points the half distance is
	            var index = -1;
	            var ellapsedDistance = 0;
	            for (var i = 0; i < this.turningPoints.length - 1; i++) {
	                index = i;
	                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);
	                if (ellapsedDistance + segment < distance / 2) {
	                    ellapsedDistance += segment;
	                } else {
	                    break;
	                }
	            }
	
	            //we have the middle distance somewhere between i(ndex) and i(ndex)+1
	            if (index != -1) {
	                var missingDistance = distance / 2 - ellapsedDistance;
	                if (Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3)) { //vertical segment (same x)
	                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];
	                } else if (Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3)) { //horizontal segment (same y)
	                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];
	                } else {
	                    console.error("Connector:middle() - this should never happen " + this.turningPoints[index] + " " + this.turningPoints[index + 1] + " nr of points " + this.turningPoints.length);
	                }
	
	            }
	        } else if (this.options.style.lineType == Connector.TYPE_CURVE) {
	            var t = 0.5;
	            var l = this.getLength();
	
	            var walked = 0;
	            for (var j = 0; j < this.turningPoints.length - 1; j++) {
	                if (walked + Util.distance(this.turningPoints[j], this.turningPoints[j + 1]) > l * t) {
	                    break;
	                }
	
	                walked += Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);
	            }
	
	            var rest = l * t - walked;
	            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);
	
	            //find the position/ration of the middle of Polyline on current segment
	            var segmentPercent = rest / currentSegmentLength;
	
	            var Xp = segmentPercent * (this.turningPoints[j + 1].x - this.turningPoints[j].x) + this.turningPoints[j].x;
	            var Yp = segmentPercent * (this.turningPoints[j + 1].y - this.turningPoints[j].y) + this.turningPoints[j].y;
	
	            return [Xp, Yp];
	
	        }
	
	        return null;
	    };
	
	    /**
	     * find total distance
	     * @return {Number} [description]
	     */
	    Connector.prototype.getLength = function() {
	        //find total distance
	        var distance = 0;
	        for (var i = 0; i < this.turningPoints.length - 1; i++) {
	            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);
	        }
	        return distance;
	    };
	
	    /**
	     * 转JSON对象 bpmn使用
	     * @return {[type]} [description]
	     */
	    Connector.prototype.toJSON = function() {
	
	        this.model.set("resourceId", this.resourceId);
	        this.model.set("properties.type", 14);
	
	        this.model.set("bounds.upperLeft.x", this.position[0]);
	        this.model.set("bounds.upperLeft.y", this.position[1]);
	        this.model.set("bounds.lowerRight.x", parseInt(this.position[0] + this.getBoundingRect().width));
	        this.model.set("bounds.lowerRight.y", parseInt(this.position[1] + this.getBoundingRect().height));
	        this.model.set("style.sPos", this.options.position.startPos);
	        this.model.set("style.ePos", this.options.position.endPos);
	        this.model.set("style.lineDash", this.options.style.lineDash);
	        this.model.set("style.stroke", this.options.style.stroke);
	        this.model.set("symbol.type", this.options.symbol.type);
	        this.model.set("dockers", this.turningPoints);
	        return this.model.option;
	    };
	
	    /**
	     * refreshModel  flow当序列化的时候调用 更新线段的位置 及线上的icons
	     * @return {[type]} [description]
	     */
	    Connector.prototype.refreshModel = function() {
	        this.model.set("options", zrUtil.clone(this.options));
	        this.model.set("options.dockers", this.turningPoints);
	        var icons = [];
	        for (var i = 0; i < this.icons.length; i++) {
	            var iconNode = this.icons[i];
	            var option = [iconNode.key, {
	                icon: iconNode.style.image,
	                width: iconNode.style.width,
	                height: iconNode.style.height
	            }];
	            icons.push(option);
	        }
	        this.model.set("icons", icons);
	    };
	
	    /**
	     * 调整曲线的形状
	     * @param  {array} points 点数组
	     * @return {void}
	     */
	    Connector.prototype.modifyCurve = function(points) {
	        var sol = this.getCurvePoint(points);
	
	        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段
	        var willDelCurves = [];
	        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve; j++) {
	            willDelCurves.push(this.groupCurve.childAt(j));
	        }
	        zrUtil.each(willDelCurves, function(curve) {
	            this.groupCurve.remove(curve);
	        }, this);
	        // 2. 遍历曲线   如果存在则直接设置形状，否则创建
	        for (var i = 0; i < sol.length; i++) {
	            var line = this.groupCurve.childAt(i);
	            if (line) {
	                line.attr('shape', sol[i]);
	            } else {
	                var cure = new graphic.BezierCurve({
	                   // position: this.options.position,
	                    style: this.options.style,
	                    shape: sol[i],
	                    z: this.options.z
	                });
	                this.groupCurve.add(cure);
	                this.createHoverStyle(cure);
	            }
	        }
	    };
	
	    /**
	     * @desc 获取点，这里可以设置点的个数
	     * @param {number} num 点个数
	     * @param {Array} p1 点坐标
	     * @param {Array} p2 点坐标
	     * @param {Array} p3 点坐标
	     * @param {Array} p4 点坐标
	     * 如果参数是 num, p1, p2 为一阶贝塞尔
	     * 如果参数是 num, p1, c1, p2 为二阶贝塞尔
	     * 如果参数是 num, p1, c1, c2, p2 为三阶贝塞尔
	     */
	    Connector.prototype.getBezierPoints = function(point, num) {
	        var points = [];
	        var func = null;
	        var start = point.start;
	        var cp1 = point.cp1;
	        var cp2 = point.cp2;
	        var end = point.end;
	        if (!num || num <= 50) {
	            num = 50;
	        }
	        if (!cp1 && !cp2) {
	            func = this.oneBezier;
	        } else if (cp1 && !cp2) {
	            func = this.twoBezier;
	        } else if (cp1 && cp2) {
	            func = this.threeBezier;
	        }
	        for (var i = 0; i < num; i++) {
	            points.push(func(i / num, start, cp1, cp2, end));
	        }
	        points.push(end);
	        return points;
	    };
	
	    /**
	     * @desc 一阶贝塞尔
	     * @param {number} t 当前百分比
	     * @param {Array} start 起点坐标
	     * @param {Array} end 终点坐标
	     */
	    Connector.prototype.oneBezier = function(t, start, cp1, cp2, end) {
	        var x1 = start.x1;
	        var y1 = start.y1;
	        var x2 = end.x2;
	        var y2 = end.y2;
	        return {
	            x: x1 + (x2 - x1) * t,
	            y: y1 + (y2 - y1) * t
	        }
	    };
	
	    /**
	     * @desc 二阶贝塞尔
	     * @param {number} t 当前百分比
	     * @param {Array} start 起点坐标
	     * @param {Array} end 终点坐标
	     * @param {Array} cp1 控制点
	     */
	    Connector.prototype.twoBezier = function(t, start, cp1, cp2, end) {
	        var x1 = start.x1;
	        var y1 = start.y1;
	        var x2 = end.x2;
	        var y2 = end.y2;
	        var cpx1 = cp1.cpx1;
	        var cpy1 = cp1.cpy1;
	        var x = (1 - t) * (1 - t) * x1 + 2 * t * (1 - t) * cpx1 + t * t * x2;
	        var y = (1 - t) * (1 - t) * y1 + 2 * t * (1 - t) * cpy1 + t * t * y2;
	        return {
	            x: x,
	            y: y
	        }
	    };
	
	    /**
	     * @desc 三阶贝塞尔
	     * @param {number} t 当前百分比
	     * @param {Array} start 起点坐标
	     * @param {Array} end 终点坐标
	     * @param {Array} cp1 控制点
	     * @param {Array} cp2 控制点
	     */
	    Connector.prototype.threeBezier = function(t, start, cp1, cp2, end) {
	        var x1 = start.x1;
	        var y1 = start.y1;
	        var x2 = end.x2;
	        var y2 = end.y2;
	        var cpx1 = cp1.cpx1;
	        var cpy1 = cp1.cpy1;
	        var cpx2 = cp2.cpx2;
	        var cpy2 = cp2.cpy2;
	        var x =
	            x1 * (1 - t) * (1 - t) * (1 - t) +
	            3 * cpx1 * t * (1 - t) * (1 - t) +
	            3 * cpx2 * t * t * (1 - t) +
	            x2 * t * t * t;
	        var y =
	            y1 * (1 - t) * (1 - t) * (1 - t) +
	            3 * cpy1 * t * (1 - t) * (1 - t) +
	            3 * cpy2 * t * t * (1 - t) +
	            y2 * t * t * t;
	        return {
	            x: x,
	            y: y
	        }
	    };
	
	    /**
	     * 获取曲线上的点轨迹
	     * @return {array}
	     */
	    Connector.prototype.getPointsFromCurve = function() {
	        var that = this;
	        var percent = 0;
	        var points = this.turningPoints;
	        var maxMinPoints = Util.getMaxLineLength(points);
	        var beizierPoints = [];
	        percent = parseInt(maxMinPoints[0].x - maxMinPoints[1].x);
	        if ((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {
	            var sols = this.transformCurvePoint(this.getCurvePoint(points));
	            if (sols.length > 0) {
	                sols.forEach(function(item) {
	                    beizierPoints.push(that.getBezierPoints(item, percent))
	                });
	            }
	        }
	        return beizierPoints;
	    }
	
	    /**
	     * 根据传入的点数组转换成需要的类型
	     * @param  {array} sol 点数组
	     * @return {object}
	     */
	    Connector.prototype.transformCurvePoint = function(sol) {
	        var points = [];
	        sol.forEach(function(point) {
	            var pointParam = {};
	            if (point.x1 && point.y1) {
	                pointParam.start = {
	                    x1: point.x1,
	                    y1: point.y1
	                }
	            }
	            if (point.cpx1 && point.cpy1) {
	                pointParam.cp1 = {
	                    cpx1: point.cpx1,
	                    cpy1: point.cpy1
	                }
	            }
	            if (point.cpx2 && point.cpy2) {
	                pointParam.cp2 = {
	                    cpx2: point.cpx2,
	                    cpy2: point.cpy2
	                }
	            }
	            if (point.x2 && point.y2) {
	                pointParam.end = {
	                    x2: point.x2,
	                    y2: point.y2
	                }
	            }
	            points.push(pointParam);
	        });
	        return points;
	    }
	
	    /**
	     * 根据传入的点数组计算曲线的点
	     * @param  {array} P 点数组
	     * @return {object}        曲线的点数组
	     */
	    Connector.prototype.getCurvePoint = function(P) {
	        var n = P.length;
	        var sol = [];
	        if (n === 3) {
	            sol.push({
	                x1: P[0].x,
	                y1: P[0].y,
	                cpx1: P[1].x,
	                cpy1: P[1].y,
	                x2: P[2].x,
	                y2: P[2].y
	            });
	            return sol;
	        } else if (n === 4) {
	            sol.push({
	                x1: P[0].x,
	                y1: P[0].y,
	                cpx1: P[1].x,
	                cpy1: P[1].y,
	                cpx2: P[2].x,
	                cpy2: P[2].y,
	                x2: P[3].x,
	                y2: P[3].y
	            });
	            return sol;
	        }
	
	
	        /**Computes the sum between two point
	         *@param p1 - {Point}
	         *@param p2 - {Point}
	         *@return {Point} the sum of initial points
	         **/
	        function sum(p1, p2) {
	            return new Point(p1.x + p2.x, p1.y + p2.y);
	        }
	
	
	        /**Computes the division of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function divide(p, nr) {
	            if (nr == 0) {
	                throw "Division by zero not allowed (yet :) " + this.callee;
	            }
	            return new Point(p.x / nr, p.y / nr);
	        }
	
	        /**Computes the multiplication of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function multiply(p, nr) {
	            return new Point(p.x * nr, p.y * nr);
	        }
	
	
	
	
	        /*
	         *I do not get why first 4 must be 0 and last 3 of same value.....
	         *but otherwise we will get division by zero
	         */
	        var k = [0, 0, 0];
	
	        var j;
	        for (j = 0; j <= n - 3; j++) {
	            k.push(j);
	        }
	
	        k.push(n - 3, n - 3);
	
	
	
	        for (var i = 1; i <= n - 3; i++) {
	            //q1 - compute start point
	            var q1 = divide(sum(multiply(P[i], k[i + 4] - k[i + 2]), multiply(P[i + 1], k[i + 2] - k[i + 1])), k[i + 4] - k[i + 1]);
	
	            //q0 - compute 1st controll point
	            var q_01 = (k[i + 3] - k[i + 2]) / (k[i + 3] - k[i + 1]);
	            var q_02 = divide(sum(multiply(P[i - 1], k[i + 3] - k[i + 2]), multiply(P[i], k[i + 2] - k[i])), k[i + 3] - k[i]);
	            var q_03 = multiply(q1, (k[i + 2] - k[i + 1]) / (k[i + 3] - k[i + 1]));
	            var q0 = sum(multiply(q_02, q_01), q_03);
	
	            //q2 - compute 2nd controll point
	            var q2 = divide(sum(multiply(P[i], k[i + 4] - k[i + 3]), multiply(P[i + 1], k[i + 3] - k[i + 1])), k[i + 4] - k[i + 1]);
	
	            //q3 - compute end point
	            var q_31 = (k[i + 3] - k[i + 2]) / (k[i + 4] - k[i + 2]);
	            var q_32 = divide(sum(multiply(P[i + 1], k[i + 5] - k[i + 3]), multiply(P[i + 2], k[i + 3] - k[i + 2])), k[i + 5] - k[i + 2]);
	            var q_33 = multiply(q2, (k[i + 4] - k[i + 3]) / (k[i + 4] - k[i + 2]));
	            var q3 = sum(multiply(q_32, q_31), q_33);
	
	            //store solution
	            //
	            sol.push({
	                x1: q0.x,
	                y1: q0.y,
	                cpx1: q1.x,
	                cpy1: q1.y,
	                cpx2: q2.x,
	                cpy2: q2.y,
	                x2: q3.x,
	                y2: q3.y
	            });
	        }
	
	        return sol;
	    };
	
	
	    Util.inherits(Connector, Node);
	
	    module.exports = Connector;
	
	


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// Symbol factory
	
	
	    var graphic = __webpack_require__(3);
	    var BoundingRect = __webpack_require__(26);
	    /**
	     * Triangle shape
	     * @inner
	     */
	    var Triangle = graphic.extendShape({
	        type: 'triangle',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy + height);
	            path.lineTo(cx - width, cy + height);
	            path.closePath();
	        }
	    });
	    /**
	     * Diamond shape
	     * @inner
	     */
	    var Diamond = graphic.extendShape({
	        type: 'diamond',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy);
	            path.lineTo(cx, cy + height);
	            path.lineTo(cx - width, cy);
	            path.closePath();
	        }
	    });
	
	    /**
	     * Pin shape
	     * @inner
	     */
	    var Pin = graphic.extendShape({
	        type: 'pin',
	        shape: {
	            // x, y on the cusp
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (path, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var w = shape.width / 5 * 3;
	            // Height must be larger than width
	            var h = Math.max(w, shape.height);
	            var r = w / 2;
	
	            // Dist on y with tangent point and circle center
	            var dy = r * r / (h - r);
	            var cy = y - h + r + dy;
	            var angle = Math.asin(dy / r);
	            // Dist on x with tangent point and circle center
	            var dx = Math.cos(angle) * r;
	
	            var tanX = Math.sin(angle);
	            var tanY = Math.cos(angle);
	
	            path.arc(
	                x, cy, r,
	                Math.PI - angle,
	                Math.PI * 2 + angle
	            );
	
	            var cpLen = r * 0.6;
	            var cpLen2 = r * 0.7;
	            path.bezierCurveTo(
	                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,
	                x, y - cpLen2,
	                x, y
	            );
	            path.bezierCurveTo(
	                x, y - cpLen2,
	                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,
	                x - dx, cy + dy
	            );
	            path.closePath();
	        }
	    });
	
	    /**
	     * Arrow shape
	     * @inner
	     */
	    var Arrow = graphic.extendShape({
	
	        type: 'arrow',
	
	        shape: {
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var height = shape.height;
	            var width = shape.width;
	            var x = shape.x;
	            var y = shape.y;
	            var dx = width / 3 * 2;
	            ctx.moveTo(x, y);
	            ctx.lineTo(x + dx, y + height);
	            ctx.lineTo(x, y + height / 4 * 3);
	            ctx.lineTo(x - dx, y + height);
	            ctx.lineTo(x, y);
	            ctx.closePath();
	        }
	    });
	
	    /**
	     * Map of path contructors
	     * @type {Object.<string, module:zrender/graphic/Path>}
	     */
	    var symbolCtors = {
	        line: graphic.Line,
	
	        rect: graphic.Rect,
	
	        roundRect: graphic.Rect,
	
	        square: graphic.Rect,
	
	        circle: graphic.Circle,
	
	        diamond: Diamond,
	
	        pin: Pin,
	
	        arrow: Arrow,
	
	        triangle: Triangle
	    };
	
	    var symbolShapeMakers = {
	
	        line: function (x, y, w, h, shape) {
	            // FIXME
	            shape.x1 = x;
	            shape.y1 = y + h / 2;
	            shape.x2 = x + w;
	            shape.y2 = y + h / 2;
	        },
	
	        rect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        roundRect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	            shape.r = Math.min(w, h) / 4;
	        },
	
	        square: function (x, y, w, h, shape) {
	            var size = Math.min(w, h);
	            shape.x = x;
	            shape.y = y;
	            shape.width = size;
	            shape.height = size;
	        },
	
	        circle: function (x, y, w, h, shape) {
	            // Put circle in the center of square
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.r = Math.min(w, h) / 2;
	        },
	
	        diamond: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        pin: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        arrow: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        triangle: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        }
	    };
	
	    var symbolBuildProxies = {};
	    for (var name in symbolCtors) {
	        symbolBuildProxies[name] = new symbolCtors[name]();
	    }
	
	    var Symbol = graphic.extendShape({
	
	        type: 'symbol',
	
	        shape: {
	            symbolType: '',
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        beforeBrush: function () {
	            var style = this.style;
	            var shape = this.shape;
	            // FIXME
	            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
	                style.textPosition = ['50%', '40%'];
	                style.textAlign = 'center';
	                style.textVerticalAlign = 'middle';
	            }
	        },
	
	        buildPath: function (ctx, shape) {
	            var symbolType = shape.symbolType;
	            var proxySymbol = symbolBuildProxies[symbolType];
	            if (shape.symbolType !== 'none') {
	                if (!proxySymbol) {
	                    // Default rect
	                    symbolType = 'rect';
	                    proxySymbol = symbolBuildProxies[symbolType];
	                }
	                symbolShapeMakers[symbolType](
	                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape
	                );
	                proxySymbol.buildPath(ctx, proxySymbol.shape);
	            }
	        }
	    });
	
	    // Provide setColor helper method to avoid determine if set the fill or stroke outside
	    var symbolPathSetColor = function (color) {
	        if (this.type !== 'image') {
	            var symbolStyle = this.style;
	            var symbolShape = this.shape;
	            if (symbolShape && symbolShape.symbolType === 'line') {
	                symbolStyle.stroke = color;
	            }
	            else if (this.__isEmptyBrush) {
	                symbolStyle.stroke = color;
	                symbolStyle.fill = '#fff';
	            }
	            else {
	                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
	                symbolStyle.fill && (symbolStyle.fill = color);
	                symbolStyle.stroke && (symbolStyle.stroke = color);
	            }
	            this.dirty();
	        }
	    };
	
	    var symbolUtil = {
	        /**
	         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
	         * @param {string} symbolType
	         * @param {number} x
	         * @param {number} y
	         * @param {number} w
	         * @param {number} h
	         * @param {number} z
	         * @param {string} color
	         */
	        createSymbol: function (symbolType, x, y, w, h, z, color) {
	            var isEmpty = symbolType.indexOf('empty') === 0;
	            if (isEmpty) {
	                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
	            }
	            var symbolPath;
	
	            if (symbolType.indexOf('image://') === 0) {
	                symbolPath = new graphic.Image({
	                    style: {
	                        image: symbolType.slice(8),
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	            else if (symbolType.indexOf('path://') === 0) {
	                symbolPath = graphic.makePath(symbolType.slice(7), {z: z, rectHover: true}, new BoundingRect(x, y, w, h));
	            }
	            else {
	                symbolPath = new Symbol({
	                    shape: {
	                        symbolType: symbolType,
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	
	            symbolPath.__isEmptyBrush = isEmpty;
	
	            symbolPath.setColor = symbolPathSetColor;
	
	            symbolPath.setColor(color);
	
	            return symbolPath;
	        }
	    };
	
	    module.exports = symbolUtil;
	


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 画句柄
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(3);
	    var Util = __webpack_require__(77);
	    function Handle(type, x, y, connector){
	        this.type = type;
	
	        this.x = x;
	
	        this.y = y;
	
	        this.visible = true;
	
	        this.connector = connector;
	
	        this.handleShape = new graphic.Circle({
	            shape: {
	                cx: x,
	                cy: y,
	                r: Handle.RADIUS
	            },
	
	            style: {
	                fill: "rgb(0,255,0)",
	                stroke:"rgb(0,0,0)"
	            },
	            zlevel : connector.options.z + 2,  //节点Z为1 线段为0;
	            draggable:true
	        });
	
	        var that = this;
	        this.handleShape.on("drag", function(e) {
	            that.actionConnector(e.offsetX,e.offsetY);
	        });
	       // return this.circle;
	    }
	
	    Handle.RADIUS = 4;
	
	    Handle.prototype = {
	
	        constructor : Handle,
	
	        equals : function(anotherHandle){
	            if(!anotherHandle instanceof Handle){
	                return false;
	            }
	
	            return this.type == anotherHandle.type
	            && this.x == anotherHandle.x
	            && this.y == anotherHandle.y
	            && this.visible == anotherHandle.visible;
	        },
	        update: function (x, y) {
	            this.handleShape.attr('position', [0, 0]);
	            this.x = x;
	            this.y = y;
	            this.handleShape.setShape({
	                cx: x,
	                cy: y
	            });
	        },
	
	        /**
	         * 移动句柄
	         * @param  {[type]} newX [description]
	         * @param  {[type]} newY [description]
	         * @return {[type]}      [description]
	         */
	        actionConnector: function(newX, newY){
	            switch(this.type){
	                case 'v':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if (this.associatedPoint && this.connector.turningPoints[i].x == this.associatedPoint.x && this.connector.turningPoints[i].y == this.associatedPoint.y) {
	                            index = i;
	                            break;
	                        }
	                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y
	                            && this.connector.turningPoints[i].y == this.y
	                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x
	                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)
	                        {
	                            index = i;
	                        }
	                    }
	                    var deltaY = newY - this.y;
	                    var translationMatrix = Util.translationMatrix(0, deltaY);
	
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	
	                    break;
	
	                case 'h':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if (this.associatedPoint && this.connector.turningPoints[i].x == this.associatedPoint.x && this.connector.turningPoints[i].y == this.associatedPoint.y) {
	                            index = i;
	                            break;
	                        }
	                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x
	                            && this.connector.turningPoints[i].x == this.x
	                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y
	                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)
	                            {
	                            index = i;
	                        }
	                    }
	                    var deltaX = newX-this.x;
	                    var translationMatrix = Util.translationMatrix(deltaX, 0);
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	
	                    break;
	            }
	           //. this.shape.updateMiddleText();
	        }
	    };
	    module.exports = Handle;
	
	
	


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连线动态效果
	 * @author miao.cunzhi
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var vec2 = __webpack_require__(14);
	    var curveUtil = __webpack_require__(30);
	    var symbolUtil = __webpack_require__(106);
	
	    function EffectLine(symbol, options, groupCurve, polyLine) {
	        this._lastFrame = 0;
	        this._lastFramePercent = 0;
	        this.symbol = symbol;
	        this.groupCurve = groupCurve;
	        this.initSymbol(options, polyLine);
	    }
	    var EffectLineProto = EffectLine.prototype;
	
	    EffectLineProto.initSymbol = function(options, polyLine) {
	        var that = this;
	        this.symbol.z2 = 100;
	        this.symbol.culling = true;
	        var period = options.effect.period * 1000;
	        this.symbol.__t = 0;
	        this.symbol.stopAnimation();
	        if ((options.style.lineType == "curve")) {
	            if (this.groupCurve) {
	                var i = 0;
	                period = period / this.groupCurve._children.length;
	                this.groupCurveAnimate(this.groupCurve._children[0], i, period);
	            }
	
	        } else {
	            this.symbol.animate('', true)
	                .when(period, {
	                    __t: 1
	                })
	                .delay(0)
	                .during(function() {
	                    that.updateSymbolPositionPolyline();
	                })
	                .start();
	            this.setAnimationPointsPolyline(polyLine.shape.points);
	        }
	
	    };
	
	    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {
	        var that = this;
	        if (curveLine == undefined) {
	            curveLine = this.groupCurve._children[0];
	            i = 0;
	        }
	        var points;
	        var pos = curveLine.shape;
	        points = [
	            [pos.x1, pos.y1],
	            [pos.x2, pos.y2],
	            [pos.cpx1, pos.cpy1],
	            [pos.cpx2, pos.cpy2]
	        ];
	        this.setAnimationPointsBezierCurve(points);
	        this.symbol.animate('')
	            .when(period, {
	                __t: 1
	            })
	            .delay(0)
	            .during(function() {
	                that.updateSymbolPositionBezierCurve();
	            })
	            .done(function() {
	                that.symbol.__t = 0;
	                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);
	            })
	            .start();
	
	    };
	
	
	    EffectLineProto.setAnimationPointsBezierCurve = function(points) {
	        this.symbol.__p1 = points[0];
	        this.symbol.__p2 = points[1];
	        this.symbol.__cp1 = points[2] || [
	            (points[0][0] + points[1][0]) / 2,
	            (points[0][1] + points[1][1]) / 2
	        ];
	        this.symbol.__cp2 = points[3];
	    };
	
	    EffectLineProto.updateSymbolPositionBezierCurve = function() {
	        var p1 = this.symbol.__p1;
	        var p2 = this.symbol.__p2;
	        var cp1 = this.symbol.__cp1;
	        var cp2 = this.symbol.__cp2;
	        var t = this.symbol.__t;
	        var pos = this.symbol.position;
	        var tx, ty;
	        if (cp2[0] != undefined) {
	            var cubicAt = curveUtil.cubicAt;
	            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;
	            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);
	            // Tangent
	            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);
	        } else {
	            var quadraticAt = curveUtil.quadraticAt;
	            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;
	            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);
	            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);
	            // Tangent
	            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);
	            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
	        }
	        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
	
	        this.symbol.ignore = false;
	    };
	
	    EffectLineProto.setAnimationPointsPolyline = function(points) {
	        this._points = points;
	        var accLenArr = [0];
	        var len = 0;
	        for (var i = 1; i < points.length; i++) {
	            var p1 = points[i - 1];
	            var p2 = points[i];
	            len += vec2.dist(p1, p2);
	            accLenArr.push(len);
	        }
	        if (len === 0) {
	            return;
	        }
	
	        for (var j = 0; j < accLenArr.length; j++) {
	            accLenArr[j] /= len;
	        }
	        this._offsets = accLenArr;
	        this._length = len;
	        this.symbol._lastFrame = 0;
	        this.symbol.__lastFramePercent = 0;
	    };
	
	    EffectLineProto.updateSymbolPositionPolyline = function() {
	        var t = this.symbol.__t;
	        var points = this._points;
	        var offsets = this._offsets;
	        var len = points.length;
	
	        if (!offsets) {
	            // Has length 0
	            return;
	        }
	
	        var lastFrame = this._lastFrame;
	        var frame;
	
	        if (t < this._lastFramePercent) {
	            // Start from the next frame
	            // PENDING start from lastFrame ?
	            var start = Math.min(lastFrame + 1, len - 1);
	            for (frame = start; frame >= 0; frame--) {
	                if (offsets[frame] <= t) {
	                    break;
	                }
	            }
	            // PENDING really need to do this ?
	            frame = Math.min(frame, len - 2);
	        } else {
	            for (var frame = lastFrame; frame < len; frame++) {
	                if (offsets[frame] > t) {
	                    break;
	                }
	            }
	            frame = Math.min(frame - 1, len - 2);
	        }
	        vec2.lerp(
	            this.symbol.position, points[frame], points[frame + 1],
	            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])
	        );
	
	        this._lastFrame = frame;
	        this._lastFramePercent = t;
	        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);
	        this.symbol.rotation = angle - Math.PI / 2;
	        this.symbol.ignore = false;
	    };
	    module.exports = EffectLine;
	


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 控制点
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(3);
	    function ConnectionPoint(connector, point, type, options){
	        this.connector = connector;
	
	        this.point = point.clone();
	
	        this.type = type;
	
	        this.color = ConnectionPoint.NORMAL_COLOR;
	
	        this.oType = 'ConnectionPoint';
	
	        this.shape = new graphic.Circle({
	            shape: {
	                cx: this.point.x,
	                cy: this.point.y,
	                r: ConnectionPoint.RADIUS
	            },
	
	            style: {
	                fill: this.color,
	                stroke:'#000000'
	            },
	            z : options.z + 2  //节点Z为1 线段为0;
	        });
	        this.shape.type =  this.type;
	
	        this.shape.connector = connector;
	        //return this.circle;
	    }
	
	    ConnectionPoint.NORMAL_COLOR = "#FFFF33"; //yellow.
	
	    ConnectionPoint.OVER_COLOR = "#FF9900"; //orange
	
	    ConnectionPoint.CONNECTED_COLOR = "#ff0000"; //red
	
	    ConnectionPoint.RADIUS = 4;
	
	    ConnectionPoint.TYPE_FIGURE = 'figure';
	
	    ConnectionPoint.TYPE_CONNECTOR = 'connector';
	
	    ConnectionPoint.prototype = {
	
	        constructor : ConnectionPoint,
	
	        equals : function(anotherConnectionPoint){
	            return this.point.equals(anotherConnectionPoint.point)
	            && this.connector == anotherConnectionPoint.connector
	            && this.type == anotherConnectionPoint.type
	            && this.color == anotherConnectionPoint.color
	            && this.radius == anotherConnectionPoint.radius;
	        }
	
	
	    };
	    module.exports = ConnectionPoint;
	
	
	


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 组， 组中元素的坐标都是相对于这个组的<br>
	 * @class fishTopoFlow.node.GroupNode
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var group1 = new node.Group({
	 *           position:[60,50]
	 *       });
	 *
	 *       var rect1 = new node.Rect({
	 *           shape:{width:120,height:30},
	 *           style:{text:"标题", fill:"#FFB90F",stroke:"#bbbbbb"},
	 *           position:[0,0],
	 *           selectable:false
	 *       });
	 *
	 *       var rect2 = new node.Rect({
	 *           shape:{width:120,height:60},
	 *           style:{text:"内容", fill:"#FFFFFF",stroke:"#bbbbbb"},
	 *           position:[0,30],
	 *           selectable:false
	 *       });
	 *
	 *       group1.add(rect1);
	 *       group1.add(rect2);
	 *       fishTopo.add(group1);
	 */
	
	
	    var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(26);
	    var graphic = __webpack_require__(3);
	    var util = __webpack_require__(77);
	    var Model = __webpack_require__(83);
	    var Connector = __webpack_require__(105);
	
	    function GroupNode(opts) {
	        var model = new Model({});
			if (!opts.id) {
				opts.id = util.getUUID();
	        }
	        if (opts.style && opts.style.textLineHeight !== 0 && !opts.style.rich) { //#170
	            opts.style.rich = {};
	        }
	        model.set("elementType", "GroupNode");
	        if (opts.style && opts.style.host) {
	            delete opts.style.host;
	        }
	        model.set("options", zrUtil.clone(opts));
	        if ("draggable" in opts) {
	            opts.isdraggable = opts.draggable;
	            delete opts.draggable;
	        }
	        if (!opts.z) {
	            opts.z = 1; //节点默认为1，线段0;
	        }
	
	        if (util.isUndefined(opts.hoverAnimation)) {
	            opts.hoverAnimation = false;
	        }
	
	        if (util.isUndefined(opts.selectable)) {
	            opts.selectable = true;  //默认可以选中
	        }
	        this.model = model;
	        graphic.Group.call(this, opts);
	
	        var defaultOptions = {
	            shape: {
	                width: 5,
	                height: 5,
	                r: 5
	            },
	            style: {
	                fill: 'rgba(0,0,0,0)',//'#f9f9f9',
	                stroke: 'rgba(0,0,0,0)'//'#bbbbbb'
	            },
	            position: [0, 0]
	        };
	        this.options = zrUtil.merge(defaultOptions, opts, true);
	        this.render(this.options);
	    }
	    GroupNode.RECT_NAME = "GROUP_RECT_NAME";
	    GroupNode.prototype = {
	        constructor: GroupNode,
	        type: "GroupNode",
	        render: function (model) {
	            var rect = new graphic.Rect({
	                shape: model.shape,
	                style: model.style,
	                //silent:true, //加上后 拖动 组中没有子元素的地方 无法手动了
	                z: 3
	            });
	            rect.name = GroupNode.RECT_NAME;
	            this.add(rect);
	            this.position = model.position;
	        },
	        rectContain: function (x, y) {
	            var rect = util.getRect(this);
	            return rect.boundingRect.contain(x, y);
	        },
	
	        add: function(child) {
	            if (child && child !== this && child.parent !== this) {
	                this._children.push(child);
	                this._doAdd(child);
	            }
	            this._api && this._api._addGroupNode(this,child);
	            return this;
	
	        },
	
	        /**
	         * 遍历组中每一个子节点
	         * @param  {Function} cb 回调函数cb
	         * @param  {Object} context   上下文context
	         */
	        each: function (cb, context) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                if (child.name != GroupNode.RECT_NAME) {
	                    cb.call(context, child, i);
	                }
	            }
	            return this;
	        },
	
	        getRect: function () {
	            var boundingRect = this.getBoundingRect();
	            //创建最小包围盒虚线
	            var points = [];
	            points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];
	            points[1] = [boundingRect.width / 2, -boundingRect.height / 2];
	            points[2] = [boundingRect.width / 2, boundingRect.height / 2];
	            points[3] = [-boundingRect.width / 2, boundingRect.height / 2];
	            points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];
	
	            var boundRect = new BoundingRect(this.position[0],
	                this.position[1],
	                boundingRect.width, boundingRect.height);
	            return {
	                x: this.position[0] + boundingRect.width / 2,
	                y: this.position[1] + boundingRect.height / 2,
	                width: boundingRect.width,
	                height: boundingRect.height,
	                points: points,
	                boundingRect: boundRect
	            };
	        },
	
	        setPosition: function(pX,pY) {
	            var boundingRect = this.getBoundingRect();
	            this.attr('position',[pX-boundingRect.width/2,pY-boundingRect.height/2]);
	
	        },
	
	        setProperties: function (opt) {
	            var rect = this.childOfName(GroupNode.RECT_NAME);
	            rect.setShape(opt.shape);
	            this.attr('position', opt.position);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.options.shape;
	            var newW = Number(shape.width * scaleRatio);
	            var newH = Number(newW * shape.height / shape.width);
	            if (ifParse) {
	                newW = parseInt(newW, 10);
	                newH = parseInt(newH, 10);
	            }
	            // 按比例缩放
	            this.setProperties({
	                shape: {
	                    width: newW,
	                    height: newH
	                }
	            });
	            // 更新组内节点
	            this.children().forEach(function(v) {
	                var position = v.position;
	                if (v.name !== GroupNode.RECT_NAME && !(v instanceof Connector) && v.type !== 'ZPath') {
	                    // 每个节点的position更新
	                    v.updateShape(ratio, ifParse);
	                    v.attr('position', [position[0] * scaleRatio, position[1] * scaleRatio]);
	                } else {
	                    var rect = v.rect;
	                    rect.height = rect.height * scaleRatio;
	                    rect.width = rect.width * scaleRatio;
	                    v.attr({
	                        position: [position[0] * scaleRatio, position[1] * scaleRatio],
	                        rect: rect
	                    });
	                }
	            });
	        }
	    }
	
	    zrUtil.inherits(GroupNode, graphic.Group);
	    module.exports = GroupNode;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 选中节点后，出现的操作框及按钮
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var Bpmn = __webpack_require__(104);
	    var BpmnUtil = __webpack_require__(76);
	    var OperationNode = __webpack_require__(112);
	    var Util = __webpack_require__(77);
	
	    function BpmnOperationNode(node, zr, forbidEdit) {
	        OperationNode.call(this, node, zr, forbidEdit);
	    }
	
	    BpmnOperationNode.prototype.refreshPositionOther = function(node,nodeRect) {
	
	        // 计算整个的位置
	        if (node.parent) {
	            if (Bpmn.isSubProcess(node.parent)) {
	                this.attr("position", [nodeRect.x + BpmnUtil.parentX(node.parent), nodeRect.y + BpmnUtil.parentY(node.parent)])
	            }
	        } else {
	            this.attr("position", [nodeRect.x, nodeRect.y])
	        }
	
	    };
	
	    BpmnOperationNode.prototype.refreshPostion = function(node, nodeRect) {
	        if (node.parent && Bpmn.isSubProcess(node.parent)) {
	            nodeRect.x -= BpmnUtil.parentX(node.parent);
	            nodeRect.y -= BpmnUtil.parentY(node.parent);
	            nodeRect.boundingRect.x = nodeRect.boundingRect.x - BpmnUtil.parentX(node.parent);
	            nodeRect.boundingRect.y = nodeRect.boundingRect.y - BpmnUtil.parentY(node.parent);
	        }
	        var i = 0;
	        var rbPoint = zrUtil.clone(nodeRect.points[2]); //取右下角坐标
	        var rotation = nodeRect.rotation || node.rotation;
	        var angle = rotation / (Math.PI/180);
	        if (Math.abs(rotation) > 0) {
	            var connectorControls = Util.getConnectorControls(nodeRect, node);
	            var brControl = connectorControls.br;
	            rbPoint = [brControl.x - nodeRect.x,  brControl.y - nodeRect.y];
	        }
	        //1.定位虚框
	        if (this.virtualRect) {
	            this.virtualRect.setShape({ points: nodeRect.points });
	            this.virtualRect.attr('rotation', rotation);
	        }
	        //2.定位每个小图标
	        this.eachChild(function(nodeItem) {
	            if (!nodeItem.isSelfComputePos) {
	                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离
	                nodeItem.attr("position", [angle >= 0 ? rbPoint[0] + 8 + (i++ * 20) : rbPoint[0] - 20 - (i++ * 20), rbPoint[1] - 10]);
	            }
	        });
	
	        this.refreshPositionOther(node,nodeRect);
	    };
	
	    BpmnOperationNode.ARROW_DRAGEND = "OperationNode:dragendArrow";
	    BpmnOperationNode.ARROW_DRAG = "OperationNode:dragArrow";
	    BpmnOperationNode.ARROW_DRAGSTART = "OperationNode:dragstartArrow";
	    BpmnOperationNode.DELETE_CLICK = "OperationNode:deleteClick";
	
	    zrUtil.inherits(BpmnOperationNode, OperationNode);
	
	
	    module.exports = BpmnOperationNode;
	


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 选中节点后，出现的操作框及按钮
	 * @author wang.xiaohu
	 */
	
	    var Node = __webpack_require__(80);
	    var zrUtil = __webpack_require__(4);
	    var Util = __webpack_require__(77);
	    var graphic = __webpack_require__(3);
	    var Connector = __webpack_require__(105);
	    var env = __webpack_require__(49);
	    var icon = __webpack_require__(113);
	    var symbolUtil = __webpack_require__(106);
	    function OperationNode(node, zr, api,forbidEdit) {
	        Node.call(this);
	        this.node = node;
	        this.zr = zr;
	        this.forbidEdit = forbidEdit;
	        this._api = api;
	        this.render();
	    }
	
	    //事件
	    OperationNode.ARROW_DRAGEND = "OperationNode:dragendArrow";
	    OperationNode.ARROW_DRAG = "OperationNode:dragArrow";
	    OperationNode.ARROW_DRAGSTART = "OperationNode:dragstartArrow";
	    OperationNode.DELETE_CLICK = "OperationNode:deleteClick";
	    OperationNode.DEL = "DEL";
	    OperationNode.COMMENT_CLICK = "OperationNode:commentClick";
	    OperationNode.COMMENT = "COMMENT";
	        //内置操作图标的图像
	    OperationNode.opicons = {
	        STRAIGHT: icon.STRAIGHT_SVG,
	        JAGGED: icon.JAGGED_SVG,
	        CURVE: icon.CURVE_SVG,
	        DEL: icon.DEL_SVG,
	        COMMENT: icon.COMMENT_SVG
	    };
	
	    OperationNode.prototype.render = function() {
	        this.renderBase();
	        if (!this.forbidEdit) {
	            this.renderOther();
	        }
	    };
	
	    OperationNode.prototype.renderBase = function() {
	        this.createOperation();
	    };
	
	    OperationNode.prototype.createOperation = function() {
	        var me = this;
	        var ifShowNodeOperationIcons = this.node.operationIcons;
	        if (this.node.parent && this.node.parent.type === 'dragSelect') {
	            ifShowNodeOperationIcons = false;
	        }
	        if (!this.node.selectStyle) {
	            this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });
	            this.virtualRect.isSelfComputePos = true;  // 自己计算位置
	            this.add(this.virtualRect);
	        } else {
	             if (this.node.type === 'ZPath') {  //addHover需要从它自身的构造函数中创建。1.Painter中addHover源码是根据shape与style创建 2.path中的构造函数是返回另一个元素
	                this.node._zCloneStyle = this.node.style.clone();
	                 this.node.setStyle(this.node.selectStyle);
	             } else if(this.node.setOrCancelSelectStyle) {
	                this.node.setOrCancelSelectStyle(true);
	             } else {
	                this._api.getZr().addHover(this.node, this.node.selectStyle);
	             }
	
	        }
	
	        if (ifShowNodeOperationIcons) {
	            zrUtil.each(this.node.operationIcons, function(item) {
	                //检查是否是内置图标
	                var opIconInstance = null;
	                var operationIcon = OperationNode.opicons[item.name.toUpperCase() + ""]
	                if (operationIcon) {
	
	                    if (this.forbidEdit) {
	                        return;
	                    }
	                    if (item.hidden) {
	                        return;
	                    }
	                    if (item.name == OperationNode.DEL) {
	                        //垃圾桶
	                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },z:me.node.z+1,rectHover: true }, { x: 0, y: 0, width: 10, height: 15 });
	
	                        if(item.callback){
	                            opIconInstance.on("click", function(e) {
	                                e.data = item;
	                                e.node = me.node;  // 将所附的节点也传递出去
	                                if (item.callback) {
	                                    item.callback(e);
	                                }
	                            });
	                        }else{
	                            opIconInstance.on("click", function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.target = this;
	                                params.type = OperationNode.DELETE_CLICK;
	                                me.trigger(params.type, params);
	                            });
	                        }
	                    } else if (item.name == OperationNode.COMMENT) {
	                        var rect = { x: 0, y: 0, width: 16, height: 16 };
	                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' }, z:me.node.z+2, rectHover: true }, rect);
	                        opIconInstance.on("click", function(e) {
	                            var params = {};
	                            params.event = e;
	                            params.target = this;
	                            params.type = OperationNode.COMMENT_CLICK;
	                            me.trigger(params.type, params);
	                        });
	                    } else {
	                        var rectOther = { x: 0, y: 0, width: 15, height: 15 };
	                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },draggable:true,z:me.node.z+2,lineType: Connector["TYPE_" + item.name.toUpperCase()],rectHover: true }, rectOther);
	                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	                            opIconInstance.on(eveName, function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.data = item.options
	                                params.type = "OperationNode:" + eveName + "Arrow";
	                                me.trigger(params.type, params);
	                            });
	                        });
	                    }
	
	                } else {
	                    opIconInstance = symbolUtil.createSymbol(item.iconPath, 0, 0, item.width || 15, item.height || 15, me.node.z+1, item.color||'#000');
	                    opIconInstance.on("click", function(e) {
	                        e.data = item;
	                        e.node = me.node;  // 将所附的节点也传递出去
	                        if (item.callback) {
	                            item.callback(e);
	                        }
	                        var param = {event:e, type:"OperationNode:" + item.name + "Click"};
	                        me._api.trigger(param.type, param);
	                    });
	                }
	                opIconInstance.name = item.name;
	                me.add(opIconInstance);
	            });
	        }
	    };
	
	    OperationNode.prototype.refreshPostion = function(node, nodeRect) {
	        var i = 0;
	        var rbPoint = zrUtil.clone(nodeRect.points[2]); //取右下角坐标
	        var rotation = node.rotation;
	        var angle = rotation / (Math.PI/180);
	        if (Math.abs(rotation) > 0) {
	            var connectorControls = Util.getConnectorControls(nodeRect, node);
	            var brControl = connectorControls.br;
	            rbPoint = [brControl.x - nodeRect.x,  brControl.y - nodeRect.y];
	        }
	        //1.定位虚框
	        if (this.virtualRect) {
	            this.virtualRect.setShape({ points: nodeRect.points });
	            if (node.parent && node.parent.childDraggable) {
	                this.virtualRect.attr('z', node.parent.z + 1)
	            }
	            this.virtualRect.attr('rotation', rotation);
	        }
	        //2.定位每个小图标
	        this.eachChild(function(nodeItem) {
	            if (!nodeItem.isSelfComputePos) {
	                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离
	                nodeItem.attr("position", [angle >= 0 ? rbPoint[0] + 8 + (i++ * 20) : rbPoint[0] - 20 - (i++ * 20), rbPoint[1] - 10]);
	            }
	        });
	
	        this.refreshPositionOther(node,nodeRect);
	    };
	
	    OperationNode.prototype.renderOther = function() {
	        //留给扩展使用
	    };
	    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {
	        //留给扩展使用
	        //3.定位整个operationNode
	        if ((node.parent && node.parent.isBg && node.parent.isBg == true) || (node.parent.type === "GroupNode")) {
	            this.attr("position", [nodeRect.x, nodeRect.y])
	        } else {
	            var nodeShapeX = node.shape? node.shape.x:0;
	            var nodeSahpeY = node.shape? node.shape.y:0;
	            this.attr("position", [nodeRect.x + node.parent.position[0]+nodeShapeX, nodeRect.y + node.parent.position[1]+nodeSahpeY])
	        }
	    };
	
	    OperationNode.prototype.cleanup = function() {
	        if(this.node.selectStyle) {
	            if (this.node.type === 'ZPath') {
	                this.node.setStyle(this.node._zCloneStyle);
	            } else if(this.node.setOrCancelSelectStyle) {
	                this.node.setOrCancelSelectStyle(false);
	             } else {
	                this._api.getZr().removeHover(this.node);
	            }
	
	        }
	    };
	
	    zrUtil.inherits(OperationNode, Node);
	    module.exports = OperationNode;
	


/***/ }),
/* 113 */
/***/ (function(module, exports) {

	/**
	 * 操作图标类
	 * @author wang.xiaohu
	 */
	
	
	    var IconOperation = {
	        STRAIGHT_SVG: 'M937.353846 724.676923C882.215385 669.538462 795.569231 661.661538 732.553846 701.046154L362.338462 330.830769C401.723077 267.815385 393.846154 181.169231 338.707692 126.030769 267.815385 55.138462 165.415385 55.138462 94.523077 126.030769 23.630769 196.923077 23.630769 299.323077 94.523077 370.215385 149.661538 425.353846 236.307692 433.230769 299.323077 393.846154L669.538462 764.061538C630.153846 827.076923 638.030769 913.723077 693.169231 968.861538 764.061538 1039.753846 866.461538 1039.753846 937.353846 968.861538 1000.369231 897.969231 1000.369231 795.569231 937.353846 724.676923L937.353846 724.676923ZM275.692308 307.2C244.184615 338.707692 189.046154 338.707692 157.538462 307.2 126.030769 275.692308 126.030769 220.553846 157.538462 189.046154 189.046154 157.538462 244.184615 157.538462 275.692308 189.046154 307.2 220.553846 307.2 267.815385 275.692308 307.2L275.692308 307.2ZM874.338462 913.723077C842.830769 945.230769 787.692308 945.230769 756.184615 913.723077 724.676923 882.215385 724.676923 827.076923 756.184615 795.569231 787.692308 764.061538 842.830769 764.061538 874.338462 795.569231 905.846154 827.076923 905.846154 874.338462 874.338462 913.723077L874.338462 913.723077Z',
	        JAGGED_SVG: 'M204.8 819.2l-51.2-102.4 204.8-307.2 51.2 102.4-204.8 307.2zM409.6 512l51.2-102.4 153.6 204.8-51.2 102.4-153.6-204.8zM819.2 204.8l51.2 102.4-204.8 409.6-51.2-102.4 204.8-409.6z                                    M153.6 716.8c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H102.4v-102.4h102.4v102.4zM409.6 204.8C322.56 204.8 256 271.36 256 358.4s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H358.4V307.2h102.4v102.4zM614.4 614.4c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4v-102.4h102.4v102.4zM870.4 0c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4V102.4h102.4v102.4z',
	        CURVE_SVG: 'M1014.285039 824.024234l-145.168428-144.37205c-12.969593-12.855825-37.543559-14.505466-44.597197 2.332252-1.877178 4.550734-2.275367 17.179022-2.275368 17.179022v97.556369H330.935383a118.319095 118.319095 0 0 1-118.546632-117.920905A118.319095 118.319095 0 0 1 330.992267 560.878016h445.516899c121.561493 0 220.426198-98.352747 220.426198-219.23163s-98.864705-219.174746-220.426198-219.174746H340.491925A174.236244 174.236244 0 0 0 174.105698 0 173.78117 173.78117 0 0 0 0.040107 173.09856a173.78117 173.78117 0 0 0 174.065591 173.09856 174.236244 174.236244 0 0 0 166.386227-122.471639h436.017241c65.416807 0 118.603516 52.902288 118.603515 117.920905A118.319095 118.319095 0 0 1 776.509166 459.624176H330.992267c-121.504609 0-220.369314 98.352747-220.369314 219.23163s98.864705 219.174746 220.369314 219.174746h491.194895v92.550561s0 14.221045 2.332252 19.795695c7.053638 16.894602 31.627604 17.577212 44.597197 4.664502l145.111543-144.315165a32.879056 32.879056 0 0 0 0-46.645027zM174.105698 244.94328c-39.818926 0-72.242909-32.25333-72.242909-71.84472s32.423983-71.787835 72.242909-71.787835c39.818926 0 72.186025 32.196446 72.186025 71.787835 0 39.591389-32.423983 71.787835-72.242909 71.787836z',
	        DEL_SVG: 'M980.992 256h-84.992v683.008c0 47.104-37.888 84.992-84.992 84.992H212.992c-47.104 0-84.992-37.888-84.992-84.992V256H43.008C19.456 256 0 236.544 0 212.992c0-23.552 19.456-43.008 43.008-43.008H256V84.992C256 37.888 293.888 0 340.992 0h340.992C730.112 0 768 37.888 768 84.992v84.992h214.016c23.552 0 43.008 19.456 43.008 43.008-1.024 23.552-20.48 43.008-44.032 43.008zM683.008 84.992H340.992v84.992h340.992V84.992zM212.992 939.008h596.992V256H212.992v683.008z m171.008-470.016v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-23.552 19.456-43.008 43.008-43.008 23.552 1.024 43.008 19.456 43.008 43.008zM512 427.008c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z m171.008 0c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z',
	        COMMENT_SVG: 'M209.92 152.064l572.416 1.536c12.8 0 23.04 10.24 23.04 23.04v237.568c0 12.8 10.24 23.04 23.04 23.04s23.04-10.24 23.04-23.04V125.44c0-12.8-10.24-23.04-23.04-23.04H158.72c-12.8 0-23.04 10.24-23.04 23.04v773.12c0 12.8 10.24 23.04 23.04 23.04h236.032c12.8 0 23.04-10.24 23.04-23.04s-10.24-22.528-22.528-23.04l-185.856-1.536c-12.8 0-22.528-10.24-22.528-23.04V174.592c0-12.288 10.24-22.528 23.04-22.528z                                            M268.8 570.368h159.232c13.312 0 24.064 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.064-10.752-24.576-24.064v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0-312.32h441.344c13.312 0 24.576 10.752 24.576 24.576v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.576-10.752-24.576-24.576v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0.512 155.648h269.312c13.312 0 24.576 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H269.312c-13.312 0-24.576-10.752-24.576-24.064v-2.56c0-13.824 10.752-24.576 24.576-24.576z m471.04 13.312l-246.784 339.456c-1.536 2.56-2.56 5.632-2.56 8.704l-1.536 132.096c0 9.728 9.728 16.896 18.944 14.336l122.88-37.888c3.072-1.024 5.632-3.072 7.68-5.632l246.784-338.944c4.608-6.144 3.584-15.36-2.56-19.968l-121.344-94.72c-7.168-5.632-16.896-4.096-21.504 2.56z m23.04 67.584l51.2 39.936c2.048 1.536 2.56 5.12 1.024 7.168l-26.112 35.84c-1.536 2.56-5.12 3.072-7.68 1.024l-51.712-38.912c-2.048-1.536-2.56-4.608-1.024-7.168l26.624-37.376c2.048-1.536 5.632-2.048 7.68-0.512z m-165.888 341.504l-35.328 10.752c-9.216 3.072-18.944-4.096-18.944-13.824l0.512-40.96c0-3.072 1.024-6.144 2.56-8.704l137.216-187.904c1.536-2.56 5.12-2.56 7.168-1.024l51.2 38.4c2.56 2.048 3.072 5.12 1.024 7.68l-137.728 189.952c-2.048 2.56-4.608 4.608-7.68 5.632z',
	        CHANGE_LINE_TYPE_SVG: 'M1008 335.2 1008 335.2l-160 144 0 0c-8.8 8-20 12.8-32 12.8-26.4 0-48-21.6-48-48 0-14.4 6.4-26.4 16-35.2l0 0 67.2-60L560 348.8c0 0 0 0 0 0L464 348.8l0 0L352 348.8 48 348.8c-26.4 0-48-21.6-48-48 0-26.4 21.6-48 48-48l124.8 0 0 0L416 252.8l0 0 208 0 0 0 227.2 0L784 192l0 0c-9.6-8.8-16-21.6-16-35.2 0-26.4 21.6-48 48-48 12 0 23.2 4.8 32 12.8l0 0 160 144 0 0c9.6 8.8 16 21.6 16 35.2C1024 314.4 1017.6 326.4 1008 335.2zM16 680.8 16 680.8l160-144 0 0c8.8-8 20-12.8 32-12.8 26.4 0 48 21.6 48 48 0 14.4-6.4 26.4-16 35.2l0 0-67.2 60L400 667.2l0 0 208 0 0 0 243.2 0 0 0L976 667.2c26.4 0 48 21.6 48 48 0 26.4-21.6 48-48 48L672 763.2 560 763.2c0 0 0 0 0 0L464 763.2l0 0L172.8 763.2 240 824l0 0c9.6 8.8 16 21.6 16 35.2 0 26.4-21.6 48-48 48-12 0-23.2-4.8-32-12.8l0 0L16 752l0 0c-9.6-8.8-16-21.6-16-35.2C0 701.6 6.4 689.6 16 680.8z'
	    }
	    module.exports = IconOperation;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * bpmn连线管理类
	 * @author wang.xiaohu
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var ConnectionManager = __webpack_require__(115);
	    var BPMNModel = __webpack_require__(82);
	    var Connector = __webpack_require__(105);
	    var Point = __webpack_require__(64);
	    var util = __webpack_require__(77);
	
	    function BpmnConnectionManager() {
	        ConnectionManager.call(this);
	        this.stencilType = "SequenceFlow";
	    }
	    /**
	     * 创建连线
	     * @param  {[type]} startNode [开始节点]
	     * @param  {[type]} endNode   [结束节点]
	     * @param  {[type]} type      [类型]
	     * @param {[type]} [api] [description]
	     * @return {[type]}           [返回连线]
	     */
	    BpmnConnectionManager.prototype.connectorCreate = function(startNode, endNode, style, api, startPos, endPos) {
	        var model = new BPMNModel({});
	        model.set("resourceId", util.getUUID());
	        model.set("style", style.style);
	        model.set("stencil.type", this.stencilType);
	        startPos && model.set("style.sPos", startPos);
	        endPos && model.set("style.ePos", endPos);
	
	        return this.connectorCreateByOptions(startNode, endNode, { model: model, isEdit: true, style: style}, api);
	    }
	
	
	    /**
	     * 根据opetions.model 反序列化线
	     * @param  {[type]} startNode [description]
	     * @param  {[type]} endNode   [description]
	     * @param  {[type]} options   [description]
	     * @param  {[type]} api       [description]
	     * @return {[type]}           [description]
	     */
	    BpmnConnectionManager.prototype.connectorCreateByOptions = function(startNode, endNode, options, api) {
	        var that = this;
	        var model = options.model;
	        model.option.text = {
	            text: model.option.properties.name
	        }
	        options.text = {
	            text: model.option.properties.name
	        }
	        var connector = new Connector(options);
	        connector.startNode = startNode;
	        connector.endNode = endNode;
	
	        this.connectors.push(connector);
	
	        //判断一下sPos,ePos
	        connector.options.position.startPos = model.get("style.sPos");
	        connector.options.position.endPos = model.get("style.ePos");
	
	        //判断一下 model里有没有dockers，如果有则调用构造point数组  或者调用refreshConnector计算如何画线
	        var dockers = model.get("dockers");
	        if (dockers && dockers.length >= 2) {
	            var points = Point.loadArray(dockers);
	            connector.refresh(points);
	        } else {
	            this.refreshConnector(connector, true);
	        }
	
	        connector.conPointsGroup.on("click", function(e) {
	            var arrSplit = e.target.type.split(Connector.SEPERATOR);
	            var connector = e.target.connector;
	            if (arrSplit[0] === Connector.START_NODE) {
	                 connector.options.position.startPos = arrSplit[1];
	            } else if (arrSplit[0] === Connector.END_NODE) {
	                connector.options.position.endPos = arrSplit[1];
	            }
	            that.refreshConnector(connector, true);
	
	            var params = {};
	            params.event = e;
	            params.type = "conPointsGroup:click";
	            params.lineNode = that.selConnector;
	            api.trigger(params.type, params);
	        });
	
	
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];
	        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	            connector.on("Connector:" + eveName, function(e) {
	                var selected = e.target;
	
	                if (that.selConnector !== selected) {
	                    that.selConnector && that.refreshConnector(that.selConnector);
	                    that.selConnector = selected;
	                }
	
	                var params = {};
	                params.event = e;
	                params.type = eveName;
	                params.target = that.selConnector;
	                api.trigger(params.type, params);
	            });
	        });
	        if (!options.isFromModel) {
	            //1.设置起始节点的outgoing数组 为线段的ID
	            var startNodeOutgoing = startNode.model.get("outgoing");
	            startNodeOutgoing.push(connector.resourceId);
	            //2.设置线段的outgoing数组 为结束节点的ID
	            var connectorOutgoing = connector.model.get("outgoing");
	            connectorOutgoing.push(endNode.resourceId);
	        }
	
	
	        return connector;
	    }
	
	    /**
	     * 设置线段的模型数据  (类型 文字)
	     * @param {[type]} connector [description]
	     * @param {[type]} option    [description]
	     */
	    BpmnConnectionManager.prototype.setModel = function(connector, option) {
	        var originName = connector.options.text.text;
	        connector.options.text.text = option.properties.name;
	        connector.model.mergeOption(option);
	        //文字不一致时
	        if (originName != option.properties.name) {
	            this.refreshConnector(connector, true);
	        }
	    }
	    /**
	     * 删除指定的线
	     * @param connector 欲删除的连线
	     * @param _zr zr
	     */
	    BpmnConnectionManager.prototype.deleteByLine = function (connector,_zr) {
	        //1.将线 所联的startNode的outgoing数据删除
	        if(connector.startNode){
	            var startNodeOutgoing = connector.startNode.model.get("outgoing");
	            index = zrUtil.indexOf(startNodeOutgoing, connector.resourceId);
	            if (index != -1) {
	                startNodeOutgoing.splice(index, 1);
	            }
	
	            if (this.connectorMap) {
	                var key = this.getTwoNodeId(connector.startNode, connector.endNode, connector.options.position);
	                this.connectorMap.removeItem(key, connector);
	            }
	        }
	
	
	        //2.从_zr上删除
	        _zr.remove(connector);
	
	
	        //3.从线数据中删除
	        var index = zrUtil.indexOf(this.connectors, connector);
	        if (index != -1) {
	            this.connectors.splice(index, 1);
	        }
	        if (this.selConnector === connector) {
	            this.selConnector = null;
	        }
	    }
	    /**
	     * 刷新连接线
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    BpmnConnectionManager.prototype.refreshLineByNode = function(node) {
	        for (var i = 0, len = this.connectors.length; i < len; i++) {
	            if (this.connectors[i].startNode == node || this.connectors[i].endNode == node) {
	                this.refreshConnector(this.connectors[i], true);
	            }
	        }
	    }
	
	    zrUtil.inherits(BpmnConnectionManager, ConnectionManager);
	
	    module.exports = BpmnConnectionManager;
	


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连线管理类
	 * @author wang.xiaohu
	 */
	
	    var Util = __webpack_require__(77);
	    var Point = __webpack_require__(64);
	    var Connector = __webpack_require__(105);
	    var Log = __webpack_require__(116);
	    var zrUtil = __webpack_require__(4);
	
	    function ConnectionManager() {
	        this.connectors = []; //当前画布所有的线段
	        this.selConnector = null; //当前选中的线段
	        this.tempConnector = null; //临时线段
	    }
	
	    /**
	     * 设置线的不可编辑
	     * @param  {[type]} forbidEdit [description]
	     * @return {[type]}            [description]
	     */
	    ConnectionManager.prototype.connectorForbidEdit = function (forbidEdit) {
	        for (var i = 0; i < this.connectors.length; i++) {
	            this.connectors[i].options.isEdit = !forbidEdit;
	        }
	        if (forbidEdit) {
	            this.removeConnectorEventListener();
	        }
	    }
	
	    /**
	     * 移除线条监听事件
	     */
	    ConnectionManager.prototype.removeConnectorEventListener = function () {
	        if (this.connectors.length > 0) {
	            this.connectors.forEach(function(connector) {
	                connector.polyLine.off('mouseover');
	                connector.polyLine.off('mousemove');
	                connector.polyLine.off('mouseout');
	                connector.curveLine.off('mouseover');
	                connector.curveLine.off('mousemove');
	                connector.curveLine.off('mouseout');
	            });
	        }
	    }
	
	
	    /**
	     * 清空连接线上的调整位置按钮
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.clearSelectCon = function () {
	        if (this.selConnector != null) {
	            this.refreshConnector(this.selConnector);
	        }
	    }
	    /**
	     * 删除和节点相关联的连接线
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.deleteSelectCon = function (node, _zr) {
	        for (var i = 0; i < this.connectors.length; i++) {
	            if (this.connectors[i].startNode == node || this.connectors[i].endNode == node) {
	                //1.将线 所联的startNode的outgoing数据删除
	                var startNodeOutgoing = this.connectors[i].startNode.model.get("outgoing");
	                var index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);
	                if (index != -1) {
	                    startNodeOutgoing.splice(index, 1);
	                }
	                //2.从_zr上删除
	                _zr.remove(this.connectors[i]);
	                this.connectors.splice(i, 1);
	                i--;
	                this.selConnector = null;
	            }
	        }
	    }
	    ConnectionManager.prototype.removeLine = function (line, zr) {
	        this.selConnector = line;
	        this.deleteLine(zr);
	    }
	    /**
	     * 删除选定的线
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.deleteLine = function (_zr) {
	        //1.将线 所联的startNode的outgoing数据删除
	        if(this.selConnector.startNode){
	            var startNodeOutgoing = this.selConnector.startNode.model.get("outgoing");
	            index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);
	            if (index != -1) {
	                startNodeOutgoing.splice(index, 1);
	            }
	
	            if (this.connectorMap) {
	                var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode, this.selConnector.options.position);
	                this.connectorMap.removeItem(key, this.selConnector);
	            }
	        }
	
	
	        //2.从_zr上删除
	        _zr.remove(this.selConnector);
	
	
	        //3.从线数据中删除
	        var index = zrUtil.indexOf(this.connectors, this.selConnector);
	        if (index != -1) {
	            this.connectors.splice(index, 1);
	        }
	        this.selConnector = null;
	    }
	
	    /**
	     * 重新画线
	     * @param  {[type]} connector          [description]
	     * @param  {[type]} force
	     * @return {[type]}                    [description]
	     */
	    ConnectionManager.prototype.refreshConnector = function (connector, force) {
	        // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘
	        if (force || (!connector.turningPoints) || (connector.turningPoints.length < 2)) {
	            if (connector.model && connector.model.get("style.lineType")) {
	                connector.options.style.lineType = connector.model.get("style.lineType");
	            }
	            var arrStartEndPoint = this.getStartEndPoint(connector);
	            var escapeDistance = null;
	            if (connector.options.position && connector.options.position.escapeDistance) {
	                escapeDistance = connector.options.position.escapeDistance;
	            }
	            var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0],
	                arrStartEndPoint[1],
	                arrStartEndPoint[2], arrStartEndPoint[3], escapeDistance); // TYPE_STRAIGHT TYPE_JAGGED
	
	            connector.refresh(solutions[0][2]);
	        }
	
	        connector.clearHandles(); //清空handle
	    }
	
	
	    ConnectionManager.prototype.getStartEndPoint = function (connector) {
	        var startNode = connector.startNode;
	        var endNode = connector.endNode;
	        var isNotInSameGroup = true;
	        isNotInSameGroup = startNode.parent !== endNode.parent;
	
	        var sRect = Util.getRect(startNode, isNotInSameGroup).boundingRect;
	        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(
	            sRect.y) + Number(sRect.height)];
	
	        var eRect = Util.getRect(endNode, isNotInSameGroup).boundingRect;
	        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(
	            eRect.y) + Number(eRect.height)];
	
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);
	        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);
	
	        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	        var position = connector.options.position;
	        if (position.direction) {
	            var posArr = position.direction.split(',');
	            position.startPos = posArr[0];
	            position.endPos = posArr[1];
	        }
	        if (!position.startPos || !position.endPos) {
	            if (sRect.x < eRect.x) {
	                position.startPos = "right";
	                position.endPos = "left";
	            } else {
	                position.startPos = "left";
	                position.endPos = "right";
	            }
	        }
	        var startPoint = this.calcPointExpression(position.startPos, sConnectorPoint);
	        var endPoint = this.calcPointExpression(position.endPos, eConnectorPoint);
	        startPoint.add(new Point(position.startOffset[0], position.startOffset[1]));
	        endPoint.add(new Point(position.endOffset[0], position.endOffset[1]));
	        return [startPoint, endPoint, sBounds, eBounds];
	    }
	
	    ConnectionManager.prototype.calcPointExpression = function (pos, point) {
	        var variable = {
	            top: point.top.x,
	            left: point.left.y,
	            right: point.right.y,
	            bottom: point.bottom.x,
	            center: point.center.x
	        };
	
	        var expression = "<% print(" + pos + ") %>";
	        var val = parseInt(Util.template(expression)(variable));
	        if (pos.indexOf("top") != -1) {
	            return new Point(val, point.top.y);
	        } else if (pos.indexOf("left") != -1) {
	            return new Point(point.left.x, val);
	        } else if (pos.indexOf("right") != -1) {
	            return new Point(point.right.x, val);
	        } else if (pos.indexOf("bottom") != -1) {
	            return new Point(val, point.bottom.y);
	        } else if (pos.indexOf("center") != -1) {
	            return new Point(val, point.bottom.y);
	        } else {
	            throw new Error("pos参数错误");
	        }
	    }
	
	    /**
	     * 创建或修改临时线
	     * @param  {[type]} startNode             [description]
	     * @param  {[type]} rEndPoint             [description]
	     * @param  {[type]} lineType              [description]
	     * @param  {[type]} startPos              [description]
	     * @return {[type]}                       [description]
	     */
	    ConnectionManager.prototype.manageTempConnector = function (startNode, rEndPoint, lineType, startPos, endPos, endNode) {
	        var eRect = null;
	        var eBounds = null;
	        var sRect = Util.getRect(startNode, true).boundingRect;
	        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(
	            sRect.y) + Number(sRect.height)];
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);
	
	        if (!this.tempConnector) {
	            this.tempConnector = new Connector({
	                isEdit: false,
	                style: {
	                    lineType: lineType
	                }
	            });
	        }
	
	        var connector = this.tempConnector;
	        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	        var position = connector.options.position;
	        position.startPos = startPos ? startPos : (sRect.x < rEndPoint.x ? "right" : "left");
	        position.endPos = endPos ? endPos : (sRect.x < rEndPoint.x ? "left" : "right");
	
	        connector.options.style.lineType = lineType;
	        if (endNode) {
	            eRect = Util.getRect(endNode, true).boundingRect;
	            eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(
	                eRect.y) + Number(eRect.height)];
	        }
	        var solutions = this.connector2Points(lineType, sConnectorPoint[position.startPos], rEndPoint,
	            sBounds, eBounds); // TYPE_STRAIGHT TYPE_JAGGED
	
	        connector.refresh(solutions[0][2]);
	        return connector;
	    }
	
	    /**
	     * 创建或修改临时反转线
	     * @param  {[type]} startPoint              [description]
	     * @param  {[type]} endNode                 [description]
	     * @param  {[type]} lineType                [description]
	     * @param  {[type]} endPos                  [description]
	     * @return {[type]}                         [description]
	     */
	    ConnectionManager.prototype.manageReverseTempConnector = function (startPoint, endNode, lineType, endPos, startPos, startNode) {
	        var sRect = null;
	        var sBounds = null;
	        var eRect = Util.getRect(endNode, true).boundingRect;
	        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(eRect.y) + Number(eRect.height)];
	        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);
	        if (!this.tempConnector) {
	            this.tempConnector = new Connector({
	                isEdit: false,
	                style: {
	                    lineType: lineType
	                }
	            });
	        }
	        var connector = this.tempConnector;
	        var position = connector.options.position;
	        position.endPos = endPos ? endPos : (eRect.x < startPoint.x ? "right" : "left");
	        position.startPos = startPos ? startPos : (eRect.x < startPoint.x ? "left" : "right");
	
	        connector.options.style.lineType = lineType;
	        if (startNode) {
	            sRect = Util.getRect(startNode, true).boundingRect;
	            sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(
	            sRect.y) + Number(sRect.height)];
	        }
	        var solutions = this.connector2Points(lineType, startPoint, eConnectorPoint[position.endPos],
	            sBounds, eBounds); // TYPE_STRAIGHT TYPE_JAGGED
	
	        connector.refresh(solutions[0][2]);
	        return connector;
	    }
	
	    /**
	     * 删除临时线
	     * @param  {[type]} zr             [description]
	     */
	    ConnectionManager.prototype.removeTempConnector = function (zr) {
	        if (this.tempConnector) {
	            zr.remove(this.tempConnector);
	            this.tempConnector = null;
	        }
	    }
	
	
	    /**
	     * 算出 两个节点 指定两个点如何联线
	     * @param  {[type]} type       [description]
	     * @param  {[type]} startPoint [description]
	     * @param  {[type]} endPoint   [description]
	     * @param  {[type]} sBounds    [description]
	     * @param  {[type]} eBounds    [description]
	     * @return {[type]}            [description]
	     */
	    ConnectionManager.prototype.connector2Points = function (type, startPoint, endPoint, sBounds, eBounds,
	        escapeDistance) {
	        var figureEscapeDistance = [30, 30];
	        if (escapeDistance) {
	            if (!zrUtil.isArray(escapeDistance)) {
	                figureEscapeDistance = [escapeDistance, escapeDistance];
	            } else {
	                figureEscapeDistance = escapeDistance;
	            }
	        }
	
	        Log.group("connectionManager: connector2Points");
	
	
	        Log.info("ConnectionManager: connector2Points (" + type + ", " + startPoint + ", " + endPoint +
	            ", " + sBounds + ", " + eBounds + ')');
	        var solutions = [];
	
	
	
	        switch (type) {
	            case Connector.TYPE_CHAIN:
	
	            case Connector.TYPE_STRAIGHT: //直线
	                var points = [startPoint.clone(), endPoint.clone()];
	                solutions.push(['straight', 'straight', points]);
	                break;
	
	            case Connector.TYPE_CURVE: //曲线
	
	            case Connector.TYPE_JAGGED: //折线
	                var startExitPoint = null;
	                var endExitPoint = null;
	
	                //find start exit point  寻找开始出口
	                if (sBounds != null) {
	                    var potentialExits = [];
	
	                    potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北
	                    potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东
	                    potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南
	                    potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西
	
	                    //pick closest exit point  寻找与 startPoint 最靠近的出口点
	                    startExitPoint = potentialExits[0];
	                    for (var i = 1; i < potentialExits.length; i++) {
	                        if (Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint,
	                                startExitPoint)) {
	                            startExitPoint = potentialExits[i];
	                        }
	                    }
	                }
	
	
	                //find end exit point  寻找结束出口
	                if (eBounds != null) {
	                    var potentialExits = [];
	
	                    potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north
	                    potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east
	                    potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south
	                    potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west
	
	                    //pick closest exit point  寻找与 endPoint 最靠近的出口点
	                    endExitPoint = potentialExits[0];
	                    for (var i = 1; i < potentialExits.length; i++) {
	                        if (Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint,
	                                endExitPoint)) {
	                            endExitPoint = potentialExits[i];
	                        }
	                    }
	                }
	
	                //Basic solution 最基本的解决方案   为其他解决方案做准备
	                var s = [startPoint];
	                var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT
	                if (startExitPoint) {
	                    s.push(startExitPoint);
	                    gapIndex = 1;
	                }
	                if (endExitPoint) {
	                    s.push(endExitPoint);
	                }
	                s.push(endPoint);
	
	
	
	                //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用
	                var s0 = Point.cloneArray(s);
	                solutions.push(['s0', 's0', s0]);
	
	
	
	                //S1   S1 解决方案  只有一个折点
	                var s1 = Point.cloneArray(s);
	
	                //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置
	                var s1_1 = Point.cloneArray(s1);
	                s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x, s1_1[gapIndex + 1].y));
	                solutions.push(['s1', 's1_1', s1_1]);
	
	                //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置
	                var s1_2 = Point.cloneArray(s1);
	                s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex + 1].x, s1_2[gapIndex].y));
	                solutions.push(['s1', 's1_2', s1_2]);
	
	
	                //S2  S2 解决方案  添加两个折点
	
	                //Variant I   s2_1方案
	                var s2_1 = Point.cloneArray(s);
	                var s2_1_1 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex].y);
	                var s2_1_2 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex + 1].y);
	                s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);
	                solutions.push(['s2', 's2_1', s2_1]);
	
	
	                //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2
	                //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2
	                var s2_2 = Point.cloneArray(s);
	                var s2_2_1 = new Point(s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);
	                var s2_2_2 = new Point(s2_2[gapIndex + 1].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);
	                s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);
	                solutions.push(['s2', 's2_2', s2_2]);
	
	
	                //Variant III
	                var s2_3 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex + 1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    eastExits.push(sBounds[2] + 20);
	                }
	
	                if (eBounds) {
	                    eastExits.push(eBounds[2] + 20);
	                }
	
	                var eastExit = Util.max(eastExits);
	                var s2_3_1 = new Point(eastExit, s2_3[gapIndex].y);
	                var s2_3_2 = new Point(eastExit, s2_3[gapIndex + 1].y);
	                s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);
	                solutions.push(['s2', 's2_3', s2_3]);
	
	
	                //Variant IV  s2_4方案
	                var s2_4 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex + 1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    northExits.push(sBounds[1] - 20);
	                }
	
	                if (eBounds) {
	                    northExits.push(eBounds[1] - 20);
	                }
	
	                var northExit = Util.min(northExits);
	                var s2_4_1 = new Point(s2_4[gapIndex].x, northExit);
	                var s2_4_2 = new Point(s2_4[gapIndex + 1].x, northExit);
	                s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);
	                solutions.push(['s2', 's2_4', s2_4]);
	
	
	                //Variant V
	                var s2_5 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex + 1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    westExits.push(sBounds[0] - 20);
	                }
	
	                if (eBounds) {
	                    westExits.push(eBounds[0] - 20);
	                }
	
	                var westExit = Util.min(westExits);
	                var s2_5_1 = new Point(westExit, s2_5[gapIndex].y);
	                var s2_5_2 = new Point(westExit, s2_5[gapIndex + 1].y);
	                s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);
	                solutions.push(['s2', 's2_5', s2_5]);
	
	
	                //Variant VI
	                var s2_6 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex + 1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    southExits.push(sBounds[3] + 20);
	                }
	
	                if (eBounds) {
	                    southExits.push(eBounds[3] + 20);
	                }
	
	                var southExit = Util.max(southExits);
	                var s2_6_1 = new Point(s2_6[gapIndex].x, southExit);
	                var s2_6_2 = new Point(s2_6[gapIndex + 1].x, southExit);
	                s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);
	                solutions.push(['s2', 's2_6', s2_6]);
	
	
	
	                //FILTER solutions
	
	                /*Algorithm
	                 * 0. solutions are ordered from minimmun nr of points to maximum >:)
	                 * 1. remove all solutions that are not orthogonal (mainly s0 solution)
	                 * 2. remove all solutions that go backward (we will not need them ever)
	                 * 3. remove all solutions with intersections
	                 * 4. pick first class of solutions with same nr of points (ex: 2)
	                 * 5. pick the first solution with 90 degree angles (less turnarounds)
	                 * (not interesteted) sort by length :p
	                 */
	
	                //1. filter non ortogonal solutions 删除不是正交直线的方案
	                Log.info("Filter orthogonal solutions. Initial number of solutions = " + solutions.length);
	                var orthogonalSolution = [];
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    if (Util.orthogonalPath(solution)) {
	                        orthogonalSolution.push(solutions[l]);
	                    }
	                }
	                solutions = orthogonalSolution;
	                Log.info("\n\tOrthogonalSolutions = " + solutions.length);
	
	                //2. filter backward solutions  过滤 倒退的方案
	                //do not allow start and end points to coincide - ignore them
	                if (startPoint.equals(endPoint)) {
	                    Log.info(
	                        "Start and end point coincide...skip backward solution. I think we will just fall on s0 :)"
	                    );
	                } else {
	                    Log.info("Filter backward solutions. Initial number of solutions = " + solutions.length);
	                    var forwardSolutions = [];
	                    var temp = '';
	                    for (var l = 0; l < solutions.length; l++) {
	                        var solution = solutions[l][2];
	                        if (Util.forwardPath(solution)) {
	                            forwardSolutions.push(solutions[l]);
	                        } else {
	                            temp = temp + "\n\t" + solution;
	                        }
	                    }
	                    solutions = forwardSolutions;
	                    Log.info("\n\t ForwardSolutions = " + solutions.length);
	                    if (solutions.length == 0) {
	                        Log.info("Discarded solutions: " + temp);
	                    }
	                }
	
	
	                //3. Filter non intersecting solutions  去除没有交集()的方案
	                Log.info("Filter non intersecting solutions. Initial number of solutions = " + solutions.length);
	                var nonIntersectionSolutions = []
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    //Log.info("Solution id= " + solutions[l][1] + ' nr points = ' + solution.length + ", points = " + solution);
	                    var intersect = false;
	
	                    var innerLines = solution.slice(); //just a shallow copy
	
	                    /*If any bounds just trim the solution. So we avoid the strange case when a connection
	                     *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/
	                    if (eBounds || sBounds) {
	                        //i0nnerLines = innerLines.slice(0, innerLines.length - 1);
	                        innerLines = innerLines.slice(1, innerLines.length - 1);
	                        //Log.info("\t eBounds present,innerLines nr. points = " + innerLines.length + ", points = " + innerLines);
	                    }
	
	
	
	                    //now test for intersection
	                    if (sBounds) {
	                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);
	                    }
	                    if (eBounds) {
	                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);
	                    }
	
	                    if (!intersect) {
	                        nonIntersectionSolutions.push(solutions[l]);
	                    }
	                }
	
	                //If all solutions intersect than this is destiny  :) and just ignore the intersection filter
	                if (nonIntersectionSolutions.length != 0) {
	                    //reasign to solutions
	                    solutions = nonIntersectionSolutions;
	                }
	
	                Log.info("\n\t nonIntersectionSolutions = " + solutions.length);
	
	
	                //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）
	                Log.info("Get first class of solutions with same nr of points");
	                if (solutions.length == 0) {
	                    Log.info("This is not possible");
	                }
	
	                var firstSolution = solutions[0][2]; //pick first solution
	                var nrOfPoints = firstSolution.length;
	                var sameNrPointsSolution = [];
	
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    if (solution.length == nrOfPoints) {
	                        sameNrPointsSolution.push(solutions[l]);
	                    }
	                }
	
	                solutions = sameNrPointsSolution;
	
	
	
	
	                /*5.  计算路径分数 ，取最分数高的
	                 Pick the first solution with 90 degree angles (less turnarounds)
	                 *in case we have more than one solution in our class
	                 */
	                Log.info("pick the first solution with 90 degree angles (less turnarounds)");
	                var solIndex = 0;
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    if (Util.scorePath(solutions[solIndex][2]) < Util.scorePath(solutions[l][2])) {
	                        solIndex = l;
	                    }
	                }
	                solutions = [solutions[solIndex]];
	
	
	                break;
	        }
	
	        //SMOOTHING curve
	        if (type === Connector.TYPE_CURVE) {
	            this.smoothCurve(solutions);
	        }
	        //END SMOOTHING curve
	
	        Log.groupEnd();
	
	        return solutions;
	    }
	
	    ConnectionManager.prototype.smoothCurve = function (solutions) {
	        var option = 3;
	
	        switch (option) {
	            case 0:
	                //do nothing
	                break;
	
	            case 1: //add intermediate points
	                //Add the middle point for start and end segment so that we "force" the
	                //curve to both come "perpendicular" on bounds and also make the curve
	                //"flee" more from bounds (on exit)
	                for (var s = 0; s < solutions.length; s++) {
	                    var solTurningPoints = solutions[s][2];
	
	                    //first segment
	                    var a1 = solTurningPoints[0];
	                    var a2 = solTurningPoints[1];
	                    var startMiddlePoint = Util.getMiddle(a1, a2);
	                    solTurningPoints.splice(1, 0, startMiddlePoint);
	
	                    //last segment
	                    var a3 = solTurningPoints[solTurningPoints.length - 2];
	                    var a4 = solTurningPoints[solTurningPoints.length - 1];
	                    var endMiddlePoint = Util.getMiddle(a3, a4);
	                    solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);
	                }
	                break;
	
	            case 2: //remove points
	
	                zrUtil.each(solutions, function(solution) {
	                    var solType = solution[0];
	                    if (solType == 's1' || solType == 's2') {
	                        var solTurningPoints = solution[2];
	                        solTurningPoints.splice(1, 1);
	                        solTurningPoints.splice(solTurningPoints.length - 2, 1);
	                    }
	                });
	                break;
	
	            case 3:
	                /*remove colinear point for s1 as it seems that more colinear points do not look good
	                 * on organic solutions >:D*/
	                zrUtil.each(solutions, function(solution) {
	                    var solType = solution[0];
	                    if (solType == 's1') {
	                        var solTurningPoints = solution[2];
	                        var reducedSolution = Util.collinearReduction(solTurningPoints);
	                        solution[2] = reducedSolution;
	                    }
	                });
	                break;
	        } //end switch
	
	    }
	
	    module.exports = ConnectionManager;


/***/ }),
/* 116 */
/***/ (function(module, exports) {

	/**
	 * 日志类
	 * @author wang.xiaohu
	 */
	
	
	    var Log  = {
	        LOG_LEVEL_NONE  : 0,
	
	        LOG_LEVEL_DEBUG : 1,
	
	        LOG_LEVEL_INFO : 2,
	
	        LOG_LEVEL_ERROR : 3,
	
	        level : this.LOG_LEVEL_ERROR,
	        
	        /**
	        * The less important of all messages
	        * @param {String} message - the message to be logged
	        **/
	        debug: function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_DEBUG){
	                    
	                    //in FF is debug
	                    if(typeof console.debug == 'function'){
	                        console.debug(message);
	                    }
	                    else{//TODO: in IE is log
	    //                    console.info(message);
	                    }
	                }
	            }
	        },
	
	
	        /**
	        * The commonly used log message
	        * @param {String} message - the message to be logged
	        **/
	        info : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_INFO){
	                    console.info(message);
	                }
	            }
	        },
	
	        /**
	        * The worse kind of message. Usually a crash
	        * @param {String} message - the message to be logged
	        **/
	        error : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_ERROR){
	                    console.error(message);
	                }
	            }
	        },
	
	        /**
	         *Start grouping the log messages
	         *@param {String} title - the title of the group
	         *@see <a href="http://getfirebug.com/logging">http://getfirebug.com/logging</a>
	         **/
	        group : function(title){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){           
	                    /**If we do not test for group() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.group === 'function'){
	                        console.group(title);
	                    }
	                }
	            }
	        },
	
	        /**Ends current message grouping*/
	        groupEnd : function(){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){
	                    /**If we do not test for groupEnd() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.groupEnd === 'function'){
	                        console.groupEnd();
	                    }
	                }
	            }
	        }
	
	    };
	
	    //Log.level = Log.LOG_LEVEL_DEBUG; 
	    Log.level = Log.LOG_LEVEL_ERROR; 
	    //Log.level = Log.LOG_LEVEL_ERROR;
	    //Log.level = Log.LOG_LEVEL_NONE;
	    module.exports = Log;
	    


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连线操作类
	 * @author miao.cunzhi
	 */
	
	    var symbolUtil = __webpack_require__(106);
	    var zrUtil = __webpack_require__(4);
	    var icon = __webpack_require__(113);
	    function LineOperationManager(connectionManager, api) {
	        this.lineOperations = [],
	        this.isEdit = true;
	        this.connectionManager = connectionManager;
	        this._api = api;
	    }
	
	    /**
	     *  this.lineOperationManager.addIcon(key, options);
	     */
	    LineOperationManager.prototype.addIcon = function(key, options) {
	        //判断是小图标否存在 ，存在则直接返回
	        var lineOperationIcon = zrUtil.find(options.lineNode.icons, function(icon) {
	            return icon.key === key;
	        });
	
	        if (lineOperationIcon) {
	            this.bindOperation(options.lineNode);
	            return;
	        }else {
	            var lineOperation = this.creatOperation(key, options);
	            this._api._getParentZr().add(lineOperation);
	            this.bindOperation(options.lineNode);
	            return lineOperation;
	        }
	    }
	
	
	    LineOperationManager.prototype.creatOperation = function(key, options) {
	        var lineOperation = symbolUtil.createSymbol(options.iconPath, 0, 0, options.width || 15, options.height || 15, 0, options.color||'#aaaaac');
	        lineOperation.key = key;
	        lineOperation._width =  options.width || 15;  // path情况下无法计算
	        lineOperation._isLineOperationIcon = true;
	        lineOperation.hide();
	        options.lineNode.icons.push(lineOperation);
	        this.lineOperations.push(lineOperation);
	
	        //小图标 点击事件  如果有回调则调用回调，否则派发事件
	        lineOperation.on("click", function(event) {
	            if (options.callback) {
	                event.data = options;
	                event.lineNode = options.lineNode;
	                options.callback(event);
	            } else {
	                var params = {};
	                params.event = event;
	                params.type = "click";
	                params.elementType = "LineOperationIcon";
	                this._api.trigger(params.type, params);
	            }
	        }.bind(this));
	        return lineOperation;
	    }
	
	    /**
	     * 计算小图标的位置，并显示
	     * @param  {[type]} connector [description]
	     * @return {[type]}           [description]
	     */
	    LineOperationManager.prototype.bindOperation = function(connector) {
	        function parentX(node) {
	            if (node.parent && node.parent.nodeType == "SubProcess") {
	                return node.position[0] + parentX(node.parent)
	            } else {
	                return node.position[0]
	            }
	        }
	    
	        function parentY(node) {
	            if (node.parent && node.parent.nodeType == "SubProcess") {
	                return node.position[1] + parentY(node.parent)
	            } else {
	                return node.position[1]
	            }
	        }
	
	        if (this.isEdit == false) {
	            return;
	        }
	        var pointPosition = connector.middle(), posX, posY;
	        if (connector.parent && connector.parent.nodeType == "SubProcess") {
	            posX = pointPosition[0] + parentX(connector.parent);
	            posY = pointPosition[1] + parentY(connector.parent);
	        } else {
	            posX = pointPosition[0];
	            posY = pointPosition[1];
	        }
	
	        var arrLength = zrUtil.map(connector.icons, function(icon) {
	            return icon._width;
	        });
	
	        var totalLength = zrUtil.reduce(arrLength, function(previousValue,currentValue) {
	            return previousValue + currentValue + 10;
	        }, 0 );
	
	        zrUtil.each(connector.icons, function(icon, index) {
	            var connectorPosition = 0;
	            for (var k = 0; k < index; k++) {
	                connectorPosition += arrLength[k] + 10;
	            }
	            icon.attr("position", [posX + connectorPosition - totalLength / 2, posY + 5]);
	            icon.show();
	            icon.attachLine = connector;
	        })
	    }
	
	    LineOperationManager.prototype.hideAllLineOperation = function() {
	        zrUtil.each(this.lineOperations, function(lineOperation) {
	            lineOperation.hide();
	        });
	    }
	
	    LineOperationManager.prototype.addDeleteIcon = function(lineNode,options) {
	        var opts = zrUtil.defaults({
	            iconPath: 'path://' + icon.DEL_SVG,
	            width: 12,
	            height: 14,
	            lineNode: lineNode,
	            callback: function(e) {
	                this._api.remove(e.target.attachLine);//this.connectionManager.selConnector);
	            }.bind(this)
	        }, options,true);
	
	        this.addIcon("delete", opts);
	    }
	
	    LineOperationManager.prototype.addChangeLineTypeIcon = function(lineNode,options) {
	        var opts = zrUtil.defaults({
	            iconPath: 'path://' + icon.CHANGE_LINE_TYPE_SVG,
	            width: 15,
	            height: 15,
	            lineNode: lineNode,
	            callback: function () {
	                this._api.changeSelectConnectorType();
	            }.bind(this)
	        }, options,true);
	
	        this.addIcon("change", opts)
	    }
	
	    module.exports = LineOperationManager;
	


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 辅助线操作类
	 * @author miao.cunzhi
	 */
	
		var graphic = __webpack_require__(3);
	
	    var Guidelines = {
	        virtualXLine:null,
	        virtualYLine:null,
	        createGuidelines:function(zr){
	            //创建x轴虚线
	            this.virtualXLine = new graphic.Line({
	                style: {
	                    lineDash: [5]
	                },
	                z: 3
	            });
	            //创建Y轴虚线
	            this.virtualYLine = new graphic.Line({
	                style: {
	                    lineDash: [5]
	                },
	                z: 3
	            });
	            zr.add(this.virtualXLine);
	            zr.add(this.virtualYLine);
	        },
	        judgeAlignment:function(nowRectPosition,domArray,maxWidth,maxHeight){
	            var that = this;
	            //循环判断水平对齐
	            for (var j = 0, len = domArray.length; j < len; j++) {
	                if (nowRectPosition[1] == domArray[j].position[1]) {
	                    that.virtualXLine.attr('position', [0, nowRectPosition[1]]);
	                    that.virtualXLine.attr("shape", {
	                        x2: maxWidth
	                    });
	
	                    break;
	                } else {
	                    that.virtualXLine.attr("shape", {
	                        x2: 0
	                    });
	                }
	            }
	            //循环判断垂直对齐
	            for (var m = 0, len1 = domArray.length; m < len1; m++) {
	                if (nowRectPosition[0] == domArray[m].position[0]) {
	                    that.virtualYLine.attr('position', [nowRectPosition[0], 0]);
	                    that.virtualYLine.attr("shape", {
	                        y2: maxHeight
	                    });
	                    break;
	                } else {
	                    that.virtualYLine.attr("shape", {
	                        y2: 0
	                    });
	                }
	            }
	        }
	    };
	
		module.exports = Guidelines;
	


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict() {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	var bluebird = __webpack_require__(120)();
	bluebird.noConflict = noConflict;
	module.exports = bluebird;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	module.exports = function() {
	var makeSelfResolutionError = function () {
	    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	};
	var reflectHandler = function() {
	    return new Promise.PromiseInspection(this._target());
	};
	var apiRejection = function(msg) {
	    return Promise.reject(new TypeError(msg));
	};
	function Proxyable() {}
	var UNDEFINED_BINDING = {};
	var util = __webpack_require__(122);
	
	var getDomain;
	if (util.isNode) {
	    getDomain = function() {
	        var ret = process.domain;
	        if (ret === undefined) ret = null;
	        return ret;
	    };
	} else {
	    getDomain = function() {
	        return null;
	    };
	}
	util.notEnumerableProp(Promise, "_getDomain", getDomain);
	
	var es5 = __webpack_require__(123);
	var Async = __webpack_require__(124);
	var async = new Async();
	es5.defineProperty(Promise, "_async", {value: async});
	var errors = __webpack_require__(129);
	var TypeError = Promise.TypeError = errors.TypeError;
	Promise.RangeError = errors.RangeError;
	var CancellationError = Promise.CancellationError = errors.CancellationError;
	Promise.TimeoutError = errors.TimeoutError;
	Promise.OperationalError = errors.OperationalError;
	Promise.RejectionError = errors.OperationalError;
	Promise.AggregateError = errors.AggregateError;
	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {};
	var tryConvertToPromise = __webpack_require__(130)(Promise, INTERNAL);
	var PromiseArray =
	    __webpack_require__(131)(Promise, INTERNAL,
	                               tryConvertToPromise, apiRejection, Proxyable);
	var Context = __webpack_require__(132)(Promise);
	 /*jshint unused:false*/
	var createContext = Context.create;
	var debug = __webpack_require__(133)(Promise, Context);
	var CapturedTrace = debug.CapturedTrace;
	var PassThroughHandlerContext =
	    __webpack_require__(134)(Promise, tryConvertToPromise, NEXT_FILTER);
	var catchFilter = __webpack_require__(135)(NEXT_FILTER);
	var nodebackForPromise = __webpack_require__(136);
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	function check(self, executor) {
	    if (self == null || self.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    if (typeof executor !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(executor));
	    }
	
	}
	
	function Promise(executor) {
	    if (executor !== INTERNAL) {
	        check(this, executor);
	    }
	    this._bitField = 0;
	    this._fulfillmentHandler0 = undefined;
	    this._rejectionHandler0 = undefined;
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._resolveFromExecutor(executor);
	    this._promiseCreated();
	    this._fireEvent("promiseCreated", this);
	}
	
	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};
	
	Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (util.isObject(item)) {
	                catchInstances[j++] = item;
	            } else {
	                return apiRejection("Catch statement predicate: " +
	                    "expecting an object but got " + util.classString(item));
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];
	        return this.then(undefined, catchFilter(catchInstances, fn, this));
	    }
	    return this.then(undefined, fn);
	};
	
	Promise.prototype.reflect = function () {
	    return this._then(reflectHandler,
	        reflectHandler, undefined, this, undefined);
	};
	
	Promise.prototype.then = function (didFulfill, didReject) {
	    if (debug.warnings() && arguments.length > 0 &&
	        typeof didFulfill !== "function" &&
	        typeof didReject !== "function") {
	        var msg = ".then() only accepts functions but was passed: " +
	                util.classString(didFulfill);
	        if (arguments.length > 1) {
	            msg += ", " + util.classString(didReject);
	        }
	        this._warn(msg);
	    }
	    return this._then(didFulfill, didReject, undefined, undefined, undefined);
	};
	
	Promise.prototype.done = function (didFulfill, didReject) {
	    var promise =
	        this._then(didFulfill, didReject, undefined, undefined, undefined);
	    promise._setIsFinal();
	};
	
	Promise.prototype.spread = function (fn) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
	};
	
	Promise.prototype.toJSON = function () {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: undefined,
	        rejectionReason: undefined
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this.value();
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this.reason();
	        ret.isRejected = true;
	    }
	    return ret;
	};
	
	Promise.prototype.all = function () {
	    if (arguments.length > 0) {
	        this._warn(".all() was passed arguments but it does not take any");
	    }
	    return new PromiseArray(this).promise();
	};
	
	Promise.prototype.error = function (fn) {
	    return this.caught(util.originatesFromRejection, fn);
	};
	
	Promise.getNewLibraryCopy = module.exports;
	
	Promise.is = function (val) {
	    return val instanceof Promise;
	};
	
	Promise.fromNode = Promise.fromCallback = function(fn) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs
	                                         : false;
	    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
	    if (result === errorObj) {
	        ret._rejectCallback(result.e, true);
	    }
	    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
	    return ret;
	};
	
	Promise.all = function (promises) {
	    return new PromiseArray(promises).promise();
	};
	
	Promise.cast = function (obj) {
	    var ret = tryConvertToPromise(obj);
	    if (!(ret instanceof Promise)) {
	        ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._setFulfilled();
	        ret._rejectionHandler0 = obj;
	    }
	    return ret;
	};
	
	Promise.resolve = Promise.fulfilled = Promise.cast;
	
	Promise.reject = Promise.rejected = function (reason) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._rejectCallback(reason, true);
	    return ret;
	};
	
	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    return async.setScheduler(fn);
	};
	
	Promise.prototype._then = function (
	    didFulfill,
	    didReject,
	    _,    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== undefined;
	    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
	    var target = this._target();
	    var bitField = target._bitField;
	
	    if (!haveInternalData) {
	        promise._propagateFrom(this, 3);
	        promise._captureStackTrace();
	        if (receiver === undefined &&
	            ((this._bitField & 2097152) !== 0)) {
	            if (!((bitField & 50397184) === 0)) {
	                receiver = this._boundValue();
	            } else {
	                receiver = target === this ? undefined : this._boundTo;
	            }
	        }
	        this._fireEvent("promiseChained", this, promise);
	    }
	
	    var domain = getDomain();
	    if (!((bitField & 50397184) === 0)) {
	        var handler, value, settler = target._settlePromiseCtx;
	        if (((bitField & 33554432) !== 0)) {
	            value = target._rejectionHandler0;
	            handler = didFulfill;
	        } else if (((bitField & 16777216) !== 0)) {
	            value = target._fulfillmentHandler0;
	            handler = didReject;
	            target._unsetRejectionIsUnhandled();
	        } else {
	            settler = target._settlePromiseLateCancellationObserver;
	            value = new CancellationError("late cancellation observer");
	            target._attachExtraTrace(value);
	            handler = didReject;
	        }
	
	        async.invoke(settler, target, {
	            handler: domain === null ? handler
	                : (typeof handler === "function" &&
	                    util.domainBind(domain, handler)),
	            promise: promise,
	            receiver: receiver,
	            value: value
	        });
	    } else {
	        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
	    }
	
	    return promise;
	};
	
	Promise.prototype._length = function () {
	    return this._bitField & 65535;
	};
	
	Promise.prototype._isFateSealed = function () {
	    return (this._bitField & 117506048) !== 0;
	};
	
	Promise.prototype._isFollowing = function () {
	    return (this._bitField & 67108864) === 67108864;
	};
	
	Promise.prototype._setLength = function (len) {
	    this._bitField = (this._bitField & -65536) |
	        (len & 65535);
	};
	
	Promise.prototype._setFulfilled = function () {
	    this._bitField = this._bitField | 33554432;
	    this._fireEvent("promiseFulfilled", this);
	};
	
	Promise.prototype._setRejected = function () {
	    this._bitField = this._bitField | 16777216;
	    this._fireEvent("promiseRejected", this);
	};
	
	Promise.prototype._setFollowing = function () {
	    this._bitField = this._bitField | 67108864;
	    this._fireEvent("promiseResolved", this);
	};
	
	Promise.prototype._setIsFinal = function () {
	    this._bitField = this._bitField | 4194304;
	};
	
	Promise.prototype._isFinal = function () {
	    return (this._bitField & 4194304) > 0;
	};
	
	Promise.prototype._unsetCancelled = function() {
	    this._bitField = this._bitField & (~65536);
	};
	
	Promise.prototype._setCancelled = function() {
	    this._bitField = this._bitField | 65536;
	    this._fireEvent("promiseCancelled", this);
	};
	
	Promise.prototype._setWillBeCancelled = function() {
	    this._bitField = this._bitField | 8388608;
	};
	
	Promise.prototype._setAsyncGuaranteed = function() {
	    if (async.hasCustomScheduler()) return;
	    this._bitField = this._bitField | 134217728;
	};
	
	Promise.prototype._receiverAt = function (index) {
	    var ret = index === 0 ? this._receiver0 : this[
	            index * 4 - 4 + 3];
	    if (ret === UNDEFINED_BINDING) {
	        return undefined;
	    } else if (ret === undefined && this._isBound()) {
	        return this._boundValue();
	    }
	    return ret;
	};
	
	Promise.prototype._promiseAt = function (index) {
	    return this[
	            index * 4 - 4 + 2];
	};
	
	Promise.prototype._fulfillmentHandlerAt = function (index) {
	    return this[
	            index * 4 - 4 + 0];
	};
	
	Promise.prototype._rejectionHandlerAt = function (index) {
	    return this[
	            index * 4 - 4 + 1];
	};
	
	Promise.prototype._boundValue = function() {};
	
	Promise.prototype._migrateCallback0 = function (follower) {
	    var bitField = follower._bitField;
	    var fulfill = follower._fulfillmentHandler0;
	    var reject = follower._rejectionHandler0;
	    var promise = follower._promise0;
	    var receiver = follower._receiverAt(0);
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, promise, receiver, null);
	};
	
	Promise.prototype._migrateCallbackAt = function (follower, index) {
	    var fulfill = follower._fulfillmentHandlerAt(index);
	    var reject = follower._rejectionHandlerAt(index);
	    var promise = follower._promiseAt(index);
	    var receiver = follower._receiverAt(index);
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, promise, receiver, null);
	};
	
	Promise.prototype._addCallbacks = function (
	    fulfill,
	    reject,
	    promise,
	    receiver,
	    domain
	) {
	    var index = this._length();
	
	    if (index >= 65535 - 4) {
	        index = 0;
	        this._setLength(0);
	    }
	
	    if (index === 0) {
	        this._promise0 = promise;
	        this._receiver0 = receiver;
	        if (typeof fulfill === "function") {
	            this._fulfillmentHandler0 =
	                domain === null ? fulfill : util.domainBind(domain, fulfill);
	        }
	        if (typeof reject === "function") {
	            this._rejectionHandler0 =
	                domain === null ? reject : util.domainBind(domain, reject);
	        }
	    } else {
	        var base = index * 4 - 4;
	        this[base + 2] = promise;
	        this[base + 3] = receiver;
	        if (typeof fulfill === "function") {
	            this[base + 0] =
	                domain === null ? fulfill : util.domainBind(domain, fulfill);
	        }
	        if (typeof reject === "function") {
	            this[base + 1] =
	                domain === null ? reject : util.domainBind(domain, reject);
	        }
	    }
	    this._setLength(index + 1);
	    return index;
	};
	
	Promise.prototype._proxy = function (proxyable, arg) {
	    this._addCallbacks(undefined, undefined, arg, proxyable, null);
	};
	
	Promise.prototype._resolveCallback = function(value, shouldBind) {
	    if (((this._bitField & 117506048) !== 0)) return;
	    if (value === this)
	        return this._rejectCallback(makeSelfResolutionError(), false);
	    var maybePromise = tryConvertToPromise(value, this);
	    if (!(maybePromise instanceof Promise)) return this._fulfill(value);
	
	    if (shouldBind) this._propagateFrom(maybePromise, 2);
	
	    var promise = maybePromise._target();
	
	    if (promise === this) {
	        this._reject(makeSelfResolutionError());
	        return;
	    }
	
	    var bitField = promise._bitField;
	    if (((bitField & 50397184) === 0)) {
	        var len = this._length();
	        if (len > 0) promise._migrateCallback0(this);
	        for (var i = 1; i < len; ++i) {
	            promise._migrateCallbackAt(this, i);
	        }
	        this._setFollowing();
	        this._setLength(0);
	        this._setFollowee(promise);
	    } else if (((bitField & 33554432) !== 0)) {
	        this._fulfill(promise._value());
	    } else if (((bitField & 16777216) !== 0)) {
	        this._reject(promise._reason());
	    } else {
	        var reason = new CancellationError("late cancellation observer");
	        promise._attachExtraTrace(reason);
	        this._reject(reason);
	    }
	};
	
	Promise.prototype._rejectCallback =
	function(reason, synchronous, ignoreNonErrorWarnings) {
	    var trace = util.ensureErrorObject(reason);
	    var hasStack = trace === reason;
	    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
	        var message = "a promise was rejected with a non-error: " +
	            util.classString(reason);
	        this._warn(message, true);
	    }
	    this._attachExtraTrace(trace, synchronous ? hasStack : false);
	    this._reject(reason);
	};
	
	Promise.prototype._resolveFromExecutor = function (executor) {
	    if (executor === INTERNAL) return;
	    var promise = this;
	    this._captureStackTrace();
	    this._pushContext();
	    var synchronous = true;
	    var r = this._execute(executor, function(value) {
	        promise._resolveCallback(value);
	    }, function (reason) {
	        promise._rejectCallback(reason, synchronous);
	    });
	    synchronous = false;
	    this._popContext();
	
	    if (r !== undefined) {
	        promise._rejectCallback(r, true);
	    }
	};
	
	Promise.prototype._settlePromiseFromHandler = function (
	    handler, receiver, value, promise
	) {
	    var bitField = promise._bitField;
	    if (((bitField & 65536) !== 0)) return;
	    promise._pushContext();
	    var x;
	    if (receiver === APPLY) {
	        if (!value || typeof value.length !== "number") {
	            x = errorObj;
	            x.e = new TypeError("cannot .spread() a non-array: " +
	                                    util.classString(value));
	        } else {
	            x = tryCatch(handler).apply(this._boundValue(), value);
	        }
	    } else {
	        x = tryCatch(handler).call(receiver, value);
	    }
	    var promiseCreated = promise._popContext();
	    bitField = promise._bitField;
	    if (((bitField & 65536) !== 0)) return;
	
	    if (x === NEXT_FILTER) {
	        promise._reject(value);
	    } else if (x === errorObj) {
	        promise._rejectCallback(x.e, false);
	    } else {
	        debug.checkForgottenReturns(x, promiseCreated, "",  promise, this);
	        promise._resolveCallback(x);
	    }
	};
	
	Promise.prototype._target = function() {
	    var ret = this;
	    while (ret._isFollowing()) ret = ret._followee();
	    return ret;
	};
	
	Promise.prototype._followee = function() {
	    return this._rejectionHandler0;
	};
	
	Promise.prototype._setFollowee = function(promise) {
	    this._rejectionHandler0 = promise;
	};
	
	Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
	    var isPromise = promise instanceof Promise;
	    var bitField = this._bitField;
	    var asyncGuaranteed = ((bitField & 134217728) !== 0);
	    if (((bitField & 65536) !== 0)) {
	        if (isPromise) promise._invokeInternalOnCancel();
	
	        if (receiver instanceof PassThroughHandlerContext &&
	            receiver.isFinallyHandler()) {
	            receiver.cancelPromise = promise;
	            if (tryCatch(handler).call(receiver, value) === errorObj) {
	                promise._reject(errorObj.e);
	            }
	        } else if (handler === reflectHandler) {
	            promise._fulfill(reflectHandler.call(receiver));
	        } else if (receiver instanceof Proxyable) {
	            receiver._promiseCancelled(promise);
	        } else if (isPromise || promise instanceof PromiseArray) {
	            promise._cancel();
	        } else {
	            receiver.cancel();
	        }
	    } else if (typeof handler === "function") {
	        if (!isPromise) {
	            handler.call(receiver, value, promise);
	        } else {
	            if (asyncGuaranteed) promise._setAsyncGuaranteed();
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (receiver instanceof Proxyable) {
	        if (!receiver._isResolved()) {
	            if (((bitField & 33554432) !== 0)) {
	                receiver._promiseFulfilled(value, promise);
	            } else {
	                receiver._promiseRejected(value, promise);
	            }
	        }
	    } else if (isPromise) {
	        if (asyncGuaranteed) promise._setAsyncGuaranteed();
	        if (((bitField & 33554432) !== 0)) {
	            promise._fulfill(value);
	        } else {
	            promise._reject(value);
	        }
	    }
	};
	
	Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
	    var handler = ctx.handler;
	    var promise = ctx.promise;
	    var receiver = ctx.receiver;
	    var value = ctx.value;
	    if (typeof handler === "function") {
	        if (!(promise instanceof Promise)) {
	            handler.call(receiver, value, promise);
	        } else {
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (promise instanceof Promise) {
	        promise._reject(value);
	    }
	};
	
	Promise.prototype._settlePromiseCtx = function(ctx) {
	    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
	};
	
	Promise.prototype._settlePromise0 = function(handler, value, bitField) {
	    var promise = this._promise0;
	    var receiver = this._receiverAt(0);
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._settlePromise(promise, handler, receiver, value);
	};
	
	Promise.prototype._clearCallbackDataAtIndex = function(index) {
	    var base = index * 4 - 4;
	    this[base + 2] =
	    this[base + 3] =
	    this[base + 0] =
	    this[base + 1] = undefined;
	};
	
	Promise.prototype._fulfill = function (value) {
	    var bitField = this._bitField;
	    if (((bitField & 117506048) >>> 16)) return;
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._reject(err);
	    }
	    this._setFulfilled();
	    this._rejectionHandler0 = value;
	
	    if ((bitField & 65535) > 0) {
	        if (((bitField & 134217728) !== 0)) {
	            this._settlePromises();
	        } else {
	            async.settlePromises(this);
	        }
	    }
	};
	
	Promise.prototype._reject = function (reason) {
	    var bitField = this._bitField;
	    if (((bitField & 117506048) >>> 16)) return;
	    this._setRejected();
	    this._fulfillmentHandler0 = reason;
	
	    if (this._isFinal()) {
	        return async.fatalError(reason, util.isNode);
	    }
	
	    if ((bitField & 65535) > 0) {
	        async.settlePromises(this);
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};
	
	Promise.prototype._fulfillPromises = function (len, value) {
	    for (var i = 1; i < len; i++) {
	        var handler = this._fulfillmentHandlerAt(i);
	        var promise = this._promiseAt(i);
	        var receiver = this._receiverAt(i);
	        this._clearCallbackDataAtIndex(i);
	        this._settlePromise(promise, handler, receiver, value);
	    }
	};
	
	Promise.prototype._rejectPromises = function (len, reason) {
	    for (var i = 1; i < len; i++) {
	        var handler = this._rejectionHandlerAt(i);
	        var promise = this._promiseAt(i);
	        var receiver = this._receiverAt(i);
	        this._clearCallbackDataAtIndex(i);
	        this._settlePromise(promise, handler, receiver, reason);
	    }
	};
	
	Promise.prototype._settlePromises = function () {
	    var bitField = this._bitField;
	    var len = (bitField & 65535);
	
	    if (len > 0) {
	        if (((bitField & 16842752) !== 0)) {
	            var reason = this._fulfillmentHandler0;
	            this._settlePromise0(this._rejectionHandler0, reason, bitField);
	            this._rejectPromises(len, reason);
	        } else {
	            var value = this._rejectionHandler0;
	            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
	            this._fulfillPromises(len, value);
	        }
	        this._setLength(0);
	    }
	    this._clearCancellationData();
	};
	
	Promise.prototype._settledValue = function() {
	    var bitField = this._bitField;
	    if (((bitField & 33554432) !== 0)) {
	        return this._rejectionHandler0;
	    } else if (((bitField & 16777216) !== 0)) {
	        return this._fulfillmentHandler0;
	    }
	};
	
	function deferResolve(v) {this.promise._resolveCallback(v);}
	function deferReject(v) {this.promise._rejectCallback(v, false);}
	
	Promise.defer = Promise.pending = function() {
	    debug.deprecated("Promise.defer", "new Promise");
	    var promise = new Promise(INTERNAL);
	    return {
	        promise: promise,
	        resolve: deferResolve,
	        reject: deferReject
	    };
	};
	
	util.notEnumerableProp(Promise,
	                       "_makeSelfResolutionError",
	                       makeSelfResolutionError);
	
	__webpack_require__(137)(Promise, INTERNAL, tryConvertToPromise, apiRejection,
	    debug);
	__webpack_require__(138)(Promise, INTERNAL, tryConvertToPromise, debug);
	__webpack_require__(139)(Promise, PromiseArray, apiRejection, debug);
	__webpack_require__(140)(Promise);
	__webpack_require__(141)(Promise);
	__webpack_require__(142)(
	    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
	Promise.Promise = Promise;
	Promise.version = "3.5.0";
	__webpack_require__(143)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
	__webpack_require__(144)(Promise);
	__webpack_require__(145)(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
	__webpack_require__(146)(Promise, INTERNAL, debug);
	__webpack_require__(147)(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
	__webpack_require__(148)(Promise);
	__webpack_require__(149)(Promise, INTERNAL);
	__webpack_require__(150)(Promise, PromiseArray, tryConvertToPromise, apiRejection);
	__webpack_require__(151)(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	__webpack_require__(152)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
	__webpack_require__(153)(Promise, PromiseArray, debug);
	__webpack_require__(154)(Promise, PromiseArray, apiRejection);
	__webpack_require__(155)(Promise, INTERNAL);
	__webpack_require__(156)(Promise, INTERNAL);
	__webpack_require__(157)(Promise);
	                                                         
	    util.toFastProperties(Promise);                                          
	    util.toFastProperties(Promise.prototype);                                
	    function fillTypes(value) {                                              
	        var p = new Promise(INTERNAL);                                       
	        p._fulfillmentHandler0 = value;                                      
	        p._rejectionHandler0 = value;                                        
	        p._promise0 = value;                                                 
	        p._receiver0 = value;                                                
	    }                                                                        
	    // Complete slack tracking, opt out of field-type tracking and           
	    // stabilize map                                                         
	    fillTypes({a: 1});                                                       
	    fillTypes({b: 2});                                                       
	    fillTypes({c: 3});                                                       
	    fillTypes(1);                                                            
	    fillTypes(function(){});                                                 
	    fillTypes(undefined);                                                    
	    fillTypes(false);                                                        
	    fillTypes(new Promise(INTERNAL));                                        
	    debug.setBounds(Async.firstLineError, util.lastLineError);               
	    return Promise;                                                          
	
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ }),
/* 121 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {"use strict";
	var es5 = __webpack_require__(123);
	var canEvaluate = typeof navigator == "undefined";
	
	var errorObj = {e: {}};
	var tryCatchTarget;
	var globalObject = typeof self !== "undefined" ? self :
	    typeof window !== "undefined" ? window :
	    typeof global !== "undefined" ? global :
	    this !== undefined ? this : null;
	
	function tryCatcher() {
	    try {
	        var target = tryCatchTarget;
	        tryCatchTarget = null;
	        return target.apply(this, arguments);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	
	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;
	
	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};
	
	
	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";
	
	}
	
	function isObject(value) {
	    return typeof value === "function" ||
	           typeof value === "object" && value !== null;
	}
	
	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;
	
	    return new Error(safeToString(maybeError));
	}
	
	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}
	
	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);
	
	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
	    }
	}
	
	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}
	
	function thrower(r) {
	    throw r;
	}
	
	var inheritedDataKeys = (function() {
	    var excludedPrototypes = [
	        Array.prototype,
	        Object.prototype,
	        Function.prototype
	    ];
	
	    var isExcludedProto = function(val) {
	        for (var i = 0; i < excludedPrototypes.length; ++i) {
	            if (excludedPrototypes[i] === val) {
	                return true;
	            }
	        }
	        return false;
	    };
	
	    if (es5.isES5) {
	        var getKeys = Object.getOwnPropertyNames;
	        return function(obj) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            while (obj != null && !isExcludedProto(obj)) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        var hasProp = {}.hasOwnProperty;
	        return function(obj) {
	            if (isExcludedProto(obj)) return [];
	            var ret = [];
	
	            /*jshint forin:false */
	            enumeration: for (var key in obj) {
	                if (hasProp.call(obj, key)) {
	                    ret.push(key);
	                } else {
	                    for (var i = 0; i < excludedPrototypes.length; ++i) {
	                        if (hasProp.call(excludedPrototypes[i], key)) {
	                            continue enumeration;
	                        }
	                    }
	                    ret.push(key);
	                }
	            }
	            return ret;
	        };
	    }
	
	})();
	
	var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.names(fn.prototype);
	
	            var hasMethods = es5.isES5 && keys.length > 1;
	            var hasMethodsOtherThanConstructor = keys.length > 0 &&
	                !(keys.length === 1 && keys[0] === "constructor");
	            var hasThisAssignmentAndStaticMethods =
	                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
	
	            if (hasMethods || hasMethodsOtherThanConstructor ||
	                hasThisAssignmentAndStaticMethods) {
	                return true;
	            }
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}
	
	function toFastProperties(obj) {
	    /*jshint -W027,-W055,-W031*/
	    function FakeConstructor() {}
	    FakeConstructor.prototype = obj;
	    var l = 8;
	    while (l--) new FakeConstructor();
	    return obj;
	    eval(obj);
	}
	
	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}
	
	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}
	
	function safeToString(obj) {
	    try {
	        return obj + "";
	    } catch (e) {
	        return "[no string representation]";
	    }
	}
	
	function isError(obj) {
	    return obj !== null &&
	           typeof obj === "object" &&
	           typeof obj.message === "string" &&
	           typeof obj.name === "string";
	}
	
	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}
	
	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
	        e["isOperational"] === true);
	}
	
	function canAttachTrace(obj) {
	    return isError(obj) && es5.propertyIsWritable(obj, "stack");
	}
	
	var ensureErrorObject = (function() {
	    if (!("stack" in new Error())) {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            try {throw new Error(safeToString(value));}
	            catch(err) {return err;}
	        };
	    } else {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            return new Error(safeToString(value));
	        };
	    }
	})();
	
	function classString(obj) {
	    return {}.toString.call(obj);
	}
	
	function copyDescriptors(from, to, filter) {
	    var keys = es5.names(from);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        if (filter(key)) {
	            try {
	                es5.defineProperty(to, key, es5.getDescriptor(from, key));
	            } catch (ignore) {}
	        }
	    }
	}
	
	var asArray = function(v) {
	    if (es5.isArray(v)) {
	        return v;
	    }
	    return null;
	};
	
	if (typeof Symbol !== "undefined" && Symbol.iterator) {
	    var ArrayFrom = typeof Array.from === "function" ? function(v) {
	        return Array.from(v);
	    } : function(v) {
	        var ret = [];
	        var it = v[Symbol.iterator]();
	        var itResult;
	        while (!((itResult = it.next()).done)) {
	            ret.push(itResult.value);
	        }
	        return ret;
	    };
	
	    asArray = function(v) {
	        if (es5.isArray(v)) {
	            return v;
	        } else if (v != null && typeof v[Symbol.iterator] === "function") {
	            return ArrayFrom(v);
	        }
	        return null;
	    };
	}
	
	var isNode = typeof process !== "undefined" &&
	        classString(process).toLowerCase() === "[object process]";
	
	var hasEnvVariables = typeof process !== "undefined" &&
	    typeof process.env !== "undefined";
	
	function env(key) {
	    return hasEnvVariables ? process.env[key] : undefined;
	}
	
	function getNativePromise() {
	    if (typeof Promise === "function") {
	        try {
	            var promise = new Promise(function(){});
	            if ({}.toString.call(promise) === "[object Promise]") {
	                return Promise;
	            }
	        } catch (e) {}
	    }
	}
	
	function domainBind(self, cb) {
	    return self.bind(cb);
	}
	
	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    asArray: asArray,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    isError: isError,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch: tryCatch,
	    inherits: inherits,
	    withAppended: withAppended,
	    maybeWrapAsError: maybeWrapAsError,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange,
	    toString: safeToString,
	    canAttachTrace: canAttachTrace,
	    ensureErrorObject: ensureErrorObject,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    classString: classString,
	    copyDescriptors: copyDescriptors,
	    hasDevTools: typeof chrome !== "undefined" && chrome &&
	                 typeof chrome.loadTimes === "function",
	    isNode: isNode,
	    hasEnvVariables: hasEnvVariables,
	    env: env,
	    global: globalObject,
	    getNativePromise: getNativePromise,
	    domainBind: domainBind
	};
	ret.isRecentNode = ret.isNode && (function() {
	    var version = process.versions.node.split(".").map(Number);
	    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
	})();
	
	if (ret.isNode) ret.toFastProperties(process);
	
	try {throw new Error(); } catch (e) {ret.lastLineError = e;}
	module.exports = ret;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(121)))

/***/ }),
/* 123 */
/***/ (function(module, exports) {

	var isES5 = (function(){
	    "use strict";
	    return this === undefined;
	})();
	
	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        getDescriptor: Object.getOwnPropertyDescriptor,
	        keys: Object.keys,
	        names: Object.getOwnPropertyNames,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5,
	        propertyIsWritable: function(obj, prop) {
	            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	            return !!(!descriptor || descriptor.writable || descriptor.set);
	        }
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;
	
	    var ObjectKeys = function (o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    };
	
	    var ObjectGetDescriptor = function(o, key) {
	        return {value: o[key]};
	    };
	
	    var ObjectDefineProperty = function (o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    };
	
	    var ObjectFreeze = function (obj) {
	        return obj;
	    };
	
	    var ObjectGetPrototypeOf = function (obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    };
	
	    var ArrayIsArray = function (obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    };
	
	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        names: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        getDescriptor: ObjectGetDescriptor,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5,
	        propertyIsWritable: function() {
	            return true;
	        }
	    };
	}


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	var firstLineError;
	try {throw new Error(); } catch (e) {firstLineError = e;}
	var schedule = __webpack_require__(125);
	var Queue = __webpack_require__(128);
	var util = __webpack_require__(122);
	
	function Async() {
	    this._customScheduler = false;
	    this._isTickUsed = false;
	    this._lateQueue = new Queue(16);
	    this._normalQueue = new Queue(16);
	    this._haveDrainedQueues = false;
	    this._trampolineEnabled = true;
	    var self = this;
	    this.drainQueues = function () {
	        self._drainQueues();
	    };
	    this._schedule = schedule;
	}
	
	Async.prototype.setScheduler = function(fn) {
	    var prev = this._schedule;
	    this._schedule = fn;
	    this._customScheduler = true;
	    return prev;
	};
	
	Async.prototype.hasCustomScheduler = function() {
	    return this._customScheduler;
	};
	
	Async.prototype.enableTrampoline = function() {
	    this._trampolineEnabled = true;
	};
	
	Async.prototype.disableTrampolineIfNecessary = function() {
	    if (util.hasDevTools) {
	        this._trampolineEnabled = false;
	    }
	};
	
	Async.prototype.haveItemsQueued = function () {
	    return this._isTickUsed || this._haveDrainedQueues;
	};
	
	
	Async.prototype.fatalError = function(e, isNode) {
	    if (isNode) {
	        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) +
	            "\n");
	        process.exit(2);
	    } else {
	        this.throwLater(e);
	    }
	};
	
	Async.prototype.throwLater = function(fn, arg) {
	    if (arguments.length === 1) {
	        arg = fn;
	        fn = function () { throw arg; };
	    }
	    if (typeof setTimeout !== "undefined") {
	        setTimeout(function() {
	            fn(arg);
	        }, 0);
	    } else try {
	        this._schedule(function() {
	            fn(arg);
	        });
	    } catch (e) {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	};
	
	function AsyncInvokeLater(fn, receiver, arg) {
	    this._lateQueue.push(fn, receiver, arg);
	    this._queueTick();
	}
	
	function AsyncInvoke(fn, receiver, arg) {
	    this._normalQueue.push(fn, receiver, arg);
	    this._queueTick();
	}
	
	function AsyncSettlePromises(promise) {
	    this._normalQueue._pushOne(promise);
	    this._queueTick();
	}
	
	if (!util.hasDevTools) {
	    Async.prototype.invokeLater = AsyncInvokeLater;
	    Async.prototype.invoke = AsyncInvoke;
	    Async.prototype.settlePromises = AsyncSettlePromises;
	} else {
	    Async.prototype.invokeLater = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvokeLater.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                setTimeout(function() {
	                    fn.call(receiver, arg);
	                }, 100);
	            });
	        }
	    };
	
	    Async.prototype.invoke = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvoke.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                fn.call(receiver, arg);
	            });
	        }
	    };
	
	    Async.prototype.settlePromises = function(promise) {
	        if (this._trampolineEnabled) {
	            AsyncSettlePromises.call(this, promise);
	        } else {
	            this._schedule(function() {
	                promise._settlePromises();
	            });
	        }
	    };
	}
	
	Async.prototype._drainQueue = function(queue) {
	    while (queue.length() > 0) {
	        var fn = queue.shift();
	        if (typeof fn !== "function") {
	            fn._settlePromises();
	            continue;
	        }
	        var receiver = queue.shift();
	        var arg = queue.shift();
	        fn.call(receiver, arg);
	    }
	};
	
	Async.prototype._drainQueues = function () {
	    this._drainQueue(this._normalQueue);
	    this._reset();
	    this._haveDrainedQueues = true;
	    this._drainQueue(this._lateQueue);
	};
	
	Async.prototype._queueTick = function () {
	    if (!this._isTickUsed) {
	        this._isTickUsed = true;
	        this._schedule(this.drainQueues);
	    }
	};
	
	Async.prototype._reset = function () {
	    this._isTickUsed = false;
	};
	
	module.exports = Async;
	module.exports.firstLineError = firstLineError;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process, setImmediate) {"use strict";
	var util = __webpack_require__(122);
	var schedule;
	var noAsyncScheduler = function() {
	    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	};
	var NativePromise = util.getNativePromise();
	if (util.isNode && typeof MutationObserver === "undefined") {
	    var GlobalSetImmediate = global.setImmediate;
	    var ProcessNextTick = process.nextTick;
	    schedule = util.isRecentNode
	                ? function(fn) { GlobalSetImmediate.call(global, fn); }
	                : function(fn) { ProcessNextTick.call(process, fn); };
	} else if (typeof NativePromise === "function" &&
	           typeof NativePromise.resolve === "function") {
	    var nativePromise = NativePromise.resolve();
	    schedule = function(fn) {
	        nativePromise.then(fn);
	    };
	} else if ((typeof MutationObserver !== "undefined") &&
	          !(typeof window !== "undefined" &&
	            window.navigator &&
	            (window.navigator.standalone || window.cordova))) {
	    schedule = (function() {
	        var div = document.createElement("div");
	        var opts = {attributes: true};
	        var toggleScheduled = false;
	        var div2 = document.createElement("div");
	        var o2 = new MutationObserver(function() {
	            div.classList.toggle("foo");
	            toggleScheduled = false;
	        });
	        o2.observe(div2, opts);
	
	        var scheduleToggle = function() {
	            if (toggleScheduled) return;
	            toggleScheduled = true;
	            div2.classList.toggle("foo");
	        };
	
	        return function schedule(fn) {
	            var o = new MutationObserver(function() {
	                o.disconnect();
	                fn();
	            });
	            o.observe(div, opts);
	            scheduleToggle();
	        };
	    })();
	} else if (typeof setImmediate !== "undefined") {
	    schedule = function (fn) {
	        setImmediate(fn);
	    };
	} else if (typeof setTimeout !== "undefined") {
	    schedule = function (fn) {
	        setTimeout(fn, 0);
	    };
	} else {
	    schedule = noAsyncScheduler;
	}
	module.exports = schedule;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(121), __webpack_require__(126).setImmediate))

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
	            (typeof self !== "undefined" && self) ||
	            window;
	var apply = Function.prototype.apply;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(scope, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// setimmediate attaches itself to the global object
	__webpack_require__(127);
	// On some exotic environments, it's not clear which object `setimmediate` was
	// able to install onto.  Search each possibility in the same order as the
	// `setimmediate` library.
	exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
	                       (typeof global !== "undefined" && global.setImmediate) ||
	                       (this && this.setImmediate);
	exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
	                         (typeof global !== "undefined" && global.clearImmediate) ||
	                         (this && this.clearImmediate);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
	    "use strict";
	
	    if (global.setImmediate) {
	        return;
	    }
	
	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;
	
	    function setImmediate(callback) {
	      // Callback can either be a function or a string
	      if (typeof callback !== "function") {
	        callback = new Function("" + callback);
	      }
	      // Copy function arguments
	      var args = new Array(arguments.length - 1);
	      for (var i = 0; i < args.length; i++) {
	          args[i] = arguments[i + 1];
	      }
	      // Store and register the task
	      var task = { callback: callback, args: args };
	      tasksByHandle[nextHandle] = task;
	      registerImmediate(nextHandle);
	      return nextHandle++;
	    }
	
	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }
	
	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	        case 0:
	            callback();
	            break;
	        case 1:
	            callback(args[0]);
	            break;
	        case 2:
	            callback(args[0], args[1]);
	            break;
	        case 3:
	            callback(args[0], args[1], args[2]);
	            break;
	        default:
	            callback.apply(undefined, args);
	            break;
	        }
	    }
	
	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }
	
	    function installNextTickImplementation() {
	        registerImmediate = function(handle) {
	            process.nextTick(function () { runIfPresent(handle); });
	        };
	    }
	
	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function() {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }
	
	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	
	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function(event) {
	            if (event.source === global &&
	                typeof event.data === "string" &&
	                event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	
	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }
	
	        registerImmediate = function(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }
	
	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function(event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };
	
	        registerImmediate = function(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }
	
	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }
	
	    function installSetTimeoutImplementation() {
	        registerImmediate = function(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }
	
	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
	
	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();
	
	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();
	
	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();
	
	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 6–8
	        installReadyStateChangeImplementation();
	
	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }
	
	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(121)))

/***/ }),
/* 128 */
/***/ (function(module, exports) {

	"use strict";
	function arrayMove(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	        src[j + srcIndex] = void 0;
	    }
	}
	
	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	}
	
	Queue.prototype._willBeOverCapacity = function (size) {
	    return this._capacity < size;
	};
	
	Queue.prototype._pushOne = function (arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};
	
	Queue.prototype.push = function (fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};
	
	Queue.prototype.shift = function () {
	    var front = this._front,
	        ret = this[front];
	
	    this[front] = undefined;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};
	
	Queue.prototype.length = function () {
	    return this._length;
	};
	
	Queue.prototype._checkCapacity = function (size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 1);
	    }
	};
	
	Queue.prototype._resizeTo = function (capacity) {
	    var oldCapacity = this._capacity;
	    this._capacity = capacity;
	    var front = this._front;
	    var length = this._length;
	    var moveItemsCount = (front + length) & (oldCapacity - 1);
	    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
	};
	
	module.exports = Queue;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var es5 = __webpack_require__(123);
	var Objectfreeze = es5.freeze;
	var util = __webpack_require__(122);
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;
	
	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        notEnumerableProp(this, "message",
	            typeof message === "string" ? message : defaultMessage);
	        notEnumerableProp(this, "name", nameProperty);
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            Error.call(this);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}
	
	var _TypeError, _RangeError;
	var Warning = subError("Warning", "warning");
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}
	
	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
	
	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}
	
	es5.defineProperty(AggregateError.prototype, "length", {
	    value: 0,
	    configurable: false,
	    writable: true,
	    enumerable: true
	});
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};
	
	function OperationalError(message) {
	    if (!(this instanceof OperationalError))
	        return new OperationalError(message);
	    notEnumerableProp(this, "name", "OperationalError");
	    notEnumerableProp(this, "message", message);
	    this.cause = message;
	    this["isOperational"] = true;
	
	    if (message instanceof Error) {
	        notEnumerableProp(this, "message", message.message);
	        notEnumerableProp(this, "stack", message.stack);
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }
	
	}
	inherits(OperationalError, Error);
	
	var errorTypes = Error["__BluebirdErrorTypes__"];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
	        value: errorTypes,
	        writable: false,
	        enumerable: false,
	        configurable: false
	    });
	}
	
	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    Warning: Warning
	};


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = __webpack_require__(122);
	var errorObj = util.errorObj;
	var isObject = util.isObject;
	
	function tryConvertToPromise(obj, context) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) return obj;
	        var then = getThen(obj);
	        if (then === errorObj) {
	            if (context) context._pushContext();
	            var ret = Promise.reject(then.e);
	            if (context) context._popContext();
	            return ret;
	        } else if (typeof then === "function") {
	            if (isAnyBluebirdPromise(obj)) {
	                var ret = new Promise(INTERNAL);
	                obj._then(
	                    ret._fulfill,
	                    ret._reject,
	                    undefined,
	                    ret,
	                    null
	                );
	                return ret;
	            }
	            return doThenable(obj, then, context);
	        }
	    }
	    return obj;
	}
	
	function doGetThen(obj) {
	    return obj.then;
	}
	
	function getThen(obj) {
	    try {
	        return doGetThen(obj);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	
	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    try {
	        return hasProp.call(obj, "_promise0");
	    } catch (e) {
	        return false;
	    }
	}
	
	function doThenable(x, then, context) {
	    var promise = new Promise(INTERNAL);
	    var ret = promise;
	    if (context) context._pushContext();
	    promise._captureStackTrace();
	    if (context) context._popContext();
	    var synchronous = true;
	    var result = util.tryCatch(then).call(x, resolve, reject);
	    synchronous = false;
	
	    if (promise && result === errorObj) {
	        promise._rejectCallback(result.e, true, true);
	        promise = null;
	    }
	
	    function resolve(value) {
	        if (!promise) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }
	
	    function reject(reason) {
	        if (!promise) return;
	        promise._rejectCallback(reason, synchronous, true);
	        promise = null;
	    }
	    return ret;
	}
	
	return tryConvertToPromise;
	};


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise,
	    apiRejection, Proxyable) {
	var util = __webpack_require__(122);
	var isArray = util.isArray;
	
	function toResolutionValue(val) {
	    switch(val) {
	    case -2: return [];
	    case -3: return {};
	    case -6: return new Map();
	    }
	}
	
	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    if (values instanceof Promise) {
	        promise._propagateFrom(values, 3);
	    }
	    promise._setOnCancel(this);
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(undefined, -2);
	}
	util.inherits(PromiseArray, Proxyable);
	
	PromiseArray.prototype.length = function () {
	    return this._length;
	};
	
	PromiseArray.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
	    var values = tryConvertToPromise(this._values, this._promise);
	    if (values instanceof Promise) {
	        values = values._target();
	        var bitField = values._bitField;
	        ;
	        this._values = values;
	
	        if (((bitField & 50397184) === 0)) {
	            this._promise._setAsyncGuaranteed();
	            return values._then(
	                init,
	                this._reject,
	                undefined,
	                this,
	                resolveValueIfEmpty
	           );
	        } else if (((bitField & 33554432) !== 0)) {
	            values = values._value();
	        } else if (((bitField & 16777216) !== 0)) {
	            return this._reject(values._reason());
	        } else {
	            return this._cancel();
	        }
	    }
	    values = util.asArray(values);
	    if (values === null) {
	        var err = apiRejection(
	            "expecting an array or an iterable object but got " + util.classString(values)).reason();
	        this._promise._rejectCallback(err, false);
	        return;
	    }
	
	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    this._iterate(values);
	};
	
	PromiseArray.prototype._iterate = function(values) {
	    var len = this.getActualLength(values.length);
	    this._length = len;
	    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
	    var result = this._promise;
	    var isResolved = false;
	    var bitField = null;
	    for (var i = 0; i < len; ++i) {
	        var maybePromise = tryConvertToPromise(values[i], result);
	
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            bitField = maybePromise._bitField;
	        } else {
	            bitField = null;
	        }
	
	        if (isResolved) {
	            if (bitField !== null) {
	                maybePromise.suppressUnhandledRejections();
	            }
	        } else if (bitField !== null) {
	            if (((bitField & 50397184) === 0)) {
	                maybePromise._proxy(this, i);
	                this._values[i] = maybePromise;
	            } else if (((bitField & 33554432) !== 0)) {
	                isResolved = this._promiseFulfilled(maybePromise._value(), i);
	            } else if (((bitField & 16777216) !== 0)) {
	                isResolved = this._promiseRejected(maybePromise._reason(), i);
	            } else {
	                isResolved = this._promiseCancelled(i);
	            }
	        } else {
	            isResolved = this._promiseFulfilled(maybePromise, i);
	        }
	    }
	    if (!isResolved) result._setAsyncGuaranteed();
	};
	
	PromiseArray.prototype._isResolved = function () {
	    return this._values === null;
	};
	
	PromiseArray.prototype._resolve = function (value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};
	
	PromiseArray.prototype._cancel = function() {
	    if (this._isResolved() || !this._promise._isCancellable()) return;
	    this._values = null;
	    this._promise._cancel();
	};
	
	PromiseArray.prototype._reject = function (reason) {
	    this._values = null;
	    this._promise._rejectCallback(reason, false);
	};
	
	PromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	        return true;
	    }
	    return false;
	};
	
	PromiseArray.prototype._promiseCancelled = function() {
	    this._cancel();
	    return true;
	};
	
	PromiseArray.prototype._promiseRejected = function (reason) {
	    this._totalResolved++;
	    this._reject(reason);
	    return true;
	};
	
	PromiseArray.prototype._resultCancelled = function() {
	    if (this._isResolved()) return;
	    var values = this._values;
	    this._cancel();
	    if (values instanceof Promise) {
	        values.cancel();
	    } else {
	        for (var i = 0; i < values.length; ++i) {
	            if (values[i] instanceof Promise) {
	                values[i].cancel();
	            }
	        }
	    }
	};
	
	PromiseArray.prototype.shouldCopyValues = function () {
	    return true;
	};
	
	PromiseArray.prototype.getActualLength = function (len) {
	    return len;
	};
	
	return PromiseArray;
	};


/***/ }),
/* 132 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = function(Promise) {
	var longStackTraces = false;
	var contextStack = [];
	
	Promise.prototype._promiseCreated = function() {};
	Promise.prototype._pushContext = function() {};
	Promise.prototype._popContext = function() {return null;};
	Promise._peekContext = Promise.prototype._peekContext = function() {};
	
	function Context() {
	    this._trace = new Context.CapturedTrace(peekContext());
	}
	Context.prototype._pushContext = function () {
	    if (this._trace !== undefined) {
	        this._trace._promiseCreated = null;
	        contextStack.push(this._trace);
	    }
	};
	
	Context.prototype._popContext = function () {
	    if (this._trace !== undefined) {
	        var trace = contextStack.pop();
	        var ret = trace._promiseCreated;
	        trace._promiseCreated = null;
	        return ret;
	    }
	    return null;
	};
	
	function createContext() {
	    if (longStackTraces) return new Context();
	}
	
	function peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return undefined;
	}
	Context.CapturedTrace = null;
	Context.create = createContext;
	Context.deactivateLongStackTraces = function() {};
	Context.activateLongStackTraces = function() {
	    var Promise_pushContext = Promise.prototype._pushContext;
	    var Promise_popContext = Promise.prototype._popContext;
	    var Promise_PeekContext = Promise._peekContext;
	    var Promise_peekContext = Promise.prototype._peekContext;
	    var Promise_promiseCreated = Promise.prototype._promiseCreated;
	    Context.deactivateLongStackTraces = function() {
	        Promise.prototype._pushContext = Promise_pushContext;
	        Promise.prototype._popContext = Promise_popContext;
	        Promise._peekContext = Promise_PeekContext;
	        Promise.prototype._peekContext = Promise_peekContext;
	        Promise.prototype._promiseCreated = Promise_promiseCreated;
	        longStackTraces = false;
	    };
	    longStackTraces = true;
	    Promise.prototype._pushContext = Context.prototype._pushContext;
	    Promise.prototype._popContext = Context.prototype._popContext;
	    Promise._peekContext = Promise.prototype._peekContext = peekContext;
	    Promise.prototype._promiseCreated = function() {
	        var ctx = this._peekContext();
	        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
	    };
	};
	return Context;
	};


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	module.exports = function(Promise, Context) {
	var getDomain = Promise._getDomain;
	var async = Promise._async;
	var Warning = __webpack_require__(129).Warning;
	var util = __webpack_require__(122);
	var canAttachTrace = util.canAttachTrace;
	var unhandledRejectionHandled;
	var possiblyUnhandledRejection;
	var bluebirdFramePattern =
	    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
	var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
	var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
	var stackFramePattern = null;
	var formatStack = null;
	var indentStackFrames = false;
	var printWarning;
	var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 &&
	                        (false ||
	                         util.env("BLUEBIRD_DEBUG") ||
	                         util.env("NODE_ENV") === "development"));
	
	var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 &&
	    (debugging || util.env("BLUEBIRD_WARNINGS")));
	
	var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 &&
	    (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
	
	var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 &&
	    (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
	
	Promise.prototype.suppressUnhandledRejections = function() {
	    var target = this._target();
	    target._bitField = ((target._bitField & (~1048576)) |
	                      524288);
	};
	
	Promise.prototype._ensurePossibleRejectionHandled = function () {
	    if ((this._bitField & 524288) !== 0) return;
	    this._setRejectionIsUnhandled();
	    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
	};
	
	Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
	    fireRejectionEvent("rejectionHandled",
	                                  unhandledRejectionHandled, undefined, this);
	};
	
	Promise.prototype._setReturnedNonUndefined = function() {
	    this._bitField = this._bitField | 268435456;
	};
	
	Promise.prototype._returnedNonUndefined = function() {
	    return (this._bitField & 268435456) !== 0;
	};
	
	Promise.prototype._notifyUnhandledRejection = function () {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._settledValue();
	        this._setUnhandledRejectionIsNotified();
	        fireRejectionEvent("unhandledRejection",
	                                      possiblyUnhandledRejection, reason, this);
	    }
	};
	
	Promise.prototype._setUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField | 262144;
	};
	
	Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField & (~262144);
	};
	
	Promise.prototype._isUnhandledRejectionNotified = function () {
	    return (this._bitField & 262144) > 0;
	};
	
	Promise.prototype._setRejectionIsUnhandled = function () {
	    this._bitField = this._bitField | 1048576;
	};
	
	Promise.prototype._unsetRejectionIsUnhandled = function () {
	    this._bitField = this._bitField & (~1048576);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};
	
	Promise.prototype._isRejectionUnhandled = function () {
	    return (this._bitField & 1048576) > 0;
	};
	
	Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
	    return warn(message, shouldUseOwnTrace, promise || this);
	};
	
	Promise.onPossiblyUnhandledRejection = function (fn) {
	    var domain = getDomain();
	    possiblyUnhandledRejection =
	        typeof fn === "function" ? (domain === null ?
	                                            fn : util.domainBind(domain, fn))
	                                 : undefined;
	};
	
	Promise.onUnhandledRejectionHandled = function (fn) {
	    var domain = getDomain();
	    unhandledRejectionHandled =
	        typeof fn === "function" ? (domain === null ?
	                                            fn : util.domainBind(domain, fn))
	                                 : undefined;
	};
	
	var disableLongStackTraces = function() {};
	Promise.longStackTraces = function () {
	    if (async.haveItemsQueued() && !config.longStackTraces) {
	        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    if (!config.longStackTraces && longStackTracesIsSupported()) {
	        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
	        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
	        config.longStackTraces = true;
	        disableLongStackTraces = function() {
	            if (async.haveItemsQueued() && !config.longStackTraces) {
	                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	            }
	            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
	            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
	            Context.deactivateLongStackTraces();
	            async.enableTrampoline();
	            config.longStackTraces = false;
	        };
	        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
	        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
	        Context.activateLongStackTraces();
	        async.disableTrampolineIfNecessary();
	    }
	};
	
	Promise.hasLongStackTraces = function () {
	    return config.longStackTraces && longStackTracesIsSupported();
	};
	
	var fireDomEvent = (function() {
	    try {
	        if (typeof CustomEvent === "function") {
	            var event = new CustomEvent("CustomEvent");
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = new CustomEvent(name.toLowerCase(), {
	                    detail: event,
	                    cancelable: true
	                });
	                return !util.global.dispatchEvent(domEvent);
	            };
	        } else if (typeof Event === "function") {
	            var event = new Event("CustomEvent");
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = new Event(name.toLowerCase(), {
	                    cancelable: true
	                });
	                domEvent.detail = event;
	                return !util.global.dispatchEvent(domEvent);
	            };
	        } else {
	            var event = document.createEvent("CustomEvent");
	            event.initCustomEvent("testingtheevent", false, true, {});
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = document.createEvent("CustomEvent");
	                domEvent.initCustomEvent(name.toLowerCase(), false, true,
	                    event);
	                return !util.global.dispatchEvent(domEvent);
	            };
	        }
	    } catch (e) {}
	    return function() {
	        return false;
	    };
	})();
	
	var fireGlobalEvent = (function() {
	    if (util.isNode) {
	        return function() {
	            return process.emit.apply(process, arguments);
	        };
	    } else {
	        if (!util.global) {
	            return function() {
	                return false;
	            };
	        }
	        return function(name) {
	            var methodName = "on" + name.toLowerCase();
	            var method = util.global[methodName];
	            if (!method) return false;
	            method.apply(util.global, [].slice.call(arguments, 1));
	            return true;
	        };
	    }
	})();
	
	function generatePromiseLifecycleEventObject(name, promise) {
	    return {promise: promise};
	}
	
	var eventToObjectGenerator = {
	    promiseCreated: generatePromiseLifecycleEventObject,
	    promiseFulfilled: generatePromiseLifecycleEventObject,
	    promiseRejected: generatePromiseLifecycleEventObject,
	    promiseResolved: generatePromiseLifecycleEventObject,
	    promiseCancelled: generatePromiseLifecycleEventObject,
	    promiseChained: function(name, promise, child) {
	        return {promise: promise, child: child};
	    },
	    warning: function(name, warning) {
	        return {warning: warning};
	    },
	    unhandledRejection: function (name, reason, promise) {
	        return {reason: reason, promise: promise};
	    },
	    rejectionHandled: generatePromiseLifecycleEventObject
	};
	
	var activeFireEvent = function (name) {
	    var globalEventFired = false;
	    try {
	        globalEventFired = fireGlobalEvent.apply(null, arguments);
	    } catch (e) {
	        async.throwLater(e);
	        globalEventFired = true;
	    }
	
	    var domEventFired = false;
	    try {
	        domEventFired = fireDomEvent(name,
	                    eventToObjectGenerator[name].apply(null, arguments));
	    } catch (e) {
	        async.throwLater(e);
	        domEventFired = true;
	    }
	
	    return domEventFired || globalEventFired;
	};
	
	Promise.config = function(opts) {
	    opts = Object(opts);
	    if ("longStackTraces" in opts) {
	        if (opts.longStackTraces) {
	            Promise.longStackTraces();
	        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
	            disableLongStackTraces();
	        }
	    }
	    if ("warnings" in opts) {
	        var warningsOption = opts.warnings;
	        config.warnings = !!warningsOption;
	        wForgottenReturn = config.warnings;
	
	        if (util.isObject(warningsOption)) {
	            if ("wForgottenReturn" in warningsOption) {
	                wForgottenReturn = !!warningsOption.wForgottenReturn;
	            }
	        }
	    }
	    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
	        if (async.haveItemsQueued()) {
	            throw new Error(
	                "cannot enable cancellation after promises are in use");
	        }
	        Promise.prototype._clearCancellationData =
	            cancellationClearCancellationData;
	        Promise.prototype._propagateFrom = cancellationPropagateFrom;
	        Promise.prototype._onCancel = cancellationOnCancel;
	        Promise.prototype._setOnCancel = cancellationSetOnCancel;
	        Promise.prototype._attachCancellationCallback =
	            cancellationAttachCancellationCallback;
	        Promise.prototype._execute = cancellationExecute;
	        propagateFromFunction = cancellationPropagateFrom;
	        config.cancellation = true;
	    }
	    if ("monitoring" in opts) {
	        if (opts.monitoring && !config.monitoring) {
	            config.monitoring = true;
	            Promise.prototype._fireEvent = activeFireEvent;
	        } else if (!opts.monitoring && config.monitoring) {
	            config.monitoring = false;
	            Promise.prototype._fireEvent = defaultFireEvent;
	        }
	    }
	    return Promise;
	};
	
	function defaultFireEvent() { return false; }
	
	Promise.prototype._fireEvent = defaultFireEvent;
	Promise.prototype._execute = function(executor, resolve, reject) {
	    try {
	        executor(resolve, reject);
	    } catch (e) {
	        return e;
	    }
	};
	Promise.prototype._onCancel = function () {};
	Promise.prototype._setOnCancel = function (handler) { ; };
	Promise.prototype._attachCancellationCallback = function(onCancel) {
	    ;
	};
	Promise.prototype._captureStackTrace = function () {};
	Promise.prototype._attachExtraTrace = function () {};
	Promise.prototype._clearCancellationData = function() {};
	Promise.prototype._propagateFrom = function (parent, flags) {
	    ;
	    ;
	};
	
	function cancellationExecute(executor, resolve, reject) {
	    var promise = this;
	    try {
	        executor(resolve, reject, function(onCancel) {
	            if (typeof onCancel !== "function") {
	                throw new TypeError("onCancel must be a function, got: " +
	                                    util.toString(onCancel));
	            }
	            promise._attachCancellationCallback(onCancel);
	        });
	    } catch (e) {
	        return e;
	    }
	}
	
	function cancellationAttachCancellationCallback(onCancel) {
	    if (!this._isCancellable()) return this;
	
	    var previousOnCancel = this._onCancel();
	    if (previousOnCancel !== undefined) {
	        if (util.isArray(previousOnCancel)) {
	            previousOnCancel.push(onCancel);
	        } else {
	            this._setOnCancel([previousOnCancel, onCancel]);
	        }
	    } else {
	        this._setOnCancel(onCancel);
	    }
	}
	
	function cancellationOnCancel() {
	    return this._onCancelField;
	}
	
	function cancellationSetOnCancel(onCancel) {
	    this._onCancelField = onCancel;
	}
	
	function cancellationClearCancellationData() {
	    this._cancellationParent = undefined;
	    this._onCancelField = undefined;
	}
	
	function cancellationPropagateFrom(parent, flags) {
	    if ((flags & 1) !== 0) {
	        this._cancellationParent = parent;
	        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
	        if (branchesRemainingToCancel === undefined) {
	            branchesRemainingToCancel = 0;
	        }
	        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
	    }
	    if ((flags & 2) !== 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	}
	
	function bindingPropagateFrom(parent, flags) {
	    if ((flags & 2) !== 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	}
	var propagateFromFunction = bindingPropagateFrom;
	
	function boundValueFunction() {
	    var ret = this._boundTo;
	    if (ret !== undefined) {
	        if (ret instanceof Promise) {
	            if (ret.isFulfilled()) {
	                return ret.value();
	            } else {
	                return undefined;
	            }
	        }
	    }
	    return ret;
	}
	
	function longStackTracesCaptureStackTrace() {
	    this._trace = new CapturedTrace(this._peekContext());
	}
	
	function longStackTracesAttachExtraTrace(error, ignoreSelf) {
	    if (canAttachTrace(error)) {
	        var trace = this._trace;
	        if (trace !== undefined) {
	            if (ignoreSelf) trace = trace._parent;
	        }
	        if (trace !== undefined) {
	            trace.attachExtraTrace(error);
	        } else if (!error.__stackCleaned__) {
	            var parsed = parseStackAndMessage(error);
	            util.notEnumerableProp(error, "stack",
	                parsed.message + "\n" + parsed.stack.join("\n"));
	            util.notEnumerableProp(error, "__stackCleaned__", true);
	        }
	    }
	}
	
	function checkForgottenReturns(returnValue, promiseCreated, name, promise,
	                               parent) {
	    if (returnValue === undefined && promiseCreated !== null &&
	        wForgottenReturn) {
	        if (parent !== undefined && parent._returnedNonUndefined()) return;
	        if ((promise._bitField & 65535) === 0) return;
	
	        if (name) name = name + " ";
	        var handlerLine = "";
	        var creatorLine = "";
	        if (promiseCreated._trace) {
	            var traceLines = promiseCreated._trace.stack.split("\n");
	            var stack = cleanStack(traceLines);
	            for (var i = stack.length - 1; i >= 0; --i) {
	                var line = stack[i];
	                if (!nodeFramePattern.test(line)) {
	                    var lineMatches = line.match(parseLinePattern);
	                    if (lineMatches) {
	                        handlerLine  = "at " + lineMatches[1] +
	                            ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
	                    }
	                    break;
	                }
	            }
	
	            if (stack.length > 0) {
	                var firstUserLine = stack[0];
	                for (var i = 0; i < traceLines.length; ++i) {
	
	                    if (traceLines[i] === firstUserLine) {
	                        if (i > 0) {
	                            creatorLine = "\n" + traceLines[i - 1];
	                        }
	                        break;
	                    }
	                }
	
	            }
	        }
	        var msg = "a promise was created in a " + name +
	            "handler " + handlerLine + "but was not returned from it, " +
	            "see http://goo.gl/rRqMUw" +
	            creatorLine;
	        promise._warn(msg, true, promiseCreated);
	    }
	}
	
	function deprecated(name, replacement) {
	    var message = name +
	        " is deprecated and will be removed in a future version.";
	    if (replacement) message += " Use " + replacement + " instead.";
	    return warn(message);
	}
	
	function warn(message, shouldUseOwnTrace, promise) {
	    if (!config.warnings) return;
	    var warning = new Warning(message);
	    var ctx;
	    if (shouldUseOwnTrace) {
	        promise._attachExtraTrace(warning);
	    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
	        ctx.attachExtraTrace(warning);
	    } else {
	        var parsed = parseStackAndMessage(warning);
	        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
	    }
	
	    if (!activeFireEvent("warning", warning)) {
	        formatAndLogError(warning, "", true);
	    }
	}
	
	function reconstructStack(message, stacks) {
	    for (var i = 0; i < stacks.length - 1; ++i) {
	        stacks[i].push("From previous event:");
	        stacks[i] = stacks[i].join("\n");
	    }
	    if (i < stacks.length) {
	        stacks[i] = stacks[i].join("\n");
	    }
	    return message + "\n" + stacks.join("\n");
	}
	
	function removeDuplicateOrEmptyJumps(stacks) {
	    for (var i = 0; i < stacks.length; ++i) {
	        if (stacks[i].length === 0 ||
	            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
	            stacks.splice(i, 1);
	            i--;
	        }
	    }
	}
	
	function removeCommonRoots(stacks) {
	    var current = stacks[0];
	    for (var i = 1; i < stacks.length; ++i) {
	        var prev = stacks[i];
	        var currentLastIndex = current.length - 1;
	        var currentLastLine = current[currentLastIndex];
	        var commonRootMeetPoint = -1;
	
	        for (var j = prev.length - 1; j >= 0; --j) {
	            if (prev[j] === currentLastLine) {
	                commonRootMeetPoint = j;
	                break;
	            }
	        }
	
	        for (var j = commonRootMeetPoint; j >= 0; --j) {
	            var line = prev[j];
	            if (current[currentLastIndex] === line) {
	                current.pop();
	                currentLastIndex--;
	            } else {
	                break;
	            }
	        }
	        current = prev;
	    }
	}
	
	function cleanStack(stack) {
	    var ret = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        var isTraceLine = "    (No stack trace)" === line ||
	            stackFramePattern.test(line);
	        var isInternalFrame = isTraceLine && shouldIgnore(line);
	        if (isTraceLine && !isInternalFrame) {
	            if (indentStackFrames && line.charAt(0) !== " ") {
	                line = "    " + line;
	            }
	            ret.push(line);
	        }
	    }
	    return ret;
	}
	
	function stackFramesAsArray(error) {
	    var stack = error.stack.replace(/\s+$/g, "").split("\n");
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
	            break;
	        }
	    }
	    if (i > 0 && error.name != "SyntaxError") {
	        stack = stack.slice(i);
	    }
	    return stack;
	}
	
	function parseStackAndMessage(error) {
	    var stack = error.stack;
	    var message = error.toString();
	    stack = typeof stack === "string" && stack.length > 0
	                ? stackFramesAsArray(error) : ["    (No stack trace)"];
	    return {
	        message: message,
	        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
	    };
	}
	
	function formatAndLogError(error, title, isSoft) {
	    if (typeof console !== "undefined") {
	        var message;
	        if (util.isObject(error)) {
	            var stack = error.stack;
	            message = title + formatStack(stack, error);
	        } else {
	            message = title + String(error);
	        }
	        if (typeof printWarning === "function") {
	            printWarning(message, isSoft);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	}
	
	function fireRejectionEvent(name, localHandler, reason, promise) {
	    var localEventFired = false;
	    try {
	        if (typeof localHandler === "function") {
	            localEventFired = true;
	            if (name === "rejectionHandled") {
	                localHandler(promise);
	            } else {
	                localHandler(reason, promise);
	            }
	        }
	    } catch (e) {
	        async.throwLater(e);
	    }
	
	    if (name === "unhandledRejection") {
	        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
	            formatAndLogError(reason, "Unhandled rejection ");
	        }
	    } else {
	        activeFireEvent(name, promise);
	    }
	}
	
	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj && typeof obj.toString === "function"
	            ? obj.toString() : util.toString(obj);
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {
	
	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}
	
	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}
	
	function longStackTracesIsSupported() {
	    return typeof captureStackTrace === "function";
	}
	
	var shouldIgnore = function() { return false; };
	var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
	function parseLineInfo(line) {
	    var matches = line.match(parseLineInfoRegex);
	    if (matches) {
	        return {
	            fileName: matches[1],
	            line: parseInt(matches[2], 10)
	        };
	    }
	}
	
	function setBounds(firstLineError, lastLineError) {
	    if (!longStackTracesIsSupported()) return;
	    var firstStackLines = firstLineError.stack.split("\n");
	    var lastStackLines = lastLineError.stack.split("\n");
	    var firstIndex = -1;
	    var lastIndex = -1;
	    var firstFileName;
	    var lastFileName;
	    for (var i = 0; i < firstStackLines.length; ++i) {
	        var result = parseLineInfo(firstStackLines[i]);
	        if (result) {
	            firstFileName = result.fileName;
	            firstIndex = result.line;
	            break;
	        }
	    }
	    for (var i = 0; i < lastStackLines.length; ++i) {
	        var result = parseLineInfo(lastStackLines[i]);
	        if (result) {
	            lastFileName = result.fileName;
	            lastIndex = result.line;
	            break;
	        }
	    }
	    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
	        firstFileName !== lastFileName || firstIndex >= lastIndex) {
	        return;
	    }
	
	    shouldIgnore = function(line) {
	        if (bluebirdFramePattern.test(line)) return true;
	        var info = parseLineInfo(line);
	        if (info) {
	            if (info.fileName === firstFileName &&
	                (firstIndex <= info.line && info.line <= lastIndex)) {
	                return true;
	            }
	        }
	        return false;
	    };
	}
	
	function CapturedTrace(parent) {
	    this._parent = parent;
	    this._promisesCreated = 0;
	    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
	    captureStackTrace(this, CapturedTrace);
	    if (length > 32) this.uncycle();
	}
	util.inherits(CapturedTrace, Error);
	Context.CapturedTrace = CapturedTrace;
	
	CapturedTrace.prototype.uncycle = function() {
	    var length = this._length;
	    if (length < 2) return;
	    var nodes = [];
	    var stackToIndex = {};
	
	    for (var i = 0, node = this; node !== undefined; ++i) {
	        nodes.push(node);
	        node = node._parent;
	    }
	    length = this._length = i;
	    for (var i = length - 1; i >= 0; --i) {
	        var stack = nodes[i].stack;
	        if (stackToIndex[stack] === undefined) {
	            stackToIndex[stack] = i;
	        }
	    }
	    for (var i = 0; i < length; ++i) {
	        var currentStack = nodes[i].stack;
	        var index = stackToIndex[currentStack];
	        if (index !== undefined && index !== i) {
	            if (index > 0) {
	                nodes[index - 1]._parent = undefined;
	                nodes[index - 1]._length = 1;
	            }
	            nodes[i]._parent = undefined;
	            nodes[i]._length = 1;
	            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
	
	            if (index < length - 1) {
	                cycleEdgeNode._parent = nodes[index + 1];
	                cycleEdgeNode._parent.uncycle();
	                cycleEdgeNode._length =
	                    cycleEdgeNode._parent._length + 1;
	            } else {
	                cycleEdgeNode._parent = undefined;
	                cycleEdgeNode._length = 1;
	            }
	            var currentChildLength = cycleEdgeNode._length + 1;
	            for (var j = i - 2; j >= 0; --j) {
	                nodes[j]._length = currentChildLength;
	                currentChildLength++;
	            }
	            return;
	        }
	    }
	};
	
	CapturedTrace.prototype.attachExtraTrace = function(error) {
	    if (error.__stackCleaned__) return;
	    this.uncycle();
	    var parsed = parseStackAndMessage(error);
	    var message = parsed.message;
	    var stacks = [parsed.stack];
	
	    var trace = this;
	    while (trace !== undefined) {
	        stacks.push(cleanStack(trace.stack.split("\n")));
	        trace = trace._parent;
	    }
	    removeCommonRoots(stacks);
	    removeDuplicateOrEmptyJumps(stacks);
	    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
	    util.notEnumerableProp(error, "__stackCleaned__", true);
	};
	
	var captureStackTrace = (function stackDetection() {
	    var v8stackFramePattern = /^\s*at\s*/;
	    var v8stackFormatter = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if (error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        Error.stackTraceLimit += 6;
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        var captureStackTrace = Error.captureStackTrace;
	
	        shouldIgnore = function(line) {
	            return bluebirdFramePattern.test(line);
	        };
	        return function(receiver, ignoreUntil) {
	            Error.stackTraceLimit += 6;
	            captureStackTrace(receiver, ignoreUntil);
	            Error.stackTraceLimit -= 6;
	        };
	    }
	    var err = new Error();
	
	    if (typeof err.stack === "string" &&
	        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
	        stackFramePattern = /@/;
	        formatStack = v8stackFormatter;
	        indentStackFrames = true;
	        return function captureStackTrace(o) {
	            o.stack = new Error().stack;
	        };
	    }
	
	    var hasStackAfterThrow;
	    try { throw new Error(); }
	    catch(e) {
	        hasStackAfterThrow = ("stack" in e);
	    }
	    if (!("stack" in err) && hasStackAfterThrow &&
	        typeof Error.stackTraceLimit === "number") {
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        return function captureStackTrace(o) {
	            Error.stackTraceLimit += 6;
	            try { throw new Error(); }
	            catch(e) { o.stack = e.stack; }
	            Error.stackTraceLimit -= 6;
	        };
	    }
	
	    formatStack = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if ((typeof error === "object" ||
	            typeof error === "function") &&
	            error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    return null;
	
	})([]);
	
	if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
	    printWarning = function (message) {
	        console.warn(message);
	    };
	    if (util.isNode && process.stderr.isTTY) {
	        printWarning = function(message, isSoft) {
	            var color = isSoft ? "\u001b[33m" : "\u001b[31m";
	            console.warn(color + message + "\u001b[0m\n");
	        };
	    } else if (!util.isNode && typeof (new Error().stack) === "string") {
	        printWarning = function(message, isSoft) {
	            console.warn("%c" + message,
	                        isSoft ? "color: darkorange" : "color: red");
	        };
	    }
	}
	
	var config = {
	    warnings: warnings,
	    longStackTraces: false,
	    cancellation: false,
	    monitoring: false
	};
	
	if (longStackTraces) Promise.longStackTraces();
	
	return {
	    longStackTraces: function() {
	        return config.longStackTraces;
	    },
	    warnings: function() {
	        return config.warnings;
	    },
	    cancellation: function() {
	        return config.cancellation;
	    },
	    monitoring: function() {
	        return config.monitoring;
	    },
	    propagateFromFunction: function() {
	        return propagateFromFunction;
	    },
	    boundValueFunction: function() {
	        return boundValueFunction;
	    },
	    checkForgottenReturns: checkForgottenReturns,
	    setBounds: setBounds,
	    warn: warn,
	    deprecated: deprecated,
	    CapturedTrace: CapturedTrace,
	    fireDomEvent: fireDomEvent,
	    fireGlobalEvent: fireGlobalEvent
	};
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {
	var util = __webpack_require__(122);
	var CancellationError = Promise.CancellationError;
	var errorObj = util.errorObj;
	var catchFilter = __webpack_require__(135)(NEXT_FILTER);
	
	function PassThroughHandlerContext(promise, type, handler) {
	    this.promise = promise;
	    this.type = type;
	    this.handler = handler;
	    this.called = false;
	    this.cancelPromise = null;
	}
	
	PassThroughHandlerContext.prototype.isFinallyHandler = function() {
	    return this.type === 0;
	};
	
	function FinallyHandlerCancelReaction(finallyHandler) {
	    this.finallyHandler = finallyHandler;
	}
	
	FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
	    checkCancel(this.finallyHandler);
	};
	
	function checkCancel(ctx, reason) {
	    if (ctx.cancelPromise != null) {
	        if (arguments.length > 1) {
	            ctx.cancelPromise._reject(reason);
	        } else {
	            ctx.cancelPromise._cancel();
	        }
	        ctx.cancelPromise = null;
	        return true;
	    }
	    return false;
	}
	
	function succeed() {
	    return finallyHandler.call(this, this.promise._target()._settledValue());
	}
	function fail(reason) {
	    if (checkCancel(this, reason)) return;
	    errorObj.e = reason;
	    return errorObj;
	}
	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;
	
	    if (!this.called) {
	        this.called = true;
	        var ret = this.isFinallyHandler()
	            ? handler.call(promise._boundValue())
	            : handler.call(promise._boundValue(), reasonOrValue);
	        if (ret === NEXT_FILTER) {
	            return ret;
	        } else if (ret !== undefined) {
	            promise._setReturnedNonUndefined();
	            var maybePromise = tryConvertToPromise(ret, promise);
	            if (maybePromise instanceof Promise) {
	                if (this.cancelPromise != null) {
	                    if (maybePromise._isCancelled()) {
	                        var reason =
	                            new CancellationError("late cancellation observer");
	                        promise._attachExtraTrace(reason);
	                        errorObj.e = reason;
	                        return errorObj;
	                    } else if (maybePromise.isPending()) {
	                        maybePromise._attachCancellationCallback(
	                            new FinallyHandlerCancelReaction(this));
	                    }
	                }
	                return maybePromise._then(
	                    succeed, fail, undefined, this, undefined);
	            }
	        }
	    }
	
	    if (promise.isRejected()) {
	        checkCancel(this);
	        errorObj.e = reasonOrValue;
	        return errorObj;
	    } else {
	        checkCancel(this);
	        return reasonOrValue;
	    }
	}
	
	Promise.prototype._passThrough = function(handler, type, success, fail) {
	    if (typeof handler !== "function") return this.then();
	    return this._then(success,
	                      fail,
	                      undefined,
	                      new PassThroughHandlerContext(this, type, handler),
	                      undefined);
	};
	
	Promise.prototype.lastly =
	Promise.prototype["finally"] = function (handler) {
	    return this._passThrough(handler,
	                             0,
	                             finallyHandler,
	                             finallyHandler);
	};
	
	
	Promise.prototype.tap = function (handler) {
	    return this._passThrough(handler, 1, finallyHandler);
	};
	
	Promise.prototype.tapCatch = function (handlerOrPredicate) {
	    var len = arguments.length;
	    if(len === 1) {
	        return this._passThrough(handlerOrPredicate,
	                                 1,
	                                 undefined,
	                                 finallyHandler);
	    } else {
	         var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (util.isObject(item)) {
	                catchInstances[j++] = item;
	            } else {
	                return Promise.reject(new TypeError(
	                    "tapCatch statement predicate: "
	                    + "expecting an object but got " + util.classString(item)
	                ));
	            }
	        }
	        catchInstances.length = j;
	        var handler = arguments[i];
	        return this._passThrough(catchFilter(catchInstances, handler, this),
	                                 1,
	                                 undefined,
	                                 finallyHandler);
	    }
	
	};
	
	return PassThroughHandlerContext;
	};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = __webpack_require__(122);
	var getKeys = __webpack_require__(123).keys;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	function catchFilter(instances, cb, promise) {
	    return function(e) {
	        var boundTo = promise._boundValue();
	        predicateLoop: for (var i = 0; i < instances.length; ++i) {
	            var item = instances[i];
	
	            if (item === Error ||
	                (item != null && item.prototype instanceof Error)) {
	                if (e instanceof item) {
	                    return tryCatch(cb).call(boundTo, e);
	                }
	            } else if (typeof item === "function") {
	                var matchesPredicate = tryCatch(item).call(boundTo, e);
	                if (matchesPredicate === errorObj) {
	                    return matchesPredicate;
	                } else if (matchesPredicate) {
	                    return tryCatch(cb).call(boundTo, e);
	                }
	            } else if (util.isObject(e)) {
	                var keys = getKeys(item);
	                for (var j = 0; j < keys.length; ++j) {
	                    var key = keys[j];
	                    if (item[key] != e[key]) {
	                        continue predicateLoop;
	                    }
	                }
	                return tryCatch(cb).call(boundTo, e);
	            }
	        }
	        return NEXT_FILTER;
	    };
	}
	
	return catchFilter;
	};


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var util = __webpack_require__(122);
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = __webpack_require__(129);
	var OperationalError = errors.OperationalError;
	var es5 = __webpack_require__(123);
	
	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}
	
	var rErrorKey = /^(?:name|message|stack|cause)$/;
	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	        ret.name = obj.name;
	        ret.message = obj.message;
	        ret.stack = obj.stack;
	        var keys = es5.keys(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!rErrorKey.test(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    util.markAsOriginatingFromRejection(obj);
	    return obj;
	}
	
	function nodebackForPromise(promise, multiArgs) {
	    return function(err, value) {
	        if (promise === null) return;
	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (!multiArgs) {
	            promise._fulfill(value);
	        } else {
	            var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};
	            promise._fulfill(args);
	        }
	        promise = null;
	    };
	}
	
	module.exports = nodebackForPromise;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports =
	function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
	var util = __webpack_require__(122);
	var tryCatch = util.tryCatch;
	
	Promise.method = function (fn) {
	    if (typeof fn !== "function") {
	        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
	    }
	    return function () {
	        var ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._pushContext();
	        var value = tryCatch(fn).apply(this, arguments);
	        var promiseCreated = ret._popContext();
	        debug.checkForgottenReturns(
	            value, promiseCreated, "Promise.method", ret);
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};
	
	Promise.attempt = Promise["try"] = function (fn) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._pushContext();
	    var value;
	    if (arguments.length > 1) {
	        debug.deprecated("calling Promise.try with more than 1 argument");
	        var arg = arguments[1];
	        var ctx = arguments[2];
	        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
	                                  : tryCatch(fn).call(ctx, arg);
	    } else {
	        value = tryCatch(fn)();
	    }
	    var promiseCreated = ret._popContext();
	    debug.checkForgottenReturns(
	        value, promiseCreated, "Promise.try", ret);
	    ret._resolveFromSyncValue(value);
	    return ret;
	};
	
	Promise.prototype._resolveFromSyncValue = function (value) {
	    if (value === util.errorObj) {
	        this._rejectCallback(value.e, false);
	    } else {
	        this._resolveCallback(value, true);
	    }
	};
	};


/***/ }),
/* 138 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
	var calledBind = false;
	var rejectThis = function(_, e) {
	    this._reject(e);
	};
	
	var targetRejected = function(e, context) {
	    context.promiseRejectionQueued = true;
	    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
	};
	
	var bindingResolved = function(thisArg, context) {
	    if (((this._bitField & 50397184) === 0)) {
	        this._resolveCallback(context.target);
	    }
	};
	
	var bindingRejected = function(e, context) {
	    if (!context.promiseRejectionQueued) this._reject(e);
	};
	
	Promise.prototype.bind = function (thisArg) {
	    if (!calledBind) {
	        calledBind = true;
	        Promise.prototype._propagateFrom = debug.propagateFromFunction();
	        Promise.prototype._boundValue = debug.boundValueFunction();
	    }
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 1);
	    var target = this._target();
	    ret._setBoundTo(maybePromise);
	    if (maybePromise instanceof Promise) {
	        var context = {
	            promiseRejectionQueued: false,
	            promise: ret,
	            target: target,
	            bindingPromise: maybePromise
	        };
	        target._then(INTERNAL, targetRejected, undefined, ret, context);
	        maybePromise._then(
	            bindingResolved, bindingRejected, undefined, ret, context);
	        ret._setOnCancel(maybePromise);
	    } else {
	        ret._resolveCallback(target);
	    }
	    return ret;
	};
	
	Promise.prototype._setBoundTo = function (obj) {
	    if (obj !== undefined) {
	        this._bitField = this._bitField | 2097152;
	        this._boundTo = obj;
	    } else {
	        this._bitField = this._bitField & (~2097152);
	    }
	};
	
	Promise.prototype._isBound = function () {
	    return (this._bitField & 2097152) === 2097152;
	};
	
	Promise.bind = function (thisArg, value) {
	    return Promise.resolve(value).bind(thisArg);
	};
	};


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, PromiseArray, apiRejection, debug) {
	var util = __webpack_require__(122);
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var async = Promise._async;
	
	Promise.prototype["break"] = Promise.prototype.cancel = function() {
	    if (!debug.cancellation()) return this._warn("cancellation is disabled");
	
	    var promise = this;
	    var child = promise;
	    while (promise._isCancellable()) {
	        if (!promise._cancelBy(child)) {
	            if (child._isFollowing()) {
	                child._followee().cancel();
	            } else {
	                child._cancelBranched();
	            }
	            break;
	        }
	
	        var parent = promise._cancellationParent;
	        if (parent == null || !parent._isCancellable()) {
	            if (promise._isFollowing()) {
	                promise._followee().cancel();
	            } else {
	                promise._cancelBranched();
	            }
	            break;
	        } else {
	            if (promise._isFollowing()) promise._followee().cancel();
	            promise._setWillBeCancelled();
	            child = promise;
	            promise = parent;
	        }
	    }
	};
	
	Promise.prototype._branchHasCancelled = function() {
	    this._branchesRemainingToCancel--;
	};
	
	Promise.prototype._enoughBranchesHaveCancelled = function() {
	    return this._branchesRemainingToCancel === undefined ||
	           this._branchesRemainingToCancel <= 0;
	};
	
	Promise.prototype._cancelBy = function(canceller) {
	    if (canceller === this) {
	        this._branchesRemainingToCancel = 0;
	        this._invokeOnCancel();
	        return true;
	    } else {
	        this._branchHasCancelled();
	        if (this._enoughBranchesHaveCancelled()) {
	            this._invokeOnCancel();
	            return true;
	        }
	    }
	    return false;
	};
	
	Promise.prototype._cancelBranched = function() {
	    if (this._enoughBranchesHaveCancelled()) {
	        this._cancel();
	    }
	};
	
	Promise.prototype._cancel = function() {
	    if (!this._isCancellable()) return;
	    this._setCancelled();
	    async.invoke(this._cancelPromises, this, undefined);
	};
	
	Promise.prototype._cancelPromises = function() {
	    if (this._length() > 0) this._settlePromises();
	};
	
	Promise.prototype._unsetOnCancel = function() {
	    this._onCancelField = undefined;
	};
	
	Promise.prototype._isCancellable = function() {
	    return this.isPending() && !this._isCancelled();
	};
	
	Promise.prototype.isCancellable = function() {
	    return this.isPending() && !this.isCancelled();
	};
	
	Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
	    if (util.isArray(onCancelCallback)) {
	        for (var i = 0; i < onCancelCallback.length; ++i) {
	            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
	        }
	    } else if (onCancelCallback !== undefined) {
	        if (typeof onCancelCallback === "function") {
	            if (!internalOnly) {
	                var e = tryCatch(onCancelCallback).call(this._boundValue());
	                if (e === errorObj) {
	                    this._attachExtraTrace(e.e);
	                    async.throwLater(e.e);
	                }
	            }
	        } else {
	            onCancelCallback._resultCancelled(this);
	        }
	    }
	};
	
	Promise.prototype._invokeOnCancel = function() {
	    var onCancelCallback = this._onCancel();
	    this._unsetOnCancel();
	    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
	};
	
	Promise.prototype._invokeInternalOnCancel = function() {
	    if (this._isCancellable()) {
	        this._doInvokeOnCancel(this._onCancel(), true);
	        this._unsetOnCancel();
	    }
	};
	
	Promise.prototype._resultCancelled = function() {
	    this.cancel();
	};
	
	};


/***/ }),
/* 140 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = function(Promise) {
	function returner() {
	    return this.value;
	}
	function thrower() {
	    throw this.reason;
	}
	
	Promise.prototype["return"] =
	Promise.prototype.thenReturn = function (value) {
	    if (value instanceof Promise) value.suppressUnhandledRejections();
	    return this._then(
	        returner, undefined, undefined, {value: value}, undefined);
	};
	
	Promise.prototype["throw"] =
	Promise.prototype.thenThrow = function (reason) {
	    return this._then(
	        thrower, undefined, undefined, {reason: reason}, undefined);
	};
	
	Promise.prototype.catchThrow = function (reason) {
	    if (arguments.length <= 1) {
	        return this._then(
	            undefined, thrower, undefined, {reason: reason}, undefined);
	    } else {
	        var _reason = arguments[1];
	        var handler = function() {throw _reason;};
	        return this.caught(reason, handler);
	    }
	};
	
	Promise.prototype.catchReturn = function (value) {
	    if (arguments.length <= 1) {
	        if (value instanceof Promise) value.suppressUnhandledRejections();
	        return this._then(
	            undefined, returner, undefined, {value: value}, undefined);
	    } else {
	        var _value = arguments[1];
	        if (_value instanceof Promise) _value.suppressUnhandledRejections();
	        var handler = function() {return _value;};
	        return this.caught(value, handler);
	    }
	};
	};


/***/ }),
/* 141 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== undefined) {
	        promise = promise._target();
	        this._bitField = promise._bitField;
	        this._settledValueField = promise._isFateSealed()
	            ? promise._settledValue() : undefined;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValueField = undefined;
	    }
	}
	
	PromiseInspection.prototype._settledValue = function() {
	    return this._settledValueField;
	};
	
	var value = PromiseInspection.prototype.value = function () {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    return this._settledValue();
	};
	
	var reason = PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason = function () {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    return this._settledValue();
	};
	
	var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
	    return (this._bitField & 33554432) !== 0;
	};
	
	var isRejected = PromiseInspection.prototype.isRejected = function () {
	    return (this._bitField & 16777216) !== 0;
	};
	
	var isPending = PromiseInspection.prototype.isPending = function () {
	    return (this._bitField & 50397184) === 0;
	};
	
	var isResolved = PromiseInspection.prototype.isResolved = function () {
	    return (this._bitField & 50331648) !== 0;
	};
	
	PromiseInspection.prototype.isCancelled = function() {
	    return (this._bitField & 8454144) !== 0;
	};
	
	Promise.prototype.__isCancelled = function() {
	    return (this._bitField & 65536) === 65536;
	};
	
	Promise.prototype._isCancelled = function() {
	    return this._target().__isCancelled();
	};
	
	Promise.prototype.isCancelled = function() {
	    return (this._target()._bitField & 8454144) !== 0;
	};
	
	Promise.prototype.isPending = function() {
	    return isPending.call(this._target());
	};
	
	Promise.prototype.isRejected = function() {
	    return isRejected.call(this._target());
	};
	
	Promise.prototype.isFulfilled = function() {
	    return isFulfilled.call(this._target());
	};
	
	Promise.prototype.isResolved = function() {
	    return isResolved.call(this._target());
	};
	
	Promise.prototype.value = function() {
	    return value.call(this._target());
	};
	
	Promise.prototype.reason = function() {
	    var target = this._target();
	    target._unsetRejectionIsUnhandled();
	    return reason.call(target);
	};
	
	Promise.prototype._value = function() {
	    return this._settledValue();
	};
	
	Promise.prototype._reason = function() {
	    this._unsetRejectionIsUnhandled();
	    return this._settledValue();
	};
	
	Promise.PromiseInspection = PromiseInspection;
	};


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports =
	function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,
	         getDomain) {
	var util = __webpack_require__(122);
	var canEvaluate = util.canEvaluate;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var reject;
	
	if (true) {
	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };
	
	    var promiseSetter = function(i) {
	        return new Function("promise", "holder", "                           \n\
	            'use strict';                                                    \n\
	            holder.pIndex = promise;                                         \n\
	            ".replace(/Index/g, i));
	    };
	
	    var generateHolderClass = function(total) {
	        var props = new Array(total);
	        for (var i = 0; i < props.length; ++i) {
	            props[i] = "this.p" + (i+1);
	        }
	        var assignment = props.join(" = ") + " = null;";
	        var cancellationCode= "var promise;\n" + props.map(function(prop) {
	            return "                                                         \n\
	                promise = " + prop + ";                                      \n\
	                if (promise instanceof Promise) {                            \n\
	                    promise.cancel();                                        \n\
	                }                                                            \n\
	            ";
	        }).join("\n");
	        var passedArguments = props.join(", ");
	        var name = "Holder$" + total;
	
	
	        var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
	            'use strict';                                                    \n\
	            function [TheName](fn) {                                         \n\
	                [TheProperties]                                              \n\
	                this.fn = fn;                                                \n\
	                this.asyncNeeded = true;                                     \n\
	                this.now = 0;                                                \n\
	            }                                                                \n\
	                                                                             \n\
	            [TheName].prototype._callFunction = function(promise) {          \n\
	                promise._pushContext();                                      \n\
	                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
	                promise._popContext();                                       \n\
	                if (ret === errorObj) {                                      \n\
	                    promise._rejectCallback(ret.e, false);                   \n\
	                } else {                                                     \n\
	                    promise._resolveCallback(ret);                           \n\
	                }                                                            \n\
	            };                                                               \n\
	                                                                             \n\
	            [TheName].prototype.checkFulfillment = function(promise) {       \n\
	                var now = ++this.now;                                        \n\
	                if (now === [TheTotal]) {                                    \n\
	                    if (this.asyncNeeded) {                                  \n\
	                        async.invoke(this._callFunction, this, promise);     \n\
	                    } else {                                                 \n\
	                        this._callFunction(promise);                         \n\
	                    }                                                        \n\
	                                                                             \n\
	                }                                                            \n\
	            };                                                               \n\
	                                                                             \n\
	            [TheName].prototype._resultCancelled = function() {              \n\
	                [CancellationCode]                                           \n\
	            };                                                               \n\
	                                                                             \n\
	            return [TheName];                                                \n\
	        }(tryCatch, errorObj, Promise, async);                               \n\
	        ";
	
	        code = code.replace(/\[TheName\]/g, name)
	            .replace(/\[TheTotal\]/g, total)
	            .replace(/\[ThePassedArguments\]/g, passedArguments)
	            .replace(/\[TheProperties\]/g, assignment)
	            .replace(/\[CancellationCode\]/g, cancellationCode);
	
	        return new Function("tryCatch", "errorObj", "Promise", "async", code)
	                           (tryCatch, errorObj, Promise, async);
	    };
	
	    var holderClasses = [];
	    var thenCallbacks = [];
	    var promiseSetters = [];
	
	    for (var i = 0; i < 8; ++i) {
	        holderClasses.push(generateHolderClass(i + 1));
	        thenCallbacks.push(thenCallback(i + 1));
	        promiseSetters.push(promiseSetter(i + 1));
	    }
	
	    reject = function (reason) {
	        this._reject(reason);
	    };
	}}
	
	Promise.join = function () {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (true) {
	            if (last <= 8 && canEvaluate) {
	                var ret = new Promise(INTERNAL);
	                ret._captureStackTrace();
	                var HolderClass = holderClasses[last - 1];
	                var holder = new HolderClass(fn);
	                var callbacks = thenCallbacks;
	
	                for (var i = 0; i < last; ++i) {
	                    var maybePromise = tryConvertToPromise(arguments[i], ret);
	                    if (maybePromise instanceof Promise) {
	                        maybePromise = maybePromise._target();
	                        var bitField = maybePromise._bitField;
	                        ;
	                        if (((bitField & 50397184) === 0)) {
	                            maybePromise._then(callbacks[i], reject,
	                                               undefined, ret, holder);
	                            promiseSetters[i](maybePromise, holder);
	                            holder.asyncNeeded = false;
	                        } else if (((bitField & 33554432) !== 0)) {
	                            callbacks[i].call(ret,
	                                              maybePromise._value(), holder);
	                        } else if (((bitField & 16777216) !== 0)) {
	                            ret._reject(maybePromise._reason());
	                        } else {
	                            ret._cancel();
	                        }
	                    } else {
	                        callbacks[i].call(ret, maybePromise, holder);
	                    }
	                }
	
	                if (!ret._isFateSealed()) {
	                    if (holder.asyncNeeded) {
	                        var domain = getDomain();
	                        if (domain !== null) {
	                            holder.fn = util.domainBind(domain, holder.fn);
	                        }
	                    }
	                    ret._setAsyncGuaranteed();
	                    ret._setOnCancel(holder);
	                }
	                return ret;
	            }
	        }
	    }
	    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];};
	    if (fn) args.pop();
	    var ret = new PromiseArray(args).promise();
	    return fn !== undefined ? ret.spread(fn) : ret;
	};
	
	};


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL,
	                          debug) {
	var getDomain = Promise._getDomain;
	var util = __webpack_require__(122);
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var async = Promise._async;
	
	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    var domain = getDomain();
	    this._callback = domain === null ? fn : util.domainBind(domain, fn);
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = [];
	    async.invoke(this._asyncInit, this, undefined);
	}
	util.inherits(MappingPromiseArray, PromiseArray);
	
	MappingPromiseArray.prototype._asyncInit = function() {
	    this._init$(undefined, -2);
	};
	
	MappingPromiseArray.prototype._init = function () {};
	
	MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;
	
	    if (index < 0) {
	        index = (index * -1) - 1;
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return true;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return false;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;
	
	        var promise = this._promise;
	        var callback = this._callback;
	        var receiver = promise._boundValue();
	        promise._pushContext();
	        var ret = tryCatch(callback).call(receiver, value, index, length);
	        var promiseCreated = promise._popContext();
	        debug.checkForgottenReturns(
	            ret,
	            promiseCreated,
	            preservedValues !== null ? "Promise.filter" : "Promise.map",
	            promise
	        );
	        if (ret === errorObj) {
	            this._reject(ret.e);
	            return true;
	        }
	
	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            var bitField = maybePromise._bitField;
	            ;
	            if (((bitField & 50397184) === 0)) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = maybePromise;
	                maybePromise._proxy(this, (index + 1) * -1);
	                return false;
	            } else if (((bitField & 33554432) !== 0)) {
	                ret = maybePromise._value();
	            } else if (((bitField & 16777216) !== 0)) {
	                this._reject(maybePromise._reason());
	                return true;
	            } else {
	                this._cancel();
	                return true;
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }
	        return true;
	    }
	    return false;
	};
	
	MappingPromiseArray.prototype._drainQueue = function () {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        if (this._isResolved()) return;
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};
	
	MappingPromiseArray.prototype._filter = function (booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};
	
	MappingPromiseArray.prototype.preservedValues = function () {
	    return this._preservedValues;
	};
	
	function map(promises, fn, options, _filter) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	
	    var limit = 0;
	    if (options !== undefined) {
	        if (typeof options === "object" && options !== null) {
	            if (typeof options.concurrency !== "number") {
	                return Promise.reject(
	                    new TypeError("'concurrency' must be a number but it is " +
	                                    util.classString(options.concurrency)));
	            }
	            limit = options.concurrency;
	        } else {
	            return Promise.reject(new TypeError(
	                            "options argument must be an object but it is " +
	                             util.classString(options)));
	        }
	    }
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter).promise();
	}
	
	Promise.prototype.map = function (fn, options) {
	    return map(this, fn, options, null);
	};
	
	Promise.map = function (promises, fn, options, _filter) {
	    return map(promises, fn, options, _filter);
	};
	
	
	};


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var cr = Object.create;
	if (cr) {
	    var callerCache = cr(null);
	    var getterCache = cr(null);
	    callerCache[" size"] = getterCache[" size"] = 0;
	}
	
	module.exports = function(Promise) {
	var util = __webpack_require__(122);
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;
	
	var getMethodCaller;
	var getGetter;
	if (true) {
	var makeMethodCaller = function (methodName) {
	    return new Function("ensureMethod", "                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g, methodName))(ensureMethod);
	};
	
	var makeGetter = function (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	};
	
	var getCompiled = function(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	};
	
	getMethodCaller = function(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	};
	
	getGetter = function(name) {
	    return getCompiled(name, makeGetter, getterCache);
	};
	}
	
	function ensureMethod(obj, methodName) {
	    var fn;
	    if (obj != null) fn = obj[methodName];
	    if (typeof fn !== "function") {
	        var message = "Object " + util.classString(obj) + " has no method '" +
	            util.toString(methodName) + "'";
	        throw new Promise.TypeError(message);
	    }
	    return fn;
	}
	
	function caller(obj) {
	    var methodName = this.pop();
	    var fn = ensureMethod(obj, methodName);
	    return fn.apply(obj, this);
	}
	Promise.prototype.call = function (methodName) {
	    var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};
	    if (true) {
	        if (canEvaluate) {
	            var maybeCaller = getMethodCaller(methodName);
	            if (maybeCaller !== null) {
	                return this._then(
	                    maybeCaller, undefined, undefined, args, undefined);
	            }
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, undefined, undefined, args, undefined);
	};
	
	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    var index = +this;
	    if (index < 0) index = Math.max(0, index + obj.length);
	    return obj[index];
	}
	Promise.prototype.get = function (propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, undefined, undefined, propertyName, undefined);
	};
	};


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function (Promise, apiRejection, tryConvertToPromise,
	    createContext, INTERNAL, debug) {
	    var util = __webpack_require__(122);
	    var TypeError = __webpack_require__(129).TypeError;
	    var inherits = __webpack_require__(122).inherits;
	    var errorObj = util.errorObj;
	    var tryCatch = util.tryCatch;
	    var NULL = {};
	
	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }
	
	    function castPreservingDisposable(thenable) {
	        var maybePromise = tryConvertToPromise(thenable);
	        if (maybePromise !== thenable &&
	            typeof thenable._isDisposable === "function" &&
	            typeof thenable._getDisposer === "function" &&
	            thenable._isDisposable()) {
	            maybePromise._setDisposable(thenable._getDisposer());
	        }
	        return maybePromise;
	    }
	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = new Promise(INTERNAL);
	        function iterator() {
	            if (i >= len) return ret._fulfill();
	            var maybePromise = castPreservingDisposable(resources[i++]);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = tryConvertToPromise(
	                        maybePromise._getDisposer().tryDispose(inspection),
	                        resources.promise);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret;
	    }
	
	    function Disposer(data, promise, context) {
	        this._data = data;
	        this._promise = promise;
	        this._context = context;
	    }
	
	    Disposer.prototype.data = function () {
	        return this._data;
	    };
	
	    Disposer.prototype.promise = function () {
	        return this._promise;
	    };
	
	    Disposer.prototype.resource = function () {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return NULL;
	    };
	
	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var context = this._context;
	        if (context !== undefined) context._pushContext();
	        var ret = resource !== NULL
	            ? this.doDispose(resource, inspection) : null;
	        if (context !== undefined) context._popContext();
	        this._promise._unsetDisposable();
	        this._data = null;
	        return ret;
	    };
	
	    Disposer.isDisposer = function (d) {
	        return (d != null &&
	                typeof d.resource === "function" &&
	                typeof d.tryDispose === "function");
	    };
	
	    function FunctionDisposer(fn, promise, context) {
	        this.constructor$(fn, promise, context);
	    }
	    inherits(FunctionDisposer, Disposer);
	
	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };
	
	    function maybeUnwrapDisposer(value) {
	        if (Disposer.isDisposer(value)) {
	            this.resources[this.index]._setDisposable(value);
	            return value.promise();
	        }
	        return value;
	    }
	
	    function ResourceList(length) {
	        this.length = length;
	        this.promise = null;
	        this[length-1] = null;
	    }
	
	    ResourceList.prototype._resultCancelled = function() {
	        var len = this.length;
	        for (var i = 0; i < len; ++i) {
	            var item = this[i];
	            if (item instanceof Promise) {
	                item.cancel();
	            }
	        }
	    };
	
	    Promise.using = function () {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") {
	            return apiRejection("expecting a function but got " + util.classString(fn));
	        }
	        var input;
	        var spreadArgs = true;
	        if (len === 2 && Array.isArray(arguments[0])) {
	            input = arguments[0];
	            len = input.length;
	            spreadArgs = false;
	        } else {
	            input = arguments;
	            len--;
	        }
	        var resources = new ResourceList(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = input[i];
	            if (Disposer.isDisposer(resource)) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            } else {
	                var maybePromise = tryConvertToPromise(resource);
	                if (maybePromise instanceof Promise) {
	                    resource =
	                        maybePromise._then(maybeUnwrapDisposer, null, null, {
	                            resources: resources,
	                            index: i
	                    }, undefined);
	                }
	            }
	            resources[i] = resource;
	        }
	
	        var reflectedResources = new Array(resources.length);
	        for (var i = 0; i < reflectedResources.length; ++i) {
	            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
	        }
	
	        var resultPromise = Promise.all(reflectedResources)
	            .then(function(inspections) {
	                for (var i = 0; i < inspections.length; ++i) {
	                    var inspection = inspections[i];
	                    if (inspection.isRejected()) {
	                        errorObj.e = inspection.error();
	                        return errorObj;
	                    } else if (!inspection.isFulfilled()) {
	                        resultPromise.cancel();
	                        return;
	                    }
	                    inspections[i] = inspection.value();
	                }
	                promise._pushContext();
	
	                fn = tryCatch(fn);
	                var ret = spreadArgs
	                    ? fn.apply(undefined, inspections) : fn(inspections);
	                var promiseCreated = promise._popContext();
	                debug.checkForgottenReturns(
	                    ret, promiseCreated, "Promise.using", promise);
	                return ret;
	            });
	
	        var promise = resultPromise.lastly(function() {
	            var inspection = new Promise.PromiseInspection(resultPromise);
	            return dispose(resources, inspection);
	        });
	        resources.promise = promise;
	        promise._setOnCancel(resources);
	        return promise;
	    };
	
	    Promise.prototype._setDisposable = function (disposer) {
	        this._bitField = this._bitField | 131072;
	        this._disposer = disposer;
	    };
	
	    Promise.prototype._isDisposable = function () {
	        return (this._bitField & 131072) > 0;
	    };
	
	    Promise.prototype._getDisposer = function () {
	        return this._disposer;
	    };
	
	    Promise.prototype._unsetDisposable = function () {
	        this._bitField = this._bitField & (~131072);
	        this._disposer = undefined;
	    };
	
	    Promise.prototype.disposer = function (fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this, createContext());
	        }
	        throw new TypeError();
	    };
	
	};


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, INTERNAL, debug) {
	var util = __webpack_require__(122);
	var TimeoutError = Promise.TimeoutError;
	
	function HandleWrapper(handle)  {
	    this.handle = handle;
	}
	
	HandleWrapper.prototype._resultCancelled = function() {
	    clearTimeout(this.handle);
	};
	
	var afterValue = function(value) { return delay(+this).thenReturn(value); };
	var delay = Promise.delay = function (ms, value) {
	    var ret;
	    var handle;
	    if (value !== undefined) {
	        ret = Promise.resolve(value)
	                ._then(afterValue, null, null, ms, undefined);
	        if (debug.cancellation() && value instanceof Promise) {
	            ret._setOnCancel(value);
	        }
	    } else {
	        ret = new Promise(INTERNAL);
	        handle = setTimeout(function() { ret._fulfill(); }, +ms);
	        if (debug.cancellation()) {
	            ret._setOnCancel(new HandleWrapper(handle));
	        }
	        ret._captureStackTrace();
	    }
	    ret._setAsyncGuaranteed();
	    return ret;
	};
	
	Promise.prototype.delay = function (ms) {
	    return delay(ms, this);
	};
	
	var afterTimeout = function (promise, message, parent) {
	    var err;
	    if (typeof message !== "string") {
	        if (message instanceof Error) {
	            err = message;
	        } else {
	            err = new TimeoutError("operation timed out");
	        }
	    } else {
	        err = new TimeoutError(message);
	    }
	    util.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._reject(err);
	
	    if (parent != null) {
	        parent.cancel();
	    }
	};
	
	function successClear(value) {
	    clearTimeout(this.handle);
	    return value;
	}
	
	function failureClear(reason) {
	    clearTimeout(this.handle);
	    throw reason;
	}
	
	Promise.prototype.timeout = function (ms, message) {
	    ms = +ms;
	    var ret, parent;
	
	    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
	        if (ret.isPending()) {
	            afterTimeout(ret, message, parent);
	        }
	    }, ms));
	
	    if (debug.cancellation()) {
	        parent = this.then();
	        ret = parent._then(successClear, failureClear,
	                            undefined, handleWrapper, undefined);
	        ret._setOnCancel(handleWrapper);
	    } else {
	        ret = this._then(successClear, failureClear,
	                            undefined, handleWrapper, undefined);
	    }
	
	    return ret;
	};
	
	};


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise,
	                          apiRejection,
	                          INTERNAL,
	                          tryConvertToPromise,
	                          Proxyable,
	                          debug) {
	var errors = __webpack_require__(129);
	var TypeError = errors.TypeError;
	var util = __webpack_require__(122);
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	var yieldHandlers = [];
	
	function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
	    for (var i = 0; i < yieldHandlers.length; ++i) {
	        traceParent._pushContext();
	        var result = tryCatch(yieldHandlers[i])(value);
	        traceParent._popContext();
	        if (result === errorObj) {
	            traceParent._pushContext();
	            var ret = Promise.reject(errorObj.e);
	            traceParent._popContext();
	            return ret;
	        }
	        var maybePromise = tryConvertToPromise(result, traceParent);
	        if (maybePromise instanceof Promise) return maybePromise;
	    }
	    return null;
	}
	
	function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
	    if (debug.cancellation()) {
	        var internal = new Promise(INTERNAL);
	        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
	        this._promise = internal.lastly(function() {
	            return _finallyPromise;
	        });
	        internal._captureStackTrace();
	        internal._setOnCancel(this);
	    } else {
	        var promise = this._promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	    }
	    this._stack = stack;
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = undefined;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	    this._yieldedPromise = null;
	    this._cancellationPhase = false;
	}
	util.inherits(PromiseSpawn, Proxyable);
	
	PromiseSpawn.prototype._isResolved = function() {
	    return this._promise === null;
	};
	
	PromiseSpawn.prototype._cleanup = function() {
	    this._promise = this._generator = null;
	    if (debug.cancellation() && this._finallyPromise !== null) {
	        this._finallyPromise._fulfill();
	        this._finallyPromise = null;
	    }
	};
	
	PromiseSpawn.prototype._promiseCancelled = function() {
	    if (this._isResolved()) return;
	    var implementsReturn = typeof this._generator["return"] !== "undefined";
	
	    var result;
	    if (!implementsReturn) {
	        var reason = new Promise.CancellationError(
	            "generator .return() sentinel");
	        Promise.coroutine.returnSentinel = reason;
	        this._promise._attachExtraTrace(reason);
	        this._promise._pushContext();
	        result = tryCatch(this._generator["throw"]).call(this._generator,
	                                                         reason);
	        this._promise._popContext();
	    } else {
	        this._promise._pushContext();
	        result = tryCatch(this._generator["return"]).call(this._generator,
	                                                          undefined);
	        this._promise._popContext();
	    }
	    this._cancellationPhase = true;
	    this._yieldedPromise = null;
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._promiseFulfilled = function(value) {
	    this._yieldedPromise = null;
	    this._promise._pushContext();
	    var result = tryCatch(this._generator.next).call(this._generator, value);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._promiseRejected = function(reason) {
	    this._yieldedPromise = null;
	    this._promise._attachExtraTrace(reason);
	    this._promise._pushContext();
	    var result = tryCatch(this._generator["throw"])
	        .call(this._generator, reason);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._resultCancelled = function() {
	    if (this._yieldedPromise instanceof Promise) {
	        var promise = this._yieldedPromise;
	        this._yieldedPromise = null;
	        promise.cancel();
	    }
	};
	
	PromiseSpawn.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseSpawn.prototype._run = function () {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = undefined;
	    this._promiseFulfilled(undefined);
	};
	
	PromiseSpawn.prototype._continue = function (result) {
	    var promise = this._promise;
	    if (result === errorObj) {
	        this._cleanup();
	        if (this._cancellationPhase) {
	            return promise.cancel();
	        } else {
	            return promise._rejectCallback(result.e, false);
	        }
	    }
	
	    var value = result.value;
	    if (result.done === true) {
	        this._cleanup();
	        if (this._cancellationPhase) {
	            return promise.cancel();
	        } else {
	            return promise._resolveCallback(value);
	        }
	    } else {
	        var maybePromise = tryConvertToPromise(value, this._promise);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise,
	                                        this._yieldHandlers,
	                                        this._promise);
	            if (maybePromise === null) {
	                this._promiseRejected(
	                    new TypeError(
	                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", String(value)) +
	                        "From coroutine:\u000a" +
	                        this._stack.split("\n").slice(1, -7).join("\n")
	                    )
	                );
	                return;
	            }
	        }
	        maybePromise = maybePromise._target();
	        var bitField = maybePromise._bitField;
	        ;
	        if (((bitField & 50397184) === 0)) {
	            this._yieldedPromise = maybePromise;
	            maybePromise._proxy(this, null);
	        } else if (((bitField & 33554432) !== 0)) {
	            Promise._async.invoke(
	                this._promiseFulfilled, this, maybePromise._value()
	            );
	        } else if (((bitField & 16777216) !== 0)) {
	            Promise._async.invoke(
	                this._promiseRejected, this, maybePromise._reason()
	            );
	        } else {
	            this._promiseCancelled();
	        }
	    }
	};
	
	Promise.coroutine = function (generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    var stack = new Error().stack;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
	                                      stack);
	        var ret = spawn.promise();
	        spawn._generator = generator;
	        spawn._promiseFulfilled(undefined);
	        return ret;
	    };
	};
	
	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    yieldHandlers.push(fn);
	};
	
	Promise.spawn = function (generatorFunction) {
	    debug.deprecated("Promise.spawn()", "Promise.coroutine()");
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise) {
	var util = __webpack_require__(122);
	var async = Promise._async;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	function spreadAdapter(val, nodeback) {
	    var promise = this;
	    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
	    var ret =
	        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	function successAdapter(val, nodeback) {
	    var promise = this;
	    var receiver = promise._boundValue();
	    var ret = val === undefined
	        ? tryCatch(nodeback).call(receiver, null)
	        : tryCatch(nodeback).call(receiver, null, val);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	function errorAdapter(reason, nodeback) {
	    var promise = this;
	    if (!reason) {
	        var newReason = new Error(reason + "");
	        newReason.cause = reason;
	        reason = newReason;
	    }
	    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,
	                                                                     options) {
	    if (typeof nodeback == "function") {
	        var adapter = successAdapter;
	        if (options !== undefined && Object(options).spread) {
	            adapter = spreadAdapter;
	        }
	        this._then(
	            adapter,
	            errorAdapter,
	            undefined,
	            this,
	            nodeback
	        );
	    }
	    return this;
	};
	};


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = __webpack_require__(122);
	var nodebackForPromise = __webpack_require__(136);
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = __webpack_require__(129).TypeError;
	var defaultSuffix = "Async";
	var defaultPromisified = {__isPromisified__: true};
	var noCopyProps = [
	    "arity",    "length",
	    "name",
	    "arguments",
	    "caller",
	    "callee",
	    "prototype",
	    "__isPromisified__"
	];
	var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
	
	var defaultFilter = function(name) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        name !== "constructor";
	};
	
	function propsFilter(key) {
	    return !noCopyPropsPattern.test(key);
	}
	
	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}
	
	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a"
	                        .replace("%s", suffix));
	                }
	            }
	        }
	    }
	}
	
	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        var passesDefaultFilter = filter === defaultFilter
	            ? true : defaultFilter(key, value, obj);
	        if (typeof value === "function" &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj, passesDefaultFilter)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}
	
	var escapeIdentRegex = function(str) {
	    return str.replace(/([$])/, "\\$");
	};
	
	var makeNodePromisifiedEval;
	if (true) {
	var switchCaseArgumentOrder = function(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 3);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
	        ret.push(i);
	    }
	    return ret;
	};
	
	var argumentSequence = function(argumentCount) {
	    return util.filledRange(argumentCount, "_arg", "");
	};
	
	var parameterDeclaration = function(parameterCount) {
	    return util.filledRange(
	        Math.max(parameterCount, 3), "_arg", "");
	};
	
	var parameterCount = function(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	};
	
	makeNodePromisifiedEval =
	function(callback, receiver, originalName, fn, _, multiArgs) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var shouldProxyThis = typeof callback === "string" || receiver === THIS;
	
	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (shouldProxyThis) {
	            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
	        } else {
	            ret = receiver === undefined
	                ? "ret = callback({{args}}, nodeback); break;\n"
	                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
	        }
	        return ret.replace("{{args}}", args).replace(", ", comma);
	    }
	
	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for (var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }
	
	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", (shouldProxyThis
	                                ? "ret = callback.apply(this, args);\n"
	                                : "ret = callback.apply(receiver, args);\n"));
	        return ret;
	    }
	
	    var getFunctionCode = typeof callback === "string"
	                                ? ("this != null ? this['"+callback+"'] : fn")
	                                : "fn";
	    var body = "'use strict';                                                \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
	        return ret;                                                          \n\
	    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
	        .replace("[GetFunctionCode]", getFunctionCode);
	    body = body.replace("Parameters", parameterDeclaration(newParameterCount));
	    return new Function("Promise",
	                        "fn",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "tryCatch",
	                        "errorObj",
	                        "notEnumerableProp",
	                        "INTERNAL",
	                        body)(
	                    Promise,
	                    fn,
	                    receiver,
	                    withAppended,
	                    maybeWrapAsError,
	                    nodebackForPromise,
	                    util.tryCatch,
	                    util.errorObj,
	                    util.notEnumerableProp,
	                    INTERNAL);
	};
	}
	
	function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
	    var defaultThis = (function() {return this;})();
	    var method = callback;
	    if (typeof method === "string") {
	        callback = fn;
	    }
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        var promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	        var cb = typeof method === "string" && this !== defaultThis
	            ? this[method] : callback;
	        var fn = nodebackForPromise(promise, multiArgs);
	        try {
	            cb.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            promise._rejectCallback(maybeWrapAsError(e), true, true);
	        }
	        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
	        return promise;
	    }
	    util.notEnumerableProp(promisified, "__isPromisified__", true);
	    return promisified;
	}
	
	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;
	
	function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);
	
	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        if (promisifier === makeNodePromisified) {
	            obj[promisifiedKey] =
	                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
	        } else {
	            var promisified = promisifier(fn, function() {
	                return makeNodePromisified(key, THIS, key,
	                                           fn, suffix, multiArgs);
	            });
	            util.notEnumerableProp(promisified, "__isPromisified__", true);
	            obj[promisifiedKey] = promisified;
	        }
	    }
	    util.toFastProperties(obj);
	    return obj;
	}
	
	function promisify(callback, receiver, multiArgs) {
	    return makeNodePromisified(callback, receiver, undefined,
	                                callback, null, multiArgs);
	}
	
	Promise.promisify = function (fn, options) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    options = Object(options);
	    var receiver = options.context === undefined ? THIS : options.context;
	    var multiArgs = !!options.multiArgs;
	    var ret = promisify(fn, receiver, multiArgs);
	    util.copyDescriptors(fn, ret, propsFilter);
	    return ret;
	};
	
	Promise.promisifyAll = function (target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    options = Object(options);
	    var multiArgs = !!options.multiArgs;
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;
	
	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	
	    var keys = util.inheritedDataKeys(target);
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier,
	                multiArgs);
	            promisifyAll(value, suffix, filter, promisifier, multiArgs);
	        }
	    }
	
	    return promisifyAll(target, suffix, filter, promisifier, multiArgs);
	};
	};
	


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(
	    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
	var util = __webpack_require__(122);
	var isObject = util.isObject;
	var es5 = __webpack_require__(123);
	var Es6Map;
	if (typeof Map === "function") Es6Map = Map;
	
	var mapToEntries = (function() {
	    var index = 0;
	    var size = 0;
	
	    function extractEntry(value, key) {
	        this[index] = value;
	        this[index + size] = key;
	        index++;
	    }
	
	    return function mapToEntries(map) {
	        size = map.size;
	        index = 0;
	        var ret = new Array(map.size * 2);
	        map.forEach(extractEntry, ret);
	        return ret;
	    };
	})();
	
	var entriesToMap = function(entries) {
	    var ret = new Es6Map();
	    var length = entries.length / 2 | 0;
	    for (var i = 0; i < length; ++i) {
	        var key = entries[length + i];
	        var value = entries[i];
	        ret.set(key, value);
	    }
	    return ret;
	};
	
	function PropertiesPromiseArray(obj) {
	    var isMap = false;
	    var entries;
	    if (Es6Map !== undefined && obj instanceof Es6Map) {
	        entries = mapToEntries(obj);
	        isMap = true;
	    } else {
	        var keys = es5.keys(obj);
	        var len = keys.length;
	        entries = new Array(len * 2);
	        for (var i = 0; i < len; ++i) {
	            var key = keys[i];
	            entries[i] = obj[key];
	            entries[i + len] = key;
	        }
	    }
	    this.constructor$(entries);
	    this._isMap = isMap;
	    this._init$(undefined, isMap ? -6 : -3);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);
	
	PropertiesPromiseArray.prototype._init = function () {};
	
	PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val;
	        if (this._isMap) {
	            val = entriesToMap(this._values);
	        } else {
	            val = {};
	            var keyOffset = this.length();
	            for (var i = 0, len = this.length(); i < len; ++i) {
	                val[this._values[i + keyOffset]] = this._values[i];
	            }
	        }
	        this._resolve(val);
	        return true;
	    }
	    return false;
	};
	
	PropertiesPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};
	
	PropertiesPromiseArray.prototype.getActualLength = function (len) {
	    return len >> 1;
	};
	
	function props(promises) {
	    var ret;
	    var castValue = tryConvertToPromise(promises);
	
	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(
	            Promise.props, undefined, undefined, undefined, undefined);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }
	
	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 2);
	    }
	    return ret;
	}
	
	Promise.prototype.props = function () {
	    return props(this);
	};
	
	Promise.props = function (promises) {
	    return props(promises);
	};
	};


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(
	    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var util = __webpack_require__(122);
	
	var raceLater = function (promise) {
	    return promise.then(function(array) {
	        return race(array, promise);
	    });
	};
	
	function race(promises, parent) {
	    var maybePromise = tryConvertToPromise(promises);
	
	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else {
	        promises = util.asArray(promises);
	        if (promises === null)
	            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
	    }
	
	    var ret = new Promise(INTERNAL);
	    if (parent !== undefined) {
	        ret._propagateFrom(parent, 3);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];
	
	        if (val === undefined && !(i in promises)) {
	            continue;
	        }
	
	        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
	    }
	    return ret;
	}
	
	Promise.race = function (promises) {
	    return race(promises, undefined);
	};
	
	Promise.prototype.race = function () {
	    return race(this, undefined);
	};
	
	};


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL,
	                          debug) {
	var getDomain = Promise._getDomain;
	var util = __webpack_require__(122);
	var tryCatch = util.tryCatch;
	
	function ReductionPromiseArray(promises, fn, initialValue, _each) {
	    this.constructor$(promises);
	    var domain = getDomain();
	    this._fn = domain === null ? fn : util.domainBind(domain, fn);
	    if (initialValue !== undefined) {
	        initialValue = Promise.resolve(initialValue);
	        initialValue._attachCancellationCallback(this);
	    }
	    this._initialValue = initialValue;
	    this._currentCancellable = null;
	    if(_each === INTERNAL) {
	        this._eachValues = Array(this._length);
	    } else if (_each === 0) {
	        this._eachValues = null;
	    } else {
	        this._eachValues = undefined;
	    }
	    this._promise._captureStackTrace();
	    this._init$(undefined, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);
	
	ReductionPromiseArray.prototype._gotAccum = function(accum) {
	    if (this._eachValues !== undefined && 
	        this._eachValues !== null && 
	        accum !== INTERNAL) {
	        this._eachValues.push(accum);
	    }
	};
	
	ReductionPromiseArray.prototype._eachComplete = function(value) {
	    if (this._eachValues !== null) {
	        this._eachValues.push(value);
	    }
	    return this._eachValues;
	};
	
	ReductionPromiseArray.prototype._init = function() {};
	
	ReductionPromiseArray.prototype._resolveEmptyArray = function() {
	    this._resolve(this._eachValues !== undefined ? this._eachValues
	                                                 : this._initialValue);
	};
	
	ReductionPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};
	
	ReductionPromiseArray.prototype._resolve = function(value) {
	    this._promise._resolveCallback(value);
	    this._values = null;
	};
	
	ReductionPromiseArray.prototype._resultCancelled = function(sender) {
	    if (sender === this._initialValue) return this._cancel();
	    if (this._isResolved()) return;
	    this._resultCancelled$();
	    if (this._currentCancellable instanceof Promise) {
	        this._currentCancellable.cancel();
	    }
	    if (this._initialValue instanceof Promise) {
	        this._initialValue.cancel();
	    }
	};
	
	ReductionPromiseArray.prototype._iterate = function (values) {
	    this._values = values;
	    var value;
	    var i;
	    var length = values.length;
	    if (this._initialValue !== undefined) {
	        value = this._initialValue;
	        i = 0;
	    } else {
	        value = Promise.resolve(values[0]);
	        i = 1;
	    }
	
	    this._currentCancellable = value;
	
	    if (!value.isRejected()) {
	        for (; i < length; ++i) {
	            var ctx = {
	                accum: null,
	                value: values[i],
	                index: i,
	                length: length,
	                array: this
	            };
	            value = value._then(gotAccum, undefined, undefined, ctx, undefined);
	        }
	    }
	
	    if (this._eachValues !== undefined) {
	        value = value
	            ._then(this._eachComplete, undefined, undefined, this, undefined);
	    }
	    value._then(completed, completed, undefined, value, this);
	};
	
	Promise.prototype.reduce = function (fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};
	
	Promise.reduce = function (promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};
	
	function completed(valueOrReason, array) {
	    if (this.isFulfilled()) {
	        array._resolve(valueOrReason);
	    } else {
	        array._reject(valueOrReason);
	    }
	}
	
	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}
	
	function gotAccum(accum) {
	    this.accum = accum;
	    this.array._gotAccum(accum);
	    var value = tryConvertToPromise(this.value, this.array._promise);
	    if (value instanceof Promise) {
	        this.array._currentCancellable = value;
	        return value._then(gotValue, undefined, undefined, this, undefined);
	    } else {
	        return gotValue.call(this, value);
	    }
	}
	
	function gotValue(value) {
	    var array = this.array;
	    var promise = array._promise;
	    var fn = tryCatch(array._fn);
	    promise._pushContext();
	    var ret;
	    if (array._eachValues !== undefined) {
	        ret = fn.call(promise._boundValue(), value, this.index, this.length);
	    } else {
	        ret = fn.call(promise._boundValue(),
	                              this.accum, value, this.index, this.length);
	    }
	    if (ret instanceof Promise) {
	        array._currentCancellable = ret;
	    }
	    var promiseCreated = promise._popContext();
	    debug.checkForgottenReturns(
	        ret,
	        promiseCreated,
	        array._eachValues !== undefined ? "Promise.each" : "Promise.reduce",
	        promise
	    );
	    return ret;
	}
	};


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports =
	    function(Promise, PromiseArray, debug) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = __webpack_require__(122);
	
	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);
	
	SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	        return true;
	    }
	    return false;
	};
	
	SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 33554432;
	    ret._settledValueField = value;
	    return this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 16777216;
	    ret._settledValueField = reason;
	    return this._promiseResolved(index, ret);
	};
	
	Promise.settle = function (promises) {
	    debug.deprecated(".settle()", ".reflect()");
	    return new SettledPromiseArray(promises).promise();
	};
	
	Promise.prototype.settle = function () {
	    return Promise.settle(this);
	};
	};


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = __webpack_require__(122);
	var RangeError = __webpack_require__(129).RangeError;
	var AggregateError = __webpack_require__(129).AggregateError;
	var isArray = util.isArray;
	var CANCELLATION = {};
	
	
	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);
	
	SomePromiseArray.prototype._init = function () {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(undefined, -5);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        this._reject(this._getRangeError(this.length()));
	    }
	};
	
	SomePromiseArray.prototype.init = function () {
	    this._initialized = true;
	    this._init();
	};
	
	SomePromiseArray.prototype.setUnwrap = function () {
	    this._unwrap = true;
	};
	
	SomePromiseArray.prototype.howMany = function () {
	    return this._howMany;
	};
	
	SomePromiseArray.prototype.setHowMany = function (count) {
	    this._howMany = count;
	};
	
	SomePromiseArray.prototype._promiseFulfilled = function (value) {
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	        return true;
	    }
	    return false;
	
	};
	SomePromiseArray.prototype._promiseRejected = function (reason) {
	    this._addRejected(reason);
	    return this._checkOutcome();
	};
	
	SomePromiseArray.prototype._promiseCancelled = function () {
	    if (this._values instanceof Promise || this._values == null) {
	        return this._cancel();
	    }
	    this._addRejected(CANCELLATION);
	    return this._checkOutcome();
	};
	
	SomePromiseArray.prototype._checkOutcome = function() {
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            if (this._values[i] !== CANCELLATION) {
	                e.push(this._values[i]);
	            }
	        }
	        if (e.length > 0) {
	            this._reject(e);
	        } else {
	            this._cancel();
	        }
	        return true;
	    }
	    return false;
	};
	
	SomePromiseArray.prototype._fulfilled = function () {
	    return this._totalResolved;
	};
	
	SomePromiseArray.prototype._rejected = function () {
	    return this._values.length - this.length();
	};
	
	SomePromiseArray.prototype._addRejected = function (reason) {
	    this._values.push(reason);
	};
	
	SomePromiseArray.prototype._addFulfilled = function (value) {
	    this._values[this._totalResolved++] = value;
	};
	
	SomePromiseArray.prototype._canPossiblyFulfill = function () {
	    return this.length() - this._rejected();
	};
	
	SomePromiseArray.prototype._getRangeError = function (count) {
	    var message = "Input array must contain at least " +
	            this._howMany + " items but contains only " + count + " items";
	    return new RangeError(message);
	};
	
	SomePromiseArray.prototype._resolveEmptyArray = function () {
	    this._reject(this._getRangeError(0));
	};
	
	function some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}
	
	Promise.some = function (promises, howMany) {
	    return some(promises, howMany);
	};
	
	Promise.prototype.some = function (howMany) {
	    return some(this, howMany);
	};
	
	Promise._SomePromiseArray = SomePromiseArray;
	};


/***/ }),
/* 155 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;
	
	Promise.prototype.filter = function (fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};
	
	Promise.filter = function (promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};


/***/ }),
/* 156 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;
	var PromiseAll = Promise.all;
	
	function promiseAllThis() {
	    return PromiseAll(this);
	}
	
	function PromiseMapSeries(promises, fn) {
	    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
	}
	
	Promise.prototype.each = function (fn) {
	    return PromiseReduce(this, fn, INTERNAL, 0)
	              ._then(promiseAllThis, undefined, undefined, this, undefined);
	};
	
	Promise.prototype.mapSeries = function (fn) {
	    return PromiseReduce(this, fn, INTERNAL, INTERNAL);
	};
	
	Promise.each = function (promises, fn) {
	    return PromiseReduce(promises, fn, INTERNAL, 0)
	              ._then(promiseAllThis, undefined, undefined, promises, undefined);
	};
	
	Promise.mapSeries = PromiseMapSeries;
	};
	


/***/ }),
/* 157 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}
	
	Promise.any = function (promises) {
	    return any(promises);
	};
	
	Promise.prototype.any = function () {
	    return any(this);
	};
	
	};


/***/ }),
/* 158 */
/***/ (function(module, exports) {

	
	    //polyfill bind
	    if (!Function.prototype.bind) {
	        Function.prototype.bind = function(oThis) {
	            if (typeof this !== "function") {
	                // closest thing possible to the ECMAScript 5 internal IsCallable function
	                throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
	            }
	
	            var aArgs = Array.prototype.slice.call(arguments, 1),
	                fToBind = this,
	                fNOP = function() {},
	                fBound = function() {
	                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis || window,
	                        aArgs.concat(Array.prototype.slice.call(arguments)));
	                };
	
	            fNOP.prototype = this.prototype;
	            fBound.prototype = new fNOP();
	
	            return fBound;
	        };
	    }
	
	    //polyfill remove
	    if (!('remove' in Element.prototype)) {
	        Element.prototype.remove = function() {
	            if (this.parentNode) {
	                this.parentNode.removeChild(this);
	            }
	        };
	    }
	
	    if (!String.prototype.endsWith) {
	    String.prototype.endsWith = function(searchString, position) {
	        var subjectString = this.toString();
	        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
	            position = subjectString.length;
	        }
	        position -= searchString.length;
	        var lastIndex = subjectString.indexOf(searchString, position);
	        return lastIndex !== -1 && lastIndex === position;
	    };
	    }
	


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(160);
	
	var _zrender = __webpack_require__(65);
	
	var registerPainter = _zrender.registerPainter;
	
	var Painter = __webpack_require__(162);
	
	registerPainter('vml', Painter);

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	var env = __webpack_require__(49);
	
	var _vector = __webpack_require__(14);
	
	var applyTransform = _vector.applyTransform;
	
	var BoundingRect = __webpack_require__(26);
	
	var colorTool = __webpack_require__(19);
	
	var textContain = __webpack_require__(25);
	
	var textHelper = __webpack_require__(24);
	
	var RectText = __webpack_require__(23);
	
	var Displayable = __webpack_require__(7);
	
	var ZImage = __webpack_require__(44);
	
	var Text = __webpack_require__(45);
	
	var Path = __webpack_require__(6);
	
	var PathProxy = __webpack_require__(29);
	
	var Gradient = __webpack_require__(41);
	
	var vmlCore = __webpack_require__(161);
	
	// http://www.w3.org/TR/NOTE-VML
	// TODO Use proxy like svg instead of overwrite brush methods
	var CMD = PathProxy.CMD;
	var round = Math.round;
	var sqrt = Math.sqrt;
	var abs = Math.abs;
	var cos = Math.cos;
	var sin = Math.sin;
	var mathMax = Math.max;
	
	if (!env.canvasSupported) {
	  var comma = ',';
	  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';
	  var Z = 21600;
	  var Z2 = Z / 2;
	  var ZLEVEL_BASE = 100000;
	  var Z_BASE = 1000;
	
	  var initRootElStyle = function (el) {
	    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';
	    el.coordsize = Z + ',' + Z;
	    el.coordorigin = '0,0';
	  };
	
	  var encodeHtmlAttribute = function (s) {
	    return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
	  };
	
	  var rgb2Str = function (r, g, b) {
	    return 'rgb(' + [r, g, b].join(',') + ')';
	  };
	
	  var append = function (parent, child) {
	    if (child && parent && child.parentNode !== parent) {
	      parent.appendChild(child);
	    }
	  };
	
	  var remove = function (parent, child) {
	    if (child && parent && child.parentNode === parent) {
	      parent.removeChild(child);
	    }
	  };
	
	  var getZIndex = function (zlevel, z, z2) {
	    // z 的取值范围为 [0, 1000]
	    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
	  };
	
	  var parsePercent = function (value, maxValue) {
	    if (typeof value === 'string') {
	      if (value.lastIndexOf('%') >= 0) {
	        return parseFloat(value) / 100 * maxValue;
	      }
	
	      return parseFloat(value);
	    }
	
	    return value;
	  };
	  /***************************************************
	   * PATH
	   **************************************************/
	
	
	  var setColorAndOpacity = function (el, color, opacity) {
	    var colorArr = colorTool.parse(color);
	    opacity = +opacity;
	
	    if (isNaN(opacity)) {
	      opacity = 1;
	    }
	
	    if (colorArr) {
	      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
	      el.opacity = opacity * colorArr[3];
	    }
	  };
	
	  var getColorAndAlpha = function (color) {
	    var colorArr = colorTool.parse(color);
	    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];
	  };
	
	  var updateFillNode = function (el, style, zrEl) {
	    // TODO pattern
	    var fill = style.fill;
	
	    if (fill != null) {
	      // Modified from excanvas
	      if (fill instanceof Gradient) {
	        var gradientType;
	        var angle = 0;
	        var focus = [0, 0]; // additional offset
	
	        var shift = 0; // scale factor for offset
	
	        var expansion = 1;
	        var rect = zrEl.getBoundingRect();
	        var rectWidth = rect.width;
	        var rectHeight = rect.height;
	
	        if (fill.type === 'linear') {
	          gradientType = 'gradient';
	          var transform = zrEl.transform;
	          var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];
	
	          if (transform) {
	            applyTransform(p0, p0, transform);
	            applyTransform(p1, p1, transform);
	          }
	
	          var dx = p1[0] - p0[0];
	          var dy = p1[1] - p0[1];
	          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.
	
	          if (angle < 0) {
	            angle += 360;
	          } // Very small angles produce an unexpected result because they are
	          // converted to a scientific notation string.
	
	
	          if (angle < 1e-6) {
	            angle = 0;
	          }
	        } else {
	          gradientType = 'gradientradial';
	          var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	          var transform = zrEl.transform;
	          var scale = zrEl.scale;
	          var width = rectWidth;
	          var height = rectHeight;
	          focus = [// Percent in bounding rect
	          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];
	
	          if (transform) {
	            applyTransform(p0, p0, transform);
	          }
	
	          width /= scale[0] * Z;
	          height /= scale[1] * Z;
	          var dimension = mathMax(width, height);
	          shift = 2 * 0 / dimension;
	          expansion = 2 * fill.r / dimension - shift;
	        } // We need to sort the color stops in ascending order by offset,
	        // otherwise IE won't interpret it correctly.
	
	
	        var stops = fill.colorStops.slice();
	        stops.sort(function (cs1, cs2) {
	          return cs1.offset - cs2.offset;
	        });
	        var length = stops.length; // Color and alpha list of first and last stop
	
	        var colorAndAlphaList = [];
	        var colors = [];
	
	        for (var i = 0; i < length; i++) {
	          var stop = stops[i];
	          var colorAndAlpha = getColorAndAlpha(stop.color);
	          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);
	
	          if (i === 0 || i === length - 1) {
	            colorAndAlphaList.push(colorAndAlpha);
	          }
	        }
	
	        if (length >= 2) {
	          var color1 = colorAndAlphaList[0][0];
	          var color2 = colorAndAlphaList[1][0];
	          var opacity1 = colorAndAlphaList[0][1] * style.opacity;
	          var opacity2 = colorAndAlphaList[1][1] * style.opacity;
	          el.type = gradientType;
	          el.method = 'none';
	          el.focus = '100%';
	          el.angle = angle;
	          el.color = color1;
	          el.color2 = color2;
	          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2
	          // are reversed.
	
	          el.opacity = opacity2; // FIXME g_o_:opacity ?
	
	          el.opacity2 = opacity1;
	        }
	
	        if (gradientType === 'radial') {
	          el.focusposition = focus.join(',');
	        }
	      } else {
	        // FIXME Change from Gradient fill to color fill
	        setColorAndOpacity(el, fill, style.opacity);
	      }
	    }
	  };
	
	  var updateStrokeNode = function (el, style) {
	    // if (style.lineJoin != null) {
	    //     el.joinstyle = style.lineJoin;
	    // }
	    // if (style.miterLimit != null) {
	    //     el.miterlimit = style.miterLimit * Z;
	    // }
	    // if (style.lineCap != null) {
	    //     el.endcap = style.lineCap;
	    // }
	    if (style.lineDash != null) {
	      el.dashstyle = style.lineDash.join(' ');
	    }
	
	    if (style.stroke != null && !(style.stroke instanceof Gradient)) {
	      setColorAndOpacity(el, style.stroke, style.opacity);
	    }
	  };
	
	  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {
	    var isFill = type == 'fill';
	    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth
	
	    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {
	      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error
	
	      if (style[type] instanceof Gradient) {
	        remove(vmlEl, el);
	      }
	
	      if (!el) {
	        el = vmlCore.createNode(type);
	      }
	
	      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
	      append(vmlEl, el);
	    } else {
	      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';
	      remove(vmlEl, el);
	    }
	  };
	
	  var points = [[], [], []];
	
	  var pathDataToString = function (path, m) {
	    var M = CMD.M;
	    var C = CMD.C;
	    var L = CMD.L;
	    var A = CMD.A;
	    var Q = CMD.Q;
	    var str = [];
	    var nPoint;
	    var cmdStr;
	    var cmd;
	    var i;
	    var xi;
	    var yi;
	    var data = path.data;
	    var dataLength = path.len();
	
	    for (i = 0; i < dataLength;) {
	      cmd = data[i++];
	      cmdStr = '';
	      nPoint = 0;
	
	      switch (cmd) {
	        case M:
	          cmdStr = ' m ';
	          nPoint = 1;
	          xi = data[i++];
	          yi = data[i++];
	          points[0][0] = xi;
	          points[0][1] = yi;
	          break;
	
	        case L:
	          cmdStr = ' l ';
	          nPoint = 1;
	          xi = data[i++];
	          yi = data[i++];
	          points[0][0] = xi;
	          points[0][1] = yi;
	          break;
	
	        case Q:
	        case C:
	          cmdStr = ' c ';
	          nPoint = 3;
	          var x1 = data[i++];
	          var y1 = data[i++];
	          var x2 = data[i++];
	          var y2 = data[i++];
	          var x3;
	          var y3;
	
	          if (cmd === Q) {
	            // Convert quadratic to cubic using degree elevation
	            x3 = x2;
	            y3 = y2;
	            x2 = (x2 + 2 * x1) / 3;
	            y2 = (y2 + 2 * y1) / 3;
	            x1 = (xi + 2 * x1) / 3;
	            y1 = (yi + 2 * y1) / 3;
	          } else {
	            x3 = data[i++];
	            y3 = data[i++];
	          }
	
	          points[0][0] = x1;
	          points[0][1] = y1;
	          points[1][0] = x2;
	          points[1][1] = y2;
	          points[2][0] = x3;
	          points[2][1] = y3;
	          xi = x3;
	          yi = y3;
	          break;
	
	        case A:
	          var x = 0;
	          var y = 0;
	          var sx = 1;
	          var sy = 1;
	          var angle = 0;
	
	          if (m) {
	            // Extract SRT from matrix
	            x = m[4];
	            y = m[5];
	            sx = sqrt(m[0] * m[0] + m[1] * m[1]);
	            sy = sqrt(m[2] * m[2] + m[3] * m[3]);
	            angle = Math.atan2(-m[1] / sy, m[0] / sx);
	          }
	
	          var cx = data[i++];
	          var cy = data[i++];
	          var rx = data[i++];
	          var ry = data[i++];
	          var startAngle = data[i++] + angle;
	          var endAngle = data[i++] + startAngle + angle; // FIXME
	          // var psi = data[i++];
	
	          i++;
	          var clockwise = data[i++];
	          var x0 = cx + cos(startAngle) * rx;
	          var y0 = cy + sin(startAngle) * ry;
	          var x1 = cx + cos(endAngle) * rx;
	          var y1 = cy + sin(endAngle) * ry;
	          var type = clockwise ? ' wa ' : ' at ';
	
	          if (Math.abs(x0 - x1) < 1e-4) {
	            // IE won't render arches drawn counter clockwise if x0 == x1.
	            if (Math.abs(endAngle - startAngle) > 1e-2) {
	              // Offset x0 by 1/80 of a pixel. Use something
	              // that can be represented in binary
	              if (clockwise) {
	                x0 += 270 / Z;
	              }
	            } else {
	              // Avoid case draw full circle
	              if (Math.abs(y0 - cy) < 1e-4) {
	                if (clockwise && x0 < cx || !clockwise && x0 > cx) {
	                  y1 -= 270 / Z;
	                } else {
	                  y1 += 270 / Z;
	                }
	              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {
	                x1 += 270 / Z;
	              } else {
	                x1 -= 270 / Z;
	              }
	            }
	          }
	
	          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));
	          xi = x1;
	          yi = y1;
	          break;
	
	        case CMD.R:
	          var p0 = points[0];
	          var p1 = points[1]; // x0, y0
	
	          p0[0] = data[i++];
	          p0[1] = data[i++]; // x1, y1
	
	          p1[0] = p0[0] + data[i++];
	          p1[1] = p0[1] + data[i++];
	
	          if (m) {
	            applyTransform(p0, p0, m);
	            applyTransform(p1, p1, m);
	          }
	
	          p0[0] = round(p0[0] * Z - Z2);
	          p1[0] = round(p1[0] * Z - Z2);
	          p0[1] = round(p0[1] * Z - Z2);
	          p1[1] = round(p1[1] * Z - Z2);
	          str.push( // x0, y0
	          ' m ', p0[0], comma, p0[1], // x1, y0
	          ' l ', p1[0], comma, p0[1], // x1, y1
	          ' l ', p1[0], comma, p1[1], // x0, y1
	          ' l ', p0[0], comma, p1[1]);
	          break;
	
	        case CMD.Z:
	          // FIXME Update xi, yi
	          str.push(' x ');
	      }
	
	      if (nPoint > 0) {
	        str.push(cmdStr);
	
	        for (var k = 0; k < nPoint; k++) {
	          var p = points[k];
	          m && applyTransform(p, p, m); // 不 round 会非常慢
	
	          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');
	        }
	      }
	    }
	
	    return str.join('');
	  }; // Rewrite the original path method
	
	
	  Path.prototype.brushVML = function (vmlRoot) {
	    var style = this.style;
	    var vmlEl = this._vmlEl;
	
	    if (!vmlEl) {
	      vmlEl = vmlCore.createNode('shape');
	      initRootElStyle(vmlEl);
	      this._vmlEl = vmlEl;
	    }
	
	    updateFillAndStroke(vmlEl, 'fill', style, this);
	    updateFillAndStroke(vmlEl, 'stroke', style, this);
	    var m = this.transform;
	    var needTransform = m != null;
	    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];
	
	    if (strokeEl) {
	      var lineWidth = style.lineWidth; // Get the line scale.
	      // Determinant of this.m_ means how much the area is enlarged by the
	      // transformation. So its square root can be used as a scale factor
	      // for width.
	
	      if (needTransform && !style.strokeNoScale) {
	        var det = m[0] * m[3] - m[1] * m[2];
	        lineWidth *= sqrt(abs(det));
	      }
	
	      strokeEl.weight = lineWidth + 'px';
	    }
	
	    var path = this.path || (this.path = new PathProxy());
	
	    if (this.__dirtyPath) {
	      path.beginPath();
	      this.buildPath(path, this.shape);
	      path.toStatic();
	      this.__dirtyPath = false;
	    }
	
	    vmlEl.path = pathDataToString(path, this.transform);
	    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root
	
	    append(vmlRoot, vmlEl); // Text
	
	    if (style.text != null) {
	      this.drawRectText(vmlRoot, this.getBoundingRect());
	    } else {
	      this.removeRectText(vmlRoot);
	    }
	  };
	
	  Path.prototype.onRemove = function (vmlRoot) {
	    remove(vmlRoot, this._vmlEl);
	    this.removeRectText(vmlRoot);
	  };
	
	  Path.prototype.onAdd = function (vmlRoot) {
	    append(vmlRoot, this._vmlEl);
	    this.appendRectText(vmlRoot);
	  };
	  /***************************************************
	   * IMAGE
	   **************************************************/
	
	
	  var isImage = function (img) {
	    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错
	    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;
	  }; // Rewrite the original path method
	
	
	  ZImage.prototype.brushVML = function (vmlRoot) {
	    var style = this.style;
	    var image = style.image; // Image original width, height
	
	    var ow;
	    var oh;
	
	    if (isImage(image)) {
	      var src = image.src;
	
	      if (src === this._imageSrc) {
	        ow = this._imageWidth;
	        oh = this._imageHeight;
	      } else {
	        var imageRuntimeStyle = image.runtimeStyle;
	        var oldRuntimeWidth = imageRuntimeStyle.width;
	        var oldRuntimeHeight = imageRuntimeStyle.height;
	        imageRuntimeStyle.width = 'auto';
	        imageRuntimeStyle.height = 'auto'; // get the original size
	
	        ow = image.width;
	        oh = image.height; // and remove overides
	
	        imageRuntimeStyle.width = oldRuntimeWidth;
	        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src
	
	        this._imageSrc = src;
	        this._imageWidth = ow;
	        this._imageHeight = oh;
	      }
	
	      image = src;
	    } else {
	      if (image === this._imageSrc) {
	        ow = this._imageWidth;
	        oh = this._imageHeight;
	      }
	    }
	
	    if (!image) {
	      return;
	    }
	
	    var x = style.x || 0;
	    var y = style.y || 0;
	    var dw = style.width;
	    var dh = style.height;
	    var sw = style.sWidth;
	    var sh = style.sHeight;
	    var sx = style.sx || 0;
	    var sy = style.sy || 0;
	    var hasCrop = sw && sh;
	    var vmlEl = this._vmlEl;
	
	    if (!vmlEl) {
	      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。
	      // vmlEl = vmlCore.createNode('group');
	      vmlEl = vmlCore.doc.createElement('div');
	      initRootElStyle(vmlEl);
	      this._vmlEl = vmlEl;
	    }
	
	    var vmlElStyle = vmlEl.style;
	    var hasRotation = false;
	    var m;
	    var scaleX = 1;
	    var scaleY = 1;
	
	    if (this.transform) {
	      m = this.transform;
	      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
	      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
	      hasRotation = m[1] || m[2];
	    }
	
	    if (hasRotation) {
	      // If filters are necessary (rotation exists), create them
	      // filters are bog-slow, so only create them if abbsolutely necessary
	      // The following check doesn't account for skews (which don't exist
	      // in the canvas spec (yet) anyway.
	      // From excanvas
	      var p0 = [x, y];
	      var p1 = [x + dw, y];
	      var p2 = [x, y + dh];
	      var p3 = [x + dw, y + dh];
	      applyTransform(p0, p0, m);
	      applyTransform(p1, p1, m);
	      applyTransform(p2, p2, m);
	      applyTransform(p3, p3, m);
	      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
	      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
	      var transformFilter = [];
	      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));
	      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用
	
	      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';
	    } else {
	      if (m) {
	        x = x * scaleX + m[4];
	        y = y * scaleY + m[5];
	      }
	
	      vmlElStyle.filter = '';
	      vmlElStyle.left = round(x) + 'px';
	      vmlElStyle.top = round(y) + 'px';
	    }
	
	    var imageEl = this._imageEl;
	    var cropEl = this._cropEl;
	
	    if (!imageEl) {
	      imageEl = vmlCore.doc.createElement('div');
	      this._imageEl = imageEl;
	    }
	
	    var imageELStyle = imageEl.style;
	
	    if (hasCrop) {
	      // Needs know image original width and height
	      if (!(ow && oh)) {
	        var tmpImage = new Image();
	        var self = this;
	
	        tmpImage.onload = function () {
	          tmpImage.onload = null;
	          ow = tmpImage.width;
	          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize
	
	          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src
	
	          self._imageWidth = ow;
	          self._imageHeight = oh;
	          self._imageSrc = image;
	        };
	
	        tmpImage.src = image;
	      } else {
	        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
	      }
	
	      if (!cropEl) {
	        cropEl = vmlCore.doc.createElement('div');
	        cropEl.style.overflow = 'hidden';
	        this._cropEl = cropEl;
	      }
	
	      var cropElStyle = cropEl.style;
	      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
	      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
	      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';
	
	      if (!cropEl.parentNode) {
	        vmlEl.appendChild(cropEl);
	      }
	
	      if (imageEl.parentNode != cropEl) {
	        cropEl.appendChild(imageEl);
	      }
	    } else {
	      imageELStyle.width = round(scaleX * dw) + 'px';
	      imageELStyle.height = round(scaleY * dh) + 'px';
	      vmlEl.appendChild(imageEl);
	
	      if (cropEl && cropEl.parentNode) {
	        vmlEl.removeChild(cropEl);
	        this._cropEl = null;
	      }
	    }
	
	    var filterStr = '';
	    var alpha = style.opacity;
	
	    if (alpha < 1) {
	      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';
	    }
	
	    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';
	    imageELStyle.filter = filterStr;
	    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root
	
	    append(vmlRoot, vmlEl); // Text
	
	    if (style.text != null) {
	      this.drawRectText(vmlRoot, this.getBoundingRect());
	    }
	  };
	
	  ZImage.prototype.onRemove = function (vmlRoot) {
	    remove(vmlRoot, this._vmlEl);
	    this._vmlEl = null;
	    this._cropEl = null;
	    this._imageEl = null;
	    this.removeRectText(vmlRoot);
	  };
	
	  ZImage.prototype.onAdd = function (vmlRoot) {
	    append(vmlRoot, this._vmlEl);
	    this.appendRectText(vmlRoot);
	  };
	  /***************************************************
	   * TEXT
	   **************************************************/
	
	
	  var DEFAULT_STYLE_NORMAL = 'normal';
	  var fontStyleCache = {};
	  var fontStyleCacheCount = 0;
	  var MAX_FONT_CACHE_SIZE = 100;
	  var fontEl = document.createElement('div');
	
	  var getFontStyle = function (fontString) {
	    var fontStyle = fontStyleCache[fontString];
	
	    if (!fontStyle) {
	      // Clear cache
	      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
	        fontStyleCacheCount = 0;
	        fontStyleCache = {};
	      }
	
	      var style = fontEl.style;
	      var fontFamily;
	
	      try {
	        style.font = fontString;
	        fontFamily = style.fontFamily.split(',')[0];
	      } catch (e) {}
	
	      fontStyle = {
	        style: style.fontStyle || DEFAULT_STYLE_NORMAL,
	        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
	        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
	        size: parseFloat(style.fontSize || 12) | 0,
	        family: fontFamily || 'Microsoft YaHei'
	      };
	      fontStyleCache[fontString] = fontStyle;
	      fontStyleCacheCount++;
	    }
	
	    return fontStyle;
	  };
	
	  var textMeasureEl; // Overwrite measure text method
	
	  textContain.$override('measureText', function (text, textFont) {
	    var doc = vmlCore.doc;
	
	    if (!textMeasureEl) {
	      textMeasureEl = doc.createElement('div');
	      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';
	      vmlCore.doc.body.appendChild(textMeasureEl);
	    }
	
	    try {
	      textMeasureEl.style.font = textFont;
	    } catch (ex) {// Ignore failures to set to invalid font.
	    }
	
	    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.
	
	    textMeasureEl.appendChild(doc.createTextNode(text));
	    return {
	      width: textMeasureEl.offsetWidth
	    };
	  });
	  var tmpRect = new BoundingRect();
	
	  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {
	    var style = this.style; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true);
	    var text = style.text; // Convert to string
	
	    text != null && (text += '');
	
	    if (!text) {
	      return;
	    } // Convert rich text to plain text. Rich text is not supported in
	    // IE8-, but tags in rich text template will be removed.
	
	
	    if (style.rich) {
	      var contentBlock = textContain.parseRichText(text, style);
	      text = [];
	
	      for (var i = 0; i < contentBlock.lines.length; i++) {
	        var tokens = contentBlock.lines[i].tokens;
	        var textLine = [];
	
	        for (var j = 0; j < tokens.length; j++) {
	          textLine.push(tokens[j].text);
	        }
	
	        text.push(textLine.join(''));
	      }
	
	      text = text.join('\n');
	    }
	
	    var x;
	    var y;
	    var align = style.textAlign;
	    var verticalAlign = style.textVerticalAlign;
	    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?
	
	    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px "' + fontStyle.family + '"';
	    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign); // Transform rect to view space
	
	    var m = this.transform; // Ignore transform for text in other element
	
	    if (m && !fromTextEl) {
	      tmpRect.copy(rect);
	      tmpRect.applyTransform(m);
	      rect = tmpRect;
	    }
	
	    if (!fromTextEl) {
	      var textPosition = style.textPosition;
	      var distance = style.textDistance; // Text position represented by coord
	
	      if (textPosition instanceof Array) {
	        x = rect.x + parsePercent(textPosition[0], rect.width);
	        y = rect.y + parsePercent(textPosition[1], rect.height);
	        align = align || 'left';
	      } else {
	        var res = textContain.adjustTextPositionOnRect(textPosition, rect, distance);
	        x = res.x;
	        y = res.y; // Default align and baseline when has textPosition
	
	        align = align || res.textAlign;
	        verticalAlign = verticalAlign || res.textVerticalAlign;
	      }
	    } else {
	      x = rect.x;
	      y = rect.y;
	    }
	
	    x = textContain.adjustTextX(x, textRect.width, align);
	    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'
	
	    y += textRect.height / 2; // var fontSize = fontStyle.size;
	    // 1.75 is an arbitrary number, as there is no info about the text baseline
	    // switch (baseline) {
	    // case 'hanging':
	    // case 'top':
	    //     y += fontSize / 1.75;
	    //     break;
	    //     case 'middle':
	    //         break;
	    //     default:
	    //     // case null:
	    //     // case 'alphabetic':
	    //     // case 'ideographic':
	    //     // case 'bottom':
	    //         y -= fontSize / 2.25;
	    //         break;
	    // }
	    // switch (align) {
	    //     case 'left':
	    //         break;
	    //     case 'center':
	    //         x -= textRect.width / 2;
	    //         break;
	    //     case 'right':
	    //         x -= textRect.width;
	    //         break;
	    // case 'end':
	    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';
	    // break;
	    // case 'start':
	    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';
	    // break;
	    // default:
	    //     align = 'left';
	    // }
	
	    var createNode = vmlCore.createNode;
	    var textVmlEl = this._textVmlEl;
	    var pathEl;
	    var textPathEl;
	    var skewEl;
	
	    if (!textVmlEl) {
	      textVmlEl = createNode('line');
	      pathEl = createNode('path');
	      textPathEl = createNode('textpath');
	      skewEl = createNode('skew'); // FIXME Why here is not cammel case
	      // Align 'center' seems wrong
	
	      textPathEl.style['v-text-align'] = 'left';
	      initRootElStyle(textVmlEl);
	      pathEl.textpathok = true;
	      textPathEl.on = true;
	      textVmlEl.from = '0 0';
	      textVmlEl.to = '1000 0.05';
	      append(textVmlEl, skewEl);
	      append(textVmlEl, pathEl);
	      append(textVmlEl, textPathEl);
	      this._textVmlEl = textVmlEl;
	    } else {
	      // 这里是在前面 appendChild 保证顺序的前提下
	      skewEl = textVmlEl.firstChild;
	      pathEl = skewEl.nextSibling;
	      textPathEl = pathEl.nextSibling;
	    }
	
	    var coords = [x, y];
	    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element
	
	    if (m && fromTextEl) {
	      applyTransform(coords, coords, m);
	      skewEl.on = true;
	      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position
	
	      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin
	
	      skewEl.origin = '0 0';
	      textVmlElStyle.left = '0px';
	      textVmlElStyle.top = '0px';
	    } else {
	      skewEl.on = false;
	      textVmlElStyle.left = round(x) + 'px';
	      textVmlElStyle.top = round(y) + 'px';
	    }
	
	    textPathEl.string = encodeHtmlAttribute(text); // TODO
	
	    try {
	      textPathEl.style.font = font;
	    } // Error font format
	    catch (e) {}
	
	    updateFillAndStroke(textVmlEl, 'fill', {
	      fill: style.textFill,
	      opacity: style.opacity
	    }, this);
	    updateFillAndStroke(textVmlEl, 'stroke', {
	      stroke: style.textStroke,
	      opacity: style.opacity,
	      lineDash: style.lineDash
	    }, this);
	    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root
	
	    append(vmlRoot, textVmlEl);
	  };
	
	  var removeRectText = function (vmlRoot) {
	    remove(vmlRoot, this._textVmlEl);
	    this._textVmlEl = null;
	  };
	
	  var appendRectText = function (vmlRoot) {
	    append(vmlRoot, this._textVmlEl);
	  };
	
	  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText
	
	  for (var i = 0; i < list.length; i++) {
	    var proto = list[i].prototype;
	    proto.drawRectText = drawRectText;
	    proto.removeRectText = removeRectText;
	    proto.appendRectText = appendRectText;
	  }
	
	  Text.prototype.brushVML = function (vmlRoot) {
	    var style = this.style;
	
	    if (style.text != null) {
	      this.drawRectText(vmlRoot, {
	        x: style.x || 0,
	        y: style.y || 0,
	        width: 0,
	        height: 0
	      }, this.getBoundingRect(), true);
	    } else {
	      this.removeRectText(vmlRoot);
	    }
	  };
	
	  Text.prototype.onRemove = function (vmlRoot) {
	    this.removeRectText(vmlRoot);
	  };
	
	  Text.prototype.onAdd = function (vmlRoot) {
	    this.appendRectText(vmlRoot);
	  };
	}

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	var env = __webpack_require__(49);
	
	var urn = 'urn:schemas-microsoft-com:vml';
	var win = typeof window === 'undefined' ? null : window;
	var vmlInited = false;
	var doc = win && win.document;
	
	function createNode(tagName) {
	  return doCreateNode(tagName);
	} // Avoid assign to an exported variable, for transforming to cjs.
	
	
	var doCreateNode;
	
	if (doc && !env.canvasSupported) {
	  try {
	    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);
	
	    doCreateNode = function (tagName) {
	      return doc.createElement('<zrvml:' + tagName + ' class="zrvml">');
	    };
	  } catch (e) {
	    doCreateNode = function (tagName) {
	      return doc.createElement('<' + tagName + ' xmlns="' + urn + '" class="zrvml">');
	    };
	  }
	} // From raphael
	
	
	function initVML() {
	  if (vmlInited || !doc) {
	    return;
	  }
	
	  vmlInited = true;
	  var styleSheets = doc.styleSheets;
	
	  if (styleSheets.length < 31) {
	    doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');
	  } else {
	    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
	    styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');
	  }
	}
	
	exports.doc = doc;
	exports.createNode = createNode;
	exports.initVML = initVML;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	var zrLog = __webpack_require__(21);
	
	var vmlCore = __webpack_require__(161);
	
	var _util = __webpack_require__(4);
	
	var each = _util.each;
	
	/**
	 * VML Painter.
	 *
	 * @module zrender/vml/Painter
	 */
	function parseInt10(val) {
	  return parseInt(val, 10);
	}
	/**
	 * @alias module:zrender/vml/Painter
	 */
	
	
	function VMLPainter(root, storage) {
	  vmlCore.initVML();
	  this.root = root;
	  this.storage = storage;
	  var vmlViewport = document.createElement('div');
	  var vmlRoot = document.createElement('div');
	  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';
	  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';
	  root.appendChild(vmlViewport);
	  this._vmlRoot = vmlRoot;
	  this._vmlViewport = vmlViewport;
	  this.resize(); // Modify storage
	
	  var oldDelFromStorage = storage.delFromStorage;
	  var oldAddToStorage = storage.addToStorage;
	
	  storage.delFromStorage = function (el) {
	    oldDelFromStorage.call(storage, el);
	
	    if (el) {
	      el.onRemove && el.onRemove(vmlRoot);
	    }
	  };
	
	  storage.addToStorage = function (el) {
	    // Displayable already has a vml node
	    el.onAdd && el.onAdd(vmlRoot);
	    oldAddToStorage.call(storage, el);
	  };
	
	  this._firstPaint = true;
	}
	
	VMLPainter.prototype = {
	  constructor: VMLPainter,
	  getType: function () {
	    return 'vml';
	  },
	
	  /**
	   * @return {HTMLDivElement}
	   */
	  getViewportRoot: function () {
	    return this._vmlViewport;
	  },
	  getViewportRootOffset: function () {
	    var viewportRoot = this.getViewportRoot();
	
	    if (viewportRoot) {
	      return {
	        offsetLeft: viewportRoot.offsetLeft || 0,
	        offsetTop: viewportRoot.offsetTop || 0
	      };
	    }
	  },
	
	  /**
	   * 刷新
	   */
	  refresh: function () {
	    var list = this.storage.getDisplayList(true, true);
	
	    this._paintList(list);
	  },
	  _paintList: function (list) {
	    var vmlRoot = this._vmlRoot;
	
	    for (var i = 0; i < list.length; i++) {
	      var el = list[i];
	
	      if (el.invisible || el.ignore) {
	        if (!el.__alreadyNotVisible) {
	          el.onRemove(vmlRoot);
	        } // Set as already invisible
	
	
	        el.__alreadyNotVisible = true;
	      } else {
	        if (el.__alreadyNotVisible) {
	          el.onAdd(vmlRoot);
	        }
	
	        el.__alreadyNotVisible = false;
	
	        if (el.__dirty) {
	          el.beforeBrush && el.beforeBrush();
	          (el.brushVML || el.brush).call(el, vmlRoot);
	          el.afterBrush && el.afterBrush();
	        }
	      }
	
	      el.__dirty = false;
	    }
	
	    if (this._firstPaint) {
	      // Detached from document at first time
	      // to avoid page refreshing too many times
	      // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变
	      this._vmlViewport.appendChild(vmlRoot);
	
	      this._firstPaint = false;
	    }
	  },
	  resize: function (width, height) {
	    var width = width == null ? this._getWidth() : width;
	    var height = height == null ? this._getHeight() : height;
	
	    if (this._width != width || this._height != height) {
	      this._width = width;
	      this._height = height;
	      var vmlViewportStyle = this._vmlViewport.style;
	      vmlViewportStyle.width = width + 'px';
	      vmlViewportStyle.height = height + 'px';
	    }
	  },
	  dispose: function () {
	    this.root.innerHTML = '';
	    this._vmlRoot = this._vmlViewport = this.storage = null;
	  },
	  getWidth: function () {
	    return this._width;
	  },
	  getHeight: function () {
	    return this._height;
	  },
	  clear: function () {
	    if (this._vmlViewport) {
	      this.root.removeChild(this._vmlViewport);
	    }
	  },
	  _getWidth: function () {
	    var root = this.root;
	    var stl = root.currentStyle;
	    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;
	  },
	  _getHeight: function () {
	    var root = this.root;
	    var stl = root.currentStyle;
	    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;
	  }
	}; // Not supported methods
	
	function createMethodNotSupport(method) {
	  return function () {
	    zrLog('In IE8.0 VML mode painter not support method "' + method + '"');
	  };
	} // Unsupported methods
	
	
	each(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {
	  VMLPainter.prototype[name] = createMethodNotSupport(name);
	});
	var _default = VMLPainter;
	module.exports = _default;

/***/ })
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA5ZTViYzEwMjBlZjg1MmI4YzMwOSIsIndlYnBhY2s6Ly8vLi9pbmRleC5icG1uLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvRmlzaFRvcG9CcG1uLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1N0eWxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS92ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vZWFzaW5nLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdG9vbC9jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvTFJVLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL21peGluL1JlY3RUZXh0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvY3VydmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2Jib3guanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL2xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL2N1YmljLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9xdWFkcmF0aWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL2FyYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vd2luZGluZ0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdHRlcm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi90b29sL3RyYW5zZm9ybVBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9maXhDbGlwV2l0aFNoYWRvdy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZW52LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aFNwbGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aEJlemllci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0xpbmVhckdyYWRpZW50LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvU3RhdGVzLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvRXh0ZW5zaW9uQXBpLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi96cmVuZGVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL1N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9QYWludGVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9kb20vSGFuZGxlclByb3h5LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9HZXN0dXJlTWdyLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvQnBtblV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTGluZVN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvQlBNTk5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Ob2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvY2xhenouanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9tb2RlbC9CUE1OTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZXZlbnQvU3RhcnRFdmVudE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2V2ZW50L0V2ZW50Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZXZlbnQvRW5kRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1VzZXJUYXNrTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvdGFzay9UYXNrTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvdGFzay9NYW51YWxUYXNrTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvdGFzay9TY3JpcHRUYXNrTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvdGFzay9NYWlsVGFza05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL3Rhc2svU2VydmljZVRhc2tOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1Ntc1Rhc2tOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9Db21tZW50Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZXZlbnQvYm91bmRhcnlldmVudC9DYXRjaFRpbWVyRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L0NhdGNoU2lnbmFsRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L1Rocm93U2lnbmFsRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9DYXRjaE1lc3NhZ2VFdmVudE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvSW5jbHVzaXZlR2F0ZXdheU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvR2F0ZXdheU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvRXhjbHVzaXZlR2F0ZXdheU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvUGFyYWxsZWxHYXRld2F5Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvU3ViUHJvY2Vzc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9CcG1uLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvSGFuZGxlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0VmZmVjdExpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdGlvblBvaW50LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9Hcm91cE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL0JwbW5PcGVyYXRpb25Ob2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9PcGVyYXRpb25Ob2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9JY29uT3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbWFuYWdlci9CcG1uQ29ubmVjdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0Nvbm5lY3Rpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTG9nLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9MaW5lT3BlcmF0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvR3VpZGVsaW5lcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvYmx1ZWJpcmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2VzNS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvYXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3NjaGVkdWxlLmpzIiwid2VicGFjazovLy8uL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3F1ZXVlLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3RoZW5hYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvcHJvbWlzZV9hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvZGVidWdnYWJpbGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvZmluYWxseS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvY2F0Y2hfZmlsdGVyLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9ub2RlYmFjay5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvbWV0aG9kLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9iaW5kLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9jYW5jZWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2RpcmVjdF9yZXNvbHZlLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9zeW5jaHJvbm91c19pbnNwZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9qb2luLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2NhbGxfZ2V0LmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS91c2luZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvdGltZXJzLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9nZW5lcmF0b3JzLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9ub2RlaWZ5LmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3Byb3BzLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9yYWNlLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2Uvc29tZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvZmlsdGVyLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9lYWNoLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9hbnkuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3ZtbC92bWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi92bWwvZ3JhcGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3ZtbC9jb3JlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdm1sL1BhaW50ZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFxRDtBQUNyRDtBQUNBLCtEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLHFDQUFxQztBQUM1RTtBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBLGlCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1osK0JBQThCO0FBQzlCLHFDQUFvQztBQUNwQywrQkFBOEI7QUFDOUIsbUNBQWtDO0FBQ2xDLHFDQUFvQztBQUNwQztBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0EsMEJBQXlCO0FBQ3pCLCtCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0Esc0RBQXFEO0FBQ3JELHdEQUF1RDtBQUN2RDtBQUNBLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUM7QUFDdkMsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixtQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZOztBQUVaO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLCtCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXFDO0FBQ3JDO0FBQ0EsdUJBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFrRCxRQUFRLDRCQUE0Qix5QkFBeUI7QUFDL0csYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQW9ELG9CQUFvQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQywyQkFBMkI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE9BQU87QUFDekIsbUJBQWtCLE1BQU07QUFDeEI7QUFDQSxzQ0FBcUMsY0FBYztBQUNuRCx5QkFBd0IsbUJBQW1CO0FBQzNDLHlCQUF3QixpQkFBaUI7QUFDekMseUJBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxtREFBa0Qsa0NBQWtDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFnRCxXQUFXLEVBQUUsbUJBQW1CLEVBQUUsY0FBYyxFQUFFLGdCQUFnQjtBQUNsSDtBQUNBLCtDQUE4QyxrRUFBa0UsbUNBQW1DO0FBQ25KLDBDQUF5QztBQUN6QztBQUNBLDZCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDO0FBQzNDO0FBQ0EsK0NBQThDLFdBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esd0RBQXVELGFBQWE7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMEIsNkJBQTZCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MsdUJBQXVCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEIsNkJBQTZCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDLDJCQUEyQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWiwrQkFBOEIsNkJBQTZCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEIsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBOEIsdUJBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RkFBd0YseUNBQXlDO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RkFBd0YseUNBQXlDO0FBQ2pJLHFEQUFvRCxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyw4QkFBOEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBLDZDQUE0QyxhQUFhO0FBQ3pEO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLGVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLGFBQWE7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLGFBQWE7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQThELDRCQUE0QixFQUFFO0FBQzVGLG9CQUFtQixTQUFTO0FBQzVCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0EscUdBQW9HLDhCQUE4QjtBQUNsSTtBQUNBO0FBQ0EsaUJBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixtQkFBa0IsT0FBTztBQUN6QixtQkFBa0IsT0FBTztBQUN6QixtQkFBa0IsT0FBTztBQUN6QixtQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QztBQUM3QztBQUNBO0FBQ0EsMkRBQTBEO0FBQzFEO0FBQ0EsaUNBQWdDO0FBQ2hDLDZCQUE0QixFQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFxRCxZQUFZO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsNENBQTJDO0FBQzNDLHNDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNEUsbUNBQW1DO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQSx5Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLHlDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFnRixtQ0FBbUM7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBaUYsbUNBQW1DO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QixPQUFPLGdCQUFnQiwrREFBK0Q7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLDZCQUE0QixPQUFPLGdCQUFnQixpRUFBaUU7QUFDcEg7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQztBQUMxQyw2Q0FBNEM7QUFDNUMsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUE4RCxzQkFBc0I7QUFDcEYsK0NBQThDO0FBQzlDLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUNBQWdDLE9BQU8sZ0JBQWdCLCtEQUErRDtBQUN0SCxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxxREFBcUQ7QUFDbEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWlHO0FBQ2pHO0FBQ0E7QUFDQSw4REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0Esa0ZBQWlGLG1DQUFtQztBQUNwSCxrRkFBaUYsbUNBQW1DO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLHVEQUF1RDtBQUNsRztBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQyx5REFBeUQ7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCLDBCQUF5QjtBQUN6Qiw0Q0FBMkMsK0ZBQStGO0FBQzFJO0FBQ0Esc0JBQXFCO0FBQ3JCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxzQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXdELDZDQUE2QyxJQUFJO0FBQ3pHLCtHQUE4RztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxpRkFBZ0YsNkJBQTZCO0FBQzdHLGlGQUFnRiw2QkFBNkI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLG1FQUFtRTtBQUM5RztBQUNBLDBCQUF5QjtBQUN6Qiw0Q0FBMkMsbUhBQW1IOztBQUU5SjtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw0Q0FBMkMsaUVBQWlFO0FBQzVHO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBLHdDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEIsaUJBQWdCO0FBQ2hCO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBNkM7QUFDN0Msd0NBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQSxvQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBa0YsaUNBQWlDO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixPQUFPLGdCQUFnQiwrREFBK0Q7QUFDakg7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLE9BQU8sZ0JBQWdCLGlFQUFpRTtBQUN2SDtBQUNBLGlCQUFnQjtBQUNoQixhQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGdEQUErQztBQUMvQztBQUNBLG1EQUFrRCxpQkFBaUI7QUFDbkU7QUFDQTtBQUNBLDBDQUF5QztBQUN6QztBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCLHFCQUFvQjtBQUNwQjtBQUNBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBZ0csYUFBYTtBQUM3RztBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBdUQsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQSwyREFBMEQsZ0JBQWdCO0FBQzFFO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEIsYUFBWTtBQUNaLHdEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEIsdUNBQXNDLCtCQUErQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLGlDQUFpQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEMsOEJBQThCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxtREFBa0QsMkJBQTJCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQWtELDJCQUEyQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsMkJBQTJCO0FBQ3JFO0FBQ0E7QUFDQSx1REFBc0Qsd0NBQXdDO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMEQsZ0JBQWdCO0FBQzFFO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW1ELGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEIsdURBQXNELGtCQUFrQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QztBQUM1QztBQUNBLDBDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0EsaUJBQWdCO0FBQ2hCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWlELGFBQWE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QiwwQkFBMEI7QUFDeEQ7QUFDQTtBQUNBLDJDQUEwQyxrQ0FBa0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7O0FBRVo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEIsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBOEIsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLDBCQUEwQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0MsOEJBQThCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQixvQ0FBbUMseUJBQXlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4Qiw0REFBNEQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4Qiw0REFBNEQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEIsaUdBQWdHLHVDQUF1QztBQUN2STtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDO0FBQ0EscUNBQW9DO0FBQ3BDO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDLHlDQUF3QztBQUN4QztBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUZBQXNGLDZDQUE2QztBQUNuSSwyREFBMEQsU0FBUztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQztBQUNwQyxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLHFDQUFvQztBQUNwQztBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0M7QUFDeEM7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQztBQUNoQztBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFrQywwQkFBMEI7QUFDNUQ7QUFDQTtBQUNBLCtDQUE4QyxrQ0FBa0M7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxpQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsOEJBQThCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDZCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQSwyQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBa0QsMkJBQTJCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEMsOEJBQThCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQThDLDBCQUEwQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQztBQUNwQyxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLHFDQUFvQztBQUNwQztBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLDBCQUEwQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLDhCQUE4QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDZCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHVDQUFzQyxtQkFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLDBCQUEwQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyw4QkFBOEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDLDZCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0EseUJBQXdCO0FBQ3hCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG1DQUFrQywwQkFBMEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsK0NBQThDLGtDQUFrQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBcUQsYUFBYTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUMsYUFBYSxVQUFVO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0Esa0RBQWlELGFBQWEsWUFBWTtBQUMxRSxvREFBbUQsaUJBQWlCO0FBQ3BFLGlCQUFnQjtBQUNoQixrREFBaUQsYUFBYSxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esd0NBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0EseURBQXdEO0FBQ3hEO0FBQ0E7QUFDQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCLHFEQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCLDRDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixZQUFZO0FBQzlCLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixZQUFZO0FBQy9CLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdC9HQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxpQ0FBaUM7QUFDaEQsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSw0QkFBNEI7QUFDM0MsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVB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Q0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSwyQjs7Ozs7O0FDdlVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHFCQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLHlCQUF5QjtBQUNwQzs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxlQUFlO0FBQzFCLFlBQVcsT0FBTztBQUNsQixZQUFXLGVBQWU7QUFDMUIsWUFBVyxlQUFlO0FBQzFCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkI7Ozs7OztBQzFSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsNEJBQTRCO0FBQ3ZDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyw0QkFBNEI7QUFDdkMsWUFBVyw0QkFBNEI7QUFDdkM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLDRCQUE0QjtBQUN2QyxZQUFXLDRCQUE0QjtBQUN2QyxZQUFXLDRCQUE0QjtBQUN2Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsNEJBQTRCO0FBQ3ZDLFlBQVcsNEJBQTRCO0FBQ3ZDLFlBQVcsNEJBQTRCO0FBQ3ZDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyw0QkFBNEI7QUFDdkMsWUFBVyw0QkFBNEI7QUFDdkMsWUFBVyxPQUFPO0FBQ2xCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsNEJBQTRCO0FBQ3ZDLFlBQVcsNEJB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Q0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQjs7Ozs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJ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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLGVBQWU7QUFDMUIsYUFBWTtBQUNaO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7OztBQUdILDRCQUEyQjs7QUFFM0Isc0RBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7OztBQUdIO0FBQ0E7QUFDQSw0Q0FBMkM7O0FBRTNDO0FBQ0E7QUFDQSxnQkFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCw0Q0FBMkM7O0FBRTNDO0FBQ0E7QUFDQSxnQkFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsZUFBZTtBQUMxQixZQUFXLGVBQWU7QUFDMUIsYUFBWSxlQUFlO0FBQzNCOzs7QUFHQTtBQUNBLHlEQUF3RDtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxlQUFlO0FBQzFCLGFBQVksZUFBZTtBQUMzQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCOztBQUUvQixnQ0FBK0I7O0FBRS9CLDJCQUEwQjs7QUFFMUI7QUFDQTtBQUNBLFNBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLHVCQUF1QjtBQUNsQyxZQUFXLGVBQWU7QUFDMUIsYUFBWSxlQUFlO0FBQzNCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLGVBQWU7QUFDMUIsWUFBVyxTQUFTO0FBQ3BCLGFBQVksZ0JBQWdCO0FBQzVCLHNDQUFxQyx3REFBd0Q7QUFDN0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxRQUFRO0FBQ25CLFlBQVcsUUFBUTtBQUNuQixZQUFXLFFBQVE7QUFDbkIsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxRQUFRO0FBQ25CLGFBQVksT0FBTztBQUNuQjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsZUFBZTtBQUMxQixZQUFXLE9BQU87QUFDbEIsYUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQjs7Ozs7O0FDNW1CQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLDhCQUE4QjtBQUMxQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLDhCQUE4QjtBQUMxQzs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYixjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkI7Ozs7OztBQ3pNQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkI7Ozs7OztBQ3JCQSxhQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxtQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQSw2Qzs7Ozs7O0FDdkJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYyx5QkFBeUI7QUFDdkMsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQzs7QUFFbEM7QUFDQSwyQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQSxNQUFLOzs7QUFHTCxnQkFBZTs7QUFFZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkI7Ozs7OztBQ3REQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyw2QkFBNkI7QUFDeEMsYUFBWSw2QkFBNkI7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTRGOztBQUU1RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLHlCQUF5QjtBQUNwQyxZQUFXLE9BQU87QUFDbEIsWUFBVyw2QkFBNkI7QUFDeEMsWUFBVyxlQUFlLFNBQVM7QUFDbkM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFnRDtBQUNoRDs7QUFFQSx5Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBLDhEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7OztBQUdMOztBQUVBO0FBQ0EsaUNBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSx5QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBcUY7O0FBRXJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQyxZQUFZO0FBQ2IsWUFBVzs7O0FBR1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQWtEOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxxQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLHFCQUFxQjtBQUNoQyxhQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDOzs7Ozs7QUNsYkE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIscUJBQXFCLEtBQUs7QUFDN0Msc0NBQXFDOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZLE9BQU87QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsZUFBZTtBQUMxQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGFBQVksT0FBTyxFQUFFO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsYUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsYUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU8sT0FBTztBQUN6QixZQUFXLE9BQU87QUFDbEIsYUFBWSxPQUFPLEVBQUU7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkVBQTRFO0FBQzVFOztBQUVBLDBDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpRUFBZ0U7QUFDaEU7O0FBRUEsNkNBQTRDO0FBQzVDOztBQUVBO0FBQ0EsNERBQTJEO0FBQzNEOztBQUVBLHVFQUFzRTs7QUFFdEUsa0JBQWlCLDZDQUE2QztBQUM5RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBNkIsaUNBQWlDO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZLE9BQU87QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsYUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZLE9BQU8sU0FBUztBQUM1QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBTyxFQUFFO0FBQ1Q7O0FBRUEsMENBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixZQUFZLFdBQVcsWUFBWSxJQUFJLEdBQUc7QUFDdEUsd0JBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7OztBQUdILGtCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBLG9CQUFtQix3QkFBd0I7QUFDM0M7QUFDQSw2RUFBNEU7O0FBRTVFLG9FQUFtRTs7QUFFbkUsNkRBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRkFBK0U7QUFDL0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCO0FBQ3ZCO0FBQ0EsUUFBTztBQUNQO0FBQ0Esd0NBQXVDO0FBQ3ZDOztBQUVBO0FBQ0Esd0VBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQix3QkFBd0I7QUFDekM7QUFDQSwyQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLFFBQU8sVUFBVTtBQUNqQjtBQUNBO0FBQ0Esa0RBQWlELEdBQUc7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkI7Ozs7OztBQzlxQkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYSxpQ0FBaUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxjQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFjLGlDQUFpQztBQUMvQyxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsY0FBYSwwQ0FBMEM7QUFDdkQsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLHdDQUF3QztBQUNuRCxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCOzs7Ozs7QUN0TEE7O0FBRUE7QUFDQTtBQUNBLFlBQVcsaURBQWlEO0FBQzVELGFBQVksMENBQTBDO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxpREFBaUQ7QUFDNUQsWUFBVywwQ0FBMEM7QUFDckQsWUFBVyx1QkFBdUI7QUFDbEMsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsT0FBTztBQUNsQixhQUFZLDBDQUEwQztBQUN0RDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixpQ0FBaUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUM7Ozs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQjs7Ozs7O0FDaEZBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWMseUJBQXlCO0FBQ3ZDLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckIsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxlQUFjLE9BQU87QUFDckIsZUFBYyxPQUFPO0FBQ3JCLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxlQUFjLE9BQU87QUFDckIsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckIsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQixlQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckIsZUFBYyxPQUFPO0FBQ3JCLGVBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxlQUFjLE9BQU87QUFDckIsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckIsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsUUFBUTtBQUN0QixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLHlCQUF5QjtBQUN0QyxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsY0FBYSx5QkFBeUI7QUFDdEMsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYSxvRUFBb0U7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLFNBQVM7QUFDNUI7O0FBRUEsc0JBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLGVBQWU7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXNCOztBQUV0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7OztBQUdMLFdBQVUsYUFBYTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFnRDs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOzs7QUFHUDtBQUNBO0FBQ0EsTUFBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLFNBQVM7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCOzs7Ozs7QUMxdkJBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7O0FBRXRCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksZUFBZTtBQUMzQixhQUFZLE9BQU87QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCx1QkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSwyQkFBMEI7O0FBRTFCLHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxlQUFlO0FBQzNCLGFBQVksT0FBTztBQUNuQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxlQUFlO0FBQzNCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLGVBQWU7QUFDMUIsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQSxtQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZTs7QUFFZixrQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBLElBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLGVBQWU7QUFDM0IsYUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVk7QUFDWjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksZUFBZTtBQUMzQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DOztBQUVuQztBQUNBO0FBQ0EsaUJBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxlQUFlO0FBQzFCLGFBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBLG1CQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFlOztBQUVmLGtCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUQ7Ozs7OztBQ25oQkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsY0FBYztBQUN6QixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxlQUFlO0FBQzFCLFlBQVcsZUFBZTtBQUMxQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsZUFBZTtBQUMxQixZQUFXLGVBQWU7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxlQUFlO0FBQzFCLFlBQVcsZUFBZTtBQUMxQjs7O0FBR0E7QUFDQTtBQUNBLHVDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxlQUFlO0FBQzFCLFlBQVcsZUFBZTtBQUMxQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7O0FBR0Esc0JBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkI7Ozs7OztBQzVOQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixZQUFZO0FBQy9CLHdCQUF1Qjs7QUFFdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBaUIsT0FBTztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixpQkFBaUI7QUFDbEMseUJBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOzs7QUFHVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0Esa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUM7Ozs7OztBQzFZQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjOztBQUVkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDOzs7Ozs7QUN0Q0E7O0FBRUE7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDOzs7Ozs7QUNoQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Qzs7Ozs7O0FDaENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLFFBQVE7QUFDcEIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVDOzs7Ozs7QUMzREE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQStCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCOzs7Ozs7QUNyQkE7QUFDQTtBQUNBLDBCQUF5QixXQUFXO0FBQ3BDO0FBQ0Esd0JBQXVCOztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCOzs7Ozs7QUNkQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFxRDs7QUFFckQ7QUFDQSx3QkFBdUI7O0FBRXZCO0FBQ0Esd0JBQXVCO0FBQ3ZCOztBQUVBO0FBQ0EseUJBQXdCOztBQUV4Qiw0QkFBMkI7O0FBRTNCLDRCQUEyQjs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCOzs7Ozs7QUNuR0E7QUFDQSxZQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJCOzs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCOzs7Ozs7QUM5RUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckIsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFhLHVCQUF1QjtBQUNwQyxjQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZSxxQkFBcUI7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFjLFNBQVM7QUFDdkIsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFjLFNBQVM7QUFDdkIsZ0JBQWU7QUFDZjtBQUNBO0FBQ0Esb0JBQW1CLDJCQUEyQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0Esb0JBQW1CLDJCQUEyQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0Esb0JBQW1CLDJCQUEyQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIscUJBQXFCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkI7Ozs7OztBQ3ZUQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBLGdDQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQjs7Ozs7O0FDMUZBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkI7O0FBRTNCLGdFQUErRDs7QUFFL0Q7QUFDQSwyQkFBMEI7O0FBRTFCLGtDQUFpQzs7QUFFakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLDRCQUEyQjs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCOzs7Ozs7QUN0RUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxFQUFDOztBQUVELDJCOzs7Ozs7QUMvQkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVELDJCOzs7Ozs7QUMzQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQSwyQjs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZixXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBOztBQUVBLG9CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIseUNBQXlDLElBQUk7QUFDaEUsd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBOEM7QUFDOUM7O0FBRUEsNERBQTJEO0FBQzNEO0FBQ0EseUNBQXdDOztBQUV4QywyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQjs7Ozs7O0FDMUhBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCwyQjs7Ozs7O0FDekJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsMkI7Ozs7OztBQ3BCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0I7Ozs7OztBQ3BDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQixZQUFXLFFBQVE7QUFDbkIsYUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsU0FBUztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQjs7Ozs7O0FDbkVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQixZQUFXLE9BQU87QUFDbEIsWUFBVyxRQUFRO0FBQ25CLFlBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBLE1BQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBc0MsU0FBUztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQjs7Ozs7O0FDdkdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCwyQjs7Ozs7O0FDdkJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCwyQjs7Ozs7O0FDdkNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckIsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELDJCOzs7Ozs7QUNyREE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckIsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsMkI7Ozs7OztBQ2hIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLHdCQUF3QjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQW9DLE9BQU87QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMkI7Ozs7OztBQy9PQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFlLGFBQWE7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQixhQUFhO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQixhQUFhO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVULG9DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUNsTEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGtDQUFrQztBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5Qiw2QkFBNkI7QUFDdEQ7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDs7O0FBR0E7QUFDQTs7Ozs7Ozs7O0FDMUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBLDBCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQSx5QkFBd0I7QUFDeEIseURBQXdELFFBQVEsNkJBQTZCLEtBQUs7QUFDbEc7QUFDQSxzREFBcUQsUUFBUSxpQkFBaUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7Ozs7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QjtBQUM5Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDeEVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsMEJBQXlCLDZCQUE2QjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBLHlCQUF3QjtBQUN4QixtREFBa0QsUUFBUSw2QkFBNkIsS0FBSzs7QUFFNUYsc0RBQXFELFFBQVEsaUJBQWlCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUN4REE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdWQUF1VjtBQUN2VjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSwwQkFBeUIsNkJBQTZCO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUEseUJBQXdCO0FBQ3hCLG1EQUFrRCxRQUFRLDZCQUE2QixLQUFLOztBQUU1RixzREFBcUQsUUFBUSxpQkFBaUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ3hEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBLDBCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQSx5QkFBd0I7QUFDeEIsbURBQWtELFFBQVEsNkJBQTZCLEtBQUs7O0FBRTVGLHNEQUFxRCxRQUFRLGlCQUFpQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQ3hEQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBLDBCQUF5QiwrQkFBK0I7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQSx5QkFBd0I7QUFDeEIsbURBQWtELFFBQVEsNkJBQTZCLEtBQUs7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQSwwQkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUEseUJBQXdCO0FBQ3hCLG1EQUFrRCxRQUFRLDZCQUE2QixLQUFLO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DOztBQUVuQztBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQix5QkFBeUI7QUFDN0MscUJBQW9CO0FBQ3BCLFVBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQW9CLHlCQUF5QjtBQUM3QyxxQkFBb0I7QUFDcEIsVUFBUztBQUNUO0FBQ0E7QUFDQSxxQkFBb0IsMkJBQTJCO0FBQy9DLHFCQUFvQjtBQUNwQixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBOzs7Ozs7OztBQ25HQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLG1DQUFtQztBQUN0RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EscUJBQW9CO0FBQ3BCLG9EQUFtRCxRQUFRLGNBQWMsS0FBSztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNsRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMk5BQTBOLGlCQUFpQixvQkFBb0I7QUFDL1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixvQ0FBb0M7QUFDdkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLHFCQUFvQjtBQUNwQixvREFBbUQsUUFBUSw2QkFBNkIsS0FBSztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNoRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMk5BQTBOLGlCQUFpQixvQkFBb0I7QUFDL1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixvQ0FBb0M7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EscUJBQW9CO0FBQ3BCLG9EQUFtRCxRQUFRLDZCQUE2QixLQUFLO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQy9EQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLHFCQUFvQjtBQUNwQixvREFBbUQsUUFBUSxjQUFjLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ3REQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQixzREFBcUQsUUFBUSw2QkFBNkIsS0FBSztBQUMvRjtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckIsbURBQWtELFFBQVEsZUFBZSxLQUFLO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUN0Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QiwrQkFBK0I7QUFDeEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUMvREE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLG9DQUFvQztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEIsc0RBQXFELFFBQVEsNkJBQTZCLEtBQUs7QUFDL0Y7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLG1EQUFrRCxRQUFRLGVBQWUsS0FBSztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDdENBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCLHNEQUFxRCxRQUFRLDZCQUE2QixLQUFLO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQixtREFBa0QsUUFBUSxlQUFlLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ3RDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUF5QjtBQUN6QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsdURBQXNEOzs7QUFHdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQ7QUFDM0Q7QUFDQTtBQUNBLG9EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOzs7O0FBSVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDek1BO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckIsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckIsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckIsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckIsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsOENBQTZDO0FBQzdDLHNDQUFxQztBQUNyQztBQUNBO0FBQ0Esc0JBQXFCLCtFQUErRTtBQUNwRyxxQkFBb0Isa0ZBQWtGO0FBQ3RHLDBCQUF5QixpREFBaUQ7QUFDMUUsK0JBQThCLGdDQUFnQztBQUM5RCxxQkFBb0Isc0RBQXNEO0FBQzFFLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRDtBQUNqRDtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsU0FBUztBQUN6QixpQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixTQUFTO0FBQ3pCLGlCQUFnQixTQUFTO0FBQ3pCLGlCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Qsc0NBQXFDLGlCQUFpQjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFhO0FBQ2IsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsd0JBQXdCO0FBQ3BFLHVEQUFzRCx3QkFBd0I7QUFDOUUscUJBQW9CO0FBQ3BCLGlCQUFnQjtBQUNoQixpREFBZ0Qsd0JBQXdCO0FBQ3hFLDJEQUEwRCx3QkFBd0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLHNCQUFzQjtBQUNqRSxzREFBcUQsc0JBQXNCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLHdDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QyxzQkFBc0I7QUFDOUQsbURBQWtELHNCQUFzQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHVFQUF1RTtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTyxPQUFPO0FBQzlCLGlCQUFnQixPQUFPLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQThFLCtCQUErQjtBQUM3RyxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU8sY0FBYztBQUNyQyxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXNGO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLG9FQUFvRTs7QUFFL0Y7QUFDQTtBQUNBLGdDQUErQixnQ0FBZ0M7O0FBRS9EO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxnQ0FBK0IsZ0NBQWdDO0FBQy9EO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLHdCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQiw0Q0FBNEM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQ0FBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWlFLHVCQUF1QixJQUFJLHdCQUF3QjtBQUNwSCwrREFBOEQsU0FBUzs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBb0QsdUNBQXVDO0FBQzNGO0FBQ0EseUJBQXdCLGlFQUFpRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixtQ0FBbUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9IQUFtSDtBQUNuSDtBQUNBLGtCQUFpQix5R0FBeUc7QUFDMUg7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLG1DQUFtQztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixtQ0FBbUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixNQUFNO0FBQ3RCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUF5RSxjQUFjO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0Esd0JBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE1BQU07QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsTUFBTTtBQUN0QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0Esd0JBQXVCO0FBQ3ZCLHdCQUF1QjtBQUN2QixvQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esd0NBQXVDLE1BQU07QUFDN0MsdUJBQXNCO0FBQ3RCLHdCQUF1QjtBQUN2QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQTZDLE1BQU07QUFDbkQsdUJBQXNCO0FBQ3RCLHdCQUF1QjtBQUN2QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixZQUFZO0FBQy9CO0FBQ0E7O0FBRUE7Ozs7QUFJQSx3QkFBdUIsWUFBWTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7Ozs7Ozs7OztBQ241Q0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUEsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzVNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLDBCQUEwQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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Q0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDJCQUEwQjtBQUMxQiwwQkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0M7QUFDQSw4QztBQUNBLGdDO0FBQ0EsdUM7QUFDQSx3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QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzlEQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7Ozs7Ozs7O0FDekxEO0FBQ0E7QUFDQSxvQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0Esd0JBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLFNBQVM7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsd0JBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxxRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCLE1BQUs7QUFDTDtBQUNBLGlCQUFnQjtBQUNoQixNQUFLO0FBQ0w7QUFDQSxpQkFBZ0I7QUFDaEIsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQTZCLGNBQWM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXFELEVBQUU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVCwwQ0FBeUMsNkNBQTZDLGlCQUFpQixhQUFhLFNBQVM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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RUEsbUNBQWtDLHVDQUF1QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSx5Q0FBd0MsZ0JBQWdCLEVBQUU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsaURBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyxTQUFTO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLHlCQUF5QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDbkpBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQzs7Ozs7O0FDUkE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTBDLE9BQU8sTUFBTSxVQUFVLFdBQVc7QUFDNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQXlDLHdCQUF3QjtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Uzs7O0FBR1Q7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSwyQiIsImZpbGUiOiJmaXNoVG9wb0JwbW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJmaXNoVG9wb0JwbW5cIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZmlzaFRvcG9CcG1uXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDllNWJjMTAyMGVmODUyYjhjMzA5IiwiLyoqXHJcbiAqIEV4cG9ydCBmaXNoVG9wbyBhcyBDb21tb25KUyBtb2R1bGVcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL0Zpc2hUb3BvQnBtbi5qcycpO1xyXG4vL+WFvOWuuUlFOCDlvJXlhaVWTUwg5aaC5p6c5LiN6ZyA6KaB5YW85a65SUU46K+35Yig6ZmkXHJcbnJlcXVpcmUoJ3pyZW5kZXIvbGliL3ZtbC92bWwnKTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5kZXguYnBtbi5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQlBNTuWvueixoVxyXG4gKiBAY2xhc3MgZmlzaC50b3BvLkZpc2hUb3BvQnBtblxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgY2xpY2tcclxuICog6IqC54K55oiW6ICF57q/5q6155qEY2xpY2vkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tiBldmVudC50YXJnZXTkuLrnm67moIflr7nosaEgZXZlbnQudGFyZ2V0Lm1vZGVs5Li655uu5qCH5a+56LGh55qE5Lia5Yqh5pWw5o2uXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgIHRoaXMuZmlzaFRvcG9CcG1uLm9uKFwiY2xpY2tcIixmdW5jdGlvbihlKSB7XHJcbiAgICAqICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcclxuICAgICogICAgICAgICAgaWYoRmlzaFRvcG9CcG1uLkJwbW4uaXNGbG93KHRhcmdldCkpIHsgLy/liKTmlq3nsbvlnotcclxuICAgICogICAgICAgICAgICAgIHZhciBsaW5lTm9kZSA9IGUudGFyZ2V0O1xyXG4gICAgKiAgICAgICAgICAgICAgdGhhdC5maXNoVG9wb0JwbW4uYmluZExpbmVEZWxldGUobGluZU5vZGUpOyAvL+e7mee6v+auteWinuWKoOWIoOmZpOWbvuagh1xyXG4gICAgKiAgICAgICAgICAgICAgLy90b2RvXHJcbiAgICAqICAgICAgICAgIH1cclxuICAgICogICAgICB9XHJcbiAgICAqL1xyXG5cclxuICAgLyoqXHJcbiAgICAqIEBldmVudCBkYmxjbGlja1xyXG4gICAgKiDoioLngrnmiJbogIXnur/mrrXnmoTlj4zlh7vkuovku7ZcclxuICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tiBldmVudC50YXJnZXTkuLrnm67moIflr7nosaEgZXZlbnQudGFyZ2V0Lm1vZGVs5Li655uu5qCH5a+56LGh55qE5Lia5Yqh5pWw5o2uXHJcbiAgICAqXHJcbiAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICpcclxuICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgKiAgICAgICAgICAvL+WPjOWHu+W8ueWHuuiKgueCueWvueW6lOeahGpzb25cclxuICAgICogICAgICAgICAgdGhpcy5maXNoVG9wb0JwbW4ub24oXCJkYmxjbGlja1wiLGZ1bmN0aW9uKGUpIHtcclxuICAgICogICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcclxuICAgICpcclxuICAgICogICAgICAgICAgICAgIGlmKEZpc2hUb3BvQnBtbi5CcG1uLmlzRmxvdyh0YXJnZXQpKSB7XHJcbiAgICAqICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkYmxjbGljayBsaW5lXCIpO1xyXG4gICAgKiAgICAgICAgICAgICAgfVxyXG4gICAgKiAgICAgICAgICAgICAgZWxzZXtcclxuICAgICogICAgICAgICAgICAgICAgICB2YXIganNvbiA9IG5vZGVNb2RlbC5vcHRpb247XHJcbiAgICAqICAgICAgICAgICAgICAgICAgZmlzaC5wb3B1cFZpZXcoe1xyXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwidmlld3MvZGlhbG9nL0V4cG9ydEpzb25EbGcuanNcIixcclxuICAgICogICAgICAgICAgICAgICAgICAgICAgdmlld09wdGlvbjp7YnBtbkpzb246SlNPTi5zdHJpbmdpZnkoanNvbixudWxsLDQpfSxcclxuICAgICogICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKHBvcHVwLHZpZXcpIHtcclxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiT0tcIik7XHJcbiAgICAqICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAqICAgICAgICAgICAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbihtc2cpIHtcclxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmV0dXJuIHZhbHVlOiBcIiArIG1zZyk7XHJcbiAgICAqICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICogICAgICAgICAgICAgICAgICB9KTtcclxuICAgICogICAgICAgICAgICAgIH1cclxuICAgICogICAgICAgICAgfSk7XHJcbiAgICAqL1xyXG5cclxuICAgLyoqXHJcbiAgICAqIEBldmVudCBjcmVhdGVcclxuICAgICog6IqC54K55LiO57q/5q615Yib5bu65a6M5q+V55qE5LqL5Lu2XHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7YgZXZlbnQudGFyZ2V05Li655uu5qCH5a+56LGhIGV2ZW50LnRhcmdldC5tb2RlbOS4uuebruagh+WvueixoeeahOS4muWKoeaVsOaNrlxyXG4gICAgKlxyXG4gICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAqXHJcbiAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICogICAgICAgICAgdGhpcy5maXNoVG9wb0JwbW4ub24oXCJjcmVhdGVcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgKiAgICAgICAgICAgICAgaWYoRmlzaFRvcG9CcG1uLkJwbW4uaXNGbG93KGUudGFyZ2V0KSkge1xyXG4gICAgKiAgICAgICAgICAgICAgICAgIHZhciBsaW5lID0gZS50YXJnZXQ7XHJcbiAgICAqICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLov57nur/liJvlu7rlrozmr5XvvIzku45cIiArIGxpbmUuc3RhcnROb2RlLm1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSArIFwiIOiHsyBcIiArIGxpbmUuZW5kTm9kZS5tb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikpO1xyXG4gICAgKiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICogICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGUudGFyZ2V0O1xyXG4gICAgKiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi6IqC54K577yaXCIgKyBub2RlLm1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSArIFwiIOWIm+W7uuWujOavlVwiKTtcclxuICAgICogICAgICAgICAgICAgIH1cclxuICAgICogICAgICAgICAgfSk7XHJcbiAgICAqL1xyXG5cclxuICAgLyoqXHJcbiAgICAqIEBldmVudCBkZWxldGVcclxuICAgICog6IqC54K55LiO57q/5q615Yig6Zmk5a6M5q+V55qE5LqL5Lu2XHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7YgZXZlbnQudGFyZ2V05Li655uu5qCH5a+56LGhIGV2ZW50LnRhcmdldC5tb2RlbOS4uuebruagh+WvueixoeeahOS4muWKoeaVsOaNrlxyXG4gICAgKlxyXG4gICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAqXHJcbiAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICogICAgICAgICAgLy/oioLngrnliKDpmaTlrozmr5Xkuovku7ZcclxuICAgICogICAgICAgICAgdGhpcy5maXNoVG9wb0JwbW4ub24oXCJkZWxldGVcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICogICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5Yig6Zmk55qE5piv77yaXCIgKyBldmVudC50YXJnZXQpO1xyXG4gICAgKiAgICAgICAgICB9KTtcclxuICAgICovXHJcblxyXG4gICBcclxuICAgICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgICAgdmFyIEV4dGVuc2lvbkFQSSA9IHJlcXVpcmUoJy4vRXh0ZW5zaW9uQXBpJyk7XHJcbiAgICAgICB2YXIgUG9pbnQgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL1BvaW50LmpzXCIpO1xyXG4gICAgICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnenJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwnKTtcclxuICAgICAgIHZhciB6cmVuZGVyID0gcmVxdWlyZSgnenJlbmRlci9saWIvenJlbmRlcicpO1xyXG4gICAgICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcbiAgICAgICB2YXIgQnBtblV0aWwgPSByZXF1aXJlKFwiLi9CcG1uVXRpbC5qc1wiKTtcclxuICAgICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG4gICAgICAgdmFyIEJQTU5Nb2RlbCA9IHJlcXVpcmUoXCIuL21vZGVsL0JQTU5Nb2RlbC5qc1wiKTtcclxuICAgICAgIHZhciBCUE1OTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvQlBNTk5vZGUuanNcIik7XHJcbiAgICAgICB2YXIgR3JvdXBOb2RlID0gcmVxdWlyZShcIi4vbm9kZS9Hcm91cE5vZGUuanNcIik7XHJcbiAgICAgICB2YXIgT3BlcmF0aW9uTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvQnBtbk9wZXJhdGlvbk5vZGUuanNcIik7XHJcbiAgICAgICB2YXIgQnBtbkNvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4vbWFuYWdlci9CcG1uQ29ubmVjdGlvbk1hbmFnZXIuanNcIik7XHJcbiAgICAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29udGFpbi90ZXh0Jyk7XHJcbiAgICAgICB2YXIgTGluZU9wZXJhdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvTGluZU9wZXJhdGlvbk1hbmFnZXIuanNcIik7XHJcbiAgICAgICB2YXIgR3VpZGVsaW5lcyA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9HdWlkZWxpbmVzLmpzXCIpO1xyXG4gICAgICAgdmFyIHByb21pc2UgPSByZXF1aXJlKFwiYmx1ZWJpcmRcIik7XHJcbiAgICAgICB2YXIgQnBtbiA9IHJlcXVpcmUoXCIuL0JwbW4uanNcIik7XHJcbiAgICAgICB2YXIga2V5Q29kZSA9IHtFTlRFUjoxMywgRVNDQVBFOjI3fTtcclxuICAgICAgIHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvcG9seWZpbGwuanNcIik7XHJcbiAgICAgICBCcG1uVXRpbC5yZWdpc3RlckJQTU5Ob2RlKCk7XHJcblxyXG4gICAgICAgZnVuY3Rpb24gRmlzaFRvcG9CcG1uKGRvbSwgb3B0cykge1xyXG4gICAgICAgICAgIHRoaXMuaWQ7XHJcbiAgICAgICAgICAgdGhpcy5ncm91cDtcclxuICAgICAgICAgICB0aGlzLl9kb20gPSBkb207XHJcbiAgICAgICAgICAgdGhpcy5fenIgPSB6cmVuZGVyLmluaXQoZG9tLCB7XHJcbiAgICAgICAgICAgICAgIHJlbmRlcmVyOiBvcHRzLnJlbmRlcmVyIHx8ICdjYW52YXMnLFxyXG4gICAgICAgICAgICAgICBkZXZpY2VQaXhlbFJhdGlvOiBvcHRzLmRldmljZVBpeGVsUmF0aW9cclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICB0aGlzLmFsbE5vZGVzID0gW107IC8v5a2Y5pS+5omA5pyJ6IqC54K5XHJcbiAgICAgICAgICAgdGhpcy5zdWJQcm9jZXNzTm9kZSA9IFtdOyAgLy/lrZjmlL7lrZDoioLngrlcclxuICAgICAgICAgICB0aGlzLmRvbUFycmF5ID0gW107IC8v5a2Y5pS+6IqC54K555qE5L2N572u5L+h5oGv77yM5ouW5Yqo55qE5pe25YCZ55So5YiwXHJcbiAgICAgICAgICAgdGhpcy5vdmVybGFwQXJyYXkgPSBbXTsgLy8g5a2Y5pS+6IqC54K555qE5L2N572u5L+h5oGv77yM5Yik5pat6YeN5Y+g55So5Yiw77yM6Zmk5Y675LqG5a2Q5rWB56iL6YeM6Z2i55qE6IqC54K5XHJcbiAgICAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGUgPSBudWxsOyAgLy/pgInkuK3nmoToioLngrlcclxuICAgICAgICAgICB0aGlzLmlzTm9kZSA9IGZhbHNlO1xyXG4gICAgICAgICAgIHRoaXMubm93Wm9vbSA9IDE7XHJcbiAgICAgICAgICAgdGhpcy5yZWN0OyAgLy8g5a+56b2Q57q/5ZKM56e75Yqo5qGG6IqC54K5XHJcbiAgICAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlO1xyXG4gICAgICAgICAgIHRoaXMuc3RlcCA9IDA7Ly/liY3ov5vlkI7pgIDorqHmraXmlbBcclxuICAgICAgICAgICB0aGlzLnN0ZXBKc29uID0gW107Ly/lrZjmlL7mr4/mraXnmoRqc29uXHJcbiAgICAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcclxuICAgICAgICAgICB0aGlzLnNlbGVjdGVkTm9kZXMgPSBbXTtcclxuICAgICAgICAgICB0aGlzLmxpbmVPcHQgPSB7fTsgIC8v5Yid5aeL55qE57q/5q616YWN572u5L+h5oGvXHJcbiAgICAgICAgICAgdGhpcy5fYXBpID0gbmV3IEV4dGVuc2lvbkFQSSh0aGlzKTtcclxuICAgICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTsgIC8v5a2Y5pS+5omA5pyJ6IqC54K555qE6L+e5o6l54K5XHJcbiAgICAgICAgICAgdGhpcy5jb25Db250cm9sc0dyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTsgIC8v5a2Y5pS+5omA5pyJ6IqC54K555qE5o6n5Yi254K5XHJcbiAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICogQGNmZyB7Qm9vbGVhbn0gZm9yYmlkRWRpdCDmmK/lkKbnpoHnlKjnvJbovpHlip/og71cclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICB0aGlzLmZvcmJpZEVkaXQgPSBvcHRzLmZvcmJpZEVkaXQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0cy5mb3JiaWRFZGl0O1xyXG4gICAgICAgICAgIHRoaXMubW91c2VNb2RlID0gJ2RlZmF1bHQnLCAgICAgICAgICAgICAgICAgLy/lvZPliY3nlLvluIPkuIrpvKDmoIfnmoTmk43kvZzmqKHlvI/vvIxkZWZhdWx05Li65q2j5bi454K55Ye744CB5ouW5ou9562J5pON5L2c77yMZHJhZy1zZWxlY3TkuLrmoYbpgInmk43kvZxcclxuICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IEJwbW5Db25uZWN0aW9uTWFuYWdlcigpO1xyXG4gICAgICAgICAgIHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIgPSBuZXcgTGluZU9wZXJhdGlvbk1hbmFnZXIodGhpcy5jb25uZWN0aW9uTWFuYWdlcix0aGlzLl9hcGkpO1xyXG4gICAgICAgICAgIHRoaXMubW9kZWwgPSBuZXcgQlBNTk1vZGVsKHt9KTtcclxuICAgICAgICAgICB0aGlzLm1vZGVsLnNldChCcG1uLlJFU09VUkNFX0lELCB1dGlsLmdldFVVSUQoKSk7XHJcbiAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoQnBtbi5CUE1OX1RZUEUsIEJwbW4uVEVNUExBVEUpO1xyXG4gICAgICAgICAgIHRoaXMuY3Vyc29yTWFwID0ge1xyXG4gICAgICAgICAgICAgICB0bDogJ253LXJlc2l6ZScsXHJcbiAgICAgICAgICAgICAgIHRyOiAnbmUtcmVzaXplJyxcclxuICAgICAgICAgICAgICAgYmw6ICdzdy1yZXNpemUnLFxyXG4gICAgICAgICAgICAgICBicjogJ3NlLXJlc2l6ZScsXHJcbiAgICAgICAgICAgICAgIG10cjondXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQlFBQUFBVUNBTUFBQUM2ViswL0FBQUFZRkJNVkVVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUQ2VCtpTkFBQUFIM1JTVGxNQTdzVU1vWVhuRWtZWXphYVRqUWlBUUN3ZUJjRzdmdm5VTGgyWmRqTXk2RnpkN3dBQUFMSkpSRUZVR05OMWtGa093ekFJQlFIdlcvWTZTYmZjLzVZMWx0cW9saklmMkJvaEJBOHFVMDk2eGVWNUwvK3VGSDRTcHNHQUdTS21UaEN5TXo2NFVkMzhUZTBtZUlwSGNUUDFuZFRLdnF6U1V1UUlMRk1RSkFVd0luZ0JMQ2QwVXJKaFNSR3F6SEhVM0ZjSEJWTW9rcXhTMzhZTkdRTFFiaG1nWloyM3NWRVhuWFZtUzQ2N0ZxMDg5MlNTTGFXNVNIck45cno5Ylh2OUVISUIrRTlwZE1HN1lzNDhaMmNqeG83RkwzazhrUElFMTN3QW1FVUlPMk1MOVlNQUFBQUFTVVZPUks1Q1lJST0pIDEwIDEwLCBhdXRvJ1xyXG4gICAgICAgICAgIH07IC8vIOiKgueCueaOp+WItueCuem8oOagh+S/oeaBryjkuIrlt6bvvIzkuIrlj7PvvIzkuIvlt6bvvIzkuIvlj7PvvIzml4vovawpXHJcbiAgICAgICAgICAgdGhpcy5jdXJzb3JNYXBzID0gW1xyXG4gICAgICAgICAgICAgICAnbi1yZXNpemUnLFxyXG4gICAgICAgICAgICAgICAnbmUtcmVzaXplJyxcclxuICAgICAgICAgICAgICAgJ2UtcmVzaXplJyxcclxuICAgICAgICAgICAgICAgJ3NlLXJlc2l6ZScsXHJcbiAgICAgICAgICAgICAgICdzLXJlc2l6ZScsXHJcbiAgICAgICAgICAgICAgICdzdy1yZXNpemUnLFxyXG4gICAgICAgICAgICAgICAndy1yZXNpemUnLFxyXG4gICAgICAgICAgICAgICAnbnctcmVzaXplJ1xyXG4gICAgICAgICAgIF1cclxuICAgICAgICAgICB0aGlzLmN1cnNvck9mZnNldCA9IHtcclxuICAgICAgICAgICAgICAgdHI6IDEsXHJcbiAgICAgICAgICAgICAgIGJyOiAzLFxyXG4gICAgICAgICAgICAgICBibDogNSxcclxuICAgICAgICAgICAgICAgdGw6IDdcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcclxuICAgICAgIH1cclxuXHJcbiAgICAgICB2YXIgZmlzaFRvcG9Qcm90byA9IEZpc2hUb3BvQnBtbi5wcm90b3R5cGU7XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDojrflj5YgZmlzaFRvcG8g5a6e5L6L5a655Zmo55qEIGRvbSDoioLngrlcclxuICAgICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmdldERvbSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgIHJldHVybiB0aGlzLl9kb207XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5nZXRaciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgIHJldHVybiB0aGlzLl96cjtcclxuICAgICAgIH07XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIOiOt+WPliBmaXNoVG9wbyDlrp7kvovlrrnlmajnmoTlrr3luqbjgIJcclxuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5nZXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgIHJldHVybiB0aGlzLl96ci5nZXRXaWR0aCgpO1xyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIOiOt+WPliBmaXNoVG9wbyDlrp7kvovlrrnlmajnmoTpq5jluqbjgIJcclxuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5nZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICByZXR1cm4gdGhpcy5fenIuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIOW9k+WJjeWunuS+i+aYr+WQpuW3sue7j+iiq+mHiuaUvuOAglxyXG4gICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5pc0Rpc3Bvc2VkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIERpc3Bvc2UgaW5zdGFuY2VcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICB0aGlzLl96ci5kaXNwb3NlKCk7XHJcblxyXG4gICAgICAgICAgIGluc3RhbmNlc1t0aGlzLmlkXSA9IG51bGw7XHJcbiAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIOiwg+aVtOWwuuWvuCAg5Zyo56qX5Y+j5aSn5bCP5Y+R55Sf5pS55Y+Y5pe26ZyA6KaB5omL5bel6LCD55SoXHJcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGgg5a695bqmXHJcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IOmrmOW6plxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICAgICB0aGlzLmdldERvbSgpLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xyXG4gICAgICAgICAgIHRoaXMuZ2V0RG9tKCkuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICAgICB0aGlzLl96ci5yZXNpemUoKTtcclxuICAgICAgICAgICB0aGlzLl96ci5yZW1vdmUodGhpcy5ncm91cCk7XHJcbiAgICAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgICAgaWYgKHRoaXMub3B0cy5zaG93R3JpZExpbmUgPT0gdHJ1ZSB8fCB0aGlzLm9wdHMuc2hvd0dyaWRMaW5lID09IFwidHJ1ZVwiKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMuZ3JpZExpbmUoMC4yKTtcclxuICAgICAgICAgICAgICAgdGhpcy5fenIuYWRkKHRoaXMuZ3JvdXApO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqIEBwcml2YXRlIOWIneWni+WMliAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5pbml0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgICAgaWYgKHRoaXMub3B0cy5zaG93R3JpZExpbmUgPT0gdHJ1ZSB8fCB0aGlzLm9wdHMuc2hvd0dyaWRMaW5lID09IFwidHJ1ZVwiKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMuZ3JpZExpbmUoMC4yKTtcclxuICAgICAgICAgICAgICAgdGhpcy5fenIuYWRkKHRoaXMuZ3JvdXApO1xyXG4gICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgLy9tb3VzZXVwIOS8muWcqOWQhOS4qm5vZGXmiJbnur/nmoTngrnlh7vkuovku7bkuYvliY3miafooYwgIOWcqOmAieS4reiKgueCueaIlue6v+WJjSDlhYjmuIXnqbrpgInkuK3mlYjmnpxcclxuICAgICAgICAgICB0aGlzLl96ci5vbihcIm1vdXNldXBcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAvLyAxLiDmuIXnqbroioLngrnnmoTpgInkuK3mlYjmnpxcclxuICAgICAgICAgICAgICAgLy8gdGhpcy5fcmVtb3ZlT3BlcmF0aW9uTm9kZSgpO1xyXG4gICAgICAgICAgICAgICAvLyAyLiDngrnlh7vnmoTnur8g77yM5YiZ55u05o6l6L+U5ZueXHJcbiAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IGUudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuY29ubmVjdG9yIGluc3RhbmNlb2YgQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jbGVhclNlbGVjdENvbigpO1xyXG4gICAgICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuX2lzTGluZU9wZXJhdGlvbkljb24gJiYgc2hhcGUuX2lzTGluZU9wZXJhdGlvbkljb24gPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAvL+a0vuWPkeS4jeaYr+iKgueCueaIlue6vyDnmoTnlLvluIPngrnlh7vkuovku7ZcclxuICAgICAgICAgICB0aGlzLl96ci5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgLy8g5aaC5p6c54K55Ye75LqG5o6n5Yi254K577yM5YiZ5LiN5Lya5Y+W5raI6YCJ5Lit54q25oCBKOaOp+WItueCueS4jeWcqOiKgueCueiMg+WbtOWGhSlcclxuICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IHt9O1xyXG4gICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRhcmdldC50eXBlO1xyXG4gICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gJ0Nvbm5lY3RDb250cm9sTGluZScgJiYgdHlwZSAhPT0gJ0Nvbm5lY3RDb250cm9sJykge1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlQ29ubmVjdG9yUG9pbnQoKTtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvckNvbnRyb2woKTtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZU9wZXJhdGlvbk5vZGUoKTtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIuaGlkZUFsbExpbmVPcGVyYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IGUudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgLy/ngrnlh7vnmoTnur9cclxuICAgICAgICAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5wYXJlbnQgJiYgc2hhcGUucGFyZW50LnJlc291cmNlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJjbGlja1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgdGhpcy5fenIub24oXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgaWYgKHRoaXMubW91c2VNb2RlID09PSAnZHJhZy1zZWxlY3QnICYmICghZS50YXJnZXQgfHwgKGUudGFyZ2V0ICYmIGUudGFyZ2V0LnR5cGUgPT09ICdncmlkLWxpbmUnKSB8fCAoZS50YXJnZXQgJiYgZS50YXJnZXQubmFtZSA9PT0gJ3N1YnByb2Nlc3MtcmVjdCcpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ1NlbGVjdChlLnRhcmdldCwgZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgdGhpcy5vbignY29uUG9pbnRzR3JvdXA6Y2xpY2snLCBmdW5jdGlvbihhcmd1bWVudCkge1xyXG4gICAgICAgICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmJpbmRPcGVyYXRpb24oYXJndW1lbnQubGluZU5vZGUpO1xyXG4gICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgIH07XHJcblxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5fcmVsZWFzZVNlbGVjdE5vZGUgPSBmdW5jdGlvbiAoZmxhZykge1xyXG4gICAgICAgICAgIGlmICh0aGlzLmRyYWdTZWxlY3RSZWN0KSB7XHJcbiAgICAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMuZHJhZ1NlbGVjdFJlY3QuY2hpbGRyZW4oKS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgIHJldHVybiB2Lm5hbWUgIT09IFwiR1JPVVBfUkVDVF9OQU1FXCI7XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICB2YXIgc3RhcnRYID0gdGhpcy5kcmFnU2VsZWN0UmVjdC5wb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IHRoaXMuZHJhZ1NlbGVjdFJlY3QucG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVggPSBCcG1uLmlzRmxvdyhpdGVtKSA/IDAgOiBpdGVtLmdldFJlY3QoKS54O1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIG5vZGVZID0gQnBtbi5pc0Zsb3coaXRlbSkgPyAwIDogaXRlbS5nZXRSZWN0KCkueTtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3QucmVtb3ZlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3JpZ2luUGFyZW50ICYmICFmbGFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vcmlnaW5QYXJlbnQuYWRkKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl96ci5hZGQoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoIUJwbW4uaXNGbG93KGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3JpZ2luUGFyZW50ICYmICFmbGFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0UG9zaXRpb24obm9kZVgrc3RhcnRYLUJwbW5VdGlsLnBhcmVudFgoaXRlbS5vcmlnaW5QYXJlbnQpLCBub2RlWStzdGFydFktQnBtblV0aWwucGFyZW50WShpdGVtLm9yaWdpblBhcmVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0UG9zaXRpb24obm9kZVgrc3RhcnRYLCBub2RlWStzdGFydFkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3JpZ2luUGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vcmlnaW5QYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3Qub2ZmKFwibW91c2Vkb3duXCIpO1xyXG4gICAgICAgICAgICAgICB0aGlzLl96ci5yZW1vdmUodGhpcy5kcmFnU2VsZWN0UmVjdCk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfVxyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uX2RyYWdTZWxlY3QgPSBmdW5jdGlvbiAobm9kZSwgeCwgeSkge1xyXG4gICAgICAgICAgIHRoaXMuX3JlbGVhc2VTZWxlY3ROb2RlKCk7ICAvL+i/mOWOn+mAieS4reeahOiKgueCuVxyXG4gICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3QgPSBuZXcgR3JvdXBOb2RlKHtcclxuICAgICAgICAgICAgICAgc2hhcGU6eyB3aWR0aDogMCwgaGVpZ2h0OiAwfSxcclxuICAgICAgICAgICAgICAgcG9zaXRpb246W3gsIHldLFxyXG4gICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgbGluZURhc2g6WzIsMl0sXHJcbiAgICAgICAgICAgICAgICAgICBmaWxsOiBcInJnYmEoMjM5LDIyMiwyMjEsMC43KVwiLFxyXG4gICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAncmdiYSgwLCAwLCAwLCAxKSdcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3QudHlwZSA9IFwiZHJhZ1NlbGVjdFwiO1xyXG4gICAgICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzLmRyYWdTZWxlY3RSZWN0KTtcclxuICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3RSZWN0Lm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMubmV3RHJhZyh0aGlzLmRyYWdTZWxlY3RSZWN0LCBlLmV2ZW50LmNsaWVudFgsIGUuZXZlbnQuY2xpZW50WSk7XHJcbiAgICAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICAgICB2YXIgbW92ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGV2ZW50Lm9mZnNldFggLSB4KSA8PSAxICYmIE1hdGguYWJzKGV2ZW50Lm9mZnNldFkgLSB5KSA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdmFyIHBvc1ggPSB4IDw9IGV2ZW50Lm9mZnNldFggPyB4IDogZXZlbnQub2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgdmFyIHBvc1kgPSB5IDw9IGV2ZW50Lm9mZnNldFkgPyB5IDogZXZlbnQub2Zmc2V0WTtcclxuICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5hYnMoZXZlbnQub2Zmc2V0WCAtIHgpO1xyXG4gICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5hYnMoZXZlbnQub2Zmc2V0WSAtIHkpO1xyXG4gICAgICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3RSZWN0LnNldFByb3BlcnRpZXMoe3NoYXBlOiB7d2lkdGg6d2lkdGgsIGhlaWdodDogaGVpZ2h0fSwgcG9zaXRpb246IFtwb3NYLCBwb3NZXX0pO1xyXG4gICAgICAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgICAgICAgICB0aGlzLl96ci5vbignbW91c2Vtb3ZlJywgbW92ZUhhbmRsZXIpO1xyXG5cclxuICAgICAgICAgICB2YXIgZW5kRHJhZ0hhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgdGhpcy5fenIub2ZmKCdtb3VzZW1vdmUnLCBtb3ZlSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3pyLm9mZignbW91c2V1cCcsIGVuZERyYWdIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgdGhpcy5fenIub2ZmKFwiZ2xvYmFsb3V0XCIsIGVuZERyYWdIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGV2ZW50Lm9mZnNldFggLSB4KSA8PSAxICYmIE1hdGguYWJzKGV2ZW50Lm9mZnNldFkgLSB5KSA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVDbGlja0hhbmRsZXIobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoJ3NlbGVjdE5vZGUnLCB7dGFyZ2V0OiBub2RlLnBhcmVudH0pO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHZhciB0cyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgIHZhciBzdGFydFggPSB0aGlzLmRyYWdTZWxlY3RSZWN0LnBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICB2YXIgc3RhcnRZID0gdGhpcy5kcmFnU2VsZWN0UmVjdC5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5kcmFnU2VsZWN0UmVjdC5vcHRpb25zLnNoYXBlLndpZHRoO1xyXG4gICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5kcmFnU2VsZWN0UmVjdC5vcHRpb25zLnNoYXBlLmhlaWdodDtcclxuICAgICAgICAgICAgICAgdmFyIGNudCA9IDA7XHJcbiAgICAgICAgICAgICAgIHRoaXMuYWxsTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBpdGVtLmdldFJlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgIHZhciBub2RlV2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIG5vZGVIZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgIHZhciBub2RlWCA9IGl0ZW0ucGFyZW50ID8gcmVjdC54K0JwbW5VdGlsLnBhcmVudFgoaXRlbS5wYXJlbnQpIDogcmVjdC54O1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIG5vZGVZID0gaXRlbS5wYXJlbnQgPyByZWN0LnkrQnBtblV0aWwucGFyZW50WShpdGVtLnBhcmVudCkgOiByZWN0Lnk7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoKChCcG1uLmlzRXZlbnQoaXRlbSkgfHwgQnBtbi5pc0dhdGV3YXkoaXRlbSkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgbm9kZVgtbm9kZVdpZHRoID49IHN0YXJ0WCAmJiBub2RlWS1ub2RlV2lkdGggPj0gc3RhcnRZICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgbm9kZVgrbm9kZVdpZHRoIDw9IHN0YXJ0WCt3aWR0aCAmJiBub2RlWStub2RlV2lkdGggPD0gc3RhcnRZK2hlaWdodCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAoIShCcG1uLmlzRXZlbnQoaXRlbSkgfHwgQnBtbi5pc0dhdGV3YXkoaXRlbSkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgbm9kZVgtbm9kZVdpZHRoLzIgPj0gc3RhcnRYICYmIG5vZGVZLW5vZGVIZWlnaHQvMiA+PSBzdGFydFkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICBub2RlWCtub2RlV2lkdGgvMiA8PSBzdGFydFgrd2lkdGggJiYgbm9kZVkrbm9kZUhlaWdodC8yIDw9IHN0YXJ0WStoZWlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uc2xvdEV2ZW50ICYmIGl0ZW0uc2xvdEV2ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBpdGVtLnNsb3RFdmVudC5sZW5ndGg7IG4rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RFdmVudFBvc2l0aW9uMiA9IFtpdGVtLnNsb3RFdmVudFtuXS5wb3NpdGlvblswXSArIChub2RlWC1zdGFydFgpIC0genJVdGlsLmNsb25lKGl0ZW0ucG9zaXRpb25bMF0pIC0gaXRlbS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDIsIGl0ZW0uc2xvdEV2ZW50W25dLnBvc2l0aW9uWzFdICsgKG5vZGVZLXN0YXJ0WSkgLSB6clV0aWwuY2xvbmUoaXRlbS5wb3NpdGlvblsxXSkgLSBpdGVtLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAvIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zbG90RXZlbnRbbl0uYXR0cihcInBvc2l0aW9uXCIsIHNsb3RFdmVudFBvc2l0aW9uMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKGl0ZW0uc2xvdEV2ZW50W25dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vcmlnaW5QYXJlbnQgPSBpdGVtLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5wYXJlbnQucmVtb3ZlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRzLl96ci5yZW1vdmUoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIHRzLmRyYWdTZWxlY3RSZWN0LmFkZChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB0cy5zZWxlY3RlZE5vZGVzLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRQb3NpdGlvbihub2RlWC1zdGFydFgsIG5vZGVZLXN0YXJ0WSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgY250Kys7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICBpZiAoIWNudCkge1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnU2VsZWN0UmVjdC5vZmYoXCJtb3VzZWRvd25cIik7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLl96ci5yZW1vdmUodGhpcy5kcmFnU2VsZWN0UmVjdCk7XHJcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3RSZWN0LmNoaWxkT2ZOYW1lKFwiR1JPVVBfUkVDVF9OQU1FXCIpLmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogXCJyZ2JhKDAsMCwwLDApXCJcclxuICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnROb2RlID0gdHMuZHJhZ1NlbGVjdFJlY3QuY2hpbGRyZW4oKS5maW5kKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2LmlkID09PSBpdGVtLnN0YXJ0Tm9kZS5pZDtcclxuICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kTm9kZSA9IHRzLmRyYWdTZWxlY3RSZWN0LmNoaWxkcmVuKCkuZmluZChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5pZCA9PT0gaXRlbS5lbmROb2RlLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydE5vZGUgJiYgZW5kTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0cy5fenIucmVtb3ZlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0cy5kcmFnU2VsZWN0UmVjdC5hZGQoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKGl0ZW0uc3RhcnROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgICAgICAgICB0aGlzLl96ci5vbignbW91c2V1cCcsIGVuZERyYWdIYW5kbGVyKTtcclxuICAgICAgICAgICB0aGlzLl96ci5vbihcImdsb2JhbG91dFwiLCBlbmREcmFnSGFuZGxlcik7XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDmoLnmja7kvKDov4fmnaXnmoTlgLwgIOiuvue9ruiKgueCueaooeWei1xyXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNoYXBlICDoioLngrnmiJbnur9cclxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb24g5qih5Z6L5pWw5o2uXHJcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGgg5a695bqmKOS7heeUqOS6juiwg+aVtOeUu+W4g+Wkp+WwjylcclxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQg6auY5bqmKOS7heeUqOS6juiwg+aVtOeUu+W4g+Wkp+WwjylcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5zZXRTaGFwZU1vZGVsID0gZnVuY3Rpb24oc2hhcGUsIG9wdGlvbiwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgICAgIGlmICh0aGlzLmZvcmJpZEVkaXQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBpZiAoQnBtbi5pc1RlbXBsYXRlKHNoYXBlKSkge1xyXG4gICAgICAgICAgICAgICB0aGlzLm1vZGVsLm1lcmdlT3B0aW9uKG9wdGlvbik7XHJcbiAgICAgICAgICAgICAgIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9IGVsc2UgaWYgKEJwbW4uaXNGbG93KHNoYXBlKSkge1xyXG4gICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnNldE1vZGVsKHNoYXBlLCBvcHRpb24pO1xyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIGlmIChzaGFwZS5icG1uSW5mby5uYW1lLmluZGV4T2YoXCJUYXNrXCIpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgb3B0aW9uLnByb3BlcnRpZXMucG9zaXRpb24gPSAnY2VudGVyJztcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBpZiAoc2hhcGUuYnBtbkluZm8ubmFtZSA9PT0gJ0NvbW1lbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICBvcHRpb24ucHJvcGVydGllcy5wb3NpdGlvbiA9ICdsZWZ0JztcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBzaGFwZS5zZXRNb2RlbChvcHRpb24pO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDojrflj5bniLZcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5fZ2V0UGFyZW50WnIgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgdmFyIHBhcmVudFpyID0gbnVsbDtcclxuICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICBwYXJlbnRaciA9IG5vZGUucGFyZW50O1xyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIHBhcmVudFpyID0gdGhpcy5fenI7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHJldHVybiBwYXJlbnRacjtcclxuICAgICAgIH1cclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIOa4heepuuW9k+WJjeWunuS+i++8jOS8muenu+mZpOWunuS+i+S4reaJgOacieeahOiKgueCueS4jue6v1xyXG4gICAgICAgICogQG1ldGhvZCBjbGVhclxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmNsZWFyID0gZnVuY3Rpb24oaXNOb0NvdW50KSB7XHJcbiAgICAgICAgICAgdGhpcy5hbGxOb2RlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICB0aGlzLnN1YlByb2Nlc3NOb2RlID0gW107XHJcblxyXG4gICAgICAgICAgIHRoaXMuZG9tQXJyYXkgPSBbXTtcclxuXHJcbiAgICAgICAgICAgdGhpcy5vdmVybGFwQXJyYXkgPSBbXTtcclxuXHJcbiAgICAgICAgICAgdGhpcy5oaWRlQ29ubmVjdG9yUG9pbnQoKTsgIC8v6ZqQ6JeP5omA5pyJ6IqC54K55LiK55qE6L+e5o6l54K5XHJcblxyXG4gICAgICAgICAgIHRoaXMuc2VsZWN0ZWROb2RlID0gbnVsbDtcclxuICAgICAgICAgICB0aGlzLnJlY3QgPSBudWxsO1xyXG4gICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycyA9IFtdO1xyXG4gICAgICAgICAgIHRoaXMuX3pyLmNsZWFyKCk7XHJcbiAgICAgICAgICAgdGhpcy5fenIuYWRkKHRoaXMuZ3JvdXApOyAvLyDnlLvnvZHmoLznur8gIOS7o+eggeaUvui/meavlOi+g+aBtuW/gyDlkI7pnaLmlLlcclxuICAgICAgICAgICBpZiAoaXNOb0NvdW50ICE9IHRydWUpIHtcclxuICAgICAgICAgICAgICAgdGhpcy5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDorr7nva7mmK/lkKbmmL7npLrnvZHnu5znur9cclxuICAgICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGlzRm9yYmlkZGVuIOaYr+WQpuaYvuekuue9kee7nOe6v1xyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmZvcmJpZEdyaWRMaW5lID0gZnVuY3Rpb24oaXNGb3JiaWRkZW4pIHtcclxuICAgICAgICAgICB0aGlzLm9wdHMuc2hvd0dyaWRMaW5lID0gIWlzRm9yYmlkZGVuO1xyXG4gICAgICAgICAgIGlmIChpc0ZvcmJpZGRlbiA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3pyLnJlbW92ZSh0aGlzLmdyb3VwKTtcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICB0aGlzLl96ci5yZW1vdmUodGhpcy5ncm91cCk7XHJcbiAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgICAgICAgICB0aGlzLmdyaWRMaW5lKDAuMik7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzLmdyb3VwKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICog5a+85Ye6anNvblxyXG4gICAgICAgICogQHJldHVybiB7c3RyaW5nfSBqc29u5a2X56ym5LiyXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8udG9Kc29uID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIEJwbW5VdGlsLnRvSnNvbih0aGlzLm1vZGVsLCB0aGlzLmFsbE5vZGVzLCB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnMpO1xyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIOWvvOWFpWpzb25cclxuICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30ganNvbiBqc29u5qC85byP55qE5a2X56ym5LiyXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uZnJvbUpzb24gPSBmdW5jdGlvbihqc29uKSB7XHJcbiAgICAgICAgICAgQnBtblV0aWwuZnJvbUpzb24odGhpcywganNvbik7XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8v6IOM5pmv572R5qC857q/XHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmdyaWRMaW5lID0gZnVuY3Rpb24ob3BhY2l0eSkge1xyXG4gICAgICAgICAgIHZhciBwaXhlbCA9IHRoaXMub3B0cy5ncmlkTGluZVNwYWNpbmc7XHJcbiAgICAgICAgICAgdmFyIHdpZHRoTGVuID0gcGFyc2VJbnQodGhpcy5nZXRXaWR0aCgpIC8gcGl4ZWwpO1xyXG4gICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDw9IHdpZHRoTGVuOyB4KyspIHtcclxuICAgICAgICAgICAgICAgdmFyIGxpbmVYID0gbmV3IGdyYXBoaWMuTGluZSh7XHJcbiAgICAgICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHgxOiB4ICogcGl4ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgeTE6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgeDI6IHggKiBwaXhlbCxcclxuICAgICAgICAgICAgICAgICAgICAgICB5MjogdGhpcy5nZXRIZWlnaHQoKVxyXG4gICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgbGluZURhc2g6IFsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5XHJcbiAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgejogLTEsXHJcbiAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIGxpbmVYLnR5cGUgPSBcImdyaWQtbGluZVwiO1xyXG4gICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChsaW5lWCk7XHJcbiAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICB2YXIgaGVpZ2h0TGVuID0gcGFyc2VJbnQodGhpcy5nZXRIZWlnaHQoKSAvIHBpeGVsLCBwaXhlbCk7XHJcbiAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPD0gaGVpZ2h0TGVuOyB5KyspIHtcclxuICAgICAgICAgICAgICAgdmFyIGxpbmVZID0gbmV3IGdyYXBoaWMuTGluZSh7XHJcbiAgICAgICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHgxOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHkxOiB5ICogcGl4ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgeDI6IHRoaXMuZ2V0V2lkdGgoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICB5MjogeSAqIHBpeGVsXHJcbiAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaDogWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcclxuICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICB6OiAtMSxcclxuICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICBjdXJzb3I6ICdkZWZhdWx0J1xyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgbGluZVkudHlwZSA9IFwiZ3JpZC1saW5lXCI7XHJcbiAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKGxpbmVZKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uX3JlbW92ZU9wZXJhdGlvbk5vZGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICBpZiAodGhpcy5vcGVyYXRpb25Ob2RlKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3pyLnJlbW92ZSh0aGlzLm9wZXJhdGlvbk5vZGUpO1xyXG4gICAgICAgICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUuY2xlYW51cCgpO1xyXG4gICAgICAgICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH1cclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIOmAmui/h+eVjOmdouaLluWKqCDlop7liqDoioLngrlcclxuICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpdGVtVHlwZSDliJvlu7roioLngrnnmoTnsbvlnovvvIjlt7LmnInpooTlrprkuYnnsbvlnovljIXmi6xTdGFydE5vbmVFdmVudOOAgUVuZE5vbmVFdmVudOOAgVVzZXJUYXNr44CBTWFudWFsVGFza+OAgVNjcmlwdFRhc2vjgIFNYWlsVGFza+OAgUNhdGNoVGltZXJFdmVudOOAgUNhdGNoU2lnbmFsRXZlbnTjgIFUaHJvd1NpZ25hbEV2ZW5044CBSW5jbHVzaXZlR2F0ZXdheeOAgUV4Y2x1c2l2ZUdhdGV3YXnjgIFQYXJhbGxlbEdhdGV3YXnjgIFTdWJQcm9jZXNz77yJXHJcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geCAgICAgICAg6IqC54K55Yib5bu655qEeOWdkOagh1xyXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHkgICAgICAgIOiKgueCueWIm+W7uueahHnlnZDmoIdcclxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOmAiemhuVxyXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm5hbWVdIOiKgueCueS4i+mdouaYvuekuuWQjeensFxyXG4gICAgICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMub3BlcmF0aW9uSWNvbnNdIOiuvue9rumAieS4reiKgueCueaXtiDmmL7npLrnmoTmk43kvZzlsI/lm77moIfvvIwg6buY6K6k5o+Q5L6b5LqGIOWIoOmZpOOAgeebtOe6v+OAgeaKmOe6v+OAgeabsue6vzTnp43lm77moIfvvIzkuZ/lj6/ku6Xoh6rlrprlm77moIcgZWcuXHJcbiAgICAgICAgKiA8cHJlPlxyXG4gICAgICAgICogICAgICAgICAgb3BlcmF0aW9uSWNvbnM6IFt7IG5hbWU6ICdERUwnIH0sXHJcbiAgICAgICAgKiAgICAgICAgICAgICAgeyBuYW1lOiAnU1RSQUlHSFQnIH0sXHJcbiAgICAgICAgKiAgICAgICAgICAgICAgeyBuYW1lOiAnSkFHR0VEJyB9LFxyXG4gICAgICAgICogICAgICAgICAgICAgIHsgbmFtZTogJ0NVUlZFJyB9LFxyXG4gICAgICAgICogICAgICAgICAgICAgIHtcclxuICAgICAgICAqICAgICAgICAgICAgICAgICAgbmFtZTogXCJjdXN0b20xXCIsXHJcbiAgICAgICAgKiAgICAgICAgICAgICAgICAgIGljb25QYXRoOiBcImltZy9ob3N0LnBuZ1wiLFxyXG4gICAgICAgICogICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oZSkgeyBhbGVydChlLmRhdGEubmFtZSArIFwiIGNsaWNrZWRcIikgfSAgLy9lLm5vZGXmmK/lvZPliY3nmoToioLngrlcclxuICAgICAgICAqICAgICAgICAgICAgICB9XHJcbiAgICAgICAgKiAgICAgICAgICBdXHJcbiAgICAgICAgKiA8L3ByZT5cclxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyRGF0YSDnlKjmiLfkvKDpgJLnmoTkuJrliqHmlbDmja5cclxuICAgICAgICAqXHJcbiAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgKlxyXG4gICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICogICAgICBmaXNoVG9wby5hZGROb2RlKGl0ZW1UeXBlLCB4LCB5LCB7XHJcbiAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBpdGVtVHlwZSwgICAvL+iKgueCueeahOWQjeensFxyXG4gICAgICAgICogICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWNvbnM6W3tuYW1lOidERUwnfSx7IG5hbWU6ICdTVFJBSUdIVCcgfSx7bmFtZTonSkFHR0VEJ30seyBuYW1lOiAnQ1VSVkUnIH1dLFxyXG4gICAgICAgICogICAgICAgICAgICAgICAgICAgICAgLy8g5aKe5Yqg6IqC54K55pON5L2c5Zu+5qCHIOS4iumdouWIhuWIq+aYr1wi5Yig6Zmk44CB55u057q/44CB5oqY57q/44CB5puy57q/XCLvvIxcclxuICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgIC8vIOS5n+WPr+S7peWinuWKoOiHquWumuWbvuaghyDlpoJ7bmFtZTogXCJjdXN0b20xXCIsIGljb25QYXRoOiBcImltZy9ob3N0LnBuZ1wiLCBjYWxsYmFjazogZnVuY3Rpb24oZSkgeyBhbGVydChlLmRhdGEubmFtZSArIFwiIGNsaWNrZWRcIikgfX0gLy9lLm5vZGXmmK/lvZPliY3nmoToioLngrlcclxuICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOntidXNpbmVzc0RhdGE6J+aIkeaYr+S4muWKoeaVsOaNrizpgJrov4dCcG1uLmdldFVzZXJEYXRh5Y+v6I635Y+WJ31cclxuICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgIC8vIOWinuWKoOiKgueCueeahOiHquWumuS5ieS4muWKoe+8jOWPr+S7pemAmui/h0JwbW4uZ2V0VXNlckRhdGEobm9kZSnojrflj5ZcclxuICAgICAgICAqICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uYWRkTm9kZSA9IGZ1bmN0aW9uKGl0ZW1UeXBlLCB4LCB5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgIC8v5Yik5pat5piv5ZCm5Zyo6IyD5Zu05YaFXHJcbiAgICAgICAgICAgaWYgKHggPj0gMCAmJiB5ID49IDApIHtcclxuICAgICAgICAgICAgICAgdmFyIG1vZGVsID0gbmV3IEJQTU5Nb2RlbCh7fSk7XHJcbiAgICAgICAgICAgICAgIG1vZGVsLnNldChCcG1uLkJQTU5fVFlQRSwgaXRlbVR5cGUpO1xyXG4gICAgICAgICAgICAgICBtb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0XCIsIHt4OiB4LCB5OiB5fSk7XHJcbiAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICBtb2RlbC5zZXQoXCJwcm9wZXJ0aWVzXCIsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJBc3luYygnYmVmb3JlQ3JlYXRlTm9kZScsIHt0YXJnZXQ6IG51bGx9LCBtb2RlbCkudGhlbihmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hc3luY0FkZE5vZGVCeU1vZGVsKG1vZGVsLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICAvL+a3u+WKoOS4gOS4qua1geeoi+WbvueJh+autVxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5hZGRTaGFwZXMgPSBmdW5jdGlvbihjaGlsZFNoYXBlcywgeCwgeSkge1xyXG4gICAgICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMCkge1xyXG4gICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIC8v5YWI5ou/5Yiw6ICB55qE55S75biDanNvbuaVsOaNrlxyXG4gICAgICAgICAgIHZhciBjbG9uZUNoaWxkU2hhcGVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjaGlsZFNoYXBlcykpO1xyXG4gICAgICAgICAgIHZhciBjYW52YXNEYXRhID0gdGhpcy50b0pzb24oKTtcclxuICAgICAgICAgICB2YXIgb2xkQ2hpbGRTaGFwZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNhbnZhc0RhdGEuY2hpbGRTaGFwZXMpKTtcclxuXHJcbiAgICAgICAgICAgLy/orqHnrpflh7ropoHmt7vliqBzaGFwZXPnmoTlrr3pq5hcclxuICAgICAgICAgICB2YXIgYWxsVXBwZXJMZWZ0WCA9IFtdLCBhbGxVcHBlckxlZnRZID0gW10sIGFsbExvd2VyUmlnaHRYID0gW10sIGFsbExvd2VyUmlnaHRZID0gW107XHJcbiAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZUNoaWxkU2hhcGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBub2RlID0gY2xvbmVDaGlsZFNoYXBlc1tpXTtcclxuICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RlbmNpbC50eXBlICE9PSBCcG1uLlNFUVVFTkNFX0ZMT1cpIHtcclxuICAgICAgICAgICAgICAgICAgIGFsbFVwcGVyTGVmdFgucHVzaChub2RlLmJvdW5kcy51cHBlckxlZnQueCk7XHJcbiAgICAgICAgICAgICAgICAgICBhbGxVcHBlckxlZnRZLnB1c2gobm9kZS5ib3VuZHMudXBwZXJMZWZ0LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgYWxsTG93ZXJSaWdodFgucHVzaChub2RlLmJvdW5kcy5sb3dlclJpZ2h0LngpO1xyXG4gICAgICAgICAgICAgICAgICAgYWxsTG93ZXJSaWdodFkucHVzaChub2RlLmJvdW5kcy5sb3dlclJpZ2h0LnkpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHZhciBtaW5YID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgYWxsVXBwZXJMZWZ0WCk7XHJcbiAgICAgICAgICAgdmFyIG1pblkgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBhbGxVcHBlckxlZnRZKTtcclxuICAgICAgICAgICB2YXIgbWF4WCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGFsbExvd2VyUmlnaHRYKTtcclxuICAgICAgICAgICB2YXIgbWF4WSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGFsbExvd2VyUmlnaHRZKTtcclxuICAgICAgICAgICB2YXIgc2hhcGVzV2lkdGggPSBtYXhYIC0gbWluWDtcclxuICAgICAgICAgICB2YXIgc2hhcGVzSGVpZ2h0ID0gbWF4WSAtIG1pblk7XHJcblxyXG4gICAgICAgICAgIC8v5Yik5pat5b6A55S75biD6YeM6L+Y5piv5a2Q6L+b56iL6YeM5re75Yqgc2hhcGVzXHJcbiAgICAgICAgICAgdmFyIGluc2VydFBvcyA9ICdjYW52YXMnO1xyXG4gICAgICAgICAgIGZ1bmN0aW9uIEp1ZGdlSW5TdWJQcm9jZXNzKHN1YlByb2Nlc3MsIHgsIHkpIHtcclxuICAgICAgICAgICAgICAgaWYgKHN1YlByb2Nlc3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJQcm9jZXNzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggPiBCcG1uVXRpbC5wYXJlbnRYKHN1YlByb2Nlc3NbaV0pICYmIHggPCBCcG1uVXRpbC5wYXJlbnRYKHN1YlByb2Nlc3NbaV0pICsgc3ViUHJvY2Vzc1tpXS5nZXRSZWN0KCkud2lkdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgeSA+IEJwbW5VdGlsLnBhcmVudFkoc3ViUHJvY2Vzc1tpXSkgJiYgeSA8IEJwbW5VdGlsLnBhcmVudFkoc3ViUHJvY2Vzc1tpXSkgKyBzdWJQcm9jZXNzW2ldLmdldFJlY3QoKS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YlByb2Nlc3NbaV0uY2hpbGRyZW4oKSAmJiBzdWJQcm9jZXNzW2ldLmNoaWxkcmVuKCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1N1YlByb2Nlc3MgPSBzdWJQcm9jZXNzW2ldLmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uYnBtbkluZm8gJiYgaXRlbS5ub2RlVHlwZSA9PT0gJ1N1YlByb2Nlc3MnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gSnVkZ2VJblN1YlByb2Nlc3MobmV3U3ViUHJvY2VzcywgeCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUgfHwgc3ViUHJvY2Vzc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICB2YXIgX3N1YlByb2Nlc3MgPSBKdWRnZUluU3ViUHJvY2Vzcyh0aGlzLnN1YlByb2Nlc3NOb2RlLCB4LCB5KTtcclxuICAgICAgICAgICBpZiAoX3N1YlByb2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgaW5zZXJ0UG9zID0gX3N1YlByb2Nlc3MucmVzb3VyY2VJZDtcclxuICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgIC8v6K6h566X5Ye6c2hhcGVz6YeM5q+P5Liqc2hhcGXnmoTmlrDkvY3nva7vvIwg5bm25o+S5YWl5Yiw55S75biD5oiW6ICF5p+Q5Liq5a2Q6L+b56iL55qEY2hpbGRTaGFwZXPph4xcclxuICAgICAgICAgICB2YXIgbmV3Q2hpbGRTaGFwZXMgPSBbXTtcclxuICAgICAgICAgICBpZiAoaW5zZXJ0UG9zID09PSAnY2FudmFzJykge1xyXG4gICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lQ2hpbGRTaGFwZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gY2xvbmVDaGlsZFNoYXBlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnN0ZW5jaWwudHlwZSAhPT0gQnBtbi5TRVFVRU5DRV9GTE9XKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5ib3VuZHMudXBwZXJMZWZ0LnggPSBpdGVtLmJvdW5kcy51cHBlckxlZnQueCAtIG1pblggKyB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYm91bmRzLmxvd2VyUmlnaHQueCA9IGl0ZW0uYm91bmRzLmxvd2VyUmlnaHQueCAtIG1pblggKyB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYm91bmRzLnVwcGVyTGVmdC55ID0gaXRlbS5ib3VuZHMudXBwZXJMZWZ0LnkgLSBtaW5ZICsgeTtcclxuICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmJvdW5kcy5sb3dlclJpZ2h0LnkgPSBpdGVtLmJvdW5kcy5sb3dlclJpZ2h0LnkgLSBtaW5ZICsgeTtcclxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5kb2NrZXJzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgLy/nlLvluIPph4zov5jlrZjlnKjlhbbku5boioLngrlcclxuICAgICAgICAgICAgICAgaWYgKG9sZENoaWxkU2hhcGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2xkQ2hpbGRTaGFwZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG9sZENoaWxkU2hhcGVzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnN0ZW5jaWwudHlwZSA9PT0gQnBtbi5TRVFVRU5DRV9GTE9XKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZG9ja2VycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuYm91bmRzLmxvd2VyUmlnaHQueCA+PSB4ICYmIG5vZGUuYm91bmRzLmxvd2VyUmlnaHQueSA+PSB5ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvL+WIpOaWremcgOimgeS/ruaUueS9jee9rueahOiKgueCuVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ib3VuZHMudXBwZXJMZWZ0LnggPD0geCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v6IqC54K55L2N572u5ZCR5LiL56e75YqoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmJvdW5kcy51cHBlckxlZnQueSA9IG5vZGUuYm91bmRzLnVwcGVyTGVmdC55ICsgc2hhcGVzSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ib3VuZHMubG93ZXJSaWdodC55ID0gbm9kZS5ib3VuZHMubG93ZXJSaWdodC55ICsgc2hhcGVzSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy/oioLngrnkvY3nva7lkJHlj7Pnp7vliqhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYm91bmRzLnVwcGVyTGVmdC54ID0gbm9kZS5ib3VuZHMudXBwZXJMZWZ0LnggKyBzaGFwZXNXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYm91bmRzLmxvd2VyUmlnaHQueCA9IG5vZGUuYm91bmRzLmxvd2VyUmlnaHQueCArIHNoYXBlc1dpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIG5ld0NoaWxkU2hhcGVzID0gb2xkQ2hpbGRTaGFwZXMuY29uY2F0KGNsb25lQ2hpbGRTaGFwZXMpO1xyXG4gICAgICAgICAgICAgICBjYW52YXNEYXRhLmNoaWxkU2hhcGVzID0gbmV3Q2hpbGRTaGFwZXM7XHJcbiAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBjbG9uZUNoaWxkU2hhcGVzLmxlbmd0aDsgbSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGNsb25lQ2hpbGRTaGFwZXNbbV07XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGVuY2lsLnR5cGUgIT09IEJwbW4uU0VRVUVOQ0VfRkxPVykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYm91bmRzLnVwcGVyTGVmdC54ID0gaXRlbS5ib3VuZHMudXBwZXJMZWZ0LnggLSBtaW5YICsgKHggLSBCcG1uVXRpbC5wYXJlbnRYKF9zdWJQcm9jZXNzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5ib3VuZHMubG93ZXJSaWdodC54ID0gaXRlbS5ib3VuZHMubG93ZXJSaWdodC54IC0gbWluWCArICh4IC0gQnBtblV0aWwucGFyZW50WChfc3ViUHJvY2VzcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYm91bmRzLnVwcGVyTGVmdC55ID0gaXRlbS5ib3VuZHMudXBwZXJMZWZ0LnkgLSBtaW5ZICsgKHkgLSBCcG1uVXRpbC5wYXJlbnRZKF9zdWJQcm9jZXNzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5ib3VuZHMubG93ZXJSaWdodC55ID0gaXRlbS5ib3VuZHMubG93ZXJSaWdodC55IC0gbWluWSArICh5IC0gQnBtblV0aWwucGFyZW50WShfc3ViUHJvY2VzcykpO1xyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmRvY2tlcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB2YXIgbmV3WCwgbmV3WTtcclxuICAgICAgICAgICAgICAgLy/kv67mlLnmiYDlnKjlrZDov5vnqIvoioLngrnnmoTlrr3pq5jlkozlroPnmoTkvY3nva7kv6Hmga9cclxuICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBvbGRDaGlsZFNoYXBlcy5sZW5ndGg7IG4rKykge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBvbGRDaGlsZFNoYXBlc1tuXTtcclxuICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJlc291cmNlSWQgPT09IGluc2VydFBvcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIG5ld1ggPSBub2RlLmJvdW5kcy51cHBlckxlZnQueDtcclxuICAgICAgICAgICAgICAgICAgICAgICBuZXdZID0gbm9kZS5ib3VuZHMudXBwZXJMZWZ0Lnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuYm91bmRzLmxvd2VyUmlnaHQueCAtIHggPCBzaGFwZXNXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmJvdW5kcy5sb3dlclJpZ2h0LnggPSBzaGFwZXNXaWR0aCArIHggKyAxMDtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuYm91bmRzLmxvd2VyUmlnaHQueSAtIHkgPCBzaGFwZXNIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ib3VuZHMubG93ZXJSaWdodC55ID0gc2hhcGVzSGVpZ2h0ICsgeSArIDEwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAvL+aPkuWFpeeahOWtkOi/m+eoi+iKgueCuemHjOehruS/neayoeacieWFtuS7luiKgueCue+8jOiLpeWtmOWcqOWFtuS7luiKgueCueWwhuS8mua4heepulxyXG4gICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRTaGFwZXMgPSBbXS5jb25jYXQoY2xvbmVDaGlsZFNoYXBlcyk7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgLy/mkpHlvIDlrZDov5vnqIvoioLngrnlj6/og73kvJrlvbHlk43lroPlkajlm7TnmoToioLngrnvvIzlm6DmraTpnIDopoHkv67mlLnlkajlm7ToioLngrnnmoTkvY3nva7kv6Hmga9cclxuICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvbGRDaGlsZFNoYXBlcy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBvbGRDaGlsZFNoYXBlc1trXTtcclxuICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJlc291cmNlSWQgPT09IGluc2VydFBvcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RlbmNpbC50eXBlID09PSBCcG1uLlNFUVVFTkNFX0ZMT1cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRvY2tlcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmJvdW5kcy5sb3dlclJpZ2h0LnggPj0gbmV3WCAmJiBub2RlLmJvdW5kcy5sb3dlclJpZ2h0LnkgPj0gbmV3WSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAvL+WIpOaWremcgOimgeS/ruaUueS9jee9rueahOiKgueCuVxyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmJvdW5kcy51cHBlckxlZnQueCA8PSBuZXdYICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvL+iKgueCueS9jee9ruWQkeS4i+enu+WKqFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmJvdW5kcy51cHBlckxlZnQueSA9IG5vZGUuYm91bmRzLnVwcGVyTGVmdC55ICsgc2hhcGVzSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmJvdW5kcy5sb3dlclJpZ2h0LnkgPSBub2RlLmJvdW5kcy5sb3dlclJpZ2h0LnkgKyBzaGFwZXNIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLy/oioLngrnkvY3nva7lkJHlj7Pnp7vliqhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ib3VuZHMudXBwZXJMZWZ0LnggPSBub2RlLmJvdW5kcy51cHBlckxlZnQueCArIHNoYXBlc1dpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmJvdW5kcy5sb3dlclJpZ2h0LnggPSBub2RlLmJvdW5kcy5sb3dlclJpZ2h0LnggKyBzaGFwZXNXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgY2FudmFzRGF0YS5jaGlsZFNoYXBlcyA9IG9sZENoaWxkU2hhcGVzO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICAvL+mHjeaWsOa4suafk+aVtOS4queUu+W4g1xyXG4gICAgICAgICAgIHRoaXMuZnJvbUpzb24oY2FudmFzRGF0YSk7XHJcbiAgICAgICAgICAgdGhpcy5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgfVxyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uX0p1ZGdlTm9kZUluV2hpY2hTdWJQcm9jZXNzID0gZnVuY3Rpb24gKHN1YlByb2Nlc3MsIG5vZGUpIHtcclxuICAgICAgICAgICBpZiAoc3ViUHJvY2Vzcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ViUHJvY2Vzcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgQnBtblV0aWwucGFyZW50WChzdWJQcm9jZXNzW2ldKSxcclxuICAgICAgICAgICAgICAgICAgICAgICBCcG1uVXRpbC5wYXJlbnRZKHN1YlByb2Nlc3NbaV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHN1YlByb2Nlc3NbaV0uZ2V0UmVjdCgpLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHN1YlByb2Nlc3NbaV0uZ2V0UmVjdCgpLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgIGlmIChib3VuZGluZ1JlY3QuY29udGFpbihub2RlLngsIG5vZGUueSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViUHJvY2Vzc1tpXS5jaGlsZHJlbigpICYmIHN1YlByb2Nlc3NbaV0uY2hpbGRyZW4oKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTdWJQcm9jZXNzID0gc3ViUHJvY2Vzc1tpXS5jaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uYnBtbkluZm8gJiYgaXRlbS5ub2RlVHlwZSA9PT0gJ1N1YlByb2Nlc3MnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlID0gdGhpcy5fSnVkZ2VOb2RlSW5XaGljaFN1YlByb2Nlc3MobmV3U3ViUHJvY2Vzcywgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdOb2RlIHx8IHN1YlByb2Nlc3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIOagueaNruaooeWei+WinuWKoOiKgueCuSjlkIzmraUpXHJcbiAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAqIEByZXR1cm4ge09iamVjdH0g5Yib5bu65a6M5oiQ55qE6IqC54K5XHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uYWRkTm9kZUJ5TW9kZWwgPSBmdW5jdGlvbihtb2RlbCwgaXNGcm9tRHJhZywgaXNOb0NvdW50KSB7XHJcbiAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgIHZhciBTaGFwZSA9IEJQTU5Ob2RlLmdldENsYXNzKG1vZGVsLmdldChCcG1uLkJQTU5fVFlQRSkpO1xyXG5cclxuICAgICAgICAgICBpZiAoU2hhcGUpIHtcclxuICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBuZXcgU2hhcGUobW9kZWwsIHRoaXMuX2FwaSk7XHJcbiAgICAgICAgICAgICAgIHZhciBfc3ViUHJvY2VzcyA9IHRoYXQuX0p1ZGdlTm9kZUluV2hpY2hTdWJQcm9jZXNzKHRoYXQuc3ViUHJvY2Vzc05vZGUsIHt4OiBub2RlLmdldFJlY3QoKS54LCB5OiBub2RlLmdldFJlY3QoKS55fSk7XHJcbiAgICAgICAgICAgICAgIHRoYXQuYWRkTm9kZVRvU2hhcGUobm9kZSwgaXNGcm9tRHJhZywgaXNOb0NvdW50LCBfc3ViUHJvY2Vzcyk7XHJcbiAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDmoLnmja7mqKHlnovlop7liqDoioLngrko5byC5q2lKVxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IOWIm+W7uuWujOaIkOeahOiKgueCuVxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmFzeW5jQWRkTm9kZUJ5TW9kZWwgPSBmdW5jdGlvbihtb2RlbCwgaXNGcm9tRHJhZywgaXNOb0NvdW50KSB7XHJcbiAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgIHZhciBTaGFwZSA9IEJQTU5Ob2RlLmdldENsYXNzKG1vZGVsLmdldChCcG1uLkJQTU5fVFlQRSkpO1xyXG5cclxuICAgICAgICAgICBpZiAoU2hhcGUpIHtcclxuICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBuZXcgU2hhcGUobW9kZWwsIHRoaXMuX2FwaSk7XHJcbiAgICAgICAgICAgICAgIHZhciBfc3ViUHJvY2VzcyA9IHRoYXQuX0p1ZGdlTm9kZUluV2hpY2hTdWJQcm9jZXNzKHRoYXQuc3ViUHJvY2Vzc05vZGUsIHt4OiBub2RlLmdldFJlY3QoKS54LCB5OiBub2RlLmdldFJlY3QoKS55fSk7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJBc3luYygnYmVmb3JlQWRkTm9kZScsIHt0YXJnZXQ6IF9zdWJQcm9jZXNzfSwgbm9kZSkudGhlbihmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hZGROb2RlVG9TaGFwZShub2RlLCBpc0Zyb21EcmFnLCBpc05vQ291bnQsIF9zdWJQcm9jZXNzKTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmFkZE5vZGVUb1NoYXBlID0gZnVuY3Rpb24gKG5vZGUsIGlzRnJvbURyYWcsIGlzTm9Db3VudCwgX3N1YlByb2Nlc3MpIHtcclxuICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgdmFyIG1lc0FycmF5O1xyXG4gICAgICAgICAgIGlmICh0aGF0LnN1YlByb2Nlc3NOb2RlLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgIHRoYXQuX3pyLmFkZChub2RlKTtcclxuICAgICAgICAgICAgICAgbWVzQXJyYXkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcclxuICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbbm9kZS5nZXRSZWN0KCkueCwgbm9kZS5nZXRSZWN0KCkueV0sXHJcbiAgICAgICAgICAgICAgICAgICB3aWR0aDogbm9kZS5nZXRSZWN0KCkud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG5vZGUuZ2V0UmVjdCgpLmhlaWdodFxyXG4gICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICBpZiAoIUJwbW4uaXNTbG90RXZlbnQobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgIHRoYXQub3ZlcmxhcEFycmF5LnB1c2gobWVzQXJyYXkpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgdGhhdC5fenIuYWRkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICBtZXNBcnJheSA9IHtcclxuICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFtub2RlLmdldFJlY3QoKS54LCBub2RlLmdldFJlY3QoKS55XSxcclxuICAgICAgICAgICAgICAgICAgIHdpZHRoOiBub2RlLmdldFJlY3QoKS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgIGhlaWdodDogbm9kZS5nZXRSZWN0KCkuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgIGlmICghQnBtbi5pc1Nsb3RFdmVudChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgdGhhdC5vdmVybGFwQXJyYXkucHVzaChtZXNBcnJheSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgaWYgKGlzRnJvbURyYWcpIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRYID0gMCwgb2Zmc2V0WSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoX3N1YlByb2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3N1YlByb2Nlc3MucGFyZW50ICYmIEJwbW4uaXNTdWJQcm9jZXNzKF9zdWJQcm9jZXNzLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCA9IEJwbW5VdGlsLnBhcmVudFgoX3N1YlByb2Nlc3MucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WSA9IEJwbW5VdGlsLnBhcmVudFkoX3N1YlByb2Nlc3MucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwTm9kZVBvc2l0aW9uWCA9IF9zdWJQcm9jZXNzLmdldFJlY3QoKS53aWR0aCAvIDIgKyAobm9kZS5nZXRSZWN0KCkueCAtIChfc3ViUHJvY2Vzcy5nZXRSZWN0KCkueCArIG9mZnNldFgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBOb2RlUG9zaXRpb25ZID0gX3N1YlByb2Nlc3MuZ2V0UmVjdCgpLmhlaWdodCAvIDIgKyAobm9kZS5nZXRSZWN0KCkueSAtIChfc3ViUHJvY2Vzcy5nZXRSZWN0KCkueSArIG9mZnNldFkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldFBvc2l0aW9uKGdyb3VwTm9kZVBvc2l0aW9uWCwgZ3JvdXBOb2RlUG9zaXRpb25ZKTtcclxuICAgICAgICAgICAgICAgICAgICAgICBfc3ViUHJvY2Vzcy5hZGQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fenIucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhhdC5vdmVybGFwQXJyYXkubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT0gdGhhdC5vdmVybGFwQXJyYXlbal0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub3ZlcmxhcEFycmF5LnNwbGljZShqLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICAvLzIu5aaC5p6c5piv5a2Q6IqC54K5IOWImeWKoOWFpeWIsOWtkOiKgueCueaVsOe7hOS4rVxyXG4gICAgICAgICAgIGlmIChCcG1uLmlzU3ViUHJvY2Vzcyhub2RlKSkge1xyXG4gICAgICAgICAgICAgICB0aGF0LnN1YlByb2Nlc3NOb2RlLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHRoYXQuYWxsTm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICAgICAvL+aUvuWFpeiKgueCueS9jee9ruS/oeaBryDnlKjkuo7mi5bmi71cclxuICAgICAgICAgICBtZXNBcnJheS5wb3NpdGlvbiA9IFtub2RlLmdldFJlY3QoKS54LCBub2RlLmdldFJlY3QoKS55XTtcclxuICAgICAgICAgICB0aGF0LmRvbUFycmF5LnB1c2gobWVzQXJyYXkpO1xyXG5cclxuICAgICAgICAgICAvL+S+puWQrOiKgueCueeahOS6i+S7tiDlubbmiorkuovku7bnu5nlj5bmtojmjokg6Ziy5q2iIOWmguaenOeItuaYr+WtkOiKgueCueS+puWQrOWIsFxyXG4gICAgICAgICAgIG5vZGUub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgaWYgKCEodGhhdC5mb3JiaWRFZGl0ID09IHRydWUgfHxcclxuICAgICAgICAgICAgICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC50eXBlID09PSBcImRyYWdTZWxlY3RcIikgfHxcclxuICAgICAgICAgICAgICAgICAgICh0aGF0Lm1vdXNlTW9kZSA9PT0gXCJkcmFnLXNlbGVjdFwiICYmIEJwbW4uaXNTdWJQcm9jZXNzKHRoaXMpKSkpIHtcclxuICAgICAgICAgICAgICAgICAgIHRoYXQubmV3RHJhZyh0aGlzLCBlLmV2ZW50LmNsaWVudFgsIGUuZXZlbnQuY2xpZW50WSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgLy/lpoLmnpzpgInmi6nnmoTmmK/kuovku7boioLngrnvvIzliJnkuLrlhbbku5Z0YXNr57uR5a6a5o+S5qe9XHJcbiAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU2xvdEV2ZW50KHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0LmJpbmRFdmVudE5vZGUoKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBpZiAodGhhdC5tb3VzZU1vZGUgIT09IFwiZHJhZy1zZWxlY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgbm9kZS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgIHRoYXQubm9kZUNsaWNrSGFuZGxlcih0aGlzKTtcclxuICAgICAgICAgICAgICAgdGhhdC5fdHJpZ2dlcignc2VsZWN0Tm9kZScsIHt0YXJnZXQ6IG5vZGV9KTtcclxuICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIC8v5re75YqgdGlwXHJcbiAgICAgICAgICAgaWYgKEJwbW4uaXNBY3Rpdml0eShub2RlKSkge1xyXG4gICAgICAgICAgICAgICB0aGF0LmNyZWF0VGlwKG5vZGUpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBub2RlLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICBpZiAodGhpcy5hbGFybSAmJiB0aGlzLmFsYXJtLmlzU2hvdyA9PSB0cnVlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5hbGFybS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLmFsYXJtLmVhY2hDaGlsZChmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgLy/moLnmja7lrZflhoXlrrnmm7TmlLl0aXDlpJbmoYbnmoTlpKflsI9cclxuICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5hbGFybS5jaGlsZE9mTmFtZShcIlRleHRcIik7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBXaWR0aCA9IHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggKyA0O1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwSGVpZ2h0ID0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgKyA4O1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICBbMCwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgW2dyb3VwV2lkdGgsIDBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLCBncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgW2dyb3VwV2lkdGggLyAyIC0gMywgZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIFtncm91cFdpZHRoIC8gMiwgZ3JvdXBIZWlnaHQgKyAzXSxcclxuICAgICAgICAgICAgICAgICAgICAgICBbZ3JvdXBXaWR0aCAvIDIgKyAzLCBncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgWzAsIGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICBbMCwgMF1cclxuICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgUG9seWxpbmUgPSB0aGlzLmFsYXJtLmNoaWxkT2ZOYW1lKFwiUG9seWxpbmVcIik7XHJcbiAgICAgICAgICAgICAgICAgICBQb2x5bGluZS5hdHRyKFwic2hhcGVcIiwge3BvaW50czogcG9pbnRzfSk7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvbiA9IFtCcG1uVXRpbC5wYXJlbnRYKG5vZGUpICsgbm9kZS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtIHRoaXMuYWxhcm0uZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLyAyLCBCcG1uVXRpbC5wYXJlbnRZKG5vZGUpIC0gdGhpcy5hbGFybS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLSAzXTtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuYWxhcm0uYXR0cihcInBvc2l0aW9uXCIsIGdyb3VwUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgbm9kZS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICBpZiAodGhpcy5hbGFybSkge1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5hbGFybS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLmFsYXJtLmVhY2hDaGlsZChmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgaWYgKGlzTm9Db3VudCAhPSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgIHRoYXQuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgdGhhdC5fdHJpZ2dlcignYWZ0ZXJDcmVhdGVOb2RlJywge3RhcmdldDogbm9kZX0pO1xyXG4gICAgICAgfVxyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICog6YCJ5Lit5Zy65pmv5Lit55qE5p+Q5Liq6IqC54K5LOW5tuS4lOinpuWPkXNlbGVjdE5vZGXkuovku7ZcclxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIOW+hemAieS4reeahOiKgueCueWvueixoVxyXG4gICAgICAgICogQHNpbmNlIFYyLjMuMFxyXG4gICAgICAgICogICoq5L2/55So6IyD5L6L77yaKipcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBmaXNoVG9wby5zZWxlY3ROb2RlKG5vZGUpO1xyXG4gICAgICAgICovXHJcblxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5zZWxlY3ROb2RlID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMubm9kZUNsaWNrSGFuZGxlcihub2RlKTtcclxuICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcignc2VsZWN0Tm9kZScsIHt0YXJnZXQ6IG5vZGV9KTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICog5qC55o2ubmFtZeiOt+WPluiKgueCuVxyXG4gICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIOWcqOWIm+W7uuiKgueCueS4rSAgbmFtZeWxnuaAp+iuvue9rueahOWAvFxyXG4gICAgICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgIG5hbWXlr7nlupTnmoToioLngrlcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5jaGlsZE9mTmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICB2YXIgYXJyUmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgIGlmICh0aGlzLmFsbE5vZGVzW2ldLm1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSA9PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICBhcnJSZXN1bHQucHVzaCh0aGlzLmFsbE5vZGVzW2ldKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBpZiAoYXJyUmVzdWx0Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgcmV0dXJuIGFyclJlc3VsdDtcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICByZXR1cm4gYXJyUmVzdWx0WzBdO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDmn6Xmib7lnLrmma/kuK3nmoTlr7nosaEgICDkvovlpoI6IHjlnZDmoIflpKfkuo4xMDDnmoToioLngrkgZmluZEVsZW1lbnRzKGZ1bmN0aW9uKGUpeyByZXR1cm4gZS5wb3NpdGlvblswXSA+IDEwMDsgfSk7XHJcbiAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2IgICAgICDlm57osIPlh73mlbBcclxuICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gICBjb250ZXh0IOWbnuiwg+WHveaVsOaJp+ihjOeahOS4iuS4i+aWh1xyXG4gICAgICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICDov5Tlm57mn6Xmib7liLDnmoTlr7nosaFcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5maW5kRWxlbWVudHMgPSBmdW5jdGlvbihjYiwgY29udGV4dCkge1xyXG4gICAgICAgICAgIHZhciBjaGlsZHJlbk5vZGUgPSB0aGlzLmFsbE5vZGVzO1xyXG4gICAgICAgICAgIHZhciBjaGlsZHJlbkxpbmUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnM7XHJcbiAgICAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5Ob2RlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuTm9kZVtpXTtcclxuICAgICAgICAgICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICBhcnIucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZHJlbkxpbmUubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgdmFyIGNoaWxkTGluZSA9IGNoaWxkcmVuTGluZVtqXTtcclxuICAgICAgICAgICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgY2hpbGRMaW5lLCBqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgYXJyLnB1c2goY2hpbGRMaW5lKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKiDmoLnmja7mqKHlnovlop7liqDnur9cclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5hZGRDb25uZWN0b3JCeU1vZGVsID0gZnVuY3Rpb24obW9kZWwsIHBhcmVudFpyKSB7XHJcbiAgICAgICAgICAgLy/mib7lh7ogc3RhcnROb2RlIOS4jiBlbmROb2RlXHJcbiAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IG51bGwsXHJcbiAgICAgICAgICAgICAgIGVuZE5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuYWxsTm9kZXMsIGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgLy9zdGFydE5vZGU6IOS7jmFsbE5vZGXkuK3mib7lh7pvdXRnb2luZ+S4uiDnur/nmoRpZOeahOi1t+Wni+iKgueCuVxyXG4gICAgICAgICAgICAgICB2YXIgbm9kZU91dGdvaW5nID0gbm9kZS5tb2RlbC5nZXQoXCJvdXRnb2luZ1wiKTtcclxuICAgICAgICAgICAgICAgaWYgKG5vZGVPdXRnb2luZy5pbmRleE9mKG1vZGVsLmdldChcInJlc291cmNlSWRcIikpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgc3RhcnROb2RlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAvL2VuZE5vZGUgOiDku45hbGxOb2Rl5Lit5om+5Ye6IGlkIOS4uue6v+eahG91dGdvaW5n55qE57uT5p2f6IqC54K5XHJcbiAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3JPdXRnb2luZyA9IG1vZGVsLmdldChcIm91dGdvaW5nXCIpO1xyXG4gICAgICAgICAgICAgICBpZiAoY29ubmVjdG9yT3V0Z29pbmcuaW5kZXhPZihub2RlLnJlc291cmNlSWQpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgZW5kTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICBpZiAoc3RhcnROb2RlICYmIGVuZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9yQ3JlYXRlQnlPcHRpb25zKHN0YXJ0Tm9kZSwgZW5kTm9kZSwge21vZGVsOiBtb2RlbCxpc0Zyb21Nb2RlbDp0cnVlfSwgdGhpcy5fYXBpKTtcclxuICAgICAgICAgICAgICAgaWYgKHBhcmVudFpyKSB7XHJcbiAgICAgICAgICAgICAgICAgICBwYXJlbnRaci5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLl96ci5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvckZvcmJpZEVkaXQodGhpcy5mb3JiaWRFZGl0KTtcclxuICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ29ubmVjdG9yRHJhZ0V2ZW50cyhjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICAgICBjb25uZWN0b3Iub24oXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5pc0VkaXQgPSAhdGhpcy5mb3JiaWRFZGl0O1xyXG4gICAgICAgICAgICAgICAgICAgLy8g5Y+W5raI6IqC54K555qE6YCJ5LitXHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JQb2ludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlQ29ubmVjdG9yQ29udHJvbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlT3BlcmF0aW9uTm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5pc05vZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICB9XHJcblxyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIOWIm+W7uui/nue6v+eahOWwj+Wbvuagh+aTjeS9nFxyXG4gICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSDlsI/lm77moIfnmoTlkI3np7BcclxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOWwj+Wbvuagh+mAiemhuVxyXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmljb25dIOWwj+Wbvuagh+i3r+W+hFxyXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxpbmVOb2RlXSDnur/mrrXlrp7kvotcclxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXSDngrnlh7vlkI7nmoTlm57osINcclxuICAgICAgICAqXHJcbiAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgKlxyXG4gICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICogICAgICBmaXNoVG9wb0JwbW4uYWRkSWNvbihcImljb24xXCIseyAgLy/nur/kuIrlm77moIfnmoTlkI3np7BcclxuICAgICAgICAqICAgICAgICAgICAgICAgICAgICBpY29uOlwiYnBtbjIuMC9pY29ucy9hY3Rpdml0eS9saXN0L21haWwuc2VuZC5wbmdcIiwgLy/nur/kuIrlm77moIfnmoTot6/lvoRcclxuICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgbGluZU5vZGU6bGluZU5vZGUsICAvL+e6v1xyXG4gICAgICAgICogICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazpmdW5jdGlvbihsaW5lTm9kZSl7ICAvL+Wbnuiwg1xyXG4gICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KEpTT04uc3RyaW5naWZ5KGxpbmVOb2RlKSlcclxuICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgKiAgICAgICAgICAgICAgICAgIH0pOypcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5hZGRJY29uID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5hZGRJY29uKGtleSwgb3B0aW9ucyk7XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICog5Yib5bu66L+e57q/55qE6buY6K6k5Yig6Zmk5pON5L2cXHJcbiAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGxpbmVOb2RlIOe6v1xyXG4gICAgICAgICpcclxuICAgICAgICAqICAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgKlxyXG4gICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICogICAgICBmaXNoVG9wb0JwbW4uYmluZExpbmVEZWxldGUobGluZU5vZGUpO1xyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmJpbmRMaW5lRGVsZXRlID0gZnVuY3Rpb24obGluZU5vZGUsb3B0aW9ucykge1xyXG4gICAgICAgICAgIC8v5Yib5bu65Yig6ZmkXHJcbiAgICAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5hZGREZWxldGVJY29uKGxpbmVOb2RlLG9wdGlvbnMpO1xyXG4gICAgICAgfTtcclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqIOi/lOWbniDov57lkJHor6XoioLngrnnmoToioLngrnmlbDnu4TvvJpub2RlQXJyYXlbMF0gIOS7peWPiuivpeiKgueCuei/nuWQkeeahOiKgueCueaVsOe7hCBub2RlQXJyYXlbMF1cclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5jaGVja0xpbmVOb2RlID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgIHZhciBzdGFydEFycmF5ID0gW10sXHJcbiAgICAgICAgICAgICAgIGVuZEFycmF5ID0gW107XHJcbiAgICAgICAgICAgdmFyIGxpbmVBcnJheSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycztcclxuICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgIGlmIChsaW5lQXJyYXlbaV0uc3RhcnROb2RlID09IG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgIGVuZEFycmF5LnB1c2gobGluZUFycmF5W2ldLmVuZE5vZGUpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW5FbmQgPSBsaW5lQXJyYXkubGVuZ3RoOyBqIDwgbGVuRW5kOyBqKyspIHtcclxuICAgICAgICAgICAgICAgaWYgKGxpbmVBcnJheVtqXS5lbmROb2RlID09IG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgIHN0YXJ0QXJyYXkucHVzaChsaW5lQXJyYXlbal0uc3RhcnROb2RlKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICByZXR1cm4gW3N0YXJ0QXJyYXksIGVuZEFycmF5XTtcclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICog6K6h566X5Zyoc3VicHJvY2Vzc+WGheeahOiKgueCueeahOecn+WunuS9jee9rlxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmNhbGN1bGF0ZU5vZGVSZWN0SW5Hcm91cCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICB2YXIgcmVjdCA9IHV0aWwuZ2V0UmVjdChub2RlKTtcclxuICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3Mobm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgIHJlY3QuYm91bmRpbmdSZWN0LnggKz0gQnBtblV0aWwucGFyZW50WChub2RlLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgIHJlY3QuYm91bmRpbmdSZWN0LnkgKz0gQnBtblV0aWwucGFyZW50WShub2RlLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgIHJlY3QueCArPSBCcG1uVXRpbC5wYXJlbnRYKG5vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgICAgcmVjdC55ICs9IEJwbW5VdGlsLnBhcmVudFkobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICByZWN0OiByZWN0LFxyXG4gICAgICAgICAgICAgICBwYXJlbnROb2RlOiBCcG1uVXRpbC5nZXRQYXJlbnROb2RlKG5vZGUpXHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfVxyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqIOS+neasoeS7juiKgueCuemAkuW9kuiHs+acgOWkluWxgueahHN1YnByb2Nlc3PvvIzorqHnrpfoioLngrnmnIDnu4jnmoTljIXlm7Tnm5JcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5jYWxjdWxhdGVSZWN0ID0gZnVuY3Rpb24obm9kZSwgbm9kZVJlY3QpIHtcclxuICAgICAgICAgICBpZiAoIW5vZGVSZWN0KSB7XHJcbiAgICAgICAgICAgICAgIG5vZGVSZWN0ID0gdGhpcy5jYWxjdWxhdGVOb2RlUmVjdEluR3JvdXAobm9kZSkucmVjdDtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgaWYgKCFub2RlUmVjdC5yb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICBub2RlUmVjdC5yb3RhdGlvbiA9IG5vZGUucm90YXRpb247XHJcbiAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgbm9kZVJlY3Qucm90YXRpb24gKz0gbm9kZS5yb3RhdGlvbjtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgLy8g5aaC5p6c54i26IqC54K55peL6L2s5LqG77yM6ZyA6KaB5pu05paw5a2Q6IqC54K555qE5Lit5b+D54K5XHJcbiAgICAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIEJwbW4uaXNTdWJQcm9jZXNzKG5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSBub2RlLnBhcmVudC5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHJvdGF0aW9uKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmNhbGN1bGF0ZU5vZGVSZWN0SW5Hcm91cChub2RlLnBhcmVudCkucmVjdDtcclxuICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICB4OiBub2RlUmVjdC54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHk6IG5vZGVSZWN0LnlcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIHZhciBuUG9pbnQgPSB1dGlsLmNhbGN1bGF0ZVBvaW50cyhwb2ludCwgY2VudGVyLCByb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICBub2RlUmVjdC54ID0gblBvaW50Lng7XHJcbiAgICAgICAgICAgICAgICAgICBub2RlUmVjdC55ID0gblBvaW50Lnk7XHJcbiAgICAgICAgICAgICAgICAgICBub2RlUmVjdC5ib3VuZGluZ1JlY3QueCA9IG5vZGVSZWN0LnggLSBub2RlUmVjdC53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICBub2RlUmVjdC5ib3VuZGluZ1JlY3QueSA9IG5vZGVSZWN0LnkgLSBub2RlUmVjdC5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZVJlY3Qobm9kZS5wYXJlbnQsIG5vZGVSZWN0KTtcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICByZXR1cm4gbm9kZVJlY3Q7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfVxyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uY3JlYXRlQ29ubmVjdG9yUG9pbnQgPSBmdW5jdGlvbihwb2ludCwgcG9zLCBsaW5lVHlwZSkge1xyXG4gICAgICAgICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICAgICAgICAgdmFyIHBvaW50SW5zdGFuY2UgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgY3g6IHBvaW50LngsXHJcbiAgICAgICAgICAgICAgICAgICBjeTogcG9pbnQueSxcclxuICAgICAgICAgICAgICAgICAgIHI6IDRcclxuICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgIGZpbGw6ICcjRkZGRjMzJyxcclxuICAgICAgICAgICAgICAgICAgIHN0cm9rZTonIzAwMDAwMCdcclxuICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgeiA6IDIsXHJcbiAgICAgICAgICAgICAgIGN1cnNvcjogJ2Nyb3NzaGFpcicsXHJcbiAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgbGluZVR5cGU6IGxpbmVUeXBlXHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgcG9pbnRJbnN0YW5jZS50eXBlID0gJ0Nvbm5lY3RQb2ludCc7XHJcbiAgICAgICAgICAgcG9pbnRJbnN0YW5jZS5wb3MgPSBwb3M7ICAgICAgICAgICAgICAgIC8v6K6w5b2V5piv6IqC54K55LiK5ZOq5Liq5L2N572u55qE6L+e5o6l54K5XHJcbiAgICAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydkcmFnc3RhcnQnLCAnZHJhZycsICdkcmFnZW5kJ107XHJcbiAgICAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgcG9pbnRJbnN0YW5jZS5vbihldmVOYW1lLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcIkNvbm5lY3RQb2ludDpcIiArIGV2ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICBtZS5jb25Qb2ludHNHcm91cC50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwLmFkZChwb2ludEluc3RhbmNlKTtcclxuICAgICAgIH1cclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmhpZGVDb25uZWN0b3JQb2ludCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgIHRoaXMuY29uUG9pbnRzR3JvdXAucmVtb3ZlQWxsKCk7ICAvL+makOiXj+aJgOacieiKgueCueS4iueahOi/nuaOpeeCuVxyXG4gICAgICAgICAgIHRoaXMuY29uUG9pbnRzR3JvdXAub2ZmKCk7ICAgICAgICAvL+a4heepuuaJgOacieS6i+S7tlxyXG4gICAgICAgICAgIHRoaXMuX3pyLnJlbW92ZSh0aGlzLmNvblBvaW50c0dyb3VwKTtcclxuICAgICAgIH1cclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmZpbHRlckNvbm5lY3RQb2ludCA9IGZ1bmN0aW9uKHRhcmdldE5vZGVzLCBsaW5lVHlwZSkge1xyXG4gICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICB2YXIgbm9kZXMgPSB0YXJnZXROb2RlcztcclxuICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgdmFyIGNhbGN1bGF0ZVJlY3QgPSB0aGF0LmNhbGN1bGF0ZVJlY3QoaXRlbSk7XHJcbiAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3JQb2ludCA9IHV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKGNhbGN1bGF0ZVJlY3QsIHsgcm90YXRpb246IGNhbGN1bGF0ZVJlY3Qucm90YXRpb24gfSk7XHJcbiAgICAgICAgICAgICAgIHRoYXQuY3JlYXRlQ29ubmVjdG9yUG9pbnQoY29ubmVjdG9yUG9pbnQubGVmdCwgXCJsZWZ0XCIsIGxpbmVUeXBlKTtcclxuICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JQb2ludChjb25uZWN0b3JQb2ludC5yaWdodCwgXCJyaWdodFwiLCBsaW5lVHlwZSk7XHJcbiAgICAgICAgICAgICAgIHRoYXQuY3JlYXRlQ29ubmVjdG9yUG9pbnQoY29ubmVjdG9yUG9pbnQudG9wLCBcInRvcFwiLCBsaW5lVHlwZSk7XHJcbiAgICAgICAgICAgICAgIHRoYXQuY3JlYXRlQ29ubmVjdG9yUG9pbnQoY29ubmVjdG9yUG9pbnQuYm90dG9tLCBcImJvdHRvbVwiLCBsaW5lVHlwZSk7XHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5zaG93Q29ubmVjdG9yUG9pbnQgPSBmdW5jdGlvbihsaW5lVHlwZSwgbGluZU9wdCwgaWZDdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JQb2ludCgpO1xyXG4gICAgICAgICAgIGlmIChsaW5lT3B0KSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMubGluZU9wdCA9IGxpbmVPcHQ7ICAvL+e8k+WtmOe6v+auteeahOmFjee9ruS/oeaBr1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBpZiAobGluZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgdGhpcy5saW5lVHlwZSA9IGxpbmVUeXBlOyAvLyDnvJPlrZjnur/mrrXnsbvlnotcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgaWYgKCF0aGlzLmxpbmVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMubGluZVR5cGUgPSAnamFnZ2VkJzsgLy8g57q/5q616buY6K6k5oqY57q/57G75Z6LXHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGlmICghaWZDdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICBpZkN1cnJlbnROb2RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHZhciB0YXJnZXROb2RlcyA9IGlmQ3VycmVudE5vZGUgPyBbdGhhdC5zZWxlY3RlZE5vZGVdIDogdGhhdC5hbGxOb2RlcztcclxuICAgICAgICAgICAvLyDorqnmiYDmnInnlLvluIPkuK3nmoToioLngrkv5b2T5YmN6IqC54K55pi+56S66L+e5o6l54K5XHJcbiAgICAgICAgICAgdGhpcy5maWx0ZXJDb25uZWN0UG9pbnQodGFyZ2V0Tm9kZXMsIHRoaXMubGluZVR5cGUpO1xyXG5cclxuICAgICAgICAgICBmdW5jdGlvbiBmaW5kQ29ubmVjdG9yTm9kZSh4LCB5LCBvZmZzZXQsIHBvcykge1xyXG4gICAgICAgICAgICAgICB2YXIgbm9kZSwgZW5kUG9zID0gbnVsbDtcclxuICAgICAgICAgICAgICAgdGhhdC5hbGxOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBjYWxjdWxhdGVSZWN0ID0gdGhhdC5jYWxjdWxhdGVSZWN0KGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RvclBvaW50ID0gdXRpbC5nZXRDb25uZWN0b3JQb2ludHMoY2FsY3VsYXRlUmVjdCwgeyByb3RhdGlvbjogY2FsY3VsYXRlUmVjdC5yb3RhdGlvbiB9KTtcclxuICAgICAgICAgICAgICAgICAgIGlmIChwb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbcG9zXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W3Bvc10ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImxlZnRcIl0ueCAtIHgpIDw9IG9mZnNldCAmJiBNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImxlZnRcIl0ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInRvcFwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1widG9wXCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJ0b3BcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInJpZ2h0XCJdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbXCJyaWdodFwiXS55IC0geSkgPD0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImJvdHRvbVwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wiYm90dG9tXCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJib3R0b21cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICBlbmRQb3M6IGVuZFBvc1xyXG4gICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwLm9uKFwiQ29ubmVjdFBvaW50OmRyYWdzdGFydFwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgIC8vIOWmguaenOaYr+W9k+WJjeiKgueCueaYvuekuui/nuaOpeeCue+8jOmcgOimgeWcqOaLluWKqOWJquWktOaXtuiuqeeUu+W4g+S4reeahOWFtuS7luiKgueCueaYvuekuui/nuaOpeeCuVxyXG4gICAgICAgICAgICAgICBpZiAoaWZDdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgdGhhdC5maWx0ZXJDb25uZWN0UG9pbnQodGhhdC5hbGxOb2RlcywgdGhhdC5saW5lVHlwZSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdmFyIHggPSBlLmV2ZW50Lm9mZnNldFg7XHJcbiAgICAgICAgICAgICAgIHZhciB5ID0gZS5ldmVudC5vZmZzZXRZO1xyXG4gICAgICAgICAgICAgICB2YXIgYXJyb3cgPSBlLmV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgICAgdGhhdC5zdGFydFBvcyA9IGFycm93LnBvcztcclxuICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RDb25uTm9kZSA9IGZpbmRDb25uZWN0b3JOb2RlKGFycm93LnNoYXBlLmN4LCBhcnJvdy5zaGFwZS5jeSwgMCwgdGhhdC5zdGFydFBvcykubm9kZTtcclxuICAgICAgICAgICAgICAgYXJyb3cuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICB0aGF0LmxpbmVPcGVyYXRpb25NYW5hZ2VyLmhpZGVBbGxMaW5lT3BlcmF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgIHRoYXQucmV2ZXJzZUNvbm5lY3QgPSBmYWxzZTsgICAvL+aYr+WQpuWPjeWQkei/nue6v+eahOagh+ivhlxyXG4gICAgICAgICAgICAgICB0aGF0Lm9yaWdpbk5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XHJcbiAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3IgPSB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLm1hbmFnZVRlbXBDb25uZWN0b3IodGhhdC5zZWxlY3RDb25uTm9kZSwgcG9pbnQsIGFycm93LmxpbmVUeXBlLCB0aGF0LnN0YXJ0UG9zKTtcclxuICAgICAgICAgICAgICAgdGhhdC5fenIuYWRkKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cC5vbihcIkNvbm5lY3RQb2ludDpkcmFnXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgdmFyIGFycm93ID0gZS5ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgIHRoYXQuX2hhbmRsZUxpbmVEcmFnKCdkcmFnJywgZSwgYXJyb3cubGluZVR5cGUpO1xyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIHRoaXMuY29uUG9pbnRzR3JvdXAub24oXCJDb25uZWN0UG9pbnQ6ZHJhZ2VuZFwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBhcnJvdyA9IGUuZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICB0aGF0Ll9oYW5kbGVMaW5lRHJhZygnZHJhZ2VuZCcsIGUsIGFycm93LmxpbmVUeXBlKTtcclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5jb25Qb2ludHNHcm91cCk7XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDlpITnkIbov57nur/lkozov57mjqXngrlkcmFn5LqL5Lu2XHJcbiAgICAgICAgKiBAbWV0aG9kIF9oYW5kbGVMaW5lRHJhZ1xyXG4gICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBkcmFnVHlwZSBkcmFn57G75Z6LXHJcbiAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGUgICBldmVudOS6i+S7tuWvueixoVxyXG4gICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBsaW5lVHlwZSDov57nur/nsbvlnotcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5faGFuZGxlTGluZURyYWcgPSBmdW5jdGlvbihkcmFnVHlwZSwgZSwgbGluZVR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgeCA9IGUuZXZlbnQub2Zmc2V0WDtcclxuICAgICAgICAgICAgdmFyIHkgPSBlLmV2ZW50Lm9mZnNldFk7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRDb25uZWN0b3JOb2RlKHgsIHksIG9mZnNldCwgcG9zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSwgZW5kUG9zID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoYXQuYWxsTm9kZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGN1bGF0ZVJlY3QgPSB0aGF0LmNhbGN1bGF0ZVJlY3QoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RvclBvaW50ID0gdXRpbC5nZXRDb25uZWN0b3JQb2ludHMoY2FsY3VsYXRlUmVjdCwgeyByb3RhdGlvbjogY2FsY3VsYXRlUmVjdC5yb3RhdGlvbiB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtwb3NdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbcG9zXS55IC0geSkgPD0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImxlZnRcIl0ueCAtIHgpIDw9IG9mZnNldCAmJiBNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImxlZnRcIl0ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInRvcFwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1widG9wXCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IFwidG9wXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInJpZ2h0XCJdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbXCJyaWdodFwiXS55IC0geSkgPD0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3MgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImJvdHRvbVwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wiYm90dG9tXCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IFwiYm90dG9tXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZFBvczogZW5kUG9zXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcclxuICAgICAgICAgICAgaWYgKGRyYWdUeXBlID09PSAnZHJhZycpIHtcclxuICAgICAgICAgICAgaWYgKHRoYXQucmV2ZXJzZUNvbm5lY3QpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlUmV2ZXJzZVRlbXBDb25uZWN0b3IocG9pbnQsIHRoYXQuc2VsZWN0Q29ubk5vZGUsIGxpbmVUeXBlLCB0aGF0LmVuZFBvcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLm1hbmFnZVRlbXBDb25uZWN0b3IodGhhdC5zZWxlY3RDb25uTm9kZSwgcG9pbnQsIGxpbmVUeXBlLCB0aGF0LnN0YXJ0UG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0LmNvblBvaW50c0dyb3VwLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgdi5hdHRyKHtzdHlsZTp7ZmlsbDogXCIjRkZGRjMzXCJ9LHNjYWxlOlsxLDFdLG9yaWdpbjpbdi5zaGFwZS5jeCx2LnNoYXBlLmN5XSxjdXJzb3I6J2Nyb3NzaGFpcid9KTtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh2LnNoYXBlLmN4IC0geCkgPD0gMTAgJiYgTWF0aC5hYnModi5zaGFwZS5jeSAtIHkpIDw9IDEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IGZpbmRDb25uZWN0b3JOb2RlKHgsIHksIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5yZXZlcnNlQ29ubmVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLm1hbmFnZVJldmVyc2VUZW1wQ29ubmVjdG9yKHBvaW50LCB0aGF0LnNlbGVjdENvbm5Ob2RlLCBsaW5lVHlwZSwgdGhhdC5lbmRQb3MsIHJlcy5lbmRQb3MsIHJlcy5ub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLm1hbmFnZVRlbXBDb25uZWN0b3IodGhhdC5zZWxlY3RDb25uTm9kZSwgcG9pbnQsIGxpbmVUeXBlLCB0aGF0LnN0YXJ0UG9zLCByZXMuZW5kUG9zLCByZXMubm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHYuYXR0cih7c3R5bGU6e2ZpbGw6IFwiI2ZmMDAwMFwifSxzY2FsZTpbMS41LDEuNV0sb3JpZ2luOlt2LnNoYXBlLmN4LHYuc2hhcGUuY3ldLGN1cnNvcjoncG9pbnRlcid9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZHJhZ1R5cGUgPT09ICdkcmFnZW5kJykge1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gZmluZENvbm5lY3Rvck5vZGUoeCwgeSwgMTApO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHJlcy5ub2RlO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQ7XHJcbiAgICAgICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgICAgIHZhciBlbmRQb3MgPSByZXMuZW5kUG9zIHx8ICdsZWZ0JztcclxuICAgICAgICAgICAgdmFyIHN0YXJ0UG9zO1xyXG4gICAgICAgICAgICB2YXIgY2FuQ29ubmVjdCA9IGZhbHNlOyAgICAgICAvL+S4pOS4quiKgueCueaYr+WQpuWPr+S7pei/nue6v+eahOagh+ivhlxyXG4gICAgICAgICAgICAvL+WIoOmZpOS4tOaXtue6v1xyXG4gICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlbW92ZVRlbXBDb25uZWN0b3IodGhhdC5fenIpO1xyXG4gICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RDb25uTm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3ModGhhdC5zZWxlY3RDb25uTm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSAmJiBCcG1uLmlzU2xvdEV2ZW50KHRoYXQuc2VsZWN0Q29ubk5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5b2T5YmN6IqC54K55piv6L6555WM6IqC54K55Y+v6L+e57q/XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuQ29ubmVjdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSAmJiB0YXJnZXROb2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyh0YXJnZXROb2RlLnBhcmVudCkgJiYgdGFyZ2V0Tm9kZS5wYXJlbnQuaWQgPT09IHRoYXQuc2VsZWN0Q29ubk5vZGUucGFyZW50LmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6LW35aeL6IqC54K56YO95Zyo5ZCM5LiA5Liq5a2Q6IqC54K55YaF5YiZ5Y+v5Lul6L+e57q/XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuQ29ubmVjdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSAmJiAhdGFyZ2V0Tm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYW5Db25uZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXROb2RlICYmIHRhcmdldE5vZGUucGFyZW50ICYmIEJwbW4uaXNTdWJQcm9jZXNzKHRhcmdldE5vZGUucGFyZW50KSAmJiBCcG1uLmlzU2xvdEV2ZW50KHRhcmdldE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g55uu5qCH6IqC54K55piv6L6555WM6IqC54K55Y+v6L+e57q/XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuQ29ubmVjdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8yLuWmguaenOaJvuWIsOebruagh+e7k+eCuSDliJnnlLvnur9cclxuICAgICAgICAgICAgaWYgKGNhbkNvbm5lY3QgJiYgKHRoYXQuc2VsZWN0Q29ubk5vZGUuaWQgIT09IHRhcmdldE5vZGUuaWQpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVR5cGU6IGxpbmVUeXBlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGZpbmFsT3B0ID0gdXRpbC5tZXJnZU9wdChjb25uZWN0T3B0aW9ucywgdGhhdC5saW5lT3B0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhhdC5yZXZlcnNlQ29ubmVjdCA/IHRhcmdldE5vZGUgOiB0aGF0LnNlbGVjdENvbm5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgZW5kID0gdGhhdC5yZXZlcnNlQ29ubmVjdCA/IHRoYXQuc2VsZWN0Q29ubk5vZGUgOiB0YXJnZXROb2RlO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRQb3MgPSB0aGF0LnJldmVyc2VDb25uZWN0ID8gZW5kUG9zIDogdGhhdC5zdGFydFBvcztcclxuICAgICAgICAgICAgICAgIGVuZFBvcyA9IHRoYXQucmV2ZXJzZUNvbm5lY3QgPyB0aGF0LmVuZFBvcyA6IGVuZFBvcztcclxuICAgICAgICAgICAgICAgIHRoYXQuX2NyZWF0ZUNvbm5lY3RvckJ5Tm9kZXMoc3RhcnQsIGVuZCwgZmluYWxPcHQsIHN0YXJ0UG9zLCBlbmRQb3MpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5oaWRlQ29ubmVjdG9yUG9pbnQoKTsgICAgICAvL+makOiXj+aJgOacieiKgueCueS4iueahOi/nuaOpeeCuVxyXG4gICAgICAgICAgICAgICAgdGhhdC5oaWRlQ29ubmVjdG9yQ29udHJvbCgpOyAgICAgIC8v6ZqQ6JeP5omA5pyJ6IqC54K55LiK55qE5o6n5Yi254K5XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5vcmlnaW5Ob2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/lpoLmnpzov57nur/lpLHotKXvvIzkuJTljp/lp4vnur/mrrXlrZjlnKjvvIzliJnov5jljp/ljp/lp4vnur/mrrVcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRoYXQucmV2ZXJzZUNvbm5lY3QgPyB0aGF0Lm9yaWdpbk5vZGUgOiB0aGF0LnNlbGVjdENvbm5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHRoYXQucmV2ZXJzZUNvbm5lY3QgPyB0aGF0LnNlbGVjdENvbm5Ob2RlIDogdGhhdC5vcmlnaW5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zID0gdGhhdC5yZXZlcnNlQ29ubmVjdCA/IHRoYXQub3JpZ2luUG9zIDogdGhhdC5zdGFydFBvcztcclxuICAgICAgICAgICAgICAgICAgICBlbmRQb3MgPSB0aGF0LnJldmVyc2VDb25uZWN0ID8gdGhhdC5lbmRQb3MgOiB0aGF0Lm9yaWdpblBvcztcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9jcmVhdGVDb25uZWN0b3JCeU5vZGVzKHN0YXJ0LCBlbmQsIHsgc3R5bGU6IHRoYXQubGluZU9wdCB9LCBzdGFydFBvcywgZW5kUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmhpZGVDb25uZWN0b3JQb2ludCgpOyAgICAgIC8v6ZqQ6JeP5omA5pyJ6IqC54K55LiK55qE6L+e5o6l54K5XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8v6L+Y5Y6f5omA5pyJ6L+e5o6l54K555qE6aKc6ImyXHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25Qb2ludHNHcm91cC5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdi5hdHRyKHtzdHlsZTp7ZmlsbDogXCIjRkZGRjMzXCJ9LHNjYWxlOlsxLDFdLG9yaWdpbjpbdi5zaGFwZS5jeCx2LnNoYXBlLmN5XSxjdXJzb3I6J2Nyb3NzaGFpcid9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uc2hvd0Nvbm5lY3RvckNvbnRyb2wgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSB0aGF0Lm9wdHMuZ3JpZExpbmVTcGFjaW5nO1xyXG4gICAgICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JDb250cm9sKCk7XHJcbiAgICAgICAgICAgIC8vIOiuqeW9k+WJjeiKgueCueaYvuekuuaOp+WItueCuVxyXG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlUmVjdCA9IHRoaXMuY2FsY3VsYXRlUmVjdCh0aGlzLnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0ge1xyXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuc2VsZWN0ZWROb2RlLmlkLFxyXG4gICAgICAgICAgICAgICAgcm90YXRpb246IGNhbGN1bGF0ZVJlY3Qucm90YXRpb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29ubmVjdG9yUG9pbnQgPSB1dGlsLmdldENvbm5lY3RvckNvbnRyb2xzKGNhbGN1bGF0ZVJlY3QsIG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5yZXR1cm5Db25uZWN0b3JDb250cm9sUGFyYW0odGhpcy5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICBpZiAocGFyYW1zLnNjYWxlYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JDb250cm9sKGNvbm5lY3RvclBvaW50LnRsLCBcInRsXCIsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JDb250cm9sKGNvbm5lY3RvclBvaW50LnRyLCBcInRyXCIsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JDb250cm9sKGNvbm5lY3RvclBvaW50LmJsLCBcImJsXCIsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JDb250cm9sKGNvbm5lY3RvclBvaW50LmJyLCBcImJyXCIsIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMucm90YXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmNyZWF0ZUNvbm5lY3RvckNvbnRyb2woY29ubmVjdG9yUG9pbnQubXRyLCBcIm10clwiLCBub2RlKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuY3JlYXRlQ29ubmVjdG9yQ29udHJvbCh7IHRvcDogY29ubmVjdG9yUG9pbnQubXRyLCBib3R0b206IGNvbm5lY3RvclBvaW50LnRjIH0sIFwibXRyLHRjXCIsIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kQ29udHJvbE5vZGUgKGlkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmFsbE5vZGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmlkID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5jb25Db250cm9sc0dyb3VwLm9uKFwiQ29ubmVjdENvbnRyb2w6ZHJhZ3N0YXJ0XCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIOmmluWFiOa4hemZpOWFtuS7luaJgOacieiKgueCueeahOaOp+WItueCueWSjOi/nuaOpeeCuVxyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IGUuZXZlbnQudGFyZ2V0LmN1cnNvcjtcclxuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBlLmV2ZW50LnRhcmdldC5wb3M7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zTWFwID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICd0bCc6ICdicicsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3RyJzogJ2JsJyxcclxuICAgICAgICAgICAgICAgICAgICAnYmwnOiAndHInLFxyXG4gICAgICAgICAgICAgICAgICAgICdicic6ICd0bCdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdENvbm5Ob2RlID0gZmluZENvbnRyb2xOb2RlKGUubm9kZUlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IgJiYgcG9zICE9PSAnbXRyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5Ob2RlID0gdGhhdC5jb25Db250cm9sc0dyb3VwLmNoaWxkcmVuKCkuZmluZChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3MgPT09IHBvc01hcFtwb3NdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoYXQuY29uQ29udHJvbHNHcm91cC5jaGlsZHJlbigpLmZpbmQoZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zID09PSBwb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoYXQuc2VsZWN0Q29ubk5vZGUuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5vcHBvc2l0ZVNoYXBlID0genJVdGlsLmNsb25lKG9yaWdpbk5vZGUuc2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY3VycmVudFNoYXBlID0genJVdGlsLmNsb25lKGN1cnJlbnROb2RlLnNoYXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHpyVXRpbC5jbG9uZSh0aGF0LmNhbGN1bGF0ZVJlY3QodGhhdC5zZWxlY3RDb25uTm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWFnb25hbCA9IE1hdGguc3FydChNYXRoLnBvdyhyZWN0LndpZHRoLCAyKSArIE1hdGgucG93KHJlY3QuaGVpZ2h0LCAyKSk7Ly8g5a+56KeS57q/6ZW/5bqmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5kaWFnb25hbCA9IGRpYWdvbmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQub3JpZ2luUmVjdCA9IHpyVXRpbC5jbG9uZShyZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmlmUG9pbnRDZW50ZXIgPSBib3VuZGluZ1JlY3QueCA8IC0xOyAvLyDliKTmlq3kuK3lv4PngrnmmK/lkKblnKjoioLngrnkuK3lv4Mo5Y6f5b2i5Zyo5Lit5b+D77yM55+p5b2i5Zyo5bem5LiK6KeSKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIOenu+mZpG5vZGXpq5jkuq5cclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdENvbm5Ob2RlLnNlbGVjdFN0eWxlICYmIHRoYXQuX2FwaS5nZXRacigpLnJlbW92ZUhvdmVyKHRoYXQuc2VsZWN0Q29ubk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5jb25Db250cm9sc0dyb3VwLm9uKFwiQ29ubmVjdENvbnRyb2w6ZHJhZ1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gZS5ldmVudC50YXJnZXQuY3Vyc29yO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFBvcyA9IGUuZXZlbnQudGFyZ2V0LnBvcztcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoYXQuc2VsZWN0Q29ubk5vZGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IChlLmV2ZW50Lm9mZnNldFggLSB0aGF0Lmdyb3VwLnBvc2l0aW9uWzBdKSAvIHRoYXQubm93Wm9vbTtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gKGUuZXZlbnQub2Zmc2V0WSAtIHRoYXQuZ3JvdXAucG9zaXRpb25bMV0pIC8gdGhhdC5ub3dab29tO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3RPcmlnaW4gPSB1dGlsLmdldFJlY3QoY3VycmVudE5vZGUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFBvcyA9PT0gJ210cicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUucGFyZW50ICYmIEJwbW4uaXNTdWJQcm9jZXNzKGN1cnJlbnROb2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCAtPSBCcG1uVXRpbC5wYXJlbnRYKGN1cnJlbnROb2RlLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gQnBtblV0aWwucGFyZW50WShjdXJyZW50Tm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyDml4vovaxcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHBhcnNlSW50KCgoeCAtY3VycmVudE5vZGUucG9zaXRpb25bMF0pIC8gcGl4ZWwpLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBwYXJzZUludCgoKHkgLWN1cnJlbnROb2RlLnBvc2l0aW9uWzFdKSAvIHBpeGVsKSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByX3ggPSBwaXhlbCAqIG07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJfeSA9IHBpeGVsICogbjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2lucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogcmVjdE9yaWdpbi54IC0gY3VycmVudE5vZGUucG9zaXRpb25bMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHJlY3RPcmlnaW4ueSAtIGN1cnJlbnROb2RlLnBvc2l0aW9uWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IE1hdGguYXRhbjIocl95LCByX3gpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0ZWROb2RlLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JpZ2luJzogW29yaWdpbnMueCwgb3JpZ2lucy55XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JvdGF0aW9uJzogLXJvdGF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGN1bGF0ZVJlY3QgPSB0aGF0LmNhbGN1bGF0ZVJlY3QodGhhdC5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3JQb2ludCA9IHV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKGNhbGN1bGF0ZVJlY3QsIHsgcm90YXRpb246IGNhbGN1bGF0ZVJlY3Qucm90YXRpb24gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xQb2ludCA9IHV0aWwuZ2V0Q29ubmVjdG9yQ29udHJvbHMoY2FsY3VsYXRlUmVjdCwgeyByb3RhdGlvbjogY2FsY3VsYXRlUmVjdC5yb3RhdGlvbiB9KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDoioLngrnov57nur/ngrnvvIzmjqfliLbngrnkvY3nva7mm7TmlrBcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmNvblBvaW50c0dyb3VwLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gaXRlbS5wb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdDb25uZWN0UG9pbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFNoYXBlKHsgY3g6IGNvbm5lY3RvclBvaW50W3Bvc10ueCwgY3k6IGNvbm5lY3RvclBvaW50W3Bvc10ueSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY29uQ29udHJvbHNHcm91cC5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IGl0ZW0ucG9zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnQ29ubmVjdENvbnRyb2wnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09PSAnbXRyJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYXR0cigncG9zaXRpb24nLCBbMCwgMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYXR0cigncm90YXRpb24nLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0U2hhcGUoeyB4OiBjb250cm9sUG9pbnRbcG9zXS54IC0gNCwgeTogY29udHJvbFBvaW50W3Bvc10ueSAtIDQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcmlnaW4nOiBbaXRlbS5zaGFwZS54ICsgNCwgaXRlbS5zaGFwZS55ICsgNF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JvdGF0aW9uJzogLXJvdGF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09ICdDb25uZWN0Q29udHJvbExpbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFNoYXBlKHsgeDE6IGNvbnRyb2xQb2ludC5tdHIueCwgeDI6IGNvbnRyb2xQb2ludC50Yy54LCB5MTogY29udHJvbFBvaW50Lm10ci55LCB5MjogY29udHJvbFBvaW50LnRjLnkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g57yp5pS+KOe8qeaUvueCuemcgOimgee7k+WQiOaXi+i9rOinkuW6puiuoeeulylcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXIgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyUG9pbnQgPSB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgwLCBoZWlnaHQwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JzWSA9IFsnbi1yZXNpemUnLCAncy1yZXNpemUnXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25PcmcgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICd0bCc6ICdicicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cic6ICdibCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdibCc6ICd0cicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdicic6ICd0bCdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZU5vZGVzID0gdGhhdC5jb25Db250cm9sc0dyb3VwLmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdDb25uZWN0Q29udHJvbCcgJiYgbm9kZS5wb3MgIT09ICdtdHInXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDb250cm9sTm9kZSA9IHNjYWxlTm9kZXMuZmluZChmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnBvcyA9PT0gdGFyZ2V0UG9zO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA8PSA4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSA4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoeSA8PSA4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSA4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvcnNZLmluY2x1ZGVzKGN1cnNvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g6I635Y+Weei9tOavlOS+i+WNs+WPr1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRZID0gY3VycmVudENvbnRyb2xOb2RlLnNoYXBlLnkgKyA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYXRpbyA9IE1hdGguYWJzKHBhcnNlSW50KCgoeSAtIHRoYXQub3Bwb3NpdGVTaGFwZS55IC0gNCkgLyBwaXhlbCksIDEwKSkgLyBNYXRoLmFicyhwYXJzZUludCgoKHN0YXJ0WSAtIHRoYXQub3Bwb3NpdGVTaGFwZS55KSAvIHBpeGVsKSwgMTApKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDojrflj5Z46L205q+U5L6L5Y2z5Y+vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFggPSBjdXJyZW50Q29udHJvbE5vZGUuc2hhcGUueCArIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdGlvID0gTWF0aC5hYnMocGFyc2VJbnQoKCh4IC0gdGhhdC5vcHBvc2l0ZVNoYXBlLnggLSA0KSAvIHBpeGVsKSwgMTApKSAvIE1hdGguYWJzKHBhcnNlSW50KCgoc3RhcnRYIC0gdGhhdC5vcHBvc2l0ZVNoYXBlLngpIC8gcGl4ZWwpLCAxMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIS9eWzAtOV0rLj9bMC05XSovLnRlc3QocmF0aW8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdGlvID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUudXBkYXRlU2hhcGUocmF0aW8pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdFNjYWxlID0gdXRpbC5nZXRSZWN0KGN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBjZW50ZXJQb2ludCA9IHRoYXQuaWZQb2ludENlbnRlciA/IHsgeDogdGhhdC5vcmlnaW5SZWN0LngsIHk6IHRoYXQub3JpZ2luUmVjdC55IH0gOiB7IHg6IHRoYXQub3JpZ2luUmVjdC5ib3VuZGluZ1JlY3QueCwgeTogdGhhdC5vcmlnaW5SZWN0LmJvdW5kaW5nUmVjdC55IH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpYWdvbmFsTmV3ID0gTWF0aC5zcXJ0KE1hdGgucG93KHJlY3RTY2FsZS53aWR0aCwgMikgKyBNYXRoLnBvdyhyZWN0U2NhbGUuaGVpZ2h0LCAyKSk7Ly8g5a+56KeS57q/6ZW/5bqmXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjdXJzb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5LiKLOW3puS4ilxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduLXJlc2l6ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ253LXJlc2l6ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDAgPSAodGhhdC5vcHBvc2l0ZVNoYXBlLnggKyA0IC0gY2VudGVyUG9pbnQueCkgKiBkaWFnb25hbE5ldyAvIHRoYXQuZGlhZ29uYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQwID0gKHRoYXQub3Bwb3NpdGVTaGFwZS55ICsgNCAtIGNlbnRlclBvaW50LnkpICogZGlhZ29uYWxOZXcgLyB0aGF0LmRpYWdvbmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyLnB1c2godGhhdC5vcHBvc2l0ZVNoYXBlLnggLSB3aWR0aDAgKyA0LCB0aGF0Lm9wcG9zaXRlU2hhcGUueSAtIGhlaWdodDAgKyA0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlj7Ms5Y+z5LiKXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2UtcmVzaXplJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmUtcmVzaXplJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoMCA9IChjZW50ZXJQb2ludC54IC0gdGhhdC5vcHBvc2l0ZVNoYXBlLnggLSA0KSAqIGRpYWdvbmFsTmV3IC8gdGhhdC5kaWFnb25hbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDAgPSAodGhhdC5vcHBvc2l0ZVNoYXBlLnkgKyA0IC0gY2VudGVyUG9pbnQueSkgKiBkaWFnb25hbE5ldyAvIHRoYXQuZGlhZ29uYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXIucHVzaCh0aGF0Lm9wcG9zaXRlU2hhcGUueCArIHdpZHRoMCArIDQsIHRoYXQub3Bwb3NpdGVTaGFwZS55IC0gaGVpZ2h0MCArIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOS4i++8jOWPs+S4i1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzLXJlc2l6ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlLXJlc2l6ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDAgPSAoY2VudGVyUG9pbnQueCAtIHRoYXQub3Bwb3NpdGVTaGFwZS54IC0gNCkgKiBkaWFnb25hbE5ldyAvIHRoYXQuZGlhZ29uYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQwID0gKGNlbnRlclBvaW50LnkgLSB0aGF0Lm9wcG9zaXRlU2hhcGUueSAtIDQpICogZGlhZ29uYWxOZXcgLyB0aGF0LmRpYWdvbmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyLnB1c2godGhhdC5vcHBvc2l0ZVNoYXBlLnggKyB3aWR0aDAgKyA0LCB0aGF0Lm9wcG9zaXRlU2hhcGUueSArIGhlaWdodDAgKyA0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlt6Ys5bem5LiLXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ctcmVzaXplJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3ctcmVzaXplJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoMCA9ICh0aGF0Lm9wcG9zaXRlU2hhcGUueCArIDQgLSBjZW50ZXJQb2ludC54KSAqIGRpYWdvbmFsTmV3IC8gdGhhdC5kaWFnb25hbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDAgPSAoY2VudGVyUG9pbnQueSAtIHRoYXQub3Bwb3NpdGVTaGFwZS55IC0gNCkgKiBkaWFnb25hbE5ldyAvIHRoYXQuZGlhZ29uYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXIucHVzaCh0aGF0Lm9wcG9zaXRlU2hhcGUueCAtIHdpZHRoMCArIDQsIHRoYXQub3Bwb3NpdGVTaGFwZS55ICsgaGVpZ2h0MCArIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3MoY3VycmVudE5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50UmVjdCA9IHRoYXQuY2FsY3VsYXRlUmVjdChjdXJyZW50Tm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSB1dGlsLmNhbGN1bGF0ZVBvaW50cyhjZW50ZXIsIHBhcmVudFJlY3QsIC1wYXJlbnRSZWN0LnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyID0gW25ld1Bvc2l0aW9uWzBdIC0gcGFyZW50UmVjdC5ib3VuZGluZ1JlY3QueCwgbmV3UG9zaXRpb25bMV0gLSBwYXJlbnRSZWN0LmJvdW5kaW5nUmVjdC55XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5TY2FsZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogcmVjdFNjYWxlLnggLSBjZW50ZXJbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHJlY3RTY2FsZS55IC0gY2VudGVyWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9zaXRpb24nOiBjZW50ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmlnaW4nOiBbb3JpZ2luU2NhbGUueCwgb3JpZ2luU2NhbGUueV1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5q2k5pe26IqC54K55YyF5Zu055uS6ZyA6KaB6YeN5paw6K6h566XXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3ROb3cgPSB0aGF0LmNhbGN1bGF0ZVJlY3QoY3VycmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3JQb2ludFNjYWxlID0gdXRpbC5nZXRDb25uZWN0b3JQb2ludHMocmVjdE5vdywgeyByb3RhdGlvbjogcmVjdE5vdy5yb3RhdGlvbiB9KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbFBvaW50U2NhbGUgPSB1dGlsLmdldENvbm5lY3RvckNvbnRyb2xzKHJlY3ROb3csIHsgcm90YXRpb246IHJlY3ROb3cucm90YXRpb24gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25Db250cm9sc0dyb3VwLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBpdGVtLnBvcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gdGFyZ2V0UG9zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHIoJ3Bvc2l0aW9uJywgWzAsIDBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnQ29ubmVjdENvbnRyb2wnICYmIHBvcyAhPT0gcG9zaXRpb25PcmdbdGFyZ2V0UG9zXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRTaGFwZSh7IHg6IGNvbnRyb2xQb2ludFNjYWxlW3Bvc10ueCAtIDQsIHk6IGNvbnRyb2xQb2ludFNjYWxlW3Bvc10ueSAtIDQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHIoJ29yaWdpbicsIFtjb250cm9sUG9pbnRTY2FsZVtwb3NdLngsIGNvbnRyb2xQb2ludFNjYWxlW3Bvc10ueV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gJ0Nvbm5lY3RDb250cm9sTGluZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0U2hhcGUoeyB4MTogY29udHJvbFBvaW50U2NhbGUubXRyLngsIHgyOiBjb250cm9sUG9pbnRTY2FsZS50Yy54LCB5MTogY29udHJvbFBvaW50U2NhbGUubXRyLnksIHkyOiBjb250cm9sUG9pbnRTY2FsZS50Yy55IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY29uUG9pbnRzR3JvdXAuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IGl0ZW0ucG9zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnQ29ubmVjdFBvaW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRTaGFwZSh7IGN4OiBjb25uZWN0b3JQb2ludFNjYWxlW3Bvc10ueCwgY3k6IGNvbm5lY3RvclBvaW50U2NhbGVbcG9zXS55IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm9wZXJhdGlvbk5vZGUucmVmcmVzaFBvc3Rpb24odGhhdC5zZWxlY3RlZE5vZGUsIHRoYXQuY2FsY3VsYXRlUmVjdCh0aGF0LnNlbGVjdGVkTm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0ZWROb2RlLnNsb3RFdmVudCAmJiB0aGF0LnNlbGVjdGVkTm9kZS5zbG90RXZlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOabtOaWsOS6i+S7tuiKgueCuVxyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlU2xvdEV2ZW50KHRoYXQuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIDEuNSDliLfmlrDov57nur9cclxuICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUodGhhdC5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5jb25Db250cm9sc0dyb3VwLm9uKFwiQ29ubmVjdENvbnRyb2w6ZHJhZ2VuZFwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDmm7TmlrDoioLngrlwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFBvcyA9IGUuZXZlbnQudGFyZ2V0LnBvcztcclxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhhdC5zZWxlY3RDb25uTm9kZTtcclxuICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHRoYXQub3B0cy5ncmlkTGluZVNwYWNpbmc7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBub2RlLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IG5vZGUub3JpZ2luO1xyXG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb24gb3JpZ2lu5Y+W5pW0XHJcbiAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdENvbm5Ob2RlLmF0dHIoJ3Bvc2l0aW9uJywgW3BhcnNlSW50KHBvc2l0aW9uWzBdLCAxMCksIHBhcnNlSW50KHBvc2l0aW9uWzFdLCAxMCldKTtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9yaWdpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdENvbm5Ob2RlLmF0dHIoJ29yaWdpbicsIFtwYXJzZUludChvcmlnaW5bMF0sIDEwKSwgcGFyc2VJbnQob3JpZ2luWzFdLCAxMCldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRQb3MgIT09ICdtdHInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS51cGRhdGVTaGFwZSgxLCB0cnVlLCBwaXhlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zbG90RXZlbnQgJiYgbm9kZS5zbG90RXZlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOabtOaWsOS6i+S7tuiKgueCuVxyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlU2xvdEV2ZW50KG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubW9kZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmm7TmlrBtb2RlbO+8jOaUr+aMgeW6j+WIl+WMli/lj43luo/liJfljJZcclxuICAgICAgICAgICAgICAgICAgICBub2RlLm1vZGVsLnNldChcIm9wdGlvbnMucm90YXRpb25cIiwgbm9kZS5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tb2RlbC5zZXQoXCJvcHRpb25zLm9yaWdpblwiLCBub2RlLm9yaWdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbm9kZS5tb2RlbC5vcHRpb24uZWxlbWVudFR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSAnSW1hZ2UnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubW9kZWwuc2V0KFwib3B0aW9ucy5zdHlsZVwiLCBub2RlLnN0eWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1vZGVsLnNldChcIm9wdGlvbnMuc2hhcGVcIiwgbm9kZS5zaGFwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gMS40IOinpuWPkeeCueWHu1xyXG4gICAgICAgICAgICAgICAgdGhhdC5ub2RlQ2xpY2tIYW5kbGVyKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5vcHBvc2l0ZVNoYXBlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoYXQuY3VycmVudFNoYXBlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoYXQuZGlhZ29uYWwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5vcmlnaW5SZWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoYXQuaWZQb2ludENlbnRlciA9IG51bGw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5jb25Db250cm9sc0dyb3VwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5nZXRSb3RhdGVkQ29ybmVyQ3Vyc29yID0gZnVuY3Rpb24obm9kZSwgcG9zKSB7XHJcbiAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgIHZhciByb3RhdGlvbiA9IG5vZGUucm90YXRpb247XHJcbiAgICAgICAgICAgaWYgKHBvcyA9PT0gJ210cicpIHtcclxuICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuY3Vyc29yTWFwW3Bvc107XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGlmIChNYXRoLmFicyhyb3RhdGlvbikgPiAwKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IC1yb3RhdGlvbiAvIChNYXRoLlBJLzE4MCk7XHJcbiAgICAgICAgICAgICAgIHZhciBuID0gTWF0aC5yb3VuZCgoYW5nbGUgJSAzNjApIC8gNDUpO1xyXG4gICAgICAgICAgICAgICBpZiAobiA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgIG4gKz0gODsgLy8gZnVsbCBjaXJjbGUgYWhlYWRcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBuICs9IHRoYXQuY3Vyc29yT2Zmc2V0W3Bvc107XHJcbiAgICAgICAgICAgICAgIG4gJT0gODtcclxuICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuY3Vyc29yTWFwc1tuXTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgcmV0dXJuIHRoYXQuY3Vyc29yTWFwW3Bvc107XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5jcmVhdGVDb25uZWN0b3JDb250cm9sID0gZnVuY3Rpb24ocG9pbnQsIHBvcywgbm9kZSkge1xyXG4gICAgICAgICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICAgICAgICAgdmFyIHBvc0FyciA9IHBvcy5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgIGlmIChwb3NBcnIubGVuZ3RoIDwgMikge1xyXG4gICAgICAgICAgICAgICB2YXIgY29udHJvbEN1cnNvciA9IG1lLmdldFJvdGF0ZWRDb3JuZXJDdXJzb3Iobm9kZSwgcG9zKTtcclxuICAgICAgICAgICAgICAgdmFyIHBvaW50SW5zdGFuY2UgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgICAgICAgIHNoYXBlOntcclxuICAgICAgICAgICAgICAgICAgICAgICB4OiBwb2ludC54IC0gNCxcclxuICAgICAgICAgICAgICAgICAgICAgICB5OiBwb2ludC55IC0gNCxcclxuICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogOCxcclxuICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDhcclxuICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcclxuICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6JyMwMDAwMDAnXHJcbiAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgejogMixcclxuICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBub2RlLnJvdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgb3JpZ2luOiBbcG9pbnQueCwgcG9pbnQueV0sXHJcbiAgICAgICAgICAgICAgICAgICBjdXJzb3I6IGNvbnRyb2xDdXJzb3IsXHJcbiAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIHBvaW50SW5zdGFuY2UudHlwZSA9ICdDb25uZWN0Q29udHJvbCc7XHJcbiAgICAgICAgICAgICAgIHBvaW50SW5zdGFuY2UucG9zID0gcG9zOy8vIOiusOW9leaYr+iKgueCueS4iuWTquS4quS9jee9rueahOi/nuaOpeeCuVxyXG4gICAgICAgICAgICAgICB2YXIgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2RyYWdzdGFydCcsICdkcmFnJywgJ2RyYWdlbmQnXTtcclxuICAgICAgICAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgIHBvaW50SW5zdGFuY2Uub24oZXZlTmFtZSwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJDb25uZWN0Q29udHJvbDpcIiArIGV2ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLm5vZGVJZCA9IG5vZGUuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmN1cnNvciA9IGNvbnRyb2xDdXJzb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgbWUuY29uQ29udHJvbHNHcm91cC50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICB0aGlzLmNvbkNvbnRyb2xzR3JvdXAuYWRkKHBvaW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIC8vIOaXi+i9rOeCueS4juiKgueCueS5i+mXtOmcgOimgei/nue6v1xyXG4gICAgICAgICAgICAgICB2YXIgbGluZSA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICB4MTogcG9pbnQudG9wLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgeTE6IHBvaW50LnRvcC55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHgyOiBwb2ludC5ib3R0b20ueCxcclxuICAgICAgICAgICAgICAgICAgICAgICB5MjogcG9pbnQuYm90dG9tLnlcclxuICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMVxyXG4gICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgIHo6IDEsXHJcbiAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIGxpbmUudHlwZSA9ICdDb25uZWN0Q29udHJvbExpbmUnO1xyXG4gICAgICAgICAgICAgICBsaW5lLm5vZGVJZCA9IG5vZGUuaWQ7XHJcbiAgICAgICAgICAgICAgIHRoaXMuY29uQ29udHJvbHNHcm91cC5hZGQobGluZSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfVxyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8ucmV0dXJuQ29ubmVjdG9yQ29udHJvbFBhcmFtID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgIHZhciBzY2FsZUZsYWcgPSBmYWxzZTtcclxuICAgICAgICAgICB2YXIgcm90YXRlRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgIGlmICh0aGlzLm9wdHMuc2NhbGVhYmxlKSB7XHJcbiAgICAgICAgICAgICAgIHNjYWxlRmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGlmIChub2RlLm1vZGVsLmdldChcInByb3BlcnRpZXMuc2NhbGVhYmxlXCIpKSB7XHJcbiAgICAgICAgICAgICAgIHNjYWxlRmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgc2NhbGVGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGlmIChub2RlLnNjYWxlYWJsZSkge1xyXG4gICAgICAgICAgICAgICBzY2FsZUZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgIH0gZWxzZSBpZiAoIW5vZGUuc2NhbGVhYmxlICYmICFub2RlLm1vZGVsLmdldChcInByb3BlcnRpZXMuc2NhbGVhYmxlXCIpKSB7XHJcbiAgICAgICAgICAgICAgIHNjYWxlRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgaWYgKHRoaXMub3B0cy5yb3RhdGFibGUpIHtcclxuICAgICAgICAgICAgICAgcm90YXRlRmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGlmIChub2RlLm1vZGVsLmdldChcInByb3BlcnRpZXMucm90YXRhYmxlXCIpKSB7XHJcbiAgICAgICAgICAgICAgIHJvdGF0ZUZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIHJvdGF0ZUZsYWcgPSBmYWxzZTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgaWYgKG5vZGUucm90YXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgIHJvdGF0ZUZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgIH0gZWxzZSBpZiAoIW5vZGUucm90YXRhYmxlICYmICFub2RlLm1vZGVsLmdldChcInByb3BlcnRpZXMucm90YXRhYmxlXCIpKSB7XHJcbiAgICAgICAgICAgICAgIHJvdGF0ZUZsYWcgPSBmYWxzZTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgc2NhbGVhYmxlOiBzY2FsZUZsYWcsXHJcbiAgICAgICAgICAgICAgIHJvdGF0YWJsZTogcm90YXRlRmxhZ1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH1cclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmhpZGVDb25uZWN0b3JDb250cm9sID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgdGhpcy5jb25Db250cm9sc0dyb3VwLnJlbW92ZUFsbCgpOyAgLy/pmpDol4/miYDmnInoioLngrnkuIrnmoTov57mjqXngrlcclxuICAgICAgICAgICB0aGlzLmNvbkNvbnRyb2xzR3JvdXAub2ZmKCk7ICAgICAgICAvL+a4heepuuaJgOacieS6i+S7tlxyXG4gICAgICAgICAgIHRoaXMuX3pyLnJlbW92ZSh0aGlzLmNvbkNvbnRyb2xzR3JvdXApO1xyXG4gICAgICAgfVxyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICog54K55Ye76L+e57q/5oyJ6ZKu5pe25Yib5bu66Zmk6YCJ5Lit6IqC54K55aSW5YW25L2Z6IqC54K56L655qGG5LiK55qE6L+e5o6l54K5XHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uY3JlYXRlTGluZUNvbm5lY3RvclBvaW50ID0gZnVuY3Rpb24ocG9pbnQsIHBvcywgbGluZVR5cGUpIHtcclxuICAgICAgICAgICB2YXIgcG9pbnRJbnN0YW5jZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICBjeDogcG9pbnQueCxcclxuICAgICAgICAgICAgICAgICAgIGN5OiBwb2ludC55LFxyXG4gICAgICAgICAgICAgICAgICAgcjogNFxyXG4gICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgZmlsbDogJyNGRkZGMzMnLFxyXG4gICAgICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwMDAwJ1xyXG4gICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICB6IDogNCxcclxuICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICBsaW5lVHlwZTogbGluZVR5cGVcclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICBwb2ludEluc3RhbmNlLnR5cGUgPSAnQ29ubmVjdFBvaW50JztcclxuICAgICAgICAgICBwb2ludEluc3RhbmNlLnBvcyA9IHBvczsgICAgICAgICAgICAgICAgLy/orrDlvZXmmK/oioLngrnkuIrlk6rkuKrkvY3nva7nmoTov57mjqXngrlcclxuXHJcbiAgICAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cC5hZGQocG9pbnRJbnN0YW5jZSk7XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICog5Yid5aeL5YyWIOaTjeS9nOeahOiZmue6v+ahhlxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmluaXRPcGVyYXRpb25Ob2RlID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUgPSBuZXcgT3BlcmF0aW9uTm9kZShub2RlLCB0aGlzLl96ciwgdGhpcy5fYXBpLCB0aGlzLmZvcmJpZEVkaXQpO1xyXG4gICAgICAgICAgIGZ1bmN0aW9uIGZpbmRDb25uZWN0b3JOb2RlKHgsIHksIG9mZnNldCwgcG9zKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBub2RlLCBlbmRQb3MgPSBudWxsO1xyXG4gICAgICAgICAgICAgICB0aGF0LmFsbE5vZGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIGNhblNob3dQb2ludCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IHRoYXQuc2VsZWN0ZWROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0ZWROb2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyh0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0ucGFyZW50ICYmIEJwbW4uaXNTdWJQcm9jZXNzKGl0ZW0ucGFyZW50KSAmJiBpdGVtLnBhcmVudC5pZCA9PT0gdGhhdC5zZWxlY3RlZE5vZGUucGFyZW50LmlkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhblNob3dQb2ludCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJwbW4uaXNTbG90RXZlbnQodGhhdC5zZWxlY3RlZE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5TaG93UG9pbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaXRlbS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3MoaXRlbS5wYXJlbnQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuU2hvd1BvaW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3MoaXRlbS5wYXJlbnQpICYmIEJwbW4uaXNTbG90RXZlbnQoaXRlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhblNob3dQb2ludCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoY2FuU2hvd1BvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWxOb2RlQ2FsID0gdGhhdC5jYWxjdWxhdGVSZWN0KGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3JQb2ludCA9IHV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKHJlYWxOb2RlQ2FsLCB7IHJvdGF0aW9uOiByZWFsTm9kZUNhbC5yb3RhdGlvbiB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtwb3NdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbcG9zXS55IC0geSkgPD0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImxlZnRcIl0ueCAtIHgpIDw9IG9mZnNldCAmJiBNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImxlZnRcIl0ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInRvcFwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1widG9wXCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IFwidG9wXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInJpZ2h0XCJdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbXCJyaWdodFwiXS55IC0geSkgPD0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3MgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImJvdHRvbVwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wiYm90dG9tXCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IFwiYm90dG9tXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxyXG4gICAgICAgICAgICAgICAgICAgZW5kUG9zOiBlbmRQb3NcclxuICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgLy8g5L6m5ZCsIOeureWktCDmi5bmi73lvIDlp4vkuovku7ZcclxuICAgICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHU1RBUlQsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgdGhhdC5oaWRlQ29ubmVjdG9yUG9pbnQoKTtcclxuICAgICAgICAgICAgICAgdGhhdC5maWx0ZXJDb25uZWN0UG9pbnQodGhhdC5hbGxOb2RlcywgZS5ldmVudC50YXJnZXQubGluZVR5cGUpO1xyXG4gICAgICAgICAgICAgICB0aGF0Ll96ci5hZGQodGhhdC5jb25Qb2ludHNHcm91cCk7XHJcbiAgICAgICAgICAgICAgIHZhciB4ID0gZS5ldmVudC5vZmZzZXRYO1xyXG4gICAgICAgICAgICAgICB2YXIgeSA9IGUuZXZlbnQub2Zmc2V0WTtcclxuICAgICAgICAgICAgICAgLy/mi5bmi73lvIDlp4vlhYjmioog566t5aS05Zu+5qCHIOe7memakOiXj1xyXG4gICAgICAgICAgICAgICB2YXIgYXJyb3cgPSBlLmV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgICAgaWYgKGUuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgdGhhdC5saW5lT3B0ID0gZS5kYXRhOyAgLy/nvJPlrZjnur/mrrXnmoTphY3nva7kv6Hmga9cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBhcnJvdy5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgIHZhciByRW5kUG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XHJcbiAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3IgPSB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLm1hbmFnZVRlbXBDb25uZWN0b3IodGhhdC5zZWxlY3RlZE5vZGUsIHJFbmRQb2ludCwgYXJyb3cubGluZVR5cGUpO1xyXG4gICAgICAgICAgICAgICB0aGF0Ll96ci5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgLy8g5L6m5ZCsIOeureWktCDmi5bmi73kuovku7ZcclxuICAgICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgIHZhciB4ID0gZS5ldmVudC5vZmZzZXRYO1xyXG4gICAgICAgICAgICAgICB2YXIgeSA9IGUuZXZlbnQub2Zmc2V0WTtcclxuICAgICAgICAgICAgICAgdmFyIHJFbmRQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcclxuICAgICAgICAgICAgICAgdmFyIGFycm93ID0gZS5ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlVGVtcENvbm5lY3Rvcih0aGF0LnNlbGVjdGVkTm9kZSwgckVuZFBvaW50LCBhcnJvdy5saW5lVHlwZSk7XHJcbiAgICAgICAgICAgICAgIHRoYXQuY29uUG9pbnRzR3JvdXAuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICB2LmF0dHIoe3N0eWxlOntmaWxsOiBcIiNGRkZGMzNcIn0sc2NhbGU6WzEsMV0sb3JpZ2luOlt2LnNoYXBlLmN4LHYuc2hhcGUuY3ldLGN1cnNvcjonY3Jvc3NoYWlyJ30pO1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHYuc2hhcGUuY3ggLSB4KSA8PSAxMCAmJiBNYXRoLmFicyh2LnNoYXBlLmN5IC0geSkgPD0gMTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gZmluZENvbm5lY3Rvck5vZGUoeCwgeSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlVGVtcENvbm5lY3Rvcih0aGF0LnNlbGVjdGVkTm9kZSwgckVuZFBvaW50LCBhcnJvdy5saW5lVHlwZSwgJ3JpZ2h0JywgcmVzLmVuZFBvcywgcmVzLm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHYuYXR0cih7c3R5bGU6e2ZpbGw6IFwiI2ZmMDAwMFwifSxzY2FsZTpbMS41LDEuNV0sb3JpZ2luOlt2LnNoYXBlLmN4LHYuc2hhcGUuY3ldLGN1cnNvcjoncG9pbnRlcid9KTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgLy/kvqblkKwg566t5aS0IOaLluaLvee7k+adn+S6i+S7tiDnlLvnur9cclxuICAgICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHRU5ELCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgIHZhciB4ID0gZS5ldmVudC5vZmZzZXRYO1xyXG4gICAgICAgICAgICAgICB2YXIgeSA9IGUuZXZlbnQub2Zmc2V0WTtcclxuICAgICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAvL+aLluaLvee7k+adn+WFiOaKiiDnrq3lpLTlm77moIcg57uZ5pi+56S6XHJcbiAgICAgICAgICAgICAgIHZhciBhcnJvdyA9IGUuZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICBhcnJvdy5zaG93KCk7XHJcblxyXG4gICAgICAgICAgICAgICB2YXIgcmVzID0gZmluZENvbm5lY3Rvck5vZGUoeCwgeSwgMTApO1xyXG4gICAgICAgICAgICAgICB2YXIgc3RhcnQ7XHJcbiAgICAgICAgICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgICAgICAgIHZhciBlbmRQb3MgPSByZXMuZW5kUG9zIHx8ICdsZWZ0JztcclxuICAgICAgICAgICAgICAgdmFyIHN0YXJ0UG9zO1xyXG4gICAgICAgICAgICAgICB2YXIgY2FuQ29ubmVjdCA9IGZhbHNlOyAgICAgICAvL+S4pOS4quiKgueCueaYr+WQpuWPr+S7pei/nue6v+eahOagh+ivhlxyXG4gICAgICAgICAgICAgICB0YXJnZXROb2RlID0gcmVzLm5vZGU7XHJcbiAgICAgICAgICAgICAgIGFycm93ID0gZS5ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgIC8v5Yig6Zmk5Li05pe257q/XHJcbiAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIucmVtb3ZlVGVtcENvbm5lY3Rvcih0aGF0Ll96cik7XHJcbiAgICAgICAgICAgICAgIGlmICh0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3ModGhhdC5zZWxlY3RlZE5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXROb2RlICYmIEJwbW4uaXNTbG90RXZlbnQodGhhdC5zZWxlY3RlZE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOW9k+WJjeiKgueCueaYr+i+ueeVjOiKgueCueWPr+i/nue6v1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5Db25uZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSAmJiB0YXJnZXROb2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyh0YXJnZXROb2RlLnBhcmVudCkgJiYgdGFyZ2V0Tm9kZS5wYXJlbnQuaWQgPT09IHRoYXQuc2VsZWN0ZWROb2RlLnBhcmVudC5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIOi1t+Wni+iKgueCuemDveWcqOWQjOS4gOS4quWtkOiKgueCueWGheWImeWPr+S7pei/nue6v1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGNhbkNvbm5lY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUgJiYgIXRhcmdldE5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgY2FuQ29ubmVjdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSAmJiB0YXJnZXROb2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyh0YXJnZXROb2RlLnBhcmVudCkgJiYgQnBtbi5pc1Nsb3RFdmVudCh0YXJnZXROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIOebruagh+iKgueCueaYr+i+ueeVjOiKgueCueWPr+i/nue6v1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGNhbkNvbm5lY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIC8vMi7lpoLmnpzmib7liLDnm67moIfnu5Pngrkg5YiZ55S757q/XHJcbiAgICAgICAgICAgICAgIGlmIChjYW5Db25uZWN0ICYmICh0aGF0LnNlbGVjdGVkTm9kZS5pZCAhPT0gdGFyZ2V0Tm9kZS5pZCkpIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBjb25uZWN0T3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhhdC5zZWxlY3RlZE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICBlbmQgPSB0YXJnZXROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgc3RhcnRQb3MgPSAncmlnaHQnO1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RPcHRpb25zID0gZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVUeXBlOiBhcnJvdy5saW5lVHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgdGhhdC5fY3JlYXRlQ29ubmVjdG9yQnlOb2RlcyhzdGFydCwgZW5kLCBjb25uZWN0T3B0aW9ucywgc3RhcnRQb3MsIGVuZFBvcyk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdGhhdC5oaWRlQ29ubmVjdG9yUG9pbnQoKTsgICAgICAvL+makOiXj+aJgOacieiKgueCueS4iueahOi/nuaOpeeCuVxyXG4gICAgICAgICAgICAgICAvLyDov57nur/miJDlip8v5aSx6LSl77yM5b2T5YmN6IqC54K55L6d54S25piv6YCJ5Lit54q25oCB77yM6ZyA6KaB6YeN5paw6K6h566X6Jma57q/5ZKM5Zu+5qCH5L2N572uXHJcbiAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhhdC5zZWxlY3RlZE5vZGU7XHJcbiAgICAgICAgICAgICAgIHZhciBzaGFwZVJlY3QgPSB0aGF0LmNhbGN1bGF0ZVJlY3Qobm9kZSk7XHJcbiAgICAgICAgICAgICAgIC8vIOaYvuekuuW9k+WJjeiKgueCueeahOi/nuaOpeeCuVxyXG4gICAgICAgICAgICAgICB0aGF0LnNob3dDb25uZWN0b3JQb2ludCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgIHRoYXQub3BlcmF0aW9uTm9kZS5yZWZyZXNoUG9zdGlvbihub2RlLCBzaGFwZVJlY3QpO1xyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIC8v5Yig6Zmk5oyJ6ZKu54K55Ye75LqL5Lu2XHJcbiAgICAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlLm9uKFwiT3BlcmF0aW9uTm9kZTpkZWxldGVDbGlja1wiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgdGhhdC5yZW1vdmVOb2RlKHRoYXQuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAvL+azqOmHiuaMiemSrueCueWHu+S6i+S7tlxyXG4gICAgICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZS5vbihcIk9wZXJhdGlvbk5vZGU6Y29tbWVudENsaWNrXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGF0LnNlbGVjdGVkTm9kZTtcclxuICAgICAgICAgICAgICAgaWYgKCFzdGFydC5oYXNDb21tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgZW5kWCwgZW5kWTtcclxuICAgICAgICAgICAgICAgICAgIGlmIChzdGFydC5icG1uSW5mby5uYW1lLmluZGV4T2YoJ0V2ZW50JykgIT09IC0xIHx8IHN0YXJ0LmJwbW5JbmZvLm5hbWUuaW5kZXhPZignR2F0ZXdheScpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGVuZFggPSBzdGFydC5wb3NpdGlvblswXSArIDQwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGVuZFkgPSBzdGFydC5wb3NpdGlvblsxXSAtIDgwO1xyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydC5ub2RlVHlwZSA9PT0gXCJTdWJQcm9jZXNzXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBlbmRYID0gc3RhcnQucG9zaXRpb25bMF0gKyAyMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZW5kWSA9IHN0YXJ0LnBvc2l0aW9uWzFdIC0gODA7XHJcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGVuZFggPSBzdGFydC5wb3NpdGlvblswXSArIDEyMDtcclxuICAgICAgICAgICAgICAgICAgICAgICBlbmRZID0gc3RhcnQucG9zaXRpb25bMV0gLSA4MDtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbCA9IG5ldyBCUE1OTW9kZWwoe30pO1xyXG4gICAgICAgICAgICAgICAgICAgbW9kZWwuc2V0KEJwbW4uQlBNTl9UWVBFLCAnQ29tbWVudCcpO1xyXG4gICAgICAgICAgICAgICAgICAgbW9kZWwuc2V0KFwiYm91bmRzLnVwcGVyTGVmdFwiLCB7eDogZW5kWCwgeTogZW5kWX0pO1xyXG4gICAgICAgICAgICAgICAgICAgbW9kZWwuc2V0KFwicHJvcGVydGllc1wiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJjb21tZW50XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWNvbnM6IFt7bmFtZTonREVMJywgY2FsbGJhY2s6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQuaGFzQ29tbWVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnJlbW92ZShlbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH19XVxyXG4gICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gdGhhdC5hZGROb2RlQnlNb2RlbChtb2RlbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICBtb2RlbCA9IG5ldyBCUE1OTW9kZWwoe30pO1xyXG4gICAgICAgICAgICAgICAgICAgbW9kZWwuc2V0KFwicmVzb3VyY2VJZFwiLCB1dGlsLmdldFVVSUQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICBtb2RlbC5zZXQoXCJzdHlsZS5saW5lVHlwZVwiLCBcInN0cmFpZ2h0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgbW9kZWwuc2V0KFwic3R5bGUubGluZURhc2hcIiwgWzNdKTtcclxuICAgICAgICAgICAgICAgICAgIG1vZGVsLnNldChcInN0eWxlLnN0cm9rZVwiLCBcIiMwMDBcIik7XHJcbiAgICAgICAgICAgICAgICAgICBtb2RlbC5zZXQoXCJzeW1ib2wudHlwZVwiLCBcIm5vbmVcIik7XHJcbiAgICAgICAgICAgICAgICAgICBtb2RlbC5zZXQoXCJzdGVuY2lsLnR5cGVcIiwgXCJTZXF1ZW5jZUZsb3dcIik7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9yID0gdGhhdC5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JDcmVhdGVCeU9wdGlvbnMoc3RhcnQsIGVuZCwge21vZGVsOiBtb2RlbH0sIHRoYXQuX2FwaSk7XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0Ll96ci5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgIHN0YXJ0Lmhhc0NvbW1lbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgdGhpcy5fenIuYWRkKHRoaXMub3BlcmF0aW9uTm9kZSk7XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uZmluZE5vZGVDaGlsZElkcyA9IGZ1bmN0aW9uIChub2RlLCBjaGlsZElkcykge1xyXG4gICAgICAgICAgIGNoaWxkSWRzLnB1c2gobm9kZS5pZCk7XHJcbiAgICAgICAgICAgbm9kZS5jaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5hbGxOb2Rlcy5maW5kSW5kZXgoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmlkID09PSB2LmlkXHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICByZXR1cm4gcG9zICE9PSAtMVxyXG4gICAgICAgICAgIH0uYmluZCh0aGlzKSkuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7XHJcbiAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU3ViUHJvY2VzcyhzdWIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmROb2RlQ2hpbGRJZHMoc3ViLCBjaGlsZElkcyk7XHJcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICBjaGlsZElkcy5wdXNoKHN1Yi5pZCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgfVxyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICog56e76Zmk5Zy65pmv5Lit55qE5p+Q5Liq6IqC54K5XHJcbiAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNlbGVjdGVkTm9kZSDlvoXliKDpmaTnmoToioLngrlcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5yZW1vdmUgPSBmaXNoVG9wb1Byb3RvLnJlbW92ZU5vZGUgPSBmdW5jdGlvbihkZWxOb2RlKSB7XHJcbiAgICAgICAgICAgdmFyIHBhcmVudFpyID0gdGhpcy5fZ2V0UGFyZW50WnIoZGVsTm9kZSksIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICBpZiAoZGVsTm9kZSBpbnN0YW5jZW9mIENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ2JlZm9yZURlbGV0ZUxpbmUnLCB7dGFyZ2V0OiBkZWxOb2RlfSwgZGVsTm9kZSkudGhlbihmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gMS4xIOWIoOmZpOe6v+auteS4iueahOaTjeS9nOWbvuagh1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKGRlbE5vZGUuaWNvbnMsIGZ1bmN0aW9uKGxpbmVPcGVyYXRpb25JY29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFpyLnJlbW92ZShsaW5lT3BlcmF0aW9uSWNvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAvLyAxLjIg5Yig6Zmk5b2T5YmN6YCJ5Lit57q/5q61XHJcbiAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdGlvbk1hbmFnZXIuZGVsZXRlTGluZShwYXJlbnRacik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXIoJ2FmdGVyRGVsZXRlTGluZScsIHt0YXJnZXQ6IGRlbE5vZGV9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ2JlZm9yZURlbGV0ZU5vZGUnLCB7dGFyZ2V0OiBkZWxOb2RlfSwgZGVsTm9kZSkudGhlbihmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50WnIucmVtb3ZlKGRlbE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZElkcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU3ViUHJvY2VzcyhkZWxOb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5maW5kTm9kZUNoaWxkSWRzKGRlbE5vZGUsIGNoaWxkSWRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZElkcy5wdXNoKGRlbE5vZGUuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAvLzIu5LuOYWxsTm9kZXPmlbDnu4TkuK3liKDpmaRcclxuICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hbGxOb2RlcyA9IF90aGlzLmFsbE5vZGVzLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRJZHMuaW5kZXhPZih2LmlkKSA9PT0gLTFcclxuICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb21BcnJheSA9IF90aGlzLmRvbUFycmF5LmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRJZHMuaW5kZXhPZih2LmlkKSA9PT0gLTFcclxuICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IF90aGlzLm92ZXJsYXBBcnJheS5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsTm9kZS5pZCA9PSBfdGhpcy5vdmVybGFwQXJyYXlba10uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm92ZXJsYXBBcnJheS5zcGxpY2UoaywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJwbW4uaXNTdWJQcm9jZXNzKGRlbE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgX3RoaXMuc3ViUHJvY2Vzc05vZGUubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxOb2RlLmlkID09IF90aGlzLnN1YlByb2Nlc3NOb2RlW21dLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3ViUHJvY2Vzc05vZGUuc3BsaWNlKG0sIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIOWIoOmZpOiKgueCueaTjeS9nFxyXG4gICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVPcGVyYXRpb25Ob2RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgLy8zLuWwhuatpOiKgueCueS6pOiBlOeahOe6v+S5n+WIoOmZpFxyXG4gICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmRlbGV0ZVNlbGVjdENvbihkZWxOb2RlLCBCcG1uLmlzU2xvdEV2ZW50KGRlbE5vZGUpID8gX3RoaXMuX3pyIDogcGFyZW50WnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c5Yig6Zmk6IqC54K55pivdGFza+iKgueCue+8jOmcgOimgeWwhuS+nemZhOWug+eahOS6i+S7tuiKgueCueWIoOmZpFxyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChCcG1uLmlzQWN0aXZpdHkoZGVsTm9kZSkgfHwgQnBtbi5pc1N1YlByb2Nlc3MoZGVsTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbE5vZGUuc2xvdEV2ZW50ICYmIGRlbE5vZGUuc2xvdEV2ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgZGVsTm9kZS5zbG90RXZlbnQubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsTm9kZS5zbG90RXZlbnRbbV0ucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU3ViUHJvY2VzcyhkZWxOb2RlLnNsb3RFdmVudFttXS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxOb2RlLnNsb3RFdmVudFttXS5wYXJlbnQucmVtb3ZlKGRlbE5vZGUuc2xvdEV2ZW50W21dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl96ci5yZW1vdmUoZGVsTm9kZS5zbG90RXZlbnRbbV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IF90aGlzLmFsbE5vZGVzLmxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxOb2RlLnNsb3RFdmVudFttXS5pZCA9PSBfdGhpcy5hbGxOb2Rlc1tuXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWxsTm9kZXMuc3BsaWNlKG4sIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgX3RoaXMuZG9tQXJyYXkubGVuZ3RoOyBhKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbE5vZGUuc2xvdEV2ZW50W21dLmlkID09IF90aGlzLmRvbUFycmF5W2FdLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb21BcnJheS5zcGxpY2UoYSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgLy80LuWmguaenOWIoOmZpOeahOaYr+S6i+S7tuiKgueCue+8jOmcgOimgeWwhue7keWumuWug+eahHRhc2voioLngrnnmoTmoIfor4bliKDpmaRcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoQnBtbi5pc1Nsb3RFdmVudChkZWxOb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IF90aGlzLmFsbE5vZGVzLmxlbmd0aDsgYisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYWxsTm9kZXNbYl0uaXNDYW5TbG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmFsbE5vZGVzW2JdLnNsb3RFdmVudCAmJiBfdGhpcy5hbGxOb2Rlc1tiXS5zbG90RXZlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IF90aGlzLmFsbE5vZGVzW2JdLnNsb3RFdmVudC5sZW5ndGg7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbE5vZGUuaWQgPT0gX3RoaXMuYWxsTm9kZXNbYl0uc2xvdEV2ZW50W2NdLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWxsTm9kZXNbYl0uc2xvdEV2ZW50LnNwbGljZShjLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdHJpZ2dlcignYWZ0ZXJEZWxldGVOb2RlJywge3RhcmdldDogZGVsTm9kZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0ZXBDb3VudGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH07XHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLnJlbW92ZVNlbGVjdGVkTm9kZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWROb2Rlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgdmFyIGNoaWxkcyA9IHRoYXQuZHJhZ1NlbGVjdFJlY3QuY2hpbGRyZW4oKS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgIHJldHVybiB2Lm5hbWUgIT09IFwiR1JPVVBfUkVDVF9OQU1FXCIgJiYgIUJwbW4uaXNGbG93KHYpO1xyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gdGhhdC5kcmFnU2VsZWN0UmVjdC5jaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIHYubmFtZSAhPT0gXCJHUk9VUF9SRUNUX05BTUVcIiAmJiBCcG1uLmlzRmxvdyh2KTtcclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnROb2RlID0gY2hpbGRzLmZpbmQoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmlkID09PSB2LnN0YXJ0Tm9kZS5pZFxyXG4gICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgZW5kTm9kZSA9IGNoaWxkcy5maW5kKGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5pZCA9PT0gdi5lbmROb2RlLmlkXHJcbiAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgIHZhciBpZkV4aXN0ID0gbGluZXMuZmluZEluZGV4KGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZS5pZCA9PT0gdi5pZFxyXG4gICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoKHN0YXJ0Tm9kZSB8fCBlbmROb2RlKSAmJiBpZkV4aXN0ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIucmVtb3ZlTGluZSh2LCB2LnBhcmVudCA/IHYucGFyZW50IDogdGhhdC5fenIpO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgdGhhdC5yZW1vdmVOb2RlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzID0gW107XHJcbiAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3Qub2ZmKFwibW91c2Vkb3duXCIpO1xyXG4gICAgICAgICAgICAgICB0aGlzLl96ci5yZW1vdmUodGhpcy5kcmFnU2VsZWN0UmVjdCk7XHJcbiAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgdGhhdC5yZW1vdmVOb2RlKHRoYXQuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9O1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5fY3JlYXRlQ29ubmVjdG9yQnlOb2RlcyA9IGZ1bmN0aW9uKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgbGluZVR5cGUsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcclxuICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgIHRoaXMuX3RyaWdnZXJBc3luYygnYmVmb3JlQ3JlYXRlTGluZScsIHt0YXJnZXQ6IHN0YXJ0Tm9kZX0sIFtzdGFydE5vZGUsIGVuZE5vZGVdKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgICAgaWYgKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IF90aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvckNyZWF0ZShzdGFydE5vZGUsIGVuZE5vZGUsIGxpbmVUeXBlLCBfdGhpcy5fYXBpLCBzdGFydFBvcywgZW5kUG9zKTtcclxuICAgICAgICAgICAgICAgICAgIGlmIChzdGFydE5vZGUucGFyZW50ICYmIGVuZE5vZGUucGFyZW50ICYmIHN0YXJ0Tm9kZS5wYXJlbnQucmVzb3VyY2VJZCA9PT0gZW5kTm9kZS5wYXJlbnQucmVzb3VyY2VJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGVuZE5vZGUucGFyZW50LmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fenIuYWRkKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JGb3JiaWRFZGl0KCk7XHJcbiAgICAgICAgICAgICAgICAgICBfdGhpcy5fY3JlYXRlQ29ubmVjdG9yRHJhZ0V2ZW50cyhjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgY29ubmVjdG9yLm9uKFwibW91c2Vkb3duXCIsIHpyVXRpbC5iaW5kKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmlzRWRpdCA9ICF0aGlzLmZvcmJpZEVkaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc05vZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAvLyDlj5bmtojoioLngrnnmoTpgInkuK1cclxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JQb2ludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvckNvbnRyb2woKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVPcGVyYXRpb25Ob2RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgdGhpcy5zaG93Q29ubmVjdG9yUG9pbnQoZS50YXJnZXQuc3R5bGUubGluZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgfSwgX3RoaXMpKTtcclxuICAgICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyKCdhZnRlckNyZWF0ZUxpbmUnLCB7dGFyZ2V0OiBjb25uZWN0b3J9KTtcclxuICAgICAgICAgICAgICAgICAgIF90aGlzLnN0ZXBDb3VudGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfSlcclxuICAgICAgIH07XHJcblxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5fY3JlYXRlQ29ubmVjdG9yRHJhZ0V2ZW50cyA9IGZ1bmN0aW9uKGNvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5vbihcImRyYWdzdGFydFwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBlLmV2ZW50Lm9mZnNldFg7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGUuZXZlbnQub2Zmc2V0WTtcclxuICAgICAgICAgICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdDtcclxuICAgICAgICAgICAgICAgIHZhciBsaW5lVHlwZSA9IG9wdC5zdHlsZS5saW5lVHlwZTtcclxuICAgICAgICAgICAgICAgIHZhciBkb2NrZXJzID0gb3B0LmRvY2tlcnM7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRQb2ludCA9IGRvY2tlcnNbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kUG9pbnQgPSBkb2NrZXJzW2RvY2tlcnMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnREaWZmID0gTWF0aC5hYnMoeCAtIHN0YXJ0UG9pbnQueCkgKyBNYXRoLmFicyh5IC0gc3RhcnRQb2ludC55KTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmREaWZmID0gTWF0aC5hYnMoeCAtIGVuZFBvaW50LngpICsgTWF0aC5hYnMoeSAtIGVuZFBvaW50LnkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RGlmZiA+IDE1ICYmIGVuZERpZmYgPiAxNSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcclxuICAgICAgICAgICAgICAgIHRoYXQuc2hvd0Nvbm5lY3RvclBvaW50KHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIHRoYXQucmV2ZXJzZUNvbm5lY3QgPSBmYWxzZTsgICAvL+aYr+WQpuWPjeWQkei/nue6v+eahOagh+ivhlxyXG4gICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RDb25uTm9kZSA9IGNvbm5lY3Rvci5zdGFydE5vZGU7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmxpbmVPcHQgPSBvcHQuc3R5bGU7IC8v57yT5a2Y57q/5q6155qE6YWN572u5L+h5oGvXHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kRGlmZiA8PSAxNSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0Q29ubk5vZGUgPSBjb25uZWN0b3Iuc3RhcnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc3RhcnRQb3MgPSBvcHQuc3R5bGUuc1BvcztcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Lm9yaWdpbk5vZGUgPSB0aGlzLmVuZE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5vcmlnaW5Qb3MgPSBvcHQuc3R5bGUuZVBvcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydERpZmYgPD0gMTUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnJldmVyc2VDb25uZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdENvbm5Ob2RlID0gY29ubmVjdG9yLmVuZE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5lbmRQb3MgPSBvcHQuc3R5bGUuZVBvcztcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Lm9yaWdpbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Lm9yaWdpblBvcyA9IG9wdC5zdHlsZS5zUG9zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5kZWxldGVCeUxpbmUodGhpcywgdGhhdC5fenIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RvckxpbmU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5yZXZlcnNlQ29ubmVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvckxpbmUgPSB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLm1hbmFnZVJldmVyc2VUZW1wQ29ubmVjdG9yKHBvaW50LCB0aGF0LnNlbGVjdENvbm5Ob2RlLCBsaW5lVHlwZSwgdGhhdC5lbmRQb3MpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3JMaW5lID0gdGhhdC5jb25uZWN0aW9uTWFuYWdlci5tYW5hZ2VUZW1wQ29ubmVjdG9yKHRoYXQuc2VsZWN0Q29ubk5vZGUsIHBvaW50LCBsaW5lVHlwZSwgdGhhdC5zdGFydFBvcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll96ci5hZGQoY29ubmVjdG9yTGluZSk7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3JMaW5lLnNldFNlbGVjdGVkU3R5bGUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5vbihcImRyYWdcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuX2hhbmRsZUxpbmVEcmFnKCdkcmFnJywgZSwgdGhpcy5vcHQuc3R5bGUubGluZVR5cGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29ubmVjdG9yLm9uKFwiZHJhZ2VuZFwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5faGFuZGxlTGluZURyYWcoJ2RyYWdlbmQnLCBlLCB0aGlzLm9wdC5zdHlsZS5saW5lVHlwZSk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmhpZGVDb25uZWN0b3JQb2ludCgpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5oaWRlQ29ubmVjdG9yQ29udHJvbCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgIH1cclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLl90cmlnZ2VyQXN5bmMgPSBmdW5jdGlvbih0eXBlLCBldmVudCwgZGF0YSkge1xyXG4gICAgICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyKHR5cGUsIGV2ZW50LCBkYXRhLCB0cnVlKTtcclxuICAgICAgIH1cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uX3RyaWdnZXIgPSBmdW5jdGlvbih0eXBlLCBldmVudCwgZGF0YSwgYXN5bmMpIHtcclxuICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLm9wdHNbdHlwZV07XHJcblxyXG4gICAgICAgICAgIGlmIChkYXRhID09PSB2b2lkIDApIGRhdGEgPSB7fTtcclxuICAgICAgICAgICBpZiAoZXZlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgZXZlbnQgPSB7dHlwZTp0eXBlLCB0YXJnZXQ6dGhpc31cclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICBldmVudC50eXBlID0gdHlwZTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgZXZlbnQuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgdGhpcy5fYXBpLnRyaWdnZXIoZXZlbnQudHlwZSwgZXZlbnQpO1xyXG4gICAgICAgICAgIGlmIChhc3luYykge1xyXG4gICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5yZXNvbHZlKHpyVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSA/IGNhbGxiYWNrLmFwcGx5KHRoaXMsIFtldmVudF0uY29uY2F0KGRhdGEpKSA6IHRydWUpXHJcbiAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuICEodmFsdWUgPT09IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIHJldHVybiAhKHpyVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSAmJiBjYWxsYmFjay5hcHBseSh0aGlzLCBbZXZlbnRdLmNvbmNhdChkYXRhKSkgPT09IGZhbHNlKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICog6byg5qCH54K55LiLIOWwhuaTjeS9nOahhiDnp7vliLDlr7nlupTnmoToioLngrnkuIpcclxuICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gbm9kZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLm5vZGVDbGlja0hhbmRsZXIgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBpZlNob3dQb2ludCA9IG5vZGUudHlwZSAhPT0gJ2RyYWdTZWxlY3QnO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQudHlwZSA9PT0gXCJkcmFnU2VsZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmU2hvd1BvaW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gMS4g6ZqQ6JeP6L+e57q/54K5XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgICAgIC8vIDIuIOmakOiXj+aOp+WItueCuVxyXG4gICAgICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JDb250cm9sKCk7XHJcbiAgICAgICAgICAgIC8vIDMuIOmakOiXj+aTjeS9nG5vZGVcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlT3BlcmF0aW9uTm9kZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCdlZGl0T3BlcmF0aW9uSWNvbnMnLCB7dGFyZ2V0OiBub2RlfSwgbm9kZS5vcGVyYXRpb25JY29ucyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcmJpZEVkaXQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZVJlY3QgPSB0aGlzLmNhbGN1bGF0ZVJlY3Qobm9kZSk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5vcGVyYXRpb25Ob2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRPcGVyYXRpb25Ob2RlKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVjdCAmJiB0aGlzLnJlY3QuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCJyZ2JhKDAsIDAsIDAsIDEpXCJcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaWZTaG93UG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIOaYvuekuuW9k+WJjeiKgueCueeahOi/nuaOpeeCuVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93Q29ubmVjdG9yUG9pbnQodW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucmV0dXJuQ29ubmVjdG9yQ29udHJvbFBhcmFtKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5zY2FsZWFibGUgfHwgcGFyYW1zLnJvdGF0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOaYvuekuuW9k+WJjeiKgueCueeahOaOp+WItueCuVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Nvbm5lY3RvckNvbnRyb2woKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUucmVmcmVzaFBvc3Rpb24obm9kZSwgc2hhcGVSZWN0KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICog5Yid5aeL5YyW6Jma5qGG5a+56b2Q57q/XHJcbiAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBub2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gc2hhcGVMaXN0IFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5pbml0VmlydHVhbExpbmUgPSBmdW5jdGlvbihub2RlLCBzaGFwZUxpc3QpIHtcclxuICAgICAgICAgICBHdWlkZWxpbmVzLmNyZWF0ZUd1aWRlbGluZXModGhpcy5fenIpO1xyXG4gICAgICAgICAgIHRoaXMucmVjdCA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHtcclxuICAgICAgICAgICAgICAgcG9zaXRpb246IFtzaGFwZUxpc3QueCwgc2hhcGVMaXN0LnldLFxyXG4gICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgcG9pbnRzOiBzaGFwZUxpc3QucG9pbnRzXHJcbiAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICBsaW5lRGFzaDogWzJdXHJcbiAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgIHJvdGF0aW9uOiBub2RlLnJvdGF0aW9uLFxyXG4gICAgICAgICAgICAgICB6OiAzXHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgdGhpcy5fenIuYWRkKHRoaXMucmVjdCk7XHJcbiAgICAgICB9O1xyXG4gICAgICAgLy/nu5Hlrprkuovku7boioLngrlcclxuICAgICAgIGZpc2hUb3BvUHJvdG8uYmluZEV2ZW50Tm9kZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgIC8vbW91c2Vkb3du55qE5pe25YCZ5Li65q+P5LiqdGFza+WIm+W7uuaPkuanvVxyXG4gICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICBpZiAodGhpcy5hbGxOb2Rlc1tpXS5pc0NhblNsb3QpIHtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRTbG90KHRoaXMuYWxsTm9kZXNbaV0pO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIC8vbW91c2V1cOeahOaXtuWAmeWIoOmZpOaPkuanvVxyXG4gICAgICAgICAgIHRoaXMuX3pyLm9uKFwibW91c2V1cFwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxOb2Rlc1tpXS5pc0NhblNsb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxOb2Rlc1tpXS5zbG90ICYmIHRoaXMuYWxsTm9kZXNbaV0uc2xvdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgdGhpcy5hbGxOb2Rlc1tpXS5zbG90Lmxlbmd0aDsgbSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFsbE5vZGVzW2ldLnJlbW92ZSh0aGlzLmFsbE5vZGVzW2ldLnNsb3RbbV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG5cclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmNyZWF0U2xvdCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAvL+e7mXRhc2vliJvlu7o45Liq5o+S5qe9XHJcbiAgICAgICAgICAgbm9kZS5zbG90ID0gW107XHJcbiAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdXRpbC5nZXRTb2x0UG9pbnRzKG5vZGUpO1xyXG4gICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBDaXJjbGUgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uW2pdLFxyXG4gICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICByOiAxMFxyXG4gICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJ3JnYmEoMCwwLDAsMC42KScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50J1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgbm9kZS5zbG90LnB1c2goQ2lyY2xlKTtcclxuICAgICAgICAgICAgICAgbm9kZS5hZGQoQ2lyY2xlKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8udXBkYXRlU2xvdEV2ZW50ID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgIGlmIChub2RlLnNsb3RFdmVudCAmJiBub2RlLnNsb3RFdmVudC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHV0aWwuZ2V0U29sdFBvaW50cyhub2RlKTtcclxuICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2RlLnNsb3RFdmVudC5sZW5ndGg7IG4rKykge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbm9kZS5zbG90RXZlbnRbbl0uaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgc2xvdEV2ZW50UG9zaXRpb24yID0gcG9zaXRpb25baW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKCFCcG1uLmlzU3ViUHJvY2Vzcyhub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHNsb3RFdmVudFBvc2l0aW9uMiA9IFtwb3NpdGlvbltpbmRleF1bMF0gKyBub2RlLnBvc2l0aW9uWzBdLCBwb3NpdGlvbltpbmRleF1bMV0gKyBub2RlLnBvc2l0aW9uWzFdXVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgbm9kZS5zbG90RXZlbnRbbl0uYXR0cihcInBvc2l0aW9uXCIsIHNsb3RFdmVudFBvc2l0aW9uMik7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKG5vZGUuc2xvdEV2ZW50W25dKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgIH1cclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLl9wb3NJbldoaWNoU3VicHJvY2VzcyA9IGZ1bmN0aW9uKGNvbnRhaW5lck5vZGVzLCBub2RlKSB7XHJcbiAgICAgICAgICAgaWYgKGNvbnRhaW5lck5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250YWluZXJOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lck5vZGUgPSBjb250YWluZXJOb2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gY29udGFpbmVyTm9kZS5nZXRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgIHZhciBub2RlSGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVggPSBCcG1uVXRpbC5wYXJlbnRYKGNvbnRhaW5lck5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIG5vZGVZID0gQnBtblV0aWwucGFyZW50WShjb250YWluZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnggPj0gbm9kZVggJiYgbm9kZS55ID49IG5vZGVZICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgbm9kZS54K25vZGUud2lkdGggPD0gbm9kZVgrbm9kZVdpZHRoICYmIG5vZGUueStub2RlLmhlaWdodCA8PSBub2RlWStub2RlSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld05vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lck5vZGUuY2hpbGRyZW4oKSAmJiBjb250YWluZXJOb2RlLmNoaWxkcmVuKCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q29udGFpbmVyID0gY29udGFpbmVyTm9kZS5jaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uYnBtbkluZm8gJiYgaXRlbS5ub2RlVHlwZSA9PT0gJ1N1YlByb2Nlc3MnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlID0gdGhpcy5fcG9zSW5XaGljaFN1YnByb2Nlc3MobmV3Q29udGFpbmVyLCBub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld05vZGUgfHwgY29udGFpbmVyTm9kZTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgIH1cclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmdldERyYWdTZWxlY3RDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgdmFyIExlZnRVcHBlclBvc1ggPSBbXTtcclxuICAgICAgICAgICB2YXIgTGVmdFVwcGVyUG9zWSA9IFtdO1xyXG4gICAgICAgICAgIHZhciBSaWdodExvd2VyUG9zWCA9IFtdO1xyXG4gICAgICAgICAgIHZhciBSaWdodExvd2VyUG9zWSA9IFtdO1xyXG4gICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3QuY2hpbGRyZW4oKS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgcmV0dXJuIHYubmFtZSAhPT0gXCJHUk9VUF9SRUNUX05BTUVcIiAmJiAhQnBtbi5pc0Zsb3codik7XHJcbiAgICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICB2YXIgcmVjdCA9IGl0ZW0uZ2V0UmVjdCgpO1xyXG4gICAgICAgICAgICAgICB2YXIgbm9kZVdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICAgdmFyIG5vZGVIZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICAgICAgICAgdmFyIG5vZGVYID0gcmVjdC54O1xyXG4gICAgICAgICAgICAgICB2YXIgbm9kZVkgPSByZWN0Lnk7XHJcblxyXG4gICAgICAgICAgICAgICBpZiAoQnBtbi5pc0V2ZW50KGl0ZW0pIHx8IEJwbW4uaXNHYXRld2F5KGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICBMZWZ0VXBwZXJQb3NYLnB1c2gobm9kZVggLSBub2RlV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgTGVmdFVwcGVyUG9zWS5wdXNoKG5vZGVZIC0gbm9kZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICBSaWdodExvd2VyUG9zWC5wdXNoKG5vZGVYICsgbm9kZVdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgIFJpZ2h0TG93ZXJQb3NZLnB1c2gobm9kZVkgKyBub2RlSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgIExlZnRVcHBlclBvc1gucHVzaChub2RlWCAtIG5vZGVXaWR0aC8yKTtcclxuICAgICAgICAgICAgICAgICAgIExlZnRVcHBlclBvc1kucHVzaChub2RlWSAtIG5vZGVIZWlnaHQvMik7XHJcbiAgICAgICAgICAgICAgICAgICBSaWdodExvd2VyUG9zWC5wdXNoKG5vZGVYICsgbm9kZVdpZHRoLzIpO1xyXG4gICAgICAgICAgICAgICAgICAgUmlnaHRMb3dlclBvc1kucHVzaChub2RlWSArIG5vZGVIZWlnaHQvMik7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICB4OiBNYXRoLm1pbi5hcHBseShNYXRoLCBMZWZ0VXBwZXJQb3NYKSxcclxuICAgICAgICAgICAgICAgeTogTWF0aC5taW4uYXBwbHkoTWF0aCwgTGVmdFVwcGVyUG9zWSksXHJcbiAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heC5hcHBseShNYXRoLCBSaWdodExvd2VyUG9zWCkgLSBNYXRoLm1pbi5hcHBseShNYXRoLCBMZWZ0VXBwZXJQb3NYKSxcclxuICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdIZWlnaHQgPSBNYXRoLm1heC5hcHBseShNYXRoLCBSaWdodExvd2VyUG9zWSkgLSBNYXRoLm1pbi5hcHBseShNYXRoLCBMZWZ0VXBwZXJQb3NZKVxyXG4gICAgICAgICAgIH1cclxuICAgICAgIH1cclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKiBtb3VzZWRvd27lkI4g5byA5aeL5ouW5YqoXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8ubmV3RHJhZyA9IGZ1bmN0aW9uKGRvbSwgc1gsIHNZKSB7XHJcbiAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgIHRoYXQuc2VsZWN0ZWROb2RlID0gZG9tO1xyXG4gICAgICAgICAgIHRoYXQuaXNOb2RlID0gdHJ1ZTtcclxuICAgICAgICAgICB2YXIgcGl4ZWwgPSB0aGlzLm9wdHMuZ3JpZExpbmVTcGFjaW5nO1xyXG4gICAgICAgICAgIHZhciBzaGFwZUxpc3QgPSB0aGlzLmNhbGN1bGF0ZVJlY3QoZG9tKTtcclxuICAgICAgICAgICB2YXIgZG9tQXJyYXkgPSB0aGF0LmRvbUFycmF5O1xyXG4gICAgICAgICAgIC8venJlbmRlcuS4jeaUr+aMgemUruebmOS6i+S7tu+8jOWPquiDveS+puWQrGJvZHnlhYPntKDkuIrnmoTkuoZcclxuICAgICAgICAgICBkb2N1bWVudC5ib2R5Lm9ua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBldiA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG4gICAgICAgICAgICAgICAvL+WIpOaWrSBkZWxldGXmjInplK5cclxuICAgICAgICAgICAgICAgaWYgKGV2LmtleWNvZGUgPT0gNDYgfHwgZXYuY2hhckNvZGUgPT0gNDYgfHwgZXYud2hpY2ggPT0gNDYpIHtcclxuICAgICAgICAgICAgICAgICAgIC8vMS7lpoLmnpzmmK/oioLngrks56e76Zmk5LqL5Lu2LOi/m+ihjOWIoOmZpCAg5aaC5p6c5piv5a2Q6IqC54K5IOmAmui/h3BhcmVudOWIoOmZpFxyXG4gICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuaXNOb2RlID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdGVkTm9kZS5vZmYoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RlZE5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU3ViUHJvY2Vzcyh0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQucmVtb3ZlKHRoYXQuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3pyLnJlbW92ZSh0aGF0LnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC8vMi7liKDpmaTnu7TmiqTnmoToioLngrnmlbDnu4RcclxuICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXQuYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0ZWROb2RlLmlkID09IHRoYXQuYWxsTm9kZXNbaV0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWxsTm9kZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tQXJyYXkubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0ZWROb2RlLmlkID09IGRvbUFycmF5W2pdLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21BcnJheS5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGF0Lm92ZXJsYXBBcnJheS5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RlZE5vZGUuaWQgPT0gdGhhdC5vdmVybGFwQXJyYXlba10uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub3ZlcmxhcEFycmF5LnNwbGljZShrLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAvLzMu56e75Y675pON5L2c5qGGXHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQub3BlcmF0aW9uTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll96ci5yZW1vdmUodGhhdC5vcGVyYXRpb25Ob2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5vcGVyYXRpb25Ob2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgLy8zLuWIoOmZpOWvueW6lOeahOe6v1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIuZGVsZXRlU2VsZWN0Q29uKHRoYXQuc2VsZWN0ZWROb2RlLCB0aGF0Ll96cik7XHJcbiAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvL+WQpuWImeebtOaOpeWIoOmZpOe6v1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIuZGVsZXRlTGluZSh0aGF0Ll96cik7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAvLyA0LuWIoOmZpOi/nuaOpeeCueWSjOaOp+WItueCuVxyXG4gICAgICAgICAgICAgICAgICAgdGhhdC5oaWRlQ29ubmVjdG9yUG9pbnQoKTtcclxuICAgICAgICAgICAgICAgICAgIHRoYXQuaGlkZUNvbm5lY3RvckNvbnRyb2woKTtcclxuICAgICAgICAgICAgICAgICAgIHRoYXQuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgLy/liJ3lp4vljJYg5a+56b2Q57q/XHJcbiAgICAgICAgICAgdmFyIHN0YXJ0WCwgc3RhcnRZLCByZWN0UG9zaXRpb25YLCByZWN0UG9zaXRpb25ZO1xyXG4gICAgICAgICAgIHN0YXJ0WCA9IHNYO1xyXG4gICAgICAgICAgIHN0YXJ0WSA9IHNZO1xyXG4gICAgICAgIC8vICAgIGlmIChkb20ucGFyZW50ICYmIEJwbW4uaXNTdWJQcm9jZXNzKGRvbS5wYXJlbnQpKSB7XHJcbiAgICAgICAgLy8gICAgICAgIHJlY3RQb3NpdGlvblggPSBzaGFwZUxpc3QueCArIEJwbW5VdGlsLnBhcmVudFgoZG9tLnBhcmVudCk7XHJcbiAgICAgICAgLy8gICAgICAgIHJlY3RQb3NpdGlvblkgPSBzaGFwZUxpc3QueSArIEJwbW5VdGlsLnBhcmVudFkoZG9tLnBhcmVudCk7XHJcbiAgICAgICAgLy8gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgICAgcmVjdFBvc2l0aW9uWCA9IHNoYXBlTGlzdC54O1xyXG4gICAgICAgIC8vICAgICAgICByZWN0UG9zaXRpb25ZID0gc2hhcGVMaXN0Lnk7XHJcbiAgICAgICAgLy8gICAgfVxyXG4gICAgICAgICAgICByZWN0UG9zaXRpb25YID0gc2hhcGVMaXN0Lng7XHJcbiAgICAgICAgICAgIHJlY3RQb3NpdGlvblkgPSBzaGFwZUxpc3QueTtcclxuICAgICAgICAgICBpZiAoIXRoYXQucmVjdCkge1xyXG4gICAgICAgICAgICAgICB0aGF0LmluaXRWaXJ0dWFsTGluZShkb20sIHNoYXBlTGlzdCk7XHJcbiAgICAgICAgICAgICAgIHRoYXQucmVjdC5hdHRyKFwicG9zaXRpb25cIiwgW3JlY3RQb3NpdGlvblgsIHJlY3RQb3NpdGlvblldKTtcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICB0aGF0LnJlY3QuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IFtyZWN0UG9zaXRpb25YLCByZWN0UG9zaXRpb25ZXSxcclxuICAgICAgICAgICAgICAgICAgIFwicm90YXRpb25cIjogc2hhcGVMaXN0LnJvdGF0aW9uIHx8IGRvbS5yb3RhdGlvblxyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgdGhhdC5yZWN0LnNldFNoYXBlKHtwb2ludHM6IHNoYXBlTGlzdC5wb2ludHN9KTtcclxuICAgICAgICAgICAgICAgdGhhdC5yZWN0LnNob3coKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgdmFyIG5vd1JlY3RQb3NpdGlvbiA9IFtyZWN0UG9zaXRpb25YLCByZWN0UG9zaXRpb25ZXTtcclxuICAgICAgICAgICB2YXIgbm93RHJhZ1JlY3RQb3NpdGlvbiwgZHJhZ1JlY3RQb3NpdGlvblgsIGRyYWdSZWN0UG9zaXRpb25ZLCBkcmFnUmVjdDtcclxuICAgICAgICAgICB2YXIgZGdSZWN0LCBzdGFydENvbnRhaW5lcjtcclxuICAgICAgICAgICBpZiAoZG9tLnR5cGUgPT09IFwiZHJhZ1NlbGVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgIGRyYWdSZWN0ID0gdGhpcy5nZXREcmFnU2VsZWN0Q29udGFpbmVyKCk7XHJcbiAgICAgICAgICAgICAgIGRyYWdSZWN0UG9zaXRpb25YID0gZHJhZ1JlY3QueCArIGRyYWdSZWN0LndpZHRoLzIgKyB0aGlzLmRyYWdTZWxlY3RSZWN0LnBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICBkcmFnUmVjdFBvc2l0aW9uWSA9IGRyYWdSZWN0LnkgKyBkcmFnUmVjdC5oZWlnaHQvMiArIHRoaXMuZHJhZ1NlbGVjdFJlY3QucG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgICAgIG5vd0RyYWdSZWN0UG9zaXRpb24gPSBbZHJhZ1JlY3RQb3NpdGlvblgsIGRyYWdSZWN0UG9zaXRpb25ZXTtcclxuXHJcbiAgICAgICAgICAgICAgIGRnUmVjdCA9IHRoYXQuZHJhZ1NlbGVjdFJlY3QuZ2V0UmVjdCgpO1xyXG4gICAgICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IHRoYXQuX3Bvc0luV2hpY2hTdWJwcm9jZXNzKHRoYXQuc3ViUHJvY2Vzc05vZGUsIHtcclxuICAgICAgICAgICAgICAgICAgIHg6IGRnUmVjdC54IC0gZGdSZWN0LndpZHRoLzIsXHJcbiAgICAgICAgICAgICAgICAgICB5OiBkZ1JlY3QueSAtIGRnUmVjdC5oZWlnaHQvMixcclxuICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkZ1JlY3Qud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGRnUmVjdC5oZWlnaHRcclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICB2YXIgaXNMYXAgPSAwO1xyXG4gICAgICAgICAgIHZhciBpc01vdmUgPSAwO1xyXG4gICAgICAgICAgIHZhciBtb3ZlRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgIG1vdmVEcmFnKGUpO1xyXG4gICAgICAgICAgIH07XHJcbiAgICAgICAgICAgdmFyIHVwRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgIGVuZERyYWcoZSk7XHJcbiAgICAgICAgICAgfTtcclxuICAgICAgICAgICB0aGlzLl96ci5vbignbW91c2Vtb3ZlJywgbW92ZUZ1bmN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgLy/lvIDlp4vnp7vliqgs6IqC54K556e75Yqo5pe25Y+W5raI5omA5pyJ6IqC54K555qE6YCJ5Lit54q25oCBXHJcbiAgICAgICAgICAgZnVuY3Rpb24gbW92ZURyYWcoZSkge1xyXG4gICAgICAgICAgICAgICB0aGF0Ll9yZW1vdmVPcGVyYXRpb25Ob2RlKCk7XHJcbiAgICAgICAgICAgICAgIHRoYXQuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgICAgICAgIHRoYXQuaGlkZUNvbm5lY3RvckNvbnRyb2woKTtcclxuICAgICAgICAgICAgICAgLy/ku6UxMOS4quWDj+e0oOS4uuWNleS9jei/m+ihjOenu+WKqFxyXG4gICAgICAgICAgICAgICB2YXIgbWF4UmVjdFBvc2l0aW9uID0gW3RoYXQuZ2V0V2lkdGgoKSAtICh0aGF0LnJlY3Quc2hhcGUucG9pbnRzWzFdWzBdIC0gdGhhdC5yZWN0LnNoYXBlLnBvaW50c1swXVswXSkgLyAyLCB0aGF0LmdldEhlaWdodCgpIC0gKHRoYXQucmVjdC5zaGFwZS5wb2ludHNbMl1bMV0gLSB0aGF0LnJlY3Quc2hhcGUucG9pbnRzWzFdWzFdKSAvIDJdO1xyXG4gICAgICAgICAgICAgICB2YXIgbWluUmVjdFBvc2l0aW9uID0gWyh0aGF0LnJlY3Quc2hhcGUucG9pbnRzWzFdWzBdIC0gdGhhdC5yZWN0LnNoYXBlLnBvaW50c1swXVswXSkgLyAyLCAodGhhdC5yZWN0LnNoYXBlLnBvaW50c1syXVsxXSAtIHRoYXQucmVjdC5zaGFwZS5wb2ludHNbMV1bMV0pIC8gMl07XHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgTWF0aC5hYnMocGFyc2VJbnQoKGUuZXZlbnQuY2xpZW50WCAtIHN0YXJ0WCkgLyBwaXhlbCkpOyBuKyspIHtcclxuICAgICAgICAgICAgICAgICAgIGlzTW92ZSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoZS5ldmVudC5jbGllbnRYIC0gc3RhcnRYIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIG5vd1JlY3RQb3NpdGlvblswXSA9IHJlY3RQb3NpdGlvblggLSBwaXhlbCAqIChuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tLnR5cGUgPT09IFwiZHJhZ1NlbGVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd0RyYWdSZWN0UG9zaXRpb25bMF0gPSBkcmFnUmVjdFBvc2l0aW9uWCAtIHBpeGVsICogKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgbm93UmVjdFBvc2l0aW9uWzBdID0gcmVjdFBvc2l0aW9uWCArIHBpeGVsICogKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChkb20udHlwZSA9PT0gXCJkcmFnU2VsZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93RHJhZ1JlY3RQb3NpdGlvblswXSA9IGRyYWdSZWN0UG9zaXRpb25YICsgcGl4ZWwgKiAobik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgaWYgKG5vd1JlY3RQb3NpdGlvblswXSA8IG1pblJlY3RQb3NpdGlvblswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIG5vd1JlY3RQb3NpdGlvblswXSA9IG1pblJlY3RQb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIGlmIChub3dSZWN0UG9zaXRpb25bMF0gPiBtYXhSZWN0UG9zaXRpb25bMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBub3dSZWN0UG9zaXRpb25bMF0gPSBtYXhSZWN0UG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBNYXRoLmFicyhwYXJzZUludCgoZS5ldmVudC5jbGllbnRZIC0gc3RhcnRZKSAvIHBpeGVsKSk7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgaXNNb3ZlID0gMTtcclxuICAgICAgICAgICAgICAgICAgIGlmIChlLmV2ZW50LmNsaWVudFkgLSBzdGFydFkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgbm93UmVjdFBvc2l0aW9uWzFdID0gcmVjdFBvc2l0aW9uWSAtIHBpeGVsICogKG0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChkb20udHlwZSA9PT0gXCJkcmFnU2VsZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93RHJhZ1JlY3RQb3NpdGlvblsxXSA9IGRyYWdSZWN0UG9zaXRpb25ZIC0gcGl4ZWwgKiAobSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBub3dSZWN0UG9zaXRpb25bMV0gPSByZWN0UG9zaXRpb25ZICsgcGl4ZWwgKiAobSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbS50eXBlID09PSBcImRyYWdTZWxlY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBub3dEcmFnUmVjdFBvc2l0aW9uWzFdID0gZHJhZ1JlY3RQb3NpdGlvblkgKyBwaXhlbCAqIChtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICBpZiAobm93UmVjdFBvc2l0aW9uWzFdIDwgbWluUmVjdFBvc2l0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgbm93UmVjdFBvc2l0aW9uWzFdID0gbWluUmVjdFBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgaWYgKG5vd1JlY3RQb3NpdGlvblsxXSA+IG1heFJlY3RQb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIG5vd1JlY3RQb3NpdGlvblsxXSA9IG1heFJlY3RQb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB0aGF0LnJlY3QuYXR0cigncG9zaXRpb24nLCBub3dSZWN0UG9zaXRpb24pO1xyXG5cclxuICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzdWx0U3VjY2VzcygpIHtcclxuICAgICAgICAgICAgICAgICAgIGlzTGFwID0gMDtcclxuICAgICAgICAgICAgICAgICAgIHRoYXQucmVjdC5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogXCJyZ2JhKDAsIDAsIDAsIDEpXCJcclxuICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICBmdW5jdGlvbiByZXN1bHRGYWxzZSgpIHtcclxuICAgICAgICAgICAgICAgICAgIGlzTGFwID0gMTtcclxuICAgICAgICAgICAgICAgICAgIHRoYXQucmVjdC5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogXCJyZ2JhKDI1NSwgMCwgMCwgMSlcIlxyXG4gICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzQ2hpbGQobm9kZSwgc3ViTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKHN1Yk5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk5vZGUucGFyZW50LmlkID09PSBub2RlLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0NoaWxkKG5vZGUsIHN1Yk5vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgIHRoYXQuY29udGFpbmVyTm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgIGlmIChkb20udHlwZSA9PT0gXCJkcmFnU2VsZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBzdWJOb2RlID0gdGhhdC5fcG9zSW5XaGljaFN1YnByb2Nlc3ModGhhdC5zdWJQcm9jZXNzTm9kZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHg6IG5vd0RyYWdSZWN0UG9zaXRpb25bMF0gLSBkcmFnUmVjdC53aWR0aC8yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHk6IG5vd0RyYWdSZWN0UG9zaXRpb25bMV0gLSBkcmFnUmVjdC5oZWlnaHQvMixcclxuICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZHJhZ1JlY3Qud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBkcmFnUmVjdC5oZWlnaHRcclxuICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldENvbnRhaW5lciA9IHRoYXQuX0p1ZGdlTm9kZUluV2hpY2hTdWJQcm9jZXNzKHRoYXQuc3ViUHJvY2Vzc05vZGUsIHt4OiBlLmV2ZW50Lm9mZnNldFgsIHk6IGUuZXZlbnQub2Zmc2V0WX0pO1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKCFzdGFydENvbnRhaW5lciAmJiB0YXJnZXRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRGYWxzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0LnJlc2V0QmFja2dyb3VuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyICYmICFzdWJOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgLy/mlLnlj5jnlLvluIPpopzoibJcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lck5vZGUgPSAnenInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2V0QmFja2dyb3VuZChcIiNiNmUzZjVcIik7XHJcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWxsTm9kZXMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCcG1uLmlzU3ViUHJvY2Vzcyh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJOb2RlICYmIHN1Yk5vZGUuaWQgPT09IGl0ZW0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29udGFpbmVyTm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0Q29udGFpbmVyIHx8IChzdGFydENvbnRhaW5lciAmJiBzdGFydENvbnRhaW5lci5pZCAhPT0gaXRlbS5pZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodi5uYW1lID09PSBcInN1YnByb2Nlc3MtcmVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXYuaW5pdFN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRGaWxsID0gdi5zdHlsZS5maWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuYXR0cihcImluaXRTdHlsZVwiLCBpbml0RmlsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDonI2I2ZTNmNSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2Lm5hbWUgPT09IFwic3VicHJvY2Vzcy1yZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2LmluaXRTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRGaWxsID0gdi5zdHlsZS5maWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5hdHRyKFwiaW5pdFN0eWxlXCIsIGluaXRGaWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiB2LmluaXRTdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdi5pbml0U3R5bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICBHdWlkZWxpbmVzLmp1ZGdlQWxpZ25tZW50KG5vd1JlY3RQb3NpdGlvbiwgZG9tQXJyYXksIHRoYXQuZ2V0V2lkdGgoKSwgdGhhdC5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgICAgICAgIHZhciB0YXJnZXRTdWIgPSB0aGF0Ll9KdWRnZU5vZGVJbldoaWNoU3ViUHJvY2Vzcyh0aGF0LnN1YlByb2Nlc3NOb2RlLCB7eDogbm93UmVjdFBvc2l0aW9uWzBdLCB5OiBub3dSZWN0UG9zaXRpb25bMV19KTtcclxuICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDAsIGxlbiA9IHRoYXQuYWxsTm9kZXMubGVuZ3RoOyBsIDwgbGVuOyBsKyspIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBwb3NYLCBwb3NZO1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGhhdC5hbGxOb2Rlc1tsXTtcclxuICAgICAgICAgICAgICAgICAgIHZhciByZWN0RG9tID0gY3VycmVudE5vZGUuZ2V0UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIGNhbkNvbXBhcmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgcmVzdWx0U3VjY2VzcygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgIGlmICgoY3VycmVudE5vZGUuaWQgPT09IGRvbS5pZCkgfHwgKEJwbW4uaXNTdWJQcm9jZXNzKGRvbSkgJiYgaXNDaGlsZChkb20sIGN1cnJlbnROb2RlKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIHRoYXQucmVzZXRCYWNrZ3JvdW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoQnBtbi5pc1N1YlByb2Nlc3MoY3VycmVudE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2Lm5hbWUgPT09IFwic3VicHJvY2Vzcy1yZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdi5pbml0U3R5bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdEZpbGwgPSB2LnN0eWxlLmZpbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5hdHRyKFwiaW5pdFN0eWxlXCIsIGluaXRGaWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IHYuaW5pdFN0eWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdi5pbml0U3R5bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRTdWIgJiYgdGFyZ2V0U3ViLmlkID09PSBjdXJyZW50Tm9kZS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lck5vZGUgPSBjdXJyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb20ucGFyZW50IHx8IChkb20ucGFyZW50ICYmIHRhcmdldFN1Yi5pZCAhPT0gZG9tLnBhcmVudC5pZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2Lm5hbWUgPT09IFwic3VicHJvY2Vzcy1yZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2LmluaXRTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRGaWxsID0gdi5zdHlsZS5maWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5hdHRyKFwiaW5pdFN0eWxlXCIsIGluaXRGaWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOicjYjZlM2Y1J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIGNhbkNvbXBhcmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIGlmIChkb20ucGFyZW50ICYmICF0YXJnZXRTdWIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAvL+aUueWPmOeUu+W4g+minOiJslxyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29udGFpbmVyTm9kZSA9ICd6cic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRCYWNrZ3JvdW5kKFwiI2I2ZTNmNVwiKTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3MoY3VycmVudE5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHBvc1ggPSByZWN0RG9tLnggKyBCcG1uVXRpbC5wYXJlbnRYKGN1cnJlbnROb2RlLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcG9zWSA9IHJlY3REb20ueSArIEJwbW5VdGlsLnBhcmVudFkoY3VycmVudE5vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcG9zWCA9IHJlY3REb20ueDtcclxuICAgICAgICAgICAgICAgICAgICAgICBwb3NZID0gcmVjdERvbS55O1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgaWYgKGNhbkNvbXBhcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGVMaXN0LndpZHRoID4gcmVjdERvbS53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvL+enu+WKqOeahOS9jee9riDlh4/ljrvlvZPliY3oioLngrnnmoTkvY3nva4g5bCP5LqO5ouW5ou96IqC54K56auY5bqm5Y+K5a695bqm5LiA5Y2K77yMIOWImeaciemHjeWPoCDmoIfnuqJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlTGlzdC5oZWlnaHQgPiByZWN0RG9tLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKG5vd1JlY3RQb3NpdGlvblswXSAtIHBvc1gpIDwgKHJlY3REb20ud2lkdGgrc2hhcGVMaXN0LndpZHRoKSAvIDIgJiYgTWF0aC5hYnMobm93UmVjdFBvc2l0aW9uWzFdIC0gcG9zWSkgPCAocmVjdERvbS5oZWlnaHQrc2hhcGVMaXN0LmhlaWdodCkgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0RmFsc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKG5vd1JlY3RQb3NpdGlvblswXSAtIHBvc1gpIDwgKHJlY3REb20ud2lkdGgrc2hhcGVMaXN0LndpZHRoKSAvIDIgJiYgTWF0aC5hYnMobm93UmVjdFBvc2l0aW9uWzFdIC0gcG9zWSkgPCAocmVjdERvbS5oZWlnaHQrc2hhcGVMaXN0LmhlaWdodCkgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0RmFsc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlTGlzdC5oZWlnaHQgPiByZWN0RG9tLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKG5vd1JlY3RQb3NpdGlvblswXSAtIHBvc1gpIDwgKHJlY3REb20ud2lkdGgrc2hhcGVMaXN0LndpZHRoKSAvIDIgJiYgTWF0aC5hYnMobm93UmVjdFBvc2l0aW9uWzFdIC0gcG9zWSkgPCAocmVjdERvbS5oZWlnaHQrc2hhcGVMaXN0LmhlaWdodCkgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0RmFsc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKG5vd1JlY3RQb3NpdGlvblswXSAtIHBvc1gpIDwgKHJlY3REb20ud2lkdGgrc2hhcGVMaXN0LndpZHRoKSAvIDIgJiYgTWF0aC5hYnMobm93UmVjdFBvc2l0aW9uWzFdIC0gcG9zWSkgPCAocmVjdERvbS5oZWlnaHQrc2hhcGVMaXN0LmhlaWdodCkgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0RmFsc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAvL+WIpOaWreS6i+S7tuiKgueCueaYr+WQpuWPr+S7peS+nemZhO+8jOWPr+S7peS+nemZhOaYvuekuue7v+ahhlxyXG4gICAgICAgICAgICAgICBpZiAoQnBtbi5pc1Nsb3RFdmVudChkb20pKSB7XHJcbiAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXQuYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5hbGxOb2Rlc1tpXS5pc0NhblNsb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuYWxsTm9kZXNbaV0uc2xvdCAmJiB0aGF0LmFsbE5vZGVzW2ldLnNsb3QubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCB0aGF0LmFsbE5vZGVzW2ldLnNsb3QubGVuZ3RoOyBhKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdFBvc2l0aW9uID0gW3RoYXQuYWxsTm9kZXNbaV0uc2xvdFthXS5wb3NpdGlvblswXSArIHRoYXQuYWxsTm9kZXNbaV0ucG9zaXRpb25bMF0sIHRoYXQuYWxsTm9kZXNbaV0uc2xvdFthXS5wb3NpdGlvblsxXSArIHRoYXQuYWxsTm9kZXNbaV0ucG9zaXRpb25bMV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3dSZWN0UG9zaXRpb25bMF0gPT0gc2xvdFBvc2l0aW9uWzBdICYmIG5vd1JlY3RQb3NpdGlvblsxXSA9PSBzbG90UG9zaXRpb25bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5yZWN0LmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFwicmdiYSgwLCAyNTUsIDAsIDEpXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTGFwID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICBmdW5jdGlvbiBlbmREcmFnKCkge1xyXG4gICAgICAgICAgICAgICB0aGF0Ll96ci5vZmYoJ21vdXNlbW92ZScsIG1vdmVGdW5jdGlvbik7XHJcbiAgICAgICAgICAgICAgIHRoYXQuX3pyLm9mZignbW91c2V1cCcsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICAgICB0aGF0Ll96ci5vZmYoJ2dsb2JhbG91dCcsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICAgICBpZiAoZG9tLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgZG9tLnBhcmVudC5vZmYoXCJnbG9iYWxvdXRcIiwgdXBGdW5jdGlvbik7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdGhhdC5yZWN0LmhpZGUoKTtcclxuICAgICAgICAgICAgICAgR3VpZGVsaW5lcy52aXJ0dWFsWExpbmUuYXR0cihcInNoYXBlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgIHgyOiAwXHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICBHdWlkZWxpbmVzLnZpcnR1YWxZTGluZS5hdHRyKFwic2hhcGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgeTI6IDBcclxuICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAvL+WkhOeQhuWNleWHu+WtkOiKgueCueWGheeahOafkOS4gOS4quiKgueCueaXtu+8jOW9k+WJjeeahOWuueWZqOiKgueCueS4jeS4uuivpeWtkOiKgueCueeahGJ1Z++8iOS4um51bGzvvIlcclxuICAgICAgICAgICAgICAgaWYgKCF0aGF0LmNvbnRhaW5lck5vZGUgJiYgZG9tLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhkb20ucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXJOb2RlID0gZG9tLnBhcmVudDtcclxuICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGF0LmNvbnRhaW5lck5vZGUgPT09ICd6cicpIHtcclxuICAgICAgICAgICAgICAgICAgIHRoYXQuY29udGFpbmVyTm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdmFyIHJlbW92ZUxpbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgdmFyIGdyb3VwTm9kZVBvc2l0aW9uWCA9IG51bGwsIGdyb3VwTm9kZVBvc2l0aW9uWSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgIGlmIChpc0xhcCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5jb250YWluZXJOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgLy8g5bCG5b2T5YmN6IqC54K55ZKM54i26IqC54K55pGG5q2j77yM5YaN6K6h566X5b2T5YmN6IqC54K55Yiw54i26IqC54K55Lik6L6555qE5Z6C55u06Led56a7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFJlY3QgPSB0aGF0LmNhbGN1bGF0ZVJlY3QodGhhdC5jb250YWluZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSAtcGFyZW50UmVjdC5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSBub3dSZWN0UG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHJvdGF0aW9uKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UG9zaXRpb24gPSB1dGlsLmNhbGN1bGF0ZVBvaW50cyhub3dSZWN0UG9zaXRpb24sIHBhcmVudFJlY3QsIHJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBOb2RlUG9zaXRpb25YID0gbmV3UG9zaXRpb25bMF0gLSBwYXJlbnRSZWN0LmJvdW5kaW5nUmVjdC54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGdyb3VwTm9kZVBvc2l0aW9uWSA9IG5ld1Bvc2l0aW9uWzFdIC0gcGFyZW50UmVjdC5ib3VuZGluZ1JlY3QueTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIHZhciBwb3NYID0gdHlwZW9mIGdyb3VwTm9kZVBvc2l0aW9uWCA9PT0gJ251bWJlcicgPyBncm91cE5vZGVQb3NpdGlvblggOiBub3dSZWN0UG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgcG9zWSA9IHR5cGVvZiBncm91cE5vZGVQb3NpdGlvblkgPT09ICdudW1iZXInID8gZ3JvdXBOb2RlUG9zaXRpb25ZIDogbm93UmVjdFBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgZG9tLnNldFBvc2l0aW9uKHBvc1gsIHBvc1kpO1xyXG4gICAgICAgICAgICAgICAgICAgdGhhdC51cGRhdGVTbG90RXZlbnQoZG9tKTtcclxuICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmNvbnRhaW5lck5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tLnBhcmVudCAmJiB0aGF0LmNvbnRhaW5lck5vZGUuaWQgIT09IGRvbS5wYXJlbnQuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnBhcmVudC5yZW1vdmUoZG9tKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXJOb2RlLmFkZChkb20pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaW5lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFkb20ucGFyZW50ICYmIGRvbS50eXBlICE9PSBcImRyYWdTZWxlY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll96ci5yZW1vdmUoZG9tKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXJOb2RlLmFkZChkb20pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaW5lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGF0Lm92ZXJsYXBBcnJheS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbS5pZCA9PSB0aGF0Lm92ZXJsYXBBcnJheVtqXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub3ZlcmxhcEFycmF5LnNwbGljZShqLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9tLnR5cGUgPT09IFwiZHJhZ1NlbGVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IHRoYXQuZHJhZ1NlbGVjdFJlY3QuY2hpbGRyZW4oKS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2Lm5hbWUgIT09IFwiR1JPVVBfUkVDVF9OQU1FXCIgJiYgIUJwbW4uaXNGbG93KHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gdGhhdC5kcmFnU2VsZWN0UmVjdC5jaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYubmFtZSAhPT0gXCJHUk9VUF9SRUNUX05BTUVcIiAmJiBCcG1uLmlzRmxvdyh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IG5vZGVzLmZpbmQoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmlkID09PSB2LnN0YXJ0Tm9kZS5pZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kTm9kZSA9IG5vZGVzLmZpbmQoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmlkID09PSB2LmVuZE5vZGUuaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlmRXhpc3QgPSBsaW5lcy5maW5kSW5kZXgoZnVuY3Rpb24obGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLmlkID09PSB2LmlkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoc3RhcnROb2RlIHx8IGVuZE5vZGUpICYmIGlmRXhpc3QgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5yZW1vdmVMaW5lKHYsIHYucGFyZW50ID8gdi5wYXJlbnQgOiB0aGF0Ll96cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmRyYWdTZWxlY3RSZWN0LnJlbW92ZShsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29udGFpbmVyTm9kZS5hZGQobGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBzdGFydENvbnRhaW5lciAmJiBzdGFydENvbnRhaW5lci5pZCA9PT0gdGhhdC5jb250YWluZXJOb2RlLmlkID8gZGdSZWN0LndpZHRoIDogZHJhZ1JlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzdGFydENvbnRhaW5lciAmJiBzdGFydENvbnRhaW5lci5pZCA9PT0gdGhhdC5jb250YWluZXJOb2RlLmlkID8gZGdSZWN0LmhlaWdodCA6IGRyYWdSZWN0LmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBub2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlWCA9IGl0ZW0uZ2V0UmVjdCgpLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVkgPSBpdGVtLmdldFJlY3QoKS55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vd1gsIG5vd1k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRDb250YWluZXIgJiYgc3RhcnRDb250YWluZXIuaWQgPT09IHRoYXQuY29udGFpbmVyTm9kZS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd1ggPSBub3dSZWN0UG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93WSA9IG5vd1JlY3RQb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93WCA9IG5vd0RyYWdSZWN0UG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93WSA9IG5vd0RyYWdSZWN0UG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IG5vd1ggLSBCcG1uVXRpbC5wYXJlbnRYKHRoYXQuY29udGFpbmVyTm9kZSkgLSB3aWR0aC8yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldFkgPSBub3dZIC0gQnBtblV0aWwucGFyZW50WSh0aGF0LmNvbnRhaW5lck5vZGUpIC0gaGVpZ2h0LzI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zeCA9IG5vZGVYICsgb2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3N5ID0gbm9kZVkgKyBvZmZzZXRZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uc2xvdEV2ZW50ICYmIGl0ZW0uc2xvdEV2ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGl0ZW0uc2xvdEV2ZW50Lmxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90RXZlbnRQb3NpdGlvbjIgPSBbaXRlbS5zbG90RXZlbnRbbl0ucG9zaXRpb25bMF0gKyBwb3N4IC0genJVdGlsLmNsb25lKGl0ZW0ucG9zaXRpb25bMF0pIC0gaXRlbS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDIsIGl0ZW0uc2xvdEV2ZW50W25dLnBvc2l0aW9uWzFdICsgcG9zeSAtIHpyVXRpbC5jbG9uZShpdGVtLnBvc2l0aW9uWzFdKSAtIGl0ZW0uZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2xvdEV2ZW50W25dLmF0dHIoXCJwb3NpdGlvblwiLCBzbG90RXZlbnRQb3NpdGlvbjIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKGl0ZW0uc2xvdEV2ZW50W25dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmRyYWdTZWxlY3RSZWN0LnJlbW92ZShpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29udGFpbmVyTm9kZS5hZGQoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFBvc2l0aW9uKHBvc3gsIHBvc3kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3JpZ2luUGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vcmlnaW5QYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCB0aGF0Lm92ZXJsYXBBcnJheS5sZW5ndGg7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmlkID09IHRoYXQub3ZlcmxhcEFycmF5W21dLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub3ZlcmxhcEFycmF5LnNwbGljZShtLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHRoYXQuZG9tQXJyYXkubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pZCA9PSB0aGF0LmRvbUFycmF5W25dLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZG9tQXJyYXlbbl0ucG9zaXRpb24gPSBbbm9kZVggKyAobm93RHJhZ1JlY3RQb3NpdGlvblswXSAtIHdpZHRoLzIpLCBub2RlWSArIChub3dEcmFnUmVjdFBvc2l0aW9uWzFdIC0gaGVpZ2h0LzIpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZHJhZ1NlbGVjdFJlY3Qub2ZmKFwibW91c2Vkb3duXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll96ci5yZW1vdmUodGhhdC5kcmFnU2VsZWN0UmVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29udGFpbmVyTm9kZS5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYubmFtZSA9PT0gXCJzdWJwcm9jZXNzLXJlY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2LmluaXRTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbml0RmlsbCA9IHYuc3R5bGUuZmlsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LmF0dHIoXCJpbml0U3R5bGVcIiwgaW5pdEZpbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdi5pbml0U3R5bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiB2LmluaXRTdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9tLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGRvbS5wYXJlbnQucmVtb3ZlKGRvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fenIuYWRkKGRvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGluZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFCcG1uLmlzU2xvdEV2ZW50KGRvbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5vdmVybGFwQXJyYXkucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogZG9tLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFtub3dSZWN0UG9zaXRpb25bMF0sIG5vd1JlY3RQb3NpdGlvblsxXV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZG9tLmdldFJlY3QoKS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZG9tLmdldFJlY3QoKS5oZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgaWYgKGRvbS50eXBlICE9PSBcImRyYWdTZWxlY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgdGhhdC5kb21BcnJheS5sZW5ndGg7IGIrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tLmlkID09IHRoYXQuZG9tQXJyYXlbYl0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZG9tQXJyYXlbYl0ucG9zaXRpb24gPSBbbm93UmVjdFBvc2l0aW9uWzBdLCBub3dSZWN0UG9zaXRpb25bMV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhhdC5jb250YWluZXJOb2RlICYmICFkb20ucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhhdC5vdmVybGFwQXJyYXkubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb20uaWQgPT0gdGhhdC5vdmVybGFwQXJyYXlbal0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm92ZXJsYXBBcnJheVtqXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGRvbS5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFtub3dSZWN0UG9zaXRpb25bMF0sIG5vd1JlY3RQb3NpdGlvblsxXV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkb20uZ2V0UmVjdCgpLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGRvbS5nZXRSZWN0KCkuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoYXQuY29udGFpbmVyTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHMgPSB0aGF0LmRyYWdTZWxlY3RSZWN0LmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2Lm5hbWUgIT09IFwiR1JPVVBfUkVDVF9OQU1FXCIgJiYgIUJwbW4uaXNGbG93KHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IHRoYXQuZHJhZ1NlbGVjdFJlY3QuY2hpbGRyZW4oKS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYubmFtZSAhPT0gXCJHUk9VUF9SRUNUX05BTUVcIiAmJiBCcG1uLmlzRmxvdyh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnROb2RlID0gY2hpbGRzLmZpbmQoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuaWQgPT09IHYuc3RhcnROb2RlLmlkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kTm9kZSA9IGNoaWxkcy5maW5kKGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmlkID09PSB2LmVuZE5vZGUuaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZkV4aXN0ID0gbGluZXMuZmluZEluZGV4KGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLmlkID09PSB2LmlkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHN0YXJ0Tm9kZSB8fCBlbmROb2RlKSAmJiBpZkV4aXN0ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5yZW1vdmVMaW5lKHYsIHYucGFyZW50ID8gdi5wYXJlbnQgOiB0aGF0Ll96cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdFdpZHRoID0gdGhhdC5kcmFnU2VsZWN0UmVjdC5vcHRpb25zLnNoYXBlLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0SGVpZ2h0ID0gdGhhdC5kcmFnU2VsZWN0UmVjdC5vcHRpb25zLnNoYXBlLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNoaWxkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBub2RlLmdldFJlY3QoKS54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IG5vZGUuZ2V0UmVjdCgpLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgdGhhdC5kb21BcnJheS5sZW5ndGg7IHArKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT0gdGhhdC5kb21BcnJheVtwXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZG9tQXJyYXlbcF0ucG9zaXRpb24gPSBbeCArIChub3dSZWN0UG9zaXRpb25bMF0gLSByZWN0V2lkdGgvMiksIHkgKyAobm93UmVjdFBvc2l0aW9uWzFdIC0gcmVjdEhlaWdodC8yKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcSA9IDA7IHEgPCB0aGF0Lm92ZXJsYXBBcnJheS5sZW5ndGg7IHErKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT0gdGhhdC5vdmVybGFwQXJyYXlbcV0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm92ZXJsYXBBcnJheVtxXS5wb3NpdGlvbiA9IFt4ICsgKG5vd1JlY3RQb3NpdGlvblswXSAtIHJlY3RXaWR0aC8yKSwgeSArIChub3dSZWN0UG9zaXRpb25bMV0gLSByZWN0SGVpZ2h0LzIpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fcmVsZWFzZVNlbGVjdE5vZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoYXQuY29udGFpbmVyTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXJOb2RlLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmICh2Lm5hbWUgPT09IFwic3VicHJvY2Vzcy1yZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2LmluaXRTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRGaWxsID0gdi5zdHlsZS5maWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5hdHRyKFwiaW5pdFN0eWxlXCIsIGluaXRGaWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiB2LmluaXRTdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdi5pbml0U3R5bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdGhhdC5yZXNldEJhY2tncm91bmQoKTtcclxuICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXJOb2RlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgIGlmIChpc01vdmUgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZUxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2LnN0YXJ0Tm9kZS5pZCA9PT0gZG9tLmlkIHx8IHYuZW5kTm9kZS5pZCA9PT0gZG9tLmlkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlbW92ZUxpbmUoaXRlbSwgaXRlbS5wYXJlbnQgPyBpdGVtLnBhcmVudCA6IHRoYXQuX3pyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKGRvbSk7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0Lm5vZGVDbGlja0hhbmRsZXIoZG9tKTtcclxuICAgICAgICAgICAgICAgICAgIHRoYXQuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgLy/lsIbkuovku7boioLngrnkuI50YXNr6IqC54K557uR5a6a5oiW6Kej57uRXHJcbiAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU2xvdEV2ZW50KGRvbSkgJiYgaXNMYXAgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIG5ld1JlY3RQb3NpdGlvbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKGRvbS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoQnBtbi5pc1N1YlByb2Nlc3MoZG9tLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UmVjdFBvc2l0aW9uWzBdID0gbm93UmVjdFBvc2l0aW9uWzBdIC0gQnBtblV0aWwucGFyZW50WChkb20ucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UmVjdFBvc2l0aW9uWzFdID0gbm93UmVjdFBvc2l0aW9uWzFdIC0gQnBtblV0aWwucGFyZW50WShkb20ucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIG5ld1JlY3RQb3NpdGlvbiA9IG5vd1JlY3RQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmFsbE5vZGVzW2ldLmlzQ2FuU2xvdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5hbGxOb2Rlc1tpXS5zbG90ICYmIHRoYXQuYWxsTm9kZXNbaV0uc2xvdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5iaW5kID0gdHJ1ZSwgZXhpc3QgPSBmYWxzZSwgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHRoYXQuYWxsTm9kZXNbaV0uc2xvdC5sZW5ndGg7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90UG9zaXRpb24gPSBbdGhhdC5hbGxOb2Rlc1tpXS5zbG90W2NdLnBvc2l0aW9uWzBdICsgdGhhdC5hbGxOb2Rlc1tpXS5wb3NpdGlvblswXSwgdGhhdC5hbGxOb2Rlc1tpXS5zbG90W2NdLnBvc2l0aW9uWzFdICsgdGhhdC5hbGxOb2Rlc1tpXS5wb3NpdGlvblsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vd1JlY3RQb3NpdGlvblswXSA9PSBzbG90UG9zaXRpb25bMF0gJiYgbm93UmVjdFBvc2l0aW9uWzFdID09IHNsb3RQb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmJpbmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoYXQuYWxsTm9kZXNbaV0uc2xvdEV2ZW50Lmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbS5pZCA9PSB0aGF0LmFsbE5vZGVzW2ldLnNsb3RFdmVudFtrXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWxsTm9kZXNbaV0uc2xvdEV2ZW50W2tdLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmJpbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWxsTm9kZXNbaV0uc2xvdEV2ZW50LnNwbGljZShrLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3QgJiYgIXVuYmluZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOagh+iusHNsb3RFdmVudOS4jm5vZGUgc2xvdOaVsOe7hOWFs+iBlFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWxsTm9kZXNbaV0uc2xvdEV2ZW50LnB1c2goZG9tKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhpc3QgJiYgdW5iaW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRvbS5pbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgdGhpcy5fenIub24oXCJtb3VzZXVwXCIsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgICAgIHRoaXMuX3pyLm9uKFwiZ2xvYmFsb3V0XCIsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLnNldEJhY2tncm91bmQgPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICB0aGlzLnpyQmFja2dyb3VuZCA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuX3pyLmdldFdpZHRoKCksXHJcbiAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuX3pyLmdldEhlaWdodCgpXHJcbiAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICBmaWxsOiBjb2xvclxyXG4gICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICBjdXJzb3I6ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgICAgejogLTFcclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICB0aGlzLl96ci5hZGQodGhpcy56ckJhY2tncm91bmQpO1xyXG4gICAgICAgfVxyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8ucmVzZXRCYWNrZ3JvdW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgIGlmICh0aGlzLnpyQmFja2dyb3VuZCkge1xyXG4gICAgICAgICAgICAgICB0aGlzLl96ci5yZW1vdmUodGhpcy56ckJhY2tncm91bmQpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH1cclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uY3JlYXRUaXAgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgLy/liJvlu7p0YXNr5YaF5a6555qE5o+Q56S6XHJcbiAgICAgICAgICAgdmFyIGdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICAgICBncm91cC5pc1Nob3cgPSBmYWxzZTtcclxuICAgICAgICAgICB2YXIgbmFtZSA9IG5vZGUubW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpIHx8IFwiXCI7XHJcbiAgICAgICAgICAgdmFyIHNob3dOYW1lO1xyXG4gICAgICAgICAgIGlmIChuYW1lLmxlbmd0aCA+IDY0KSB7XHJcbiAgICAgICAgICAgICAgIHNob3dOYW1lID0gbmFtZS5zdWJzdHIoMCwgNjQpICsgJy4uJztcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICBzaG93TmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICB0ZXh0OiBzaG93TmFtZSxcclxuICAgICAgICAgICAgICAgICAgIHRleHRGb250OiAnMTZweCBNaWNyb3NvZnQgWWFIZWknLFxyXG4gICAgICAgICAgICAgICAgICAgZmlsbDogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IFwidG9wXCIgLy/lnoLnm7Tlr7npvZBcclxuICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgcG9zaXRpb246IFsyLCAwXSxcclxuICAgICAgICAgICAgICAgejogMlxyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIHRleHQubmFtZSA9IFwiVGV4dFwiO1xyXG4gICAgICAgICAgIGdyb3VwLmFkZCh0ZXh0KTtcclxuICAgICAgICAgICB2YXIgUG9seWxpbmUgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSh7XHJcbiAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICBmaWxsOiAnI2Y5ZjlmOScsXHJcbiAgICAgICAgICAgICAgICAgICBzdHJva2U6ICcjYmJiYmJiJ1xyXG4gICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICB6OiAxXHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgUG9seWxpbmUubmFtZSA9IFwiUG9seWxpbmVcIjtcclxuICAgICAgICAgICBncm91cC5hZGQoUG9seWxpbmUpO1xyXG4gICAgICAgICAgIC8vIHZhciBncm91cFBvc2l0aW9uID0gW25vZGUucG9zaXRpb25bMF0gLSBub2RlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoLzIgLSAoZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLSA2KSwgbm9kZS5wb3NpdGlvblsxXS0gbm9kZS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyIC0gZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC0gM107XHJcbiAgICAgICAgICAgLy8gZ3JvdXAuYXR0cihcInBvc2l0aW9uXCIsIGdyb3VwUG9zaXRpb24pO1xyXG4gICAgICAgICAgIHRoaXMuX3pyLmFkZChncm91cCk7XHJcbiAgICAgICAgICAgbm9kZS5hbGFybSA9IGdyb3VwO1xyXG4gICAgICAgICAgIGdyb3VwLmhpZGUoKTtcclxuICAgICAgICAgICBncm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgY2hpbGQuaGlkZSgpO1xyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLnN0ZXBDb3VudGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgdGhpcy5zdGVwSnNvbi5zcGxpY2UodGhpcy5zdGVwLCB0aGlzLnN0ZXBKc29uLmxlbmd0aCAtICh0aGlzLnN0ZXApKTtcclxuICAgICAgICAgICB0aGlzLnN0ZXAgKz0gMTtcclxuICAgICAgICAgICB2YXIganNvbiA9IHRoaXMudG9Kc29uKCk7XHJcbiAgICAgICAgICAgdGhpcy5zdGVwSnNvbi5wdXNoKEpTT04uc3RyaW5naWZ5KGpzb24pKTtcclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDmlL7lpKfmiJbogIXnvKnlsI9cclxuICAgICAgICAqIEBwYXJhbSAge1N0cmluZ3xOdW1iZXJ9IHR5cGUg5b2T5Li65a2X56ym5Liy5pe2IFwiZW5sYXJnZVwi5pS+5aSnICBcIm5hcnJvd2luZ1wi57yp5bCPICDlvZPkuLrmlbDlgLzml7Yg57yp5pS+55qE5q+U5L6LICDlu7rorq4wLjMtMS43XHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uenJTY2FsZSA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJuYXJyb3dpbmdcIikge1xyXG4gICAgICAgICAgICAgICB2YXIgem9vbURlbHRhMSA9IC0wLjA3O1xyXG4gICAgICAgICAgICAgICB0aGlzLnpvb20oem9vbURlbHRhMSwgdGhpcy5fenIuZ2V0V2lkdGgoKSAvIDIsIHRoaXMuX3pyLmdldEhlaWdodCgpIC8gMik7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGlmICh0eXBlID09IFwiZW5sYXJnZVwiKSB7XHJcbiAgICAgICAgICAgICAgIHZhciB6b29tRGVsdGEgPSAwLjA3O1xyXG4gICAgICAgICAgICAgICB0aGlzLnpvb20oem9vbURlbHRhLCB0aGlzLl96ci5nZXRXaWR0aCgpIC8gMiwgdGhpcy5fenIuZ2V0SGVpZ2h0KCkgLyAyKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgaWYgKCFpc05hTih0eXBlKSkge1xyXG4gICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5ncm91cDtcclxuICAgICAgICAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIHpvb21TY2FsZSA9IHR5cGUgLyB0aGlzLl96b29tO1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5fem9vbSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLm5vd1pvb20gPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTY2FsZSh0aGlzLl96ci5nZXRXaWR0aCgpIC8gMiwgdGhpcy5fenIuZ2V0SGVpZ2h0KCkgLyAyLCB6b29tU2NhbGUpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uem9vbSA9IGZ1bmN0aW9uICh6b29tRGVsdGEsIHpvb21YLCB6b29tWSkge1xyXG4gICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmdyb3VwO1xyXG4gICAgICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgdmFyIG5ld1pvb20gPSB0aGlzLl96b29tID0gdGhpcy5fem9vbSB8fCAxO1xyXG4gICAgICAgICAgICAgICBuZXdab29tICs9IHpvb21EZWx0YTtcclxuICAgICAgICAgICAgICAgbmV3Wm9vbSA9IE51bWJlcihuZXdab29tLnRvRml4ZWQoMikpO1xyXG4gICAgICAgICAgICAgICB2YXIgem9vbVNjYWxlID0gbmV3Wm9vbSAvIHRoaXMuX3pvb207XHJcbiAgICAgICAgICAgICAgIGlmIChuZXdab29tID4gMS43IHx8IG5ld1pvb20gPCAwLjMpIHtcclxuICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB0aGlzLl96b29tID0gbmV3Wm9vbTtcclxuICAgICAgICAgICAgICAgdGhpcy5ub3dab29tID0gbmV3Wm9vbTtcclxuICAgICAgICAgICAgICAgdGhpcy5zZXRTY2FsZSh6b29tWCwgem9vbVksIHpvb21TY2FsZSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uc2V0U2NhbGUgPSBmdW5jdGlvbiAoem9vbVgsIHpvb21ZLCB6b29tU2NhbGUpIHtcclxuICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5maW5kRWxlbWVudHMoZnVuY3Rpb24oZSl7cmV0dXJuIHRydWU7fSk7XHJcbiAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgICAgbm9kZXMucHVzaCh0YXJnZXQpO1xyXG4gICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgdmFyIHBvcyA9IHYucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IHYuc2NhbGU7XHJcbiAgICAgICAgICAgICAgIHNjYWxlWzBdICo9IHpvb21TY2FsZTtcclxuICAgICAgICAgICAgICAgc2NhbGVbMV0gKj0gem9vbVNjYWxlO1xyXG4gICAgICAgICAgICAgICB2LmF0dHIoXCJzY2FsZVwiLCBbc2NhbGVbMF0sIHNjYWxlWzFdXSk7XHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqIOiKgueCueS4iuaWh+Wtl+e8lui+kVxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLm5vZGVFZGl0ID0gZnVuY3Rpb24gKHRoaXNOb2RlKSB7XHJcbiAgICAgICAgICAgdmFyIGxpbmVUZXh0ID0gdGhpc05vZGUuY2hpbGRPZk5hbWUoJ2xpbmVUZXh0Jyk7XHJcbiAgICAgICAgICAgaWYgKHRoaXMuZm9yYmlkRWRpdCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHZhciBPRkZTRVRfTVVMVElQTEUgPSAwLjU1OyAvL+aWh+acrOahhuWuveW6puOAgemrmOW6pueahOWBj+enu+ezu+aVsFxyXG4gICAgICAgICAgIHZhciBpc05vdFNldFRleHQgPSBmYWxzZTtcclxuICAgICAgICAgICB2YXIgbm9kZVJlY3QgPSB1dGlsLmdldFJlY3QodGhpc05vZGUpO1xyXG4gICAgICAgICAgIHZhciB0ZXh0YXJlYSA9IHRoaXMuY3JlYXRlVGV4dEFyZWEoKTtcclxuICAgICAgICAgICB2YXIgbm9kZVRleHQgPSB6clV0aWwuY2xvbmUodGhpc05vZGUubW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpKTtcclxuICAgICAgICAgICB2YXIgdGV4dFJlY3QgPSAodGhpc05vZGUgaW5zdGFuY2VvZiBDb25uZWN0b3IpICYmIGxpbmVUZXh0ID8gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KGxpbmVUZXh0LnN0eWxlLnRleHQsIFwiMTJweFwiKSA6IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChub2RlVGV4dCwgXCIxMnB4XCIpO1xyXG4gICAgICAgICAgIHZhciB0ZXh0YXJlYU1pbldpZHRoID0gMC42ICogbm9kZVJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgdmFyIHRleHRhcmVhV2lkdGggPSAodGV4dFJlY3Qud2lkdGggPT0gMCA/IHRleHRhcmVhTWluV2lkdGggOiAoKHRoaXNOb2RlIGluc3RhbmNlb2YgQ29ubmVjdG9yKSAmJiAodGV4dFJlY3Qud2lkdGggPiA2MCkgPyAxLjIgKiB0ZXh0UmVjdC53aWR0aCA6IDIgKiB0ZXh0UmVjdC53aWR0aCkpICogdGhpcy5ub3dab29tO1xyXG4gICAgICAgICAgIHZhciB0ZXh0YXJlYUhlaWdodCA9ICgyICogdGV4dFJlY3QuaGVpZ2h0IHx8IDI0KSAqIHRoaXMubm93Wm9vbTtcclxuICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS53aWR0aCA9IHRleHRhcmVhV2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gdGV4dGFyZWFIZWlnaHQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgdmFyIHRleHRhcmVhTWF4V2lkdGggPSAxLjIgKiBub2RlUmVjdC53aWR0aCAqIHRoaXMubm93Wm9vbTtcclxuICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5tYXhXaWR0aCA9IHRleHRhcmVhTWF4V2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUubGluZUhlaWdodCA9ICgxLjIgKiB0ZXh0UmVjdC5saW5lSGVpZ2h0IHx8IDE0LjQpICsgXCJweFwiO1xyXG4gICAgICAgICAgIHRleHRhcmVhLnN0eWxlLmJvcmRlciA9IFwiMXB4IGRhc2hlZCAjMmUyZTJlXCI7XHJcbiAgICAgICAgICAgdGV4dGFyZWEuaW5uZXJIVE1MID0gdGhpc05vZGUubW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpO1xyXG4gICAgICAgICAgIHRoaXMuc2V0U2hhcGVNb2RlbCh0aGlzTm9kZSwge3Byb3BlcnRpZXM6IHtuYW1lOiBcIlwifX0pO1xyXG4gICAgICAgICAgIHRoaXMuX2RvbS5hcHBlbmRDaGlsZCh0ZXh0YXJlYSk7XHJcbiAgICAgICAgICAgdGhpcy5fZG9tLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG4gICAgICAgICAgIHZhciBvZmZlc3RJID0gMTtcclxuICAgICAgICAgICB2YXIgb2ZmZXN0UCA9IDA7XHJcbiAgICAgICAgICAgdmFyIHBvc1ggPSAwLCBwb3NZID0gMDtcclxuICAgICAgICAgICBpZiAodGhpc05vZGUgaW5zdGFuY2VvZiBDb25uZWN0b3IpIHsvL+i/nue6v1xyXG4gICAgICAgICAgICAgICBpZiAodGhpc05vZGUucGFyZW50ICYmIEJwbW4uaXNTdWJQcm9jZXNzKHRoaXNOb2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgIHBvc1ggPSBCcG1uVXRpbC5wYXJlbnRYKHRoaXNOb2RlLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICBwb3NZID0gQnBtblV0aWwucGFyZW50WSh0aGlzTm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGlmIChsaW5lVGV4dCkgeyAvL+acieaWh+acrOaXtlxyXG4gICAgICAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUudG9wID0gKGxpbmVUZXh0LnBvc2l0aW9uWzFdICsgcG9zWSArIHRleHRSZWN0LmhlaWdodCAvIDIgLSB0ZXh0YXJlYUhlaWdodCAvIDIpICogdGhpcy5ub3dab29tICsgdGhpcy5ncm91cFxyXG4gICAgICAgICAgICAgICAgICAgICAgIC5wb3NpdGlvblsxXSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLmxlZnQgPSAobGluZVRleHQucG9zaXRpb25bMF0gKyBwb3NYIC0gdGV4dGFyZWFXaWR0aCAvIDIpICogdGhpcy5ub3dab29tICtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLnBvc2l0aW9uWzBdICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIGxpbmVNaWRkbGVQb3MgPSB0aGlzTm9kZS5taWRkbGUoKTtcclxuICAgICAgICAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLnRvcCA9IChsaW5lTWlkZGxlUG9zWzFdICsgcG9zWSArIHRleHRSZWN0LmhlaWdodCAvIDIgLSB0ZXh0YXJlYUhlaWdodCAvIDIpICogdGhpcy5ub3dab29tICsgdGhpcy5ncm91cFxyXG4gICAgICAgICAgICAgICAgICAgICAgIC5wb3NpdGlvblsxXSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLmxlZnQgPSAobGluZU1pZGRsZVBvc1swXSArIHBvc1ggLSB0ZXh0YXJlYVdpZHRoIC8gMikgKiB0aGlzLm5vd1pvb20gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAucG9zaXRpb25bMF0gKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9IGVsc2UgeyAvL+iKgueCuVxyXG4gICAgICAgICAgICAgICBpZiAodGhpc05vZGUucGFyZW50ICYmIEJwbW4uaXNTdWJQcm9jZXNzKHRoaXNOb2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgIHBvc1ggPSBub2RlUmVjdC54ICsgQnBtblV0aWwucGFyZW50WCh0aGlzTm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgcG9zWSA9IG5vZGVSZWN0LnkgKyBCcG1uVXRpbC5wYXJlbnRZKHRoaXNOb2RlLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICBwb3NYID0gbm9kZVJlY3QueDtcclxuICAgICAgICAgICAgICAgICAgIHBvc1kgPSBub2RlUmVjdC55O1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLnRvcCA9IChwb3NZIC0gdGV4dGFyZWFIZWlnaHQgLyAyICsgb2ZmZXN0UCAqIChub2RlUmVjdC5oZWlnaHQgLSB0ZXh0UmVjdC5oZWlnaHQgL1xyXG4gICAgICAgICAgICAgICAgICAgMikpICogdGhpcy5ub3dab29tICsgdGhpcy5ncm91cC5wb3NpdGlvblsxXSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUubGVmdCA9IChwb3NYIC0gb2ZmZXN0SSAqICh0ZXh0YXJlYVdpZHRoIDwgdGV4dGFyZWFNYXhXaWR0aCA/IHRleHRhcmVhV2lkdGggOiB0ZXh0YXJlYU1heFdpZHRoKSAvIDIpICogdGhpcy5ub3dab29tICtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAucG9zaXRpb25bMF0gKyBcInB4XCI7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHRleHRhcmVhLmZvY3VzKCk7XHJcbiAgICAgICAgICAgdGV4dGFyZWEuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgdGV4dGFyZWEub25rZXl1cCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBrZXlDb2RlLkVTQ0FQRSkge1xyXG4gICAgICAgICAgICAgICAgICAgaXNOb3RTZXRUZXh0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgIHRleHRhcmVhLmJsdXIoKTtcclxuICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0UmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdCh0ZXh0YXJlYS52YWx1ZSwgXCIxMnB4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dGFyZWFSZXNpemUodGV4dFJlY3QsIHRleHRhcmVhLCB0ZXh0YXJlYS5zdHlsZS5tYXhXaWR0aCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgICAgICAgIHRleHRhcmVhLm9uYmx1ciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICBpZiAoIWlzTm90U2V0VGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmhhbmRsZVdyYXAodGV4dGFyZWEudmFsdWUsIHRleHRhcmVhLnN0eWxlLm1heFdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2hhcGVNb2RlbCh0aGlzTm9kZSwge3Byb3BlcnRpZXM6IHtuYW1lOiB0ZXh0fX0pO1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcignYWZ0ZXJFZGl0Tm9kZScsIHt0YXJnZXQ6IHRoaXNOb2RlfSk7XHJcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNoYXBlTW9kZWwodGhpc05vZGUsIHtwcm9wZXJ0aWVzOiB7bmFtZTogbm9kZVRleHR9fSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdGV4dGFyZWEucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKiDliJvlu7rmlofmnKzln59cclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5jcmVhdGVUZXh0QXJlYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICB2YXIgdGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XHJcbiAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcbiAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUucGFkZGluZyA9IFwiNnB4XCI7XHJcbiAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUucmVzaXplID0gXCJub25lXCI7XHJcbiAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUud2hpdGVTcGFjZSA9IFwicHJlXCI7XHJcbiAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUubGluZUhlaWdodCA9IFwiMTI1JVwiO1xyXG4gICAgICAgICAgIHRleHRhcmVhLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcclxuICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5ib3JkZXIgPSBcIjBcIjtcclxuICAgICAgICAgICB0ZXh0YXJlYS5zcGVsbGNoZWNrID0gZmFsc2U7XHJcbiAgICAgICAgICAgcmV0dXJuIHRleHRhcmVhO1xyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKiDlpITnkIZ0ZXh0YXJlYeiHquWKqOaNouihjFxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmhhbmRsZVdyYXAgPSBmdW5jdGlvbiAodmFsdWUsIHdpZHRoKSB7XHJcbiAgICAgICAgICAgdmFyIHNwYW5Ob2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcbiAgICAgICAgICAgc3Bhbk5vZGUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcbiAgICAgICAgICAgc3Bhbk5vZGUuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xyXG4gICAgICAgICAgIHNwYW5Ob2RlLnN0eWxlLmJvcmRlciA9IFwiMFwiO1xyXG4gICAgICAgICAgIHNwYW5Ob2RlLnN0eWxlLnBhZGRpbmcgPSBcIjBcIjtcclxuICAgICAgICAgICBzcGFuTm9kZS5zdHlsZS5sZWZ0ID0gXCIwXCI7XHJcbiAgICAgICAgICAgc3Bhbk5vZGUuc3R5bGUudG9wID0gXCIwXCI7XHJcbiAgICAgICAgICAgdGhpcy5fZG9tLmFwcGVuZENoaWxkKHNwYW5Ob2RlKTtcclxuICAgICAgICAgICB2YXIgY29udGVudCA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgICAgIGNvbnRlbnQuZm9yRWFjaChmdW5jdGlvbiAodmFsLCBpKSB7XHJcbiAgICAgICAgICAgICAgIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICBpZiAodmFsTGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgIC8vcmVzdWx0ICs9IFwiXFxuXCI7XHJcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgcHJlID0gXCJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICBpbm5lclZhbCwgdGVtcFdpZHRoLCBjb25XaWR0aDtcclxuICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlubmVySSA9IDA7IGlubmVySSA8IHZhbExlbmd0aDsgaW5uZXJJKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBpbm5lclZhbCA9IHZhbC5jaGFyQXQoaW5uZXJJKTtcclxuICAgICAgICAgICAgICAgICAgICAgICBzcGFuTm9kZS5pbm5lckhUTUwgPSBzcGFuTm9kZS5pbm5lckhUTUwgKyBpbm5lclZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICB0ZW1wV2lkdGggPSBzcGFuTm9kZS5jbGllbnRXaWR0aDsgLy/ojrflj5bmt7vliqDlrZfnrKblkI7pmpDol4/ln5/nmoTlrr3luqZcclxuICAgICAgICAgICAgICAgICAgICAgICBjb25XaWR0aCA9IE51bWJlcih3aWR0aC5zdWJzdHJpbmcoMCwgd2lkdGgubGVuZ3RoIC0gMikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wV2lkdGggPiBjb25XaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcHJlOyAvL+WmguaenOi/veWKoOWtl+espuWQjumakOiXj+Wfn+WuveW6puWkp+S6jlRleHRBcmVh5a695bqm77yM5YiZ6KGo5piO6K+l5a2X56ym5Li65LiL5LiA6KGM5a2X56ym77yMXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuTm9kZS5pbm5lckhUTUwgPSBpbm5lclZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlID0gaW5uZXJWYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbm5lckkgPT0gdmFsTGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcHJlICsgaW5uZXJWYWw7IC8v5pyA5ZCO5LiA5Liq5a2X56ymXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgY29udGVudC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuTm9kZS5pbm5lckhUTUwgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBwcmUgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZSArPSBpbm5lclZhbDsgLy/kvp3mrKHov73liqDliLBwcmXlj5jph4/kuK1cclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgdGhpcy5fZG9tLnJlbW92ZUNoaWxkKHNwYW5Ob2RlKTtcclxuICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKiDmlofmnKzln5/oh6rpgILlupTpq5jlrr1cclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5fdGV4dGFyZWFSZXNpemUgPSBmdW5jdGlvbiAodGV4dFJlY3QsIHRleHRhcmVhLCB3aWR0aCkge1xyXG4gICAgICAgICAgIHZhciBtaW5XaWR0aCA9IDA7XHJcbiAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSAwO1xyXG4gICAgICAgICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gKDEuMSAqIHRleHRSZWN0LndpZHRoKSAqIHRoaXMubm93Wm9vbSArIFwicHhcIjtcclxuICAgICAgICAgICBpZiAod2lkdGggPCA2MCkge1xyXG4gICAgICAgICAgICAgICBtaW5XaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIG1pbldpZHRoID0gNjBcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgaWYgKHRleHRSZWN0LndpZHRoIDw9IG1pbldpZHRoKSB7XHJcbiAgICAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gbWluV2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9IFwiMHB4XCI7XHJcbiAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gdGV4dGFyZWEuc2Nyb2xsSGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICAgICBpZiAodGV4dGFyZWEuc2Nyb2xsSGVpZ2h0IDw9IDApIHtcclxuICAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gXCIxMnB4XCI7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfVxyXG5cclxuICAgICAgIHpyVXRpbC5taXhpbihGaXNoVG9wb0JwbW4sIEV2ZW50ZnVsKTtcclxuXHJcbiAgICAgICAvLyAtLS0tLS0tLS3lr7nlpJbmmrTpnLJmaXNoVG9wb0JwbW4tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgIHZhciBpZEJhc2UgPSBuZXcgRGF0ZSgpIC0gMDtcclxuICAgICAgIHZhciBpbnN0YW5jZXMgPSB7fTtcclxuICAgICAgIHZhciBET01fQVRUUklCVVRFX0tFWSA9ICdfZmlzaFRvcG9CcG1uX2luc3RhbmNlXyc7XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBmaXNoVG9wb0JwbW7lhajlsYDlr7nosaHvvIzlpoLmnpzmmK9hbWTmlrnlvI/liqDovb3vvIzliJnnm7TmjqXov5Tlm55cclxuICAgICAgICAqIEBjbGFzcyBmaXNoVG9wb0JwbW5cclxuICAgICAgICAqIEBzaW5nbGV0b25cclxuICAgICAgICAqL1xyXG4gICAgICAgdmFyIGZpc2hUb3BvQnBtbiA9IHtcclxuICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgKiDniYjmnKzlj7dcclxuICAgICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgIHZlcnNpb246ICczLjIuMCcsXHJcbiAgICAgICAgICAgZGVwZW5kZW5jaWVzOiB7XHJcbiAgICAgICAgICAgICAgIHpyZW5kZXI6ICczLjAuNCdcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICog5Yid5aeL5YyWZG9t5YWD57Sg5Li6IGJwbW7lr7nosaFcclxuICAgICAgICAqIEBtZW1iZXIgZmlzaFRvcG9CcG1uXHJcbiAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb20gIOS4gOS4qmRpduWFg+e0oFxyXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgIOS8oOmAkueahOmAiemhueWPguaVsFxyXG4gICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyPSdjYW52YXMnXSAnY2FudmFzJyBvciAnc3ZnJyBvciAndm1sJ1xyXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW89MV0gcmV0aW5hIOWxj+W5leS8mOWMllxyXG4gICAgICAgICogQHJldHVybiB7ZmlzaC50b3BvLkZpc2hUb3BvQnBtbn1cclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9CcG1uLmluaXQgPSBmdW5jdGlvbihkb20sIG9wdHMpIHtcclxuICAgICAgICAgICBpZiAoIWRvbSkge1xyXG4gICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luaXRpYWxpemUgZmFpbGVkOiBpbnZhbGlkIGRvbS4nKTtcclxuICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gICAgICAgICAgIC8vIERlZmF1bHQgdmFsdWVcclxuICAgICAgICAgICB6clV0aWwuZGVmYXVsdHMob3B0cywge1xyXG4gICAgICAgICAgICAgICB0eXBlOiBcImJwbW5cIixcclxuICAgICAgICAgICAgICAgc2hvd0dyaWRMaW5lOiB0cnVlLFxyXG4gICAgICAgICAgICAgICBncmlkTGluZVNwYWNpbmc6IDEwLFxyXG4gICAgICAgICAgICAgICBiZWZvcmVEZWxldGVOb2RlOiBudWxsLCAgLy/liKDpmaToioLngrnkuYvliY3nmoTkuovku7ZcclxuICAgICAgICAgICAgICAgYmVmb3JlQ3JlYXRlTm9kZTpudWxsLCAgIC8v5Yib5bu66IqC54K55LmL5YmN55qE5LqL5Lu2XHJcbiAgICAgICAgICAgICAgIGJlZm9yZURlbGV0ZUxpbmU6IG51bGwsICAvL+WIoOmZpOi/nue6v+S5i+WJjeeahOS6i+S7tlxyXG4gICAgICAgICAgICAgICBiZWZvcmVDcmVhdGVMaW5lOm51bGwsICAgIC8v5Yib5bu66L+e57q/5LmL5YmN55qE5LqL5Lu2XHJcbiAgICAgICAgICAgICAgIHNjYWxlYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgIHJvdGF0YWJsZTogZmFsc2VcclxuICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgdmFyIGZpc2hUb3BvQnBtbiA9IG5ldyBGaXNoVG9wb0JwbW4oZG9tLCBvcHRzKTtcclxuICAgICAgICAgICBmaXNoVG9wb0JwbW4uaW5pdCgpO1xyXG5cclxuICAgICAgICAgICBmaXNoVG9wb0JwbW4uaWQgPSAnZnRfJyArIGlkQmFzZSsrO1xyXG4gICAgICAgICAgIGluc3RhbmNlc1tmaXNoVG9wb0JwbW4uaWRdID0gZmlzaFRvcG9CcG1uO1xyXG5cclxuICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlICYmIGRvbS5zZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVksIGZpc2hUb3BvQnBtbi5pZCk7XHJcblxyXG4gICAgICAgICAgIHJldHVybiBmaXNoVG9wb0JwbW47XHJcbiAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIOiOt+WPliBkb20g5a655Zmo5LiK55qE5a6e5L6L44CCXHJcbiAgICAgICAgKiBAbWVtYmVyIGZpc2hUb3BvQnBtblxyXG4gICAgICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGRvbSDkuIDkuKpkaXblhYPntKBcclxuICAgICAgICAqIEByZXR1cm4ge2Zpc2gudG9wby5GaXNoVG9wb0JwbW59XHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvQnBtbi5nZXRJbnN0YW5jZUJ5RG9tID0gZnVuY3Rpb24oZG9tKSB7XHJcbiAgICAgICAgICAgdmFyIGtleSA9IGRvbS5nZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVkpO1xyXG4gICAgICAgICAgIHJldHVybiBpbnN0YW5jZXNba2V5XTtcclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDplIDmr4Hlrp7kvovvvIzlrp7kvovplIDmr4HlkI7ml6Dms5Xlho3ooqvkvb/nlKjjgIJcclxuICAgICAgICAqIEBtZW1iZXIgZmlzaFRvcG9CcG1uXHJcbiAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R8c3RyaW5nfSBjaGFydCBmaXNoVG9wb0JwbW7lrp7kvosg5oiWIGZpc2hUb3BvQnBtbueahGlkXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvQnBtbi5kaXNwb3NlID0gZnVuY3Rpb24oY2hhcnQpIHtcclxuICAgICAgICAgICB2YXIgdG9wbztcclxuICAgICAgICAgICBpZiAoenJVdGlsLmlzRG9tKGNoYXJ0KSkge1xyXG4gICAgICAgICAgICAgICB0b3BvID0gZmlzaFRvcG9CcG1uLmdldEluc3RhbmNlQnlEb20oY2hhcnQpO1xyXG4gICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNoYXJ0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICB0b3BvID0gaW5zdGFuY2VzW2NoYXJ0XTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgaWYgKCh0b3BvIGluc3RhbmNlb2YgZmlzaFRvcG9CcG1uKSAmJiAhdG9wby5pc0Rpc3Bvc2VkKCkpIHtcclxuICAgICAgICAgICAgICAgdG9wby5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfTtcclxuICAgICAgIC8v5pq06Zyy5Ye65Y6755qE57G7IOaWueS+v+eUqOaIt+aJqeWxleWbvuWFg1xyXG4gICAgICAgZmlzaFRvcG9CcG1uLkJwbW4gPSBCcG1uO1xyXG4gICAgICAgZmlzaFRvcG9CcG1uLkJQTU5Ob2RlID0gQlBNTk5vZGU7XHJcbiAgICAgICBmaXNoVG9wb0JwbW4uZ3JhcGhpYyA9IGdyYXBoaWM7XHJcbiAgICAgICBmaXNoVG9wb0JwbW4uQm91bmRpbmdSZWN0ID0gQm91bmRpbmdSZWN0O1xyXG4gICAgICAgZmlzaFRvcG9CcG1uLkJQTU5Nb2RlbCA9IEJQTU5Nb2RlbDtcclxuXHJcbiAgICAgICBmaXNoVG9wb0JwbW4udXRpbCA9IHt9O1xyXG4gICAgICAgenJVdGlsLmVhY2goW1xyXG4gICAgICAgICAgICAgICAnbWFwJywgJ2VhY2gnLCAnZmlsdGVyJywgJ2luZGV4T2YnLCAnaW5oZXJpdHMnLFxyXG4gICAgICAgICAgICAgICAncmVkdWNlJywgJ2ZpbHRlcicsICdiaW5kJywgJ2N1cnJ5JywgJ2lzQXJyYXknLFxyXG4gICAgICAgICAgICAgICAnaXNTdHJpbmcnLCAnaXNPYmplY3QnLCAnaXNGdW5jdGlvbicsICdleHRlbmQnXHJcbiAgICAgICAgICAgXSxcclxuICAgICAgICAgICBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgICAgIGZpc2hUb3BvQnBtbi51dGlsW25hbWVdID0genJVdGlsW25hbWVdO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICk7XHJcbiAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZpc2hUb3BvQnBtbjtcclxuICAgXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9GaXNoVG9wb0JwbW4uanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIHZhciBwYXRoVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvcGF0aCcpO1xyXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcclxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoJyk7XHJcbiAgICB2YXIgY29sb3JUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvdG9vbC9jb2xvcicpO1xyXG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4Jyk7XHJcbiAgICB2YXIgdmVjdG9yID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcclxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQnKTtcclxuICAgIHZhciBEcmFnZ2FibGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUnKTtcclxuXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHt9O1xyXG4gICAgZ3JhcGhpYy5VdGlsID0genJVdGlsO1xyXG4gICAgZ3JhcGhpYy5Hcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xyXG5cclxuICAgIGdyYXBoaWMuSW1hZ2UgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5UZXh0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy50ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xyXG5cclxuICAgIGdyYXBoaWMuQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUnKTtcclxuXHJcbiAgICBncmFwaGljLlNlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5SaW5nID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Qb2x5Z29uID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Qb2x5bGluZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUnKTtcclxuXHJcbiAgICBncmFwaGljLlJlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QnKTtcclxuXHJcbiAgICBncmFwaGljLkxpbmUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUnKTtcclxuXHJcbiAgICBncmFwaGljLkJlemllckN1cnZlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZScpO1xyXG5cclxuICAgIGdyYXBoaWMuQXJjID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMnKTtcclxuXHJcbiAgICBncmFwaGljLkxpbmVhckdyYWRpZW50ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudCcpO1xyXG5cclxuICAgIGdyYXBoaWMuUmFkaWFsR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Cb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xyXG4gICAgZ3JhcGhpYy5TdGF0ZXMgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9TdGF0ZXMuanNcIik7XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCBzaGFwZSB3aXRoIHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5leHRlbmRTaGFwZSA9IGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIFBhdGguZXh0ZW5kKG9wdHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCBwYXRoXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuZXh0ZW5kUGF0aCA9IGZ1bmN0aW9uIChwYXRoRGF0YSwgb3B0cykge1xyXG4gICAgICAgIHJldHVybiBwYXRoVG9vbC5leHRlbmRGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBwYXRoIGVsZW1lbnQgZnJvbSBwYXRoIGRhdGEgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aERhdGFcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xheW91dD1jb3Zlcl0gJ2NlbnRlcicgb3IgJ2NvdmVyJ1xyXG4gICAgICovXHJcbiAgICBncmFwaGljLm1ha2VQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBvcHRzLCByZWN0LCBsYXlvdXQpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IHBhdGhUb29sLmNyZWF0ZUZyb21TdHJpbmcocGF0aERhdGEsIG9wdHMpO1xyXG4gICAgICAgIERyYWdnYWJsZS5jYWxsKHBhdGgpO1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIGlmIChyZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhc3BlY3QgPSBib3VuZGluZ1JlY3Qud2lkdGggLyBib3VuZGluZ1JlY3QuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCByZWN0IHRvIGNlbnRlciwga2VlcCB3aWR0aCAvIGhlaWdodCByYXRpby5cclxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3QuaGVpZ2h0ICogYXNwZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodDtcclxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA8PSByZWN0LndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHZhciBjeSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMjtcclxuXHJcbiAgICAgICAgICAgICAgICByZWN0LnggPSBjeCAtIHdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHJlY3QueSA9IGN5IC0gaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIHJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVBhdGgocGF0aCwgcmVjdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB6clV0aWwuaW5oZXJpdHMocGF0aCwgRHJhZ2dhYmxlKTtcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH07XHJcblxyXG4gICAgZ3JhcGhpYy5tZXJnZVBhdGggPSBwYXRoVG9vbC5tZXJnZVBhdGg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemUgYSBwYXRoIHRvIGZpdCB0aGUgcmVjdFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IHBhdGhcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMucmVzaXplUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCByZWN0KSB7XHJcbiAgICAgICAgaWYgKCFwYXRoLmFwcGx5VHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBwYXRoUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcblxyXG4gICAgICAgIHZhciBtID0gcGF0aFJlY3QuY2FsY3VsYXRlVHJhbnNmb3JtKHJlY3QpO1xyXG5cclxuICAgICAgICBwYXRoLmFwcGx5VHJhbnNmb3JtKG0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBsaW5lIGZvciBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc2hhcGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngxXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55MV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueDJdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnkyXVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zdHlsZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc3R5bGUubGluZVdpZHRoXVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBNb2RpZmllZCBwYXJhbVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lID0gZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgdmFyIHN1YlBpeGVsT3B0aW1pemUgPSBncmFwaGljLnN1YlBpeGVsT3B0aW1pemU7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gcGFyYW0uc2hhcGU7XHJcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHBhcmFtLnN0eWxlLmxpbmVXaWR0aDtcclxuXHJcbiAgICAgICAgaWYgKHJvdW5kKHNoYXBlLngxICogMikgPT09IHJvdW5kKHNoYXBlLngyICogMikpIHtcclxuICAgICAgICAgICAgc2hhcGUueDEgPSBzaGFwZS54MiA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueDEsIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb3VuZChzaGFwZS55MSAqIDIpID09PSByb3VuZChzaGFwZS55MiAqIDIpKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnkxID0gc2hhcGUueTIgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLnkxLCBsaW5lV2lkdGgsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyYW07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIHJlY3QgZm9yIGNhbnZhc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zaGFwZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueF1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUud2lkdGhdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLmhlaWdodF1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc3R5bGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnN0eWxlLmxpbmVXaWR0aF1cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdCA9IGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgIHZhciBzdWJQaXhlbE9wdGltaXplID0gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplO1xyXG4gICAgICAgIHZhciBzaGFwZSA9IHBhcmFtLnNoYXBlO1xyXG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XHJcbiAgICAgICAgdmFyIG9yaWdpblggPSBzaGFwZS54O1xyXG4gICAgICAgIHZhciBvcmlnaW5ZID0gc2hhcGUueTtcclxuICAgICAgICB2YXIgb3JpZ2luV2lkdGggPSBzaGFwZS53aWR0aDtcclxuICAgICAgICB2YXIgb3JpZ2luSGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgIHNoYXBlLnggPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLngsIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgc2hhcGUueSA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueSwgbGluZVdpZHRoLCB0cnVlKTtcclxuICAgICAgICBzaGFwZS53aWR0aCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICBzdWJQaXhlbE9wdGltaXplKG9yaWdpblggKyBvcmlnaW5XaWR0aCwgbGluZVdpZHRoLCBmYWxzZSkgLSBzaGFwZS54LFxyXG4gICAgICAgICAgICBvcmlnaW5XaWR0aCA9PT0gMCA/IDAgOiAxXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzaGFwZS5oZWlnaHQgPSBNYXRoLm1heChcclxuICAgICAgICAgICAgc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5ZICsgb3JpZ2luSGVpZ2h0LCBsaW5lV2lkdGgsIGZhbHNlKSAtIHNoYXBlLnksXHJcbiAgICAgICAgICAgIG9yaWdpbkhlaWdodCA9PT0gMCA/IDAgOiAxXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gcGFyYW07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIGZvciBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gQ29vcmRpbmF0ZSwgc3VjaCBhcyB4LCB5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIFNob3VsZCBiZSBub25uZWdhdGl2ZSBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcG9zaXRpdmVPck5lZ2F0aXZlIERlZmF1bHQgZmFsc2UgKG5lZ2F0aXZlKS5cclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gT3B0aW1pemVkIHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemUgPSBmdW5jdGlvbiAocG9zaXRpb24sIGxpbmVXaWR0aCwgcG9zaXRpdmVPck5lZ2F0aXZlKSB7XHJcbiAgICAgICAgLy8gQXNzdXJlIHRoYXQgKHBvc2l0aW9uICsgbGluZVdpZHRoIC8gMikgaXMgbmVhciBpbnRlZ2VyIGVkZ2UsXHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGxpbmUgd2lsbCBiZSBmdXp6eSBpbiBjYW52YXMuXHJcbiAgICAgICAgdmFyIGRvdWJsZWRQb3NpdGlvbiA9IHJvdW5kKHBvc2l0aW9uICogMik7XHJcbiAgICAgICAgcmV0dXJuIChkb3VibGVkUG9zaXRpb24gKyByb3VuZChsaW5lV2lkdGgpKSAlIDIgPT09IDBcclxuICAgICAgICAgICAgPyBkb3VibGVkUG9zaXRpb24gLyAyXHJcbiAgICAgICAgICAgIDogKGRvdWJsZWRQb3NpdGlvbiArIChwb3NpdGl2ZU9yTmVnYXRpdmUgPyAxIDogLTEpKSAvIDI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZG9TaW5nbGVFbnRlckhvdmVyKGVsKSB7XHJcbiAgICAgICAgaWYgKGVsLl9faXNIb3Zlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbC5fX2hvdmVyU3RsRGlydHkpIHtcclxuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IGVsLnN0eWxlLnN0cm9rZTtcclxuICAgICAgICAgICAgdmFyIGZpbGwgPSBlbC5zdHlsZS5maWxsO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGhvdmVyU3R5bGUgb24gbW91c2VvdmVyXHJcbiAgICAgICAgICAgIHZhciBob3ZlclN0eWxlID0gZWwuX19ob3ZlclN0bDtcclxuICAgICAgICAgICAgdmFyIGxpZnQgPSBjb2xvclRvb2wubGlmdDtcclxuICAgICAgICAgICAgaG92ZXJTdHlsZS5maWxsID0gaG92ZXJTdHlsZS5maWxsXHJcbiAgICAgICAgICAgICAgICB8fCAoZmlsbCAmJiAoZmlsbCBpbnN0YW5jZW9mIEdyYWRpZW50ID8gZmlsbCA6IGxpZnQoZmlsbCwgLTAuMSkpKTtcclxuICAgICAgICAgICAgaG92ZXJTdHlsZS5zdHJva2UgPSBob3ZlclN0eWxlLnN0cm9rZVxyXG4gICAgICAgICAgICAgICAgfHwgKHN0cm9rZSAmJiAoc3Ryb2tlIGluc3RhbmNlb2YgR3JhZGllbnQgPyBzdHJva2UgOiBsaWZ0KHN0cm9rZSwgLTAuMSkpKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBub3JtYWxTdHlsZSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGhvdmVyU3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChob3ZlclN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsU3R5bGVbbmFtZV0gPSBlbC5zdHlsZVtuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWwuX19ub3JtYWxTdGwgPSBub3JtYWxTdHlsZTtcclxuXHJcbiAgICAgICAgICAgIGVsLl9faG92ZXJTdGxEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbC5zZXRTdHlsZShlbC5fX2hvdmVyU3RsKTtcclxuICAgICAgICBlbC56MiArPSAxO1xyXG5cclxuICAgICAgICBlbC5fX2lzSG92ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRvU2luZ2xlTGVhdmVIb3ZlcihlbCkge1xyXG4gICAgICAgIGlmICghZWwuX19pc0hvdmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBub3JtYWxTdGwgPSBlbC5fX25vcm1hbFN0bDtcclxuICAgICAgICBub3JtYWxTdGwgJiYgZWwuc2V0U3R5bGUobm9ybWFsU3RsKTtcclxuICAgICAgICBlbC56MiAtPSAxO1xyXG5cclxuICAgICAgICBlbC5fX2lzSG92ZXIgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkb0VudGVySG92ZXIoZWwpIHtcclxuICAgICAgICAoZWwudHlwZSA9PT0gJ2dyb3VwJyB8fCBlbC50eXBlID09PSAnR3JvdXBOb2RlJylcclxuICAgICAgICAgICAgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9TaW5nbGVFbnRlckhvdmVyKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgOiBkb1NpbmdsZUVudGVySG92ZXIoZWwpO1xyXG4gICAgfVxyXG4gICAgZ3JhcGhpYy5kb0VudGVySG92ZXIgPSBkb0VudGVySG92ZXI7XHJcbiAgICBmdW5jdGlvbiBkb0xlYXZlSG92ZXIoZWwpIHtcclxuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXHJcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvU2luZ2xlTGVhdmVIb3ZlcihjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKTtcclxuICAgIH1cclxuICAgIGdyYXBoaWMuZG9MZWF2ZUhvdmVyID0gZG9MZWF2ZUhvdmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0bCkge1xyXG4gICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIHNlcGNpZmllZCBob3ZlclN0eWxlLCB0aGVuIHVzZSBpdCBpbnN0ZWFkIG9mIGdpdmVuIGhvdmVyU3R5bGVcclxuICAgICAgICAvLyBPZnRlbiB1c2VkIHdoZW4gaXRlbSBncm91cCBoYXMgYSBsYWJlbCBlbGVtZW50IGFuZCBpdCdzIGhvdmVyU3R5bGUgaXMgZGlmZmVyZW50XHJcbiAgICAgICAgZWwuX19ob3ZlclN0bCA9IGVsLmhvdmVyU3R5bGUgfHwgaG92ZXJTdGwgfHwge307XHJcbiAgICAgICAgZWwuX19ob3ZlclN0bERpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdyYXBoaWMuc2V0RWxlbWVudEhvdmVyU3RsID0gc2V0RWxlbWVudEhvdmVyU3RsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdmVyKCkge1xyXG4gICAgICAgIC8vIE9ubHkgaWYgZWxlbWVudCBpcyBub3QgaW4gZW1waGFzaXMgc3RhdHVzXHJcbiAgICAgICAgIXRoaXMuX19pc0VtcGhhc2lzICYmIGRvRW50ZXJIb3Zlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbkVsZW1lbnRNb3VzZU91dCgpIHtcclxuICAgICAgICAvLyBPbmx5IGlmIGVsZW1lbnQgaXMgbm90IGluIGVtcGhhc2lzIHN0YXR1c1xyXG4gICAgICAgICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0xlYXZlSG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZW50ZXJFbXBoYXNpcygpIHtcclxuICAgICAgICB0aGlzLl9faXNFbXBoYXNpcyA9IHRydWU7XHJcbiAgICAgICAgZG9FbnRlckhvdmVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGxlYXZlRW1waGFzaXMoKSB7XHJcbiAgICAgICAgdGhpcy5fX2lzRW1waGFzaXMgPSBmYWxzZTtcclxuICAgICAgICBkb0xlYXZlSG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgaG92ZXIgc3R5bGUgb2YgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtob3ZlclN0eWxlXVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnNldEhvdmVyU3R5bGUgPSBmdW5jdGlvbiAoZWwsIGhvdmVyU3R5bGUpIHtcclxuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXHJcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRIb3ZlclN0bChjaGlsZCwgaG92ZXJTdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0eWxlKTtcclxuICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgYm91bmQgaGFuZGxlcnNcclxuICAgICAgICBlbC5vbignbW91c2VvdmVyJywgb25FbGVtZW50TW91c2VPdmVyKVxyXG4gICAgICAgICAgLm9uKCdtb3VzZW91dCcsIG9uRWxlbWVudE1vdXNlT3V0KTtcclxuXHJcbiAgICAgICAgLy8gRW1waGFzaXMsIG5vcm1hbCBjYW4gYmUgdHJpZ2dlcmVkIG1hbnVhbGx5XHJcbiAgICAgICAgZWwub24oJ2VtcGhhc2lzJywgZW50ZXJFbXBoYXNpcylcclxuICAgICAgICAgIC5vbignbm9ybWFsJywgbGVhdmVFbXBoYXNpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChlbC5fX25vcm1hbFN0bCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5fX25vcm1hbFN0bC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLl9fbm9ybWFsU3RsW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGV4dCBvcHRpb24gaW4gdGhlIHN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBsYWJlbE1vZGVsXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHRTdHlsZSwgbGFiZWxNb2RlbCwgY29sb3IpIHtcclxuICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygncG9zaXRpb24nKSB8fCAnaW5zaWRlJztcclxuICAgICAgICB2YXIgbGFiZWxDb2xvciA9IGxhYmVsUG9zaXRpb24uaW5kZXhPZignaW5zaWRlJykgPj0gMCA/ICd3aGl0ZScgOiBjb2xvcjtcclxuICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBsYWJlbE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcclxuICAgICAgICB6clV0aWwuZXh0ZW5kKHRleHRTdHlsZSwge1xyXG4gICAgICAgICAgICB0ZXh0RGlzdGFuY2U6IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnZGlzdGFuY2UnKSB8fCA1LFxyXG4gICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxyXG4gICAgICAgICAgICB0ZXh0UG9zaXRpb246IGxhYmVsUG9zaXRpb24sXHJcbiAgICAgICAgICAgIHRleHRGaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBsYWJlbENvbG9yXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGFuaW1hdGVPclNldFByb3BzKGlzVXBkYXRlLCBlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgY2IpIHtcclxuICAgICAgICB2YXIgcG9zdGZpeCA9IGlzVXBkYXRlID8gJ1VwZGF0ZScgOiAnJztcclxuICAgICAgICB2YXIgZHVyYXRpb24gPSBhbmltYXRhYmxlTW9kZWxcclxuICAgICAgICAgICAgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkR1cmF0aW9uJyArIHBvc3RmaXgpO1xyXG4gICAgICAgIHZhciBhbmltYXRpb25FYXNpbmcgPSBhbmltYXRhYmxlTW9kZWxcclxuICAgICAgICAgICAgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkVhc2luZycgKyBwb3N0Zml4KTtcclxuXHJcbiAgICAgICAgYW5pbWF0YWJsZU1vZGVsICYmIGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb24nKVxyXG4gICAgICAgICAgICA/IGVsLmFuaW1hdGVUbyhwcm9wcywgZHVyYXRpb24sIGFuaW1hdGlvbkVhc2luZywgY2IpXHJcbiAgICAgICAgICAgIDogKGVsLmF0dHIocHJvcHMpLCBjYiAmJiBjYigpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy51cGRhdGVQcm9wcyA9IHpyVXRpbC5jdXJyeShhbmltYXRlT3JTZXRQcm9wcywgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0IGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5pbml0UHJvcHMgPSB6clV0aWwuY3VycnkoYW5pbWF0ZU9yU2V0UHJvcHMsIGZhbHNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0cmFuc2Zvcm0gbWF0cml4IG9mIHRhcmdldCAocGFyYW0gdGFyZ2V0KSxcclxuICAgICAqIGluIGNvb3JkaW5hdGUgb2YgaXRzIGFuY2VzdG9yIChwYXJhbSBhbmNlc3RvcilcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9IHRhcmdldFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSBhbmNlc3RvclxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIGFuY2VzdG9yKSB7XHJcbiAgICAgICAgdmFyIG1hdCA9IG1hdHJpeC5pZGVudGl0eShbXSk7XHJcblxyXG4gICAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBhbmNlc3Rvcikge1xyXG4gICAgICAgICAgICBtYXRyaXgubXVsKG1hdCwgdGFyZ2V0LmdldExvY2FsVHJhbnNmb3JtKCksIG1hdCk7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IHRyYW5zZm9ybSB0byBhbiB2ZXJ0ZXguXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZXJ0ZXggW3gsIHldXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxyXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFt4LCB5XVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKHZlcnRleCwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcclxuICAgICAgICBpZiAoaW52ZXJ0KSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IG1hdHJpeC5pbnZlcnQoW10sIHRyYW5zZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0oW10sIHZlcnRleCwgdHJhbnNmb3JtKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUcmFuc2Zvcm1lZCBkaXJlY3Rpb24uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMudHJhbnNmb3JtRGlyZWN0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcclxuXHJcbiAgICAgICAgLy8gUGljayBhIGJhc2UsIGVuc3VyZSB0aGF0IHRyYW5zZm9ybSByZXN1bHQgd2lsbCBub3QgYmUgKDAsIDApLlxyXG4gICAgICAgIHZhciBoQmFzZSA9ICh0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVswXSA9PT0gMClcclxuICAgICAgICAgICAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVswXSk7XHJcbiAgICAgICAgdmFyIHZCYXNlID0gKHRyYW5zZm9ybVs0XSA9PT0gMCB8fCB0cmFuc2Zvcm1bNV0gPT09IDAgfHwgdHJhbnNmb3JtWzJdID09PSAwKVxyXG4gICAgICAgICAgICA/IDEgOiBNYXRoLmFicygyICogdHJhbnNmb3JtWzRdIC8gdHJhbnNmb3JtWzJdKTtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRleCA9IFtcclxuICAgICAgICAgICAgZGlyZWN0aW9uID09PSAnbGVmdCcgPyAtaEJhc2UgOiBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyBoQmFzZSA6IDAsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3RvcCcgPyAtdkJhc2UgOiBkaXJlY3Rpb24gPT09ICdib3R0b20nID8gdkJhc2UgOiAwXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgdmVydGV4ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSh2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJ0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZlcnRleFswXSkgPiBNYXRoLmFicyh2ZXJ0ZXhbMV0pXHJcbiAgICAgICAgICAgID8gKHZlcnRleFswXSA+IDAgPyAncmlnaHQnIDogJ2xlZnQnKVxyXG4gICAgICAgICAgICA6ICh2ZXJ0ZXhbMV0gPiAwID8gJ2JvdHRvbScgOiAndG9wJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gZ3JhcGhpYztcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvdXRpbFxuICovXG4vLyDnlKjkuo7lpITnkIZtZXJnZeaXtuaXoOazlemBjeWOhkRhdGXnrYnlr7nosaHnmoTpl67pophcbnZhciBCVUlMVElOX09CSkVDVCA9IHtcbiAgJ1tvYmplY3QgRnVuY3Rpb25dJzogMSxcbiAgJ1tvYmplY3QgUmVnRXhwXSc6IDEsXG4gICdbb2JqZWN0IERhdGVdJzogMSxcbiAgJ1tvYmplY3QgRXJyb3JdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nOiAxLFxuICAvLyBGb3Igbm9kZS1jYW52YXNcbiAgJ1tvYmplY3QgSW1hZ2VdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzXSc6IDFcbn07XG52YXIgVFlQRURfQVJSQVkgPSB7XG4gICdbb2JqZWN0IEludDhBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50OEFycmF5XSc6IDEsXG4gICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc6IDEsXG4gICdbb2JqZWN0IEludDE2QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgVWludDE2QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgSW50MzJBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50MzJBcnJheV0nOiAxLFxuICAnW29iamVjdCBGbG9hdDMyQXJyYXldJzogMSxcbiAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc6IDFcbn07XG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgbmF0aXZlRm9yRWFjaCA9IGFycmF5UHJvdG8uZm9yRWFjaDtcbnZhciBuYXRpdmVGaWx0ZXIgPSBhcnJheVByb3RvLmZpbHRlcjtcbnZhciBuYXRpdmVTbGljZSA9IGFycmF5UHJvdG8uc2xpY2U7XG52YXIgbmF0aXZlTWFwID0gYXJyYXlQcm90by5tYXA7XG52YXIgbmF0aXZlUmVkdWNlID0gYXJyYXlQcm90by5yZWR1Y2U7IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cbnZhciBtZXRob2RzID0ge307XG5cbmZ1bmN0aW9uICRvdmVycmlkZShuYW1lLCBmbikge1xuICBtZXRob2RzW25hbWVdID0gZm47XG59XG4vKipcbiAqIFRob3NlIGRhdGEgdHlwZXMgY2FuIGJlIGNsb25lZDpcbiAqICAgICBQbGFpbiBvYmplY3QsIEFycmF5LCBUeXBlZEFycmF5LCBudW1iZXIsIHN0cmluZywgbnVsbCwgdW5kZWZpbmVkLlxuICogVGhvc2UgZGF0YSB0eXBlcyB3aWxsIGJlIGFzc2dpbmVkIHVzaW5nIHRoZSBvcmdpbmFsIGRhdGE6XG4gKiAgICAgQlVJTFRJTl9PQkpFQ1RcbiAqIEluc3RhbmNlIG9mIHVzZXIgZGVmaW5lZCBjbGFzcyB3aWxsIGJlIGNsb25lZCB0byBhIHBsYWluIG9iamVjdCwgd2l0aG91dFxuICogcHJvcGVydGllcyBpbiBwcm90b3R5cGUuXG4gKiBPdGhlciBkYXRhIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQgKG5vdCBzdXJlIHdoYXQgd2lsbCBoYXBwZW4pLlxuICpcbiAqIENhdXRpb246IGRvIG5vdCBzdXBwb3J0IGNsb25lIERhdGUsIGZvciBwZXJmb3JtYW5jZSBjb25zaWRlcmF0aW9uLlxuICogKFRoZXJlIG1pZ2h0IGJlIGEgbGFyZ2UgbnVtYmVyIG9mIGRhdGUgaW4gYHNlcmllcy5kYXRhYCkuXG4gKiBTbyBkYXRlIHNob3VsZCBub3QgYmUgbW9kaWZpZWQgaW4gYW5kIG91dCBvZiBlY2hhcnRzLlxuICpcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAcmV0dXJuIHsqfSBuZXdcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKHNvdXJjZSkge1xuICBpZiAoc291cmNlID09IG51bGwgfHwgdHlwZW9mIHNvdXJjZSAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gc291cmNlO1xuICB2YXIgdHlwZVN0ciA9IG9ialRvU3RyaW5nLmNhbGwoc291cmNlKTtcblxuICBpZiAodHlwZVN0ciA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gY2xvbmUoc291cmNlW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoVFlQRURfQVJSQVlbdHlwZVN0cl0pIHtcbiAgICB2YXIgQ3RvciA9IHNvdXJjZS5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChzb3VyY2UuY29uc3RydWN0b3IuZnJvbSkge1xuICAgICAgcmVzdWx0ID0gQ3Rvci5mcm9tKHNvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBDdG9yKHNvdXJjZS5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IGNsb25lKHNvdXJjZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFCVUlMVElOX09CSkVDVFt0eXBlU3RyXSAmJiAhaXNQcmltaXRpdmUoc291cmNlKSAmJiAhaXNEb20oc291cmNlKSkge1xuICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY2xvbmUoc291cmNlW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQHBhcmFtIHtib29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXVxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkge1xuICAvLyBXZSBzaG91bGQgZXNjYXBzZSB0aGF0IHNvdXJjZSBpcyBzdHJpbmdcbiAgLy8gYW5kIGVudGVyIGZvciAuLi4gaW4gLi4uXG4gIGlmICghaXNPYmplY3Qoc291cmNlKSB8fCAhaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiBvdmVyd3JpdGUgPyBjbG9uZShzb3VyY2UpIDogdGFyZ2V0O1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFyIHRhcmdldFByb3AgPSB0YXJnZXRba2V5XTtcbiAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XG5cbiAgICAgIGlmIChpc09iamVjdChzb3VyY2VQcm9wKSAmJiBpc09iamVjdCh0YXJnZXRQcm9wKSAmJiAhaXNBcnJheShzb3VyY2VQcm9wKSAmJiAhaXNBcnJheSh0YXJnZXRQcm9wKSAmJiAhaXNEb20oc291cmNlUHJvcCkgJiYgIWlzRG9tKHRhcmdldFByb3ApICYmICFpc0J1aWx0SW5PYmplY3Qoc291cmNlUHJvcCkgJiYgIWlzQnVpbHRJbk9iamVjdCh0YXJnZXRQcm9wKSAmJiAhaXNQcmltaXRpdmUoc291cmNlUHJvcCkgJiYgIWlzUHJpbWl0aXZlKHRhcmdldFByb3ApKSB7XG4gICAgICAgIC8vIOWmguaenOmcgOimgemAkuW9kuimhueblu+8jOWwsemAkuW9kuiwg+eUqG1lcmdlXG4gICAgICAgIG1lcmdlKHRhcmdldFByb3AsIHNvdXJjZVByb3AsIG92ZXJ3cml0ZSk7XG4gICAgICB9IGVsc2UgaWYgKG92ZXJ3cml0ZSB8fCAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIC8vIOWQpuWImeWPquWkhOeQhm92ZXJ3cml0ZeS4unRydWXvvIzmiJbogIXlnKjnm67moIflr7nosaHkuK3msqHmnInmraTlsZ7mgKfnmoTmg4XlhrVcbiAgICAgICAgLy8gTk9URe+8jOWcqCB0YXJnZXRba2V5XSDkuI3lrZjlnKjnmoTml7blgJnkuZ/mmK/nm7TmjqXopobnm5ZcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0QW5kU291cmNlcyBUaGUgZmlyc3QgaXRlbSBpcyB0YXJnZXQsIGFuZCB0aGUgcmVzdHMgYXJlIHNvdXJjZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAqIEByZXR1cm4geyp9IHRhcmdldFxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2VBbGwodGFyZ2V0QW5kU291cmNlcywgb3ZlcndyaXRlKSB7XG4gIHZhciByZXN1bHQgPSB0YXJnZXRBbmRTb3VyY2VzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0YXJnZXRBbmRTb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ID0gbWVyZ2UocmVzdWx0LCB0YXJnZXRBbmRTb3VyY2VzW2ldLCBvdmVyd3JpdGUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHBhcmFtIHsqfSB0YXJnZXRcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuLyoqXG4gKiBAcGFyYW0geyp9IHRhcmdldFxuICogQHBhcmFtIHsqfSBzb3VyY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJsYXk9ZmFsc2VdXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuXG5mdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChvdmVybGF5ID8gc291cmNlW2tleV0gIT0gbnVsbCA6IHRhcmdldFtrZXldID09IG51bGwpKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBjcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBtZXRob2RzLmNyZWF0ZUNhbnZhcygpO1xufTtcblxubWV0aG9kcy5jcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbn07IC8vIEZJWE1FXG5cblxudmFyIF9jdHg7XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGlmICghX2N0eCkge1xuICAgIC8vIFVzZSB1dGlsLmNyZWF0ZUNhbnZhcyBpbnN0ZWFkIG9mIGNyZWF0ZUNhbnZhc1xuICAgIC8vIGJlY2F1c2UgY3JlYXRlQ2FudmFzIG1heSBiZSBvdmVyd3JpdHRlbiBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRcbiAgICBfY3R4ID0gY3JlYXRlQ2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgfVxuXG4gIHJldHVybiBfY3R4O1xufVxuLyoqXG4gKiDmn6Xor6LmlbDnu4TkuK3lhYPntKDnmoRpbmRleFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgaWYgKGFycmF5KSB7XG4gICAgaWYgKGFycmF5LmluZGV4T2YpIHtcbiAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiDmnoTpgKDnsbvnu6fmib/lhbPns7tcbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGF6eiDmupDnsbtcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VDbGF6eiDln7rnsbtcbiAqL1xuXG5cbmZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcbiAgdmFyIGNsYXp6UHJvdG90eXBlID0gY2xhenoucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIEYoKSB7fVxuXG4gIEYucHJvdG90eXBlID0gYmFzZUNsYXp6LnByb3RvdHlwZTtcbiAgY2xhenoucHJvdG90eXBlID0gbmV3IEYoKTtcblxuICBmb3IgKHZhciBwcm9wIGluIGNsYXp6UHJvdG90eXBlKSB7XG4gICAgY2xhenoucHJvdG90eXBlW3Byb3BdID0gY2xhenpQcm90b3R5cGVbcHJvcF07XG4gIH1cblxuICBjbGF6ei5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjbGF6ejtcbiAgY2xhenouc3VwZXJDbGFzcyA9IGJhc2VDbGF6ejtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHNvcmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJsYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIG1peGluKHRhcmdldCwgc291cmNlLCBvdmVybGF5KSB7XG4gIHRhcmdldCA9ICdwcm90b3R5cGUnIGluIHRhcmdldCA/IHRhcmdldC5wcm90b3R5cGUgOiB0YXJnZXQ7XG4gIHNvdXJjZSA9ICdwcm90b3R5cGUnIGluIHNvdXJjZSA/IHNvdXJjZS5wcm90b3R5cGUgOiBzb3VyY2U7XG4gIGRlZmF1bHRzKHRhcmdldCwgc291cmNlLCBvdmVybGF5KTtcbn1cbi8qKlxuICogQ29uc2lkZXIgdHlwZWQgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IGRhdGFcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKGRhdGEpIHtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBkYXRhLmxlbmd0aCA9PSAnbnVtYmVyJztcbn1cbi8qKlxuICog5pWw57uE5oiW5a+56LGh6YGN5Y6GXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqL1xuXG5cbmZ1bmN0aW9uIGVhY2gob2JqLCBjYiwgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5mb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgb2JqLmZvckVhY2goY2IsIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIOaVsOe7hOaYoOWwhFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gbWFwKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmoubWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkge1xuICAgIHJldHVybiBvYmoubWFwKGNiLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gW21lbW9dXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiByZWR1Y2Uob2JqLCBjYiwgbWVtbywgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5yZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgcmV0dXJuIG9iai5yZWR1Y2UoY2IsIG1lbW8sIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1lbW8gPSBjYi5jYWxsKGNvbnRleHQsIG1lbW8sIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfVxufVxuLyoqXG4gKiDmlbDnu4Tov4fmu6RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbHRlcihvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLmZpbHRlciAmJiBvYmouZmlsdGVyID09PSBuYXRpdmVGaWx0ZXIpIHtcbiAgICByZXR1cm4gb2JqLmZpbHRlcihjYiwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG9ialtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXG4gKiDmlbDnu4Tpobnmn6Xmib5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cblxuZnVuY3Rpb24gZmluZChvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICByZXR1cm4gb2JqW2ldO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cblxuZnVuY3Rpb24gYmluZChmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9O1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1cnJ5KGZ1bmMpIHtcbiAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncy5jb25jYXQobmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH07XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8ICEhdmFsdWUgJiYgdHlwZSA9PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQnVpbHRJbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gISFCVUlMVElOX09CSkVDVFtvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0RvbSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS5vd25lckRvY3VtZW50ID09PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogV2hldGhlciBpcyBleGFjdGx5IE5hTi4gTm90aWNlIGlzTmFOKCdhJykgcmV0dXJucyB0cnVlLlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGVxTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG4vKipcbiAqIElmIHZhbHVlMSBpcyBub3QgbnVsbCwgdGhlbiByZXR1cm4gdmFsdWUxLCBvdGhlcndpc2UganVkZ2V0IHJlc3Qgb2YgdmFsdWVzLlxuICogTG93IHBlcmZvcm1hbmNlLlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHJldHVybiB7Kn0gRmluYWwgdmFsdWVcbiAqL1xuXG5cbmZ1bmN0aW9uIHJldHJpZXZlKHZhbHVlcykge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyaWV2ZTIodmFsdWUwLCB2YWx1ZTEpIHtcbiAgcmV0dXJuIHZhbHVlMCAhPSBudWxsID8gdmFsdWUwIDogdmFsdWUxO1xufVxuXG5mdW5jdGlvbiByZXRyaWV2ZTModmFsdWUwLCB2YWx1ZTEsIHZhbHVlMikge1xuICByZXR1cm4gdmFsdWUwICE9IG51bGwgPyB2YWx1ZTAgOiB2YWx1ZTEgIT0gbnVsbCA/IHZhbHVlMSA6IHZhbHVlMjtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGVuZEluZGV4XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIHNsaWNlKCkge1xuICByZXR1cm4gRnVuY3Rpb24uY2FsbC5hcHBseShuYXRpdmVTbGljZSwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogTm9ybWFsaXplIGNzcyBsaWtlZCBhcnJheSBjb25maWd1cmF0aW9uXG4gKiBlLmcuXG4gKiAgMyA9PiBbMywgMywgMywgM11cbiAqICBbNCwgMl0gPT4gWzQsIDIsIDQsIDJdXG4gKiAgWzQsIDMsIDJdID0+IFs0LCAzLCAyLCAzXVxuICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHZhbFxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVDc3NBcnJheSh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgdmFyIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIHZlcnRpY2FsIHwgaG9yaXpvbnRhbFxuICAgIHJldHVybiBbdmFsWzBdLCB2YWxbMV0sIHZhbFswXSwgdmFsWzFdXTtcbiAgfSBlbHNlIGlmIChsZW4gPT09IDMpIHtcbiAgICAvLyB0b3AgfCBob3Jpem9udGFsIHwgYm90dG9tXG4gICAgcmV0dXJuIFt2YWxbMF0sIHZhbFsxXSwgdmFsWzJdLCB2YWxbMV1dO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBwcmltaXRpdmVLZXkgPSAnX19lY19wcmltaXRpdmVfXyc7XG4vKipcbiAqIFNldCBhbiBvYmplY3QgYXMgcHJpbWl0aXZlIHRvIGJlIGlnbm9yZWQgdHJhdmVyc2luZyBjaGlsZHJlbiBpbiBjbG9uZSBvciBtZXJnZVxuICovXG5cbmZ1bmN0aW9uIHNldEFzUHJpbWl0aXZlKG9iaikge1xuICBvYmpbcHJpbWl0aXZlS2V5XSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICByZXR1cm4gb2JqW3ByaW1pdGl2ZUtleV07XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPbmx5IGFwcGx5IGBvd25Qcm9wZXJ0eWAuXG4gKi9cblxuXG5mdW5jdGlvbiBIYXNoTWFwKG9iaikge1xuICBvYmogJiYgZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gIH0sIHRoaXMpO1xufSAvLyBBZGQgcHJlZml4IHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZS5cblxuXG52YXIgSEFTSF9NQVBfUFJFRklYID0gJ19lY18nO1xudmFyIEhBU0hfTUFQX1BSRUZJWF9MRU5HVEggPSA0O1xuSGFzaE1hcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBIYXNoTWFwLFxuICAvLyBEbyBub3QgcHJvdmlkZSBgaGFzYCBtZXRob2QgdG8gYXZvaWQgZGVmaW5pbmcgd2hhdCBpcyBgaGFzYC5cbiAgLy8gKFdlIHVzdWFsbHkgdHJlYXQgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcyB0aGUgc2FtZSwgZGlmZmVyZW50XG4gIC8vIGZyb20gRVM2IE1hcCkuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV0gPSB2YWx1ZTsgLy8gQ29tcGFyaW5nIHdpdGggaW52b2NhdGlvbiBjaGFpbmluZywgYHJldHVybiB2YWx1ZWAgaXMgbW9yZSBjb21tb25seVxuICAgIC8vIHVzZWQgaW4gdGhpcyBjYXNlOiBgdmFyIHNvbWVWYWwgPSBtYXAuc2V0KCdhJywgZ2VuVmFsKCkpO2BcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgLy8gQWx0aG91Z2ggdXRpbC5lYWNoIGNhbiBiZSBwZXJmb3JtZWQgb24gdGhpcyBoYXNoTWFwIGRpcmVjdGx5LCB1c2VyXG4gIC8vIHNob3VsZCBub3QgdXNlIHRoZSBleHBvc2VkIGtleXMsIHdobyBhcmUgcHJlZml4ZWQuXG4gIGVhY2g6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGNvbnRleHQgIT09IHZvaWQgMCAmJiAoY2IgPSBiaW5kKGNiLCBjb250ZXh0KSk7XG5cbiAgICBmb3IgKHZhciBwcmVmaXhlZEtleSBpbiB0aGlzKSB7XG4gICAgICB0aGlzLmhhc093blByb3BlcnR5KHByZWZpeGVkS2V5KSAmJiBjYih0aGlzW3ByZWZpeGVkS2V5XSwgcHJlZml4ZWRLZXkuc2xpY2UoSEFTSF9NQVBfUFJFRklYX0xFTkdUSCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBpZiBwZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gIHJlbW92ZUtleTogZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hNYXAob2JqKSB7XG4gIHJldHVybiBuZXcgSGFzaE1hcChvYmopO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0cy4kb3ZlcnJpZGUgPSAkb3ZlcnJpZGU7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG5leHBvcnRzLm1lcmdlQWxsID0gbWVyZ2VBbGw7XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbmV4cG9ydHMuY3JlYXRlQ2FudmFzID0gY3JlYXRlQ2FudmFzO1xuZXhwb3J0cy5nZXRDb250ZXh0ID0gZ2V0Q29udGV4dDtcbmV4cG9ydHMuaW5kZXhPZiA9IGluZGV4T2Y7XG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5leHBvcnRzLm1peGluID0gbWl4aW47XG5leHBvcnRzLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG5leHBvcnRzLmVhY2ggPSBlYWNoO1xuZXhwb3J0cy5tYXAgPSBtYXA7XG5leHBvcnRzLnJlZHVjZSA9IHJlZHVjZTtcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuZXhwb3J0cy5maW5kID0gZmluZDtcbmV4cG9ydHMuYmluZCA9IGJpbmQ7XG5leHBvcnRzLmN1cnJ5ID0gY3Vycnk7XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNCdWlsdEluT2JqZWN0ID0gaXNCdWlsdEluT2JqZWN0O1xuZXhwb3J0cy5pc0RvbSA9IGlzRG9tO1xuZXhwb3J0cy5lcU5hTiA9IGVxTmFOO1xuZXhwb3J0cy5yZXRyaWV2ZSA9IHJldHJpZXZlO1xuZXhwb3J0cy5yZXRyaWV2ZTIgPSByZXRyaWV2ZTI7XG5leHBvcnRzLnJldHJpZXZlMyA9IHJldHJpZXZlMztcbmV4cG9ydHMuc2xpY2UgPSBzbGljZTtcbmV4cG9ydHMubm9ybWFsaXplQ3NzQXJyYXkgPSBub3JtYWxpemVDc3NBcnJheTtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy5zZXRBc1ByaW1pdGl2ZSA9IHNldEFzUHJpbWl0aXZlO1xuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuZXhwb3J0cy5jcmVhdGVIYXNoTWFwID0gY3JlYXRlSGFzaE1hcDtcbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL1BhdGhcIik7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciB0cmFuc2Zvcm1QYXRoID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtUGF0aFwiKTtcblxuLy8gY29tbWFuZCBjaGFyc1xudmFyIGNjID0gWydtJywgJ00nLCAnbCcsICdMJywgJ3YnLCAnVicsICdoJywgJ0gnLCAneicsICdaJywgJ2MnLCAnQycsICdxJywgJ1EnLCAndCcsICdUJywgJ3MnLCAnUycsICdhJywgJ0EnXTtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIFBJID0gTWF0aC5QSTtcblxudmFyIHZNYWcgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xufTtcblxudmFyIHZSYXRpbyA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodk1hZyh1KSAqIHZNYWcodikpO1xufTtcblxudmFyIHZBbmdsZSA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbn07XG5cbmZ1bmN0aW9uIHByb2Nlc3NBcmMoeDEsIHkxLCB4MiwgeTIsIGZhLCBmcywgcngsIHJ5LCBwc2lEZWcsIGNtZCwgcGF0aCkge1xuICB2YXIgcHNpID0gcHNpRGVnICogKFBJIC8gMTgwLjApO1xuICB2YXIgeHAgPSBtYXRoQ29zKHBzaSkgKiAoeDEgLSB4MikgLyAyLjAgKyBtYXRoU2luKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG4gIHZhciB5cCA9IC0xICogbWF0aFNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wICsgbWF0aENvcyhwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICB2YXIgbGFtYmRhID0geHAgKiB4cCAvIChyeCAqIHJ4KSArIHlwICogeXAgLyAocnkgKiByeSk7XG5cbiAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICByeCAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgIHJ5ICo9IG1hdGhTcXJ0KGxhbWJkYSk7XG4gIH1cblxuICB2YXIgZiA9IChmYSA9PT0gZnMgPyAtMSA6IDEpICogbWF0aFNxcnQoKHJ4ICogcnggKiAocnkgKiByeSkgLSByeCAqIHJ4ICogKHlwICogeXApIC0gcnkgKiByeSAqICh4cCAqIHhwKSkgLyAocnggKiByeCAqICh5cCAqIHlwKSArIHJ5ICogcnkgKiAoeHAgKiB4cCkpKSB8fCAwO1xuICB2YXIgY3hwID0gZiAqIHJ4ICogeXAgLyByeTtcbiAgdmFyIGN5cCA9IGYgKiAtcnkgKiB4cCAvIHJ4O1xuICB2YXIgY3ggPSAoeDEgKyB4MikgLyAyLjAgKyBtYXRoQ29zKHBzaSkgKiBjeHAgLSBtYXRoU2luKHBzaSkgKiBjeXA7XG4gIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMCArIG1hdGhTaW4ocHNpKSAqIGN4cCArIG1hdGhDb3MocHNpKSAqIGN5cDtcbiAgdmFyIHRoZXRhID0gdkFuZ2xlKFsxLCAwXSwgWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XSk7XG4gIHZhciB1ID0gWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIHYgPSBbKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIGRUaGV0YSA9IHZBbmdsZSh1LCB2KTtcblxuICBpZiAodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgZFRoZXRhID0gUEk7XG4gIH1cblxuICBpZiAodlJhdGlvKHUsIHYpID49IDEpIHtcbiAgICBkVGhldGEgPSAwO1xuICB9XG5cbiAgaWYgKGZzID09PSAwICYmIGRUaGV0YSA+IDApIHtcbiAgICBkVGhldGEgPSBkVGhldGEgLSAyICogUEk7XG4gIH1cblxuICBpZiAoZnMgPT09IDEgJiYgZFRoZXRhIDwgMCkge1xuICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBQSTtcbiAgfVxuXG4gIHBhdGguYWRkRGF0YShjbWQsIGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhkYXRhKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyBjb21tYW5kIHN0cmluZ1xuXG5cbiAgdmFyIGNzID0gZGF0YS5yZXBsYWNlKC8tL2csICcgLScpLnJlcGxhY2UoLyAgL2csICcgJykucmVwbGFjZSgvIC9nLCAnLCcpLnJlcGxhY2UoLywsL2csICcsJyk7XG4gIHZhciBuOyAvLyBjcmVhdGUgcGlwZXMgc28gdGhhdCB3ZSBjYW4gc3BsaXQgdGhlIGRhdGFcblxuICBmb3IgKG4gPSAwOyBuIDwgY2MubGVuZ3RoOyBuKyspIHtcbiAgICBjcyA9IGNzLnJlcGxhY2UobmV3IFJlZ0V4cChjY1tuXSwgJ2cnKSwgJ3wnICsgY2Nbbl0pO1xuICB9IC8vIGNyZWF0ZSBhcnJheVxuXG5cbiAgdmFyIGFyciA9IGNzLnNwbGl0KCd8Jyk7IC8vIGluaXQgY29udGV4dCBwb2ludFxuXG4gIHZhciBjcHggPSAwO1xuICB2YXIgY3B5ID0gMDtcbiAgdmFyIHBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gIHZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xuICB2YXIgcHJldkNtZDtcblxuICBmb3IgKG4gPSAxOyBuIDwgYXJyLmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIHN0ciA9IGFycltuXTtcbiAgICB2YXIgYyA9IHN0ci5jaGFyQXQoMCk7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIHAgPSBzdHIuc2xpY2UoMSkucmVwbGFjZSgvZSwtL2csICdlLScpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGNtZDtcblxuICAgIGlmIChwLmxlbmd0aCA+IDAgJiYgcFswXSA9PT0gJycpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBbaV0gPSBwYXJzZUZsb2F0KHBbaV0pO1xuICAgIH1cblxuICAgIHdoaWxlIChvZmYgPCBwLmxlbmd0aCAmJiAhaXNOYU4ocFtvZmZdKSkge1xuICAgICAgaWYgKGlzTmFOKHBbMF0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3RsUHR4O1xuICAgICAgdmFyIGN0bFB0eTtcbiAgICAgIHZhciByeDtcbiAgICAgIHZhciByeTtcbiAgICAgIHZhciBwc2k7XG4gICAgICB2YXIgZmE7XG4gICAgICB2YXIgZnM7XG4gICAgICB2YXIgeDEgPSBjcHg7XG4gICAgICB2YXIgeTEgPSBjcHk7IC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuXG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGMgPSAnbCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGMgPSAnTCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSk7XG4gICAgICAgICAgY3B4ID0gcFtvZmYgLSAyXTtcbiAgICAgICAgICBjcHkgPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSwgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5LCBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHkpO1xuICAgICAgICAgIGNweCArPSBwW29mZiAtIDJdO1xuICAgICAgICAgIGNweSArPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcblxuICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHgxID0gY3B4ICsgcFtvZmYrK107XG4gICAgICAgICAgeTEgPSBjcHkgKyBwW29mZisrXTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICB4MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHkxID0gcFtvZmYrK107XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgeDEgPSBwW29mZisrXSArIGNweDtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdICsgY3B5O1xuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG5cbiAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgcnkgPSBwW29mZisrXTtcbiAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGZzID0gcFtvZmYrK107XG4gICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYyA9PT0gJ3onIHx8IGMgPT09ICdaJykge1xuICAgICAgY21kID0gQ01ELlo7XG4gICAgICBwYXRoLmFkZERhdGEoY21kKTtcbiAgICB9XG5cbiAgICBwcmV2Q21kID0gY21kO1xuICB9XG5cbiAgcGF0aC50b1N0YXRpYygpO1xuICByZXR1cm4gcGF0aDtcbn0gLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykge1xuICB2YXIgcGF0aFByb3h5ID0gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhzdHIpO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHBhdGguc2V0RGF0YSkge1xuICAgICAgcGF0aC5zZXREYXRhKHBhdGhQcm94eS5kYXRhKTsgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG5cbiAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdHggPSBwYXRoO1xuICAgICAgcGF0aFByb3h5LnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgfVxuICB9O1xuXG4gIG9wdHMuYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobSkge1xuICAgIHRyYW5zZm9ybVBhdGgocGF0aFByb3h5LCBtKTtcbiAgICB0aGlzLmRpcnR5KHRydWUpO1xuICB9O1xuXG4gIHJldHVybiBvcHRzO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBQYXRoIG9iamVjdCBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRnJvbVN0cmluZyhzdHIsIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBQYXRoKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBQYXRoIGNsYXNzIGZyb20gcGF0aCBzdHJpbmcgZGF0YVxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPdGhlciBvcHRpb25zXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmRGcm9tU3RyaW5nKHN0ciwgb3B0cykge1xuICByZXR1cm4gUGF0aC5leHRlbmQoY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSk7XG59XG4vKipcbiAqIE1lcmdlIG11bHRpcGxlIHBhdGhzXG4gKi9cbi8vIFRPRE8gQXBwbHkgdHJhbnNmb3JtXG4vLyBUT0RPIHN0cm9rZSBkYXNoXG4vLyBUT0RPIE9wdGltaXplIGRvdWJsZSBtZW1vcnkgY29zdCBwcm9ibGVtXG5cblxuZnVuY3Rpb24gbWVyZ2VQYXRoKHBhdGhFbHMsIG9wdHMpIHtcbiAgdmFyIHBhdGhMaXN0ID0gW107XG4gIHZhciBsZW4gPSBwYXRoRWxzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBhdGhFbCA9IHBhdGhFbHNbaV07XG5cbiAgICBpZiAoIXBhdGhFbC5wYXRoKSB7XG4gICAgICBwYXRoRWwuY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGhFbC5fX2RpcnR5UGF0aCkge1xuICAgICAgcGF0aEVsLmJ1aWxkUGF0aChwYXRoRWwucGF0aCwgcGF0aEVsLnNoYXBlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwYXRoTGlzdC5wdXNoKHBhdGhFbC5wYXRoKTtcbiAgfVxuXG4gIHZhciBwYXRoQnVuZGxlID0gbmV3IFBhdGgob3B0cyk7IC8vIE5lZWQgcGF0aCBwcm94eS5cblxuICBwYXRoQnVuZGxlLmNyZWF0ZVBhdGhQcm94eSgpO1xuXG4gIHBhdGhCdW5kbGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBwYXRoLmFwcGVuZFBhdGgocGF0aExpc3QpOyAvLyBTdmcgYW5kIHZtbCByZW5kZXJlciBkb24ndCBoYXZlIGNvbnRleHRcblxuICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHBhdGhCdW5kbGU7XG59XG5cbmV4cG9ydHMuY3JlYXRlRnJvbVN0cmluZyA9IGNyZWF0ZUZyb21TdHJpbmc7XG5leHBvcnRzLmV4dGVuZEZyb21TdHJpbmcgPSBleHRlbmRGcm9tU3RyaW5nO1xuZXhwb3J0cy5tZXJnZVBhdGggPSBtZXJnZVBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBwYXRoQ29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3BhdGhcIik7XG5cbnZhciBQYXR0ZXJuID0gcmVxdWlyZShcIi4vUGF0dGVyblwiKTtcblxudmFyIGdldENhbnZhc1BhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBhdGhQcm94eUZvckRyYXcgPSBuZXcgUGF0aFByb3h5KHRydWUpO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cblxuZnVuY3Rpb24gUGF0aChvcHRzKSB7XG4gIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLnBhdGggPSBudWxsO1xufVxuXG5QYXRoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFBhdGgsXG4gIHR5cGU6ICdwYXRoJyxcbiAgX19kaXJ0eVBhdGg6IHRydWUsXG4gIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IDUsXG4gIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoIHx8IHBhdGhQcm94eUZvckRyYXc7XG4gICAgdmFyIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpO1xuICAgIHZhciBoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpO1xuICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcbiAgICB2YXIgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgIHZhciBoYXNGaWxsR3JhZGllbnQgPSBoYXNGaWxsICYmICEhZmlsbC5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNTdHJva2VHcmFkaWVudCA9IGhhc1N0cm9rZSAmJiAhIXN0cm9rZS5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNGaWxsUGF0dGVybiA9IGhhc0ZpbGwgJiYgISFmaWxsLmltYWdlO1xuICAgIHZhciBoYXNTdHJva2VQYXR0ZXJuID0gaGFzU3Ryb2tlICYmICEhc3Ryb2tlLmltYWdlO1xuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5KSB7XG4gICAgICB2YXIgcmVjdDsgLy8gVXBkYXRlIGdyYWRpZW50IGJlY2F1c2UgYm91bmRpbmcgcmVjdCBtYXkgY2hhbmdlZFxuXG4gICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgZmlsbCwgcmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICByZWN0ID0gcmVjdCB8fCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB0aGlzLl9zdHJva2VHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgc3Ryb2tlLCByZWN0KTtcbiAgICAgIH1cbiAgICB9IC8vIFVzZSB0aGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuXG5cbiAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAvLyBQRU5ESU5HIElmIG1heSBoYXZlIGFmZmVjdCB0aGUgc3RhdGVcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9maWxsR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNGaWxsUGF0dGVybikge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGdldENhbnZhc1BhdHRlcm4uY2FsbChmaWxsLCBjdHgpO1xuICAgIH1cblxuICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNTdHJva2VQYXR0ZXJuKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoc3Ryb2tlLCBjdHgpO1xuICAgIH1cblxuICAgIHZhciBsaW5lRGFzaCA9IHN0eWxlLmxpbmVEYXNoO1xuICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IHN0eWxlLmxpbmVEYXNoT2Zmc2V0O1xuICAgIHZhciBjdHhMaW5lRGFzaCA9ICEhY3R4LnNldExpbmVEYXNoOyAvLyBVcGRhdGUgcGF0aCBzeCwgc3lcblxuICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICBwYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7IC8vIFByb3h5IGNvbnRleHRcbiAgICAvLyBSZWJ1aWxkIHBhdGggaW4gZm9sbG93aW5nIDIgY2FzZXNcbiAgICAvLyAxLiBQYXRoIGlzIGRpcnR5XG4gICAgLy8gMi4gUGF0aCBuZWVkcyBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmVEYXNoIHN0cm9raW5nLlxuICAgIC8vICAgIEluIHRoaXMgY2FzZSwgbGluZURhc2ggaW5mb3JtYXRpb24gd2lsbCBub3QgYmUgc2F2ZWQgaW4gUGF0aFByb3h5XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCB8fCBsaW5lRGFzaCAmJiAhY3R4TGluZURhc2ggJiYgaGFzU3Ryb2tlKSB7XG4gICAgICBwYXRoLmJlZ2luUGF0aChjdHgpOyAvLyBTZXR0aW5nIGxpbmUgZGFzaCBiZWZvcmUgYnVpbGQgcGF0aFxuXG4gICAgICBpZiAobGluZURhc2ggJiYgIWN0eExpbmVEYXNoKSB7XG4gICAgICAgIHBhdGguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICBwYXRoLnNldExpbmVEYXNoT2Zmc2V0KGxpbmVEYXNoT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpOyAvLyBDbGVhciBwYXRoIGRpcnR5IGZsYWdcblxuICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcGxheSBwYXRoIGJ1aWxkaW5nXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLnBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICB9XG5cbiAgICBoYXNGaWxsICYmIHBhdGguZmlsbChjdHgpO1xuXG4gICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgfVxuXG4gICAgaGFzU3Ryb2tlICYmIHBhdGguc3Ryb2tlKGN0eCk7XG5cbiAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgIC8vIFBFTkRJTkdcbiAgICAgIC8vIFJlbW92ZSBsaW5lRGFzaFxuICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTsgLy8gRHJhdyByZWN0IHRleHRcblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgfVxuICB9LFxuICAvLyBXaGVuIGJ1bmRsaW5nIHBhdGgsIHNvbWUgc2hhcGUgbWF5IGRlY2lkZSBpZiB1c2UgbW92ZVRvIHRvIGJlZ2luIGEgbmV3IHN1YnBhdGggb3IgY2xvc2VQYXRoXG4gIC8vIExpa2UgaW4gY2lyY2xlXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGVDZmcsIGluQnVuZGxlKSB7fSxcbiAgY3JlYXRlUGF0aFByb3h5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICB9LFxuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuX3JlY3Q7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgbmVlZHNVcGRhdGVSZWN0ID0gIXJlY3Q7XG5cbiAgICBpZiAobmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcblxuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBwYXRoIG9uIGRlbWFuZC5cbiAgICAgICAgcGF0aCA9IHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWN0ID0gcmVjdDtcblxuICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgLy8gTmVlZHMgdXBkYXRlIHJlY3Qgd2l0aCBzdHJva2UgbGluZVdpZHRoIHdoZW5cbiAgICAgIC8vIDEuIEVsZW1lbnQgY2hhbmdlcyBzY2FsZSBvciBsaW5lV2lkdGhcbiAgICAgIC8vIDIuIFNoYXBlIGlzIGNoYW5nZWRcbiAgICAgIHZhciByZWN0V2l0aFN0cm9rZSA9IHRoaXMuX3JlY3RXaXRoU3Ryb2tlIHx8ICh0aGlzLl9yZWN0V2l0aFN0cm9rZSA9IHJlY3QuY2xvbmUoKSk7XG5cbiAgICAgIGlmICh0aGlzLl9fZGlydHkgfHwgbmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgIHJlY3RXaXRoU3Ryb2tlLmNvcHkocmVjdCk7IC8vIEZJWE1FIE11c3QgYWZ0ZXIgdXBkYXRlVHJhbnNmb3JtXG5cbiAgICAgICAgdmFyIHcgPSBzdHlsZS5saW5lV2lkdGg7IC8vIFBFTkRJTkcsIE1pbiBsaW5lIHdpZHRoIGlzIG5lZWRlZCB3aGVuIGxpbmUgaXMgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbFxuXG4gICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7IC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG5cbiAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICB3ID0gTWF0aC5tYXgodywgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkIHx8IDQpO1xuICAgICAgICB9IC8vIENvbnNpZGVyIGxpbmUgd2lkdGhcbiAgICAgICAgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG5cbiAgICAgICAgaWYgKGxpbmVTY2FsZSA+IDFlLTEwKSB7XG4gICAgICAgICAgcmVjdFdpdGhTdHJva2Uud2lkdGggKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS5oZWlnaHQgKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS54IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnkgLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmV0dXJuIHJlY3Qgd2l0aCBzdHJva2VcblxuXG4gICAgICByZXR1cm4gcmVjdFdpdGhTdHJva2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3Q7XG4gIH0sXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGxvY2FsUG9zID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgeCA9IGxvY2FsUG9zWzBdO1xuICAgIHkgPSBsb2NhbFBvc1sxXTtcblxuICAgIGlmIChyZWN0LmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMucGF0aC5kYXRhO1xuXG4gICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIGxpbmVTY2FsZSA9IHN0eWxlLnN0cm9rZU5vU2NhbGUgPyB0aGlzLmdldExpbmVTY2FsZSgpIDogMTsgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG4gICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgIC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG4gICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IE1hdGgubWF4KGxpbmVXaWR0aCwgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aENvbnRhaW4uY29udGFpblN0cm9rZShwYXRoRGF0YSwgbGluZVdpZHRoIC8gbGluZVNjYWxlLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhDb250YWluLmNvbnRhaW4ocGF0aERhdGEsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZGlydHlQYXRoXG4gICAqL1xuICBkaXJ0eTogZnVuY3Rpb24gKGRpcnR5UGF0aCkge1xuICAgIGlmIChkaXJ0eVBhdGggPT0gbnVsbCkge1xuICAgICAgZGlydHlQYXRoID0gdHJ1ZTtcbiAgICB9IC8vIE9ubHkgbWFyayBkaXJ0eSwgbm90IG1hcmsgY2xlYW5cblxuXG4gICAgaWYgKGRpcnR5UGF0aCkge1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7IC8vIFVzZWQgYXMgYSBjbGlwcGluZyBwYXRoXG5cbiAgICBpZiAodGhpcy5fX2NsaXBUYXJnZXQpIHtcbiAgICAgIHRoaXMuX19jbGlwVGFyZ2V0LmRpcnR5KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc2hhcGUnKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICovXG4gIGFuaW1hdGVTaGFwZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzaGFwZScsIGxvb3ApO1xuICB9LFxuICAvLyBPdmVyd3JpdGUgYXR0cktWXG4gIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAvLyBGSVhNRVxuICAgIGlmIChrZXkgPT09ICdzaGFwZScpIHtcbiAgICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IHRydWU7XG4gICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgRGlzcGxheWFibGUucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0U2hhcGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTsgLy8gUGF0aCBmcm9tIHN0cmluZyBtYXkgbm90IGhhdmUgc2hhcGVcblxuICAgIGlmIChzaGFwZSkge1xuICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChrZXkpKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgc2hhcGVbbmFtZV0gPSBrZXlbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZVtrZXldID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGlydHkodHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGdldExpbmVTY2FsZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07IC8vIEdldCB0aGUgbGluZSBzY2FsZS5cbiAgICAvLyBEZXRlcm1pbmFudCBvZiBgbWAgbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXG4gICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgIC8vIGZvciB3aWR0aC5cblxuICAgIHJldHVybiBtICYmIGFicyhtWzBdIC0gMSkgPiAxZS0xMCAmJiBhYnMobVszXSAtIDEpID4gMWUtMTAgPyBNYXRoLnNxcnQoYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pKSA6IDE7XG4gIH1cbn07XG4vKipcbiAqIOaJqeWxleS4gOS4qiBQYXRoIGVsZW1lbnQsIOavlOWmguaYn+W9ou+8jOWchuetieOAglxuICogRXh0ZW5kIGEgcGF0aCBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy50eXBlIFBhdGggdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuaW5pdCBJbml0aWFsaXplXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5idWlsZFBhdGggT3ZlcndyaXRlIGJ1aWxkUGF0aCBtZXRob2RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc3R5bGVdIEV4dGVuZGVkIGRlZmF1bHQgc3R5bGUgY29uZmlnXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnNoYXBlXSBFeHRlbmRlZCBkZWZhdWx0IHNoYXBlIGNvbmZpZ1xuICovXG5cblBhdGguZXh0ZW5kID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gIHZhciBTdWIgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIFBhdGguY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgIGlmIChkZWZhdWx0cy5zdHlsZSkge1xuICAgICAgLy8gRXh0ZW5kIGRlZmF1bHQgc3R5bGVcbiAgICAgIHRoaXMuc3R5bGUuZXh0ZW5kRnJvbShkZWZhdWx0cy5zdHlsZSwgZmFsc2UpO1xuICAgIH0gLy8gRXh0ZW5kIGRlZmF1bHQgc2hhcGVcblxuXG4gICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xuXG4gICAgaWYgKGRlZmF1bHRTaGFwZSkge1xuICAgICAgdGhpcy5zaGFwZSA9IHRoaXMuc2hhcGUgfHwge307XG4gICAgICB2YXIgdGhpc1NoYXBlID0gdGhpcy5zaGFwZTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0U2hhcGUpIHtcbiAgICAgICAgaWYgKCF0aGlzU2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgZGVmYXVsdFNoYXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdGhpc1NoYXBlW25hbWVdID0gZGVmYXVsdFNoYXBlW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVmYXVsdHMuaW5pdCAmJiBkZWZhdWx0cy5pbml0LmNhbGwodGhpcywgb3B0cyk7XG4gIH07XG5cbiAgenJVdGlsLmluaGVyaXRzKFN1YiwgUGF0aCk7IC8vIEZJWE1FIOS4jeiDvSBleHRlbmQgcG9zaXRpb24sIHJvdGF0aW9uIOetieW8leeUqOWvueixoVxuXG4gIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAvLyBFeHRlbmRpbmcgcHJvdG90eXBlIHZhbHVlcyBhbmQgbWV0aG9kc1xuICAgIGlmIChuYW1lICE9PSAnc3R5bGUnICYmIG5hbWUgIT09ICdzaGFwZScpIHtcbiAgICAgIFN1Yi5wcm90b3R5cGVbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gU3ViO1xufTtcblxuenJVdGlsLmluaGVyaXRzKFBhdGgsIERpc3BsYXlhYmxlKTtcbnZhciBfZGVmYXVsdCA9IFBhdGg7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuL1N0eWxlXCIpO1xuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoXCIuLi9FbGVtZW50XCIpO1xuXG52YXIgUmVjdFRleHQgPSByZXF1aXJlKFwiLi9taXhpbi9SZWN0VGV4dFwiKTtcblxuLyoqXG4gKiDlj6/nu5jliLbnmoTlm77lvaLln7rnsbtcbiAqIEJhc2UgY2xhc3Mgb2YgYWxsIGRpc3BsYXlhYmxlIGdyYXBoaWMgb2JqZWN0c1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqL1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9FbGVtZW50XG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL21peGluL1JlY3RUZXh0XG4gKi9cbmZ1bmN0aW9uIERpc3BsYXlhYmxlKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTsgLy8gRXh0ZW5kIHByb3BlcnRpZXNcblxuICBmb3IgKHZhciBuYW1lIGluIG9wdHMpIHtcbiAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBuYW1lICE9PSAnc3R5bGUnKSB7XG4gICAgICB0aGlzW25hbWVdID0gb3B0c1tuYW1lXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfVxuICAgKi9cblxuXG4gIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob3B0cy5zdHlsZSwgdGhpcyk7XG4gIHRoaXMuX3JlY3QgPSBudWxsOyAvLyBTaGFwZXMgZm9yIGNhc2NhZGUgY2xpcHBpbmcuXG5cbiAgdGhpcy5fX2NsaXBQYXRocyA9IFtdOyAvLyBGSVhNRSBTdGF0ZWZ1bCBtdXN0IGJlIG1peGluZWQgYWZ0ZXIgc3R5bGUgaXMgc2V0dGVkXG4gIC8vIFN0YXRlZnVsLmNhbGwodGhpcywgb3B0cyk7XG59XG5cbkRpc3BsYXlhYmxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERpc3BsYXlhYmxlLFxuICB0eXBlOiAnZGlzcGxheWFibGUnLFxuXG4gIC8qKlxuICAgKiBEaXNwbGF5YWJsZSDmmK/lkKbkuLrohI/vvIxQYWludGVyIOS4reS8muagueaNruivpeagh+iusOWIpOaWreaYr+WQpumcgOimgeaYr+WQpumcgOimgemHjeaWsOe7mOWItlxuICAgKiBEaXJ0eSBmbGFnLiBGcm9tIHdoaWNoIHBhaW50ZXIgd2lsbCBkZXRlcm1pbmUgaWYgdGhpcyBkaXNwbGF5YWJsZSBvYmplY3QgbmVlZHMgYnJ1c2hcbiAgICogQG5hbWUgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNfX2RpcnR5XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgX19kaXJ0eTogdHJ1ZSxcblxuICAvKipcbiAgICog5Zu+5b2i5piv5ZCm5Y+v6KeB77yM5Li6dHJ1ZeaXtuS4jee7mOWItuWbvuW9ou+8jOS9huaYr+S7jeiDveinpuWPkem8oOagh+S6i+S7tlxuICAgKiBJZiBpZ25vcmUgZHJhd2luZyBvZiB0aGUgZGlzcGxheWFibGUgb2JqZWN0LiBNb3VzZSBldmVudCB3aWxsIHN0aWxsIGJlIHRyaWdnZXJlZFxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNpbnZpc2libGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpbnZpc2libGU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHo6IDAsXG5cbiAgLyoqXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgejI6IDAsXG5cbiAgLyoqXG4gICAqIHrlsYJsZXZlbO+8jOWGs+Wumue7mOeUu+WcqOWTquWxgmNhbnZhc+S4rVxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6bGV2ZWxcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgemxldmVsOiAwLFxuXG4gIC8qKlxuICAgKiDmmK/lkKblj6/mi5bmi71cbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJhZ2dhYmxlOiBmYWxzZSxcblxuICAvKipcbiAgICog5piv5ZCm5q2j5Zyo5ouW5ou9XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2RyYWdnYWJsZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRyYWdnaW5nOiBmYWxzZSxcblxuICAvKipcbiAgICog5piv5ZCm55u45bqU6byg5qCH5LqL5Lu2XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3NpbGVudFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIElmIGVuYWJsZSBjdWxsaW5nXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgY3VsbGluZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIE1vdXNlIGN1cnNvciB3aGVuIGhvdmVyZWRcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjY3Vyc29yXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBjdXJzb3I6ICdwb2ludGVyJyxcblxuICAvKipcbiAgICogSWYgaG92ZXIgYXJlYSBpcyBib3VuZGluZyByZWN0XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3JlY3RIb3ZlclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgcmVjdEhvdmVyOiBmYWxzZSxcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBlbGVtZW50IHByb2dyZXNzaXZlbHkgd2hlbiB0aGUgdmFsdWUgPj0gMCxcbiAgICogdXNlZnVsbCBmb3IgbGFyZ2UgZGF0YS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHByb2dyZXNzaXZlOiAtMSxcbiAgYmVmb3JlQnJ1c2g6IGZ1bmN0aW9uIChjdHgpIHt9LFxuICBhZnRlckJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcblxuICAvKipcbiAgICog5Zu+5b2i57uY5Yi25pa55rOVXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICovXG4gIC8vIEludGVyZmFjZVxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7fSxcblxuICAvKipcbiAgICog6I635Y+W5pyA5bCP5YyF5Zu055uSXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgLy8gSW50ZXJmYWNlXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge30sXG5cbiAgLyoqXG4gICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9ouS4ilxuICAgKiBJZiBkaXNwbGF5YWJsZSBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLnJlY3RDb250YWluKHgsIHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICovXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDliKTmlq3lnZDmoIcgeCwgeSDmmK/lkKblnKjlm77lvaLnmoTljIXlm7Tnm5LkuIpcbiAgICogSWYgYm91bmRpbmcgcmVjdCBvZiBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICByZWN0Q29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgY29vcmQgPSB0aGlzLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCh4LCB5KTtcbiAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgcmV0dXJuIHJlY3QuY29udGFpbihjb29yZFswXSwgY29vcmRbMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmoIforrDlm77lvaLlhYPntKDkuLrohI/vvIzlubbkuJTlnKjkuIvkuIDluKfph43nu5hcbiAgICogTWFyayBkaXNwbGF5YWJsZSBlbGVtZW50IGRpcnR5IGFuZCByZWZyZXNoIG5leHQgZnJhbWVcbiAgICovXG4gIGRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICog5Zu+5b2i5piv5ZCm5Lya6Kem5Y+R5LqL5Lu2XG4gICAqIElmIGRpc3BsYXlhYmxlIG9iamVjdCBiaW5kZWQgYW55IGV2ZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICAvLyBUT0RPLCDpgJrov4cgYmluZCDnu5HlrprnmoTkuovku7ZcbiAgLy8gaXNTaWxlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgLy8gICAgIHJldHVybiAhKFxuICAvLyAgICAgICAgIHRoaXMuaG92ZXJhYmxlIHx8IHRoaXMuZHJhZ2dhYmxlXG4gIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlbW92ZSB8fCB0aGlzLm9ubW91c2VvdmVyIHx8IHRoaXMub25tb3VzZW91dFxuICAvLyAgICAgICAgIHx8IHRoaXMub25tb3VzZWRvd24gfHwgdGhpcy5vbm1vdXNldXAgfHwgdGhpcy5vbmNsaWNrXG4gIC8vICAgICAgICAgfHwgdGhpcy5vbmRyYWdlbnRlciB8fCB0aGlzLm9uZHJhZ292ZXIgfHwgdGhpcy5vbmRyYWdsZWF2ZVxuICAvLyAgICAgICAgIHx8IHRoaXMub25kcm9wXG4gIC8vICAgICApO1xuICAvLyB9LFxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc3R5bGUnKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICovXG4gIGFuaW1hdGVTdHlsZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzdHlsZScsIGxvb3ApO1xuICB9LFxuICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSAhPT0gJ3N0eWxlJykge1xuICAgICAgRWxlbWVudC5wcm90b3R5cGUuYXR0cktWLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3R5bGUuc2V0KHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFN0eWxlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuc3R5bGUuc2V0KGtleSwgdmFsdWUpO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVc2UgZ2l2ZW4gc3R5bGUgb2JqZWN0XG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqXG4gICAqL1xuICB1c2VTdHlsZTogZnVuY3Rpb24gKG9iaikge1xuICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob2JqLCB0aGlzKTtcbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnpyVXRpbC5pbmhlcml0cyhEaXNwbGF5YWJsZSwgRWxlbWVudCk7XG56clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFJlY3RUZXh0KTsgLy8genJVdGlsLm1peGluKERpc3BsYXlhYmxlLCBTdGF0ZWZ1bCk7XG5cbnZhciBfZGVmYXVsdCA9IERpc3BsYXlhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU1RZTEVfQ09NTU9OX1BST1BTID0gW1snc2hhZG93Qmx1cicsIDBdLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLCBbJ2xpbmVDYXAnLCAnYnV0dCddLCBbJ2xpbmVKb2luJywgJ21pdGVyJ10sIFsnbWl0ZXJMaW1pdCcsIDEwXV07IC8vIHZhciBTSEFET1dfUFJPUFMgPSBTVFlMRV9DT01NT05fUFJPUFMuc2xpY2UoMCwgNCk7XG4vLyB2YXIgTElORV9QUk9QUyA9IFNUWUxFX0NPTU1PTl9QUk9QUy5zbGljZSg0KTtcblxudmFyIFN0eWxlID0gZnVuY3Rpb24gKG9wdHMsIGhvc3QpIHtcbiAgdGhpcy5leHRlbmRGcm9tKG9wdHMsIGZhbHNlKTtcbiAgdGhpcy5ob3N0ID0gaG9zdDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmVhckdyYWRpZW50KGN0eCwgb2JqLCByZWN0KSB7XG4gIHZhciB4ID0gb2JqLnggPT0gbnVsbCA/IDAgOiBvYmoueDtcbiAgdmFyIHgyID0gb2JqLngyID09IG51bGwgPyAxIDogb2JqLngyO1xuICB2YXIgeSA9IG9iai55ID09IG51bGwgPyAwIDogb2JqLnk7XG4gIHZhciB5MiA9IG9iai55MiA9PSBudWxsID8gMCA6IG9iai55MjtcblxuICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICB4ID0geCAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgeDIgPSB4MiAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgeSA9IHkgKiByZWN0LmhlaWdodCArIHJlY3QueTtcbiAgICB5MiA9IHkyICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gIH1cblxuICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeDIsIHkyKTtcbiAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSYWRpYWxHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIHZhciBtaW4gPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIHggPSBvYmoueCA9PSBudWxsID8gMC41IDogb2JqLng7XG4gIHZhciB5ID0gb2JqLnkgPT0gbnVsbCA/IDAuNSA6IG9iai55O1xuICB2YXIgciA9IG9iai5yID09IG51bGwgPyAwLjUgOiBvYmoucjtcblxuICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICB4ID0geCAqIHdpZHRoICsgcmVjdC54O1xuICAgIHkgPSB5ICogaGVpZ2h0ICsgcmVjdC55O1xuICAgIHIgPSByICogbWluO1xuICB9XG5cbiAgdmFyIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgsIHksIDAsIHgsIHksIHIpO1xuICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG59XG5cblN0eWxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFN0eWxlLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX1cbiAgICovXG4gIGhvc3Q6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmaWxsOiAnIzAwMCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdHJva2U6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBvcGFjaXR5OiAxLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBsaW5lRGFzaDogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGxpbmVEYXNoT2Zmc2V0OiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2hhZG93Qmx1cjogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNoYWRvd09mZnNldFg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzaGFkb3dPZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbGluZVdpZHRoOiAxLFxuXG4gIC8qKlxuICAgKiBJZiBzdHJva2UgaWdub3JlIHNjYWxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc3Ryb2tlTm9TY2FsZTogZmFsc2UsXG4gIC8vIEJvdW5kaW5nIHJlY3QgdGV4dCBjb25maWd1cmF0aW9uXG4gIC8vIE5vdCBhZmZlY3RlZCBieSBlbGVtZW50IHRyYW5zZm9ybVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dDogbnVsbCxcblxuICAvKipcbiAgICogSWYgYGZvbnRTaXplYCBvciBgZm9udEZhbWlseWAgZXhpc3RzLCBgZm9udGAgd2lsbCBiZSByZXNldCBieVxuICAgKiBgZm9udFNpemVgLCBgZm9udFN0eWxlYCwgYGZvbnRXZWlnaHRgLCBgZm9udEZhbWlseWAuXG4gICAqIFNvIGRvIG5vdCB2aXNpdCBpdCBkaXJlY3RseSBpbiB1cHBlciBhcHBsaWNhdGlvbiAobGlrZSBlY2hhcnRzKSxcbiAgICogYnV0IHVzZSBgY29udGFpbi90ZXh0I21ha2VGb250YCBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udDogbnVsbCxcblxuICAvKipcbiAgICogVGhlIHNhbWUgYXMgZm9udC4gVXNlIGZvbnQgcGxlYXNlLlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEZvbnQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEl0IGhlbHBzIG1lcmdpbmcgcmVzcGVjdGl2ZWx5LCByYXRoZXIgdGhhbiBwYXJzaW5nIGFuIGVudGlyZSBmb250IHN0cmluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZvbnRTdHlsZTogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udFdlaWdodDogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBTaG91bGQgYmUgMTIgYnV0IG5vdCAnMTJweCcuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBmb250U2l6ZTogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udEZhbWlseTogbnVsbCxcblxuICAvKipcbiAgICogUmVzZXJ2ZWQgZm9yIHNwZWNpYWwgZnVuY3RpbmFsaXR5LCBsaWtlICdocicuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0VGFnOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEZpbGw6ICcjMDAwJyxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRTdHJva2U6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0V2lkdGg6IG51bGwsXG5cbiAgLyoqXG4gICAqIE9ubHkgZm9yIHRleHRCYWNrZ3JvdW5kLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEhlaWdodDogbnVsbCxcblxuICAvKipcbiAgICogdGV4dFN0cm9rZSBtYXkgYmUgc2V0IGFzIHNvbWUgY29sb3IgYXMgYSBkZWZhdWx0XG4gICAqIHZhbHVlIGluIHVwcGVyIGFwcGxpY2Fpb24sIHdoZXJlIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAqIG9mIHRleHRTdHJva2VXaWR0aCBzaG91bGQgYmUgMCB0byBtYWtlIHN1cmUgdGhhdFxuICAgKiB1c2VyIGNhbiBjaG9vc2UgdG8gZG8gbm90IHVzZSB0ZXh0IHN0cm9rZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTdHJva2VXaWR0aDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRMaW5lSGVpZ2h0OiBudWxsLFxuXG4gIC8qKlxuICAgKiAnaW5zaWRlJywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSdcbiAgICogW3gsIHldXG4gICAqIEJhc2VkIG9uIHgsIHkgb2YgcmVjdC5cbiAgICogQHR5cGUge3N0cmluZ3xBcnJheS48bnVtYmVyPn1cbiAgICogQGRlZmF1bHQgJ2luc2lkZSdcbiAgICovXG4gIHRleHRQb3NpdGlvbjogJ2luc2lkZScsXG5cbiAgLyoqXG4gICAqIElmIG5vdCBzcGVjaWZpZWQsIHVzZSB0aGUgYm91bmRpbmdSZWN0IG9mIGEgYGRpc3BsYXlhYmxlYC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRleHRSZWN0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBbeCwgeV1cbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgdGV4dE9mZnNldDogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRBbGlnbjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRWZXJ0aWNhbEFsaWduOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dERpc3RhbmNlOiA1LFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFNoYWRvd0JsdXI6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0U2hhZG93T2Zmc2V0WDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTaGFkb3dPZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd0JsdXI6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm94U2hhZG93T2Zmc2V0WDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3hTaGFkb3dPZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRyYW5zZm9ybSB0ZXh0LlxuICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdHJhbnNmb3JtVGV4dDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFRleHQgcm90YXRlIGFyb3VuZCBwb3NpdGlvbiBvZiBQYXRoIG9yIEltYWdlXG4gICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnQgYW5kIHRyYW5zZm9ybVRleHQgaXMgZmFsc2UuXG4gICAqL1xuICB0ZXh0Um90YXRpb246IDAsXG5cbiAgLyoqXG4gICAqIFRleHQgb3JpZ2luIG9mIHRleHQgcm90YXRpb24sIGxpa2UgWzEwLCA0MF0uXG4gICAqIEJhc2VkIG9uIHgsIHkgb2YgcmVjdC5cbiAgICogVXNlZnVsIGluIGxhYmVsIHJvdGF0aW9uIG9mIGNpcmN1bGFyIHN5bWJvbC5cbiAgICogQnkgZGVmYXVsdCwgdGhpcyBvcmlnaW4gaXMgdGV4dFBvc2l0aW9uLlxuICAgKiBDYW4gYmUgJ2NlbnRlcicuXG4gICAqIEB0eXBlIHtzdHJpbmd8QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0ZXh0T3JpZ2luOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEJhY2tncm91bmRDb2xvcjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRCb3JkZXJDb2xvcjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3JkZXJXaWR0aDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3JkZXJSYWRpdXM6IDAsXG5cbiAgLyoqXG4gICAqIENhbiBiZSBgMmAgb3IgYFsyLCA0XWAgb3IgYFsyLCAzLCA0LCA1XWBcbiAgICogQHR5cGUge251bWJlcnxBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHRleHRQYWRkaW5nOiBudWxsLFxuXG4gIC8qKlxuICAgKiBUZXh0IHN0eWxlcyBmb3IgcmljaCB0ZXh0LlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcmljaDogbnVsbCxcblxuICAvKipcbiAgICoge291dGVyV2lkdGgsIG91dGVySGVpZ2h0LCBlbGxpcHNpcywgcGxhY2Vob2xkZXJ9XG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0cnVuY2F0ZTogbnVsbCxcblxuICAvKipcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9nbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGJsZW5kOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICBiaW5kOiBmdW5jdGlvbiAoY3R4LCBlbCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcztcbiAgICB2YXIgcHJldlN0eWxlID0gcHJldkVsICYmIHByZXZFbC5zdHlsZTtcbiAgICB2YXIgZmlyc3REcmF3ID0gIXByZXZTdHlsZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IFNUWUxFX0NPTU1PTl9QUk9QU1tpXTtcbiAgICAgIHZhciBzdHlsZU5hbWUgPSBwcm9wWzBdO1xuXG4gICAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlW3N0eWxlTmFtZV0gIT09IHByZXZTdHlsZVtzdHlsZU5hbWVdKSB7XG4gICAgICAgIC8vIEZJWE1FIEludmFsaWQgcHJvcGVydHkgdmFsdWUgd2lsbCBjYXVzZSBzdHlsZSBsZWFrIGZyb20gcHJldmlvdXMgZWxlbWVudC5cbiAgICAgICAgY3R4W3N0eWxlTmFtZV0gPSBzdHlsZVtzdHlsZU5hbWVdIHx8IHByb3BbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZS5maWxsICE9PSBwcmV2U3R5bGUuZmlsbCkge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmZpbGw7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZS5zdHJva2UgIT09IHByZXZTdHlsZS5zdHJva2UpIHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLnN0cm9rZTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlLm9wYWNpdHkgIT09IHByZXZTdHlsZS5vcGFjaXR5KSB7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdHlsZS5vcGFjaXR5ID09IG51bGwgPyAxIDogc3R5bGUub3BhY2l0eTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlLmJsZW5kICE9PSBwcmV2U3R5bGUuYmxlbmQpIHtcbiAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBzdHlsZS5ibGVuZCB8fCAnc291cmNlLW92ZXInO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aCAvICh0aGlzLnN0cm9rZU5vU2NhbGUgJiYgZWwgJiYgZWwuZ2V0TGluZVNjYWxlID8gZWwuZ2V0TGluZVNjYWxlKCkgOiAxKTtcbiAgICB9XG4gIH0sXG4gIGhhc0ZpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmlsbCA9IHRoaXMuZmlsbDtcbiAgICByZXR1cm4gZmlsbCAhPSBudWxsICYmIGZpbGwgIT09ICdub25lJztcbiAgfSxcbiAgaGFzU3Ryb2tlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0cm9rZSA9IHRoaXMuc3Ryb2tlO1xuICAgIHJldHVybiBzdHJva2UgIT0gbnVsbCAmJiBzdHJva2UgIT09ICdub25lJyAmJiB0aGlzLmxpbmVXaWR0aCA+IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dGVuZCBmcm9tIG90aGVyIHN0eWxlXG4gICAqIEBwYXJhbSB7enJlbmRlci9ncmFwaGljL1N0eWxlfSBvdGhlclN0eWxlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcndyaXRlIHRydWU6IG92ZXJ3cmlydGUgYW55IHdheS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2U6IG92ZXJ3cml0ZSBvbmx5IHdoZW4gIXRhcmdldC5oYXNPd25Qcm9wZXJ0eVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlcnM6IG92ZXJ3cml0ZSB3aGVuIHByb3BlcnR5IGlzIG5vdCBudWxsL3VuZGVmaW5lZC5cbiAgICovXG4gIGV4dGVuZEZyb206IGZ1bmN0aW9uIChvdGhlclN0eWxlLCBvdmVyd3JpdGUpIHtcbiAgICBpZiAob3RoZXJTdHlsZSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBvdGhlclN0eWxlKSB7XG4gICAgICAgIGlmIChvdGhlclN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpICYmIChvdmVyd3JpdGUgPT09IHRydWUgfHwgKG92ZXJ3cml0ZSA9PT0gZmFsc2UgPyAhdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA6IG90aGVyU3R5bGVbbmFtZV0gIT0gbnVsbCkpKSB7XG4gICAgICAgICAgdGhpc1tuYW1lXSA9IG90aGVyU3R5bGVbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJhdGNoIHNldHRpbmcgc3R5bGUgd2l0aCBhIGdpdmVuIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IG9ialxuICAgKiBAcGFyYW0geyp9IFtvYmpdXG4gICAqL1xuICBzZXQ6IGZ1bmN0aW9uIChvYmosIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzW29ial0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHRlbmRGcm9tKG9iaiwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZVxuICAgKiBAcmV0dXJuIHt6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld1N0eWxlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICBuZXdTdHlsZS5leHRlbmRGcm9tKHRoaXMsIHRydWUpO1xuICAgIHJldHVybiBuZXdTdHlsZTtcbiAgfSxcbiAgZ2V0R3JhZGllbnQ6IGZ1bmN0aW9uIChjdHgsIG9iaiwgcmVjdCkge1xuICAgIHZhciBtZXRob2QgPSBvYmoudHlwZSA9PT0gJ3JhZGlhbCcgPyBjcmVhdGVSYWRpYWxHcmFkaWVudCA6IGNyZWF0ZUxpbmVhckdyYWRpZW50O1xuICAgIHZhciBjYW52YXNHcmFkaWVudCA9IG1ldGhvZChjdHgsIG9iaiwgcmVjdCk7XG4gICAgdmFyIGNvbG9yU3RvcHMgPSBvYmouY29sb3JTdG9wcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JTdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2FudmFzR3JhZGllbnQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcHNbaV0ub2Zmc2V0LCBjb2xvclN0b3BzW2ldLmNvbG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gIH1cbn07XG52YXIgc3R5bGVQcm90byA9IFN0eWxlLnByb3RvdHlwZTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBTVFlMRV9DT01NT05fUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG5cbiAgaWYgKCEocHJvcFswXSBpbiBzdHlsZVByb3RvKSkge1xuICAgIHN0eWxlUHJvdG9bcHJvcFswXV0gPSBwcm9wWzFdO1xuICB9XG59IC8vIFByb3ZpZGUgZm9yIG90aGVyc1xuXG5cblN0eWxlLmdldEdyYWRpZW50ID0gc3R5bGVQcm90by5nZXRHcmFkaWVudDtcbnZhciBfZGVmYXVsdCA9IFN0eWxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9TdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ3VpZCA9IHJlcXVpcmUoXCIuL2NvcmUvZ3VpZFwiKTtcblxudmFyIEV2ZW50ZnVsID0gcmVxdWlyZShcIi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbnZhciBUcmFuc2Zvcm1hYmxlID0gcmVxdWlyZShcIi4vbWl4aW4vVHJhbnNmb3JtYWJsZVwiKTtcblxudmFyIEFuaW1hdGFibGUgPSByZXF1aXJlKFwiLi9taXhpbi9BbmltYXRhYmxlXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9FbGVtZW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9BbmltYXRhYmxlfVxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9XG4gKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWx9XG4gKi9cbnZhciBFbGVtZW50ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIFRyYW5zZm9ybWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgRXZlbnRmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbiAgQW5pbWF0YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAvKipcbiAgICog55S75biD5YWD57SgSURcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG5cbiAgdGhpcy5pZCA9IG9wdHMuaWQgfHwgZ3VpZCgpO1xufTtcblxuRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiDlhYPntKDnsbvlnotcbiAgICogRWxlbWVudCB0eXBlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0eXBlOiAnZWxlbWVudCcsXG5cbiAgLyoqXG4gICAqIOWFg+e0oOWQjeWtl1xuICAgKiBFbGVtZW50IG5hbWVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIG5hbWU6ICcnLFxuXG4gIC8qKlxuICAgKiBaUmVuZGVyIOWunuS+i+Wvueixoe+8jOS8muWcqCBlbGVtZW50IOa3u+WKoOWIsCB6cmVuZGVyIOWunuS+i+S4reWQjuiHquWKqOi1i+WAvFxuICAgKiBaUmVuZGVyIGluc3RhbmNlIHdpbGwgYmUgYXNzaWduZWQgd2hlbiBlbGVtZW50IGlzIGFzc29jaWF0ZWQgd2l0aCB6cmVuZGVyXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9FbGVtZW50I19fenJcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAqL1xuICBfX3pyOiBudWxsLFxuXG4gIC8qKlxuICAgKiDlm77lvaLmmK/lkKblv73nlaXvvIzkuLp0cnVl5pe25b+955Wl5Zu+5b2i55qE57uY5Yi25Lul5Y+K5LqL5Lu26Kem5Y+RXG4gICAqIElmIGlnbm9yZSBkcmF3aW5nIGFuZCBldmVudHMgb2YgdGhlIGVsZW1lbnQgb2JqZWN0XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9FbGVtZW50I2lnbm9yZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGlnbm9yZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIOeUqOS6juijgeWJqueahOi3r+W+hChzaGFwZSnvvIzmiYDmnIkgR3JvdXAg5YaF55qE6Lev5b6E5Zyo57uY5Yi25pe26YO95Lya6KKr6L+Z5Liq6Lev5b6E6KOB5YmqXG4gICAqIOivpei3r+W+hOS8mue7p+aJv+iiq+ijgeWHj+WvueixoeeahOWPmOaNolxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofVxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC8jY2xpcHBpbmctcmVnaW9uXG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgY2xpcFBhdGg6IG51bGwsXG5cbiAgLyoqXG4gICAqIERyaWZ0IGVsZW1lbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkeCBkeCBvbiB0aGUgZ2xvYmFsIHNwYWNlXG4gICAqIEBwYXJhbSAge251bWJlcn0gZHkgZHkgb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgKi9cbiAgZHJpZnQ6IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgZHkgPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICBkeCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIG0gPSB0aGlzLnRyYW5zZm9ybSA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICB9XG5cbiAgICBtWzRdICs9IGR4O1xuICAgIG1bNV0gKz0gZHk7XG4gICAgdGhpcy5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogSG9vayBiZWZvcmUgdXBkYXRlXG4gICAqL1xuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIC8qKlxuICAgKiBIb29rIGFmdGVyIHVwZGF0ZVxuICAgKi9cbiAgYWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZWFjaCBmcmFtZVxuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAqL1xuICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7fSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicgfHwga2V5ID09PSAnc2NhbGUnIHx8IGtleSA9PT0gJ29yaWdpbicpIHtcbiAgICAgIC8vIENvcHkgdGhlIGFycmF5XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXNba2V5XTtcblxuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgIHRhcmdldCA9IHRoaXNba2V5XSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0WzBdID0gdmFsdWVbMF07XG4gICAgICAgIHRhcmdldFsxXSA9IHZhbHVlWzFdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGVsZW1lbnRcbiAgICovXG4gIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlnbm9yZSA9IHRydWU7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGVsZW1lbnRcbiAgICovXG4gIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlnbm9yZSA9IGZhbHNlO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBhdHRyOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5hdHRyS1Yoa2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHRoaXMuYXR0cktWKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGNsaXBQYXRoXG4gICAqL1xuICBzZXRDbGlwUGF0aDogZnVuY3Rpb24gKGNsaXBQYXRoKSB7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuXG4gICAgaWYgKHpyKSB7XG4gICAgICBjbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgfSAvLyBSZW1vdmUgcHJldmlvdXMgY2xpcCBwYXRoXG5cblxuICAgIGlmICh0aGlzLmNsaXBQYXRoICYmIHRoaXMuY2xpcFBhdGggIT09IGNsaXBQYXRoKSB7XG4gICAgICB0aGlzLnJlbW92ZUNsaXBQYXRoKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGlwUGF0aCA9IGNsaXBQYXRoO1xuICAgIGNsaXBQYXRoLl9fenIgPSB6cjtcbiAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSB0aGlzO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKi9cbiAgcmVtb3ZlQ2xpcFBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoO1xuXG4gICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICBpZiAoY2xpcFBhdGguX196cikge1xuICAgICAgICBjbGlwUGF0aC5yZW1vdmVTZWxmRnJvbVpyKGNsaXBQYXRoLl9fenIpO1xuICAgICAgfVxuXG4gICAgICBjbGlwUGF0aC5fX3pyID0gbnVsbDtcbiAgICAgIGNsaXBQYXRoLl9fY2xpcFRhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLmNsaXBQYXRoID0gbnVsbDtcbiAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkIHNlbGYgZnJvbSB6cmVuZGVyIGluc3RhbmNlLlxuICAgKiBOb3QgcmVjdXJzaXZlbHkgYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgd2hlbiBlbGVtZW50IGFkZGVkIHRvIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICovXG4gIGFkZFNlbGZUb1pyOiBmdW5jdGlvbiAoenIpIHtcbiAgICB0aGlzLl9fenIgPSB6cjsgLy8g5re75Yqg5Yqo55S7XG5cbiAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG5cbiAgICBpZiAoYW5pbWF0b3JzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgdGhpcy5jbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgc2VsZiBmcm9tIHpyZW5kZXIgaW5zdGFuY2UuXG4gICAqIE5vdCByZWN1cnNpdmVseSBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGVsZW1lbnQgYWRkZWQgdG8gc3RvcmFnZS5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgKi9cbiAgcmVtb3ZlU2VsZkZyb21acjogZnVuY3Rpb24gKHpyKSB7XG4gICAgdGhpcy5fX3pyID0gbnVsbDsgLy8g56e76Zmk5Yqo55S7XG5cbiAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG5cbiAgICBpZiAoYW5pbWF0b3JzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB6ci5hbmltYXRpb24ucmVtb3ZlQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgdGhpcy5jbGlwUGF0aC5yZW1vdmVTZWxmRnJvbVpyKHpyKTtcbiAgICB9XG4gIH1cbn07XG56clV0aWwubWl4aW4oRWxlbWVudCwgQW5pbWF0YWJsZSk7XG56clV0aWwubWl4aW4oRWxlbWVudCwgVHJhbnNmb3JtYWJsZSk7XG56clV0aWwubWl4aW4oRWxlbWVudCwgRXZlbnRmdWwpO1xudmFyIF9kZWZhdWx0ID0gRWxlbWVudDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL0VsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiB6cmVuZGVyOiDnlJ/miJDllK/kuIBpZFxuICpcbiAqIEBhdXRob3IgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xudmFyIGlkU3RhcnQgPSAweDA5MDc7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICByZXR1cm4gaWRTdGFydCsrO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL2d1aWQuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog5LqL5Lu25omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbnZhciBhcnJ5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4vKipcbiAqIOS6i+S7tuWIhuWPkeWZqFxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgRXZlbnRmdWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuXyRoYW5kbGVycyA9IHt9O1xufTtcblxuRXZlbnRmdWwucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRXZlbnRmdWwsXG5cbiAgLyoqXG4gICAqIOWNleasoeinpuWPkee7keWumu+8jHRyaWdnZXLlkI7plIDmr4FcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOWTjeW6lOWHveaVsFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKi9cbiAgb25lOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICBpZiAoIWhhbmRsZXIgfHwgIWV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIV9oW2V2ZW50XSkge1xuICAgICAgX2hbZXZlbnRdID0gW107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChfaFtldmVudF1baV0uaCA9PT0gaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICBoOiBoYW5kbGVyLFxuICAgICAgb25lOiB0cnVlLFxuICAgICAgY3R4OiBjb250ZXh0IHx8IHRoaXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDnu5Hlrprkuovku7ZcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAqL1xuICBvbjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgIF9oW2V2ZW50XSA9IFtdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2hbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2hbZXZlbnRdLnB1c2goe1xuICAgICAgaDogaGFuZGxlcixcbiAgICAgIG9uZTogZmFsc2UsXG4gICAgICBjdHg6IGNvbnRleHQgfHwgdGhpc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOaYr+WQpue7keWumuS6huS6i+S7tlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBldmVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNTaWxlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcbiAgICByZXR1cm4gX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOino+e7keS6i+S7tlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXSDkuovku7blpITnkIblh73mlbBcbiAgICovXG4gIG9mZjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgaWYgKCFldmVudCkge1xuICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaWYgKF9oW2V2ZW50XSkge1xuICAgICAgICB2YXIgbmV3TGlzdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gX2hbZXZlbnRdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChfaFtldmVudF1baV1bJ2gnXSAhPSBoYW5kbGVyKSB7XG4gICAgICAgICAgICBuZXdMaXN0LnB1c2goX2hbZXZlbnRdW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfaFtldmVudF0gPSBuZXdMaXN0O1xuICAgICAgfVxuXG4gICAgICBpZiAoX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5LqL5Lu25YiG5Y+RXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodGhpcy5fJGhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgaWYgKGFyZ0xlbiA+IDMpIHtcbiAgICAgICAgYXJncyA9IGFycnlTbGljZS5jYWxsKGFyZ3MsIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnNbdHlwZV07XG4gICAgICB2YXIgbGVuID0gX2gubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgLy8gT3B0aW1pemUgYWR2aXNlIGZyb20gYmFja2JvbmVcbiAgICAgICAgc3dpdGNoIChhcmdMZW4pIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoX2hbaV1bJ2N0eCddKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoX2hbaV1bJ2N0eCddLCBhcmdzWzFdKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoX2hbaV1bJ2N0eCddLCBhcmdzWzFdLCBhcmdzWzJdKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gaGF2ZSBtb3JlIHRoYW4gMiBnaXZlbiBhcmd1bWVudHNcbiAgICAgICAgICAgIF9oW2ldWydoJ10uYXBwbHkoX2hbaV1bJ2N0eCddLCBhcmdzKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2hbaV1bJ29uZSddKSB7XG4gICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgbGVuLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOW4puaciWNvbnRleHTnmoTkuovku7bliIblj5EsIOacgOWQjuS4gOS4quWPguaVsOaYr+S6i+S7tuWbnuiwg+eahGNvbnRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gICAqL1xuICB0cmlnZ2VyV2l0aENvbnRleHQ6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHRoaXMuXyRoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGlmIChhcmdMZW4gPiA0KSB7XG4gICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgdmFyIGxlbiA9IF9oLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSwgYXJnc1syXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICBfaFtpXVsnaCddLmFwcGx5KGN0eCwgYXJncyk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgIF9oLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59OyAvLyDlr7nosaHlj6/ku6XpgJrov4cgb254eHh4IOe7keWumuS6i+S7tlxuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmNsaWNrXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW92ZXJcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3V0XG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW1vdmVcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNld2hlZWxcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlZG93blxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V1cFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ1xuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ3N0YXJ0XG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnZW5kXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnZW50ZXJcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdsZWF2ZVxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ292ZXJcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyb3BcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG52YXIgX2RlZmF1bHQgPSBFdmVudGZ1bDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWF0cml4ID0gcmVxdWlyZShcIi4uL2NvcmUvbWF0cml4XCIpO1xuXG52YXIgdmVjdG9yID0gcmVxdWlyZShcIi4uL2NvcmUvdmVjdG9yXCIpO1xuXG4vKipcbiAqIOaPkOS+m+WPmOaNouaJqeWxlVxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgbUlkZW50aXR5ID0gbWF0cml4LmlkZW50aXR5O1xudmFyIEVQU0lMT04gPSA1ZS01O1xuXG5mdW5jdGlvbiBpc05vdEFyb3VuZFplcm8odmFsKSB7XG4gIHJldHVybiB2YWwgPiBFUFNJTE9OIHx8IHZhbCA8IC1FUFNJTE9OO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgVHJhbnNmb3JtYWJsZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9OyAvLyBJZiB0aGVyZSBhcmUgbm8gZ2l2ZW4gcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZVxuXG4gIGlmICghb3B0cy5wb3NpdGlvbikge1xuICAgIC8qKlxuICAgICAqIOW5s+enu1xuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAZGVmYXVsdCBbMCwgMF1cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gWzAsIDBdO1xuICB9XG5cbiAgaWYgKG9wdHMucm90YXRpb24gPT0gbnVsbCkge1xuICAgIC8qKlxuICAgICAqIOaXi+i9rFxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gIH1cblxuICBpZiAoIW9wdHMuc2NhbGUpIHtcbiAgICAvKipcbiAgICAgKiDnvKnmlL5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQGRlZmF1bHQgWzEsIDFdXG4gICAgICovXG4gICAgdGhpcy5zY2FsZSA9IFsxLCAxXTtcbiAgfVxuICAvKipcbiAgICog5peL6L2s5ZKM57yp5pS+55qE5Y6f54K5XG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cblxuXG4gIHRoaXMub3JpZ2luID0gdGhpcy5vcmlnaW4gfHwgbnVsbDtcbn07XG5cbnZhciB0cmFuc2Zvcm1hYmxlUHJvdG8gPSBUcmFuc2Zvcm1hYmxlLnByb3RvdHlwZTtcbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm0gPSBudWxsO1xuLyoqXG4gKiDliKTmlq3mmK/lkKbpnIDopoHmnInlnZDmoIflj5jmjaJcbiAqIOWmguaenOacieWdkOagh+WPmOaNoiwg5YiZ5LuOcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZeS7peWPiueItuiKgueCueeahHRyYW5zZm9ybeiuoeeul+WHuuiHqui6q+eahHRyYW5zZm9ybeefqemYtVxuICovXG5cbnRyYW5zZm9ybWFibGVQcm90by5uZWVkTG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc05vdEFyb3VuZFplcm8odGhpcy5yb3RhdGlvbikgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMucG9zaXRpb25bMF0pIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzFdKSB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVswXSAtIDEpIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnNjYWxlWzFdIC0gMSk7XG59O1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8udXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gIHZhciBwYXJlbnRIYXNUcmFuc2Zvcm0gPSBwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybTtcbiAgdmFyIG5lZWRMb2NhbFRyYW5zZm9ybSA9IHRoaXMubmVlZExvY2FsVHJhbnNmb3JtKCk7XG4gIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKCEobmVlZExvY2FsVHJhbnNmb3JtIHx8IHBhcmVudEhhc1RyYW5zZm9ybSkpIHtcbiAgICBtICYmIG1JZGVudGl0eShtKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBtID0gbSB8fCBtYXRyaXguY3JlYXRlKCk7XG5cbiAgaWYgKG5lZWRMb2NhbFRyYW5zZm9ybSkge1xuICAgIHRoaXMuZ2V0TG9jYWxUcmFuc2Zvcm0obSk7XG4gIH0gZWxzZSB7XG4gICAgbUlkZW50aXR5KG0pO1xuICB9IC8vIOW6lOeUqOeItuiKgueCueWPmOaNolxuXG5cbiAgaWYgKHBhcmVudEhhc1RyYW5zZm9ybSkge1xuICAgIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICAgIG1hdHJpeC5tdWwobSwgcGFyZW50LnRyYW5zZm9ybSwgbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdHJpeC5jb3B5KG0sIHBhcmVudC50cmFuc2Zvcm0pO1xuICAgIH1cbiAgfSAvLyDkv53lrZjov5nkuKrlj5jmjaLnn6npmLVcblxuXG4gIHRoaXMudHJhbnNmb3JtID0gbTtcbiAgdGhpcy5pbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybSB8fCBtYXRyaXguY3JlYXRlKCk7XG4gIG1hdHJpeC5pbnZlcnQodGhpcy5pbnZUcmFuc2Zvcm0sIG0pO1xufTtcblxudHJhbnNmb3JtYWJsZVByb3RvLmdldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgcmV0dXJuIFRyYW5zZm9ybWFibGUuZ2V0TG9jYWxUcmFuc2Zvcm0odGhpcywgbSk7XG59O1xuLyoqXG4gKiDlsIboh6rlt7HnmoR0cmFuc2Zvcm3lupTnlKjliLBjb250ZXh05LiKXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gKi9cblxuXG50cmFuc2Zvcm1hYmxlUHJvdG8uc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuXG4gIGlmIChtKSB7XG4gICAgY3R4LnNldFRyYW5zZm9ybShkcHIgKiBtWzBdLCBkcHIgKiBtWzFdLCBkcHIgKiBtWzJdLCBkcHIgKiBtWzNdLCBkcHIgKiBtWzRdLCBkcHIgKiBtWzVdKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbiAgfVxufTtcblxudHJhbnNmb3JtYWJsZVByb3RvLnJlc3RvcmVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xufTtcblxudmFyIHRtcFRyYW5zZm9ybSA9IFtdO1xuLyoqXG4gKiDliIbop6NgdHJhbnNmb3JtYOefqemYteWIsGBwb3NpdGlvbmAsIGByb3RhdGlvbmAsIGBzY2FsZWBcbiAqL1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8uZGVjb21wb3NlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybSkge1xuICAgIC8vIEdldCBsb2NhbCB0cmFuc2Zvcm0gYW5kIGRlY29tcG9zZSB0aGVtIHRvIHBvc2l0aW9uLCBzY2FsZSwgcm90YXRpb25cbiAgICBtYXRyaXgubXVsKHRtcFRyYW5zZm9ybSwgcGFyZW50LmludlRyYW5zZm9ybSwgbSk7XG4gICAgbSA9IHRtcFRyYW5zZm9ybTtcbiAgfVxuXG4gIHZhciBzeCA9IG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV07XG4gIHZhciBzeSA9IG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM107XG4gIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cbiAgaWYgKGlzTm90QXJvdW5kWmVybyhzeCAtIDEpKSB7XG4gICAgc3ggPSBNYXRoLnNxcnQoc3gpO1xuICB9XG5cbiAgaWYgKGlzTm90QXJvdW5kWmVybyhzeSAtIDEpKSB7XG4gICAgc3kgPSBNYXRoLnNxcnQoc3kpO1xuICB9XG5cbiAgaWYgKG1bMF0gPCAwKSB7XG4gICAgc3ggPSAtc3g7XG4gIH1cblxuICBpZiAobVszXSA8IDApIHtcbiAgICBzeSA9IC1zeTtcbiAgfVxuXG4gIHBvc2l0aW9uWzBdID0gbVs0XTtcbiAgcG9zaXRpb25bMV0gPSBtWzVdO1xuICBzY2FsZVswXSA9IHN4O1xuICBzY2FsZVsxXSA9IHN5O1xuICB0aGlzLnJvdGF0aW9uID0gTWF0aC5hdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xufTtcbi8qKlxuICogR2V0IGdsb2JhbCBzY2FsZVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG50cmFuc2Zvcm1hYmxlUHJvdG8uZ2V0R2xvYmFsU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIFsxLCAxXTtcbiAgfVxuXG4gIHZhciBzeCA9IE1hdGguc3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgdmFyIHN5ID0gTWF0aC5zcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuXG4gIGlmIChtWzBdIDwgMCkge1xuICAgIHN4ID0gLXN4O1xuICB9XG5cbiAgaWYgKG1bM10gPCAwKSB7XG4gICAgc3kgPSAtc3k7XG4gIH1cblxuICByZXR1cm4gW3N4LCBzeV07XG59O1xuLyoqXG4gKiDlj5jmjaLlnZDmoIfkvY3nva7liLAgc2hhcGUg55qE5bGA6YOo5Z2Q5qCH56m66Ze0XG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHZhciB2MiA9IFt4LCB5XTtcbiAgdmFyIGludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtO1xuXG4gIGlmIChpbnZUcmFuc2Zvcm0pIHtcbiAgICB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0odjIsIHYyLCBpbnZUcmFuc2Zvcm0pO1xuICB9XG5cbiAgcmV0dXJuIHYyO1xufTtcbi8qKlxuICog5Y+Y5o2i5bGA6YOo5Z2Q5qCH5L2N572u5Yiw5YWo5bGA5Z2Q5qCH56m66Ze0XG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybUNvb3JkVG9HbG9iYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICB2YXIgdjIgPSBbeCwgeV07XG4gIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgdHJhbnNmb3JtKTtcbiAgfVxuXG4gIHJldHVybiB2Mjtcbn07XG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRhcmdldC5vcmlnaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXQucm90YXRpb25cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRhcmdldC5wb3NpdGlvblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW21dXG4gKi9cblxuXG5UcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKHRhcmdldCwgbSkge1xuICBtID0gbSB8fCBbXTtcbiAgbUlkZW50aXR5KG0pO1xuICB2YXIgb3JpZ2luID0gdGFyZ2V0Lm9yaWdpbjtcbiAgdmFyIHNjYWxlID0gdGFyZ2V0LnNjYWxlIHx8IFsxLCAxXTtcbiAgdmFyIHJvdGF0aW9uID0gdGFyZ2V0LnJvdGF0aW9uIHx8IDA7XG4gIHZhciBwb3NpdGlvbiA9IHRhcmdldC5wb3NpdGlvbiB8fCBbMCwgMF07XG5cbiAgaWYgKG9yaWdpbikge1xuICAgIC8vIFRyYW5zbGF0ZSB0byBvcmlnaW5cbiAgICBtWzRdIC09IG9yaWdpblswXTtcbiAgICBtWzVdIC09IG9yaWdpblsxXTtcbiAgfVxuXG4gIG1hdHJpeC5zY2FsZShtLCBtLCBzY2FsZSk7XG5cbiAgaWYgKHJvdGF0aW9uKSB7XG4gICAgbWF0cml4LnJvdGF0ZShtLCBtLCByb3RhdGlvbik7XG4gIH1cblxuICBpZiAob3JpZ2luKSB7XG4gICAgLy8gVHJhbnNsYXRlIGJhY2sgZnJvbSBvcmlnaW5cbiAgICBtWzRdICs9IG9yaWdpblswXTtcbiAgICBtWzVdICs9IG9yaWdpblsxXTtcbiAgfVxuXG4gIG1bNF0gKz0gcG9zaXRpb25bMF07XG4gIG1bNV0gKz0gcG9zaXRpb25bMV07XG4gIHJldHVybiBtO1xufTtcblxudmFyIF9kZWZhdWx0ID0gVHJhbnNmb3JtYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL21peGluL1RyYW5zZm9ybWFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogM3gy55+p6Zi15pON5L2c57G7XG4gKiBAZXhwb3J0cyB6cmVuZGVyL3Rvb2wvbWF0cml4XG4gKi9cbnZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IEFycmF5IDogRmxvYXQzMkFycmF5O1xuLyoqXG4gKiDliJvlu7rkuIDkuKrljZXkvY3nn6npmLVcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDYpO1xuICBpZGVudGl0eShvdXQpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDorr7nva7nn6npmLXkuLrljZXkvY3nn6npmLVcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlpI3liLbnn6npmLVcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgbSkge1xuICBvdXRbMF0gPSBtWzBdO1xuICBvdXRbMV0gPSBtWzFdO1xuICBvdXRbMl0gPSBtWzJdO1xuICBvdXRbM10gPSBtWzNdO1xuICBvdXRbNF0gPSBtWzRdO1xuICBvdXRbNV0gPSBtWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDnn6npmLXnm7jkuZhcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG0yXG4gKi9cblxuXG5mdW5jdGlvbiBtdWwob3V0LCBtMSwgbTIpIHtcbiAgLy8gQ29uc2lkZXIgbWF0cml4Lm11bChtLCBtMiwgbSk7XG4gIC8vIHdoZXJlIG91dCBpcyB0aGUgc2FtZSBhcyBtMi5cbiAgLy8gU28gdXNlIHRlbXAgdmFyaWFibGUgdG8gZXNjYXBlIGVycm9yLlxuICB2YXIgb3V0MCA9IG0xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdO1xuICB2YXIgb3V0MSA9IG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdO1xuICB2YXIgb3V0MiA9IG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdO1xuICB2YXIgb3V0MyA9IG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdO1xuICB2YXIgb3V0NCA9IG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF07XG4gIHZhciBvdXQ1ID0gbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XTtcbiAgb3V0WzBdID0gb3V0MDtcbiAgb3V0WzFdID0gb3V0MTtcbiAgb3V0WzJdID0gb3V0MjtcbiAgb3V0WzNdID0gb3V0MztcbiAgb3V0WzRdID0gb3V0NDtcbiAgb3V0WzVdID0gb3V0NTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5bmz56e75Y+Y5o2iXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XSArIHZbMF07XG4gIG91dFs1XSA9IGFbNV0gKyB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDml4vovazlj5jmjaJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgdmFyIGFhID0gYVswXTtcbiAgdmFyIGFjID0gYVsyXTtcbiAgdmFyIGF0eCA9IGFbNF07XG4gIHZhciBhYiA9IGFbMV07XG4gIHZhciBhZCA9IGFbM107XG4gIHZhciBhdHkgPSBhWzVdO1xuICB2YXIgc3QgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgY3QgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhYSAqIGN0ICsgYWIgKiBzdDtcbiAgb3V0WzFdID0gLWFhICogc3QgKyBhYiAqIGN0O1xuICBvdXRbMl0gPSBhYyAqIGN0ICsgYWQgKiBzdDtcbiAgb3V0WzNdID0gLWFjICogc3QgKyBjdCAqIGFkO1xuICBvdXRbNF0gPSBjdCAqIGF0eCArIHN0ICogYXR5O1xuICBvdXRbNV0gPSBjdCAqIGF0eSAtIHN0ICogYXR4O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDnvKnmlL7lj5jmjaJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gdlxuICovXG5cblxuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciB2eCA9IHZbMF07XG4gIHZhciB2eSA9IHZbMV07XG4gIG91dFswXSA9IGFbMF0gKiB2eDtcbiAgb3V0WzFdID0gYVsxXSAqIHZ5O1xuICBvdXRbMl0gPSBhWzJdICogdng7XG4gIG91dFszXSA9IGFbM10gKiB2eTtcbiAgb3V0WzRdID0gYVs0XSAqIHZ4O1xuICBvdXRbNV0gPSBhWzVdICogdnk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaxgumAhuefqemYtVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGFhID0gYVswXTtcbiAgdmFyIGFjID0gYVsyXTtcbiAgdmFyIGF0eCA9IGFbNF07XG4gIHZhciBhYiA9IGFbMV07XG4gIHZhciBhZCA9IGFbM107XG4gIHZhciBhdHkgPSBhWzVdO1xuICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgb3V0WzJdID0gLWFjICogZGV0O1xuICBvdXRbM10gPSBhYSAqIGRldDtcbiAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMubXVsID0gbXVsO1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEFycmF5Q3RvciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gQXJyYXkgOiBGbG9hdDMyQXJyYXk7XG4vKipcbiAqIOWIm+W7uuS4gOS4quWQkemHj1xuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKHgsIHkpIHtcbiAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG5cbiAgaWYgKHggPT0gbnVsbCkge1xuICAgIHggPSAwO1xuICB9XG5cbiAgaWYgKHkgPT0gbnVsbCkge1xuICAgIHkgPSAwO1xuICB9XG5cbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5aSN5Yi25ZCR6YeP5pWw5o2uXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtWZWN0b3IyfVxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5YWL6ZqG5LiA5Liq5ZCR6YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZSh2KSB7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDIpO1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDorr7nva7lkJHph4/nmoTkuKTkuKrpoblcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge1ZlY3RvcjJ9IOe7k+aenFxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhO1xuICBvdXRbMV0gPSBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/nm7jliqBcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gKyB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP57yp5pS+5ZCO55u45YqgXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgdjEsIHYyLCBhKSB7XG4gIG91dFswXSA9IHYxWzBdICsgdjJbMF0gKiBhO1xuICBvdXRbMV0gPSB2MVsxXSArIHYyWzFdICogYTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP55u45YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gc3ViKG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdIC0gdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdIC0gdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+mVv+W6plxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBsZW4odikge1xuICByZXR1cm4gTWF0aC5zcXJ0KGxlblNxdWFyZSh2KSk7XG59XG5cbnZhciBsZW5ndGggPSBsZW47IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4vKipcbiAqIOWQkemHj+mVv+W6puW5s+aWuVxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gbGVuU3F1YXJlKHYpIHtcbiAgcmV0dXJuIHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV07XG59XG5cbnZhciBsZW5ndGhTcXVhcmUgPSBsZW5TcXVhcmU7XG4vKipcbiAqIOWQkemHj+S5mOazlVxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqL1xuXG5mdW5jdGlvbiBtdWwob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gKiB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gKiB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP6Zmk5rOVXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gZGl2KG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdIC8gdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdIC8gdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+eCueS5mFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gZG90KHYxLCB2Mikge1xuICByZXR1cm4gdjFbMF0gKiB2MlswXSArIHYxWzFdICogdjJbMV07XG59XG4vKipcbiAqIOWQkemHj+e8qeaUvlxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHBhcmFtIHtudW1iZXJ9IHNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgdiwgcykge1xuICBvdXRbMF0gPSB2WzBdICogcztcbiAgb3V0WzFdID0gdlsxXSAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+W9kuS4gOWMllxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgdikge1xuICB2YXIgZCA9IGxlbih2KTtcblxuICBpZiAoZCA9PT0gMCkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSB2WzBdIC8gZDtcbiAgICBvdXRbMV0gPSB2WzFdIC8gZDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOiuoeeul+WQkemHj+mXtOi3neemu1xuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gZGlzdGFuY2UodjEsIHYyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pICsgKHYxWzFdIC0gdjJbMV0pICogKHYxWzFdIC0gdjJbMV0pKTtcbn1cblxudmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxuICog5ZCR6YeP6Led56a75bmz5pa5XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gZGlzdGFuY2VTcXVhcmUodjEsIHYyKSB7XG4gIHJldHVybiAodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSkgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSk7XG59XG5cbnZhciBkaXN0U3F1YXJlID0gZGlzdGFuY2VTcXVhcmU7XG4vKipcbiAqIOaxgui0n+WQkemHj1xuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICovXG5cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIHYpIHtcbiAgb3V0WzBdID0gLXZbMF07XG4gIG91dFsxXSA9IC12WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmj5LlgLzkuKTkuKrngrlcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICovXG5cblxuZnVuY3Rpb24gbGVycChvdXQsIHYxLCB2MiwgdCkge1xuICBvdXRbMF0gPSB2MVswXSArIHQgKiAodjJbMF0gLSB2MVswXSk7XG4gIG91dFsxXSA9IHYxWzFdICsgdCAqICh2MlsxXSAtIHYxWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog55+p6Zi15bem5LmY5ZCR6YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG1cbiAqL1xuXG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKG91dCwgdiwgbSkge1xuICB2YXIgeCA9IHZbMF07XG4gIHZhciB5ID0gdlsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmsYLkuKTkuKrlkJHph4/mnIDlsI/lgLxcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBtaW4ob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4odjFbMF0sIHYyWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4odjFbMV0sIHYyWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5rGC5Lik5Liq5ZCR6YeP5pyA5aSn5YC8XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gbWF4KG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KHYxWzBdLCB2MlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KHYxWzFdLCB2MlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnNjYWxlQW5kQWRkID0gc2NhbGVBbmRBZGQ7XG5leHBvcnRzLnN1YiA9IHN1YjtcbmV4cG9ydHMubGVuID0gbGVuO1xuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLmxlblNxdWFyZSA9IGxlblNxdWFyZTtcbmV4cG9ydHMubGVuZ3RoU3F1YXJlID0gbGVuZ3RoU3F1YXJlO1xuZXhwb3J0cy5tdWwgPSBtdWw7XG5leHBvcnRzLmRpdiA9IGRpdjtcbmV4cG9ydHMuZG90ID0gZG90O1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5leHBvcnRzLmRpc3QgPSBkaXN0O1xuZXhwb3J0cy5kaXN0YW5jZVNxdWFyZSA9IGRpc3RhbmNlU3F1YXJlO1xuZXhwb3J0cy5kaXN0U3F1YXJlID0gZGlzdFNxdWFyZTtcbmV4cG9ydHMubmVnYXRlID0gbmVnYXRlO1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMuYXBwbHlUcmFuc2Zvcm0gPSBhcHBseVRyYW5zZm9ybTtcbmV4cG9ydHMubWluID0gbWluO1xuZXhwb3J0cy5tYXggPSBtYXg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQW5pbWF0b3IgPSByZXF1aXJlKFwiLi4vYW5pbWF0aW9uL0FuaW1hdG9yXCIpO1xuXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2NvcmUvbG9nXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaXNTdHJpbmcgPSBfdXRpbC5pc1N0cmluZztcbnZhciBpc0Z1bmN0aW9uID0gX3V0aWwuaXNGdW5jdGlvbjtcbnZhciBpc09iamVjdCA9IF91dGlsLmlzT2JqZWN0O1xudmFyIGlzQXJyYXlMaWtlID0gX3V0aWwuaXNBcnJheUxpa2U7XG52YXIgaW5kZXhPZiA9IF91dGlsLmluZGV4T2Y7XG5cbi8qKlxuICogQGFsaWFzIG1vZHVlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBBbmltYXRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3I+fVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIHRoaXMuYW5pbWF0b3JzID0gW107XG59O1xuXG5BbmltYXRhYmxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEFuaW1hdGFibGUsXG5cbiAgLyoqXG4gICAqIOWKqOeUu1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBmZXRjaCB2YWx1ZSBmcm9tIG9iamVjdCwgbGlrZSAnYS5iLmMnLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtsb29wXSBXaGV0aGVyIHRvIGxvb3AgYW5pbWF0aW9uLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqIEBleGFtcGxlOlxuICAgKiAgICAgZWwuYW5pbWF0ZSgnc3R5bGUnLCBmYWxzZSlcbiAgICogICAgICAgICAud2hlbigxMDAwLCB7eDogMTB9IClcbiAgICogICAgICAgICAuZG9uZShmdW5jdGlvbigpeyAvLyBBbmltYXRpb24gZG9uZSB9KVxuICAgKiAgICAgICAgIC5zdGFydCgpXG4gICAqL1xuICBhbmltYXRlOiBmdW5jdGlvbiAocGF0aCwgbG9vcCkge1xuICAgIHZhciB0YXJnZXQ7XG4gICAgdmFyIGFuaW1hdGluZ1NoYXBlID0gZmFsc2U7XG4gICAgdmFyIGVsID0gdGhpcztcbiAgICB2YXIgenIgPSB0aGlzLl9fenI7XG5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdmFyIHBhdGhTcGxpdHRlZCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgIHZhciBwcm9wID0gZWw7IC8vIElmIGFuaW1hdGluZyBzaGFwZVxuXG4gICAgICBhbmltYXRpbmdTaGFwZSA9IHBhdGhTcGxpdHRlZFswXSA9PT0gJ3NoYXBlJztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoU3BsaXR0ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghcHJvcCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcCA9IHByb3BbcGF0aFNwbGl0dGVkW2ldXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgdGFyZ2V0ID0gcHJvcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0ID0gZWw7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIGxvZygnUHJvcGVydHkgXCInICsgcGF0aCArICdcIiBpcyBub3QgZXhpc3RlZCBpbiBlbGVtZW50ICcgKyBlbC5pZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFuaW1hdG9ycyA9IGVsLmFuaW1hdG9ycztcbiAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IodGFyZ2V0LCBsb29wKTtcbiAgICBhbmltYXRvci5kdXJpbmcoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgZWwuZGlydHkoYW5pbWF0aW5nU2hhcGUpO1xuICAgIH0pLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gRklYTUUgQW5pbWF0b3Igd2lsbCBub3QgYmUgcmVtb3ZlZCBpZiB1c2UgYEFuaW1hdG9yI3N0b3BgIHRvIHN0b3AgYW5pbWF0aW9uXG4gICAgICBhbmltYXRvcnMuc3BsaWNlKGluZGV4T2YoYW5pbWF0b3JzLCBhbmltYXRvciksIDEpO1xuICAgIH0pO1xuICAgIGFuaW1hdG9ycy5wdXNoKGFuaW1hdG9yKTsgLy8gSWYgYW5pbWF0ZSBhZnRlciBhZGRlZCB0byB0aGUgenJlbmRlclxuXG4gICAgaWYgKHpyKSB7XG4gICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRvcjtcbiAgfSxcblxuICAvKipcbiAgICog5YGc5q2i5Yqo55S7XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZFRvTGFzdCBJZiBtb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICovXG4gIHN0b3BBbmltYXRpb246IGZ1bmN0aW9uIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgIHZhciBsZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYW5pbWF0b3JzW2ldLnN0b3AoZm9yd2FyZFRvTGFzdCk7XG4gICAgfVxuXG4gICAgYW5pbWF0b3JzLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhdXRpb246IHRoaXMgbWV0aG9kIHdpbGwgc3RvcCBwcmV2aW91cyBhbmltYXRpb24uXG4gICAqIFNvIGRvIG5vdCB1c2UgdGhpcyBtZXRob2QgdG8gb25lIGVsZW1lbnQgdHdpY2UgYmVmb3JlXG4gICAqIGFuaW1hdGlvbiBzdGFydHMsIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF0gVGltZSBpbiBtc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Vhc2luZz0nbGluZWFyJ11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmb3JjZUFuaW1hdGVdIFByZXZlbnQgc3RvcCBhbmltYXRpb24gYW5kIGNhbGxiYWNrXG4gICAqICAgICAgICBpbW1lZGllbnRseSB3aGVuIHRhcmdldCB2YWx1ZXMgYXJlIHRoZSBzYW1lIGFzIGN1cnJlbnQgdmFsdWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0sIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgKlxuICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zLCB3aXRoIGN1YmljT3V0IGVhc2luZ1xuICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICogICAgICBzaGFwZToge1xuICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAqICAgICAgfSxcbiAgICogICAgICBzdHlsZToge1xuICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgKiAgICAgIH1cbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0sIDEwMCwgMTAwLCAnY3ViaWNPdXQnLCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICovXG4gIC8vIFRPRE8gUmV0dXJuIGFuaW1hdGlvbiBrZXlcbiAgYW5pbWF0ZVRvOiBmdW5jdGlvbiAodGFyZ2V0LCB0aW1lLCBkZWxheSwgZWFzaW5nLCBjYWxsYmFjaywgZm9yY2VBbmltYXRlKSB7XG4gICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgaWYgKGlzU3RyaW5nKGRlbGF5KSkge1xuICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICBlYXNpbmcgPSBkZWxheTtcbiAgICAgIGRlbGF5ID0gMDtcbiAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGRlbGF5LCBjYWxsYmFjayk7XG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihlYXNpbmcpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgICBlYXNpbmcgPSAnbGluZWFyJztcbiAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgfSAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBjYWxsYmFjayk7XG4gICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGRlbGF5KSkge1xuICAgICAgICAgIGNhbGxiYWNrID0gZGVsYXk7XG4gICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQsIGNhbGxiYWNrKVxuICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRpbWUpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHRpbWU7XG4gICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgIH0gLy8gYW5pbWF0ZVRvKHRhcmdldClcbiAgICAgICAgICBlbHNlIGlmICghdGltZSkge1xuICAgICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgICAgfSAvLyBTdG9wIGFsbCBwcmV2aW91cyBhbmltYXRpb25zXG5cblxuICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuXG4gICAgdGhpcy5fYW5pbWF0ZVRvU2hhbGxvdygnJywgdGhpcywgdGFyZ2V0LCB0aW1lLCBkZWxheSk7IC8vIEFuaW1hdG9ycyBtYXkgYmUgcmVtb3ZlZCBpbW1lZGlhdGVseSBhZnRlciBzdGFydFxuICAgIC8vIGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gYW5pbWF0ZVxuXG5cbiAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnMuc2xpY2UoKTtcbiAgICB2YXIgY291bnQgPSBhbmltYXRvcnMubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIGNvdW50LS07XG5cbiAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9IC8vIE5vIGFuaW1hdG9ycy4gVGhpcyBzaG91bGQgYmUgY2hlY2tlZCBiZWZvcmUgYW5pbWF0b3JzW2ldLnN0YXJ0KCksXG4gICAgLy8gYmVjYXVzZSAnZG9uZScgbWF5IGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGlmIG5vIG5lZWQgdG8gYW5pbWF0ZS5cblxuXG4gICAgaWYgKCFjb3VudCkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9IC8vIFN0YXJ0IGFmdGVyIGFsbCBhbmltYXRvcnMgY3JlYXRlZFxuICAgIC8vIEluY2FzZSBhbnkgYW5pbWF0b3IgaXMgZG9uZSBpbW1lZGlhdGVseSB3aGVuIGFsbCBhbmltYXRpb24gcHJvcGVydGllcyBhcmUgbm90IGNoYW5nZWRcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFuaW1hdG9yc1tpXS5kb25lKGRvbmUpLnN0YXJ0KGVhc2luZywgZm9yY2VBbmltYXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoPScnXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2U9dGhpc1xuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT01MDBdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIC8vIEFuaW1hdGUgcG9zaXRpb25cbiAgICogIGVsLl9hbmltYXRlVG9TaGFsbG93KHtcbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0pXG4gICAqXG4gICAqICAvLyBBbmltYXRlIHNoYXBlLCBzdHlsZSBhbmQgcG9zaXRpb24gaW4gMTAwbXMsIGRlbGF5ZWQgMTAwbXNcbiAgICogIGVsLl9hbmltYXRlVG9TaGFsbG93KHtcbiAgICogICAgICBzaGFwZToge1xuICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAqICAgICAgfSxcbiAgICogICAgICBzdHlsZToge1xuICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgKiAgICAgIH1cbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0sIDEwMCwgMTAwKVxuICAgKi9cbiAgX2FuaW1hdGVUb1NoYWxsb3c6IGZ1bmN0aW9uIChwYXRoLCBzb3VyY2UsIHRhcmdldCwgdGltZSwgZGVsYXkpIHtcbiAgICB2YXIgb2JqU2hhbGxvdyA9IHt9O1xuICAgIHZhciBwcm9wZXJ0eUNvdW50ID0gMDtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gdGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc09iamVjdCh0YXJnZXRbbmFtZV0pICYmICFpc0FycmF5TGlrZSh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZVRvU2hhbGxvdyhwYXRoID8gcGF0aCArICcuJyArIG5hbWUgOiBuYW1lLCBzb3VyY2VbbmFtZV0sIHRhcmdldFtuYW1lXSwgdGltZSwgZGVsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9ialNoYWxsb3dbbmFtZV0gPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgcHJvcGVydHlDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIC8vIEF0dHIgZGlyZWN0bHkgaWYgbm90IGhhcyBwcm9wZXJ0eVxuICAgICAgICAvLyBGSVhNRSwgaWYgc29tZSBwcm9wZXJ0eSBub3QgbmVlZGVkIGZvciBlbGVtZW50ID9cbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgdGhpcy5hdHRyKG5hbWUsIHRhcmdldFtuYW1lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2hhcGUgb3Igc3R5bGVcbiAgICAgICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgICAgICBwcm9wc1twYXRoXSA9IHt9O1xuICAgICAgICAgIHByb3BzW3BhdGhdW25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgIHRoaXMuYXR0cihwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvcGVydHlDb3VudCA+IDApIHtcbiAgICAgIHRoaXMuYW5pbWF0ZShwYXRoLCBmYWxzZSkud2hlbih0aW1lID09IG51bGwgPyA1MDAgOiB0aW1lLCBvYmpTaGFsbG93KS5kZWxheShkZWxheSB8fCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEFuaW1hdGFibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xpcCA9IHJlcXVpcmUoXCIuL0NsaXBcIik7XG5cbnZhciBjb2xvciA9IHJlcXVpcmUoXCIuLi90b29sL2NvbG9yXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaXNBcnJheUxpa2UgPSBfdXRpbC5pc0FycmF5TGlrZTtcblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvYW5pbWF0aW9uL0FuaW1hdG9yXG4gKi9cbnZhciBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBkZWZhdWx0R2V0dGVyKHRhcmdldCwga2V5KSB7XG4gIHJldHVybiB0YXJnZXRba2V5XTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFNldHRlcih0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbn1cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihwMCwgcDEsIHBlcmNlbnQpIHtcbiAgcmV0dXJuIChwMSAtIHAwKSAqIHBlcmNlbnQgKyBwMDtcbn1cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBwMFxuICogQHBhcmFtICB7c3RyaW5nfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVN0cmluZyhwMCwgcDEsIHBlcmNlbnQpIHtcbiAgcmV0dXJuIHBlcmNlbnQgPiAwLjUgPyBwMSA6IHAwO1xufVxuLyoqXG4gKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAqIEBwYXJhbSAge0FycmF5fSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICovXG5cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHBlcmNlbnQsIG91dCwgYXJyRGltKSB7XG4gIHZhciBsZW4gPSBwMC5sZW5ndGg7XG5cbiAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb3V0W2ldID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV0sIHAxW2ldLCBwZXJjZW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbjIgPSBsZW4gJiYgcDBbMF0ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgb3V0W2ldW2pdID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV1bal0sIHAxW2ldW2pdLCBwZXJjZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gYXJyMCBpcyBzb3VyY2UgYXJyYXksIGFycjEgaXMgdGFyZ2V0IGFycmF5LlxuLy8gRG8gc29tZSBwcmVwcm9jZXNzIHRvIGF2b2lkIGVycm9yIGhhcHBlbmVkIHdoZW4gaW50ZXJwb2xhdGluZyBmcm9tIGFycjAgdG8gYXJyMVxuXG5cbmZ1bmN0aW9uIGZpbGxBcnIoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gIHZhciBhcnIwTGVuID0gYXJyMC5sZW5ndGg7XG4gIHZhciBhcnIxTGVuID0gYXJyMS5sZW5ndGg7XG5cbiAgaWYgKGFycjBMZW4gIT09IGFycjFMZW4pIHtcbiAgICAvLyBGSVhNRSBOb3Qgd29yayBmb3IgVHlwZWRBcnJheVxuICAgIHZhciBpc1ByZXZpb3VzTGFyZ2VyID0gYXJyMExlbiA+IGFycjFMZW47XG5cbiAgICBpZiAoaXNQcmV2aW91c0xhcmdlcikge1xuICAgICAgLy8gQ3V0IHRoZSBwcmV2aW91c1xuICAgICAgYXJyMC5sZW5ndGggPSBhcnIxTGVuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaWxsIHRoZSBwcmV2aW91c1xuICAgICAgZm9yICh2YXIgaSA9IGFycjBMZW47IGkgPCBhcnIxTGVuOyBpKyspIHtcbiAgICAgICAgYXJyMC5wdXNoKGFyckRpbSA9PT0gMSA/IGFycjFbaV0gOiBhcnJheVNsaWNlLmNhbGwoYXJyMVtpXSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBIYW5kbGluZyBOYU4gdmFsdWVcblxuXG4gIHZhciBsZW4yID0gYXJyMFswXSAmJiBhcnIwWzBdLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycjAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgICBpZiAoaXNOYU4oYXJyMFtpXSkpIHtcbiAgICAgICAgYXJyMFtpXSA9IGFycjFbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgIGlmIChpc05hTihhcnIwW2ldW2pdKSkge1xuICAgICAgICAgIGFycjBbaV1bal0gPSBhcnIxW2ldW2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBwYXJhbSAge0FycmF5fSBhcnIwXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyMVxuICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5U2FtZShhcnIwLCBhcnIxLCBhcnJEaW0pIHtcbiAgaWYgKGFycjAgPT09IGFycjEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsZW4gPSBhcnIwLmxlbmd0aDtcblxuICBpZiAobGVuICE9PSBhcnIxLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXJyMFtpXSAhPT0gYXJyMVtpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsZW4yID0gYXJyMFswXS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICBpZiAoYXJyMFtpXVtqXSAhPT0gYXJyMVtpXVtqXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBhcnJheVxuICogQHBhcmFtICB7QXJyYXl9IHAwXG4gKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAqIEBwYXJhbSAge0FycmF5fSBwMlxuICogQHBhcmFtICB7QXJyYXl9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gKi9cblxuXG5mdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzLCBvdXQsIGFyckRpbSkge1xuICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuXG4gIGlmIChhcnJEaW0gPT0gMSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG91dFtpXSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdCwgdDIsIHQzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbjIgPSBwMFswXS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICBvdXRbaV1bal0gPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDBbaV1bal0sIHAxW2ldW2pdLCBwMltpXVtqXSwgcDNbaV1bal0sIHQsIHQyLCB0Myk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIENhdG11bGwgUm9tIGludGVycG9sYXRlIG51bWJlclxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHQyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHQzXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mykge1xuICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gIHZhciB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgcmV0dXJuICgyICogKHAxIC0gcDIpICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIChwMSAtIHAyKSAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XG59XG5cbmZ1bmN0aW9uIGNsb25lVmFsdWUodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICBpZiAoaXNBcnJheUxpa2UodmFsdWVbMF0pKSB7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmV0LnB1c2goYXJyYXlTbGljZS5jYWxsKHZhbHVlW2ldKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5U2xpY2UuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJnYmEyU3RyaW5nKHJnYmEpIHtcbiAgcmdiYVswXSA9IE1hdGguZmxvb3IocmdiYVswXSk7XG4gIHJnYmFbMV0gPSBNYXRoLmZsb29yKHJnYmFbMV0pO1xuICByZ2JhWzJdID0gTWF0aC5mbG9vcihyZ2JhWzJdKTtcbiAgcmV0dXJuICdyZ2JhKCcgKyByZ2JhLmpvaW4oJywnKSArICcpJztcbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlEaW0oa2V5ZnJhbWVzKSB7XG4gIHZhciBsYXN0VmFsdWUgPSBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnZhbHVlO1xuICByZXR1cm4gaXNBcnJheUxpa2UobGFzdFZhbHVlICYmIGxhc3RWYWx1ZVswXSkgPyAyIDogMTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHJhY2tDbGlwKGFuaW1hdG9yLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSwga2V5ZnJhbWVzLCBwcm9wTmFtZSwgZm9yY2VBbmltYXRlKSB7XG4gIHZhciBnZXR0ZXIgPSBhbmltYXRvci5fZ2V0dGVyO1xuICB2YXIgc2V0dGVyID0gYW5pbWF0b3IuX3NldHRlcjtcbiAgdmFyIHVzZVNwbGluZSA9IGVhc2luZyA9PT0gJ3NwbGluZSc7XG4gIHZhciB0cmFja0xlbiA9IGtleWZyYW1lcy5sZW5ndGg7XG5cbiAgaWYgKCF0cmFja0xlbikge1xuICAgIHJldHVybjtcbiAgfSAvLyBHdWVzcyBkYXRhIHR5cGVcblxuXG4gIHZhciBmaXJzdFZhbCA9IGtleWZyYW1lc1swXS52YWx1ZTtcbiAgdmFyIGlzVmFsdWVBcnJheSA9IGlzQXJyYXlMaWtlKGZpcnN0VmFsKTtcbiAgdmFyIGlzVmFsdWVDb2xvciA9IGZhbHNlO1xuICB2YXIgaXNWYWx1ZVN0cmluZyA9IGZhbHNlOyAvLyBGb3IgdmVydGljZXMgbW9ycGhpbmdcblxuICB2YXIgYXJyRGltID0gaXNWYWx1ZUFycmF5ID8gZ2V0QXJyYXlEaW0oa2V5ZnJhbWVzKSA6IDA7XG4gIHZhciB0cmFja01heFRpbWU7IC8vIFNvcnQga2V5ZnJhbWUgYXMgYXNjZW5kaW5nXG5cbiAga2V5ZnJhbWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuICB9KTtcbiAgdHJhY2tNYXhUaW1lID0ga2V5ZnJhbWVzW3RyYWNrTGVuIC0gMV0udGltZTsgLy8gUGVyY2VudHMgb2YgZWFjaCBrZXlmcmFtZVxuXG4gIHZhciBrZlBlcmNlbnRzID0gW107IC8vIFZhbHVlIG9mIGVhY2gga2V5ZnJhbWVcblxuICB2YXIga2ZWYWx1ZXMgPSBbXTtcbiAgdmFyIHByZXZWYWx1ZSA9IGtleWZyYW1lc1swXS52YWx1ZTtcbiAgdmFyIGlzQWxsVmFsdWVFcXVhbCA9IHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja0xlbjsgaSsrKSB7XG4gICAga2ZQZXJjZW50cy5wdXNoKGtleWZyYW1lc1tpXS50aW1lIC8gdHJhY2tNYXhUaW1lKTsgLy8gQXNzdW1lIHZhbHVlIGlzIGEgY29sb3Igd2hlbiBpdCBpcyBhIHN0cmluZ1xuXG4gICAgdmFyIHZhbHVlID0ga2V5ZnJhbWVzW2ldLnZhbHVlOyAvLyBDaGVjayBpZiB2YWx1ZSBpcyBlcXVhbCwgZGVlcCBjaGVjayBpZiB2YWx1ZSBpcyBhcnJheVxuXG4gICAgaWYgKCEoaXNWYWx1ZUFycmF5ICYmIGlzQXJyYXlTYW1lKHZhbHVlLCBwcmV2VmFsdWUsIGFyckRpbSkgfHwgIWlzVmFsdWVBcnJheSAmJiB2YWx1ZSA9PT0gcHJldlZhbHVlKSkge1xuICAgICAgaXNBbGxWYWx1ZUVxdWFsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJldlZhbHVlID0gdmFsdWU7IC8vIFRyeSBjb252ZXJ0aW5nIGEgc3RyaW5nIHRvIGEgY29sb3IgYXJyYXlcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBjb2xvckFycmF5ID0gY29sb3IucGFyc2UodmFsdWUpO1xuXG4gICAgICBpZiAoY29sb3JBcnJheSkge1xuICAgICAgICB2YWx1ZSA9IGNvbG9yQXJyYXk7XG4gICAgICAgIGlzVmFsdWVDb2xvciA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc1ZhbHVlU3RyaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBrZlZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIGlmICghZm9yY2VBbmltYXRlICYmIGlzQWxsVmFsdWVFcXVhbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSBrZlZhbHVlc1t0cmFja0xlbiAtIDFdOyAvLyBQb2x5ZmlsbCBhcnJheSBhbmQgTmFOIHZhbHVlXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja0xlbiAtIDE7IGkrKykge1xuICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgIGZpbGxBcnIoa2ZWYWx1ZXNbaV0sIGxhc3RWYWx1ZSwgYXJyRGltKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzTmFOKGtmVmFsdWVzW2ldKSAmJiAhaXNOYU4obGFzdFZhbHVlKSAmJiAhaXNWYWx1ZVN0cmluZyAmJiAhaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgIGtmVmFsdWVzW2ldID0gbGFzdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzVmFsdWVBcnJheSAmJiBmaWxsQXJyKGdldHRlcihhbmltYXRvci5fdGFyZ2V0LCBwcm9wTmFtZSksIGxhc3RWYWx1ZSwgYXJyRGltKTsgLy8gQ2FjaGUgdGhlIGtleSBvZiBsYXN0IGZyYW1lIHRvIHNwZWVkIHVwIHdoZW5cbiAgLy8gYW5pbWF0aW9uIHBsYXliYWNrIGlzIHNlcXVlbmN5XG5cbiAgdmFyIGxhc3RGcmFtZSA9IDA7XG4gIHZhciBsYXN0RnJhbWVQZXJjZW50ID0gMDtcbiAgdmFyIHN0YXJ0O1xuICB2YXIgdztcbiAgdmFyIHAwO1xuICB2YXIgcDE7XG4gIHZhciBwMjtcbiAgdmFyIHAzO1xuXG4gIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICB2YXIgcmdiYSA9IFswLCAwLCAwLCAwXTtcbiAgfVxuXG4gIHZhciBvbmZyYW1lID0gZnVuY3Rpb24gKHRhcmdldCwgcGVyY2VudCkge1xuICAgIC8vIEZpbmQgdGhlIHJhbmdlIGtleWZyYW1lc1xuICAgIC8vIGtmMS0tLS0ta2YyLS0tLS0tLS0tY3VycmVudC0tLS0tLS0ta2YzXG4gICAgLy8gZmluZCBrZjIgYW5kIGtmMyBhbmQgZG8gaW50ZXJwb2xhdGlvblxuICAgIHZhciBmcmFtZTsgLy8gSW4gdGhlIGVhc2luZyBmdW5jdGlvbiBsaWtlIGVsYXN0aWNPdXQsIHBlcmNlbnQgbWF5IGxlc3MgdGhhbiAwXG5cbiAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgIGZyYW1lID0gMDtcbiAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPCBsYXN0RnJhbWVQZXJjZW50KSB7XG4gICAgICAvLyBTdGFydCBmcm9tIG5leHQga2V5XG4gICAgICAvLyBQRU5ESU5HIHN0YXJ0IGZyb20gbGFzdEZyYW1lID9cbiAgICAgIHN0YXJ0ID0gTWF0aC5taW4obGFzdEZyYW1lICsgMSwgdHJhY2tMZW4gLSAxKTtcblxuICAgICAgZm9yIChmcmFtZSA9IHN0YXJ0OyBmcmFtZSA+PSAwOyBmcmFtZS0tKSB7XG4gICAgICAgIGlmIChrZlBlcmNlbnRzW2ZyYW1lXSA8PSBwZXJjZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUEVORElORyByZWFsbHkgbmVlZCB0byBkbyB0aGlzID9cblxuXG4gICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lLCB0cmFja0xlbiAtIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGZyYW1lID0gbGFzdEZyYW1lOyBmcmFtZSA8IHRyYWNrTGVuOyBmcmFtZSsrKSB7XG4gICAgICAgIGlmIChrZlBlcmNlbnRzW2ZyYW1lXSA+IHBlcmNlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lIC0gMSwgdHJhY2tMZW4gLSAyKTtcbiAgICB9XG5cbiAgICBsYXN0RnJhbWUgPSBmcmFtZTtcbiAgICBsYXN0RnJhbWVQZXJjZW50ID0gcGVyY2VudDtcbiAgICB2YXIgcmFuZ2UgPSBrZlBlcmNlbnRzW2ZyYW1lICsgMV0gLSBrZlBlcmNlbnRzW2ZyYW1lXTtcblxuICAgIGlmIChyYW5nZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB3ID0gKHBlcmNlbnQgLSBrZlBlcmNlbnRzW2ZyYW1lXSkgLyByYW5nZTtcbiAgICB9XG5cbiAgICBpZiAodXNlU3BsaW5lKSB7XG4gICAgICBwMSA9IGtmVmFsdWVzW2ZyYW1lXTtcbiAgICAgIHAwID0ga2ZWYWx1ZXNbZnJhbWUgPT09IDAgPyBmcmFtZSA6IGZyYW1lIC0gMV07XG4gICAgICBwMiA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAyID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAxXTtcbiAgICAgIHAzID0ga2ZWYWx1ZXNbZnJhbWUgPiB0cmFja0xlbiAtIDMgPyB0cmFja0xlbiAtIDEgOiBmcmFtZSArIDJdO1xuXG4gICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3LCBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksIGFyckRpbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsIHJnYmEsIDEpO1xuICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgIC8vIFN0cmluZyBpcyBzdGVwKDAuNSlcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcocDEsIHAyLCB3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgIGludGVycG9sYXRlQXJyYXkoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3LCBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksIGFyckRpbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgIGludGVycG9sYXRlQXJyYXkoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3LCByZ2JhLCAxKTtcbiAgICAgICAgICB2YWx1ZSA9IHJnYmEyU3RyaW5nKHJnYmEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAvLyBTdHJpbmcgaXMgc3RlcCgwLjUpXG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU3RyaW5nKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBpbnRlcnBvbGF0ZU51bWJlcihrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGVyKHRhcmdldCwgcHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGNsaXAgPSBuZXcgQ2xpcCh7XG4gICAgdGFyZ2V0OiBhbmltYXRvci5fdGFyZ2V0LFxuICAgIGxpZmU6IHRyYWNrTWF4VGltZSxcbiAgICBsb29wOiBhbmltYXRvci5fbG9vcCxcbiAgICBkZWxheTogYW5pbWF0b3IuX2RlbGF5LFxuICAgIG9uZnJhbWU6IG9uZnJhbWUsXG4gICAgb25kZXN0cm95OiBvbmVUcmFja0RvbmVcbiAgfSk7XG5cbiAgaWYgKGVhc2luZyAmJiBlYXNpbmcgIT09ICdzcGxpbmUnKSB7XG4gICAgY2xpcC5lYXNpbmcgPSBlYXNpbmc7XG4gIH1cblxuICByZXR1cm4gY2xpcDtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyXG4gKi9cblxuXG52YXIgQW5pbWF0b3IgPSBmdW5jdGlvbiAodGFyZ2V0LCBsb29wLCBnZXR0ZXIsIHNldHRlcikge1xuICB0aGlzLl90cmFja3MgPSB7fTtcbiAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLl9sb29wID0gbG9vcCB8fCBmYWxzZTtcbiAgdGhpcy5fZ2V0dGVyID0gZ2V0dGVyIHx8IGRlZmF1bHRHZXR0ZXI7XG4gIHRoaXMuX3NldHRlciA9IHNldHRlciB8fCBkZWZhdWx0U2V0dGVyO1xuICB0aGlzLl9jbGlwQ291bnQgPSAwO1xuICB0aGlzLl9kZWxheSA9IDA7XG4gIHRoaXMuX2RvbmVMaXN0ID0gW107XG4gIHRoaXMuX29uZnJhbWVMaXN0ID0gW107XG4gIHRoaXMuX2NsaXBMaXN0ID0gW107XG59O1xuXG5BbmltYXRvci5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiDorr7nva7liqjnlLvlhbPplK7luKdcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWFs+mUruW4p+aXtumXtO+8jOWNleS9jeaYr21zXG4gICAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMg5YWz6ZSu5bin55qE5bGe5oCn5YC877yMa2V5LXZhbHVl6KGo56S6XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIHdoZW46IGZ1bmN0aW9uICh0aW1lXG4gIC8qIG1zICovXG4gICwgcHJvcHMpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5fdHJhY2tzO1xuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYWNrc1twcm9wTmFtZV0pIHtcbiAgICAgICAgdHJhY2tzW3Byb3BOYW1lXSA9IFtdOyAvLyBJbnZhbGlkIHZhbHVlXG5cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0dGVyKHRoaXMuX3RhcmdldCwgcHJvcE5hbWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgLy8genJMb2coJ0ludmFsaWQgcHJvcGVydHkgJyArIHByb3BOYW1lKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBJZiB0aW1lIGlzIDBcbiAgICAgICAgLy8gIFRoZW4gcHJvcHMgaXMgZ2l2ZW4gaW5pdGlhbGl6ZSB2YWx1ZVxuICAgICAgICAvLyBFbHNlXG4gICAgICAgIC8vICBJbml0aWFsaXplIHZhbHVlIGZyb20gY3VycmVudCBwcm9wIHZhbHVlXG5cblxuICAgICAgICBpZiAodGltZSAhPT0gMCkge1xuICAgICAgICAgIHRyYWNrc1twcm9wTmFtZV0ucHVzaCh7XG4gICAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgICAgdmFsdWU6IGNsb25lVmFsdWUodmFsdWUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJhY2tzW3Byb3BOYW1lXS5wdXNoKHtcbiAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgdmFsdWU6IHByb3BzW3Byb3BOYW1lXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWKqOeUu+avj+S4gOW4p+eahOWbnuiwg+WHveaVsFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgZHVyaW5nOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9vbmZyYW1lTGlzdC5wdXNoKGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2NsaXBMaXN0W2ldLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgfSxcbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fY2xpcExpc3RbaV0ucmVzdW1lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gIH0sXG4gIGlzUGF1c2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcGF1c2VkO1xuICB9LFxuICBfZG9uZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ2xlYXIgYWxsIHRyYWNrc1xuICAgIHRoaXMuX3RyYWNrcyA9IHt9OyAvLyBDbGVhciBhbGwgY2xpcHNcblxuICAgIHRoaXMuX2NsaXBMaXN0Lmxlbmd0aCA9IDA7XG4gICAgdmFyIGRvbmVMaXN0ID0gdGhpcy5fZG9uZUxpc3Q7XG4gICAgdmFyIGxlbiA9IGRvbmVMaXN0Lmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRvbmVMaXN0W2ldLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDlvIDlp4vmiafooYzliqjnlLtcbiAgICogQHBhcmFtICB7c3RyaW5nfEZ1bmN0aW9ufSBbZWFzaW5nXVxuICAgKiAgICAgICAgIOWKqOeUu+e8k+WKqOWHveaVsO+8jOivpuingXtAbGluayBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vZWFzaW5nfVxuICAgKiBAcGFyYW0gIHtib29sZWFufSBmb3JjZUFuaW1hdGVcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgc3RhcnQ6IGZ1bmN0aW9uIChlYXNpbmcsIGZvcmNlQW5pbWF0ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2xpcENvdW50ID0gMDtcblxuICAgIHZhciBvbmVUcmFja0RvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGlwQ291bnQtLTtcblxuICAgICAgaWYgKCFjbGlwQ291bnQpIHtcbiAgICAgICAgc2VsZi5fZG9uZUNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsYXN0Q2xpcDtcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHRoaXMuX3RyYWNrcykge1xuICAgICAgaWYgKCF0aGlzLl90cmFja3MuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xpcCA9IGNyZWF0ZVRyYWNrQ2xpcCh0aGlzLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSwgdGhpcy5fdHJhY2tzW3Byb3BOYW1lXSwgcHJvcE5hbWUsIGZvcmNlQW5pbWF0ZSk7XG5cbiAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgIHRoaXMuX2NsaXBMaXN0LnB1c2goY2xpcCk7XG5cbiAgICAgICAgY2xpcENvdW50Kys7IC8vIElmIHN0YXJ0IGFmdGVyIGFkZGVkIHRvIGFuaW1hdGlvblxuXG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmFkZENsaXAoY2xpcCk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0Q2xpcCA9IGNsaXA7XG4gICAgICB9XG4gICAgfSAvLyBBZGQgZHVyaW5nIGNhbGxiYWNrIG9uIHRoZSBsYXN0IGNsaXBcblxuXG4gICAgaWYgKGxhc3RDbGlwKSB7XG4gICAgICB2YXIgb2xkT25GcmFtZSA9IGxhc3RDbGlwLm9uZnJhbWU7XG5cbiAgICAgIGxhc3RDbGlwLm9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgICAgIG9sZE9uRnJhbWUodGFyZ2V0LCBwZXJjZW50KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuX29uZnJhbWVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2VsZi5fb25mcmFtZUxpc3RbaV0odGFyZ2V0LCBwZXJjZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IC8vIFRoaXMgb3B0aW1pemF0aW9uIHdpbGwgaGVscCB0aGUgY2FzZSB0aGF0IGluIHRoZSB1cHBlciBhcHBsaWNhdGlvblxuICAgIC8vIHRoZSB2aWV3IG1heSBiZSByZWZyZXNoZWQgZnJlcXVlbnRseSwgd2hlcmUgYW5pbWF0aW9uIHdpbGwgYmVcbiAgICAvLyBjYWxsZWQgcmVwZWF0bHkgYnV0IG5vdGhpbmcgY2hhbmdlZC5cblxuXG4gICAgaWYgKCFjbGlwQ291bnQpIHtcbiAgICAgIHRoaXMuX2RvbmVDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlgZzmraLliqjnlLtcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgKi9cbiAgc3RvcDogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICB2YXIgY2xpcExpc3QgPSB0aGlzLl9jbGlwTGlzdDtcbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb247XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2xpcCA9IGNsaXBMaXN0W2ldO1xuXG4gICAgICBpZiAoZm9yd2FyZFRvTGFzdCkge1xuICAgICAgICAvLyBNb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICAgICAgY2xpcC5vbmZyYW1lKHRoaXMuX3RhcmdldCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucmVtb3ZlQ2xpcChjbGlwKTtcbiAgICB9XG5cbiAgICBjbGlwTGlzdC5sZW5ndGggPSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiDorr7nva7liqjnlLvlu7bov5/lvIDlp4vnmoTml7bpl7RcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWNleS9jW1zXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIGRlbGF5OiBmdW5jdGlvbiAodGltZSkge1xuICAgIHRoaXMuX2RlbGF5ID0gdGltZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5Yqo55S757uT5p2f55qE5Zue6LCDXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICBkb25lOiBmdW5jdGlvbiAoY2IpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRoaXMuX2RvbmVMaXN0LnB1c2goY2IpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXA+fVxuICAgKi9cbiAgZ2V0Q2xpcHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpcExpc3Q7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBBbmltYXRvcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVhc2luZ0Z1bmNzID0gcmVxdWlyZShcIi4vZWFzaW5nXCIpO1xuXG4vKipcbiAqIOWKqOeUu+S4u+aOp+WItuWZqFxuICogQGNvbmZpZyB0YXJnZXQg5Yqo55S75a+56LGh77yM5Y+v5Lul5piv5pWw57uE77yM5aaC5p6c5piv5pWw57uE55qE6K+d5Lya5om56YeP5YiG5Y+Rb25mcmFtZeetieS6i+S7tlxuICogQGNvbmZpZyBsaWZlKDEwMDApIOWKqOeUu+aXtumVv1xuICogQGNvbmZpZyBkZWxheSgwKSDliqjnlLvlu7bov5/ml7bpl7RcbiAqIEBjb25maWcgbG9vcCh0cnVlKVxuICogQGNvbmZpZyBnYXAoMCkg5b6q546v55qE6Ze06ZqU5pe26Ze0XG4gKiBAY29uZmlnIG9uZnJhbWVcbiAqIEBjb25maWcgZWFzaW5nKG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbmRlc3Ryb3kob3B0aW9uYWwpXG4gKiBAY29uZmlnIG9ucmVzdGFydChvcHRpb25hbClcbiAqXG4gKiBUT0RPIHBhdXNlXG4gKi9cbmZ1bmN0aW9uIENsaXAob3B0aW9ucykge1xuICB0aGlzLl90YXJnZXQgPSBvcHRpb25zLnRhcmdldDsgLy8g55Sf5ZG95ZGo5pyfXG5cbiAgdGhpcy5fbGlmZSA9IG9wdGlvbnMubGlmZSB8fCAxMDAwOyAvLyDlu7bml7ZcblxuICB0aGlzLl9kZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgMDsgLy8g5byA5aeL5pe26Ze0XG4gIC8vIHRoaXMuX3N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdGhpcy5fZGVsYXk7Ly8g5Y2V5L2N5q+r56eSXG5cbiAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTsgLy8g5piv5ZCm5b6q546vXG5cbiAgdGhpcy5sb29wID0gb3B0aW9ucy5sb29wID09IG51bGwgPyBmYWxzZSA6IG9wdGlvbnMubG9vcDtcbiAgdGhpcy5nYXAgPSBvcHRpb25zLmdhcCB8fCAwO1xuICB0aGlzLmVhc2luZyA9IG9wdGlvbnMuZWFzaW5nIHx8ICdMaW5lYXInO1xuICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWU7XG4gIHRoaXMub25kZXN0cm95ID0gb3B0aW9ucy5vbmRlc3Ryb3k7XG4gIHRoaXMub25yZXN0YXJ0ID0gb3B0aW9ucy5vbnJlc3RhcnQ7XG4gIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbn1cblxuQ2xpcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBDbGlwLFxuICBzdGVwOiBmdW5jdGlvbiAoZ2xvYmFsVGltZSwgZGVsdGFUaW1lKSB7XG4gICAgLy8gU2V0IHN0YXJ0VGltZSBvbiBmaXJzdCBzdGVwLCBvciBfc3RhcnRUaW1lIG1heSBoYXMgbWlsbGVzZWNvbmRzIGRpZmZlcmVudCBiZXR3ZWVuIGNsaXBzXG4gICAgLy8gUEVORElOR1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IGdsb2JhbFRpbWUgKyB0aGlzLl9kZWxheTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IGRlbHRhVGltZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGVyY2VudCA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fcGF1c2VkVGltZSkgLyB0aGlzLl9saWZlOyAvLyDov5jmsqHlvIDlp4tcblxuICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBlcmNlbnQgPSBNYXRoLm1pbihwZXJjZW50LCAxKTtcbiAgICB2YXIgZWFzaW5nID0gdGhpcy5lYXNpbmc7XG4gICAgdmFyIGVhc2luZ0Z1bmMgPSB0eXBlb2YgZWFzaW5nID09ICdzdHJpbmcnID8gZWFzaW5nRnVuY3NbZWFzaW5nXSA6IGVhc2luZztcbiAgICB2YXIgc2NoZWR1bGUgPSB0eXBlb2YgZWFzaW5nRnVuYyA9PT0gJ2Z1bmN0aW9uJyA/IGVhc2luZ0Z1bmMocGVyY2VudCkgOiBwZXJjZW50O1xuICAgIHRoaXMuZmlyZSgnZnJhbWUnLCBzY2hlZHVsZSk7IC8vIOe7k+adn1xuXG4gICAgaWYgKHBlcmNlbnQgPT0gMSkge1xuICAgICAgaWYgKHRoaXMubG9vcCkge1xuICAgICAgICB0aGlzLnJlc3RhcnQoZ2xvYmFsVGltZSk7IC8vIOmHjeaWsOW8gOWni+WRqOacn1xuICAgICAgICAvLyDmipvlh7rogIzkuI3mmK/nm7TmjqXosIPnlKjkuovku7bnm7TliLAgc3RhZ2UudXBkYXRlIOWQjuWGjee7n+S4gOiwg+eUqOi/meS6m+S6i+S7tlxuXG4gICAgICAgIHJldHVybiAncmVzdGFydCc7XG4gICAgICB9IC8vIOWKqOeUu+WujOaIkOWwhui/meS4quaOp+WItuWZqOagh+ivhuS4uuW+heWIoOmZpFxuICAgICAgLy8g5ZyoQW5pbWF0aW9uLnVwZGF0ZeS4rei/m+ihjOaJuemHj+WIoOmZpFxuXG5cbiAgICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAnZGVzdHJveSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHJlc3RhcnQ6IGZ1bmN0aW9uIChnbG9iYWxUaW1lKSB7XG4gICAgdmFyIHJlbWFpbmRlciA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fcGF1c2VkVGltZSkgJSB0aGlzLl9saWZlO1xuICAgIHRoaXMuX3N0YXJ0VGltZSA9IGdsb2JhbFRpbWUgLSByZW1haW5kZXIgKyB0aGlzLmdhcDtcbiAgICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcbiAgICB0aGlzLl9uZWVkc1JlbW92ZSA9IGZhbHNlO1xuICB9LFxuICBmaXJlOiBmdW5jdGlvbiAoZXZlbnRUeXBlLCBhcmcpIHtcbiAgICBldmVudFR5cGUgPSAnb24nICsgZXZlbnRUeXBlO1xuXG4gICAgaWYgKHRoaXNbZXZlbnRUeXBlXSkge1xuICAgICAgdGhpc1tldmVudFR5cGVdKHRoaXMuX3RhcmdldCwgYXJnKTtcbiAgICB9XG4gIH0sXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgfSxcbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBDbGlwO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog57yT5Yqo5Luj56CB5p2l6IeqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xlL3R3ZWVuLmpzL2Jsb2IvbWFzdGVyL3NyYy9Ud2Vlbi5qc1xuICogQHNlZSBodHRwOi8vc29sZS5naXRodWIuaW8vdHdlZW4uanMvZXhhbXBsZXMvMDNfZ3JhcGhzLmh0bWxcbiAqIEBleHBvcnRzIHpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ1xuICovXG52YXIgZWFzaW5nID0ge1xuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgbGluZWFyOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFkcmF0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YWRyYXRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqICgyIC0gayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YWRyYXRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogaztcbiAgICB9XG5cbiAgICByZXR1cm4gLTAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG4gIH0sXG4gIC8vIOS4ieasoeaWueeahOe8k+WKqO+8iHReM++8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjdWJpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGN1YmljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAtLWsgKiBrICogayArIDE7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGN1YmljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcbiAgfSxcbiAgLy8g5Zub5qyh5pa555qE57yT5Yqo77yIdF4077yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YXJ0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhcnRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMSAtIC0tayAqIGsgKiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhcnRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAtMC41ICogKChrIC09IDIpICogayAqIGsgKiBrIC0gMik7XG4gIH0sXG4gIC8vIOS6lOasoeaWueeahOe8k+WKqO+8iHReNe+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWludGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiBrICogayAqIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWludGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVpbnRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrICogaztcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKiBrICogayArIDIpO1xuICB9LFxuICAvLyDmraPlvKbmm7Lnur/nmoTnvJPliqjvvIhzaW4odCnvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgc2ludXNvaWRhbEluOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAxIC0gTWF0aC5jb3MoayAqIE1hdGguUEkgLyAyKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgc2ludXNvaWRhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gTWF0aC5zaW4oayAqIE1hdGguUEkgLyAyKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgc2ludXNvaWRhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gIH0sXG4gIC8vIOaMh+aVsOabsue6v+eahOe8k+WKqO+8iDJedO+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBleHBvbmVudGlhbEluOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrID09PSAwID8gMCA6IE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZXhwb25lbnRpYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgPT09IDEgPyAxIDogMSAtIE1hdGgucG93KDIsIC0xMCAqIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBleHBvbmVudGlhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAoayAtIDEpKSArIDIpO1xuICB9LFxuICAvLyDlnIblvaLmm7Lnur/nmoTnvJPliqjvvIhzcXJ0KDEtdF4yKe+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjaXJjdWxhckluOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBrICogayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGNpcmN1bGFyT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tayAqIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjaXJjdWxhckluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gayAqIGspIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIChrIC09IDIpICogaykgKyAxKTtcbiAgfSxcbiAgLy8g5Yib5bu657G75Ly85LqO5by557Cn5Zyo5YGc5q2i5YmN5p2l5Zue5oyv6I2h55qE5Yqo55S7XG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGVsYXN0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcztcbiAgICB2YXIgYSA9IDAuMTtcbiAgICB2YXIgcCA9IDAuNDtcblxuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICBhID0gMTtcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICB9XG5cbiAgICByZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZWxhc3RpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcztcbiAgICB2YXIgYSA9IDAuMTtcbiAgICB2YXIgcCA9IDAuNDtcblxuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICBhID0gMTtcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIGspICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDE7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGVsYXN0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcztcbiAgICB2YXIgYSA9IDAuMTtcbiAgICB2YXIgcCA9IDAuNDtcblxuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICBhID0gMTtcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICB9XG5cbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gLTAuNSAqIChhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuICB9LFxuICAvLyDlnKjmn5DkuIDliqjnlLvlvIDlp4vmsr/mjIfnpLrnmoTot6/lvoTov5vooYzliqjnlLvlpITnkIbliY3nqI3nqI3mlLblm57or6XliqjnlLvnmoTnp7vliqhcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYmFja0luOiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYmFja091dDogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIC0tayAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDE7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJhY2tJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcyA9IDEuNzAxNTggKiAxLjUyNTtcblxuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAoayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDIpO1xuICB9LFxuICAvLyDliJvlu7rlvLnot7PmlYjmnpxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYm91bmNlSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNpbmcuYm91bmNlT3V0KDEgLSBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYm91bmNlT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmIChrIDwgMSAvIDIuNzUpIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiBrICogaztcbiAgICB9IGVsc2UgaWYgKGsgPCAyIC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDEuNSAvIDIuNzUpICogayArIDAuNzU7XG4gICAgfSBlbHNlIGlmIChrIDwgMi41IC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDIuMjUgLyAyLjc1KSAqIGsgKyAwLjkzNzU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAyLjYyNSAvIDIuNzUpICogayArIDAuOTg0Mzc1O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYm91bmNlSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgPCAwLjUpIHtcbiAgICAgIHJldHVybiBlYXNpbmcuYm91bmNlSW4oayAqIDIpICogMC41O1xuICAgIH1cblxuICAgIHJldHVybiBlYXNpbmcuYm91bmNlT3V0KGsgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBlYXNpbmc7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vZWFzaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTFJVID0gcmVxdWlyZShcIi4uL2NvcmUvTFJVXCIpO1xuXG52YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gICd0cmFuc3BhcmVudCc6IFswLCAwLCAwLCAwXSxcbiAgJ2FsaWNlYmx1ZSc6IFsyNDAsIDI0OCwgMjU1LCAxXSxcbiAgJ2FudGlxdWV3aGl0ZSc6IFsyNTAsIDIzNSwgMjE1LCAxXSxcbiAgJ2FxdWEnOiBbMCwgMjU1LCAyNTUsIDFdLFxuICAnYXF1YW1hcmluZSc6IFsxMjcsIDI1NSwgMjEyLCAxXSxcbiAgJ2F6dXJlJzogWzI0MCwgMjU1LCAyNTUsIDFdLFxuICAnYmVpZ2UnOiBbMjQ1LCAyNDUsIDIyMCwgMV0sXG4gICdiaXNxdWUnOiBbMjU1LCAyMjgsIDE5NiwgMV0sXG4gICdibGFjayc6IFswLCAwLCAwLCAxXSxcbiAgJ2JsYW5jaGVkYWxtb25kJzogWzI1NSwgMjM1LCAyMDUsIDFdLFxuICAnYmx1ZSc6IFswLCAwLCAyNTUsIDFdLFxuICAnYmx1ZXZpb2xldCc6IFsxMzgsIDQzLCAyMjYsIDFdLFxuICAnYnJvd24nOiBbMTY1LCA0MiwgNDIsIDFdLFxuICAnYnVybHl3b29kJzogWzIyMiwgMTg0LCAxMzUsIDFdLFxuICAnY2FkZXRibHVlJzogWzk1LCAxNTgsIDE2MCwgMV0sXG4gICdjaGFydHJldXNlJzogWzEyNywgMjU1LCAwLCAxXSxcbiAgJ2Nob2NvbGF0ZSc6IFsyMTAsIDEwNSwgMzAsIDFdLFxuICAnY29yYWwnOiBbMjU1LCAxMjcsIDgwLCAxXSxcbiAgJ2Nvcm5mbG93ZXJibHVlJzogWzEwMCwgMTQ5LCAyMzcsIDFdLFxuICAnY29ybnNpbGsnOiBbMjU1LCAyNDgsIDIyMCwgMV0sXG4gICdjcmltc29uJzogWzIyMCwgMjAsIDYwLCAxXSxcbiAgJ2N5YW4nOiBbMCwgMjU1LCAyNTUsIDFdLFxuICAnZGFya2JsdWUnOiBbMCwgMCwgMTM5LCAxXSxcbiAgJ2RhcmtjeWFuJzogWzAsIDEzOSwgMTM5LCAxXSxcbiAgJ2Rhcmtnb2xkZW5yb2QnOiBbMTg0LCAxMzQsIDExLCAxXSxcbiAgJ2RhcmtncmF5JzogWzE2OSwgMTY5LCAxNjksIDFdLFxuICAnZGFya2dyZWVuJzogWzAsIDEwMCwgMCwgMV0sXG4gICdkYXJrZ3JleSc6IFsxNjksIDE2OSwgMTY5LCAxXSxcbiAgJ2RhcmtraGFraSc6IFsxODksIDE4MywgMTA3LCAxXSxcbiAgJ2RhcmttYWdlbnRhJzogWzEzOSwgMCwgMTM5LCAxXSxcbiAgJ2RhcmtvbGl2ZWdyZWVuJzogWzg1LCAxMDcsIDQ3LCAxXSxcbiAgJ2RhcmtvcmFuZ2UnOiBbMjU1LCAxNDAsIDAsIDFdLFxuICAnZGFya29yY2hpZCc6IFsxNTMsIDUwLCAyMDQsIDFdLFxuICAnZGFya3JlZCc6IFsxMzksIDAsIDAsIDFdLFxuICAnZGFya3NhbG1vbic6IFsyMzMsIDE1MCwgMTIyLCAxXSxcbiAgJ2RhcmtzZWFncmVlbic6IFsxNDMsIDE4OCwgMTQzLCAxXSxcbiAgJ2RhcmtzbGF0ZWJsdWUnOiBbNzIsIDYxLCAxMzksIDFdLFxuICAnZGFya3NsYXRlZ3JheSc6IFs0NywgNzksIDc5LCAxXSxcbiAgJ2RhcmtzbGF0ZWdyZXknOiBbNDcsIDc5LCA3OSwgMV0sXG4gICdkYXJrdHVycXVvaXNlJzogWzAsIDIwNiwgMjA5LCAxXSxcbiAgJ2Rhcmt2aW9sZXQnOiBbMTQ4LCAwLCAyMTEsIDFdLFxuICAnZGVlcHBpbmsnOiBbMjU1LCAyMCwgMTQ3LCAxXSxcbiAgJ2RlZXBza3libHVlJzogWzAsIDE5MSwgMjU1LCAxXSxcbiAgJ2RpbWdyYXknOiBbMTA1LCAxMDUsIDEwNSwgMV0sXG4gICdkaW1ncmV5JzogWzEwNSwgMTA1LCAxMDUsIDFdLFxuICAnZG9kZ2VyYmx1ZSc6IFszMCwgMTQ0LCAyNTUsIDFdLFxuICAnZmlyZWJyaWNrJzogWzE3OCwgMzQsIDM0LCAxXSxcbiAgJ2Zsb3JhbHdoaXRlJzogWzI1NSwgMjUwLCAyNDAsIDFdLFxuICAnZm9yZXN0Z3JlZW4nOiBbMzQsIDEzOSwgMzQsIDFdLFxuICAnZnVjaHNpYSc6IFsyNTUsIDAsIDI1NSwgMV0sXG4gICdnYWluc2Jvcm8nOiBbMjIwLCAyMjAsIDIyMCwgMV0sXG4gICdnaG9zdHdoaXRlJzogWzI0OCwgMjQ4LCAyNTUsIDFdLFxuICAnZ29sZCc6IFsyNTUsIDIxNSwgMCwgMV0sXG4gICdnb2xkZW5yb2QnOiBbMjE4LCAxNjUsIDMyLCAxXSxcbiAgJ2dyYXknOiBbMTI4LCAxMjgsIDEyOCwgMV0sXG4gICdncmVlbic6IFswLCAxMjgsIDAsIDFdLFxuICAnZ3JlZW55ZWxsb3cnOiBbMTczLCAyNTUsIDQ3LCAxXSxcbiAgJ2dyZXknOiBbMTI4LCAxMjgsIDEyOCwgMV0sXG4gICdob25leWRldyc6IFsyNDAsIDI1NSwgMjQwLCAxXSxcbiAgJ2hvdHBpbmsnOiBbMjU1LCAxMDUsIDE4MCwgMV0sXG4gICdpbmRpYW5yZWQnOiBbMjA1LCA5MiwgOTIsIDFdLFxuICAnaW5kaWdvJzogWzc1LCAwLCAxMzAsIDFdLFxuICAnaXZvcnknOiBbMjU1LCAyNTUsIDI0MCwgMV0sXG4gICdraGFraSc6IFsyNDAsIDIzMCwgMTQwLCAxXSxcbiAgJ2xhdmVuZGVyJzogWzIzMCwgMjMwLCAyNTAsIDFdLFxuICAnbGF2ZW5kZXJibHVzaCc6IFsyNTUsIDI0MCwgMjQ1LCAxXSxcbiAgJ2xhd25ncmVlbic6IFsxMjQsIDI1MiwgMCwgMV0sXG4gICdsZW1vbmNoaWZmb24nOiBbMjU1LCAyNTAsIDIwNSwgMV0sXG4gICdsaWdodGJsdWUnOiBbMTczLCAyMTYsIDIzMCwgMV0sXG4gICdsaWdodGNvcmFsJzogWzI0MCwgMTI4LCAxMjgsIDFdLFxuICAnbGlnaHRjeWFuJzogWzIyNCwgMjU1LCAyNTUsIDFdLFxuICAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiBbMjUwLCAyNTAsIDIxMCwgMV0sXG4gICdsaWdodGdyYXknOiBbMjExLCAyMTEsIDIxMSwgMV0sXG4gICdsaWdodGdyZWVuJzogWzE0NCwgMjM4LCAxNDQsIDFdLFxuICAnbGlnaHRncmV5JzogWzIxMSwgMjExLCAyMTEsIDFdLFxuICAnbGlnaHRwaW5rJzogWzI1NSwgMTgyLCAxOTMsIDFdLFxuICAnbGlnaHRzYWxtb24nOiBbMjU1LCAxNjAsIDEyMiwgMV0sXG4gICdsaWdodHNlYWdyZWVuJzogWzMyLCAxNzgsIDE3MCwgMV0sXG4gICdsaWdodHNreWJsdWUnOiBbMTM1LCAyMDYsIDI1MCwgMV0sXG4gICdsaWdodHNsYXRlZ3JheSc6IFsxMTksIDEzNiwgMTUzLCAxXSxcbiAgJ2xpZ2h0c2xhdGVncmV5JzogWzExOSwgMTM2LCAxNTMsIDFdLFxuICAnbGlnaHRzdGVlbGJsdWUnOiBbMTc2LCAxOTYsIDIyMiwgMV0sXG4gICdsaWdodHllbGxvdyc6IFsyNTUsIDI1NSwgMjI0LCAxXSxcbiAgJ2xpbWUnOiBbMCwgMjU1LCAwLCAxXSxcbiAgJ2xpbWVncmVlbic6IFs1MCwgMjA1LCA1MCwgMV0sXG4gICdsaW5lbic6IFsyNTAsIDI0MCwgMjMwLCAxXSxcbiAgJ21hZ2VudGEnOiBbMjU1LCAwLCAyNTUsIDFdLFxuICAnbWFyb29uJzogWzEyOCwgMCwgMCwgMV0sXG4gICdtZWRpdW1hcXVhbWFyaW5lJzogWzEwMiwgMjA1LCAxNzAsIDFdLFxuICAnbWVkaXVtYmx1ZSc6IFswLCAwLCAyMDUsIDFdLFxuICAnbWVkaXVtb3JjaGlkJzogWzE4NiwgODUsIDIxMSwgMV0sXG4gICdtZWRpdW1wdXJwbGUnOiBbMTQ3LCAxMTIsIDIxOSwgMV0sXG4gICdtZWRpdW1zZWFncmVlbic6IFs2MCwgMTc5LCAxMTMsIDFdLFxuICAnbWVkaXVtc2xhdGVibHVlJzogWzEyMywgMTA0LCAyMzgsIDFdLFxuICAnbWVkaXVtc3ByaW5nZ3JlZW4nOiBbMCwgMjUwLCAxNTQsIDFdLFxuICAnbWVkaXVtdHVycXVvaXNlJzogWzcyLCAyMDksIDIwNCwgMV0sXG4gICdtZWRpdW12aW9sZXRyZWQnOiBbMTk5LCAyMSwgMTMzLCAxXSxcbiAgJ21pZG5pZ2h0Ymx1ZSc6IFsyNSwgMjUsIDExMiwgMV0sXG4gICdtaW50Y3JlYW0nOiBbMjQ1LCAyNTUsIDI1MCwgMV0sXG4gICdtaXN0eXJvc2UnOiBbMjU1LCAyMjgsIDIyNSwgMV0sXG4gICdtb2NjYXNpbic6IFsyNTUsIDIyOCwgMTgxLCAxXSxcbiAgJ25hdmFqb3doaXRlJzogWzI1NSwgMjIyLCAxNzMsIDFdLFxuICAnbmF2eSc6IFswLCAwLCAxMjgsIDFdLFxuICAnb2xkbGFjZSc6IFsyNTMsIDI0NSwgMjMwLCAxXSxcbiAgJ29saXZlJzogWzEyOCwgMTI4LCAwLCAxXSxcbiAgJ29saXZlZHJhYic6IFsxMDcsIDE0MiwgMzUsIDFdLFxuICAnb3JhbmdlJzogWzI1NSwgMTY1LCAwLCAxXSxcbiAgJ29yYW5nZXJlZCc6IFsyNTUsIDY5LCAwLCAxXSxcbiAgJ29yY2hpZCc6IFsyMTgsIDExMiwgMjE0LCAxXSxcbiAgJ3BhbGVnb2xkZW5yb2QnOiBbMjM4LCAyMzIsIDE3MCwgMV0sXG4gICdwYWxlZ3JlZW4nOiBbMTUyLCAyNTEsIDE1MiwgMV0sXG4gICdwYWxldHVycXVvaXNlJzogWzE3NSwgMjM4LCAyMzgsIDFdLFxuICAncGFsZXZpb2xldHJlZCc6IFsyMTksIDExMiwgMTQ3LCAxXSxcbiAgJ3BhcGF5YXdoaXAnOiBbMjU1LCAyMzksIDIxMywgMV0sXG4gICdwZWFjaHB1ZmYnOiBbMjU1LCAyMTgsIDE4NSwgMV0sXG4gICdwZXJ1JzogWzIwNSwgMTMzLCA2MywgMV0sXG4gICdwaW5rJzogWzI1NSwgMTkyLCAyMDMsIDFdLFxuICAncGx1bSc6IFsyMjEsIDE2MCwgMjIxLCAxXSxcbiAgJ3Bvd2RlcmJsdWUnOiBbMTc2LCAyMjQsIDIzMCwgMV0sXG4gICdwdXJwbGUnOiBbMTI4LCAwLCAxMjgsIDFdLFxuICAncmVkJzogWzI1NSwgMCwgMCwgMV0sXG4gICdyb3N5YnJvd24nOiBbMTg4LCAxNDMsIDE0MywgMV0sXG4gICdyb3lhbGJsdWUnOiBbNjUsIDEwNSwgMjI1LCAxXSxcbiAgJ3NhZGRsZWJyb3duJzogWzEzOSwgNjksIDE5LCAxXSxcbiAgJ3NhbG1vbic6IFsyNTAsIDEyOCwgMTE0LCAxXSxcbiAgJ3NhbmR5YnJvd24nOiBbMjQ0LCAxNjQsIDk2LCAxXSxcbiAgJ3NlYWdyZWVuJzogWzQ2LCAxMzksIDg3LCAxXSxcbiAgJ3NlYXNoZWxsJzogWzI1NSwgMjQ1LCAyMzgsIDFdLFxuICAnc2llbm5hJzogWzE2MCwgODIsIDQ1LCAxXSxcbiAgJ3NpbHZlcic6IFsxOTIsIDE5MiwgMTkyLCAxXSxcbiAgJ3NreWJsdWUnOiBbMTM1LCAyMDYsIDIzNSwgMV0sXG4gICdzbGF0ZWJsdWUnOiBbMTA2LCA5MCwgMjA1LCAxXSxcbiAgJ3NsYXRlZ3JheSc6IFsxMTIsIDEyOCwgMTQ0LCAxXSxcbiAgJ3NsYXRlZ3JleSc6IFsxMTIsIDEyOCwgMTQ0LCAxXSxcbiAgJ3Nub3cnOiBbMjU1LCAyNTAsIDI1MCwgMV0sXG4gICdzcHJpbmdncmVlbic6IFswLCAyNTUsIDEyNywgMV0sXG4gICdzdGVlbGJsdWUnOiBbNzAsIDEzMCwgMTgwLCAxXSxcbiAgJ3Rhbic6IFsyMTAsIDE4MCwgMTQwLCAxXSxcbiAgJ3RlYWwnOiBbMCwgMTI4LCAxMjgsIDFdLFxuICAndGhpc3RsZSc6IFsyMTYsIDE5MSwgMjE2LCAxXSxcbiAgJ3RvbWF0byc6IFsyNTUsIDk5LCA3MSwgMV0sXG4gICd0dXJxdW9pc2UnOiBbNjQsIDIyNCwgMjA4LCAxXSxcbiAgJ3Zpb2xldCc6IFsyMzgsIDEzMCwgMjM4LCAxXSxcbiAgJ3doZWF0JzogWzI0NSwgMjIyLCAxNzksIDFdLFxuICAnd2hpdGUnOiBbMjU1LCAyNTUsIDI1NSwgMV0sXG4gICd3aGl0ZXNtb2tlJzogWzI0NSwgMjQ1LCAyNDUsIDFdLFxuICAneWVsbG93JzogWzI1NSwgMjU1LCAwLCAxXSxcbiAgJ3llbGxvd2dyZWVuJzogWzE1NCwgMjA1LCA1MCwgMV1cbn07XG5cbmZ1bmN0aW9uIGNsYW1wQ3NzQnl0ZShpKSB7XG4gIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gIGkgPSBNYXRoLnJvdW5kKGkpOyAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cblxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wQ3NzQW5nbGUoaSkge1xuICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMzYwLlxuICBpID0gTWF0aC5yb3VuZChpKTsgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG5cbiAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAzNjAgPyAzNjAgOiBpO1xufVxuXG5mdW5jdGlvbiBjbGFtcENzc0Zsb2F0KGYpIHtcbiAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC5cbiAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ3NzSW50KHN0cikge1xuICAvLyBpbnQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgfVxuXG4gIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VJbnQoc3RyLCAxMCkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNzc0Zsb2F0KHN0cikge1xuICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgfVxuXG4gIHJldHVybiBjbGFtcENzc0Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkge1xuICBpZiAoaCA8IDApIHtcbiAgICBoICs9IDE7XG4gIH0gZWxzZSBpZiAoaCA+IDEpIHtcbiAgICBoIC09IDE7XG4gIH1cblxuICBpZiAoaCAqIDYgPCAxKSB7XG4gICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gIH1cblxuICBpZiAoaCAqIDIgPCAxKSB7XG4gICAgcmV0dXJuIG0yO1xuICB9XG5cbiAgaWYgKGggKiAzIDwgMikge1xuICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNjtcbiAgfVxuXG4gIHJldHVybiBtMTtcbn1cblxuZnVuY3Rpb24gbGVycE51bWJlcihhLCBiLCBwKSB7XG4gIHJldHVybiBhICsgKGIgLSBhKSAqIHA7XG59XG5cbmZ1bmN0aW9uIHNldFJnYmEob3V0LCByLCBnLCBiLCBhKSB7XG4gIG91dFswXSA9IHI7XG4gIG91dFsxXSA9IGc7XG4gIG91dFsyXSA9IGI7XG4gIG91dFszXSA9IGE7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGNvcHlSZ2JhKG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG52YXIgY29sb3JDYWNoZSA9IG5ldyBMUlUoMjApO1xudmFyIGxhc3RSZW1vdmVkQXJyID0gbnVsbDtcblxuZnVuY3Rpb24gcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycikge1xuICAvLyBSZXVzZSByZW1vdmVkIGFycmF5XG4gIGlmIChsYXN0UmVtb3ZlZEFycikge1xuICAgIGNvcHlSZ2JhKGxhc3RSZW1vdmVkQXJyLCByZ2JhQXJyKTtcbiAgfVxuXG4gIGxhc3RSZW1vdmVkQXJyID0gY29sb3JDYWNoZS5wdXQoY29sb3JTdHIsIGxhc3RSZW1vdmVkQXJyIHx8IHJnYmFBcnIuc2xpY2UoKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclN0clxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZShjb2xvclN0ciwgcmdiYUFycikge1xuICBpZiAoIWNvbG9yU3RyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmdiYUFyciA9IHJnYmFBcnIgfHwgW107XG4gIHZhciBjYWNoZWQgPSBjb2xvckNhY2hlLmdldChjb2xvclN0cik7XG5cbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjb3B5UmdiYShyZ2JhQXJyLCBjYWNoZWQpO1xuICB9IC8vIGNvbG9yU3RyIG1heSBiZSBub3Qgc3RyaW5nXG5cblxuICBjb2xvclN0ciA9IGNvbG9yU3RyICsgJyc7IC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxuXG4gIHZhciBzdHIgPSBjb2xvclN0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpOyAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG5cbiAgaWYgKHN0ciBpbiBrQ1NTQ29sb3JUYWJsZSkge1xuICAgIGNvcHlSZ2JhKHJnYmFBcnIsIGtDU1NDb2xvclRhYmxlW3N0cl0pO1xuICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgIHJldHVybiByZ2JhQXJyO1xuICB9IC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuXG5cbiAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7IC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkge1xuICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICByZXR1cm47IC8vIENvdmVycyBOYU4uXG4gICAgICB9XG5cbiAgICAgIHNldFJnYmEocmdiYUFyciwgKGl2ICYgMHhmMDApID4+IDQgfCAoaXYgJiAweGYwMCkgPj4gOCwgaXYgJiAweGYwIHwgKGl2ICYgMHhmMCkgPj4gNCwgaXYgJiAweGYgfCAoaXYgJiAweGYpIDw8IDQsIDEpO1xuICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICByZXR1cm4gcmdiYUFycjtcbiAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSB7XG4gICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgIHJldHVybjsgLy8gQ292ZXJzIE5hTi5cbiAgICAgIH1cblxuICAgICAgc2V0UmdiYShyZ2JhQXJyLCAoaXYgJiAweGZmMDAwMCkgPj4gMTYsIChpdiAmIDB4ZmYwMCkgPj4gOCwgaXYgJiAweGZmLCAxKTtcbiAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSxcbiAgICAgIGVwID0gc3RyLmluZGV4T2YoJyknKTtcblxuICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wICsgMSwgZXAgLSAob3AgKyAxKSkuc3BsaXQoJywnKTtcbiAgICB2YXIgYWxwaGEgPSAxOyAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuXG4gICAgc3dpdGNoIChmbmFtZSkge1xuICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhbHBoYSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuXG4gICAgICBjYXNlICdyZ2InOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCBwYXJzZUNzc0ludChwYXJhbXNbMF0pLCBwYXJzZUNzc0ludChwYXJhbXNbMV0pLCBwYXJzZUNzc0ludChwYXJhbXNbMl0pLCBhbHBoYSk7XG4gICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICByZXR1cm4gcmdiYUFycjtcblxuICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXNbM10gPSBwYXJzZUNzc0Zsb2F0KHBhcmFtc1szXSk7XG4gICAgICAgIGhzbGEycmdiYShwYXJhbXMsIHJnYmFBcnIpO1xuICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG5cbiAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBoc2xhMnJnYmEocGFyYW1zLCByZ2JhQXJyKTtcbiAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgIHJldHVybiByZ2JhQXJyO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgcmV0dXJuO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICovXG5cblxuZnVuY3Rpb24gaHNsYTJyZ2JhKGhzbGEsIHJnYmEpIHtcbiAgdmFyIGggPSAocGFyc2VGbG9hdChoc2xhWzBdKSAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjA7IC8vIDAgLi4gMVxuICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuXG4gIHZhciBzID0gcGFyc2VDc3NGbG9hdChoc2xhWzFdKTtcbiAgdmFyIGwgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMl0pO1xuICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgcmdiYSA9IHJnYmEgfHwgW107XG4gIHNldFJnYmEocmdiYSwgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCArIDEgLyAzKSAqIDI1NSksIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGgpICogMjU1KSwgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCAtIDEgLyAzKSAqIDI1NSksIDEpO1xuXG4gIGlmIChoc2xhLmxlbmd0aCA9PT0gNCkge1xuICAgIHJnYmFbM10gPSBoc2xhWzNdO1xuICB9XG5cbiAgcmV0dXJuIHJnYmE7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gKi9cblxuXG5mdW5jdGlvbiByZ2JhMmhzbGEocmdiYSkge1xuICBpZiAoIXJnYmEpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gUkdCIGZyb20gMCB0byAyNTVcblxuXG4gIHZhciBSID0gcmdiYVswXSAvIDI1NTtcbiAgdmFyIEcgPSByZ2JhWzFdIC8gMjU1O1xuICB2YXIgQiA9IHJnYmFbMl0gLyAyNTU7XG4gIHZhciB2TWluID0gTWF0aC5taW4oUiwgRywgQik7IC8vIE1pbi4gdmFsdWUgb2YgUkdCXG5cbiAgdmFyIHZNYXggPSBNYXRoLm1heChSLCBHLCBCKTsgLy8gTWF4LiB2YWx1ZSBvZiBSR0JcblxuICB2YXIgZGVsdGEgPSB2TWF4IC0gdk1pbjsgLy8gRGVsdGEgUkdCIHZhbHVlXG5cbiAgdmFyIEwgPSAodk1heCArIHZNaW4pIC8gMjtcbiAgdmFyIEg7XG4gIHZhciBTOyAvLyBIU0wgcmVzdWx0cyBmcm9tIDAgdG8gMVxuXG4gIGlmIChkZWx0YSA9PT0gMCkge1xuICAgIEggPSAwO1xuICAgIFMgPSAwO1xuICB9IGVsc2Uge1xuICAgIGlmIChMIDwgMC41KSB7XG4gICAgICBTID0gZGVsdGEgLyAodk1heCArIHZNaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBTID0gZGVsdGEgLyAoMiAtIHZNYXggLSB2TWluKTtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGFSID0gKCh2TWF4IC0gUikgLyA2ICsgZGVsdGEgLyAyKSAvIGRlbHRhO1xuICAgIHZhciBkZWx0YUcgPSAoKHZNYXggLSBHKSAvIDYgKyBkZWx0YSAvIDIpIC8gZGVsdGE7XG4gICAgdmFyIGRlbHRhQiA9ICgodk1heCAtIEIpIC8gNiArIGRlbHRhIC8gMikgLyBkZWx0YTtcblxuICAgIGlmIChSID09PSB2TWF4KSB7XG4gICAgICBIID0gZGVsdGFCIC0gZGVsdGFHO1xuICAgIH0gZWxzZSBpZiAoRyA9PT0gdk1heCkge1xuICAgICAgSCA9IDEgLyAzICsgZGVsdGFSIC0gZGVsdGFCO1xuICAgIH0gZWxzZSBpZiAoQiA9PT0gdk1heCkge1xuICAgICAgSCA9IDIgLyAzICsgZGVsdGFHIC0gZGVsdGFSO1xuICAgIH1cblxuICAgIGlmIChIIDwgMCkge1xuICAgICAgSCArPSAxO1xuICAgIH1cblxuICAgIGlmIChIID4gMSkge1xuICAgICAgSCAtPSAxO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoc2xhID0gW0ggKiAzNjAsIFMsIExdO1xuXG4gIGlmIChyZ2JhWzNdICE9IG51bGwpIHtcbiAgICBoc2xhLnB1c2gocmdiYVszXSk7XG4gIH1cblxuICByZXR1cm4gaHNsYTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiBsaWZ0KGNvbG9yLCBsZXZlbCkge1xuICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yQXJyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgY29sb3JBcnJbaV0gPSBjb2xvckFycltpXSAqICgxIC0gbGV2ZWwpIHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbG9yQXJyW2ldID0gKDI1NSAtIGNvbG9yQXJyW2ldKSAqIGxldmVsICsgY29sb3JBcnJbaV0gfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdpZnkoY29sb3JBcnIsIGNvbG9yQXJyLmxlbmd0aCA9PT0gNCA/ICdyZ2JhJyA6ICdyZ2InKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiB0b0hleChjb2xvcikge1xuICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yQXJyKSB7XG4gICAgcmV0dXJuICgoMSA8PCAyNCkgKyAoY29sb3JBcnJbMF0gPDwgMTYpICsgKGNvbG9yQXJyWzFdIDw8IDgpICsgK2NvbG9yQXJyWzJdKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gIH1cbn1cbi8qKlxuICogTWFwIHZhbHVlIHRvIGNvbG9yLiBGYXN0ZXIgdGhhbiBsZXJwIG1ldGhvZHMgYmVjYXVzZSBjb2xvciBpcyByZXByZXNlbnRlZCBieSByZ2JhIGFycmF5LlxuICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRWYWx1ZSBBIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gY29sb3JzIExpc3Qgb2YgcmdiYSBjb2xvciBhcnJheVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW291dF0gTWFwcGVkIGdiYSBjb2xvciBhcnJheVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IHdpbGwgYmUgbnVsbC91bmRlZmluZWQgaWYgaW5wdXQgaWxsZWdhbC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZhc3RMZXJwKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBvdXQpIHtcbiAgaWYgKCEoY29sb3JzICYmIGNvbG9ycy5sZW5ndGgpIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3V0ID0gb3V0IHx8IFtdO1xuICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgdmFyIGxlZnRDb2xvciA9IGNvbG9yc1tsZWZ0SW5kZXhdO1xuICB2YXIgcmlnaHRDb2xvciA9IGNvbG9yc1tyaWdodEluZGV4XTtcbiAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG4gIG91dFswXSA9IGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclswXSwgcmlnaHRDb2xvclswXSwgZHYpKTtcbiAgb3V0WzFdID0gY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzFdLCByaWdodENvbG9yWzFdLCBkdikpO1xuICBvdXRbMl0gPSBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSk7XG4gIG91dFszXSA9IGNsYW1wQ3NzRmxvYXQobGVycE51bWJlcihsZWZ0Q29sb3JbM10sIHJpZ2h0Q29sb3JbM10sIGR2KSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuXG52YXIgZmFzdE1hcFRvQ29sb3IgPSBmYXN0TGVycDtcbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRWYWx1ZSBBIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9ycyBDb2xvciBsaXN0LlxuICogQHBhcmFtIHtib29sZWFuPX0gZnVsbE91dHB1dCBEZWZhdWx0IGZhbHNlLlxuICogQHJldHVybiB7KHN0cmluZ3xPYmplY3QpfSBSZXN1bHQgY29sb3IuIElmIGZ1bGxPdXRwdXQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sb3I6IC4uLiwgbGVmdEluZGV4OiAuLi4sIHJpZ2h0SW5kZXg6IC4uLiwgdmFsdWU6IC4uLn0sXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cbmZ1bmN0aW9uIGxlcnAobm9ybWFsaXplZFZhbHVlLCBjb2xvcnMsIGZ1bGxPdXRwdXQpIHtcbiAgaWYgKCEoY29sb3JzICYmIGNvbG9ycy5sZW5ndGgpIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gbm9ybWFsaXplZFZhbHVlICogKGNvbG9ycy5sZW5ndGggLSAxKTtcbiAgdmFyIGxlZnRJbmRleCA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gIHZhciBsZWZ0Q29sb3IgPSBwYXJzZShjb2xvcnNbbGVmdEluZGV4XSk7XG4gIHZhciByaWdodENvbG9yID0gcGFyc2UoY29sb3JzW3JpZ2h0SW5kZXhdKTtcbiAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG4gIHZhciBjb2xvciA9IHN0cmluZ2lmeShbY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpLCBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSksIGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKSwgY2xhbXBDc3NGbG9hdChsZXJwTnVtYmVyKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKV0sICdyZ2JhJyk7XG4gIHJldHVybiBmdWxsT3V0cHV0ID8ge1xuICAgIGNvbG9yOiBjb2xvcixcbiAgICBsZWZ0SW5kZXg6IGxlZnRJbmRleCxcbiAgICByaWdodEluZGV4OiByaWdodEluZGV4LFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9IDogY29sb3I7XG59XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuXG52YXIgbWFwVG9Db2xvciA9IGxlcnA7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHBhcmFtIHtudW1iZXI9fSBoIDAgfiAzNjAsIGlnbm9yZSB3aGVuIG51bGwuXG4gKiBAcGFyYW0ge251bWJlcj19IHMgMCB+IDEsIGlnbm9yZSB3aGVuIG51bGwuXG4gKiBAcGFyYW0ge251bWJlcj19IGwgMCB+IDEsIGlnbm9yZSB3aGVuIG51bGwuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuZnVuY3Rpb24gbW9kaWZ5SFNMKGNvbG9yLCBoLCBzLCBsKSB7XG4gIGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXG4gIGlmIChjb2xvcikge1xuICAgIGNvbG9yID0gcmdiYTJoc2xhKGNvbG9yKTtcbiAgICBoICE9IG51bGwgJiYgKGNvbG9yWzBdID0gY2xhbXBDc3NBbmdsZShoKSk7XG4gICAgcyAhPSBudWxsICYmIChjb2xvclsxXSA9IHBhcnNlQ3NzRmxvYXQocykpO1xuICAgIGwgIT0gbnVsbCAmJiAoY29sb3JbMl0gPSBwYXJzZUNzc0Zsb2F0KGwpKTtcbiAgICByZXR1cm4gc3RyaW5naWZ5KGhzbGEycmdiYShjb2xvciksICdyZ2JhJyk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge251bWJlcj19IGFscGhhIDAgfiAxXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiBtb2RpZnlBbHBoYShjb2xvciwgYWxwaGEpIHtcbiAgY29sb3IgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yICYmIGFscGhhICE9IG51bGwpIHtcbiAgICBjb2xvclszXSA9IGNsYW1wQ3NzRmxvYXQoYWxwaGEpO1xuICAgIHJldHVybiBzdHJpbmdpZnkoY29sb3IsICdyZ2JhJyk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyQ29sb3IgbGlrZSBbMTIsMzMsNDQsMC40XVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgJ3JnYmEnLCAnaHN2YScsIC4uLlxuICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHQgY29sb3IuIChJZiBpbnB1dCBpbGxlZ2FsLCByZXR1cm4gdW5kZWZpbmVkKS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnJDb2xvciwgdHlwZSkge1xuICBpZiAoIWFyckNvbG9yIHx8ICFhcnJDb2xvci5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29sb3JTdHIgPSBhcnJDb2xvclswXSArICcsJyArIGFyckNvbG9yWzFdICsgJywnICsgYXJyQ29sb3JbMl07XG5cbiAgaWYgKHR5cGUgPT09ICdyZ2JhJyB8fCB0eXBlID09PSAnaHN2YScgfHwgdHlwZSA9PT0gJ2hzbGEnKSB7XG4gICAgY29sb3JTdHIgKz0gJywnICsgYXJyQ29sb3JbM107XG4gIH1cblxuICByZXR1cm4gdHlwZSArICcoJyArIGNvbG9yU3RyICsgJyknO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLmxpZnQgPSBsaWZ0O1xuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuZXhwb3J0cy5mYXN0TGVycCA9IGZhc3RMZXJwO1xuZXhwb3J0cy5mYXN0TWFwVG9Db2xvciA9IGZhc3RNYXBUb0NvbG9yO1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMubWFwVG9Db2xvciA9IG1hcFRvQ29sb3I7XG5leHBvcnRzLm1vZGlmeUhTTCA9IG1vZGlmeUhTTDtcbmV4cG9ydHMubW9kaWZ5QWxwaGEgPSBtb2RpZnlBbHBoYTtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBTaW1wbGUgTFJVIGNhY2hlIHVzZSBkb3VibHkgbGlua2VkIGxpc3Rcbi8vIEBtb2R1bGUgenJlbmRlci9jb3JlL0xSVVxuXG4vKipcbiAqIFNpbXBsZSBkb3VibGUgbGlua2VkIGxpc3QuIENvbXBhcmVkIHdpdGggYXJyYXksIGl0IGhhcyBPKDEpIHJlbW92ZSBvcGVyYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIExpbmtlZExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAqL1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cblxuICB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLl9sZW4gPSAwO1xufTtcblxudmFyIGxpbmtlZExpc3RQcm90byA9IExpbmtlZExpc3QucHJvdG90eXBlO1xuLyoqXG4gKiBJbnNlcnQgYSBuZXcgdmFsdWUgYXQgdGhlIHRhaWxcbiAqIEBwYXJhbSAge30gdmFsXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAqL1xuXG5saW5rZWRMaXN0UHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24gKHZhbCkge1xuICB2YXIgZW50cnkgPSBuZXcgRW50cnkodmFsKTtcbiAgdGhpcy5pbnNlcnRFbnRyeShlbnRyeSk7XG4gIHJldHVybiBlbnRyeTtcbn07XG4vKipcbiAqIEluc2VydCBhbiBlbnRyeSBhdCB0aGUgdGFpbFxuICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9IGVudHJ5XG4gKi9cblxuXG5saW5rZWRMaXN0UHJvdG8uaW5zZXJ0RW50cnkgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O1xuICAgIGVudHJ5LnByZXYgPSB0aGlzLnRhaWw7XG4gICAgZW50cnkubmV4dCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gIH1cblxuICB0aGlzLl9sZW4rKztcbn07XG4vKipcbiAqIFJlbW92ZSBlbnRyeS5cbiAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fSBlbnRyeVxuICovXG5cblxubGlua2VkTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICB2YXIgcHJldiA9IGVudHJ5LnByZXY7XG4gIHZhciBuZXh0ID0gZW50cnkubmV4dDtcblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IG5leHQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gSXMgaGVhZFxuICAgIHRoaXMuaGVhZCA9IG5leHQ7XG4gIH1cblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXY7XG4gIH0gZWxzZSB7XG4gICAgLy8gSXMgdGFpbFxuICAgIHRoaXMudGFpbCA9IHByZXY7XG4gIH1cblxuICBlbnRyeS5uZXh0ID0gZW50cnkucHJldiA9IG51bGw7XG4gIHRoaXMuX2xlbi0tO1xufTtcbi8qKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxubGlua2VkTGlzdFByb3RvLmxlbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xlbjtcbn07XG4vKipcbiAqIENsZWFyIGxpc3RcbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5fbGVuID0gMDtcbn07XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHt9IHZhbFxuICovXG5cblxudmFyIEVudHJ5ID0gZnVuY3Rpb24gKHZhbCkge1xuICAvKipcbiAgICogQHR5cGUge31cbiAgICovXG4gIHRoaXMudmFsdWUgPSB2YWw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAqL1xuXG4gIHRoaXMubmV4dDtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICovXG5cbiAgdGhpcy5wcmV2O1xufTtcbi8qKlxuICogTFJVIENhY2hlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9jb3JlL0xSVVxuICovXG5cblxudmFyIExSVSA9IGZ1bmN0aW9uIChtYXhTaXplKSB7XG4gIHRoaXMuX2xpc3QgPSBuZXcgTGlua2VkTGlzdCgpO1xuICB0aGlzLl9tYXAgPSB7fTtcbiAgdGhpcy5fbWF4U2l6ZSA9IG1heFNpemUgfHwgMTA7XG4gIHRoaXMuX2xhc3RSZW1vdmVkRW50cnkgPSBudWxsO1xufTtcblxudmFyIExSVVByb3RvID0gTFJVLnByb3RvdHlwZTtcbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSAge30gdmFsdWVcbiAqIEByZXR1cm4ge30gUmVtb3ZlZCB2YWx1ZVxuICovXG5cbkxSVVByb3RvLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgdmFyIHJlbW92ZWQgPSBudWxsO1xuXG4gIGlmIChtYXBba2V5XSA9PSBudWxsKSB7XG4gICAgdmFyIGxlbiA9IGxpc3QubGVuKCk7IC8vIFJldXNlIGxhc3QgcmVtb3ZlZCBlbnRyeVxuXG4gICAgdmFyIGVudHJ5ID0gdGhpcy5fbGFzdFJlbW92ZWRFbnRyeTtcblxuICAgIGlmIChsZW4gPj0gdGhpcy5fbWF4U2l6ZSAmJiBsZW4gPiAwKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWRcbiAgICAgIHZhciBsZWFzdFVzZWRFbnRyeSA9IGxpc3QuaGVhZDtcbiAgICAgIGxpc3QucmVtb3ZlKGxlYXN0VXNlZEVudHJ5KTtcbiAgICAgIGRlbGV0ZSBtYXBbbGVhc3RVc2VkRW50cnkua2V5XTtcbiAgICAgIHJlbW92ZWQgPSBsZWFzdFVzZWRFbnRyeS52YWx1ZTtcbiAgICAgIHRoaXMuX2xhc3RSZW1vdmVkRW50cnkgPSBsZWFzdFVzZWRFbnRyeTtcbiAgICB9XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudHJ5ID0gbmV3IEVudHJ5KHZhbHVlKTtcbiAgICB9XG5cbiAgICBlbnRyeS5rZXkgPSBrZXk7XG4gICAgbGlzdC5pbnNlcnRFbnRyeShlbnRyeSk7XG4gICAgbWFwW2tleV0gPSBlbnRyeTtcbiAgfVxuXG4gIHJldHVybiByZW1vdmVkO1xufTtcbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge31cbiAqL1xuXG5cbkxSVVByb3RvLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fbWFwW2tleV07XG4gIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcblxuICBpZiAoZW50cnkgIT0gbnVsbCkge1xuICAgIC8vIFB1dCB0aGUgbGF0ZXN0IHVzZWQgZW50cnkgaW4gdGhlIHRhaWxcbiAgICBpZiAoZW50cnkgIT09IGxpc3QudGFpbCkge1xuICAgICAgbGlzdC5yZW1vdmUoZW50cnkpO1xuICAgICAgbGlzdC5pbnNlcnRFbnRyeShlbnRyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICB9XG59O1xuLyoqXG4gKiBDbGVhciB0aGUgY2FjaGVcbiAqL1xuXG5cbkxSVVByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9saXN0LmNsZWFyKCk7XG5cbiAgdGhpcy5fbWFwID0ge307XG59O1xuXG52YXIgX2RlZmF1bHQgPSBMUlU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL0xSVS5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgZGVidWdNb2RlID0gX2NvbmZpZy5kZWJ1Z01vZGU7XG5cbnZhciBsb2cgPSBmdW5jdGlvbiAoKSB7fTtcblxuaWYgKGRlYnVnTW9kZSA9PT0gMSkge1xuICBsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihhcmd1bWVudHNba10pO1xuICAgIH1cbiAgfTtcbn0gZWxzZSBpZiAoZGVidWdNb2RlID4gMSkge1xuICBsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHMpIHtcbiAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50c1trXSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgX2RlZmF1bHQgPSBsb2c7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL2xvZy5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRwciA9IDE7IC8vIElmIGluIGJyb3dzZXIgZW52aXJvbm1lbnRcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGRwciA9IE1hdGgubWF4KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsIDEpO1xufVxuLyoqXG4gKiBjb25maWfpu5jorqTphY3nva7poblcbiAqIEBleHBvcnRzIHpyZW5kZXIvY29uZmlnXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIGRlYnVn5pel5b+X6YCJ6aG577yaY2F0Y2hCcnVzaEV4Y2VwdGlvbuS4unRydWXkuIvmnInmlYhcbiAqIDAgOiDkuI3nlJ/miJBkZWJ1Z+aVsOaNru+8jOWPkeW4g+eUqFxuICogMSA6IOW8guW4uOaKm+WHuu+8jOiwg+ivleeUqFxuICogMiA6IOaOp+WItuWPsOi+k+WHuu+8jOiwg+ivleeUqFxuICovXG5cblxudmFyIGRlYnVnTW9kZSA9IDA7IC8vIHJldGluYSDlsY/luZXkvJjljJZcblxudmFyIGRldmljZVBpeGVsUmF0aW8gPSBkcHI7XG5leHBvcnRzLmRlYnVnTW9kZSA9IGRlYnVnTW9kZTtcbmV4cG9ydHMuZGV2aWNlUGl4ZWxSYXRpbyA9IGRldmljZVBpeGVsUmF0aW87XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRleHRIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL3RleHRcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbi8qKlxuICogTWl4aW4gZm9yIGRyYXdpbmcgdGV4dCBpbiBhIGVsZW1lbnQgYm91bmRpbmcgcmVjdFxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1JlY3RUZXh0XG4gKi9cbnZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgpO1xuXG52YXIgUmVjdFRleHQgPSBmdW5jdGlvbiAoKSB7fTtcblxuUmVjdFRleHQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUmVjdFRleHQsXG5cbiAgLyoqXG4gICAqIERyYXcgdGV4dCBpbiBhIHJlY3Qgd2l0aCBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSAge09iamVjdH0gcmVjdCBEaXNwbGF5YWJsZSByZWN0XG4gICAqL1xuICBkcmF3UmVjdFRleHQ6IGZ1bmN0aW9uIChjdHgsIHJlY3QpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHJlY3QgPSBzdHlsZS50ZXh0UmVjdCB8fCByZWN0OyAvLyBPcHRpbWl6ZSwgYXZvaWQgbm9ybWFsaXplIGV2ZXJ5IHRpbWUuXG5cbiAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpO1xuICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDsgLy8gQ29udmVydCB0byBzdHJpbmdcblxuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgICBpZiAoIXRleHRIZWxwZXIubmVlZERyYXdUZXh0KHRleHQsIHN0eWxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRklYTUVcblxuXG4gICAgY3R4LnNhdmUoKTsgLy8gVHJhbnNmb3JtIHJlY3QgdG8gdmlldyBzcGFjZVxuXG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gICAgaWYgKCFzdHlsZS50cmFuc2Zvcm1UZXh0KSB7XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRtcFJlY3QuY29weShyZWN0KTtcbiAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICByZWN0ID0gdG1wUmVjdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICB9IC8vIHRyYW5zZm9ybVRleHQgYW5kIHRleHRSb3RhdGlvbiBjYW4gbm90IGJlIHVzZWQgYXQgdGhlIHNhbWUgdGltZS5cblxuXG4gICAgdGV4dEhlbHBlci5yZW5kZXJUZXh0KHRoaXMsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBSZWN0VGV4dDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3V0aWxcIik7XG5cbnZhciByZXRyaWV2ZTIgPSBfdXRpbC5yZXRyaWV2ZTI7XG52YXIgcmV0cmlldmUzID0gX3V0aWwucmV0cmlldmUzO1xudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xudmFyIG5vcm1hbGl6ZUNzc0FycmF5ID0gX3V0aWwubm9ybWFsaXplQ3NzQXJyYXk7XG52YXIgaXNTdHJpbmcgPSBfdXRpbC5pc1N0cmluZztcbnZhciBpc09iamVjdCA9IF91dGlsLmlzT2JqZWN0O1xuXG52YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwiLi4vLi4vY29udGFpbi90ZXh0XCIpO1xuXG52YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZShcIi4vcm91bmRSZWN0XCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi9pbWFnZVwiKTtcblxuLy8gVE9ETzogSGF2ZSBub3Qgc3VwcG9ydCAnc3RhcnQnLCAnZW5kJyB5ZXQuXG52YXIgVkFMSURfVEVYVF9BTElHTiA9IHtcbiAgbGVmdDogMSxcbiAgcmlnaHQ6IDEsXG4gIGNlbnRlcjogMVxufTtcbnZhciBWQUxJRF9URVhUX1ZFUlRJQ0FMX0FMSUdOID0ge1xuICB0b3A6IDEsXG4gIGJvdHRvbTogMSxcbiAgbWlkZGxlOiAxXG59O1xuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IHN0eWxlXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBUaGUgaW5wdXQgc3R5bGUuXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlKSB7XG4gIG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgZWFjaChzdHlsZS5yaWNoLCBub3JtYWxpemVTdHlsZSk7XG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUoc3R5bGUpIHtcbiAgaWYgKHN0eWxlKSB7XG4gICAgc3R5bGUuZm9udCA9IHRleHRDb250YWluLm1ha2VGb250KHN0eWxlKTtcbiAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgIHRleHRBbGlnbiA9PT0gJ21pZGRsZScgJiYgKHRleHRBbGlnbiA9ICdjZW50ZXInKTtcbiAgICBzdHlsZS50ZXh0QWxpZ24gPSB0ZXh0QWxpZ24gPT0gbnVsbCB8fCBWQUxJRF9URVhUX0FMSUdOW3RleHRBbGlnbl0gPyB0ZXh0QWxpZ24gOiAnbGVmdCc7IC8vIENvbXBhdGlibGUgd2l0aCB0ZXh0QmFzZWxpbmUuXG5cbiAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiB8fCBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgdGV4dFZlcnRpY2FsQWxpZ24gPT09ICdjZW50ZXInICYmICh0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnKTtcbiAgICBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiA9IHRleHRWZXJ0aWNhbEFsaWduID09IG51bGwgfHwgVkFMSURfVEVYVF9WRVJUSUNBTF9BTElHTlt0ZXh0VmVydGljYWxBbGlnbl0gPyB0ZXh0VmVydGljYWxBbGlnbiA6ICd0b3AnO1xuICAgIHZhciB0ZXh0UGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuXG4gICAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgICBzdHlsZS50ZXh0UGFkZGluZyA9IG5vcm1hbGl6ZUNzc0FycmF5KHN0eWxlLnRleHRQYWRkaW5nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gc3R5bGVcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFtyZWN0XSB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAqICAgICAgICAgICAgICAgICAgSWYgc2V0IGZhbHNlLCByZWN0IHRleHQgaXMgbm90IHVzZWQuXG4gKi9cblxuXG5mdW5jdGlvbiByZW5kZXJUZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCkge1xuICBzdHlsZS5yaWNoID8gcmVuZGVyUmljaFRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSA6IHJlbmRlclBsYWluVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJQbGFpblRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSB7XG4gIHZhciBmb250ID0gc2V0Q3R4KGN0eCwgJ2ZvbnQnLCBzdHlsZS5mb250IHx8IHRleHRDb250YWluLkRFRkFVTFRfRk9OVCk7XG4gIHZhciB0ZXh0UGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuICB2YXIgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrO1xuXG4gIGlmICghY29udGVudEJsb2NrIHx8IGhvc3RFbC5fX2RpcnR5KSB7XG4gICAgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrID0gdGV4dENvbnRhaW4ucGFyc2VQbGFpblRleHQodGV4dCwgZm9udCwgdGV4dFBhZGRpbmcsIHN0eWxlLnRydW5jYXRlKTtcbiAgfVxuXG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHRleHRMaW5lcyA9IGNvbnRlbnRCbG9jay5saW5lcztcbiAgdmFyIGxpbmVIZWlnaHQgPSBjb250ZW50QmxvY2subGluZUhlaWdodDtcbiAgdmFyIGJveFBvcyA9IGdldEJveFBvc2l0aW9uKG91dGVySGVpZ2h0LCBzdHlsZSwgcmVjdCk7XG4gIHZhciBiYXNlWCA9IGJveFBvcy5iYXNlWDtcbiAgdmFyIGJhc2VZID0gYm94UG9zLmJhc2VZO1xuICB2YXIgdGV4dEFsaWduID0gYm94UG9zLnRleHRBbGlnbjtcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gYm94UG9zLnRleHRWZXJ0aWNhbEFsaWduOyAvLyBPcmlnaW4gb2YgdGV4dFJvdGF0aW9uIHNob3VsZCBiZSB0aGUgYmFzZSBwb2ludCBvZiB0ZXh0IGRyYXdpbmcuXG5cbiAgYXBwbHlUZXh0Um90YXRpb24oY3R4LCBzdHlsZSwgcmVjdCwgYmFzZVgsIGJhc2VZKTtcbiAgdmFyIGJveFkgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WShiYXNlWSwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgdmFyIHRleHRYID0gYmFzZVg7XG4gIHZhciB0ZXh0WSA9IGJveFk7XG4gIHZhciBuZWVkRHJhd0JnID0gbmVlZERyYXdCYWNrZ3JvdW5kKHN0eWxlKTtcblxuICBpZiAobmVlZERyYXdCZyB8fCB0ZXh0UGFkZGluZykge1xuICAgIC8vIENvbnNpZGVyIHBlcmZvcm1hbmNlLCBkbyBub3QgY2FsbCBnZXRUZXh0V2lkdGggdXRpbCBuZWNlc3NhcnkuXG4gICAgdmFyIHRleHRXaWR0aCA9IHRleHRDb250YWluLmdldFdpZHRoKHRleHQsIGZvbnQpO1xuICAgIHZhciBvdXRlcldpZHRoID0gdGV4dFdpZHRoO1xuICAgIHRleHRQYWRkaW5nICYmIChvdXRlcldpZHRoICs9IHRleHRQYWRkaW5nWzFdICsgdGV4dFBhZGRpbmdbM10pO1xuICAgIHZhciBib3hYID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFgoYmFzZVgsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG4gICAgbmVlZERyYXdCZyAmJiBkcmF3QmFja2dyb3VuZChob3N0RWwsIGN0eCwgc3R5bGUsIGJveFgsIGJveFksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcblxuICAgIGlmICh0ZXh0UGFkZGluZykge1xuICAgICAgdGV4dFggPSBnZXRUZXh0WEZvclBhZGRpbmcoYmFzZVgsIHRleHRBbGlnbiwgdGV4dFBhZGRpbmcpO1xuICAgICAgdGV4dFkgKz0gdGV4dFBhZGRpbmdbMF07XG4gICAgfVxuICB9XG5cbiAgc2V0Q3R4KGN0eCwgJ3RleHRBbGlnbicsIHRleHRBbGlnbiB8fCAnbGVmdCcpOyAvLyBGb3JjZSBiYXNlbGluZSB0byBiZSBcIm1pZGRsZVwiLiBPdGhlcndpc2UsIGlmIHVzaW5nIFwidG9wXCIsIHRoZVxuICAvLyB0ZXh0IHdpbGwgb2Zmc2V0IGRvd253YXJkIGEgbGl0dGxlIGJpdCBpbiBmb250IFwiTWljcm9zb2Z0IFlhSGVpXCIuXG5cbiAgc2V0Q3R4KGN0eCwgJ3RleHRCYXNlbGluZScsICdtaWRkbGUnKTsgLy8gQWx3YXlzIHNldCBzaGFkb3dCbHVyIGFuZCBzaGFkb3dPZmZzZXQgdG8gYXZvaWQgbGVhayBmcm9tIGRpc3BsYXlhYmxlLlxuXG4gIHNldEN0eChjdHgsICdzaGFkb3dCbHVyJywgc3R5bGUudGV4dFNoYWRvd0JsdXIgfHwgMCk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dDb2xvcicsIHN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFgnLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WCB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFknLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSB8fCAwKTsgLy8gYHRleHRCYXNlbGluZWAgaXMgc2V0IGFzICdtaWRkbGUnLlxuXG4gIHRleHRZICs9IGxpbmVIZWlnaHQgLyAyO1xuICB2YXIgdGV4dFN0cm9rZVdpZHRoID0gc3R5bGUudGV4dFN0cm9rZVdpZHRoO1xuICB2YXIgdGV4dFN0cm9rZSA9IGdldFN0cm9rZShzdHlsZS50ZXh0U3Ryb2tlLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICB2YXIgdGV4dEZpbGwgPSBnZXRGaWxsKHN0eWxlLnRleHRGaWxsKTtcblxuICBpZiAodGV4dFN0cm9rZSkge1xuICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRTdHJva2UpO1xuICB9XG5cbiAgaWYgKHRleHRGaWxsKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2ZpbGxTdHlsZScsIHRleHRGaWxsKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gRmlsbCBhZnRlciBzdHJva2Ugc28gdGhlIG91dGxpbmUgd2lsbCBub3QgY292ZXIgdGhlIG1haW4gcGFydC5cbiAgICB0ZXh0U3Ryb2tlICYmIGN0eC5zdHJva2VUZXh0KHRleHRMaW5lc1tpXSwgdGV4dFgsIHRleHRZKTtcbiAgICB0ZXh0RmlsbCAmJiBjdHguZmlsbFRleHQodGV4dExpbmVzW2ldLCB0ZXh0WCwgdGV4dFkpO1xuICAgIHRleHRZICs9IGxpbmVIZWlnaHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyUmljaFRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2s7XG5cbiAgaWYgKCFjb250ZW50QmxvY2sgfHwgaG9zdEVsLl9fZGlydHkpIHtcbiAgICBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2sgPSB0ZXh0Q29udGFpbi5wYXJzZVJpY2hUZXh0KHRleHQsIHN0eWxlKTtcbiAgfVxuXG4gIGRyYXdSaWNoVGV4dChob3N0RWwsIGN0eCwgY29udGVudEJsb2NrLCBzdHlsZSwgcmVjdCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdSaWNoVGV4dChob3N0RWwsIGN0eCwgY29udGVudEJsb2NrLCBzdHlsZSwgcmVjdCkge1xuICB2YXIgY29udGVudFdpZHRoID0gY29udGVudEJsb2NrLndpZHRoO1xuICB2YXIgb3V0ZXJXaWR0aCA9IGNvbnRlbnRCbG9jay5vdXRlcldpZHRoO1xuICB2YXIgb3V0ZXJIZWlnaHQgPSBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQ7XG4gIHZhciB0ZXh0UGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuICB2YXIgYm94UG9zID0gZ2V0Qm94UG9zaXRpb24ob3V0ZXJIZWlnaHQsIHN0eWxlLCByZWN0KTtcbiAgdmFyIGJhc2VYID0gYm94UG9zLmJhc2VYO1xuICB2YXIgYmFzZVkgPSBib3hQb3MuYmFzZVk7XG4gIHZhciB0ZXh0QWxpZ24gPSBib3hQb3MudGV4dEFsaWduO1xuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBib3hQb3MudGV4dFZlcnRpY2FsQWxpZ247IC8vIE9yaWdpbiBvZiB0ZXh0Um90YXRpb24gc2hvdWxkIGJlIHRoZSBiYXNlIHBvaW50IG9mIHRleHQgZHJhd2luZy5cblxuICBhcHBseVRleHRSb3RhdGlvbihjdHgsIHN0eWxlLCByZWN0LCBiYXNlWCwgYmFzZVkpO1xuICB2YXIgYm94WCA9IHRleHRDb250YWluLmFkanVzdFRleHRYKGJhc2VYLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICB2YXIgYm94WSA9IHRleHRDb250YWluLmFkanVzdFRleHRZKGJhc2VZLCBvdXRlckhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pO1xuICB2YXIgeExlZnQgPSBib3hYO1xuICB2YXIgbGluZVRvcCA9IGJveFk7XG5cbiAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgeExlZnQgKz0gdGV4dFBhZGRpbmdbM107XG4gICAgbGluZVRvcCArPSB0ZXh0UGFkZGluZ1swXTtcbiAgfVxuXG4gIHZhciB4UmlnaHQgPSB4TGVmdCArIGNvbnRlbnRXaWR0aDtcbiAgbmVlZERyYXdCYWNrZ3JvdW5kKHN0eWxlKSAmJiBkcmF3QmFja2dyb3VuZChob3N0RWwsIGN0eCwgc3R5bGUsIGJveFgsIGJveFksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRCbG9jay5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gY29udGVudEJsb2NrLmxpbmVzW2ldO1xuICAgIHZhciB0b2tlbnMgPSBsaW5lLnRva2VucztcbiAgICB2YXIgdG9rZW5Db3VudCA9IHRva2Vucy5sZW5ndGg7XG4gICAgdmFyIGxpbmVIZWlnaHQgPSBsaW5lLmxpbmVIZWlnaHQ7XG4gICAgdmFyIHVzZWRXaWR0aCA9IGxpbmUud2lkdGg7XG4gICAgdmFyIGxlZnRJbmRleCA9IDA7XG4gICAgdmFyIGxpbmVYTGVmdCA9IHhMZWZ0O1xuICAgIHZhciBsaW5lWFJpZ2h0ID0geFJpZ2h0O1xuICAgIHZhciByaWdodEluZGV4ID0gdG9rZW5Db3VudCAtIDE7XG4gICAgdmFyIHRva2VuO1xuXG4gICAgd2hpbGUgKGxlZnRJbmRleCA8IHRva2VuQ291bnQgJiYgKHRva2VuID0gdG9rZW5zW2xlZnRJbmRleF0sICF0b2tlbi50ZXh0QWxpZ24gfHwgdG9rZW4udGV4dEFsaWduID09PSAnbGVmdCcpKSB7XG4gICAgICBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIGxpbmVYTGVmdCwgJ2xlZnQnKTtcbiAgICAgIHVzZWRXaWR0aCAtPSB0b2tlbi53aWR0aDtcbiAgICAgIGxpbmVYTGVmdCArPSB0b2tlbi53aWR0aDtcbiAgICAgIGxlZnRJbmRleCsrO1xuICAgIH1cblxuICAgIHdoaWxlIChyaWdodEluZGV4ID49IDAgJiYgKHRva2VuID0gdG9rZW5zW3JpZ2h0SW5kZXhdLCB0b2tlbi50ZXh0QWxpZ24gPT09ICdyaWdodCcpKSB7XG4gICAgICBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIGxpbmVYUmlnaHQsICdyaWdodCcpO1xuICAgICAgdXNlZFdpZHRoIC09IHRva2VuLndpZHRoO1xuICAgICAgbGluZVhSaWdodCAtPSB0b2tlbi53aWR0aDtcbiAgICAgIHJpZ2h0SW5kZXgtLTtcbiAgICB9IC8vIFRoZSBvdGhlciB0b2tlbnMgYXJlIHBsYWNlZCBhcyB0ZXh0QWxpZ24gJ2NlbnRlcicgaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlLlxuXG5cbiAgICBsaW5lWExlZnQgKz0gKGNvbnRlbnRXaWR0aCAtIChsaW5lWExlZnQgLSB4TGVmdCkgLSAoeFJpZ2h0IC0gbGluZVhSaWdodCkgLSB1c2VkV2lkdGgpIC8gMjtcblxuICAgIHdoaWxlIChsZWZ0SW5kZXggPD0gcmlnaHRJbmRleCkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbbGVmdEluZGV4XTsgLy8gQ29uc2lkZXIgd2lkdGggc3BlY2lmaWVkIGJ5IHVzZXIsIHVzZSAnY2VudGVyJyByYXRoZXIgdGhhbiAnbGVmdCcuXG5cbiAgICAgIHBsYWNlVG9rZW4oaG9zdEVsLCBjdHgsIHRva2VuLCBzdHlsZSwgbGluZUhlaWdodCwgbGluZVRvcCwgbGluZVhMZWZ0ICsgdG9rZW4ud2lkdGggLyAyLCAnY2VudGVyJyk7XG4gICAgICBsaW5lWExlZnQgKz0gdG9rZW4ud2lkdGg7XG4gICAgICBsZWZ0SW5kZXgrKztcbiAgICB9XG5cbiAgICBsaW5lVG9wICs9IGxpbmVIZWlnaHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUZXh0Um90YXRpb24oY3R4LCBzdHlsZSwgcmVjdCwgeCwgeSkge1xuICAvLyB0ZXh0Um90YXRpb24gb25seSBhcHBseSBpbiBSZWN0VGV4dC5cbiAgaWYgKHJlY3QgJiYgc3R5bGUudGV4dFJvdGF0aW9uKSB7XG4gICAgdmFyIG9yaWdpbiA9IHN0eWxlLnRleHRPcmlnaW47XG5cbiAgICBpZiAob3JpZ2luID09PSAnY2VudGVyJykge1xuICAgICAgeCA9IHJlY3Qud2lkdGggLyAyICsgcmVjdC54O1xuICAgICAgeSA9IHJlY3QuaGVpZ2h0IC8gMiArIHJlY3QueTtcbiAgICB9IGVsc2UgaWYgKG9yaWdpbikge1xuICAgICAgeCA9IG9yaWdpblswXSArIHJlY3QueDtcbiAgICAgIHkgPSBvcmlnaW5bMV0gKyByZWN0Lnk7XG4gICAgfVxuXG4gICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTsgLy8gUG9zaXRpdmU6IGFudGljbG9ja3dpc2VcblxuICAgIGN0eC5yb3RhdGUoLXN0eWxlLnRleHRSb3RhdGlvbik7XG4gICAgY3R4LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBsYWNlVG9rZW4oaG9zdEVsLCBjdHgsIHRva2VuLCBzdHlsZSwgbGluZUhlaWdodCwgbGluZVRvcCwgeCwgdGV4dEFsaWduKSB7XG4gIHZhciB0b2tlblN0eWxlID0gc3R5bGUucmljaFt0b2tlbi5zdHlsZU5hbWVdIHx8IHt9OyAvLyAnY3R4LnRleHRCYXNlbGluZScgaXMgYWx3YXlzIHNldCBhcyAnbWlkZGxlJywgZm9yIHNha2Ugb2ZcbiAgLy8gdGhlIGJpYXMgb2YgXCJNaWNyb3NvZnQgWWFIZWlcIi5cblxuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSB0b2tlbi50ZXh0VmVydGljYWxBbGlnbjtcbiAgdmFyIHkgPSBsaW5lVG9wICsgbGluZUhlaWdodCAvIDI7XG5cbiAgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAndG9wJykge1xuICAgIHkgPSBsaW5lVG9wICsgdG9rZW4uaGVpZ2h0IC8gMjtcbiAgfSBlbHNlIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5ID0gbGluZVRvcCArIGxpbmVIZWlnaHQgLSB0b2tlbi5oZWlnaHQgLyAyO1xuICB9XG5cbiAgIXRva2VuLmlzTGluZUhvbGRlciAmJiBuZWVkRHJhd0JhY2tncm91bmQodG9rZW5TdHlsZSkgJiYgZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHRva2VuU3R5bGUsIHRleHRBbGlnbiA9PT0gJ3JpZ2h0JyA/IHggLSB0b2tlbi53aWR0aCA6IHRleHRBbGlnbiA9PT0gJ2NlbnRlcicgPyB4IC0gdG9rZW4ud2lkdGggLyAyIDogeCwgeSAtIHRva2VuLmhlaWdodCAvIDIsIHRva2VuLndpZHRoLCB0b2tlbi5oZWlnaHQpO1xuICB2YXIgdGV4dFBhZGRpbmcgPSB0b2tlbi50ZXh0UGFkZGluZztcblxuICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICB4ID0gZ2V0VGV4dFhGb3JQYWRkaW5nKHgsIHRleHRBbGlnbiwgdGV4dFBhZGRpbmcpO1xuICAgIHkgLT0gdG9rZW4uaGVpZ2h0IC8gMiAtIHRleHRQYWRkaW5nWzJdIC0gdG9rZW4udGV4dEhlaWdodCAvIDI7XG4gIH1cblxuICBzZXRDdHgoY3R4LCAnc2hhZG93Qmx1cicsIHJldHJpZXZlMyh0b2tlblN0eWxlLnRleHRTaGFkb3dCbHVyLCBzdHlsZS50ZXh0U2hhZG93Qmx1ciwgMCkpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93Q29sb3InLCB0b2tlblN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCBzdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgJ3RyYW5zcGFyZW50Jyk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRYJywgcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dFNoYWRvd09mZnNldFgsIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRYLCAwKSk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRZJywgcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dFNoYWRvd09mZnNldFksIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZLCAwKSk7XG4gIHNldEN0eChjdHgsICd0ZXh0QWxpZ24nLCB0ZXh0QWxpZ24pOyAvLyBGb3JjZSBiYXNlbGluZSB0byBiZSBcIm1pZGRsZVwiLiBPdGhlcndpc2UsIGlmIHVzaW5nIFwidG9wXCIsIHRoZVxuICAvLyB0ZXh0IHdpbGwgb2Zmc2V0IGRvd253YXJkIGEgbGl0dGxlIGJpdCBpbiBmb250IFwiTWljcm9zb2Z0IFlhSGVpXCIuXG5cbiAgc2V0Q3R4KGN0eCwgJ3RleHRCYXNlbGluZScsICdtaWRkbGUnKTtcbiAgc2V0Q3R4KGN0eCwgJ2ZvbnQnLCB0b2tlbi5mb250IHx8IHRleHRDb250YWluLkRFRkFVTFRfRk9OVCk7XG4gIHZhciB0ZXh0U3Ryb2tlID0gZ2V0U3Ryb2tlKHRva2VuU3R5bGUudGV4dFN0cm9rZSB8fCBzdHlsZS50ZXh0U3Ryb2tlLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICB2YXIgdGV4dEZpbGwgPSBnZXRGaWxsKHRva2VuU3R5bGUudGV4dEZpbGwgfHwgc3R5bGUudGV4dEZpbGwpO1xuICB2YXIgdGV4dFN0cm9rZVdpZHRoID0gcmV0cmlldmUyKHRva2VuU3R5bGUudGV4dFN0cm9rZVdpZHRoLCBzdHlsZS50ZXh0U3Ryb2tlV2lkdGgpOyAvLyBGaWxsIGFmdGVyIHN0cm9rZSBzbyB0aGUgb3V0bGluZSB3aWxsIG5vdCBjb3ZlciB0aGUgbWFpbiBwYXJ0LlxuXG4gIGlmICh0ZXh0U3Ryb2tlKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2xpbmVXaWR0aCcsIHRleHRTdHJva2VXaWR0aCk7XG4gICAgc2V0Q3R4KGN0eCwgJ3N0cm9rZVN0eWxlJywgdGV4dFN0cm9rZSk7XG4gICAgY3R4LnN0cm9rZVRleHQodG9rZW4udGV4dCwgeCwgeSk7XG4gIH1cblxuICBpZiAodGV4dEZpbGwpIHtcbiAgICBzZXRDdHgoY3R4LCAnZmlsbFN0eWxlJywgdGV4dEZpbGwpO1xuICAgIGN0eC5maWxsVGV4dCh0b2tlbi50ZXh0LCB4LCB5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZWVkRHJhd0JhY2tncm91bmQoc3R5bGUpIHtcbiAgcmV0dXJuIHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHwgc3R5bGUudGV4dEJvcmRlcldpZHRoICYmIHN0eWxlLnRleHRCb3JkZXJDb2xvcjtcbn0gLy8gc3R5bGU6IHt0ZXh0QmFja2dyb3VuZENvbG9yLCB0ZXh0Qm9yZGVyV2lkdGgsIHRleHRCb3JkZXJDb2xvciwgdGV4dEJvcmRlclJhZGl1c31cbi8vIHNoYXBlOiB7eCwgeSwgd2lkdGgsIGhlaWdodH1cblxuXG5mdW5jdGlvbiBkcmF3QmFja2dyb3VuZChob3N0RWwsIGN0eCwgc3R5bGUsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHRleHRCYWNrZ3JvdW5kQ29sb3IgPSBzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yO1xuICB2YXIgdGV4dEJvcmRlcldpZHRoID0gc3R5bGUudGV4dEJvcmRlcldpZHRoO1xuICB2YXIgdGV4dEJvcmRlckNvbG9yID0gc3R5bGUudGV4dEJvcmRlckNvbG9yO1xuICB2YXIgaXNQbGFpbkJnID0gaXNTdHJpbmcodGV4dEJhY2tncm91bmRDb2xvcik7XG4gIHNldEN0eChjdHgsICdzaGFkb3dCbHVyJywgc3R5bGUudGV4dEJveFNoYWRvd0JsdXIgfHwgMCk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dDb2xvcicsIHN0eWxlLnRleHRCb3hTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFgnLCBzdHlsZS50ZXh0Qm94U2hhZG93T2Zmc2V0WCB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFknLCBzdHlsZS50ZXh0Qm94U2hhZG93T2Zmc2V0WSB8fCAwKTtcblxuICBpZiAoaXNQbGFpbkJnIHx8IHRleHRCb3JkZXJXaWR0aCAmJiB0ZXh0Qm9yZGVyQ29sb3IpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgdmFyIHRleHRCb3JkZXJSYWRpdXMgPSBzdHlsZS50ZXh0Qm9yZGVyUmFkaXVzO1xuXG4gICAgaWYgKCF0ZXh0Qm9yZGVyUmFkaXVzKSB7XG4gICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91bmRSZWN0SGVscGVyLmJ1aWxkUGF0aChjdHgsIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgcjogdGV4dEJvcmRlclJhZGl1c1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICB9XG5cbiAgaWYgKGlzUGxhaW5CZykge1xuICAgIHNldEN0eChjdHgsICdmaWxsU3R5bGUnLCB0ZXh0QmFja2dyb3VuZENvbG9yKTtcbiAgICBjdHguZmlsbCgpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHRleHRCYWNrZ3JvdW5kQ29sb3IpKSB7XG4gICAgdmFyIGltYWdlID0gdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZTtcbiAgICBpbWFnZSA9IGltYWdlSGVscGVyLmNyZWF0ZU9yVXBkYXRlSW1hZ2UoaW1hZ2UsIG51bGwsIGhvc3RFbCwgb25CZ0ltYWdlTG9hZGVkLCB0ZXh0QmFja2dyb3VuZENvbG9yKTtcblxuICAgIGlmIChpbWFnZSAmJiBpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoaW1hZ2UpKSB7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH1cblxuICBpZiAodGV4dEJvcmRlcldpZHRoICYmIHRleHRCb3JkZXJDb2xvcikge1xuICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0Qm9yZGVyV2lkdGgpO1xuICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRCb3JkZXJDb2xvcik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQmdJbWFnZUxvYWRlZChpbWFnZSwgdGV4dEJhY2tncm91bmRDb2xvcikge1xuICAvLyBSZXBsYWNlIGltYWdlLCBzbyB0aGF0IGBjb250YWluL3RleHQuanMjcGFyc2VSaWNoVGV4dGBcbiAgLy8gd2lsbCBnZXQgY29ycmVjdCByZXN1bHQgaW4gbmV4dCB0aWNrLlxuICB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlID0gaW1hZ2U7XG59XG5cbmZ1bmN0aW9uIGdldEJveFBvc2l0aW9uKGJsb2NrSGVpaHQsIHN0eWxlLCByZWN0KSB7XG4gIHZhciBiYXNlWCA9IHN0eWxlLnggfHwgMDtcbiAgdmFyIGJhc2VZID0gc3R5bGUueSB8fCAwO1xuICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbjsgLy8gVGV4dCBwb3NpdGlvbiByZXByZXNlbnRlZCBieSBjb29yZFxuXG4gIGlmIChyZWN0KSB7XG4gICAgdmFyIHRleHRQb3NpdGlvbiA9IHN0eWxlLnRleHRQb3NpdGlvbjtcblxuICAgIGlmICh0ZXh0UG9zaXRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgLy8gUGVyY2VudFxuICAgICAgYmFzZVggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgIGJhc2VZID0gcmVjdC55ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblsxXSwgcmVjdC5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KHRleHRQb3NpdGlvbiwgcmVjdCwgc3R5bGUudGV4dERpc3RhbmNlKTtcbiAgICAgIGJhc2VYID0gcmVzLng7XG4gICAgICBiYXNlWSA9IHJlcy55OyAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cblxuICAgICAgdGV4dEFsaWduID0gdGV4dEFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IHRleHRWZXJ0aWNhbEFsaWduIHx8IHJlcy50ZXh0VmVydGljYWxBbGlnbjtcbiAgICB9IC8vIHRleHRPZmZzZXQgaXMgb25seSBzdXBwb3J0IGluIFJlY3RUZXh0LCBvdGhlcndpc2VcbiAgICAvLyB3ZSBoYXZlIHRvIGFkanVzdCBib3VuZGluZ1JlY3QgZm9yIHRleHRPZmZzZXQuXG5cblxuICAgIHZhciB0ZXh0T2Zmc2V0ID0gc3R5bGUudGV4dE9mZnNldDtcblxuICAgIGlmICh0ZXh0T2Zmc2V0KSB7XG4gICAgICBiYXNlWCArPSB0ZXh0T2Zmc2V0WzBdO1xuICAgICAgYmFzZVkgKz0gdGV4dE9mZnNldFsxXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhc2VYOiBiYXNlWCxcbiAgICBiYXNlWTogYmFzZVksXG4gICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNldEN0eChjdHgsIHByb3AsIHZhbHVlKSB7XG4gIC8vIEZJWE1FID8/PyBwZXJmb3JtYW5jZSB0cnlcbiAgLy8gaWYgKGN0eC5fX2N1cnJlbnRWYWx1ZXNbcHJvcF0gIT09IHZhbHVlKSB7XG4gIC8vIGN0eFtwcm9wXSA9IGN0eC5fX2N1cnJlbnRWYWx1ZXNbcHJvcF0gPSB2YWx1ZTtcbiAgY3R4W3Byb3BdID0gdmFsdWU7IC8vIH1cblxuICByZXR1cm4gY3R4W3Byb3BdO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cm9rZV0gSWYgc3BlY2lmaWVkLCBkbyBub3QgY2hlY2sgc3R5bGUudGV4dFN0cm9rZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGluZVdpZHRoXSBJZiBzcGVjaWZpZWQsIGRvIG5vdCBjaGVjayBzdHlsZS50ZXh0U3Ryb2tlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0eWxlXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTdHJva2Uoc3Ryb2tlLCBsaW5lV2lkdGgpIHtcbiAgcmV0dXJuIHN0cm9rZSA9PSBudWxsIHx8IGxpbmVXaWR0aCA8PSAwIHx8IHN0cm9rZSA9PT0gJ3RyYW5zcGFyZW50JyB8fCBzdHJva2UgPT09ICdub25lJyA/IG51bGwgLy8gVE9ETyBwYXR0ZXJuIGFuZCBncmFkaWVudD9cbiAgOiBzdHJva2UuaW1hZ2UgfHwgc3Ryb2tlLmNvbG9yU3RvcHMgPyAnIzAwMCcgOiBzdHJva2U7XG59XG5cbmZ1bmN0aW9uIGdldEZpbGwoZmlsbCkge1xuICByZXR1cm4gZmlsbCA9PSBudWxsIHx8IGZpbGwgPT09ICdub25lJyA/IG51bGwgLy8gVE9ETyBwYXR0ZXJuIGFuZCBncmFkaWVudD9cbiAgOiBmaWxsLmltYWdlIHx8IGZpbGwuY29sb3JTdG9wcyA/ICcjMDAwJyA6IGZpbGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGVyY2VudCh2YWx1ZSwgbWF4VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsdWUubGFzdEluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBtYXhWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldFRleHRYRm9yUGFkZGluZyh4LCB0ZXh0QWxpZ24sIHRleHRQYWRkaW5nKSB7XG4gIHJldHVybiB0ZXh0QWxpZ24gPT09ICdyaWdodCcgPyB4IC0gdGV4dFBhZGRpbmdbMV0gOiB0ZXh0QWxpZ24gPT09ICdjZW50ZXInID8geCArIHRleHRQYWRkaW5nWzNdIC8gMiAtIHRleHRQYWRkaW5nWzFdIC8gMiA6IHggKyB0ZXh0UGFkZGluZ1szXTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3R5bGV9IHN0eWxlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gbmVlZERyYXdUZXh0KHRleHQsIHN0eWxlKSB7XG4gIHJldHVybiB0ZXh0ICE9IG51bGwgJiYgKHRleHQgfHwgc3R5bGUudGV4dEJhY2tncm91bmRDb2xvciB8fCBzdHlsZS50ZXh0Qm9yZGVyV2lkdGggJiYgc3R5bGUudGV4dEJvcmRlckNvbG9yIHx8IHN0eWxlLnRleHRQYWRkaW5nKTtcbn1cblxuZXhwb3J0cy5ub3JtYWxpemVUZXh0U3R5bGUgPSBub3JtYWxpemVUZXh0U3R5bGU7XG5leHBvcnRzLnJlbmRlclRleHQgPSByZW5kZXJUZXh0O1xuZXhwb3J0cy5nZXRTdHJva2UgPSBnZXRTdHJva2U7XG5leHBvcnRzLmdldEZpbGwgPSBnZXRGaWxsO1xuZXhwb3J0cy5uZWVkRHJhd1RleHQgPSBuZWVkRHJhd1RleHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciBpbWFnZUhlbHBlciA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL2hlbHBlci9pbWFnZVwiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIGdldENvbnRleHQgPSBfdXRpbC5nZXRDb250ZXh0O1xudmFyIGV4dGVuZCA9IF91dGlsLmV4dGVuZDtcbnZhciByZXRyaWV2ZTIgPSBfdXRpbC5yZXRyaWV2ZTI7XG52YXIgcmV0cmlldmUzID0gX3V0aWwucmV0cmlldmUzO1xudmFyIHRleHRXaWR0aENhY2hlID0ge307XG52YXIgdGV4dFdpZHRoQ2FjaGVDb3VudGVyID0gMDtcbnZhciBURVhUX0NBQ0hFX01BWCA9IDUwMDA7XG52YXIgU1RZTEVfUkVHID0gL1xceyhbYS16QS1aMC05X10rKVxcfChbXn1dKilcXH0vZztcbnZhciBERUZBVUxUX0ZPTlQgPSAnMTJweCBzYW5zLXNlcmlmJzsgLy8gQXZvaWQgYXNzaWduIHRvIGFuIGV4cG9ydGVkIHZhcmlhYmxlLCBmb3IgdHJhbnNmb3JtaW5nIHRvIGNqcy5cblxudmFyIG1ldGhvZHMgPSB7fTtcblxuZnVuY3Rpb24gJG92ZXJyaWRlKG5hbWUsIGZuKSB7XG4gIG1ldGhvZHNbbmFtZV0gPSBmbjtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHdpZHRoXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRXaWR0aCh0ZXh0LCBmb250KSB7XG4gIGZvbnQgPSBmb250IHx8IERFRkFVTFRfRk9OVDtcbiAgdmFyIGtleSA9IHRleHQgKyAnOicgKyBmb250O1xuXG4gIGlmICh0ZXh0V2lkdGhDYWNoZVtrZXldKSB7XG4gICAgcmV0dXJuIHRleHRXaWR0aENhY2hlW2tleV07XG4gIH1cblxuICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuICB2YXIgd2lkdGggPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gdGV4dExpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIC8vIHRleHRDb250YWluLm1lYXN1cmVUZXh0IG1heSBiZSBvdmVycmlkZWQgaW4gU1ZHIG9yIFZNTFxuICAgIHdpZHRoID0gTWF0aC5tYXgobWVhc3VyZVRleHQodGV4dExpbmVzW2ldLCBmb250KS53aWR0aCwgd2lkdGgpO1xuICB9XG5cbiAgaWYgKHRleHRXaWR0aENhY2hlQ291bnRlciA+IFRFWFRfQ0FDSEVfTUFYKSB7XG4gICAgdGV4dFdpZHRoQ2FjaGVDb3VudGVyID0gMDtcbiAgICB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICB9XG5cbiAgdGV4dFdpZHRoQ2FjaGVDb3VudGVyKys7XG4gIHRleHRXaWR0aENhY2hlW2tleV0gPSB3aWR0aDtcbiAgcmV0dXJuIHdpZHRoO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dEFsaWduPSdsZWZ0J11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dFZlcnRpY2FsQWxpZ249J3RvcCddXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbdGV4dFBhZGRpbmddXG4gKiBAcGFyYW0ge09iamVjdH0gW3JpY2hdXG4gKiBAcGFyYW0ge09iamVjdH0gW3RydW5jYXRlXVxuICogQHJldHVybiB7T2JqZWN0fSB7eCwgeSwgd2lkdGgsIGhlaWdodCwgbGluZUhlaWdodH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nUmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgcmljaCwgdHJ1bmNhdGUpIHtcbiAgcmV0dXJuIHJpY2ggPyBnZXRSaWNoVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHJpY2gsIHRydW5jYXRlKSA6IGdldFBsYWluVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHRydW5jYXRlKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGxhaW5UZXh0UmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgdHJ1bmNhdGUpIHtcbiAgdmFyIGNvbnRlbnRCbG9jayA9IHBhcnNlUGxhaW5UZXh0KHRleHQsIGZvbnQsIHRleHRQYWRkaW5nLCB0cnVuY2F0ZSk7XG4gIHZhciBvdXRlcldpZHRoID0gZ2V0V2lkdGgodGV4dCwgZm9udCk7XG5cbiAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgb3V0ZXJXaWR0aCArPSB0ZXh0UGFkZGluZ1sxXSArIHRleHRQYWRkaW5nWzNdO1xuICB9XG5cbiAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICB2YXIgeCA9IGFkanVzdFRleHRYKDAsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG4gIHZhciB5ID0gYWRqdXN0VGV4dFkoMCwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHgsIHksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcbiAgcmVjdC5saW5lSGVpZ2h0ID0gY29udGVudEJsb2NrLmxpbmVIZWlnaHQ7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRSaWNoVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHJpY2gsIHRydW5jYXRlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSBwYXJzZVJpY2hUZXh0KHRleHQsIHtcbiAgICByaWNoOiByaWNoLFxuICAgIHRydW5jYXRlOiB0cnVuY2F0ZSxcbiAgICBmb250OiBmb250LFxuICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgIHRleHRQYWRkaW5nOiB0ZXh0UGFkZGluZ1xuICB9KTtcbiAgdmFyIG91dGVyV2lkdGggPSBjb250ZW50QmxvY2sub3V0ZXJXaWR0aDtcbiAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICB2YXIgeCA9IGFkanVzdFRleHRYKDAsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG4gIHZhciB5ID0gYWRqdXN0VGV4dFkoMCwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgb3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQpO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRBbGlnbj0nbGVmdCddXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFkanVzdGVkIHguXG4gKi9cblxuXG5mdW5jdGlvbiBhZGp1c3RUZXh0WCh4LCB3aWR0aCwgdGV4dEFsaWduKSB7XG4gIC8vIEZJWE1FIFJpZ2h0IHRvIGxlZnQgbGFuZ3VhZ2VcbiAgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gd2lkdGg7XG4gIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gd2lkdGggLyAyO1xuICB9XG5cbiAgcmV0dXJuIHg7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRWZXJ0aWNhbEFsaWduPSd0b3AnXVxuICogQHJldHVybiB7bnVtYmVyfSBBZGp1c3RlZCB5LlxuICovXG5cblxuZnVuY3Rpb24gYWRqdXN0VGV4dFkoeSwgaGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbikge1xuICBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICdtaWRkbGUnKSB7XG4gICAgeSAtPSBoZWlnaHQgLyAyO1xuICB9IGVsc2UgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJykge1xuICAgIHkgLT0gaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3Rpcm5nfSB0ZXh0UG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHt4LCB5LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWdufVxuICovXG5cblxuZnVuY3Rpb24gYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KHRleHRQb3NpdGlvbiwgcmVjdCwgZGlzdGFuY2UpIHtcbiAgdmFyIHggPSByZWN0Lng7XG4gIHZhciB5ID0gcmVjdC55O1xuICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gJ3RvcCc7XG5cbiAgc3dpdGNoICh0ZXh0UG9zaXRpb24pIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHggLT0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgeCArPSBkaXN0YW5jZSArIHdpZHRoO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSAtPSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBoZWlnaHQgKyBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGUnOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZUxlZnQnOlxuICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZVJpZ2h0JzpcbiAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVUb3AnOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZUJvdHRvbSc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgKz0gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZVRvcExlZnQnOlxuICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZVRvcFJpZ2h0JzpcbiAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVCb3R0b21MZWZ0JzpcbiAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlQm90dG9tUmlnaHQnOlxuICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgeSArPSBoZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICB0ZXh0VmVydGljYWxBbGlnbjogdGV4dFZlcnRpY2FsQWxpZ25cbiAgfTtcbn1cbi8qKlxuICogU2hvdyBlbGxpcHNpcyBpZiBvdmVyZmxvdy5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSAge3N0cmluZ30gY29udGFpbmVyV2lkdGhcbiAqIEBwYXJhbSAge3N0cmluZ30gZm9udFxuICogQHBhcmFtICB7bnVtYmVyfSBbZWxsaXBzaXM9Jy4uLiddXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5tYXhJdGVyYXRpb25zPTNdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLm1pbkNoYXI9MF0gSWYgdHJ1bmNhdGUgcmVzdWx0IGFyZSBsZXNzXG4gKiAgICAgICAgICAgICAgICAgIHRoZW4gbWluQ2hhciwgZWxsaXBzaXMgd2lsbCBub3Qgc2hvdywgd2hpY2ggaXNcbiAqICAgICAgICAgICAgICAgICAgYmV0dGVyIGZvciB1c2VyIGhpbnQgaW4gc29tZSBjYXNlcy5cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMucGxhY2Vob2xkZXI9JyddIFdoZW4gYWxsIHRydW5jYXRlZCwgdXNlIHRoZSBwbGFjZWhvbGRlci5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIHRydW5jYXRlVGV4dCh0ZXh0LCBjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFjb250YWluZXJXaWR0aCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciB0ZXh0TGluZXMgPSAodGV4dCArICcnKS5zcGxpdCgnXFxuJyk7XG4gIG9wdGlvbnMgPSBwcmVwYXJlVHJ1bmNhdGVPcHRpb25zKGNvbnRhaW5lcldpZHRoLCBmb250LCBlbGxpcHNpcywgb3B0aW9ucyk7IC8vIEZJWE1FXG4gIC8vIEl0IGlzIG5vdCBhcHByb3ByaWF0ZSB0aGF0IGV2ZXJ5IGxpbmUgaGFzICcuLi4nIHdoZW4gdHJ1bmNhdGUgbXVsdGlwbGUgbGluZXMuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHRleHRMaW5lc1tpXSA9IHRydW5jYXRlU2luZ2xlTGluZSh0ZXh0TGluZXNbaV0sIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHRleHRMaW5lcy5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRydW5jYXRlT3B0aW9ucyhjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIG9wdGlvbnMuZm9udCA9IGZvbnQ7XG4gIHZhciBlbGxpcHNpcyA9IHJldHJpZXZlMihlbGxpcHNpcywgJy4uLicpO1xuICBvcHRpb25zLm1heEl0ZXJhdGlvbnMgPSByZXRyaWV2ZTIob3B0aW9ucy5tYXhJdGVyYXRpb25zLCAyKTtcbiAgdmFyIG1pbkNoYXIgPSBvcHRpb25zLm1pbkNoYXIgPSByZXRyaWV2ZTIob3B0aW9ucy5taW5DaGFyLCAwKTsgLy8gRklYTUVcbiAgLy8gT3RoZXIgbGFuZ3VhZ2VzP1xuXG4gIG9wdGlvbnMuY25DaGFyV2lkdGggPSBnZXRXaWR0aCgn5Zu9JywgZm9udCk7IC8vIEZJWE1FXG4gIC8vIENvbnNpZGVyIHByb3BvcnRpb25hbCBmb250P1xuXG4gIHZhciBhc2NDaGFyV2lkdGggPSBvcHRpb25zLmFzY0NoYXJXaWR0aCA9IGdldFdpZHRoKCdhJywgZm9udCk7XG4gIG9wdGlvbnMucGxhY2Vob2xkZXIgPSByZXRyaWV2ZTIob3B0aW9ucy5wbGFjZWhvbGRlciwgJycpOyAvLyBFeGFtcGxlIDE6IG1pbkNoYXI6IDMsIHRleHQ6ICdhc2RmenhjdicsIHRydW5jYXRlIHJlc3VsdDogJ2FzZGYnLCBidXQgbm90OiAnYS4uLicuXG4gIC8vIEV4YW1wbGUgMjogbWluQ2hhcjogMywgdGV4dDogJ+e7tOW6picsIHRydW5jYXRlIHJlc3VsdDogJ+e7tCcsIGJ1dCBub3Q6ICcuLi4nLlxuXG4gIHZhciBjb250ZW50V2lkdGggPSBjb250YWluZXJXaWR0aCA9IE1hdGgubWF4KDAsIGNvbnRhaW5lcldpZHRoIC0gMSk7IC8vIFJlc2VydmUgc29tZSBnYXAuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5DaGFyICYmIGNvbnRlbnRXaWR0aCA+PSBhc2NDaGFyV2lkdGg7IGkrKykge1xuICAgIGNvbnRlbnRXaWR0aCAtPSBhc2NDaGFyV2lkdGg7XG4gIH1cblxuICB2YXIgZWxsaXBzaXNXaWR0aCA9IGdldFdpZHRoKGVsbGlwc2lzKTtcblxuICBpZiAoZWxsaXBzaXNXaWR0aCA+IGNvbnRlbnRXaWR0aCkge1xuICAgIGVsbGlwc2lzID0gJyc7XG4gICAgZWxsaXBzaXNXaWR0aCA9IDA7XG4gIH1cblxuICBjb250ZW50V2lkdGggPSBjb250YWluZXJXaWR0aCAtIGVsbGlwc2lzV2lkdGg7XG4gIG9wdGlvbnMuZWxsaXBzaXMgPSBlbGxpcHNpcztcbiAgb3B0aW9ucy5lbGxpcHNpc1dpZHRoID0gZWxsaXBzaXNXaWR0aDtcbiAgb3B0aW9ucy5jb250ZW50V2lkdGggPSBjb250ZW50V2lkdGg7XG4gIG9wdGlvbnMuY29udGFpbmVyV2lkdGggPSBjb250YWluZXJXaWR0aDtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlU2luZ2xlTGluZSh0ZXh0TGluZSwgb3B0aW9ucykge1xuICB2YXIgY29udGFpbmVyV2lkdGggPSBvcHRpb25zLmNvbnRhaW5lcldpZHRoO1xuICB2YXIgZm9udCA9IG9wdGlvbnMuZm9udDtcbiAgdmFyIGNvbnRlbnRXaWR0aCA9IG9wdGlvbnMuY29udGVudFdpZHRoO1xuXG4gIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgbGluZVdpZHRoID0gZ2V0V2lkdGgodGV4dExpbmUsIGZvbnQpO1xuXG4gIGlmIChsaW5lV2lkdGggPD0gY29udGFpbmVyV2lkdGgpIHtcbiAgICByZXR1cm4gdGV4dExpbmU7XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDs7IGorKykge1xuICAgIGlmIChsaW5lV2lkdGggPD0gY29udGVudFdpZHRoIHx8IGogPj0gb3B0aW9ucy5tYXhJdGVyYXRpb25zKSB7XG4gICAgICB0ZXh0TGluZSArPSBvcHRpb25zLmVsbGlwc2lzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHN1Ykxlbmd0aCA9IGogPT09IDAgPyBlc3RpbWF0ZUxlbmd0aCh0ZXh0TGluZSwgY29udGVudFdpZHRoLCBvcHRpb25zLmFzY0NoYXJXaWR0aCwgb3B0aW9ucy5jbkNoYXJXaWR0aCkgOiBsaW5lV2lkdGggPiAwID8gTWF0aC5mbG9vcih0ZXh0TGluZS5sZW5ndGggKiBjb250ZW50V2lkdGggLyBsaW5lV2lkdGgpIDogMDtcbiAgICB0ZXh0TGluZSA9IHRleHRMaW5lLnN1YnN0cigwLCBzdWJMZW5ndGgpO1xuICAgIGxpbmVXaWR0aCA9IGdldFdpZHRoKHRleHRMaW5lLCBmb250KTtcbiAgfVxuXG4gIGlmICh0ZXh0TGluZSA9PT0gJycpIHtcbiAgICB0ZXh0TGluZSA9IG9wdGlvbnMucGxhY2Vob2xkZXI7XG4gIH1cblxuICByZXR1cm4gdGV4dExpbmU7XG59XG5cbmZ1bmN0aW9uIGVzdGltYXRlTGVuZ3RoKHRleHQsIGNvbnRlbnRXaWR0aCwgYXNjQ2hhcldpZHRoLCBjbkNoYXJXaWR0aCkge1xuICB2YXIgd2lkdGggPSAwO1xuICB2YXIgaSA9IDA7XG5cbiAgZm9yICh2YXIgbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBsZW4gJiYgd2lkdGggPCBjb250ZW50V2lkdGg7IGkrKykge1xuICAgIHZhciBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICB3aWR0aCArPSAwIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IDEyNyA/IGFzY0NoYXJXaWR0aCA6IGNuQ2hhcldpZHRoO1xuICB9XG5cbiAgcmV0dXJuIGk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcmV0dXJuIHtudW1iZXJ9IGxpbmUgaGVpZ2h0XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRMaW5lSGVpZ2h0KGZvbnQpIHtcbiAgLy8gRklYTUUgQSByb3VnaCBhcHByb2FjaC5cbiAgcmV0dXJuIGdldFdpZHRoKCflm70nLCBmb250KTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpZHRoXG4gKi9cblxuXG5mdW5jdGlvbiBtZWFzdXJlVGV4dCh0ZXh0LCBmb250KSB7XG4gIHJldHVybiBtZXRob2RzLm1lYXN1cmVUZXh0KHRleHQsIGZvbnQpO1xufSAvLyBBdm9pZCBhc3NpZ24gdG8gYW4gZXhwb3J0ZWQgdmFyaWFibGUsIGZvciB0cmFuc2Zvcm1pbmcgdG8gY2pzLlxuXG5cbm1ldGhvZHMubWVhc3VyZVRleHQgPSBmdW5jdGlvbiAodGV4dCwgZm9udCkge1xuICB2YXIgY3R4ID0gZ2V0Q29udGV4dCgpO1xuICBjdHguZm9udCA9IGZvbnQgfHwgREVGQVVMVF9GT05UO1xuICByZXR1cm4gY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xufTtcbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcGFyYW0ge09iamVjdH0gW3RydW5jYXRlXVxuICogQHJldHVybiB7T2JqZWN0fSBibG9jazoge2xpbmVIZWlnaHQsIGxpbmVzLCBoZWlnaHQsIG91dGVySGVpZ2h0fVxuICogIE5vdGljZTogZm9yIHBlcmZvcm1hbmNlLCBkbyBub3QgY2FsY3VsYXRlIG91dGVyV2lkdGggdXRpbCBuZWVkZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCBwYWRkaW5nLCB0cnVuY2F0ZSkge1xuICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuICB2YXIgbGluZUhlaWdodCA9IGdldExpbmVIZWlnaHQoZm9udCk7XG4gIHZhciBsaW5lcyA9IHRleHQgPyB0ZXh0LnNwbGl0KCdcXG4nKSA6IFtdO1xuICB2YXIgaGVpZ2h0ID0gbGluZXMubGVuZ3RoICogbGluZUhlaWdodDtcbiAgdmFyIG91dGVySGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIGlmIChwYWRkaW5nKSB7XG4gICAgb3V0ZXJIZWlnaHQgKz0gcGFkZGluZ1swXSArIHBhZGRpbmdbMl07XG4gIH1cblxuICBpZiAodGV4dCAmJiB0cnVuY2F0ZSkge1xuICAgIHZhciB0cnVuY091dGVySGVpZ2h0ID0gdHJ1bmNhdGUub3V0ZXJIZWlnaHQ7XG4gICAgdmFyIHRydW5jT3V0ZXJXaWR0aCA9IHRydW5jYXRlLm91dGVyV2lkdGg7XG5cbiAgICBpZiAodHJ1bmNPdXRlckhlaWdodCAhPSBudWxsICYmIG91dGVySGVpZ2h0ID4gdHJ1bmNPdXRlckhlaWdodCkge1xuICAgICAgdGV4dCA9ICcnO1xuICAgICAgbGluZXMgPSBbXTtcbiAgICB9IGVsc2UgaWYgKHRydW5jT3V0ZXJXaWR0aCAhPSBudWxsKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHByZXBhcmVUcnVuY2F0ZU9wdGlvbnModHJ1bmNPdXRlcldpZHRoIC0gKHBhZGRpbmcgPyBwYWRkaW5nWzFdICsgcGFkZGluZ1szXSA6IDApLCBmb250LCB0cnVuY2F0ZS5lbGxpcHNpcywge1xuICAgICAgICBtaW5DaGFyOiB0cnVuY2F0ZS5taW5DaGFyLFxuICAgICAgICBwbGFjZWhvbGRlcjogdHJ1bmNhdGUucGxhY2Vob2xkZXJcbiAgICAgIH0pOyAvLyBGSVhNRVxuICAgICAgLy8gSXQgaXMgbm90IGFwcHJvcHJpYXRlIHRoYXQgZXZlcnkgbGluZSBoYXMgJy4uLicgd2hlbiB0cnVuY2F0ZSBtdWx0aXBsZSBsaW5lcy5cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpbmVzW2ldID0gdHJ1bmNhdGVTaW5nbGVMaW5lKGxpbmVzW2ldLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxpbmVzOiBsaW5lcyxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBvdXRlckhlaWdodDogb3V0ZXJIZWlnaHQsXG4gICAgbGluZUhlaWdodDogbGluZUhlaWdodFxuICB9O1xufVxuLyoqXG4gKiBGb3IgZXhhbXBsZTogJ3NvbWUgdGV4dCB7YXxzb21lIHRleHR9b3RoZXIgdGV4dHtifHNvbWUgdGV4dH14eHh7Y3x9eHh4J1xuICogQWxzbyBjb25zaWRlciAnYmJiYnthfHh4eFxcbnp6en14eHh4XFxuYWFhYScuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICogQHJldHVybiB7T2JqZWN0fSBibG9ja1xuICoge1xuICogICAgICB3aWR0aCxcbiAqICAgICAgaGVpZ2h0LFxuICogICAgICBsaW5lczogW3tcbiAqICAgICAgICAgIGxpbmVIZWlnaHQsXG4gKiAgICAgICAgICB3aWR0aCxcbiAqICAgICAgICAgIHRva2VuczogW1t7XG4gKiAgICAgICAgICAgICAgc3R5bGVOYW1lLFxuICogICAgICAgICAgICAgIHRleHQsXG4gKiAgICAgICAgICAgICAgd2lkdGgsICAgICAgLy8gaW5jbHVkZSB0ZXh0UGFkZGluZ1xuICogICAgICAgICAgICAgIGhlaWdodCwgICAgIC8vIGluY2x1ZGUgdGV4dFBhZGRpbmdcbiAqICAgICAgICAgICAgICB0ZXh0V2lkdGgsIC8vIHB1cmUgdGV4dCB3aWR0aFxuICogICAgICAgICAgICAgIHRleHRIZWlnaHQsIC8vIHB1cmUgdGV4dCBoZWlnaHRcbiAqICAgICAgICAgICAgICBsaW5lSGVpaGd0LFxuICogICAgICAgICAgICAgIGZvbnQsXG4gKiAgICAgICAgICAgICAgdGV4dEFsaWduLFxuICogICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduXG4gKiAgICAgICAgICB9XSwgWy4uLl0sIC4uLl1cbiAqICAgICAgfSwgLi4uXVxuICogfVxuICogSWYgc3R5bGVOYW1lIGlzIHVuZGVmaW5lZCwgaXQgaXMgcGxhaW4gdGV4dC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlUmljaFRleHQodGV4dCwgc3R5bGUpIHtcbiAgdmFyIGNvbnRlbnRCbG9jayA9IHtcbiAgICBsaW5lczogW10sXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG4gIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgaWYgKCF0ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRlbnRCbG9jaztcbiAgfVxuXG4gIHZhciBsYXN0SW5kZXggPSBTVFlMRV9SRUcubGFzdEluZGV4ID0gMDtcbiAgdmFyIHJlc3VsdDtcblxuICB3aGlsZSAoKHJlc3VsdCA9IFNUWUxFX1JFRy5leGVjKHRleHQpKSAhPSBudWxsKSB7XG4gICAgdmFyIG1hdGNoZWRJbmRleCA9IHJlc3VsdC5pbmRleDtcblxuICAgIGlmIChtYXRjaGVkSW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHB1c2hUb2tlbnMoY29udGVudEJsb2NrLCB0ZXh0LnN1YnN0cmluZyhsYXN0SW5kZXgsIG1hdGNoZWRJbmRleCkpO1xuICAgIH1cblxuICAgIHB1c2hUb2tlbnMoY29udGVudEJsb2NrLCByZXN1bHRbMl0sIHJlc3VsdFsxXSk7XG4gICAgbGFzdEluZGV4ID0gU1RZTEVfUkVHLmxhc3RJbmRleDtcbiAgfVxuXG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHB1c2hUb2tlbnMoY29udGVudEJsb2NrLCB0ZXh0LnN1YnN0cmluZyhsYXN0SW5kZXgsIHRleHQubGVuZ3RoKSk7XG4gIH1cblxuICB2YXIgbGluZXMgPSBjb250ZW50QmxvY2subGluZXM7XG4gIHZhciBjb250ZW50SGVpZ2h0ID0gMDtcbiAgdmFyIGNvbnRlbnRXaWR0aCA9IDA7IC8vIEZvciBgdGV4dFdpZHRoOiAxMDAlYFxuXG4gIHZhciBwZW5kaW5nTGlzdCA9IFtdO1xuICB2YXIgc3RsUGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuICB2YXIgdHJ1bmNhdGUgPSBzdHlsZS50cnVuY2F0ZTtcbiAgdmFyIHRydW5jYXRlV2lkdGggPSB0cnVuY2F0ZSAmJiB0cnVuY2F0ZS5vdXRlcldpZHRoO1xuICB2YXIgdHJ1bmNhdGVIZWlnaHQgPSB0cnVuY2F0ZSAmJiB0cnVuY2F0ZS5vdXRlckhlaWdodDtcblxuICBpZiAoc3RsUGFkZGluZykge1xuICAgIHRydW5jYXRlV2lkdGggIT0gbnVsbCAmJiAodHJ1bmNhdGVXaWR0aCAtPSBzdGxQYWRkaW5nWzFdICsgc3RsUGFkZGluZ1szXSk7XG4gICAgdHJ1bmNhdGVIZWlnaHQgIT0gbnVsbCAmJiAodHJ1bmNhdGVIZWlnaHQgLT0gc3RsUGFkZGluZ1swXSArIHN0bFBhZGRpbmdbMl0pO1xuICB9IC8vIENhbGN1bGF0ZSBsYXlvdXQgaW5mbyBvZiB0b2tlbnMuXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICB2YXIgbGluZUhlaWdodCA9IDA7XG4gICAgdmFyIGxpbmVXaWR0aCA9IDA7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmUudG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgdG9rZW4gPSBsaW5lLnRva2Vuc1tqXTtcbiAgICAgIHZhciB0b2tlblN0eWxlID0gdG9rZW4uc3R5bGVOYW1lICYmIHN0eWxlLnJpY2hbdG9rZW4uc3R5bGVOYW1lXSB8fCB7fTsgLy8gdGV4dFBhZGRpbmcgc2hvdWxkIG5vdCBpbmhlcml0IGZyb20gc3R5bGUuXG5cbiAgICAgIHZhciB0ZXh0UGFkZGluZyA9IHRva2VuLnRleHRQYWRkaW5nID0gdG9rZW5TdHlsZS50ZXh0UGFkZGluZzsgLy8gdGV4dEZvbnQgaGFzIGJlZW4gYXNpZ25lZCB0byBmb250IGJ5IGBub3JtYWxpemVTdHlsZWAuXG5cbiAgICAgIHZhciBmb250ID0gdG9rZW4uZm9udCA9IHRva2VuU3R5bGUuZm9udCB8fCBzdHlsZS5mb250OyAvLyB0ZXh0SGVpZ2h0IGNhbiBiZSB1c2VkIHdoZW4gdGV4dFZlcnRpY2FsQWxpZ24gaXMgc3BlY2lmaWVkIGluIHRva2VuLlxuXG4gICAgICB2YXIgdG9rZW5IZWlnaHQgPSB0b2tlbi50ZXh0SGVpZ2h0ID0gcmV0cmlldmUyKCAvLyB0ZXh0SGVpZ2h0IHNob3VsZCBub3QgYmUgaW5oZXJpdGVkLCBjb25zaWRlciBpdCBjYW4gYmUgc3BlY2lmaWVkXG4gICAgICAvLyBhcyBib3ggaGVpZ2h0IG9mIHRoZSBibG9jay5cbiAgICAgIHRva2VuU3R5bGUudGV4dEhlaWdodCwgZ2V0TGluZUhlaWdodChmb250KSk7XG4gICAgICB0ZXh0UGFkZGluZyAmJiAodG9rZW5IZWlnaHQgKz0gdGV4dFBhZGRpbmdbMF0gKyB0ZXh0UGFkZGluZ1syXSk7XG4gICAgICB0b2tlbi5oZWlnaHQgPSB0b2tlbkhlaWdodDtcbiAgICAgIHRva2VuLmxpbmVIZWlnaHQgPSByZXRyaWV2ZTModG9rZW5TdHlsZS50ZXh0TGluZUhlaWdodCwgc3R5bGUudGV4dExpbmVIZWlnaHQsIHRva2VuSGVpZ2h0KTtcbiAgICAgIHRva2VuLnRleHRBbGlnbiA9IHRva2VuU3R5bGUgJiYgdG9rZW5TdHlsZS50ZXh0QWxpZ24gfHwgc3R5bGUudGV4dEFsaWduO1xuICAgICAgdG9rZW4udGV4dFZlcnRpY2FsQWxpZ24gPSB0b2tlblN0eWxlICYmIHRva2VuU3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gfHwgJ21pZGRsZSc7XG5cbiAgICAgIGlmICh0cnVuY2F0ZUhlaWdodCAhPSBudWxsICYmIGNvbnRlbnRIZWlnaHQgKyB0b2tlbi5saW5lSGVpZ2h0ID4gdHJ1bmNhdGVIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lczogW10sXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRva2VuLnRleHRXaWR0aCA9IGdldFdpZHRoKHRva2VuLnRleHQsIGZvbnQpO1xuICAgICAgdmFyIHRva2VuV2lkdGggPSB0b2tlblN0eWxlLnRleHRXaWR0aDtcbiAgICAgIHZhciB0b2tlbldpZHRoTm90U3BlY2lmaWVkID0gdG9rZW5XaWR0aCA9PSBudWxsIHx8IHRva2VuV2lkdGggPT09ICdhdXRvJzsgLy8gUGVyY2VudCB3aWR0aCwgY2FuIGJlIGAxMDAlYCwgY2FuIGJlIHVzZWQgaW4gZHJhd2luZyBzZXBhcmF0ZVxuICAgICAgLy8gbGluZSB3aGVuIGJveCB3aWR0aCBpcyBuZWVkZWQgdG8gYmUgYXV0by5cblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbldpZHRoID09PSAnc3RyaW5nJyAmJiB0b2tlbldpZHRoLmNoYXJBdCh0b2tlbldpZHRoLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgICAgdG9rZW4ucGVyY2VudFdpZHRoID0gdG9rZW5XaWR0aDtcbiAgICAgICAgcGVuZGluZ0xpc3QucHVzaCh0b2tlbik7XG4gICAgICAgIHRva2VuV2lkdGggPSAwOyAvLyBEbyBub3QgdHJ1bmNhdGUgaW4gdGhpcyBjYXNlLCBiZWNhdXNlIHRoZXJlIGlzIG5vIHVzZXIgY2FzZVxuICAgICAgICAvLyBhbmQgaXQgaXMgdG9vIGNvbXBsaWNhdGVkLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRva2VuV2lkdGhOb3RTcGVjaWZpZWQpIHtcbiAgICAgICAgICB0b2tlbldpZHRoID0gdG9rZW4udGV4dFdpZHRoOyAvLyBGSVhNRTogSWYgaW1hZ2UgaXMgbm90IGxvYWRlZCBhbmQgdGV4dFdpZHRoIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGxpbmdcbiAgICAgICAgICAvLyBgZ2V0Qm91bmRpbmdSZWN0KClgIHdpbGwgbm90IGdldCBjb3JyZWN0IHJlc3VsdC5cblxuICAgICAgICAgIHZhciB0ZXh0QmFja2dyb3VuZENvbG9yID0gdG9rZW5TdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgIHZhciBiZ0ltZyA9IHRleHRCYWNrZ3JvdW5kQ29sb3IgJiYgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZTsgLy8gVXNlIGNhc2VzOlxuICAgICAgICAgIC8vICgxKSBJZiBpbWFnZSBpcyBub3QgbG9hZGVkLCBpdCB3aWxsIGJlIGxvYWRlZCBhdCByZW5kZXIgcGhhc2UgYW5kIGNhbGxcbiAgICAgICAgICAvLyBgZGlydHkoKWAgYW5kIGB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlYCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGxvYWRlZFxuICAgICAgICAgIC8vIGltYWdlLCBhbmQgdGhlbiB0aGUgcmlnaHQgc2l6ZSB3aWxsIGJlIGNhbGN1bGF0ZWQgaGVyZSBhdCB0aGUgbmV4dCB0aWNrLlxuICAgICAgICAgIC8vIFNlZSBgZ3JhcGhpYy9oZWxwZXIvdGV4dC5qc2AuXG4gICAgICAgICAgLy8gKDIpIElmIGltYWdlIGxvYWRlZCwgYW5kIGB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlYCBpcyBpbWFnZSBzcmMgc3RyaW5nLFxuICAgICAgICAgIC8vIHVzZSBgaW1hZ2VIZWxwZXIuZmluZEV4aXN0SW1hZ2VgIHRvIGZpbmQgY2FjaGVkIGltYWdlLlxuICAgICAgICAgIC8vIGBpbWFnZUhlbHBlci5maW5kRXhpc3RJbWFnZWAgd2lsbCBhbHdheXMgYmUgY2FsbGVkIGhlcmUgYmVmb3JlXG4gICAgICAgICAgLy8gYGltYWdlSGVscGVyLmNyZWF0ZU9yVXBkYXRlSW1hZ2VgIGluIGBncmFwaGljL2hlbHBlci90ZXh0LmpzI3JlbmRlclJpY2hUZXh0YFxuICAgICAgICAgIC8vIHdoaWNoIGVuc3VyZXMgdGhhdCBpbWFnZSB3aWxsIG5vdCBiZSByZW5kZXJlZCBiZWZvcmUgY29ycmVjdCBzaXplIGNhbGN1YWx0ZWQuXG5cbiAgICAgICAgICBpZiAoYmdJbWcpIHtcbiAgICAgICAgICAgIGJnSW1nID0gaW1hZ2VIZWxwZXIuZmluZEV4aXN0SW1hZ2UoYmdJbWcpO1xuXG4gICAgICAgICAgICBpZiAoaW1hZ2VIZWxwZXIuaXNJbWFnZVJlYWR5KGJnSW1nKSkge1xuICAgICAgICAgICAgICB0b2tlbldpZHRoID0gTWF0aC5tYXgodG9rZW5XaWR0aCwgYmdJbWcud2lkdGggKiB0b2tlbkhlaWdodCAvIGJnSW1nLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhZGRpbmdXID0gdGV4dFBhZGRpbmcgPyB0ZXh0UGFkZGluZ1sxXSArIHRleHRQYWRkaW5nWzNdIDogMDtcbiAgICAgICAgdG9rZW5XaWR0aCArPSBwYWRkaW5nVztcbiAgICAgICAgdmFyIHJlbWlhblRydW5jV2lkdGggPSB0cnVuY2F0ZVdpZHRoICE9IG51bGwgPyB0cnVuY2F0ZVdpZHRoIC0gbGluZVdpZHRoIDogbnVsbDtcblxuICAgICAgICBpZiAocmVtaWFuVHJ1bmNXaWR0aCAhPSBudWxsICYmIHJlbWlhblRydW5jV2lkdGggPCB0b2tlbldpZHRoKSB7XG4gICAgICAgICAgaWYgKCF0b2tlbldpZHRoTm90U3BlY2lmaWVkIHx8IHJlbWlhblRydW5jV2lkdGggPCBwYWRkaW5nVykge1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9ICcnO1xuICAgICAgICAgICAgdG9rZW4udGV4dFdpZHRoID0gdG9rZW5XaWR0aCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSB0cnVuY2F0ZVRleHQodG9rZW4udGV4dCwgcmVtaWFuVHJ1bmNXaWR0aCAtIHBhZGRpbmdXLCBmb250LCB0cnVuY2F0ZS5lbGxpcHNpcywge1xuICAgICAgICAgICAgICBtaW5DaGFyOiB0cnVuY2F0ZS5taW5DaGFyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRva2VuLnRleHRXaWR0aCA9IGdldFdpZHRoKHRva2VuLnRleHQsIGZvbnQpO1xuICAgICAgICAgICAgdG9rZW5XaWR0aCA9IHRva2VuLnRleHRXaWR0aCArIHBhZGRpbmdXO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaW5lV2lkdGggKz0gdG9rZW4ud2lkdGggPSB0b2tlbldpZHRoO1xuICAgICAgdG9rZW5TdHlsZSAmJiAobGluZUhlaWdodCA9IE1hdGgubWF4KGxpbmVIZWlnaHQsIHRva2VuLmxpbmVIZWlnaHQpKTtcbiAgICB9XG5cbiAgICBsaW5lLndpZHRoID0gbGluZVdpZHRoO1xuICAgIGxpbmUubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgY29udGVudEhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgIGNvbnRlbnRXaWR0aCA9IE1hdGgubWF4KGNvbnRlbnRXaWR0aCwgbGluZVdpZHRoKTtcbiAgfVxuXG4gIGNvbnRlbnRCbG9jay5vdXRlcldpZHRoID0gY29udGVudEJsb2NrLndpZHRoID0gcmV0cmlldmUyKHN0eWxlLnRleHRXaWR0aCwgY29udGVudFdpZHRoKTtcbiAgY29udGVudEJsb2NrLm91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLmhlaWdodCA9IHJldHJpZXZlMihzdHlsZS50ZXh0SGVpZ2h0LCBjb250ZW50SGVpZ2h0KTtcblxuICBpZiAoc3RsUGFkZGluZykge1xuICAgIGNvbnRlbnRCbG9jay5vdXRlcldpZHRoICs9IHN0bFBhZGRpbmdbMV0gKyBzdGxQYWRkaW5nWzNdO1xuICAgIGNvbnRlbnRCbG9jay5vdXRlckhlaWdodCArPSBzdGxQYWRkaW5nWzBdICsgc3RsUGFkZGluZ1syXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGVuZGluZ0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSBwZW5kaW5nTGlzdFtpXTtcbiAgICB2YXIgcGVyY2VudFdpZHRoID0gdG9rZW4ucGVyY2VudFdpZHRoOyAvLyBTaG91bGQgbm90IGJhc2Ugb24gb3V0ZXJXaWR0aCwgYmVjYXVzZSB0b2tlbiBjYW4gbm90IGJlIHBsYWNlZCBvdXQgb2YgcGFkZGluZy5cblxuICAgIHRva2VuLndpZHRoID0gcGFyc2VJbnQocGVyY2VudFdpZHRoLCAxMCkgLyAxMDAgKiBjb250ZW50V2lkdGg7XG4gIH1cblxuICByZXR1cm4gY29udGVudEJsb2NrO1xufVxuXG5mdW5jdGlvbiBwdXNoVG9rZW5zKGJsb2NrLCBzdHIsIHN0eWxlTmFtZSkge1xuICB2YXIgaXNFbXB0eVN0ciA9IHN0ciA9PT0gJyc7XG4gIHZhciBzdHJzID0gc3RyLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGxpbmVzID0gYmxvY2subGluZXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRleHQgPSBzdHJzW2ldO1xuICAgIHZhciB0b2tlbiA9IHtcbiAgICAgIHN0eWxlTmFtZTogc3R5bGVOYW1lLFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIGlzTGluZUhvbGRlcjogIXRleHQgJiYgIWlzRW1wdHlTdHJcbiAgICB9OyAvLyBUaGUgZmlyc3QgdG9rZW4gc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBsYXN0IGxpbmUuXG5cbiAgICBpZiAoIWkpIHtcbiAgICAgIHZhciB0b2tlbnMgPSAobGluZXNbbGluZXMubGVuZ3RoIC0gMV0gfHwgKGxpbmVzWzBdID0ge1xuICAgICAgICB0b2tlbnM6IFtdXG4gICAgICB9KSkudG9rZW5zOyAvLyBDb25zaWRlciBjYXNlczpcbiAgICAgIC8vICgxKSAnJy5zcGxpdCgnXFxuJykgPT4gWycnLCAnXFxuJywgJyddLCB0aGUgJycgYXQgdGhlIGZpcnN0IGl0ZW1cbiAgICAgIC8vICh3aGljaCBpcyBhIHBsYWNlaG9sZGVyKSBzaG91bGQgYmUgcmVwbGFjZWQgYnkgbmV3IHRva2VuLlxuICAgICAgLy8gKDIpIEEgaW1hZ2UgYmFja2FnZSwgd2hlcmUgdG9rZW4gbGlrZXMge2F8fS5cbiAgICAgIC8vICgzKSBBIHJlZHVuZGFudCAnJyB3aWxsIGFmZmVjdCB0ZXh0QWxpZ24gaW4gbGluZS5cbiAgICAgIC8vICg0KSB0b2tlbnMgd2l0aCB0aGUgc2FtZSB0cGxOYW1lIHNob3VsZCBub3QgYmUgbWVyZ2VkLCBiZWNhdXNlXG4gICAgICAvLyB0aGV5IHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gZGlmZmVyZW50IGJveCAod2l0aCBib3JkZXIgYW5kIHBhZGRpbmcpLlxuXG4gICAgICB2YXIgdG9rZW5zTGVuID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgIHRva2Vuc0xlbiA9PT0gMSAmJiB0b2tlbnNbMF0uaXNMaW5lSG9sZGVyID8gdG9rZW5zWzBdID0gdG9rZW4gOiAvLyBDb25zaWRlciB0ZXh0IGlzICcnLCBvbmx5IGluc2VydCB3aGVuIGl0IGlzIHRoZSBcImxpbmVIb2xkZXJcIiBvclxuICAgICAgLy8gXCJlbXB0eVN0clwiLiBPdGhlcndpc2UgYSByZWR1bmRhbnQgJycgd2lsbCBhZmZlY3QgdGV4dEFsaWduIGluIGxpbmUuXG4gICAgICAodGV4dCB8fCAhdG9rZW5zTGVuIHx8IGlzRW1wdHlTdHIpICYmIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICB9IC8vIE90aGVyIHRva2VucyBhbHdheXMgc3RhcnQgYSBuZXcgbGluZS5cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgJycsIGluc2VydCBpdCBhcyBhIHBsYWNlaG9sZGVyLlxuICAgICAgICBsaW5lcy5wdXNoKHtcbiAgICAgICAgICB0b2tlbnM6IFt0b2tlbl1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUZvbnQoc3R5bGUpIHtcbiAgLy8gRklYTUUgaW4gbm9kZS1jYW52YXMgZm9udFdlaWdodCBpcyBiZWZvcmUgZm9udFN0eWxlXG4gIC8vIFVzZSBgZm9udFNpemVgIGBmb250RmFtaWx5YCB0byBjaGVjayB3aGV0aGVyIGZvbnQgcHJvcGVydGllcyBhcmUgZGVmaW5lZC5cbiAgcmV0dXJuIChzdHlsZS5mb250U2l6ZSB8fCBzdHlsZS5mb250RmFtaWx5KSAmJiBbc3R5bGUuZm9udFN0eWxlLCBzdHlsZS5mb250V2VpZ2h0LCAoc3R5bGUuZm9udFNpemUgfHwgMTIpICsgJ3B4JywgLy8gSWYgZm9udCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLCBgZm9udEZhbWlseWAgc2hvdWxkIG5vdCBiZSBpZ25vcmVkLlxuICBzdHlsZS5mb250RmFtaWx5IHx8ICdzYW5zLXNlcmlmJ10uam9pbignICcpIHx8IHN0eWxlLnRleHRGb250IHx8IHN0eWxlLmZvbnQ7XG59XG5cbmV4cG9ydHMuREVGQVVMVF9GT05UID0gREVGQVVMVF9GT05UO1xuZXhwb3J0cy4kb3ZlcnJpZGUgPSAkb3ZlcnJpZGU7XG5leHBvcnRzLmdldFdpZHRoID0gZ2V0V2lkdGg7XG5leHBvcnRzLmdldEJvdW5kaW5nUmVjdCA9IGdldEJvdW5kaW5nUmVjdDtcbmV4cG9ydHMuYWRqdXN0VGV4dFggPSBhZGp1c3RUZXh0WDtcbmV4cG9ydHMuYWRqdXN0VGV4dFkgPSBhZGp1c3RUZXh0WTtcbmV4cG9ydHMuYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0ID0gYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0O1xuZXhwb3J0cy50cnVuY2F0ZVRleHQgPSB0cnVuY2F0ZVRleHQ7XG5leHBvcnRzLmdldExpbmVIZWlnaHQgPSBnZXRMaW5lSGVpZ2h0O1xuZXhwb3J0cy5tZWFzdXJlVGV4dCA9IG1lYXN1cmVUZXh0O1xuZXhwb3J0cy5wYXJzZVBsYWluVGV4dCA9IHBhcnNlUGxhaW5UZXh0O1xuZXhwb3J0cy5wYXJzZVJpY2hUZXh0ID0gcGFyc2VSaWNoVGV4dDtcbmV4cG9ydHMubWFrZUZvbnQgPSBtYWtlRm9udDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi90ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdmVjMiA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcblxudmFyIG1hdHJpeCA9IHJlcXVpcmUoXCIuL21hdHJpeFwiKTtcblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAqL1xudmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdFxuICovXG5cbmZ1bmN0aW9uIEJvdW5kaW5nUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGlmICh3aWR0aCA8IDApIHtcbiAgICB4ID0geCArIHdpZHRoO1xuICAgIHdpZHRoID0gLXdpZHRoO1xuICB9XG5cbiAgaWYgKGhlaWdodCA8IDApIHtcbiAgICB5ID0geSArIGhlaWdodDtcbiAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuXG4gIHRoaXMueCA9IHg7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLnkgPSB5O1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59XG5cbkJvdW5kaW5nUmVjdC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBCb3VuZGluZ1JlY3QsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9IG90aGVyXG4gICAqL1xuICB1bmlvbjogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIHggPSBtYXRoTWluKG90aGVyLngsIHRoaXMueCk7XG4gICAgdmFyIHkgPSBtYXRoTWluKG90aGVyLnksIHRoaXMueSk7XG4gICAgdGhpcy53aWR0aCA9IG1hdGhNYXgob3RoZXIueCArIG90aGVyLndpZHRoLCB0aGlzLnggKyB0aGlzLndpZHRoKSAtIHg7XG4gICAgdGhpcy5oZWlnaHQgPSBtYXRoTWF4KG90aGVyLnkgKyBvdGhlci5oZWlnaHQsIHRoaXMueSArIHRoaXMuaGVpZ2h0KSAtIHk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtXG4gICAqIEBtZXRob2RzXG4gICAqL1xuICBhcHBseVRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsdCA9IFtdO1xuICAgIHZhciByYiA9IFtdO1xuICAgIHZhciBsYiA9IFtdO1xuICAgIHZhciBydCA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAobSkge1xuICAgICAgLy8gSW4gY2FzZSB1c2FnZSBsaWtlIHRoaXNcbiAgICAgIC8vIGVsLmdldEJvdW5kaW5nUmVjdCgpLmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSlcbiAgICAgIC8vIEFuZCBlbGVtZW50IGhhcyBubyB0cmFuc2Zvcm1cbiAgICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGx0WzBdID0gbGJbMF0gPSB0aGlzLng7XG4gICAgICBsdFsxXSA9IHJ0WzFdID0gdGhpcy55O1xuICAgICAgcmJbMF0gPSBydFswXSA9IHRoaXMueCArIHRoaXMud2lkdGg7XG4gICAgICByYlsxXSA9IGxiWzFdID0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKGx0LCBsdCwgbSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHJiLCByYiwgbSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKGxiLCBsYiwgbSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHJ0LCBydCwgbSk7XG4gICAgICB0aGlzLnggPSBtYXRoTWluKGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgIHRoaXMueSA9IG1hdGhNaW4obHRbMV0sIHJiWzFdLCBsYlsxXSwgcnRbMV0pO1xuICAgICAgdmFyIG1heFggPSBtYXRoTWF4KGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgIHZhciBtYXhZID0gbWF0aE1heChsdFsxXSwgcmJbMV0sIGxiWzFdLCBydFsxXSk7XG4gICAgICB0aGlzLndpZHRoID0gbWF4WCAtIHRoaXMueDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gbWF4WSAtIHRoaXMueTtcbiAgICB9O1xuICB9KCksXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBtYXRyaXggb2YgdHJhbnNmb3JtaW5nIGZyb20gc2VsZiB0byB0YXJnZXQgcmVjdFxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gYlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGNhbGN1bGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGIpIHtcbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIHN4ID0gYi53aWR0aCAvIGEud2lkdGg7XG4gICAgdmFyIHN5ID0gYi5oZWlnaHQgLyBhLmhlaWdodDtcbiAgICB2YXIgbSA9IG1hdHJpeC5jcmVhdGUoKTsgLy8g55+p6Zi15Y+z5LmYXG5cbiAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstYS54LCAtYS55XSk7XG4gICAgbWF0cml4LnNjYWxlKG0sIG0sIFtzeCwgc3ldKTtcbiAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFtiLngsIGIueV0pO1xuICAgIHJldHVybiBtO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyhtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdHxPYmplY3QpfSBiXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChiKSB7XG4gICAgaWYgKCFiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIEJvdW5kaW5nUmVjdCkpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZSBuZWdhdGl2ZSB3aWR0aC9oZWlnaHQuXG4gICAgICBiID0gQm91bmRpbmdSZWN0LmNyZWF0ZShiKTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGF4MCA9IGEueDtcbiAgICB2YXIgYXgxID0gYS54ICsgYS53aWR0aDtcbiAgICB2YXIgYXkwID0gYS55O1xuICAgIHZhciBheTEgPSBhLnkgKyBhLmhlaWdodDtcbiAgICB2YXIgYngwID0gYi54O1xuICAgIHZhciBieDEgPSBiLnggKyBiLndpZHRoO1xuICAgIHZhciBieTAgPSBiLnk7XG4gICAgdmFyIGJ5MSA9IGIueSArIGIuaGVpZ2h0O1xuICAgIHJldHVybiAhKGF4MSA8IGJ4MCB8fCBieDEgPCBheDAgfHwgYXkxIDwgYnkwIHx8IGJ5MSA8IGF5MCk7XG4gIH0sXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzO1xuICAgIHJldHVybiB4ID49IHJlY3QueCAmJiB4IDw9IHJlY3QueCArIHJlY3Qud2lkdGggJiYgeSA+PSByZWN0LnkgJiYgeSA8PSByZWN0LnkgKyByZWN0LmhlaWdodDtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvcHkgZnJvbSBhbm90aGVyIHJlY3RcbiAgICovXG4gIGNvcHk6IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHRoaXMueCA9IG90aGVyLng7XG4gICAgdGhpcy55ID0gb3RoZXIueTtcbiAgICB0aGlzLndpZHRoID0gb3RoZXIud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBvdGhlci5oZWlnaHQ7XG4gIH0sXG4gIHBsYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHRoaXMueCxcbiAgICAgIHk6IHRoaXMueSxcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fG1vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC54XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC55XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC53aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IHJlY3QuaGVpZ2h0XG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAqL1xuXG5Cb3VuZGluZ1JlY3QuY3JlYXRlID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IEJvdW5kaW5nUmVjdDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTFJVID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvTFJVXCIpO1xuXG52YXIgZ2xvYmFsSW1hZ2VDYWNoZSA9IG5ldyBMUlUoNTApO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gbmV3SW1hZ2VPclNyY1xuICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IGltYWdlXG4gKi9cblxuZnVuY3Rpb24gZmluZEV4aXN0SW1hZ2UobmV3SW1hZ2VPclNyYykge1xuICBpZiAodHlwZW9mIG5ld0ltYWdlT3JTcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGNhY2hlZEltZ09iaiA9IGdsb2JhbEltYWdlQ2FjaGUuZ2V0KG5ld0ltYWdlT3JTcmMpO1xuICAgIHJldHVybiBjYWNoZWRJbWdPYmogJiYgY2FjaGVkSW1nT2JqLmltYWdlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXdJbWFnZU9yU3JjO1xuICB9XG59XG4vKipcbiAqIENhdXRpb246IFVzZXIgc2hvdWxkIGNhY2hlIGxvYWRlZCBpbWFnZXMsIGJ1dCBub3QganVzdCBjb3VudCBvbiBMUlUuXG4gKiBDb25zaWRlciBpZiByZXF1aXJlZCBpbWFnZXMgbW9yZSB0aGFuIExSVSBzaXplLCB3aWxsIGRlYWQgbG9vcCBvY2N1cj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gbmV3SW1hZ2VPclNyY1xuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gaW1hZ2UgRXhpc3RlbnQgaW1hZ2UuXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IFtob3N0RWxdIEZvciBjYWxsaW5nIGBkaXJ0eWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIHBhcmFtczogKGltYWdlLCBjYlBheWxvYWQpXG4gKiBAcGFyYW0ge09iamVjdH0gW2NiUGF5bG9hZF0gUGF5bG9hZCBvbiBjYiBjYWxsaW5nLlxuICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IGltYWdlXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUltYWdlKG5ld0ltYWdlT3JTcmMsIGltYWdlLCBob3N0RWwsIGNiLCBjYlBheWxvYWQpIHtcbiAgaWYgKCFuZXdJbWFnZU9yU3JjKSB7XG4gICAgcmV0dXJuIGltYWdlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBuZXdJbWFnZU9yU3JjID09PSAnc3RyaW5nJykge1xuICAgIC8vIEltYWdlIHNob3VsZCBub3QgYmUgbG9hZGVkIHJlcGVhdGx5LlxuICAgIGlmIChpbWFnZSAmJiBpbWFnZS5fX3pySW1hZ2VTcmMgPT09IG5ld0ltYWdlT3JTcmMgfHwgIWhvc3RFbCkge1xuICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH0gLy8gT25seSB3aGVuIHRoZXJlIGlzIG5vIGV4aXN0ZW50IGltYWdlIG9yIGV4aXN0ZW50IGltYWdlIHNyY1xuICAgIC8vIGlzIGRpZmZlcmVudCwgdGhpcyBtZXRob2QgaXMgcmVzcG9uc2libGUgZm9yIGxvYWQuXG5cblxuICAgIHZhciBjYWNoZWRJbWdPYmogPSBnbG9iYWxJbWFnZUNhY2hlLmdldChuZXdJbWFnZU9yU3JjKTtcbiAgICB2YXIgcGVuZGluZ1dyYXAgPSB7XG4gICAgICBob3N0RWw6IGhvc3RFbCxcbiAgICAgIGNiOiBjYixcbiAgICAgIGNiUGF5bG9hZDogY2JQYXlsb2FkXG4gICAgfTtcblxuICAgIGlmIChjYWNoZWRJbWdPYmopIHtcbiAgICAgIGltYWdlID0gY2FjaGVkSW1nT2JqLmltYWdlO1xuICAgICAgIWlzSW1hZ2VSZWFkeShpbWFnZSkgJiYgY2FjaGVkSW1nT2JqLnBlbmRpbmcucHVzaChwZW5kaW5nV3JhcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICFpbWFnZSAmJiAoaW1hZ2UgPSBuZXcgSW1hZ2UoKSk7XG4gICAgICBpbWFnZS5vbmxvYWQgPSBpbWFnZU9uTG9hZDtcbiAgICAgIGdsb2JhbEltYWdlQ2FjaGUucHV0KG5ld0ltYWdlT3JTcmMsIGltYWdlLl9fY2FjaGVkSW1nT2JqID0ge1xuICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgIHBlbmRpbmc6IFtwZW5kaW5nV3JhcF1cbiAgICAgIH0pO1xuICAgICAgaW1hZ2Uuc3JjID0gaW1hZ2UuX196ckltYWdlU3JjID0gbmV3SW1hZ2VPclNyYztcbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH0gLy8gbmV3SW1hZ2VPclNyYyBpcyBhbiBIVE1MSW1hZ2VFbGVtZW50IG9yIEhUTUxDYW52YXNFbGVtZW50IG9yIENhbnZhc1xuICBlbHNlIHtcbiAgICAgIHJldHVybiBuZXdJbWFnZU9yU3JjO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW1hZ2VPbkxvYWQoKSB7XG4gIHZhciBjYWNoZWRJbWdPYmogPSB0aGlzLl9fY2FjaGVkSW1nT2JqO1xuICB0aGlzLm9ubG9hZCA9IHRoaXMuX19jYWNoZWRJbWdPYmogPSBudWxsO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FjaGVkSW1nT2JqLnBlbmRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGVuZGluZ1dyYXAgPSBjYWNoZWRJbWdPYmoucGVuZGluZ1tpXTtcbiAgICB2YXIgY2IgPSBwZW5kaW5nV3JhcC5jYjtcbiAgICBjYiAmJiBjYih0aGlzLCBwZW5kaW5nV3JhcC5jYlBheWxvYWQpO1xuICAgIHBlbmRpbmdXcmFwLmhvc3RFbC5kaXJ0eSgpO1xuICB9XG5cbiAgY2FjaGVkSW1nT2JqLnBlbmRpbmcubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gaXNJbWFnZVJlYWR5KGltYWdlKSB7XG4gIHJldHVybiBpbWFnZSAmJiBpbWFnZS53aWR0aCAmJiBpbWFnZS5oZWlnaHQ7XG59XG5cbmV4cG9ydHMuZmluZEV4aXN0SW1hZ2UgPSBmaW5kRXhpc3RJbWFnZTtcbmV4cG9ydHMuY3JlYXRlT3JVcGRhdGVJbWFnZSA9IGNyZWF0ZU9yVXBkYXRlSW1hZ2U7XG5leHBvcnRzLmlzSW1hZ2VSZWFkeSA9IGlzSW1hZ2VSZWFkeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvaW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIGJ1aWxkUGF0aChjdHgsIHNoYXBlKSB7XG4gIHZhciB4ID0gc2hhcGUueDtcbiAgdmFyIHkgPSBzaGFwZS55O1xuICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgdmFyIHIgPSBzaGFwZS5yO1xuICB2YXIgcjE7XG4gIHZhciByMjtcbiAgdmFyIHIzO1xuICB2YXIgcjQ7IC8vIENvbnZlcnQgd2lkdGggYW5kIGhlaWdodCB0byBwb3NpdGl2ZSBmb3IgYmV0dGVyIGJvcmRlclJhZGl1c1xuXG4gIGlmICh3aWR0aCA8IDApIHtcbiAgICB4ID0geCArIHdpZHRoO1xuICAgIHdpZHRoID0gLXdpZHRoO1xuICB9XG5cbiAgaWYgKGhlaWdodCA8IDApIHtcbiAgICB5ID0geSArIGhlaWdodDtcbiAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICB9XG5cbiAgaWYgKHR5cGVvZiByID09PSAnbnVtYmVyJykge1xuICAgIHIxID0gcjIgPSByMyA9IHI0ID0gcjtcbiAgfSBlbHNlIGlmIChyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBpZiAoci5sZW5ndGggPT09IDEpIHtcbiAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gclswXTtcbiAgICB9IGVsc2UgaWYgKHIubGVuZ3RoID09PSAyKSB7XG4gICAgICByMSA9IHIzID0gclswXTtcbiAgICAgIHIyID0gcjQgPSByWzFdO1xuICAgIH0gZWxzZSBpZiAoci5sZW5ndGggPT09IDMpIHtcbiAgICAgIHIxID0gclswXTtcbiAgICAgIHIyID0gcjQgPSByWzFdO1xuICAgICAgcjMgPSByWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICByMSA9IHJbMF07XG4gICAgICByMiA9IHJbMV07XG4gICAgICByMyA9IHJbMl07XG4gICAgICByNCA9IHJbM107XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHIxID0gcjIgPSByMyA9IHI0ID0gMDtcbiAgfVxuXG4gIHZhciB0b3RhbDtcblxuICBpZiAocjEgKyByMiA+IHdpZHRoKSB7XG4gICAgdG90YWwgPSByMSArIHIyO1xuICAgIHIxICo9IHdpZHRoIC8gdG90YWw7XG4gICAgcjIgKj0gd2lkdGggLyB0b3RhbDtcbiAgfVxuXG4gIGlmIChyMyArIHI0ID4gd2lkdGgpIHtcbiAgICB0b3RhbCA9IHIzICsgcjQ7XG4gICAgcjMgKj0gd2lkdGggLyB0b3RhbDtcbiAgICByNCAqPSB3aWR0aCAvIHRvdGFsO1xuICB9XG5cbiAgaWYgKHIyICsgcjMgPiBoZWlnaHQpIHtcbiAgICB0b3RhbCA9IHIyICsgcjM7XG4gICAgcjIgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgcjMgKj0gaGVpZ2h0IC8gdG90YWw7XG4gIH1cblxuICBpZiAocjEgKyByNCA+IGhlaWdodCkge1xuICAgIHRvdGFsID0gcjEgKyByNDtcbiAgICByMSAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICByNCAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgfVxuXG4gIGN0eC5tb3ZlVG8oeCArIHIxLCB5KTtcbiAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByMiwgeSk7XG4gIHIyICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcjIpO1xuICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHIzKTtcbiAgcjMgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByMywgeSArIGhlaWdodCk7XG4gIGN0eC5saW5lVG8oeCArIHI0LCB5ICsgaGVpZ2h0KTtcbiAgcjQgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHI0KTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgcjEpO1xuICByMSAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcjEsIHkpO1xufVxuXG5leHBvcnRzLmJ1aWxkUGF0aCA9IGJ1aWxkUGF0aDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcm91bmRSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY3VydmUgPSByZXF1aXJlKFwiLi9jdXJ2ZVwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciBiYm94ID0gcmVxdWlyZShcIi4vYmJveFwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuL0JvdW5kaW5nUmVjdFwiKTtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgZHByID0gX2NvbmZpZy5kZXZpY2VQaXhlbFJhdGlvO1xuXG4vKipcbiAqIFBhdGgg5Luj55CG77yM5Y+v5Lul5ZyoYGJ1aWxkUGF0aGDkuK3nlKjkuo7mm7/ku6NgY3R4YCwg5Lya5L+d5a2Y5q+P5LiqcGF0aOaTjeS9nOeahOWRveS7pOWIsHBhdGhDb21tYW5kc+WxnuaAp+S4rVxuICog5Y+v5Lul55So5LqOIGlzSW5zaWRlUGF0aCDliKTmlq3ku6Xlj4rojrflj5Zib3VuZGluZ1JlY3RcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAqIEBhdXRob3IgWWkgU2hlbiAoaHR0cDovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbi8vIFRPRE8gZ2V0VG90YWxMZW5ndGgsIGdldFBvaW50QXRMZW5ndGhcbnZhciBDTUQgPSB7XG4gIE06IDEsXG4gIEw6IDIsXG4gIEM6IDMsXG4gIFE6IDQsXG4gIEE6IDUsXG4gIFo6IDYsXG4gIC8vIFJlY3RcbiAgUjogN1xufTsgLy8gdmFyIENNRF9NRU1fU0laRSA9IHtcbi8vICAgICBNOiAzLFxuLy8gICAgIEw6IDMsXG4vLyAgICAgQzogNyxcbi8vICAgICBROiA1LFxuLy8gICAgIEE6IDksXG4vLyAgICAgUjogNSxcbi8vICAgICBaOiAxXG4vLyB9O1xuXG52YXIgbWluID0gW107XG52YXIgbWF4ID0gW107XG52YXIgbWluMiA9IFtdO1xudmFyIG1heDIgPSBbXTtcbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xudmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgbWF0aEFicyA9IE1hdGguYWJzO1xudmFyIGhhc1R5cGVkQXJyYXkgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9ICd1bmRlZmluZWQnO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBQYXRoUHJveHkgPSBmdW5jdGlvbiAobm90U2F2ZURhdGEpIHtcbiAgdGhpcy5fc2F2ZURhdGEgPSAhKG5vdFNhdmVEYXRhIHx8IGZhbHNlKTtcblxuICBpZiAodGhpcy5fc2F2ZURhdGEpIHtcbiAgICAvKipcbiAgICAgKiBQYXRoIGRhdGEuIFN0b3JlZCBhcyBmbGF0IGFycmF5XG4gICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICB9XG5cbiAgdGhpcy5fY3R4ID0gbnVsbDtcbn07XG4vKipcbiAqIOW/q+mAn+iuoeeul1BhdGjljIXlm7Tnm5LvvIjlubbkuI3mmK/mnIDlsI/ljIXlm7Tnm5LvvIlcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5cblBhdGhQcm94eS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoUHJveHksXG4gIF94aTogMCxcbiAgX3lpOiAwLFxuICBfeDA6IDAsXG4gIF95MDogMCxcbiAgLy8gVW5pdCB4LCBVbml0IHkuIFByb3ZpZGUgZm9yIGF2b2lkaW5nIGRyYXdpbmcgdGhhdCB0b28gc2hvcnQgbGluZSBzZWdtZW50XG4gIF91eDogMCxcbiAgX3V5OiAwLFxuICBfbGVuOiAwLFxuICBfbGluZURhc2g6IG51bGwsXG4gIF9kYXNoT2Zmc2V0OiAwLFxuICBfZGFzaElkeDogMCxcbiAgX2Rhc2hTdW06IDAsXG5cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgc2V0U2NhbGU6IGZ1bmN0aW9uIChzeCwgc3kpIHtcbiAgICB0aGlzLl91eCA9IG1hdGhBYnMoMSAvIGRwciAvIHN4KSB8fCAwO1xuICAgIHRoaXMuX3V5ID0gbWF0aEFicygxIC8gZHByIC8gc3kpIHx8IDA7XG4gIH0sXG4gIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3R4O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGJlZ2luUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICBjdHggJiYgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eCAmJiAodGhpcy5kcHIgPSBjdHguZHByKTsgLy8gUmVzZXRcblxuICAgIGlmICh0aGlzLl9zYXZlRGF0YSkge1xuICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGluZURhc2gpIHtcbiAgICAgIHRoaXMuX2xpbmVEYXNoID0gbnVsbDtcbiAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgbW92ZVRvOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuTSwgeCwgeSk7XG4gICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5tb3ZlVG8oeCwgeSk7IC8vIHgwLCB5MCwgeGksIHlpIOaYr+iusOW9leWcqCBfZGFzaGVkWFhYWFRvIOaWueazleS4reS9v+eUqFxuICAgIC8vIHhpLCB5aSDorrDlvZXlvZPliY3ngrksIHgwLCB5MCDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeWbnuWIsOi1t+Wni+eCueOAglxuICAgIC8vIOacieWPr+iDveWcqCBiZWdpblBhdGgg5LmL5ZCO55u05o6l6LCD55SoIGxpbmVUb++8jOi/meaXtuWAmSB4MCwgeTAg6ZyA6KaBXG4gICAgLy8g5ZyoIGxpbmVUbyDmlrnms5XkuK3orrDlvZXvvIzov5nph4zlhYjkuI3ogIPomZHov5nnp43mg4XlhrXvvIxkYXNoZWQgbGluZSDkuZ/lj6rlnKggSUUxMC0g5Lit5LiN5pSv5oyBXG5cbiAgICB0aGlzLl94MCA9IHg7XG4gICAgdGhpcy5feTAgPSB5O1xuICAgIHRoaXMuX3hpID0geDtcbiAgICB0aGlzLl95aSA9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBsaW5lVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGV4Y2VlZFVuaXQgPSBtYXRoQWJzKHggLSB0aGlzLl94aSkgPiB0aGlzLl91eCB8fCBtYXRoQWJzKHkgLSB0aGlzLl95aSkgPiB0aGlzLl91eSAvLyBGb3JjZSBkcmF3IHRoZSBmaXJzdCBzZWdtZW50XG4gICAgfHwgdGhpcy5fbGVuIDwgNTtcbiAgICB0aGlzLmFkZERhdGEoQ01ELkwsIHgsIHkpO1xuXG4gICAgaWYgKHRoaXMuX2N0eCAmJiBleGNlZWRVbml0KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZExpbmVUbyh4LCB5KSA6IHRoaXMuX2N0eC5saW5lVG8oeCwgeSk7XG4gICAgfVxuXG4gICAgaWYgKGV4Y2VlZFVuaXQpIHtcbiAgICAgIHRoaXMuX3hpID0geDtcbiAgICAgIHRoaXMuX3lpID0geTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxXG4gICAqIEBwYXJhbSAge251bWJlcn0geDJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgzXG4gICAqIEBwYXJhbSAge251bWJlcn0geTNcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuQywgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG5cbiAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZEJlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIDogdGhpcy5fY3R4LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgfVxuXG4gICAgdGhpcy5feGkgPSB4MztcbiAgICB0aGlzLl95aSA9IHkzO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5RLCB4MSwgeTEsIHgyLCB5Mik7XG5cbiAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZFF1YWRyYXRpY1RvKHgxLCB5MSwgeDIsIHkyKSA6IHRoaXMuX2N0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyKTtcbiAgICB9XG5cbiAgICB0aGlzLl94aSA9IHgyO1xuICAgIHRoaXMuX3lpID0geTI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0gY3hcbiAgICogQHBhcmFtICB7bnVtYmVyfSBjeVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBzdGFydEFuZ2xlXG4gICAqIEBwYXJhbSAge251bWJlcn0gZW5kQW5nbGVcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gYW50aWNsb2Nrd2lzZVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGFyYzogZnVuY3Rpb24gKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELkEsIGN4LCBjeSwgciwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlLCAwLCBhbnRpY2xvY2t3aXNlID8gMCA6IDEpO1xuICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHguYXJjKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpO1xuICAgIHRoaXMuX3hpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByICsgY3g7XG4gICAgdGhpcy5feWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHIgKyBjeDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gVE9ET1xuICBhcmNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICB0aGlzLl9jdHguYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIFRPRE9cbiAgcmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgdGhpcy5hZGREYXRhKENNRC5SLCB4LCB5LCB3LCBoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBjbG9zZVBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlopO1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgdmFyIHgwID0gdGhpcy5feDA7XG4gICAgdmFyIHkwID0gdGhpcy5feTA7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSAmJiB0aGlzLl9kYXNoZWRMaW5lVG8oeDAsIHkwKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICB0aGlzLl94aSA9IHgwO1xuICAgIHRoaXMuX3lpID0geTA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnRleHQg5LuO5aSW6YOo5Lyg5YWl77yM5Zug5Li65pyJ5Y+v6IO95pivIHJlYnVpbGRQYXRoIOWujOS5i+WQjuWGjSBmaWxs44CCXG4gICAqIHN0cm9rZSDlkIzmoLdcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGZpbGw6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICBjdHggJiYgY3R4LmZpbGwoKTtcbiAgICB0aGlzLnRvU3RhdGljKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBzdHJva2U6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICBjdHggJiYgY3R4LnN0cm9rZSgpO1xuICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgfSxcblxuICAvKipcbiAgICog5b+F6aG75Zyo5YW25a6D57uY5Yi25ZG95Luk5YmN6LCD55SoXG4gICAqIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgYWxsIG90aGVyIHBhdGggZHJhd2luZyBtZXRob2RzXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgc2V0TGluZURhc2g6IGZ1bmN0aW9uIChsaW5lRGFzaCkge1xuICAgIGlmIChsaW5lRGFzaCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB0aGlzLl9saW5lRGFzaCA9IGxpbmVEYXNoO1xuICAgICAgdGhpcy5fZGFzaElkeCA9IDA7XG4gICAgICB2YXIgbGluZURhc2hTdW0gPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVEYXNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpbmVEYXNoU3VtICs9IGxpbmVEYXNoW2ldO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kYXNoU3VtID0gbGluZURhc2hTdW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOW/hemhu+WcqOWFtuWug+e7mOWItuWRveS7pOWJjeiwg+eUqFxuICAgKiBNdXN0IGJlIGludm9rZWQgYmVmb3JlIGFsbCBvdGhlciBwYXRoIGRyYXdpbmcgbWV0aG9kc1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIHNldExpbmVEYXNoT2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgdGhpcy5fZGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGxlbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW47XG4gIH0sXG5cbiAgLyoqXG4gICAqIOebtOaOpeiuvue9riBQYXRoIOaVsOaNrlxuICAgKi9cbiAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAoISh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmxlbmd0aCA9PSBsZW4pICYmIGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLmRhdGFbaV0gPSBkYXRhW2ldO1xuICAgIH1cblxuICAgIHRoaXMuX2xlbiA9IGxlbjtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5a2Q6Lev5b6EXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl8QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5Pn0gcGF0aFxuICAgKi9cbiAgYXBwZW5kUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICBwYXRoID0gW3BhdGhdO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgYXBwZW5kU2l6ZSA9IDA7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX2xlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFwcGVuZFNpemUgKz0gcGF0aFtpXS5sZW4oKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVHlwZWRBcnJheSAmJiB0aGlzLmRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkob2Zmc2V0ICsgYXBwZW5kU2l6ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGFwcGVuZFBhdGhEYXRhID0gcGF0aFtpXS5kYXRhO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFwcGVuZFBhdGhEYXRhLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHRoaXMuZGF0YVtvZmZzZXQrK10gPSBhcHBlbmRQYXRoRGF0YVtrXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9sZW4gPSBvZmZzZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWhq+WFhSBQYXRoIOaVsOaNruOAglxuICAgKiDlsL3ph4/lpI3nlKjogIzkuI3nlLPmmI7mlrDnmoTmlbDnu4TjgILlpKfpg6jliIblm77lvaLph43nu5jnmoTmjIfku6TmlbDmja7plb/luqbpg73mmK/kuI3lj5jnmoTjgIJcbiAgICovXG4gIGFkZERhdGE6IGZ1bmN0aW9uIChjbWQpIHtcbiAgICBpZiAoIXRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICBpZiAodGhpcy5fbGVuICsgYXJndW1lbnRzLmxlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAvLyDlm6DkuLrkuYvliY3nmoTmlbDnu4Tlt7Lnu4/ovazmjaLmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5XG4gICAgICAvLyDmiYDku6XkuI3lpJ/nlKjml7bpnIDopoHmianlsZXkuIDkuKrmlrDnmoTliqjmgIHmlbDnu4RcbiAgICAgIHRoaXMuX2V4cGFuZERhdGEoKTtcblxuICAgICAgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YVt0aGlzLl9sZW4rK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5fcHJldkNtZCA9IGNtZDtcbiAgfSxcbiAgX2V4cGFuZERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBPbmx5IGlmIGRhdGEgaXMgRmxvYXQzMkFycmF5XG4gICAgaWYgKCEodGhpcy5kYXRhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xlbjsgaSsrKSB7XG4gICAgICAgIG5ld0RhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBuZWVkcyBqcyBpbXBsZW1lbnRlZCBkYXNoZWQgbGluZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX25lZWRzRGFzaDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9saW5lRGFzaDtcbiAgfSxcbiAgX2Rhc2hlZExpbmVUbzogZnVuY3Rpb24gKHgxLCB5MSkge1xuICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgIHZhciB5MCA9IHRoaXMuX3lpO1xuICAgIHZhciBkeCA9IHgxIC0geDA7XG4gICAgdmFyIGR5ID0geTEgLSB5MDtcbiAgICB2YXIgZGlzdCA9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB2YXIgeCA9IHgwO1xuICAgIHZhciB5ID0geTA7XG4gICAgdmFyIGRhc2g7XG4gICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgIHZhciBpZHg7XG4gICAgZHggLz0gZGlzdDtcbiAgICBkeSAvPSBkaXN0O1xuXG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgIH1cblxuICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgIHggLT0gb2Zmc2V0ICogZHg7XG4gICAgeSAtPSBvZmZzZXQgKiBkeTtcblxuICAgIHdoaWxlIChkeCA+IDAgJiYgeCA8PSB4MSB8fCBkeCA8IDAgJiYgeCA+PSB4MSB8fCBkeCA9PSAwICYmIChkeSA+IDAgJiYgeSA8PSB5MSB8fCBkeSA8IDAgJiYgeSA+PSB5MSkpIHtcbiAgICAgIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgICBkYXNoID0gbGluZURhc2hbaWR4XTtcbiAgICAgIHggKz0gZHggKiBkYXNoO1xuICAgICAgeSArPSBkeSAqIGRhc2g7XG4gICAgICB0aGlzLl9kYXNoSWR4ID0gKGlkeCArIDEpICUgbkRhc2g7IC8vIFNraXAgcG9zaXRpdmUgb2Zmc2V0XG5cbiAgICAgIGlmIChkeCA+IDAgJiYgeCA8IHgwIHx8IGR4IDwgMCAmJiB4ID4geDAgfHwgZHkgPiAwICYmIHkgPCB5MCB8fCBkeSA8IDAgJiYgeSA+IHkwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjdHhbaWR4ICUgMiA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKGR4ID49IDAgPyBtYXRoTWluKHgsIHgxKSA6IG1hdGhNYXgoeCwgeDEpLCBkeSA+PSAwID8gbWF0aE1pbih5LCB5MSkgOiBtYXRoTWF4KHksIHkxKSk7XG4gICAgfSAvLyBPZmZzZXQgZm9yIG5leHQgbGluZVRvXG5cblxuICAgIGR4ID0geCAtIHgxO1xuICAgIGR5ID0geSAtIHkxO1xuICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAtbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB9LFxuICAvLyBOb3QgYWNjdXJhdGUgZGFzaGVkIGxpbmUgdG9cbiAgX2Rhc2hlZEJlemllclRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgIHZhciB5MCA9IHRoaXMuX3lpO1xuICAgIHZhciB0O1xuICAgIHZhciBkeDtcbiAgICB2YXIgZHk7XG4gICAgdmFyIGN1YmljQXQgPSBjdXJ2ZS5jdWJpY0F0O1xuICAgIHZhciBiZXppZXJMZW4gPSAwO1xuICAgIHZhciBpZHggPSB0aGlzLl9kYXNoSWR4O1xuICAgIHZhciBuRGFzaCA9IGxpbmVEYXNoLmxlbmd0aDtcbiAgICB2YXIgeDtcbiAgICB2YXIgeTtcbiAgICB2YXIgdG1wTGVuID0gMDtcblxuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAvLyBDb252ZXJ0IHRvIHBvc2l0aXZlIG9mZnNldFxuICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICB9XG5cbiAgICBvZmZzZXQgJT0gZGFzaFN1bTsgLy8gQmV6aWVyIGFwcHJveCBsZW5ndGhcblxuICAgIGZvciAodCA9IDA7IHQgPCAxOyB0ICs9IDAuMSkge1xuICAgICAgZHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0ICsgMC4xKSAtIGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgZHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0ICsgMC4xKSAtIGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuICAgICAgYmV6aWVyTGVuICs9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9IC8vIEZpbmQgaWR4IGFmdGVyIGFkZCBvZmZzZXRcblxuXG4gICAgZm9yICg7IGlkeCA8IG5EYXNoOyBpZHgrKykge1xuICAgICAgdG1wTGVuICs9IGxpbmVEYXNoW2lkeF07XG5cbiAgICAgIGlmICh0bXBMZW4gPiBvZmZzZXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdCA9ICh0bXBMZW4gLSBvZmZzZXQpIC8gYmV6aWVyTGVuO1xuXG4gICAgd2hpbGUgKHQgPD0gMSkge1xuICAgICAgeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpOyAvLyBVc2UgbGluZSB0byBhcHByb3hpbWF0ZSBkYXNoZWQgYmV6aWVyXG4gICAgICAvLyBCYWQgcmVzdWx0IGlmIGRhc2ggaXMgbG9uZ1xuXG4gICAgICBpZHggJSAyID8gY3R4Lm1vdmVUbyh4LCB5KSA6IGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICB0ICs9IGxpbmVEYXNoW2lkeF0gLyBiZXppZXJMZW47XG4gICAgICBpZHggPSAoaWR4ICsgMSkgJSBuRGFzaDtcbiAgICB9IC8vIEZpbmlzaCB0aGUgbGFzdCBzZWdtZW50IGFuZCBjYWxjdWxhdGUgdGhlIG5ldyBvZmZzZXRcblxuXG4gICAgaWR4ICUgMiAhPT0gMCAmJiBjdHgubGluZVRvKHgzLCB5Myk7XG4gICAgZHggPSB4MyAtIHg7XG4gICAgZHkgPSB5MyAtIHk7XG4gICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIH0sXG4gIF9kYXNoZWRRdWFkcmF0aWNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgLy8gQ29udmVydCBxdWFkcmF0aWMgdG8gY3ViaWMgdXNpbmcgZGVncmVlIGVsZXZhdGlvblxuICAgIHZhciB4MyA9IHgyO1xuICAgIHZhciB5MyA9IHkyO1xuICAgIHgyID0gKHgyICsgMiAqIHgxKSAvIDM7XG4gICAgeTIgPSAoeTIgKyAyICogeTEpIC8gMztcbiAgICB4MSA9ICh0aGlzLl94aSArIDIgKiB4MSkgLyAzO1xuICAgIHkxID0gKHRoaXMuX3lpICsgMiAqIHkxKSAvIDM7XG5cbiAgICB0aGlzLl9kYXNoZWRCZXppZXJUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgfSxcblxuICAvKipcbiAgICog6L2s5oiQ6Z2Z5oCB55qEIEZsb2F0MzJBcnJheSDlh4/lsJHloIblhoXlrZjljaDnlKhcbiAgICogQ29udmVydCBkeW5hbWljIGFycmF5IHRvIHN0YXRpYyBGbG9hdDMyQXJyYXlcbiAgICovXG4gIHRvU3RhdGljOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBkYXRhLmxlbmd0aCA9IHRoaXMuX2xlbjtcblxuICAgICAgaWYgKGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgbWluWzBdID0gbWluWzFdID0gbWluMlswXSA9IG1pbjJbMV0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIG1heFswXSA9IG1heFsxXSA9IG1heDJbMF0gPSBtYXgyWzFdID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIHhpID0gMDtcbiAgICB2YXIgeWkgPSAwO1xuICAgIHZhciB4MCA9IDA7XG4gICAgdmFyIHkwID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuXG4gICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgLy9cbiAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgeGkgPSBkYXRhW2ldO1xuICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuICAgICAgICB4MCA9IHhpO1xuICAgICAgICB5MCA9IHlpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgICAgLy8g5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnkvb/nlKhcbiAgICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgbWluMlswXSA9IHgwO1xuICAgICAgICAgIG1pbjJbMV0gPSB5MDtcbiAgICAgICAgICBtYXgyWzBdID0geDA7XG4gICAgICAgICAgbWF4MlsxXSA9IHkwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgYmJveC5mcm9tTGluZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgIGJib3guZnJvbUN1YmljKHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICBiYm94LmZyb21RdWFkcmF0aWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBlbmRBbmdsZSA9IGRhdGFbaSsrXSArIHN0YXJ0QW5nbGU7IC8vIFRPRE8gQXJjIOaXi+i9rFxuXG4gICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgYW50aWNsb2Nrd2lzZSA9IDEgLSBkYXRhW2krK107XG5cbiAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAvLyDnm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICB4MCA9IG1hdGhDb3Moc3RhcnRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgeTAgPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBiYm94LmZyb21BcmMoY3gsIGN5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICB4aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICB5aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeTAgPSB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTsgLy8gVXNlIGZyb21MaW5lXG5cbiAgICAgICAgICBiYm94LmZyb21MaW5lKHgwLCB5MCwgeDAgKyB3aWR0aCwgeTAgKyBoZWlnaHQsIG1pbjIsIG1heDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBVbmlvblxuXG5cbiAgICAgIHZlYzIubWluKG1pbiwgbWluLCBtaW4yKTtcbiAgICAgIHZlYzIubWF4KG1heCwgbWF4LCBtYXgyKTtcbiAgICB9IC8vIE5vIGRhdGFcblxuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIG1pblswXSA9IG1pblsxXSA9IG1heFswXSA9IG1heFsxXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVidWlsZCBwYXRoIGZyb20gY3VycmVudCBkYXRhXG4gICAqIFJlYnVpbGQgcGF0aCB3aWxsIG5vdCBjb25zaWRlciBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmUgZGFzaC5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgcmVidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgZCA9IHRoaXMuZGF0YTtcbiAgICB2YXIgeDAsIHkwO1xuICAgIHZhciB4aSwgeWk7XG4gICAgdmFyIHgsIHk7XG4gICAgdmFyIHV4ID0gdGhpcy5fdXg7XG4gICAgdmFyIHV5ID0gdGhpcy5fdXk7XG4gICAgdmFyIGxlbiA9IHRoaXMuX2xlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgdmFyIGNtZCA9IGRbaSsrXTtcblxuICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgIC8vXG4gICAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICAgIHhpID0gZFtpXTtcbiAgICAgICAgeWkgPSBkW2kgKyAxXTtcbiAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgeTAgPSB5aTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICB4MCA9IHhpID0gZFtpKytdO1xuICAgICAgICAgIHkwID0geWkgPSBkW2krK107XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4aSwgeWkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgeCA9IGRbaSsrXTtcbiAgICAgICAgICB5ID0gZFtpKytdOyAvLyBOb3QgZHJhdyB0b28gc21hbGwgc2VnIGJldHdlZW5cblxuICAgICAgICAgIGlmIChtYXRoQWJzKHggLSB4aSkgPiB1eCB8fCBtYXRoQWJzKHkgLSB5aSkgPiB1eSB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgeGkgPSB4O1xuICAgICAgICAgICAgeWkgPSB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgeGkgPSBkW2kgLSAyXTtcbiAgICAgICAgICB5aSA9IGRbaSAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgIHlpID0gZFtpIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICB2YXIgY3ggPSBkW2krK107XG4gICAgICAgICAgdmFyIGN5ID0gZFtpKytdO1xuICAgICAgICAgIHZhciByeCA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgcnkgPSBkW2krK107XG4gICAgICAgICAgdmFyIHRoZXRhID0gZFtpKytdO1xuICAgICAgICAgIHZhciBkVGhldGEgPSBkW2krK107XG4gICAgICAgICAgdmFyIHBzaSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgZnMgPSBkW2krK107XG4gICAgICAgICAgdmFyIHIgPSByeCA+IHJ5ID8gcnggOiByeTtcbiAgICAgICAgICB2YXIgc2NhbGVYID0gcnggPiByeSA/IDEgOiByeCAvIHJ5O1xuICAgICAgICAgIHZhciBzY2FsZVkgPSByeCA+IHJ5ID8gcnkgLyByeCA6IDE7XG4gICAgICAgICAgdmFyIGlzRWxsaXBzZSA9IE1hdGguYWJzKHJ4IC0gcnkpID4gMWUtMztcbiAgICAgICAgICB2YXIgZW5kQW5nbGUgPSB0aGV0YSArIGRUaGV0YTtcblxuICAgICAgICAgIGlmIChpc0VsbGlwc2UpIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUocHNpKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmFyYyhjeCwgY3ksIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAvLyDnm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICB4MCA9IG1hdGhDb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgIHkwID0gbWF0aFNpbih0aGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgeDAgPSB4aSA9IGRbaV07XG4gICAgICAgICAgeTAgPSB5aSA9IGRbaSArIDFdO1xuICAgICAgICAgIGN0eC5yZWN0KGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICB5aSA9IHkwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblBhdGhQcm94eS5DTUQgPSBDTUQ7XG52YXIgX2RlZmF1bHQgPSBQYXRoUHJveHk7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciB2MkNyZWF0ZSA9IF92ZWN0b3IuY3JlYXRlO1xudmFyIHYyRGlzdFNxdWFyZSA9IF92ZWN0b3IuZGlzdFNxdWFyZTtcblxuLyoqXG4gKiDmm7Lnur/ovoXliqnmqKHlnZdcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2N1cnZlXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgbWF0aFBvdyA9IE1hdGgucG93O1xudmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIEVQU0lMT04gPSAxZS04O1xudmFyIEVQU0lMT05fTlVNRVJJQyA9IDFlLTQ7XG52YXIgVEhSRUVfU1FSVCA9IG1hdGhTcXJ0KDMpO1xudmFyIE9ORV9USElSRCA9IDEgLyAzOyAvLyDkuLTml7blj5jph49cblxudmFyIF92MCA9IHYyQ3JlYXRlKCk7XG5cbnZhciBfdjEgPSB2MkNyZWF0ZSgpO1xuXG52YXIgX3YyID0gdjJDcmVhdGUoKTtcblxuZnVuY3Rpb24gaXNBcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gLUVQU0lMT04gJiYgdmFsIDwgRVBTSUxPTjtcbn1cblxuZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5YC8XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY0F0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gIHZhciBvbmV0ID0gMSAtIHQ7XG4gIHJldHVybiBvbmV0ICogb25ldCAqIChvbmV0ICogcDAgKyAzICogdCAqIHAxKSArIHQgKiB0ICogKHQgKiBwMyArIDMgKiBvbmV0ICogcDIpO1xufVxuLyoqXG4gKiDorqHnrpfkuInmrKHotJ3loZ7lsJTlr7zmlbDlgLxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljRGVyaXZhdGl2ZUF0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gIHZhciBvbmV0ID0gMSAtIHQ7XG4gIHJldHVybiAzICogKCgocDEgLSBwMCkgKiBvbmV0ICsgMiAqIChwMiAtIHAxKSAqIHQpICogb25ldCArIChwMyAtIHAyKSAqIHQgKiB0KTtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5qC577yM5L2/55So55ub6YeR5YWs5byPXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmoLnmlbDnm65cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljUm9vdEF0KHAwLCBwMSwgcDIsIHAzLCB2YWwsIHJvb3RzKSB7XG4gIC8vIEV2YWx1YXRlIHJvb3RzIG9mIGN1YmljIGZ1bmN0aW9uc1xuICB2YXIgYSA9IHAzICsgMyAqIChwMSAtIHAyKSAtIHAwO1xuICB2YXIgYiA9IDMgKiAocDIgLSBwMSAqIDIgKyBwMCk7XG4gIHZhciBjID0gMyAqIChwMSAtIHAwKTtcbiAgdmFyIGQgPSBwMCAtIHZhbDtcbiAgdmFyIEEgPSBiICogYiAtIDMgKiBhICogYztcbiAgdmFyIEIgPSBiICogYyAtIDkgKiBhICogZDtcbiAgdmFyIEMgPSBjICogYyAtIDMgKiBiICogZDtcbiAgdmFyIG4gPSAwO1xuXG4gIGlmIChpc0Fyb3VuZFplcm8oQSkgJiYgaXNBcm91bmRaZXJvKEIpKSB7XG4gICAgaWYgKGlzQXJvdW5kWmVybyhiKSkge1xuICAgICAgcm9vdHNbMF0gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdDEgPSAtYyAvIGI7IC8vdDEsIHQyLCB0MywgYiBpcyBub3QgemVyb1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpc2MgPSBCICogQiAtIDQgKiBBICogQztcblxuICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgIHZhciBLID0gQiAvIEE7XG4gICAgICB2YXIgdDEgPSAtYiAvIGEgKyBLOyAvLyB0MSwgYSBpcyBub3QgemVyb1xuXG4gICAgICB2YXIgdDIgPSAtSyAvIDI7IC8vIHQyLCB0M1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICB2YXIgWTEgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgKyBkaXNjU3FydCk7XG4gICAgICB2YXIgWTIgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgLSBkaXNjU3FydCk7XG5cbiAgICAgIGlmIChZMSA8IDApIHtcbiAgICAgICAgWTEgPSAtbWF0aFBvdygtWTEsIE9ORV9USElSRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBZMSA9IG1hdGhQb3coWTEsIE9ORV9USElSRCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChZMiA8IDApIHtcbiAgICAgICAgWTIgPSAtbWF0aFBvdygtWTIsIE9ORV9USElSRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBZMiA9IG1hdGhQb3coWTIsIE9ORV9USElSRCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0MSA9ICgtYiAtIChZMSArIFkyKSkgLyAoMyAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIFQgPSAoMiAqIEEgKiBiIC0gMyAqIGEgKiBCKSAvICgyICogbWF0aFNxcnQoQSAqIEEgKiBBKSk7XG4gICAgICB2YXIgdGhldGEgPSBNYXRoLmFjb3MoVCkgLyAzO1xuICAgICAgdmFyIEFTcXJ0ID0gbWF0aFNxcnQoQSk7XG4gICAgICB2YXIgdG1wID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHQxID0gKC1iIC0gMiAqIEFTcXJ0ICogdG1wKSAvICgzICogYSk7XG4gICAgICB2YXIgdDIgPSAoLWIgKyBBU3FydCAqICh0bXAgKyBUSFJFRV9TUVJUICogTWF0aC5zaW4odGhldGEpKSkgLyAoMyAqIGEpO1xuICAgICAgdmFyIHQzID0gKC1iICsgQVNxcnQgKiAodG1wIC0gVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgfVxuXG4gICAgICBpZiAodDMgPj0gMCAmJiB0MyA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5p6B6ZmQ5YC855qE5L2N572uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IGV4dHJlbWFcbiAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5pWw55uuXG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY0V4dHJlbWEocDAsIHAxLCBwMiwgcDMsIGV4dHJlbWEpIHtcbiAgdmFyIGIgPSA2ICogcDIgLSAxMiAqIHAxICsgNiAqIHAwO1xuICB2YXIgYSA9IDkgKiBwMSArIDMgKiBwMyAtIDMgKiBwMCAtIDkgKiBwMjtcbiAgdmFyIGMgPSAzICogcDEgLSAzICogcDA7XG4gIHZhciBuID0gMDtcblxuICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgdmFyIHQxID0gLWMgLyBiO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuXG4gICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgZXh0cmVtYVswXSA9IC1iIC8gKDIgKiBhKTtcbiAgICB9IGVsc2UgaWYgKGRpc2MgPiAwKSB7XG4gICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICB2YXIgdDIgPSAoLWIgLSBkaXNjU3FydCkgLyAoMiAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIGV4dHJlbWFbbisrXSA9IHQyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuO1xufVxuLyoqXG4gKiDnu4bliIbkuInmrKHotJ3loZ7lsJTmm7Lnur9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHAzLCB0LCBvdXQpIHtcbiAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgdmFyIHAxMiA9IChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgdmFyIHAyMyA9IChwMyAtIHAyKSAqIHQgKyBwMjtcbiAgdmFyIHAwMTIgPSAocDEyIC0gcDAxKSAqIHQgKyBwMDE7XG4gIHZhciBwMTIzID0gKHAyMyAtIHAxMikgKiB0ICsgcDEyO1xuICB2YXIgcDAxMjMgPSAocDEyMyAtIHAwMTIpICogdCArIHAwMTI7IC8vIFNlZzBcblxuICBvdXRbMF0gPSBwMDtcbiAgb3V0WzFdID0gcDAxO1xuICBvdXRbMl0gPSBwMDEyO1xuICBvdXRbM10gPSBwMDEyMzsgLy8gU2VnMVxuXG4gIG91dFs0XSA9IHAwMTIzO1xuICBvdXRbNV0gPSBwMTIzO1xuICBvdXRbNl0gPSBwMjM7XG4gIG91dFs3XSA9IHAzO1xufVxuLyoqXG4gKiDmipXlsITngrnliLDkuInmrKHotJ3loZ7lsJTmm7Lnur/kuIrvvIzov5Tlm57mipXlsITot53nprvjgIJcbiAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gKiBAcGFyYW0ge251bWJlcn0geTNcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW291dF0g5oqV5bCE54K5XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY1Byb2plY3RQb2ludCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHgsIHksIG91dCkge1xuICAvLyBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI3Byb2plY3Rpb25zXG4gIHZhciB0O1xuICB2YXIgaW50ZXJ2YWwgPSAwLjAwNTtcbiAgdmFyIGQgPSBJbmZpbml0eTtcbiAgdmFyIHByZXY7XG4gIHZhciBuZXh0O1xuICB2YXIgZDE7XG4gIHZhciBkMjtcbiAgX3YwWzBdID0geDtcbiAgX3YwWzFdID0geTsgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gIC8vIFBFTkRJTkdcblxuICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgIF92MVswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIF90KTtcbiAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBfdCk7XG4gICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuXG4gICAgaWYgKGQxIDwgZCkge1xuICAgICAgdCA9IF90O1xuICAgICAgZCA9IGQxO1xuICAgIH1cbiAgfVxuXG4gIGQgPSBJbmZpbml0eTsgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHByZXYgPSB0IC0gaW50ZXJ2YWw7XG4gICAgbmV4dCA9IHQgKyBpbnRlcnZhbDsgLy8gdCAtIGludGVydmFsXG5cbiAgICBfdjFbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBwcmV2KTtcbiAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBwcmV2KTtcbiAgICBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgdCA9IHByZXY7XG4gICAgICBkID0gZDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgX3YyWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgbmV4dCk7XG4gICAgICBfdjJbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBuZXh0KTtcbiAgICAgIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcblxuICAgICAgaWYgKG5leHQgPD0gMSAmJiBkMiA8IGQpIHtcbiAgICAgICAgdCA9IG5leHQ7XG4gICAgICAgIGQgPSBkMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVydmFsICo9IDAuNTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gdFxuXG5cbiAgaWYgKG91dCkge1xuICAgIG91dFswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgIG91dFsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuICB9IC8vIGNvbnNvbGUubG9nKGludGVydmFsLCBpKTtcblxuXG4gIHJldHVybiBtYXRoU3FydChkKTtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5YC8XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY0F0KHAwLCBwMSwgcDIsIHQpIHtcbiAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgcmV0dXJuIG9uZXQgKiAob25ldCAqIHAwICsgMiAqIHQgKiBwMSkgKyB0ICogdCAqIHAyO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlr7zmlbDlgLxcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljRGVyaXZhdGl2ZUF0KHAwLCBwMSwgcDIsIHQpIHtcbiAgcmV0dXJuIDIgKiAoKDEgLSB0KSAqIChwMSAtIHAwKSArIHQgKiAocDIgLSBwMSkpO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTmlrnnqIvmoLlcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IHJvb3RzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljUm9vdEF0KHAwLCBwMSwgcDIsIHZhbCwgcm9vdHMpIHtcbiAgdmFyIGEgPSBwMCAtIDIgKiBwMSArIHAyO1xuICB2YXIgYiA9IDIgKiAocDEgLSBwMCk7XG4gIHZhciBjID0gcDAgLSB2YWw7XG4gIHZhciBuID0gMDtcblxuICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgdmFyIHQxID0gLWMgLyBiO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcblxuICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgIHZhciB0MSA9IC1iIC8gKDIgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHotJ3loZ7lsJTmlrnnqIvmnoHpmZDlgLxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNFeHRyZW11bShwMCwgcDEsIHAyKSB7XG4gIHZhciBkaXZpZGVyID0gcDAgKyBwMiAtIDIgKiBwMTtcblxuICBpZiAoZGl2aWRlciA9PT0gMCkge1xuICAgIC8vIHAxIGlzIGNlbnRlciBvZiBwMCBhbmQgcDJcbiAgICByZXR1cm4gMC41O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAocDAgLSBwMSkgLyBkaXZpZGVyO1xuICB9XG59XG4vKipcbiAqIOe7huWIhuS6jOasoei0neWhnuWwlOabsue6v1xuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IG91dFxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHQsIG91dCkge1xuICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTsgLy8gU2VnMFxuXG4gIG91dFswXSA9IHAwO1xuICBvdXRbMV0gPSBwMDE7XG4gIG91dFsyXSA9IHAwMTI7IC8vIFNlZzFcblxuICBvdXRbM10gPSBwMDEyO1xuICBvdXRbNF0gPSBwMTI7XG4gIG91dFs1XSA9IHAyO1xufVxuLyoqXG4gKiDmipXlsITngrnliLDkuozmrKHotJ3loZ7lsJTmm7Lnur/kuIrvvIzov5Tlm57mipXlsITot53nprvjgIJcbiAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXQg5oqV5bCE54K5XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSwgb3V0KSB7XG4gIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgdmFyIHQ7XG4gIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICB2YXIgZCA9IEluZmluaXR5O1xuICBfdjBbMF0gPSB4O1xuICBfdjBbMV0gPSB5OyAvLyDlhYjnspfnlaXkvLDorqHkuIDkuIvlj6/og73nmoTmnIDlsI/ot53nprvnmoQgdCDlgLxcbiAgLy8gUEVORElOR1xuXG4gIGZvciAodmFyIF90ID0gMDsgX3QgPCAxOyBfdCArPSAwLjA1KSB7XG4gICAgX3YxWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgX3QpO1xuICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIF90KTtcbiAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuXG4gICAgaWYgKGQxIDwgZCkge1xuICAgICAgdCA9IF90O1xuICAgICAgZCA9IGQxO1xuICAgIH1cbiAgfVxuXG4gIGQgPSBJbmZpbml0eTsgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgIHZhciBuZXh0ID0gdCArIGludGVydmFsOyAvLyB0IC0gaW50ZXJ2YWxcblxuICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHByZXYpO1xuICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHByZXYpO1xuICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgdCA9IHByZXY7XG4gICAgICBkID0gZDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgX3YyWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgbmV4dCk7XG4gICAgICBfdjJbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBuZXh0KTtcbiAgICAgIHZhciBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG5cbiAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgIHQgPSBuZXh0O1xuICAgICAgICBkID0gZDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHRcblxuXG4gIGlmIChvdXQpIHtcbiAgICBvdXRbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0KTtcbiAgICBvdXRbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0KTtcbiAgfSAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG5cblxuICByZXR1cm4gbWF0aFNxcnQoZCk7XG59XG5cbmV4cG9ydHMuY3ViaWNBdCA9IGN1YmljQXQ7XG5leHBvcnRzLmN1YmljRGVyaXZhdGl2ZUF0ID0gY3ViaWNEZXJpdmF0aXZlQXQ7XG5leHBvcnRzLmN1YmljUm9vdEF0ID0gY3ViaWNSb290QXQ7XG5leHBvcnRzLmN1YmljRXh0cmVtYSA9IGN1YmljRXh0cmVtYTtcbmV4cG9ydHMuY3ViaWNTdWJkaXZpZGUgPSBjdWJpY1N1YmRpdmlkZTtcbmV4cG9ydHMuY3ViaWNQcm9qZWN0UG9pbnQgPSBjdWJpY1Byb2plY3RQb2ludDtcbmV4cG9ydHMucXVhZHJhdGljQXQgPSBxdWFkcmF0aWNBdDtcbmV4cG9ydHMucXVhZHJhdGljRGVyaXZhdGl2ZUF0ID0gcXVhZHJhdGljRGVyaXZhdGl2ZUF0O1xuZXhwb3J0cy5xdWFkcmF0aWNSb290QXQgPSBxdWFkcmF0aWNSb290QXQ7XG5leHBvcnRzLnF1YWRyYXRpY0V4dHJlbXVtID0gcXVhZHJhdGljRXh0cmVtdW07XG5leHBvcnRzLnF1YWRyYXRpY1N1YmRpdmlkZSA9IHF1YWRyYXRpY1N1YmRpdmlkZTtcbmV4cG9ydHMucXVhZHJhdGljUHJvamVjdFBvaW50ID0gcXVhZHJhdGljUHJvamVjdFBvaW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdmVjMiA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcblxudmFyIGN1cnZlID0gcmVxdWlyZShcIi4vY3VydmVcIik7XG5cbi8qKlxuICogQGF1dGhvciBZaSBTaGVuKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgbWF0aE1pbiA9IE1hdGgubWluO1xudmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIFBJMiA9IE1hdGguUEkgKiAyO1xudmFyIHN0YXJ0ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBlbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGV4dHJlbWl0eSA9IHZlYzIuY3JlYXRlKCk7XG4vKipcbiAqIOS7jumhtueCueaVsOe7hOS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9pbnRzIOmhtueCueaVsOe7hFxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICovXG5cbmZ1bmN0aW9uIGZyb21Qb2ludHMocG9pbnRzLCBtaW4sIG1heCkge1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwID0gcG9pbnRzWzBdO1xuICB2YXIgbGVmdCA9IHBbMF07XG4gIHZhciByaWdodCA9IHBbMF07XG4gIHZhciB0b3AgPSBwWzFdO1xuICB2YXIgYm90dG9tID0gcFsxXTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHAgPSBwb2ludHNbaV07XG4gICAgbGVmdCA9IG1hdGhNaW4obGVmdCwgcFswXSk7XG4gICAgcmlnaHQgPSBtYXRoTWF4KHJpZ2h0LCBwWzBdKTtcbiAgICB0b3AgPSBtYXRoTWluKHRvcCwgcFsxXSk7XG4gICAgYm90dG9tID0gbWF0aE1heChib3R0b20sIHBbMV0pO1xuICB9XG5cbiAgbWluWzBdID0gbGVmdDtcbiAgbWluWzFdID0gdG9wO1xuICBtYXhbMF0gPSByaWdodDtcbiAgbWF4WzFdID0gYm90dG9tO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tTGluZSh4MCwgeTAsIHgxLCB5MSwgbWluLCBtYXgpIHtcbiAgbWluWzBdID0gbWF0aE1pbih4MCwgeDEpO1xuICBtaW5bMV0gPSBtYXRoTWluKHkwLCB5MSk7XG4gIG1heFswXSA9IG1hdGhNYXgoeDAsIHgxKTtcbiAgbWF4WzFdID0gbWF0aE1heCh5MCwgeTEpO1xufVxuXG52YXIgeERpbSA9IFtdO1xudmFyIHlEaW0gPSBbXTtcbi8qKlxuICog5LuO5LiJ6Zi26LSd5aGe5bCU5puy57q/KHAwLCBwMSwgcDIsIHAzKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cbmZ1bmN0aW9uIGZyb21DdWJpYyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbiwgbWF4KSB7XG4gIHZhciBjdWJpY0V4dHJlbWEgPSBjdXJ2ZS5jdWJpY0V4dHJlbWE7XG4gIHZhciBjdWJpY0F0ID0gY3VydmUuY3ViaWNBdDtcbiAgdmFyIGk7XG4gIHZhciBuID0gY3ViaWNFeHRyZW1hKHgwLCB4MSwgeDIsIHgzLCB4RGltKTtcbiAgbWluWzBdID0gSW5maW5pdHk7XG4gIG1pblsxXSA9IEluZmluaXR5O1xuICBtYXhbMF0gPSAtSW5maW5pdHk7XG4gIG1heFsxXSA9IC1JbmZpbml0eTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB4RGltW2ldKTtcbiAgICBtaW5bMF0gPSBtYXRoTWluKHgsIG1pblswXSk7XG4gICAgbWF4WzBdID0gbWF0aE1heCh4LCBtYXhbMF0pO1xuICB9XG5cbiAgbiA9IGN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgeURpbSk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgeURpbVtpXSk7XG4gICAgbWluWzFdID0gbWF0aE1pbih5LCBtaW5bMV0pO1xuICAgIG1heFsxXSA9IG1hdGhNYXgoeSwgbWF4WzFdKTtcbiAgfVxuXG4gIG1pblswXSA9IG1hdGhNaW4oeDAsIG1pblswXSk7XG4gIG1heFswXSA9IG1hdGhNYXgoeDAsIG1heFswXSk7XG4gIG1pblswXSA9IG1hdGhNaW4oeDMsIG1pblswXSk7XG4gIG1heFswXSA9IG1hdGhNYXgoeDMsIG1heFswXSk7XG4gIG1pblsxXSA9IG1hdGhNaW4oeTAsIG1pblsxXSk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTAsIG1heFsxXSk7XG4gIG1pblsxXSA9IG1hdGhNaW4oeTMsIG1pblsxXSk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTMsIG1heFsxXSk7XG59XG4vKipcbiAqIOS7juS6jOmYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUXVhZHJhdGljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIG1pbiwgbWF4KSB7XG4gIHZhciBxdWFkcmF0aWNFeHRyZW11bSA9IGN1cnZlLnF1YWRyYXRpY0V4dHJlbXVtO1xuICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZS5xdWFkcmF0aWNBdDsgLy8gRmluZCBleHRyZW1pdGllcywgd2hlcmUgZGVyaXZhdGl2ZSBpbiB4IGRpbSBvciB5IGRpbSBpcyB6ZXJvXG5cbiAgdmFyIHR4ID0gbWF0aE1heChtYXRoTWluKHF1YWRyYXRpY0V4dHJlbXVtKHgwLCB4MSwgeDIpLCAxKSwgMCk7XG4gIHZhciB0eSA9IG1hdGhNYXgobWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh5MCwgeTEsIHkyKSwgMSksIDApO1xuICB2YXIgeCA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHR4KTtcbiAgdmFyIHkgPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0eSk7XG4gIG1pblswXSA9IG1hdGhNaW4oeDAsIHgyLCB4KTtcbiAgbWluWzFdID0gbWF0aE1pbih5MCwgeTIsIHkpO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MiwgeCk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkyLCB5KTtcbn1cbi8qKlxuICog5LuO5ZyG5byn5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICogQG1ldGhvZFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge251bWJlcn0gcnhcbiAqIEBwYXJhbSB7bnVtYmVyfSByeVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRBbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IGFudGljbG9ja3dpc2VcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tQXJjKHgsIHksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIG1pbiwgbWF4KSB7XG4gIHZhciB2ZWMyTWluID0gdmVjMi5taW47XG4gIHZhciB2ZWMyTWF4ID0gdmVjMi5tYXg7XG4gIHZhciBkaWZmID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcblxuICBpZiAoZGlmZiAlIFBJMiA8IDFlLTQgJiYgZGlmZiA+IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIG1pblswXSA9IHggLSByeDtcbiAgICBtaW5bMV0gPSB5IC0gcnk7XG4gICAgbWF4WzBdID0geCArIHJ4O1xuICAgIG1heFsxXSA9IHkgKyByeTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGFydFswXSA9IG1hdGhDb3Moc3RhcnRBbmdsZSkgKiByeCArIHg7XG4gIHN0YXJ0WzFdID0gbWF0aFNpbihzdGFydEFuZ2xlKSAqIHJ5ICsgeTtcbiAgZW5kWzBdID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIHg7XG4gIGVuZFsxXSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyB5O1xuICB2ZWMyTWluKG1pbiwgc3RhcnQsIGVuZCk7XG4gIHZlYzJNYXgobWF4LCBzdGFydCwgZW5kKTsgLy8gVGhyZXNoIHRvIFswLCBNYXRoLlBJICogMl1cblxuICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSAlIFBJMjtcblxuICBpZiAoc3RhcnRBbmdsZSA8IDApIHtcbiAgICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSArIFBJMjtcbiAgfVxuXG4gIGVuZEFuZ2xlID0gZW5kQW5nbGUgJSBQSTI7XG5cbiAgaWYgKGVuZEFuZ2xlIDwgMCkge1xuICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgKyBQSTI7XG4gIH1cblxuICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlICYmICFhbnRpY2xvY2t3aXNlKSB7XG4gICAgZW5kQW5nbGUgKz0gUEkyO1xuICB9IGVsc2UgaWYgKHN0YXJ0QW5nbGUgPCBlbmRBbmdsZSAmJiBhbnRpY2xvY2t3aXNlKSB7XG4gICAgc3RhcnRBbmdsZSArPSBQSTI7XG4gIH1cblxuICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgIHZhciB0bXAgPSBlbmRBbmdsZTtcbiAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgc3RhcnRBbmdsZSA9IHRtcDtcbiAgfSAvLyB2YXIgbnVtYmVyID0gMDtcbiAgLy8gdmFyIHN0ZXAgPSAoYW50aWNsb2Nrd2lzZSA/IC1NYXRoLlBJIDogTWF0aC5QSSkgLyAyO1xuXG5cbiAgZm9yICh2YXIgYW5nbGUgPSAwOyBhbmdsZSA8IGVuZEFuZ2xlOyBhbmdsZSArPSBNYXRoLlBJIC8gMikge1xuICAgIGlmIChhbmdsZSA+IHN0YXJ0QW5nbGUpIHtcbiAgICAgIGV4dHJlbWl0eVswXSA9IG1hdGhDb3MoYW5nbGUpICogcnggKyB4O1xuICAgICAgZXh0cmVtaXR5WzFdID0gbWF0aFNpbihhbmdsZSkgKiByeSArIHk7XG4gICAgICB2ZWMyTWluKG1pbiwgZXh0cmVtaXR5LCBtaW4pO1xuICAgICAgdmVjMk1heChtYXgsIGV4dHJlbWl0eSwgbWF4KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5mcm9tUG9pbnRzID0gZnJvbVBvaW50cztcbmV4cG9ydHMuZnJvbUxpbmUgPSBmcm9tTGluZTtcbmV4cG9ydHMuZnJvbUN1YmljID0gZnJvbUN1YmljO1xuZXhwb3J0cy5mcm9tUXVhZHJhdGljID0gZnJvbVF1YWRyYXRpYztcbmV4cG9ydHMuZnJvbUFyYyA9IGZyb21BcmM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvYmJveC5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BhdGhQcm94eVwiKTtcblxudmFyIGxpbmUgPSByZXF1aXJlKFwiLi9saW5lXCIpO1xuXG52YXIgY3ViaWMgPSByZXF1aXJlKFwiLi9jdWJpY1wiKTtcblxudmFyIHF1YWRyYXRpYyA9IHJlcXVpcmUoXCIuL3F1YWRyYXRpY1wiKTtcblxudmFyIGFyYyA9IHJlcXVpcmUoXCIuL2FyY1wiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIG5vcm1hbGl6ZVJhZGlhbiA9IF91dGlsLm5vcm1hbGl6ZVJhZGlhbjtcblxudmFyIGN1cnZlID0gcmVxdWlyZShcIi4uL2NvcmUvY3VydmVcIik7XG5cbnZhciB3aW5kaW5nTGluZSA9IHJlcXVpcmUoXCIuL3dpbmRpbmdMaW5lXCIpO1xuXG52YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbnZhciBFUFNJTE9OID0gMWUtNDtcblxuZnVuY3Rpb24gaXNBcm91bmRFcXVhbChhLCBiKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBFUFNJTE9OO1xufSAvLyDkuLTml7bmlbDnu4RcblxuXG52YXIgcm9vdHMgPSBbLTEsIC0xLCAtMV07XG52YXIgZXh0cmVtYSA9IFstMSwgLTFdO1xuXG5mdW5jdGlvbiBzd2FwRXh0cmVtYSgpIHtcbiAgdmFyIHRtcCA9IGV4dHJlbWFbMF07XG4gIGV4dHJlbWFbMF0gPSBleHRyZW1hWzFdO1xuICBleHRyZW1hWzFdID0gdG1wO1xufVxuXG5mdW5jdGlvbiB3aW5kaW5nQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5KSB7XG4gIC8vIFF1aWNrIHJlamVjdFxuICBpZiAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIgJiYgeSA+IHkzIHx8IHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyICYmIHkgPCB5Mykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIG5Sb290cyA9IGN1cnZlLmN1YmljUm9vdEF0KHkwLCB5MSwgeTIsIHkzLCB5LCByb290cyk7XG5cbiAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHZhciB3ID0gMDtcbiAgICB2YXIgbkV4dHJlbWEgPSAtMTtcbiAgICB2YXIgeTBfLCB5MV87XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHJvb3RzW2ldOyAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cblxuICAgICAgdmFyIHVuaXQgPSB0ID09PSAwIHx8IHQgPT09IDEgPyAwLjUgOiAxO1xuICAgICAgdmFyIHhfID0gY3VydmUuY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG5cbiAgICAgIGlmICh4XyA8IHgpIHtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobkV4dHJlbWEgPCAwKSB7XG4gICAgICAgIG5FeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hKHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hKTtcblxuICAgICAgICBpZiAoZXh0cmVtYVsxXSA8IGV4dHJlbWFbMF0gJiYgbkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgc3dhcEV4dHJlbWEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHkwXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMF0pO1xuXG4gICAgICAgIGlmIChuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICB5MV8gPSBjdXJ2ZS5jdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobkV4dHJlbWEgPT0gMikge1xuICAgICAgICAvLyDliIbmiJDkuInmrrXljZXosIPlh73mlbBcbiAgICAgICAgaWYgKHQgPCBleHRyZW1hWzBdKSB7XG4gICAgICAgICAgdyArPSB5MF8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgZXh0cmVtYVsxXSkge1xuICAgICAgICAgIHcgKz0geTFfIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0geTMgPCB5MV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIOWIhuaIkOS4pOauteWNleiwg+WHveaVsFxuICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICB3ICs9IHkwXyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0geTMgPCB5MF8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxufVxuXG5mdW5jdGlvbiB3aW5kaW5nUXVhZHJhdGljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgLy8gUXVpY2sgcmVqZWN0XG4gIGlmICh5ID4geTAgJiYgeSA+IHkxICYmIHkgPiB5MiB8fCB5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5Mikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIG5Sb290cyA9IGN1cnZlLnF1YWRyYXRpY1Jvb3RBdCh5MCwgeTEsIHkyLCB5LCByb290cyk7XG5cbiAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHZhciB0ID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5Mik7XG5cbiAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgdmFyIHcgPSAwO1xuICAgICAgdmFyIHlfID0gY3VydmUucXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJvb3RzOyBpKyspIHtcbiAgICAgICAgLy8gUmVtb3ZlIG9uZSBlbmRwb2ludC5cbiAgICAgICAgdmFyIHVuaXQgPSByb290c1tpXSA9PT0gMCB8fCByb290c1tpXSA9PT0gMSA/IDAuNSA6IDE7XG4gICAgICAgIHZhciB4XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHJvb3RzW2ldKTtcblxuICAgICAgICBpZiAoeF8gPCB4KSB7XG4gICAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm9vdHNbaV0gPCB0KSB7XG4gICAgICAgICAgdyArPSB5XyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0geTIgPCB5XyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIG9uZSBlbmRwb2ludC5cbiAgICAgIHZhciB1bml0ID0gcm9vdHNbMF0gPT09IDAgfHwgcm9vdHNbMF0gPT09IDEgPyAwLjUgOiAxO1xuICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbMF0pO1xuXG4gICAgICBpZiAoeF8gPCB4KSB7XG4gICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHkyIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgfVxuICB9XG59IC8vIFRPRE9cbi8vIEFyYyDml4vovaxcblxuXG5mdW5jdGlvbiB3aW5kaW5nQXJjKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHgsIHkpIHtcbiAgeSAtPSBjeTtcblxuICBpZiAoeSA+IHIgfHwgeSA8IC1yKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgdG1wID0gTWF0aC5zcXJ0KHIgKiByIC0geSAqIHkpO1xuICByb290c1swXSA9IC10bXA7XG4gIHJvb3RzWzFdID0gdG1wO1xuICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG5cbiAgaWYgKGRpZmYgPCAxZS00KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoZGlmZiAlIFBJMiA8IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIHN0YXJ0QW5nbGUgPSAwO1xuICAgIGVuZEFuZ2xlID0gUEkyO1xuICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuXG4gICAgaWYgKHggPj0gcm9vdHNbMF0gKyBjeCAmJiB4IDw9IHJvb3RzWzFdICsgY3gpIHtcbiAgICAgIHJldHVybiBkaXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4odG1wKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHN0YXJ0QW5nbGUpO1xuICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgfVxuXG4gIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICBlbmRBbmdsZSArPSBQSTI7XG4gIH1cblxuICB2YXIgdyA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICB2YXIgeF8gPSByb290c1tpXTtcblxuICAgIGlmICh4XyArIGN4ID4geCkge1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4Xyk7XG4gICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcblxuICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICBhbmdsZSA9IFBJMiArIGFuZ2xlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSA8PSBlbmRBbmdsZSB8fCBhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKSB7XG4gICAgICAgIGlmIChhbmdsZSA+IE1hdGguUEkgLyAyICYmIGFuZ2xlIDwgTWF0aC5QSSAqIDEuNSkge1xuICAgICAgICAgIGRpciA9IC1kaXI7XG4gICAgICAgIH1cblxuICAgICAgICB3ICs9IGRpcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdztcbn1cblxuZnVuY3Rpb24gY29udGFpblBhdGgoZGF0YSwgbGluZVdpZHRoLCBpc1N0cm9rZSwgeCwgeSkge1xuICB2YXIgdyA9IDA7XG4gIHZhciB4aSA9IDA7XG4gIHZhciB5aSA9IDA7XG4gIHZhciB4MCA9IDA7XG4gIHZhciB5MCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICB2YXIgY21kID0gZGF0YVtpKytdOyAvLyBCZWdpbiBhIG5ldyBzdWJwYXRoXG5cbiAgICBpZiAoY21kID09PSBDTUQuTSAmJiBpID4gMSkge1xuICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc3VicGF0aFxuICAgICAgaWYgKCFpc1N0cm9rZSkge1xuICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgIH0gLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAvLyBpZiAodyAhPT0gMCkge1xuICAgICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgICAgLy8gfVxuXG4gICAgfVxuXG4gICAgaWYgKGkgPT0gMSkge1xuICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgIC8vXG4gICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgeGkgPSBkYXRhW2ldO1xuICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcbiAgICAgIHgwID0geGk7XG4gICAgICB5MCA9IHlpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICBjYXNlIENNRC5NOlxuICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgIHhpID0geDA7XG4gICAgICAgIHlpID0geTA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5MOlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAobGluZS5jb250YWluU3Ryb2tlKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOT1RFIOWcqOesrOS4gOS4quWRveS7pOS4uiBMLCBDLCBRIOeahOaXtuWAmeS8muiuoeeul+WHuiBOYU5cbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5DOlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAoY3ViaWMuY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdDdWJpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5ROlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAocXVhZHJhdGljLmNvbnRhaW5TdHJva2UoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdRdWFkcmF0aWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5BOlxuICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgdGhldGEgPSBkYXRhW2krK107XG4gICAgICAgIHZhciBkVGhldGEgPSBkYXRhW2krK107IC8vIFRPRE8gQXJjIOaXi+i9rFxuXG4gICAgICAgIHZhciBwc2kgPSBkYXRhW2krK107XG4gICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHgxID0gTWF0aC5jb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgdmFyIHkxID0gTWF0aC5zaW4odGhldGEpICogcnkgKyBjeTsgLy8g5LiN5piv55u05o6l5L2/55SoIGFyYyDlkb3ku6RcblxuICAgICAgICBpZiAoaSA+IDEpIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgIHkwID0geTE7XG4gICAgICAgIH0gLy8genIg5L2/55Soc2NhbGXmnaXmqKHmi5/mpK3lnIYsIOi/memHjOS5n+WvuXjlgZrkuIDlrprnmoTnvKnmlL5cblxuXG4gICAgICAgIHZhciBfeCA9ICh4IC0gY3gpICogcnkgLyByeCArIGN4O1xuXG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChhcmMuY29udGFpblN0cm9rZShjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsIGxpbmVXaWR0aCwgX3gsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB3aW5kaW5nQXJjKGN4LCBjeSwgcnksIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgYW50aWNsb2Nrd2lzZSwgX3gsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgeGkgPSBNYXRoLmNvcyh0aGV0YSArIGRUaGV0YSkgKiByeCArIGN4O1xuICAgICAgICB5aSA9IE1hdGguc2luKHRoZXRhICsgZFRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5SOlxuICAgICAgICB4MCA9IHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2krK107XG4gICAgICAgIHZhciB4MSA9IHgwICsgd2lkdGg7XG4gICAgICAgIHZhciB5MSA9IHkwICsgaGVpZ2h0O1xuXG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChsaW5lLmNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTAsIGxpbmVXaWR0aCwgeCwgeSkgfHwgbGluZS5jb250YWluU3Ryb2tlKHgxLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHx8IGxpbmUuY29udGFpblN0cm9rZSh4MSwgeTEsIHgwLCB5MSwgbGluZVdpZHRoLCB4LCB5KSB8fCBsaW5lLmNvbnRhaW5TdHJva2UoeDAsIHkxLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGSVhNRSBDbG9ja3dpc2UgP1xuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDEsIHkwLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDAsIHkxLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChsaW5lLmNvbnRhaW5TdHJva2UoeGksIHlpLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDbG9zZSBhIHN1YnBhdGhcbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTsgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgLy8gRklYTUUgc3VicGF0aHMgbWF5IG92ZXJsYXBcbiAgICAgICAgICAvLyBpZiAodyAhPT0gMCkge1xuICAgICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IHgwO1xuICAgICAgICB5aSA9IHkwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoIWlzU3Ryb2tlICYmICFpc0Fyb3VuZEVxdWFsKHlpLCB5MCkpIHtcbiAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KSB8fCAwO1xuICB9XG5cbiAgcmV0dXJuIHcgIT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW4ocGF0aERhdGEsIHgsIHkpIHtcbiAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCAwLCBmYWxzZSwgeCwgeSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UocGF0aERhdGEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICByZXR1cm4gY29udGFpblBhdGgocGF0aERhdGEsIGxpbmVXaWR0aCwgdHJ1ZSwgeCwgeSk7XG59XG5cbmV4cG9ydHMuY29udGFpbiA9IGNvbnRhaW47XG5leHBvcnRzLmNvbnRhaW5TdHJva2UgPSBjb250YWluU3Ryb2tlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog57q/5q615YyF5ZCr5Yik5patXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgdmFyIF9hID0gMDtcbiAgdmFyIF9iID0geDA7IC8vIFF1aWNrIHJlamVjdFxuXG4gIGlmICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCB8fCB5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCB8fCB4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCB8fCB4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh4MCAhPT0geDEpIHtcbiAgICBfYSA9ICh5MCAtIHkxKSAvICh4MCAtIHgxKTtcbiAgICBfYiA9ICh4MCAqIHkxIC0geDEgKiB5MCkgLyAoeDAgLSB4MSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggLSB4MCkgPD0gX2wgLyAyO1xuICB9XG5cbiAgdmFyIHRtcCA9IF9hICogeCAtIHkgKyBfYjtcblxuICB2YXIgX3MgPSB0bXAgKiB0bXAgLyAoX2EgKiBfYSArIDEpO1xuXG4gIHJldHVybiBfcyA8PSBfbCAvIDIgKiBfbCAvIDI7XG59XG5cbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN1cnZlID0gcmVxdWlyZShcIi4uL2NvcmUvY3VydmVcIik7XG5cbi8qKlxuICog5LiJ5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4M1xuICogQHBhcmFtICB7bnVtYmVyfSAgeTNcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIGxpbmVXaWR0aCwgeCwgeSkge1xuICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIF9sID0gbGluZVdpZHRoOyAvLyBRdWljayByZWplY3RcblxuICBpZiAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wgJiYgeSA+IHkzICsgX2wgfHwgeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgJiYgeSA8IHkyIC0gX2wgJiYgeSA8IHkzIC0gX2wgfHwgeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wgJiYgeCA+IHgzICsgX2wgfHwgeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wgJiYgeCA8IHgzIC0gX2wpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZCA9IGN1cnZlLmN1YmljUHJvamVjdFBvaW50KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSwgbnVsbCk7XG4gIHJldHVybiBkIDw9IF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi9jdWJpYy5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9jdXJ2ZSA9IHJlcXVpcmUoXCIuLi9jb3JlL2N1cnZlXCIpO1xuXG52YXIgcXVhZHJhdGljUHJvamVjdFBvaW50ID0gX2N1cnZlLnF1YWRyYXRpY1Byb2plY3RQb2ludDtcblxuLyoqXG4gKiDkuozmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbCA9IGxpbmVXaWR0aDsgLy8gUXVpY2sgcmVqZWN0XG5cbiAgaWYgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sIHx8IHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sIHx8IHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sICYmIHggPiB4MiArIF9sIHx8IHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGQgPSBxdWFkcmF0aWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSwgbnVsbCk7XG4gIHJldHVybiBkIDw9IF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi9xdWFkcmF0aWMuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBub3JtYWxpemVSYWRpYW4gPSBfdXRpbC5ub3JtYWxpemVSYWRpYW47XG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4vKipcbiAqIOWchuW8p+aPj+i+ueWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgY3hcbiAqIEBwYXJhbSAge251bWJlcn0gIGN5XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICByXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBzdGFydEFuZ2xlXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBlbmRBbmdsZVxuICogQHBhcmFtICB7Ym9vbGVhbn0gIGFudGljbG9ja3dpc2VcbiAqIEBwYXJhbSAge251bWJlcn0gbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gIHggLT0gY3g7XG4gIHkgLT0gY3k7XG4gIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gIGlmIChkIC0gX2wgPiByIHx8IGQgKyBfbCA8IHIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAlIFBJMiA8IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeCk7XG5cbiAgaWYgKGFuZ2xlIDwgMCkge1xuICAgIGFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHJldHVybiBhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlIHx8IGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGU7XG59XG5cbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhZGlhbihhbmdsZSkge1xuICBhbmdsZSAlPSBQSTI7XG5cbiAgaWYgKGFuZ2xlIDwgMCkge1xuICAgIGFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHJldHVybiBhbmdsZTtcbn1cblxuZXhwb3J0cy5ub3JtYWxpemVSYWRpYW4gPSBub3JtYWxpemVSYWRpYW47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gd2luZGluZ0xpbmUoeDAsIHkwLCB4MSwgeTEsIHgsIHkpIHtcbiAgaWYgKHkgPiB5MCAmJiB5ID4geTEgfHwgeSA8IHkwICYmIHkgPCB5MSkge1xuICAgIHJldHVybiAwO1xuICB9IC8vIElnbm9yZSBob3Jpem9udGFsIGxpbmVcblxuXG4gIGlmICh5MSA9PT0geTApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBkaXIgPSB5MSA8IHkwID8gMSA6IC0xO1xuICB2YXIgdCA9ICh5IC0geTApIC8gKHkxIC0geTApOyAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cblxuICBpZiAodCA9PT0gMSB8fCB0ID09PSAwKSB7XG4gICAgZGlyID0geTEgPCB5MCA/IDAuNSA6IC0wLjU7XG4gIH1cblxuICB2YXIgeF8gPSB0ICogKHgxIC0geDApICsgeDA7XG4gIHJldHVybiB4XyA+IHggPyBkaXIgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRpbmdMaW5lO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0dGVybiA9IGZ1bmN0aW9uIChpbWFnZSwgcmVwZWF0KSB7XG4gIC8vIFNob3VsZCBkbyBub3RoaW5nIG1vcmUgaW4gdGhpcyBjb25zdHJ1Y3Rvci4gQmVjYXVzZSBncmFkaWVudCBjYW4gYmVcbiAgLy8gZGVjbGFyZCBieSBgY29sb3I6IHtpbWFnZTogLi4ufWAsIHdoZXJlIHRoaXMgY29uc3RydWN0b3Igd2lsbCBub3QgYmUgY2FsbGVkLlxuICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gIHRoaXMucmVwZWF0ID0gcmVwZWF0OyAvLyBDYW4gYmUgY2xvbmVkXG5cbiAgdGhpcy50eXBlID0gJ3BhdHRlcm4nO1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybiA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRoaXMuaW1hZ2UsIHRoaXMucmVwZWF0IHx8ICdyZXBlYXQnKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IFBhdHRlcm47XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdHRlcm4uanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgdjJBcHBseVRyYW5zZm9ybSA9IF92ZWN0b3IuYXBwbHlUcmFuc2Zvcm07XG52YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbnZhciBwb2ludHMgPSBbW10sIFtdLCBbXV07XG52YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgbWF0aEF0YW4yID0gTWF0aC5hdGFuMjtcblxuZnVuY3Rpb24gX2RlZmF1bHQocGF0aCwgbSkge1xuICB2YXIgZGF0YSA9IHBhdGguZGF0YTtcbiAgdmFyIGNtZDtcbiAgdmFyIG5Qb2ludDtcbiAgdmFyIGk7XG4gIHZhciBqO1xuICB2YXIgaztcbiAgdmFyIHA7XG4gIHZhciBNID0gQ01ELk07XG4gIHZhciBDID0gQ01ELkM7XG4gIHZhciBMID0gQ01ELkw7XG4gIHZhciBSID0gQ01ELlI7XG4gIHZhciBBID0gQ01ELkE7XG4gIHZhciBRID0gQ01ELlE7XG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICBjbWQgPSBkYXRhW2krK107XG4gICAgaiA9IGk7XG4gICAgblBvaW50ID0gMDtcblxuICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICBjYXNlIE06XG4gICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEw6XG4gICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEM6XG4gICAgICAgIG5Qb2ludCA9IDM7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFE6XG4gICAgICAgIG5Qb2ludCA9IDI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEE6XG4gICAgICAgIHZhciB4ID0gbVs0XTtcbiAgICAgICAgdmFyIHkgPSBtWzVdO1xuICAgICAgICB2YXIgc3ggPSBtYXRoU3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgICAgdmFyIHN5ID0gbWF0aFNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgIHZhciBhbmdsZSA9IG1hdGhBdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpOyAvLyBjeFxuXG4gICAgICAgIGRhdGFbaV0gKj0gc3g7XG4gICAgICAgIGRhdGFbaSsrXSArPSB4OyAvLyBjeVxuXG4gICAgICAgIGRhdGFbaV0gKj0gc3k7XG4gICAgICAgIGRhdGFbaSsrXSArPSB5OyAvLyBTY2FsZSByeCBhbmQgcnlcbiAgICAgICAgLy8gRklYTUUgQXNzdW1lIHBzaSBpcyAwIGhlcmVcblxuICAgICAgICBkYXRhW2krK10gKj0gc3g7XG4gICAgICAgIGRhdGFbaSsrXSAqPSBzeTsgLy8gU3RhcnQgYW5nbGVcblxuICAgICAgICBkYXRhW2krK10gKz0gYW5nbGU7IC8vIGVuZCBhbmdsZVxuXG4gICAgICAgIGRhdGFbaSsrXSArPSBhbmdsZTsgLy8gRklYTUUgcHNpXG5cbiAgICAgICAgaSArPSAyO1xuICAgICAgICBqID0gaTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUjpcbiAgICAgICAgLy8geDAsIHkwXG4gICAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICAgIHBbMV0gPSBkYXRhW2krK107XG4gICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMV07IC8vIHgxLCB5MVxuXG4gICAgICAgIHBbMF0gKz0gZGF0YVtpKytdO1xuICAgICAgICBwWzFdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICB9XG5cbiAgICBmb3IgKGsgPSAwOyBrIDwgblBvaW50OyBrKyspIHtcbiAgICAgIHZhciBwID0gcG9pbnRzW2tdO1xuICAgICAgcFswXSA9IGRhdGFbaSsrXTtcbiAgICAgIHBbMV0gPSBkYXRhW2krK107XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pOyAvLyBXcml0ZSBiYWNrXG5cbiAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi90b29sL3RyYW5zZm9ybVBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gY29sb3JTdG9wc1xuICovXG52YXIgR3JhZGllbnQgPSBmdW5jdGlvbiAoY29sb3JTdG9wcykge1xuICB0aGlzLmNvbG9yU3RvcHMgPSBjb2xvclN0b3BzIHx8IFtdO1xufTtcblxuR3JhZGllbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogR3JhZGllbnQsXG4gIGFkZENvbG9yU3RvcDogZnVuY3Rpb24gKG9mZnNldCwgY29sb3IpIHtcbiAgICB0aGlzLmNvbG9yU3RvcHMucHVzaCh7XG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIGNvbG9yOiBjb2xvclxuICAgIH0pO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gR3JhZGllbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUT0RPIERyYWdnYWJsZSBmb3IgZ3JvdXBcbi8vIEZJWE1FIERyYWdnYWJsZSBvbiBlbGVtZW50IHdoaWNoIGhhcyBwYXJlbnQgcm90YXRpb24gb3Igc2NhbGVcbmZ1bmN0aW9uIERyYWdnYWJsZSgpIHtcbiAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5fZHJhZ1N0YXJ0LCB0aGlzKTtcbiAgdGhpcy5vbignbW91c2Vtb3ZlJywgdGhpcy5fZHJhZywgdGhpcyk7XG4gIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgdGhpcy5vbignZ2xvYmFsb3V0JywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7IC8vIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAvLyB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG4gIC8vIHRoaXMuX3ggPSAwO1xuICAvLyB0aGlzLl95ID0gMDtcbn1cblxuRHJhZ2dhYmxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERyYWdnYWJsZSxcbiAgX2RyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSBlLnRhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCAmJiBkcmFnZ2luZ1RhcmdldC5kcmFnZ2FibGUpIHtcbiAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gZHJhZ2dpbmdUYXJnZXQ7XG4gICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB0aGlzLl94ID0gZS5vZmZzZXRYO1xuICAgICAgdGhpcy5feSA9IGUub2Zmc2V0WTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZ3N0YXJ0JywgZS5ldmVudCk7XG4gICAgfVxuICB9LFxuICBfZHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgdmFyIHggPSBlLm9mZnNldFg7XG4gICAgICB2YXIgeSA9IGUub2Zmc2V0WTtcbiAgICAgIHZhciBkeCA9IHggLSB0aGlzLl94O1xuICAgICAgdmFyIGR5ID0geSAtIHRoaXMuX3k7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJpZnQoZHgsIGR5LCBlKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZycsIGUuZXZlbnQpO1xuICAgICAgdmFyIGRyb3BUYXJnZXQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5LCBkcmFnZ2luZ1RhcmdldCkudGFyZ2V0O1xuICAgICAgdmFyIGxhc3REcm9wVGFyZ2V0ID0gdGhpcy5fZHJvcFRhcmdldDtcbiAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuXG4gICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgIT09IGRyb3BUYXJnZXQpIHtcbiAgICAgICAgaWYgKGxhc3REcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShsYXN0RHJvcFRhcmdldCwgZSksICdkcmFnbGVhdmUnLCBlLmV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcm9wVGFyZ2V0LCBlKSwgJ2RyYWdlbnRlcicsIGUuZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfZHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWdlbmQnLCBlLmV2ZW50KTtcblxuICAgIGlmICh0aGlzLl9kcm9wVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKHRoaXMuX2Ryb3BUYXJnZXQsIGUpLCAnZHJvcCcsIGUuZXZlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLl9kcm9wVGFyZ2V0ID0gbnVsbDtcbiAgfVxufTtcblxuZnVuY3Rpb24gcGFyYW0odGFyZ2V0LCBlKSB7XG4gIHJldHVybiB7XG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgdG9wVGFyZ2V0OiBlICYmIGUudG9wVGFyZ2V0XG4gIH07XG59XG5cbnZhciBfZGVmYXVsdCA9IERyYWdnYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZShcIi4uL0VsZW1lbnRcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbi8qKlxuICogR3JvdXDmmK/kuIDkuKrlrrnlmajvvIzlj6/ku6Xmj5LlhaXlrZDoioLngrnvvIxHcm91cOeahOWPmOaNouS5n+S8muiiq+W6lOeUqOWIsOWtkOiKgueCueS4ilxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvR3JvdXBcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIEdyb3VwID0gcmVxdWlyZSgnenJlbmRlci9jb250YWluZXIvR3JvdXAnKTtcbiAqICAgICB2YXIgQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9ncmFwaGljL3NoYXBlL0NpcmNsZScpO1xuICogICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gKiAgICAgZy5wb3NpdGlvblswXSA9IDEwMDtcbiAqICAgICBnLnBvc2l0aW9uWzFdID0gMTAwO1xuICogICAgIGcuYWRkKG5ldyBDaXJjbGUoe1xuICogICAgICAgICBzdHlsZToge1xuICogICAgICAgICAgICAgeDogMTAwLFxuICogICAgICAgICAgICAgeTogMTAwLFxuICogICAgICAgICAgICAgcjogMjAsXG4gKiAgICAgICAgIH1cbiAqICAgICB9KSk7XG4gKiAgICAgenIuYWRkKGcpO1xuICovXG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXBcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqL1xudmFyIEdyb3VwID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTtcblxuICBmb3IgKHZhciBrZXkgaW4gb3B0cykge1xuICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRoaXNba2V5XSA9IG9wdHNba2V5XTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICB0aGlzLl9fc3RvcmFnZSA9IG51bGw7XG4gIHRoaXMuX19kaXJ0eSA9IHRydWU7XG59O1xuXG5Hcm91cC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBHcm91cCxcbiAgaXNHcm91cDogdHJ1ZSxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHR5cGU6ICdncm91cCcsXG5cbiAgLyoqXG4gICAqIOaJgOacieWtkOWtmeWFg+e0oOaYr+WQpuWTjeW6lOm8oOagh+S6i+S7tlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvY29udGFpbmVyL0dyb3VwI3NpbGVudFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9FbGVtZW50Pn1cbiAgICovXG4gIGNoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLnNsaWNlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPluaMh+WumiBpbmRleCDnmoTlhL/lrZDoioLngrlcbiAgICogQHBhcmFtICB7bnVtYmVyfSBpZHhcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICovXG4gIGNoaWxkQXQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW5baWR4XTtcbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W5oyH5a6a5ZCN5a2X55qE5YS/5a2Q6IqC54K5XG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgKi9cbiAgY2hpbGRPZk5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5a2Q6IqC54K55Yiw5pyA5ZCOXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICovXG4gIGFkZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cbiAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5a2Q6IqC54K55ZyoIG5leHRTaWJsaW5nIOS5i+WJjVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gbmV4dFNpYmxpbmdcbiAgICovXG4gIGFkZEJlZm9yZTogZnVuY3Rpb24gKGNoaWxkLCBuZXh0U2libGluZykge1xuICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXMgJiYgbmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgIHZhciBpZHggPSBjaGlsZHJlbi5pbmRleE9mKG5leHRTaWJsaW5nKTtcblxuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDAsIGNoaWxkKTtcblxuICAgICAgICB0aGlzLl9kb0FkZChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9kb0FkZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY2hpbGQucGFyZW50LnJlbW92ZShjaGlsZCk7XG4gICAgfVxuXG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgIHZhciB6ciA9IHRoaXMuX196cjtcblxuICAgIGlmIChzdG9yYWdlICYmIHN0b3JhZ2UgIT09IGNoaWxkLl9fc3RvcmFnZSkge1xuICAgICAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBjaGlsZC5hZGRDaGlsZHJlblRvU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOenu+mZpOWtkOiKgueCuVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIHZhciBpZHggPSB6clV0aWwuaW5kZXhPZihjaGlsZHJlbiwgY2hpbGQpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xuICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG5cbiAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgenIgJiYgenIucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDnp7vpmaTmiYDmnInlrZDoioLngrlcbiAgICovXG4gIHJlbW92ZUFsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgdmFyIGNoaWxkO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDpgY3ljobmiYDmnInlrZDoioLngrlcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAqL1xuICBlYWNoQ2hpbGQ6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkLCBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5rex5bqm5LyY5YWI6YGN5Y6G5omA5pyJ5a2Q5a2Z6IqC54K5XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgKi9cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgY2IuY2FsbChjb250ZXh0LCBjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgIGNoaWxkLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkQ2hpbGRyZW5Ub1N0b3JhZ2U6IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICBzdG9yYWdlLmFkZFRvU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmFkZENoaWxkcmVuVG9TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICovXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKGluY2x1ZGVDaGlsZHJlbikge1xuICAgIC8vIFRPRE8gQ2FjaGluZ1xuICAgIHZhciByZWN0ID0gbnVsbDtcbiAgICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgdmFyIGNoaWxkcmVuID0gaW5jbHVkZUNoaWxkcmVuIHx8IHRoaXMuX2NoaWxkcmVuO1xuICAgIHZhciB0bXBNYXQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoY2hpbGQuaWdub3JlIHx8IGNoaWxkLmludmlzaWJsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkUmVjdCA9IGNoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGNoaWxkLmdldExvY2FsVHJhbnNmb3JtKHRtcE1hdCk7IC8vIFRPRE9cbiAgICAgIC8vIFRoZSBib3VuZGluZ1JlY3QgY2FjbHVhdGVkIGJ5IHRyYW5zZm9ybWluZyBvcmlnaW5hbFxuICAgICAgLy8gcmVjdCBtYXkgYmUgYmlnZ2VyIHRoYW4gdGhlIGFjdHVhbCBidW5kaW5nUmVjdCB3aGVuIHJvdGF0aW9uXG4gICAgICAvLyBpcyB1c2VkLiAoQ29uc2lkZXIgYSBjaXJjbGUgcm90YXRlZCBhZ2luc3QgaXRzIGNlbnRlciwgd2hlcmVcbiAgICAgIC8vIHRoZSBhY3R1YWwgYm91bmRpbmdSZWN0IHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGF0IG5vdCBiZVxuICAgICAgLy8gcm90YXRlZC4pIEJ1dCB3ZSBjYW4gbm90IGZpbmQgYmV0dGVyIGFwcHJvYWNoIHRvIGNhbGN1bGF0ZVxuICAgICAgLy8gYWN0dWFsIGJvdW5kaW5nUmVjdCB5ZXQsIGNvbnNpZGVyaW5nIHBlcmZvcm1hbmNlLlxuXG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRtcFJlY3QuY29weShjaGlsZFJlY3QpO1xuICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IHRtcFJlY3QuY2xvbmUoKTtcbiAgICAgICAgcmVjdC51bmlvbih0bXBSZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IGNoaWxkUmVjdC5jbG9uZSgpO1xuICAgICAgICByZWN0LnVuaW9uKGNoaWxkUmVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3QgfHwgdG1wUmVjdDtcbiAgfVxufTtcbnpyVXRpbC5pbmhlcml0cyhHcm91cCwgRWxlbWVudCk7XG52YXIgX2RlZmF1bHQgPSBHcm91cDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZShcIi4vRGlzcGxheWFibGVcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXIvaW1hZ2VcIik7XG5cbi8qKlxuICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5mdW5jdGlvbiBaSW1hZ2Uob3B0cykge1xuICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG5aSW1hZ2UucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogWkltYWdlLFxuICB0eXBlOiAnaW1hZ2UnLFxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgc3JjID0gc3R5bGUuaW1hZ2U7IC8vIE11c3QgYmluZCBlYWNoIHRpbWVcblxuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlID0gaW1hZ2VIZWxwZXIuY3JlYXRlT3JVcGRhdGVJbWFnZShzcmMsIHRoaXMuX2ltYWdlLCB0aGlzLCB0aGlzLm9ubG9hZCk7XG5cbiAgICBpZiAoIWltYWdlIHx8ICFpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoaW1hZ2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyDlm77niYflt7Lnu4/liqDovb3lrozmiJBcbiAgICAvLyBpZiAoaW1hZ2Uubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnSU1HJykge1xuICAgIC8vICAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSB7XG4gICAgLy8gICAgICAgICByZXR1cm47XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gICAgLy8gRWxzZSBpcyBjYW52YXNcblxuXG4gICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHN0eWxlLmhlaWdodDtcbiAgICB2YXIgYXNwZWN0ID0gaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQ7XG5cbiAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgLy8gS2VlcCBpbWFnZS9oZWlnaHQgcmF0aW9cbiAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0O1xuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwgJiYgd2lkdGggIT0gbnVsbCkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA9PSBudWxsICYmIGhlaWdodCA9PSBudWxsKSB7XG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIH0gLy8g6K6+572udHJhbnNmb3JtXG5cblxuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4IHx8IDA7XG4gICAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuc3ggJiYgc3R5bGUuc3kpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4O1xuICAgICAgdmFyIHN5ID0gc3R5bGUuc3k7XG4gICAgICB2YXIgc1dpZHRoID0gd2lkdGggLSBzeDtcbiAgICAgIHZhciBzSGVpZ2h0ID0gaGVpZ2h0IC0gc3k7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBzeCwgc3ksIHNXaWR0aCwgc0hlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpOyAvLyBEcmF3IHJlY3QgdGV4dFxuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICB9XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgIHRoaXMuX3JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHN0eWxlLnggfHwgMCwgc3R5bGUueSB8fCAwLCBzdHlsZS53aWR0aCB8fCAwLCBzdHlsZS5oZWlnaHQgfHwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XG52YXIgX2RlZmF1bHQgPSBaSW1hZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3RleHRcIik7XG5cbnZhciB0ZXh0SGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyL3RleHRcIik7XG5cbi8qKlxuICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9UZXh0XG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbnZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG59O1xuXG5UZXh0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRleHQsXG4gIHR5cGU6ICd0ZXh0JyxcbiAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7IC8vIFVzZSBwcm9wcyB3aXRoIHByZWZpeCAndGV4dCcuXG5cbiAgICBzdHlsZS5maWxsID0gc3R5bGUuc3Ryb2tlID0gc3R5bGUuc2hhZG93Qmx1ciA9IHN0eWxlLnNoYWRvd0NvbG9yID0gc3R5bGUuc2hhZG93T2Zmc2V0WCA9IHN0eWxlLnNoYWRvd09mZnNldFkgPSBudWxsO1xuICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDsgLy8gQ29udmVydCB0byBzdHJpbmdcblxuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7IC8vIEFsd2F5cyBiaW5kIHN0eWxlXG5cbiAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcblxuICAgIGlmICghdGV4dEhlbHBlci5uZWVkRHJhd1RleHQodGV4dCwgc3R5bGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICB0ZXh0SGVscGVyLnJlbmRlclRleHQodGhpcywgY3R4LCB0ZXh0LCBzdHlsZSk7XG4gICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7XG5cbiAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcbiAgICAgIHRleHQgIT0gbnVsbCA/IHRleHQgKz0gJycgOiB0ZXh0ID0gJyc7XG4gICAgICB2YXIgcmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChzdHlsZS50ZXh0ICsgJycsIHN0eWxlLmZvbnQsIHN0eWxlLnRleHRBbGlnbiwgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24sIHN0eWxlLnRleHRQYWRkaW5nLCBzdHlsZS5yaWNoKTtcbiAgICAgIHJlY3QueCArPSBzdHlsZS54IHx8IDA7XG4gICAgICByZWN0LnkgKz0gc3R5bGUueSB8fCAwO1xuXG4gICAgICBpZiAodGV4dEhlbHBlci5nZXRTdHJva2Uoc3R5bGUudGV4dFN0cm9rZSwgc3R5bGUudGV4dFN0cm9rZVdpZHRoKSkge1xuICAgICAgICB2YXIgdyA9IHN0eWxlLnRleHRTdHJva2VXaWR0aDtcbiAgICAgICAgcmVjdC54IC09IHcgLyAyO1xuICAgICAgICByZWN0LnkgLT0gdyAvIDI7XG4gICAgICAgIHJlY3Qud2lkdGggKz0gdztcbiAgICAgICAgcmVjdC5oZWlnaHQgKz0gdztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoVGV4dCwgRGlzcGxheWFibGUpO1xudmFyIF9kZWZhdWx0ID0gVGV4dDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxuLyoqXG4gKiDlnIblvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9DaXJjbGVcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnY2lyY2xlJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByOiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUsIGluQnVuZGxlKSB7XG4gICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgLy8gQWx3YXlzIGRvIGl0IG1heSBoYXZlIHBlcmZvcm1lbmNlIGlzc3VlICggZmlsbCBtYXkgYmUgMnggbW9yZSBjb3N0KVxuICAgIGlmIChpbkJ1bmRsZSkge1xuICAgICAgY3R4Lm1vdmVUbyhzaGFwZS5jeCArIHNoYXBlLnIsIHNoYXBlLmN5KTtcbiAgICB9IC8vIGVsc2Uge1xuICAgIC8vICAgICBpZiAoY3R4LmFsbG9jYXRlICYmICFjdHguZGF0YS5sZW5ndGgpIHtcbiAgICAvLyAgICAgICAgIGN0eC5hbGxvY2F0ZShjdHguQ01EX01FTV9TSVpFLkEpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgIC8vIGN0eC5tb3ZlVG8oc2hhcGUuY3ggKyBzaGFwZS5yLCBzaGFwZS5jeSk7XG5cblxuICAgIGN0eC5hcmMoc2hhcGUuY3gsIHNoYXBlLmN5LCBzaGFwZS5yLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIGZpeENsaXBXaXRoU2hhZG93ID0gcmVxdWlyZShcIi4uL2hlbHBlci9maXhDbGlwV2l0aFNoYWRvd1wiKTtcblxuLyoqXG4gKiDmiYflvaJcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1NlY3RvclxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdzZWN0b3InLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHIwOiAwLFxuICAgIHI6IDAsXG4gICAgc3RhcnRBbmdsZTogMCxcbiAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXG4gICAgY2xvY2t3aXNlOiB0cnVlXG4gIH0sXG4gIGJydXNoOiBmaXhDbGlwV2l0aFNoYWRvdyhQYXRoLnByb3RvdHlwZS5icnVzaCksXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgdmFyIHIwID0gTWF0aC5tYXgoc2hhcGUucjAgfHwgMCwgMCk7XG4gICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgdmFyIGVuZEFuZ2xlID0gc2hhcGUuZW5kQW5nbGU7XG4gICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcbiAgICB2YXIgdW5pdFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICBjdHgubW92ZVRvKHVuaXRYICogcjAgKyB4LCB1bml0WSAqIHIwICsgeSk7XG4gICAgY3R4LmxpbmVUbyh1bml0WCAqIHIgKyB4LCB1bml0WSAqIHIgKyB5KTtcbiAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcbiAgICBjdHgubGluZVRvKE1hdGguY29zKGVuZEFuZ2xlKSAqIHIwICsgeCwgTWF0aC5zaW4oZW5kQW5nbGUpICogcjAgKyB5KTtcblxuICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgY3R4LmFyYyh4LCB5LCByMCwgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIGNsb2Nrd2lzZSk7XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBlbnYgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9lbnZcIik7XG5cbi8vIEZpeCB3ZWlyZCBidWcgaW4gc29tZSB2ZXJzaW9uIG9mIElFMTEgKGxpa2UgMTEuMC45NjAwLjE3OCoqKSxcbi8vIHdoZXJlIGV4Y2VwdGlvbiBcInVuZXhwZWN0ZWQgY2FsbCB0byBtZXRob2Qgb3IgcHJvcGVydHkgYWNjZXNzXCJcbi8vIG1pZ2h0IGJlIHRocm93biB3aGVuIGNhbGxpbmcgY3R4LmZpbGwgb3IgY3R4LnN0cm9rZSBhZnRlciBhIHBhdGhcbi8vIHdob3NlIGFyZWEgc2l6ZSBpcyB6ZXJvIGlzIGRyYXduIGFuZCBjdHguY2xpcCgpIGlzIGNhbGxlZCBhbmRcbi8vIHNoYWRvd0JsdXIgaXMgc2V0LiBTZWUgIzQ1NzIsICMzMTEyLCAjNTc3Ny5cbi8vIChlLmcuLFxuLy8gIGN0eC5tb3ZlVG8oMTAsIDEwKTtcbi8vICBjdHgubGluZVRvKDIwLCAxMCk7XG4vLyAgY3R4LmNsb3NlUGF0aCgpO1xuLy8gIGN0eC5jbGlwKCk7XG4vLyAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcbi8vICAuLi5cbi8vICBjdHguZmlsbCgpO1xuLy8gKVxudmFyIHNoYWRvd1RlbXAgPSBbWydzaGFkb3dCbHVyJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF1dO1xuXG5mdW5jdGlvbiBfZGVmYXVsdChvcmlnbmFsQnJ1c2gpIHtcbiAgLy8gdmVyc2lvbiBzdHJpbmcgY2FuIGJlOiAnMTEuMCdcbiAgcmV0dXJuIGVudi5icm93c2VyLmllICYmIGVudi5icm93c2VyLnZlcnNpb24gPj0gMTEgPyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNsaXBQYXRocyA9IHRoaXMuX19jbGlwUGF0aHM7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgbW9kaWZpZWQ7XG5cbiAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgICAgIHZhciBzaGFwZSA9IGNsaXBQYXRoICYmIGNsaXBQYXRoLnNoYXBlO1xuICAgICAgICB2YXIgdHlwZSA9IGNsaXBQYXRoICYmIGNsaXBQYXRoLnR5cGU7XG5cbiAgICAgICAgaWYgKHNoYXBlICYmICh0eXBlID09PSAnc2VjdG9yJyAmJiBzaGFwZS5zdGFydEFuZ2xlID09PSBzaGFwZS5lbmRBbmdsZSB8fCB0eXBlID09PSAncmVjdCcgJiYgKCFzaGFwZS53aWR0aCB8fCAhc2hhcGUuaGVpZ2h0KSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIC8vIEl0IGlzIHNhdmUgdG8gcHV0IHNoYWRvd1RlbXAgc3RhdGljLCBiZWNhdXNlIHNoYWRvd1RlbXBcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgYWxsIG1vZGlmaWVkIGVhY2ggaXRlbSBicnVzaCBjYWxsZWQuXG4gICAgICAgICAgICBzaGFkb3dUZW1wW2pdWzJdID0gc3R5bGVbc2hhZG93VGVtcFtqXVswXV07XG4gICAgICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3JpZ25hbEJydXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhZG93VGVtcC5sZW5ndGg7IGorKykge1xuICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMl07XG4gICAgICB9XG4gICAgfVxuICB9IDogb3JpZ25hbEJydXNoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9maXhDbGlwV2l0aFNoYWRvdy5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBlY2hhcnRz6K6+5aSH546v5aKD6K+G5YirXG4gKlxuICogQGRlc2MgZWNoYXJ0c+WfuuS6jkNhbnZhc++8jOe6r0phdmFzY3JpcHTlm77ooajlupPvvIzmj5Dkvpvnm7Top4LvvIznlJ/liqjvvIzlj6/kuqTkupLvvIzlj6/kuKrmgKfljJblrprliLbnmoTmlbDmja7nu5/orqHlm77ooajjgIJcbiAqIEBhdXRob3IgZmlyZWRlW2ZpcmVkZUBmaXJlZGUudXNdXG4gKiBAZGVzYyB0aGFua3MgemVwdG8uXG4gKi9cbnZhciBlbnYgPSB7fTtcblxuaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIEluIG5vZGVcbiAgZW52ID0ge1xuICAgIGJyb3dzZXI6IHt9LFxuICAgIG9zOiB7fSxcbiAgICBub2RlOiB0cnVlLFxuICAgIC8vIEFzc3VtZSBjYW52YXMgaXMgc3VwcG9ydGVkXG4gICAgY2FudmFzU3VwcG9ydGVkOiB0cnVlLFxuICAgIHN2Z1N1cHBvcnRlZDogdHJ1ZVxuICB9O1xufSBlbHNlIHtcbiAgZW52ID0gZGV0ZWN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuXG52YXIgX2RlZmF1bHQgPSBlbnY7IC8vIFplcHRvLmpzXG4vLyAoYykgMjAxMC0yMDEzIFRob21hcyBGdWNoc1xuLy8gWmVwdG8uanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbmZ1bmN0aW9uIGRldGVjdCh1YSkge1xuICB2YXIgb3MgPSB7fTtcbiAgdmFyIGJyb3dzZXIgPSB7fTsgLy8gdmFyIHdlYmtpdCA9IHVhLm1hdGNoKC9XZWJba0tdaXRbXFwvXXswLDF9KFtcXGQuXSspLyk7XG4gIC8vIHZhciBhbmRyb2lkID0gdWEubWF0Y2goLyhBbmRyb2lkKTs/W1xcc1xcL10rKFtcXGQuXSspPy8pO1xuICAvLyB2YXIgaXBhZCA9IHVhLm1hdGNoKC8oaVBhZCkuKk9TXFxzKFtcXGRfXSspLyk7XG4gIC8vIHZhciBpcG9kID0gdWEubWF0Y2goLyhpUG9kKSguKk9TXFxzKFtcXGRfXSspKT8vKTtcbiAgLy8gdmFyIGlwaG9uZSA9ICFpcGFkICYmIHVhLm1hdGNoKC8oaVBob25lXFxzT1MpXFxzKFtcXGRfXSspLyk7XG4gIC8vIHZhciB3ZWJvcyA9IHVhLm1hdGNoKC8od2ViT1N8aHB3T1MpW1xcc1xcL10oW1xcZC5dKykvKTtcbiAgLy8gdmFyIHRvdWNocGFkID0gd2Vib3MgJiYgdWEubWF0Y2goL1RvdWNoUGFkLyk7XG4gIC8vIHZhciBraW5kbGUgPSB1YS5tYXRjaCgvS2luZGxlXFwvKFtcXGQuXSspLyk7XG4gIC8vIHZhciBzaWxrID0gdWEubWF0Y2goL1NpbGtcXC8oW1xcZC5fXSspLyk7XG4gIC8vIHZhciBibGFja2JlcnJ5ID0gdWEubWF0Y2goLyhCbGFja0JlcnJ5KS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgYmIxMCA9IHVhLm1hdGNoKC8oQkIxMCkuKlZlcnNpb25cXC8oW1xcZC5dKykvKTtcbiAgLy8gdmFyIHJpbXRhYmxldG9zID0gdWEubWF0Y2goLyhSSU1cXHNUYWJsZXRcXHNPUylcXHMoW1xcZC5dKykvKTtcbiAgLy8gdmFyIHBsYXlib29rID0gdWEubWF0Y2goL1BsYXlCb29rLyk7XG4gIC8vIHZhciBjaHJvbWUgPSB1YS5tYXRjaCgvQ2hyb21lXFwvKFtcXGQuXSspLykgfHwgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLyk7XG5cbiAgdmFyIGZpcmVmb3ggPSB1YS5tYXRjaCgvRmlyZWZveFxcLyhbXFxkLl0rKS8pOyAvLyB2YXIgc2FmYXJpID0gd2Via2l0ICYmIHVhLm1hdGNoKC9Nb2JpbGVcXC8vKSAmJiAhY2hyb21lO1xuICAvLyB2YXIgd2VidmlldyA9IHVhLm1hdGNoKC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpLykgJiYgIWNocm9tZTtcblxuICB2YXIgaWUgPSB1YS5tYXRjaCgvTVNJRVxccyhbXFxkLl0rKS8pIC8vIElFIDExIFRyaWRlbnQvNy4wOyBydjoxMS4wXG4gIHx8IHVhLm1hdGNoKC9UcmlkZW50XFwvLis/cnY6KChbXFxkLl0rKSkvKTtcbiAgdmFyIGVkZ2UgPSB1YS5tYXRjaCgvRWRnZVxcLyhbXFxkLl0rKS8pOyAvLyBJRSAxMiBhbmQgMTIrXG5cbiAgdmFyIHdlQ2hhdCA9IC9taWNyb21lc3Nlbmdlci9pLnRlc3QodWEpOyAvLyBUb2RvOiBjbGVhbiB0aGlzIHVwIHdpdGggYSBiZXR0ZXIgT1MvYnJvd3NlciBzZXBlcmF0aW9uOlxuICAvLyAtIGRpc2Nlcm4gKG1vcmUpIGJldHdlZW4gbXVsdGlwbGUgYnJvd3NlcnMgb24gYW5kcm9pZFxuICAvLyAtIGRlY2lkZSBpZiBraW5kbGUgZmlyZSBpbiBzaWxrIG1vZGUgaXMgYW5kcm9pZCBvciBub3RcbiAgLy8gLSBGaXJlZm94IG9uIEFuZHJvaWQgZG9lc24ndCBzcGVjaWZ5IHRoZSBBbmRyb2lkIHZlcnNpb25cbiAgLy8gLSBwb3NzaWJseSBkZXZpZGUgaW4gb3MsIGRldmljZSBhbmQgYnJvd3NlciBoYXNoZXNcbiAgLy8gaWYgKGJyb3dzZXIud2Via2l0ID0gISF3ZWJraXQpIGJyb3dzZXIudmVyc2lvbiA9IHdlYmtpdFsxXTtcbiAgLy8gaWYgKGFuZHJvaWQpIG9zLmFuZHJvaWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gYW5kcm9pZFsyXTtcbiAgLy8gaWYgKGlwaG9uZSAmJiAhaXBvZCkgb3MuaW9zID0gb3MuaXBob25lID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwaG9uZVsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gIC8vIGlmIChpcGFkKSBvcy5pb3MgPSBvcy5pcGFkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwYWRbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAvLyBpZiAoaXBvZCkgb3MuaW9zID0gb3MuaXBvZCA9IHRydWUsIG9zLnZlcnNpb24gPSBpcG9kWzNdID8gaXBvZFszXS5yZXBsYWNlKC9fL2csICcuJykgOiBudWxsO1xuICAvLyBpZiAod2Vib3MpIG9zLndlYm9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHdlYm9zWzJdO1xuICAvLyBpZiAodG91Y2hwYWQpIG9zLnRvdWNocGFkID0gdHJ1ZTtcbiAgLy8gaWYgKGJsYWNrYmVycnkpIG9zLmJsYWNrYmVycnkgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmxhY2tiZXJyeVsyXTtcbiAgLy8gaWYgKGJiMTApIG9zLmJiMTAgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmIxMFsyXTtcbiAgLy8gaWYgKHJpbXRhYmxldG9zKSBvcy5yaW10YWJsZXRvcyA9IHRydWUsIG9zLnZlcnNpb24gPSByaW10YWJsZXRvc1syXTtcbiAgLy8gaWYgKHBsYXlib29rKSBicm93c2VyLnBsYXlib29rID0gdHJ1ZTtcbiAgLy8gaWYgKGtpbmRsZSkgb3Mua2luZGxlID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGtpbmRsZVsxXTtcbiAgLy8gaWYgKHNpbGspIGJyb3dzZXIuc2lsayA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IHNpbGtbMV07XG4gIC8vIGlmICghc2lsayAmJiBvcy5hbmRyb2lkICYmIHVhLm1hdGNoKC9LaW5kbGUgRmlyZS8pKSBicm93c2VyLnNpbGsgPSB0cnVlO1xuICAvLyBpZiAoY2hyb21lKSBicm93c2VyLmNocm9tZSA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IGNocm9tZVsxXTtcblxuICBpZiAoZmlyZWZveCkge1xuICAgIGJyb3dzZXIuZmlyZWZveCA9IHRydWU7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gZmlyZWZveFsxXTtcbiAgfSAvLyBpZiAoc2FmYXJpICYmICh1YS5tYXRjaCgvU2FmYXJpLykgfHwgISFvcy5pb3MpKSBicm93c2VyLnNhZmFyaSA9IHRydWU7XG4gIC8vIGlmICh3ZWJ2aWV3KSBicm93c2VyLndlYnZpZXcgPSB0cnVlO1xuXG5cbiAgaWYgKGllKSB7XG4gICAgYnJvd3Nlci5pZSA9IHRydWU7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gaWVbMV07XG4gIH1cblxuICBpZiAoZWRnZSkge1xuICAgIGJyb3dzZXIuZWRnZSA9IHRydWU7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gZWRnZVsxXTtcbiAgfSAvLyBJdCBpcyBkaWZmaWN1bHQgdG8gZGV0ZWN0IFdlQ2hhdCBpbiBXaW4gUGhvbmUgcHJlY2lzZWx5LCBiZWNhdXNlIHVhIGNhblxuICAvLyBub3QgYmUgc2V0IG9uIHdpbiBwaG9uZS4gU28gd2UgZG8gbm90IGNvbnNpZGVyIFdpbiBQaG9uZS5cblxuXG4gIGlmICh3ZUNoYXQpIHtcbiAgICBicm93c2VyLndlQ2hhdCA9IHRydWU7XG4gIH0gLy8gb3MudGFibGV0ID0gISEoaXBhZCB8fCBwbGF5Ym9vayB8fCAoYW5kcm9pZCAmJiAhdWEubWF0Y2goL01vYmlsZS8pKSB8fFxuICAvLyAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL1RhYmxldC8pKSB8fCAoaWUgJiYgIXVhLm1hdGNoKC9QaG9uZS8pICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSk7XG4gIC8vIG9zLnBob25lICA9ICEhKCFvcy50YWJsZXQgJiYgIW9zLmlwb2QgJiYgKGFuZHJvaWQgfHwgaXBob25lIHx8IHdlYm9zIHx8XG4gIC8vICAgICAoY2hyb21lICYmIHVhLm1hdGNoKC9BbmRyb2lkLykpIHx8IChjaHJvbWUgJiYgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLykpIHx8XG4gIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvTW9iaWxlLykpIHx8IChpZSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpKTtcblxuXG4gIHJldHVybiB7XG4gICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICBvczogb3MsXG4gICAgbm9kZTogZmFsc2UsXG4gICAgLy8g5Y6f55SfY2FudmFz5pSv5oyB77yM5pS55p6B56uv54K55LqGXG4gICAgLy8gY2FudmFzU3VwcG9ydGVkIDogIShicm93c2VyLmllICYmIHBhcnNlRmxvYXQoYnJvd3Nlci52ZXJzaW9uKSA8IDkpXG4gICAgY2FudmFzU3VwcG9ydGVkOiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQsXG4gICAgc3ZnU3VwcG9ydGVkOiB0eXBlb2YgU1ZHUmVjdCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgLy8gQHNlZSA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80ODE3MDI5L3doYXRzLXRoZS1iZXN0LXdheS10by1kZXRlY3QtYS10b3VjaC1zY3JlZW4tZGV2aWNlLXVzaW5nLWphdmFzY3JpcHQ+XG4gICAgLy8gd29ya3Mgb24gbW9zdCBicm93c2Vyc1xuICAgIC8vIElFMTAvMTEgZG9lcyBub3Qgc3VwcG9ydCB0b3VjaCBldmVudCwgYW5kIE1TIEVkZ2Ugc3VwcG9ydHMgdGhlbSBidXQgbm90IGJ5XG4gICAgLy8gZGVmYXVsdCwgc28gd2UgZG9udCBjaGVjayBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgZm9yIHRoZW0gaGVyZS5cbiAgICB0b3VjaEV2ZW50c1N1cHBvcnRlZDogJ29udG91Y2hzdGFydCcgaW4gd2luZG93ICYmICFicm93c2VyLmllICYmICFicm93c2VyLmVkZ2UsXG4gICAgLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXBvaW50ZXIlMjBldmVudD4uXG4gICAgcG9pbnRlckV2ZW50c1N1cHBvcnRlZDogJ29ucG9pbnRlcmRvd24nIGluIHdpbmRvdyAvLyBGaXJlZm94IHN1cHBvcnRzIHBvaW50ZXIgYnV0IG5vdCBieSBkZWZhdWx0LCBvbmx5IE1TIGJyb3dzZXJzIGFyZSByZWxpYWJsZSBvbiBwb2ludGVyXG4gICAgLy8gZXZlbnRzIGN1cnJlbnRseS4gU28gd2UgZG9udCB1c2UgdGhhdCBvbiBvdGhlciBicm93c2VycyB1bmxlc3MgdGVzdGVkIHN1ZmZpY2llbnRseS5cbiAgICAvLyBBbHRob3VnaCBJRSAxMCBzdXBwb3J0cyBwb2ludGVyIGV2ZW50LCBpdCB1c2Ugb2xkIHN0eWxlIGFuZCBpcyBkaWZmZXJlbnQgZnJvbSB0aGVcbiAgICAvLyBzdGFuZGFyZC4gU28gd2UgZXhjbHVkZSB0aGF0LiAoSUUgMTAgaXMgaGFyZGx5IHVzZWQgb24gdG91Y2ggZGV2aWNlKVxuICAgICYmIChicm93c2VyLmVkZ2UgfHwgYnJvd3Nlci5pZSAmJiBicm93c2VyLnZlcnNpb24gPj0gMTEpXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvZW52LmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOWchueOr1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmluZ1xuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdyaW5nJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByOiAwLFxuICAgIHIwOiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgIGN0eC5tb3ZlVG8oeCArIHNoYXBlLnIsIHkpO1xuICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUuciwgMCwgUEkyLCBmYWxzZSk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUucjAsIHkpO1xuICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUucjAsIDAsIFBJMiwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciBwb2x5SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci9wb2x5XCIpO1xuXG4vKipcbiAqIOWkmui+ueW9olxuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL1BvbHlnb25cbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAncG9seWdvbicsXG4gIHNoYXBlOiB7XG4gICAgcG9pbnRzOiBudWxsLFxuICAgIHNtb290aDogZmFsc2UsXG4gICAgc21vb3RoQ29uc3RyYWludDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBzbW9vdGhTcGxpbmUgPSByZXF1aXJlKFwiLi9zbW9vdGhTcGxpbmVcIik7XG5cbnZhciBzbW9vdGhCZXppZXIgPSByZXF1aXJlKFwiLi9zbW9vdGhCZXppZXJcIik7XG5cbmZ1bmN0aW9uIGJ1aWxkUGF0aChjdHgsIHNoYXBlLCBjbG9zZVBhdGgpIHtcbiAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgdmFyIHNtb290aCA9IHNoYXBlLnNtb290aDtcblxuICBpZiAocG9pbnRzICYmIHBvaW50cy5sZW5ndGggPj0gMikge1xuICAgIGlmIChzbW9vdGggJiYgc21vb3RoICE9PSAnc3BsaW5lJykge1xuICAgICAgdmFyIGNvbnRyb2xQb2ludHMgPSBzbW9vdGhCZXppZXIocG9pbnRzLCBzbW9vdGgsIGNsb3NlUGF0aCwgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG4gICAgICBjdHgubW92ZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTtcbiAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChjbG9zZVBhdGggPyBsZW4gOiBsZW4gLSAxKTsgaSsrKSB7XG4gICAgICAgIHZhciBjcDEgPSBjb250cm9sUG9pbnRzW2kgKiAyXTtcbiAgICAgICAgdmFyIGNwMiA9IGNvbnRyb2xQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNwMVswXSwgY3AxWzFdLCBjcDJbMF0sIGNwMlsxXSwgcFswXSwgcFsxXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzbW9vdGggPT09ICdzcGxpbmUnKSB7XG4gICAgICAgIHBvaW50cyA9IHNtb290aFNwbGluZShwb2ludHMsIGNsb3NlUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbaV1bMF0sIHBvaW50c1tpXVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2VQYXRoICYmIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxufVxuXG5leHBvcnRzLmJ1aWxkUGF0aCA9IGJ1aWxkUGF0aDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciB2MkRpc3RhbmNlID0gX3ZlY3Rvci5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYXRtdWxsLVJvbSBzcGxpbmUg5o+S5YC85oqY57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhTcGxpbmVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICogICAgICAgICBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mykge1xuICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gIHZhciB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgcmV0dXJuICgyICogKHAxIC0gcDIpICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIChwMSAtIHAyKSAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9zaGFwZS91dGlsL3Ntb290aFNwbGluZVxuICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIOe6v+autemhtueCueaVsOe7hFxuICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gX2RlZmF1bHQocG9pbnRzLCBpc0xvb3ApIHtcbiAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gIHZhciByZXQgPSBbXTtcbiAgdmFyIGRpc3RhbmNlID0gMDtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgZGlzdGFuY2UgKz0gdjJEaXN0YW5jZShwb2ludHNbaSAtIDFdLCBwb2ludHNbaV0pO1xuICB9XG5cbiAgdmFyIHNlZ3MgPSBkaXN0YW5jZSAvIDI7XG4gIHNlZ3MgPSBzZWdzIDwgbGVuID8gbGVuIDogc2VncztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ3M7IGkrKykge1xuICAgIHZhciBwb3MgPSBpIC8gKHNlZ3MgLSAxKSAqIChpc0xvb3AgPyBsZW4gOiBsZW4gLSAxKTtcbiAgICB2YXIgaWR4ID0gTWF0aC5mbG9vcihwb3MpO1xuICAgIHZhciB3ID0gcG9zIC0gaWR4O1xuICAgIHZhciBwMDtcbiAgICB2YXIgcDEgPSBwb2ludHNbaWR4ICUgbGVuXTtcbiAgICB2YXIgcDI7XG4gICAgdmFyIHAzO1xuXG4gICAgaWYgKCFpc0xvb3ApIHtcbiAgICAgIHAwID0gcG9pbnRzW2lkeCA9PT0gMCA/IGlkeCA6IGlkeCAtIDFdO1xuICAgICAgcDIgPSBwb2ludHNbaWR4ID4gbGVuIC0gMiA/IGxlbiAtIDEgOiBpZHggKyAxXTtcbiAgICAgIHAzID0gcG9pbnRzW2lkeCA+IGxlbiAtIDMgPyBsZW4gLSAxIDogaWR4ICsgMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAwID0gcG9pbnRzWyhpZHggLSAxICsgbGVuKSAlIGxlbl07XG4gICAgICBwMiA9IHBvaW50c1soaWR4ICsgMSkgJSBsZW5dO1xuICAgICAgcDMgPSBwb2ludHNbKGlkeCArIDIpICUgbGVuXTtcbiAgICB9XG5cbiAgICB2YXIgdzIgPSB3ICogdztcbiAgICB2YXIgdzMgPSB3ICogdzI7XG4gICAgcmV0LnB1c2goW2ludGVycG9sYXRlKHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdLCB3LCB3MiwgdzMpLCBpbnRlcnBvbGF0ZShwMFsxXSwgcDFbMV0sIHAyWzFdLCBwM1sxXSwgdywgdzIsIHczKV0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyTWluID0gX3ZlY3Rvci5taW47XG52YXIgdjJNYXggPSBfdmVjdG9yLm1heDtcbnZhciB2MlNjYWxlID0gX3ZlY3Rvci5zY2FsZTtcbnZhciB2MkRpc3RhbmNlID0gX3ZlY3Rvci5kaXN0YW5jZTtcbnZhciB2MkFkZCA9IF92ZWN0b3IuYWRkO1xudmFyIHYyQ2xvbmUgPSBfdmVjdG9yLmNsb25lO1xudmFyIHYyU3ViID0gX3ZlY3Rvci5zdWI7XG5cbi8qKlxuICog6LSd5aGe5bCU5bmz5ruR5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhCZXppZXJcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICogICAgICAgICBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIOe6v+autemhtueCueaVsOe7hFxuICogQHBhcmFtIHtudW1iZXJ9IHNtb290aCDlubPmu5HnrYnnuqcsIDAtMVxuICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbnN0cmFpbnQg5bCG6K6h566X5Ye65p2l55qE5o6n5Yi254K557qm5p2f5Zyo5LiA5Liq5YyF5Zu055uS5YaFXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOavlOWmgiBbWzAsIDBdLCBbMTAwLCAxMDBdXSwg6L+Z5Liq5YyF5Zu055uS5Lya5LiOXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOaVtOS4quaKmOe6v+eahOWMheWbtOebkuWBmuS4gOS4quW5tumbhueUqOadpee6puadn+aOp+WItueCueOAglxuICogQHBhcmFtIHtBcnJheX0g6K6h566X5Ye65p2l55qE5o6n5Yi254K55pWw57uEXG4gKi9cbmZ1bmN0aW9uIF9kZWZhdWx0KHBvaW50cywgc21vb3RoLCBpc0xvb3AsIGNvbnN0cmFpbnQpIHtcbiAgdmFyIGNwcyA9IFtdO1xuICB2YXIgdiA9IFtdO1xuICB2YXIgdjEgPSBbXTtcbiAgdmFyIHYyID0gW107XG4gIHZhciBwcmV2UG9pbnQ7XG4gIHZhciBuZXh0UG9pbnQ7XG4gIHZhciBtaW4sIG1heDtcblxuICBpZiAoY29uc3RyYWludCkge1xuICAgIG1pbiA9IFtJbmZpbml0eSwgSW5maW5pdHldO1xuICAgIG1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2Mk1pbihtaW4sIG1pbiwgcG9pbnRzW2ldKTtcbiAgICAgIHYyTWF4KG1heCwgbWF4LCBwb2ludHNbaV0pO1xuICAgIH0gLy8g5LiO5oyH5a6a55qE5YyF5Zu055uS5YGa5bm26ZuGXG5cblxuICAgIHYyTWluKG1pbiwgbWluLCBjb25zdHJhaW50WzBdKTtcbiAgICB2Mk1heChtYXgsIG1heCwgY29uc3RyYWludFsxXSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgaWYgKGlzTG9vcCkge1xuICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgPyBpIC0gMSA6IGxlbiAtIDFdO1xuICAgICAgbmV4dFBvaW50ID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgIGNwcy5wdXNoKHYyQ2xvbmUocG9pbnRzW2ldKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgLSAxXTtcbiAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2MlN1Yih2LCBuZXh0UG9pbnQsIHByZXZQb2ludCk7IC8vIHVzZSBkZWdyZWUgdG8gc2NhbGUgdGhlIGhhbmRsZSBsZW5ndGhcblxuICAgIHYyU2NhbGUodiwgdiwgc21vb3RoKTtcbiAgICB2YXIgZDAgPSB2MkRpc3RhbmNlKHBvaW50LCBwcmV2UG9pbnQpO1xuICAgIHZhciBkMSA9IHYyRGlzdGFuY2UocG9pbnQsIG5leHRQb2ludCk7XG4gICAgdmFyIHN1bSA9IGQwICsgZDE7XG5cbiAgICBpZiAoc3VtICE9PSAwKSB7XG4gICAgICBkMCAvPSBzdW07XG4gICAgICBkMSAvPSBzdW07XG4gICAgfVxuXG4gICAgdjJTY2FsZSh2MSwgdiwgLWQwKTtcbiAgICB2MlNjYWxlKHYyLCB2LCBkMSk7XG4gICAgdmFyIGNwMCA9IHYyQWRkKFtdLCBwb2ludCwgdjEpO1xuICAgIHZhciBjcDEgPSB2MkFkZChbXSwgcG9pbnQsIHYyKTtcblxuICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICB2Mk1heChjcDAsIGNwMCwgbWluKTtcbiAgICAgIHYyTWluKGNwMCwgY3AwLCBtYXgpO1xuICAgICAgdjJNYXgoY3AxLCBjcDEsIG1pbik7XG4gICAgICB2Mk1pbihjcDEsIGNwMSwgbWF4KTtcbiAgICB9XG5cbiAgICBjcHMucHVzaChjcDApO1xuICAgIGNwcy5wdXNoKGNwMSk7XG4gIH1cblxuICBpZiAoaXNMb29wKSB7XG4gICAgY3BzLnB1c2goY3BzLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIGNwcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvcG9seVwiKTtcblxuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZVxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdwb2x5bGluZScsXG4gIHNoYXBlOiB7XG4gICAgcG9pbnRzOiBudWxsLFxuICAgIHNtb290aDogZmFsc2UsXG4gICAgc21vb3RoQ29uc3RyYWludDogbnVsbFxuICB9LFxuICBzdHlsZToge1xuICAgIHN0cm9rZTogJyMwMDAnLFxuICAgIGZpbGw6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHBvbHlIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUsIGZhbHNlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciByb3VuZFJlY3RIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL3JvdW5kUmVjdFwiKTtcblxuLyoqXG4gKiDnn6nlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1JlY3RcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAncmVjdCcsXG4gIHNoYXBlOiB7XG4gICAgLy8g5bem5LiK44CB5Y+z5LiK44CB5Y+z5LiL44CB5bem5LiL6KeS55qE5Y2K5b6E5L6d5qyh5Li6cjHjgIFyMuOAgXIz44CBcjRcbiAgICAvLyBy57yp5YaZ5Li6MSAgICAgICAgIOebuOW9k+S6jiBbMSwgMSwgMSwgMV1cbiAgICAvLyBy57yp5YaZ5Li6WzFdICAgICAgIOebuOW9k+S6jiBbMSwgMSwgMSwgMV1cbiAgICAvLyBy57yp5YaZ5Li6WzEsIDJdICAgIOebuOW9k+S6jiBbMSwgMiwgMSwgMl1cbiAgICAvLyBy57yp5YaZ5Li6WzEsIDIsIDNdIOebuOW9k+S6jiBbMSwgMiwgMywgMl1cbiAgICByOiAwLFxuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcblxuICAgIGlmICghc2hhcGUucikge1xuICAgICAgY3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdW5kUmVjdEhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSk7XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIHJldHVybjtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxuLyoqXG4gKiDnm7Tnur9cbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL0xpbmVcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnbGluZScsXG4gIHNoYXBlOiB7XG4gICAgLy8gU3RhcnQgcG9pbnRcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICAvLyBFbmQgcG9pbnRcbiAgICB4MjogMCxcbiAgICB5MjogMCxcbiAgICBwZXJjZW50OiAxXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHgxID0gc2hhcGUueDE7XG4gICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgdmFyIHkyID0gc2hhcGUueTI7XG4gICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xuXG4gICAgaWYgKHBlcmNlbnQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG5cbiAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgIHgyID0geDEgKiAoMSAtIHBlcmNlbnQpICsgeDIgKiBwZXJjZW50O1xuICAgICAgeTIgPSB5MSAqICgxIC0gcGVyY2VudCkgKyB5MiAqIHBlcmNlbnQ7XG4gICAgfVxuXG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBwb2ludEF0OiBmdW5jdGlvbiAocCkge1xuICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgcmV0dXJuIFtzaGFwZS54MSAqICgxIC0gcCkgKyBzaGFwZS54MiAqIHAsIHNoYXBlLnkxICogKDEgLSBwKSArIHNoYXBlLnkyICogcF07XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciB2ZWMyID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgX2N1cnZlID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvY3VydmVcIik7XG5cbnZhciBxdWFkcmF0aWNTdWJkaXZpZGUgPSBfY3VydmUucXVhZHJhdGljU3ViZGl2aWRlO1xudmFyIGN1YmljU3ViZGl2aWRlID0gX2N1cnZlLmN1YmljU3ViZGl2aWRlO1xudmFyIHF1YWRyYXRpY0F0ID0gX2N1cnZlLnF1YWRyYXRpY0F0O1xudmFyIGN1YmljQXQgPSBfY3VydmUuY3ViaWNBdDtcbnZhciBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgPSBfY3VydmUucXVhZHJhdGljRGVyaXZhdGl2ZUF0O1xudmFyIGN1YmljRGVyaXZhdGl2ZUF0ID0gX2N1cnZlLmN1YmljRGVyaXZhdGl2ZUF0O1xuXG4vKipcbiAqIOi0neWhnuWwlOabsue6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL0JlemllckN1cnZlXG4gKi9cbnZhciBvdXQgPSBbXTtcblxuZnVuY3Rpb24gc29tZVZlY3RvckF0KHNoYXBlLCB0LCBpc1RhbmdlbnQpIHtcbiAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xuICB2YXIgY3B5MiA9IHNoYXBlLmNweTI7XG5cbiAgaWYgKGNweDIgPT09IG51bGwgfHwgY3B5MiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbKGlzVGFuZ2VudCA/IGN1YmljRGVyaXZhdGl2ZUF0IDogY3ViaWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLmNweDIsIHNoYXBlLngyLCB0KSwgKGlzVGFuZ2VudCA/IGN1YmljRGVyaXZhdGl2ZUF0IDogY3ViaWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLmNweTIsIHNoYXBlLnkyLCB0KV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFsoaXNUYW5nZW50ID8gcXVhZHJhdGljRGVyaXZhdGl2ZUF0IDogcXVhZHJhdGljQXQpKHNoYXBlLngxLCBzaGFwZS5jcHgxLCBzaGFwZS54MiwgdCksIChpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLnkyLCB0KV07XG4gIH1cbn1cblxudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnYmV6aWVyLWN1cnZlJyxcbiAgc2hhcGU6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB4MjogMCxcbiAgICB5MjogMCxcbiAgICBjcHgxOiAwLFxuICAgIGNweTE6IDAsXG4gICAgLy8gY3B4MjogMCxcbiAgICAvLyBjcHkyOiAwXG4gICAgLy8gQ3VydmUgc2hvdyBwZXJjZW50LCBmb3IgYW5pbWF0aW5nXG4gICAgcGVyY2VudDogMVxuICB9LFxuICBzdHlsZToge1xuICAgIHN0cm9rZTogJyMwMDAnLFxuICAgIGZpbGw6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4MSA9IHNoYXBlLngxO1xuICAgIHZhciB5MSA9IHNoYXBlLnkxO1xuICAgIHZhciB4MiA9IHNoYXBlLngyO1xuICAgIHZhciB5MiA9IHNoYXBlLnkyO1xuICAgIHZhciBjcHgxID0gc2hhcGUuY3B4MTtcbiAgICB2YXIgY3B5MSA9IHNoYXBlLmNweTE7XG4gICAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xuICAgIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcbiAgICB2YXIgcGVyY2VudCA9IHNoYXBlLnBlcmNlbnQ7XG5cbiAgICBpZiAocGVyY2VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblxuICAgIGlmIChjcHgyID09IG51bGwgfHwgY3B5MiA9PSBudWxsKSB7XG4gICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKHgxLCBjcHgxLCB4MiwgcGVyY2VudCwgb3V0KTtcbiAgICAgICAgY3B4MSA9IG91dFsxXTtcbiAgICAgICAgeDIgPSBvdXRbMl07XG4gICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZSh5MSwgY3B5MSwgeTIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgIHkyID0gb3V0WzJdO1xuICAgICAgfVxuXG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjcHgxLCBjcHkxLCB4MiwgeTIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgY3ViaWNTdWJkaXZpZGUoeDEsIGNweDEsIGNweDIsIHgyLCBwZXJjZW50LCBvdXQpO1xuICAgICAgICBjcHgxID0gb3V0WzFdO1xuICAgICAgICBjcHgyID0gb3V0WzJdO1xuICAgICAgICB4MiA9IG91dFszXTtcbiAgICAgICAgY3ViaWNTdWJkaXZpZGUoeTEsIGNweTEsIGNweTIsIHkyLCBwZXJjZW50LCBvdXQpO1xuICAgICAgICBjcHkxID0gb3V0WzFdO1xuICAgICAgICBjcHkyID0gb3V0WzJdO1xuICAgICAgICB5MiA9IG91dFszXTtcbiAgICAgIH1cblxuICAgICAgY3R4LmJlemllckN1cnZlVG8oY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgeDIsIHkyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBwb2ludCBhdCBwZXJjZW50XG4gICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHBvaW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHNvbWVWZWN0b3JBdCh0aGlzLnNoYXBlLCB0LCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0YW5nZW50IGF0IHBlcmNlbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgdGFuZ2VudEF0OiBmdW5jdGlvbiAodCkge1xuICAgIHZhciBwID0gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIHRydWUpO1xuICAgIHJldHVybiB2ZWMyLm5vcm1hbGl6ZShwLCBwKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5ZyG5bynXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9BcmNcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnYXJjJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByOiAwLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICB9LFxuICBzdHlsZToge1xuICAgIHN0cm9rZTogJyMwMDAnLFxuICAgIGZpbGw6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICB2YXIgciA9IE1hdGgubWF4KHNoYXBlLnIsIDApO1xuICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICB2YXIgY2xvY2t3aXNlID0gc2hhcGUuY2xvY2t3aXNlO1xuICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIHZhciB1bml0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC5tb3ZlVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBHcmFkaWVudCA9IHJlcXVpcmUoXCIuL0dyYWRpZW50XCIpO1xuXG4vKipcbiAqIHgsIHksIHgyLCB5MiBhcmUgYWxsIHBlcmNlbnQgZnJvbSAwIHRvIDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW3gyPTFdXG4gKiBAcGFyYW0ge251bWJlcn0gW3kyPTBdXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjb2xvclN0b3BzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxDb29yZD1mYWxzZV1cbiAqL1xudmFyIExpbmVhckdyYWRpZW50ID0gZnVuY3Rpb24gKHgsIHksIHgyLCB5MiwgY29sb3JTdG9wcywgZ2xvYmFsQ29vcmQpIHtcbiAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAvLyBkZWNsYXJkIGJ5IGBjb2xvcjoge3R5cGU6ICdsaW5lYXInLCBjb2xvclN0b3BzOiAuLi59YCwgd2hlcmVcbiAgLy8gdGhpcyBjb25zdHJ1Y3RvciB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gIHRoaXMueCA9IHggPT0gbnVsbCA/IDAgOiB4O1xuICB0aGlzLnkgPSB5ID09IG51bGwgPyAwIDogeTtcbiAgdGhpcy54MiA9IHgyID09IG51bGwgPyAxIDogeDI7XG4gIHRoaXMueTIgPSB5MiA9PSBudWxsID8gMCA6IHkyOyAvLyBDYW4gYmUgY2xvbmVkXG5cbiAgdGhpcy50eXBlID0gJ2xpbmVhcic7IC8vIElmIHVzZSBnbG9iYWwgY29vcmRcblxuICB0aGlzLmdsb2JhbCA9IGdsb2JhbENvb3JkIHx8IGZhbHNlO1xuICBHcmFkaWVudC5jYWxsKHRoaXMsIGNvbG9yU3RvcHMpO1xufTtcblxuTGluZWFyR3JhZGllbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTGluZWFyR3JhZGllbnRcbn07XG56clV0aWwuaW5oZXJpdHMoTGluZWFyR3JhZGllbnQsIEdyYWRpZW50KTtcbnZhciBfZGVmYXVsdCA9IExpbmVhckdyYWRpZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBHcmFkaWVudCA9IHJlcXVpcmUoXCIuL0dyYWRpZW50XCIpO1xuXG4vKipcbiAqIHgsIHksIHIgYXJlIGFsbCBwZXJjZW50IGZyb20gMCB0byAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MC41XVxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTAuNV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcj0wLjVdXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbY29sb3JTdG9wc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICovXG52YXIgUmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgciwgY29sb3JTdG9wcywgZ2xvYmFsQ29vcmQpIHtcbiAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAvLyBkZWNsYXJkIGJ5IGBjb2xvcjoge3R5cGU6ICdyYWRpYWwnLCBjb2xvclN0b3BzOiAuLi59YCwgd2hlcmVcbiAgLy8gdGhpcyBjb25zdHJ1Y3RvciB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gIHRoaXMueCA9IHggPT0gbnVsbCA/IDAuNSA6IHg7XG4gIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAuNSA6IHk7XG4gIHRoaXMuciA9IHIgPT0gbnVsbCA/IDAuNSA6IHI7IC8vIENhbiBiZSBjbG9uZWRcblxuICB0aGlzLnR5cGUgPSAncmFkaWFsJzsgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuXG4gIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG4gIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG59O1xuXG5SYWRpYWxHcmFkaWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBSYWRpYWxHcmFkaWVudFxufTtcbnpyVXRpbC5pbmhlcml0cyhSYWRpYWxHcmFkaWVudCwgR3JhZGllbnQpO1xudmFyIF9kZWZhdWx0ID0gUmFkaWFsR3JhZGllbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vU3R5bGVcIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgdmVjMkNvcHkgPSBfdmVjdG9yLmNvcHk7XG5cbi8qKlxuICogU3RhdGVzIG1hY2hpbmUgZm9yIG1hbmFnaW5nIGdyYXBoaWMgc3RhdGVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJR3JhcGhpY1N0YXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3psZXZlbF1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbel1cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj59IHtwb3NpdGlvbn1cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVtYmVyfSB7cm90YXRpb259XG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSB7c2NhbGV9XG4gKiBAcHJvcGVydHkge09iamVjdH0gc3R5bGVcbiAqXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvbmVudGVyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvbmxlYXZlXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvbnRyYW5zaXRpb25cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPElHcmFwaGljU3RhdGVUcmFuc2l0aW9ufHN0cmluZz59IHRyYW5zaXRpb25cbiAqICAgICAgICAgICBUcmFuc2l0aW9uIG9iamVjdCBvciBhIHN0cmluZyBkZXNjcmlwdG9yIGxpa2UgJyogMzAgMCBMaW5lYXInXG4gKi9cbnZhciB0cmFuc2l0aW9uUHJvcGVydGllcyA9IFsncG9zaXRpb24nLCAncm90YXRpb24nLCAnc2NhbGUnLCAnc3R5bGUnLCAnc2hhcGUnXTtcbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvU3RhdGVzflRyYW5zaXRpb25PYmplY3RcbiAqL1xuXG52YXIgVHJhbnNpdGlvbk9iamVjdCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PSAnc3RyaW5nJykge1xuICAgIHRoaXMuX2Zyb21TdHIob3B0cyk7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIG9wdHMucHJvcGVydHkgJiYgKHRoaXMucHJvcGVydHkgPSBvcHRzLnByb3BlcnR5KTtcbiAgICBvcHRzLmR1cmF0aW9uICE9IG51bGwgJiYgKHRoaXMuZHVyYXRpb24gPSBvcHRzLmR1cmF0aW9uKTtcbiAgICBvcHRzLmVhc2luZyAmJiAodGhpcy5lYXNpbmcgPSBvcHRzLmVhc2luZyk7XG4gICAgb3B0cy5kZWxheSAmJiAodGhpcy5kZWxheSA9IG9wdHMuZGVsYXkpO1xuICB9XG5cbiAgaWYgKHRoaXMucHJvcGVydHkgIT09ICcqJykge1xuICAgIHRoaXMucHJvcGVydHkgPSB0aGlzLnByb3BlcnR5LnNwbGl0KCcsJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcm9wZXJ0eSA9IHRyYW5zaXRpb25Qcm9wZXJ0aWVzO1xuICB9XG59O1xuXG5UcmFuc2l0aW9uT2JqZWN0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zaXRpb25PYmplY3QsXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYWxsIHRyYW5zaXRpb24gcHJvcGVydGllcy4gU3BsaXR0ZWQgYnkgY29tbWEuIE11c3Qgbm90IGhhdmUgc3BhY2VzIGluIHRoZSBzdHJpbmcuXG4gICAqIGUuZy4gJ3Bvc2l0aW9uLHN0eWxlLmNvbG9yJy4gJyonIHdpbGwgbWF0Y2ggYWxsIHRoZSB2YWxpZCBwcm9wZXJ0aWVzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAqXG4gICAqL1xuICBwcm9wZXJ0eTogJyonLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnTGluZWFyJ1xuICAgKi9cbiAgZWFzaW5nOiAnTGluZWFyJyxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgJ251bWJlcidcbiAgICovXG4gIGR1cmF0aW9uOiA1MDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBkZWxheTogMCxcbiAgX2Zyb21TdHI6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgYXJyID0gc3RyLnNwbGl0KC9cXHMrL2cpO1xuICAgIHRoaXMucHJvcGVydHkgPSBhcnJbMF07XG4gICAgdGhpcy5kdXJhdGlvbiA9ICthcnJbMV07XG4gICAgdGhpcy5kZWxheSA9ICthcnJbMl07XG4gICAgdGhpcy5lYXNpbmcgPSBhcnJbM107XG4gIH1cbn07XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL1N0YXRlc1xuICovXG5cbnZhciBHcmFwaGljU3RhdGVzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMuX3N0YXRlcyA9IHt9O1xuICAvKipcbiAgICogVGFyZ2V0IGVsZW1lbnRcbiAgICogQHR5cGUge3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZXx6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICovXG5cbiAgdGhpcy5fZWwgPSBvcHRzLmVsO1xuICB0aGlzLl9zdWJTdGF0ZXMgPSBbXTtcbiAgdGhpcy5fdHJhbnNpdGlvbkFuaW1hdG9ycyA9IFtdO1xuXG4gIGlmIChvcHRzLmluaXRpYWxTdGF0ZSkge1xuICAgIHRoaXMuX2luaXRpYWxTdGF0ZSA9IG9wdHMuaW5pdGlhbFN0YXRlO1xuICB9XG5cbiAgdmFyIG9wdHNTdGF0ZXMgPSBvcHRzLnN0YXRlcztcblxuICBpZiAob3B0c1N0YXRlcykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gb3B0c1N0YXRlcykge1xuICAgICAgaWYgKG9wdHNTdGF0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gb3B0c1N0YXRlc1tuYW1lXTtcblxuICAgICAgICB0aGlzLl9hZGRTdGF0ZShuYW1lLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zZXRTdGF0ZSh0aGlzLl9pbml0aWFsU3RhdGUpO1xufTtcblxuR3JhcGhpY1N0YXRlcy5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBHcmFwaGljU3RhdGVzLFxuXG4gIC8qKlxuICAgKiBBbGwgb3RoZXIgc3RhdGUgd2lsbCBiZSBleHRlbmRlZCBmcm9tIGluaXRpYWwgc3RhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0aWFsU3RhdGU6ICdub3JtYWwnLFxuXG4gIC8qKlxuICAgKiBDdXJyZW50IHN0YXRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3VycmVudFN0YXRlOiAnJyxcbiAgZWw6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWw7XG4gIH0sXG4gIF9hZGRTdGF0ZTogZnVuY3Rpb24gKG5hbWUsIHN0YXRlKSB7XG4gICAgdGhpcy5fc3RhdGVzW25hbWVdID0gc3RhdGU7XG5cbiAgICBpZiAoc3RhdGUudHJhbnNpdGlvbikge1xuICAgICAgc3RhdGUudHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uT2JqZWN0KHN0YXRlLnRyYW5zaXRpb24pO1xuICAgIH0gLy8gRXh0ZW5kIGZyb20gaW5pdGlhbCBzdGF0ZVxuXG5cbiAgICBpZiAobmFtZSAhPT0gdGhpcy5faW5pdGlhbFN0YXRlKSB7XG4gICAgICB0aGlzLl9leHRlbmRGcm9tSW5pdGlhbChzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbCA9IHRoaXMuX2VsOyAvLyBzZXRTdGF0ZSDnmoTml7blgJnoh6rluKbnmoQgc3R5bGUg5ZKMIHNoYXBlIOmDveS8muiiq+ebtOaOpeimhuebllxuICAgICAgLy8g5omA5Lul6L+Z6L655YWI5oqK6Ieq5bim55qEIHN0eWxlIOWSjCBzaGFwZSDmianlsZXliLDliJ3lp4vnirbmgIHkuK1cblxuICAgICAgenJVdGlsLm1lcmdlKHN0YXRlLnN0eWxlLCBlbC5zdHlsZSwgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgaWYgKHN0YXRlLnNoYXBlKSB7XG4gICAgICAgIHpyVXRpbC5tZXJnZShzdGF0ZS5zaGFwZSwgZWwuc2hhcGUsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnNoYXBlID0genJVdGlsLmNsb25lKGVsLnNoYXBlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLl9zdGF0ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHRoaXMuX2V4dGVuZEZyb21Jbml0aWFsKHRoaXMuX3N0YXRlc1tuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIF9leHRlbmRGcm9tSW5pdGlhbDogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuX3N0YXRlc1t0aGlzLl9pbml0aWFsU3RhdGVdO1xuXG4gICAgaWYgKGluaXRpYWxTdGF0ZSAmJiBzdGF0ZSAhPT0gaW5pdGlhbFN0YXRlKSB7XG4gICAgICB6clV0aWwubWVyZ2Uoc3RhdGUsIGluaXRpYWxTdGF0ZSwgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgfSxcbiAgc2V0U3RhdGU6IGZ1bmN0aW9uIChuYW1lLCBzaWxlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gdGhpcy5fY3VycmVudFN0YXRlICYmICF0aGlzLnRyYW5zaXRpbmcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlc1tuYW1lXTtcblxuICAgIGlmIChzdGF0ZSkge1xuICAgICAgdGhpcy5fc3RvcFRyYW5zaXRpb24oKTtcblxuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdmFyIHByZXZTdGF0ZSA9IHRoaXMuX3N0YXRlc1t0aGlzLl9jdXJyZW50U3RhdGVdO1xuXG4gICAgICAgIGlmIChwcmV2U3RhdGUpIHtcbiAgICAgICAgICBwcmV2U3RhdGUub25sZWF2ZSAmJiBwcmV2U3RhdGUub25sZWF2ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUub25lbnRlciAmJiBzdGF0ZS5vbmVudGVyLmNhbGwodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IG5hbWU7XG5cbiAgICAgIGlmICh0aGlzLl9lbCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLl9lbDsgLy8gU2V0dGluZyBhdHRyaWJ1dGVzXG5cbiAgICAgICAgaWYgKHN0YXRlLnpsZXZlbCAhPSBudWxsKSB7XG4gICAgICAgICAgZWwuemxldmVsID0gc3RhdGUuemxldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLnogIT0gbnVsbCkge1xuICAgICAgICAgIGVsLnogPSBzdGF0ZS56O1xuICAgICAgICB9IC8vIFNSVFxuXG5cbiAgICAgICAgc3RhdGUucG9zaXRpb24gJiYgdmVjMkNvcHkoZWwucG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgc3RhdGUuc2NhbGUgJiYgdmVjMkNvcHkoZWwuc2NhbGUsIHN0YXRlLnNjYWxlKTtcblxuICAgICAgICBpZiAoc3RhdGUucm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIGVsLnJvdGF0aW9uID0gc3RhdGUucm90YXRpb247XG4gICAgICAgIH0gLy8gU3R5bGVcblxuXG4gICAgICAgIGlmIChzdGF0ZS5zdHlsZSkge1xuICAgICAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLl9zdGF0ZXNbdGhpcy5faW5pdGlhbFN0YXRlXTtcbiAgICAgICAgICBlbC5zdHlsZSA9IG5ldyBTdHlsZSgpO1xuXG4gICAgICAgICAgaWYgKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgZWwuc3R5bGUuZXh0ZW5kRnJvbShpbml0aWFsU3RhdGUuc3R5bGUsIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIC8vIE5vdCBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgbmFtZSAhPSB0aGlzLl9pbml0aWFsU3RhdGUgLy8gTm90IGNvcGllZCBmcm9tIGluaXRpYWwgc3RhdGUgaW4gX2V4dGVuZEZyb21Jbml0aWFsIG1ldGhvZFxuICAgICAgICAgICYmIGluaXRpYWxTdGF0ZS5zdHlsZSAhPT0gc3RhdGUuc3R5bGUpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmV4dGVuZEZyb20oc3RhdGUuc3R5bGUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZS5zaGFwZSkge1xuICAgICAgICAgIGVsLnNoYXBlID0genJVdGlsLmNsb25lKHN0YXRlLnNoYXBlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLmRpcnR5KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdWJTdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3N1YlN0YXRlcy5zZXRTdGF0ZShuYW1lKTtcbiAgICB9XG4gIH0sXG4gIGdldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZTtcbiAgfSxcbiAgdHJhbnNpdGlvblN0YXRlOiBmdW5jdGlvbiAodGFyZ2V0LCBkb25lKSB7XG4gICAgaWYgKHRhcmdldCA9PT0gdGhpcy5fY3VycmVudFN0YXRlICYmICF0aGlzLnRyYW5zaXRpbmcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlc1t0YXJnZXRdO1xuICAgIHZhciBzdHlsZVNoYXBlUmVnID0gLyRbc3R5bGV8c2hhcGVdXFwuLztcbiAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIEFuaW1hdGlvbiDljrvph41cblxuICAgIHZhciBwcm9wUGF0aE1hcCA9IHt9O1xuXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICBzZWxmLl9zdG9wVHJhbnNpdGlvbigpO1xuXG4gICAgICB2YXIgZWwgPSBzZWxmLl9lbDtcblxuICAgICAgaWYgKHN0YXRlLnRyYW5zaXRpb24gJiYgZWwgJiYgZWwuX196cikge1xuICAgICAgICAvLyBFbCBjYW4gYmUgYW5pbWF0ZWRcbiAgICAgICAgdmFyIHRyYW5zaXRpb25DZmcgPSBzdGF0ZS50cmFuc2l0aW9uO1xuICAgICAgICB2YXIgcHJvcGVydHkgPSB0cmFuc2l0aW9uQ2ZnLnByb3BlcnR5O1xuICAgICAgICB2YXIgYW5pbWF0aW5nQ291bnQgPSAwO1xuXG4gICAgICAgIHZhciBhbmltYXRpb25Eb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGFuaW1hdGluZ0NvdW50LS07XG5cbiAgICAgICAgICBpZiAoYW5pbWF0aW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHNlbGYuc2V0U3RhdGUodGFyZ2V0KTtcbiAgICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlbaV07IC8vIEFuaW1hdGluZyBhbGwgdGhlIHByb3BlcnRpZXMgaW4gc3R5bGUgb3Igc2hhcGVcblxuICAgICAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3N0eWxlJyB8fCBwcm9wTmFtZSA9PT0gJ3NoYXBlJykge1xuICAgICAgICAgICAgaWYgKHN0YXRlW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3RhdGVbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZVtwcm9wTmFtZV0uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBwcm9wTmFtZSArICcuJyArIGtleTtcblxuICAgICAgICAgICAgICAgIGlmIChwcm9wUGF0aE1hcFtwYXRoXSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJvcFBhdGhNYXBbcGF0aF0gPSAxO1xuICAgICAgICAgICAgICAgIGFuaW1hdGluZ0NvdW50ICs9IHNlbGYuX2FuaW1Qcm9wKHN0YXRlLCBwcm9wTmFtZSwga2V5LCB0cmFuc2l0aW9uQ2ZnLCBhbmltYXRpb25Eb25lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvcFBhdGhNYXBbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9wUGF0aE1hcFtwcm9wTmFtZV0gPSAxOyAvLyBBbmltYXRpbmcgcGFydGljdWxhciBwcm9wZXJ0eSBpbiBzdHlsZSBvciBzdHlsZVxuXG4gICAgICAgICAgICBpZiAocHJvcE5hbWUubWF0Y2goc3R5bGVTaGFwZVJlZykpIHtcbiAgICAgICAgICAgICAgLy8gcmVtb3ZlICdzdHlsZS4nLCAnc2hhcGUuJyBwcmVmaXhcbiAgICAgICAgICAgICAgdmFyIHN1YlByb3AgPSBwcm9wTmFtZS5zbGljZSgwLCA1KTtcbiAgICAgICAgICAgICAgcHJvcE5hbWUgPSBwcm9wTmFtZS5zbGljZSg2KTtcbiAgICAgICAgICAgICAgYW5pbWF0aW5nQ291bnQgKz0gc2VsZi5fYW5pbVByb3Aoc3RhdGUsIHN1YlByb3AsIHByb3BOYW1lLCB0cmFuc2l0aW9uQ2ZnLCBhbmltYXRpb25Eb25lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFuaW1hdGluZ0NvdW50ICs9IHNlbGYuX2FuaW1Qcm9wKHN0YXRlLCAnJywgcHJvcE5hbWUsIHRyYW5zaXRpb25DZmcsIGFuaW1hdGlvbkRvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBObyB0cmFuc2l0aW9uIHByb3BlcnRpZXNcblxuXG4gICAgICAgIGlmIChhbmltYXRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgIHNlbGYuc2V0U3RhdGUodGFyZ2V0KTtcbiAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5zZXRTdGF0ZSh0YXJnZXQpO1xuICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3ViU3RhdGVzID0gc2VsZi5fc3ViU3RhdGVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJTdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN1YlN0YXRlcy50cmFuc2l0aW9uU3RhdGUodGFyZ2V0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERvIHRyYW5zaXRpb24gYW5pbWF0aW9uIG9mIHBhcnRpY3VsYXIgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJQcm9wS2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zaXRpb25DZmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FuaW1Qcm9wOiBmdW5jdGlvbiAoc3RhdGUsIHN1YlByb3BLZXksIGtleSwgdHJhbnNpdGlvbkNmZywgZG9uZSkge1xuICAgIHZhciBlbCA9IHRoaXMuX2VsO1xuICAgIHZhciBzdGF0ZU9iaiA9IHN1YlByb3BLZXkgPyBzdGF0ZVtzdWJQcm9wS2V5XSA6IHN0YXRlO1xuICAgIHZhciBlbE9iaiA9IHN1YlByb3BLZXkgPyBlbFtzdWJQcm9wS2V5XSA6IGVsO1xuICAgIHZhciBhdmFpbGFibGVQcm9wID0gc3RhdGVPYmogJiYga2V5IGluIHN0YXRlT2JqICYmIGVsT2JqICYmIGtleSBpbiBlbE9iajtcbiAgICB2YXIgdHJhbnNpdGlvbkFuaW1hdG9ycyA9IHRoaXMuX3RyYW5zaXRpb25BbmltYXRvcnM7XG5cbiAgICBpZiAoYXZhaWxhYmxlUHJvcCkge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuXG4gICAgICBpZiAoc3RhdGVPYmpba2V5XSA9PT0gZWxPYmpba2V5XSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgb2JqW2tleV0gPSBzdGF0ZU9ialtrZXldO1xuICAgICAgdmFyIGFuaW1hdG9yID0gZWwuYW5pbWF0ZShzdWJQcm9wS2V5KS53aGVuKHRyYW5zaXRpb25DZmcuZHVyYXRpb24sIG9iaikuZGVsYXkodHJhbnNpdGlvbkNmZy5kZWFseSkuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHggPSB6clV0aWwuaW5kZXhPZih0cmFuc2l0aW9uQW5pbWF0b3JzLCAxKTtcblxuICAgICAgICBpZiAoaWR4ID4gMCkge1xuICAgICAgICAgIHRyYW5zaXRpb25BbmltYXRvcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBkb25lKCk7XG4gICAgICB9KS5zdGFydCh0cmFuc2l0aW9uQ2ZnLmVhc2luZyk7XG4gICAgICB0cmFuc2l0aW9uQW5pbWF0b3JzLnB1c2goYW5pbWF0b3IpO1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIF9zdG9wVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0cmFuc2l0aW9uQW5pbWF0b3JzID0gdGhpcy5fdHJhbnNpdGlvbkFuaW1hdG9ycztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNpdGlvbkFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJhbnNpdGlvbkFuaW1hdG9yc1tpXS5zdG9wKCk7XG4gICAgfVxuXG4gICAgdHJhbnNpdGlvbkFuaW1hdG9ycy5sZW5ndGggPSAwO1xuICB9LFxuICB0cmFuc2l0aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25BbmltYXRvcnMubGVuZ3RoID4gMDtcbiAgfSxcbiAgYWRkU3ViU3RhdGVzOiBmdW5jdGlvbiAoc3RhdGVzKSB7XG4gICAgdGhpcy5fc3ViU3RhdGVzLnB1c2goc3RhdGVzKTtcbiAgfSxcbiAgcmVtb3ZlU3ViU3RhdGVzOiBmdW5jdGlvbiAoc3RhdGVzKSB7XG4gICAgdmFyIGlkeCA9IHpyVXRpbC5pbmRleE9mKHRoaXMuX3N1YlN0YXRlcywgc3RhdGVzKTtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgdGhpcy5fc3ViU3RhdGVzLnNwbGljZShzdGF0ZXMsIDEpO1xuICAgIH1cbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEdyYXBoaWNTdGF0ZXM7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1N0YXRlcy5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIHZhciBhcGlMaXN0ID0gW1xyXG4gICAgICAgICdnZXREb20nLCAnZ2V0WnInLCAnZ2V0V2lkdGgnLCAnZ2V0SGVpZ2h0JywgJ2Rpc3BhdGNoQWN0aW9uJyxcclxuICAgICAgICAnb24nLCAnb2ZmJywgJ3RyaWdnZXInLCAnZ2V0RGF0YVVSTCcsICdnZXRDb25uZWN0ZWREYXRhVVJMJywgJ2dldE1vZGVsJywgJ2dldE9wdGlvbicsXHJcbiAgICAgICAgXCJyZW1vdmVcIiwgXCJfZ2V0UGFyZW50WnJcIlxyXG4gICAgXTtcclxuXHJcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25BUEkoaW5zdGFuY2UpIHtcclxuICAgICAgICB6clV0aWwuZWFjaChhcGlMaXN0LCBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzW25hbWVdID0genJVdGlsLmJpbmQoaW5zdGFuY2VbbmFtZV0sIGluc3RhbmNlKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV4dGVuc2lvbkFQSTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9FeHRlbnNpb25BcGkuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUG9pbnRcclxuICAgICAgKlxyXG4gICAgICAqXHJcbiAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICogQHRoaXMge1BvaW50fVxyXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgb2YgcG9pbnQuXHJcbiAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSBvZiBwb2ludC5cclxuICAgICAgKiBOb3RlOiBFdmVuIGlmIGl0IGlzIG5hbWVkIFBvaW50IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIG5hbWVkIERvdCBhcyBEb3QgaXMgY2xvc2VyXHJcbiAgICAgICogdGhlbiBQb2ludCBmcm9tIG1hdGggcGVyc3BlY3RpdmUuXHJcbiAgICAgICoqL1xyXG4gICAgZnVuY3Rpb24gUG9pbnQoeCwgeSl7XHJcbiAgICAgICAgLyoqVGhlIHggY29vcmRpbmF0ZSBvZiBwb2ludCovXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuXHJcbiAgICAgICAgLyoqVGhlIHkgY29vcmRpbmF0ZSBvZiBwb2ludCovXHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKkNyZWF0ZXMgYSB7UG9pbnR9IG91dCBvZiBKU09OIHBhcnNlZCBvYmplY3RcclxuICAgICAqQHBhcmFtIHtKU09OT2JqZWN0fSBvIC0gdGhlIEpTT04gcGFyc2VkIG9iamVjdFxyXG4gICAgICpAcmV0dXJuIHtQb2ludH0gYSBuZXdseSBjb25zdHJ1Y3RlZCBQb2ludFxyXG4gICAgICoqL1xyXG4gICAgUG9pbnQubG9hZCA9IGZ1bmN0aW9uKG8pe1xyXG4gICAgICAgIHZhciBuZXdQb2ludCA9IG5ldyBQb2ludChOdW1iZXIoby54KSwgTnVtYmVyKG8ueSkpO1xyXG4gICAgICAgIHJldHVybiBuZXdQb2ludDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKkNyZWF0ZXMgYW4gYXJyYXkgb2YgcG9pbnRzIGZyb20gYW4gYXJyYXkgb2Yge0pTT05PYmplY3R9c1xyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gdGhlIGFycmF5IG9mIEpTT05PYmplY3RzXHJcbiAgICAgKkByZXR1cm4gYW4ge0FycmF5fSBvZiB7UG9pbnR9c1xyXG4gICAgICoqL1xyXG4gICAgUG9pbnQubG9hZEFycmF5ID0gZnVuY3Rpb24odil7XHJcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPCB2Lmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2goUG9pbnQubG9hZCh2W2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdQb2ludHM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipDbG9uZXMgYW4gYXJyYXkgb2YgcG9pbnRzXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSB0aGUgYXJyYXkgb2Yge1BvaW50fXNcclxuICAgICAqQHJldHVybiBhbiB7QXJyYXl9IG9mIHtQb2ludH1zXHJcbiAgICAgKiovXHJcbiAgICBQb2ludC5jbG9uZUFycmF5ID0gZnVuY3Rpb24odil7XHJcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPCB2Lmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2godltpXS5jbG9uZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1BvaW50cztcclxuICAgIH07XHJcblxyXG4gICAgUG9pbnQucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yIDogUG9pbnQsXHJcblxyXG4gICAgICAgIHRyYW5zZm9ybTpmdW5jdGlvbihtYXRyaXgpe1xyXG4gICAgICAgICAgICB2YXIgb2xkWCA9IHRoaXMueDtcclxuICAgICAgICAgICAgdmFyIG9sZFkgPSB0aGlzLnk7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IG1hdHJpeFswXVswXSAqIG9sZFggKyBtYXRyaXhbMF1bMV0gKiBvbGRZICsgbWF0cml4WzBdWzJdO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBtYXRyaXhbMV1bMF0gKiBvbGRYICsgbWF0cml4WzFdWzFdICogb2xkWSArIG1hdHJpeFsxXVsyXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipUZXN0cyBpZiB0aGlzIHBvaW50IGlzIHNpbWlsYXIgdG8gb3RoZXIgcG9pbnRcclxuICAgICAgICAgKkBwYXJhbSB7UG9pbnR9IGFub3RoZXJQb2ludCAtIHRoZSBvdGhlciBwb2ludFxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBlcXVhbHM6ZnVuY3Rpb24oYW5vdGhlclBvaW50KXtcclxuICAgICAgICAgICAgaWYoISAoYW5vdGhlclBvaW50IGluc3RhbmNlb2YgUG9pbnQpICl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnggPT0gYW5vdGhlclBvaW50LngpXHJcbiAgICAgICAgICAgICYmICh0aGlzLnkgPT0gYW5vdGhlclBvaW50LnkpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqQ2xvbmUgY3VycmVudCBQb2ludFxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIG5ld1BvaW50ID0gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1BvaW50O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFkZDogZnVuY3Rpb24ocG9pbnQpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy54ICsgcG9pbnQueDtcclxuICAgICAgICAgICAgdGhpcy55ID0gdGhpcy55ICsgcG9pbnQueTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqVGVzdHMgdG8gc2VlIGlmIGEgcG9pbnQgKHgsIHkpIGlzIHdpdGhpbiBhIHJhbmdlIG9mIGN1cnJlbnQgUG9pbnRcclxuICAgICAgICAgKkBwYXJhbSB7TnVtZXJpY30geCAtIHRoZSB4IGNvb3JkaW5hdGUgb2YgdGVzdGVkIHBvaW50XHJcbiAgICAgICAgICpAcGFyYW0ge051bWVyaWN9IHkgLSB0aGUgeCBjb29yZGluYXRlIG9mIHRlc3RlZCBwb2ludFxyXG4gICAgICAgICAqQHBhcmFtIHtOdW1lcmljfSByYWRpdXMgLSB0aGUgcmFkaXVzIG9mIHRoZSB2aWNpbml0eVxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBuZWFyOmZ1bmN0aW9uKHgsIHksIHJhZGl1cyl7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLnggLSB4LCAyKSArIE1hdGgucG93KHRoaXMueSAtIHksIDIpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoZGlzdGFuY2UgPD0gcmFkaXVzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjb250YWluczogZnVuY3Rpb24oeCx5KXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCA9PSB4ICYmIHRoaXMueSA9PSB5O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRvU3RyaW5nOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiAnWycgKyB0aGlzLnggKyAnLCcgKyB0aGlzLnkgKyAnXSc7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0UG9pbnRzOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiBbdGhpc107XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Qb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGd1aWQgPSByZXF1aXJlKFwiLi9jb3JlL2d1aWRcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi9jb3JlL2VudlwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIEhhbmRsZXIgPSByZXF1aXJlKFwiLi9IYW5kbGVyXCIpO1xuXG52YXIgU3RvcmFnZSA9IHJlcXVpcmUoXCIuL1N0b3JhZ2VcIik7XG5cbnZhciBQYWludGVyID0gcmVxdWlyZShcIi4vUGFpbnRlclwiKTtcblxudmFyIEFuaW1hdGlvbiA9IHJlcXVpcmUoXCIuL2FuaW1hdGlvbi9BbmltYXRpb25cIik7XG5cbnZhciBIYW5kbGVyUHJveHkgPSByZXF1aXJlKFwiLi9kb20vSGFuZGxlclByb3h5XCIpO1xuXG4vKiFcbiogWlJlbmRlciwgYSBoaWdoIHBlcmZvcm1hbmNlIDJkIGRyYXdpbmcgbGlicmFyeS5cbipcbiogQ29weXJpZ2h0IChjKSAyMDEzLCBCYWlkdSBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIExJQ0VOU0VcbiogaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4qL1xudmFyIHVzZVZNTCA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xudmFyIHBhaW50ZXJDdG9ycyA9IHtcbiAgY2FudmFzOiBQYWludGVyXG59O1xudmFyIGluc3RhbmNlcyA9IHt9OyAvLyBaUmVuZGVy5a6e5L6LbWFw57Si5byVXG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuXG52YXIgdmVyc2lvbiA9ICczLjcuNCc7XG4vKipcbiAqIEluaXRpYWxpemluZyBhIHpyZW5kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLmhlaWdodF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICovXG5cbmZ1bmN0aW9uIGluaXQoZG9tLCBvcHRzKSB7XG4gIHZhciB6ciA9IG5ldyBaUmVuZGVyKGd1aWQoKSwgZG9tLCBvcHRzKTtcbiAgaW5zdGFuY2VzW3pyLmlkXSA9IHpyO1xuICByZXR1cm4genI7XG59XG4vKipcbiAqIERpc3Bvc2UgenJlbmRlciBpbnN0YW5jZVxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICovXG5cblxuZnVuY3Rpb24gZGlzcG9zZSh6cikge1xuICBpZiAoenIpIHtcbiAgICB6ci5kaXNwb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIga2V5IGluIGluc3RhbmNlcykge1xuICAgICAgaWYgKGluc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGluc3RhbmNlc1trZXldLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnN0YW5jZXMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuLyoqXG4gKiBHZXQgenJlbmRlciBpbnN0YW5jZSBieSBpZFxuICogQHBhcmFtIHtzdHJpbmd9IGlkIHpyZW5kZXIgaW5zdGFuY2UgaWRcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZShpZCkge1xuICByZXR1cm4gaW5zdGFuY2VzW2lkXTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJQYWludGVyKG5hbWUsIEN0b3IpIHtcbiAgcGFpbnRlckN0b3JzW25hbWVdID0gQ3Rvcjtcbn1cblxuZnVuY3Rpb24gZGVsSW5zdGFuY2UoaWQpIHtcbiAgZGVsZXRlIGluc3RhbmNlc1tpZF07XG59XG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9aUmVuZGVyXG4gKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9aUmVuZGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICovXG5cblxudmFyIFpSZW5kZXIgPSBmdW5jdGlvbiAoaWQsIGRvbSwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgLyoqXG4gICAqIEB0eXBlIHtIVE1MRG9tRWxlbWVudH1cbiAgICovXG5cbiAgdGhpcy5kb20gPSBkb207XG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuICB0aGlzLmlkID0gaWQ7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpO1xuICB2YXIgcmVuZGVyZXJUeXBlID0gb3B0cy5yZW5kZXJlcjsgLy8gVE9ETyBXZWJHTFxuXG4gIGlmICh1c2VWTUwpIHtcbiAgICBpZiAoIXBhaW50ZXJDdG9ycy52bWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcmVxdWlyZSBcXCd6cmVuZGVyL3ZtbC92bWxcXCcgdG8gc3VwcG9ydCBJRTgnKTtcbiAgICB9XG5cbiAgICByZW5kZXJlclR5cGUgPSAndm1sJztcbiAgfSBlbHNlIGlmICghcmVuZGVyZXJUeXBlIHx8ICFwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXSkge1xuICAgIHJlbmRlcmVyVHlwZSA9ICdjYW52YXMnO1xuICB9XG5cbiAgdmFyIHBhaW50ZXIgPSBuZXcgcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0oZG9tLCBzdG9yYWdlLCBvcHRzKTtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdmFyIGhhbmRlclByb3h5ID0gIWVudi5ub2RlID8gbmV3IEhhbmRsZXJQcm94eShwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKSA6IG51bGw7XG4gIHRoaXMuaGFuZGxlciA9IG5ldyBIYW5kbGVyKHN0b3JhZ2UsIHBhaW50ZXIsIGhhbmRlclByb3h5LCBwYWludGVyLnJvb3QpO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb259XG4gICAqL1xuXG4gIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih7XG4gICAgc3RhZ2U6IHtcbiAgICAgIHVwZGF0ZTogenJVdGlsLmJpbmQodGhpcy5mbHVzaCwgdGhpcylcbiAgICB9XG4gIH0pO1xuICB0aGlzLmFuaW1hdGlvbi5zdGFydCgpO1xuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX25lZWRzUmVmcmVzaDsgLy8g5L+u5pS5IHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UsIOavj+asoeWIoOmZpOWFg+e0oOS5i+WJjeWIoOmZpOWKqOeUu1xuICAvLyBGSVhNRSDmnInngrl1Z2x5XG5cbiAgdmFyIG9sZERlbEZyb21TdG9yYWdlID0gc3RvcmFnZS5kZWxGcm9tU3RvcmFnZTtcbiAgdmFyIG9sZEFkZFRvU3RvcmFnZSA9IHN0b3JhZ2UuYWRkVG9TdG9yYWdlO1xuXG4gIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBvbGREZWxGcm9tU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgICBlbCAmJiBlbC5yZW1vdmVTZWxmRnJvbVpyKHNlbGYpO1xuICB9O1xuXG4gIHN0b3JhZ2UuYWRkVG9TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgb2xkQWRkVG9TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuICAgIGVsLmFkZFNlbGZUb1pyKHNlbGYpO1xuICB9O1xufTtcblxuWlJlbmRlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBaUmVuZGVyLFxuXG4gIC8qKlxuICAgKiDojrflj5blrp7kvovllK/kuIDmoIfor4ZcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0SWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5YWD57SgXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uIChlbCkge1xuICAgIHRoaXMuc3RvcmFnZS5hZGRSb290KGVsKTtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiDliKDpmaTlhYPntKBcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoZWwpO1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoYW5nZSBjb25maWd1cmF0aW9uIG9mIGxheWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6TGV2ZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5jbGVhckNvbG9yPTBdIENsZWFyIGNvbG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIElmIGVuYWJsZSBtb3Rpb24gYmx1clxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddIE1vdGlvbiBibHVyIGZhY3Rvci4gTGFyZ2VyIHZhbHVlIGNhdXNlIGxvbmdlciB0cmFpbGVyXG4gICovXG4gIGNvbmZpZ0xheWVyOiBmdW5jdGlvbiAoekxldmVsLCBjb25maWcpIHtcbiAgICB0aGlzLnBhaW50ZXIuY29uZmlnTGF5ZXIoekxldmVsLCBjb25maWcpO1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGNhbnZhcyBpbW1lZGlhdGVseVxuICAgKi9cbiAgcmVmcmVzaEltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdmFyIHN0YXJ0ID0gbmV3IERhdGUoKTtcbiAgICAvLyBDbGVhciBuZWVkc1JlZnJlc2ggYWhlYWQgdG8gYXZvaWQgc29tZXRoaW5nIHdyb25nIGhhcHBlbnMgaW4gcmVmcmVzaFxuICAgIC8vIE9yIGl0IHdpbGwgY2F1c2UgenJlbmRlciByZWZyZXNoZXMgYWdhaW4gYW5kIGFnYWluLlxuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgIHRoaXMucGFpbnRlci5yZWZyZXNoKCk7XG4gICAgLyoqXG4gICAgICogQXZvaWQgdHJpZ2dlciB6ci5yZWZyZXNoIGluIEVsZW1lbnQjYmVmb3JlVXBkYXRlIGhvb2tcbiAgICAgKi9cblxuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlOyAvLyB2YXIgZW5kID0gbmV3IERhdGUoKTtcbiAgICAvLyB2YXIgbG9nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZycpO1xuICAgIC8vIGlmIChsb2cpIHtcbiAgICAvLyAgICAgbG9nLmlubmVySFRNTCA9IGxvZy5pbm5lckhUTUwgKyAnPGJyPicgKyAoZW5kIC0gc3RhcnQpO1xuICAgIC8vIH1cbiAgfSxcblxuICAvKipcbiAgICogTWFyayBhbmQgcmVwYWludCB0aGUgY2FudmFzIGluIHRoZSBuZXh0IGZyYW1lIG9mIGJyb3dzZXJcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFsbCByZWZyZXNoXG4gICAqL1xuICBmbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2gpIHtcbiAgICAgIHRoaXMucmVmcmVzaEltbWVkaWF0ZWx5KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyKSB7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgZWxlbWVudCB0byBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICovXG4gIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5hZGRIb3Zlcikge1xuICAgICAgdGhpcy5wYWludGVyLmFkZEhvdmVyKGVsLCBzdHlsZSk7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkIGVsZW1lbnQgZnJvbSBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICh0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIpIHtcbiAgICAgIHRoaXMucGFpbnRlci5yZW1vdmVIb3ZlcihlbCk7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGhvdmVyIGVsZW1lbnRzIGluIGhvdmVyIGxheWVyXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5jbGVhckhvdmVyKSB7XG4gICAgICB0aGlzLnBhaW50ZXIuY2xlYXJIb3ZlcigpO1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggaG92ZXIgaW4gbmV4dCBmcmFtZVxuICAgKi9cbiAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGhvdmVyIGltbWVkaWF0ZWx5XG4gICAqL1xuICByZWZyZXNoSG92ZXJJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gZmFsc2U7XG4gICAgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlciAmJiB0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2l6ZSB0aGUgY2FudmFzLlxuICAgKiBTaG91bGQgYmUgaW52b2tlZCB3aGVuIGNvbnRhaW5lciBzaXplIGlzIGNoYW5nZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMucGFpbnRlci5yZXNpemUob3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuICAgIHRoaXMuaGFuZGxlci5yZXNpemUoKTtcbiAgfSxcblxuICAvKipcbiAgICogU3RvcCBhbmQgY2xlYXIgYWxsIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgKi9cbiAgY2xlYXJBbmltYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbi5jbGVhcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY29udGFpbmVyIHdpZHRoXG4gICAqL1xuICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNvbnRhaW5lciBoZWlnaHRcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9ydCB0aGUgY2FudmFzIGFzIEJhc2U2NCBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtiYWNrZ3JvdW5kQ29sb3I9JyNmZmYnXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2U2NCBVUkxcbiAgICovXG4gIC8vIHRvRGF0YVVSTDogZnVuY3Rpb24odHlwZSwgYmFja2dyb3VuZENvbG9yKSB7XG4gIC8vICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFJlbmRlcmVkQ2FudmFzKHtcbiAgLy8gICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAvLyAgICAgfSkudG9EYXRhVVJMKHR5cGUpO1xuICAvLyB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0aW5nIGEgcGF0aCB0byBpbWFnZS5cbiAgICogSXQgaGFzIG11Y2ggYmV0dGVyIHBlcmZvcm1hbmNlIG9mIGRyYXdpbmcgaW1hZ2UgcmF0aGVyIHRoYW4gZHJhd2luZyBhIHZlY3RvciBwYXRoLlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gZVxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgKi9cbiAgcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uIChlLCBkcHIpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludGVyLnBhdGhUb0ltYWdlKGUsIGRwcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IGN1cnNvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgKi9cbiAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgIHRoaXMuaGFuZGxlci5zZXRDdXJzb3JTdHlsZShjdXJzb3JTdHlsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmQgaG92ZXJlZCBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge09iamVjdH0ge3RhcmdldCwgdG9wVGFyZ2V0fVxuICAgKi9cbiAgZmluZEhvdmVyOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZmluZEhvdmVyKHgsIHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCaW5kIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudEhhbmRsZXIgSGFuZGxlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQgb2JqZWN0XG4gICAqL1xuICBvbjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdGhpcy5oYW5kbGVyLm9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogVW5iaW5kIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXZlbnRIYW5kbGVyXSBIYW5kbGVyIGZ1bmN0aW9uXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgIHRoaXMuaGFuZGxlci5vZmYoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGV2ZW50IG1hbnVhbGx5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgIHRoaXMuaGFuZGxlci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgb2JqZWN0cyBhbmQgdGhlIGNhbnZhcy5cbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoKTtcbiAgICB0aGlzLnBhaW50ZXIuY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcG9zZSBzZWxmLlxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uLnN0b3AoKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5zdG9yYWdlLmRpc3Bvc2UoKTtcbiAgICB0aGlzLnBhaW50ZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gICAgdGhpcy5hbmltYXRpb24gPSB0aGlzLnN0b3JhZ2UgPSB0aGlzLnBhaW50ZXIgPSB0aGlzLmhhbmRsZXIgPSBudWxsO1xuICAgIGRlbEluc3RhbmNlKHRoaXMuaWQpO1xuICB9XG59O1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmRpc3Bvc2UgPSBkaXNwb3NlO1xuZXhwb3J0cy5nZXRJbnN0YW5jZSA9IGdldEluc3RhbmNlO1xuZXhwb3J0cy5yZWdpc3RlclBhaW50ZXIgPSByZWdpc3RlclBhaW50ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3pyZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB1dGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG52YXIgdmVjMiA9IHJlcXVpcmUoXCIuL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgRHJhZ2dhYmxlID0gcmVxdWlyZShcIi4vbWl4aW4vRHJhZ2dhYmxlXCIpO1xuXG52YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwiLi9taXhpbi9FdmVudGZ1bFwiKTtcblxuLyoqXG4gKiBIYW5kbGVyXG4gKiBAbW9kdWxlIHpyZW5kZXIvSGFuZGxlclxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiAgICAgICAgIHBpc3NhbmcgKHNoZW55aS45MTRAZ21haWwuY29tKVxuICovXG52YXIgU0lMRU5UID0gJ3NpbGVudCc7XG5cbmZ1bmN0aW9uIG1ha2VFdmVudFBhY2tldChldmVUeXBlLCB0YXJnZXRJbmZvLCBldmVudCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV2ZVR5cGUsXG4gICAgZXZlbnQ6IGV2ZW50LFxuICAgIC8vIHRhcmdldCBjYW4gb25seSBiZSBhbiBlbGVtZW50IHRoYXQgaXMgbm90IHNpbGVudC5cbiAgICB0YXJnZXQ6IHRhcmdldEluZm8udGFyZ2V0LFxuICAgIC8vIHRvcFRhcmdldCBjYW4gYmUgYSBzaWxlbnQgZWxlbWVudC5cbiAgICB0b3BUYXJnZXQ6IHRhcmdldEluZm8udG9wVGFyZ2V0LFxuICAgIGNhbmNlbEJ1YmJsZTogZmFsc2UsXG4gICAgb2Zmc2V0WDogZXZlbnQuenJYLFxuICAgIG9mZnNldFk6IGV2ZW50LnpyWSxcbiAgICBnZXN0dXJlRXZlbnQ6IGV2ZW50Lmdlc3R1cmVFdmVudCxcbiAgICBwaW5jaFg6IGV2ZW50LnBpbmNoWCxcbiAgICBwaW5jaFk6IGV2ZW50LnBpbmNoWSxcbiAgICBwaW5jaFNjYWxlOiBldmVudC5waW5jaFNjYWxlLFxuICAgIHdoZWVsRGVsdGE6IGV2ZW50LnpyRGVsdGEsXG4gICAgenJCeVRvdWNoOiBldmVudC56ckJ5VG91Y2gsXG4gICAgd2hpY2g6IGV2ZW50LndoaWNoXG4gIH07XG59XG5cbmZ1bmN0aW9uIEVtcHR5UHJveHkoKSB7fVxuXG5FbXB0eVByb3h5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBoYW5kbGVyTmFtZXMgPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J107XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9IYW5kbGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2UgU3RvcmFnZSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvUGFpbnRlcn0gcGFpbnRlciBQYWludGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9kb20vSGFuZGxlclByb3h5fSBwcm94eSBIYW5kbGVyUHJveHkgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYWludGVyUm9vdCBwYWludGVyLnJvb3QgKG5vdCBwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKS5cbiAqL1xuXG52YXIgSGFuZGxlciA9IGZ1bmN0aW9uIChzdG9yYWdlLCBwYWludGVyLCBwcm94eSwgcGFpbnRlclJvb3QpIHtcbiAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdGhpcy5wYWludGVyUm9vdCA9IHBhaW50ZXJSb290O1xuICBwcm94eSA9IHByb3h5IHx8IG5ldyBFbXB0eVByb3h5KCk7XG4gIC8qKlxuICAgKiBQcm94eSBvZiBldmVudC4gY2FuIGJlIERvbSwgV2ViR0xTdXJmYWNlLCBldGMuXG4gICAqL1xuXG4gIHRoaXMucHJveHkgPSBwcm94eTsgLy8gQXR0YWNoIGhhbmRsZXJcblxuICBwcm94eS5oYW5kbGVyID0gdGhpcztcbiAgLyoqXG4gICAqIHt0YXJnZXQsIHRvcFRhcmdldCwgeCwgeX1cbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdGhpcy5faG92ZXJlZCA9IHt9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0RhdGV9XG4gICAqL1xuXG4gIHRoaXMuX2xhc3RUb3VjaE1vbWVudDtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuX2xhc3RYO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5fbGFzdFk7XG4gIERyYWdnYWJsZS5jYWxsKHRoaXMpO1xuICB1dGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHByb3h5Lm9uICYmIHByb3h5Lm9uKG5hbWUsIHRoaXNbbmFtZV0sIHRoaXMpO1xuICB9LCB0aGlzKTtcbn07XG5cbkhhbmRsZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFuZGxlcixcbiAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgeCA9IGV2ZW50LnpyWDtcbiAgICB2YXIgeSA9IGV2ZW50LnpyWTtcbiAgICB2YXIgbGFzdEhvdmVyZWQgPSB0aGlzLl9ob3ZlcmVkO1xuICAgIHZhciBsYXN0SG92ZXJlZFRhcmdldCA9IGxhc3RIb3ZlcmVkLnRhcmdldDsgLy8gSWYgbGFzdEhvdmVyZWRUYXJnZXQgaXMgcmVtb3ZlZCBmcm9tIHpyIChkZXRlY3RlZCBieSAnX196cicpIGJ5IHNvbWUgQVBJIGNhbGxcbiAgICAvLyAobGlrZSAnc2V0T3B0aW9uJyBvciAnZGlzcGF0Y2hBY3Rpb24nKSBpbiBldmVudCBoYW5kbGVycywgd2Ugc2hvdWxkIGZpbmRcbiAgICAvLyBsYXN0SG92ZXJlZCBhZ2FpbiBoZXJlLiBPdGhlcndpc2UgJ21vdXNlb3V0JyBjYW4gbm90IGJlIHRyaWdnZXJlZCBub3JtYWxseS5cbiAgICAvLyBTZWUgIzYxOTguXG5cbiAgICBpZiAobGFzdEhvdmVyZWRUYXJnZXQgJiYgIWxhc3RIb3ZlcmVkVGFyZ2V0Ll9fenIpIHtcbiAgICAgIGxhc3RIb3ZlcmVkID0gdGhpcy5maW5kSG92ZXIobGFzdEhvdmVyZWQueCwgbGFzdEhvdmVyZWQueSk7XG4gICAgICBsYXN0SG92ZXJlZFRhcmdldCA9IGxhc3RIb3ZlcmVkLnRhcmdldDtcbiAgICB9XG5cbiAgICB2YXIgaG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5KTtcbiAgICB2YXIgaG92ZXJlZFRhcmdldCA9IGhvdmVyZWQudGFyZ2V0O1xuICAgIHZhciBwcm94eSA9IHRoaXMucHJveHk7XG4gICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihob3ZlcmVkVGFyZ2V0ID8gaG92ZXJlZFRhcmdldC5jdXJzb3IgOiAnZGVmYXVsdCcpOyAvLyBNb3VzZSBvdXQgb24gcHJldmlvdXMgaG92ZXJlZCBlbGVtZW50XG5cbiAgICBpZiAobGFzdEhvdmVyZWRUYXJnZXQgJiYgaG92ZXJlZFRhcmdldCAhPT0gbGFzdEhvdmVyZWRUYXJnZXQpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQobGFzdEhvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTtcbiAgICB9IC8vIE1vdXNlIG1vdmluZyBvbiBvbmUgZWxlbWVudFxuXG5cbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW1vdmUnLCBldmVudCk7IC8vIE1vdXNlIG92ZXIgb24gYSBuZXcgZWxlbWVudFxuXG4gICAgaWYgKGhvdmVyZWRUYXJnZXQgJiYgaG92ZXJlZFRhcmdldCAhPT0gbGFzdEhvdmVyZWRUYXJnZXQpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgJ21vdXNlb3ZlcicsIGV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHRoaXMuX2hvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTsgLy8gVGhlcmUgbWlnaHQgYmUgc29tZSBkb21zIGNyZWF0ZWQgYnkgdXBwZXIgbGF5ZXIgYXBwbGljYXRpb25cbiAgICAvLyBhdCB0aGUgc2FtZSBsZXZlbCBvZiBwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpIChlLmcuLCB0b29sdGlwXG4gICAgLy8gZG9tIGNyZWF0ZWQgYnkgZWNoYXJ0cyksIHdoZXJlICdnbG9iYWxvdXQnIGV2ZW50IHNob3VsZCBub3RcbiAgICAvLyBiZSB0cmlnZ2VyZWQgd2hlbiBtb3VzZSBlbnRlcnMgdGhlc2UgZG9tcy4gKEJ1dCAnbW91c2VvdXQnXG4gICAgLy8gc2hvdWxkIGJlIHRyaWdnZXJlZCBhdCB0aGUgb3JpZ2luYWwgaG92ZXJlZCBlbGVtZW50IGFzIHVzdWFsKS5cblxuICAgIHZhciBlbGVtZW50ID0gZXZlbnQudG9FbGVtZW50IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgdmFyIGlubmVyRG9tO1xuXG4gICAgZG8ge1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIH0gd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPSA5ICYmICEoaW5uZXJEb20gPSBlbGVtZW50ID09PSB0aGlzLnBhaW50ZXJSb290KSk7XG5cbiAgICAhaW5uZXJEb20gJiYgdGhpcy50cmlnZ2VyKCdnbG9iYWxvdXQnLCB7XG4gICAgICBldmVudDogZXZlbnRcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVzaXplXG4gICAqL1xuICByZXNpemU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuX2hvdmVyZWQgPSB7fTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2ggZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnRBcmdzXG4gICAqL1xuICBkaXNwYXRjaDogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcmdzKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB0aGlzW2V2ZW50TmFtZV07XG4gICAgaGFuZGxlciAmJiBoYW5kbGVyLmNhbGwodGhpcywgZXZlbnRBcmdzKTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcG9zZVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJveHkuZGlzcG9zZSgpO1xuICAgIHRoaXMuc3RvcmFnZSA9IHRoaXMucHJveHkgPSB0aGlzLnBhaW50ZXIgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiDorr7nva7pu5jorqTnmoRjdXJzb3Igc3R5bGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JTdHlsZT0nZGVmYXVsdCddIOS+i+WmgiBjcm9zc2hhaXJcbiAgICovXG4gIHNldEN1cnNvclN0eWxlOiBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgIHByb3h5LnNldEN1cnNvciAmJiBwcm94eS5zZXRDdXJzb3IoY3Vyc29yU3R5bGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDkuovku7bliIblj5Hku6PnkIZcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldEluZm8ge3RhcmdldCwgdG9wVGFyZ2V0fSDnm67moIflm77lvaLlhYPntKBcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSDkuovku7blkI3np7BcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tuWvueixoVxuICAgKi9cbiAgZGlzcGF0Y2hUb0VsZW1lbnQ6IGZ1bmN0aW9uICh0YXJnZXRJbmZvLCBldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgdGFyZ2V0SW5mbyA9IHRhcmdldEluZm8gfHwge307XG4gICAgdmFyIGVsID0gdGFyZ2V0SW5mby50YXJnZXQ7XG5cbiAgICBpZiAoZWwgJiYgZWwuc2lsZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50SGFuZGxlciA9ICdvbicgKyBldmVudE5hbWU7XG4gICAgdmFyIGV2ZW50UGFja2V0ID0gbWFrZUV2ZW50UGFja2V0KGV2ZW50TmFtZSwgdGFyZ2V0SW5mbywgZXZlbnQpO1xuXG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBlbFtldmVudEhhbmRsZXJdICYmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUgPSBlbFtldmVudEhhbmRsZXJdLmNhbGwoZWwsIGV2ZW50UGFja2V0KSk7XG4gICAgICBlbC50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgZWwgPSBlbC5wYXJlbnQ7XG5cbiAgICAgIGlmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgIC8vIOWGkuazoeWIsOmhtue6pyB6cmVuZGVyIOWvueixoVxuICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpOyAvLyDliIblj5Hkuovku7bliLDnlKjmiLfoh6rlrprkuYnlsYJcbiAgICAgIC8vIOeUqOaIt+acieWPr+iDveWcqOWFqOWxgCBjbGljayDkuovku7bkuK0gZGlzcG9zZe+8jOaJgOS7pemcgOimgeWIpOaWreS4iyBwYWludGVyIOaYr+WQpuWtmOWcqFxuXG4gICAgICB0aGlzLnBhaW50ZXIgJiYgdGhpcy5wYWludGVyLmVhY2hPdGhlckxheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBpZiAodHlwZW9mIGxheWVyW2V2ZW50SGFuZGxlcl0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGxheWVyW2V2ZW50SGFuZGxlcl0uY2FsbChsYXllciwgZXZlbnRQYWNrZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxheWVyLnRyaWdnZXIpIHtcbiAgICAgICAgICBsYXllci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX0gZXhjbHVkZVxuICAgKiBAcmV0dXJuIHttb2RlbDp6cmVuZGVyL0VsZW1lbnR9XG4gICAqIEBtZXRob2RcbiAgICovXG4gIGZpbmRIb3ZlcjogZnVuY3Rpb24gKHgsIHksIGV4Y2x1ZGUpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpO1xuICAgIHZhciBvdXQgPSB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGhvdmVyQ2hlY2tSZXN1bHQ7XG5cbiAgICAgIGlmIChsaXN0W2ldICE9PSBleGNsdWRlIC8vIGdldERpc3BsYXlMaXN0IG1heSBpbmNsdWRlIGlnbm9yZWQgaXRlbSBpbiBWTUwgbW9kZVxuICAgICAgJiYgIWxpc3RbaV0uaWdub3JlICYmIChob3ZlckNoZWNrUmVzdWx0ID0gaXNIb3ZlcihsaXN0W2ldLCB4LCB5KSkpIHtcbiAgICAgICAgIW91dC50b3BUYXJnZXQgJiYgKG91dC50b3BUYXJnZXQgPSBsaXN0W2ldKTtcblxuICAgICAgICBpZiAoaG92ZXJDaGVja1Jlc3VsdCAhPT0gU0lMRU5UKSB7XG4gICAgICAgICAgb3V0LnRhcmdldCA9IGxpc3RbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG59OyAvLyBDb21tb24gaGFuZGxlcnNcblxudXRpbC5lYWNoKFsnY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2V3aGVlbCcsICdkYmxjbGljaycsICdjb250ZXh0bWVudSddLCBmdW5jdGlvbiAobmFtZSkge1xuICBIYW5kbGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIEZpbmQgaG92ZXIgYWdhaW4gdG8gYXZvaWQgY2xpY2sgZXZlbnQgaXMgZGlzcGF0Y2hlZCBtYW51YWxseS4gT3IgY2xpY2sgaXMgdHJpZ2dlcmVkIHdpdGhvdXQgbW91c2VvdmVyXG4gICAgdmFyIGhvdmVyZWQgPSB0aGlzLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSk7XG4gICAgdmFyIGhvdmVyZWRUYXJnZXQgPSBob3ZlcmVkLnRhcmdldDtcblxuICAgIGlmIChuYW1lID09PSAnbW91c2Vkb3duJykge1xuICAgICAgdGhpcy5fZG93bkVsID0gaG92ZXJlZFRhcmdldDtcbiAgICAgIHRoaXMuX2Rvd25Qb2ludCA9IFtldmVudC56clgsIGV2ZW50LnpyWV07IC8vIEluIGNhc2UgY2xpY2sgdHJpZ2dlcmVkIGJlZm9yZSBtb3VzZXVwXG5cbiAgICAgIHRoaXMuX3VwRWwgPSBob3ZlcmVkVGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ21vc3VldXAnKSB7XG4gICAgICB0aGlzLl91cEVsID0gaG92ZXJlZFRhcmdldDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgIGlmICh0aGlzLl9kb3duRWwgIT09IHRoaXMuX3VwRWwgLy8gT3JpZ2luYWwgY2xpY2sgZXZlbnQgaXMgdHJpZ2dlcmVkIG9uIHRoZSB3aG9sZSBjYW52YXMgZWxlbWVudCxcbiAgICAgIC8vIGluY2x1ZGluZyB0aGUgY2FzZSB0aGF0IGBtb3VzZWRvd25gIC0gYG1vdXNlbW92ZWAgLSBgbW91c2V1cGAsXG4gICAgICAvLyB3aGljaCBzaG91bGQgYmUgZmlsdGVyZWQsIG90aGVyd2lzZSBpdCB3aWxsIGJyaW5nIHRyb3VibGUgdG9cbiAgICAgIC8vIHBhbiBhbmQgem9vbS5cbiAgICAgIHx8ICF0aGlzLl9kb3duUG9pbnQgLy8gQXJiaXRyYXJ5IHZhbHVlXG4gICAgICB8fCB2ZWMyLmRpc3QodGhpcy5fZG93blBvaW50LCBbZXZlbnQuenJYLCBldmVudC56clldKSA+IDQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb3duUG9pbnQgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgbmFtZSwgZXZlbnQpO1xuICB9O1xufSk7XG5cbmZ1bmN0aW9uIGlzSG92ZXIoZGlzcGxheWFibGUsIHgsIHkpIHtcbiAgaWYgKGRpc3BsYXlhYmxlW2Rpc3BsYXlhYmxlLnJlY3RIb3ZlciA/ICdyZWN0Q29udGFpbicgOiAnY29udGFpbiddKHgsIHkpKSB7XG4gICAgdmFyIGVsID0gZGlzcGxheWFibGU7XG4gICAgdmFyIGlzU2lsZW50O1xuXG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICAvLyBJZiBjbGlwcGVkIGJ5IGFuY2VzdG9yLlxuICAgICAgLy8gRklYTUU6IElmIGNsaXBQYXRoIGhhcyBuZWl0aGVyIHN0cm9rZSBub3IgZmlsbCxcbiAgICAgIC8vIGVsLmNsaXBQYXRoLmNvbnRhaW4oeCwgeSkgd2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlLlxuICAgICAgaWYgKGVsLmNsaXBQYXRoICYmICFlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsLnNpbGVudCkge1xuICAgICAgICBpc1NpbGVudCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGVsID0gZWwucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBpc1NpbGVudCA/IFNJTEVOVCA6IHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnV0aWwubWl4aW4oSGFuZGxlciwgRXZlbnRmdWwpO1xudXRpbC5taXhpbihIYW5kbGVyLCBEcmFnZ2FibGUpO1xudmFyIF9kZWZhdWx0ID0gSGFuZGxlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL0hhbmRsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB1dGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4vY29yZS9lbnZcIik7XG5cbnZhciBHcm91cCA9IHJlcXVpcmUoXCIuL2NvbnRhaW5lci9Hcm91cFwiKTtcblxudmFyIHRpbXNvcnQgPSByZXF1aXJlKFwiLi9jb3JlL3RpbXNvcnRcIik7XG5cbi8qKlxuICogU3RvcmFnZeWGheWuueS7k+W6k+aooeWdl1xuICogQG1vZHVsZSB6cmVuZGVyL1N0b3JhZ2VcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogQGF1dGhvciBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZy8pXG4gKi9cbi8vIFVzZSB0aW1zb3J0IGJlY2F1c2UgaW4gbW9zdCBjYXNlIGVsZW1lbnRzIGFyZSBwYXJ0aWFsbHkgc29ydGVkXG4vLyBodHRwczovL2pzZmlkZGxlLm5ldC9waXNzYW5nL2pyNHg3bWRtLzgvXG5mdW5jdGlvbiBzaGFwZUNvbXBhcmVGdW5jKGEsIGIpIHtcbiAgaWYgKGEuemxldmVsID09PSBiLnpsZXZlbCkge1xuICAgIGlmIChhLnogPT09IGIueikge1xuICAgICAgLy8gaWYgKGEuejIgPT09IGIuejIpIHtcbiAgICAgIC8vICAgICAvLyBGSVhNRSBTbG93IGhhcyByZW5kZXJpZHggY29tcGFyZVxuICAgICAgLy8gICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjA4ODM0MjEvc29ydGluZy1pbi1qYXZhc2NyaXB0LXNob3VsZC1ldmVyeS1jb21wYXJlLWZ1bmN0aW9uLWhhdmUtYS1yZXR1cm4tMC1zdGF0ZW1lbnRcbiAgICAgIC8vICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdjgvdjgvYmxvYi80N2NjZTU0NGEzMWVkNTU3N2ZmZTI5NjNmNjdhY2I0MTQ0ZWUwMjMyL3NyYy9qcy9hcnJheS5qcyNMMTAxMlxuICAgICAgLy8gICAgIHJldHVybiBhLl9fcmVuZGVyaWR4IC0gYi5fX3JlbmRlcmlkeDtcbiAgICAgIC8vIH1cbiAgICAgIHJldHVybiBhLnoyIC0gYi56MjtcbiAgICB9XG5cbiAgICByZXR1cm4gYS56IC0gYi56O1xuICB9XG5cbiAgcmV0dXJuIGEuemxldmVsIC0gYi56bGV2ZWw7XG59XG4vKipcbiAqIOWGheWuueS7k+W6kyAoTSlcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9TdG9yYWdlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBTdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgdGhpcy5fcm9vdHMgPSBbXTtcbiAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcbiAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xufTtcblxuU3RvcmFnZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTdG9yYWdlLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICpcbiAgICovXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9yb290c1tpXS50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDov5Tlm57miYDmnInlm77lvaLnmoTnu5jliLbpmJ/liJdcbiAgICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlPWZhbHNlXSDmmK/lkKblnKjov5Tlm57liY3mm7TmlrDor6XmlbDnu4RcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUlnbm9yZT1mYWxzZV0g5piv5ZCm5YyF5ZCrIGlnbm9yZSDnmoTmlbDnu4QsIOWcqCB1cGRhdGUg5Li6IHRydWUg55qE5pe25YCZ5pyJ5pWIXG4gICAqXG4gICAqIOivpuingXtAbGluayBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5TGlzdH1cbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGU+fVxuICAgKi9cbiAgZ2V0RGlzcGxheUxpc3Q6IGZ1bmN0aW9uICh1cGRhdGUsIGluY2x1ZGVJZ25vcmUpIHtcbiAgICBpbmNsdWRlSWdub3JlID0gaW5jbHVkZUlnbm9yZSB8fCBmYWxzZTtcblxuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlRGlzcGxheUxpc3QoaW5jbHVkZUlnbm9yZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXlMaXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiDmm7TmlrDlm77lvaLnmoTnu5jliLbpmJ/liJfjgIJcbiAgICog5q+P5qyh57uY5Yi25YmN6YO95Lya6LCD55So77yM6K+l5pa55rOV5Lya5YWI5rex5bqm5LyY5YWI6YGN5Y6G5pW05Liq5qCR77yM5pu05paw5omA5pyJR3JvdXDlkoxTaGFwZeeahOWPmOaNouW5tuS4lOaKiuaJgOacieWPr+ingeeahFNoYXBl5L+d5a2Y5Yiw5pWw57uE5Lit77yMXG4gICAqIOacgOWQjuagueaNrue7mOWItueahOS8mOWFiOe6p++8iHpsZXZlbCA+IHogPiDmj5LlhaXpobrluo/vvInmjpLluo/lvpfliLDnu5jliLbpmJ/liJdcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUlnbm9yZT1mYWxzZV0g5piv5ZCm5YyF5ZCrIGlnbm9yZSDnmoTmlbDnu4RcbiAgICovXG4gIHVwZGF0ZURpc3BsYXlMaXN0OiBmdW5jdGlvbiAoaW5jbHVkZUlnbm9yZSkge1xuICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICB2YXIgcm9vdHMgPSB0aGlzLl9yb290cztcbiAgICB2YXIgZGlzcGxheUxpc3QgPSB0aGlzLl9kaXNwbGF5TGlzdDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb290cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5fdXBkYXRlQW5kQWRkRGlzcGxheWFibGUocm9vdHNbaV0sIG51bGwsIGluY2x1ZGVJZ25vcmUpO1xuICAgIH1cblxuICAgIGRpc3BsYXlMaXN0Lmxlbmd0aCA9IHRoaXMuX2Rpc3BsYXlMaXN0TGVuOyAvLyBmb3IgKHZhciBpID0gMCwgbGVuID0gZGlzcGxheUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyAgICAgZGlzcGxheUxpc3RbaV0uX19yZW5kZXJpZHggPSBpO1xuICAgIC8vIH1cbiAgICAvLyBkaXNwbGF5TGlzdC5zb3J0KHNoYXBlQ29tcGFyZUZ1bmMpO1xuXG4gICAgZW52LmNhbnZhc1N1cHBvcnRlZCAmJiB0aW1zb3J0KGRpc3BsYXlMaXN0LCBzaGFwZUNvbXBhcmVGdW5jKTtcbiAgfSxcbiAgX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlOiBmdW5jdGlvbiAoZWwsIGNsaXBQYXRocywgaW5jbHVkZUlnbm9yZSkge1xuICAgIGlmIChlbC5pZ25vcmUgJiYgIWluY2x1ZGVJZ25vcmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbC5iZWZvcmVVcGRhdGUoKTtcblxuICAgIGlmIChlbC5fX2RpcnR5KSB7XG4gICAgICBlbC51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBlbC5hZnRlclVwZGF0ZSgpO1xuICAgIHZhciB1c2VyU2V0Q2xpcFBhdGggPSBlbC5jbGlwUGF0aDtcblxuICAgIGlmICh1c2VyU2V0Q2xpcFBhdGgpIHtcbiAgICAgIC8vIEZJWE1FIOaViOeOh+W9seWTjVxuICAgICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICBjbGlwUGF0aHMgPSBjbGlwUGF0aHMuc2xpY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaXBQYXRocyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudENsaXBQYXRoID0gdXNlclNldENsaXBQYXRoO1xuICAgICAgdmFyIHBhcmVudENsaXBQYXRoID0gZWw7IC8vIFJlY3Vyc2l2ZWx5IGFkZCBjbGlwIHBhdGhcblxuICAgICAgd2hpbGUgKGN1cnJlbnRDbGlwUGF0aCkge1xuICAgICAgICAvLyBjbGlwUGF0aCDnmoTlj5jmjaLmmK/ln7rkuo7kvb/nlKjov5nkuKogY2xpcFBhdGgg55qE5YWD57SgXG4gICAgICAgIGN1cnJlbnRDbGlwUGF0aC5wYXJlbnQgPSBwYXJlbnRDbGlwUGF0aDtcbiAgICAgICAgY3VycmVudENsaXBQYXRoLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICBjbGlwUGF0aHMucHVzaChjdXJyZW50Q2xpcFBhdGgpO1xuICAgICAgICBwYXJlbnRDbGlwUGF0aCA9IGN1cnJlbnRDbGlwUGF0aDtcbiAgICAgICAgY3VycmVudENsaXBQYXRoID0gY3VycmVudENsaXBQYXRoLmNsaXBQYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbC5pc0dyb3VwKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5fY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07IC8vIEZvcmNlIHRvIG1hcmsgYXMgZGlydHkgaWYgZ3JvdXAgaXMgZGlydHlcbiAgICAgICAgLy8gRklYTUUgX19kaXJ0eVBhdGggP1xuXG4gICAgICAgIGlmIChlbC5fX2RpcnR5KSB7XG4gICAgICAgICAgY2hpbGQuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShjaGlsZCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKTtcbiAgICAgIH0gLy8gTWFyayBncm91cCBjbGVhbiBoZXJlXG5cblxuICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5fX2NsaXBQYXRocyA9IGNsaXBQYXRocztcbiAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0W3RoaXMuX2Rpc3BsYXlMaXN0TGVuKytdID0gZWw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKeWIsOagueiKgueCuVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBhZGRSb290OiBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwuX19zdG9yYWdlID09PSB0aGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgIGVsLmFkZENoaWxkcmVuVG9TdG9yYWdlKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuYWRkVG9TdG9yYWdlKGVsKTtcblxuICAgIHRoaXMuX3Jvb3RzLnB1c2goZWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDliKDpmaTmjIflrprnmoTlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKVxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2VsXSDlpoLmnpzkuLrnqbrmuIXnqbrmlbTkuKpTdG9yYWdlXG4gICAqL1xuICBkZWxSb290OiBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwgPT0gbnVsbCkge1xuICAgICAgLy8g5LiN5oyH5a6aZWzmuIXnqbpcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290c1tpXTtcblxuICAgICAgICBpZiAocm9vdCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgcm9vdC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Jvb3RzID0gW107XG4gICAgICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmRlbFJvb3QoZWxbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9yb290cywgZWwpO1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICB0aGlzLmRlbEZyb21TdG9yYWdlKGVsKTtcblxuICAgICAgdGhpcy5fcm9vdHMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGVsLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2UodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBhZGRUb1N0b3JhZ2U6IGZ1bmN0aW9uIChlbCkge1xuICAgIGVsLl9fc3RvcmFnZSA9IHRoaXM7XG4gICAgZWwuZGlydHkoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkZWxGcm9tU3RvcmFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5fX3N0b3JhZ2UgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmuIXnqbrlubbkuJTph4rmlL5TdG9yYWdlXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVuZGVyTGlzdCA9IHRoaXMuX3Jvb3RzID0gbnVsbDtcbiAgfSxcbiAgZGlzcGxheWFibGVTb3J0RnVuYzogc2hhcGVDb21wYXJlRnVuY1xufTtcbnZhciBfZGVmYXVsdCA9IFN0b3JhZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9TdG9yYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbXppY2NhcmQvbm9kZS10aW1zb3J0XG52YXIgREVGQVVMVF9NSU5fTUVSR0UgPSAzMjtcbnZhciBERUZBVUxUX01JTl9HQUxMT1BJTkcgPSA3O1xudmFyIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIID0gMjU2O1xuXG5mdW5jdGlvbiBtaW5SdW5MZW5ndGgobikge1xuICB2YXIgciA9IDA7XG5cbiAgd2hpbGUgKG4gPj0gREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICByIHw9IG4gJiAxO1xuICAgIG4gPj49IDE7XG4gIH1cblxuICByZXR1cm4gbiArIHI7XG59XG5cbmZ1bmN0aW9uIG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSkge1xuICB2YXIgcnVuSGkgPSBsbyArIDE7XG5cbiAgaWYgKHJ1bkhpID09PSBoaSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgaWYgKGNvbXBhcmUoYXJyYXlbcnVuSGkrK10sIGFycmF5W2xvXSkgPCAwKSB7XG4gICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pIDwgMCkge1xuICAgICAgcnVuSGkrKztcbiAgICB9XG5cbiAgICByZXZlcnNlUnVuKGFycmF5LCBsbywgcnVuSGkpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA+PSAwKSB7XG4gICAgICBydW5IaSsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydW5IaSAtIGxvO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlUnVuKGFycmF5LCBsbywgaGkpIHtcbiAgaGktLTtcblxuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciB0ID0gYXJyYXlbbG9dO1xuICAgIGFycmF5W2xvKytdID0gYXJyYXlbaGldO1xuICAgIGFycmF5W2hpLS1dID0gdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIHN0YXJ0LCBjb21wYXJlKSB7XG4gIGlmIChzdGFydCA9PT0gbG8pIHtcbiAgICBzdGFydCsrO1xuICB9XG5cbiAgZm9yICg7IHN0YXJ0IDwgaGk7IHN0YXJ0KyspIHtcbiAgICB2YXIgcGl2b3QgPSBhcnJheVtzdGFydF07XG4gICAgdmFyIGxlZnQgPSBsbztcbiAgICB2YXIgcmlnaHQgPSBzdGFydDtcbiAgICB2YXIgbWlkO1xuXG4gICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgbWlkID0gbGVmdCArIHJpZ2h0ID4+PiAxO1xuXG4gICAgICBpZiAoY29tcGFyZShwaXZvdCwgYXJyYXlbbWlkXSkgPCAwKSB7XG4gICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG4gPSBzdGFydCAtIGxlZnQ7XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgYXJyYXlbbGVmdCArIDNdID0gYXJyYXlbbGVmdCArIDJdO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIGFycmF5W2xlZnQgKyAyXSA9IGFycmF5W2xlZnQgKyAxXTtcblxuICAgICAgY2FzZSAxOlxuICAgICAgICBhcnJheVtsZWZ0ICsgMV0gPSBhcnJheVtsZWZ0XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgIGFycmF5W2xlZnQgKyBuXSA9IGFycmF5W2xlZnQgKyBuIC0gMV07XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhcnJheVtsZWZ0XSA9IHBpdm90O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdhbGxvcExlZnQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgdmFyIG1heE9mZnNldCA9IDA7XG4gIHZhciBvZmZzZXQgPSAxO1xuXG4gIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA+IDApIHtcbiAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgfVxuXG4gICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgIG9mZnNldCArPSBoaW50O1xuICB9IGVsc2Uge1xuICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8PSAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gIH1cblxuICBsYXN0T2Zmc2V0Kys7XG5cbiAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPiAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IG07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gZ2FsbG9wUmlnaHQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgdmFyIG1heE9mZnNldCA9IDA7XG4gIHZhciBvZmZzZXQgPSAxO1xuXG4gIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA8IDApIHtcbiAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPCAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gIH0gZWxzZSB7XG4gICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPj0gMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICB9XG5cbiAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgb2Zmc2V0ICs9IGhpbnQ7XG4gIH1cblxuICBsYXN0T2Zmc2V0Kys7XG5cbiAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPCAwKSB7XG4gICAgICBvZmZzZXQgPSBtO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gVGltU29ydChhcnJheSwgY29tcGFyZSkge1xuICB2YXIgbWluR2FsbG9wID0gREVGQVVMVF9NSU5fR0FMTE9QSU5HO1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHRtcFN0b3JhZ2VMZW5ndGggPSBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSDtcbiAgdmFyIHN0YWNrTGVuZ3RoID0gMDtcbiAgdmFyIHJ1blN0YXJ0O1xuICB2YXIgcnVuTGVuZ3RoO1xuICB2YXIgc3RhY2tTaXplID0gMDtcbiAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPCAyICogREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEgpIHtcbiAgICB0bXBTdG9yYWdlTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuICB9XG5cbiAgdmFyIHRtcCA9IFtdO1xuICBzdGFja0xlbmd0aCA9IGxlbmd0aCA8IDEyMCA/IDUgOiBsZW5ndGggPCAxNTQyID8gMTAgOiBsZW5ndGggPCAxMTkxNTEgPyAxOSA6IDQwO1xuICBydW5TdGFydCA9IFtdO1xuICBydW5MZW5ndGggPSBbXTtcblxuICBmdW5jdGlvbiBwdXNoUnVuKF9ydW5TdGFydCwgX3J1bkxlbmd0aCkge1xuICAgIHJ1blN0YXJ0W3N0YWNrU2l6ZV0gPSBfcnVuU3RhcnQ7XG4gICAgcnVuTGVuZ3RoW3N0YWNrU2l6ZV0gPSBfcnVuTGVuZ3RoO1xuICAgIHN0YWNrU2l6ZSArPSAxO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VSdW5zKCkge1xuICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgIGlmIChuID49IDEgJiYgcnVuTGVuZ3RoW24gLSAxXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiArIDFdIHx8IG4gPj0gMiAmJiBydW5MZW5ndGhbbiAtIDJdIDw9IHJ1bkxlbmd0aFtuXSArIHJ1bkxlbmd0aFtuIC0gMV0pIHtcbiAgICAgICAgaWYgKHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJ1bkxlbmd0aFtuXSA+IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG1lcmdlQXQobik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yY2VNZXJnZVJ1bnMoKSB7XG4gICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgIHZhciBuID0gc3RhY2tTaXplIC0gMjtcblxuICAgICAgaWYgKG4gPiAwICYmIHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgIG4tLTtcbiAgICAgIH1cblxuICAgICAgbWVyZ2VBdChuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUF0KGkpIHtcbiAgICB2YXIgc3RhcnQxID0gcnVuU3RhcnRbaV07XG4gICAgdmFyIGxlbmd0aDEgPSBydW5MZW5ndGhbaV07XG4gICAgdmFyIHN0YXJ0MiA9IHJ1blN0YXJ0W2kgKyAxXTtcbiAgICB2YXIgbGVuZ3RoMiA9IHJ1bkxlbmd0aFtpICsgMV07XG4gICAgcnVuTGVuZ3RoW2ldID0gbGVuZ3RoMSArIGxlbmd0aDI7XG5cbiAgICBpZiAoaSA9PT0gc3RhY2tTaXplIC0gMykge1xuICAgICAgcnVuU3RhcnRbaSArIDFdID0gcnVuU3RhcnRbaSArIDJdO1xuICAgICAgcnVuTGVuZ3RoW2kgKyAxXSA9IHJ1bkxlbmd0aFtpICsgMl07XG4gICAgfVxuXG4gICAgc3RhY2tTaXplLS07XG4gICAgdmFyIGsgPSBnYWxsb3BSaWdodChhcnJheVtzdGFydDJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcbiAgICBzdGFydDEgKz0gaztcbiAgICBsZW5ndGgxIC09IGs7XG5cbiAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxlbmd0aDIgPSBnYWxsb3BMZWZ0KGFycmF5W3N0YXJ0MSArIGxlbmd0aDEgLSAxXSwgYXJyYXksIHN0YXJ0MiwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMSA8PSBsZW5ndGgyKSB7XG4gICAgICBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDEgKyBpXTtcbiAgICB9XG5cbiAgICB2YXIgY3Vyc29yMSA9IDA7XG4gICAgdmFyIGN1cnNvcjIgPSBzdGFydDI7XG4gICAgdmFyIGRlc3QgPSBzdGFydDE7XG4gICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICB9XG5cbiAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX21pbkdhbGxvcCA9IG1pbkdhbGxvcDtcbiAgICB2YXIgY291bnQxLCBjb3VudDIsIGV4aXQ7XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgY291bnQxID0gMDtcbiAgICAgIGNvdW50MiA9IDA7XG4gICAgICBleGl0ID0gZmFsc2U7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbY3Vyc29yMl0sIHRtcFtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG4gICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgY291bnQxID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcbiAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICBjb3VudDIgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkbyB7XG4gICAgICAgIGNvdW50MSA9IGdhbGxvcFJpZ2h0KGFycmF5W2N1cnNvcjJdLCB0bXAsIGN1cnNvcjEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQxOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVzdCArPSBjb3VudDE7XG4gICAgICAgICAgY3Vyc29yMSArPSBjb3VudDE7XG4gICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG5cbiAgICAgICAgICBpZiAobGVuZ3RoMSA8PSAxKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvdW50MiA9IGdhbGxvcExlZnQodG1wW2N1cnNvcjFdLCBhcnJheSwgY3Vyc29yMiwgbGVuZ3RoMiwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc3QgKz0gY291bnQyO1xuICAgICAgICAgIGN1cnNvcjIgKz0gY291bnQyO1xuICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIF9taW5HYWxsb3AtLTtcbiAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICB9XG5cbiAgICAgIF9taW5HYWxsb3AgKz0gMjtcbiAgICB9XG5cbiAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuICAgIG1pbkdhbGxvcCA8IDEgJiYgKG1pbkdhbGxvcCA9IDEpO1xuXG4gICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgfVxuXG4gICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgfSBlbHNlIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUxvdyBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VIaWdoKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQyICsgaV07XG4gICAgfVxuXG4gICAgdmFyIGN1cnNvcjEgPSBzdGFydDEgKyBsZW5ndGgxIC0gMTtcbiAgICB2YXIgY3Vyc29yMiA9IGxlbmd0aDIgLSAxO1xuICAgIHZhciBkZXN0ID0gc3RhcnQyICsgbGVuZ3RoMiAtIDE7XG4gICAgdmFyIGN1c3RvbUN1cnNvciA9IDA7XG4gICAgdmFyIGN1c3RvbURlc3QgPSAwO1xuICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIGNvdW50MSA9IDA7XG4gICAgICB2YXIgY291bnQyID0gMDtcbiAgICAgIHZhciBleGl0ID0gZmFsc2U7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNvbXBhcmUodG1wW2N1cnNvcjJdLCBhcnJheVtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG4gICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgY291bnQyID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcbiAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICBjb3VudDEgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkbyB7XG4gICAgICAgIGNvdW50MSA9IGxlbmd0aDEgLSBnYWxsb3BSaWdodCh0bXBbY3Vyc29yMl0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIGxlbmd0aDEgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgZGVzdCAtPSBjb3VudDE7XG4gICAgICAgICAgY3Vyc29yMSAtPSBjb3VudDE7XG4gICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG4gICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgZm9yIChpID0gY291bnQxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb3VudDIgPSBsZW5ndGgyIC0gZ2FsbG9wTGVmdChhcnJheVtjdXJzb3IxXSwgdG1wLCAwLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgIGRlc3QgLT0gY291bnQyO1xuICAgICAgICAgIGN1cnNvcjIgLT0gY291bnQyO1xuICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IyICsgMTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gdG1wW2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW5ndGgyIDw9IDEpIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChfbWluR2FsbG9wIDwgMCkge1xuICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgIH1cblxuICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgIH1cblxuICAgIG1pbkdhbGxvcCA9IF9taW5HYWxsb3A7XG5cbiAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgbWluR2FsbG9wID0gMTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgfSBlbHNlIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUhpZ2ggcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5tZXJnZVJ1bnMgPSBtZXJnZVJ1bnM7XG4gIHRoaXMuZm9yY2VNZXJnZVJ1bnMgPSBmb3JjZU1lcmdlUnVucztcbiAgdGhpcy5wdXNoUnVuID0gcHVzaFJ1bjtcbn1cblxuZnVuY3Rpb24gc29ydChhcnJheSwgY29tcGFyZSwgbG8sIGhpKSB7XG4gIGlmICghbG8pIHtcbiAgICBsbyA9IDA7XG4gIH1cblxuICBpZiAoIWhpKSB7XG4gICAgaGkgPSBhcnJheS5sZW5ndGg7XG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gaGkgLSBsbztcblxuICBpZiAocmVtYWluaW5nIDwgMikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBydW5MZW5ndGggPSAwO1xuXG4gIGlmIChyZW1haW5pbmcgPCBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG4gICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRzID0gbmV3IFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpO1xuICB2YXIgbWluUnVuID0gbWluUnVuTGVuZ3RoKHJlbWFpbmluZyk7XG5cbiAgZG8ge1xuICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG5cbiAgICBpZiAocnVuTGVuZ3RoIDwgbWluUnVuKSB7XG4gICAgICB2YXIgZm9yY2UgPSByZW1haW5pbmc7XG5cbiAgICAgIGlmIChmb3JjZSA+IG1pblJ1bikge1xuICAgICAgICBmb3JjZSA9IG1pblJ1bjtcbiAgICAgIH1cblxuICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGxvICsgZm9yY2UsIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgIHJ1bkxlbmd0aCA9IGZvcmNlO1xuICAgIH1cblxuICAgIHRzLnB1c2hSdW4obG8sIHJ1bkxlbmd0aCk7XG4gICAgdHMubWVyZ2VSdW5zKCk7XG4gICAgcmVtYWluaW5nIC09IHJ1bkxlbmd0aDtcbiAgICBsbyArPSBydW5MZW5ndGg7XG4gIH0gd2hpbGUgKHJlbWFpbmluZyAhPT0gMCk7XG5cbiAgdHMuZm9yY2VNZXJnZVJ1bnMoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IF9jb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBsb2cgPSByZXF1aXJlKFwiLi9jb3JlL2xvZ1wiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgdGltc29ydCA9IHJlcXVpcmUoXCIuL2NvcmUvdGltc29ydFwiKTtcblxudmFyIExheWVyID0gcmVxdWlyZShcIi4vTGF5ZXJcIik7XG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKFwiLi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpO1xuXG52YXIgSW1hZ2UgPSByZXF1aXJlKFwiLi9ncmFwaGljL0ltYWdlXCIpO1xuXG4vKipcbiAqIERlZmF1bHQgY2FudmFzIHBhaW50ZXJcbiAqIEBtb2R1bGUgenJlbmRlci9QYWludGVyXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBQRU5ESUdOXG4vLyBMYXllciBleGNlZWRzIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgbWF5IGhhdmUgc29tZSBwcm9ibGVtIHdoZW4gZmx1c2ggZGlyZWN0bHkgc2Vjb25kIHRpbWUuXG4vL1xuLy8gTWF4aW11bSBwcm9ncmVzc2l2ZSBsYXllci4gV2hlbiBleGNlZWRpbmcgdGhpcyBudW1iZXIuIEFsbCBlbGVtZW50cyB3aWxsIGJlIGRyYXdlZCBpbiB0aGUgbGFzdCBsYXllci5cbnZhciBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSID0gNTtcblxuZnVuY3Rpb24gcGFyc2VJbnQxMCh2YWwpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0xheWVyVmFsaWQobGF5ZXIpIHtcbiAgaWYgKCFsYXllcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBsYXllci5yZXNpemUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGxheWVyLnJlZnJlc2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcHJlUHJvY2Vzc0xheWVyKGxheWVyKSB7XG4gIGxheWVyLl9fdW51c2VkQ291bnQrKztcbn1cblxuZnVuY3Rpb24gcG9zdFByb2Nlc3NMYXllcihsYXllcikge1xuICBpZiAobGF5ZXIuX191bnVzZWRDb3VudCA9PSAxKSB7XG4gICAgbGF5ZXIuY2xlYXIoKTtcbiAgfVxufVxuXG52YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG52YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuXG5mdW5jdGlvbiBpc0Rpc3BsYXlhYmxlQ3VsbGVkKGVsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHRtcFJlY3QuY29weShlbC5nZXRCb3VuZGluZ1JlY3QoKSk7XG5cbiAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcbiAgfVxuXG4gIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gIHZpZXdSZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgcmV0dXJuICF0bXBSZWN0LmludGVyc2VjdCh2aWV3UmVjdCk7XG59XG5cbmZ1bmN0aW9uIGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgcHJldkNsaXBQYXRocykge1xuICBpZiAoY2xpcFBhdGhzID09IHByZXZDbGlwUGF0aHMpIHtcbiAgICAvLyBDYW4gYm90aCBiZSBudWxsIG9yIHVuZGVmaW5lZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghY2xpcFBhdGhzIHx8ICFwcmV2Q2xpcFBhdGhzIHx8IGNsaXBQYXRocy5sZW5ndGggIT09IHByZXZDbGlwUGF0aHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgY2xpcFBhdGguc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGNsaXBQYXRoLmJ1aWxkUGF0aChjdHgsIGNsaXBQYXRoLnNoYXBlKTtcbiAgICBjdHguY2xpcCgpOyAvLyBUcmFuc2Zvcm0gYmFja1xuXG4gICAgY2xpcFBhdGgucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3Qod2lkdGgsIGhlaWdodCkge1xuICB2YXIgZG9tUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvLyBkb21Sb290Lm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8g6YG/5YWN6aG16Z2i6YCJ5Lit55qE5bC05bCsXG5cbiAgZG9tUm9vdC5zdHlsZS5jc3NUZXh0ID0gWydwb3NpdGlvbjpyZWxhdGl2ZScsICdvdmVyZmxvdzpoaWRkZW4nLCAnd2lkdGg6JyArIHdpZHRoICsgJ3B4JywgJ2hlaWdodDonICsgaGVpZ2h0ICsgJ3B4JywgJ3BhZGRpbmc6MCcsICdtYXJnaW46MCcsICdib3JkZXItd2lkdGg6MCddLmpvaW4oJzsnKSArICc7JztcbiAgcmV0dXJuIGRvbVJvb3Q7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9QYWludGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJvb3Qg57uY5Zu+5a655ZmoXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cblxuXG52YXIgUGFpbnRlciA9IGZ1bmN0aW9uIChyb290LCBzdG9yYWdlLCBvcHRzKSB7XG4gIHRoaXMudHlwZSA9ICdjYW52YXMnOyAvLyBJbiBub2RlIGVudmlyb25tZW50IHVzaW5nIG5vZGUtY2FudmFzXG5cbiAgdmFyIHNpbmdsZUNhbnZhcyA9ICFyb290Lm5vZGVOYW1lIC8vIEluIG5vZGUgP1xuICB8fCByb290Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnO1xuICB0aGlzLl9vcHRzID0gb3B0cyA9IHV0aWwuZXh0ZW5kKHt9LCBvcHRzIHx8IHt9KTtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuZHByID0gb3B0cy5kZXZpY2VQaXhlbFJhdGlvIHx8IGRldmljZVBpeGVsUmF0aW87XG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fc2luZ2xlQ2FudmFzID0gc2luZ2xlQ2FudmFzO1xuICAvKipcbiAgICog57uY5Zu+5a655ZmoXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICovXG5cbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdmFyIHJvb3RTdHlsZSA9IHJvb3Quc3R5bGU7XG5cbiAgaWYgKHJvb3RTdHlsZSkge1xuICAgIHJvb3RTdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAndHJhbnNwYXJlbnQnO1xuICAgIHJvb3RTdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID0gcm9vdFN0eWxlWyd1c2VyLXNlbGVjdCddID0gcm9vdFN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcbiAgICByb290LmlubmVySFRNTCA9ICcnO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX1cbiAgICovXG5cblxuICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3QgPSBbXTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnpyZW5kZXIvTGF5ZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzID0ge307XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdD59XG4gICAqIEB0eXBlIHtwcml2YXRlfVxuICAgKi9cblxuICB0aGlzLl9sYXllckNvbmZpZyA9IHt9O1xuXG4gIGlmICghc2luZ2xlQ2FudmFzKSB7XG4gICAgdGhpcy5fd2lkdGggPSB0aGlzLl9nZXRTaXplKDApO1xuICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290ID0gY3JlYXRlUm9vdCh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICByb290LmFwcGVuZENoaWxkKGRvbVJvb3QpO1xuICB9IGVsc2Uge1xuICAgIGlmIChvcHRzLndpZHRoICE9IG51bGwpIHtcbiAgICAgIHJvb3Qud2lkdGggPSBvcHRzLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICByb290LmhlaWdodCA9IG9wdHMuaGVpZ2h0O1xuICAgIH0gLy8gVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0IGRpcmVjdGx5XG5cblxuICAgIHZhciB3aWR0aCA9IHJvb3Qud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0OyAvLyBDcmVhdGUgbGF5ZXIgaWYgb25seSBvbmUgZ2l2ZW4gY2FudmFzXG4gICAgLy8gRGV2aWNlIHBpeGVsIHJhdGlvIGlzIGZpeGVkIHRvIDEgYmVjYXVzZSBnaXZlbiBjYW52YXMgaGFzIGl0cyBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuXG4gICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290LCB0aGlzLCAxKTtcbiAgICBtYWluTGF5ZXIuaW5pdENvbnRleHQoKTsgLy8gRklYTUUgVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgLy8gbWFpbkxheWVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGxheWVyc1swXSA9IG1haW5MYXllcjtcbiAgICB6bGV2ZWxMaXN0LnB1c2goMCk7XG4gICAgdGhpcy5fZG9tUm9vdCA9IHJvb3Q7XG4gIH0gLy8gTGF5ZXJzIGZvciBwcm9ncmVzc2l2ZSByZW5kZXJpbmdcblxuXG4gIHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzID0gW107XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2hvdmVybGF5ZXI7XG4gIHRoaXMuX2hvdmVyRWxlbWVudHMgPSBbXTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGFpbnRlcixcbiAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnY2FudmFzJztcbiAgfSxcblxuICAvKipcbiAgICogSWYgcGFpbnRlciB1c2UgYSBzaW5nbGUgY2FudmFzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1NpbmdsZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zaW5nbGVDYW52YXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvbVJvb3Q7XG4gIH0sXG4gIGdldFZpZXdwb3J0Um9vdE9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aWV3cG9ydFJvb3QgPSB0aGlzLmdldFZpZXdwb3J0Um9vdCgpO1xuXG4gICAgaWYgKHZpZXdwb3J0Um9vdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0TGVmdDogdmlld3BvcnRSb290Lm9mZnNldExlZnQgfHwgMCxcbiAgICAgICAgb2Zmc2V0VG9wOiB2aWV3cG9ydFJvb3Qub2Zmc2V0VG9wIHx8IDBcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDliLfmlrBcbiAgICogQHBhcmFtIHtib29sZWFufSBbcGFpbnRBbGw9ZmFsc2VdIOW8uuWItue7mOWItuaJgOaciWRpc3BsYXlhYmxlXG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiAocGFpbnRBbGwpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG5cbiAgICB0aGlzLl9wYWludExpc3QobGlzdCwgcGFpbnRBbGwpOyAvLyBQYWludCBjdXN0dW0gbGF5ZXJzXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuXG4gICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fICYmIGxheWVyLnJlZnJlc2gpIHtcbiAgICAgICAgbGF5ZXIucmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG5cbiAgICBpZiAodGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zdGFydFByb2dlc3NpdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkSG92ZXI6IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSkge1xuICAgIGlmIChlbC5fX2hvdmVyTWlyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsTWlycm9yID0gbmV3IGVsLmNvbnN0cnVjdG9yKHtcbiAgICAgIHN0eWxlOiBlbC5zdHlsZSxcbiAgICAgIHNoYXBlOiBlbC5zaGFwZVxuICAgIH0pO1xuICAgIGVsTWlycm9yLl9fZnJvbSA9IGVsO1xuICAgIGVsLl9faG92ZXJNaXIgPSBlbE1pcnJvcjtcbiAgICBlbE1pcnJvci5zZXRTdHlsZShob3ZlclN0eWxlKTtcblxuICAgIHRoaXMuX2hvdmVyRWxlbWVudHMucHVzaChlbE1pcnJvcik7XG4gIH0sXG4gIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgZWxNaXJyb3IgPSBlbC5fX2hvdmVyTWlyO1xuICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKGhvdmVyRWxlbWVudHMsIGVsTWlycm9yKTtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG5cbiAgICBlbC5fX2hvdmVyTWlyID0gbnVsbDtcbiAgfSxcbiAgY2xlYXJIb3ZlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3ZlckVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZnJvbSA9IGhvdmVyRWxlbWVudHNbaV0uX19mcm9tO1xuXG4gICAgICBpZiAoZnJvbSkge1xuICAgICAgICBmcm9tLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhvdmVyRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgfSxcbiAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgIHZhciBsZW4gPSBob3ZlckVsZW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXI7XG4gICAgaG92ZXJMYXllciAmJiBob3ZlckxheWVyLmNsZWFyKCk7XG5cbiAgICBpZiAoIWxlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbXNvcnQoaG92ZXJFbGVtZW50cywgdGhpcy5zdG9yYWdlLmRpc3BsYXlhYmxlU29ydEZ1bmMpOyAvLyBVc2UgYSBleHRyZWFtIGxhcmdlIHpsZXZlbFxuICAgIC8vIEZJWE1FP1xuXG4gICAgaWYgKCFob3ZlckxheWVyKSB7XG4gICAgICBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllciA9IHRoaXMuZ2V0TGF5ZXIoMWU1KTtcbiAgICB9XG5cbiAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICBob3ZlckxheWVyLmN0eC5zYXZlKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgIHZhciBlbCA9IGhvdmVyRWxlbWVudHNbaV07XG4gICAgICB2YXIgb3JpZ2luYWxFbCA9IGVsLl9fZnJvbTsgLy8gT3JpZ2luYWwgZWwgaXMgcmVtb3ZlZFxuICAgICAgLy8gUEVORElOR1xuXG4gICAgICBpZiAoIShvcmlnaW5hbEVsICYmIG9yaWdpbmFsRWwuX196cikpIHtcbiAgICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIG9yaWdpbmFsRWwuX19ob3Zlck1pciA9IG51bGw7XG4gICAgICAgIGxlbi0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaSsrOyAvLyBVc2UgdHJhbnNmb3JtXG4gICAgICAvLyBGSVhNRSBzdHlsZSBhbmQgc2hhcGUgP1xuXG4gICAgICBpZiAoIW9yaWdpbmFsRWwuaW52aXNpYmxlKSB7XG4gICAgICAgIGVsLnRyYW5zZm9ybSA9IG9yaWdpbmFsRWwudHJhbnNmb3JtO1xuICAgICAgICBlbC5pbnZUcmFuc2Zvcm0gPSBvcmlnaW5hbEVsLmludlRyYW5zZm9ybTtcbiAgICAgICAgZWwuX19jbGlwUGF0aHMgPSBvcmlnaW5hbEVsLl9fY2xpcFBhdGhzOyAvLyBlbC5cblxuICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGhvdmVyTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBob3ZlckxheWVyLmN0eC5yZXN0b3JlKCk7XG4gIH0sXG4gIF9zdGFydFByb2dlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIXNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVXNlIGEgdG9rZW4gdG8gc3RvcCBwcm9ncmVzcyBzdGVwcyB0cmlnZ2VyZWQgYnlcbiAgICAvLyBwcmV2aW91cyB6ci5yZWZyZXNoIGNhbGxpbmcuXG5cblxuICAgIHZhciB0b2tlbiA9IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSArbmV3IERhdGUoKTtcbiAgICBzZWxmLl9wcm9ncmVzcysrO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcblxuICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICAvLyBJbiBjYXNlIHJlZnJlc2hlZCBvciBkaXNwb3NlZFxuICAgICAgaWYgKHRva2VuID09PSBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuICYmIHNlbGYuc3RvcmFnZSkge1xuICAgICAgICBzZWxmLl9kb1BhaW50TGlzdChzZWxmLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKSk7XG5cbiAgICAgICAgaWYgKHNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgIHNlbGYuX3Byb2dyZXNzKys7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2NsZWFyUHJvZ3Jlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVRva2VuID0gLTE7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSAwO1xuICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBsYXllci5fX2RpcnR5ICYmIGxheWVyLmNsZWFyKCk7XG4gICAgfSk7XG4gIH0sXG4gIF9wYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBwYWludEFsbCkge1xuICAgIGlmIChwYWludEFsbCA9PSBudWxsKSB7XG4gICAgICBwYWludEFsbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUxheWVyU3RhdHVzKGxpc3QpO1xuXG4gICAgdGhpcy5fY2xlYXJQcm9ncmVzc2l2ZSgpO1xuXG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHByZVByb2Nlc3NMYXllcik7XG5cbiAgICB0aGlzLl9kb1BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocG9zdFByb2Nlc3NMYXllcik7XG4gIH0sXG4gIF9kb1BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QsIHBhaW50QWxsKSB7XG4gICAgdmFyIGN1cnJlbnRMYXllcjtcbiAgICB2YXIgY3VycmVudFpMZXZlbDtcbiAgICB2YXIgY3R4OyAvLyB2YXIgaW52VHJhbnNmb3JtID0gW107XG5cbiAgICB2YXIgc2NvcGU7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJJZHggPSAwO1xuICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcbiAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgIHZhciBsYXllclByb2dyZXNzO1xuICAgIHZhciBmcmFtZSA9IHRoaXMuX3Byb2dyZXNzO1xuXG4gICAgZnVuY3Rpb24gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGxheWVyKSB7XG4gICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDA7IC8vIEF2b2lkIGxheWVyIGRvbid0IGNsZWFyIGluIG5leHQgcHJvZ3Jlc3NpdmUgZnJhbWVcblxuICAgICAgY3VycmVudExheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UobGF5ZXIuZG9tLCAwLCAwLCB3aWR0aCAqIGRwciwgaGVpZ2h0ICogZHByKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgIHZhciBlbFpMZXZlbCA9IHRoaXMuX3NpbmdsZUNhbnZhcyA/IDAgOiBlbC56bGV2ZWw7XG4gICAgICB2YXIgZWxGcmFtZSA9IGVsLl9fZnJhbWU7IC8vIEZsdXNoIGF0IGN1cnJlbnQgY29udGV4dFxuICAgICAgLy8gUEVORElOR1xuXG4gICAgICBpZiAoZWxGcmFtZSA8IDAgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgfSAvLyBDaGFuZ2UgZHJhdyBsYXllclxuXG5cbiAgICAgIGlmIChjdXJyZW50WkxldmVsICE9PSBlbFpMZXZlbCkge1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSAvLyBSZXNldCBzY29wZVxuXG5cbiAgICAgICAgc2NvcGUgPSB7fTsgLy8gT25seSAwIHpsZXZlbCBpZiBvbmx5IGhhcyBvbmUgY2FudmFzXG5cbiAgICAgICAgY3VycmVudFpMZXZlbCA9IGVsWkxldmVsO1xuICAgICAgICBjdXJyZW50TGF5ZXIgPSB0aGlzLmdldExheWVyKGN1cnJlbnRaTGV2ZWwpO1xuXG4gICAgICAgIGlmICghY3VycmVudExheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgICAgbG9nKCdaTGV2ZWwgJyArIGN1cnJlbnRaTGV2ZWwgKyAnIGhhcyBiZWVuIHVzZWQgYnkgdW5rb3duIGxheWVyICcgKyBjdXJyZW50TGF5ZXIuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4ID0gY3VycmVudExheWVyLmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTsgLy8gUmVzZXQgdGhlIGNvdW50XG5cbiAgICAgICAgY3VycmVudExheWVyLl9fdW51c2VkQ291bnQgPSAwO1xuXG4gICAgICAgIGlmIChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBwYWludEFsbCkge1xuICAgICAgICAgIGN1cnJlbnRMYXllci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsRnJhbWUgPj0gMCkge1xuICAgICAgICAvLyBQcm9ncmVzc2l2ZSBsYXllciBjaGFuZ2VkXG4gICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzW01hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJJZHgrKywgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiAtIDEpXTtcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlID0ge307XG5cbiAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcyA+IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIC8vIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICAvLyBRdWljayBqdW1wIGFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50c1xuICAgICAgICAgICAgLy8gQWxsIHByb2dyZXNzaXZlIGVsZW1lbnQgYXJlIG5vdCBkaXJ0eSwganVtcCBvdmVyIGFuZCBmbHVzaCBkaXJlY3RseVxuICAgICAgICAgICAgaSA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgLSAxOyAvLyBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IG51bGw7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxheWVyUHJvZ3Jlc3MgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzO1xuXG4gICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAvLyBLZWVwIHJlbmRlcmluZ1xuICAgICAgICAgICAgZnJhbWUgPSBsYXllclByb2dyZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPSBmcmFtZSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxGcmFtZSA9PT0gZnJhbWUpIHtcbiAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLCB0cnVlLCBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5yZW5kZXJTY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudExheWVyLCBwYWludEFsbCwgc2NvcGUpO1xuICAgICAgfVxuXG4gICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgIH0gLy8gUmVzdG9yZSB0aGUgbGFzdExheWVyIGN0eFxuXG5cbiAgICBjdHggJiYgY3R4LnJlc3RvcmUoKTsgLy8gSWYgc3RpbGwgaGFzIGNsaXBwaW5nIHN0YXRlXG4gICAgLy8gaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgIC8vICAgICBjdHgucmVzdG9yZSgpO1xuICAgIC8vIH1cblxuICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IGZhbHNlO1xuICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBpZiAobGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBsYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG4gIF9kb1BhaW50RWw6IGZ1bmN0aW9uIChlbCwgY3VycmVudExheWVyLCBmb3JjZVBhaW50LCBzY29wZSkge1xuICAgIHZhciBjdHggPSBjdXJyZW50TGF5ZXIuY3R4O1xuICAgIHZhciBtID0gZWwudHJhbnNmb3JtO1xuXG4gICAgaWYgKChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBmb3JjZVBhaW50KSAmJiAvLyBJZ25vcmUgaW52aXNpYmxlIGVsZW1lbnRcbiAgICAhZWwuaW52aXNpYmxlIC8vIElnbm9yZSB0cmFuc3BhcmVudCBlbGVtZW50XG4gICAgJiYgZWwuc3R5bGUub3BhY2l0eSAhPT0gMCAvLyBJZ25vcmUgc2NhbGUgMCBlbGVtZW50LCBpbiBzb21lIGVudmlyb25tZW50IGxpa2Ugbm9kZS1jYW52YXNcbiAgICAvLyBEcmF3IGEgc2NhbGUgMCBlbGVtZW50IGNhbiBjYXVzZSBhbGwgZm9sbG93aW5nIGRyYXcgd3JvbmdcbiAgICAvLyBBbmQgc2V0VHJhbnNmb3JtIHdpdGggc2NhbGUgMCB3aWxsIGNhdXNlIHNldCBiYWNrIHRyYW5zZm9ybSBmYWlsZWQuXG4gICAgJiYgIShtICYmICFtWzBdICYmICFtWzNdKSAvLyBJZ25vcmUgY3VsbGVkIGVsZW1lbnRcbiAgICAmJiAhKGVsLmN1bGxpbmcgJiYgaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpKSB7XG4gICAgICB2YXIgY2xpcFBhdGhzID0gZWwuX19jbGlwUGF0aHM7IC8vIE9wdGltaXplIHdoZW4gY2xpcHBpbmcgb24gZ3JvdXAgd2l0aCBzZXZlcmFsIGVsZW1lbnRzXG5cbiAgICAgIGlmIChzY29wZS5wcmV2Q2xpcExheWVyICE9PSBjdXJyZW50TGF5ZXIgfHwgaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBzY29wZS5wcmV2RWxDbGlwUGF0aHMpKSB7XG4gICAgICAgIC8vIElmIGhhcyBwcmV2aW91cyBjbGlwcGluZyBzdGF0ZSwgcmVzdG9yZSBmcm9tIGl0XG4gICAgICAgIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IHNjb3BlLnByZXZFbENsaXBQYXRocyA9IG51bGw7IC8vIFJlc2V0IHByZXZFbCBzaW5jZSBjb250ZXh0IGhhcyBiZWVuIHJlc3RvcmVkXG5cbiAgICAgICAgICBzY29wZS5wcmV2RWwgPSBudWxsO1xuICAgICAgICB9IC8vIE5ldyBjbGlwcGluZyBzdGF0ZVxuXG5cbiAgICAgICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgZG9DbGlwKGNsaXBQYXRocywgY3R4KTtcbiAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyID0gY3VycmVudExheWVyO1xuICAgICAgICAgIHNjb3BlLnByZXZFbENsaXBQYXRocyA9IGNsaXBQYXRocztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaChjdHgpO1xuICAgICAgZWwuYnJ1c2goY3R4LCBzY29wZS5wcmV2RWwgfHwgbnVsbCk7XG4gICAgICBzY29wZS5wcmV2RWwgPSBlbDtcbiAgICAgIGVsLmFmdGVyQnJ1c2ggJiYgZWwuYWZ0ZXJCcnVzaChjdHgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6I635Y+WIHpsZXZlbCDmiYDlnKjlsYLvvIzlpoLmnpzkuI3lrZjlnKjliJnkvJrliJvlu7rkuIDkuKrmlrDnmoTlsYJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICovXG4gIGdldExheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXTtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBsYXllclxuICAgICAgbGF5ZXIgPSBuZXcgTGF5ZXIoJ3pyXycgKyB6bGV2ZWwsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgIGxheWVyLl9fYnVpbHRpbl9fID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5zZXJ0TGF5ZXIoemxldmVsLCBsYXllcik7IC8vIENvbnRleHQgaXMgY3JlYXRlZCBhZnRlciBkb20gaW5zZXJ0ZWQgdG8gZG9jdW1lbnRcbiAgICAgIC8vIE9yIGV4Y2FudmFzIHdpbGwgZ2V0IDBweCBjbGllbnRXaWR0aCBhbmQgY2xpZW50SGVpZ2h0XG5cbiAgICAgIGxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVyO1xuICB9LFxuICBpbnNlcnRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgbGF5ZXIpIHtcbiAgICB2YXIgbGF5ZXJzTWFwID0gdGhpcy5fbGF5ZXJzO1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGVuID0gemxldmVsTGlzdC5sZW5ndGg7XG4gICAgdmFyIHByZXZMYXllciA9IG51bGw7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG5cbiAgICBpZiAobGF5ZXJzTWFwW3psZXZlbF0pIHtcbiAgICAgIGxvZygnWkxldmVsICcgKyB6bGV2ZWwgKyAnIGhhcyBiZWVuIHVzZWQgYWxyZWFkeScpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ2hlY2sgaWYgaXMgYSB2YWxpZCBsYXllclxuXG5cbiAgICBpZiAoIWlzTGF5ZXJWYWxpZChsYXllcikpIHtcbiAgICAgIGxvZygnTGF5ZXIgb2YgemxldmVsICcgKyB6bGV2ZWwgKyAnIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW4gPiAwICYmIHpsZXZlbCA+IHpsZXZlbExpc3RbMF0pIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKHpsZXZlbExpc3RbaV0gPCB6bGV2ZWwgJiYgemxldmVsTGlzdFtpICsgMV0gPiB6bGV2ZWwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2TGF5ZXIgPSBsYXllcnNNYXBbemxldmVsTGlzdFtpXV07XG4gICAgfVxuXG4gICAgemxldmVsTGlzdC5zcGxpY2UoaSArIDEsIDAsIHpsZXZlbCk7XG4gICAgbGF5ZXJzTWFwW3psZXZlbF0gPSBsYXllcjsgLy8gVml0dWFsIGxheWVyIHdpbGwgbm90IGRpcmVjdGx5IHNob3cgb24gdGhlIHNjcmVlbi5cbiAgICAvLyAoSXQgY2FuIGJlIGEgV2ViR0wgbGF5ZXIgYW5kIGFzc2lnbmVkIHRvIGEgWkltYWdlIGVsZW1lbnQpXG4gICAgLy8gQnV0IGl0IHN0aWxsIHVuZGVyIG1hbmFnZW1lbnQgb2YgenJlbmRlci5cblxuICAgIGlmICghbGF5ZXIudmlydHVhbCkge1xuICAgICAgaWYgKHByZXZMYXllcikge1xuICAgICAgICB2YXIgcHJldkRvbSA9IHByZXZMYXllci5kb207XG5cbiAgICAgICAgaWYgKHByZXZEb20ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBkb21Sb290Lmluc2VydEJlZm9yZShsYXllci5kb20sIHByZXZEb20ubmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRvbVJvb3QuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKGxheWVyLmRvbSwgZG9tUm9vdC5maXJzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBsYXllclxuICBlYWNoTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgejtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW3pdLCB6KTtcbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBidWlsZGluIGxheWVyXG4gIGVhY2hCdWlsdGluTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGF5ZXI7XG4gICAgdmFyIHo7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcblxuICAgICAgaWYgKGxheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgbGF5ZXIsIHopO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gSXRlcmF0ZSBlYWNoIG90aGVyIGxheWVyIGV4Y2VwdCBidWlsZGluIGxheWVyXG4gIGVhY2hPdGhlckxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdmFyIGxheWVyO1xuICAgIHZhciB6O1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG5cbiAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmiYDmnInlt7LliJvlu7rnmoTlsYJcbiAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvTGF5ZXI+fSBbcHJldkxheWVyXVxuICAgKi9cbiAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xheWVycztcbiAgfSxcbiAgX3VwZGF0ZUxheWVyU3RhdHVzOiBmdW5jdGlvbiAobGlzdCkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJzID0gdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnM7XG4gICAgdmFyIGVsQ291bnRzTGFzdEZyYW1lID0ge307XG4gICAgdmFyIHByb2dyZXNzaXZlRWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICBlbENvdW50c0xhc3RGcmFtZVt6XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICBsYXllci5lbENvdW50ID0gMDtcbiAgICAgIGxheWVyLl9fZGlydHkgPSBmYWxzZTtcbiAgICB9KTtcbiAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gPSBsYXllci5lbENvdW50O1xuICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICBsYXllci5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfSk7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJDb3VudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyO1xuICAgIHZhciBsYXN0UHJvZ3Jlc3NpdmVLZXk7XG4gICAgdmFyIGZyYW1lQ291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgIHZhciB6bGV2ZWwgPSB0aGlzLl9zaW5nbGVDYW52YXMgPyAwIDogZWwuemxldmVsO1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW3psZXZlbF07XG4gICAgICB2YXIgZWxQcm9ncmVzcyA9IGVsLnByb2dyZXNzaXZlO1xuXG4gICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuZWxDb3VudCsrO1xuICAgICAgICBsYXllci5fX2RpcnR5ID0gbGF5ZXIuX19kaXJ0eSB8fCBlbC5fX2RpcnR5O1xuICAgICAgfSAvLy8vLy8vIFVwZGF0ZSBwcm9ncmVzc2l2ZVxuXG5cbiAgICAgIGlmIChlbFByb2dyZXNzID49IDApIHtcbiAgICAgICAgLy8gRml4IHdyb25nIHByb2dyZXNzaXZlIHNlcXVlbmNlIHByb2JsZW0uXG4gICAgICAgIGlmIChsYXN0UHJvZ3Jlc3NpdmVLZXkgIT09IGVsUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBsYXN0UHJvZ3Jlc3NpdmVLZXkgPSBlbFByb2dyZXNzO1xuICAgICAgICAgIGZyYW1lQ291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZSA9IGZyYW1lQ291bnQgLSAxO1xuXG4gICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSk7XG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdO1xuXG4gICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdID0gbmV3IExheWVyKCdwcm9ncmVzc2l2ZScsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5ID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSB8fCBlbC5fX2RpcnR5O1xuICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5lbENvdW50Kys7XG4gICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSBNYXRoLm1heChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzLCBlbEZyYW1lKTtcblxuICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgICAgLy8gU2hvdWxkIGtlZXAgcmVuZGVyaW5nIHRoaXMgIGxheWVyIGJlY2F1c2UgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGlzIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICBsYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuX19mcmFtZSA9IC0xO1xuXG4gICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgPSBpO1xuICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgcHJvZ3Jlc3NpdmVMYXllckNvdW50Kys7XG4gICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICB9IC8vIOWxguS4reeahOWFg+e0oOaVsOmHj+acieWPkeeUn+WPmOWMllxuXG5cbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICBpZiAoZWxDb3VudHNMYXN0RnJhbWVbel0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSKTtcbiAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICBpZiAocHJvZ3Jlc3NpdmVFbENvdW50c0xhc3RGcmFtZVtpZHhdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgIGVsLl9fZGlydHkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobGF5ZXIuX19kaXJ0eSkge1xuICAgICAgICBsYXllci5fX3Byb2dyZXNzID0gMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICog5riF6ZmkaG92ZXLlsYLlpJbmiYDmnInlhoXlrrlcbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHRoaXMuX2NsZWFyTGF5ZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfY2xlYXJMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgbGF5ZXIuY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICog5L+u5pS55oyH5a6aemxldmVs55qE57uY5Yi25Y+C5pWwXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6bGV2ZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyDphY3nva7lr7nosaFcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSDmr4/mrKHmuIXnqbrnlLvluIPnmoTpopzoibJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0g5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxhc3RGcmFtZUFscGhhPTAuN11cbiAgICogICAgICAgICAgICAgICAgIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAqL1xuICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdmFyIGxheWVyQ29uZmlnID0gdGhpcy5fbGF5ZXJDb25maWc7XG5cbiAgICAgIGlmICghbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIGxheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWwg5bGC5omA5Zyo55qEemxldmVsXG4gICAqL1xuICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuXG4gICAgaWYgKCFsYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxheWVyLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxheWVyLmRvbSk7XG4gICAgZGVsZXRlIGxheWVyc1t6bGV2ZWxdO1xuICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgfSxcblxuICAvKipcbiAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAqL1xuICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290OyAvLyBGSVhNRSBXaHkgP1xuXG4gICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBTYXZlIGlucHV0IHcvaFxuXG4gICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgIHdpZHRoICE9IG51bGwgJiYgKG9wdHMud2lkdGggPSB3aWR0aCk7XG4gICAgaGVpZ2h0ICE9IG51bGwgJiYgKG9wdHMuaGVpZ2h0ID0gaGVpZ2h0KTtcbiAgICB3aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgaGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSgxKTtcbiAgICBkb21Sb290LnN0eWxlLmRpc3BsYXkgPSAnJzsgLy8g5LyY5YyW5rKh5pyJ5a6e6ZmF5pS55Y+Y55qEcmVzaXplXG5cbiAgICBpZiAodGhpcy5fd2lkdGggIT0gd2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMuX2hlaWdodCkge1xuICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIGRvbVJvb3Quc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXllcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJlZnJlc2godHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4hemZpOWNleeLrOeahOS4gOS4quWxglxuICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAqL1xuICBjbGVhckxheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG5cbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDph4rmlL5cbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG4gICAgdGhpcy5yb290ID0gdGhpcy5zdG9yYWdlID0gdGhpcy5fZG9tUm9vdCA9IHRoaXMuX2xheWVycyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMucGl4ZWxSYXRpb11cbiAgICovXG4gIGdldFJlbmRlcmVkQ2FudmFzOiBmdW5jdGlvbiAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXS5kb207XG4gICAgfVxuXG4gICAgdmFyIGltYWdlTGF5ZXIgPSBuZXcgTGF5ZXIoJ2ltYWdlJywgdGhpcywgb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZHByKTtcbiAgICBpbWFnZUxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgaW1hZ2VMYXllci5jbGVhckNvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgaW1hZ2VMYXllci5jbGVhcigpO1xuICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcbiAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICB2YXIgemxldmVsO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGZpbmRBbmREcmF3T3RoZXJMYXllcihzbWFsbGVyLCBsYXJnZXIpIHtcbiAgICAgIHZhciB6bGV2ZWxMaXN0ID0gc2VsZi5femxldmVsTGlzdDtcblxuICAgICAgaWYgKHNtYWxsZXIgPT0gbnVsbCkge1xuICAgICAgICBzbWFsbGVyID0gLUluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICB2YXIgaW50ZXJtZWRpYXRlTGF5ZXI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgIHZhciBsYXllciA9IHNlbGYuX2xheWVyc1t6XTtcblxuICAgICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fICYmIHogPiBzbWFsbGVyICYmIHogPCBsYXJnZXIpIHtcbiAgICAgICAgICBpbnRlcm1lZGlhdGVMYXllciA9IGxheWVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnRlcm1lZGlhdGVMYXllciAmJiBpbnRlcm1lZGlhdGVMYXllci5yZW5kZXJUb0NhbnZhcykge1xuICAgICAgICBpbWFnZUxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgIGludGVybWVkaWF0ZUxheWVyLnJlbmRlclRvQ2FudmFzKGltYWdlTGF5ZXIuY3R4KTtcbiAgICAgICAgaW1hZ2VMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbCA9IGRpc3BsYXlMaXN0W2ldO1xuXG4gICAgICBpZiAoZWwuemxldmVsICE9PSB6bGV2ZWwpIHtcbiAgICAgICAgZmluZEFuZERyYXdPdGhlckxheWVyKHpsZXZlbCwgZWwuemxldmVsKTtcbiAgICAgICAgemxldmVsID0gZWwuemxldmVsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGltYWdlTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICB9XG5cbiAgICBmaW5kQW5kRHJhd090aGVyTGF5ZXIoemxldmVsLCBJbmZpbml0eSk7XG4gICAgcmV0dXJuIGltYWdlTGF5ZXIuZG9tO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/lrr3luqZcbiAgICovXG4gIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/pq5jluqZcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH0sXG4gIF9nZXRTaXplOiBmdW5jdGlvbiAod2hJZHgpIHtcbiAgICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gICAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXVt3aElkeF07XG4gICAgdmFyIGN3aCA9IFsnY2xpZW50V2lkdGgnLCAnY2xpZW50SGVpZ2h0J11bd2hJZHhdO1xuICAgIHZhciBwbHQgPSBbJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdUb3AnXVt3aElkeF07XG4gICAgdmFyIHByYiA9IFsncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nXVt3aElkeF07XG5cbiAgICBpZiAob3B0c1t3aF0gIT0gbnVsbCAmJiBvcHRzW3doXSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChvcHRzW3doXSk7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7IC8vIElFOCBkb2VzIG5vdCBzdXBwb3J0IGdldENvbXB1dGVkU3R5bGUsIGJ1dCBpdCB1c2UgVk1MLlxuXG4gICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUocm9vdCk7XG4gICAgcmV0dXJuIChyb290W2N3aF0gfHwgcGFyc2VJbnQxMChzdGxbd2hdKSB8fCBwYXJzZUludDEwKHJvb3Quc3R5bGVbd2hdKSkgLSAocGFyc2VJbnQxMChzdGxbcGx0XSkgfHwgMCkgLSAocGFyc2VJbnQxMChzdGxbcHJiXSkgfHwgMCkgfCAwO1xuICB9LFxuICBwYXRoVG9JbWFnZTogZnVuY3Rpb24gKHBhdGgsIGRwcikge1xuICAgIGRwciA9IGRwciB8fCB0aGlzLmRwcjtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgc3R5bGUgPSBwYXRoLnN0eWxlO1xuICAgIHZhciBzaGFkb3dCbHVyU2l6ZSA9IHN0eWxlLnNoYWRvd0JsdXI7XG4gICAgdmFyIHNoYWRvd09mZnNldFggPSBzdHlsZS5zaGFkb3dPZmZzZXRYO1xuICAgIHZhciBzaGFkb3dPZmZzZXRZID0gc3R5bGUuc2hhZG93T2Zmc2V0WTtcbiAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUuaGFzU3Ryb2tlKCkgPyBzdHlsZS5saW5lV2lkdGggOiAwO1xuICAgIHZhciBsZWZ0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFggKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHJpZ2h0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgc2hhZG93T2Zmc2V0WCArIHNoYWRvd0JsdXJTaXplKTtcbiAgICB2YXIgdG9wTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIGJvdHRvbU1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIHNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aCArIGxlZnRNYXJnaW4gKyByaWdodE1hcmdpbjtcbiAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyB0b3BNYXJnaW4gKyBib3R0b21NYXJnaW47XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcbiAgICBjdHguc2NhbGUoZHByLCBkcHIpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgY3R4LmRwciA9IGRwcjtcbiAgICB2YXIgcGF0aFRyYW5zZm9ybSA9IHtcbiAgICAgIHBvc2l0aW9uOiBwYXRoLnBvc2l0aW9uLFxuICAgICAgcm90YXRpb246IHBhdGgucm90YXRpb24sXG4gICAgICBzY2FsZTogcGF0aC5zY2FsZVxuICAgIH07XG4gICAgcGF0aC5wb3NpdGlvbiA9IFtsZWZ0TWFyZ2luIC0gcmVjdC54LCB0b3BNYXJnaW4gLSByZWN0LnldO1xuICAgIHBhdGgucm90YXRpb24gPSAwO1xuICAgIHBhdGguc2NhbGUgPSBbMSwgMV07XG4gICAgcGF0aC51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgIGlmIChwYXRoKSB7XG4gICAgICBwYXRoLmJydXNoKGN0eCk7XG4gICAgfVxuXG4gICAgdmFyIEltYWdlU2hhcGUgPSBJbWFnZTtcbiAgICB2YXIgaW1nU2hhcGUgPSBuZXcgSW1hZ2VTaGFwZSh7XG4gICAgICBzdHlsZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBpbWFnZTogY2FudmFzXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGF0aFRyYW5zZm9ybS5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICBpbWdTaGFwZS5wb3NpdGlvbiA9IHBhdGgucG9zaXRpb24gPSBwYXRoVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIH1cblxuICAgIGlmIChwYXRoVHJhbnNmb3JtLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgIGltZ1NoYXBlLnJvdGF0aW9uID0gcGF0aC5yb3RhdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucm90YXRpb247XG4gICAgfVxuXG4gICAgaWYgKHBhdGhUcmFuc2Zvcm0uc2NhbGUgIT0gbnVsbCkge1xuICAgICAgaW1nU2hhcGUuc2NhbGUgPSBwYXRoLnNjYWxlID0gcGF0aFRyYW5zZm9ybS5zY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1nU2hhcGU7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBQYWludGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvUGFpbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IF9jb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcblxudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vZ3JhcGhpYy9TdHlsZVwiKTtcblxudmFyIFBhdHRlcm4gPSByZXF1aXJlKFwiLi9ncmFwaGljL1BhdHRlcm5cIik7XG5cbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL0xheWVyXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiDliJvlu7pkb21cbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBkb20gaWQg5b6F55SoXG4gKiBAcGFyYW0ge1BhaW50ZXJ9IHBhaW50ZXIgcGFpbnRlciBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRG9tKGlkLCBwYWludGVyLCBkcHIpIHtcbiAgdmFyIG5ld0RvbSA9IHV0aWwuY3JlYXRlQ2FudmFzKCk7XG4gIHZhciB3aWR0aCA9IHBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgdmFyIGhlaWdodCA9IHBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gIHZhciBuZXdEb21TdHlsZSA9IG5ld0RvbS5zdHlsZTsgLy8g5rKhYXBwZW5k5ZGi77yM6K+35Y6f6LCF5oiR6L+Z5qC35YaZ77yM5riF5pmwflxuXG4gIG5ld0RvbVN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgbmV3RG9tU3R5bGUubGVmdCA9IDA7XG4gIG5ld0RvbVN0eWxlLnRvcCA9IDA7XG4gIG5ld0RvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBuZXdEb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICBuZXdEb20ud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgbmV3RG9tLmhlaWdodCA9IGhlaWdodCAqIGRwcjsgLy8gaWTkuI3kvZzkuLrntKLlvJXnlKjvvIzpgb/lhY3lj6/og73pgKDmiJDnmoTph43lkI3vvIzlrprkuYnkuLrnp4HmnInlsZ7mgKdcblxuICBuZXdEb20uc2V0QXR0cmlidXRlKCdkYXRhLXpyLWRvbS1pZCcsIGlkKTtcbiAgcmV0dXJuIG5ld0RvbTtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0xheWVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9QYWludGVyfSBwYWludGVyXG4gKiBAcGFyYW0ge251bWJlcn0gW2Rwcl1cbiAqL1xuXG5cbnZhciBMYXllciA9IGZ1bmN0aW9uIChpZCwgcGFpbnRlciwgZHByKSB7XG4gIHZhciBkb207XG4gIGRwciA9IGRwciB8fCBkZXZpY2VQaXhlbFJhdGlvO1xuXG4gIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgZG9tID0gY3JlYXRlRG9tKGlkLCBwYWludGVyLCBkcHIpO1xuICB9IC8vIE5vdCB1c2luZyBpc0RvbSBiZWNhdXNlIGluIG5vZGUgaXQgd2lsbCByZXR1cm4gZmFsc2VcbiAgZWxzZSBpZiAodXRpbC5pc09iamVjdChpZCkpIHtcbiAgICAgIGRvbSA9IGlkO1xuICAgICAgaWQgPSBkb20uaWQ7XG4gICAgfVxuXG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5kb20gPSBkb207XG4gIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcblxuICBpZiAoZG9tU3R5bGUpIHtcbiAgICAvLyBOb3QgaW4gbm9kZVxuICAgIGRvbS5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuXG4gICAgZG9tU3R5bGVbJy13ZWJraXQtdXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICBkb21TdHlsZVsndXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICBkb21TdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSAnbm9uZSc7XG4gICAgZG9tU3R5bGVbJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvciddID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgIGRvbVN0eWxlWydwYWRkaW5nJ10gPSAwO1xuICAgIGRvbVN0eWxlWydtYXJnaW4nXSA9IDA7XG4gICAgZG9tU3R5bGVbJ2JvcmRlci13aWR0aCddID0gMDtcbiAgfVxuXG4gIHRoaXMuZG9tQmFjayA9IG51bGw7XG4gIHRoaXMuY3R4QmFjayA9IG51bGw7XG4gIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG4gIHRoaXMuY29uZmlnID0gbnVsbDsgLy8gQ29uZmlnc1xuXG4gIC8qKlxuICAgKiDmr4/mrKHmuIXnqbrnlLvluIPnmoTpopzoibJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cblxuICB0aGlzLmNsZWFyQ29sb3IgPSAwO1xuICAvKipcbiAgICog5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cblxuICB0aGlzLm1vdGlvbkJsdXIgPSBmYWxzZTtcbiAgLyoqXG4gICAqIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDAuN1xuICAgKi9cblxuICB0aGlzLmxhc3RGcmFtZUFscGhhID0gMC43O1xuICAvKipcbiAgICogTGF5ZXIgZHByXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuZHByID0gZHByO1xufTtcblxuTGF5ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTGF5ZXIsXG4gIGVsQ291bnQ6IDAsXG4gIF9fZGlydHk6IHRydWUsXG4gIGluaXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdHggPSB0aGlzLmRvbS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY3R4Ll9fY3VycmVudFZhbHVlcyA9IHt9O1xuICAgIHRoaXMuY3R4LmRwciA9IHRoaXMuZHByO1xuICB9LFxuICBjcmVhdGVCYWNrQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRwciA9IHRoaXMuZHByO1xuICAgIHRoaXMuZG9tQmFjayA9IGNyZWF0ZURvbSgnYmFjay0nICsgdGhpcy5pZCwgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgIHRoaXMuY3R4QmFjayA9IHRoaXMuZG9tQmFjay5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY3R4QmFjay5fX2N1cnJlbnRWYWx1ZXMgPSB7fTtcblxuICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZHByID0gdGhpcy5kcHI7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICBkb21TdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBkb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIGRvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICAgIGRvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICBpZiAoZG9tQmFjaykge1xuICAgICAgZG9tQmFjay53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgZG9tQmFjay5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5riF56m66K+l5bGC55S75biDXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJBbGwgQ2xlYXIgYWxsIHdpdGggb3V0IG1vdGlvbiBibHVyXG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKGNsZWFyQWxsKSB7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICB2YXIgd2lkdGggPSBkb20ud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGRvbS5oZWlnaHQ7XG4gICAgdmFyIGNsZWFyQ29sb3IgPSB0aGlzLmNsZWFyQ29sb3I7XG4gICAgdmFyIGhhdmVNb3Rpb25CTHVyID0gdGhpcy5tb3Rpb25CbHVyICYmICFjbGVhckFsbDtcbiAgICB2YXIgbGFzdEZyYW1lQWxwaGEgPSB0aGlzLmxhc3RGcmFtZUFscGhhO1xuICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgIGlmIChoYXZlTW90aW9uQkx1cikge1xuICAgICAgaWYgKCF0aGlzLmRvbUJhY2spIHtcbiAgICAgICAgdGhpcy5jcmVhdGVCYWNrQnVmZmVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4QmFjay5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgICB0aGlzLmN0eEJhY2suZHJhd0ltYWdlKGRvbSwgMCwgMCwgd2lkdGggLyBkcHIsIGhlaWdodCAvIGRwcik7XG4gICAgfVxuXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGlmIChjbGVhckNvbG9yKSB7XG4gICAgICB2YXIgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuOyAvLyBHcmFkaWVudFxuXG4gICAgICBpZiAoY2xlYXJDb2xvci5jb2xvclN0b3BzKSB7XG4gICAgICAgIC8vIENhY2hlIGNhbnZhcyBncmFkaWVudFxuICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgfHwgU3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBjbGVhckNvbG9yLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgY2xlYXJDb2xvci5fX2NhbnZhc0dyYWRpZW50ID0gY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuO1xuICAgICAgfSAvLyBQYXR0ZXJuXG4gICAgICBlbHNlIGlmIChjbGVhckNvbG9yLmltYWdlKSB7XG4gICAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybi5jYWxsKGNsZWFyQ29sb3IsIGN0eCk7XG4gICAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gfHwgY2xlYXJDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgaWYgKGhhdmVNb3Rpb25CTHVyKSB7XG4gICAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBsYXN0RnJhbWVBbHBoYTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoZG9tQmFjaywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IExheWVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvTGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZGVmYXVsdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvenJlbmRlci9pc3N1ZXMvMTg5I2lzc3VlY29tbWVudC0yMjQ5MTk4MDlcbndpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkgfHwgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgc2V0VGltZW91dChmdW5jLCAxNik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBfZXZlbnQgPSByZXF1aXJlKFwiLi4vY29yZS9ldmVudFwiKTtcblxudmFyIERpc3BhdGNoZXIgPSBfZXZlbnQuRGlzcGF0Y2hlcjtcblxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoXCIuL3JlcXVlc3RBbmltYXRpb25GcmFtZVwiKTtcblxudmFyIEFuaW1hdG9yID0gcmVxdWlyZShcIi4vQW5pbWF0b3JcIik7XG5cbi8qKlxuICog5Yqo55S75Li757G7LCDosIPluqblkoznrqHnkIbmiYDmnInliqjnlLvmjqfliLblmahcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBUT0RPIEFkZGl0aXZlIGFuaW1hdGlvblxuLy8gaHR0cDovL2lvc290ZXJpYy5jb20vYWRkaXRpdmUtYW5pbWF0aW9ucy1hbmltYXRld2l0aGR1cmF0aW9uLWluLWlvcy04L1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy93d2RjMjAxNC8jMjM2XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSVpSZW5kZXJTdGFnZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXBkYXRlXG4gKi9cblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbmZyYW1lXVxuICogQHBhcmFtIHtJWlJlbmRlclN0YWdlfSBbb3B0aW9ucy5zdGFnZV1cbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oKTtcbiAqICAgICB2YXIgb2JqID0ge1xuICogICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgIHk6IDEwMFxuICogICAgIH07XG4gKiAgICAgYW5pbWF0aW9uLmFuaW1hdGUobm9kZS5wb3NpdGlvbilcbiAqICAgICAgICAgLndoZW4oMTAwMCwge1xuICogICAgICAgICAgICAgeDogNTAwLFxuICogICAgICAgICAgICAgeTogNTAwXG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIC53aGVuKDIwMDAsIHtcbiAqICAgICAgICAgICAgIHg6IDEwMCxcbiAqICAgICAgICAgICAgIHk6IDEwMFxuICogICAgICAgICB9KVxuICogICAgICAgICAuc3RhcnQoJ3NwbGluZScpO1xuICovXG52YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuc3RhZ2UgPSBvcHRpb25zLnN0YWdlIHx8IHt9O1xuXG4gIHRoaXMub25mcmFtZSA9IG9wdGlvbnMub25mcmFtZSB8fCBmdW5jdGlvbiAoKSB7fTsgLy8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG5cblxuICB0aGlzLl9jbGlwcyA9IFtdO1xuICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gIHRoaXMuX3RpbWU7XG4gIHRoaXMuX3BhdXNlZFRpbWU7XG4gIHRoaXMuX3BhdXNlU3RhcnQ7XG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICBEaXNwYXRjaGVyLmNhbGwodGhpcyk7XG59O1xuXG5BbmltYXRpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQW5pbWF0aW9uLFxuXG4gIC8qKlxuICAgKiDmt7vliqAgY2xpcFxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAqL1xuICBhZGRDbGlwOiBmdW5jdGlvbiAoY2xpcCkge1xuICAgIHRoaXMuX2NsaXBzLnB1c2goY2xpcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoCBhbmltYXRvclxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICovXG4gIGFkZEFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICBhbmltYXRvci5hbmltYXRpb24gPSB0aGlzO1xuICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFkZENsaXAoY2xpcHNbaV0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXB9IGNsaXBcbiAgICovXG4gIHJlbW92ZUNsaXA6IGZ1bmN0aW9uIChjbGlwKSB7XG4gICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9jbGlwcywgY2xpcCk7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuX2NsaXBzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfSBhbmltYXRvclxuICAgKi9cbiAgcmVtb3ZlQW5pbWF0b3I6IGZ1bmN0aW9uIChhbmltYXRvcikge1xuICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlbW92ZUNsaXAoY2xpcHNbaV0pO1xuICAgIH1cblxuICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IG51bGw7XG4gIH0sXG4gIF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fcGF1c2VkVGltZTtcblxuICAgIHZhciBkZWx0YSA9IHRpbWUgLSB0aGlzLl90aW1lO1xuICAgIHZhciBjbGlwcyA9IHRoaXMuX2NsaXBzO1xuICAgIHZhciBsZW4gPSBjbGlwcy5sZW5ndGg7XG4gICAgdmFyIGRlZmVycmVkRXZlbnRzID0gW107XG4gICAgdmFyIGRlZmVycmVkQ2xpcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjbGlwID0gY2xpcHNbaV07XG4gICAgICB2YXIgZSA9IGNsaXAuc3RlcCh0aW1lLCBkZWx0YSk7IC8vIFRocm93IG91dCB0aGUgZXZlbnRzIG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyXG4gICAgICAvLyBzdGFnZS51cGRhdGUsIGxpa2UgZGVzdHJveVxuXG4gICAgICBpZiAoZSkge1xuICAgICAgICBkZWZlcnJlZEV2ZW50cy5wdXNoKGUpO1xuICAgICAgICBkZWZlcnJlZENsaXBzLnB1c2goY2xpcCk7XG4gICAgICB9XG4gICAgfSAvLyBSZW1vdmUgdGhlIGZpbmlzaGVkIGNsaXBcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICBpZiAoY2xpcHNbaV0uX25lZWRzUmVtb3ZlKSB7XG4gICAgICAgIGNsaXBzW2ldID0gY2xpcHNbbGVuIC0gMV07XG4gICAgICAgIGNsaXBzLnBvcCgpO1xuICAgICAgICBsZW4tLTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZW4gPSBkZWZlcnJlZEV2ZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZWZlcnJlZENsaXBzW2ldLmZpcmUoZGVmZXJyZWRFdmVudHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHRoaXMub25mcmFtZShkZWx0YSk7XG4gICAgdGhpcy50cmlnZ2VyKCdmcmFtZScsIGRlbHRhKTtcblxuICAgIGlmICh0aGlzLnN0YWdlLnVwZGF0ZSkge1xuICAgICAgdGhpcy5zdGFnZS51cGRhdGUoKTtcbiAgICB9XG4gIH0sXG4gIF9zdGFydExvb3A6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgaWYgKHNlbGYuX3J1bm5pbmcpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICAhc2VsZi5fcGF1c2VkICYmIHNlbGYuX3VwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgfSxcblxuICAvKipcbiAgICog5byA5aeL6L+Q6KGM5Yqo55S7XG4gICAqL1xuICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcblxuICAgIHRoaXMuX3N0YXJ0TG9vcCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlgZzmraLov5DooYzliqjnlLtcbiAgICovXG4gIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhdXNlXG4gICAqL1xuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzdW1lXG4gICAqL1xuICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fcGF1c2VTdGFydDtcbiAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5riF6Zmk5omA5pyJ5Yqo55S754mH5q61XG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NsaXBzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWvueS4gOS4quebruagh+WIm+W7uuS4gOS4qmFuaW1hdG9y5a+56LGh77yM5Y+v5Lul5oyH5a6a55uu5qCH5Lit55qE5bGe5oCn5L2/55So5Yqo55S7XG4gICAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5sb29wPWZhbHNlXSDmmK/lkKblvqrnjq/mkq3mlL7liqjnlLtcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLmdldHRlcj1udWxsXVxuICAgKiAgICAgICAgIOWmguaenOaMh+WummdldHRlcuWHveaVsO+8jOS8mumAmui/h2dldHRlcuWHveaVsOWPluWxnuaAp+WAvFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29wdGlvbnMuc2V0dGVyPW51bGxdXG4gICAqICAgICAgICAg5aaC5p6c5oyH5a6ac2V0dGVy5Ye95pWw77yM5Lya6YCa6L+Hc2V0dGVy5Ye95pWw6K6+572u5bGe5oCn5YC8XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25+QW5pbWF0b3J9XG4gICAqL1xuICAvLyBUT0RPIEdhcFxuICBhbmltYXRlOiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKHRhcmdldCwgb3B0aW9ucy5sb29wLCBvcHRpb25zLmdldHRlciwgb3B0aW9ucy5zZXR0ZXIpO1xuICAgIHRoaXMuYWRkQW5pbWF0b3IoYW5pbWF0b3IpO1xuICAgIHJldHVybiBhbmltYXRvcjtcbiAgfVxufTtcbnV0aWwubWl4aW4oQW5pbWF0aW9uLCBEaXNwYXRjaGVyKTtcbnZhciBfZGVmYXVsdCA9IEFuaW1hdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuLi9taXhpbi9FdmVudGZ1bFwiKTtcblxuZXhwb3J0cy5EaXNwYXRjaGVyID0gRXZlbnRmdWw7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi9lbnZcIik7XG5cbi8qKlxuICog5LqL5Lu26L6F5Yqp57G7XG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9ldmVudFxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKi9cbnZhciBpc0RvbUxldmVsMiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICEhd2luZG93LmFkZEV2ZW50TGlzdGVuZXI7XG52YXIgTU9VU0VfRVZFTlRfUkVHID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svO1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpIHtcbiAgLy8gQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKSBkb24ndCBoYXZlIGdldEJvdW5kaW5nUmVjdFxuICByZXR1cm4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID8gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDBcbiAgfTtcbn0gLy8gYGNhbGN1bGF0ZWAgaXMgb3B0aW9uYWwsIGRlZmF1bHQgZmFsc2VcblxuXG5mdW5jdGlvbiBjbGllbnRUb0xvY2FsKGVsLCBlLCBvdXQsIGNhbGN1bGF0ZSkge1xuICBvdXQgPSBvdXQgfHwge307IC8vIEFjY29yZGluZyB0byB0aGUgVzNDIFdvcmtpbmcgRHJhZnQsIG9mZnNldFggYW5kIG9mZnNldFkgc2hvdWxkIGJlIHJlbGF0aXZlXG4gIC8vIHRvIHRoZSBwYWRkaW5nIGVkZ2Ugb2YgdGhlIHRhcmdldCBlbGVtZW50LiBUaGUgb25seSBicm93c2VyIHVzaW5nIHRoaXMgY29udmVudGlvblxuICAvLyBpcyBJRS4gV2Via2l0IHVzZXMgdGhlIGJvcmRlciBlZGdlLCBPcGVyYSB1c2VzIHRoZSBjb250ZW50IGVkZ2UsIGFuZCBGaXJlRm94IGRvZXNcbiAgLy8gbm90IHN1cHBvcnQgdGhlIHByb3BlcnRpZXMuXG4gIC8vIChzZWUgaHR0cDovL3d3dy5qYWNrbG1vb3JlLmNvbS9ub3Rlcy9tb3VzZS1wb3NpdGlvbi8pXG4gIC8vIEluIHpyIHBhaW50ZXIuZG9tLCBwYWRkaW5nIGVkZ2UgZXF1YWxzIHRvIGJvcmRlciBlZGdlLlxuICAvLyBGSVhNRVxuICAvLyBXaGVuIG1vdXNlbW92ZSBldmVudCB0cmlnZ2VyZWQgb24gZWMgdG9vbHRpcCwgdGFyZ2V0IGlzIG5vdCB6ciBwYWludGVyLmRvbSwgYW5kXG4gIC8vIG9mZnNldFgvWSBpcyByZWxhdGl2ZSB0byBlLnRhcmdldCwgd2hlcmUgdGhlIGNhbGN1bGF0aW9uIG9mIHpyWC9ZIHZpYSBvZmZzZXRYL1lcbiAgLy8gaXMgdG9vIGNvbXBsZXguIFNvIGNzcy10cmFuc2Zyb20gZG9udCBzdXBwb3J0IGluIHRoaXMgY2FzZSB0ZW1wb3JhcmlseS5cblxuICBpZiAoY2FsY3VsYXRlIHx8ICFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCk7XG4gIH0gLy8gQ2F1dGlvbjogSW4gRmlyZUZveCwgbGF5ZXJYL2xheWVyWSBNb3VzZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgY2xvc2VzdCBwb3NpdGlvbmVkXG4gIC8vIGFuY2VzdG9yIGVsZW1lbnQsIHNvIHdlIHNob3VsZCBtYWtlIHN1cmUgZWwgaXMgcG9zaXRpb25lZCAoZS5nLiwgbm90IHBvc2l0aW9uOnN0YXRpYykuXG4gIC8vIEJUVzEsIFdlYmtpdCBkb24ndCByZXR1cm4gdGhlIHNhbWUgcmVzdWx0cyBhcyBGRiBpbiBub24tc2ltcGxlIGNhc2VzIChsaWtlIGFkZFxuICAvLyB6b29tLWZhY3Rvciwgb3ZlcmZsb3cgLyBvcGFjaXR5IGxheWVycywgdHJhbnNmb3JtcyAuLi4pXG4gIC8vIEJUVzIsIChldi5vZmZzZXRZIHx8IGV2LnBhZ2VZIC0gJChldi50YXJnZXQpLm9mZnNldCgpLnRvcCkgaXMgbm90IGNvcnJlY3QgaW4gcHJlc2VydmUtM2QuXG4gIC8vIDxodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvODUyMyNjb21tZW50OjE0PlxuICAvLyBCVFczLCBJbiBmZiwgb2Zmc2V0WC9vZmZzZXRZIGlzIGFsd2F5cyAwLlxuICBlbHNlIGlmIChlbnYuYnJvd3Nlci5maXJlZm94ICYmIGUubGF5ZXJYICE9IG51bGwgJiYgZS5sYXllclggIT09IGUub2Zmc2V0WCkge1xuICAgICAgb3V0LnpyWCA9IGUubGF5ZXJYO1xuICAgICAgb3V0LnpyWSA9IGUubGF5ZXJZO1xuICAgIH0gLy8gRm9yIElFNissIGNocm9tZSwgc2FmYXJpLCBvcGVyYS4gKFdoZW4gd2lsbCBmZiBzdXBwb3J0IG9mZnNldFg/KVxuICAgIGVsc2UgaWYgKGUub2Zmc2V0WCAhPSBudWxsKSB7XG4gICAgICAgIG91dC56clggPSBlLm9mZnNldFg7XG4gICAgICAgIG91dC56clkgPSBlLm9mZnNldFk7XG4gICAgICB9IC8vIEZvciBzb21lIG90aGVyIGRldmljZSwgZS5nLiwgSU9TIHNhZmFyaS5cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpO1xuICAgICAgICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCkge1xuICAvLyBUaGlzIHdlbGwta25vd24gbWV0aG9kIGJlbG93IGRvZXMgbm90IHN1cHBvcnQgY3NzIHRyYW5zZm9ybS5cbiAgdmFyIGJveCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCk7XG4gIG91dC56clggPSBlLmNsaWVudFggLSBib3gubGVmdDtcbiAgb3V0LnpyWSA9IGUuY2xpZW50WSAtIGJveC50b3A7XG59XG4vKipcbiAqIOWmguaenOWtmOWcqOesrOS4ieaWueW1jOWFpeeahOS4gOS6m2RvbeinpuWPkeeahOS6i+S7tu+8jOaIlnRvdWNo5LqL5Lu277yM6ZyA6KaB6L2s5o2i5LiA5LiL5LqL5Lu25Z2Q5qCHLlxuICogYGNhbGN1bGF0ZWAgaXMgb3B0aW9uYWwsIGRlZmF1bHQgZmFsc2UuXG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudChlbCwgZSwgY2FsY3VsYXRlKSB7XG4gIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICBpZiAoZS56clggIT0gbnVsbCkge1xuICAgIHJldHVybiBlO1xuICB9XG5cbiAgdmFyIGV2ZW50VHlwZSA9IGUudHlwZTtcbiAgdmFyIGlzVG91Y2ggPSBldmVudFR5cGUgJiYgZXZlbnRUeXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMDtcblxuICBpZiAoIWlzVG91Y2gpIHtcbiAgICBjbGllbnRUb0xvY2FsKGVsLCBlLCBlLCBjYWxjdWxhdGUpO1xuICAgIGUuenJEZWx0YSA9IGUud2hlZWxEZWx0YSA/IGUud2hlZWxEZWx0YSAvIDEyMCA6IC0oZS5kZXRhaWwgfHwgMCkgLyAzO1xuICB9IGVsc2Uge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50VHlwZSAhPSAndG91Y2hlbmQnID8gZS50YXJnZXRUb3VjaGVzWzBdIDogZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICB0b3VjaCAmJiBjbGllbnRUb0xvY2FsKGVsLCB0b3VjaCwgZSwgY2FsY3VsYXRlKTtcbiAgfSAvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0OyBvdGhlcndpc2U6IDA7XG4gIC8vIFNlZSBqUXVlcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuICAvLyBJZiBlLndoaWNoIGhhcyBiZWVuIGRlZmluZWQsIGlmIG1heSBiZSByZWFkb25seSxcbiAgLy8gc2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC93aGljaFxuXG5cbiAgdmFyIGJ1dHRvbiA9IGUuYnV0dG9uO1xuXG4gIGlmIChlLndoaWNoID09IG51bGwgJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgTU9VU0VfRVZFTlRfUkVHLnRlc3QoZS50eXBlKSkge1xuICAgIGUud2hpY2ggPSBidXR0b24gJiAxID8gMSA6IGJ1dHRvbiAmIDIgPyAzIDogYnV0dG9uICYgNCA/IDIgOiAwO1xuICB9XG5cbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgbmFtZSwgaGFuZGxlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaGFuZGxlcikge1xuICBpZiAoaXNEb21MZXZlbDIpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIGVsLmRldGFjaEV2ZW50KCdvbicgKyBuYW1lLCBoYW5kbGVyKTtcbiAgfVxufVxuLyoqXG4gKiBwcmV2ZW50RGVmYXVsdCBhbmQgc3RvcFByb3BhZ2F0aW9uLlxuICogTm90aWNlOiBkbyBub3QgZG8gdGhhdCBpbiB6cmVuZGVyLiBVcHBlciBhcHBsaWNhdGlvblxuICogZG8gdGhhdCBpZiBuZWNlc3NhcnkuXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvZXZlbnRcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7RXZlbnR9IGUgOiBldmVudOWvueixoVxuICovXG5cblxudmFyIHN0b3AgPSBpc0RvbUxldmVsMiA/IGZ1bmN0aW9uIChlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xufSA6IGZ1bmN0aW9uIChlKSB7XG4gIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xufTtcblxuZnVuY3Rpb24gbm90TGVmdE1vdXNlKGUpIHtcbiAgLy8gSWYgZS53aGljaCBpcyB1bmRlZmluZWQsIGNvbnNpZGVyZWQgYXMgbGVmdCBtb3VzZSBldmVudC5cbiAgcmV0dXJuIGUud2hpY2ggPiAxO1xufSAvLyDlgZrlkJHkuIrlhbzlrrlcblxuXG5leHBvcnRzLmNsaWVudFRvTG9jYWwgPSBjbGllbnRUb0xvY2FsO1xuZXhwb3J0cy5ub3JtYWxpemVFdmVudCA9IG5vcm1hbGl6ZUV2ZW50O1xuZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcbmV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLnN0b3AgPSBzdG9wO1xuZXhwb3J0cy5ub3RMZWZ0TW91c2UgPSBub3RMZWZ0TW91c2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZXZlbnQgPSByZXF1aXJlKFwiLi4vY29yZS9ldmVudFwiKTtcblxudmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBfZXZlbnQuYWRkRXZlbnRMaXN0ZW5lcjtcbnZhciByZW1vdmVFdmVudExpc3RlbmVyID0gX2V2ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXI7XG52YXIgbm9ybWFsaXplRXZlbnQgPSBfZXZlbnQubm9ybWFsaXplRXZlbnQ7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwiLi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi4vY29yZS9lbnZcIik7XG5cbnZhciBHZXN0dXJlTWdyID0gcmVxdWlyZShcIi4uL2NvcmUvR2VzdHVyZU1nclwiKTtcblxudmFyIFRPVUNIX0NMSUNLX0RFTEFZID0gMzAwO1xudmFyIG1vdXNlSGFuZGxlck5hbWVzID0gWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JywgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdjb250ZXh0bWVudSddO1xudmFyIHRvdWNoSGFuZGxlck5hbWVzID0gWyd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSddO1xudmFyIHBvaW50ZXJFdmVudE5hbWVzID0ge1xuICBwb2ludGVyZG93bjogMSxcbiAgcG9pbnRlcnVwOiAxLFxuICBwb2ludGVybW92ZTogMSxcbiAgcG9pbnRlcm91dDogMVxufTtcbnZhciBwb2ludGVySGFuZGxlck5hbWVzID0genJVdGlsLm1hcChtb3VzZUhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIG5tID0gbmFtZS5yZXBsYWNlKCdtb3VzZScsICdwb2ludGVyJyk7XG4gIHJldHVybiBwb2ludGVyRXZlbnROYW1lc1tubV0gPyBubSA6IG5hbWU7XG59KTtcblxuZnVuY3Rpb24gZXZlbnROYW1lRml4KG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUgPT09ICdtb3VzZXdoZWVsJyAmJiBlbnYuYnJvd3Nlci5maXJlZm94ID8gJ0RPTU1vdXNlU2Nyb2xsJyA6IG5hbWU7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NHZXN0dXJlKHByb3h5LCBldmVudCwgc3RhZ2UpIHtcbiAgdmFyIGdlc3R1cmVNZ3IgPSBwcm94eS5fZ2VzdHVyZU1ncjtcbiAgc3RhZ2UgPT09ICdzdGFydCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuICB2YXIgZ2VzdHVyZUluZm8gPSBnZXN0dXJlTWdyLnJlY29nbml6ZShldmVudCwgcHJveHkuaGFuZGxlci5maW5kSG92ZXIoZXZlbnQuenJYLCBldmVudC56clksIG51bGwpLnRhcmdldCwgcHJveHkuZG9tKTtcbiAgc3RhZ2UgPT09ICdlbmQnICYmIGdlc3R1cmVNZ3IuY2xlYXIoKTsgLy8gRG8gbm90IGRvIGFueSBwcmV2ZW50RGVmYXVsdCBoZXJlLiBVcHBlciBhcHBsaWNhdGlvbiBkbyB0aGF0IGlmIG5lY2Vzc2FyeS5cblxuICBpZiAoZ2VzdHVyZUluZm8pIHtcbiAgICB2YXIgdHlwZSA9IGdlc3R1cmVJbmZvLnR5cGU7XG4gICAgZXZlbnQuZ2VzdHVyZUV2ZW50ID0gdHlwZTtcbiAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KHtcbiAgICAgIHRhcmdldDogZ2VzdHVyZUluZm8udGFyZ2V0XG4gICAgfSwgdHlwZSwgZ2VzdHVyZUluZm8uZXZlbnQpO1xuICB9XG59IC8vIGZ1bmN0aW9uIG9uTVNHZXN0dXJlQ2hhbmdlKHByb3h5LCBldmVudCkge1xuLy8gICAgIGlmIChldmVudC50cmFuc2xhdGlvblggfHwgZXZlbnQudHJhbnNsYXRpb25ZKSB7XG4vLyAgICAgICAgIC8vIG1vdXNlbW92ZSBpcyBjYXJyaWVkIGJ5IE1TR2VzdHVyZSB0byByZWR1Y2UgdGhlIHNlbnNpdGl2aXR5LlxuLy8gICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGV2ZW50LnRhcmdldCwgJ21vdXNlbW92ZScsIGV2ZW50KTtcbi8vICAgICB9XG4vLyAgICAgaWYgKGV2ZW50LnNjYWxlICE9PSAxKSB7XG4vLyAgICAgICAgIGV2ZW50LnBpbmNoWCA9IGV2ZW50Lm9mZnNldFg7XG4vLyAgICAgICAgIGV2ZW50LnBpbmNoWSA9IGV2ZW50Lm9mZnNldFk7XG4vLyAgICAgICAgIGV2ZW50LnBpbmNoU2NhbGUgPSBldmVudC5zY2FsZTtcbi8vICAgICAgICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudChldmVudC50YXJnZXQsICdwaW5jaCcsIGV2ZW50KTtcbi8vICAgICB9XG4vLyB9XG5cbi8qKlxuICogUHJldmVudCBtb3VzZSBldmVudCBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgYWZ0ZXIgVG91Y2ggRXZlbnRzIGFjdGlvblxuICogQHNlZSA8aHR0cHM6Ly9naXRodWIuY29tL2RlbHRha29zaC9oYW5kanMvYmxvYi9tYXN0ZXIvc3JjL2hhbmQuYmFzZS5qcz5cbiAqIDEuIE1vYmlsZSBicm93c2VycyBkaXNwYXRjaCBtb3VzZSBldmVudHMgMzAwbXMgYWZ0ZXIgdG91Y2hlbmQuXG4gKiAyLiBDaHJvbWUgZm9yIEFuZHJvaWQgZGlzcGF0Y2ggbW91c2Vkb3duIGZvciBsb25nLXRvdWNoIGFib3V0IDY1MG1zXG4gKiBSZXN1bHQ6IEJsb2NraW5nIE1vdXNlIEV2ZW50cyBmb3IgNzAwbXMuXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRUb3VjaFRpbWVyKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLl90b3VjaGluZyA9IHRydWU7XG4gIGNsZWFyVGltZW91dChpbnN0YW5jZS5fdG91Y2hUaW1lcik7XG4gIGluc3RhbmNlLl90b3VjaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaW5zdGFuY2UuX3RvdWNoaW5nID0gZmFsc2U7XG4gIH0sIDcwMCk7XG59XG5cbnZhciBkb21IYW5kbGVycyA9IHtcbiAgLyoqXG4gICAqIE1vdXNlIG1vdmUgaGFuZGxlclxuICAgKiBAaW5uZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuICAgIHRoaXMudHJpZ2dlcignbW91c2Vtb3ZlJywgZXZlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3VzZSBvdXQgaGFuZGxlclxuICAgKiBAaW5uZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldDtcblxuICAgIGlmIChlbGVtZW50ICE9IHRoaXMuZG9tKSB7XG4gICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9IDkpIHtcbiAgICAgICAgLy8g5b+955Wl5YyF5ZCr5Zyocm9vdOS4reeahGRvbeW8lei1t+eahG1vdXNlT3V0XG4gICAgICAgIGlmIChlbGVtZW50ID09PSB0aGlzLmRvbSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyKCdtb3VzZW91dCcsIGV2ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogVG91Y2jlvIDlp4vlk43lupTlh73mlbBcbiAgICogQGlubmVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICB0b3VjaHN0YXJ0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBEZWZhdWx0IG1vdXNlIGJlaGF2aW91ciBzaG91bGQgbm90IGJlIGRpc2FibGVkIGhlcmUuXG4gICAgLy8gRm9yIGV4YW1wbGUsIHBhZ2UgbWF5IG5lZWRzIHRvIGJlIHNsaWRlZC5cbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7IC8vIE1hcmsgdG91Y2gsIHdoaWNoIGlzIHVzZWZ1bCBpbiBkaXN0aW5ndWlzaCB0b3VjaCBhbmRcbiAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cblxuICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG4gICAgdGhpcy5fbGFzdFRvdWNoTW9tZW50ID0gbmV3IERhdGUoKTtcbiAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ3N0YXJ0Jyk7IC8vIEluIHRvdWNoIGRldmljZSwgdHJpZ2dlciBgbW91c2Vtb3ZlYChgbW91c2VvdmVyYCkgc2hvdWxkXG4gICAgLy8gYmUgdHJpZ2dlcmVkLCBhbmQgbXVzdCBiZWZvcmUgYG1vdXNlZG93bmAgdHJpZ2dlcmVkLlxuXG4gICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIGRvbUhhbmRsZXJzLm1vdXNlZG93bi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb3VjaOenu+WKqOWTjeW6lOWHveaVsFxuICAgKiBAaW5uZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpOyAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG5cbiAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnY2hhbmdlJyk7IC8vIE1vdXNlIG1vdmUgc2hvdWxkIGFsd2F5cyBiZSB0cmlnZ2VyZWQgbm8gbWF0dGVyIHdoZXRoZXJcbiAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LCBiZWNhdXNlIG1vdXNlIG1vdmUgYW5kIHBpbmNoIG1heVxuICAgIC8vIGJlIHVzZWQgYXQgdGhlIHNhbWUgdGltZS5cblxuICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb3VjaOe7k+adn+WTjeW6lOWHveaVsFxuICAgKiBAaW5uZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIHRvdWNoZW5kOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7IC8vIE1hcmsgdG91Y2gsIHdoaWNoIGlzIHVzZWZ1bCBpbiBkaXN0aW5ndWlzaCB0b3VjaCBhbmRcbiAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cblxuICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG4gICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdlbmQnKTtcbiAgICBkb21IYW5kbGVycy5tb3VzZXVwLmNhbGwodGhpcywgZXZlbnQpOyAvLyBEbyBub3QgdHJpZ2dlciBgbW91c2VvdXRgIGhlcmUsIGluIHNwaXRlIG9mIGBtb3VzZW1vdmVgKGBtb3VzZW92ZXJgKSBpc1xuICAgIC8vIHRyaWdnZXJlZCBpbiBgdG91Y2hzdGFydGAuIFRoaXMgc2VlbXMgdG8gYmUgaWxsb2dpY2FsLCBidXQgYnkgdGhpcyBtZWNoYW5pc20sXG4gICAgLy8gd2UgY2FuIGNvbnZlbmllbnRseSBpbXBsZW1lbnQgXCJob3ZlciBzdHlsZVwiIGluIGJvdGggUEMgYW5kIHRvdWNoIGRldmljZSBqdXN0XG4gICAgLy8gYnkgbGlzdGVuaW5nIHRvIGBtb3VzZW92ZXJgIHRvIGFkZCBcImhvdmVyIHN0eWxlXCIgYW5kIGxpc3RlbmluZyB0byBgbW91c2VvdXRgXG4gICAgLy8gdG8gcmVtb3ZlIFwiaG92ZXIgc3R5bGVcIiBvbiBhbiBlbGVtZW50LCB3aXRob3V0IGFueSBhZGRpdGlvbmFsIGNvZGUgZm9yXG4gICAgLy8gY29tcGF0aWJpbGl0eS4gKGBtb3VzZW91dGAgd2lsbCBub3QgYmUgdHJpZ2dlcmVkIGluIGB0b3VjaGVuZGAsIHNvIFwiaG92ZXJcbiAgICAvLyBzdHlsZVwiIHdpbGwgcmVtYWluIGZvciB1c2VyIHZpZXcpXG4gICAgLy8gY2xpY2sgZXZlbnQgc2hvdWxkIGFsd2F5cyBiZSB0cmlnZ2VyZWQgbm8gbWF0dGVyIHdoZXRoZXJcbiAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LiBTeXN0ZW0gY2xpY2sgY2FuIG5vdCBiZSBwcmV2ZW50ZWQuXG5cbiAgICBpZiAoK25ldyBEYXRlKCkgLSB0aGlzLl9sYXN0VG91Y2hNb21lbnQgPCBUT1VDSF9DTElDS19ERUxBWSkge1xuICAgICAgZG9tSGFuZGxlcnMuY2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuXG4gICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgfSxcbiAgcG9pbnRlcmRvd246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGRvbUhhbmRsZXJzLm1vdXNlZG93bi5jYWxsKHRoaXMsIGV2ZW50KTsgLy8gaWYgKHVzZU1TR3Vlc3R1cmUodGhpcywgZXZlbnQpKSB7XG4gICAgLy8gICAgIHRoaXMuX21zR2VzdHVyZS5hZGRQb2ludGVyKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgLy8gfVxuICB9LFxuICBwb2ludGVybW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gRklYTUVcbiAgICAvLyBwb2ludGVybW92ZSBpcyBzbyBzZW5zaXRpdmUgdGhhdCBpdCBhbHdheXMgdHJpZ2dlcmVkIHdoZW5cbiAgICAvLyB0YXAoY2xpY2spIG9uIHRvdWNoIHNjcmVlbiwgd2hpY2ggYWZmZWN0IHNvbWUganVkZ2VtZW50IGluXG4gICAgLy8gdXBwZXIgYXBwbGljYXRpb24uIFNvLCB3ZSBkb250IHN1cHBvcnQgbW91c2Vtb3ZlIG9uIE1TIHRvdWNoXG4gICAgLy8gZGV2aWNlIHlldC5cbiAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIHBvaW50ZXJ1cDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZG9tSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfSxcbiAgcG9pbnRlcm91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gcG9pbnRlcm91dCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRhcCBvbiB0b3VjaCBzY3JlZW5cbiAgICAvLyAoSUUxMSsvRWRnZSBvbiBNUyBTdXJmYWNlKSBhZnRlciBjbGljayBldmVudCB0cmlnZ2VyZWQsXG4gICAgLy8gd2hpY2ggaXMgaW5jb25zaXN0ZW50IHdpdGggdGhlIG1vdXNvdXQgYmVoYXZpb3Igd2UgZGVmaW5lZFxuICAgIC8vIGluIHRvdWNoZW5kLiBTbyB3ZSB1bmlmeSB0aGVtLlxuICAgIC8vIChjaGVjayBkb21IYW5kbGVycy50b3VjaGVuZCBmb3IgZGV0YWlsZWQgZXhwbGFuYXRpb24pXG4gICAgaWYgKCFpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpKSB7XG4gICAgICBkb21IYW5kbGVycy5tb3VzZW91dC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzUG9pbnRlckZyb21Ub3VjaChldmVudCkge1xuICB2YXIgcG9pbnRlclR5cGUgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgcmV0dXJuIHBvaW50ZXJUeXBlID09PSAncGVuJyB8fCBwb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcbn0gLy8gZnVuY3Rpb24gdXNlTVNHdWVzdHVyZShoYW5kbGVyUHJveHksIGV2ZW50KSB7XG4vLyAgICAgcmV0dXJuIGlzUG9pbnRlckZyb21Ub3VjaChldmVudCkgJiYgISFoYW5kbGVyUHJveHkuX21zR2VzdHVyZTtcbi8vIH1cbi8vIENvbW1vbiBoYW5kbGVyc1xuXG5cbnpyVXRpbC5lYWNoKFsnY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2V3aGVlbCcsICdkYmxjbGljaycsICdjb250ZXh0bWVudSddLCBmdW5jdGlvbiAobmFtZSkge1xuICBkb21IYW5kbGVyc1tuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICB0aGlzLnRyaWdnZXIobmFtZSwgZXZlbnQpO1xuICB9O1xufSk7XG4vKipcbiAqIOS4uuaOp+WItuexu+WunuS+i+WIneWni+WMlmRvbSDkuovku7blpITnkIblh73mlbBcbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvSGFuZGxlcn0gaW5zdGFuY2Ug5o6n5Yi257G75a6e5L6LXG4gKi9cblxuZnVuY3Rpb24gaW5pdERvbUhhbmRsZXIoaW5zdGFuY2UpIHtcbiAgenJVdGlsLmVhY2godG91Y2hIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdID0genJVdGlsLmJpbmQoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgfSk7XG4gIHpyVXRpbC5lYWNoKHBvaW50ZXJIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdID0genJVdGlsLmJpbmQoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgfSk7XG4gIHpyVXRpbC5lYWNoKG1vdXNlSGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IG1ha2VNb3VzZUhhbmRsZXIoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gbWFrZU1vdXNlSGFuZGxlcihmbiwgaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGluc3RhbmNlLl90b3VjaGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbi5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIEhhbmRsZXJEb21Qcm94eShkb20pIHtcbiAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcbiAgdGhpcy5kb20gPSBkb207XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG5cbiAgdGhpcy5fdG91Y2hpbmcgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuX3RvdWNoVGltZXI7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9HZXN0dXJlTWdyfVxuICAgKi9cblxuICB0aGlzLl9nZXN0dXJlTWdyID0gbmV3IEdlc3R1cmVNZ3IoKTtcbiAgdGhpcy5faGFuZGxlcnMgPSB7fTtcbiAgaW5pdERvbUhhbmRsZXIodGhpcyk7XG5cbiAgaWYgKGVudi5wb2ludGVyRXZlbnRzU3VwcG9ydGVkKSB7XG4gICAgLy8gT25seSBJRTExKy9FZGdlXG4gICAgLy8gMS4gT24gZGV2aWNlcyB0aGF0IGJvdGggZW5hYmxlIHRvdWNoIGFuZCBtb3VzZSAoZS5nLiwgTVMgU3VyZmFjZSBhbmQgbGVub3ZvIFgyNDApLFxuICAgIC8vIElFMTErL0VkZ2UgZG8gbm90IHRyaWdnZXIgdG91Y2ggZXZlbnQsIGJ1dCB0cmlnZ2VyIHBvaW50ZXIgZXZlbnQgYW5kIG1vdXNlIGV2ZW50XG4gICAgLy8gYXQgdGhlIHNhbWUgdGltZS5cbiAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBpdCBwcm9iYWJsZWx5IG9ubHkgdHJpZ2dlciBtb3VzZWRvd24gYnV0IG5vIG1vdXNldXAgd2hlbiB0YXAgb25cbiAgICAvLyBzY3JlZW4sIHdoaWNoIGRvIG5vdCBvY2N1cnMgaW4gcG9pbnRlciBldmVudC5cbiAgICAvLyBTbyB3ZSB1c2UgcG9pbnRlciBldmVudCB0byBib3RoIGRldGVjdCB0b3VjaCBnZXN0dXJlIGFuZCBtb3VzZSBiZWhhdmlvci5cbiAgICBtb3VudEhhbmRsZXJzKHBvaW50ZXJIYW5kbGVyTmFtZXMsIHRoaXMpOyAvLyBGSVhNRVxuICAgIC8vIE5vdGU6IE1TIEdlc3R1cmUgcmVxdWlyZSBDU1MgdG91Y2gtYWN0aW9uIHNldC4gQnV0IHRvdWNoLWFjdGlvbiBpcyBub3QgcmVsaWFibGUsXG4gICAgLy8gd2hpY2ggZG9lcyBub3QgcHJldmVudCBkZWZ1YXVsdCBiZWhhdmlvciBvY2Nhc2lvbmFsbHkgKHdoaWNoIG1heSBjYXVzZSB2aWV3IHBvcnRcbiAgICAvLyB6b29tZWQgaW4gYnV0IHVzZSBjYW4gbm90IHpvb20gaXQgYmFjaykuIEFuZCBldmVudC5wcmV2ZW50RGVmYXVsdCgpIGRvZXMgbm90IHdvcmsuXG4gICAgLy8gU28gd2UgaGF2ZSB0byBub3QgdG8gdXNlIE1TR2VzdHVyZSBhbmQgbm90IHRvIHN1cHBvcnQgdG91Y2htb3ZlIGFuZCBwaW5jaCBvbiBNU1xuICAgIC8vIHRvdWNoIHNjcmVlbi4gQW5kIHdlIG9ubHkgc3VwcG9ydCBjbGljayBiZWhhdmlvciBvbiBNUyB0b3VjaCBzY3JlZW4gbm93LlxuICAgIC8vIE1TIEdlc3R1cmUgRXZlbnQgaXMgb25seSBzdXBwb3J0ZWQgb24gSUUxMSsvRWRnZSBhbmQgb24gV2luZG93cyA4Ky5cbiAgICAvLyBXZSBkb250IHN1cHBvcnQgdG91Y2ggb24gSUUgb24gd2luNy5cbiAgICAvLyBTZWUgPGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDModj12cy44NSkuYXNweD5cbiAgICAvLyBpZiAodHlwZW9mIE1TR2VzdHVyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICAgICAodGhpcy5fbXNHZXN0dXJlID0gbmV3IE1TR2VzdHVyZSgpKS50YXJnZXQgPSBkb207IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIC8vICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignTVNHZXN0dXJlQ2hhbmdlJywgb25NU0dlc3R1cmVDaGFuZ2UpO1xuICAgIC8vIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW52LnRvdWNoRXZlbnRzU3VwcG9ydGVkKSB7XG4gICAgICBtb3VudEhhbmRsZXJzKHRvdWNoSGFuZGxlck5hbWVzLCB0aGlzKTsgLy8gSGFuZGxlciBvZiAnbW91c2VvdXQnIGV2ZW50IGlzIG5lZWRlZCBpbiB0b3VjaCBtb2RlLCB3aGljaCB3aWxsIGJlIG1vdW50ZWQgYmVsb3cuXG4gICAgICAvLyBhZGRFdmVudExpc3RlbmVyKHJvb3QsICdtb3VzZW91dCcsIHRoaXMuX21vdXNlb3V0SGFuZGxlcik7XG4gICAgfSAvLyAxLiBDb25zaWRlcmluZyBzb21lIGRldmljZXMgdGhhdCBib3RoIGVuYWJsZSB0b3VjaCBhbmQgbW91c2UgZXZlbnQgKGxpa2Ugb24gTVMgU3VyZmFjZVxuICAgIC8vIGFuZCBsZW5vdm8gWDI0MCwgQHNlZSAjMjM1MCksIHdlIG1ha2UgbW91c2UgZXZlbnQgYmUgYWx3YXlzIGxpc3RlbmVkLCBvdGhlcndpc2VcbiAgICAvLyBtb3VzZSBldmVudCBjYW4gbm90IGJlIGhhbmRsZSBpbiB0aG9zZSBkZXZpY2VzLlxuICAgIC8vIDIuIE9uIE1TIFN1cmZhY2UsIENocm9tZSB3aWxsIHRyaWdnZXIgYm90aCB0b3VjaCBldmVudCBhbmQgbW91c2UgZXZlbnQuIEhvdyB0byBwcmV2ZW50XG4gICAgLy8gbW91c2VldmVudCBhZnRlciB0b3VjaCBldmVudCB0cmlnZ2VyZWQsIHNlZSBgc2V0VG91Y2hUaW1lcmAuXG5cblxuICAgIG1vdW50SGFuZGxlcnMobW91c2VIYW5kbGVyTmFtZXMsIHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRIYW5kbGVycyhoYW5kbGVyTmFtZXMsIGluc3RhbmNlKSB7XG4gICAgenJVdGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihkb20sIGV2ZW50TmFtZUZpeChuYW1lKSwgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdKTtcbiAgICB9LCBpbnN0YW5jZSk7XG4gIH1cbn1cblxudmFyIGhhbmRsZXJEb21Qcm94eVByb3RvID0gSGFuZGxlckRvbVByb3h5LnByb3RvdHlwZTtcblxuaGFuZGxlckRvbVByb3h5UHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhhbmRsZXJOYW1lcyA9IG1vdXNlSGFuZGxlck5hbWVzLmNvbmNhdCh0b3VjaEhhbmRsZXJOYW1lcyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IGhhbmRsZXJOYW1lc1tpXTtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuZG9tLCBldmVudE5hbWVGaXgobmFtZSksIHRoaXMuX2hhbmRsZXJzW25hbWVdKTtcbiAgfVxufTtcblxuaGFuZGxlckRvbVByb3h5UHJvdG8uc2V0Q3Vyc29yID0gZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gIHRoaXMuZG9tLnN0eWxlLmN1cnNvciA9IGN1cnNvclN0eWxlIHx8ICdkZWZhdWx0Jztcbn07XG5cbnpyVXRpbC5taXhpbihIYW5kbGVyRG9tUHJveHksIEV2ZW50ZnVsKTtcbnZhciBfZGVmYXVsdCA9IEhhbmRsZXJEb21Qcm94eTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBldmVudFV0aWwgPSByZXF1aXJlKFwiLi9ldmVudFwiKTtcblxuLyoqXG4gKiBPbmx5IGltcGxlbWVudHMgbmVlZGVkIGdlc3R1cmVzIGZvciBtb2JpbGUuXG4gKi9cbnZhciBHZXN0dXJlTWdyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgKi9cbiAgdGhpcy5fdHJhY2sgPSBbXTtcbn07XG5cbkdlc3R1cmVNZ3IucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogR2VzdHVyZU1ncixcbiAgcmVjb2duaXplOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCwgcm9vdCkge1xuICAgIHRoaXMuX2RvVHJhY2soZXZlbnQsIHRhcmdldCwgcm9vdCk7XG5cbiAgICByZXR1cm4gdGhpcy5fcmVjb2duaXplKGV2ZW50KTtcbiAgfSxcbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl90cmFjay5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfZG9UcmFjazogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XG5cbiAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2tJdGVtID0ge1xuICAgICAgcG9pbnRzOiBbXSxcbiAgICAgIHRvdWNoZXM6IFtdLFxuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBldmVudDogZXZlbnRcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRvdWNoZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG4gICAgICB2YXIgcG9zID0gZXZlbnRVdGlsLmNsaWVudFRvTG9jYWwocm9vdCwgdG91Y2gsIHt9KTtcbiAgICAgIHRyYWNrSXRlbS5wb2ludHMucHVzaChbcG9zLnpyWCwgcG9zLnpyWV0pO1xuICAgICAgdHJhY2tJdGVtLnRvdWNoZXMucHVzaCh0b3VjaCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdHJhY2sucHVzaCh0cmFja0l0ZW0pO1xuICB9LFxuICBfcmVjb2duaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcmVjb2duaXplcnMpIHtcbiAgICAgIGlmIChyZWNvZ25pemVycy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IHJlY29nbml6ZXJzW2V2ZW50TmFtZV0odGhpcy5fdHJhY2ssIGV2ZW50KTtcblxuICAgICAgICBpZiAoZ2VzdHVyZUluZm8pIHtcbiAgICAgICAgICByZXR1cm4gZ2VzdHVyZUluZm87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRpc3QocG9pbnRQYWlyKSB7XG4gIHZhciBkeCA9IHBvaW50UGFpclsxXVswXSAtIHBvaW50UGFpclswXVswXTtcbiAgdmFyIGR5ID0gcG9pbnRQYWlyWzFdWzFdIC0gcG9pbnRQYWlyWzBdWzFdO1xuICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbn1cblxuZnVuY3Rpb24gY2VudGVyKHBvaW50UGFpcikge1xuICByZXR1cm4gWyhwb2ludFBhaXJbMF1bMF0gKyBwb2ludFBhaXJbMV1bMF0pIC8gMiwgKHBvaW50UGFpclswXVsxXSArIHBvaW50UGFpclsxXVsxXSkgLyAyXTtcbn1cblxudmFyIHJlY29nbml6ZXJzID0ge1xuICBwaW5jaDogZnVuY3Rpb24gKHRyYWNrLCBldmVudCkge1xuICAgIHZhciB0cmFja0xlbiA9IHRyYWNrLmxlbmd0aDtcblxuICAgIGlmICghdHJhY2tMZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGluY2hFbmQgPSAodHJhY2tbdHJhY2tMZW4gLSAxXSB8fCB7fSkucG9pbnRzO1xuICAgIHZhciBwaW5jaFByZSA9ICh0cmFja1t0cmFja0xlbiAtIDJdIHx8IHt9KS5wb2ludHMgfHwgcGluY2hFbmQ7XG5cbiAgICBpZiAocGluY2hQcmUgJiYgcGluY2hQcmUubGVuZ3RoID4gMSAmJiBwaW5jaEVuZCAmJiBwaW5jaEVuZC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgcGluY2hTY2FsZSA9IGRpc3QocGluY2hFbmQpIC8gZGlzdChwaW5jaFByZSk7XG4gICAgICAhaXNGaW5pdGUocGluY2hTY2FsZSkgJiYgKHBpbmNoU2NhbGUgPSAxKTtcbiAgICAgIGV2ZW50LnBpbmNoU2NhbGUgPSBwaW5jaFNjYWxlO1xuICAgICAgdmFyIHBpbmNoQ2VudGVyID0gY2VudGVyKHBpbmNoRW5kKTtcbiAgICAgIGV2ZW50LnBpbmNoWCA9IHBpbmNoQ2VudGVyWzBdO1xuICAgICAgZXZlbnQucGluY2hZID0gcGluY2hDZW50ZXJbMV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAncGluY2gnLFxuICAgICAgICB0YXJnZXQ6IHRyYWNrWzBdLnRhcmdldCxcbiAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBPbmx5IHBpbmNoIGN1cnJlbnRseS5cblxufTtcbnZhciBfZGVmYXVsdCA9IEdlc3R1cmVNZ3I7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKi9cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1wiKTtcclxuICAgIHZhciBCUE1OTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvQlBNTk5vZGUuanNcIik7XHJcbiAgICB2YXIgQlBNTk1vZGVsID0gcmVxdWlyZShcIi4vbW9kZWwvQlBNTk1vZGVsLmpzXCIpO1xyXG4gICAgdmFyIFN0YXJ0RXZlbnROb2RlID0gcmVxdWlyZShcIi4vbm9kZS9ldmVudC9TdGFydEV2ZW50Tm9kZVwiKTtcclxuICAgIHZhciBFbmRFdmVudE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL2V2ZW50L0VuZEV2ZW50Tm9kZVwiKTtcclxuICAgIHZhciBVc2VyVGFza05vZGUgPSByZXF1aXJlKFwiLi9ub2RlL3Rhc2svVXNlclRhc2tOb2RlXCIpO1xyXG4gICAgdmFyIE1hbnVhbFRhc2tOb2RlID0gcmVxdWlyZShcIi4vbm9kZS90YXNrL01hbnVhbFRhc2tOb2RlXCIpO1xyXG4gICAgdmFyIFNjcmlwdFRhc2tOb2RlID0gcmVxdWlyZShcIi4vbm9kZS90YXNrL1NjcmlwdFRhc2tOb2RlXCIpO1xyXG4gICAgdmFyIE1haWxUYXNrTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvdGFzay9NYWlsVGFza05vZGVcIik7XHJcbiAgICB2YXIgU2VydmljZVRhc2tOb2RlID0gcmVxdWlyZShcIi4vbm9kZS90YXNrL1NlcnZpY2VUYXNrTm9kZVwiKTtcclxuICAgIHZhciBTbXNUYXNrTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvdGFzay9TbXNUYXNrTm9kZVwiKTtcclxuICAgIHZhciBDb21tZW50Tm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvQ29tbWVudE5vZGVcIik7XHJcbiAgICB2YXIgQ2F0Y2hUaW1lckV2ZW50Tm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvZXZlbnQvYm91bmRhcnlldmVudC9DYXRjaFRpbWVyRXZlbnROb2RlXCIpO1xyXG4gICAgdmFyIENhdGNoU2lnbmFsRXZlbnROb2RlID0gcmVxdWlyZShcIi4vbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L0NhdGNoU2lnbmFsRXZlbnROb2RlXCIpO1xyXG4gICAgdmFyIFRocm93U2lnbmFsRXZlbnROb2RlID0gcmVxdWlyZShcIi4vbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L1Rocm93U2lnbmFsRXZlbnROb2RlXCIpO1xyXG4gICAgdmFyIENhdGNoTWVzc2FnZUV2ZW50Tm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvZXZlbnQvQ2F0Y2hNZXNzYWdlRXZlbnROb2RlXCIpO1xyXG4gICAgdmFyIEluY2x1c2l2ZUdhdGV3YXlOb2RlID0gcmVxdWlyZShcIi4vbm9kZS9nYXRld2F5L0luY2x1c2l2ZUdhdGV3YXlOb2RlXCIpO1xyXG4gICAgdmFyIEV4Y2x1c2l2ZUdhdGV3YXlOb2RlID0gcmVxdWlyZShcIi4vbm9kZS9nYXRld2F5L0V4Y2x1c2l2ZUdhdGV3YXlOb2RlXCIpO1xyXG4gICAgdmFyIFBhcmFsbGVsR2F0ZXdheU5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL2dhdGV3YXkvUGFyYWxsZWxHYXRld2F5Tm9kZVwiKTtcclxuICAgIHZhciBTdWJQcmNlc3NOb2RlID0gcmVxdWlyZShcIi4vbm9kZS9TdWJQcm9jZXNzTm9kZVwiKTtcclxuICAgIHZhciBCcG1uID0gcmVxdWlyZShcIi4vQnBtbi5qc1wiKTtcclxuICAgIC8qKlxyXG4gICAgICog5qC55o2u57uT54K55pWw57uEIOWvvOWHukpTT07moLzlvI/nmoTmlbDmja5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBub2RlcyDnu5PngrnmlbDnu4RcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBicG1uTW9kZWwgYnBtbueahG1vZGVsXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25uZWN0b3JzIOaJgOaciei/nue6v1xyXG4gICAgICogQHJldHVybiB7SlNPTn0gSlNPTuagvOW8j+eahOaVsOaNrlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0pzb24oYnBtbk1vZGVsLCBub2RlcywgY29ubmVjdG9ycykge1xyXG4gICAgICAgIHZhciBqc29uQXJyID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAvL+WOu+aOieWtkOa1geeoi+mHjOmdoueahOiKgueCuVxyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3Mobm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggbm9kZSAmJiBub2RlLnRvSlNPTikge1xyXG4gICAgICAgICAgICAgICAganNvbkFyci5wdXNoKG5vZGUudG9KU09OKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5aKe5Yqg57q/XHJcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGNvbm5lY3RvcnMubGVuZ3RoO2orKyl7XHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3IgPSBjb25uZWN0b3JzW2pdO1xyXG4gICAgICAgICAgICAvL+WOu+aOieWtkOa1geeoi+mHjOmdoueahOe6v+autVxyXG4gICAgICAgICAgICBpZiAoY29ubmVjdG9yLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhjb25uZWN0b3IucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIGNvbm5lY3RvciAmJiBjb25uZWN0b3IudG9KU09OKSB7XHJcbiAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2goY29ubmVjdG9yLnRvSlNPTigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBicG1uTW9kZWwuc2V0KFwiY2hpbGRTaGFwZXNcIiwganNvbkFycik7XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gYnBtbk1vZGVsLm9wdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNriBKU09OIOeUn+aIkOiKgueCuVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBmaXNoVG9wb0JwbW4gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBqc29uICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tSnNvbihmaXNoVG9wb0JwbW4sIGpzb24pIHtcclxuICAgICAgICAvLyAxLua4heepuueUu+W4g1xyXG4gICAgICAgIGZpc2hUb3BvQnBtbi5jbGVhcih0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gMi7lhYjliJvlu7roioLngrkgIOmBjeWOhuW9oueKtiDojrflj5bmqKHlnotcclxuICAgICAgICB2YXIgYnBtbk1vZGVsID0gbmV3IEJQTU5Nb2RlbChqc29uKTtcclxuXHJcbiAgICAgICAgZmlzaFRvcG9CcG1uLm1vZGVsID0gYnBtbk1vZGVsO1xyXG5cclxuICAgICAgICB2YXIgYnBtbldpZHRoID0gYnBtbk1vZGVsLmdldChcInByb3BlcnRpZXMud2lkdGhcIik7XHJcbiAgICAgICAgdmFyIGJwbW5IZWlnaHQgPSBicG1uTW9kZWwuZ2V0KFwicHJvcGVydGllcy5oZWlnaHRcIik7XHJcbiAgICAgICAgaWYgKGJwbW5XaWR0aCA+IDAgJiYgYnBtbkhlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgZmlzaFRvcG9CcG1uLnJlc2l6ZShicG1uV2lkdGgsYnBtbkhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGxvb3BBZGRTdWJOb2RlKG5vZGUsIG1vZGVsKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBCcG1uLlNVQl9QUk9DRVNTKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ViU2hhcGVzID0gbW9kZWwuZ2V0KFwiY2hpbGRTaGFwZXNcIik7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1YlNoYXBlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJNb2RlbCA9IG5ldyBCUE1OTW9kZWwoc3ViU2hhcGVzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihCcG1uLmlzRmxvd01vZGVsKHN1Yk1vZGVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXNoVG9wb0JwbW4uYWRkQ29ubmVjdG9yQnlNb2RlbChzdWJNb2RlbCwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1cGVyVXBwZXJMZWZ0ID0gbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YlVwcGVyTGVmdCA9IHN1Yk1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJMb3dlclJpZ2h0ID0gc3ViTW9kZWwuZ2V0KFwiYm91bmRzLmxvd2VyUmlnaHRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGVsLnNldChcImJvdW5kcy51cHBlckxlZnRcIiwgeyB4OiBzdWJVcHBlckxlZnQueCArIHN1cGVyVXBwZXJMZWZ0LngsIHk6IHN1YlVwcGVyTGVmdC55ICsgc3VwZXJVcHBlckxlZnQueSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZWwuc2V0KFwiYm91bmRzLmxvd2VyUmlnaHRcIiwgeyB4OiBzdWJMb3dlclJpZ2h0LnggKyBzdXBlclVwcGVyTGVmdC54LCB5OiBzdWJMb3dlclJpZ2h0LnkgKyBzdXBlclVwcGVyTGVmdC55IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ViTm9kZSA9IGZpc2hUb3BvQnBtbi5hZGROb2RlQnlNb2RlbChzdWJNb2RlbCx0cnVlLHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb29wQWRkU3ViTm9kZShzdWJOb2RlLCBzdWJNb2RlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjaGlsZFNoYXBlcyA9IGJwbW5Nb2RlbC5nZXQoXCJjaGlsZFNoYXBlc1wiKTtcclxuICAgICAgICB2YXIgY29ubmVjdG9ycyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRTaGFwZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gY2hpbGRTaGFwZXNbaV07XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gc2hhcGUuc3RlbmNpbC50eXBlO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gQnBtbi5TRVFVRU5DRV9GTE9XKSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3JzLnB1c2goc2hhcGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGVsID0gbmV3IEJQTU5Nb2RlbChzaGFwZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3JlYXRlZE5vZGUgPSBmaXNoVG9wb0JwbW4uYWRkTm9kZUJ5TW9kZWwobW9kZWwsZmFsc2UsdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBsb29wQWRkU3ViTm9kZShjcmVhdGVkTm9kZSwgbW9kZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuIOWGjeWIm+W7uue6v1xyXG4gICAgICAgIGZvcih2YXIgayA9IDAsIGxlbiA9IGNvbm5lY3RvcnMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcclxuICAgICAgICAgICAgdmFyIG1vZGVsTGluZSA9IG5ldyBCUE1OTW9kZWwoY29ubmVjdG9yc1trXSk7IC8vIHNoYXBlXHJcbiAgICAgICAgICAgIGZpc2hUb3BvQnBtbi5hZGRDb25uZWN0b3JCeU1vZGVsKG1vZGVsTGluZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyA0LuWIm+W7uuS6i+S7tuaPkuanvVxyXG4gICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgY2hpbGRTaGFwZXMubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkU2hhcGVzW21dLnByb3BlcnRpZXMuc2xvdEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIG4gPSAwO24gPCBjaGlsZFNoYXBlc1ttXS5wcm9wZXJ0aWVzLnNsb3RFdmVudC5sZW5ndGg7IG4rKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluZE5vZGVCeUlkKGZpc2hUb3BvQnBtbixjaGlsZFNoYXBlc1ttXS5yZXNvdXJjZUlkKS5zbG90RXZlbnQucHVzaChmaW5kTm9kZUJ5SWQoZmlzaFRvcG9CcG1uLGNoaWxkU2hhcGVzW21dLnByb3BlcnRpZXMuc2xvdEV2ZW50W25dKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2uaWTlnKhmaXNoVG9wb0JwbW7kuK3mn6Xmib5cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZmlzaFRvcG9CcG1uICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGVJZCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZpbmROb2RlQnlJZChmaXNoVG9wb0JwbW4sIG5vZGVJZCkge1xyXG4gICAgICAgIHZhciBub2RlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBmaXNoVG9wb0JwbW4uYWxsTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYgKGZpc2hUb3BvQnBtbi5hbGxOb2Rlc1tpXS5tb2RlbC5nZXQoXCJyZXNvdXJjZUlkXCIpID09IG5vZGVJZCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IGZpc2hUb3BvQnBtbi5hbGxOb2Rlc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyQlBNTk5vZGUgKCkge1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoU3RhcnRFdmVudE5vZGUsIFwiU3RhcnROb25lRXZlbnRcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhFbmRFdmVudE5vZGUsIFwiRW5kTm9uZUV2ZW50XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoVXNlclRhc2tOb2RlLCBcIlVzZXJUYXNrXCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoTWFudWFsVGFza05vZGUsIFwiTWFudWFsVGFza1wiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKFNjcmlwdFRhc2tOb2RlLCBcIlNjcmlwdFRhc2tcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhNYWlsVGFza05vZGUsIFwiTWFpbFRhc2tcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhTZXJ2aWNlVGFza05vZGUsIFwiU2VydmljZVRhc2tcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhTbXNUYXNrTm9kZSwgXCJTbXNUYXNrXCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoQ29tbWVudE5vZGUsIFwiQ29tbWVudFwiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKENhdGNoVGltZXJFdmVudE5vZGUsIFwiQ2F0Y2hUaW1lckV2ZW50XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoQ2F0Y2hNZXNzYWdlRXZlbnROb2RlLCBcIkNhdGNoTWVzc2FnZUV2ZW50XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoQ2F0Y2hTaWduYWxFdmVudE5vZGUsIFwiQ2F0Y2hTaWduYWxFdmVudFwiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKFRocm93U2lnbmFsRXZlbnROb2RlLCBcIlRocm93U2lnbmFsRXZlbnRcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhJbmNsdXNpdmVHYXRld2F5Tm9kZSwgXCJJbmNsdXNpdmVHYXRld2F5XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoRXhjbHVzaXZlR2F0ZXdheU5vZGUsIFwiRXhjbHVzaXZlR2F0ZXdheVwiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKFBhcmFsbGVsR2F0ZXdheU5vZGUsIFwiUGFyYWxsZWxHYXRld2F5XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoU3ViUHJjZXNzTm9kZSwgXCJTdWJQcm9jZXNzXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcmVudFgobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zaXRpb25bMF0gKyBwYXJlbnRYKG5vZGUucGFyZW50KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzBdXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcmVudFkobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zaXRpb25bMV0gKyBwYXJlbnRZKG5vZGUucGFyZW50KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzFdXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldFBhcmVudE5vZGUobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0hvdmVyKG5vZGUsIHgsIHkpIHtcclxuICAgICAgICB2YXIgY3ggLCBjeTtcclxuICAgICAgICBpZihub2RlLnBhcmVudCl7XHJcbiAgICAgICAgICAgIGlmKEJwbW4uaXNTdWJQcm9jZXNzKG5vZGUucGFyZW50KSl7XHJcbiAgICAgICAgICAgICAgICBjeCA9IHggLSBwYXJlbnRYKG5vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgICAgIGN5ID0geSAtIHBhcmVudFkobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucmVjdENvbnRhaW4oY3gsIGN5KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnJlY3RDb250YWluKHgsIHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZpbmRIb3ZlcihsaXN0LCB4LCB5LCBleGNsdWRlcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMCA7IGktLSkge1xyXG4gICAgICAgICAgICBpZiAoaXNFeGNsdWRlKGV4Y2x1ZGVzLGxpc3RbaV0pIC8vbGlzdFtpXSAhPT0gZXhjbHVkZVxyXG4gICAgICAgICAgICAgLy8gZ2V0RGlzcGxheUxpc3QgbWF5IGluY2x1ZGUgaWdub3JlZCBpdGVtIGluIFZNTCBtb2RlXHJcbiAgICAgICAgICAgICAmJiAhbGlzdFtpXS5pZ25vcmVcclxuICAgICAgICAgICAgICYmIGlzSG92ZXIobGlzdFtpXSwgeCwgeSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0W2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBpc0V4Y2x1ZGUoZXhjbHVkZXMsIG5vZGUpIHtcclxuICAgICAgICByZXR1cm4genJVdGlsLmluZGV4T2YoZXhjbHVkZXMsbm9kZSkgPT0gLTE7XHJcbiAgICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIHZhciBCcG1uVXRpbCA9IHtcclxuICAgICAgICB0b0pzb246IHRvSnNvbixcclxuICAgICAgICBmcm9tSnNvbjogZnJvbUpzb24sXHJcbiAgICAgICAgcmVnaXN0ZXJCUE1OTm9kZTogcmVnaXN0ZXJCUE1OTm9kZSxcclxuICAgICAgICBmaW5kSG92ZXI6IGZpbmRIb3ZlcixcclxuICAgICAgICBwYXJlbnRYOiBwYXJlbnRYLFxyXG4gICAgICAgIHBhcmVudFk6IHBhcmVudFksXHJcbiAgICAgICAgZ2V0UGFyZW50Tm9kZTogZ2V0UGFyZW50Tm9kZSxcclxuICAgICAgICBnZXRVVUlEOiB1dGlsLmdldFVVSURcclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJwbW5VdGlsO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL0JwbW5VdGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5bel5YW35pa55rOV57G7XHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4vUG9pbnQuanNcIik7XHJcbiAgICB2YXIgTGluZSA9IHJlcXVpcmUoXCIuL0xpbmVTdHJ1Y3QuanNcIik7XHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIC8qKlxyXG4gICAgICog5p6E6YCg57G757un5om/5YWz57O7XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xhenog5rqQ57G7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlQ2xhenog5Z+657G7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcclxuICAgICAgICB2YXIgY2xhenpQcm90b3R5cGUgPSBjbGF6ei5wcm90b3R5cGU7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxyXG4gICAgICAgIEYucHJvdG90eXBlID0gYmFzZUNsYXp6LnByb3RvdHlwZTtcclxuICAgICAgICBjbGF6ei5wcm90b3R5cGUgPSBuZXcgRigpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGNsYXp6UHJvdG90eXBlKSB7XHJcbiAgICAgICAgICAgIGNsYXp6LnByb3RvdHlwZVtwcm9wXSA9IGNsYXp6UHJvdG90eXBlW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGF6ei5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjbGF6ejtcclxuICAgICAgICBjbGF6ei5zdXBlckNsYXNzID0gYmFzZUNsYXp6O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFVVSUQoKSB7XHJcbiAgICAgICAgdmFyIGNoYXJzID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Jy5zcGxpdCgnJyksXHJcbiAgICAgICAgICAgIHV1aWQgPSBuZXcgQXJyYXkoMzYpLFxyXG4gICAgICAgICAgICBybmQgPSAwLFxyXG4gICAgICAgICAgICByO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzY7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA9PSA4IHx8IGkgPT0gMTMgfHwgaSA9PSAxOCB8fCBpID09IDIzKSB7XHJcbiAgICAgICAgICAgICAgICB1dWlkW2ldID0gJy0nO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT0gMTQpIHtcclxuICAgICAgICAgICAgICAgIHV1aWRbaV0gPSAnNCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocm5kIDw9IDB4MDIpIHJuZCA9IDB4MjAwMDAwMCArIChNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwKSB8IDA7XHJcbiAgICAgICAgICAgICAgICByID0gcm5kICYgMHhmO1xyXG4gICAgICAgICAgICAgICAgcm5kID0gcm5kID4+IDQ7XHJcbiAgICAgICAgICAgICAgICB1dWlkW2ldID0gY2hhcnNbKGkgPT0gMTkpID8gKHIgJiAweDMpIHwgMHg4IDogcl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwic2lkLVwiICsgdXVpZC5qb2luKCcnKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorqHnrpfkuKTngrnkuYvpl7TnmoTot53nprtcclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDEgLSBmaXJzdCB7UG9pbnR9XHJcbiAgICAgKkBwYXJhbSB7UG9pbnR9IHAyIC0gc2Vjb25kIHtQb2ludH1cclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRob3NlIDIgcG9pbnRzLiBJdCBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBkaXN0YW5jZShwMSwgcDIpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHAxLnggLSBwMi54LCAyKSArIE1hdGgucG93KHAxLnkgLSBwMi55LCAyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDov5Tlm57kuIDmnaHmipjnur8g5pyA6ZW/55qE5Lik5Liq54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHBvaW50cyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldE1heExpbmVMZW5ndGgocG9pbnRzKSB7XHJcbiAgICAgICAgdmFyIG0gPSBkaXN0YW5jZShwb2ludHNbMF0sIHBvaW50c1sxXSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtwb2ludHNbMF0sIHBvaW50c1sxXV07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAobSA8IGRpc3RhbmNlKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSkpIHtcclxuICAgICAgICAgICAgICAgIG0gPSBkaXN0YW5jZShwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbcG9pbnRzW2ldLCBwb2ludHNbaSArIDFdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipSZXR1cm5zIHRoZSBsZW5ndGggb2YgYSBQb2x5bGluZSB0aGF0IHdvdWxkIGJlIGNyZWF0ZWQgd2l0aCBhIHNldCBvZiBwb2ludHNcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIGFuIHtBcnJheX0gb2Yge1BvaW50c31cclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIGEgcG9zaXRpdmUgbnVtYmVyIGVxdWFsIHdpdGggdG90YWwgbGVuZ3RoKi9cclxuICAgIGZ1bmN0aW9uIGdldFBvbHlsaW5lTGVuZ3RoKHYpIHtcclxuICAgICAgICB2YXIgbCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBsICs9IGRpc3RhbmNlKHZbaV0sIHZbaSArIDFdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBsO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipSZXR1cm5zIHRoZSBtYXggb2YgYSB2ZWN0b3JcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIHZlY3RvciBvZiB7TnVtYmVyfXNcclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIHRoZSBtYXhpbXVtIG51bWJlciBmcm9tIHRoZSB2ZWN0b3Igb3IgTmFOIGlmIHZlY3RvciBpcyBlbXB0eVxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gbWF4KHYpIHtcclxuICAgICAgICBpZiAodi5sZW5naHQgPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBtID0gdlswXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobSA8IHZbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gdltpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipSZXR1cm5zIHRoZSBtaW4gb2YgYSB2ZWN0b3JcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIHZlY3RvciBvZiB7TnVtYmVyfXNcclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIHRoZSBtaW5pbXVtIG51bWJlciBmcm9tIHRoZSB2ZWN0b3Igb3IgTmFOIGlmIHZlY3RvciBpcyBlbXB0eVxyXG4gICAgICpAYXV0aG9yIGFsZXhAc2NyaXB0b2lkLmNvbVxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gbWluKHYpIHtcclxuICAgICAgICBpZiAodi5sZW5naHQgPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBtID0gdlswXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobSA+IHZbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gdltpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yik5patIOeCueaVsOe7hCDmmK/lkKbmraPkuqTnm7Tnur/ot6/lvoRcclxuICAgICAqVGVzdHMgaWYgYSB2ZWN0b3Igb2YgcG9pbnRzIGlzIGFuIG9ydGhvZ29uYWwgcGF0aCAobW92aW5nIGluIG11bHRpcGxlcyBvZiA5MCBkZWdyZWVzKVxyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gYW4ge0FycmF5fSBvZiB7UG9pbnR9c1xyXG4gICAgICpAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgcGF0aCBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBvcnRob2dvbmFsUGF0aCh2KSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh2W2ldLnggIT0gdltpICsgMV0ueCAmJiB2W2ldLnkgIT0gdltpICsgMV0ueSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlRlc3QgdG8gc2VlIGlmIDIge0xpbmV9cyBpbnRlcnNlY3RzLiBUaGV5IGFyZSBjb25zaWRlcmVkIGZpbml0ZSBzZWdtZW50c1xyXG4gICAgICphbmQgbm90IHRoZSBpbmZpbml0ZSBsaW5lcyBmcm9tIGdlb21ldHJ5XHJcbiAgICAgKkBwYXJhbSB7TGluZX0gbDEgLSBmaXN0IGxpbmUvc2VnbWVudFxyXG4gICAgICpAcGFyYW0ge0xpbmV9IGwyIC0gbGFzdCBsaW5lL3NlZ21lbnRcclxuICAgICAqQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSAtIGlmIHRoZSBsaW5lcyBpbnRlcnNlY3Qgb3IgZmFsc2UgaWYgbm90XHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBsaW5lSW50ZXJzZWN0c0xpbmUobDEsIGwyKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIHR3byB2ZXJ0aWNhbCBsaW5lc1xyXG4gICAgICAgIGlmIChsMS5zdGFydFBvaW50LnggPT0gbDEuZW5kUG9pbnQueCAmJiBsMi5zdGFydFBvaW50LnggPT0gbDIuZW5kUG9pbnQueCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbDEuc3RhcnRQb2ludC54ID09IGwyLnN0YXJ0UG9pbnQueCA/IC8vIGlmICdpbmZpbml0ZSAnbGluZXMgZG8gY29pbmNpZGUsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGNoZWNrIHNlZ21lbnQgYm91bmRzIGZvciBvdmVybGFwcGluZ1xyXG4gICAgICAgICAgICAgICAgbDEuY29udGFpbnMobDIuc3RhcnRQb2ludC54LCBsMi5zdGFydFBvaW50LnkpIHx8XHJcbiAgICAgICAgICAgICAgICBsMS5jb250YWlucyhsMi5lbmRQb2ludC54LCBsMi5lbmRQb2ludC55KSA6XHJcbiAgICAgICAgICAgICAgICAvLyBsaW5lcyBhcmUgcGFyYWxlbFxyXG4gICAgICAgICAgICAgICAgZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIG9uZSBsaW5lIGlzIHZlcnRpY2FsLCBhbmQgYW5vdGhlciBsaW5lIGlzIG5vdCB2ZXJ0aWNhbFxyXG4gICAgICAgIGVsc2UgaWYgKGwxLnN0YXJ0UG9pbnQueCA9PSBsMS5lbmRQb2ludC54IHx8IGwyLnN0YXJ0UG9pbnQueCA9PSBsMi5lbmRQb2ludC54KSB7XHJcbiAgICAgICAgICAgIC8vIGxldCBhc3N1bWUgbDIgaXMgdmVydGljYWwsIG90aGVyd2lzZSBleGNoYW5nZSB0aGVtXHJcbiAgICAgICAgICAgIGlmIChsMS5zdGFydFBvaW50LnggPT0gbDEuZW5kUG9pbnQueCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGwgPSBsMTtcclxuICAgICAgICAgICAgICAgIGwxID0gbDI7XHJcbiAgICAgICAgICAgICAgICBsMiA9IGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZmluZGluZyBpbnRlcnNlY3Rpb24gb2YgJ2luZmluaXRlJyBsaW5lc1xyXG4gICAgICAgICAgICAvLyBlcXVhdGlvbiBvZiB0aGUgZmlyc3QgbGluZSBpcyB5ID0gYXggKyBiLCBzZWNvbmQ6IHggPSBjXHJcbiAgICAgICAgICAgIHZhciBhID0gKGwxLmVuZFBvaW50LnkgLSBsMS5zdGFydFBvaW50LnkpIC8gKGwxLmVuZFBvaW50LnggLSBsMS5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgYiA9IGwxLnN0YXJ0UG9pbnQueSAtIGEgKiBsMS5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgIHZhciB4MCA9IGwyLnN0YXJ0UG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIHkwID0gYSAqIHgwICsgYjtcclxuICAgICAgICAgICAgcmV0dXJuIGwxLmNvbnRhaW5zKHgwLCB5MCkgJiYgbDIuY29udGFpbnMoeDAsIHkwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIG5vcm1hbCBjYXNlIC0gYm90aCBsaW5lcyBhcmUgbm90IHZlcnRpY2FsXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vbGluZSBlcXVhdGlvbiBpcyA6IHkgPSBhKnggKyBiLCBiID0geSAtIGEgKiB4XHJcbiAgICAgICAgICAgIHZhciBhMSA9IChsMS5lbmRQb2ludC55IC0gbDEuc3RhcnRQb2ludC55KSAvIChsMS5lbmRQb2ludC54IC0gbDEuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgdmFyIGIxID0gbDEuc3RhcnRQb2ludC55IC0gYTEgKiBsMS5zdGFydFBvaW50Lng7XHJcblxyXG4gICAgICAgICAgICB2YXIgYTIgPSAobDIuZW5kUG9pbnQueSAtIGwyLnN0YXJ0UG9pbnQueSkgLyAobDIuZW5kUG9pbnQueCAtIGwyLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciBiMiA9IGwyLnN0YXJ0UG9pbnQueSAtIGEyICogbDIuc3RhcnRQb2ludC54O1xyXG5cclxuICAgICAgICAgICAgaWYgKGExID09IGEyKSB7IC8vcGFyYWxlbCBsaW5lc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIxID09IGIyID9cclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgY29pbmNpZGUgbGluZXMsIGNoZWNrIGZvciBzZWdtZW50IGJvdW5kcyBvdmVybGFwcGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGwxLmNvbnRhaW5zKGwyLnN0YXJ0UG9pbnQueCwgbDIuc3RhcnRQb2ludC55KSB8fCBsMS5jb250YWlucyhsMi5lbmRQb2ludC54LCBsMi5lbmRQb2ludC55KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGNvaW5jaWRlIHBhcmFsZWwgbGluZXMgaGF2ZSBubyBjaGFuY2UgdG8gaW50ZXJzZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vdXN1YWwgY2FzZSAtIG5vbiBwYXJhbGVsLCB0aGUgJ2luZmluaXRlJyBsaW5lcyBpbnRlcnNlY3RzLi4ud2Ugb25seSBuZWVkIHRvIGtub3cgaWYgaW5zaWRlIHRoZSBzZWdtZW50XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIGlmIG9uZSBvZiB0aGUgbGluZXMgYXJlIHZlcnRpY2FsLCB0aGVuIHgwIGlzIGVxdWFsIHRvIHRoZWlyIHgsXHJcbiAgICAgICAgICAgICAgICAgKiBvdGhlcndpc2U6XHJcbiAgICAgICAgICAgICAgICAgKiB5MSA9IGExICogeCArIGIxXHJcbiAgICAgICAgICAgICAgICAgKiB5MiA9IGEyICogeCArIGIyXHJcbiAgICAgICAgICAgICAgICAgKiA9PiB4MCA9IChiMiAtIGIxKSAvIChhMSAtIGEyKVxyXG4gICAgICAgICAgICAgICAgICogPT4geTAgPSBhMSAqIHgwICsgYjFcclxuICAgICAgICAgICAgICAgICAqKi9cclxuICAgICAgICAgICAgICAgIHgwID0gKGIyIC0gYjEpIC8gKGExIC0gYTIpO1xyXG4gICAgICAgICAgICAgICAgeTAgPSBhMSAqIHgwICsgYjE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbDEuY29udGFpbnMoeDAsIHkwKSAmJiBsMi5jb250YWlucyh4MCwgeTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqVGVzdHMgaWYgYSBhIHBvbHlsaW5lIGRlZmluZWQgYnkgYSBzZXQgb2YgcG9pbnRzIGludGVyc2VjdHMgYSByZWN0YW5nbGVcclxuICAgICAqQHBhcmFtIHtBcnJheX0gcG9pbnRzIC0gYW5kIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqQHBhcmFtIHtBcnJheX0gYm91bmRzIC0gdGhlIGJvdW5kcyBvZiB0aGUgcmVjdGFuZ2xlIGRlZmluZWQgYnkgKHgxLCB5MSwgeDIsIHkyKVxyXG4gICAgICpAcGFyYW0ge0Jvb2xlYW59IGNsb3NlZFBvbHlsaW5lIC0gaW5jYXNlIHBvbHlsaW5lIGlzIGNsb3NlZCBmaWd1cmUgdGhlbiB0cnVlLCBlbHNlIGZhbHNlXHJcbiAgICAgKlxyXG4gICAgICpAcmV0dXJuIHRydWUgLSBpZiBsaW5lIGludGVyc2VjdHMgdGhlIHJlY3RhbmdsZSwgZmFsc2UgLSBpZiBub3RcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIHBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZShwb2ludHMsIGJvdW5kcywgY2xvc2VkUG9seWxpbmUpIHtcclxuXHJcblxyXG4gICAgICAgIC8vZ2V0IHRoZSA0IGxpbmVzL3NlZ21lbnRzIHJlcHJlc2VudGVkIGJ5IHRoZSBib3VuZHNcclxuICAgICAgICB2YXIgbGluZXMgPSBbXTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1sxXSksIG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1sxXSkpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1sxXSksIG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1szXSkpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1szXSksIG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1szXSkpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1szXSksIG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1sxXSkpKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBwb2ludHMubGVuZ3RoIC0gMTsgaysrKSB7XHJcbiAgICAgICAgICAgIC8vY3JlYXRlIGEgbGluZSBvdXQgb2YgZWFjaCAyIGNvbnNlY3V0aXZlIHBvaW50c1xyXG4gICAgICAgICAgICB2YXIgdGVtcExpbmUgPSBuZXcgTGluZShwb2ludHNba10sIHBvaW50c1trICsgMV0pO1xyXG5cclxuICAgICAgICAgICAgLy9zZWUgaWYgdGhhdCBsaW5lIGludGVyc2VjdCBhbnkgb2YgdGhlIGxpbmUgb24gYm91bmRzIGJvcmRlclxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZUludGVyc2VjdHNMaW5lKHRlbXBMaW5lLCBsaW5lc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jaGVjayB0aGUgY2xvc2VkIGZpZ3VyZSAtIHRoYXQgaXMgbGFzdCBwb2ludCBjb25uZWN0ZWQgdG8gdGhlIGZpcnN0XHJcbiAgICAgICAgaWYgKGNsb3NlZFBvbHlsaW5lKSB7XHJcbiAgICAgICAgICAgIC8vY3JlYXRlIGEgbGluZSBvdXQgb2YgZWFjaCAyIGNvbnNlY3V0aXZlIHBvaW50c1xyXG4gICAgICAgICAgICB2YXIgdGVtcExpbmUxID0gbmV3IExpbmUocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSwgcG9pbnRzWzBdKTtcclxuXHJcbiAgICAgICAgICAgIC8vc2VlIGlmIHRoYXQgbGluZSBpbnRlcnNlY3QgYW55IG9mIHRoZSBsaW5lIG9uIGJvdW5kcyBib3JkZXJcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVJbnRlcnNlY3RzTGluZSh0ZW1wTGluZTEsIGxpbmVzW2pdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorqHnrpfot6/lvoTnmoTliIbmlbBcclxuICAgICAqIFNjb3JlIGEgb3J0b2dvbmFsIHBhdGggbWFkZSBvdXQgb2YgUG9pbnRzXHJcbiAgICAgKkl0ZXJhdGVzIG92ZXIgYSBzZXQgb2YgcG9pbnRzIChtaW5pbXVtIDMpXHJcbiAgICAgKkZvciBlYWNoIDMgcG9pbnRzIChpLCBpKzEsIGkrMikgOlxyXG4gICAgICogIC0gaWYgdGhlIDNyZCBvbmUgaXMgYWZ0ZXIgdGhlIDJuZCBvbiB0aGUgc2FtZSBsaW5lIHdlIGFkZCArMVxyXG4gICAgICogIC0gaWYgdGhlIDNyZCBpcyB1cCBvciBkb3duIHJlbGF0ZWQgdG8gdGhlIDJuZCB3ZSBkbyBub3QgZG8gYW55dGhpbmcgKzBcclxuICAgICAqICAtIGlmIHRoZSAzcmQgZ29lcyBiYWNrIHdlIGltZWRpYXRlbGx5IHJldHVybiAtMVxyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gYW4gYXJyYXkgb2Yge1BvaW50fXNcclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIC0xIGlmIHRoZSBwYXRoIGlzIHdyb25nIChnb2VzIGJhY2spIG9yIHNvbWV0aGluZyA+PSAwIGlmIGlzIGZpbmVcclxuICAgICAqICBUaGUgYmlnZ2VyIHRoZSBudW1iZXIgdGhlIHNtb290aCB0aGUgcGF0aCBpc1xyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gc2NvcmVQYXRoKHYpIHtcclxuICAgICAgICBpZiAodi5sZW5ndGggPD0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2NvcmUgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdi5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHZbaSAtIDFdLnggPT0gdltpXS54ICYmIHZbaV0ueCA9PSB2W2kgKyAxXS54KSB7IC8vb24gdGhlIHNhbWUgdmVydGljYWxcclxuICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueSAtIHZbaV0ueSkgPT0gc2lnbnVtKHZbaV0ueSAtIHZbaSAtIDFdLnkpKSB7IC8vc2FtZSBkaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBzY29yZSsrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9nb2luZyBiYWNrIC0gbm8gZ29vZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2W2kgLSAxXS55ID09IHZbaV0ueSAmJiB2W2ldLnkgPT0gdltpICsgMV0ueSkgeyAvL29uIHRoZSBzYW1lIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueCAtIHZbaV0ueCkgPT0gc2lnbnVtKHZbaV0ueCAtIHZbaSAtIDFdLngpKSB7IC8vc2FtZSBkaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBzY29yZSsrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9nb2luZyBiYWNrIC0gbm8gZ29vZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHsgLy9ub3Qgb24gc2FtZSB2ZXJ0aWNhbCBub3IgaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgc2NvcmUtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNjb3JlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6L+U5Zue5pWw5a2X56ym5Y+377yIKyAtKVxyXG4gICAgICogUmV0dXJucyB0aGUgc2lnbiBvZiBhIG51bWJlclxyXG4gICAgICpAcGFyYW0ge051bWJlcn0geCAtIHRoZSBudW1iZXJcclxuICAgICAqQHJldHVybnMge051bWJlcn1cclxuICAgICAqQHNlZSA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaWduX2Z1bmN0aW9uXCI+aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaWduX2Z1bmN0aW9uPC9hPlxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gc2lnbnVtKHgpIHtcclxuICAgICAgICBpZiAoeCA+IDApXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIGVsc2UgaWYgKHggPCAwKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIpOaWrSDngrnmlbDnu4Qg5piv5LiN5piv5pyJ5pWI6Lev5b6E77yI5rKh5pyJ5Zue6Lev77yJXHJcbiAgICAgKlRlc3RzIGlmIGEgdmVjdG9yIG9mIHBvaW50cyBpcyBhIHZhbGlkIHBhdGggKG5vdCBnb2luZyBiYWNrKVxyXG4gICAgICpUaGVyZSBhcmUgYSBmZXcgcHJvYmxlbXMgaGVyZS4gSWYgeW91IGhhdmUgcDEsIHAyLCBwMyBhbmQgcDQgYW5kIHAyID0gcDMgeW91IG5lZWQgdG8gaWdub3JlIHRoYXRcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIGFuIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIHBhdGggaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gZm9yd2FyZFBhdGgodikge1xyXG4gICAgICAgIGlmICh2Lmxlbmd0aCA8PSAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aCAtIDI7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodltpXS54ID09IHZbaSArIDFdLnggJiYgdltpICsgMV0ueCA9PSB2W2kgKyAyXS54KSB7IC8vb24gdGhlIHNhbWUgdmVydGljYWxcclxuICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueSAtIHZbaV0ueSkgIT0gMCkgeyAvL3Rlc3Qgb25seSB3ZSBoYXZlIGEgcHJvZ3Jlc3NpbmcgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueSAtIHZbaV0ueSkgPT0gLTEgKiBzaWdudW0odltpICsgMl0ueSAtIHZbaSArIDFdLnkpKSB7IC8vZ29pbmcgYmFjayAoaWdub3JlIHplcm8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodltpXS55ID09IHZbaSArIDFdLnkgJiYgdltpICsgMV0ueSA9PSB2W2kgKyAyXS55KSB7IC8vb24gdGhlIHNhbWUgaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS54IC0gdltpXS54KSAhPSAwKSB7IC8vdGVzdCBvbmx5IHdlIGhhdmUgYSBwcm9ncmVzc2luZyBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS54IC0gdltpXS54KSA9PSAtMSAqIHNpZ251bSh2W2kgKyAyXS54IC0gdltpICsgMV0ueCkpIHsgLy9nb2luZyBiYWNrIChpZ25vcmUgemVybylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlsIZbeDowLHk6MF3ovazljJbkuLpbMCwgMF0gIOe7mXpyZW5kZXLkvb/nlKhcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcG9pbnRzIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gaXNSZXZlcnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0cmFzbGF0ZVBvaW50cyhwb2ludHMsIGlzUmV2ZXJ0KSB7XHJcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IFtdO1xyXG4gICAgICAgIGlmIChpc1JldmVydCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2gobmV3IFBvaW50KHBvaW50WzBdLCBwb2ludFsxXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdQb2ludHM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2ludDEgPSBwb2ludHNbal07XHJcbiAgICAgICAgICAgICAgICBuZXdQb2ludHMucHVzaChbcG9pbnQxLngsIHBvaW50MS55XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ld1BvaW50cztcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByb3RhdGlvbk1hdHJpeChhbmdsZSkge1xyXG4gICAgICAgIHZhciBtUmV0dXJuID0gW1xyXG4gICAgICAgICAgICBbTWF0aC5jb3MoYW5nbGUpLCAtTWF0aC5zaW4oYW5nbGUpLCAwXSxcclxuICAgICAgICAgICAgW01hdGguc2luKGFuZ2xlKSwgTWF0aC5jb3MoYW5nbGUpLCAwXSxcclxuICAgICAgICAgICAgWzAsIDAsIDFdXHJcbiAgICAgICAgXTtcclxuICAgICAgICByZXR1cm4gbVJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0cmFuc2xhdGlvbk1hdHJpeChkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbMSwgMCwgZHhdLFxyXG4gICAgICAgICAgICBbMCwgMSwgZHldLFxyXG4gICAgICAgICAgICBbMCwgMCwgMV1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNjYWxlTWF0cml4KHN4LCBzeSkge1xyXG4gICAgICAgIGlmIChzeSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN5ID0gc3g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFtzeCwgMCwgMF0sXHJcbiAgICAgICAgICAgIFswLCBzeSwgMF0sXHJcbiAgICAgICAgICAgIFswLCAwLCAxXVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEl0IHdpbGwgcmV0dXJuIHRoZSBlbmQgcG9pbnQgb2YgYSBsaW5lIG9uIGEgZ2l2ZW4gYW5nbGUgKGNsb2Nrd2lzZSkuXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBzdGFydFBvaW50IC0gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gdGhlIGxlbmd0aCBvZiB0aGUgbGluZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIC0gdGhlIGFuZ2xlIG9mIHRoZSBsaW5lIGluIHJhZGlhbnNcclxuICAgICAqIEByZXR1cm4ge1BvaW50fSAtIHRoZSBlbmRQb2ludCBvZiB0aGUgbGluZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRFbmRQb2ludChzdGFydFBvaW50LCBsZW5ndGgsIGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIGVuZFBvaW50ID0gc3RhcnRQb2ludC5jbG9uZSgpO1xyXG4gICAgICAgIGVuZFBvaW50LnRyYW5zZm9ybSh0cmFuc2xhdGlvbk1hdHJpeCgtc3RhcnRQb2ludC54LCAtc3RhcnRQb2ludC55KSk7XHJcbiAgICAgICAgZW5kUG9pbnQueSAtPSBsZW5ndGg7XHJcbiAgICAgICAgZW5kUG9pbnQudHJhbnNmb3JtKHJvdGF0aW9uTWF0cml4KGFuZ2xlKSk7XHJcbiAgICAgICAgZW5kUG9pbnQudHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KHN0YXJ0UG9pbnQueCwgc3RhcnRQb2ludC55KSk7XHJcbiAgICAgICAgcmV0dXJuIGVuZFBvaW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W6I635Y+W5Lik5Liq5Zu+5b2i55qE5aSW6Z2i5Zub5Liq6L+e5o6l54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHJlY3QgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldENvbm5lY3RvclBvaW50cyhyZWN0LCBub2RlKSB7XHJcbiAgICAgICAgbm9kZSA9IG5vZGUgfHwge307XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHpyVXRpbC5jbG9uZShyZWN0LmJvdW5kaW5nUmVjdCB8fCByZWN0KTtcclxuICAgICAgICB2YXIgcm90YXRpb24gPSBub2RlLnJvdGF0aW9uO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSB7XHJcbiAgICAgICAgICAgIGxlZnQ6IG5ldyBQb2ludChib3VuZGluZ1JlY3QueCwgYm91bmRpbmdSZWN0LnkgKyBib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMiksIC8v55+p5b2iIOW3puS4reeahOS9jee9rlxyXG4gICAgICAgICAgICB0b3A6IG5ldyBQb2ludChib3VuZGluZ1JlY3QueCArIGJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC55KSwgLy/nn6nlvaIg5LiK5Lit55qE5L2N572uXHJcbiAgICAgICAgICAgIHJpZ2h0OiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC55ICsgYm91bmRpbmdSZWN0LmhlaWdodCAvIDIpLCAvL+efqeW9oiDlj7PkuK3nmoTkvY3nva5cclxuICAgICAgICAgICAgYm90dG9tOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGggLyAyLCBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQpLCAvL+efqeW9oiDkuIvkuK3nmoTkvY3nva5cclxuICAgICAgICAgICAgY2VudGVyOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGggLyAyLCBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyKSAvL+S4remXtOS9jee9rlxyXG5cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhub2RlKS5sZW5ndGggPiAwICYmIE1hdGguYWJzKHJvdGF0aW9uKSA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHJlY3ROZXcgPSByZWN0LmJvdW5kaW5nUmVjdCA/IHJlY3QgOiBnZXRSZWN0KG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0geyB4OiByZWN0TmV3LngsIHk6IHJlY3ROZXcueSB9OyAvLyDkuK3lv4PngrlcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMocG9pbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcG9pbnRzW2tleV07XHJcbiAgICAgICAgICAgICAgICB2YXIgeDAgPSBjZW50ZXIueCAtIHZhbHVlLng7XHJcbiAgICAgICAgICAgICAgICB2YXIgeTAgPSBjZW50ZXIueSAtIHZhbHVlLnk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oLXJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcygtcm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uX25feCA9IGNlbnRlci54IC0gKHgwICogY29zIC0geTAgKiBzaW4pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uX25feSA9IGNlbnRlci55IC0gKHgwICogc2luICsgeTAgKiBjb3MpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzW2tleV0ueCA9IHBvc2l0aW9uX25feDtcclxuICAgICAgICAgICAgICAgIHBvaW50c1trZXldLnkgPSBwb3NpdGlvbl9uX3k7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W6IqC54K55aSW6Z2i5Zub5Liq5o6n5Yi254K55ZKM5peL6L2s54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0Q29ubmVjdG9yQ29udHJvbHMocmVjdCwgbm9kZSkge1xyXG4gICAgICAgIG5vZGUgPSBub2RlIHx8IHt9O1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB6clV0aWwuY2xvbmUocmVjdC5ib3VuZGluZ1JlY3QpO1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IG5vZGUucm90YXRpb247XHJcbiAgICAgICAgdmFyIGNvbnRyb2xzID0ge1xyXG4gICAgICAgICAgICB0bDogbmV3IFBvaW50KGJvdW5kaW5nUmVjdC54LCBib3VuZGluZ1JlY3QueSksIC8v55+p5b2iIOW3puS4iuinkuS9jee9rlxyXG4gICAgICAgICAgICB0YzogbmV3IFBvaW50KGJvdW5kaW5nUmVjdC54ICsgYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LnkgLSA0KSwgLy/nn6nlvaIg5LiK5Lit5L2N572uXHJcbiAgICAgICAgICAgIHRyOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC55KSwgLy/nn6nlvaIg5Y+z5LiK6KeS5L2N572uXHJcbiAgICAgICAgICAgIGJsOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LngsIGJvdW5kaW5nUmVjdC55ICsgYm91bmRpbmdSZWN0LmhlaWdodCksIC8v55+p5b2iIOW3puS4i+inklxyXG4gICAgICAgICAgICBicjogbmV3IFBvaW50KGJvdW5kaW5nUmVjdC54ICsgYm91bmRpbmdSZWN0LndpZHRoLCBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQpLCAvL+efqeW9oiDlj7PkuIvop5LkvY3nva5cclxuICAgICAgICAgICAgbXRyOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGggLyAyLCBib3VuZGluZ1JlY3QueSAtIDIwKSAvLyDml4vovazngrnkvY3nva5cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhub2RlKS5sZW5ndGggPiAwICYmIE1hdGguYWJzKHJvdGF0aW9uKSA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHJlY3ROZXcgPSByZWN0O1xyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0geyB4OiByZWN0TmV3LngsIHk6IHJlY3ROZXcueSB9OyAvLyDkuK3lv4PngrlcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udHJvbHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjb250cm9sc1trZXldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHgwID0gY2VudGVyLnggLSB2YWx1ZS54O1xyXG4gICAgICAgICAgICAgICAgdmFyIHkwID0gY2VudGVyLnkgLSB2YWx1ZS55O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKC1yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoLXJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbl9uX3ggPSBjZW50ZXIueCAtICh4MCAqIGNvcyAtIHkwICogc2luKTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbl9uX3kgPSBjZW50ZXIueSAtICh4MCAqIHNpbiArIHkwICogY29zKTtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xzW2tleV0ueCA9IHBvc2l0aW9uX25feDtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xzW2tleV0ueSA9IHBvc2l0aW9uX25feTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250cm9scztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruS4reW/g+eCueWSjOaXi+i9rOW8p+W6pu+8jOiuoeeul+aXi+i9rOWQjueahOeCueWdkOagh1xyXG4gICAgICogQHBhcmFtICB7W29iamVjdHxhcnJheV19IHBvaW50cyBb5Y6f5Z2Q5qCHXVxyXG4gICAgICogQHBhcmFtICB7W29iamVjdF19ICAgICAgIGNlbnRlciBb5Lit5b+D54K5XVxyXG4gICAgICogQHBhcmFtICB7W251bWJlcl19ICAgICAgIHJvdGF0aW9uIFvml4vovazlvKfluqZdXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVQb2ludHMocG9pbnRzLCBjZW50ZXIsIHJvdGF0aW9uKSB7XHJcbiAgICAgICAgdmFyIHggPSBBcnJheS5pc0FycmF5KHBvaW50cykgPyBwb2ludHNbMF0gOiBwb2ludHMueDtcclxuICAgICAgICB2YXIgeSA9IEFycmF5LmlzQXJyYXkocG9pbnRzKSA/IHBvaW50c1sxXSA6IHBvaW50cy55O1xyXG4gICAgICAgIHZhciB4MCA9IGNlbnRlci54IC0geDtcclxuICAgICAgICB2YXIgeTAgPSBjZW50ZXIueSAtIHk7XHJcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKC1yb3RhdGlvbik7XHJcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKC1yb3RhdGlvbik7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uX25feCA9IGNlbnRlci54IC0gKHgwICogY29zIC0geTAgKiBzaW4pO1xyXG4gICAgICAgIHZhciBwb3NpdGlvbl9uX3kgPSBjZW50ZXIueSAtICh4MCAqIHNpbiArIHkwICogY29zKTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2ludHMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbcG9zaXRpb25fbl94LCBwb3NpdGlvbl9uX3ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBwb3NpdGlvbl9uX3gsXHJcbiAgICAgICAgICAgIHk6IHBvc2l0aW9uX25feVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluiOt+WPluS4pOS4quWbvuW9oueahOWklumdouWbm+S4qui/nuaOpeeCuVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFNvbHRQb2ludHMobm9kZSkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIC8vdG9wXHJcbiAgICAgICAgICAgIFtNYXRoLnJvdW5kKG5vZGUuZ2V0UmVjdCgpLndpZHRoIC8gMyAvMTApKjEwLCAwIF0sXHJcbiAgICAgICAgICAgIFtNYXRoLnJvdW5kKDIqbm9kZS5nZXRSZWN0KCkud2lkdGggLyAzIC8xMCkqMTAsIDAgXSxcclxuICAgICAgICAgICAgLy9yaWdodFxyXG4gICAgICAgICAgICBbbm9kZS5nZXRSZWN0KCkud2lkdGgsIE1hdGgucm91bmQobm9kZS5nZXRSZWN0KCkuaGVpZ2h0IC8gMyAvMTApKjEwIF0sXHJcbiAgICAgICAgICAgIFtub2RlLmdldFJlY3QoKS53aWR0aCwgTWF0aC5yb3VuZCgyKm5vZGUuZ2V0UmVjdCgpLmhlaWdodCAvIDMgLzEwKSoxMCBdLFxyXG4gICAgICAgICAgICAvL2JvdHRvbVxyXG4gICAgICAgICAgICBbTWF0aC5yb3VuZChub2RlLmdldFJlY3QoKS53aWR0aCAvIDMgLzEwKSoxMCwgbm9kZS5nZXRSZWN0KCkuaGVpZ2h0IF0sXHJcbiAgICAgICAgICAgIFtNYXRoLnJvdW5kKDIqbm9kZS5nZXRSZWN0KCkud2lkdGggLyAzIC8xMCkqMTAsIG5vZGUuZ2V0UmVjdCgpLmhlaWdodCBdLFxyXG4gICAgICAgICAgICAvL2xlZnRcclxuICAgICAgICAgICAgWzAsIE1hdGgucm91bmQobm9kZS5nZXRSZWN0KCkuaGVpZ2h0IC8gMyAvMTApKjEwIF0sXHJcbiAgICAgICAgICAgIFswLCBNYXRoLnJvdW5kKDIqbm9kZS5nZXRSZWN0KCkuaGVpZ2h0IC8gMyAvMTApKjEwIF1cclxuXHJcbiAgICAgICAgXVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6h566XIHAxIHAy5Lik54K55omA6L+e5o6l55qE55u057q/55qE6KeS5bqmXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHAxIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcDIgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRhbmdlbnRSb3RhdGlvbihwMSwgcDIpIHtcclxuICAgICAgICByZXR1cm4gLU1hdGguUEkgLyAyIC0gTWF0aC5hdGFuMihcclxuICAgICAgICAgICAgcDIueSAtIHAxLnksIHAyLnggLSBwMS54XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIpOaWrTPngrnmmK/lkKblnKjkuIDmnaHnm7Tnur/kuIpcclxuICAgICAqIFRlc3RzIGlmIDMgcG9pbnRzIGFyZSBjb2xpbmlhciB3aXRoIG1hdHJpeCBkZXRlcm1pbmFudHMuXHJcbiAgICAgKiBJZiB0aGUgZGV0ZXJtaW5hdCBvZiBtYXRyaXhcclxuICAgICAqIC8gICAgICAgICBcXFxyXG4gICAgICogfCB4MSB5MSAxIHxcclxuICAgICAqIHwgeDIgeTIgMSB8XHJcbiAgICAgKiB8IHgzIHkzIDEgfFxyXG4gICAgICogXFwgICAgICAgICAvXHJcbiAgICAgKiBpcyB6ZXJvIGl0IG1lYW5zIHRoYXQgdGhlIHBvaW50cyBhcmUgY29saW5lYXJcclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDEgLSBmaXJzdCBwb2ludFxyXG4gICAgICpAcGFyYW0ge1BvaW50fSBwMiAtIHNlY29uZCBwb2ludFxyXG4gICAgICpAcGFyYW0ge1BvaW50fSBwMyAtIHRoaXJkIHBvaW50XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzc2lvblxyXG4gICAgICpAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgY29saW5pYXIgYW5kIGZhbHNlIGlmIG5vdFxyXG4gICAgICpAYXV0aG9yIEFsZXhcclxuICAgICAqQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RldGVybWluYW50XHJcbiAgICAgKkBzZWUgaHR0cHM6Ly9wZW9wbGUucmljaGxhbmQuZWR1L2phbWVzL2xlY3R1cmUvbTExNi9tYXRyaWNlcy9hcHBsaWNhdGlvbnMuaHRtbFxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gY29sbGluZWFyaXR5KHAxLCBwMiwgcDMsIHByZWNpc3Npb24pIHtcclxuICAgICAgICB2YXIgZGV0ZXJtaW5hbnQgPSAocDEueCAqIHAyLnkgKyBwMS55ICogcDMueCArIHAyLnggKiBwMy55KSAtIChwMi55ICogcDMueCArIHAxLnkgKiBwMi54ICsgcDEueCAqIHAzLnkpO1xyXG5cclxuICAgICAgICBpZiAocHJlY2lzc2lvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoZGV0ZXJtaW5hbnQpIDw9IHByZWNpc3Npb247XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRldGVybWluYW50ID09PSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlm5voiI3kupTlhaUg5L+d5a2YZGVjaW1hbHPnmoTlsI/mlbBcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGVuaGFuY2VkUm91bmQobnVtYmVyLCBkZWNpbWFscykge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIE1hdGgucG93KDEwLCBkZWNpbWFscykpIC8gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluS4pOeCueS5i+mXtOeahOmVv+W6plxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gZ2V0TGVuZ3RoKHN0YXJ0UG9pbnQsIGVuZFBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhzdGFydFBvaW50LnggLSBlbmRQb2ludC54LCAyKSArIE1hdGgucG93KHN0YXJ0UG9pbnQueSAtIGVuZFBvaW50LnksIDIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluinkuW6plxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBjZW50ZXJQb2ludCAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBvdXRzaWRlUG9pbnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSByb3VuZCAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRBbmdsZShjZW50ZXJQb2ludCwgb3V0c2lkZVBvaW50LCByb3VuZCkge1xyXG4gICAgICAgIGNlbnRlclBvaW50LnggPSBlbmhhbmNlZFJvdW5kKGNlbnRlclBvaW50LngsIDUpO1xyXG4gICAgICAgIGNlbnRlclBvaW50LnkgPSBlbmhhbmNlZFJvdW5kKGNlbnRlclBvaW50LnksIDUpO1xyXG4gICAgICAgIG91dHNpZGVQb2ludC54ID0gZW5oYW5jZWRSb3VuZChvdXRzaWRlUG9pbnQueCwgNSk7XHJcbiAgICAgICAgb3V0c2lkZVBvaW50LnkgPSBlbmhhbmNlZFJvdW5kKG91dHNpZGVQb2ludC55LCA1KTtcclxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4oKG91dHNpZGVQb2ludC54IC0gY2VudGVyUG9pbnQueCkgLyAob3V0c2lkZVBvaW50LnkgLSBjZW50ZXJQb2ludC55KSk7XHJcbiAgICAgICAgYW5nbGUgPSAtYW5nbGU7XHJcblxyXG4gICAgICAgIC8vZW5kQW5nbGUrPTkwO1xyXG4gICAgICAgIGlmIChvdXRzaWRlUG9pbnQueCA+PSBjZW50ZXJQb2ludC54ICYmIG91dHNpZGVQb2ludC55ID49IGNlbnRlclBvaW50LnkpIHtcclxuICAgICAgICAgICAgYW5nbGUgKz0gTWF0aC5QSTtcclxuICAgICAgICB9IGVsc2UgaWYgKG91dHNpZGVQb2ludC54IDw9IGNlbnRlclBvaW50LnggJiYgb3V0c2lkZVBvaW50LnkgPj0gY2VudGVyUG9pbnQueSkge1xyXG4gICAgICAgICAgICBhbmdsZSArPSBNYXRoLlBJO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3V0c2lkZVBvaW50LnggPD0gY2VudGVyUG9pbnQueCAmJiBvdXRzaWRlUG9pbnQueSA8PSBjZW50ZXJQb2ludC55KSB7XHJcbiAgICAgICAgICAgIGFuZ2xlICs9IE1hdGguUEkgKiAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoYW5nbGUgPj0gTWF0aC5QSSAqIDIpIHtcclxuICAgICAgICAgICAgYW5nbGUgLT0gTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc05hTihhbmdsZSkpIHsgLy9OYW5cclxuICAgICAgICAgICAgYW5nbGUgPSAwOyAvL3dlIGFyZSBhdCBjZW50ZXIgcG9pbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb3VuZCkge1xyXG4gICAgICAgICAgICBhbmdsZSA9IE1hdGgucm91bmQoYW5nbGUgLyByb3VuZCkgKiByb3VuZFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYW5nbGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bniLboioLngrnnmoRwb3NpdGlvblswXVxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBub2RlICBb6IqC54K5XVxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwYXJlbnRLZXkgW+WIpOaWreaYr+WQpuacieaMh+WumueItuiKgueCueeahGtleSzlr7nkuo5ncm91cOaYr3R5cGXvvJvlr7nkuo5zdWJwcm9jZXNz5pivbm9kZVR5cGVdXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBhcmVudFZhbHVlICBb5Yik5pat5piv5ZCm5pyJ5oyH5a6a54i26IqC54K555qEdmFsdWUs5a+55LqOZ3JvdXDmmK9Hcm91cE5vZGXvvJvlr7nkuo5zdWJwcm9jZXNz5pivU3ViUHJvY2Vzc11cclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgIOeItuiKgueCueeahHBvc2l0aW9uWzBdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFBhcmVudFgobm9kZSwgcGFyZW50S2V5LCBwYXJlbnRWYWx1ZSkge1xyXG4gICAgICAgIGlmICghcGFyZW50S2V5KSB7XHJcbiAgICAgICAgICAgIHBhcmVudEtleSA9ICd0eXBlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwYXJlbnRWYWx1ZSkge1xyXG4gICAgICAgICAgICBwYXJlbnRWYWx1ZSA9ICdHcm91cE5vZGUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnRbcGFyZW50S2V5XSA9PT0gcGFyZW50VmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zaXRpb25bMF0gKyBnZXRQYXJlbnRYKG5vZGUucGFyZW50KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzBdXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W54i26IqC54K555qEcG9zaXRpb25bMV1cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gbm9kZSAgW+iKgueCuV1cclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gcGFyZW50S2V5IFvliKTmlq3mmK/lkKbmnInmjIflrprniLboioLngrnnmoRrZXks5a+55LqOZ3JvdXDmmK90eXBl77yb5a+55LqOc3VicHJvY2Vzc+aYr25vZGVUeXBlXVxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwYXJlbnRWYWx1ZSAgW+WIpOaWreaYr+WQpuacieaMh+WumueItuiKgueCueeahHZhbHVlLOWvueS6jmdyb3Vw5pivR3JvdXBOb2Rl77yb5a+55LqOc3VicHJvY2Vzc+aYr1N1YlByb2Nlc3NdXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICAgICDniLboioLngrnnmoRwb3NpdGlvblsxXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRQYXJlbnRZKG5vZGUsIHBhcmVudEtleSwgcGFyZW50VmFsdWUpIHtcclxuICAgICAgICBpZiAoIXBhcmVudEtleSkge1xyXG4gICAgICAgICAgICBwYXJlbnRLZXkgPSAndHlwZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcGFyZW50VmFsdWUpIHtcclxuICAgICAgICAgICAgcGFyZW50VmFsdWUgPSAnR3JvdXBOb2RlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50W3BhcmVudEtleV0gPT09IHBhcmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzFdICsgZ2V0UGFyZW50WShub2RlLnBhcmVudClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblsxXVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRSZWN0KG5vZGUsIGlzQ2FsY1BhcmVudCkge1xyXG4gICAgICAgIHZhciBjbGlwUGF0aCA9IG5vZGUuY2xpcFBhdGg7XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgLy8g6IqC54K56KOB5Ymq5ZCO77yM5Lul6KOB5Ymq6IqC54K55YyF5Zu055uS5Li65YeGXHJcbiAgICAgICAgaWYgKGNsaXBQYXRoKSB7XHJcbiAgICAgICAgICAgIGJvdW5kaW5nUmVjdCA9IGNsaXBQYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+WIm+W7uuacgOWwj+WMheWbtOebkuiZmue6v1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICBwb2ludHNbMF0gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgcG9pbnRzWzFdID0gW2JvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgcG9pbnRzWzJdID0gW2JvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbM10gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbNF0gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcblxyXG4gICAgICAgIHZhciBwb3NpdGlvblggPSBub2RlLnBvc2l0aW9uWzBdO1xyXG4gICAgICAgIHZhciBwb3NpdGlvblkgPSBub2RlLnBvc2l0aW9uWzFdO1xyXG4gICAgICAgIC8v6L+Z6YeM6KaB5b6q546v5Yik5pat5LiA5oqKIOacieayoeacieeItuiKgueCuSDlubbkuJTniLboioLngrnkuI3mmK/moLnoioLngrkg54S25ZCO6L+b6KGM55u45YqgXHJcbiAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIGlzQ2FsY1BhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gJ0dyb3VwTm9kZScgfHwgbm9kZS5wYXJlbnQubm9kZVR5cGUgPT09ICdTdWJQcm9jZXNzJykge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25YICs9IGdldFBhcmVudFgobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25ZICs9IGdldFBhcmVudFkobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYm91bmRSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChcclxuICAgICAgICAgICAgICAgIE51bWJlcihwb3NpdGlvblggKyBib3VuZGluZ1JlY3QueCksICAgLy/ms6g6IOWboOS6i+S7tuS4uuWchuW9oiAg5omA5LulIHggeSDkuLrlnIblv4PnmoTkvY3nva4gIOWMheWbtOefqeW9ouimgeWHj+WOu+WuveW6puS4gOWNilxyXG4gICAgICAgICAgICAgICAgTnVtYmVyKHBvc2l0aW9uWSArIGJvdW5kaW5nUmVjdC55KSxcclxuICAgICAgICAgICAgICAgIE51bWJlcihib3VuZGluZ1JlY3Qud2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyKGJvdW5kaW5nUmVjdC5oZWlnaHQpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgLy/kuK3lv4PngrlcclxuICAgICAgICB2YXIgY3ggPSBOdW1iZXIocG9zaXRpb25YKSArIE51bWJlcihib3VuZGluZ1JlY3Qud2lkdGgpIC8gMiArIE51bWJlcihib3VuZGluZ1JlY3QueCk7XHJcbiAgICAgICAgdmFyIGN5ID0gTnVtYmVyKHBvc2l0aW9uWSkgKyBOdW1iZXIoYm91bmRpbmdSZWN0LmhlaWdodCkgLyAyICsgTnVtYmVyKGJvdW5kaW5nUmVjdC55KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBOdW1iZXIoY3gpLFxyXG4gICAgICAgICAgICB5OiBOdW1iZXIoY3kpLFxyXG4gICAgICAgICAgICB3aWR0aDogTnVtYmVyKGJvdW5kaW5nUmVjdC53aWR0aCksXHJcbiAgICAgICAgICAgIGhlaWdodDogTnVtYmVyKGJvdW5kaW5nUmVjdC5oZWlnaHQpLFxyXG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICAgICAgYm91bmRpbmdSZWN0OiBib3VuZFJlY3RcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBTdGFja2VkTWFwID0ge1xyXG4gICAgICAgIGNyZWF0ZU5ldzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFjayA9IFtdO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJLZXkgPSB0aGlzLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFycktleS5wdXNoKHZhbHVlKVxyXG5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyDojrflj5botbflp4vngrnmnIlvZmZzZXTpl7TpmpTnmoRhcnJLZXlcclxuICAgICAgICAgICAgICAgIGdldHNpbWlsYXI6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlBcnIgPSBrZXkuc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1LZXlBcnIgPSBpdGVtLmtleS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbUtleUFyclswXS5pbmRleE9mKGtleUFyclswXSkgPiAtMSAmJiBpdGVtS2V5QXJyWzFdLmluZGV4T2Yoa2V5QXJyWzFdKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNvbmNhdChpdGVtLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTsgIFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gc3RhY2tbaV0ua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tbaV0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy/lpoLmnpzmsqHmnInmib7liLDnmoTor53vvIzliJnliJvlu7rkuIDkuKrmlrDnmoTmlbDnu4RcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAga2V5czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChzdGFja1tpXS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0b3A6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gc3RhY2tbaV0ua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNwbGljZShpZHgsIDEpWzBdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uKGtleSwgaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJLZXkgPSB0aGlzLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHpyVXRpbC5pbmRleE9mKGFycktleSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyS2V5LnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZVRvcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSAxLCAxKVswXTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFjay5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnNwbGljZSgwLCBzdGFjay5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcmFuZG9tQ29sb3IoKSB7XHJcbiAgICAgICAgdmFyIGFyckhleCA9IFtcIjBcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIl0sXHJcbiAgICAgICAgICAgIHN0ckhleCA9IFwiI1wiLFxyXG4gICAgICAgICAgICBpbmRleDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xyXG4gICAgICAgICAgICBpbmRleCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDE1KTtcclxuICAgICAgICAgICAgc3RySGV4ICs9IGFyckhleFtpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHJIZXg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbGxpbmVhclJlZHVjdGlvbiAodikge1xyXG4gICAgICAgIHZhciByID0gW107XHJcblxyXG4gICAgICAgIGlmKHYubGVuZ3RoIDwgMyl7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5jbG9uZUFycmF5KHYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgci5wdXNoKCB2WzBdLmNsb25lKCkgKTtcclxuICAgICAgICBmb3IodmFyIGk9MTsgaSA8IHYubGVuZ3RoLTE7IGkrKyl7XHJcbiAgICAgICAgICAgIGlmKCAodltpLTFdLnggPT0gdltpXS54ICYmIHZbaV0ueCA9PSB2W2krMV0ueCkgIHx8ICAodltpLTFdLnkgPT0gdltpXS55ICYmIHZbaV0ueSA9PSB2W2krMV0ueSkgKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgci5wdXNoKCB2W2ldLmNsb25lKCkgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByLnB1c2goIHZbdi5sZW5ndGgtMV0uY2xvbmUoKSApO1xyXG5cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcclxuICAgIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cclxuICAgIHZhciB0ZW1wbGF0ZVNldHRpbmdzID0ge1xyXG4gICAgICAgIGV2YWx1YXRlOiAvPCUoW1xcc1xcU10rPyklPi9nLFxyXG4gICAgICAgIGludGVycG9sYXRlOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcclxuICAgICAgICBlc2NhcGU6IC88JS0oW1xcc1xcU10rPyklPi9nXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cclxuICAgIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcclxuICAgIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxyXG4gICAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XHJcblxyXG4gICAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcclxuICAgIC8vIHN0cmluZyBsaXRlcmFsLlxyXG4gICAgdmFyIGVzY2FwZXMgPSB7XHJcbiAgICAgICAgXCInXCI6IFwiJ1wiLFxyXG4gICAgICAgICdcXFxcJzogJ1xcXFwnLFxyXG4gICAgICAgICdcXHInOiAncicsXHJcbiAgICAgICAgJ1xcbic6ICduJyxcclxuICAgICAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXHJcbiAgICAgICAgJ1xcdTIwMjknOiAndTIwMjknXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xyXG5cclxuICAgIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXHJcbiAgICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXHJcbiAgICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cclxuICAgIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cclxuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xyXG4gICAgICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XHJcbiAgICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcclxuICAgICAgICBzZXR0aW5ncyA9IHpyVXRpbC5kZWZhdWx0cyhzZXR0aW5ncywgdGVtcGxhdGVTZXR0aW5ncywgdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxyXG4gICAgICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcclxuICAgICAgICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXHJcbiAgICAgICAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXHJcbiAgICAgICAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcclxuICAgICAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XHJcblxyXG4gICAgICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcclxuICAgICAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVyLCBlc2NhcGVDaGFyKTtcclxuICAgICAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBpZiAoZXNjYXBlKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcclxuXHJcbiAgICAgICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cclxuICAgICAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xyXG5cclxuICAgICAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXHJcbiAgICAgICAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXHJcbiAgICAgICAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsIHNvdXJjZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cclxuICAgICAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcclxuICAgICAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XHJcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXlMaWtlKG9iaikgJiYgKHpyVXRpbC5pc0FycmF5KG9iaikgfHwgenJVdGlsLmlzU3RyaW5nKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lcmdlT3B0KHRhcmdldCwgc291cmNlLCBvdmVyd3JpdGUsIGV4Y2x1ZGUpIHtcclxuICAgICAgICAvLyBXZSBzaG91bGQgZXNjYXBzZSB0aGF0IHNvdXJjZSBpcyBzdHJpbmdcclxuICAgICAgICAvLyBhbmQgZW50ZXIgZm9yIC4uLiBpbiAuLi5cclxuICAgICAgICBpZiAoIXpyVXRpbC5pc09iamVjdChzb3VyY2UpIHx8ICF6clV0aWwuaXNPYmplY3QodGFyZ2V0KSkge1xyXG4gICAgICAgICAgcmV0dXJuIG92ZXJ3cml0ZSA/IHpyVXRpbC5jbG9uZShzb3VyY2UpIDogdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xyXG4gICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRQcm9wID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XHJcblxyXG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KHNvdXJjZVByb3ApICYmIHpyVXRpbC5pc09iamVjdCh0YXJnZXRQcm9wKSAmJiAhenJVdGlsLmlzQXJyYXkoc291cmNlUHJvcCkgJiYgIXpyVXRpbC5pc0FycmF5KHRhcmdldFByb3ApICYmICF6clV0aWwuaXNEb20oc291cmNlUHJvcCkgJiYgIXpyVXRpbC5pc0RvbSh0YXJnZXRQcm9wKSAmJiAhenJVdGlsLmlzQnVpbHRJbk9iamVjdChzb3VyY2VQcm9wKSAmJiAhenJVdGlsLmlzQnVpbHRJbk9iamVjdCh0YXJnZXRQcm9wKSAmJiAhenJVdGlsLmlzUHJpbWl0aXZlKHNvdXJjZVByb3ApICYmICF6clV0aWwuaXNQcmltaXRpdmUodGFyZ2V0UHJvcCkpIHtcclxuICAgICAgICAgICAgICAvLyDlpoLmnpzpnIDopoHpgJLlvZLopobnm5bvvIzlsLHpgJLlvZLosIPnlKhtZXJnZVxyXG4gICAgICAgICAgICAgIG1lcmdlT3B0KHRhcmdldFByb3AsIHNvdXJjZVByb3AsIG92ZXJ3cml0ZSwgZXhjbHVkZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3ZlcndyaXRlIHx8ICEoa2V5IGluIHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAvLyDlkKbliJnlj6rlpITnkIZvdmVyd3JpdGXkuLp0cnVl77yM5oiW6ICF5Zyo55uu5qCH5a+56LGh5Lit5rKh5pyJ5q2k5bGe5oCn55qE5oOF5Ya1XHJcbiAgICAgICAgICAgICAgLy8gTk9URe+8jOWcqCB0YXJnZXRba2V5XSDkuI3lrZjlnKjnmoTml7blgJnkuZ/mmK/nm7TmjqXopobnm5ZcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IGV4Y2x1ZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHpyVXRpbC5jbG9uZShzb3VyY2Vba2V5XSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIENsYXNzKCkge31cclxuICAgIENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uKHByb3RvKSB7XHJcbiAgICAgICAgdmFyIGJhc2UgPSBmdW5jdGlvbigpIHt9LFxyXG4gICAgICAgICAgICBtZW1iZXIsXHJcbiAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgICAgICBzdWJjbGFzcyA9IHByb3RvICYmIHByb3RvLmluaXQgPyBwcm90by5pbml0IDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmbjtcclxuXHJcbiAgICAgICAgYmFzZS5wcm90b3R5cGUgPSB0aGF0LnByb3RvdHlwZTtcclxuICAgICAgICBmbiA9IHN1YmNsYXNzLmZuID0gc3ViY2xhc3MucHJvdG90eXBlID0gbmV3IGJhc2UoKTtcclxuXHJcbiAgICAgICAgZm9yIChtZW1iZXIgaW4gcHJvdG8pIHtcclxuICAgICAgICAgICAgaWYgKHByb3RvW21lbWJlcl0gIT0gbnVsbCAmJiBwcm90b1ttZW1iZXJdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1lcmdlIG9iamVjdCBtZW1iZXJzXHJcbiAgICAgICAgICAgICAgICBmblttZW1iZXJdID0genJVdGlsLm1lcmdlQWxsKFt7fSwgYmFzZS5wcm90b3R5cGVbbWVtYmVyXSwgcHJvdG9bbWVtYmVyXV0sdHJ1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmblttZW1iZXJdID0gcHJvdG9bbWVtYmVyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm4uY29uc3RydWN0b3IgPSBzdWJjbGFzcztcclxuICAgICAgICBzdWJjbGFzcy5leHRlbmQgPSB0aGF0LmV4dGVuZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN1YmNsYXNzO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBpbmhlcml0czogaW5oZXJpdHMsXHJcbiAgICAgICAgZ2V0VVVJRDogZ2V0VVVJRCxcclxuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXHJcbiAgICAgICAgZ2V0UG9seWxpbmVMZW5ndGg6IGdldFBvbHlsaW5lTGVuZ3RoLFxyXG4gICAgICAgIG1heDogbWF4LFxyXG4gICAgICAgIG1pbjogbWluLFxyXG4gICAgICAgIGlzRW1wdHk6IGlzRW1wdHksXHJcbiAgICAgICAgbWVyZ2VPcHQ6IG1lcmdlT3B0LFxyXG4gICAgICAgIG9ydGhvZ29uYWxQYXRoOiBvcnRob2dvbmFsUGF0aCxcclxuICAgICAgICBwb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGU6IHBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZSxcclxuICAgICAgICBzY29yZVBhdGg6IHNjb3JlUGF0aCxcclxuICAgICAgICBmb3J3YXJkUGF0aDogZm9yd2FyZFBhdGgsXHJcbiAgICAgICAgdHJhc2xhdGVQb2ludHM6IHRyYXNsYXRlUG9pbnRzLFxyXG4gICAgICAgIGdldEVuZFBvaW50OiBnZXRFbmRQb2ludCxcclxuICAgICAgICBnZXRDb25uZWN0b3JQb2ludHM6IGdldENvbm5lY3RvclBvaW50cyxcclxuICAgICAgICBnZXRDb25uZWN0b3JDb250cm9sczogZ2V0Q29ubmVjdG9yQ29udHJvbHMsXHJcbiAgICAgICAgY2FsY3VsYXRlUG9pbnRzOiBjYWxjdWxhdGVQb2ludHMsXHJcbiAgICAgICAgdGFuZ2VudFJvdGF0aW9uOiB0YW5nZW50Um90YXRpb24sXHJcbiAgICAgICAgY29sbGluZWFyaXR5OiBjb2xsaW5lYXJpdHksXHJcbiAgICAgICAgdHJhbnNsYXRpb25NYXRyaXg6IHRyYW5zbGF0aW9uTWF0cml4LFxyXG4gICAgICAgIHNjYWxlTWF0cml4OiBzY2FsZU1hdHJpeCxcclxuICAgICAgICByb3VuZDogZW5oYW5jZWRSb3VuZCxcclxuICAgICAgICBnZXRMZW5ndGg6IGdldExlbmd0aCxcclxuICAgICAgICBnZXRBbmdsZTogZ2V0QW5nbGUsXHJcbiAgICAgICAgZ2V0UGFyZW50WDogZ2V0UGFyZW50WCxcclxuICAgICAgICBnZXRQYXJlbnRZOiBnZXRQYXJlbnRZLFxyXG4gICAgICAgIGdldFJlY3Q6IGdldFJlY3QsXHJcbiAgICAgICAgU3RhY2tlZE1hcDogU3RhY2tlZE1hcCxcclxuICAgICAgICBnZXRNYXhMaW5lTGVuZ3RoOiBnZXRNYXhMaW5lTGVuZ3RoLFxyXG4gICAgICAgIHJhbmRvbUNvbG9yOiByYW5kb21Db2xvcixcclxuICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICAgICAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxyXG4gICAgICAgIGdldFNvbHRQb2ludHM6Z2V0U29sdFBvaW50cyxcclxuICAgICAgICBjb2xsaW5lYXJSZWR1Y3Rpb246IGNvbGxpbmVhclJlZHVjdGlvbixcclxuICAgICAgICBDbGFzczpDbGFzc1xyXG4gICAgfTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHJcbiAgICAvKipcclxuICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgTGluZS4gQSBMaW5lIGlzIGFjdHVhbGx5IGEgc2VnbWVudCBhbmQgbm90IGEgcHVyZVxyXG4gICAgICAqIGdlb21ldHJpY2FsIExpbmVcclxuICAgICAgKlxyXG4gICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAqIEB0aGlzIHtMaW5lfVxyXG4gICAgICAqIEBwYXJhbSB7UG9pbnR9IHN0YXJ0UG9pbnQgLSBzdGFydGluZyBwb2ludCBvZiB0aGUgbGluZVxyXG4gICAgICAqIEBwYXJhbSB7UG9pbnR9IGVuZFBvaW50IC0gdGhlIGVuZGluZyBwb2ludCBvZiB0aGUgbGluZVxyXG4gICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIExpbmUoc3RhcnRQb2ludCwgZW5kUG9pbnQpe1xyXG4gICAgICAgIC8qKlN0YXJ0aW5nIHtAbGluayBQb2ludH0gb2YgdGhlIGxpbmUqL1xyXG4gICAgICAgIHRoaXMuc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQ7XHJcblxyXG4gICAgICAgIC8qKkVuZGluZyB7QGxpbmsgUG9pbnR9IG9mIHRoZSBsaW5lKi9cclxuICAgICAgICB0aGlzLmVuZFBvaW50ID0gZW5kUG9pbnQ7XHJcblxyXG4gICAgICAgIC8qKlNlcmlhbGl6YXRpb24gdHlwZSovXHJcbiAgICAgICAgdGhpcy5vVHlwZSA9ICdMaW5lJzsgLy9vYmplY3QgdHlwZSB1c2VkIGZvciBKU09OIGRlc2VyaWFsaXphdGlvblxyXG4gICAgfVxyXG5cclxuICAgIC8qKkNyZWF0ZXMgYSB7TGluZX0gb3V0IG9mIEpTT04gcGFyc2VkIG9iamVjdFxyXG4gICAgICpAcGFyYW0ge0pTT05PYmplY3R9IG8gLSB0aGUgSlNPTiBwYXJzZWQgb2JqZWN0XHJcbiAgICAgKkByZXR1cm4ge0xpbmV9IGEgbmV3bHkgY29uc3RydWN0ZWQgTGluZVxyXG4gICAgICoqL1xyXG4gICAgTGluZS5sb2FkID0gZnVuY3Rpb24obyl7XHJcbiAgICAgICAgdmFyIG5ld0xpbmUgPSBuZXcgTGluZShcclxuICAgICAgICAgICAgUG9pbnQubG9hZChvLnN0YXJ0UG9pbnQpLFxyXG4gICAgICAgICAgICBQb2ludC5sb2FkKG8uZW5kUG9pbnQpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld0xpbmU7XHJcbiAgICB9O1xyXG5cclxuICAgIExpbmUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnRydWN0b3I6IExpbmUsXHJcblxyXG5cclxuXHJcbiAgICAgICAgY2xvbmU6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBMaW5lKHRoaXMuc3RhcnRQb2ludC5jbG9uZSgpLCB0aGlzLmVuZFBvaW50LmNsb25lKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGVxdWFsczpmdW5jdGlvbihhbm90aGVyTGluZSl7XHJcbiAgICAgICAgICAgIGlmKCFhbm90aGVyTGluZSBpbnN0YW5jZW9mIExpbmUpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UG9pbnQuZXF1YWxzKGFub3RoZXJMaW5lLnN0YXJ0UG9pbnQpXHJcbiAgICAgICAgICAgICYmIHRoaXMuZW5kUG9pbnQuZXF1YWxzKGFub3RoZXJMaW5lLmVuZFBvaW50KVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKiBUZXN0cyB0byBzZWUgaWYgYSBwb2ludCBiZWxvbmdzIHRvIHRoaXMgbGluZSAobm90IGFzIGluZmluaXRlIGxpbmUgYnV0IG1vcmUgbGlrZSBhIHNlZ21lbnQpXHJcbiAgICAgICAgICogQWxnb3JpdGhtOiBDb21wdXRlIGxpbmUncyBlcXVhdGlvbiBhbmQgc2VlIGlmICh4LCB5KSB2ZXJpZmllcyBpdC5cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIHRoZSBYIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSB0aGUgWSBjb29yZGluYXRlc1xyXG4gICAgICAgICAqKi9cclxuICAgICAgICBjb250YWluczogZnVuY3Rpb24oeCwgeSl7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgcmVjdGFuZ2xlIGJvdW5kcyBvZiB0aGUgc2VnbWVudFxyXG4gICAgICAgICAgICBpZiAoTWF0aC5taW4odGhpcy5zdGFydFBvaW50LngsIHRoaXMuZW5kUG9pbnQueCkgPD0geFxyXG4gICAgICAgICAgICAgICAgJiYgeCA8PSBNYXRoLm1heCh0aGlzLnN0YXJ0UG9pbnQueCwgdGhpcy5lbmRQb2ludC54KVxyXG4gICAgICAgICAgICAgICAgJiYgTWF0aC5taW4odGhpcy5zdGFydFBvaW50LnksIHRoaXMuZW5kUG9pbnQueSkgPD0geVxyXG4gICAgICAgICAgICAgICAgJiYgeSA8PSBNYXRoLm1heCh0aGlzLnN0YXJ0UG9pbnQueSwgdGhpcy5lbmRQb2ludC55KSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciB2ZXJ0aWNhbCBsaW5lXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydFBvaW50LnggPT0gdGhpcy5lbmRQb2ludC54KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggPT0gdGhpcy5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyB1c3VhbCAobm90IHZlcnRpY2FsKSBsaW5lIGNhbiBiZSByZXByZXNlbnRlZCBhcyB5ID0gYSAqIHggKyBiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSAodGhpcy5lbmRQb2ludC55IC0gdGhpcy5zdGFydFBvaW50LnkpIC8gKHRoaXMuZW5kUG9pbnQueCAtIHRoaXMuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMuc3RhcnRQb2ludC55IC0gYSAqIHRoaXMuc3RhcnRQb2ludC54O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5ID09IGEgKiB4ICsgYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICpTZWUgaWYgd2UgYXJlIG5lYXIgYSB7TGluZX0gYnkgYSBjZXJ0YWluIHJhZGl1cyAoYWxzbyBpbmNsdWRlcyB0aGUgZXh0cmVtaXRpZXMgaW50byBjb21wdXRhdGlvbilcclxuICAgICAgICAgKkBwYXJhbSB7TnVtYmVyfSB4IC0gdGhlIHggY29vcmRpbmF0ZXNcclxuICAgICAgICAgKkBwYXJhbSB7TnVtYmVyfSB5IC0gdGhlIHkgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKkBwYXJhbSB7TnVtYmVyfSByYWRpdXMgLSB0aGUgcmFkaXVzIHRvIHNlYXJjaCBmb3JcclxuICAgICAgICAgKkBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lXHJcbiAgICAgICAgICpAc2VlIFwiTWF0aGVtYXRpY3MgZm9yIENvbXB1dGVyIEdyYXBoaWNzLCAybmQgRWQuLCBieSBKb2huIFZpY2UsIHBhZ2UgMjI3XCJcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgbmVhcjpmdW5jdGlvbih4LHkscmFkaXVzKXtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuZW5kUG9pbnQueCA9PT0gdGhpcy5zdGFydFBvaW50LngpeyAvL1ZlcnRpY2FsIGxpbmUsIHNvIHRoZSB2aWNpbml0eSBhcmVhIGlzIGEgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCAodGhpcy5zdGFydFBvaW50LnktcmFkaXVzPD15ICYmIHRoaXMuZW5kUG9pbnQueStyYWRpdXM+PXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICh0aGlzLmVuZFBvaW50LnktcmFkaXVzPD15ICYmIHRoaXMuc3RhcnRQb2ludC55K3JhZGl1cz49eSkpXHJcbiAgICAgICAgICAgICAgICAmJiB4ID4gdGhpcy5zdGFydFBvaW50LnggLSByYWRpdXMgJiYgeCA8IHRoaXMuc3RhcnRQb2ludC54ICsgcmFkaXVzIDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5zdGFydFBvaW50LnkgPT09IHRoaXMuZW5kUG9pbnQueSl7IC8vSG9yaXpvbnRhbCBsaW5lLCBzbyB0aGUgdmljaW5pdHkgYXJlYSBpcyBhIHJlY3RhbmdsZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICggKHRoaXMuc3RhcnRQb2ludC54IC0gcmFkaXVzPD14ICYmIHRoaXMuZW5kUG9pbnQueCtyYWRpdXM+PXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICh0aGlzLmVuZFBvaW50LngtcmFkaXVzPD14ICYmIHRoaXMuc3RhcnRQb2ludC54K3JhZGl1cz49eCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHk+dGhpcy5zdGFydFBvaW50LnktcmFkaXVzICYmIHk8dGhpcy5zdGFydFBvaW50LnkrcmFkaXVzIDtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBzdGFydFggPSBNYXRoLm1pbih0aGlzLmVuZFBvaW50LngsdGhpcy5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gTWF0aC5taW4odGhpcy5lbmRQb2ludC55LHRoaXMuc3RhcnRQb2ludC55KTtcclxuICAgICAgICAgICAgdmFyIGVuZFggPSBNYXRoLm1heCh0aGlzLmVuZFBvaW50LngsdGhpcy5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgZW5kWSA9IE1hdGgubWF4KHRoaXMuZW5kUG9pbnQueSx0aGlzLnN0YXJ0UG9pbnQueSk7XHJcblxyXG4gICAgICAgICAgICAvKldlIHdpbGwgY29tcHV0ZSB0aGUgZGlzdGFuY2UgZnJvbSBwb2ludCB0byB0aGUgbGluZVxyXG4gICAgICAgICAgICAgKiBieSB1c2luZyB0aGUgYWxnb3JpdGhtIGZyb21cclxuICAgICAgICAgICAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lXHJcbiAgICAgICAgICAgICAqICovXHJcblxyXG4gICAgICAgICAgICAvL0ZpcnN0IHdlIG5lZWQgdG8gZmluZCBhLGIsYyBvZiB0aGUgbGluZSBlcXVhdGlvbiBheCArIGJ5ICsgYyA9IDBcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmVuZFBvaW50LnkgLSB0aGlzLnN0YXJ0UG9pbnQueTtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLnN0YXJ0UG9pbnQueCAtIHRoaXMuZW5kUG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIGMgPSAtKHRoaXMuc3RhcnRQb2ludC54ICogdGhpcy5lbmRQb2ludC55IC0gdGhpcy5lbmRQb2ludC54ICogdGhpcy5zdGFydFBvaW50LnkpO1xyXG5cclxuICAgICAgICAgICAgLy9TZWNvbmRseSB3ZSBnZXQgdGhlIGRpc3RhbmNlIFwiTWF0aGVtYXRpY3MgZm9yIENvbXB1dGVyIEdyYXBoaWNzLCAybmQgRWQuLCBieSBKb2huIFZpY2UsIHBhZ2UgMjI3XCJcclxuICAgICAgICAgICAgdmFyIGQgPSBNYXRoLmFicyggKGEqeCArIGIqeSArIGMpIC8gTWF0aC5zcXJ0KE1hdGgucG93KGEsMikgKyBNYXRoLnBvdyhiLDIpKSApO1xyXG5cclxuICAgICAgICAgICAgLy9UaGlyZGx5IHdlIGdldCBjb29yZGluYXRlcyBvZiBjbG9zZXN0IGxpbmUncyBwb2ludCB0byB0YXJnZXQgcG9pbnRcclxuICAgICAgICAgICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RhbmNlX2Zyb21fYV9wb2ludF90b19hX2xpbmUjQ2FydGVzaWFuX2Nvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIHZhciBjbG9zZXN0WCA9IChiICogKGIqeCAtIGEqeSkgLSBhKmMpIC8gKCBNYXRoLnBvdyhhLDIpICsgTWF0aC5wb3coYiwyKSApO1xyXG4gICAgICAgICAgICB2YXIgY2xvc2VzdFkgPSAoYSAqICgtYip4ICsgYSp5KSAtIGIqYykgLyAoIE1hdGgucG93KGEsMikgKyBNYXRoLnBvdyhiLDIpICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgciA9ICggZCA8PSByYWRpdXMgJiYgZW5kWD49Y2xvc2VzdFggJiYgY2xvc2VzdFg+PXN0YXJ0WCAmJiBlbmRZPj1jbG9zZXN0WSAmJiBjbG9zZXN0WT49c3RhcnRZICkgLy90aGUgcHJvamVjdGlvbiBvZiB0aGUgcG9pbnQgZmFsbHMgSU5TSURFIG9mIHRoZSBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICB8fCB0aGlzLnN0YXJ0UG9pbnQubmVhcih4LHkscmFkaXVzKSB8fCB0aGlzLmVuZFBvaW50Lm5lYXIoeCx5LHJhZGl1cyk7IC8vdGhlIHByb2plY3Rpb24gb2YgdGhlIHBvaW50IGZhbGxzIE9VVFNJREUgb2YgdGhlIHNlZ21lbnRcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAgcjtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgYXJyYXkgZWFjaCB0aW1lLCBvciB3ZSB3aWxsIGFmZmVjdCB0aGUgYWN0dWFsIHNoYXBlKi9cclxuICAgICAgICBnZXRQb2ludHM6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh0aGlzLnN0YXJ0UG9pbnQpO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh0aGlzLmVuZFBvaW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipSZXR1cm4gdGhlIHtQb2ludH0gY29ycmVzcG9uZGluZyB0aGUgdCBjZXJ0YWluIHQgdmFsdWVcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gdCB0aGUgdmFsdWUgb2YgcGFyYW1ldGVyIHQsIHdoZXJlIHQgaW4gWzAsMV0sIHQgaXMgbGlrZSBhIHBlcmNlbnQqL1xyXG4gICAgICAgIGdldFBvaW50OiBmdW5jdGlvbih0KXtcclxuICAgICAgICAgICAgdmFyIFhwID0gdCAqICh0aGlzLmVuZFBvaW50LnggLSB0aGlzLnN0YXJ0UG9pbnQueCkgKyB0aGlzLnN0YXJ0UG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIFlwID0gdCAqICh0aGlzLmVuZFBvaW50LnkgLSB0aGlzLnN0YXJ0UG9pbnQueSkgKyB0aGlzLnN0YXJ0UG9pbnQueTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWHAsIFlwKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyAvKipcclxuICAgICAgICAvLyAgKiBSZXR1cm5zIHRoZSBtaWRkbGUgb2YgdGhlIGxpbmVcclxuICAgICAgICAvLyAgKiBAcmV0dXJuIHtQb2ludH0gdGhlIG1pZGRsZSBwb2ludFxyXG4gICAgICAgIC8vICAqICovXHJcbiAgICAgICAgLy8gZ2V0TWlkZGxlIDogZnVuY3Rpb24oKXtcclxuICAgICAgICAvLyAgICAgcmV0dXJuIFV0aWwuZ2V0TWlkZGxlKHRoaXMuc3RhcnRQb2ludCwgdGhpcy5lbmRQb2ludCk7XHJcbiAgICAgICAgLy8gfSxcclxuXHJcblxyXG4gICAgICAgIC8vIGdldExlbmd0aCA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgLy8gICAgIHJldHVybiBVdGlsLmdldExlbmd0aCh0aGlzLnN0YXJ0UG9pbnQsIHRoaXMuZW5kUG9pbnQpO1xyXG4gICAgICAgIC8vIH0sXHJcblxyXG4gICAgICAgIC8vIC8qKlxyXG4gICAgICAgIC8vICAqR2V0IGJvdW5kcyBmb3IgdGhpcyBsaW5lXHJcbiAgICAgICAgLy8gICpAYXV0aG9yIEFsZXggR2hlb3JnaGl1IDxhbGV4QHNjcmlwdG9pZC5jb20+XHJcbiAgICAgICAgLy8gICoqL1xyXG4gICAgICAgIC8vIGdldEJvdW5kczpmdW5jdGlvbigpe1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gVXRpbC5nZXRCb3VuZHModGhpcy5nZXRQb2ludHMoKSk7XHJcbiAgICAgICAgLy8gfSxcclxuXHJcbiAgICAgICAgLyoqU3RyaW5nIHJlcHJlc2VudGF0aW9uKi9cclxuICAgICAgICB0b1N0cmluZzpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gJ2xpbmUoJyArIHRoaXMuc3RhcnRQb2ludCArICcsJyArIHRoaXMuZW5kUG9pbnQgKyAnKSc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gTGluZTtcclxuXHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTGluZVN0cnVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEJQTU7oioLngrnnsbsgIOaJgOacieeahEJQTU7lvaLnirbpg73nu6fmib/kuI7lroPvvIznlKjmiLfoh6rlrprkuYnoioLngrnlj6/ku6Xnu6fmib/lroPlubbms6jlhozljbPlj6/kvb/nlKhcclxuICogQGNsYXNzIGZpc2gudG9wby5GaXNoVG9wb0JwbW4uQlBNTk5vZGVcclxuICovXHJcblxyXG5cclxuXHR2YXIgTm9kZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvTm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblx0dmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2NsYXp6Jyk7XHJcblx0Ly/liJvlu7pOb2Rl57G7IOaJgOacieW9oueKtumDvee7p+aJv05vZGVcclxuXHRmdW5jdGlvbiBCUE1OTm9kZShtb2RlbCwgYXBpKSB7XHJcblx0XHROb2RlLmNhbGwodGhpcyk7XHJcblx0XHR0aGlzLm1vZGVsID0gbW9kZWw7XHJcblx0XHR0aGlzLm9wdGlvbnMgPVxyXG5cdFx0e1xyXG5cdFx0XHRvdXRsaW5lOiB7XHJcblx0XHRcdFx0ZW5hYmxlOiB0cnVlLCAvLyDmmK/lkKbmnInlpJbmoYZcclxuXHRcdFx0XHRyYWRpdXM6IHRydWUsIC8vIOaYr+WQpuWchuinklxyXG5cdFx0XHRcdGluaXRWaXNpYmxlOiBmYWxzZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHR0ZXh0OiB7XHJcblx0XHRcdFx0Y29sb3I6ICcjMDAwMDAwJywgLy8g5paH5pys6aKc6ImyXHJcblx0XHRcdFx0bGluZUhlaWdodDogMjQgLy8g5paH5pys6KGM6auYXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IC0xLCBuYW1lOlwiQlBNTkRpYWdyYW1cIiwgZGlzcGxheU5hbWU6XCJUYXNrXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuXHRcdHZhciByZXNvdXJjZUlkID0gbW9kZWwuZ2V0KFwicmVzb3VyY2VJZFwiKTtcclxuXHRcdGlmKHJlc291cmNlSWQgJiYgcmVzb3VyY2VJZCAhPSBcIlwiKSB7XHJcblx0XHRcdHRoaXMucmVzb3VyY2VJZCA9IHJlc291cmNlSWQ7XHJcblx0XHR9XHJcblxyXG4gICAgICAgIC8v5Yik5pat5piv5ZCm5pyJb3BlcmF0aW9uTm9kZVxyXG4gICAgICAgIHZhciBwcm9wID0gbW9kZWwuZ2V0KFwicHJvcGVydGllc1wiKTtcclxuICAgICAgICBpZiAocHJvcC5vcGVyYXRpb25JY29ucykge1xyXG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbkljb25zID0gcHJvcC5vcGVyYXRpb25JY29ucztcclxuICAgICAgICB9XHJcblx0XHR0aGlzLmluaXRFdmVudChhcGkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiB1dGY4TGVuZ3RoKHN0cikge1xyXG4gICAgICAgIHZhciBtID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikubWF0Y2goLyVbODlBQmFiXS9nKTtcclxuICAgICAgICByZXR1cm4gc3RyLmxlbmd0aCArIChtID8gbS5sZW5ndGggOiAwKTtcclxuICAgIH1cclxuXHJcbiAgICBCUE1OTm9kZS5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24oYXBpKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnZGJsY2xpY2snLCAnY2xpY2snXTsvLydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnXHJcblxyXG5cclxuICAgICAgICB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24gKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhhdC5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xyXG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuXHQgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG5cdCAgICAgICAgICAgIHBhcmFtcy50eXBlID0gZXZlTmFtZTtcclxuXHQgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhhdDtcclxuXHQgICAgICAgICAgICBhcGkudHJpZ2dlcihldmVOYW1lLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5blvZPliY3oioLngrnnmoTljIXlm7Tlkowg55u45YWz5Y+C5pWwXHJcbiAgICAgKiBAcmV0dXJucyB7e3g6TnVtYmVyLCB5Ok51bWJlciwgd2lkdGg6TnVtYmVyLCBoZWlnaHQ6TnVtYmVyLCBwb2ludHM6QXJyYXksIGJvdW5kaW5nUmVjdDpPYmplY3R9fVxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gcmV0dXJuLngg5b2T5YmN6IqC54K555qE5Lit5b+D54K5eOWAvFxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gcmV0dXJuLnkg5b2T5YmN6IqC54K555qE5Lit5b+D54K5eeWAvFxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gcmV0dXJuLndpZHRoIOW9k+WJjeiKgueCueeahOWuveW6plxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gcmV0dXJuLmhlaWdodCDlvZPliY3oioLngrnnmoTpq5jluqZcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcmV0dXJuLnBvaW50cyDlvZPliY3oioLngrnnmoTljIXlm7TlkowgW+W3puS4iuinkuWdkOagh++8jOWPs+S4iuinkuWdkOagh++8jOWPs+S4i+inkuWdkOagh++8jOWPs+S4i+inkuWdkOagh10g55So5LqO6IqC54K56YCJ5Lit5pe25YyF5Zu06Jma57q/5qGGXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZXR1cm4uYm91bmRpbmdSZWN0IOW9k+WJjeiKgueCueeahOWMheWbtOefqeW9olxyXG4gICAgICovXHJcbiAgICBCUE1OTm9kZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOi/lOWbnuW9k+WJjeiKgueCueeahOWMheWbtOefqeW9olxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSDlvZPliY3oioLngrnnmoTljIXlm7Tnn6nlvaIgIOS4gOiIrOS4jeWMheaLrOS4i+mdoueahOaWh+Wtl1xyXG4gICAgICovXHJcbiAgICBCUE1OTm9kZS5wcm90b3R5cGUuZ2V0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u5Zu+5YWD55qE5L2N572uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCB45Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB55Z2Q5qCHXHJcbiAgICAgKi9cclxuICAgIEJQTU5Ob2RlLnByb3RvdHlwZS5zZXRQb3NpdGlvbiAgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOafpeeci+W9k+WJjeiKgueCueaYr+WQpiDljIXmi6x4ICx5IOWdkOagh1xyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB4IHjlnZDmoIdcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0geSB55Z2Q5qCHXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgIOaYr+WQpuWcqOiMg+WbtOWGhVxyXG4gICAgICovXHJcbiAgICBCUE1OTm9kZS5wcm90b3R5cGUucmVjdENvbnRhaW4gPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICBcdHZhciByZWN0ID0gdGhpcy5nZXRSZWN0KCk7XHJcbiAgICAgICAgcmV0dXJuIHJlY3QuYm91bmRpbmdSZWN0LmNvbnRhaW4oeCx5KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDov5Tlm55qc29u5a+56LGhXHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGpzb27lr7nosaFcclxuICAgICAqL1xyXG5cdEJQTU5Ob2RlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMubW9kZWwuc2V0KFwicmVzb3VyY2VJZFwiLCB0aGlzLnJlc291cmNlSWQpO1xyXG5cdFx0dGhpcy5tb2RlbC5zZXQoXCJwcm9wZXJ0aWVzLnR5cGVcIiwgdGhpcy5icG1uSW5mby50eXBlKTtcclxuXHRcdHRoaXMubW9kZWwuc2V0KFwic3RlbmNpbC50eXBlXCIsIHRoaXMuYnBtbkluZm8ubmFtZSk7ICAvL3N0ZW5jaWwuaWRcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc2xvdEV2ZW50ICYmIHRoaXMuc2xvdEV2ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGFyclNsb3RFdmVudCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5zbG90RXZlbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGFyclNsb3RFdmVudC5wdXNoKHRoaXMuc2xvdEV2ZW50W2ldLnJlc291cmNlSWQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJwcm9wZXJ0aWVzLnNsb3RFdmVudFwiLCBhcnJTbG90RXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInByb3BlcnRpZXMudHlwZVwiLCB0aGlzLmJwbW5JbmZvLnR5cGUpO1xyXG5cclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0UmVjdCgpLmJvdW5kaW5nUmVjdDtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImJvdW5kcy51cHBlckxlZnQueFwiLCBwYXJzZUludChyZWN0LngpKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImJvdW5kcy51cHBlckxlZnQueVwiLCBwYXJzZUludChyZWN0LnkpKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImJvdW5kcy5sb3dlclJpZ2h0LnhcIiwgcGFyc2VJbnQocmVjdC54ICsgcmVjdC53aWR0aCkpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLmxvd2VyUmlnaHQueVwiLCBwYXJzZUludChyZWN0LnkgKyByZWN0LmhlaWdodCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMubW9kZWwub3B0aW9uO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOagueaNruWxnuaAp+iuvue9ruaooeWei+aVsOaNrlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbiDmqKHlnovmlbDmja5cclxuICAgICAqL1xyXG4gICAgQlBNTk5vZGUucHJvdG90eXBlLnNldE1vZGVsID0gZnVuY3Rpb24ob3B0aW9uKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLCBwb3M7XHJcbiAgICAgICAgdmFyIG9yaWdpblRleHQgPSB0aGlzLm1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKTtcclxuICAgICAgICB0aGlzLm1vZGVsLm1lcmdlT3B0aW9uKG9wdGlvbik7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudFgobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQubm9kZVR5cGUgPT0gXCJTdWJQcm9jZXNzXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzBdICsgcGFyZW50WChub2RlLnBhcmVudClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzBdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBmdW5jdGlvbiBwYXJlbnRZKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50Lm5vZGVUeXBlID09IFwiU3ViUHJvY2Vzc1wiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblsxXSArIHBhcmVudFkobm9kZS5wYXJlbnQpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblsxXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZighb3B0aW9uLnByb3BlcnRpZXMubmFtZSAmJiBvcHRpb24ucHJvcGVydGllcy5uYW1lICE9ICcnICYmIG9wdGlvbi5wcm9wZXJ0aWVzLm5hbWUgIT0gJzAnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYob3JpZ2luVGV4dCAhPSBvcHRpb24ucHJvcGVydGllcy5uYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IHRoaXMuY2hpbGRPZk5hbWUoXCJUaXRsZVwiKTtcclxuICAgICAgICAgICAgdmFyIG5hbWVCeXRlTGVuZ3RoID0gdXRmOExlbmd0aChvcHRpb24ucHJvcGVydGllcy5uYW1lKTtcclxuICAgICAgICAgICAgdmFyIHNob3dOYW1lO1xyXG4gICAgICAgICAgICBpZihuYW1lQnl0ZUxlbmd0aCA+IDE1KXtcclxuICAgICAgICAgICAgICAgIHNob3dOYW1lID0gb3B0aW9uLnByb3BlcnRpZXMubmFtZS5zdWJzdHIoMCw2KSsnLi4nO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5hbGFybSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGFybS5pc1Nob3cgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHNob3dOYW1lID0gb3B0aW9uLnByb3BlcnRpZXMubmFtZTtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuYWxhcm0pe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxhcm0uaXNTaG93ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRpdGxlLmF0dHIoXCJzdHlsZVwiLHt0ZXh0OnNob3dOYW1lfSk7XHJcbiAgICAgICAgICAgIHBvcyA9IG9wdGlvbi5wcm9wZXJ0aWVzLnBvc2l0aW9uID8gb3B0aW9uLnByb3BlcnRpZXMucG9zaXRpb24gOiAnaW5pdCc7XHJcbiAgICAgICAgICAgIHRoYXQucmVmcmVzaFRleHQocG9zKTtcclxuICAgICAgICAgICBpZih0aGlzLmFsYXJtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG9wdGlvbi5wcm9wZXJ0aWVzLm5hbWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuYWxhcm0uY2hpbGRPZk5hbWUoXCJUZXh0XCIpO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5hdHRyKFwic3R5bGVcIix7dGV4dDpuYW1lfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBXaWR0aCA9IHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGgrNDtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cEhlaWdodCA9IHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0Kzg7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIFswLDBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLDBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICBbZ3JvdXBXaWR0aC0zLGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICBbZ3JvdXBXaWR0aC02LGdyb3VwSGVpZ2h0KzNdLFxyXG4gICAgICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLTksZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgIFswLGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICBbMCwwXVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIHZhciBQb2x5bGluZSA9IHRoaXMuYWxhcm0uY2hpbGRPZk5hbWUoXCJQb2x5bGluZVwiKTtcclxuICAgICAgICAgICAgICAgIFBvbHlsaW5lLmF0dHIoXCJzaGFwZVwiLHtwb2ludHM6cG9pbnRzfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zWCA9IHBhcmVudFgodGhpcyksIHBvc1kgPSBwYXJlbnRZKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwUG9zaXRpb24gPSBbcG9zWCArIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLSAodGhpcy5hbGFybS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aC02KSwgcG9zWSAtIHRoaXMuYWxhcm0uZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC0gM107XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsYXJtLmF0dHIoXCJwb3NpdGlvblwiLGdyb3VwUG9zaXRpb24pO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcblx0enJVdGlsLmluaGVyaXRzKEJQTU5Ob2RlLE5vZGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5rOo5YaMQlBNTuiKgueCueeahOexu++8jOWPquacieazqOWGjOi/h+WQju+8jOaJjeiDveWcqEJQTU7nvJbovpHlmajkuK3mt7vliqBcclxuICAgICAqIEBtZXRob2QgcmVnaXN0ZXJDbGFzc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IENsYXp6IOe7p+aJv+S6hkJQTU5Ob2Rl55qE5a6e546w57G7XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50VHlwZSDms6jlhoznsbvnmoTlkI3np7BcclxuICAgICAqXHJcbiAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhDdXN0b21Ob2RlLCBcIkN1c3RvbU5vZGVcIik7XHJcbiAgICAgKi9cclxuXHRjbGF6elV0aWwuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KEJQTU5Ob2RlLCB7XHJcbiAgICAgICAgcmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlXHJcbiAgICB9KTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IEJQTU5Ob2RlO1xyXG5cclxuXHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9CUE1OTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4vZ3JhcGhpYycpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpXHJcbiAgICAvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZSAg5YyF5ousZnJvbUpTT04gdG9KU09OXHJcbiAgICBmdW5jdGlvbiBOb2RlKCkge1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VJZCA9IHV0aWwuZ2V0VVVJRCgpOyAvLyDnlJ/miJDoioLngrlJRFxyXG4gICAgICAgIGdyYXBoaWMuR3JvdXAuY2FsbCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUseeItuexu+WunueOsFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlLHniLbnsbvlrp7njrBcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0ganNvbiBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24oanNvbikge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkcmF3VGV4dFxyXG4gICAgICogQGRlc2NyaXB0aW9uIOeUu+S4gOS4quaWh+acrFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS5kcmF3VGV4dCA9IGZ1bmN0aW9uKG5hbWUsIGNvbG9yLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciB0ZXh0TmFtZSA9IHRoaXMuYnBtbkluZm8ubmFtZSwgeCwgeTtcclxuICAgICAgICBpZihuYW1lICE9IG51bGwpe1xyXG4gICAgICAgICAgICB0ZXh0TmFtZSA9IG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0TmFtZSxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvciA/IGNvbG9yIDogdGhpcy5vcHRpb25zLnRleHQuY29sb3IsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzEycHggTWljcm9zb2Z0IFlhSGVpJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6bGV2ZWw6IDIwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy/mloflrZfnu5jliLbnmoTkvY3nva4gXHJcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA/IHBvc2l0aW9uIDogJ2luaXQnO1xyXG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcclxuICAgICAgICAgICAgLy/oioLngrnkuIvmlrnlsYXkuK3kvY3nva5cclxuICAgICAgICAgICAgY2FzZSAnaW5pdCc6IFxyXG4gICAgICAgICAgICAgICAgLy94ID0g5Lit5b+D54K5LnggLSDotbflp4vkvY3nva4ueCAtIOaWh+Wtl+WuveW6pueahOS4gOWNilxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0UmVjdCgpLnggLSB0aGlzLnBvc2l0aW9uWzBdIC0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAvL3kgPSDkuK3lv4PngrkueSAtIOi1t+Wni+S9jee9ri55ICsg5YGP56e75YC877yINu+8iVxyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2V0UmVjdCgpLnkgLSB0aGlzLnBvc2l0aW9uWzFdICsgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyICsgNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvL+iKgueCueWGhemDqOWxheS4reS9jee9rlxyXG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0UmVjdCgpLnggLSB0aGlzLnBvc2l0aW9uWzBdIC0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRSZWN0KCkueSAtIHRoaXMucG9zaXRpb25bMV0gLSA2O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIC8v6IqC54K55YaF6YOo5bGF5bem5L2N572uXHJcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOiBcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLmdldFJlY3QoKS54IC0gdGhpcy5wb3NpdGlvblswXSAtIHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggKyA2O1xyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2V0UmVjdCgpLnkgLSB0aGlzLnBvc2l0aW9uWzFdIC0gNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OiBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dC5hdHRyKFwic3R5bGVcIiwgeyB4OiB4LCB5OiB5IH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgICAgIHJlY3Q6IHRleHQuZ2V0Qm91bmRpbmdSZWN0KClcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogcmVmcmVzaFRleHRcclxuICAgICAqIEBkZXNjcmlwdGlvbiDliLfmlrDmlofmnKxcclxuICAgICAqL1xyXG4gICAgTm9kZS5wcm90b3R5cGUucmVmcmVzaFRleHQgPSBmdW5jdGlvbihwb3MpIHtcclxuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJUaXRsZVwiKSwgeCwgeTtcclxuICAgICAgICBwb3MgPSBwb3MgPyBwb3MgOiAnaW5pdCc7XHJcbiAgICAgICAgc3dpdGNoIChwb3MpIHtcclxuICAgICAgICAgICAgY2FzZSAnaW5pdCc6IFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0UmVjdCgpLnggLSB0aGlzLnBvc2l0aW9uWzBdIC0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRSZWN0KCkueSAtIHRoaXMucG9zaXRpb25bMV0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAvIDIgKyA2O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5nZXRSZWN0KCkueCAtIHRoaXMucG9zaXRpb25bMF0gLSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLmdldFJlY3QoKS55IC0gdGhpcy5wb3NpdGlvblsxXSAtIDY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICB4ID0gMjtcclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLmdldFJlY3QoKS55IC0gdGhpcy5wb3NpdGlvblsxXSAtIDY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDogYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHQuYXR0cihcInN0eWxlXCIsIHsgeDogeCwgeTogeSB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOeUseeItuexu+WunueOsFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgZ3JhcGhpYy5VdGlsLmluaGVyaXRzKE5vZGUsIGdyYXBoaWMuR3JvdXApO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHJcbiAgICB2YXIgY2xhenogPSB7fTtcclxuXHJcbiAgICB2YXIgVFlQRV9ERUxJTUlURVIgPSAnLic7XHJcbiAgICB2YXIgSVNfQ09OVEFJTkVSID0gJ19fX0ZUX19DT01QT05FTlRfX0NPTlRBSU5FUl9fXyc7XHJcbiAgICAvKipcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgdmFyIHBhcnNlQ2xhc3NUeXBlID0gY2xhenoucGFyc2VDbGFzc1R5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgIHZhciByZXQgPSB7bWFpbjogJycsIHN1YjogJyd9O1xyXG4gICAgICAgIGlmIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBjb21wb25lbnRUeXBlLnNwbGl0KFRZUEVfREVMSU1JVEVSKTtcclxuICAgICAgICAgICAgcmV0Lm1haW4gPSBjb21wb25lbnRUeXBlWzBdIHx8ICcnO1xyXG4gICAgICAgICAgICByZXQuc3ViID0gY29tcG9uZW50VHlwZVsxXSB8fCAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwdWJsaWMgIOebuOavlCDnm7TmjqXnlKh6clV0aWwuaW5oZXJpdHMg5aW95aSE5pivICDlj6/ku6Xnm7TmjqXosIPnlKjniLbnsbvnmoTmnoTpgKDlh73mlbBcclxuICAgICAqL1xyXG4gICAgY2xhenouZW5hYmxlQ2xhc3NFeHRlbmQgPSBmdW5jdGlvbiAoUm9vdENsYXNzLCBwcmVDb25zdHJ1Y3QpIHtcclxuICAgICAgICBSb290Q2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3RvKSB7XHJcbiAgICAgICAgICAgIHZhciBFeHRlbmRlZENsYXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcHJlQ29uc3RydWN0ICYmIHByZUNvbnN0cnVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgUm9vdENsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB6clV0aWwuZXh0ZW5kKEV4dGVuZGVkQ2xhc3MucHJvdG90eXBlLCBwcm90byk7XHJcblxyXG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLmV4dGVuZCA9IHRoaXMuZXh0ZW5kO1xyXG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLnN1cGVyQ2FsbCA9IHN1cGVyQ2FsbDtcclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckFwcGx5ID0gc3VwZXJBcHBseTtcclxuICAgICAgICAgICAgenJVdGlsLmluaGVyaXRzKEV4dGVuZGVkQ2xhc3MsIHRoaXMpO1xyXG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLnN1cGVyQ2xhc3MgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIEV4dGVuZGVkQ2xhc3M7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gc3VwZXJDYWxsIHNob3VsZCBoYXZlIGNsYXNzIGluZm8sIHdoaWNoIGNhbiBub3QgYmUgZmV0Y2ggZnJvbSAndGhpcycuXHJcbiAgICAvLyBDb25zaWRlciB0aGlzIGNhc2U6XHJcbiAgICAvLyBjbGFzcyBBIGhhcyBtZXRob2QgZixcclxuICAgIC8vIGNsYXNzIEIgaW5oZXJpdHMgY2xhc3MgQSwgb3ZlcnJpZGVzIG1ldGhvZCBmLCBmIGNhbGwgc3VwZXJBcHBseSgnZicpLFxyXG4gICAgLy8gY2xhc3MgQyBpbmhlcml0cyBjbGFzcyBCLCBkbyBub3Qgb3ZlcnJpZGVzIG1ldGhvZCBmLFxyXG4gICAgLy8gdGhlbiB3aGVuIG1ldGhvZCBvZiBjbGFzcyBDIGlzIGNhbGxlZCwgZGVhZCBsb29wIG9jY3VyZWQuXHJcbiAgICBmdW5jdGlvbiBzdXBlckNhbGwoY29udGV4dCwgbWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHZhciBhcmdzID0genJVdGlsLnNsaWNlKGFyZ3VtZW50cywgMik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3VwZXJBcHBseShjb250ZXh0LCBtZXRob2ROYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW50aXR5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWdpc3RlcldoZW5FeHRlbmRdXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGNsYXp6LmVuYWJsZUNsYXNzTWFuYWdlbWVudCA9IGZ1bmN0aW9uIChlbnRpdHksIG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29tcG9uZW50IG1vZGVsIGNsYXNzZXNcclxuICAgICAgICAgKiBrZXk6IGNvbXBvbmVudFR5cGUsXHJcbiAgICAgICAgICogdmFsdWU6XHJcbiAgICAgICAgICogICAgIGNvbXBvbmVudENsYXNzLCB3aGVuIGNvbXBvbmVudFR5cGUgaXMgJ3h4eCdcclxuICAgICAgICAgKiAgICAgb3IgT2JqZWN0LjxzdWJLZXksIGNvbXBvbmVudENsYXNzPiwgd2hlbiBjb21wb25lbnRUeXBlIGlzICd4eHgueXknXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgc3RvcmFnZSA9IHt9O1xyXG5cclxuICAgICAgICBlbnRpdHkucmVnaXN0ZXJDbGFzcyA9IGZ1bmN0aW9uIChDbGF6eiwgY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50VHlwZS5zdWIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5bey57uP5rOo5YaM6L+H5LqG77yM55u05o6l6L+U5ZueXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dID0gQ2xheno7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnRUeXBlLnN1YiAhPT0gSVNfQ09OVEFJTkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG1ha2VDb250YWluZXIoY29tcG9uZW50VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyW2NvbXBvbmVudFR5cGUuc3ViXSA9IENsYXp6O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBDbGF6ejtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZU1haW4sIHN1YlR5cGUsIHRocm93V2hlbk5vdEZvdW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBDbGF6eiA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZU1haW5dO1xyXG5cclxuICAgICAgICAgICAgaWYgKENsYXp6ICYmIENsYXp6W0lTX0NPTlRBSU5FUl0pIHtcclxuICAgICAgICAgICAgICAgIENsYXp6ID0gc3ViVHlwZSA/IENsYXp6W3N1YlR5cGVdIDogbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRocm93V2hlbk5vdEZvdW5kICYmICFDbGF6eikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICdDb21wb25lbnQgJyArIGNvbXBvbmVudFR5cGVNYWluICsgJy4nICsgKHN1YlR5cGUgfHwgJycpICsgJyBub3QgZXhpc3RzLiBMb2FkIGl0IGZpcnN0LidcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBDbGF6ejtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkuZ2V0Q2xhc3Nlc0J5TWFpblR5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgIHZhciBvYmogPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XHJcblxyXG4gICAgICAgICAgICBpZiAob2JqICYmIG9ialtJU19DT05UQUlORVJdKSB7XHJcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChvYmosIGZ1bmN0aW9uIChvLCB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gSVNfQ09OVEFJTkVSICYmIHJlc3VsdC5wdXNoKG8pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmopO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGVudGl0eS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIC8vIEp1c3QgY29uc2lkZXIgY29tcG9uZW50VHlwZS5tYWluLlxyXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybiAhIXN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gTGlrZSBbJ2FhJywgJ2JiJ10sIGJ1dCBjYW4gbm90IGJlIFsnYWEueHgnXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVudGl0eS5nZXRBbGxDbGFzc01haW5UeXBlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGVzID0gW107XHJcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHN0b3JhZ2UsIGZ1bmN0aW9uIChvYmosIHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2godHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgYSBtYWluIHR5cGUgaXMgY29udGFpbmVyIGFuZCBoYXMgc3ViIHR5cGVzXHJcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSAgY29tcG9uZW50VHlwZVxyXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW50aXR5Lmhhc1N1YlR5cGVzID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIG9ialtJU19DT05UQUlORVJdO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGVudGl0eS5wYXJzZUNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBtYWtlQ29udGFpbmVyKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcclxuICAgICAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lcltJU19DT05UQUlORVJdKSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl0gPSB7fTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcltJU19DT05UQUlORVJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMucmVnaXN0ZXJXaGVuRXh0ZW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEV4dGVuZCA9IGVudGl0eS5leHRlbmQ7XHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEV4dGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBFeHRlbmRlZENsYXNzID0gb3JpZ2luYWxFeHRlbmQuY2FsbCh0aGlzLCBwcm90byk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudGl0eS5yZWdpc3RlckNsYXNzKEV4dGVuZGVkQ2xhc3MsIHByb3RvLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjbGF6ejtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9jbGF6ei5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEJQTU4gbW9kZWxcclxuICpcclxuICovXHJcblxyXG5cclxuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9tb2RlbCcpO1xyXG4gICAgdmFyIEJQTU5Nb2RlbCA9IE1vZGVsLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdCUE1OJyxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XHJcbiAgICAgICAgICAgIHJlc291cmNlSWQ6IFwiXCIsICAvL+i1hOa6kElEXHJcblxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAtMSwgIC8v57G75Z6LXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBudWxsLCAvL+WQjeensFxyXG4gICAgICAgICAgICAgICAgbm90ZXM6IFwiXCIsICAvL+Wkh+azqFxyXG4gICAgICAgICAgICAgICAgLy9ubzogXCJcIlxyXG4gICAgICAgICAgICAgICAgZXh0UHJvcGVydGllczoge30gIC8v5omp5bGV5bGe5oCnXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzdGVuY2lsOiB7dHlwZTogXCJCUE1ORGlhZ3JhbVwifSxcclxuXHJcbiAgICAgICAgICAgIGNoaWxkU2hhcGVzOiBbXSwgICAgLy/lrZDlvaLnirZcclxuXHJcbiAgICAgICAgICAgIG91dGdvaW5nOiBbXSwgIC8vIOS4i+S4gOS4quimgei/nuaOpeeahOW9oueKtlxyXG5cclxuICAgICAgICAgICAgYm91bmRzOiB7XHJcbiAgICAgICAgICAgICAgICB1cHBlckxlZnQ6IHt4OjAsIHk6MH0sICAvL+W3puS4iuinkuWdkOagh1xyXG4gICAgICAgICAgICAgICAgbG93ZXJSaWdodDoge3g6MCwgeTowfSAvL+WPs+S4i+inkuWdkOagh1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJQTU5Nb2RlbDtcclxuXHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbW9kZWwvQlBNTk1vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog6IqC54K5562J55qE5qih5Z6LXHJcbiAqIOmHjOmdouWtmOeahOaVsOaNrueUqOadpeWkhOeQhuW6j+WIl+WMluWSjOWPjeW6j+WIl+WMllxyXG4gKiBAY2xhc3MgZmlzaC50b3BvLm1vZGVsXHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi9jbGF6eicpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1vZGVsKG9wdGlvbiwgcGFyZW50TW9kZWwsICBleHRyYU9wdCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50TW9kZWwgPSBwYXJlbnRNb2RlbDtcclxuICAgICAgICB0aGlzLm9wdGlvbiA9IG9wdGlvbjtcclxuXHJcbiAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxyXG4gICAgICAgIGlmICh0aGlzLmluaXQpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KG9wdGlvbiwgcGFyZW50TW9kZWwsICBleHRyYU9wdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBNb2RlbC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBNb2RlbCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTW9kZWwg55qE5Yid5aeL5YyW5Ye95pWwXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGlzLmdldERlZmF1bHRPcHRpb24oKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0RGVmYXVsdE9wdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ19fZGVmYXVsdE9wdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0TGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIENsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBDbGFzcy5wcm90b3R5cGUuZGVmYXVsdE9wdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBvcHQgJiYgb3B0TGlzdC5wdXNoKG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBDbGFzcy5zdXBlckNsYXNzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0T3B0aW9uID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb3B0TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb24gPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbiwgb3B0TGlzdFtpXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGVmYXVsdE9wdGlvbiA9IGRlZmF1bHRPcHRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kZWZhdWx0T3B0aW9uO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICAgICAgenJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBvcHRpb24sIHRydWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPlm1vZGVs55qE5p+Q5Liq5bGe5oCn55qE5YC8XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggbW9kZWzkuK3nmoTlsZ7mgKdcclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAgICAgbm9kZS5tb2RlbC5nZXQoXCJvcHRpb25zLnRleHRcIik7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAocGF0aCwgaWdub3JlUGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghcGF0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5vcHRpb247XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRNb2RlbCA9IHRoaXMucGFyZW50TW9kZWw7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gb2JqIGNvdWxkIGJlIG51bWJlci9zdHJpbmcvLi4uIChsaWtlIDApXHJcbiAgICAgICAgICAgICAgICBvYmogPSAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSA/IG9ialtwYXRoW2ldXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2JqID09IG51bGwgJiYgcGFyZW50TW9kZWwgJiYgIWlnbm9yZVBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgb2JqID0gcGFyZW50TW9kZWwuZ2V0KHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6K6+572ubW9kZWznmoTmn5DkuKrlsZ7mgKfnmoTlgLxcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBtb2RlbOS4reeahOWxnuaAp1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSDmiYDpnIDopoHorr7nva7nmoTlgLxcclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAgICAgbm9kZS5tb2RlbC5zZXQoXCJvcHRpb25zLnRleHRcIixcIuS+i+WtkFwiKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXRoLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5vcHRpb247XHJcblxyXG4gICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKFwiLlwiKSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgb2JqW3BhdGhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRBcnJheSAgPSBwYXRoLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGZpZWxkQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRSZWYgPSBvYmo7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGROYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkQXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudFJlZltmaWVsZE5hbWVdID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlZltmaWVsZE5hbWVdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZWYgPSBjdXJyZW50UmVmW2ZpZWxkTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSBmaWVsZEFycmF5W24tMV07XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVmW2ZpZWxkTmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0U2hhbGxvdzogZnVuY3Rpb24gKGtleSwgaWdub3JlUGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IG9wdGlvbiAmJiBvcHRpb25ba2V5XTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudE1vZGVsID0gdGhpcy5wYXJlbnRNb2RlbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsICYmIHBhcmVudE1vZGVsICYmICFpZ25vcmVQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IHBhcmVudE1vZGVsLmdldFNoYWxsb3coa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0TW9kZWw6IGZ1bmN0aW9uIChwYXRoLCBwYXJlbnRNb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXQocGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciB0aGlzUGFyZW50TW9kZWwgPSB0aGlzLnBhcmVudE1vZGVsO1xyXG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoXHJcbiAgICAgICAgICAgICAgICBvYmosIHBhcmVudE1vZGVsIHx8ICh0aGlzUGFyZW50TW9kZWwgJiYgdGhpc1BhcmVudE1vZGVsLmdldE1vZGVsKHBhdGgpKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kZWw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICrmuIXnqbptb2RlbOeahG9wdGlvblxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb24gPT0gbnVsbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge30sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIEN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoenJVdGlsLmNsb25lKHRoaXMub3B0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFbmFibGUgTW9kZWwuZXh0ZW5kLlxyXG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKE1vZGVsKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHR2YXIgRXZlbnROb2RlID0gcmVxdWlyZShcIi4vRXZlbnROb2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG5cclxuXHRmdW5jdGlvbiBTdGFydEV2ZW50Tm9kZShtb2RlbCwgYXBpKSB7XHJcblx0XHRFdmVudE5vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMTg7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAyOSwgbmFtZTpcIlN0YXJ0Tm9uZUV2ZW50XCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcblx0fVxyXG5cclxuICAgIFN0YXJ0RXZlbnROb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciBjaXJjbGUgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgIHI6IHRoaXMuaXRlbVNpemUtMC41XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnIzAwMCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejoyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlLm5hbWUgPSBcIkNpcmNsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZSk7XHJcbiAgICAgICAgdmFyIGNpcmNsZTEgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgIHI6IHRoaXMuaXRlbVNpemUtMlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmZmYnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNpcmNsZTEubmFtZSA9IFwiQ2lyY2xlMVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZTEpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpICsgdGhpcy5pdGVtU2l6ZSwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpICsgdGhpcy5pdGVtU2l6ZV07XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5kcmF3VGV4dChtb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuXHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoU3RhcnRFdmVudE5vZGUsIEV2ZW50Tm9kZSk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBTdGFydEV2ZW50Tm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2V2ZW50L1N0YXJ0RXZlbnROb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuICAgIHZhciBCUE1OTm9kZSA9IHJlcXVpcmUoXCIuLi9CUE1OTm9kZVwiKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcycpO1xyXG4gICAgLy/liJvlu7pOb2Rl57G7IOaJgOacieW9oueKtumDvee7p+aJv05vZGUgIOWMheaLrGZyb21KU09OIHRvSlNPTlxyXG4gICAgLy9cclxuICAgIGZ1bmN0aW9uIEV2ZW50Tm9kZShtb2RlbCxhcGkpIHtcclxuICAgICAgICBCUE1OTm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMuYnBtbkluZm8gPSB7dHlwZTogLTEsIG5hbWU6XCJFdmVudE5vZGVcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgRXZlbnROb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBFdmVudE5vZGUucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBib2R5Li4uXHJcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgLy/liJvlu7rmnIDlsI/ljIXlm7Tnm5LomZrnur9cclxuICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgcG9pbnRzWzBdID1bLWJvdW5kaW5nUmVjdC53aWR0aC8yLC1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1sxXSA9W2JvdW5kaW5nUmVjdC53aWR0aC8yLC1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1syXSA9W2JvdW5kaW5nUmVjdC53aWR0aC8yLGJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzNdID1bLWJvdW5kaW5nUmVjdC53aWR0aC8yLGJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzRdID1bLWJvdW5kaW5nUmVjdC53aWR0aC8yLC1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG5cclxuICAgICAgICAvL+azqDog5Zug5LqL5Lu25Li65ZyG5b2iICDmiYDku6UgeCB5IOS4uuWchuW/g+eahOS9jee9riAg5YyF5Zu055+p5b2i6KaB5YeP5Y675a695bqm5LiA5Y2KXHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSAtIGJvdW5kaW5nUmVjdC53aWR0aC8yICxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdIC0gYm91bmRpbmdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nUmVjdC53aWR0aCwgYm91bmRpbmdSZWN0LmhlaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogdGhpcy5wb3NpdGlvblswXSxcclxuICAgICAgICAgICAgeTogdGhpcy5wb3NpdGlvblsxXSxcclxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aC8yLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQvMixcclxuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgICAgIGJvdW5kaW5nUmVjdDogYm91bmRSZWN0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9O1xyXG4gICAgRXZlbnROb2RlLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHBYLHBZKSB7XHJcbiAgICAgICAgLy8gYm9keS4uLlxyXG4gICAgICAgIHRoaXMuYXR0cigncG9zaXRpb24nLFtwWCxwWV0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBFdmVudE5vZGUucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBjaXJjbGUgPSB0aGlzLmNoaWxkT2ZOYW1lKFwiQ2lyY2xlXCIpO1xyXG4gICAgICAgIHJldHVybiBjaXJjbGUuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIEV2ZW50Tm9kZS5wcm90b3R5cGUudXBkYXRlU2hhcGUgPSBmdW5jdGlvbihyYXRpbywgaWZQYXJzZSkge1xyXG4gICAgICAgIHZhciBjaXJjbGUgPSB0aGlzLmNoaWxkT2ZOYW1lKFwiQ2lyY2xlXCIpO1xyXG4gICAgICAgIHZhciBjaXJjbGUxID0gdGhpcy5jaGlsZE9mTmFtZShcIkNpcmNsZTFcIik7XHJcbiAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgIHZhciBzaGFwZSA9IGNpcmNsZS5zaGFwZTtcclxuICAgICAgICB2YXIgc2hhcGUxID0gY2lyY2xlMS5zaGFwZTtcclxuICAgICAgICB2YXIgbmV3UiA9IE51bWJlcihzaGFwZS5yICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgdmFyIG5ld1IxID0gTnVtYmVyKHNoYXBlMS5yICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgbmV3UiA9IHBhcnNlSW50KG5ld1IsIDEwKTtcclxuICAgICAgICAgICAgbmV3UjEgPSBwYXJzZUludChuZXdSMSwgMTApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaXJjbGUuc2V0U2hhcGUoe1xyXG4gICAgICAgICAgICByOiBuZXdSXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlMS5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgIHI6IG5ld1IxXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoRXZlbnROb2RlLEJQTU5Ob2RlKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gRXZlbnROb2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZXZlbnQvRXZlbnROb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHR2YXIgRXZlbnROb2RlID0gcmVxdWlyZShcIi4vRXZlbnROb2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG5cclxuXHRmdW5jdGlvbiBFbmRFdmVudE5vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0RXZlbnROb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMTg7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAzMSwgbmFtZTpcIkVuZE5vbmVFdmVudFwiIH07XHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBFbmRFdmVudE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZS0wLjVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaXJjbGUubmFtZSA9IFwiQ2lyY2xlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQoY2lyY2xlKTtcclxuICAgICAgICB2YXIgY2lyY2xlMSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZS01XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejoyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlMS5uYW1lID0gXCJDaXJjbGUxXCI7XHJcbiAgICAgICAgdGhpcy5hZGQoY2lyY2xlMSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikgKyB0aGlzLml0ZW1TaXplLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIikgKyB0aGlzLml0ZW1TaXplXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAgICAgICAgdGl0bGUudGV4dC5uYW1lID0gXCJUaXRsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHRpdGxlLnRleHQpO1xyXG5cclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhFbmRFdmVudE5vZGUsIEV2ZW50Tm9kZSk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBFbmRFdmVudE5vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9FbmRFdmVudE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cdHZhciBUYXNrTm9kZSA9IHJlcXVpcmUoXCIuL1Rhc2tOb2RlLmpzXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4vKipcclxuICpcclxuICogPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgbWluaW11bVNpemU9XCI4NSA1NVwiIGlkPVwic2lkLThBMUNEQTIxLTlDRDAtNDhFQy1CNDlELTY0NDc0RUVERUY2RFwiIHRpdGxlPVwiVXNlciB0YXNrXCI+XHJcbiAqICAgPHJlY3QgaWQ9XCJzaWQtOEExQ0RBMjEtOUNEMC00OEVDLUI0OUQtNjQ0NzRFRURFRjZEdGV4dF9mcmFtZVwiIGFuY2hvcnM9XCJib3R0b20gdG9wIHJpZ2h0IGxlZnRcIiB4PVwiMS4wMDAwMDAwNTk4Mzc3NTVcIiB5PVwiMS4wMTYyMDI0OTI0XCIgd2lkdGg9XCI3MlwiIGhlaWdodD1cIjIyLjAwMDAwMDAwMDAwMDAwNFwiIHJ4PVwiN1wiIHJ5PVwiN1wiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIwXCIgZmlsbD1cIm5vbmVcIj5cclxuICogICA8L3JlY3Q+XHJcbiAqICAgPHJlY3QgaWQ9XCJzaWQtOEExQ0RBMjEtOUNEMC00OEVDLUI0OUQtNjQ0NzRFRURFRjZEYmdfZnJhbWVcIiByZXNpemU9XCJ2ZXJ0aWNhbCBob3Jpem9udGFsXCIgeD1cIjUuOTgzNzc1NDllLThcIiB5PVwiMC4wMTYyMDI0OTI0XCIgd2lkdGg9XCI4NVwiIGhlaWdodD1cIjU1XCIgcng9XCI3XCIgcnk9XCI3XCIgc3Ryb2tlPVwiI2JiYmJiYlwiIHN0cm9rZS13aWR0aD1cIjFcIiBmaWxsPVwiI2Y5ZjlmOVwiPlxyXG4gKiAgIDwvcmVjdD5cclxuICogICA8cmVjdCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGlkPVwic2lkLThBMUNEQTIxLTlDRDAtNDhFQy1CNDlELTY0NDc0RUVERUY2RGFyZWFfc3RhdGVcIiBhbmNob3JzPVwiYm90dG9tXCIgeD1cIjUuOTgzNzc1NDllLThcIiB5PVwiNDUuMDE2MjAyNDkyNFwiIHdpZHRoPVwiODVcIiBoZWlnaHQ9XCIxMFwiIHJ4PVwiMTBcIiByeT1cIjEwXCIgcmVzaXplPVwiaG9yaXpvbnRhbFwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIwXCIgZmlsbD1cIm5vbmVcIiBzdHlsZT1cIlwiPlxyXG4gKiAgIDwvcmVjdD5cclxuICogICA8dGV4dCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZvbnQtc2l6ZT1cIjEyXCIgaWQ9XCJzaWQtOEExQ0RBMjEtOUNEMC00OEVDLUI0OUQtNjQ0NzRFRURFRjZEdGV4dF9uYW1lXCIgeD1cIjUyXCIgeT1cIjM1XCIgYWxpZ249XCJtaWRkbGUgY2VudGVyXCIgZml0dG9lbGVtPVwidGV4dF9mcmFtZVwiIHN0cm9rZT1cIiMzNzNlNDhcIiBzdHJva2Utd2lkdGg9XCIwcHRcIiBsZXR0ZXItc3BhY2luZz1cIi0wLjAxcHhcIiB0cmFuc2Zvcm09XCJyb3RhdGUoMCA1MiAzNSlcIiBvcnl4OmZvbnRTaXplPVwiMTJcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPlxyXG4gKiAgICAgICA8dHNwYW4geD1cIjUyXCIgeT1cIjM1XCIgZHk9XCI1XCI+VGFza1xyXG4gKiAgICAgICA8L3RzcGFuPlxyXG4gKiAgIDwvdGV4dD5cclxuICogICA8ZyBpZD1cInNpZC04QTFDREEyMS05Q0QwLTQ4RUMtQjQ5RC02NDQ3NEVFREVGNkR1c2VyVGFza1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg1LjAwMDAwMCwgNS4wMDAwMDApXCIgZmlsbD1cIiM0OTkwRTJcIj5cclxuICogICAgICAgPHBhdGggYW5jaG9ycz1cInRvcCBsZWZ0XCIgZD1cIiBNNC42ODk3NTQ3NDk4Mzc3NTUgMC43NTQ3NDk3MjE0MDAwMDAxICBDMy4xMjQ5MDg2Mzk4Mzc3NTUgMS41MDk0OTk0NDI0IDIuNTM2OTAyOTg5ODM3NzU1IDIuODM1OTQwNDUyNCAzLjAzODg1MzI5OTgzNzc1NDcgNS4zODc4MTk0NzIzOTk5OTk1ICBDMy41NDA4MDM1OTk4Mzc3NTUgNy45Mzk2OTg1MDI0IDQuMjU2ODU0Mzc5ODM3NzU2IDcuOTcyOTIxODEyNCA0LjY4OTc1NDc0OTgzNzc1NSA4LjkyMDc2MjU5MjQgIEM1LjEyMjY1NTExOTgzNzc1NSA5Ljg2ODYwMzM3MjM5OTk5OSA0LjgzNDA1NDg4OTgzNzc1NTYgMTAuNjcwNjIyNDkyNCAzLjgyMzk1Mzg3OTgzNzc1NDYgMTEuMTA4MDg3NDkyNCAgQzIuODEzODUyODc5ODM3NzU1IDExLjU0NTU1MjQ5MjQgMS4xOTY3NTUwOTQ5OTk5OTk5ZS03IDEyLjg1Nzk0NzM5MjQgNS45ODM3NzU0OWUtOCAxMy41ODcwNTU2OTI0ICBDMCAxNC4zMTYxNjM5OTI0IDEuMjI2NTUxMjg5ODM3NzU1IDE0LjI0MzI1MzA5MjQgMi4zMDg4MDIzNjk4Mzc3NTQ3IDE0LjI0MzI1MzA5MjQgIEMzLjM5MTA1MzQ0OTgzNzc1NSAxNC4yNDMyNTMwOTI0IDkuMDkwOTA5MTQ5ODM3NzU1IDE0LjI0MzI1MzA5MjQgOS4wOTA5MDkxNDk4Mzc3NTUgMTQuMjQzMjUzMDkyNCAgTDkuMTYzMDU5MjE5ODM3NzU0IDAuNTIzNzcwNDgwNDAwMDAwMSAgQzkuMTYzMDU5MjE5ODM3NzU0IDAuNTIzNzcwNDgwNDAwMDAwMSA2LjI1NDYwMDg1OTgzNzc1NiAwIDQuNjg5NzU0NzQ5ODM3NzU1IDAuNzU0NzQ5NzIxNDAwMDAwMSAgelwiIGlkPVwic2lkLThBMUNEQTIxLTlDRDAtNDhFQy1CNDlELTY0NDc0RUVERUY2RFBhdGgtMTRcIj5cclxuICogICAgICAgPC9wYXRoPlxyXG4gKiAgICAgICA8cGF0aCBhbmNob3JzPVwidG9wIGxlZnRcIiBkPVwiIE05LjU5NTk1OTY1OTgzNzc1NyAwLjc1NDc0OTcyMTQwMDAwMDEgIEMxMS4xNjA4MDU3NTk4Mzc3NTMgMS41MDk0OTk0NDI0IDExLjU3NjUxNzg1OTgzNzc1NCAyLjc0NjY1NDY4MjQgMTEuMDc0NTY3NTU5ODM3NzU3IDUuMjk4NTMzNzAyMzk5OTk5ICBDMTAuNTcyNjE3MjU5ODM3NzU2IDcuODUwNDEyNzMyNCAxMC4wMjg4NjAwNTk4Mzc3NTQgNy45NzI5MjE4MTI0IDkuNTk1OTU5NjU5ODM3NzU3IDguOTIwNzYyNTkyNCAgQzkuMTYzMDU5Mjc5ODM3NzUzIDkuODY4NjAzMzcyMzk5OTk5IDkuNDUxNjU5NTE5ODM3NzU0IDEwLjY3MDYyMjQ5MjQgMTAuNDYxNzYwNTU5ODM3NzU3IDExLjEwODA4NzQ5MjQgIEMxMS40NzE4NjE1NTk4Mzc3NTUgMTEuNTQ1NTUyNDkyNCAxNC4yODU3MTQyNTk4Mzc3NTUgMTIuODU3OTQ3MzkyNCAxNC4yODU3MTQzNTk4Mzc3NTcgMTMuNTg3MDU1NjkyNCAgQzE0LjI4NTcxNDM1OTgzNzc1NyAxNC4zMTYxNjM5OTI0IDEzLjA1OTE2MzE1OTgzNzc1NSAxNC4yNDMyNTMwOTI0IDExLjk3NjkxMjA1OTgzNzc1NSAxNC4yNDMyNTMwOTI0ICBDMTAuODk0NjYwOTU5ODM3NzU0IDE0LjI0MzI1MzA5MjQgNi4zNDkyMDY0MDk4Mzc3NTUgMTQuMjQzMjUzMDkyNCA2LjM0OTIwNjQwOTgzNzc1NSAxNC4yNDMyNTMwOTI0ICBMNi4xNTIwNjE5Njk4Mzc3NTUgMC40Mjk5MjYyNjk0ICBDNi4xNTIwNjE5Njk4Mzc3NTUgMC40Mjk5MjYyNjk0IDguMDMxMTEzNTQ5ODM3NzU1IDAgOS41OTU5NTk2NTk4Mzc3NTcgMC43NTQ3NDk3MjE0MDAwMDAxICB6XCIgaWQ9XCJzaWQtOEExQ0RBMjEtOUNEMC00OEVDLUI0OUQtNjQ0NzRFRURFRjZEUGF0aC0xNC1Db3B5XCI+XHJcbiAqICAgICAgIDwvcGF0aD5cclxuICogICA8L2c+XHJcbiAqIDwvZz5cclxuICovXHJcblxyXG4gICAgZnVuY3Rpb24gVXNlclRhc2tOb2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIFRhc2tOb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnJlY3RTaXplID0ge3dpZHRoOjEwMCwgaGVpZ2h0OjYwfTtcclxuICAgICAgICB0aGlzLmljb25QYXRoID0gXCJNNzY1LjU3Mzc0MSA3MTguNDg5ODg4Yy0xNC45OTk2MjItMTEyLjY1OTg3My0xMTkuNjcxNTY3LTE5Ni40Mzg5NzQtMjM3Ljc3NjQ1Mi0xOTYuNDM4OTc0LTExOC45MTIyNzMgMC0yMjAuNTE0Mjk5IDg1LjI3NzIyMi0yMzguMjAzMTcgMTk4Ljc3MDA2Ni0xMS44NDA2NzYgNzYuMDcxNTU5IDU0LjU4NTE5OSA3MS4zMjY0ODkgNTQuNTg1MTk5IDcxLjMyNjQ4OWwzNjAuNzM0ODc4IDBDNzA0LjkxMzE3MyA3OTIuMTQ4NDkxIDc3Ni42MDgwNTIgODAxLjM2NDM4NyA3NjUuNTczNzQxIDcxOC40ODk4ODh6TTY5MC4yNDkxOTUgMzY1LjcxODM3OWMwIDg5LjkxMTc3Ni03Mi44ODkwNzcgMTYyLjgxMDA2My0xNjIuNzk2NzYgMTYyLjgxMDA2My04OS45MDg3MDYgMC0xNjIuNzk3NzgzLTcyLjg5ODI4Ny0xNjIuNzk3NzgzLTE2Mi44MTAwNjMgMC04OS45MTY4OTIgNzIuODg5MDc3LTE2Mi44MDU5NyAxNjIuNzk3NzgzLTE2Mi44MDU5N0M2MTcuMzYwMTE4IDIwMi45MTI0MDkgNjkwLjI0OTE5NSAyNzUuODAxNDg3IDY5MC4yNDkxOTUgMzY1LjcxODM3OXpcIjtcclxuICAgICAgICB0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDAsIG5hbWU6XCJVc2VyVGFza1wiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIFVzZXJUYXNrTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgeDogMC41LFxyXG4gICAgICAgICAgICAgICAgeTogMC41LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMucmVjdFNpemUud2lkdGgtMSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZWN0U2l6ZS5oZWlnaHQtMSxcclxuICAgICAgICAgICAgICAgIHI6IDdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZicsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICByZWN0Lm5hbWUgPSBcIlJlY3RcIjtcclxuICAgICAgICB0aGlzLmFkZChyZWN0KTtcclxuXHJcbiAgICAgICAgdmFyIGljb25SZWN0ID0ge3g6NSwgeTogNSwgd2lkdGg6IDE1LCBoZWlnaHQ6MTV9O1xyXG4gICAgICAgIHZhciBwYXRoSWNvbiA9IGdyYXBoaWMubWFrZVBhdGgodGhpcy5pY29uUGF0aCwge3N0eWxlOiB7ZmlsbDogJyNmZmYnLCBzdHJva2U6ICcjMDAwJ30sejoyfSwgaWNvblJlY3QpO1xyXG4gICAgICAgIHRoaXMuYWRkKHBhdGhJY29uKTtcclxuICAgICAgIC8vIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5pY29uUGF0aDIsIHtzdHlsZToge2ZpbGw6ICcjNDk5MEUyJ319LCByZWN0LFwiY2VudGVyXCIpKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gIFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiksIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5kcmF3VGV4dChtb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIiksICcnLCAnY2VudGVyJyk7XHJcbiAgICAgICAgdGl0bGUudGV4dC5uYW1lID0gXCJUaXRsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHRpdGxlLnRleHQpO1xyXG4gICAgfTtcclxuXHJcblxyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoVXNlclRhc2tOb2RlLFRhc2tOb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IFVzZXJUYXNrTm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL3Rhc2svVXNlclRhc2tOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHR2YXIgQlBNTk5vZGUgPSByZXF1aXJlKFwiLi4vQlBNTk5vZGVcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcblx0Ly/liJvlu7pOb2Rl57G7IOaJgOacieW9oueKtumDvee7p+aJv05vZGVcclxuXHQvL1xyXG5cdGZ1bmN0aW9uIFRhc2tOb2RlKG1vZGVsLCBhcGkpIHtcclxuXHJcblx0XHRCUE1OTm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTpcIlRhc2tOb2RlXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdGhpcy5zbG90ID0gW107XHJcbiAgICAgICAgdGhpcy5zbG90RXZlbnQgPSBbXTtcclxuICAgICAgICB0aGlzLmlzQ2FuU2xvdCA9IHRydWU7ICAvL+eUqOS6juaOp+WItuacrOiKgueCueaYr+WQpuWPr+S7peiiq+aPkuanvVxyXG5cdH1cclxuXHJcbiAgICBUYXNrTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBUYXNrTm9kZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIC8v5Yib5bu65pyA5bCP5YyF5Zu055uS6Jma57q/XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgIHBvaW50c1swXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMV0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMl0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1szXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1s0XSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuXHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMucG9zaXRpb25bMF0rYm91bmRpbmdSZWN0LndpZHRoLzIsXHJcbiAgICAgICAgICAgIHk6IHRoaXMucG9zaXRpb25bMV0rYm91bmRpbmdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxyXG4gICAgICAgICAgICBib3VuZGluZ1JlY3Q6IGJvdW5kUmVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIFRhc2tOb2RlLnByb3RvdHlwZS5nZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJSZWN0XCIpO1xyXG4gICAgICAgIHJldHVybiByZWN0LmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBUYXNrTm9kZS5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbihwWCxwWSkge1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIHRoaXMuYXR0cigncG9zaXRpb24nLFtwWC1ib3VuZGluZ1JlY3Qud2lkdGgvMixwWS1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIFRhc2tOb2RlLnByb3RvdHlwZS51cGRhdGVTaGFwZSA9IGZ1bmN0aW9uKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNoaWxkT2ZOYW1lKFwiUmVjdFwiKTtcclxuICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gcmVjdC5zaGFwZTtcclxuICAgICAgICB2YXIgbmV3VyA9IE51bWJlcihzaGFwZS53aWR0aCAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgIHZhciBuZXdIID0gTnVtYmVyKG5ld1cgKiBzaGFwZS5oZWlnaHQgLyBzaGFwZS53aWR0aCk7XHJcbiAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgbmV3VyA9IHBhcnNlSW50KG5ld1csIDEwKTtcclxuICAgICAgICAgICAgbmV3SCA9IHBhcnNlSW50KG5ld0gsIDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVjdC5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgIHdpZHRoOiBuZXdXLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IG5ld0hcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlZnJlc2hUZXh0KCk7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoVGFza05vZGUsQlBNTk5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gVGFza05vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1Rhc2tOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL01hbnVhbFRhc2voioLngrlcclxuXHJcblx0dmFyIFRhc2tOb2RlID0gcmVxdWlyZShcIi4vVGFza05vZGUuanNcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbi8qKlxyXG4gKlxyXG4gKiAgPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgbWluaW11bVNpemU9XCI4MiA0MlwiIGlkPVwic2lkLUE5NTQ1MjI0LTRDQUUtNDUwRC04OTNELTEyQ0ZBN0U2ODgyNVwiIHRpdGxlPVwiTWFudWFsIHRhc2tcIj5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUE5NTQ1MjI0LTRDQUUtNDUwRC04OTNELTEyQ0ZBN0U2ODgyNXRleHRfZnJhbWVcIiBhbmNob3JzPVwiYm90dG9tIHRvcCByaWdodCBsZWZ0XCIgeD1cIjFcIiB5PVwiMVwiIHdpZHRoPVwiNzRcIiBoZWlnaHQ9XCIzOVwiIHJ4PVwiMTBcIiByeT1cIjEwXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiPjwvcmVjdD5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUE5NTQ1MjI0LTRDQUUtNDUwRC04OTNELTEyQ0ZBN0U2ODgyNWJnX2ZyYW1lXCIgcmVzaXplPVwidmVydGljYWwgaG9yaXpvbnRhbFwiIHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiNDBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHN0cm9rZT1cIiNiYmJiYmJcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIiNmOWY5ZjlcIj48L3JlY3Q+XHJcbiAqICAgICA8cmVjdCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGlkPVwic2lkLUE5NTQ1MjI0LTRDQUUtNDUwRC04OTNELTEyQ0ZBN0U2ODgyNWFyZWFfc3RhdGVcIiBhbmNob3JzPVwiYm90dG9tXCIgeD1cIjBcIiB5PVwiMzBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiMTBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHJlc2l6ZT1cImhvcml6b250YWxcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMFwiIGZpbGw9XCJub25lXCIgc3R5bGU9XCJcIj48L3JlY3Q+XHJcbiAqICAgICA8dGV4dCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZvbnQtc2l6ZT1cIjEyXCIgaWQ9XCJzaWQtQTk1NDUyMjQtNENBRS00NTBELTg5M0QtMTJDRkE3RTY4ODI1dGV4dF9uYW1lXCIgeD1cIjQzXCIgeT1cIjI0XCIgYWxpZ249XCJtaWRkbGUgY2VudGVyXCIgZml0dG9lbGVtPVwidGV4dF9mcmFtZVwiIHN0cm9rZT1cIiMzNzNlNDhcIiBzdHJva2Utd2lkdGg9XCIwcHRcIiBsZXR0ZXItc3BhY2luZz1cIi0wLjAxcHhcIiB0cmFuc2Zvcm09XCJyb3RhdGUoMCA0MyAyNClcIiBvcnl4OmZvbnRTaXplPVwiMTJcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPjx0c3BhbiB4PVwiNDNcIiB5PVwiMjRcIiBkeT1cIjVcIj5UYXNrPC90c3Bhbj48L3RleHQ+XHJcbiAqICAgICA8ZyBpZD1cInNpZC1BOTU0NTIyNC00Q0FFLTQ1MEQtODkzRC0xMkNGQTdFNjg4MjVtYW51YWxUYXNrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDMsMSkgc2NhbGUoMC44KVwiPlxyXG4gKiAgICAgPHBhdGggYW5jaG9ycz1cInRvcCBsZWZ0XCIgc3R5bGU9XCJmaWxsOiNkMWI1NzU7c3Ryb2tlPW5vbmVcIiBkPVwibSAxNyw5LjMyOTAzMjYgYyAtMC4wMDY5LDAuNTUxMjQ2MSAtMC40NTUxNjYsMS4wNDU1ODk0IC0wLjk0MDc3OCwxLjAzNzY2MDQgbCAtNS43OTI3NDYsMCBjIDAuMDA1MywwLjExOTM4MSAwLjAwMjYsMC4yMzcxMDcgMC4wMDYxLDAuMzU1OTY1IGwgNS4xNTQ5MTgsMCBjIDAuNDgyMDMyLC0wLjAwOTYgMC45MjU1MjksMC40OTA1MSAwLjkxOTUyNSwxLjAzNzU3NCAtMC4wMDc4LDAuNTM3MTI4IC0wLjQ0NjI4MywxLjAxNzUzMSAtMC45MTk1MjEsMS4wMDc2ODMgbCAtNS4yNDUyNzMsMCBjIC0wLjAxNTA3LDAuMTA0NDg0IC0wLjAzMzg5LDAuMjA0MDgxIC0wLjA1MzE2LDAuMzAxNTkxIGwgMi42MzAxNzUsMCBjIDAuNDU0MTM3LC0wLjAwOTYgMC44NzIxMTIsMC40NjE3NTQgMC44NjYzODYsMC45NzcxODYgQyAxMy42MTk1MjYsMTQuNTU0MTA2IDEzLjIwNjI5MywxNS4wMDk0OTggMTIuNzU5MjQsMTUgTCAzLjc3NTMwNTQsMTUgQyAzLjYwNDU4MTIsMTUgMy40MzM1NTIsMTQuOTQ0MjMgMy4yOTE2MzYzLDE0LjgzNzEzNiBjIC0wLjAwMTc0LDAgLTAuMDA0MzYsMCAtMC4wMDYwOSwwIEMgMS43MjEyMDM1LDE0LjM2NzgwMSAwLjk5OTk4MjU1LDExLjQ1ODY0MSAxLDExLjQ1ODY0MSBMIDEsNy40NTg4MzkzIGMgMCwwIDAuNjYyMzE0NCwtMS4zMTYzMzMgMS44MzkwNTgzLC0yLjA4NzI1ODQgMS4xNzY3NjE0LC0wLjc3MTE4NjggNi44MDUzMzU4LC0yLjQwNDk3IDcuMjU4Nzg0NywtMi44MDUyOTAxIDAuNDUzNDg0LC0wLjQwMDMyIDEuNjYwMjEzLDEuNDg1OTk0MiAwLjA0Nzc1LDIuNDAxMDQ4NyBDIDguNTMzMjMxNSw1Ljg4MjM5NCA4LjUwNzM1MSw1Ljc5OTYxMTMgOC40MzcwMjkyLDUuNzkzNjg1OSBsIDYuMzU2OTc0OCwtMC4wMDg3MSBjIDAuNDk3MDQ2LC0wLjAwOTU4IDAuOTUyMjczLDAuNTA5NzY3NiAwLjk0NjEyLDEuMDczODIzMiAtMC4wMDUzLDAuNTU2MTI2IC0wLjQ1NjE3NiwxLjA1NjY1NjYgLTAuOTQ2MTIsMS4wNDk2ODU0IGwgLTQuNzI0MzUsMCBjIDAuMDEzMDcsMC4xMTQ5Mzc0IDAuMDI0NCwwLjIyODEzMTkgMC4wMzcyMSwwLjM0OTg2NjEgbCA1Ljk1MjE5NSwwIGMgMC40OTQ1MTcsLTAuMDA4NzEgMC45NDc5MDYsMC41MDY2MzA1IDAuOTQwNzk1LDEuMDY3OTg0OCB6XCIgaWQ9XCJzaWQtQTk1NDUyMjQtNENBRS00NTBELTg5M0QtMTJDRkE3RTY4ODI1X3NpZC1BOTU0NTIyNC00Q0FFLTQ1MEQtODkzRC0xMkNGQTdFNjg4MjVfMTdcIj48L3BhdGg+XHJcbiAqICAgICA8L2c+XHJcbiAqIDwvZz5cclxuICovXHJcbiAgICBmdW5jdGlvbiBNYW51YWxUYXNrTm9kZShtb2RlbCxhcGkpIHtcclxuICAgICAgICBUYXNrTm9kZS5jYWxsKHRoaXMsbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2l6ZSA9IHt3aWR0aDoxMDAsIGhlaWdodDo2MH07XHJcbiAgICAgICAgdGhpcy5pY29uUGF0aCA9IFwibSAxNyw5LjMyOTAzMjYgYyAtMC4wMDY5LDAuNTUxMjQ2MSAtMC40NTUxNjYsMS4wNDU1ODk0IC0wLjk0MDc3OCwxLjAzNzY2MDQgbCAtNS43OTI3NDYsMCBjIDAuMDA1MywwLjExOTM4MSAwLjAwMjYsMC4yMzcxMDcgMC4wMDYxLDAuMzU1OTY1IGwgNS4xNTQ5MTgsMCBjIDAuNDgyMDMyLC0wLjAwOTYgMC45MjU1MjksMC40OTA1MSAwLjkxOTUyNSwxLjAzNzU3NCAtMC4wMDc4LDAuNTM3MTI4IC0wLjQ0NjI4MywxLjAxNzUzMSAtMC45MTk1MjEsMS4wMDc2ODMgbCAtNS4yNDUyNzMsMCBjIC0wLjAxNTA3LDAuMTA0NDg0IC0wLjAzMzg5LDAuMjA0MDgxIC0wLjA1MzE2LDAuMzAxNTkxIGwgMi42MzAxNzUsMCBjIDAuNDU0MTM3LC0wLjAwOTYgMC44NzIxMTIsMC40NjE3NTQgMC44NjYzODYsMC45NzcxODYgQyAxMy42MTk1MjYsMTQuNTU0MTA2IDEzLjIwNjI5MywxNS4wMDk0OTggMTIuNzU5MjQsMTUgTCAzLjc3NTMwNTQsMTUgQyAzLjYwNDU4MTIsMTUgMy40MzM1NTIsMTQuOTQ0MjMgMy4yOTE2MzYzLDE0LjgzNzEzNiBjIC0wLjAwMTc0LDAgLTAuMDA0MzYsMCAtMC4wMDYwOSwwIEMgMS43MjEyMDM1LDE0LjM2NzgwMSAwLjk5OTk4MjU1LDExLjQ1ODY0MSAxLDExLjQ1ODY0MSBMIDEsNy40NTg4MzkzIGMgMCwwIDAuNjYyMzE0NCwtMS4zMTYzMzMgMS44MzkwNTgzLC0yLjA4NzI1ODQgMS4xNzY3NjE0LC0wLjc3MTE4NjggNi44MDUzMzU4LC0yLjQwNDk3IDcuMjU4Nzg0NywtMi44MDUyOTAxIDAuNDUzNDg0LC0wLjQwMDMyIDEuNjYwMjEzLDEuNDg1OTk0MiAwLjA0Nzc1LDIuNDAxMDQ4NyBDIDguNTMzMjMxNSw1Ljg4MjM5NCA4LjUwNzM1MSw1Ljc5OTYxMTMgOC40MzcwMjkyLDUuNzkzNjg1OSBsIDYuMzU2OTc0OCwtMC4wMDg3MSBjIDAuNDk3MDQ2LC0wLjAwOTU4IDAuOTUyMjczLDAuNTA5NzY3NiAwLjk0NjEyLDEuMDczODIzMiAtMC4wMDUzLDAuNTU2MTI2IC0wLjQ1NjE3NiwxLjA1NjY1NjYgLTAuOTQ2MTIsMS4wNDk2ODU0IGwgLTQuNzI0MzUsMCBjIDAuMDEzMDcsMC4xMTQ5Mzc0IDAuMDI0NCwwLjIyODEzMTkgMC4wMzcyMSwwLjM0OTg2NjEgbCA1Ljk1MjE5NSwwIGMgMC40OTQ1MTcsLTAuMDA4NzEgMC45NDc5MDYsMC41MDY2MzA1IDAuOTQwNzk1LDEuMDY3OTg0OCB6XCI7XHJcbiAgICAgIC8vICB0aGlzLmljb25QYXRoMiA9IFwiTTkuNTk1OTU5NjU5ODM3NzU3IDAuNzU0NzQ5NzIxNDAwMDAwMSAgQzExLjE2MDgwNTc1OTgzNzc1MyAxLjUwOTQ5OTQ0MjQgMTEuNTc2NTE3ODU5ODM3NzU0IDIuNzQ2NjU0NjgyNCAxMS4wNzQ1Njc1NTk4Mzc3NTcgNS4yOTg1MzM3MDIzOTk5OTkgIEMxMC41NzI2MTcyNTk4Mzc3NTYgNy44NTA0MTI3MzI0IDEwLjAyODg2MDA1OTgzNzc1NCA3Ljk3MjkyMTgxMjQgOS41OTU5NTk2NTk4Mzc3NTcgOC45MjA3NjI1OTI0ICBDOS4xNjMwNTkyNzk4Mzc3NTMgOS44Njg2MDMzNzIzOTk5OTkgOS40NTE2NTk1MTk4Mzc3NTQgMTAuNjcwNjIyNDkyNCAxMC40NjE3NjA1NTk4Mzc3NTcgMTEuMTA4MDg3NDkyNCAgQzExLjQ3MTg2MTU1OTgzNzc1NSAxMS41NDU1NTI0OTI0IDE0LjI4NTcxNDI1OTgzNzc1NSAxMi44NTc5NDczOTI0IDE0LjI4NTcxNDM1OTgzNzc1NyAxMy41ODcwNTU2OTI0ICBDMTQuMjg1NzE0MzU5ODM3NzU3IDE0LjMxNjE2Mzk5MjQgMTMuMDU5MTYzMTU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgMTEuOTc2OTEyMDU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEMxMC44OTQ2NjA5NTk4Mzc3NTQgMTQuMjQzMjUzMDkyNCA2LjM0OTIwNjQwOTgzNzc1NSAxNC4yNDMyNTMwOTI0IDYuMzQ5MjA2NDA5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEw2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgIEM2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgOC4wMzExMTM1NDk4Mzc3NTUgMCA5LjU5NTk1OTY1OTgzNzc1NyAwLjc1NDc0OTcyMTQwMDAwMDEgIHpcIjtcclxuICAgICAgICB0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDQsIG5hbWU6XCJNYW51YWxUYXNrXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgTWFudWFsVGFza05vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IDAuNSxcclxuICAgICAgICAgICAgICAgIHk6IDAuNSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLnJlY3RTaXplLndpZHRoLTEsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMucmVjdFNpemUuaGVpZ2h0LTEsXHJcbiAgICAgICAgICAgICAgICByOiA3XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcblxyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmZmYnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejoyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVjdC5uYW1lID0gXCJSZWN0XCI7XHJcbiAgICAgICAgdGhpcy5hZGQocmVjdCk7XHJcblxyXG4gICAgICAgIHZhciBpY29ucmVjdCA9IHt4OjUsIHk6IDUsIHdpZHRoOiAxNSwgaGVpZ2h0OjE1fTtcclxuICAgICAgICB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMuaWNvblBhdGgsIHtzdHlsZToge2ZpbGw6ICcjZmZmJywgc3Ryb2tlOiAnIzAwMCd9LHo6Mn0sIGljb25yZWN0KSk7XHJcblxyXG4gICAgICAgLy8gdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoMiwge3N0eWxlOiB7ZmlsbDogJyM0OTkwRTInfX0sIHJlY3QsXCJjZW50ZXJcIikpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAgW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSwgJycsICdjZW50ZXInKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoTWFudWFsVGFza05vZGUsVGFza05vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gTWFudWFsVGFza05vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL01hbnVhbFRhc2tOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL1NjcmlwdFRhc2voioLngrlcclxuXHJcblx0dmFyIFRhc2tOb2RlID0gcmVxdWlyZShcIi4vVGFza05vZGUuanNcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbi8qKlxyXG4gKlxyXG4gKiAgPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgbWluaW11bVNpemU9XCI4MiA0MlwiIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RFwiIHRpdGxlPVwiU2NyaXB0IHRhc2tcIj5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RHRleHRfZnJhbWVcIiBhbmNob3JzPVwiYm90dG9tIHRvcCByaWdodCBsZWZ0XCIgeD1cIjFcIiB5PVwiMVwiIHdpZHRoPVwiNzRcIiBoZWlnaHQ9XCIzOVwiIHJ4PVwiMTBcIiByeT1cIjEwXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiPjwvcmVjdD5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RGJnX2ZyYW1lXCIgcmVzaXplPVwidmVydGljYWwgaG9yaXpvbnRhbFwiIHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiNDBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHN0cm9rZT1cIiNiYmJiYmJcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIiNmOWY5ZjlcIj48L3JlY3Q+XHJcbiAqICAgICA8cmVjdCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RGFyZWFfc3RhdGVcIiBhbmNob3JzPVwiYm90dG9tXCIgeD1cIjBcIiB5PVwiMzBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiMTBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHJlc2l6ZT1cImhvcml6b250YWxcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMFwiIGZpbGw9XCJub25lXCIgc3R5bGU9XCJcIj48L3JlY3Q+XHJcbiAqICAgICA8dGV4dCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZvbnQtc2l6ZT1cIjEyXCIgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEdGV4dF9uYW1lXCIgeD1cIjQzXCIgeT1cIjI0XCIgYWxpZ249XCJtaWRkbGUgY2VudGVyXCIgZml0dG9lbGVtPVwidGV4dF9mcmFtZVwiIHN0cm9rZT1cIiMzNzNlNDhcIiBzdHJva2Utd2lkdGg9XCIwcHRcIiBsZXR0ZXItc3BhY2luZz1cIi0wLjAxcHhcIiB0cmFuc2Zvcm09XCJyb3RhdGUoMCA0MyAyNClcIiBvcnl4OmZvbnRTaXplPVwiMTJcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPjx0c3BhbiB4PVwiNDNcIiB5PVwiMjRcIiBkeT1cIjVcIj5UYXNrPC90c3Bhbj48L3RleHQ+XHJcbiAqICAgICA8ZyBpZD1cInNpZC1CODNERkE5RS0wMDY2LTQwMzItQTlFOC1BN0ZGMTlDMUFCNURzY3JpcHRUYXNrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDIsMikgc2NhbGUoMC44KVwiPlxyXG4gKiAgICAgPHBhdGggYW5jaG9ycz1cInRvcCBsZWZ0XCIgZD1cIm0gNSwyIDAsMC4wOTQgYyAwLjIzNzA2LDAuMDY0IDAuNTMxODksMC4xNjQ1IDAuODEyNSwwLjM3NSAwLjU1ODIsMC40MTg2IDEuMDUxMDksMS4yMjggMS4xNTYyNSwyLjUzMTIgbCA4LjAzMTI1LDAgMSwwIDEsMCBjIDAsLTMgLTIsLTMgLTIsLTMgbCAtMTAsMCB6IE0gNCwzIDQsMTMgMiwxMyBjIDAsMyAyLDMgMiwzIGwgOSwwIGMgMCwwIDIsMCAyLC0zIEwgMTUsNiA2LDYgNiw1LjUgQyA2LDQuMTExMSA1LjU1OTUsMy41MjkgNS4xODc1LDMuMjUgNC44MTU1LDIuOTcxIDQuNSwzIDQuNSwzIEwgNCwzIHpcIiBzdHlsZT1cImZpbGw6IzcyYTdkMDtzdHJva2U6bm9uZVwiIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RF9zaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEXzE3XCI+PC9wYXRoPlxyXG4gKiAgICAgPC9nPlxyXG4gKiA8L2c+XHJcbiAqL1xyXG4gICAgZnVuY3Rpb24gU2NyaXB0VGFza05vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgVGFza05vZGUuY2FsbCh0aGlzLG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNpemUgPSB7d2lkdGg6MTAwLCBoZWlnaHQ6NjB9O1xyXG4gICAgICAgIHRoaXMuaWNvblBhdGggPSBcIm0gNSwyIDAsMC4wOTQgYyAwLjIzNzA2LDAuMDY0IDAuNTMxODksMC4xNjQ1IDAuODEyNSwwLjM3NSAwLjU1ODIsMC40MTg2IDEuMDUxMDksMS4yMjggMS4xNTYyNSwyLjUzMTIgbCA4LjAzMTI1LDAgMSwwIDEsMCBjIDAsLTMgLTIsLTMgLTIsLTMgbCAtMTAsMCB6IE0gNCwzIDQsMTMgMiwxMyBjIDAsMyAyLDMgMiwzIGwgOSwwIGMgMCwwIDIsMCAyLC0zIEwgMTUsNiA2LDYgNiw1LjUgQyA2LDQuMTExMSA1LjU1OTUsMy41MjkgNS4xODc1LDMuMjUgNC44MTU1LDIuOTcxIDQuNSwzIDQuNSwzIEwgNCwzIHpcIjtcclxuICAgICAgLy8gIHRoaXMuaWNvblBhdGgyID0gXCJNOS41OTU5NTk2NTk4Mzc3NTcgMC43NTQ3NDk3MjE0MDAwMDAxICBDMTEuMTYwODA1NzU5ODM3NzUzIDEuNTA5NDk5NDQyNCAxMS41NzY1MTc4NTk4Mzc3NTQgMi43NDY2NTQ2ODI0IDExLjA3NDU2NzU1OTgzNzc1NyA1LjI5ODUzMzcwMjM5OTk5OSAgQzEwLjU3MjYxNzI1OTgzNzc1NiA3Ljg1MDQxMjczMjQgMTAuMDI4ODYwMDU5ODM3NzU0IDcuOTcyOTIxODEyNCA5LjU5NTk1OTY1OTgzNzc1NyA4LjkyMDc2MjU5MjQgIEM5LjE2MzA1OTI3OTgzNzc1MyA5Ljg2ODYwMzM3MjM5OTk5OSA5LjQ1MTY1OTUxOTgzNzc1NCAxMC42NzA2MjI0OTI0IDEwLjQ2MTc2MDU1OTgzNzc1NyAxMS4xMDgwODc0OTI0ICBDMTEuNDcxODYxNTU5ODM3NzU1IDExLjU0NTU1MjQ5MjQgMTQuMjg1NzE0MjU5ODM3NzU1IDEyLjg1Nzk0NzM5MjQgMTQuMjg1NzE0MzU5ODM3NzU3IDEzLjU4NzA1NTY5MjQgIEMxNC4yODU3MTQzNTk4Mzc3NTcgMTQuMzE2MTYzOTkyNCAxMy4wNTkxNjMxNTk4Mzc3NTUgMTQuMjQzMjUzMDkyNCAxMS45NzY5MTIwNTk4Mzc3NTUgMTQuMjQzMjUzMDkyNCAgQzEwLjg5NDY2MDk1OTgzNzc1NCAxNC4yNDMyNTMwOTI0IDYuMzQ5MjA2NDA5ODM3NzU1IDE0LjI0MzI1MzA5MjQgNi4zNDkyMDY0MDk4Mzc3NTUgMTQuMjQzMjUzMDkyNCAgTDYuMTUyMDYxOTY5ODM3NzU1IDAuNDI5OTI2MjY5NCAgQzYuMTUyMDYxOTY5ODM3NzU1IDAuNDI5OTI2MjY5NCA4LjAzMTExMzU0OTgzNzc1NSAwIDkuNTk1OTU5NjU5ODM3NzU3IDAuNzU0NzQ5NzIxNDAwMDAwMSAgelwiO1xyXG4gICAgICAgIHRoaXMuYnBtbkluZm8gPSB7dHlwZTogNywgbmFtZTpcIlNjcmlwdFRhc2tcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG4gICAgICAgIHRoaXMucmVuZGVyKG1vZGVsKTtcclxuICAgIH1cclxuXHJcbiAgICBTY3JpcHRUYXNrTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgeDogMC41LFxyXG4gICAgICAgICAgICAgICAgeTogMC41LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMucmVjdFNpemUud2lkdGgtMSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZWN0U2l6ZS5oZWlnaHQtMSxcclxuICAgICAgICAgICAgICAgIHI6IDdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZicsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICByZWN0Lm5hbWUgPSBcIlJlY3RcIjtcclxuICAgICAgICB0aGlzLmFkZChyZWN0KTtcclxuXHJcbiAgICAgICAgdmFyIGljb25yZWN0ID0ge3g6NSwgeTogNSwgd2lkdGg6IDE1LCBoZWlnaHQ6MTV9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5pY29uUGF0aCwge3N0eWxlOiB7ZmlsbDogJyNmZmYnLCBzdHJva2U6ICcjMDAwJ30sejoyfSwgaWNvbnJlY3QpKTtcclxuXHJcbiAgICAgICAvLyB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMuaWNvblBhdGgyLCB7c3R5bGU6IHtmaWxsOiAnIzQ5OTBFMid9fSwgcmVjdCxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIildO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpLCAnJywgJ2NlbnRlcicpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhTY3JpcHRUYXNrTm9kZSxUYXNrTm9kZSk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBTY3JpcHRUYXNrTm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL3Rhc2svU2NyaXB0VGFza05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vTWFpbFRhc2voioLngrlcclxuXHJcblx0dmFyIFRhc2tOb2RlID0gcmVxdWlyZShcIi4vVGFza05vZGUuanNcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbi8qKlxyXG4gKlxyXG4gKiAgPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgbWluaW11bVNpemU9XCI4MiA0MlwiIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RFwiIHRpdGxlPVwiU2NyaXB0IHRhc2tcIj5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RHRleHRfZnJhbWVcIiBhbmNob3JzPVwiYm90dG9tIHRvcCByaWdodCBsZWZ0XCIgeD1cIjFcIiB5PVwiMVwiIHdpZHRoPVwiNzRcIiBoZWlnaHQ9XCIzOVwiIHJ4PVwiMTBcIiByeT1cIjEwXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiPjwvcmVjdD5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RGJnX2ZyYW1lXCIgcmVzaXplPVwidmVydGljYWwgaG9yaXpvbnRhbFwiIHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiNDBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHN0cm9rZT1cIiNiYmJiYmJcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIiNmOWY5ZjlcIj48L3JlY3Q+XHJcbiAqICAgICA8cmVjdCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RGFyZWFfc3RhdGVcIiBhbmNob3JzPVwiYm90dG9tXCIgeD1cIjBcIiB5PVwiMzBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiMTBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHJlc2l6ZT1cImhvcml6b250YWxcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMFwiIGZpbGw9XCJub25lXCIgc3R5bGU9XCJcIj48L3JlY3Q+XHJcbiAqICAgICA8dGV4dCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZvbnQtc2l6ZT1cIjEyXCIgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEdGV4dF9uYW1lXCIgeD1cIjQzXCIgeT1cIjI0XCIgYWxpZ249XCJtaWRkbGUgY2VudGVyXCIgZml0dG9lbGVtPVwidGV4dF9mcmFtZVwiIHN0cm9rZT1cIiMzNzNlNDhcIiBzdHJva2Utd2lkdGg9XCIwcHRcIiBsZXR0ZXItc3BhY2luZz1cIi0wLjAxcHhcIiB0cmFuc2Zvcm09XCJyb3RhdGUoMCA0MyAyNClcIiBvcnl4OmZvbnRTaXplPVwiMTJcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPjx0c3BhbiB4PVwiNDNcIiB5PVwiMjRcIiBkeT1cIjVcIj5UYXNrPC90c3Bhbj48L3RleHQ+XHJcbiAqICAgICA8ZyBpZD1cInNpZC1CODNERkE5RS0wMDY2LTQwMzItQTlFOC1BN0ZGMTlDMUFCNURzY3JpcHRUYXNrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDIsMikgc2NhbGUoMC44KVwiPlxyXG4gKiAgICAgICAgPHBhdGggYW5jaG9ycz1cInRvcCBsZWZ0XCIgZD1cIk0wLjMzMjYzODkzNiwxLjE3MzkxMzA0IEw4Ljk4MTI1MTI2LDYuNjUyMTczOTFcIiBpZD1cInNpZC0wOUI5N0M1RS1CRUE4LTQwQTItOUYyMi0zMDY0QTI3NDVEQkVMaW5lXCIgc3Ryb2tlPVwiI0ZGRkZGRlwiIHN0cm9rZS1saW5lY2FwPVwic3F1YXJlXCI+PC9wYXRoPlxyXG4gKiAgICAgICAgPHBhdGggYW5jaG9ycz1cInRvcCBsZWZ0XCIgZD1cIk0xNy41NTAwMzAyLDEuMTczOTEzMDQgTDguOTAxNDE3OTIsNi42NTIxNzM5MVwiIGlkPVwic2lkLTA5Qjk3QzVFLUJFQTgtNDBBMi05RjIyLTMwNjRBMjc0NURCRUxpbmUtQ29weS00XCIgc3Ryb2tlPVwiI0ZGRkZGRlwiIHN0cm9rZS1saW5lY2FwPVwic3F1YXJlXCI+PC9wYXRoPlxyXG4gKlx0ICAgPC9nPlxyXG4gKiA8L2c+XHJcbiAqL1xyXG4gICAgZnVuY3Rpb24gTWFpbFRhc2tOb2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIFRhc2tOb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnJlY3RTaXplID0ge3dpZHRoOjEwMCwgaGVpZ2h0OjYwfTtcclxuICAgICAgICB0aGlzLmljb25QYXRoID0gXCJNNDkuMDEzLDUxLjAwM2MxLjg0NywxLjMwMyw3LjQxNCw1LjE3NCwxNi43MDIsMTEuNjFTODIuMTE4LDc0LjAwNSw4Ny4wNjEsNzcuNDhjMC41NDMsMC4zODEsMS42OTcsMS4yMDksMy40NjIsMi40ODVjMS43NjUsMS4yNzcsMy4yMzIsMi4zMSw0LjM5OSwzLjA5N2MxLjE2OCwwLjc4NywyLjU4LDEuNjcsNC4yMzcsMi42NDdjMS42NTcsMC45NzcsMy4yMTksMS43MTEsNC42ODUsMi4xOThjMS40NjcsMC40OSwyLjgyNSwwLjczMyw0LjA3NCwwLjczM0gxMDhoMC4wODJjMS4yNDksMCwyLjYwNy0wLjI0Myw0LjA3NC0wLjczM2MxLjQ2Ni0wLjQ4NywzLjAyOS0xLjIyMiw0LjY4NS0yLjE5OGMxLjY1Ni0wLjk3OCwzLjA2OC0xLjg2LDQuMjM2LTIuNjQ3czIuNjM0LTEuODIsNC4zOTktMy4wOTdzMi45Mi0yLjEwNCwzLjQ2My0yLjQ4NWM0Ljk5Ni0zLjQ3NiwxNy43MDctMTIuMzAyLDM4LjEyOS0yNi40NzljMy45NjUtMi43NjksNy4yNzctNi4xMSw5LjkzOS0xMC4wMjFDMTc5LjY3LDM3LjA3MSwxODEsMzIuOTcsMTgxLDI4LjY3OWMwLTMuNTg1LTEuMjkxLTYuNjU0LTMuODcxLTkuMjA3Yy0yLjU4LTIuNTUzLTUuNjM2LTMuODI5LTkuMTY1LTMuODI5SDQ4LjAzNWMtNC4xODIsMC03LjQsMS40MTItOS42NTQsNC4yMzZDMzYuMTI3LDIyLjcwNCwzNSwyNi4yMzUsMzUsMzAuNDcxYzAsMy40MjIsMS40OTQsNy4xMyw0LjQ4MSwxMS4xMjJTNDUuNjQ2LDQ4LjcyMiw0OS4wMTMsNTEuMDAzeiBNMTcyLjg1Miw1OS43MmMtMTcuODE0LDEyLjA1Ny0zMS4zNCwyMS40MjctNDAuNTcyLDI4LjEwOGMtMy4wOTYsMi4yODEtNS42MDgsNC4wNjEtNy41MzcsNS4zMzZjLTEuOTI4LDEuMjc3LTQuNDk0LDIuNTgtNy42OTksMy45MTFjLTMuMjA0LDEuMzMxLTYuMTkxLDEuOTk2LTguOTYxLDEuOTk2SDEwOGgtMC4wODJjLTIuNzcsMC01Ljc1OC0wLjY2NS04Ljk2Mi0xLjk5NnMtNS43NzEtMi42MzQtNy42OTktMy45MTFjLTEuOTI4LTEuMjc1LTQuNDQtMy4wNTUtNy41MzYtNS4zMzZjLTcuMzMzLTUuMzc3LTIwLjgzLTE0Ljc0Ny00MC40OTItMjguMTA4Yy0zLjA5Ni0yLjA2My01LjgzOS00LjQyNy04LjIyOS03LjA4OHY2NC42ODhjMCwzLjU4NiwxLjI3Niw2LjY1NCwzLjgyOSw5LjIwN2MyLjU1MywyLjU1NCw1LjYyMiwzLjgzLDkuMjA3LDMuODNoMTE5LjkyOWMzLjU4NCwwLDYuNjUzLTEuMjc2LDkuMjA2LTMuODNjMi41NTQtMi41NTQsMy44MjktNS42MjEsMy44MjktOS4yMDdWNTIuNjMyQzE3OC42NjQsNTUuMjM4LDE3NS45NDksNTcuNjAyLDE3Mi44NTIsNTkuNzJ6XCI7XHJcbiAgICAgIC8vICB0aGlzLmljb25QYXRoMiA9IFwiTTkuNTk1OTU5NjU5ODM3NzU3IDAuNzU0NzQ5NzIxNDAwMDAwMSAgQzExLjE2MDgwNTc1OTgzNzc1MyAxLjUwOTQ5OTQ0MjQgMTEuNTc2NTE3ODU5ODM3NzU0IDIuNzQ2NjU0NjgyNCAxMS4wNzQ1Njc1NTk4Mzc3NTcgNS4yOTg1MzM3MDIzOTk5OTkgIEMxMC41NzI2MTcyNTk4Mzc3NTYgNy44NTA0MTI3MzI0IDEwLjAyODg2MDA1OTgzNzc1NCA3Ljk3MjkyMTgxMjQgOS41OTU5NTk2NTk4Mzc3NTcgOC45MjA3NjI1OTI0ICBDOS4xNjMwNTkyNzk4Mzc3NTMgOS44Njg2MDMzNzIzOTk5OTkgOS40NTE2NTk1MTk4Mzc3NTQgMTAuNjcwNjIyNDkyNCAxMC40NjE3NjA1NTk4Mzc3NTcgMTEuMTA4MDg3NDkyNCAgQzExLjQ3MTg2MTU1OTgzNzc1NSAxMS41NDU1NTI0OTI0IDE0LjI4NTcxNDI1OTgzNzc1NSAxMi44NTc5NDczOTI0IDE0LjI4NTcxNDM1OTgzNzc1NyAxMy41ODcwNTU2OTI0ICBDMTQuMjg1NzE0MzU5ODM3NzU3IDE0LjMxNjE2Mzk5MjQgMTMuMDU5MTYzMTU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgMTEuOTc2OTEyMDU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEMxMC44OTQ2NjA5NTk4Mzc3NTQgMTQuMjQzMjUzMDkyNCA2LjM0OTIwNjQwOTgzNzc1NSAxNC4yNDMyNTMwOTI0IDYuMzQ5MjA2NDA5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEw2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgIEM2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgOC4wMzExMTM1NDk4Mzc3NTUgMCA5LjU5NTk1OTY1OTgzNzc1NyAwLjc1NDc0OTcyMTQwMDAwMDEgIHpcIjtcclxuICAgICAgICB0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDgsIG5hbWU6XCJNYWlsVGFza1wiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIE1haWxUYXNrTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgeDogMC41LFxyXG4gICAgICAgICAgICAgICAgeTogMC41LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMucmVjdFNpemUud2lkdGgtMSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZWN0U2l6ZS5oZWlnaHQtMSxcclxuICAgICAgICAgICAgICAgIHI6IDdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZicsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICByZWN0Lm5hbWUgPSBcIlJlY3RcIjtcclxuICAgICAgICB0aGlzLmFkZChyZWN0KTtcclxuXHJcbiAgICAgICAgdmFyIGljb25yZWN0ID0ge3g6NSwgeTogNSwgd2lkdGg6IDE1LCBoZWlnaHQ6MTV9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5pY29uUGF0aCwge3N0eWxlOiB7ZmlsbDogJyNmZmYnLCBzdHJva2U6ICcjMDAwJ30sejoyfSwgaWNvbnJlY3QpKTtcclxuXHJcbiAgICAgICAvLyB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMuaWNvblBhdGgyLCB7c3R5bGU6IHtmaWxsOiAnIzQ5OTBFMid9fSwgcmVjdCxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIildO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpLCAnJywgJ2NlbnRlcicpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhNYWlsVGFza05vZGUsVGFza05vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gTWFpbFRhc2tOb2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvdGFzay9NYWlsVGFza05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cdHZhciBUYXNrTm9kZSA9IHJlcXVpcmUoXCIuL1Rhc2tOb2RlLmpzXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBTZXJ2aWNlVGFza05vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgVGFza05vZGUuY2FsbCh0aGlzLG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNpemUgPSB7d2lkdGg6MTAwLCBoZWlnaHQ6NjB9O1xyXG4gICAgICAgIHRoaXMuaWNvblBhdGggPSBcIk04OTEuODQgNDEwLjA3MmMtOC45MzYtMzMuNDgtMjIuMTkyLTY1LjIzMi0zOS4xOTItOTQuNTg0bDc0LjUxMi0xMTIuNC0xMDYuMjcyLTEwNi4xODQtMTEyLjM0NCA3NC40NTZjLTI5LjM4NC0xNi45NDQtNjEuMTQ0LTMwLjI1Ni05NC42NDgtMzkuMkw1ODcuMDggMGwtMTUwLjE2IDAtMjYuODE2IDEzMi4xNmMtMzMuNTA0IDguOTQ0LTY1LjI2NCAyMi4yNTYtOTQuNjQ4IDM5LjJsLTExMi40LTc0LjQ1Nkw5Ni44MzIgMjAzLjA4bDc0LjUyIDExMi40Yy0xNyAyOS4zNTItMzAuMjU2IDYxLjExMi0zOS4yIDk0LjY0OEwwIDQzNi44ODhsMCAxNTAuMTkyIDEzMi4xNiAyNi44MjRjOC45NDQgMzMuNTA0IDIyLjE5MiA2NS4yNjQgMzkuMiA5NC42NDhsLTc0LjUyIDExMi40MDggMTA2LjIxNiAxMDYuMTUyIDExMi40LTc0LjQ1NmMyOS4zODQgMTYuOTM2IDYxLjE0NCAzMC4yNTYgOTQuNjQ4IDM5LjE5Mkw0MzYuOTIgMTAyNGwxNTAuMTYgMCAyNi44MjQtMTMyLjE2YzMzLjUwNC04LjkzNiA2NS4yNjQtMjIuMjU2IDk0LjY0OC0zOS4xOTJsMTEyLjM0NCA3NC40NTYgMTA2LjI3Mi0xMDYuMTUyLTc0LjUxMi0xMTIuNDA4YzE3LTI5LjM4NCAzMC4yNTYtNjEuMTQ0IDM5LjE5Mi05NC42NDhMMTAyNCA1ODcuMDggMTAyNCA0MzYuODg4IDg5MS44NCA0MTAuMDcyIDg5MS44NCA0MTAuMDcyek02ODkuOCA1MTJjMCA5OC4xNTItNzkuNTg0IDE3Ny44LTE3Ny44IDE3Ny44UzMzNC4yMDggNjEwLjE1MiAzMzQuMjA4IDUxMmMwLTk4LjE3NiA3OS41ODQtMTc3Ljc5MiAxNzcuNzkyLTE3Ny43OTJTNjg5LjggNDEzLjgyNCA2ODkuOCA1MTJ6XCI7XHJcbiAgICAgICAgdGhpcy5icG1uSW5mbyA9IHt0eXBlOiAxMiwgbmFtZTpcIlNlcnZpY2VUYXNrXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgU2VydmljZVRhc2tOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB5OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWN0U2l6ZS53aWR0aC0xLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlY3RTaXplLmhlaWdodC0xLFxyXG4gICAgICAgICAgICAgICAgcjogN1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlY3QubmFtZSA9IFwiUmVjdFwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHJlY3QpO1xyXG5cclxuICAgICAgICB2YXIgaWNvbnJlY3QgPSB7eDo1LCB5OiA1LCB3aWR0aDogMTUsIGhlaWdodDoxNX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoLCB7c3R5bGU6IHtmaWxsOiAnI2ZmZicsIHN0cm9rZTogJyMwMDAnfSx6OjJ9LCBpY29ucmVjdCkpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAgW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSwgJycsICdjZW50ZXInKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoU2VydmljZVRhc2tOb2RlLFRhc2tOb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2VUYXNrTm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL3Rhc2svU2VydmljZVRhc2tOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHR2YXIgVGFza05vZGUgPSByZXF1aXJlKFwiLi9UYXNrTm9kZS5qc1wiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gU21zVGFza05vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgVGFza05vZGUuY2FsbCh0aGlzLG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNpemUgPSB7d2lkdGg6MTAwLCBoZWlnaHQ6NjB9O1xyXG4gICAgICAgIHRoaXMuaWNvblBhdGggPSBcIk05NTkuOTA3Nzc1IDQzOS44OTQ3NzVjMCAxOTUuMTQwMzk5LTIwMC42MDc5MjQgMzUyLjkwOTY1NS00NDcuOTY0NTY4IDM1Mi45MDk2NTUtMjEuNzYxNjMgMC00My4wODMyMzgtMS4yMDM0MDgtNjQuMDgwNDU3LTMuNDk5NzA3LTQxLjU1NTQ0MS00LjcwMTA2OS0xMDkuODk3OTY5IDEyMS42MDE1MjItMzAwLjgyODQ4NiAxNDcuNTE3Nzc1IDEwMC4xNjQyODEtMTE3Ljk5MjMyMSAxMDYuNzI3NzY3LTIwNi40ODU3OTUgNzQuMjUwMDc0LTIyOC4zMDE2NTlDMTI1LjA1MzY0NiA2NDMuNzgyMzk2IDY0LjA5MTIwMiA1NDcuNTUzNzUxIDY0LjA5MTIwMiA0MzkuODk0Nzc1YzAtMTk0Ljc1NzY4MiAyMDAuNjA3OTI0LTM1Mi43MTcyNzQgNDQ3Ljg1MjAwNC0zNTIuNzE3Mjc0Qzc1OS4yOTk4NTEgODcuMTc3NTAyIDk1OS45MDc3NzUgMjQ1LjEzNjA3IDk1OS45MDc3NzUgNDM5Ljg5NDc3NXpcIjtcclxuICAgICAgICB0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDExLCBuYW1lOlwiU21zVGFza1wiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIFNtc1Rhc2tOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB5OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWN0U2l6ZS53aWR0aC0xLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlY3RTaXplLmhlaWdodC0xLFxyXG4gICAgICAgICAgICAgICAgcjogN1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlY3QubmFtZSA9IFwiUmVjdFwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHJlY3QpO1xyXG5cclxuICAgICAgICB2YXIgaWNvbnJlY3QgPSB7eDo1LCB5OiA1LCB3aWR0aDogMTUsIGhlaWdodDoxNX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoLCB7c3R5bGU6IHtmaWxsOiAnI2ZmZicsIHN0cm9rZTogJyMwMDAnfSx6OjJ9LCBpY29ucmVjdCkpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAgW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSwgJycsICdjZW50ZXInKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoU21zVGFza05vZGUsVGFza05vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gU21zVGFza05vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1Ntc1Rhc2tOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHR2YXIgQlBNTk5vZGUgPSByZXF1aXJlKFwiLi9CUE1OTm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIGltYWdlVXJsID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUlBQUFBQ0FDQVlBQUFERFBtSExBQUFESUVsRVFWUjRYdTJYd1UzRFVCUUVYL3BCYVlwRzZJS2lPRVljS1lBR3VJWWpJa0k0VWp6eFJKNmN2LzZ1WjBlMmNwaCt1eVp3MlBYVDkvQ1RBRHVYSUFFU1lKSEF5K0tKOVE5OHpzenIrdGQyNHlXQmE5NEE1dzJ3bldibXVFSHU3aUlUWUhlVC8zN2dCRWlBUlFKOUFoWVJQZTZCM2dDUHU5MHF6Uk5nRll5UGU4bXRBanpOelB2alBuN05FMkRuRGlSQUFpd1MrTzlmUUorQVJYenVBNzBCM1B2ZzdSSUFSK3dPU0FEM1BuaTdCTUFSdXdNU3dMMFAzaTRCY01UdWdBUnc3NE8zU3dBY3NUc2dBZHo3NE8wU0FFZnNEa2dBOXo1NHV3VEFFYnNERXNDOUQ5NHVBWERFN29BRWNPK0R0MHNBSExFN0lBSGMrK0R0RWdCSDdBNUlBUGMrZUxzRXdCRzdBeExBdlEvZUxnRnd4TzZBQkhEdmc3ZExBQnl4T3lBQjNQdmc3UklBUit3T1NBRDNQbmk3Qk1BUnV3TVN3TDBQM2k0QmNNVHVnQVJ3NzRPM1N3QWNzVHNnQWR6NzRPMFNBRWZzRGtnQTl6NTR1d1RBRWJzREVzQzlEOTR1QVhERTdvQUVjTytEdDBzQUhMRTdJQUhjKytEdEVnQkg3QTVJQVBjK2VMc0V3Qkc3QXhMQXZRL2VMZ0Z3eE82QUJIRHZnN2RMQUJ5eE95QUIzUHZnN1JJQVIrd09TQUQzUG5pN0JNQVJ1d01Td0wwUDNpNEJjTVR1Z0FSdzc0TzNTd0Fjc1RzZ0Fkejc0TzBTQUVmc0RrZ0E5ejU0dXdUQUVic0RFc0M5RDk0dUFYREU3b0FFY08rRHQwc0FITEU3SUFIYysrRHRFZ0JIN0E1SUFQYytlTHNFd0JHN0F4TEF2US9lTGdGd3hPNkFCSER2ZzdkTEFCeXhPeUFCM1B2ZzdSSUFSK3dPU0FEM1BuaTdCTUFSdXdNU3dMMFAzaTRCY01UdWdBUnc3NE8zU3dBY3NUc2dBZHo3NE8wU0FFZnNEa2dBOXo1NHV3VEFFYnNERXNDOUQ5NHVBWERFN29BRWNPK0R0MHNBSExFN0lBSGMrK0R0RWdCSDdBNUlBUGMrZUxzRXdCRzdBeExBdlEvZUxnRnd4TzZBQkhEdmc3ZExBQnl4T3lBQjNQdmc3UklBUit3T1NBRDNQbmk3Qk1BUnV3TVN3TDBQM2k0QmNNVHVnRnNGZUp1WkwrQVJQMmJtR2JpM0t5OEkzQ29BQmZRME0wZnE4dTc5SVpBQU83Y2hBUkpna2NCNThjVDZCL29Fck0vMHp4dDdBOXdKdERVbUFhekwzS25YTlFMY3FVb3hXeEJJZ0Myb2l6SVRRRFRHRmxVU1lBdnFvc3h2U2JueWdjYzd3RHNBQUFBQVNVVk9SSzVDWUlJPVwiO1xyXG5cclxuICAgIGZ1bmN0aW9uIENvbW1lbnROb2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIEJQTU5Ob2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5icG1uSW5mbyA9IHt0eXBlOiAyMSwgbmFtZTpcIkNvbW1lbnRcIiB9O1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgQ29tbWVudE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogNDBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejoyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVjdC5uYW1lID0gXCJSZWN0XCI7XHJcbiAgICAgICAgdGhpcy5hZGQocmVjdCk7XHJcbiAgICAgICAgdmFyIGxpbmUgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcclxuICAgICAgICAgICAgc2hhcGU6IHt4MTowLCAgeTE6MCwgeDI6MTAsIHkyOjB9LFxyXG4gICAgICAgICAgICBzdHlsZToge2xpbmVXaWR0aDoxLCBzdHJva2U6IFwiIzAwMFwifVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWRkKGxpbmUpO1xyXG4gICAgICAgIHZhciBsaW5lMSA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICBzaGFwZToge3gxOjAsICB5MTowLCB4MjowLCB5Mjo0MH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7bGluZVdpZHRoOjEsIHN0cm9rZTogXCIjMDAwXCJ9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hZGQobGluZTEpO1xyXG4gICAgICAgIHZhciBsaW5lMiA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICBzaGFwZToge3gxOjAsICB5MTo0MCwgeDI6MTAsIHkyOjQwfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtsaW5lV2lkdGg6MSwgc3Ryb2tlOiBcIiMwMDBcIn1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZChsaW5lMik7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIildO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpLCAnJywgJ2xlZnQnKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuICAgIENvbW1lbnROb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24oanNvbikge1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIC8v5Yib5bu65pyA5bCP5YyF5Zu055uS6Jma57q/XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgIHBvaW50c1swXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMV0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMl0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1szXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1s0XSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuXHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMucG9zaXRpb25bMF0rYm91bmRpbmdSZWN0LndpZHRoLzIsXHJcbiAgICAgICAgICAgIHk6IHRoaXMucG9zaXRpb25bMV0rYm91bmRpbmdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxyXG4gICAgICAgICAgICBib3VuZGluZ1JlY3Q6IGJvdW5kUmVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgQ29tbWVudE5vZGUucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocFgscFkpIHtcclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICB0aGlzLmF0dHIoJ3Bvc2l0aW9uJyxbcFgtYm91bmRpbmdSZWN0LndpZHRoLzIscFktYm91bmRpbmdSZWN0LmhlaWdodC8yXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIENvbW1lbnROb2RlLnByb3RvdHlwZS5nZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJSZWN0XCIpO1xyXG4gICAgICAgIHJldHVybiByZWN0LmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBDb21tZW50Tm9kZS5wcm90b3R5cGUudXBkYXRlU2hhcGUgPSBmdW5jdGlvbihyYXRpbywgaWZQYXJzZSkge1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jaGlsZE9mTmFtZShcIlJlY3RcIik7XHJcbiAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgIHZhciBzaGFwZSA9IHJlY3Quc2hhcGU7XHJcbiAgICAgICAgdmFyIG5ld1cgPSBOdW1iZXIoc2hhcGUud2lkdGggKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICB2YXIgbmV3SCA9IE51bWJlcihuZXdXICogc2hhcGUuaGVpZ2h0IC8gc2hhcGUud2lkdGgpO1xyXG4gICAgICAgIGlmIChpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgIG5ld1cgPSBwYXJzZUludChuZXdXLCAxMCk7XHJcbiAgICAgICAgICAgIG5ld0ggPSBwYXJzZUludChuZXdILCAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlY3Quc2V0U2hhcGUoe1xyXG4gICAgICAgICAgICB3aWR0aDogbmV3VyxcclxuICAgICAgICAgICAgaGVpZ2h0OiBuZXdIXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoQ29tbWVudE5vZGUsIEJQTU5Ob2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IENvbW1lbnROb2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvQ29tbWVudE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8v6L6555WM5LqL5Lu2LS0t5o2V6I635a6a5pe25Zmo5LqL5Lu26IqC54K5XHJcblxyXG5cdHZhciBFdmVudE5vZGUgPSByZXF1aXJlKFwiLi4vRXZlbnROb2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIDxnIHBvaW50ZXItZXZlbnRzPVwiZmlsbFwiIGlkPVwic2lkLUZGMEFERkMwLUQzRUMtNDIzNy1BRDE2LUEzNjI3M0QxRkU2RFwiIHRpdGxlPVwiU3RhcnQgZXZlbnRcIj5cclxuICogICAgPGNpcmNsZSBpZD1cInNpZC1GOERGQkRBRC0yODUyLTRBOUEtODRFOS1BNjU5NDNBMDk2MkJiZ19mcmFtZVwiIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjE1XCIgc3Ryb2tlPVwiIzU4NTg1OFwiIGZpbGw9XCIjZmZmZmZmXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIHN0eWxlPVwic3Ryb2tlLWRhc2hhcnJheTogNS41LCAzXCI+PC9jaXJjbGU+XHJcbiAqICAgIDxjaXJjbGUgaWQ9XCJzaWQtRjhERkJEQUQtMjg1Mi00QTlBLTg0RTktQTY1OTQzQTA5NjJCZnJhbWUyX25vbl9pbnRlcnJ1cHRpbmdcIiBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxMlwiIHN0cm9rZT1cIiM1ODU4NThcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjFcIiBzdHlsZT1cInN0cm9rZS1kYXNoYXJyYXk6IDQuNSwgM1wiPjwvY2lyY2xlPlxyXG4gKiAgICA8Y2lyY2xlIGlkPVwic2lkLUY4REZCREFELTI4NTItNEE5QS04NEU5LUE2NTk0M0EwOTYyQmZyYW1lXCIgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMTVcIiBzdHJva2U9XCIjNTg1ODU4XCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxXCI+PC9jaXJjbGU+XHJcbiAqICAgIDxjaXJjbGUgaWQ9XCJzaWQtRjhERkJEQUQtMjg1Mi00QTlBLTg0RTktQTY1OTQzQTA5NjJCZnJhbWUyXCIgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMTJcIiBzdHJva2U9XCIjNTg1ODU4XCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxXCI+PC9jaXJjbGU+XHJcbiAqICAgIDxwYXRoIGlkPVwic2lkLUY4REZCREFELTI4NTItNEE5QS04NEU5LUE2NTk0M0EwOTYyQnBhdGgxXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDYsNilcIiBkPVwiTSAxMCAwIEMgNC40NzcxNTI1IDAgMCA0LjQ3NzE1MjUgMCAxMCBDIDAgMTUuNTIyODQ3IDQuNDc3MTUyNSAyMCAxMCAyMCBDIDE1LjUyMjg0NyAyMCAyMCAxNS41MjI4NDcgMjAgMTAgQyAyMCA0LjQ3NzE1MjUgMTUuNTIyODQ3IDEuMTg0MjM3OWUtMTUgMTAgMCB6IE0gOS4wOTM3NSAxLjAzMTI1IEMgOS4yMjkyMTY0IDEuMDE3NDkyNiA5LjM2MjgyNSAxLjAzODkzMTEgOS41IDEuMDMxMjUgTCA5LjUgMy41IEwgMTAuNSAzLjUgTCAxMC41IDEuMDMxMjUgQyAxNS4wNjM1MjYgMS4yODY3ODMxIDE4LjcxMzIxNyA0LjkzNjQ3MzggMTguOTY4NzUgOS41IEwgMTYuNSA5LjUgTCAxNi41IDEwLjUgTCAxOC45Njg3NSAxMC41IEMgMTguNzEzMjE3IDE1LjA2MzUyNiAxNS4wNjM1MjYgMTguNzEzMjE3IDEwLjUgMTguOTY4NzUgTCAxMC41IDE2LjUgTCA5LjUgMTYuNSBMIDkuNSAxOC45Njg3NSBDIDQuOTM2NDczOCAxOC43MTMyMTcgMS4yODY3ODMxIDE1LjA2MzUyNiAxLjAzMTI1IDEwLjUgTCAzLjUgMTAuNSBMIDMuNSA5LjUgTCAxLjAzMTI1IDkuNSBDIDEuMjc5MTAyIDUuMDczNjQ4OCA0LjcyMjUzMjYgMS40NzUxNzEzIDkuMDkzNzUgMS4wMzEyNSB6IE0gOS41IDUgTCA5LjUgOC4wNjI1IEMgOC42MzczMDA3IDguMjg0NDYyNyA4IDkuMDY4MDE5NSA4IDEwIEMgOCAxMS4xMDQ1NjkgOC44OTU0MzA1IDEyIDEwIDEyIEMgMTAuOTMxOTgxIDEyIDExLjcxNTUzNyAxMS4zNjI2OTkgMTEuOTM3NSAxMC41IEwgMTQgMTAuNSBMIDE0IDkuNSBMIDExLjkzNzUgOS41IEMgMTEuNzU2NjQyIDguNzk3MDU5OSAxMS4yMDI5NCA4LjI0MzM1ODUgMTAuNSA4LjA2MjUgTCAxMC41IDUgTCA5LjUgNSB6IFwiIGZpbGw9XCIjNTg1ODU4XCIgc3Ryb2tlPVwibm9uZVwiPjwvcGF0aD5cclxuICogPC9nPlxyXG4gKi9cclxuXHJcblx0ZnVuY3Rpb24gQ2F0Y2hUaW1lckV2ZW50Tm9kZShtb2RlbCwgYXBpKSB7XHJcblx0XHRFdmVudE5vZGUuY2FsbCh0aGlzLG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJY29uID0gJ00gMTAgMCBDIDQuNDc3MTUyNSAwIDAgNC40NzcxNTI1IDAgMTAgQyAwIDE1LjUyMjg0NyA0LjQ3NzE1MjUgMjAgMTAgMjAgQyAxNS41MjI4NDcgMjAgMjAgMTUuNTIyODQ3IDIwIDEwIEMgMjAgNC40NzcxNTI1IDE1LjUyMjg0NyAxLjE4NDIzNzllLTE1IDEwIDAgeiBNIDkuMDkzNzUgMS4wMzEyNSBDIDkuMjI5MjE2NCAxLjAxNzQ5MjYgOS4zNjI4MjUgMS4wMzg5MzExIDkuNSAxLjAzMTI1IEwgOS41IDMuNSBMIDEwLjUgMy41IEwgMTAuNSAxLjAzMTI1IEMgMTUuMDYzNTI2IDEuMjg2NzgzMSAxOC43MTMyMTcgNC45MzY0NzM4IDE4Ljk2ODc1IDkuNSBMIDE2LjUgOS41IEwgMTYuNSAxMC41IEwgMTguOTY4NzUgMTAuNSBDIDE4LjcxMzIxNyAxNS4wNjM1MjYgMTUuMDYzNTI2IDE4LjcxMzIxNyAxMC41IDE4Ljk2ODc1IEwgMTAuNSAxNi41IEwgOS41IDE2LjUgTCA5LjUgMTguOTY4NzUgQyA0LjkzNjQ3MzggMTguNzEzMjE3IDEuMjg2NzgzMSAxNS4wNjM1MjYgMS4wMzEyNSAxMC41IEwgMy41IDEwLjUgTCAzLjUgOS41IEwgMS4wMzEyNSA5LjUgQyAxLjI3OTEwMiA1LjA3MzY0ODggNC43MjI1MzI2IDEuNDc1MTcxMyA5LjA5Mzc1IDEuMDMxMjUgeiBNIDkuNSA1IEwgOS41IDguMDYyNSBDIDguNjM3MzAwNyA4LjI4NDQ2MjcgOCA5LjA2ODAxOTUgOCAxMCBDIDggMTEuMTA0NTY5IDguODk1NDMwNSAxMiAxMCAxMiBDIDEwLjkzMTk4MSAxMiAxMS43MTU1MzcgMTEuMzYyNjk5IDExLjkzNzUgMTAuNSBMIDE0IDEwLjUgTCAxNCA5LjUgTCAxMS45Mzc1IDkuNSBDIDExLjc1NjY0MiA4Ljc5NzA1OTkgMTEuMjAyOTQgOC4yNDMzNTg1IDEwLjUgOC4wNjI1IEwgMTAuNSA1IEwgOS41IDUgeic7XHJcbiAgICAgICAgdGhpcy5pdGVtU2l6ZSA9IDEwO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiA0MywgbmFtZTpcIkNhdGNoVGltZXJFdmVudFwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBDYXRjaFRpbWVyRXZlbnROb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG5cclxuICAgICAgICB2YXIgY2lyY2xlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgICAgICByOiB0aGlzLml0ZW1TaXplLTAuNVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjNcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaXJjbGUubmFtZSA9IFwiQ2lyY2xlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQoY2lyY2xlKTtcclxuICAgICAgICB2YXIgY2lyY2xlMSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZS0zXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZmZmZicsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6JyMwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6M1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNpcmNsZTEubmFtZSA9IFwiQ2lyY2xlMVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZTEpO1xyXG5cclxuICAgICAgICB2YXIgaXRlbVNpemUgPSB0aGlzLml0ZW1TaXplKzY7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB7eDotaXRlbVNpemUvMiwgeTogLWl0ZW1TaXplLzIsIHdpZHRoOiBpdGVtU2l6ZSwgaGVpZ2h0Oml0ZW1TaXplfTtcclxuICAgICAgICB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMuc3RhcnRJY29uLCB7c3R5bGU6IHtzdHJva2U6JyMwMDAnfSx6OjN9LCByZWN0LFwiY2VudGVyXCIpKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSt0aGlzLml0ZW1TaXplICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpK3RoaXMuaXRlbVNpemVdO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICAgICAgdGhpcy56ID0gMztcclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhDYXRjaFRpbWVyRXZlbnROb2RlLCBFdmVudE5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gQ2F0Y2hUaW1lckV2ZW50Tm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2V2ZW50L2JvdW5kYXJ5ZXZlbnQvQ2F0Y2hUaW1lckV2ZW50Tm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy/ovrnnlYzkuovku7YtLS3mjZXojrfkv6Hlj7fph4/kuovku7ZcclxuXHJcblx0dmFyIEV2ZW50Tm9kZSA9IHJlcXVpcmUoXCIuLi9FdmVudE5vZGVcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcblxyXG4vKipcclxuICogPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgaWQ9XCJzaWQtRkYwQURGQzAtRDNFQy00MjM3LUFEMTYtQTM2MjczRDFGRTZEXCIgdGl0bGU9XCJTdGFydCBldmVudFwiPlxyXG4gKiAgICA8Y2lyY2xlIGlkPVwic2lkLUY4REZCREFELTI4NTItNEE5QS04NEU5LUE2NTk0M0EwOTYyQmJnX2ZyYW1lXCIgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMTVcIiBzdHJva2U9XCIjNTg1ODU4XCIgZmlsbD1cIiNmZmZmZmZcIiBzdHJva2Utd2lkdGg9XCIxXCIgc3R5bGU9XCJzdHJva2UtZGFzaGFycmF5OiA1LjUsIDNcIj48L2NpcmNsZT5cclxuICogICAgPGNpcmNsZSBpZD1cInNpZC1GOERGQkRBRC0yODUyLTRBOUEtODRFOS1BNjU5NDNBMDk2MkJmcmFtZTJfbm9uX2ludGVycnVwdGluZ1wiIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjEyXCIgc3Ryb2tlPVwiIzU4NTg1OFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIHN0eWxlPVwic3Ryb2tlLWRhc2hhcnJheTogNC41LCAzXCI+PC9jaXJjbGU+XHJcbiAqICAgIDxwYXRoIGlkPVwic2lkLTNDQzMzOTI0LTczRjMtNEQxMy1BMkE5LTAyNDI1MzA2ODBERXNpZ25hbENhdGNoaW5nXCIgc3Ryb2tlPVwiIzU4NTg1OFwiIGQ9XCIgTTcuNzEyNDk3MSAyMC4yNDczNDIgIEwyMi4zMzMzMzQgMjAuMjQ3MzQyICBMMTUuMDIyOTE1MDAwMDAwMDAxIDcuNTc1OTUxMjAwMDAwMDAxICBMNy43MTI0OTcxIDIwLjI0NzM0MiAgelwiIHN0eWxlPVwiZmlsbDpub25lO3N0cm9rZS13aWR0aDoxLjQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmVcIj48L3BhdGg+XHJcbiAqIDwvZz5cclxuICovXHJcblxyXG5cdGZ1bmN0aW9uIENhdGNoU2lnbmFsRXZlbnROb2RlKG1vZGVsLCBhcGkpIHtcclxuXHRcdEV2ZW50Tm9kZS5jYWxsKHRoaXMsbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5zdGFydEljb24gPSAnTTcuNzEyNDk3MSAyMC4yNDczNDIgIEwyMi4zMzMzMzQgMjAuMjQ3MzQyICBMMTUuMDIyOTE1MDAwMDAwMDAxIDcuNTc1OTUxMjAwMDAwMDAxICBMNy43MTI0OTcxIDIwLjI0NzM0MiAgeic7XHJcbiAgICAgICAgdGhpcy5pdGVtU2l6ZSA9IDEwO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiA3MiwgbmFtZTpcIkNhdGNoU2lnbmFsRXZlbnRcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG4gICAgICAgIHRoaXMucmVuZGVyKG1vZGVsKTtcclxuXHR9XHJcblxyXG4gICAgQ2F0Y2hTaWduYWxFdmVudE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcblxyXG4gICAgICAgIHZhciBjaXJjbGUgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgIHI6IHRoaXMuaXRlbVNpemUtMC41XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZmZmZicsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6JyMwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6M1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNpcmNsZS5uYW1lID0gXCJDaXJjbGVcIjtcclxuICAgICAgICB0aGlzLmFkZChjaXJjbGUpO1xyXG4gICAgICAgIHZhciBjaXJjbGUxID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgICAgICByOiB0aGlzLml0ZW1TaXplLTNcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTonIzAwMCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejozXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlMS5uYW1lID0gXCJDaXJjbGUxXCI7XHJcbiAgICAgICAgdGhpcy5hZGQoY2lyY2xlMSk7XHJcblxyXG4gICAgICAgIHZhciBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemU7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB7eDotaXRlbVNpemUvMiwgeTogLWl0ZW1TaXplLzItMiwgd2lkdGg6IGl0ZW1TaXplLCBoZWlnaHQ6aXRlbVNpemV9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5zdGFydEljb24sIHtzdHlsZToge3N0cm9rZTonIzAwMCcsZmlsbDonI2ZmZmZmZid9LHo6M30sIHJlY3QsXCJjZW50ZXJcIikpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpK3RoaXMuaXRlbVNpemUgLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIikrdGhpcy5pdGVtU2l6ZV07XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5kcmF3VGV4dChtb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgICAgICB0aGlzLnogPSAzO1xyXG4gICAgfTtcclxuXHJcblx0enJVdGlsLmluaGVyaXRzKENhdGNoU2lnbmFsRXZlbnROb2RlLCBFdmVudE5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gQ2F0Y2hTaWduYWxFdmVudE5vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L0NhdGNoU2lnbmFsRXZlbnROb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL+i+ueeVjOS6i+S7ti0tLVRocm93U2lnbmFsRXZlbnToioLngrlcclxuXHJcblx0dmFyIEV2ZW50Tm9kZSA9IHJlcXVpcmUoXCIuLi9FdmVudE5vZGVcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcblxyXG4vKipcclxuICogPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgaWQ9XCJzaWQtRkYwQURGQzAtRDNFQy00MjM3LUFEMTYtQTM2MjczRDFGRTZEXCIgdGl0bGU9XCJTdGFydCBldmVudFwiPlxyXG4gKiAgICA8Y2lyY2xlIGlkPVwic2lkLUY4REZCREFELTI4NTItNEE5QS04NEU5LUE2NTk0M0EwOTYyQmJnX2ZyYW1lXCIgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMTVcIiBzdHJva2U9XCIjNTg1ODU4XCIgZmlsbD1cIiNmZmZmZmZcIiBzdHJva2Utd2lkdGg9XCIxXCIgc3R5bGU9XCJzdHJva2UtZGFzaGFycmF5OiA1LjUsIDNcIj48L2NpcmNsZT5cclxuICogICAgPGNpcmNsZSBpZD1cInNpZC1GOERGQkRBRC0yODUyLTRBOUEtODRFOS1BNjU5NDNBMDk2MkJmcmFtZTJfbm9uX2ludGVycnVwdGluZ1wiIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjEyXCIgc3Ryb2tlPVwiIzU4NTg1OFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIHN0eWxlPVwic3Ryb2tlLWRhc2hhcnJheTogNC41LCAzXCI+PC9jaXJjbGU+XHJcbiAqICAgIDxwYXRoIGlkPVwic2lkLTNDQzMzOTI0LTczRjMtNEQxMy1BMkE5LTAyNDI1MzA2ODBERXNpZ25hbENhdGNoaW5nXCIgc3Ryb2tlPVwiIzU4NTg1OFwiIGQ9XCIgTTcuNzEyNDk3MSAyMC4yNDczNDIgIEwyMi4zMzMzMzQgMjAuMjQ3MzQyICBMMTUuMDIyOTE1MDAwMDAwMDAxIDcuNTc1OTUxMjAwMDAwMDAxICBMNy43MTI0OTcxIDIwLjI0NzM0MiAgelwiIHN0eWxlPVwiZmlsbDpub25lO3N0cm9rZS13aWR0aDoxLjQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmVcIj48L3BhdGg+XHJcbiAqIDwvZz5cclxuICovXHJcblxyXG5cdGZ1bmN0aW9uIFRocm93U2lnbmFsRXZlbnROb2RlKG1vZGVsLCBhcGkpIHtcclxuXHRcdEV2ZW50Tm9kZS5jYWxsKHRoaXMsbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5zdGFydEljb24gPSAnTTcuNzEyNDk3MSAyMC4yNDczNDIgIEwyMi4zMzMzMzQgMjAuMjQ3MzQyICBMMTUuMDIyOTE1MDAwMDAwMDAxIDcuNTc1OTUxMjAwMDAwMDAxICBMNy43MTI0OTcxIDIwLjI0NzM0MiAgeic7XHJcbiAgICAgICAgdGhpcy5pdGVtU2l6ZSA9IDEwO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiA3NSwgbmFtZTpcIlRocm93U2lnbmFsRXZlbnRcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG4gICAgICAgIHRoaXMucmVuZGVyKG1vZGVsKTtcclxuXHR9XHJcblxyXG4gICAgVGhyb3dTaWduYWxFdmVudE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZS0wLjVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTonIzAwMCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejozXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlLm5hbWUgPSBcIkNpcmNsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZSk7XHJcbiAgICAgICAgdmFyIGNpcmNsZTEgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgIHI6IHRoaXMuaXRlbVNpemUtM1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjNcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaXJjbGUxLm5hbWUgPSBcIkNpcmNsZTFcIjtcclxuICAgICAgICB0aGlzLmFkZChjaXJjbGUxKTtcclxuXHJcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZTtcclxuICAgICAgICB2YXIgcmVjdCA9IHt4Oi1pdGVtU2l6ZS8yLCB5OiAtaXRlbVNpemUvMi0yLCB3aWR0aDogaXRlbVNpemUsIGhlaWdodDppdGVtU2l6ZX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLnN0YXJ0SWNvbiwge3N0eWxlOiB7c3Ryb2tlOicjMDAwJyxmaWxsOicjMDAwMDAwJ30sejozfSwgcmVjdCxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikrdGhpcy5pdGVtU2l6ZSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKSt0aGlzLml0ZW1TaXplXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAgICAgICAgdGl0bGUudGV4dC5uYW1lID0gXCJUaXRsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHRpdGxlLnRleHQpO1xyXG4gICAgICAgIHRoaXMueiA9IDM7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoVGhyb3dTaWduYWxFdmVudE5vZGUsIEV2ZW50Tm9kZSk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBUaHJvd1NpZ25hbEV2ZW50Tm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2V2ZW50L2JvdW5kYXJ5ZXZlbnQvVGhyb3dTaWduYWxFdmVudE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8v6L6555WM5LqL5Lu2LS0t5o2V6I635a6a5pe25Zmo5LqL5Lu26IqC54K5XHJcblxyXG5cdHZhciBFdmVudE5vZGUgPSByZXF1aXJlKFwiLi9FdmVudE5vZGVcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcblxyXG5cdGZ1bmN0aW9uIENhdGNoTWVzc2FnZUV2ZW50Tm9kZShtb2RlbCwgYXBpKSB7XHJcblx0XHRFdmVudE5vZGUuY2FsbCh0aGlzLG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJY29uID0gXCJNNjY0LjM1NjU3MSA2MzMuMzQ0bC01MC43OTc3MTQgMCAyMjguODI3NDI5IDE0Ni45ODA1NzFMMTgxLjYxMzcxNCA3ODAuMzI0NTcxbDIyOC44Mjc0MjktMTQ2Ljk4MDU3MS01MC44MzQyODYgMC0yMDMuMTkwODU3IDEzMC40NTAyODZMMTU2LjQxNiAzNTkuMDk0ODU3bDM1OS4wMjE3MTQgMjQyLjU3ODI4NiAzNTIuMTQ2Mjg2LTIzNS4zMDA1NzEgMCAzOTcuNDU4Mjg2TDY2NC4zNTY1NzEgNjMzLjM0NHpNMTU2LjQxNiAyOTkuOTIyMjg2IDE1Ni40MTYgMjQzLjY3NTQyOWw3MTEuMTY4IDAgMCA3MS4zMTQyODYtMzUxLjM3ODI4NiAyMjIuMTcxNDI5TDE1Ni40MTYgMjk5LjkyMjI4NnpcIjtcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMTg7XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDEwMCwgbmFtZTpcIkNhdGNoTWVzc2FnZUV2ZW50XCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcblx0fVxyXG5cclxuICAgIENhdGNoTWVzc2FnZUV2ZW50Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICB2YXIgY2lyY2xlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgICAgICByOiB0aGlzLml0ZW1TaXplLTAuNVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaXJjbGUubmFtZSA9IFwiQ2lyY2xlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQoY2lyY2xlKTtcclxuICAgICAgICB2YXIgY2lyY2xlMSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZS0zXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZmZmZicsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6JyMwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNpcmNsZTEubmFtZSA9IFwiQ2lyY2xlMVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZTEpO1xyXG5cclxuICAgICAgICB2YXIgaXRlbVNpemUgPSB0aGlzLml0ZW1TaXplO1xyXG4gICAgICAgIHZhciByZWN0ID0ge3g6LWl0ZW1TaXplLzIsIHk6IC1pdGVtU2l6ZS8yLCB3aWR0aDogaXRlbVNpemUsIGhlaWdodDppdGVtU2l6ZX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLnN0YXJ0SWNvbiwge3N0eWxlOiB7c3Ryb2tlOicjZmZmJ30sejoyfSwgcmVjdCxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikrdGhpcy5pdGVtU2l6ZSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKSt0aGlzLml0ZW1TaXplXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAgICAgICAgdGl0bGUudGV4dC5uYW1lID0gXCJUaXRsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHRpdGxlLnRleHQpO1xyXG4gICAgfTtcclxuXHJcblx0enJVdGlsLmluaGVyaXRzKENhdGNoTWVzc2FnZUV2ZW50Tm9kZSwgRXZlbnROb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IENhdGNoTWVzc2FnZUV2ZW50Tm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2V2ZW50L0NhdGNoTWVzc2FnZUV2ZW50Tm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy9JbmNsdXNpdmVHYXRlV2F56IqC54K5XHJcblxyXG5cdHZhciBHYXRld2F5Tm9kZSA9IHJlcXVpcmUoXCIuL0dhdGV3YXlOb2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIDxnIHBvaW50ZXItZXZlbnRzPVwiZmlsbFwiIGlkPVwic2lkLUZGMEFERkMwLUQzRUMtNDIzNy1BRDE2LUEzNjI3M0QxRkU2RFwiIHRpdGxlPVwiU3RhcnQgZXZlbnRcIj5cclxuICogICAgPHBhdGggZD1cIiBNMCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMCAgTDM5LjAxMjc4Nzk2NCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMzkuMDEyNzg3OTY0ICBMMCAxOS41MDYzOTM5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgelwiIGlkPVwic2lkLTZEMEU5M0RBLTBFMEItNDdGMC1BRjg1LTNGMzIzMDM2NzY1MVJlY3RhbmdsZS0xXCIgZmlsbD1cIiNGNkE2MjNcIj48L3BhdGg+XHJcbiAqICAgIDxwYXRoIGQ9XCIgTTE5Ljg1MTIyMTU2NCAyNy43ODIyNTYwNjQwMDAwMDIgIEMyNC4yMzE0MTA5NjQgMjcuNzgyMjU2MDY0MDAwMDAyIDI3Ljc4MjI1NjA2NDAwMDAwMiAyNC4yMzE0MTA5NjQgMjcuNzgyMjU2MDY0MDAwMDAyIDE5Ljg1MTIyMTU2NCAgQzI3Ljc4MjI1NjA2NDAwMDAwMiAxNS40NzEwMzIxNjM5OTk5OTkgMjQuMjMxNDEwOTY0IDExLjkyMDE4NzA2Mzk5OTk5OSAxOS44NTEyMjE1NjQgMTEuOTIwMTg3MDYzOTk5OTk5ICBDMTUuNDcxMDMyMTYzOTk5OTk5IDExLjkyMDE4NzA2Mzk5OTk5OSAxMS45MjAxODcwNjM5OTk5OTkgMTUuNDcxMDMyMTYzOTk5OTk5IDExLjkyMDE4NzA2Mzk5OTk5OSAxOS44NTEyMjE1NjQgIEMxMS45MjAxODcwNjM5OTk5OTkgMjQuMjMxNDEwOTY0IDE1LjQ3MTAzMjE2Mzk5OTk5OSAyNy43ODIyNTYwNjQwMDAwMDIgMTkuODUxMjIxNTY0IDI3Ljc4MjI1NjA2NDAwMDAwMiAgelwiIGlkPVwic2lkLTZEMEU5M0RBLTBFMEItNDdGMC1BRjg1LTNGMzIzMDM2NzY1MU92YWwtNFwiIGZpbGw9XCIjRkZGRkZGXCI+PC9wYXRoPlxyXG4gKiA8L2c+XHJcbiAqL1xyXG5cclxuXHRmdW5jdGlvbiBJbmNsdXNpdmVHYXRld2F5Tm9kZShtb2RlbCwgYXBpKSB7XHJcblx0XHRHYXRld2F5Tm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJY29uID0gJ00wIDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAwICBMMzkuMDEyNzg3OTY0IDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAzOS4wMTI3ODc5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgTDAgMTkuNTA2MzkzOTY0ICB6JztcclxuICAgICAgICB0aGlzLm5leHRJY29uID0gJ001MDcuNzM4MyA0OS40NjM4NjdDMzI3LjM4OTU3IDQ4Ljg2NTA1NSAxNTQuMzM3MDQ1IDE2NS4zOTcyMzUgODUuODg3Njk1IDMzMi4wOTU3MDUgMTMuODI4MjggNDk3LjE3MTg3NSA1MS4yNjkyMSA3MDIuMjM3NiAxNzcuMzE4MzYgODMwLjk4MTQ1IDI5OC41NTAyIDk2MS40Nzc0IDQ5OC4yOTI5NyAxMDA5LjM3NDcgNjY1LjU3ODEgOTQ4LjMxNzQgODM4Ljk0OCA4ODkuMjgwNjUgOTY2LjkzOTkgNzE5LjAyMDU1IDk3My44OTc0NSA1MzUuNzcxNSA5ODUuNTY3MTUgMzU1LjcwNjE0NSA4NzkuNjI5OCAxNzYuMDYwODI1IDcxNy40MjA5IDk3LjYyNSA2NTMuOTAzNjUgNjUuOTI3OTc1IDU4Mi45NzQ2NSA0OS4zOTg1MDkgNTEyIDQ5LjUgNTEwLjU3OTA1IDQ5LjQ4MDcyOCA1MDkuMTU4MzUgNDkuNDY4NTgyIDUwNy43MzgzIDQ5LjQ2Mzg2N3pNNTIwLjQxNDA1IDk5LjQ1MDE5NUM2OTYuOTUwMyAxMDAuNDE5MzE1IDg2My4yMTY0IDIyOC4xMjk1MyA5MDguODczMDUgMzk4Ljk2NDg0NSA5NTcuMzg4MSA1NjIuNDE4NjUgODkxLjc2NjIgNzUxLjY2NzYgNzUwLjkxOTkgODQ4LjQ3NzU1IDYwNC42MTM2NSA5NTYuMDE0NzUgMzg3LjY0OTYzIDk0OC4yMzQ0NSAyNDkuNDg4MjggODMwLjM5OTQgMTEwLjI4MTI1IDcxOS40MDk0NSA2MC40NTIzNjUgNTE0LjExMTY1IDEzMS44NzUgMzUxLjMwODU5NSAxOTMuNzc4NzMgMjAwLjgwMjQzIDM0OS4xNjg5MSA5Ny41ODk0MSA1MTIgOTkuNSA1MTQuODA2OSA5OS40NTExODUgNTE3LjYxMTkgOTkuNDM0ODEgNTIwLjQxNDA1IDk5LjQ1MDE5NXonO1xyXG4gICAgICAgIHRoaXMuaXRlbVNpemUgPSAyMDtcclxuXHRcdHRoaXMuYnBtbkluZm8gPSB7dHlwZTogMjAsIG5hbWU6XCJJbmNsdXNpdmVHYXRld2F5XCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcblx0fVxyXG5cclxuICAgIEluY2x1c2l2ZUdhdGV3YXlOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemUqMjtcclxuICAgICAgICB2YXIgcmVjdCA9IHt4Oi1pdGVtU2l6ZS8yLCB5OiAtaXRlbVNpemUvMiwgd2lkdGg6IGl0ZW1TaXplLCBoZWlnaHQ6aXRlbVNpemV9O1xyXG4gICAgICAgIHZhciBwYXRoID0gZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLnN0YXJ0SWNvbiwge3N0eWxlOiB7c3Ryb2tlOiAnIzAwMCcsIGZpbGw6ICcjZmZmJ30sejoyfSwgcmVjdCxcImNlbnRlclwiKTtcclxuICAgICAgICBwYXRoLm5hbWUgPSAnUGF0aCc7XHJcbiAgICAgICAgdGhpcy5hZGQocGF0aCk7XHJcbiAgICAgICAgdmFyIGl0ZW1TaXplMSA9IHRoaXMuaXRlbVNpemU7XHJcbiAgICAgICAgdmFyIHJlY3QxID0ge3g6LWl0ZW1TaXplMS8yLCB5OiAtaXRlbVNpemUxLzIsIHdpZHRoOiBpdGVtU2l6ZTEsIGhlaWdodDppdGVtU2l6ZTF9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5uZXh0SWNvbiwge3N0eWxlOiB7c3Ryb2tlOiAnIzAwMCd9LHo6Mn0sIHJlY3QxLFwiY2VudGVyXCIpKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKStpdGVtU2l6ZTEgLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIikraXRlbVNpemUxXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAgICAgICAgdGl0bGUudGV4dC5uYW1lID0gXCJUaXRsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHRpdGxlLnRleHQpO1xyXG4gICAgfTtcclxuXHJcblx0enJVdGlsLmluaGVyaXRzKEluY2x1c2l2ZUdhdGV3YXlOb2RlLCBHYXRld2F5Tm9kZSk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBJbmNsdXNpdmVHYXRld2F5Tm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvSW5jbHVzaXZlR2F0ZXdheU5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8v5omA5pyJR2F0ZVdheeiKgueCueeahOWfuuexu1xyXG5cclxuICAgIHZhciBCUE1OTm9kZSA9IHJlcXVpcmUoXCIuLi9CUE1OTm9kZVwiKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcbiAgICAvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZSAg5YyF5ousZnJvbUpTT04gdG9KU09OXHJcbiAgICAvL1xyXG4gICAgZnVuY3Rpb24gR2F0ZXdheU5vZGUobW9kZWwsIGFwaSkge1xyXG4gICAgICAgIEJQTU5Ob2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5icG1uSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTpcIkdhdGV3YXlOb2RlXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICB9XHJcblxyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAvL+WIm+W7uuacgOWwj+WMheWbtOebkuiZmue6v1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICBwb2ludHNbMF0gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzFdID1bYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzJdID1bYm91bmRpbmdSZWN0LndpZHRoLzIsYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbM10gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbNF0gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSAtIGJvdW5kaW5nUmVjdC53aWR0aC8yICxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdIC0gYm91bmRpbmdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nUmVjdC53aWR0aCwgYm91bmRpbmdSZWN0LmhlaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogdGhpcy5wb3NpdGlvblswXSxcclxuICAgICAgICAgICAgeTogdGhpcy5wb3NpdGlvblsxXSxcclxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aC8yLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQvMixcclxuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgICAgIGJvdW5kaW5nUmVjdDogYm91bmRSZWN0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9O1xyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocFgscFkpIHtcclxuICAgICAgICAvLyBib2R5Li4uXHJcbiAgICAgICAgdGhpcy5hdHRyKCdwb3NpdGlvbicsW3BYLHBZXSk7XHJcbiAgICB9O1xyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5jaGlsZE9mTmFtZShcIlBhdGhcIik7XHJcbiAgICAgICAgcmV0dXJuIHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICB9O1xyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLnVwZGF0ZVNoYXBlID0gZnVuY3Rpb24ocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgdmFyIGdldEJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLmNoaWxkT2ZOYW1lKFwiUGF0aFwiKTtcclxuICAgICAgICB2YXIgd2lkdGggPSBnZXRCb3VuZGluZ1JlY3Qud2lkdGggKiBzY2FsZVJhdGlvO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBnZXRCb3VuZGluZ1JlY3QuaGVpZ2h0ICogc2NhbGVSYXRpbztcclxuICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHdpZHRoLCAxMCk7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IHBhcnNlSW50KGhlaWdodCwgMTApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVjdCA9IHt4Oi13aWR0aC8yLCB5OiAtaGVpZ2h0LzIsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OmhlaWdodH07XHJcbiAgICAgICAgZ3JhcGhpYy5yZXNpemVQYXRoKHBhdGgsIHJlY3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoR2F0ZXdheU5vZGUsQlBNTk5vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHYXRld2F5Tm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvR2F0ZXdheU5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL0V4Y2x1c2l2ZUdhdGVXYXnoioLngrlcclxuXHJcblx0dmFyIEdhdGV3YXlOb2RlID0gcmVxdWlyZShcIi4vR2F0ZXdheU5vZGVcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcblxyXG4vKipcclxuICogPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgaWQ9XCJzaWQtRkYwQURGQzAtRDNFQy00MjM3LUFEMTYtQTM2MjczRDFGRTZEXCIgdGl0bGU9XCJTdGFydCBldmVudFwiPlxyXG4gKiAgICA8cGF0aCBkPVwiIE0wIDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAwICBMMzkuMDEyNzg3OTY0IDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAzOS4wMTI3ODc5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgTDAgMTkuNTA2MzkzOTY0ICB6XCIgaWQ9XCJzaWQtNkQwRTkzREEtMEUwQi00N0YwLUFGODUtM0YzMjMwMzY3NjUxUmVjdGFuZ2xlLTFcIiBmaWxsPVwiI0Y2QTYyM1wiPjwvcGF0aD5cclxuICogICAgPHBhdGggZD1cIiBNOC4yNzU4NjIwNjkgMTEuOTY1NTE3MjY5MDAwMDAxICBMMS40OTk5OTk5OTkgMTEuOTY1NTE3MjY5MDAwMDAxICBMMCAxMS45NjU1MTcyNjkwMDAwMDEgIEwwIDguOTY1NTE3MjM5ICBMMS40OTk5OTk5OTkgOC45NjU1MTcyMzkgIEw4LjI3NTg2MjA2OSA4Ljk2NTUxNzIzOSAgTDguMjc1ODYyMDY5IDEuNDk5OTk5OTk5ICBMOC4yNzU4NjIwNjkgMCAgTDExLjI3NTg2MjA2OSAwICBMMTEuMjc1ODYyMDY5IDEuNDk5OTk5OTk5ICBMMTEuMjc1ODYyMDY5IDguOTY1NTE3MjM5ICBMMTguNzQxMzc5MjY5IDguOTY1NTE3MjM5ICBMMjAuMjQxMzc5MjY5IDguOTY1NTE3MjM5ICBMMjAuMjQxMzc5MjY5IDExLjk2NTUxNzI2OTAwMDAwMSAgTDE4Ljc0MTM3OTI2OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwxMS4yNzU4NjIwNjkgMTEuOTY1NTE3MjY5MDAwMDAxICBMMTEuMjc1ODYyMDY5IDE4Ljc0MTM3OTI2OSAgTDExLjI3NTg2MjA2OSAyMC4yNDEzNzkyNjkgIEw4LjI3NTg2MjA2OSAyMC4yNDEzNzkyNjkgIEw4LjI3NTg2MjA2OSAxOC43NDEzNzkyNjkgIEw4LjI3NTg2MjA2OSAxMS45NjU1MTcyNjkwMDAwMDEgIHpcIiBpZD1cInNpZC0xQjg4RDJERi1BMDhGLTQ4MzctOTFGMi05MUY2N0FDQUIyOUFMaW5lLUNvcHlcIj48L3BhdGg+XHJcbiAqIDwvZz5cclxuICovXHJcblxyXG5cdGZ1bmN0aW9uIEV4Y2x1c2l2ZUdhdGV3YXlOb2RlKG1vZGVsLCBhcGkpIHtcclxuXHRcdEdhdGV3YXlOb2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5zdGFydEljb24gPSAnTTAgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDAgIEwzOS4wMTI3ODc5NjQgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDM5LjAxMjc4Nzk2NCAgTDAgMTkuNTA2MzkzOTY0ICBMMCAxOS41MDYzOTM5NjQgIHonO1xyXG4gICAgICAgIHRoaXMubmV4dEljb24gPSAnTTE5LjkwNDEyOTA2NDAwMDAwMyAxNy42NzY5OTM5NjQwMDAwMDUgIEwyNC45OTc0NTc4NjQwMDAwMDUgMTIuNTgzNjY0ODY0MDAwMDAzICBMMjYuMDU4MTE4MDY0MDAwMDA2IDExLjUyMzAwNDY2NDAwMDAwMiAgTDI4LjE3OTQzODQ2NCAxMy42NDQzMjQ5NjQwMDAwMDMgIEwyNy4xMTg3NzgyNjQgMTQuNzA0OTg1MTY0MDAwMDAyICBMMjIuMDI1NDQ5MzY0MDAwMDA0IDE5Ljc5ODMxNDM2NCAgTDI3LjExODc3ODI2NCAyNC44OTE2NDM0NjQwMDAwMDUgIEwyOC4xNzk0Mzg0NjQgMjUuOTUyMzAzNjY0MDAwMDA2ICBMMjYuMDU4MTE4MDY0MDAwMDA2IDI4LjA3MzYyMzk2NDAwMDAwMyAgTDI0Ljk5NzQ1Nzg2NDAwMDAwNSAyNy4wMTI5NjM3NjQwMDAwMDYgIEwxOS45MDQxMjkwNjQwMDAwMDMgMjEuOTE5NjM0NzY0ICBMMTQuODEwODAwMTY0MDAwMDAzIDI3LjAxMjk2Mzc2NDAwMDAwNiAgTDEzLjc1MDE0MDA2NDAwMDAwMiAyOC4wNzM2MjM5NjQwMDAwMDMgIEwxMS42Mjg4MTk2NjQwMDAwMDMgMjUuOTUyMzAzNjY0MDAwMDA2ICBMMTIuNjg5NDc5NzY0MDAwMDAzIDI0Ljg5MTY0MzQ2NDAwMDAwNSAgTDE3Ljc4MjgwODc2NDAwMDAwMiAxOS43OTgzMTQzNjQgIEwxMi42ODk0Nzk3NjQwMDAwMDMgMTQuNzA0OTg1MTY0MDAwMDAyICBMMTEuNjI4ODE5NjY0MDAwMDAzIDEzLjY0NDMyNDk2NDAwMDAwMyAgTDEzLjc1MDE0MDA2NDAwMDAwMiAxMS41MjMwMDQ2NjQwMDAwMDIgIEwxNC44MTA4MDAxNjQwMDAwMDMgMTIuNTgzNjY0ODY0MDAwMDAzICBMMTkuOTA0MTI5MDY0MDAwMDAzIDE3LjY3Njk5Mzk2NDAwMDAwNSAgeic7XHJcbiAgICAgICAgdGhpcy5pdGVtU2l6ZSA9IDIwO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAxNywgbmFtZTpcIkV4Y2x1c2l2ZUdhdGV3YXlcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG4gICAgICAgIHRoaXMucmVuZGVyKG1vZGVsKTtcclxuXHR9XHJcblxyXG4gICAgRXhjbHVzaXZlR2F0ZXdheU5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZSoyO1xyXG4gICAgICAgIHZhciByZWN0ID0ge3g6LWl0ZW1TaXplLzIsIHk6IC1pdGVtU2l6ZS8yLCB3aWR0aDogaXRlbVNpemUsIGhlaWdodDppdGVtU2l6ZX07XHJcbiAgICAgICAgdmFyIHBhdGggPSBncmFwaGljLm1ha2VQYXRoKHRoaXMuc3RhcnRJY29uLCB7c3R5bGU6IHtzdHJva2U6ICcjMDAwJywgZmlsbDogJyNmZmYnfSx6OjJ9LCByZWN0LFwiY2VudGVyXCIpO1xyXG4gICAgICAgIHBhdGgubmFtZSA9ICdQYXRoJztcclxuICAgICAgICB0aGlzLmFkZChwYXRoKTtcclxuICAgICAgICB2YXIgaXRlbVNpemUxID0gdGhpcy5pdGVtU2l6ZTtcclxuICAgICAgICB2YXIgcmVjdDEgPSB7eDotaXRlbVNpemUxLzIsIHk6IC1pdGVtU2l6ZTEvMiwgd2lkdGg6IGl0ZW1TaXplMSwgaGVpZ2h0Oml0ZW1TaXplMX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLm5leHRJY29uLCB7c3R5bGU6IHtzdHJva2U6ICcjMDAwJ30sejoyfSwgcmVjdDEsXCJjZW50ZXJcIikpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpK2l0ZW1TaXplMSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKStpdGVtU2l6ZTFdO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoRXhjbHVzaXZlR2F0ZXdheU5vZGUsIEdhdGV3YXlOb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IEV4Y2x1c2l2ZUdhdGV3YXlOb2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZ2F0ZXdheS9FeGNsdXNpdmVHYXRld2F5Tm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vUGFyYWxsZWxHYXRlV2F56IqC54K5XHJcblxyXG5cdHZhciBHYXRld2F5Tm9kZSA9IHJlcXVpcmUoXCIuL0dhdGV3YXlOb2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIDxnIHBvaW50ZXItZXZlbnRzPVwiZmlsbFwiIGlkPVwic2lkLUZGMEFERkMwLUQzRUMtNDIzNy1BRDE2LUEzNjI3M0QxRkU2RFwiIHRpdGxlPVwiU3RhcnQgZXZlbnRcIj5cclxuICogICAgPHBhdGggZD1cIiBNMCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMCAgTDM5LjAxMjc4Nzk2NCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMzkuMDEyNzg3OTY0ICBMMCAxOS41MDYzOTM5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgelwiIGlkPVwic2lkLTZEMEU5M0RBLTBFMEItNDdGMC1BRjg1LTNGMzIzMDM2NzY1MVJlY3RhbmdsZS0xXCIgZmlsbD1cIiNGNkE2MjNcIj48L3BhdGg+XHJcbiAqICAgIDxwYXRoIGQ9XCIgTTE5LjkwNDEyOTA2NDAwMDAwMyAxNy42NzY5OTM5NjQwMDAwMDUgIEwyNC45OTc0NTc4NjQwMDAwMDUgMTIuNTgzNjY0ODY0MDAwMDAzICBMMjYuMDU4MTE4MDY0MDAwMDA2IDExLjUyMzAwNDY2NDAwMDAwMiAgTDI4LjE3OTQzODQ2NCAxMy42NDQzMjQ5NjQwMDAwMDMgIEwyNy4xMTg3NzgyNjQgMTQuNzA0OTg1MTY0MDAwMDAyICBMMjIuMDI1NDQ5MzY0MDAwMDA0IDE5Ljc5ODMxNDM2NCAgTDI3LjExODc3ODI2NCAyNC44OTE2NDM0NjQwMDAwMDUgIEwyOC4xNzk0Mzg0NjQgMjUuOTUyMzAzNjY0MDAwMDA2ICBMMjYuMDU4MTE4MDY0MDAwMDA2IDI4LjA3MzYyMzk2NDAwMDAwMyAgTDI0Ljk5NzQ1Nzg2NDAwMDAwNSAyNy4wMTI5NjM3NjQwMDAwMDYgIEwxOS45MDQxMjkwNjQwMDAwMDMgMjEuOTE5NjM0NzY0ICBMMTQuODEwODAwMTY0MDAwMDAzIDI3LjAxMjk2Mzc2NDAwMDAwNiAgTDEzLjc1MDE0MDA2NDAwMDAwMiAyOC4wNzM2MjM5NjQwMDAwMDMgIEwxMS42Mjg4MTk2NjQwMDAwMDMgMjUuOTUyMzAzNjY0MDAwMDA2ICBMMTIuNjg5NDc5NzY0MDAwMDAzIDI0Ljg5MTY0MzQ2NDAwMDAwNSAgTDE3Ljc4MjgwODc2NDAwMDAwMiAxOS43OTgzMTQzNjQgIEwxMi42ODk0Nzk3NjQwMDAwMDMgMTQuNzA0OTg1MTY0MDAwMDAyICBMMTEuNjI4ODE5NjY0MDAwMDAzIDEzLjY0NDMyNDk2NDAwMDAwMyAgTDEzLjc1MDE0MDA2NDAwMDAwMiAxMS41MjMwMDQ2NjQwMDAwMDIgIEwxNC44MTA4MDAxNjQwMDAwMDMgMTIuNTgzNjY0ODY0MDAwMDAzICBMMTkuOTA0MTI5MDY0MDAwMDAzIDE3LjY3Njk5Mzk2NDAwMDAwNSAgelwiIGlkPVwic2lkLThGQ0Q2QzAxLUI5NzMtNEM5Qy1BOTBCLTNEMkFERkM3NTIxN0xpbmVcIiBmaWxsPVwiI0ZGRkZGRlwiPjwvcGF0aD5cclxuICogPC9nPlxyXG4gKi9cclxuXHJcblx0ZnVuY3Rpb24gUGFyYWxsZWxHYXRld2F5Tm9kZShtb2RlbCwgYXBpKSB7XHJcblx0XHRHYXRld2F5Tm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJY29uID0gJ00wIDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAwICBMMzkuMDEyNzg3OTY0IDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAzOS4wMTI3ODc5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgTDAgMTkuNTA2MzkzOTY0ICB6JztcclxuICAgICAgICB0aGlzLm5leHRJY29uID0gJ004LjI3NTg2MjA2OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwxLjQ5OTk5OTk5OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwwIDExLjk2NTUxNzI2OTAwMDAwMSAgTDAgOC45NjU1MTcyMzkgIEwxLjQ5OTk5OTk5OSA4Ljk2NTUxNzIzOSAgTDguMjc1ODYyMDY5IDguOTY1NTE3MjM5ICBMOC4yNzU4NjIwNjkgMS40OTk5OTk5OTkgIEw4LjI3NTg2MjA2OSAwICBMMTEuMjc1ODYyMDY5IDAgIEwxMS4yNzU4NjIwNjkgMS40OTk5OTk5OTkgIEwxMS4yNzU4NjIwNjkgOC45NjU1MTcyMzkgIEwxOC43NDEzNzkyNjkgOC45NjU1MTcyMzkgIEwyMC4yNDEzNzkyNjkgOC45NjU1MTcyMzkgIEwyMC4yNDEzNzkyNjkgMTEuOTY1NTE3MjY5MDAwMDAxICBMMTguNzQxMzc5MjY5IDExLjk2NTUxNzI2OTAwMDAwMSAgTDExLjI3NTg2MjA2OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwxMS4yNzU4NjIwNjkgMTguNzQxMzc5MjY5ICBMMTEuMjc1ODYyMDY5IDIwLjI0MTM3OTI2OSAgTDguMjc1ODYyMDY5IDIwLjI0MTM3OTI2OSAgTDguMjc1ODYyMDY5IDE4Ljc0MTM3OTI2OSAgTDguMjc1ODYyMDY5IDExLjk2NTUxNzI2OTAwMDAwMSAgeic7XHJcbiAgICAgICAgdGhpcy5pdGVtU2l6ZSA9IDIwO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAyMCwgbmFtZTpcIlBhcmFsbGVsR2F0ZXdheVwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBQYXJhbGxlbEdhdGV3YXlOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemUqMjtcclxuICAgICAgICB2YXIgcmVjdCA9IHt4Oi1pdGVtU2l6ZS8yLCB5OiAtaXRlbVNpemUvMiwgd2lkdGg6IGl0ZW1TaXplLCBoZWlnaHQ6aXRlbVNpemV9O1xyXG4gICAgICAgIHZhciBwYXRoID0gZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLnN0YXJ0SWNvbiwge3N0eWxlOiB7c3Ryb2tlOiAnIzAwMCcsIGZpbGw6ICcjZmZmJ30sejoyfSwgcmVjdCxcImNlbnRlclwiKTtcclxuICAgICAgICBwYXRoLm5hbWUgPSAnUGF0aCc7XHJcbiAgICAgICAgdGhpcy5hZGQocGF0aCk7XHJcbiAgICAgICAgdmFyIGl0ZW1TaXplMSA9IHRoaXMuaXRlbVNpemU7XHJcbiAgICAgICAgdmFyIHJlY3QxID0ge3g6LWl0ZW1TaXplMS8yLCB5OiAtaXRlbVNpemUxLzIsIHdpZHRoOiBpdGVtU2l6ZTEsIGhlaWdodDppdGVtU2l6ZTF9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5uZXh0SWNvbiwge3N0eWxlOiB7c3Ryb2tlOiAnIzAwMCd9LHo6Mn0sIHJlY3QxLFwiY2VudGVyXCIpKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKStpdGVtU2l6ZTEgLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIikraXRlbVNpemUxXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAgICAgICAgdGl0bGUudGV4dC5uYW1lID0gXCJUaXRsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHRpdGxlLnRleHQpO1xyXG4gICAgfTtcclxuXHJcblx0enJVdGlsLmluaGVyaXRzKFBhcmFsbGVsR2F0ZXdheU5vZGUsIEdhdGV3YXlOb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IFBhcmFsbGVsR2F0ZXdheU5vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9nYXRld2F5L1BhcmFsbGVsR2F0ZXdheU5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL+WtkOa1geeoi1xyXG5cclxuICAgIHZhciBCcG1uID0gcmVxdWlyZShcIi4uL0JwbW4uanNcIik7XHJcblx0dmFyIEJQTU5Ob2RlID0gcmVxdWlyZShcIi4vQlBNTk5vZGVcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcblx0Ly/liJvlu7pOb2Rl57G7IOaJgOacieW9oueKtumDvee7p+aJv05vZGVcclxuXHQvL1xyXG5cdGZ1bmN0aW9uIFN1YlByb2Nlc3NOb2RlKG1vZGVsLCBhcGkpIHtcclxuXHJcblx0XHRCUE1OTm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTpcIlN1YlByb2Nlc3NcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB0aGlzLnNsb3QgPSBbXTtcclxuICAgICAgICB0aGlzLnNsb3RFdmVudCA9IFtdO1xyXG4gICAgICAgIHRoaXMuaXNDYW5TbG90ID0gdHJ1ZTtcclxuICAgICAgICB2YXIgd2lkdGgsaGVpZ2h0O1xyXG4gICAgICAgIHdpZHRoID0gbW9kZWwuZ2V0KFwiYm91bmRzLmxvd2VyUmlnaHQueFwiKS1tb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIik7XHJcbiAgICAgICAgaGVpZ2h0ID0gbW9kZWwuZ2V0KFwiYm91bmRzLmxvd2VyUmlnaHQueVwiKS1tb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIik7XHJcbiAgICAgICAgaWYoIXdpZHRoIHx8IHdpZHRoIDw9IDApe1xyXG4gICAgICAgICAgICB3aWR0aCA9IDE2MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoIWhlaWdodCB8fCBoZWlnaHQgPD0gMCl7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IDEwMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVjdFNpemUgPSB7d2lkdGg6d2lkdGgsIGhlaWdodDpoZWlnaHR9O1xyXG4gICAgICAgIHRoaXMucmVuZGVyKG1vZGVsKTtcclxuXHR9XHJcblxyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbihhcGkpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydkYmxjbGljaycsICdjbGljayddOy8vJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCdcclxuXHJcblxyXG4gICAgICAgIHpyVXRpbC5lYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbiAoZXZlTmFtZSkge1xyXG4gICAgICAgICAgICB0aGF0Lm9uKGV2ZU5hbWUsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBlLnRhcmdldDtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnBhcmVudCAmJiAgY3VycmVudC5wYXJlbnQgaW5zdGFuY2VvZiBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IGV2ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhhdDtcclxuICAgICAgICAgICAgICAgIGFwaS50cmlnZ2VyKGV2ZU5hbWUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgU3ViUHJvY2Vzc05vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICBcdHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB5OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWN0U2l6ZS53aWR0aC0xLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlY3RTaXplLmhlaWdodC0xLFxyXG4gICAgICAgICAgICAgICAgcjogN1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmOWY5ZjknLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnI2JiYmJiYidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejowXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVjdC5uYW1lID0gXCJzdWJwcm9jZXNzLXJlY3RcIjtcclxuICAgICAgICB0aGlzLmFkZChyZWN0KTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gIFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiksIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5kcmF3VGV4dChtb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gYm9keS4uLlxyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIC8v5Yib5bu65pyA5bCP5YyF5Zu055uS6Jma57q/XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgIHBvaW50c1swXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMV0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMl0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1szXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1s0XSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuXHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMucG9zaXRpb25bMF0rYm91bmRpbmdSZWN0LndpZHRoLzIsXHJcbiAgICAgICAgICAgIHk6IHRoaXMucG9zaXRpb25bMV0rYm91bmRpbmdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxyXG4gICAgICAgICAgICBib3VuZGluZ1JlY3Q6IGJvdW5kUmVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHBYLHBZKSB7XHJcbiAgICAgICAgLy8gYm9keS4uLlxyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIHRoaXMuYXR0cigncG9zaXRpb24nLFtwWC1ib3VuZGluZ1JlY3Qud2lkdGgvMixwWS1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdKTtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBTdWJQcm9jZXNzTm9kZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKG9wdCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jaGlsZE9mTmFtZShcInN1YnByb2Nlc3MtcmVjdFwiKTtcclxuICAgICAgICByZWN0LnNldFNoYXBlKG9wdC5zaGFwZSk7XHJcbiAgICAgICAgdGhpcy5hdHRyKCdwb3NpdGlvbicsb3B0LnBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2hUZXh0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5nZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJzdWJwcm9jZXNzLXJlY3RcIik7XHJcbiAgICAgICAgcmV0dXJuIHJlY3QuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInJlc291cmNlSWRcIiwgdGhpcy5yZXNvdXJjZUlkKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInByb3BlcnRpZXMudHlwZVwiLCB0aGlzLmJwbW5JbmZvLnR5cGUpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwic3RlbmNpbC50eXBlXCIsIHRoaXMuYnBtbkluZm8ubmFtZSk7ICAvL3N0ZW5jaWwuaWRcclxuICAgICAgICBpZiAodGhpcy5zbG90RXZlbnQgJiYgdGhpcy5zbG90RXZlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgYXJyU2xvdEV2ZW50ID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnNsb3RFdmVudC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgYXJyU2xvdEV2ZW50LnB1c2godGhpcy5zbG90RXZlbnRbaV0ucmVzb3VyY2VJZClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcInByb3BlcnRpZXMuc2xvdEV2ZW50XCIsIGFyclNsb3RFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB2YXIgcmVjdCA9IHRoaXMuZ2V0UmVjdCgpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLm1vZGVsLnNldChcImJvdW5kcy51cHBlckxlZnQueFwiLCByZWN0LngpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLm1vZGVsLnNldChcImJvdW5kcy51cHBlckxlZnQueVwiLCByZWN0LnkpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLm1vZGVsLnNldChcImJvdW5kcy5sb3dlclJpZ2h0LnhcIiwgcmVjdC54ICsgcmVjdC5ib3VuZGluZ1JlY3Qud2lkdGgpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLm1vZGVsLnNldChcImJvdW5kcy5sb3dlclJpZ2h0LnlcIiwgcmVjdC55ICsgcmVjdC5ib3VuZGluZ1JlY3QuaGVpZ2h0KTtcclxuICAgICAgICBmdW5jdGlvbiBwYXJlbnRYKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSBub2RlLmdldFJlY3QoKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0LnggKyBwYXJlbnRYKG5vZGUucGFyZW50KVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3QueFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwYXJlbnRZKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSBub2RlLmdldFJlY3QoKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0LnkgKyBwYXJlbnRZKG5vZGUucGFyZW50KVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3QueVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0UmVjdCgpLmJvdW5kaW5nUmVjdDtcclxuXHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiwgcGFyc2VJbnQocmVjdC54KSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIiwgcGFyc2VJbnQocmVjdC55KSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC54XCIsIHBhcnNlSW50KHJlY3QueCArIHJlY3Qud2lkdGgpKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImJvdW5kcy5sb3dlclJpZ2h0LnlcIiwgcGFyc2VJbnQocmVjdC55ICsgcmVjdC5oZWlnaHQpKTtcclxuXHJcblxyXG5cclxuICAgICAgICAvLyDliqDlhaXlrZDmtYHnqIvnmoQg6IqC54K5XHJcbiAgICAgICAgdmFyIGFyckNoaWxkU2hhcGVzID0gW107XHJcbiAgICAgICAgdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24oY2hpbGQpe1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCUE1OTm9kZSB8fCBjaGlsZCBpbnN0YW5jZW9mIENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgYXJyQ2hpbGRTaGFwZXMucHVzaChjaGlsZC50b0pTT04oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImNoaWxkU2hhcGVzXCIsIGFyckNoaWxkU2hhcGVzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5vcHRpb247XHJcbiAgICB9O1xyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS51cGRhdGVTaGFwZSA9IGZ1bmN0aW9uKHJhdGlvLCBpZlBhcnNlLCBwaXhlbCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jaGlsZE9mTmFtZShcInN1YnByb2Nlc3MtcmVjdFwiKTtcclxuICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gcmVjdC5zaGFwZTtcclxuICAgICAgICB2YXIgbmV3VyA9IE51bWJlcihzaGFwZS53aWR0aCAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgIHZhciBuZXdIID0gTnVtYmVyKG5ld1cgKiBzaGFwZS5oZWlnaHQgLyBzaGFwZS53aWR0aCk7XHJcbiAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHcgPSBwYXJzZUludChuZXdXIC8gcGl4ZWwsIDEwKTtcclxuICAgICAgICAgICAgdmFyIGggPSBwYXJzZUludChuZXdIIC8gcGl4ZWwsIDEwKTtcclxuICAgICAgICAgICAgbmV3VyA9IHcgKiBwaXhlbCAtIDE7XHJcbiAgICAgICAgICAgIG5ld0ggPSBoICogcGl4ZWwgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWN0LnNldFNoYXBlKHtcclxuICAgICAgICAgICAgd2lkdGg6IG5ld1csXHJcbiAgICAgICAgICAgIGhlaWdodDogbmV3SFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaFRleHQoKTtcclxuICAgIH07XHJcblxyXG4gICAgU3ViUHJvY2Vzc05vZGUucHJvdG90eXBlLm5vZGVUeXBlID0gXCJTdWJQcm9jZXNzXCI7XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhTdWJQcm9jZXNzTm9kZSxCUE1OTm9kZSk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBTdWJQcm9jZXNzTm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL1N1YlByb2Nlc3NOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEJQTU7pnZnmgIHmlrnms5XnsbtcclxuICogQGNsYXNzIGZpc2gudG9wby5GaXNoVG9wb0JwbW4uQnBtblxyXG4gKi9cclxuXHJcblx0dmFyIEJwbW4gPSB7XHJcblx0XHRCUE1OX1RZUEU6XCJzdGVuY2lsLnR5cGVcIixcclxuXHRcdEJQTU5fU0NSSVBUX1RBU0s6IFwiU2NyaXB0VGFza1wiLFxyXG5cdFx0QlBNTl9FVkVOVF9TVUJfUFJPQ0VTUzogXCJTdWJQcm9jZXNzVGFza1wiLFxyXG5cdFx0QlBNTl9UQVNLOlwiVGFza1wiLFxyXG5cdFx0VEVNUExBVEU6IFwiQlBNTkRpYWdyYW1cIixcclxuXHRcdFJFU09VUkNFX0lEOiBcInJlc291cmNlSWRcIixcclxuXHRcdFNFUVVFTkNFX0ZMT1c6IFwiU2VxdWVuY2VGbG93XCIsXHJcblx0XHRTVUJfUFJPQ0VTUzogXCJTdWJQcm9jZXNzXCIsXHJcblx0XHRVU0VSX0RBVEE6IFwicHJvcGVydGllcy51c2VyRGF0YVwiLFxyXG5cclxuXHRcdFNUQVJUX0VWRU5UOiBcIlN0YXJ0Tm9uZUV2ZW50XCIsXHJcblx0XHRFTkRfRVZFTlQ6IFwiRW5kTm9uZUV2ZW50XCIsXHJcblx0XHRVU0VSX1RBU0s6IFwiVXNlclRhc2tcIixcclxuXHRcdE1BTlVBTF9UQVNLOiBcIk1hbnVhbFRhc2tcIixcclxuXHRcdFNDUklQVF9UQVNLOiBcIlNjcmlwdFRhc2tcIixcclxuXHRcdE1BSUxfVEFTSzogXCJNYWlsVGFza1wiLFxyXG5cdFx0U0VSVklDRV9UQVNLOiBcIlNlcnZpY2VUYXNrXCIsXHJcblx0XHRTTVNfVEFTSzogXCJTbXNUYXNrXCIsXHJcblx0XHRDT01NRU5UOiBcIkNvbW1lbnRcIixcclxuXHRcdENBVENIX1RJTUVSX0VWRU5UOiBcIkNhdGNoVGltZXJFdmVudFwiLFxyXG5cdFx0Q0FUQ0hfU0lHTkFMX0VWRU5UOiBcIkNhdGNoU2lnbmFsRXZlbnRcIixcclxuXHRcdFRIUk9XX1NJR05BTF9FVkVOVDogXCJUaHJvd1NpZ25hbEV2ZW50XCIsXHJcblx0XHRDQVRDSF9NRVNTQUdFX0VWRU5UOiBcIkNhdGNoTWVzc2FnZUV2ZW50XCIsXHJcblx0XHRJTkNMVVNJVkVfR0FURVdBWTogXCJJbmNsdXNpdmVHYXRld2F5XCIsXHJcblx0XHRFWENMVVNJVkVfR0FURVdBWTogXCJFeGNsdXNpdmVHYXRld2F5XCIsXHJcblx0XHRQQVJBTExFTF9HQVRFV0FZOiBcIlBhcmFsbGVsR2F0ZXdheVwiLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog5Yik5pat6IqC54K55piv5ZCmIEJQTU7mqKHmnb8g57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcblx0XHQgKi9cclxuXHRcdGlzVGVtcGxhdGU6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dmFyIGJwbW50eXBlID0gbm9kZS5tb2RlbC5nZXQoQnBtbi5CUE1OX1RZUEUpO1xyXG5cdFx0XHRyZXR1cm4gYnBtbnR5cGUgPT09IEJwbW4uVEVNUExBVEU7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog5Yik5pat6IqC54K55piv5ZCmIEFjdGl2aXR5IOexu+Wei1xyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG5cdFx0ICovXHJcblx0XHRpc0FjdGl2aXR5OiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuIChicG1udHlwZS5pbmRleE9mKFwiVGFza1wiKSAhPSAtMSB8fCBicG1udHlwZSA9PT0gQnBtbi5DT01NRU5UKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiDliKTmlq3oioLngrnmmK/lkKYg5a2Q5rWB56iLIOexu+Wei1xyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG5cdFx0ICovXHJcblx0XHRpc1N1YlByb2Nlc3M6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dmFyIGJwbW50eXBlID0gbm9kZS5ub2RlVHlwZTtcclxuXHRcdFx0cmV0dXJuICBicG1udHlwZSA9PSBCcG1uLlNVQl9QUk9DRVNTXHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog5Yik5pat6IqC54K55piv5ZCmIOe9keWFsyDnsbvlnotcclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gIG5vZGUg6ZyA6KaB5Yik5pat57G75Z6L55qE6IqC54K5XHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuXHRcdCAqL1xyXG5cdFx0aXNHYXRld2F5OiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuIGJwbW50eXBlLmluZGV4T2YoXCJHYXRld2F5XCIpICE9IC0xO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOWIpOaWreiKgueCueaYr+WQpiDnur/mrrUg57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcblx0XHQgKi9cclxuXHRcdGlzRmxvdzogZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR2YXIgYnBtbnR5cGUgPSBub2RlLm1vZGVsLmdldChCcG1uLkJQTU5fVFlQRSk7XHJcblx0XHRcdHJldHVybiBicG1udHlwZSA9PT0gQnBtbi5TRVFVRU5DRV9GTE9XO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiDliKTmlq3mqKHlnovmmK/lkKYg57q/5q61IOexu+Wei1xyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbW9kZWwg6ZyA6KaB5Yik5pat57G75Z6L55qE5qih5Z6LXHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuXHRcdCAqL1xyXG5cdFx0aXNGbG93TW9kZWw6IGZ1bmN0aW9uKG1vZGVsKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG1vZGVsLmdldChCcG1uLkJQTU5fVFlQRSk7XHJcblx0XHRcdHJldHVybiBicG1udHlwZSA9PT0gQnBtbi5TRVFVRU5DRV9GTE9XO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOWIpOaWreiKgueCueaYr+WQpiDkuovku7Yg57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcblx0XHQgKi9cclxuXHRcdGlzRXZlbnQ6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dmFyIGJwbW50eXBlID0gbm9kZS5tb2RlbC5nZXQoQnBtbi5CUE1OX1RZUEUpO1xyXG5cdFx0XHRyZXR1cm4gYnBtbnR5cGUuaW5kZXhPZihcIkV2ZW50XCIpICE9IC0xO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOWIpOaWreiKgueCueaYr+WQpiDmj5Lns5/kuovku7Yg57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcblx0XHQgKi9cclxuXHRcdGlzU2xvdEV2ZW50OiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuIGJwbW50eXBlID09IEJwbW4uQ0FUQ0hfVElNRVJfRVZFTlQgfHwgYnBtbnR5cGUgPT0gQnBtbi5DQVRDSF9TSUdOQUxfRVZFTlQgfHwgYnBtbnR5cGUgPT0gQnBtbi5USFJPV19TSUdOQUxfRVZFTlQ7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog5Yik5pat6IqC54K55piv5ZCmIOazqOmHiiDnsbvlnotcclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gIG5vZGUg6ZyA6KaB5Yik5pat57G75Z6L55qE6IqC54K5XHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuXHRcdCAqL1xyXG5cdFx0aXNDb21tZW50OiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuIGJwbW50eXBlID09PSBCcG1uLkNPTU1FTlQ7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog6I635Y+W5b2T5YmN6IqC54K555qE57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSAgICAgIOiKgueCueeahOexu+Wei1xyXG5cdFx0ICovXHJcblx0XHRnZXRUeXBlOiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuIGJwbW50eXBlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOi/lOWbnuW9k+WJjeiKgueCueeahOagt+W8j+mAiemhuVxyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gICAgICDmoLflvI/lr7nosaFcclxuXHRcdCAqL1xyXG5cdFx0Z2V0U3R5bGU6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0cmV0dXJuIG5vZGUubW9kZWwub3B0aW9uLnN0eWxlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOi/lOWbnuW9k+WJjeiKgueCueeahOWxnuaAp+mAiemhuVxyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4gIHtPYmplY3R9ICAgICAg5bGe5oCn5a+56LGhXHJcblx0XHQgKi9cclxuXHRcdGdldFByb3A6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0cmV0dXJuIG5vZGUubW9kZWwub3B0aW9uLnByb3BlcnRpZXM7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog6I635Y+W55So5oi36Ieq5a6a5LmJ55qE5pWw5o2uXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSAgIOeUqOaIt+iHquWumuS5ieeahOaVsOaNrlxyXG5cdFx0ICovXHJcblx0XHRnZXRVc2VyRGF0YTogZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR2YXIgbW9kZWwgPSBub2RlLm1vZGVsO1xyXG5cdFx0XHRyZXR1cm4gbW9kZWwuZ2V0KEJwbW4uVVNFUl9EQVRBKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiDorr7nva7nlKjmiLfnmoToh6rlrprkuYnmlbDmja5cclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gIG5vZGUg6ZyA6KaB5Yik5pat57G75Z6L55qE6IqC54K5XHJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdXNlckRhdGEg55So5oi355qE6Ieq5a6a5LmJ5pWw5o2uXHJcblx0XHQgKi9cclxuXHRcdHNldFVzZXJEYXRhOiBmdW5jdGlvbihub2RlLCB1c2VyRGF0YSkge1xyXG5cdFx0XHR2YXIgbW9kZWwgPSBub2RlLm1vZGVsO1xyXG5cdFx0XHRtb2RlbC5zZXQoQnBtbi5VU0VSX0RBVEEsIHVzZXJEYXRhKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IEJwbW47XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvQnBtbi5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDov57mjqXnur9cclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOb2RlID0gcmVxdWlyZShcIi4uL05vZGUuanNcIik7XHJcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoXCIuL1N5bWJvbC5qc1wiKTtcclxuICAgIHZhciBIYW5kbGUgPSByZXF1aXJlKFwiLi9IYW5kbGUuanNcIik7XHJcbiAgICB2YXIgRWZmZWN0TGluZSA9IHJlcXVpcmUoXCIuL0VmZmVjdExpbmUuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdGlvblBvaW50ID0gcmVxdWlyZShcIi4vQ29ubmVjdGlvblBvaW50LmpzXCIpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZShcIi4uL21vZGVsLmpzXCIpO1xyXG5cclxuICAgIENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUID0gJ3N0cmFpZ2h0JztcclxuICAgIENvbm5lY3Rvci5UWVBFX0pBR0dFRCA9ICdqYWdnZWQnO1xyXG4gICAgQ29ubmVjdG9yLlRZUEVfQ1VSVkUgPSAnY3VydmUnO1xyXG4gICAgQ29ubmVjdG9yLlRZUEVfQ0hBSU4gPSAnY2hhaW4nO1xyXG4gICAgQ29ubmVjdG9yLlJBRElVUyA9IDM7XHJcbiAgICBDb25uZWN0b3IuU1RBUlRfTk9ERSA9IFwic3RhcnROb2RlXCI7XHJcbiAgICBDb25uZWN0b3IuRU5EX05PREUgPSBcImVuZE5vZGVcIjtcclxuICAgIENvbm5lY3Rvci5MRUZUID0gXCJsZWZ0XCI7XHJcbiAgICBDb25uZWN0b3IuUklHSFQgPSBcInJpZ2h0XCI7XHJcbiAgICBDb25uZWN0b3IuVE9QID0gXCJ0b3BcIjtcclxuICAgIENvbm5lY3Rvci5CT1RUT00gPSBcImJvdHRvbVwiO1xyXG4gICAgQ29ubmVjdG9yLkJPVFRPTSA9IFwiYm90dG9tXCI7XHJcbiAgICBDb25uZWN0b3IuU0VQRVJBVE9SID0gXCItXCI7XHJcbiAgICBDb25uZWN0b3IuTk9STUFMX0NPTE9SID0gXCIjMDAwXCI7XHJcbiAgICBDb25uZWN0b3IuU0VMRUNURURfQ09MT1IgPSAnIzc0QjdFMCc7XHJcbiAgICBDb25uZWN0b3IuQ0hJTERfTkFNRSA9IFsnbGluZVRleHQnLCAnbGluZUltYWdlJ107XHJcbiAgICAvKipcclxuICAgICAqIOaehOmAoOWHveaVsFxyXG4gICAgICogQHBhcmFtIHtbdHlwZV19IG9wdGlvbnMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDb25uZWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIE5vZGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9wdCA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgaWYgKHRoaXMub3B0Lm1vZGVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VJZCA9IHRoaXMub3B0Lm1vZGVsLmdldChcInJlc291cmNlSWRcIik7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSB0aGlzLm9wdC5tb2RlbDtcclxuICAgICAgICAgICAgdGhpcy5vcHQgPSB0aGlzLm9wdC5tb2RlbC5vcHRpb247XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZUlkID0gVXRpbC5nZXRVVUlEKCk7IC8vIOeUn+aIkOiKgueCuUlEXHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBuZXcgTW9kZWwoe30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHN5bWJvbDogeyB0eXBlOiBcImFycm93XCIsIHNpemU6IDEwLCBjb2xvcjogQ29ubmVjdG9yLk5PUk1BTF9DT0xPUiwgYm90aDpmYWxzZSwgb2Zmc2V0OjAgfSwgLy/nrq3lpLQgIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICAgICAgICBzdHlsZTogeyBsaW5lV2lkdGg6IDEsIHN0cm9rZTogQ29ubmVjdG9yLk5PUk1BTF9DT0xPUiwgbGluZVR5cGU6IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUIH0sIC8v5qC35byPXHJcbiAgICAgICAgICAgIGhvdmVyU3R5bGU6IHsgbGluZVdpZHRoOiAyLCBzdHJva2U6IENvbm5lY3Rvci5TRUxFQ1RFRF9DT0xPUiB9LCAvL+enu+S4iuWOu+eahOagt+W8j1xyXG4gICAgICAgICAgICBhcnJvd0hvdmVyU3R5bGU6IHsgZmlsbDogQ29ubmVjdG9yLlNFTEVDVEVEX0NPTE9SfSxcclxuICAgICAgICAgICAgc2hhcGU6IHsgcG9pbnRzOiBudWxsLCBzbW9vdGg6IGZhbHNlLCBzbW9vdGhDb25zdHJhaW50OiBudWxsIH0sIC8v5b2i54q2XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHN0YXJ0UG9zOm51bGwsIGVuZFBvczpudWxsLCAgLy/mjIflrprnur/mrrXotbflp4vkuI7nu4jmraIg5Zyo6IqC54K555qE5LuA5LmI5L2N572uIOm7mOiupOWAvOS4uidsZWZ0LHJpZ2h0JyAg5Y+v5Y+W5YC85Zub5Liq5pa55ZCRdG9wLGJvdHRvbSxsZWZ0LHJpZ2h0IOaWueWQkeWPr+WKoOWBj+enu+mHj+WmguWmgiBcImxlZnQrMTAsdG9wXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6WzAsMF0sICAvLyDotbflp4vnur/mrrXnprvoioLngrnnmoTlgY/np7tcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kT2Zmc2V0OlswLDBdLCAgICAvLyDnu4jmraLnur/mrrXnprvoioLngrnnmoTlgY/np7tcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlRGlzdGFuY2U6WzMwLDMwXSwgLy8g56ys5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM5pyA5ZCO5LiA5p2h5oqY57q/55qE6ZW/5bqmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czpudWxsICAgIC8v5LiN5L2/55So6Ieq5Yqo6K6h566XIOaMh+Wumui/nue6v+eahOaKmOeCueS9jee9ruaVsOe7hO+8jOmmluWwvuWPr+S7peS9v+eUqGxlZnQscmlnaHQsdG9wLGJvdHRvbVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF1dG9DaGFuZ2VQb3NpdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIHRleHRDb250ZXh0TWVudTogbnVsbCxcclxuICAgICAgICAgICAgaXNFZGl0OiB0cnVlLCAvL+aYr+WQpuWPr+e8lui+kVxyXG4gICAgICAgICAgICB0ZXh0OiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgdGV4dEZpbGw6ICcjMDAwMDAwJywgLy8g5paH5pys6aKc6ImyXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzEycHggTWljcm9zb2Z0IFlhSGVpJyxcclxuICAgICAgICAgICAgICAgIHRleHRQb3M6ICdjZW50ZXInLFxyXG4gICAgICAgICAgICAgICAgdGV4dFJvdGF0ZWFibGU6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW1hZ2U6IHtcclxuICAgICAgICAgICAgICAgIGltYWdlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDUwLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1MCxcclxuICAgICAgICAgICAgICAgIC8vIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gaW1hZ2U6IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFEd0FBQUF5Q0FZQUFBQUE5cmdDQUFBRVprbEVRVlJvUSsyYVhZZ2JWUlRIei84bXV3U0pXUHg0c0Znb2FCVXJXb3JVTDhTSzlVR2hGQ3QyVVJSaFFhaTZ1TERaeVIwRGhUYUladS9OWlBkTnJZTDRoYUtsZmxEd29TZ1VWS3JZSWhSYVA3QjkySWJ0ZzFKZklxelpuUnk1eTBSbXgyUjNNcWxKWnBONW5Ebm4zdi92bm52bm52c0JhdkJvcmE4SGNGdXRWdHZTNkhzdnZ4TkNuQWR3aXBuUFpMUFp2NEphRVh5aHRTNFNrZFhMVUNHMXpRb2g5bG1XOVo3ZmZobXcxbnFXaURhRUxEQVdac3ljdDIzN1FGM3N2OEJhNisrSTZNNVlVTFF1OGo0cDVkZkdiUWxZS1hVQXdQN1d5NG1OeHk4QWJqZGp1Zzc4SVlESGZmTEx6UHlTYmR0dnhBYkpFK280em1iWGRVZUNBUlJDM0dGWjFnOTFZTk1DTi9yZ0Rra3BSK0lHVzllcnRkNUpSRWNDK2tlbGxHOHZBV3V0MmY4eE9ORGpDTjZNYVFCc29qbUljQXo3OUtCTGV3bklZQXozMGhndUZvdTdtWGtUZ04rRkVMT1RrNU5maFIxZHNldlNXdXVQaVdoUEFQQlRLZVdqWWFCakJheVVPbUZTd1NaZ3owc3BYMXNOT2piQVRiS2taWHpKWlBLcVRDWnpjU1hvMkFBcnBTWUJPQ3ZCQUxncm04MSt2eWFBaThYaUtETy90UktNRU9KbXk3SitYaFBBcFZKcGgrdTZYemFEQWZCcnBWTFprcy9uNXpzT1BETXpzMjVoWVdFak0vOWgyM1o1dFI5SjJPOWE2MCtJYUhjaiswUWk4V0NZNmVtU2pPRkNvWEMvRUdJUGdIdUlhQ01ScmZPSk9rMUVSNG5vT0RNZmI3Y0J0TmJQRWRHcnZ2TG52RFg2NjJFYXJpMWdwVlFXZ0prVHQ0V3B6RXRlQ3VsMCtwV3hzYkZLV0orZzNmVDA5Sld1NjI1aTVvdXBWR3AyZkh6ODc3QmxSUWJXV2hlSTZNV3dGZm50QVB3STRDbkxzczVFOFcvSHB4M2daWnNERVVTY0ZrS01kQnI2a2dFejgyOEFQZ2R3ZUhGeDhjTDgvUHhjT3AzZVdxdlZIZ2J3VUpPZHo4TlN5c2NpTkZaa2w4akEzbzdtZHEvbW9wVHlpMVdtQTJrMlFvTTJBSjdOWnJNSEl4TzA2QmdadU1WNmxzeTExazhUMFRzQjMzSXltZHlleVdUT1JTbXpWWitPQW52UUpzb20ydjduQXlubGs2MktqMkxmY1dESGNhNnUxV3JmRU5GTmZzSE0vTEp0Mi91aVFMVGkwM0ZnTDhyUEVOR2JRYUhNdkNGTVlsSW9GTFlKSWN3eThWWUFtd0Y4UzBRbm1mbVVsUExzS3YrU2hsdlAvL3NXajliYTVNVTdHb2k3VjBwcEFQN3pURTFObVpPREp3QThzZ0xVUjh6czJMWjlvcEZOVnlKc2hDaWxkcGxwcklsd2s0WWVOV2U2cnV1V2hSQVBNUE1vZ0d0Q2R0OHFFVG11NnpxNVhPNVB2MC9YZ0wydWJmTGZ2U0Vob3BqOVJFVDdwWlNINnM1ZEJmYWdUWlIzUmFDWk13c1NBT2VZMlN4WTdpYWk2eHFWTXpRMHRINWlZdUtDVjE5M3huQ2dtelg4aVRWcGhMUE0vUDd3OFBEQk9vUXZlaTh3OHppQUcveSs5UlBDbmdFMlFuekhtU2JWdktVQjdHY0EzcTFVS2tmeStmeGlzeDdocmFRTXVKbnJMeU9pWXdCMjF1OTFkTDFMTnhLdWxMbzhtVXhlVzYxVzF5Y1NpZk9wVktyY3loTFFsRmtxbGJaV3E5VXJjcm5jc1o3NWFVVVl0MjI3OUdTRTI2WmFvWUFCOE9Bd3pkYzkxdnlCdUZLcXZ5NjFLS1g2N3RwU2YxMU04MUt4L3JsNjZNdFIrK2R5cVErNmY2NFArNkRYN0FYeGZ3QU52ZkZnV2NDeWpBQUFBQUJKUlU1RXJrSmdnZz09XCIsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gd2lkdGg6NTAsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gaGVpZ2h0OjUwXHJcbiAgICAgICAgICAgICAgICAvLyB9LFxyXG4gICAgICAgICAgICAgICAgaW1hZ2VQb3M6ICdjZW50ZXInLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2VSb3RhdGVhYmxlOiB0cnVlIC8vIOWbvueJh+aYr+WQpui3n+maj+e6v+auteaXi+i9rFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OiAwXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBVdGlsLm1lcmdlT3B0KGRlZmF1bHRPcHRpb25zLCB0aGlzLm9wdCwgdHJ1ZSwgJ3RleHRDb250ZXh0TWVudScpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29uUG9pbnRzR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgIHRoaXMuc3RhcnROb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVuZE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGluZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ncm91cEN1cnZlID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICB0aGlzLmljb25zID0gW107IC8vIOeUqOS6juWtmOWCqOe6v+auteS4iumdoueahOaTjeS9nOWbvuagh1xyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e57q/6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbT2JqZWN0XX0gb3B0aW9ucyBb6IqC54K55Y+C5pWwXVxyXG4gICAgICogQHBhcmFtICB7W1N0cmluZ119IHR5cGUgW+iKgueCueexu+Wei10gJ3RleHQnICdpbWFnZSdcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVMaW5lTm9kZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIHR5cGUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHRleHQgPSBudWxsO1xyXG4gICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICB0eXBlID0gJ3RleHQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbm9kZU5hbWUgPSB6clV0aWwuZmluZChDb25uZWN0b3IuQ0hJTERfTkFNRSwgZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpLmluZGV4T2YodHlwZSkgPiAtMTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXkob3B0aW9uc1t0eXBlXSkgJiYgdGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NIQUlOKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnNbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGF0LmRyYXdUZXh0KG5vZGVOYW1lK1wiLVwiK2ksIHYsIDAsIDAsIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHpyVXRpbC5pc1N0cmluZyh2KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBvYmpbdHlwZV0gPSB2O1xyXG4gICAgICAgICAgICAgICAgICAgIG9ialt0eXBlKydJZCddID0gY29udGVudC50ZXh0LmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQub3B0aW9uc1t0eXBlXVt0eXBlXVtpXSA9IG9iajtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5vcHRpb25zW3R5cGVdW3R5cGVdW2ldLnRleHRJZCA9IGNvbnRlbnQudGV4dC5pZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoYXQuYWRkKGNvbnRlbnQudGV4dCk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmNyZWF0ZU5vZGVDb250ZXh0TWVudShjb250ZW50LnRleHQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0ZXh0ID0gdGhpcy5kcmF3VGV4dChub2RlTmFtZSwgb3B0aW9ucywgMCwgMCwgdHlwZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRleHQudGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoYXQuY3JlYXRlTm9kZUNvbnRleHRNZW51KHRleHQudGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuaWZMaW5lTm9kZVJvdGF0ZWFibGUgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSAndGV4dCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQpIHtcclxuICAgICAgICAgICAgaWYgKCh0eXBlID09PSAndGV4dCcgJiYgdGhpcy5vcHRpb25zLnRleHQudGV4dFJvdGF0ZWFibGUpIHx8ICh0eXBlID09PSAnaW1hZ2UnICYmIHRoaXMub3B0aW9ucy5pbWFnZS5pbWFnZVJvdGF0ZWFibGUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5pu05paw6L+e57q/55qE5paH5a2XL+WbvueJh+iKgueCuVxyXG4gICAgICogQHBhcmFtICB7W09iamVjdF19IGxpbmVOb2RlIFvoioLngrldXHJcbiAgICAgKiBAcGFyYW0gIHtbT2JqZWN0XX0gb3B0aW9ucyBb6IqC54K55Y+C5pWwXVxyXG4gICAgICogQHBhcmFtICB7W1N0cmluZ119IHR5cGUgW+iKgueCueexu+Wei10gJ3RleHQnICdpbWFnZSdcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZWZyZXNoTGluZU5vZGUgPSBmdW5jdGlvbihsaW5lTm9kZSwgb3B0aW9ucywgdHlwZSkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgbGluZU5vZGVBcnIgPSBbXSwgbm9kZU5hbWUgPSBDb25uZWN0b3IuQ0hJTERfTkFNRVswXTtcclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgdHlwZSA9ICd0ZXh0JztcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZU5hbWUgPSB6clV0aWwuZmluZChDb25uZWN0b3IuQ0hJTERfTkFNRSwgZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpLmluZGV4T2YodHlwZSkgPiAtMTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NIQUlOICYmIHpyVXRpbC5pc0FycmF5KG9wdGlvbnNbdHlwZV0pKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnNbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICAgICAgbGluZU5vZGVBcnIucHVzaChzZWxmLmNoaWxkT2ZOYW1lKG5vZGVOYW1lKyctJytpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWxpbmVOb2RlICYmIG9wdGlvbnNbdHlwZV0pIHtcclxuICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmRyYXdUZXh0KG5vZGVOYW1lLCBvcHRpb25zLCAwLCAwLCB0eXBlKTtcclxuICAgICAgICAgICAgdGhpcy5hZGQodGV4dC50ZXh0KTtcclxuICAgICAgICAgICAgbGluZU5vZGUgPSB0aGlzLmNoaWxkT2ZOYW1lKG5vZGVOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpbmVOb2RlQXJyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGNudCA9IGxpbmVOb2RlQXJyLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gdGhpcy50dXJuaW5nUG9pbnRzWzFdLnggLSB0aGlzLnR1cm5pbmdQb2ludHNbMF0ueCxcclxuICAgICAgICAgICAgICAgIGdhcCA9IHBhcnNlSW50KGRpc3RhbmNlL2NudCksXHJcbiAgICAgICAgICAgICAgICBwb3MgPSAtKGdhcCkgKiBwYXJzZUludChjbnQvMik7XHJcblxyXG4gICAgICAgICAgICAgICAgbGluZU5vZGVBcnIuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleHRQb2ludCA9IHNlbGYuZ2V0VGV4dFBvc3Rpb24ob3B0aW9ucywgdiksIHdheSA9ICcnO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciByYXRlID0gc2VsZi5nZXRUZXh0Um90YXRpb24odGV4dFBvaW50LCB2KTtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhyYXRlKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXkgPSByYXRlID4gMCA/ICdwbHVzJyA6ICdtaW51cyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByYXRlID0gTWF0aC5hYnMocmF0ZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVnID0gKDE4MCpyYXRlKS9NYXRoLlBJO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gbnVsbCwgbGVuZ3RoID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2LnNldFN0eWxlKFwidGV4dFwiLCB6clV0aWwuaXNTdHJpbmcob3B0aW9uc1t0eXBlXVtpXSkgPyBvcHRpb25zW3R5cGVdW2ldIDogb3B0aW9uc1t0eXBlXVtpXS50ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmm7TmlrDmloflrZfnn6nlvaLljIXlm7Tnm5JcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dEJvdW5kaW5nUmVjdCA9IHNlbGYuZ2V0VGV4dEJvdW5kaW5nUmVjdCh2LnN0eWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB2LnNldFNoYXBlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRleHRCb3VuZGluZ1JlY3Qud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGV4dEJvdW5kaW5nUmVjdC5oZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAod2F5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm90YXRpb24gPSBkZWcgPiA5MCA/ICgoZGVnLTQ1KSpNYXRoLlBJKS8xODAgOiAoKDQ1K2RlZykqTWF0aC5QSSkvMTgwO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gd2F5ID09PSAnbWludXMnID8gLShyb3RhdGlvbikgOiByb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm90YXRpb24gPSAoNDUqTWF0aC5QSSkvMTgwXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2LmF0dHIoJ3JvdGF0aW9uJywgcm90YXRpb24pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkZWcgPT09IDkwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dFBvaW50WzFdIC09IHBvcztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dFBvaW50WzBdICs9IHBvcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmF0ZSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBNYXRoLnRhbihkZWcqTWF0aC5QSS8xODApKnBvcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb2ludFsxXSAtPSB3YXkgPT09ICdwbHVzJyA/IGxlbmd0aCA6IC0obGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb2ludFsxXSArPSB3YXkgPT09ICdwbHVzJyA/IC0obGVuZ3RoKSA6IChsZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHYuYXR0cihcInBvc2l0aW9uXCIsIHRleHRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICBwb3MgKz0gZ2FwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpbmVOb2RlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVOb2RlLnNldFN0eWxlKFwidGV4dFwiLCBvcHRpb25zW3R5cGVdKTtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXh0UmVjdCA9IHRoaXMuZ2V0VGV4dEJvdW5kaW5nUmVjdChvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGxpbmVOb2RlLnNldFNoYXBlKHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGV4dFJlY3Qud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0ZXh0UmVjdC5oZWlnaHRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ZXh0UG9pbnQgPSB0aGlzLmdldFRleHRQb3N0aW9uKG9wdGlvbnMsIGxpbmVOb2RlKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaWZMaW5lTm9kZVJvdGF0ZWFibGUodHlwZSkpIHsgLy8jMTg3XHJcbiAgICAgICAgICAgICAgICBsaW5lTm9kZS5hdHRyKCdyb3RhdGlvbicsIHRoaXMuZ2V0VGV4dFJvdGF0aW9uKHRleHRQb2ludCwgbGluZU5vZGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaW5lTm9kZS5hdHRyKFwicG9zaXRpb25cIiwgdGV4dFBvaW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6YeN5paw55S757q/77yM5aaC5p6c5Lyg56m65YiZ5qC55o2udHVybmluZ1BvaW50cyDph43mlrDnlLvnur9cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcG9pbnRzIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oYXJyUG9pbnRzKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIGlmIChhcnJQb2ludHMpIHtcclxuICAgICAgICAgICAgdGhpcy50dXJuaW5nUG9pbnRzID0gYXJyUG9pbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+Wwhlt4OjAseTowXei9rOWMluS4ulswLCAwXSAg57uZenJlbmRlcuS9v+eUqFxyXG4gICAgICAgIHZhciBwb2ludHMgPSBVdGlsLnRyYXNsYXRlUG9pbnRzKHRoaXMudHVybmluZ1BvaW50cyk7XHJcblxyXG4gICAgICAgIGlmICgodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSAmJiAocG9pbnRzLmxlbmd0aCA+IDIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q3VydmUodGhpcy50dXJuaW5nUG9pbnRzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmUuYXR0cignc2hhcGUnLCB7IHBvaW50czogcG9pbnRzIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5pu05paw57q/5q615paH5a2XL+WbvueJh+iKgueCuVxyXG4gICAgICAgIENvbm5lY3Rvci5DSElMRF9OQU1FLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgbGluZU5vZGUgPSB0aGF0LmNoaWxkT2ZOYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IG5hbWUgPT09IENvbm5lY3Rvci5DSElMRF9OQU1FWzBdID8gJ3RleHQnIDogJ2ltYWdlJztcclxuICAgICAgICAgICAgdGhhdC5yZWZyZXNoTGluZU5vZGUobGluZU5vZGUsIHRoYXQub3B0aW9uc1t0eXBlXSwgdHlwZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMucmVmcmVzaEZyb21Ub1N5bWJvbChwb2ludHMpO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaEhhbmRsZXMoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uue6v+S4iuiKgueCueeahOWPs+WHu+ebkeWQrFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY3JlYXRlTm9kZUNvbnRleHRNZW51ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICBpZiAobm9kZSAmJiB0aGlzLm9wdC50ZXh0Q29udGV4dE1lbnUpIHtcclxuICAgICAgICAgICAgdmFyIHRleHRDb250ZXh0TWVudSA9IHRoaXMub3B0LnRleHRDb250ZXh0TWVudTtcclxuICAgICAgICAgICAgbm9kZS5vbihcImNvbnRleHRtZW51XCIsZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgZS5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgZS5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIHRleHRDb250ZXh0TWVudS5idWlsZE1lbnUoZS5ldmVudCx0aGlzKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOa4suafk1xyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIC8vMS7liJvlu7rnrq3lpLRcclxuICAgICAgICB0aGlzLnJlbmRlckZyb21Ub1N5bWJvbCgpO1xyXG5cclxuICAgICAgICAvLzIu5Yib5bu657q/XHJcbiAgICAgICAgdGhpcy5jdXJ2ZUxpbmUgPSBuZXcgZ3JhcGhpYy5CZXppZXJDdXJ2ZSh7XHJcbiAgICAgICAgICAgIC8vcG9zaXRpb246IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcclxuICAgICAgICAgICAgc3R5bGU6IHRoaXMub3B0aW9ucy5zdHlsZSxcclxuICAgICAgICAgICAgejogdGhpcy5vcHRpb25zLnpcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmdyb3VwQ3VydmUuYWRkKHRoaXMuY3VydmVMaW5lKTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLmdyb3VwQ3VydmUpO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMuY29uUG9pbnRzR3JvdXApO1xyXG4gICAgICAgIHRoaXMucG9seUxpbmUgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSh7XHJcbiAgICAgICAgICAgIC8vcG9zaXRpb246IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcclxuICAgICAgICAgICAgc2hhcGU6IHRoaXMub3B0aW9ucy5zaGFwZSxcclxuICAgICAgICAgICAgc3R5bGU6IHRoaXMub3B0aW9ucy5zdHlsZSxcclxuICAgICAgICAgICAgejogdGhpcy5vcHRpb25zLnpcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLnBvbHlMaW5lKTtcclxuXHJcbiAgICAgICAgaWYgKCh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZSA9IHRoaXMuZ3JvdXBDdXJ2ZTtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVIb3ZlclN0eWxlKHRoaXMuY3VydmVMaW5lKTtcclxuICAgICAgICAgICAgdGhpcy5wb2x5TGluZS5oaWRlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lID0gdGhpcy5wb2x5TGluZTtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVIb3ZlclN0eWxlKHRoaXMucG9seUxpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnZlTGluZS5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLzMu5L6m5ZCs57q/5LqL5Lu2XHJcbiAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydkYmxjbGljaycsICdjbGljayddOyAvLydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnXHJcbiAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lLm9uKGV2ZU5hbWUsIHpyVXRpbC5iaW5kKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiQ29ubmVjdG9yOlwiICsgZXZlTmFtZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGF0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pc0VkaXQgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IH1cclxuICAgICAgICAgICAgICAgIHRoYXQuc2V0U2VsZWN0ZWRTdHlsZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhbmRsZXMubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcGVTZXRIYW5kbGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgLy80LuWIm+W7uue6v+S4iuaWh+acrFxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dC50ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlTGluZU5vZGUodGhpcy5vcHRpb25zLnRleHQsICd0ZXh0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIC8vIDUu5Yib5bu657q/5LiK5Zu+54mH6IqC54K5XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbWFnZS5pbWFnZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUxpbmVOb2RlKHRoaXMub3B0aW9ucy5pbWFnZSwgJ2ltYWdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnJlbmRlckZyb21Ub1N5bWJvbCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgc3ltYm9sVG8gPSB0aGlzLmNyZWF0ZVN5bWJvbCgndG9TeW1ib2wnLCB0aGlzLm9wdGlvbnMpOyAvL2Fycm93LHRyaWFuZ2xlXHJcbiAgICAgICAgaWYgKHN5bWJvbFRvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHN5bWJvbFRvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/lpoLmnpzlj4zlkJHnrq3lpLQg5YiZ5YaN5Yib5bu66aaW566t5aS0XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zeW1ib2wuYm90aCkge1xyXG4gICAgICAgICAgICB2YXIgc3ltYm9sRnJvbSA9IHRoaXMuY3JlYXRlU3ltYm9sKCdmcm9tU3ltYm9sJywgdGhpcy5vcHRpb25zKTsgLy9hcnJvdyx0cmlhbmdsZVxyXG4gICAgICAgICAgICBpZiAoc3ltYm9sRnJvbSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoc3ltYm9sRnJvbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZWZyZXNoRnJvbVRvU3ltYm9sID0gZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICB2YXIgc3ltYm9sRnJvbSA9IHRoaXMuY2hpbGRPZk5hbWUoJ2Zyb21TeW1ib2wnKTtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBbXSwgb2Zmc2V0ID0gdGhpcy5vcHRpb25zLnN5bWJvbC5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHN5bWJvbFRvKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWZmZWN0ICYmIHRoaXMub3B0aW9ucy5lZmZlY3Quc2hvdykge1xyXG4gICAgICAgICAgICAgICAgbmV3IEVmZmVjdExpbmUoc3ltYm9sVG8sIHRoaXMub3B0aW9ucywgdGhpcy5ncm91cEN1cnZlLCB0aGlzLnBvbHlMaW5lKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgIT09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gdmVjMi5kaXN0YW5jZShwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IGRpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdmVjMi5sZXJwKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW10sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgLyBkaXN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN5bWJvbFRvLmF0dHIoJ3Bvc2l0aW9uJywgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sVG8uYXR0cigncm90YXRpb24nLCBVdGlsLnRhbmdlbnRSb3RhdGlvbih0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCAtIDJdLCB0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCAtIDFdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzeW1ib2xGcm9tKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uID0gcG9pbnRzWzBdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlICE9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlRnJvbSA9IHZlYzIuZGlzdGFuY2UocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSBkaXN0YW5jZUZyb20pIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHZlYzIubGVycChcclxuICAgICAgICAgICAgICAgICAgICAgICAgW10sIHBvaW50c1swXSwgcG9pbnRzWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgLyBkaXN0YW5jZUZyb20pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvaW50c1swXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzeW1ib2xGcm9tLmF0dHIoJ3Bvc2l0aW9uJywgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICBzeW1ib2xGcm9tLmF0dHIoJ3JvdGF0aW9uJywgVXRpbC50YW5nZW50Um90YXRpb24odGhpcy50dXJuaW5nUG9pbnRzWzFdLCB0aGlzLnR1cm5pbmdQb2ludHNbMF0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOiuvue9rnN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyDmoLflvI/lr7nosaFcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbm90U2F2ZU1vZGVsIOiuvue9ruagt+W8j+aYr+WQpuS/neWtmOWIsOaooeWei+S4rSzpu5jorqTmmK9mYWxzZVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24ob3B0aW9ucyxub3RTYXZlTW9kZWwpIHtcclxuICAgICAgICB2YXIgbGluZU9wdCA9IHt9O1xyXG4gICAgICAgIHZhciBzeW1ib2xUbyA9IG51bGw7XHJcbiAgICAgICAgdmFyIG5vdExpbmVLZXlzID0gWyd0ZXh0JywgJ2ltYWdlJywgJ3N5bWJvbCddO1xyXG4gICAgICAgIC8vIGlmIChvcHRpb25zLmNvbG9yKSB7XHJcbiAgICAgICAgLy8gICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpIHtcclxuICAgICAgICAvLyAgICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZS5lYWNoQ2hpbGQoZnVuY3Rpb24oY3VydmUpIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICBjdXJ2ZS5hdHRyKFwic3R5bGVcIiwgeyBzdHJva2U6IG9wdGlvbnMuY29sb3IgfSk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgZ3JhcGhpYy5zZXROb3JtYWxTdHlsZShjdXJ2ZSwgeyBzdHJva2U6IG9wdGlvbnMuY29sb3IgfSk7XHJcbiAgICAgICAgLy8gICAgICAgICB9KTtcclxuICAgICAgICAvLyAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgICAgIHRoaXMucG9seUxpbmUuYXR0cihcInN0eWxlXCIsIHsgc3Ryb2tlOiBvcHRpb25zLmNvbG9yIH0pO1xyXG4gICAgICAgIC8vICAgICAgICAgZ3JhcGhpYy5zZXROb3JtYWxTdHlsZSh0aGlzLnBvbHlMaW5lLCB7IHN0cm9rZTogb3B0aW9ucy5jb2xvciB9KTtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vICAgICBzeW1ib2xUbyA9IHRoaXMuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XHJcbiAgICAgICAgLy8gICAgIGlmIChzeW1ib2xUbykge1xyXG4gICAgICAgIC8vICAgICAgICAgc3ltYm9sVG8uYXR0cihcInN0eWxlXCIsIHsgZmlsbDogb3B0aW9ucy5jb2xvciB9KTtcclxuICAgICAgICAvLyAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUoc3ltYm9sVG8sIHsgZmlsbDogb3B0aW9ucy5jb2xvciB9KTtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vICAgICBpZighbm90U2F2ZU1vZGVsKSB7XHJcbiAgICAgICAgLy8gICAgICAgICB0aGlzLm9wdGlvbnMuc3R5bGUuc3Ryb2tlID0gb3B0aW9ucy5jb2xvcjtcclxuICAgICAgICAvLyAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zdHlsZS5zdHJva2VcIiwgb3B0aW9ucy5jb2xvcik7XHJcbiAgICAgICAgLy8gICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuc3ltYm9sLmNvbG9yXCIsIG9wdGlvbnMuY29sb3IpO1xyXG4gICAgICAgIC8vICAgICAgICAgdGhpcy5vcHRpb25zLnN5bWJvbC5jb2xvciA9IG9wdGlvbnMuY29sb3I7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZShDb25uZWN0b3IuQ0hJTERfTkFNRVswXSk7XHJcbiAgICAgICAgICAgIC8v5byA5aeL5rKh5pyJ5Yib5bu65paH5pys77yM5ZCO5p2l5Lyg6L+b5p2ldGV4dOS6hu+8jOmcgOimgeWFiOWIm+W7uuaWh+acrFxyXG4gICAgICAgICAgICBpZiAoIWxpbmVUZXh0ICYmIG9wdGlvbnMudGV4dC50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZHJhd1RleHQoQ29ubmVjdG9yLkNISUxEX05BTUVbMF0sIG9wdGlvbnMudGV4dCwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZCh0ZXh0LnRleHQpO1xyXG4gICAgICAgICAgICAgICAgbGluZVRleHQgPSB0aGlzLmNoaWxkT2ZOYW1lKENvbm5lY3Rvci5DSElMRF9OQU1FWzBdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGV4dC50ZXh0IHx8IG9wdGlvbnMudGV4dC50ZXh0ID09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVUZXh0LnNldFN0eWxlKFwidGV4dFwiLCBvcHRpb25zLnRleHQudGV4dCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC50ZXh0ID0gb3B0aW9ucy50ZXh0LnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRleHRQb2ludCA9IHRoaXMuZ2V0VGV4dFBvc3Rpb24ob3B0aW9ucy50ZXh0KTtcclxuICAgICAgICAgICAgbGluZVRleHQuYXR0cihcInBvc2l0aW9uXCIsIHRleHRQb2ludCk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRleHQudGV4dFBvcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRleHQudGV4dFBvcyA9IG9wdGlvbnMudGV4dC50ZXh0UG9zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRleHQub2Zmc2V0KSB7IC8vIzE4N1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRleHQub2Zmc2V0ID0gb3B0aW9ucy50ZXh0Lm9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGV4dC5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgbGluZVRleHQuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0RmlsbDogb3B0aW9ucy50ZXh0LmNvbG9yXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0LnRleHRGaWxsID0gb3B0aW9ucy50ZXh0LmNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50ZXh0LnRleHRGb250KSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lVGV4dC5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRGb250Om9wdGlvbnMudGV4dC50ZXh0Rm9udFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC50ZXh0Rm9udCA9IG9wdGlvbnMudGV4dC50ZXh0Rm9udDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGV4dC50ZXh0RmlsbCkge1xyXG4gICAgICAgICAgICAgICAgbGluZVRleHQuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0RmlsbDogb3B0aW9ucy50ZXh0LnRleHRGaWxsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0LnRleHRGaWxsID0gb3B0aW9ucy50ZXh0LnRleHRGaWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy50ZXh0XCIsIG9wdGlvbnMudGV4dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5pbWFnZSkge1xyXG4gICAgICAgICAgICB2YXIgbGluZUltYWdlID0gdGhpcy5jaGlsZE9mTmFtZShDb25uZWN0b3IuQ0hJTERfTkFNRVsxXSk7XHJcbiAgICAgICAgICAgIC8v5byA5aeL5rKh5pyJ5Yib5bu65Zu+54mH77yM5ZCO5p2l5Lyg6L+b5p2laW1hZ2XkuobvvIzpnIDopoHlhYjliJvlu7rlm77niYdcclxuICAgICAgICAgICAgaWYgKCFsaW5lSW1hZ2UgJiYgb3B0aW9ucy5pbWFnZS5pbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlID0gdGhpcy5kcmF3VGV4dChDb25uZWN0b3IuQ0hJTERfTkFNRVsxXSwgb3B0aW9ucy5pbWFnZSwgMCwgMCwgJ2ltYWdlJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChpbWFnZS50ZXh0KTtcclxuICAgICAgICAgICAgICAgIGxpbmVJbWFnZSA9IHRoaXMuY2hpbGRPZk5hbWUoQ29ubmVjdG9yLkNISUxEX05BTUVbMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbWFnZVBvaW50ID0gdGhpcy5nZXRUZXh0UG9zdGlvbihvcHRpb25zLmltYWdlLCBsaW5lSW1hZ2UpO1xyXG4gICAgICAgICAgICBsaW5lSW1hZ2UuYXR0cihcInBvc2l0aW9uXCIsIGltYWdlUG9pbnQpO1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmltYWdlW2tleV0gPSBvcHRpb25zW2tleV07XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmltYWdlLm9mZnNldCkgeyAvLyMxODdcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5pbWFnZS5vZmZzZXQgPSBvcHRpb25zLmltYWdlLm9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuaW1hZ2VcIiwgb3B0aW9ucy5pbWFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zeW1ib2wpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3ltYm9sLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zeW1ib2wudHlwZSA9IG9wdGlvbnMuc3ltYm9sLnR5cGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuc3ltYm9sLnR5cGVcIiwgb3B0aW9ucy5zeW1ib2wudHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3ltYm9sLnNpemUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zeW1ib2wuc2l6ZSA9IG9wdGlvbnMuc3ltYm9sLnNpemU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuc3ltYm9sLnNpemVcIiwgb3B0aW9ucy5zeW1ib2wuc2l6ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3ltYm9sLmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3ltYm9sLmNvbG9yID0gb3B0aW9ucy5zeW1ib2wuY29sb3I7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuc3ltYm9sLmNvbG9yXCIsIG9wdGlvbnMuc3ltYm9sLmNvbG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zeW1ib2wueikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN5bWJvbC56ID0gb3B0aW9ucy5zeW1ib2wuejtcclxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zeW1ib2wuelwiLCBvcHRpb25zLnN5bWJvbC56KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3ltYm9sVG8gPSB0aGlzLmNoaWxkT2ZOYW1lKCd0b1N5bWJvbCcpO1xyXG4gICAgICAgICAgICBpZiAoc3ltYm9sVG8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHN5bWJvbFRvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3ltYm9sID0gdGhpcy5jcmVhdGVTeW1ib2woXCJ0b1N5bWJvbFwiLCB0aGlzLm1vZGVsLmdldChcIm9wdGlvbnNcIikpXHJcbiAgICAgICAgICAgIGlmIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHN5bWJvbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgaWYgKG5vdExpbmVLZXlzLmluZGV4T2Yoa2V5KSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGxpbmVPcHRba2V5XSA9IG9wdGlvbnNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShsaW5lT3B0KSAhPT0gJ3t9Jykge1xyXG4gICAgICAgICAgICBpZiAobGluZU9wdC5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgbGluZU9wdC5zdHJva2UgPSBsaW5lT3B0LmNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsaW5lT3B0LnN0cm9rZSkge1xyXG4gICAgICAgICAgICAgICAgbGluZU9wdC5jb2xvciA9IGxpbmVPcHQuc3Ryb2tlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZS5lYWNoQ2hpbGQoZnVuY3Rpb24oY3VydmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJ2ZS5hdHRyKFwic3R5bGVcIiwgbGluZU9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5zZXROb3JtYWxTdHlsZShjdXJ2ZSwgbGluZU9wdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9seUxpbmUuYXR0cihcInN0eWxlXCIsIGxpbmVPcHQpO1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpYy5zZXROb3JtYWxTdHlsZSh0aGlzLnBvbHlMaW5lLCBsaW5lT3B0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzeW1ib2xUbyA9IHRoaXMuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XHJcbiAgICAgICAgICAgIGlmIChzeW1ib2xUbyAmJiBsaW5lT3B0LmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKFwic3R5bGVcIiwgeyBmaWxsOiBsaW5lT3B0LmNvbG9yIH0pO1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpYy5zZXROb3JtYWxTdHlsZShzeW1ib2xUbywgeyBmaWxsOiBsaW5lT3B0LmNvbG9yIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCFub3RTYXZlTW9kZWwpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGxpbmVPcHQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN0eWxlW2tleV0gPSBsaW5lT3B0W2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLnN0eWxlXCIrIGtleSwgbGluZU9wdFtrZXldKTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZU9wdC5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zeW1ib2wuY29sb3IgPSBsaW5lT3B0LmNvbG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuvue9rumAieS4rXN0eWxlXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuc2V0U2VsZWN0ZWRTdHlsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIOmAieS4reeahOi/nue6v+Wxgue6p+aYr+acgOmrmOeahFxyXG4gICAgICAgIHZhciBzeW1ib2xUbztcclxuICAgICAgICB0aGlzLnNldFN0eWxlKHRoaXMub3B0aW9ucy5ob3ZlclN0eWxlLCB0cnVlKTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZS5lYWNoQ2hpbGQoZnVuY3Rpb24oY3VydmUpIHtcclxuICAgICAgICAgICAgICAgIGN1cnZlLmF0dHIoXCJ6XCIsIHRoaXMub3B0aW9ucy56ICsgMik7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wb2x5TGluZS5hdHRyKCd6JywgdGhpcy5vcHRpb25zLnogKyAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3ltYm9sVG8gPSB0aGlzLmNoaWxkT2ZOYW1lKCd0b1N5bWJvbCcpO1xyXG4gICAgICAgIGlmIChzeW1ib2xUbykge1xyXG4gICAgICAgICAgICBzeW1ib2xUby5hdHRyKFwielwiLCB0aGlzLm9wdGlvbnMueiArIDIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7lj5bmtojpgInkuK1zdHlsZVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnJlbW92ZVNlbGVjdGVkU3R5bGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc3ltYm9sVG87XHJcbiAgICAgICAgdGhpcy5zZXRTdHlsZSh7Y29sb3I6dGhpcy5vcHRpb25zLnN0eWxlLnN0cm9rZSxsaW5lV2lkdGg6dGhpcy5vcHRpb25zLnN0eWxlLmxpbmVXaWR0aH0sdHJ1ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGN1cnZlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJ2ZS5hdHRyKFwielwiLCB0aGlzLm9wdGlvbnMueik7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wb2x5TGluZS5hdHRyKCd6JywgdGhpcy5vcHRpb25zLnopO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzeW1ib2xUbyA9IHRoaXMuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XHJcbiAgICAgICAgaWYgKHN5bWJvbFRvKSB7XHJcbiAgICAgICAgICAgIHN5bWJvbFRvLmF0dHIoXCJ6XCIsIHRoaXMub3B0aW9ucy56KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W57q/5q616IqC54K555qE5L2N572uXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHRleHQge3RleHQ6JycsIGNvbG9yOicnLCB0ZXh0UG9zOicnfVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgIHt4LHl9XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0VGV4dFBvc3Rpb24gPSBmdW5jdGlvbih0ZXh0LCBub2RlKSB7XHJcbiAgICAgICAgdmFyIHRleHRQb3N0aW9uID0gW107XHJcbiAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dC5pbWFnZSAmJiBub2RlID8gbm9kZS5nZXRCb3VuZGluZ1JlY3QoKSA6IHRoaXMuZ2V0VGV4dEJvdW5kaW5nUmVjdCh0ZXh0KTtcclxuICAgICAgICB2YXIgdGV4dFdpZHRoID0gdGV4dFJlY3Qud2lkdGg7XHJcbiAgICAgICAgdmFyIHRleHRIZWlnaHQgPSB0ZXh0UmVjdC5oZWlnaHQgfHwgMTI7XHJcbiAgICAgICAgdmFyIHBvcztcclxuICAgICAgICBpZiAodGV4dCAmJiAodGV4dC50ZXh0UG9zIHx8IHRleHQuaW1hZ2VQb3MpKSB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0ZXh0Lm9mZnNldCB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgYXJyT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICBwb3MgPSB0ZXh0LnRleHRQb3MgfHwgdGV4dC5pbWFnZVBvcztcclxuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShvZmZzZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJPZmZzZXQgPSBbb2Zmc2V0LCAwXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcG9pbnRzT3JpZ2luID0gVXRpbC5nZXRNYXhMaW5lTGVuZ3RoKFt0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCAtIDJdLCB0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCAtIDFdXSk7XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXSwgYmVpemllclBvaW50cyA9W107XHJcbiAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gVXRpbC5nZXRBbmdsZShwb2ludHNPcmlnaW5bMF0sIHBvaW50c09yaWdpblsxXSk7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGgsIG5ld1BvaW50O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgICAgICBiZWl6aWVyUG9pbnRzID0gdGhpcy5nZXRQb2ludHNGcm9tQ3VydmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb2ludHNPcmlnaW4uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUNvcHkgPSBuZXcgUG9pbnQoaXRlbS54LCBwb2ludHNPcmlnaW5bMV0ueCA+PSBwb2ludHNPcmlnaW5bMF0ueCA/IGl0ZW0ueSAtIHRleHRIZWlnaHQgLyAyIDogaXRlbS55ICsgdGV4dEhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goaXRlbUNvcHkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc3dpdGNoKHBvcykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhcnQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT09IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGFyck9mZnNldFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UG9pbnQgPSBVdGlsLmdldEVuZFBvaW50KHBvaW50c1swXSwgbGVuZ3RoLCBhbmdsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW25ld1BvaW50LngsIG5ld1BvaW50LnkgKyBhcnJPZmZzZXRbMV1dO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW3RoaXMudHVybmluZ1BvaW50c1swXS54IC0gdGV4dFdpZHRoIC8gMiArIGFyck9mZnNldFswXSwgdGhpcy50dXJuaW5nUG9pbnRzWzBdLnkgKyBhcnJPZmZzZXRbMV0gLSB0ZXh0SGVpZ2h0IC8gMl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09PSBDb25uZWN0b3IuVFlQRV9TVFJBSUdIVCAmJiAhdGhpcy5vcHRpb25zLnRleHQudGV4dFJvdGF0ZWFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gVXRpbC5kaXN0YW5jZShwb2ludHNbMF0sIHBvaW50c1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BvaW50ID0gVXRpbC5nZXRFbmRQb2ludChwb2ludHNbMF0sIGxlbmd0aCwgYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFtuZXdQb2ludC54ICAtIHRleHRXaWR0aCArIGFyck9mZnNldFswXSwgbmV3UG9pbnQueSArIGFyck9mZnNldFsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gVXRpbC5kaXN0YW5jZShwb2ludHNbMF0sIHBvaW50c1sxXSkgLSB0ZXh0V2lkdGggKyBhcnJPZmZzZXRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BvaW50ID0gVXRpbC5nZXRFbmRQb2ludChwb2ludHNbMF0sIGxlbmd0aCwgYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFtuZXdQb2ludC54LCBuZXdQb2ludC55ICsgYXJyT2Zmc2V0WzFdXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaWRQb2ludCA9IHRoaXMubWlkZGxlKHRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlmTGluZU5vZGVSb3RhdGVhYmxlKHRleHQuaW1hZ2UgPyAnaW1hZ2UnIDogJ3RleHQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGUgPSB0aGlzLmdldFRleHRSb3RhdGlvbih0ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25CZWZvcmUgPSBbbWlkUG9pbnRbMF0gLSB0ZXh0V2lkdGggLyAyLCBtaWRQb2ludFsxXSAtIHRleHRIZWlnaHQgLyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFV0aWwuY2FsY3VsYXRlUG9pbnRzKHBvc2l0aW9uQmVmb3JlLCB7eDogbWlkUG9pbnRbMF0sIHk6IG1pZFBvaW50WzFdfSwgcm90YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDmm7Lnur/nmoTmloflrZdwb3NpdGlvbuWNleeLrOiuoeeul1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlaXppZXJQb2ludHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIgPSBhcnIuY29uY2F0KGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5yb3VuZChhcnIubGVuZ3RoIC8gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW2FycltpbmRleF0ueCAtIHRleHRXaWR0aCAvIDIsIGFycltpbmRleF0ueSAtdGV4dEhlaWdodCAvIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW21pZFBvaW50WzBdICsgYXJyT2Zmc2V0WzBdLCBtaWRQb2ludFsxXSArIGFyck9mZnNldFsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgIT09IENvbm5lY3Rvci5UWVBFX0NIQUlOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFt0ZXh0UG9zdGlvblswXSAtIHRleHRXaWR0aCAvIDIsIHRleHRQb3N0aW9uWzFdIC0gdGV4dEhlaWdodCAvIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5taWRkbGUodGV4dCk7XHJcbiAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW3Bvc2l0aW9uWzBdIC0gdGV4dFdpZHRoIC8gMiwgcG9zaXRpb25bMV1dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHRQb3N0aW9uO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPlue6v+auteeahOaXi+i9rOinkuW6plxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSB0ZXh0UG9zdGlvbiB7eCx5fVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICDop5LluqblgLxcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5nZXRUZXh0Um90YXRpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgLy/orqHnrpflh7rmnoHlnZDmoIfnmoTop5LluqZcclxuICAgICAgICB2YXIgcG9pbnRzID0gVXRpbC5nZXRNYXhMaW5lTGVuZ3RoKHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgdmFyIG1pZFBvaW50ID0gdGhpcy5taWRkbGUob3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gLU1hdGguYXRhbjIocG9pbnRzWzFdLnkgLSBtaWRQb2ludFsxXSwgcG9pbnRzWzFdLnggLSBtaWRQb2ludFswXSk7IC8vLE1hdGguUEkvMlxyXG4gICAgICAgIHJldHVybiBhbmdsZTtcclxuICAgIH07XHJcblxyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVIb3ZlclN0eWxlID0gZnVuY3Rpb24oZWwpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhvdmVyU3R5bGUgJiYgdGhpcy5vcHRpb25zLmlzRWRpdCkge1xyXG4gICAgICAgICAgICBncmFwaGljLnNldEVsZW1lbnRIb3ZlclN0bChlbCwgdGhpcy5vcHRpb25zLmhvdmVyU3R5bGUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICAgICAgaWYgKHN5bWJvbFRvKSB7IGdyYXBoaWMuc2V0RWxlbWVudEhvdmVyU3RsKHN5bWJvbFRvLCB0aGlzLm9wdGlvbnMuYXJyb3dIb3ZlclN0eWxlKTsgfVxyXG5cclxuICAgICAgICAgICAgZWwub24oJ21vdXNlb3ZlcicsIHpyVXRpbC5iaW5kKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpYy5kb0VudGVySG92ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbFRvKSB7IGdyYXBoaWMuZG9FbnRlckhvdmVyKHN5bWJvbFRvKTsgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZS5lYWNoQ2hpbGQoZnVuY3Rpb24obGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuZG9FbnRlckhvdmVyKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIHpyVXRpbC5iaW5kKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydFBvaW50ID0gdGhpcy50dXJuaW5nUG9pbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZFBvaW50ID0gdGhpcy50dXJuaW5nUG9pbnRzW3RoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydERpZmYgPSBNYXRoLmFicyhlLmV2ZW50Lm9mZnNldFggLSBzdGFydFBvaW50LngpICsgTWF0aC5hYnMoZS5ldmVudC5vZmZzZXRZIC0gc3RhcnRQb2ludC55KTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmREaWZmID0gTWF0aC5hYnMoZS5ldmVudC5vZmZzZXRYIC0gZW5kUG9pbnQueCkgKyBNYXRoLmFicyhlLmV2ZW50Lm9mZnNldFkgLSBlbmRQb2ludC55KTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydERpZmYgPD0gMTUgfHwgZW5kRGlmZiA8PSAxNSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLmN1cnNvciA9ICdtb3ZlJztcclxuICAgICAgICAgICAgICAgICAgICBlbC5kcmFnZ2FibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5jdXJzb3IgPSAncG9pbnRlcic7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgenJVdGlsLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljLmRvTGVhdmVIb3ZlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sVG8pIHsgZ3JhcGhpYy5kb0xlYXZlSG92ZXIoc3ltYm9sVG8pOyB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaGljLmRvTGVhdmVIb3ZlcihsaW5lKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCB0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu6Tm9kZeeahOi/nuaOpeeCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVBbGxjb25uZWN0aW9uUG9pbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLCB0aGlzLnR1cm5pbmdQb2ludHNbMF0uY2xvbmUoKSwgQ29ubmVjdGlvblBvaW50LlRZUEVfQ09OTkVDVE9SKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLCB0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCAtIDFdLmNsb25lKCksIENvbm5lY3Rpb25Qb2ludC5UWVBFX0NPTk5FQ1RPUik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e5o6l54K5XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzaGFwZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHBvaW50IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gdHlwZSAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY29ubmVjdGlvblBvaW50Q3JlYXRlID0gZnVuY3Rpb24oc2hhcGUsIHBvaW50LCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIGNvblBvaW50ID0gbmV3IENvbm5lY3Rpb25Qb2ludCh0aGlzLCBwb2ludCwgdHlwZSwgdGhpcy5vcHRpb25zKTtcclxuICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwLmFkZChjb25Qb2ludC5zaGFwZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5riF56m65o6n5Yi254K5XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jbGVhckhhbmRsZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGFuZGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aGlzLmhhbmRsZXNbaV0uaGFuZGxlU2hhcGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhhbmRsZXMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5jb25Qb2ludHNHcm91cCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aBouWkjeWOn+adpeeahOminOiJslxyXG4gICAgICAgIHRoaXMucmVtb3ZlU2VsZWN0ZWRTdHlsZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOabtOaWsOaOp+WItueCuVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUucmVmcmVzaEhhbmRsZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy50dXJuaW5nUG9pbnRzO1xyXG4gICAgICAgIHZhciBiZWl6aWVyUG9pbnRzID0gW107XHJcbiAgICAgICAgdmFyIHgsIHksIHR5cGU7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpIHtcclxuICAgICAgICAgICAgICAgIC8vIOiOt+WPluabsue6v+eahOi3r+W+hOeCuembhuWQiFxyXG4gICAgICAgICAgICAgICAgYmVpemllclBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzRnJvbUN1cnZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuaGFuZGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFzc29jaWF0ZWRQb2ludCA9IHRoaXMuaGFuZGxlc1tpXS5hc3NvY2lhdGVkUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gdGhpcy5oYW5kbGVzW2ldLnR5cGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwb2ludHMuZmluZEluZGV4KGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS54ID09IGFzc29jaWF0ZWRQb2ludC54ICYmIGl0ZW0ueSA9PSBhc3NvY2lhdGVkUG9pbnQueTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09ICdoJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gcG9pbnRzW2luZGV4IC0gMV0ueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IChwb2ludHNbaW5kZXggLSAxXS55ICsgcG9pbnRzW2luZGV4XS55KSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICd2Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gKHBvaW50c1tpbmRleCAtIDFdLnggKyBwb2ludHNbaW5kZXhdLngpIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHBvaW50c1tpbmRleCAtIDFdLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUgJiYgYmVpemllclBvaW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZWl6aWVyUG9pbnQgPSB6clV0aWwuZmluZChiZWl6aWVyUG9pbnRzW2luZGV4IC0gMl0sIGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdoJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRWYWx1ZSA9IE1hdGguYWJzKHBvaW50LnkgLSB5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3YnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZFZhbHVlID0gTWF0aC5hYnMocG9pbnQueCAtIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRWYWx1ZSA8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmVpemllclBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYmVpemllclBvaW50Lng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYmVpemllclBvaW50Lnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVzW2ldLnVwZGF0ZSh4LCB5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uuaLhue6vyDnur/mlq3nmoTmjqfliLbngrlcclxuICAgICAqIOabsue6v+aOp+WItueCueS9jee9ruiuoeeul+eyvuehrlxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuc2hhcGVTZXRIYW5kbGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy50dXJuaW5nUG9pbnRzO1xyXG4gICAgICAgIC8vIOiOt+WPluabsue6v+eahOi3r+W+hOeCuembhuWQiFxyXG4gICAgICAgIHZhciBiZWl6aWVyUG9pbnRzID0gdGhpcy5nZXRQb2ludHNGcm9tQ3VydmUoKTtcclxuICAgICAgICB2YXIgdHlwZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGggLSAyOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGg7XHJcbiAgICAgICAgICAgIHZhciB4LCB5O1xyXG4gICAgICAgICAgICAvL+aYr+WQpuWcqOS4gOadoee6v+S4ilxyXG4gICAgICAgICAgICB2YXIgaXNDb2xsaW5lYWl0eUZpcnN0ID0gVXRpbC5jb2xsaW5lYXJpdHkocG9pbnRzW2kgLSAxXSwgcG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKTtcclxuICAgICAgICAgICAgdmFyIGlzQ29sbGluZWFpdHlTZWNvbmQgPSBVdGlsLmNvbGxpbmVhcml0eShwb2ludHNbaV0sIHBvaW50c1tpICsgMV0sIHBvaW50c1tpICsgMl0pO1xyXG4gICAgICAgICAgICBpZiAoKCFpc0NvbGxpbmVhaXR5Rmlyc3QgJiYgKCFpc0NvbGxpbmVhaXR5U2Vjb25kIHx8IHBvaW50c1tpICsgMV0uZXF1YWxzKHBvaW50c1tpICsgMl0pKSkgfHwgKCghaXNDb2xsaW5lYWl0eUZpcnN0IHx8IHBvaW50c1tpIC0gMV0uZXF1YWxzKHBvaW50c1tpXSkpICYmICFpc0NvbGxpbmVhaXR5U2Vjb25kKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwb2ludHNbaV0ueCA9PT0gcG9pbnRzW2kgKyAxXS54KSB7IC8vc2FtZSB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgICAgIHggPSBwb2ludHNbaV0ueDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gKHBvaW50c1tpXS55ICsgcG9pbnRzW2kgKyAxXS55KSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdoJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRzW2ldLnkgPT09IHBvaW50c1tpICsgMV0ueSkgeyAvLyBzYW1lIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgICAgICB4ID0gKHBvaW50c1tpXS54ICsgcG9pbnRzW2kgKyAxXS54KSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHBvaW50c1tpXS55O1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAndic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoeCAmJiB5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSAmJiBiZWl6aWVyUG9pbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJlaXppZXJQb2ludCA9IHpyVXRpbC5maW5kKGJlaXppZXJQb2ludHNbaSAtIDFdLCBmdW5jdGlvbihwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnaCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkVmFsdWUgPSBNYXRoLmFicyhwb2ludC55IC0geSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRWYWx1ZSA9IE1hdGguYWJzKHBvaW50LnggLSB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkVmFsdWUgPCAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlaXppZXJQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGJlaXppZXJQb2ludC54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGJlaXppZXJQb2ludC55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGggPSBuZXcgSGFuZGxlKHR5cGUsIHgsIHksIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGguYXNzb2NpYXRlZFBvaW50ID0gcG9pbnRzW2kgKyAxXTsgLy8g6L+e57q/5o6n5Yi254K55LiOdGhpcy50dXJuaW5nUG9pbnRz5YWz6IGUXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKGguaGFuZGxlU2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcy5wdXNoKGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu6566t5aS0XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5hbWUgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBvcHRpb25zIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY3JlYXRlU3ltYm9sID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBzeW1ib2xUeXBlID0gb3B0aW9ucy5zeW1ib2wudHlwZTtcclxuICAgICAgICB2YXIgc3ltYm9sU2l6ZSA9IG9wdGlvbnMuc3ltYm9sLnNpemU7XHJcbiAgICAgICAgaWYgKHN5bWJvbFR5cGUgPT09ICdub25lJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHN5bWJvbFNpemUpKSB7XHJcbiAgICAgICAgICAgIHN5bWJvbFNpemUgPSBbc3ltYm9sU2l6ZSwgc3ltYm9sU2l6ZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc3ltYm9sWkluZGV4ID0gb3B0aW9ucy56O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zeW1ib2wueikgeyBzeW1ib2xaSW5kZXggPSBvcHRpb25zLnN5bWJvbC56IH1cclxuXHJcbiAgICAgICAgdmFyIHN5bWJvbFBhdGggPSBzeW1ib2xVdGlsLmNyZWF0ZVN5bWJvbChcclxuICAgICAgICAgICAgc3ltYm9sVHlwZSwgLXN5bWJvbFNpemVbMF0gLyAyLCAtc3ltYm9sU2l6ZVsxXSAvIDIsXHJcbiAgICAgICAgICAgIHN5bWJvbFNpemVbMF0sIHN5bWJvbFNpemVbMV0sIHN5bWJvbFpJbmRleCwgb3B0aW9ucy5zeW1ib2wuY29sb3JcclxuICAgICAgICApO1xyXG4gICAgICAgIHN5bWJvbFBhdGgubmFtZSA9IG5hbWU7XHJcblxyXG4gICAgICAgIHJldHVybiBzeW1ib2xQYXRoO1xyXG4gICAgfTtcclxuXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihuYW1lLCBjb250ZW50KSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog57uY5Yi257q/5q615LiK55qE5paH5pysXHJcbiAgICAgKiDnlKjnn6nlvaLku6Pmm7/mlofmnKxcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gY29udGVudCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5hbWUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSB4ICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0geSAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNvbG9yICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5kcmF3VGV4dCA9IGZ1bmN0aW9uKG5hbWUsIGNvbnRlbnQsIHgsIHksIHR5cGUpIHtcclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgdHlwZSA9ICd0ZXh0JztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9wdCA9IHpyVXRpbC5pc1N0cmluZyhjb250ZW50KSA/ICh0eXBlID09PSAndGV4dCcgPyB7dGV4dDpjb250ZW50LCB4OngsIHk6eX0gOiB7aW1hZ2U6Y29udGVudCwgeDp4LCB5Onl9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB6clV0aWwuZGVmYXVsdHMoe3g6eCwgeTp5fSwgY29udGVudCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0U3R5bGUgPSB6clV0aWwuZGVmYXVsdHMoenJVdGlsLmNsb25lKHRoaXMub3B0aW9ucy50ZXh0KSwgb3B0LCB0cnVlKTtcclxuICAgICAgICB2YXIgbm9kZTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0Qm91bmRpbmdSZWN0ID0gdGhpcy5nZXRUZXh0Qm91bmRpbmdSZWN0KHRleHRTdHlsZSk7XHJcbiAgICAgICAgICAgIHRleHRTdHlsZSA9IHpyVXRpbC5kZWZhdWx0cyh0ZXh0U3R5bGUsIHsgZmlsbDogJyNGOUY5RjknLCB0cmFuc2Zvcm1UZXh0OiB0cnVlIH0sIHRydWUpO1xyXG4gICAgICAgICAgICBub2RlID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgICAgICBzaGFwZTogeyB3aWR0aDogdGV4dEJvdW5kaW5nUmVjdC53aWR0aCwgaGVpZ2h0OiB0ZXh0Qm91bmRpbmdSZWN0LmhlaWdodCB9LFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHRleHRTdHlsZSxcclxuICAgICAgICAgICAgICAgIHpsZXZlbDogMjAsXHJcbiAgICAgICAgICAgICAgICBuYW1lIDogbmFtZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0xpbmtJbWFnZScsXHJcbiAgICAgICAgICAgICAgICBzdHlsZTogdGV4dFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgemxldmVsOiAyMCxcclxuICAgICAgICAgICAgICAgIG5hbWUgOiBuYW1lXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0ZXh0OiBub2RlLFxyXG4gICAgICAgICAgICByZWN0OiBub2RlLmdldEJvdW5kaW5nUmVjdCgpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAgLyoqXHJcbiAgICAgKiDojrflj5bnur/mrrXmlofmnKzljIXlm7Tnm5JcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gY29udGVudCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmdldFRleHRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgICAgdmFyIHRleHRSZWN0ID0gZ3JhcGhpYy50ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dC50ZXh0LCB0ZXh0LnRleHRGb250KTtcclxuICAgICAgICB2YXIgdGV4dFdpZHRoID0gZ3JhcGhpYy50ZXh0Q29udGFpbi5nZXRXaWR0aCh0ZXh0LnRleHQsIHRleHQudGV4dEZvbnQpO1xyXG4gICAgICAgIHZhciB0ZXh0SGVpZ2h0ID0gdGV4dFJlY3QuaGVpZ2h0IHx8IDEyO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0ZXh0V2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGV4dEhlaWdodFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bnur/mrrXnmoTkuK3pl7TlgLxcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gdGV4dFxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLm1pZGRsZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUIHx8IHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DSEFJTikge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gVXRpbC5nZXRNYXhMaW5lTGVuZ3RoKHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgICAgIC8v5aaC5p6c5piv5rGC57q/5q615LiK55qE5paH5a2X55qE5Lit6Ze05YC8XHJcbiAgICAgICAgICAgIC8vIGlmKHRleHQpIHtcclxuICAgICAgICAgICAgLy8gICAgIC8v5Y+W5Ye65a2X55qE6ZW/5bqm77yM6K6h566X6KeS5bqm77yMXHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgdGV4dFdpZHRoID0gZ3JhcGhpYy50ZXh0Q29udGFpbi5nZXRXaWR0aCh0ZXh0LnRleHQsIHRleHQudGV4dEZvbnQpO1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIGFuZ2xlID0gVXRpbC5nZXRBbmdsZShwb2ludHNbMF0scG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBsZW5ndGggPSAgVXRpbC5kaXN0YW5jZShwb2ludHNbMF0scG9pbnRzWzFdKS8yIC0gdGV4dFdpZHRoLzI7XHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgbmV3UG9pbnQgPSBVdGlsLmdldEVuZFBvaW50KHBvaW50c1swXSwgbGVuZ3RoLCBhbmdsZSk7XHJcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gW25ld1BvaW50LngsIG5ld1BvaW50LnldO1xyXG4gICAgICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIG1pZGRsZVggPSAocG9pbnRzWzBdLnggKyBwb2ludHNbMV0ueCkvMjtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBtaWRkbGVZID0gKHBvaW50c1swXS55ICsgcG9pbnRzWzFdLnkpIC8yO1xyXG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuIFttaWRkbGVYLCBtaWRkbGVZXTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICB2YXIgbWlkZGxlWCA9IChwb2ludHNbMF0ueCArIHBvaW50c1sxXS54KSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVZID0gKHBvaW50c1swXS55ICsgcG9pbnRzWzFdLnkpIC8gMjtcclxuICAgICAgICAgICAgcmV0dXJuIFttaWRkbGVYLCBtaWRkbGVZXTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9KQUdHRUQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vZmluZCB0b3RhbCBkaXN0YW5jZVxyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLmdldExlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgLy9maW5kIGJldHdlZW4gd2hhdCB0dXJuaW5nIHBvaW50cyB0aGUgaGFsZiBkaXN0YW5jZSBpc1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcclxuICAgICAgICAgICAgdmFyIGVsbGFwc2VkRGlzdGFuY2UgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gVXRpbC5nZXRMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzW2ldLCB0aGlzLnR1cm5pbmdQb2ludHNbaSArIDFdKTtcclxuICAgICAgICAgICAgICAgIGlmIChlbGxhcHNlZERpc3RhbmNlICsgc2VnbWVudCA8IGRpc3RhbmNlIC8gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsbGFwc2VkRGlzdGFuY2UgKz0gc2VnbWVudDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vd2UgaGF2ZSB0aGUgbWlkZGxlIGRpc3RhbmNlIHNvbWV3aGVyZSBiZXR3ZWVuIGkobmRleCkgYW5kIGkobmRleCkrMVxyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtaXNzaW5nRGlzdGFuY2UgPSBkaXN0YW5jZSAvIDIgLSBlbGxhcHNlZERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKFV0aWwucm91bmQodGhpcy50dXJuaW5nUG9pbnRzW2luZGV4XS54LCAzKSA9PSBVdGlsLnJvdW5kKHRoaXMudHVybmluZ1BvaW50c1tpbmRleCArIDFdLngsIDMpKSB7IC8vdmVydGljYWwgc2VnbWVudCAoc2FtZSB4KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4XS54LCBNYXRoLm1pbih0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLnksIHRoaXMudHVybmluZ1BvaW50c1tpbmRleCArIDFdLnkpICsgbWlzc2luZ0Rpc3RhbmNlXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbC5yb3VuZCh0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLnksIDMpID09IFV0aWwucm91bmQodGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueSwgMykpIHsgLy9ob3Jpem9udGFsIHNlZ21lbnQgKHNhbWUgeSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW01hdGgubWluKHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueCwgdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueCkgKyBtaXNzaW5nRGlzdGFuY2UsIHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb25uZWN0b3I6bWlkZGxlKCkgLSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4gXCIgKyB0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdICsgXCIgXCIgKyB0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXggKyAxXSArIFwiIG5yIG9mIHBvaW50cyBcIiArIHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gMC41O1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgd2Fsa2VkID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2Fsa2VkICsgVXRpbC5kaXN0YW5jZSh0aGlzLnR1cm5pbmdQb2ludHNbal0sIHRoaXMudHVybmluZ1BvaW50c1tqICsgMV0pID4gbCAqIHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB3YWxrZWQgKz0gVXRpbC5kaXN0YW5jZSh0aGlzLnR1cm5pbmdQb2ludHNbal0sIHRoaXMudHVybmluZ1BvaW50c1tqICsgMV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdCA9IGwgKiB0IC0gd2Fsa2VkO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFNlZ21lbnRMZW5ndGggPSBVdGlsLmRpc3RhbmNlKHRoaXMudHVybmluZ1BvaW50c1tqXSwgdGhpcy50dXJuaW5nUG9pbnRzW2ogKyAxXSk7XHJcblxyXG4gICAgICAgICAgICAvL2ZpbmQgdGhlIHBvc2l0aW9uL3JhdGlvbiBvZiB0aGUgbWlkZGxlIG9mIFBvbHlsaW5lIG9uIGN1cnJlbnQgc2VnbWVudFxyXG4gICAgICAgICAgICB2YXIgc2VnbWVudFBlcmNlbnQgPSByZXN0IC8gY3VycmVudFNlZ21lbnRMZW5ndGg7XHJcblxyXG4gICAgICAgICAgICB2YXIgWHAgPSBzZWdtZW50UGVyY2VudCAqICh0aGlzLnR1cm5pbmdQb2ludHNbaiArIDFdLnggLSB0aGlzLnR1cm5pbmdQb2ludHNbal0ueCkgKyB0aGlzLnR1cm5pbmdQb2ludHNbal0ueDtcclxuICAgICAgICAgICAgdmFyIFlwID0gc2VnbWVudFBlcmNlbnQgKiAodGhpcy50dXJuaW5nUG9pbnRzW2ogKyAxXS55IC0gdGhpcy50dXJuaW5nUG9pbnRzW2pdLnkpICsgdGhpcy50dXJuaW5nUG9pbnRzW2pdLnk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW1hwLCBZcF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZmluZCB0b3RhbCBkaXN0YW5jZVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9maW5kIHRvdGFsIGRpc3RhbmNlXHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gVXRpbC5nZXRMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzW2ldLCB0aGlzLnR1cm5pbmdQb2ludHNbaSArIDFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOi9rEpTT07lr7nosaEgYnBtbuS9v+eUqFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwicmVzb3VyY2VJZFwiLCB0aGlzLnJlc291cmNlSWQpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwicHJvcGVydGllcy50eXBlXCIsIDE0KTtcclxuXHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiwgdGhpcy5wb3NpdGlvblswXSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIiwgdGhpcy5wb3NpdGlvblsxXSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC54XCIsIHBhcnNlSW50KHRoaXMucG9zaXRpb25bMF0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoKSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC55XCIsIHBhcnNlSW50KHRoaXMucG9zaXRpb25bMV0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCkpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwic3R5bGUuc1Bvc1wiLCB0aGlzLm9wdGlvbnMucG9zaXRpb24uc3RhcnRQb3MpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwic3R5bGUuZVBvc1wiLCB0aGlzLm9wdGlvbnMucG9zaXRpb24uZW5kUG9zKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0eWxlLmxpbmVEYXNoXCIsIHRoaXMub3B0aW9ucy5zdHlsZS5saW5lRGFzaCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJzdHlsZS5zdHJva2VcIiwgdGhpcy5vcHRpb25zLnN0eWxlLnN0cm9rZSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJzeW1ib2wudHlwZVwiLCB0aGlzLm9wdGlvbnMuc3ltYm9sLnR5cGUpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiZG9ja2Vyc1wiLCB0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm9wdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZWZyZXNoTW9kZWwgIGZsb3flvZPluo/liJfljJbnmoTml7blgJnosIPnlKgg5pu05paw57q/5q6155qE5L2N572uIOWPiue6v+S4iueahGljb25zXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZWZyZXNoTW9kZWwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnNcIiwgenJVdGlsLmNsb25lKHRoaXMub3B0aW9ucykpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5kb2NrZXJzXCIsIHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgdmFyIGljb25zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmljb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpY29uTm9kZSA9IHRoaXMuaWNvbnNbaV07XHJcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBbaWNvbk5vZGUua2V5LCB7XHJcbiAgICAgICAgICAgICAgICBpY29uOiBpY29uTm9kZS5zdHlsZS5pbWFnZSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBpY29uTm9kZS5zdHlsZS53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaWNvbk5vZGUuc3R5bGUuaGVpZ2h0XHJcbiAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBpY29ucy5wdXNoKG9wdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiaWNvbnNcIiwgaWNvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiwg+aVtOabsue6v+eahOW9oueKtlxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IHBvaW50cyDngrnmlbDnu4RcclxuICAgICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUubW9kaWZ5Q3VydmUgPSBmdW5jdGlvbihwb2ludHMpIHtcclxuICAgICAgICB2YXIgc29sID0gdGhpcy5nZXRDdXJ2ZVBvaW50KHBvaW50cyk7XHJcblxyXG4gICAgICAgIC8vIDEuIOWmguaenOabsue6v+eahOaVsOmHjyDmr5TmlbDph4/nmoTkuK3mlbDph4/opoHlsJEg5YiZ5Yig6Zmk5aSa5L2Z55qE57q/5q61XHJcbiAgICAgICAgdmFyIHdpbGxEZWxDdXJ2ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBqID0gc29sLmxlbmd0aCwgY250Q3VydmUgPSB0aGlzLmdyb3VwQ3VydmUuY2hpbGRDb3VudCgpOyBqIDwgY250Q3VydmU7IGorKykge1xyXG4gICAgICAgICAgICB3aWxsRGVsQ3VydmVzLnB1c2godGhpcy5ncm91cEN1cnZlLmNoaWxkQXQoaikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB6clV0aWwuZWFjaCh3aWxsRGVsQ3VydmVzLCBmdW5jdGlvbihjdXJ2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUucmVtb3ZlKGN1cnZlKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAvLyAyLiDpgY3ljobmm7Lnur8gICDlpoLmnpzlrZjlnKjliJnnm7TmjqXorr7nva7lvaLnirbvvIzlkKbliJnliJvlu7pcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvbC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMuZ3JvdXBDdXJ2ZS5jaGlsZEF0KGkpO1xyXG4gICAgICAgICAgICBpZiAobGluZSkge1xyXG4gICAgICAgICAgICAgICAgbGluZS5hdHRyKCdzaGFwZScsIHNvbFtpXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VyZSA9IG5ldyBncmFwaGljLkJlemllckN1cnZlKHtcclxuICAgICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uOiB0aGlzLm9wdGlvbnMucG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHRoaXMub3B0aW9ucy5zdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZTogc29sW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgIHo6IHRoaXMub3B0aW9ucy56XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZS5hZGQoY3VyZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUhvdmVyU3R5bGUoY3VyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2Mg6I635Y+W54K577yM6L+Z6YeM5Y+v5Lul6K6+572u54K555qE5Liq5pWwXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtIOeCueS4quaVsFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcDEg54K55Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwMiDngrnlnZDmoIdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHAzIOeCueWdkOagh1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcDQg54K55Z2Q5qCHXHJcbiAgICAgKiDlpoLmnpzlj4LmlbDmmK8gbnVtLCBwMSwgcDIg5Li65LiA6Zi26LSd5aGe5bCUXHJcbiAgICAgKiDlpoLmnpzlj4LmlbDmmK8gbnVtLCBwMSwgYzEsIHAyIOS4uuS6jOmYtui0neWhnuWwlFxyXG4gICAgICog5aaC5p6c5Y+C5pWw5pivIG51bSwgcDEsIGMxLCBjMiwgcDIg5Li65LiJ6Zi26LSd5aGe5bCUXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0QmV6aWVyUG9pbnRzID0gZnVuY3Rpb24ocG9pbnQsIG51bSkge1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICB2YXIgZnVuYyA9IG51bGw7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9pbnQuc3RhcnQ7XHJcbiAgICAgICAgdmFyIGNwMSA9IHBvaW50LmNwMTtcclxuICAgICAgICB2YXIgY3AyID0gcG9pbnQuY3AyO1xyXG4gICAgICAgIHZhciBlbmQgPSBwb2ludC5lbmQ7XHJcbiAgICAgICAgaWYgKCFudW0gfHwgbnVtIDw9IDUwKSB7XHJcbiAgICAgICAgICAgIG51bSA9IDUwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWNwMSAmJiAhY3AyKSB7XHJcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLm9uZUJlemllcjtcclxuICAgICAgICB9IGVsc2UgaWYgKGNwMSAmJiAhY3AyKSB7XHJcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnR3b0JlemllcjtcclxuICAgICAgICB9IGVsc2UgaWYgKGNwMSAmJiBjcDIpIHtcclxuICAgICAgICAgICAgZnVuYyA9IHRoaXMudGhyZWVCZXppZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goZnVuYyhpIC8gbnVtLCBzdGFydCwgY3AxLCBjcDIsIGVuZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb2ludHMucHVzaChlbmQpO1xyXG4gICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2Mg5LiA6Zi26LSd5aGe5bCUXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCDlvZPliY3nmb7liIbmr5RcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IOi1t+eCueWdkOagh1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZW5kIOe7iOeCueWdkOagh1xyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLm9uZUJlemllciA9IGZ1bmN0aW9uKHQsIHN0YXJ0LCBjcDEsIGNwMiwgZW5kKSB7XHJcbiAgICAgICAgdmFyIHgxID0gc3RhcnQueDE7XHJcbiAgICAgICAgdmFyIHkxID0gc3RhcnQueTE7XHJcbiAgICAgICAgdmFyIHgyID0gZW5kLngyO1xyXG4gICAgICAgIHZhciB5MiA9IGVuZC55MjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB4MSArICh4MiAtIHgxKSAqIHQsXHJcbiAgICAgICAgICAgIHk6IHkxICsgKHkyIC0geTEpICogdFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzYyDkuozpmLbotJ3loZ7lsJRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IOW9k+WJjeeZvuWIhuavlFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQg6LW354K55Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbmQg57uI54K55Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjcDEg5o6n5Yi254K5XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUudHdvQmV6aWVyID0gZnVuY3Rpb24odCwgc3RhcnQsIGNwMSwgY3AyLCBlbmQpIHtcclxuICAgICAgICB2YXIgeDEgPSBzdGFydC54MTtcclxuICAgICAgICB2YXIgeTEgPSBzdGFydC55MTtcclxuICAgICAgICB2YXIgeDIgPSBlbmQueDI7XHJcbiAgICAgICAgdmFyIHkyID0gZW5kLnkyO1xyXG4gICAgICAgIHZhciBjcHgxID0gY3AxLmNweDE7XHJcbiAgICAgICAgdmFyIGNweTEgPSBjcDEuY3B5MTtcclxuICAgICAgICB2YXIgeCA9ICgxIC0gdCkgKiAoMSAtIHQpICogeDEgKyAyICogdCAqICgxIC0gdCkgKiBjcHgxICsgdCAqIHQgKiB4MjtcclxuICAgICAgICB2YXIgeSA9ICgxIC0gdCkgKiAoMSAtIHQpICogeTEgKyAyICogdCAqICgxIC0gdCkgKiBjcHkxICsgdCAqIHQgKiB5MjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICB5OiB5XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjIOS4iemYtui0neWhnuWwlFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQg5b2T5YmN55m+5YiG5q+UXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCDotbfngrnlnZDmoIdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVuZCDnu4jngrnlnZDmoIdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNwMSDmjqfliLbngrlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNwMiDmjqfliLbngrlcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS50aHJlZUJlemllciA9IGZ1bmN0aW9uKHQsIHN0YXJ0LCBjcDEsIGNwMiwgZW5kKSB7XHJcbiAgICAgICAgdmFyIHgxID0gc3RhcnQueDE7XHJcbiAgICAgICAgdmFyIHkxID0gc3RhcnQueTE7XHJcbiAgICAgICAgdmFyIHgyID0gZW5kLngyO1xyXG4gICAgICAgIHZhciB5MiA9IGVuZC55MjtcclxuICAgICAgICB2YXIgY3B4MSA9IGNwMS5jcHgxO1xyXG4gICAgICAgIHZhciBjcHkxID0gY3AxLmNweTE7XHJcbiAgICAgICAgdmFyIGNweDIgPSBjcDIuY3B4MjtcclxuICAgICAgICB2YXIgY3B5MiA9IGNwMi5jcHkyO1xyXG4gICAgICAgIHZhciB4ID1cclxuICAgICAgICAgICAgeDEgKiAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCkgK1xyXG4gICAgICAgICAgICAzICogY3B4MSAqIHQgKiAoMSAtIHQpICogKDEgLSB0KSArXHJcbiAgICAgICAgICAgIDMgKiBjcHgyICogdCAqIHQgKiAoMSAtIHQpICtcclxuICAgICAgICAgICAgeDIgKiB0ICogdCAqIHQ7XHJcbiAgICAgICAgdmFyIHkgPVxyXG4gICAgICAgICAgICB5MSAqICgxIC0gdCkgKiAoMSAtIHQpICogKDEgLSB0KSArXHJcbiAgICAgICAgICAgIDMgKiBjcHkxICogdCAqICgxIC0gdCkgKiAoMSAtIHQpICtcclxuICAgICAgICAgICAgMyAqIGNweTIgKiB0ICogdCAqICgxIC0gdCkgK1xyXG4gICAgICAgICAgICB5MiAqIHQgKiB0ICogdDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICB5OiB5XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluabsue6v+S4iueahOeCuei9qOi/uVxyXG4gICAgICogQHJldHVybiB7YXJyYXl9XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0UG9pbnRzRnJvbUN1cnZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwZXJjZW50ID0gMDtcclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy50dXJuaW5nUG9pbnRzO1xyXG4gICAgICAgIHZhciBtYXhNaW5Qb2ludHMgPSBVdGlsLmdldE1heExpbmVMZW5ndGgocG9pbnRzKTtcclxuICAgICAgICB2YXIgYmVpemllclBvaW50cyA9IFtdO1xyXG4gICAgICAgIHBlcmNlbnQgPSBwYXJzZUludChtYXhNaW5Qb2ludHNbMF0ueCAtIG1heE1pblBvaW50c1sxXS54KTtcclxuICAgICAgICBpZiAoKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkgJiYgKHBvaW50cy5sZW5ndGggPiAyKSkge1xyXG4gICAgICAgICAgICB2YXIgc29scyA9IHRoaXMudHJhbnNmb3JtQ3VydmVQb2ludCh0aGlzLmdldEN1cnZlUG9pbnQocG9pbnRzKSk7XHJcbiAgICAgICAgICAgIGlmIChzb2xzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHNvbHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVpemllclBvaW50cy5wdXNoKHRoYXQuZ2V0QmV6aWVyUG9pbnRzKGl0ZW0sIHBlcmNlbnQpKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJlaXppZXJQb2ludHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7kvKDlhaXnmoTngrnmlbDnu4TovazmjaLmiJDpnIDopoHnmoTnsbvlnotcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBzb2wg54K55pWw57uEXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUudHJhbnNmb3JtQ3VydmVQb2ludCA9IGZ1bmN0aW9uKHNvbCkge1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICBzb2wuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRQYXJhbSA9IHt9O1xyXG4gICAgICAgICAgICBpZiAocG9pbnQueDEgJiYgcG9pbnQueTEpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50UGFyYW0uc3RhcnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDE6IHBvaW50LngxLFxyXG4gICAgICAgICAgICAgICAgICAgIHkxOiBwb2ludC55MVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2ludC5jcHgxICYmIHBvaW50LmNweTEpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50UGFyYW0uY3AxID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNweDE6IHBvaW50LmNweDEsXHJcbiAgICAgICAgICAgICAgICAgICAgY3B5MTogcG9pbnQuY3B5MVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2ludC5jcHgyICYmIHBvaW50LmNweTIpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50UGFyYW0uY3AyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNweDI6IHBvaW50LmNweDIsXHJcbiAgICAgICAgICAgICAgICAgICAgY3B5MjogcG9pbnQuY3B5MlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2ludC54MiAmJiBwb2ludC55Mikge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRQYXJhbS5lbmQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDI6IHBvaW50LngyLFxyXG4gICAgICAgICAgICAgICAgICAgIHkyOiBwb2ludC55MlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50UGFyYW0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7kvKDlhaXnmoTngrnmlbDnu4TorqHnrpfmm7Lnur/nmoTngrlcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBQIOeCueaVsOe7hFxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAg5puy57q/55qE54K55pWw57uEXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0Q3VydmVQb2ludCA9IGZ1bmN0aW9uKFApIHtcclxuICAgICAgICB2YXIgbiA9IFAubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzb2wgPSBbXTtcclxuICAgICAgICBpZiAobiA9PT0gMykge1xyXG4gICAgICAgICAgICBzb2wucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB4MTogUFswXS54LFxyXG4gICAgICAgICAgICAgICAgeTE6IFBbMF0ueSxcclxuICAgICAgICAgICAgICAgIGNweDE6IFBbMV0ueCxcclxuICAgICAgICAgICAgICAgIGNweTE6IFBbMV0ueSxcclxuICAgICAgICAgICAgICAgIHgyOiBQWzJdLngsXHJcbiAgICAgICAgICAgICAgICB5MjogUFsyXS55XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc29sO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobiA9PT0gNCkge1xyXG4gICAgICAgICAgICBzb2wucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB4MTogUFswXS54LFxyXG4gICAgICAgICAgICAgICAgeTE6IFBbMF0ueSxcclxuICAgICAgICAgICAgICAgIGNweDE6IFBbMV0ueCxcclxuICAgICAgICAgICAgICAgIGNweTE6IFBbMV0ueSxcclxuICAgICAgICAgICAgICAgIGNweDI6IFBbMl0ueCxcclxuICAgICAgICAgICAgICAgIGNweTI6IFBbMl0ueSxcclxuICAgICAgICAgICAgICAgIHgyOiBQWzNdLngsXHJcbiAgICAgICAgICAgICAgICB5MjogUFszXS55XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc29sO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKkNvbXB1dGVzIHRoZSBzdW0gYmV0d2VlbiB0d28gcG9pbnRcclxuICAgICAgICAgKkBwYXJhbSBwMSAtIHtQb2ludH1cclxuICAgICAgICAgKkBwYXJhbSBwMiAtIHtQb2ludH1cclxuICAgICAgICAgKkByZXR1cm4ge1BvaW50fSB0aGUgc3VtIG9mIGluaXRpYWwgcG9pbnRzXHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHN1bShwMSwgcDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwMS54ICsgcDIueCwgcDEueSArIHAyLnkpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKkNvbXB1dGVzIHRoZSBkaXZpc2lvbiBvZiBhIHtQb2ludH0gYnkgYSBudW1iZXJcclxuICAgICAgICAgKkBwYXJhbSBwIC0ge1BvaW50fVxyXG4gICAgICAgICAqQHBhcmFtIG5yIC0ge051bWJlcn1cclxuICAgICAgICAgKkByZXR1cm4ge1BvaW50fVxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBmdW5jdGlvbiBkaXZpZGUocCwgbnIpIHtcclxuICAgICAgICAgICAgaWYgKG5yID09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiRGl2aXNpb24gYnkgemVybyBub3QgYWxsb3dlZCAoeWV0IDopIFwiICsgdGhpcy5jYWxsZWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwLnggLyBuciwgcC55IC8gbnIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqQ29tcHV0ZXMgdGhlIG11bHRpcGxpY2F0aW9uIG9mIGEge1BvaW50fSBieSBhIG51bWJlclxyXG4gICAgICAgICAqQHBhcmFtIHAgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcGFyYW0gbnIgLSB7TnVtYmVyfVxyXG4gICAgICAgICAqQHJldHVybiB7UG9pbnR9XHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGZ1bmN0aW9uIG11bHRpcGx5KHAsIG5yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocC54ICogbnIsIHAueSAqIG5yKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICpJIGRvIG5vdCBnZXQgd2h5IGZpcnN0IDQgbXVzdCBiZSAwIGFuZCBsYXN0IDMgb2Ygc2FtZSB2YWx1ZS4uLi4uXHJcbiAgICAgICAgICpidXQgb3RoZXJ3aXNlIHdlIHdpbGwgZ2V0IGRpdmlzaW9uIGJ5IHplcm9cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgayA9IFswLCAwLCAwXTtcclxuXHJcbiAgICAgICAgdmFyIGo7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8PSBuIC0gMzsgaisrKSB7XHJcbiAgICAgICAgICAgIGsucHVzaChqKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGsucHVzaChuIC0gMywgbiAtIDMpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG4gLSAzOyBpKyspIHtcclxuICAgICAgICAgICAgLy9xMSAtIGNvbXB1dGUgc3RhcnQgcG9pbnRcclxuICAgICAgICAgICAgdmFyIHExID0gZGl2aWRlKHN1bShtdWx0aXBseShQW2ldLCBrW2kgKyA0XSAtIGtbaSArIDJdKSwgbXVsdGlwbHkoUFtpICsgMV0sIGtbaSArIDJdIC0ga1tpICsgMV0pKSwga1tpICsgNF0gLSBrW2kgKyAxXSk7XHJcblxyXG4gICAgICAgICAgICAvL3EwIC0gY29tcHV0ZSAxc3QgY29udHJvbGwgcG9pbnRcclxuICAgICAgICAgICAgdmFyIHFfMDEgPSAoa1tpICsgM10gLSBrW2kgKyAyXSkgLyAoa1tpICsgM10gLSBrW2kgKyAxXSk7XHJcbiAgICAgICAgICAgIHZhciBxXzAyID0gZGl2aWRlKHN1bShtdWx0aXBseShQW2kgLSAxXSwga1tpICsgM10gLSBrW2kgKyAyXSksIG11bHRpcGx5KFBbaV0sIGtbaSArIDJdIC0ga1tpXSkpLCBrW2kgKyAzXSAtIGtbaV0pO1xyXG4gICAgICAgICAgICB2YXIgcV8wMyA9IG11bHRpcGx5KHExLCAoa1tpICsgMl0gLSBrW2kgKyAxXSkgLyAoa1tpICsgM10gLSBrW2kgKyAxXSkpO1xyXG4gICAgICAgICAgICB2YXIgcTAgPSBzdW0obXVsdGlwbHkocV8wMiwgcV8wMSksIHFfMDMpO1xyXG5cclxuICAgICAgICAgICAgLy9xMiAtIGNvbXB1dGUgMm5kIGNvbnRyb2xsIHBvaW50XHJcbiAgICAgICAgICAgIHZhciBxMiA9IGRpdmlkZShzdW0obXVsdGlwbHkoUFtpXSwga1tpICsgNF0gLSBrW2kgKyAzXSksIG11bHRpcGx5KFBbaSArIDFdLCBrW2kgKyAzXSAtIGtbaSArIDFdKSksIGtbaSArIDRdIC0ga1tpICsgMV0pO1xyXG5cclxuICAgICAgICAgICAgLy9xMyAtIGNvbXB1dGUgZW5kIHBvaW50XHJcbiAgICAgICAgICAgIHZhciBxXzMxID0gKGtbaSArIDNdIC0ga1tpICsgMl0pIC8gKGtbaSArIDRdIC0ga1tpICsgMl0pO1xyXG4gICAgICAgICAgICB2YXIgcV8zMiA9IGRpdmlkZShzdW0obXVsdGlwbHkoUFtpICsgMV0sIGtbaSArIDVdIC0ga1tpICsgM10pLCBtdWx0aXBseShQW2kgKyAyXSwga1tpICsgM10gLSBrW2kgKyAyXSkpLCBrW2kgKyA1XSAtIGtbaSArIDJdKTtcclxuICAgICAgICAgICAgdmFyIHFfMzMgPSBtdWx0aXBseShxMiwgKGtbaSArIDRdIC0ga1tpICsgM10pIC8gKGtbaSArIDRdIC0ga1tpICsgMl0pKTtcclxuICAgICAgICAgICAgdmFyIHEzID0gc3VtKG11bHRpcGx5KHFfMzIsIHFfMzEpLCBxXzMzKTtcclxuXHJcbiAgICAgICAgICAgIC8vc3RvcmUgc29sdXRpb25cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgc29sLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgeDE6IHEwLngsXHJcbiAgICAgICAgICAgICAgICB5MTogcTAueSxcclxuICAgICAgICAgICAgICAgIGNweDE6IHExLngsXHJcbiAgICAgICAgICAgICAgICBjcHkxOiBxMS55LFxyXG4gICAgICAgICAgICAgICAgY3B4MjogcTIueCxcclxuICAgICAgICAgICAgICAgIGNweTI6IHEyLnksXHJcbiAgICAgICAgICAgICAgICB4MjogcTMueCxcclxuICAgICAgICAgICAgICAgIHkyOiBxMy55XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNvbDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFV0aWwuaW5oZXJpdHMoQ29ubmVjdG9yLCBOb2RlKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbm5lY3RvcjtcclxuXHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIFN5bWJvbCBmYWN0b3J5XHJcblxyXG5cclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vZ3JhcGhpYycpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XHJcbiAgICAvKipcclxuICAgICAqIFRyaWFuZ2xlIHNoYXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRyaWFuZ2xlID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcbiAgICAgICAgdHlwZTogJ3RyaWFuZ2xlJyxcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBjeCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgY3kgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIERpYW1vbmQgc2hhcGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgRGlhbW9uZCA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG4gICAgICAgIHR5cGU6ICdkaWFtb25kJyxcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBjeCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgY3kgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCwgY3kgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQaW4gc2hhcGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgUGluID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcbiAgICAgICAgdHlwZTogJ3BpbicsXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgLy8geCwgeSBvbiB0aGUgY3VzcFxyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XHJcbiAgICAgICAgICAgIHZhciB3ID0gc2hhcGUud2lkdGggLyA1ICogMztcclxuICAgICAgICAgICAgLy8gSGVpZ2h0IG11c3QgYmUgbGFyZ2VyIHRoYW4gd2lkdGhcclxuICAgICAgICAgICAgdmFyIGggPSBNYXRoLm1heCh3LCBzaGFwZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgciA9IHcgLyAyO1xyXG5cclxuICAgICAgICAgICAgLy8gRGlzdCBvbiB5IHdpdGggdGFuZ2VudCBwb2ludCBhbmQgY2lyY2xlIGNlbnRlclxyXG4gICAgICAgICAgICB2YXIgZHkgPSByICogciAvIChoIC0gcik7XHJcbiAgICAgICAgICAgIHZhciBjeSA9IHkgLSBoICsgciArIGR5O1xyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oZHkgLyByKTtcclxuICAgICAgICAgICAgLy8gRGlzdCBvbiB4IHdpdGggdGFuZ2VudCBwb2ludCBhbmQgY2lyY2xlIGNlbnRlclxyXG4gICAgICAgICAgICB2YXIgZHggPSBNYXRoLmNvcyhhbmdsZSkgKiByO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRhblggPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgIHZhciB0YW5ZID0gTWF0aC5jb3MoYW5nbGUpO1xyXG5cclxuICAgICAgICAgICAgcGF0aC5hcmMoXHJcbiAgICAgICAgICAgICAgICB4LCBjeSwgcixcclxuICAgICAgICAgICAgICAgIE1hdGguUEkgLSBhbmdsZSxcclxuICAgICAgICAgICAgICAgIE1hdGguUEkgKiAyICsgYW5nbGVcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjcExlbiA9IHIgKiAwLjY7XHJcbiAgICAgICAgICAgIHZhciBjcExlbjIgPSByICogMC43O1xyXG4gICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICB4ICsgZHggLSB0YW5YICogY3BMZW4sIGN5ICsgZHkgKyB0YW5ZICogY3BMZW4sXHJcbiAgICAgICAgICAgICAgICB4LCB5IC0gY3BMZW4yLFxyXG4gICAgICAgICAgICAgICAgeCwgeVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICB4LCB5IC0gY3BMZW4yLFxyXG4gICAgICAgICAgICAgICAgeCAtIGR4ICsgdGFuWCAqIGNwTGVuLCBjeSArIGR5ICsgdGFuWSAqIGNwTGVuLFxyXG4gICAgICAgICAgICAgICAgeCAtIGR4LCBjeSArIGR5XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJvdyBzaGFwZVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBBcnJvdyA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG5cclxuICAgICAgICB0eXBlOiAnYXJyb3cnLFxyXG5cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XHJcbiAgICAgICAgICAgIHZhciBkeCA9IHdpZHRoIC8gMyAqIDI7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGR4LCB5ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgaGVpZ2h0IC8gNCAqIDMpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHggLSBkeCwgeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBvZiBwYXRoIGNvbnRydWN0b3JzXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aD59XHJcbiAgICAgKi9cclxuICAgIHZhciBzeW1ib2xDdG9ycyA9IHtcclxuICAgICAgICBsaW5lOiBncmFwaGljLkxpbmUsXHJcblxyXG4gICAgICAgIHJlY3Q6IGdyYXBoaWMuUmVjdCxcclxuXHJcbiAgICAgICAgcm91bmRSZWN0OiBncmFwaGljLlJlY3QsXHJcblxyXG4gICAgICAgIHNxdWFyZTogZ3JhcGhpYy5SZWN0LFxyXG5cclxuICAgICAgICBjaXJjbGU6IGdyYXBoaWMuQ2lyY2xlLFxyXG5cclxuICAgICAgICBkaWFtb25kOiBEaWFtb25kLFxyXG5cclxuICAgICAgICBwaW46IFBpbixcclxuXHJcbiAgICAgICAgYXJyb3c6IEFycm93LFxyXG5cclxuICAgICAgICB0cmlhbmdsZTogVHJpYW5nbGVcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHN5bWJvbFNoYXBlTWFrZXJzID0ge1xyXG5cclxuICAgICAgICBsaW5lOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgLy8gRklYTUVcclxuICAgICAgICAgICAgc2hhcGUueDEgPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55MSA9IHkgKyBoIC8gMjtcclxuICAgICAgICAgICAgc2hhcGUueDIgPSB4ICsgdztcclxuICAgICAgICAgICAgc2hhcGUueTIgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geTtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJvdW5kUmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geTtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgICAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyA0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNxdWFyZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4odywgaCk7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geTtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSBzaXplO1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBzaXplO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNpcmNsZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIC8vIFB1dCBjaXJjbGUgaW4gdGhlIGNlbnRlciBvZiBzcXVhcmVcclxuICAgICAgICAgICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyAyO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRpYW1vbmQ6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwaW46IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYXJyb3c6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdHJpYW5nbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzeW1ib2xCdWlsZFByb3hpZXMgPSB7fTtcclxuICAgIGZvciAodmFyIG5hbWUgaW4gc3ltYm9sQ3RvcnMpIHtcclxuICAgICAgICBzeW1ib2xCdWlsZFByb3hpZXNbbmFtZV0gPSBuZXcgc3ltYm9sQ3RvcnNbbmFtZV0oKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgU3ltYm9sID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdzeW1ib2wnLFxyXG5cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBzeW1ib2xUeXBlOiAnJyxcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIC8vIEZJWE1FXHJcbiAgICAgICAgICAgIGlmIChzaGFwZS5zeW1ib2xUeXBlID09PSAncGluJyAmJiBzdHlsZS50ZXh0UG9zaXRpb24gPT09ICdpbnNpZGUnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0UG9zaXRpb24gPSBbJzUwJScsICc0MCUnXTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBzaGFwZS5zeW1ib2xUeXBlO1xyXG4gICAgICAgICAgICB2YXIgcHJveHlTeW1ib2wgPSBzeW1ib2xCdWlsZFByb3hpZXNbc3ltYm9sVHlwZV07XHJcbiAgICAgICAgICAgIGlmIChzaGFwZS5zeW1ib2xUeXBlICE9PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJveHlTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHJlY3RcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2xUeXBlID0gJ3JlY3QnO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3h5U3ltYm9sID0gc3ltYm9sQnVpbGRQcm94aWVzW3N5bWJvbFR5cGVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sU2hhcGVNYWtlcnNbc3ltYm9sVHlwZV0oXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUueCwgc2hhcGUueSwgc2hhcGUud2lkdGgsIHNoYXBlLmhlaWdodCwgcHJveHlTeW1ib2wuc2hhcGVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBwcm94eVN5bWJvbC5idWlsZFBhdGgoY3R4LCBwcm94eVN5bWJvbC5zaGFwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBQcm92aWRlIHNldENvbG9yIGhlbHBlciBtZXRob2QgdG8gYXZvaWQgZGV0ZXJtaW5lIGlmIHNldCB0aGUgZmlsbCBvciBzdHJva2Ugb3V0c2lkZVxyXG4gICAgdmFyIHN5bWJvbFBhdGhTZXRDb2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdpbWFnZScpIHtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbFN0eWxlID0gdGhpcy5zdHlsZTtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbFNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgaWYgKHN5bWJvbFNoYXBlICYmIHN5bWJvbFNoYXBlLnN5bWJvbFR5cGUgPT09ICdsaW5lJykge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fX2lzRW1wdHlCcnVzaCkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5maWxsID0gJyNmZmYnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRklYTUUg5Yik5pat5Zu+5b2i6buY6K6k5piv5aGr5YWF6L+Y5piv5o+P6L6577yM5L2/55SoIG9ubHlTdHJva2UgP1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuZmlsbCAmJiAoc3ltYm9sU3R5bGUuZmlsbCA9IGNvbG9yKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSAmJiAoc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzeW1ib2xVdGlsID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSBhIHN5bWJvbCBlbGVtZW50IHdpdGggZ2l2ZW4gc3ltYm9sIGNvbmZpZ3VyYXRpb246IHNoYXBlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xUeXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3XHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gelxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyZWF0ZVN5bWJvbDogZnVuY3Rpb24gKHN5bWJvbFR5cGUsIHgsIHksIHcsIGgsIHosIGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gc3ltYm9sVHlwZS5pbmRleE9mKCdlbXB0eScpID09PSAwO1xyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sVHlwZSA9IHN5bWJvbFR5cGUuc3Vic3RyKDUsIDEpLnRvTG93ZXJDYXNlKCkgKyBzeW1ib2xUeXBlLnN1YnN0cig2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3ltYm9sUGF0aDtcclxuXHJcbiAgICAgICAgICAgIGlmIChzeW1ib2xUeXBlLmluZGV4T2YoJ2ltYWdlOi8vJykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFBhdGggPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHN5bWJvbFR5cGUuc2xpY2UoOCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHo6IHpcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN5bWJvbFR5cGUuaW5kZXhPZigncGF0aDovLycpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xQYXRoID0gZ3JhcGhpYy5tYWtlUGF0aChzeW1ib2xUeXBlLnNsaWNlKDcpLCB7ejogeiwgcmVjdEhvdmVyOiB0cnVlfSwgbmV3IEJvdW5kaW5nUmVjdCh4LCB5LCB3LCBoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xQYXRoID0gbmV3IFN5bWJvbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sVHlwZTogc3ltYm9sVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgejogelxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN5bWJvbFBhdGguX19pc0VtcHR5QnJ1c2ggPSBpc0VtcHR5O1xyXG5cclxuICAgICAgICAgICAgc3ltYm9sUGF0aC5zZXRDb2xvciA9IHN5bWJvbFBhdGhTZXRDb2xvcjtcclxuXHJcbiAgICAgICAgICAgIHN5bWJvbFBhdGguc2V0Q29sb3IoY29sb3IpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHN5bWJvbFV0aWw7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL1N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDnlLvlj6Xmn4RcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC5qc1wiKTtcclxuICAgIGZ1bmN0aW9uIEhhbmRsZSh0eXBlLCB4LCB5LCBjb25uZWN0b3Ipe1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yO1xyXG5cclxuICAgICAgICB0aGlzLmhhbmRsZVNoYXBlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIGN4OiB4LFxyXG4gICAgICAgICAgICAgICAgY3k6IHksXHJcbiAgICAgICAgICAgICAgICByOiBIYW5kbGUuUkFESVVTXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogXCJyZ2IoMCwyNTUsMClcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTpcInJnYigwLDAsMClcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6bGV2ZWwgOiBjb25uZWN0b3Iub3B0aW9ucy56ICsgMiwgIC8v6IqC54K5WuS4ujEg57q/5q615Li6MDtcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOnRydWVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlU2hhcGUub24oXCJkcmFnXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdGhhdC5hY3Rpb25Db25uZWN0b3IoZS5vZmZzZXRYLGUub2Zmc2V0WSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAvLyByZXR1cm4gdGhpcy5jaXJjbGU7XHJcbiAgICB9XHJcblxyXG4gICAgSGFuZGxlLlJBRElVUyA9IDQ7XHJcblxyXG4gICAgSGFuZGxlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IgOiBIYW5kbGUsXHJcblxyXG4gICAgICAgIGVxdWFscyA6IGZ1bmN0aW9uKGFub3RoZXJIYW5kbGUpe1xyXG4gICAgICAgICAgICBpZighYW5vdGhlckhhbmRsZSBpbnN0YW5jZW9mIEhhbmRsZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gYW5vdGhlckhhbmRsZS50eXBlXHJcbiAgICAgICAgICAgICYmIHRoaXMueCA9PSBhbm90aGVySGFuZGxlLnhcclxuICAgICAgICAgICAgJiYgdGhpcy55ID09IGFub3RoZXJIYW5kbGUueVxyXG4gICAgICAgICAgICAmJiB0aGlzLnZpc2libGUgPT0gYW5vdGhlckhhbmRsZS52aXNpYmxlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNoYXBlLmF0dHIoJ3Bvc2l0aW9uJywgWzAsIDBdKTtcclxuICAgICAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTaGFwZS5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgICAgICBjeDogeCxcclxuICAgICAgICAgICAgICAgIGN5OiB5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOenu+WKqOWPpeafhFxyXG4gICAgICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbmV3WCBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBuZXdZIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFjdGlvbkNvbm5lY3RvcjogZnVuY3Rpb24obmV3WCwgbmV3WSl7XHJcbiAgICAgICAgICAgIHN3aXRjaCh0aGlzLnR5cGUpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndic6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOaJvuWHuuS4pOS4qui9rOaKmOeCue+8iOWPr+enu+WKqOWPpeafhOWcqOi/meS4pOS4qui9rOaKmOeCueS4remXtO+8iVxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzLmxlbmd0aC0xOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hc3NvY2lhdGVkUG9pbnQgJiYgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54ID09IHRoaXMuYXNzb2NpYXRlZFBvaW50LnggJiYgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS55ID09IHRoaXMuYXNzb2NpYXRlZFBvaW50LnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS55ID09IHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS55ID09IHRoaXMueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5taW4odGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54LCB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueCkgPD0gdGhpcy54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLm1heCh0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLngsIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS54KSA+PSB0aGlzLngpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFZID0gbmV3WSAtIHRoaXMueTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRpb25NYXRyaXggPSBVdGlsLnRyYW5zbGF0aW9uTWF0cml4KDAsIGRlbHRhWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaW5kZXgtMV0udHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2luZGV4XS50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnJlZnJlc2goKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOaJvuWHuuS4pOS4qui9rOaKmOeCue+8iOWPr+enu+WKqOWPpeafhOWcqOi/meS4pOS4qui9rOaKmOeCueS4remXtO+8iVxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzLmxlbmd0aC0xOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hc3NvY2lhdGVkUG9pbnQgJiYgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54ID09IHRoaXMuYXNzb2NpYXRlZFBvaW50LnggJiYgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS55ID09IHRoaXMuYXNzb2NpYXRlZFBvaW50LnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS54ID09IHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54ID09IHRoaXMueFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5taW4odGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS55LCB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueSkgPD0gdGhpcy55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLm1heCh0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnksIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS55KSA+PSB0aGlzLnkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhWCA9IG5ld1gtdGhpcy54O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2xhdGlvbk1hdHJpeCA9IFV0aWwudHJhbnNsYXRpb25NYXRyaXgoZGVsdGFYLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2luZGV4LTFdLnRyYW5zZm9ybSh0cmFuc2xhdGlvbk1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpbmRleF0udHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5yZWZyZXNoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgLy8uIHRoaXMuc2hhcGUudXBkYXRlTWlkZGxlVGV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhhbmRsZTtcclxuXHJcblxyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9IYW5kbGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog6L+e57q/5Yqo5oCB5pWI5p6cXHJcbiAqIEBhdXRob3IgbWlhby5jdW56aGlcclxuICovXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xyXG4gICAgdmFyIGN1cnZlVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvY3VydmUnKTtcclxuICAgIHZhciBzeW1ib2xVdGlsID0gcmVxdWlyZSgnLi9TeW1ib2wuanMnKTtcclxuXHJcbiAgICBmdW5jdGlvbiBFZmZlY3RMaW5lKHN5bWJvbCwgb3B0aW9ucywgZ3JvdXBDdXJ2ZSwgcG9seUxpbmUpIHtcclxuICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZVBlcmNlbnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZSA9IGdyb3VwQ3VydmU7XHJcbiAgICAgICAgdGhpcy5pbml0U3ltYm9sKG9wdGlvbnMsIHBvbHlMaW5lKTtcclxuICAgIH1cclxuICAgIHZhciBFZmZlY3RMaW5lUHJvdG8gPSBFZmZlY3RMaW5lLnByb3RvdHlwZTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8uaW5pdFN5bWJvbCA9IGZ1bmN0aW9uKG9wdGlvbnMsIHBvbHlMaW5lKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLnoyID0gMTAwO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLmN1bGxpbmcgPSB0cnVlO1xyXG4gICAgICAgIHZhciBwZXJpb2QgPSBvcHRpb25zLmVmZmVjdC5wZXJpb2QgKiAxMDAwO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fdCA9IDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuc3RvcEFuaW1hdGlvbigpO1xyXG4gICAgICAgIGlmICgob3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBcImN1cnZlXCIpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwQ3VydmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgIHBlcmlvZCA9IHBlcmlvZCAvIHRoaXMuZ3JvdXBDdXJ2ZS5fY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlQW5pbWF0ZSh0aGlzLmdyb3VwQ3VydmUuX2NoaWxkcmVuWzBdLCBpLCBwZXJpb2QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sLmFuaW1hdGUoJycsIHRydWUpXHJcbiAgICAgICAgICAgICAgICAud2hlbihwZXJpb2QsIHtcclxuICAgICAgICAgICAgICAgICAgICBfX3Q6IDFcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuZGVsYXkoMClcclxuICAgICAgICAgICAgICAgIC5kdXJpbmcoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51cGRhdGVTeW1ib2xQb3NpdGlvblBvbHlsaW5lKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QW5pbWF0aW9uUG9pbnRzUG9seWxpbmUocG9seUxpbmUuc2hhcGUucG9pbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8uZ3JvdXBDdXJ2ZUFuaW1hdGUgPSBmdW5jdGlvbihjdXJ2ZUxpbmUsIGksIHBlcmlvZCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBpZiAoY3VydmVMaW5lID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjdXJ2ZUxpbmUgPSB0aGlzLmdyb3VwQ3VydmUuX2NoaWxkcmVuWzBdO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBvaW50cztcclxuICAgICAgICB2YXIgcG9zID0gY3VydmVMaW5lLnNoYXBlO1xyXG4gICAgICAgIHBvaW50cyA9IFtcclxuICAgICAgICAgICAgW3Bvcy54MSwgcG9zLnkxXSxcclxuICAgICAgICAgICAgW3Bvcy54MiwgcG9zLnkyXSxcclxuICAgICAgICAgICAgW3Bvcy5jcHgxLCBwb3MuY3B5MV0sXHJcbiAgICAgICAgICAgIFtwb3MuY3B4MiwgcG9zLmNweTJdXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLnNldEFuaW1hdGlvblBvaW50c0JlemllckN1cnZlKHBvaW50cyk7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuYW5pbWF0ZSgnJylcclxuICAgICAgICAgICAgLndoZW4ocGVyaW9kLCB7XHJcbiAgICAgICAgICAgICAgICBfX3Q6IDFcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmRlbGF5KDApXHJcbiAgICAgICAgICAgIC5kdXJpbmcoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVN5bWJvbFBvc2l0aW9uQmV6aWVyQ3VydmUoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnN5bWJvbC5fX3QgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5ncm91cEN1cnZlQW5pbWF0ZSh0aGF0Lmdyb3VwQ3VydmUuX2NoaWxkcmVuW2kgKyAxXSwgaSArIDEsIHBlcmlvZCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdGFydCgpO1xyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by5zZXRBbmltYXRpb25Qb2ludHNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fcDEgPSBwb2ludHNbMF07XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX19wMiA9IHBvaW50c1sxXTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX2NwMSA9IHBvaW50c1syXSB8fCBbXHJcbiAgICAgICAgICAgIChwb2ludHNbMF1bMF0gKyBwb2ludHNbMV1bMF0pIC8gMixcclxuICAgICAgICAgICAgKHBvaW50c1swXVsxXSArIHBvaW50c1sxXVsxXSkgLyAyXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX2NwMiA9IHBvaW50c1szXTtcclxuICAgIH07XHJcblxyXG4gICAgRWZmZWN0TGluZVByb3RvLnVwZGF0ZVN5bWJvbFBvc2l0aW9uQmV6aWVyQ3VydmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcDEgPSB0aGlzLnN5bWJvbC5fX3AxO1xyXG4gICAgICAgIHZhciBwMiA9IHRoaXMuc3ltYm9sLl9fcDI7XHJcbiAgICAgICAgdmFyIGNwMSA9IHRoaXMuc3ltYm9sLl9fY3AxO1xyXG4gICAgICAgIHZhciBjcDIgPSB0aGlzLnN5bWJvbC5fX2NwMjtcclxuICAgICAgICB2YXIgdCA9IHRoaXMuc3ltYm9sLl9fdDtcclxuICAgICAgICB2YXIgcG9zID0gdGhpcy5zeW1ib2wucG9zaXRpb247XHJcbiAgICAgICAgdmFyIHR4LCB0eTtcclxuICAgICAgICBpZiAoY3AyWzBdICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YXIgY3ViaWNBdCA9IGN1cnZlVXRpbC5jdWJpY0F0O1xyXG4gICAgICAgICAgICB2YXIgY3ViaWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVV0aWwuY3ViaWNEZXJpdmF0aXZlQXQ7XHJcbiAgICAgICAgICAgIHBvc1swXSA9IGN1YmljQXQocDFbMF0sIGNwMVswXSwgY3AyWzBdLCBwMlswXSwgdCk7XHJcbiAgICAgICAgICAgIHBvc1sxXSA9IGN1YmljQXQocDFbMV0sIGNwMVsxXSwgY3AyWzFdLCBwMlsxXSwgdCk7XHJcbiAgICAgICAgICAgIC8vIFRhbmdlbnRcclxuICAgICAgICAgICAgdHggPSBjdWJpY0Rlcml2YXRpdmVBdChwMVswXSwgY3AxWzBdLCBjcDJbMF0sIHAyWzBdLCB0KTtcclxuICAgICAgICAgICAgdHkgPSBjdWJpY0Rlcml2YXRpdmVBdChwMVsxXSwgY3AxWzFdLCBjcDJbMV0sIHAyWzFdLCB0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZVV0aWwucXVhZHJhdGljQXQ7XHJcbiAgICAgICAgICAgIHZhciBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVV0aWwucXVhZHJhdGljRGVyaXZhdGl2ZUF0O1xyXG4gICAgICAgICAgICBwb3NbMF0gPSBxdWFkcmF0aWNBdChwMVswXSwgY3AxWzBdLCBwMlswXSwgdCk7XHJcbiAgICAgICAgICAgIHBvc1sxXSA9IHF1YWRyYXRpY0F0KHAxWzFdLCBjcDFbMV0sIHAyWzFdLCB0KTtcclxuICAgICAgICAgICAgLy8gVGFuZ2VudFxyXG4gICAgICAgICAgICB0eCA9IHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMVswXSwgY3AxWzBdLCBwMlswXSwgdCk7XHJcbiAgICAgICAgICAgIHR5ID0gcXVhZHJhdGljRGVyaXZhdGl2ZUF0KHAxWzFdLCBjcDFbMV0sIHAyWzFdLCB0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zeW1ib2wucm90YXRpb24gPSAtTWF0aC5hdGFuMih0eSwgdHgpIC0gTWF0aC5QSSAvIDI7XHJcblxyXG4gICAgICAgIHRoaXMuc3ltYm9sLmlnbm9yZSA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8uc2V0QW5pbWF0aW9uUG9pbnRzUG9seWxpbmUgPSBmdW5jdGlvbihwb2ludHMpIHtcclxuICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgdmFyIGFjY0xlbkFyciA9IFswXTtcclxuICAgICAgICB2YXIgbGVuID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcDEgPSBwb2ludHNbaSAtIDFdO1xyXG4gICAgICAgICAgICB2YXIgcDIgPSBwb2ludHNbaV07XHJcbiAgICAgICAgICAgIGxlbiArPSB2ZWMyLmRpc3QocDEsIHAyKTtcclxuICAgICAgICAgICAgYWNjTGVuQXJyLnB1c2gobGVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFjY0xlbkFyci5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBhY2NMZW5BcnJbal0gLz0gbGVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9vZmZzZXRzID0gYWNjTGVuQXJyO1xyXG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbjtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fbGFzdEZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX2xhc3RGcmFtZVBlcmNlbnQgPSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8udXBkYXRlU3ltYm9sUG9zaXRpb25Qb2x5bGluZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0ID0gdGhpcy5zeW1ib2wuX190O1xyXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLl9wb2ludHM7XHJcbiAgICAgICAgdmFyIG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xyXG4gICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoIW9mZnNldHMpIHtcclxuICAgICAgICAgICAgLy8gSGFzIGxlbmd0aCAwXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsYXN0RnJhbWUgPSB0aGlzLl9sYXN0RnJhbWU7XHJcbiAgICAgICAgdmFyIGZyYW1lO1xyXG5cclxuICAgICAgICBpZiAodCA8IHRoaXMuX2xhc3RGcmFtZVBlcmNlbnQpIHtcclxuICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSB0aGUgbmV4dCBmcmFtZVxyXG4gICAgICAgICAgICAvLyBQRU5ESU5HIHN0YXJ0IGZyb20gbGFzdEZyYW1lID9cclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5taW4obGFzdEZyYW1lICsgMSwgbGVuIC0gMSk7XHJcbiAgICAgICAgICAgIGZvciAoZnJhbWUgPSBzdGFydDsgZnJhbWUgPj0gMDsgZnJhbWUtLSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldHNbZnJhbWVdIDw9IHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQRU5ESU5HIHJlYWxseSBuZWVkIHRvIGRvIHRoaXMgP1xyXG4gICAgICAgICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lLCBsZW4gLSAyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBmcmFtZSA9IGxhc3RGcmFtZTsgZnJhbWUgPCBsZW47IGZyYW1lKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRzW2ZyYW1lXSA+IHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lIC0gMSwgbGVuIC0gMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZlYzIubGVycChcclxuICAgICAgICAgICAgdGhpcy5zeW1ib2wucG9zaXRpb24sIHBvaW50c1tmcmFtZV0sIHBvaW50c1tmcmFtZSArIDFdLFxyXG4gICAgICAgICAgICAodCAtIG9mZnNldHNbZnJhbWVdKSAvIChvZmZzZXRzW2ZyYW1lICsgMV0gLSBvZmZzZXRzW2ZyYW1lXSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSBmcmFtZTtcclxuICAgICAgICB0aGlzLl9sYXN0RnJhbWVQZXJjZW50ID0gdDtcclxuICAgICAgICB2YXIgYW5nbGUgPSAtTWF0aC5hdGFuMihwb2ludHNbZnJhbWUgKyAxXVsxXSAtIHBvaW50c1tmcmFtZV1bMV0sIHBvaW50c1tmcmFtZSArIDFdWzBdIC0gcG9pbnRzW2ZyYW1lXVswXSk7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wucm90YXRpb24gPSBhbmdsZSAtIE1hdGguUEkgLyAyO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLmlnbm9yZSA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gRWZmZWN0TGluZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvRWZmZWN0TGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDmjqfliLbngrlcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvblBvaW50KGNvbm5lY3RvciwgcG9pbnQsIHR5cGUsIG9wdGlvbnMpe1xyXG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yO1xyXG5cclxuICAgICAgICB0aGlzLnBvaW50ID0gcG9pbnQuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IENvbm5lY3Rpb25Qb2ludC5OT1JNQUxfQ09MT1I7XHJcblxyXG4gICAgICAgIHRoaXMub1R5cGUgPSAnQ29ubmVjdGlvblBvaW50JztcclxuXHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogdGhpcy5wb2ludC54LFxyXG4gICAgICAgICAgICAgICAgY3k6IHRoaXMucG9pbnQueSxcclxuICAgICAgICAgICAgICAgIHI6IENvbm5lY3Rpb25Qb2ludC5SQURJVVNcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiB0aGlzLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6IDogb3B0aW9ucy56ICsgMiAgLy/oioLngrla5Li6MSDnur/mrrXkuLowO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2hhcGUudHlwZSA9ICB0aGlzLnR5cGU7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhcGUuY29ubmVjdG9yID0gY29ubmVjdG9yO1xyXG4gICAgICAgIC8vcmV0dXJuIHRoaXMuY2lyY2xlO1xyXG4gICAgfVxyXG5cclxuICAgIENvbm5lY3Rpb25Qb2ludC5OT1JNQUxfQ09MT1IgPSBcIiNGRkZGMzNcIjsgLy95ZWxsb3cuXHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50Lk9WRVJfQ09MT1IgPSBcIiNGRjk5MDBcIjsgLy9vcmFuZ2VcclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQuQ09OTkVDVEVEX0NPTE9SID0gXCIjZmYwMDAwXCI7IC8vcmVkXHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlJBRElVUyA9IDQ7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlRZUEVfRklHVVJFID0gJ2ZpZ3VyZSc7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlRZUEVfQ09OTkVDVE9SID0gJ2Nvbm5lY3Rvcic7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IgOiBDb25uZWN0aW9uUG9pbnQsXHJcblxyXG4gICAgICAgIGVxdWFscyA6IGZ1bmN0aW9uKGFub3RoZXJDb25uZWN0aW9uUG9pbnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb2ludC5lcXVhbHMoYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5wb2ludClcclxuICAgICAgICAgICAgJiYgdGhpcy5jb25uZWN0b3IgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5jb25uZWN0b3JcclxuICAgICAgICAgICAgJiYgdGhpcy50eXBlID09IGFub3RoZXJDb25uZWN0aW9uUG9pbnQudHlwZVxyXG4gICAgICAgICAgICAmJiB0aGlzLmNvbG9yID09IGFub3RoZXJDb25uZWN0aW9uUG9pbnQuY29sb3JcclxuICAgICAgICAgICAgJiYgdGhpcy5yYWRpdXMgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5yYWRpdXM7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uUG9pbnQ7XHJcblxyXG5cclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdGlvblBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOe7hO+8jCDnu4TkuK3lhYPntKDnmoTlnZDmoIfpg73mmK/nm7jlr7nkuo7ov5nkuKrnu4TnmoQ8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5Hcm91cE5vZGVcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgdmFyIGdyb3VwMSA9IG5ldyBub2RlLkdyb3VwKHtcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw1MF1cclxuICogICAgICAgfSk7XHJcbiAqXHJcbiAqICAgICAgIHZhciByZWN0MSA9IG5ldyBub2RlLlJlY3Qoe1xyXG4gKiAgICAgICAgICAgc2hhcGU6e3dpZHRoOjEyMCxoZWlnaHQ6MzB9LFxyXG4gKiAgICAgICAgICAgc3R5bGU6e3RleHQ6XCLmoIfpophcIiwgZmlsbDpcIiNGRkI5MEZcIixzdHJva2U6XCIjYmJiYmJiXCJ9LFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzAsMF0sXHJcbiAqICAgICAgICAgICBzZWxlY3RhYmxlOmZhbHNlXHJcbiAqICAgICAgIH0pO1xyXG4gKlxyXG4gKiAgICAgICB2YXIgcmVjdDIgPSBuZXcgbm9kZS5SZWN0KHtcclxuICogICAgICAgICAgIHNoYXBlOnt3aWR0aDoxMjAsaGVpZ2h0OjYwfSxcclxuICogICAgICAgICAgIHN0eWxlOnt0ZXh0Olwi5YaF5a65XCIsIGZpbGw6XCIjRkZGRkZGXCIsc3Ryb2tlOlwiI2JiYmJiYlwifSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOlswLDMwXSxcclxuICogICAgICAgICAgIHNlbGVjdGFibGU6ZmFsc2VcclxuICogICAgICAgfSk7XHJcbiAqXHJcbiAqICAgICAgIGdyb3VwMS5hZGQocmVjdDEpO1xyXG4gKiAgICAgICBncm91cDEuYWRkKHJlY3QyKTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKGdyb3VwMSk7XHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21vZGVsLmpzXCIpO1xyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBHcm91cE5vZGUob3B0cykge1xyXG4gICAgICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbCh7fSk7XHJcblx0XHRpZiAoIW9wdHMuaWQpIHtcclxuXHRcdFx0b3B0cy5pZCA9IHV0aWwuZ2V0VVVJRCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0cy5zdHlsZSAmJiBvcHRzLnN0eWxlLnRleHRMaW5lSGVpZ2h0ICE9PSAwICYmICFvcHRzLnN0eWxlLnJpY2gpIHsgLy8jMTcwXHJcbiAgICAgICAgICAgIG9wdHMuc3R5bGUucmljaCA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBtb2RlbC5zZXQoXCJlbGVtZW50VHlwZVwiLCBcIkdyb3VwTm9kZVwiKTtcclxuICAgICAgICBpZiAob3B0cy5zdHlsZSAmJiBvcHRzLnN0eWxlLmhvc3QpIHtcclxuICAgICAgICAgICAgZGVsZXRlIG9wdHMuc3R5bGUuaG9zdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbW9kZWwuc2V0KFwib3B0aW9uc1wiLCB6clV0aWwuY2xvbmUob3B0cykpO1xyXG4gICAgICAgIGlmIChcImRyYWdnYWJsZVwiIGluIG9wdHMpIHtcclxuICAgICAgICAgICAgb3B0cy5pc2RyYWdnYWJsZSA9IG9wdHMuZHJhZ2dhYmxlO1xyXG4gICAgICAgICAgICBkZWxldGUgb3B0cy5kcmFnZ2FibGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb3B0cy56KSB7XHJcbiAgICAgICAgICAgIG9wdHMueiA9IDE7IC8v6IqC54K56buY6K6k5Li6Me+8jOe6v+autTA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChvcHRzLmhvdmVyQW5pbWF0aW9uKSkge1xyXG4gICAgICAgICAgICBvcHRzLmhvdmVyQW5pbWF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChvcHRzLnNlbGVjdGFibGUpKSB7XHJcbiAgICAgICAgICAgIG9wdHMuc2VsZWN0YWJsZSA9IHRydWU7ICAvL+m7mOiupOWPr+S7pemAieS4rVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgZ3JhcGhpYy5Hcm91cC5jYWxsKHRoaXMsIG9wdHMpO1xyXG5cclxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogNSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogNSxcclxuICAgICAgICAgICAgICAgIHI6IDVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICdyZ2JhKDAsMCwwLDApJywvLycjZjlmOWY5JyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJ3JnYmEoMCwwLDAsMCknLy8nI2JiYmJiYidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcG9zaXRpb246IFswLCAwXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0genJVdGlsLm1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRzLCB0cnVlKTtcclxuICAgICAgICB0aGlzLnJlbmRlcih0aGlzLm9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgR3JvdXBOb2RlLlJFQ1RfTkFNRSA9IFwiR1JPVVBfUkVDVF9OQU1FXCI7XHJcbiAgICBHcm91cE5vZGUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHcm91cE5vZGUsXHJcbiAgICAgICAgdHlwZTogXCJHcm91cE5vZGVcIixcclxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IG1vZGVsLnNoYXBlLFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IG1vZGVsLnN0eWxlLFxyXG4gICAgICAgICAgICAgICAgLy9zaWxlbnQ6dHJ1ZSwgLy/liqDkuIrlkI4g5ouW5YqoIOe7hOS4reayoeacieWtkOWFg+e0oOeahOWcsOaWuSDml6Dms5XmiYvliqjkuoZcclxuICAgICAgICAgICAgICAgIHo6IDNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJlY3QubmFtZSA9IEdyb3VwTm9kZS5SRUNUX05BTUU7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHJlY3QpO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gbW9kZWwucG9zaXRpb247XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWN0Q29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSB1dGlsLmdldFJlY3QodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZWN0LmJvdW5kaW5nUmVjdC5jb250YWluKHgsIHkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFkZDogZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kb0FkZChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYXBpICYmIHRoaXMuX2FwaS5fYWRkR3JvdXBOb2RlKHRoaXMsY2hpbGQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6YGN5Y6G57uE5Lit5q+P5LiA5Liq5a2Q6IqC54K5XHJcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiIOWbnuiwg+WHveaVsGNiXHJcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBjb250ZXh0ICAg5LiK5LiL5paHY29udGV4dFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubmFtZSAhPSBHcm91cE5vZGUuUkVDVF9OQU1FKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBjaGlsZCwgaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0UmVjdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgLy/liJvlu7rmnIDlsI/ljIXlm7Tnm5LomZrnur9cclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICBwb2ludHNbMF0gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgICAgIHBvaW50c1sxXSA9IFtib3VuZGluZ1JlY3Qud2lkdGggLyAyLCAtYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG4gICAgICAgICAgICBwb2ludHNbMl0gPSBbYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG4gICAgICAgICAgICBwb2ludHNbM10gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICAgICAgcG9pbnRzWzRdID0gWy1ib3VuZGluZ1JlY3Qud2lkdGggLyAyLCAtYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSxcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0sXHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogdGhpcy5wb3NpdGlvblswXSArIGJvdW5kaW5nUmVjdC53aWR0aCAvIDIsXHJcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnBvc2l0aW9uWzFdICsgYm91bmRpbmdSZWN0LmhlaWdodCAvIDIsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ1JlY3QuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3Q6IGJvdW5kUmVjdFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbihwWCxwWSkge1xyXG4gICAgICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyKCdwb3NpdGlvbicsW3BYLWJvdW5kaW5nUmVjdC53aWR0aC8yLHBZLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl0pO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbiAob3B0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5jaGlsZE9mTmFtZShHcm91cE5vZGUuUkVDVF9OQU1FKTtcclxuICAgICAgICAgICAgcmVjdC5zZXRTaGFwZShvcHQuc2hhcGUpO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHIoJ3Bvc2l0aW9uJywgb3B0LnBvc2l0aW9uKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLm9wdGlvbnMuc2hhcGU7XHJcbiAgICAgICAgICAgIHZhciBuZXdXID0gTnVtYmVyKHNoYXBlLndpZHRoICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBuZXdIID0gTnVtYmVyKG5ld1cgKiBzaGFwZS5oZWlnaHQgLyBzaGFwZS53aWR0aCk7XHJcbiAgICAgICAgICAgIGlmIChpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdXID0gcGFyc2VJbnQobmV3VywgMTApO1xyXG4gICAgICAgICAgICAgICAgbmV3SCA9IHBhcnNlSW50KG5ld0gsIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDmjInmr5TkvovnvKnmlL5cclxuICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG5ld1csXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdIXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyDmm7TmlrDnu4TlhoXoioLngrlcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdi5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmICh2Lm5hbWUgIT09IEdyb3VwTm9kZS5SRUNUX05BTUUgJiYgISh2IGluc3RhbmNlb2YgQ29ubmVjdG9yKSAmJiB2LnR5cGUgIT09ICdaUGF0aCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmr4/kuKroioLngrnnmoRwb3NpdGlvbuabtOaWsFxyXG4gICAgICAgICAgICAgICAgICAgIHYudXBkYXRlU2hhcGUocmF0aW8sIGlmUGFyc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYuYXR0cigncG9zaXRpb24nLCBbcG9zaXRpb25bMF0gKiBzY2FsZVJhdGlvLCBwb3NpdGlvblsxXSAqIHNjYWxlUmF0aW9dKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB2LnJlY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdC5oZWlnaHQgPSByZWN0LmhlaWdodCAqIHNjYWxlUmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdC53aWR0aCA9IHJlY3Qud2lkdGggKiBzY2FsZVJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgIHYuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbcG9zaXRpb25bMF0gKiBzY2FsZVJhdGlvLCBwb3NpdGlvblsxXSAqIHNjYWxlUmF0aW9dLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0OiByZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoR3JvdXBOb2RlLCBncmFwaGljLkdyb3VwKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JvdXBOb2RlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9Hcm91cE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog6YCJ5Lit6IqC54K55ZCO77yM5Ye6546w55qE5pON5L2c5qGG5Y+K5oyJ6ZKuXHJcbiAqL1xyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBCcG1uID0gcmVxdWlyZShcIi4uL0JwbW4uanNcIik7XHJcbiAgICB2YXIgQnBtblV0aWwgPSByZXF1aXJlKFwiLi4vQnBtblV0aWwuanNcIik7XHJcbiAgICB2YXIgT3BlcmF0aW9uTm9kZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9PcGVyYXRpb25Ob2RlLmpzXCIpO1xyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcblxyXG4gICAgZnVuY3Rpb24gQnBtbk9wZXJhdGlvbk5vZGUobm9kZSwgenIsIGZvcmJpZEVkaXQpIHtcclxuICAgICAgICBPcGVyYXRpb25Ob2RlLmNhbGwodGhpcywgbm9kZSwgenIsIGZvcmJpZEVkaXQpO1xyXG4gICAgfVxyXG5cclxuICAgIEJwbW5PcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5yZWZyZXNoUG9zaXRpb25PdGhlciA9IGZ1bmN0aW9uKG5vZGUsbm9kZVJlY3QpIHtcclxuXHJcbiAgICAgICAgLy8g6K6h566X5pW05Liq55qE5L2N572uXHJcbiAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChCcG1uLmlzU3ViUHJvY2Vzcyhub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cihcInBvc2l0aW9uXCIsIFtub2RlUmVjdC54ICsgQnBtblV0aWwucGFyZW50WChub2RlLnBhcmVudCksIG5vZGVSZWN0LnkgKyBCcG1uVXRpbC5wYXJlbnRZKG5vZGUucGFyZW50KV0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmF0dHIoXCJwb3NpdGlvblwiLCBbbm9kZVJlY3QueCwgbm9kZVJlY3QueV0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgQnBtbk9wZXJhdGlvbk5vZGUucHJvdG90eXBlLnJlZnJlc2hQb3N0aW9uID0gZnVuY3Rpb24obm9kZSwgbm9kZVJlY3QpIHtcclxuICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3Mobm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgIG5vZGVSZWN0LnggLT0gQnBtblV0aWwucGFyZW50WChub2RlLnBhcmVudCk7XHJcbiAgICAgICAgICAgIG5vZGVSZWN0LnkgLT0gQnBtblV0aWwucGFyZW50WShub2RlLnBhcmVudCk7XHJcbiAgICAgICAgICAgIG5vZGVSZWN0LmJvdW5kaW5nUmVjdC54ID0gbm9kZVJlY3QuYm91bmRpbmdSZWN0LnggLSBCcG1uVXRpbC5wYXJlbnRYKG5vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgbm9kZVJlY3QuYm91bmRpbmdSZWN0LnkgPSBub2RlUmVjdC5ib3VuZGluZ1JlY3QueSAtIEJwbW5VdGlsLnBhcmVudFkobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgdmFyIHJiUG9pbnQgPSB6clV0aWwuY2xvbmUobm9kZVJlY3QucG9pbnRzWzJdKTsgLy/lj5blj7PkuIvop5LlnZDmoIdcclxuICAgICAgICB2YXIgcm90YXRpb24gPSBub2RlUmVjdC5yb3RhdGlvbiB8fCBub2RlLnJvdGF0aW9uO1xyXG4gICAgICAgIHZhciBhbmdsZSA9IHJvdGF0aW9uIC8gKE1hdGguUEkvMTgwKTtcclxuICAgICAgICBpZiAoTWF0aC5hYnMocm90YXRpb24pID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgY29ubmVjdG9yQ29udHJvbHMgPSBVdGlsLmdldENvbm5lY3RvckNvbnRyb2xzKG5vZGVSZWN0LCBub2RlKTtcclxuICAgICAgICAgICAgdmFyIGJyQ29udHJvbCA9IGNvbm5lY3RvckNvbnRyb2xzLmJyO1xyXG4gICAgICAgICAgICByYlBvaW50ID0gW2JyQ29udHJvbC54IC0gbm9kZVJlY3QueCwgIGJyQ29udHJvbC55IC0gbm9kZVJlY3QueV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vMS7lrprkvY3omZrmoYZcclxuICAgICAgICBpZiAodGhpcy52aXJ0dWFsUmVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxSZWN0LnNldFNoYXBlKHsgcG9pbnRzOiBub2RlUmVjdC5wb2ludHMgfSk7XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbFJlY3QuYXR0cigncm90YXRpb24nLCByb3RhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vMi7lrprkvY3mr4/kuKrlsI/lm77moIdcclxuICAgICAgICB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbihub2RlSXRlbSkge1xyXG4gICAgICAgICAgICBpZiAoIW5vZGVJdGVtLmlzU2VsZkNvbXB1dGVQb3MpIHtcclxuICAgICAgICAgICAgICAgIC8vIDhweOaYr+esrOS4gOS4quaTjeS9nOaMiemSruWbvuagh+eahOi3neemuyDpnaDlpKrov5HkuI3lpb3nnIsgICAgMjBweOaYr+avj+S4quWbvuagh+eahOmXtOmalCAgMTBweOaYr+Wbvuagh+WQkeWBj+eahOi3neemu1xyXG4gICAgICAgICAgICAgICAgbm9kZUl0ZW0uYXR0cihcInBvc2l0aW9uXCIsIFthbmdsZSA+PSAwID8gcmJQb2ludFswXSArIDggKyAoaSsrICogMjApIDogcmJQb2ludFswXSAtIDIwIC0gKGkrKyAqIDIwKSwgcmJQb2ludFsxXSAtIDEwXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWZyZXNoUG9zaXRpb25PdGhlcihub2RlLG5vZGVSZWN0KTtcclxuICAgIH07XHJcblxyXG4gICAgQnBtbk9wZXJhdGlvbk5vZGUuQVJST1dfRFJBR0VORCA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnZW5kQXJyb3dcIjtcclxuICAgIEJwbW5PcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUcgPSBcIk9wZXJhdGlvbk5vZGU6ZHJhZ0Fycm93XCI7XHJcbiAgICBCcG1uT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHU1RBUlQgPSBcIk9wZXJhdGlvbk5vZGU6ZHJhZ3N0YXJ0QXJyb3dcIjtcclxuICAgIEJwbW5PcGVyYXRpb25Ob2RlLkRFTEVURV9DTElDSyA9IFwiT3BlcmF0aW9uTm9kZTpkZWxldGVDbGlja1wiO1xyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhCcG1uT3BlcmF0aW9uTm9kZSwgT3BlcmF0aW9uTm9kZSk7XHJcblxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQnBtbk9wZXJhdGlvbk5vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9CcG1uT3BlcmF0aW9uTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDpgInkuK3oioLngrnlkI7vvIzlh7rnjrDnmoTmk43kvZzmoYblj4rmjInpkq5cclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgTm9kZSA9IHJlcXVpcmUoXCIuLi9Ob2RlXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC5qc1wiKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9lbnYnKTtcclxuICAgIHZhciBpY29uID0gcmVxdWlyZSgnLi9JY29uT3BlcmF0aW9uJyk7XHJcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoJy4uL3NoYXBlcy9TeW1ib2wnKTtcclxuICAgIGZ1bmN0aW9uIE9wZXJhdGlvbk5vZGUobm9kZSwgenIsIGFwaSxmb3JiaWRFZGl0KSB7XHJcbiAgICAgICAgTm9kZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy56ciA9IHpyO1xyXG4gICAgICAgIHRoaXMuZm9yYmlkRWRpdCA9IGZvcmJpZEVkaXQ7XHJcbiAgICAgICAgdGhpcy5fYXBpID0gYXBpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy/kuovku7ZcclxuICAgIE9wZXJhdGlvbk5vZGUuQVJST1dfRFJBR0VORCA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnZW5kQXJyb3dcIjtcclxuICAgIE9wZXJhdGlvbk5vZGUuQVJST1dfRFJBRyA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnQXJyb3dcIjtcclxuICAgIE9wZXJhdGlvbk5vZGUuQVJST1dfRFJBR1NUQVJUID0gXCJPcGVyYXRpb25Ob2RlOmRyYWdzdGFydEFycm93XCI7XHJcbiAgICBPcGVyYXRpb25Ob2RlLkRFTEVURV9DTElDSyA9IFwiT3BlcmF0aW9uTm9kZTpkZWxldGVDbGlja1wiO1xyXG4gICAgT3BlcmF0aW9uTm9kZS5ERUwgPSBcIkRFTFwiO1xyXG4gICAgT3BlcmF0aW9uTm9kZS5DT01NRU5UX0NMSUNLID0gXCJPcGVyYXRpb25Ob2RlOmNvbW1lbnRDbGlja1wiO1xyXG4gICAgT3BlcmF0aW9uTm9kZS5DT01NRU5UID0gXCJDT01NRU5UXCI7XHJcbiAgICAgICAgLy/lhoXnva7mk43kvZzlm77moIfnmoTlm77lg49cclxuICAgIE9wZXJhdGlvbk5vZGUub3BpY29ucyA9IHtcclxuICAgICAgICBTVFJBSUdIVDogaWNvbi5TVFJBSUdIVF9TVkcsXHJcbiAgICAgICAgSkFHR0VEOiBpY29uLkpBR0dFRF9TVkcsXHJcbiAgICAgICAgQ1VSVkU6IGljb24uQ1VSVkVfU1ZHLFxyXG4gICAgICAgIERFTDogaWNvbi5ERUxfU1ZHLFxyXG4gICAgICAgIENPTU1FTlQ6IGljb24uQ09NTUVOVF9TVkdcclxuICAgIH07XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJCYXNlKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZvcmJpZEVkaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJPdGhlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVuZGVyQmFzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlT3BlcmF0aW9uKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZXJhdGlvbk5vZGUucHJvdG90eXBlLmNyZWF0ZU9wZXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGlmU2hvd05vZGVPcGVyYXRpb25JY29ucyA9IHRoaXMubm9kZS5vcGVyYXRpb25JY29ucztcclxuICAgICAgICBpZiAodGhpcy5ub2RlLnBhcmVudCAmJiB0aGlzLm5vZGUucGFyZW50LnR5cGUgPT09ICdkcmFnU2VsZWN0Jykge1xyXG4gICAgICAgICAgICBpZlNob3dOb2RlT3BlcmF0aW9uSWNvbnMgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vZGUuc2VsZWN0U3R5bGUpIHtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsUmVjdCA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHsgc3R5bGU6IHsgbGluZURhc2g6IFsyXSB9IH0pO1xyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxSZWN0LmlzU2VsZkNvbXB1dGVQb3MgPSB0cnVlOyAgLy8g6Ieq5bex6K6h566X5L2N572uXHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMudmlydHVhbFJlY3QpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICBpZiAodGhpcy5ub2RlLnR5cGUgPT09ICdaUGF0aCcpIHsgIC8vYWRkSG92ZXLpnIDopoHku47lroPoh6rouqvnmoTmnoTpgKDlh73mlbDkuK3liJvlu7rjgIIxLlBhaW50ZXLkuK1hZGRIb3Zlcua6kOeggeaYr+agueaNrnNoYXBl5LiOc3R5bGXliJvlu7ogMi5wYXRo5Lit55qE5p6E6YCg5Ye95pWw5piv6L+U5Zue5Y+m5LiA5Liq5YWD57SgXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUuX3pDbG9uZVN0eWxlID0gdGhpcy5ub2RlLnN0eWxlLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgdGhpcy5ub2RlLnNldFN0eWxlKHRoaXMubm9kZS5zZWxlY3RTdHlsZSk7XHJcbiAgICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5ub2RlLnNldE9yQ2FuY2VsU2VsZWN0U3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5zZXRPckNhbmNlbFNlbGVjdFN0eWxlKHRydWUpO1xyXG4gICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaS5nZXRacigpLmFkZEhvdmVyKHRoaXMubm9kZSwgdGhpcy5ub2RlLnNlbGVjdFN0eWxlKTtcclxuICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaWZTaG93Tm9kZU9wZXJhdGlvbkljb25zKSB7XHJcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRoaXMubm9kZS5vcGVyYXRpb25JY29ucywgZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgLy/mo4Dmn6XmmK/lkKbmmK/lhoXnva7lm77moIdcclxuICAgICAgICAgICAgICAgIHZhciBvcEljb25JbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3BlcmF0aW9uSWNvbiA9IE9wZXJhdGlvbk5vZGUub3BpY29uc1tpdGVtLm5hbWUudG9VcHBlckNhc2UoKSArIFwiXCJdXHJcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uSWNvbikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mb3JiaWRFZGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uaGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ubmFtZSA9PSBPcGVyYXRpb25Ob2RlLkRFTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+Weg+WcvuahtlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZSA9IGdyYXBoaWMubWFrZVBhdGgob3BlcmF0aW9uSWNvbiwgeyBzdHlsZTogeyBmaWxsOiAnI2FhYWFhYycgfSx6Om1lLm5vZGUueisxLHJlY3RIb3ZlcjogdHJ1ZSB9LCB7IHg6IDAsIHk6IDAsIHdpZHRoOiAxMCwgaGVpZ2h0OiAxNSB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0uY2FsbGJhY2spe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm5vZGUgPSBtZS5ub2RlOyAgLy8g5bCG5omA6ZmE55qE6IqC54K55Lmf5Lyg6YCS5Ye65Y67XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jYWxsYmFjayhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IE9wZXJhdGlvbk5vZGUuREVMRVRFX0NMSUNLO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5uYW1lID09IE9wZXJhdGlvbk5vZGUuQ09NTUVOVCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlID0gZ3JhcGhpYy5tYWtlUGF0aChvcGVyYXRpb25JY29uLCB7IHN0eWxlOiB7IGZpbGw6ICcjYWFhYWFjJyB9LCB6Om1lLm5vZGUueisyLCByZWN0SG92ZXI6IHRydWUgfSwgcmVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBPcGVyYXRpb25Ob2RlLkNPTU1FTlRfQ0xJQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdE90aGVyID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMTUsIGhlaWdodDogMTUgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2UgPSBncmFwaGljLm1ha2VQYXRoKG9wZXJhdGlvbkljb24sIHsgc3R5bGU6IHsgZmlsbDogJyNhYWFhYWMnIH0sZHJhZ2dhYmxlOnRydWUsejptZS5ub2RlLnorMixsaW5lVHlwZTogQ29ubmVjdG9yW1wiVFlQRV9cIiArIGl0ZW0ubmFtZS50b1VwcGVyQ2FzZSgpXSxyZWN0SG92ZXI6IHRydWUgfSwgcmVjdE90aGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydkcmFnc3RhcnQnLCAnZHJhZycsICdkcmFnZW5kJ107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbihldmVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZS5vbihldmVOYW1lLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmRhdGEgPSBpdGVtLm9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiT3BlcmF0aW9uTm9kZTpcIiArIGV2ZU5hbWUgKyBcIkFycm93XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZSA9IHN5bWJvbFV0aWwuY3JlYXRlU3ltYm9sKGl0ZW0uaWNvblBhdGgsIDAsIDAsIGl0ZW0ud2lkdGggfHwgMTUsIGl0ZW0uaGVpZ2h0IHx8IDE1LCBtZS5ub2RlLnorMSwgaXRlbS5jb2xvcnx8JyMwMDAnKTtcclxuICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5ub2RlID0gbWUubm9kZTsgIC8vIOWwhuaJgOmZhOeahOiKgueCueS5n+S8oOmAkuWHuuWOu1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jYWxsYmFjayhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSB7ZXZlbnQ6ZSwgdHlwZTpcIk9wZXJhdGlvbk5vZGU6XCIgKyBpdGVtLm5hbWUgKyBcIkNsaWNrXCJ9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5fYXBpLnRyaWdnZXIocGFyYW0udHlwZSwgcGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2UubmFtZSA9IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgICAgIG1lLmFkZChvcEljb25JbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVmcmVzaFBvc3Rpb24gPSBmdW5jdGlvbihub2RlLCBub2RlUmVjdCkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB2YXIgcmJQb2ludCA9IHpyVXRpbC5jbG9uZShub2RlUmVjdC5wb2ludHNbMl0pOyAvL+WPluWPs+S4i+inkuWdkOagh1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IG5vZGUucm90YXRpb247XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gcm90YXRpb24gLyAoTWF0aC5QSS8xODApO1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhyb3RhdGlvbikgPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3JDb250cm9scyA9IFV0aWwuZ2V0Q29ubmVjdG9yQ29udHJvbHMobm9kZVJlY3QsIG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgYnJDb250cm9sID0gY29ubmVjdG9yQ29udHJvbHMuYnI7XHJcbiAgICAgICAgICAgIHJiUG9pbnQgPSBbYnJDb250cm9sLnggLSBub2RlUmVjdC54LCAgYnJDb250cm9sLnkgLSBub2RlUmVjdC55XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8xLuWumuS9jeiZmuahhlxyXG4gICAgICAgIGlmICh0aGlzLnZpcnR1YWxSZWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbFJlY3Quc2V0U2hhcGUoeyBwb2ludHM6IG5vZGVSZWN0LnBvaW50cyB9KTtcclxuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LmNoaWxkRHJhZ2dhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpcnR1YWxSZWN0LmF0dHIoJ3onLCBub2RlLnBhcmVudC56ICsgMSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxSZWN0LmF0dHIoJ3JvdGF0aW9uJywgcm90YXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLzIu5a6a5L2N5q+P5Liq5bCP5Zu+5qCHXHJcbiAgICAgICAgdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24obm9kZUl0ZW0pIHtcclxuICAgICAgICAgICAgaWYgKCFub2RlSXRlbS5pc1NlbGZDb21wdXRlUG9zKSB7XHJcbiAgICAgICAgICAgICAgICAvLyA4cHjmmK/nrKzkuIDkuKrmk43kvZzmjInpkq7lm77moIfnmoTot53nprsg6Z2g5aSq6L+R5LiN5aW955yLICAgIDIwcHjmmK/mr4/kuKrlm77moIfnmoTpl7TpmpQgIDEwcHjmmK/lm77moIflkJHlgY/nmoTot53nprtcclxuICAgICAgICAgICAgICAgIG5vZGVJdGVtLmF0dHIoXCJwb3NpdGlvblwiLCBbYW5nbGUgPj0gMCA/IHJiUG9pbnRbMF0gKyA4ICsgKGkrKyAqIDIwKSA6IHJiUG9pbnRbMF0gLSAyMCAtIChpKysgKiAyMCksIHJiUG9pbnRbMV0gLSAxMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMucmVmcmVzaFBvc2l0aW9uT3RoZXIobm9kZSxub2RlUmVjdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZXJhdGlvbk5vZGUucHJvdG90eXBlLnJlbmRlck90aGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy/nlZnnu5nmianlsZXkvb/nlKhcclxuICAgIH07XHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5yZWZyZXNoUG9zaXRpb25PdGhlciA9IGZ1bmN0aW9uKG5vZGUsbm9kZVJlY3QpIHtcclxuICAgICAgICAvL+eVmee7meaJqeWxleS9v+eUqFxyXG4gICAgICAgIC8vMy7lrprkvY3mlbTkuKpvcGVyYXRpb25Ob2RlXHJcbiAgICAgICAgaWYgKChub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC5pc0JnICYmIG5vZGUucGFyZW50LmlzQmcgPT0gdHJ1ZSkgfHwgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiR3JvdXBOb2RlXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cihcInBvc2l0aW9uXCIsIFtub2RlUmVjdC54LCBub2RlUmVjdC55XSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbm9kZVNoYXBlWCA9IG5vZGUuc2hhcGU/IG5vZGUuc2hhcGUueDowO1xyXG4gICAgICAgICAgICB2YXIgbm9kZVNhaHBlWSA9IG5vZGUuc2hhcGU/IG5vZGUuc2hhcGUueTowO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHIoXCJwb3NpdGlvblwiLCBbbm9kZVJlY3QueCArIG5vZGUucGFyZW50LnBvc2l0aW9uWzBdK25vZGVTaGFwZVgsIG5vZGVSZWN0LnkgKyBub2RlLnBhcmVudC5wb3NpdGlvblsxXStub2RlU2FocGVZXSlcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZXJhdGlvbk5vZGUucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZih0aGlzLm5vZGUuc2VsZWN0U3R5bGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZS50eXBlID09PSAnWlBhdGgnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUuc2V0U3R5bGUodGhpcy5ub2RlLl96Q2xvbmVTdHlsZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLm5vZGUuc2V0T3JDYW5jZWxTZWxlY3RTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLnNldE9yQ2FuY2VsU2VsZWN0U3R5bGUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaS5nZXRacigpLnJlbW92ZUhvdmVyKHRoaXMubm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoT3BlcmF0aW9uTm9kZSwgTm9kZSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE9wZXJhdGlvbk5vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9PcGVyYXRpb25Ob2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOaTjeS9nOWbvuagh+exu1xyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgSWNvbk9wZXJhdGlvbiA9IHtcclxuICAgICAgICBTVFJBSUdIVF9TVkc6ICdNOTM3LjM1Mzg0NiA3MjQuNjc2OTIzQzg4Mi4yMTUzODUgNjY5LjUzODQ2MiA3OTUuNTY5MjMxIDY2MS42NjE1MzggNzMyLjU1Mzg0NiA3MDEuMDQ2MTU0TDM2Mi4zMzg0NjIgMzMwLjgzMDc2OUM0MDEuNzIzMDc3IDI2Ny44MTUzODUgMzkzLjg0NjE1NCAxODEuMTY5MjMxIDMzOC43MDc2OTIgMTI2LjAzMDc2OSAyNjcuODE1Mzg1IDU1LjEzODQ2MiAxNjUuNDE1Mzg1IDU1LjEzODQ2MiA5NC41MjMwNzcgMTI2LjAzMDc2OSAyMy42MzA3NjkgMTk2LjkyMzA3NyAyMy42MzA3NjkgMjk5LjMyMzA3NyA5NC41MjMwNzcgMzcwLjIxNTM4NSAxNDkuNjYxNTM4IDQyNS4zNTM4NDYgMjM2LjMwNzY5MiA0MzMuMjMwNzY5IDI5OS4zMjMwNzcgMzkzLjg0NjE1NEw2NjkuNTM4NDYyIDc2NC4wNjE1MzhDNjMwLjE1Mzg0NiA4MjcuMDc2OTIzIDYzOC4wMzA3NjkgOTEzLjcyMzA3NyA2OTMuMTY5MjMxIDk2OC44NjE1MzggNzY0LjA2MTUzOCAxMDM5Ljc1Mzg0NiA4NjYuNDYxNTM4IDEwMzkuNzUzODQ2IDkzNy4zNTM4NDYgOTY4Ljg2MTUzOCAxMDAwLjM2OTIzMSA4OTcuOTY5MjMxIDEwMDAuMzY5MjMxIDc5NS41NjkyMzEgOTM3LjM1Mzg0NiA3MjQuNjc2OTIzTDkzNy4zNTM4NDYgNzI0LjY3NjkyM1pNMjc1LjY5MjMwOCAzMDcuMkMyNDQuMTg0NjE1IDMzOC43MDc2OTIgMTg5LjA0NjE1NCAzMzguNzA3NjkyIDE1Ny41Mzg0NjIgMzA3LjIgMTI2LjAzMDc2OSAyNzUuNjkyMzA4IDEyNi4wMzA3NjkgMjIwLjU1Mzg0NiAxNTcuNTM4NDYyIDE4OS4wNDYxNTQgMTg5LjA0NjE1NCAxNTcuNTM4NDYyIDI0NC4xODQ2MTUgMTU3LjUzODQ2MiAyNzUuNjkyMzA4IDE4OS4wNDYxNTQgMzA3LjIgMjIwLjU1Mzg0NiAzMDcuMiAyNjcuODE1Mzg1IDI3NS42OTIzMDggMzA3LjJMMjc1LjY5MjMwOCAzMDcuMlpNODc0LjMzODQ2MiA5MTMuNzIzMDc3Qzg0Mi44MzA3NjkgOTQ1LjIzMDc2OSA3ODcuNjkyMzA4IDk0NS4yMzA3NjkgNzU2LjE4NDYxNSA5MTMuNzIzMDc3IDcyNC42NzY5MjMgODgyLjIxNTM4NSA3MjQuNjc2OTIzIDgyNy4wNzY5MjMgNzU2LjE4NDYxNSA3OTUuNTY5MjMxIDc4Ny42OTIzMDggNzY0LjA2MTUzOCA4NDIuODMwNzY5IDc2NC4wNjE1MzggODc0LjMzODQ2MiA3OTUuNTY5MjMxIDkwNS44NDYxNTQgODI3LjA3NjkyMyA5MDUuODQ2MTU0IDg3NC4zMzg0NjIgODc0LjMzODQ2MiA5MTMuNzIzMDc3TDg3NC4zMzg0NjIgOTEzLjcyMzA3N1onLFxyXG4gICAgICAgIEpBR0dFRF9TVkc6ICdNMjA0LjggODE5LjJsLTUxLjItMTAyLjQgMjA0LjgtMzA3LjIgNTEuMiAxMDIuNC0yMDQuOCAzMDcuMnpNNDA5LjYgNTEybDUxLjItMTAyLjQgMTUzLjYgMjA0LjgtNTEuMiAxMDIuNC0xNTMuNi0yMDQuOHpNODE5LjIgMjA0LjhsNTEuMiAxMDIuNC0yMDQuOCA0MDkuNi01MS4yLTEwMi40IDIwNC44LTQwOS42eiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE0xNTMuNiA3MTYuOGMtODcuMDQgMC0xNTMuNiA2Ni41Ni0xNTMuNiAxNTMuNnM2Ni41NiAxNTMuNiAxNTMuNiAxNTMuNiAxNTMuNi02Ni41NiAxNTMuNi0xNTMuNi02Ni41Ni0xNTMuNi0xNTMuNi0xNTMuNnogbTUxLjIgMjA0LjhIMTAyLjR2LTEwMi40aDEwMi40djEwMi40ek00MDkuNiAyMDQuOEMzMjIuNTYgMjA0LjggMjU2IDI3MS4zNiAyNTYgMzU4LjRzNjYuNTYgMTUzLjYgMTUzLjYgMTUzLjYgMTUzLjYtNjYuNTYgMTUzLjYtMTUzLjYtNjYuNTYtMTUzLjYtMTUzLjYtMTUzLjZ6IG01MS4yIDIwNC44SDM1OC40VjMwNy4yaDEwMi40djEwMi40ek02MTQuNCA2MTQuNGMtODcuMDQgMC0xNTMuNiA2Ni41Ni0xNTMuNiAxNTMuNnM2Ni41NiAxNTMuNiAxNTMuNiAxNTMuNiAxNTMuNi02Ni41NiAxNTMuNi0xNTMuNi02Ni41Ni0xNTMuNi0xNTMuNi0xNTMuNnogbTUxLjIgMjA0LjhoLTEwMi40di0xMDIuNGgxMDIuNHYxMDIuNHpNODcwLjQgMGMtODcuMDQgMC0xNTMuNiA2Ni41Ni0xNTMuNiAxNTMuNnM2Ni41NiAxNTMuNiAxNTMuNiAxNTMuNiAxNTMuNi02Ni41NiAxNTMuNi0xNTMuNi02Ni41Ni0xNTMuNi0xNTMuNi0xNTMuNnogbTUxLjIgMjA0LjhoLTEwMi40VjEwMi40aDEwMi40djEwMi40eicsXHJcbiAgICAgICAgQ1VSVkVfU1ZHOiAnTTEwMTQuMjg1MDM5IDgyNC4wMjQyMzRsLTE0NS4xNjg0MjgtMTQ0LjM3MjA1Yy0xMi45Njk1OTMtMTIuODU1ODI1LTM3LjU0MzU1OS0xNC41MDU0NjYtNDQuNTk3MTk3IDIuMzMyMjUyLTEuODc3MTc4IDQuNTUwNzM0LTIuMjc1MzY3IDE3LjE3OTAyMi0yLjI3NTM2OCAxNy4xNzkwMjJ2OTcuNTU2MzY5SDMzMC45MzUzODNhMTE4LjMxOTA5NSAxMTguMzE5MDk1IDAgMCAxLTExOC41NDY2MzItMTE3LjkyMDkwNUExMTguMzE5MDk1IDExOC4zMTkwOTUgMCAwIDEgMzMwLjk5MjI2NyA1NjAuODc4MDE2aDQ0NS41MTY4OTljMTIxLjU2MTQ5MyAwIDIyMC40MjYxOTgtOTguMzUyNzQ3IDIyMC40MjYxOTgtMjE5LjIzMTYzcy05OC44NjQ3MDUtMjE5LjE3NDc0Ni0yMjAuNDI2MTk4LTIxOS4xNzQ3NDZIMzQwLjQ5MTkyNUExNzQuMjM2MjQ0IDE3NC4yMzYyNDQgMCAwIDAgMTc0LjEwNTY5OCAwIDE3My43ODExNyAxNzMuNzgxMTcgMCAwIDAgMC4wNDAxMDcgMTczLjA5ODU2YTE3My43ODExNyAxNzMuNzgxMTcgMCAwIDAgMTc0LjA2NTU5MSAxNzMuMDk4NTYgMTc0LjIzNjI0NCAxNzQuMjM2MjQ0IDAgMCAwIDE2Ni4zODYyMjctMTIyLjQ3MTYzOWg0MzYuMDE3MjQxYzY1LjQxNjgwNyAwIDExOC42MDM1MTYgNTIuOTAyMjg4IDExOC42MDM1MTUgMTE3LjkyMDkwNUExMTguMzE5MDk1IDExOC4zMTkwOTUgMCAwIDEgNzc2LjUwOTE2NiA0NTkuNjI0MTc2SDMzMC45OTIyNjdjLTEyMS41MDQ2MDkgMC0yMjAuMzY5MzE0IDk4LjM1Mjc0Ny0yMjAuMzY5MzE0IDIxOS4yMzE2M3M5OC44NjQ3MDUgMjE5LjE3NDc0NiAyMjAuMzY5MzE0IDIxOS4xNzQ3NDZoNDkxLjE5NDg5NXY5Mi41NTA1NjFzMCAxNC4yMjEwNDUgMi4zMzIyNTIgMTkuNzk1Njk1YzcuMDUzNjM4IDE2Ljg5NDYwMiAzMS42Mjc2MDQgMTcuNTc3MjEyIDQ0LjU5NzE5NyA0LjY2NDUwMmwxNDUuMTExNTQzLTE0NC4zMTUxNjVhMzIuODc5MDU2IDMyLjg3OTA1NiAwIDAgMCAwLTQ2LjY0NTAyN3pNMTc0LjEwNTY5OCAyNDQuOTQzMjhjLTM5LjgxODkyNiAwLTcyLjI0MjkwOS0zMi4yNTMzMy03Mi4yNDI5MDktNzEuODQ0NzJzMzIuNDIzOTgzLTcxLjc4NzgzNSA3Mi4yNDI5MDktNzEuNzg3ODM1YzM5LjgxODkyNiAwIDcyLjE4NjAyNSAzMi4xOTY0NDYgNzIuMTg2MDI1IDcxLjc4NzgzNSAwIDM5LjU5MTM4OS0zMi40MjM5ODMgNzEuNzg3ODM1LTcyLjI0MjkwOSA3MS43ODc4MzZ6JyxcclxuICAgICAgICBERUxfU1ZHOiAnTTk4MC45OTIgMjU2aC04NC45OTJ2NjgzLjAwOGMwIDQ3LjEwNC0zNy44ODggODQuOTkyLTg0Ljk5MiA4NC45OTJIMjEyLjk5MmMtNDcuMTA0IDAtODQuOTkyLTM3Ljg4OC04NC45OTItODQuOTkyVjI1Nkg0My4wMDhDMTkuNDU2IDI1NiAwIDIzNi41NDQgMCAyMTIuOTkyYzAtMjMuNTUyIDE5LjQ1Ni00My4wMDggNDMuMDA4LTQzLjAwOEgyNTZWODQuOTkyQzI1NiAzNy44ODggMjkzLjg4OCAwIDM0MC45OTIgMGgzNDAuOTkyQzczMC4xMTIgMCA3NjggMzcuODg4IDc2OCA4NC45OTJ2ODQuOTkyaDIxNC4wMTZjMjMuNTUyIDAgNDMuMDA4IDE5LjQ1NiA0My4wMDggNDMuMDA4LTEuMDI0IDIzLjU1Mi0yMC40OCA0My4wMDgtNDQuMDMyIDQzLjAwOHpNNjgzLjAwOCA4NC45OTJIMzQwLjk5MnY4NC45OTJoMzQwLjk5MlY4NC45OTJ6TTIxMi45OTIgOTM5LjAwOGg1OTYuOTkyVjI1NkgyMTIuOTkydjY4My4wMDh6IG0xNzEuMDA4LTQ3MC4wMTZ2MjU2YzAgMjMuNTUyLTE5LjQ1NiA0My4wMDgtNDMuMDA4IDQzLjAwOC0yMy41NTIgMC00My4wMDgtMTkuNDU2LTQzLjAwOC00My4wMDh2LTI1NmMwLTIzLjU1MiAxOS40NTYtNDMuMDA4IDQzLjAwOC00My4wMDggMjMuNTUyIDEuMDI0IDQzLjAwOCAxOS40NTYgNDMuMDA4IDQzLjAwOHpNNTEyIDQyNy4wMDhjMjMuNTUyIDAgNDMuMDA4IDE5LjQ1NiA0My4wMDggNDMuMDA4djI1NmMwIDIzLjU1Mi0xOS40NTYgNDMuMDA4LTQzLjAwOCA0My4wMDgtMjMuNTUyIDAtNDMuMDA4LTE5LjQ1Ni00My4wMDgtNDMuMDA4di0yNTZjMC0yNC41NzYgMTkuNDU2LTQzLjAwOCA0My4wMDgtNDMuMDA4eiBtMTcxLjAwOCAwYzIzLjU1MiAwIDQzLjAwOCAxOS40NTYgNDMuMDA4IDQzLjAwOHYyNTZjMCAyMy41NTItMTkuNDU2IDQzLjAwOC00My4wMDggNDMuMDA4LTIzLjU1MiAwLTQzLjAwOC0xOS40NTYtNDMuMDA4LTQzLjAwOHYtMjU2YzAtMjQuNTc2IDE5LjQ1Ni00My4wMDggNDMuMDA4LTQzLjAwOHonLFxyXG4gICAgICAgIENPTU1FTlRfU1ZHOiAnTTIwOS45MiAxNTIuMDY0bDU3Mi40MTYgMS41MzZjMTIuOCAwIDIzLjA0IDEwLjI0IDIzLjA0IDIzLjA0djIzNy41NjhjMCAxMi44IDEwLjI0IDIzLjA0IDIzLjA0IDIzLjA0czIzLjA0LTEwLjI0IDIzLjA0LTIzLjA0VjEyNS40NGMwLTEyLjgtMTAuMjQtMjMuMDQtMjMuMDQtMjMuMDRIMTU4LjcyYy0xMi44IDAtMjMuMDQgMTAuMjQtMjMuMDQgMjMuMDR2NzczLjEyYzAgMTIuOCAxMC4yNCAyMy4wNCAyMy4wNCAyMy4wNGgyMzYuMDMyYzEyLjggMCAyMy4wNC0xMC4yNCAyMy4wNC0yMy4wNHMtMTAuMjQtMjIuNTI4LTIyLjUyOC0yMy4wNGwtMTg1Ljg1Ni0xLjUzNmMtMTIuOCAwLTIyLjUyOC0xMC4yNC0yMi41MjgtMjMuMDRWMTc0LjU5MmMwLTEyLjI4OCAxMC4yNC0yMi41MjggMjMuMDQtMjIuNTI4eiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTTI2OC44IDU3MC4zNjhoMTU5LjIzMmMxMy4zMTIgMCAyNC4wNjQgMTAuNzUyIDI0LjU3NiAyNC4wNjR2Mi41NmMwIDEzLjMxMi0xMC43NTIgMjQuNTc2LTI0LjU3NiAyNC41NzZIMjY4LjhjLTEzLjMxMiAwLTI0LjA2NC0xMC43NTItMjQuNTc2LTI0LjA2NHYtMi41NmMwLjUxMi0xMy4zMTIgMTEuMjY0LTI0LjU3NiAyNC41NzYtMjQuNTc2eiBtMC0zMTIuMzJoNDQxLjM0NGMxMy4zMTIgMCAyNC41NzYgMTAuNzUyIDI0LjU3NiAyNC41NzZ2Mi41NmMwIDEzLjMxMi0xMC43NTIgMjQuNTc2LTI0LjU3NiAyNC41NzZIMjY4LjhjLTEzLjMxMiAwLTI0LjU3Ni0xMC43NTItMjQuNTc2LTI0LjU3NnYtMi41NmMwLjUxMi0xMy4zMTIgMTEuMjY0LTI0LjU3NiAyNC41NzYtMjQuNTc2eiBtMC41MTIgMTU1LjY0OGgyNjkuMzEyYzEzLjMxMiAwIDI0LjU3NiAxMC43NTIgMjQuNTc2IDI0LjA2NHYyLjU2YzAgMTMuMzEyLTEwLjc1MiAyNC41NzYtMjQuNTc2IDI0LjU3NkgyNjkuMzEyYy0xMy4zMTIgMC0yNC41NzYtMTAuNzUyLTI0LjU3Ni0yNC4wNjR2LTIuNTZjMC0xMy44MjQgMTAuNzUyLTI0LjU3NiAyNC41NzYtMjQuNTc2eiBtNDcxLjA0IDEzLjMxMmwtMjQ2Ljc4NCAzMzkuNDU2Yy0xLjUzNiAyLjU2LTIuNTYgNS42MzItMi41NiA4LjcwNGwtMS41MzYgMTMyLjA5NmMwIDkuNzI4IDkuNzI4IDE2Ljg5NiAxOC45NDQgMTQuMzM2bDEyMi44OC0zNy44ODhjMy4wNzItMS4wMjQgNS42MzItMy4wNzIgNy42OC01LjYzMmwyNDYuNzg0LTMzOC45NDRjNC42MDgtNi4xNDQgMy41ODQtMTUuMzYtMi41Ni0xOS45NjhsLTEyMS4zNDQtOTQuNzJjLTcuMTY4LTUuNjMyLTE2Ljg5Ni00LjA5Ni0yMS41MDQgMi41NnogbTIzLjA0IDY3LjU4NGw1MS4yIDM5LjkzNmMyLjA0OCAxLjUzNiAyLjU2IDUuMTIgMS4wMjQgNy4xNjhsLTI2LjExMiAzNS44NGMtMS41MzYgMi41Ni01LjEyIDMuMDcyLTcuNjggMS4wMjRsLTUxLjcxMi0zOC45MTJjLTIuMDQ4LTEuNTM2LTIuNTYtNC42MDgtMS4wMjQtNy4xNjhsMjYuNjI0LTM3LjM3NmMyLjA0OC0xLjUzNiA1LjYzMi0yLjA0OCA3LjY4LTAuNTEyeiBtLTE2NS44ODggMzQxLjUwNGwtMzUuMzI4IDEwLjc1MmMtOS4yMTYgMy4wNzItMTguOTQ0LTQuMDk2LTE4Ljk0NC0xMy44MjRsMC41MTItNDAuOTZjMC0zLjA3MiAxLjAyNC02LjE0NCAyLjU2LTguNzA0bDEzNy4yMTYtMTg3LjkwNGMxLjUzNi0yLjU2IDUuMTItMi41NiA3LjE2OC0xLjAyNGw1MS4yIDM4LjRjMi41NiAyLjA0OCAzLjA3MiA1LjEyIDEuMDI0IDcuNjhsLTEzNy43MjggMTg5Ljk1MmMtMi4wNDggMi41Ni00LjYwOCA0LjYwOC03LjY4IDUuNjMyeicsXHJcbiAgICAgICAgQ0hBTkdFX0xJTkVfVFlQRV9TVkc6ICdNMTAwOCAzMzUuMiAxMDA4IDMzNS4ybC0xNjAgMTQ0IDAgMGMtOC44IDgtMjAgMTIuOC0zMiAxMi44LTI2LjQgMC00OC0yMS42LTQ4LTQ4IDAtMTQuNCA2LjQtMjYuNCAxNi0zNS4ybDAgMCA2Ny4yLTYwTDU2MCAzNDguOGMwIDAgMCAwIDAgMEw0NjQgMzQ4LjhsMCAwTDM1MiAzNDguOCA0OCAzNDguOGMtMjYuNCAwLTQ4LTIxLjYtNDgtNDggMC0yNi40IDIxLjYtNDggNDgtNDhsMTI0LjggMCAwIDBMNDE2IDI1Mi44bDAgMCAyMDggMCAwIDAgMjI3LjIgMEw3ODQgMTkybDAgMGMtOS42LTguOC0xNi0yMS42LTE2LTM1LjIgMC0yNi40IDIxLjYtNDggNDgtNDggMTIgMCAyMy4yIDQuOCAzMiAxMi44bDAgMCAxNjAgMTQ0IDAgMGM5LjYgOC44IDE2IDIxLjYgMTYgMzUuMkMxMDI0IDMxNC40IDEwMTcuNiAzMjYuNCAxMDA4IDMzNS4yek0xNiA2ODAuOCAxNiA2ODAuOGwxNjAtMTQ0IDAgMGM4LjgtOCAyMC0xMi44IDMyLTEyLjggMjYuNCAwIDQ4IDIxLjYgNDggNDggMCAxNC40LTYuNCAyNi40LTE2IDM1LjJsMCAwLTY3LjIgNjBMNDAwIDY2Ny4ybDAgMCAyMDggMCAwIDAgMjQzLjIgMCAwIDBMOTc2IDY2Ny4yYzI2LjQgMCA0OCAyMS42IDQ4IDQ4IDAgMjYuNC0yMS42IDQ4LTQ4IDQ4TDY3MiA3NjMuMiA1NjAgNzYzLjJjMCAwIDAgMCAwIDBMNDY0IDc2My4ybDAgMEwxNzIuOCA3NjMuMiAyNDAgODI0bDAgMGM5LjYgOC44IDE2IDIxLjYgMTYgMzUuMiAwIDI2LjQtMjEuNiA0OC00OCA0OC0xMiAwLTIzLjItNC44LTMyLTEyLjhsMCAwTDE2IDc1MmwwIDBjLTkuNi04LjgtMTYtMjEuNi0xNi0zNS4yQzAgNzAxLjYgNi40IDY4OS42IDE2IDY4MC44eidcclxuICAgIH1cclxuICAgIG1vZHVsZS5leHBvcnRzID0gSWNvbk9wZXJhdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvSWNvbk9wZXJhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBicG1u6L+e57q/566h55CG57G7XHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0Nvbm5lY3Rpb25NYW5hZ2VyLmpzXCIpO1xyXG4gICAgdmFyIEJQTU5Nb2RlbCA9IHJlcXVpcmUoXCIuLi9tb2RlbC9CUE1OTW9kZWwuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9Qb2ludC5qc1wiKTtcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEJwbW5Db25uZWN0aW9uTWFuYWdlcigpIHtcclxuICAgICAgICBDb25uZWN0aW9uTWFuYWdlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbFR5cGUgPSBcIlNlcXVlbmNlRmxvd1wiO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rov57nur9cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhcnROb2RlIFvlvIDlp4voioLngrldXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGVuZE5vZGUgICBb57uT5p2f6IqC54K5XVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSB0eXBlICAgICAgW+exu+Wei11cclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBbYXBpXSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICBb6L+U5Zue6L+e57q/XVxyXG4gICAgICovXHJcbiAgICBCcG1uQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3RvckNyZWF0ZSA9IGZ1bmN0aW9uKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgc3R5bGUsIGFwaSwgc3RhcnRQb3MsIGVuZFBvcykge1xyXG4gICAgICAgIHZhciBtb2RlbCA9IG5ldyBCUE1OTW9kZWwoe30pO1xyXG4gICAgICAgIG1vZGVsLnNldChcInJlc291cmNlSWRcIiwgdXRpbC5nZXRVVUlEKCkpO1xyXG4gICAgICAgIG1vZGVsLnNldChcInN0eWxlXCIsIHN0eWxlLnN0eWxlKTtcclxuICAgICAgICBtb2RlbC5zZXQoXCJzdGVuY2lsLnR5cGVcIiwgdGhpcy5zdGVuY2lsVHlwZSk7XHJcbiAgICAgICAgc3RhcnRQb3MgJiYgbW9kZWwuc2V0KFwic3R5bGUuc1Bvc1wiLCBzdGFydFBvcyk7XHJcbiAgICAgICAgZW5kUG9zICYmIG1vZGVsLnNldChcInN0eWxlLmVQb3NcIiwgZW5kUG9zKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yQ3JlYXRlQnlPcHRpb25zKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgeyBtb2RlbDogbW9kZWwsIGlzRWRpdDogdHJ1ZSwgc3R5bGU6IHN0eWxlfSwgYXBpKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja5vcGV0aW9ucy5tb2RlbCDlj43luo/liJfljJbnur9cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhcnROb2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZW5kTm9kZSAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gb3B0aW9ucyAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gYXBpICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQnBtbkNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0b3JDcmVhdGVCeU9wdGlvbnMgPSBmdW5jdGlvbihzdGFydE5vZGUsIGVuZE5vZGUsIG9wdGlvbnMsIGFwaSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgbW9kZWwgPSBvcHRpb25zLm1vZGVsO1xyXG4gICAgICAgIG1vZGVsLm9wdGlvbi50ZXh0ID0ge1xyXG4gICAgICAgICAgICB0ZXh0OiBtb2RlbC5vcHRpb24ucHJvcGVydGllcy5uYW1lXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9wdGlvbnMudGV4dCA9IHtcclxuICAgICAgICAgICAgdGV4dDogbW9kZWwub3B0aW9uLnByb3BlcnRpZXMubmFtZVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gbmV3IENvbm5lY3RvcihvcHRpb25zKTtcclxuICAgICAgICBjb25uZWN0b3Iuc3RhcnROb2RlID0gc3RhcnROb2RlO1xyXG4gICAgICAgIGNvbm5lY3Rvci5lbmROb2RlID0gZW5kTm9kZTtcclxuXHJcbiAgICAgICAgdGhpcy5jb25uZWN0b3JzLnB1c2goY29ubmVjdG9yKTtcclxuXHJcbiAgICAgICAgLy/liKTmlq3kuIDkuItzUG9zLGVQb3NcclxuICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbi5zdGFydFBvcyA9IG1vZGVsLmdldChcInN0eWxlLnNQb3NcIik7XHJcbiAgICAgICAgY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24uZW5kUG9zID0gbW9kZWwuZ2V0KFwic3R5bGUuZVBvc1wiKTtcclxuXHJcbiAgICAgICAgLy/liKTmlq3kuIDkuIsgbW9kZWzph4zmnInmsqHmnIlkb2NrZXJz77yM5aaC5p6c5pyJ5YiZ6LCD55So5p6E6YCgcG9pbnTmlbDnu4QgIOaIluiAheiwg+eUqHJlZnJlc2hDb25uZWN0b3LorqHnrpflpoLkvZXnlLvnur9cclxuICAgICAgICB2YXIgZG9ja2VycyA9IG1vZGVsLmdldChcImRvY2tlcnNcIik7XHJcbiAgICAgICAgaWYgKGRvY2tlcnMgJiYgZG9ja2Vycy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gUG9pbnQubG9hZEFycmF5KGRvY2tlcnMpO1xyXG4gICAgICAgICAgICBjb25uZWN0b3IucmVmcmVzaChwb2ludHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbm5lY3Rvcihjb25uZWN0b3IsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29ubmVjdG9yLmNvblBvaW50c0dyb3VwLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB2YXIgYXJyU3BsaXQgPSBlLnRhcmdldC50eXBlLnNwbGl0KENvbm5lY3Rvci5TRVBFUkFUT1IpO1xyXG4gICAgICAgICAgICB2YXIgY29ubmVjdG9yID0gZS50YXJnZXQuY29ubmVjdG9yO1xyXG4gICAgICAgICAgICBpZiAoYXJyU3BsaXRbMF0gPT09IENvbm5lY3Rvci5TVEFSVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24uc3RhcnRQb3MgPSBhcnJTcGxpdFsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcnJTcGxpdFswXSA9PT0gQ29ubmVjdG9yLkVORF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbi5lbmRQb3MgPSBhcnJTcGxpdFsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0LnJlZnJlc2hDb25uZWN0b3IoY29ubmVjdG9yLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcImNvblBvaW50c0dyb3VwOmNsaWNrXCI7XHJcbiAgICAgICAgICAgIHBhcmFtcy5saW5lTm9kZSA9IHRoYXQuc2VsQ29ubmVjdG9yO1xyXG4gICAgICAgICAgICBhcGkudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnZGJsY2xpY2snLCAnY2xpY2snXTtcclxuICAgICAgICB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24oZXZlTmFtZSkge1xyXG4gICAgICAgICAgICBjb25uZWN0b3Iub24oXCJDb25uZWN0b3I6XCIgKyBldmVOYW1lLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBlLnRhcmdldDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5zZWxDb25uZWN0b3IgIT09IHNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZWxDb25uZWN0b3IgJiYgdGhhdC5yZWZyZXNoQ29ubmVjdG9yKHRoYXQuc2VsQ29ubmVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbENvbm5lY3RvciA9IHNlbGVjdGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IGV2ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhhdC5zZWxDb25uZWN0b3I7XHJcbiAgICAgICAgICAgICAgICBhcGkudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFvcHRpb25zLmlzRnJvbU1vZGVsKSB7XHJcbiAgICAgICAgICAgIC8vMS7orr7nva7otbflp4voioLngrnnmoRvdXRnb2luZ+aVsOe7hCDkuLrnur/mrrXnmoRJRFxyXG4gICAgICAgICAgICB2YXIgc3RhcnROb2RlT3V0Z29pbmcgPSBzdGFydE5vZGUubW9kZWwuZ2V0KFwib3V0Z29pbmdcIik7XHJcbiAgICAgICAgICAgIHN0YXJ0Tm9kZU91dGdvaW5nLnB1c2goY29ubmVjdG9yLnJlc291cmNlSWQpO1xyXG4gICAgICAgICAgICAvLzIu6K6+572u57q/5q6155qEb3V0Z29pbmfmlbDnu4Qg5Li657uT5p2f6IqC54K555qESURcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3Rvck91dGdvaW5nID0gY29ubmVjdG9yLm1vZGVsLmdldChcIm91dGdvaW5nXCIpO1xyXG4gICAgICAgICAgICBjb25uZWN0b3JPdXRnb2luZy5wdXNoKGVuZE5vZGUucmVzb3VyY2VJZCk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuvue9rue6v+auteeahOaooeWei+aVsOaNriAgKOexu+WeiyDmloflrZcpXHJcbiAgICAgKiBAcGFyYW0ge1t0eXBlXX0gY29ubmVjdG9yIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBvcHRpb24gICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBCcG1uQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldE1vZGVsID0gZnVuY3Rpb24oY29ubmVjdG9yLCBvcHRpb24pIHtcclxuICAgICAgICB2YXIgb3JpZ2luTmFtZSA9IGNvbm5lY3Rvci5vcHRpb25zLnRleHQudGV4dDtcclxuICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy50ZXh0LnRleHQgPSBvcHRpb24ucHJvcGVydGllcy5uYW1lO1xyXG4gICAgICAgIGNvbm5lY3Rvci5tb2RlbC5tZXJnZU9wdGlvbihvcHRpb24pO1xyXG4gICAgICAgIC8v5paH5a2X5LiN5LiA6Ie05pe2XHJcbiAgICAgICAgaWYgKG9yaWdpbk5hbWUgIT0gb3B0aW9uLnByb3BlcnRpZXMubmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25uZWN0b3IoY29ubmVjdG9yLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWIoOmZpOaMh+WumueahOe6v1xyXG4gICAgICogQHBhcmFtIGNvbm5lY3RvciDmrLLliKDpmaTnmoTov57nur9cclxuICAgICAqIEBwYXJhbSBfenIgenJcclxuICAgICAqL1xyXG4gICAgQnBtbkNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVCeUxpbmUgPSBmdW5jdGlvbiAoY29ubmVjdG9yLF96cikge1xyXG4gICAgICAgIC8vMS7lsIbnur8g5omA6IGU55qEc3RhcnROb2Rl55qEb3V0Z29pbmfmlbDmja7liKDpmaRcclxuICAgICAgICBpZihjb25uZWN0b3Iuc3RhcnROb2RlKXtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZU91dGdvaW5nID0gY29ubmVjdG9yLnN0YXJ0Tm9kZS5tb2RlbC5nZXQoXCJvdXRnb2luZ1wiKTtcclxuICAgICAgICAgICAgaW5kZXggPSB6clV0aWwuaW5kZXhPZihzdGFydE5vZGVPdXRnb2luZywgY29ubmVjdG9yLnJlc291cmNlSWQpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZU91dGdvaW5nLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rvck1hcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0VHdvTm9kZUlkKGNvbm5lY3Rvci5zdGFydE5vZGUsIGNvbm5lY3Rvci5lbmROb2RlLCBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvck1hcC5yZW1vdmVJdGVtKGtleSwgY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vMi7ku45fenLkuIrliKDpmaRcclxuICAgICAgICBfenIucmVtb3ZlKGNvbm5lY3Rvcik7XHJcblxyXG5cclxuICAgICAgICAvLzMu5LuO57q/5pWw5o2u5Lit5Yig6ZmkXHJcbiAgICAgICAgdmFyIGluZGV4ID0genJVdGlsLmluZGV4T2YodGhpcy5jb25uZWN0b3JzLCBjb25uZWN0b3IpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsQ29ubmVjdG9yID09PSBjb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxDb25uZWN0b3IgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5Yi35paw6L+e5o6l57q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQnBtbkNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZWZyZXNoTGluZUJ5Tm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb25uZWN0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RvcnNbaV0uc3RhcnROb2RlID09IG5vZGUgfHwgdGhpcy5jb25uZWN0b3JzW2ldLmVuZE5vZGUgPT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ubmVjdG9yKHRoaXMuY29ubmVjdG9yc1tpXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKEJwbW5Db25uZWN0aW9uTWFuYWdlciwgQ29ubmVjdGlvbk1hbmFnZXIpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQnBtbkNvbm5lY3Rpb25NYW5hZ2VyO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL21hbmFnZXIvQnBtbkNvbm5lY3Rpb25NYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOi/nue6v+euoeeQhuexu1xyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuICAgIHZhciBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIExvZyA9IHJlcXVpcmUoXCIuLi9Mb2cuanNcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblxyXG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvbk1hbmFnZXIoKSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0b3JzID0gW107IC8v5b2T5YmN55S75biD5omA5pyJ55qE57q/5q61XHJcbiAgICAgICAgdGhpcy5zZWxDb25uZWN0b3IgPSBudWxsOyAvL+W9k+WJjemAieS4reeahOe6v+autVxyXG4gICAgICAgIHRoaXMudGVtcENvbm5lY3RvciA9IG51bGw7IC8v5Li05pe257q/5q61XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7nur/nmoTkuI3lj6/nvJbovpFcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZm9yYmlkRWRpdCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdG9yRm9yYmlkRWRpdCA9IGZ1bmN0aW9uIChmb3JiaWRFZGl0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbm5lY3RvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzW2ldLm9wdGlvbnMuaXNFZGl0ID0gIWZvcmJpZEVkaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3JiaWRFZGl0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29ubmVjdG9yRXZlbnRMaXN0ZW5lcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOenu+mZpOe6v+adoeebkeWQrOS6i+S7tlxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlQ29ubmVjdG9yRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0b3JzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzLmZvckVhY2goZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IucG9seUxpbmUub2ZmKCdtb3VzZW92ZXInKTtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5wb2x5TGluZS5vZmYoJ21vdXNlbW92ZScpO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLnBvbHlMaW5lLm9mZignbW91c2VvdXQnKTtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5jdXJ2ZUxpbmUub2ZmKCdtb3VzZW92ZXInKTtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5jdXJ2ZUxpbmUub2ZmKCdtb3VzZW1vdmUnKTtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5jdXJ2ZUxpbmUub2ZmKCdtb3VzZW91dCcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5riF56m66L+e5o6l57q/5LiK55qE6LCD5pW05L2N572u5oyJ6ZKuXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsZWFyU2VsZWN0Q29uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlbENvbm5lY3RvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbm5lY3Rvcih0aGlzLnNlbENvbm5lY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDliKDpmaTlkozoioLngrnnm7jlhbPogZTnmoTov57mjqXnur9cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlU2VsZWN0Q29uID0gZnVuY3Rpb24gKG5vZGUsIF96cikge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25uZWN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RvcnNbaV0uc3RhcnROb2RlID09IG5vZGUgfHwgdGhpcy5jb25uZWN0b3JzW2ldLmVuZE5vZGUgPT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgLy8xLuWwhue6vyDmiYDogZTnmoRzdGFydE5vZGXnmoRvdXRnb2luZ+aVsOaNruWIoOmZpFxyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZU91dGdvaW5nID0gdGhpcy5jb25uZWN0b3JzW2ldLnN0YXJ0Tm9kZS5tb2RlbC5nZXQoXCJvdXRnb2luZ1wiKTtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHpyVXRpbC5pbmRleE9mKHN0YXJ0Tm9kZU91dGdvaW5nLCB0aGlzLmNvbm5lY3RvcnNbaV0ucmVzb3VyY2VJZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGVPdXRnb2luZy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8yLuS7jl96cuS4iuWIoOmZpFxyXG4gICAgICAgICAgICAgICAgX3pyLnJlbW92ZSh0aGlzLmNvbm5lY3RvcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsQ29ubmVjdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVMaW5lID0gZnVuY3Rpb24gKGxpbmUsIHpyKSB7XHJcbiAgICAgICAgdGhpcy5zZWxDb25uZWN0b3IgPSBsaW5lO1xyXG4gICAgICAgIHRoaXMuZGVsZXRlTGluZSh6cik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWIoOmZpOmAieWumueahOe6v1xyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVMaW5lID0gZnVuY3Rpb24gKF96cikge1xyXG4gICAgICAgIC8vMS7lsIbnur8g5omA6IGU55qEc3RhcnROb2Rl55qEb3V0Z29pbmfmlbDmja7liKDpmaRcclxuICAgICAgICBpZih0aGlzLnNlbENvbm5lY3Rvci5zdGFydE5vZGUpe1xyXG4gICAgICAgICAgICB2YXIgc3RhcnROb2RlT3V0Z29pbmcgPSB0aGlzLnNlbENvbm5lY3Rvci5zdGFydE5vZGUubW9kZWwuZ2V0KFwib3V0Z29pbmdcIik7XHJcbiAgICAgICAgICAgIGluZGV4ID0genJVdGlsLmluZGV4T2Yoc3RhcnROb2RlT3V0Z29pbmcsIHRoaXMuc2VsQ29ubmVjdG9yLnJlc291cmNlSWQpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZU91dGdvaW5nLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rvck1hcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0VHdvTm9kZUlkKHRoaXMuc2VsQ29ubmVjdG9yLnN0YXJ0Tm9kZSwgdGhpcy5zZWxDb25uZWN0b3IuZW5kTm9kZSwgdGhpcy5zZWxDb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvck1hcC5yZW1vdmVJdGVtKGtleSwgdGhpcy5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8yLuS7jl96cuS4iuWIoOmZpFxyXG4gICAgICAgIF96ci5yZW1vdmUodGhpcy5zZWxDb25uZWN0b3IpO1xyXG5cclxuXHJcbiAgICAgICAgLy8zLuS7jue6v+aVsOaNruS4reWIoOmZpFxyXG4gICAgICAgIHZhciBpbmRleCA9IHpyVXRpbC5pbmRleE9mKHRoaXMuY29ubmVjdG9ycywgdGhpcy5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWxDb25uZWN0b3IgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6YeN5paw55S757q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNvbm5lY3RvciAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGZvcmNlXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZWZyZXNoQ29ubmVjdG9yID0gZnVuY3Rpb24gKGNvbm5lY3RvciwgZm9yY2UpIHtcclxuICAgICAgICAvLyDlj6rmnInpnIDopoHlvLrliLbliLfmlrAgIOaIluiAhSDov57nur/kuLrnqbrvvIg8Minml7Yg5omN6L+b6KGM6YeN5paw6K6h566X6YeN57uYXHJcbiAgICAgICAgaWYgKGZvcmNlIHx8ICghY29ubmVjdG9yLnR1cm5pbmdQb2ludHMpIHx8IChjb25uZWN0b3IudHVybmluZ1BvaW50cy5sZW5ndGggPCAyKSkge1xyXG4gICAgICAgICAgICBpZiAoY29ubmVjdG9yLm1vZGVsICYmIGNvbm5lY3Rvci5tb2RlbC5nZXQoXCJzdHlsZS5saW5lVHlwZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPSBjb25uZWN0b3IubW9kZWwuZ2V0KFwic3R5bGUubGluZVR5cGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFyclN0YXJ0RW5kUG9pbnQgPSB0aGlzLmdldFN0YXJ0RW5kUG9pbnQoY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgdmFyIGVzY2FwZURpc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uICYmIGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uLmVzY2FwZURpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBlc2NhcGVEaXN0YW5jZSA9IGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uLmVzY2FwZURpc3RhbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzb2x1dGlvbnMgPSB0aGlzLmNvbm5lY3RvcjJQb2ludHMoY29ubmVjdG9yLm9wdGlvbnMuc3R5bGUubGluZVR5cGUsIGFyclN0YXJ0RW5kUG9pbnRbMF0sXHJcbiAgICAgICAgICAgICAgICBhcnJTdGFydEVuZFBvaW50WzFdLFxyXG4gICAgICAgICAgICAgICAgYXJyU3RhcnRFbmRQb2ludFsyXSwgYXJyU3RhcnRFbmRQb2ludFszXSwgZXNjYXBlRGlzdGFuY2UpOyAvLyBUWVBFX1NUUkFJR0hUIFRZUEVfSkFHR0VEXHJcblxyXG4gICAgICAgICAgICBjb25uZWN0b3IucmVmcmVzaChzb2x1dGlvbnNbMF1bMl0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29ubmVjdG9yLmNsZWFySGFuZGxlcygpOyAvL+a4heepumhhbmRsZVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0U3RhcnRFbmRQb2ludCA9IGZ1bmN0aW9uIChjb25uZWN0b3IpIHtcclxuICAgICAgICB2YXIgc3RhcnROb2RlID0gY29ubmVjdG9yLnN0YXJ0Tm9kZTtcclxuICAgICAgICB2YXIgZW5kTm9kZSA9IGNvbm5lY3Rvci5lbmROb2RlO1xyXG4gICAgICAgIHZhciBpc05vdEluU2FtZUdyb3VwID0gdHJ1ZTtcclxuICAgICAgICBpc05vdEluU2FtZUdyb3VwID0gc3RhcnROb2RlLnBhcmVudCAhPT0gZW5kTm9kZS5wYXJlbnQ7XHJcblxyXG4gICAgICAgIHZhciBzUmVjdCA9IFV0aWwuZ2V0UmVjdChzdGFydE5vZGUsIGlzTm90SW5TYW1lR3JvdXApLmJvdW5kaW5nUmVjdDtcclxuICAgICAgICB2YXIgc0JvdW5kcyA9IFtOdW1iZXIoc1JlY3QueCksIE51bWJlcihzUmVjdC55KSwgTnVtYmVyKHNSZWN0LngpICsgTnVtYmVyKHNSZWN0LndpZHRoKSwgTnVtYmVyKFxyXG4gICAgICAgICAgICBzUmVjdC55KSArIE51bWJlcihzUmVjdC5oZWlnaHQpXTtcclxuXHJcbiAgICAgICAgdmFyIGVSZWN0ID0gVXRpbC5nZXRSZWN0KGVuZE5vZGUsIGlzTm90SW5TYW1lR3JvdXApLmJvdW5kaW5nUmVjdDtcclxuICAgICAgICB2YXIgZUJvdW5kcyA9IFtOdW1iZXIoZVJlY3QueCksIE51bWJlcihlUmVjdC55KSwgTnVtYmVyKGVSZWN0LngpICsgTnVtYmVyKGVSZWN0LndpZHRoKSwgTnVtYmVyKFxyXG4gICAgICAgICAgICBlUmVjdC55KSArIE51bWJlcihlUmVjdC5oZWlnaHQpXTtcclxuXHJcblxyXG4gICAgICAgIHZhciBzQ29ubmVjdG9yUG9pbnQgPSBVdGlsLmdldENvbm5lY3RvclBvaW50cyhzUmVjdCwgc3RhcnROb2RlKTtcclxuICAgICAgICB2YXIgZUNvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoZVJlY3QsIGVuZE5vZGUpO1xyXG5cclxuICAgICAgICAvL+WIpOaWreWmguaenOayoeacieaMh+WumuS9jee9rueahOivnSwg5Yik5pat5byA5aeL6IqC54K55Zyo57uT5p2f57uT5p6c5bem6L655YiZ6YeH55SoIHJpZ2h0LWxlZnQg5ZCm5YiZ6YeH55SobGVmdC1yaWdodFxyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uO1xyXG4gICAgICAgIGlmIChwb3NpdGlvbi5kaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIHBvc0FyciA9IHBvc2l0aW9uLmRpcmVjdGlvbi5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydFBvcyA9IHBvc0FyclswXTtcclxuICAgICAgICAgICAgcG9zaXRpb24uZW5kUG9zID0gcG9zQXJyWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXBvc2l0aW9uLnN0YXJ0UG9zIHx8ICFwb3NpdGlvbi5lbmRQb3MpIHtcclxuICAgICAgICAgICAgaWYgKHNSZWN0LnggPCBlUmVjdC54KSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5zdGFydFBvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLmVuZFBvcyA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc3RhcnRQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLmVuZFBvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhcnRQb2ludCA9IHRoaXMuY2FsY1BvaW50RXhwcmVzc2lvbihwb3NpdGlvbi5zdGFydFBvcywgc0Nvbm5lY3RvclBvaW50KTtcclxuICAgICAgICB2YXIgZW5kUG9pbnQgPSB0aGlzLmNhbGNQb2ludEV4cHJlc3Npb24ocG9zaXRpb24uZW5kUG9zLCBlQ29ubmVjdG9yUG9pbnQpO1xyXG4gICAgICAgIHN0YXJ0UG9pbnQuYWRkKG5ldyBQb2ludChwb3NpdGlvbi5zdGFydE9mZnNldFswXSwgcG9zaXRpb24uc3RhcnRPZmZzZXRbMV0pKTtcclxuICAgICAgICBlbmRQb2ludC5hZGQobmV3IFBvaW50KHBvc2l0aW9uLmVuZE9mZnNldFswXSwgcG9zaXRpb24uZW5kT2Zmc2V0WzFdKSk7XHJcbiAgICAgICAgcmV0dXJuIFtzdGFydFBvaW50LCBlbmRQb2ludCwgc0JvdW5kcywgZUJvdW5kc107XHJcbiAgICB9XHJcblxyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNhbGNQb2ludEV4cHJlc3Npb24gPSBmdW5jdGlvbiAocG9zLCBwb2ludCkge1xyXG4gICAgICAgIHZhciB2YXJpYWJsZSA9IHtcclxuICAgICAgICAgICAgdG9wOiBwb2ludC50b3AueCxcclxuICAgICAgICAgICAgbGVmdDogcG9pbnQubGVmdC55LFxyXG4gICAgICAgICAgICByaWdodDogcG9pbnQucmlnaHQueSxcclxuICAgICAgICAgICAgYm90dG9tOiBwb2ludC5ib3R0b20ueCxcclxuICAgICAgICAgICAgY2VudGVyOiBwb2ludC5jZW50ZXIueFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBleHByZXNzaW9uID0gXCI8JSBwcmludChcIiArIHBvcyArIFwiKSAlPlwiO1xyXG4gICAgICAgIHZhciB2YWwgPSBwYXJzZUludChVdGlsLnRlbXBsYXRlKGV4cHJlc3Npb24pKHZhcmlhYmxlKSk7XHJcbiAgICAgICAgaWYgKHBvcy5pbmRleE9mKFwidG9wXCIpICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodmFsLCBwb2ludC50b3AueSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwb3MuaW5kZXhPZihcImxlZnRcIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwb2ludC5sZWZ0LngsIHZhbCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwb3MuaW5kZXhPZihcInJpZ2h0XCIpICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocG9pbnQucmlnaHQueCwgdmFsKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwiYm90dG9tXCIpICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodmFsLCBwb2ludC5ib3R0b20ueSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwb3MuaW5kZXhPZihcImNlbnRlclwiKSAhPSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHZhbCwgcG9pbnQuYm90dG9tLnkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBvc+WPguaVsOmUmeivr1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rmiJbkv67mlLnkuLTml7bnur9cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhcnROb2RlICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gckVuZFBvaW50ICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbGluZVR5cGUgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhcnRQb3MgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm1hbmFnZVRlbXBDb25uZWN0b3IgPSBmdW5jdGlvbiAoc3RhcnROb2RlLCByRW5kUG9pbnQsIGxpbmVUeXBlLCBzdGFydFBvcywgZW5kUG9zLCBlbmROb2RlKSB7XHJcbiAgICAgICAgdmFyIGVSZWN0ID0gbnVsbDtcclxuICAgICAgICB2YXIgZUJvdW5kcyA9IG51bGw7XHJcbiAgICAgICAgdmFyIHNSZWN0ID0gVXRpbC5nZXRSZWN0KHN0YXJ0Tm9kZSwgdHJ1ZSkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgIHZhciBzQm91bmRzID0gW051bWJlcihzUmVjdC54KSwgTnVtYmVyKHNSZWN0LnkpLCBOdW1iZXIoc1JlY3QueCkgKyBOdW1iZXIoc1JlY3Qud2lkdGgpLCBOdW1iZXIoXHJcbiAgICAgICAgICAgIHNSZWN0LnkpICsgTnVtYmVyKHNSZWN0LmhlaWdodCldO1xyXG5cclxuICAgICAgICB2YXIgc0Nvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoc1JlY3QsIHN0YXJ0Tm9kZSk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy50ZW1wQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGVtcENvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Ioe1xyXG4gICAgICAgICAgICAgICAgaXNFZGl0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZVR5cGU6IGxpbmVUeXBlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IHRoaXMudGVtcENvbm5lY3RvcjtcclxuICAgICAgICAvL+WIpOaWreWmguaenOayoeacieaMh+WumuS9jee9rueahOivnSwg5Yik5pat5byA5aeL6IqC54K55Zyo57uT5p2f57uT5p6c5bem6L655YiZ6YeH55SoIHJpZ2h0LWxlZnQg5ZCm5YiZ6YeH55SobGVmdC1yaWdodFxyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uO1xyXG4gICAgICAgIHBvc2l0aW9uLnN0YXJ0UG9zID0gc3RhcnRQb3MgPyBzdGFydFBvcyA6IChzUmVjdC54IDwgckVuZFBvaW50LnggPyBcInJpZ2h0XCIgOiBcImxlZnRcIik7XHJcbiAgICAgICAgcG9zaXRpb24uZW5kUG9zID0gZW5kUG9zID8gZW5kUG9zIDogKHNSZWN0LnggPCByRW5kUG9pbnQueCA/IFwibGVmdFwiIDogXCJyaWdodFwiKTtcclxuXHJcbiAgICAgICAgY29ubmVjdG9yLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPSBsaW5lVHlwZTtcclxuICAgICAgICBpZiAoZW5kTm9kZSkge1xyXG4gICAgICAgICAgICBlUmVjdCA9IFV0aWwuZ2V0UmVjdChlbmROb2RlLCB0cnVlKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgICAgIGVCb3VuZHMgPSBbTnVtYmVyKGVSZWN0LngpLCBOdW1iZXIoZVJlY3QueSksIE51bWJlcihlUmVjdC54KSArIE51bWJlcihlUmVjdC53aWR0aCksIE51bWJlcihcclxuICAgICAgICAgICAgICAgIGVSZWN0LnkpICsgTnVtYmVyKGVSZWN0LmhlaWdodCldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc29sdXRpb25zID0gdGhpcy5jb25uZWN0b3IyUG9pbnRzKGxpbmVUeXBlLCBzQ29ubmVjdG9yUG9pbnRbcG9zaXRpb24uc3RhcnRQb3NdLCByRW5kUG9pbnQsXHJcbiAgICAgICAgICAgIHNCb3VuZHMsIGVCb3VuZHMpOyAvLyBUWVBFX1NUUkFJR0hUIFRZUEVfSkFHR0VEXHJcblxyXG4gICAgICAgIGNvbm5lY3Rvci5yZWZyZXNoKHNvbHV0aW9uc1swXVsyXSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uuaIluS/ruaUueS4tOaXtuWPjei9rOe6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFydFBvaW50ICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGVuZE5vZGUgICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbGluZVR5cGUgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBlbmRQb3MgICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm1hbmFnZVJldmVyc2VUZW1wQ29ubmVjdG9yID0gZnVuY3Rpb24gKHN0YXJ0UG9pbnQsIGVuZE5vZGUsIGxpbmVUeXBlLCBlbmRQb3MsIHN0YXJ0UG9zLCBzdGFydE5vZGUpIHtcclxuICAgICAgICB2YXIgc1JlY3QgPSBudWxsO1xyXG4gICAgICAgIHZhciBzQm91bmRzID0gbnVsbDtcclxuICAgICAgICB2YXIgZVJlY3QgPSBVdGlsLmdldFJlY3QoZW5kTm9kZSwgdHJ1ZSkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgIHZhciBlQm91bmRzID0gW051bWJlcihlUmVjdC54KSwgTnVtYmVyKGVSZWN0LnkpLCBOdW1iZXIoZVJlY3QueCkgKyBOdW1iZXIoZVJlY3Qud2lkdGgpLCBOdW1iZXIoZVJlY3QueSkgKyBOdW1iZXIoZVJlY3QuaGVpZ2h0KV07XHJcbiAgICAgICAgdmFyIGVDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKGVSZWN0LCBlbmROb2RlKTtcclxuICAgICAgICBpZiAoIXRoaXMudGVtcENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBDb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKHtcclxuICAgICAgICAgICAgICAgIGlzRWRpdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVUeXBlOiBsaW5lVHlwZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IHRoaXMudGVtcENvbm5lY3RvcjtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbjtcclxuICAgICAgICBwb3NpdGlvbi5lbmRQb3MgPSBlbmRQb3MgPyBlbmRQb3MgOiAoZVJlY3QueCA8IHN0YXJ0UG9pbnQueCA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTtcclxuICAgICAgICBwb3NpdGlvbi5zdGFydFBvcyA9IHN0YXJ0UG9zID8gc3RhcnRQb3MgOiAoZVJlY3QueCA8IHN0YXJ0UG9pbnQueCA/IFwibGVmdFwiIDogXCJyaWdodFwiKTtcclxuXHJcbiAgICAgICAgY29ubmVjdG9yLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPSBsaW5lVHlwZTtcclxuICAgICAgICBpZiAoc3RhcnROb2RlKSB7XHJcbiAgICAgICAgICAgIHNSZWN0ID0gVXRpbC5nZXRSZWN0KHN0YXJ0Tm9kZSwgdHJ1ZSkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgICAgICBzQm91bmRzID0gW051bWJlcihzUmVjdC54KSwgTnVtYmVyKHNSZWN0LnkpLCBOdW1iZXIoc1JlY3QueCkgKyBOdW1iZXIoc1JlY3Qud2lkdGgpLCBOdW1iZXIoXHJcbiAgICAgICAgICAgIHNSZWN0LnkpICsgTnVtYmVyKHNSZWN0LmhlaWdodCldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc29sdXRpb25zID0gdGhpcy5jb25uZWN0b3IyUG9pbnRzKGxpbmVUeXBlLCBzdGFydFBvaW50LCBlQ29ubmVjdG9yUG9pbnRbcG9zaXRpb24uZW5kUG9zXSxcclxuICAgICAgICAgICAgc0JvdW5kcywgZUJvdW5kcyk7IC8vIFRZUEVfU1RSQUlHSFQgVFlQRV9KQUdHRURcclxuXHJcbiAgICAgICAgY29ubmVjdG9yLnJlZnJlc2goc29sdXRpb25zWzBdWzJdKTtcclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yig6Zmk5Li05pe257q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHpyICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZVRlbXBDb25uZWN0b3IgPSBmdW5jdGlvbiAoenIpIHtcclxuICAgICAgICBpZiAodGhpcy50ZW1wQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHpyLnJlbW92ZSh0aGlzLnRlbXBDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBDb25uZWN0b3IgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnrpflh7og5Lik5Liq6IqC54K5IOaMh+WumuS4pOS4queCueWmguS9leiBlOe6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSB0eXBlICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhcnRQb2ludCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGVuZFBvaW50ICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzQm91bmRzICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZUJvdW5kcyAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdG9yMlBvaW50cyA9IGZ1bmN0aW9uICh0eXBlLCBzdGFydFBvaW50LCBlbmRQb2ludCwgc0JvdW5kcywgZUJvdW5kcyxcclxuICAgICAgICBlc2NhcGVEaXN0YW5jZSkge1xyXG4gICAgICAgIHZhciBmaWd1cmVFc2NhcGVEaXN0YW5jZSA9IFszMCwgMzBdO1xyXG4gICAgICAgIGlmIChlc2NhcGVEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGVzY2FwZURpc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgZmlndXJlRXNjYXBlRGlzdGFuY2UgPSBbZXNjYXBlRGlzdGFuY2UsIGVzY2FwZURpc3RhbmNlXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZpZ3VyZUVzY2FwZURpc3RhbmNlID0gZXNjYXBlRGlzdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIExvZy5ncm91cChcImNvbm5lY3Rpb25NYW5hZ2VyOiBjb25uZWN0b3IyUG9pbnRzXCIpO1xyXG5cclxuXHJcbiAgICAgICAgTG9nLmluZm8oXCJDb25uZWN0aW9uTWFuYWdlcjogY29ubmVjdG9yMlBvaW50cyAoXCIgKyB0eXBlICsgXCIsIFwiICsgc3RhcnRQb2ludCArIFwiLCBcIiArIGVuZFBvaW50ICtcclxuICAgICAgICAgICAgXCIsIFwiICsgc0JvdW5kcyArIFwiLCBcIiArIGVCb3VuZHMgKyAnKScpO1xyXG4gICAgICAgIHZhciBzb2x1dGlvbnMgPSBbXTtcclxuXHJcblxyXG5cclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBDb25uZWN0b3IuVFlQRV9DSEFJTjpcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQ6IC8v55u057q/XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW3N0YXJ0UG9pbnQuY2xvbmUoKSwgZW5kUG9pbnQuY2xvbmUoKV07XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3N0cmFpZ2h0JywgJ3N0cmFpZ2h0JywgcG9pbnRzXSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29ubmVjdG9yLlRZUEVfQ1VSVkU6IC8v5puy57q/XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbm5lY3Rvci5UWVBFX0pBR0dFRDogLy/mipjnur9cclxuICAgICAgICAgICAgICAgIHZhciBzdGFydEV4aXRQb2ludCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kRXhpdFBvaW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgc3RhcnQgZXhpdCBwb2ludCAg5a+75om+5byA5aeL5Ye65Y+jXHJcbiAgICAgICAgICAgICAgICBpZiAoc0JvdW5kcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvdGVudGlhbEV4aXRzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KHN0YXJ0UG9pbnQueCwgc0JvdW5kc1sxXSAtIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzBdKSk7IC8vbm9ydGgg5YyXXHJcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoc0JvdW5kc1syXSArIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzBdLCBzdGFydFBvaW50LnkpKTsgLy9lYXN0ICDkuJxcclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChzdGFydFBvaW50LngsIHNCb3VuZHNbM10gKyBmaWd1cmVFc2NhcGVEaXN0YW5jZVswXSkpOyAvL3NvdXRoICDljZdcclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChzQm91bmRzWzBdIC0gZmlndXJlRXNjYXBlRGlzdGFuY2VbMF0sIHN0YXJ0UG9pbnQueSkpOyAvL3dlc3QgIOilv1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3BpY2sgY2xvc2VzdCBleGl0IHBvaW50ICDlr7vmib7kuI4gc3RhcnRQb2ludCDmnIDpnaDov5HnmoTlh7rlj6PngrlcclxuICAgICAgICAgICAgICAgICAgICBzdGFydEV4aXRQb2ludCA9IHBvdGVudGlhbEV4aXRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG90ZW50aWFsRXhpdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWwuZGlzdGFuY2Uoc3RhcnRQb2ludCwgcG90ZW50aWFsRXhpdHNbaV0pIDwgVXRpbC5kaXN0YW5jZShzdGFydFBvaW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RXhpdFBvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRFeGl0UG9pbnQgPSBwb3RlbnRpYWxFeGl0c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9maW5kIGVuZCBleGl0IHBvaW50ICDlr7vmib7nu5PmnZ/lh7rlj6NcclxuICAgICAgICAgICAgICAgIGlmIChlQm91bmRzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG90ZW50aWFsRXhpdHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoZW5kUG9pbnQueCwgZUJvdW5kc1sxXSAtIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzFdKSk7IC8vbm9ydGhcclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChlQm91bmRzWzJdICsgZmlndXJlRXNjYXBlRGlzdGFuY2VbMV0sIGVuZFBvaW50LnkpKTsgLy9lYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoZW5kUG9pbnQueCwgZUJvdW5kc1szXSArIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzFdKSk7IC8vc291dGhcclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChlQm91bmRzWzBdIC0gZmlndXJlRXNjYXBlRGlzdGFuY2VbMV0sIGVuZFBvaW50LnkpKTsgLy93ZXN0XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcGljayBjbG9zZXN0IGV4aXQgcG9pbnQgIOWvu+aJvuS4jiBlbmRQb2ludCDmnIDpnaDov5HnmoTlh7rlj6PngrlcclxuICAgICAgICAgICAgICAgICAgICBlbmRFeGl0UG9pbnQgPSBwb3RlbnRpYWxFeGl0c1swXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvdGVudGlhbEV4aXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChVdGlsLmRpc3RhbmNlKGVuZFBvaW50LCBwb3RlbnRpYWxFeGl0c1tpXSkgPCBVdGlsLmRpc3RhbmNlKGVuZFBvaW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEV4aXRQb2ludCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEV4aXRQb2ludCA9IHBvdGVudGlhbEV4aXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vQmFzaWMgc29sdXRpb24g5pyA5Z+65pys55qE6Kej5Yaz5pa55qGIICAg5Li65YW25LuW6Kej5Yaz5pa55qGI5YGa5YeG5aSHXHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IFtzdGFydFBvaW50XTtcclxuICAgICAgICAgICAgICAgIHZhciBnYXBJbmRleCA9IDA7IC8vdGhlIGluZGV4IG9mIHRoZSBnYXAgKHdoZXJlIGRvIHdlIG5lZWQgdG8gaW5zZXJ0IG5ldyBwb2ludHMpIERPIE5PVCBDSEFOR0UgSVRcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydEV4aXRQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHMucHVzaChzdGFydEV4aXRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FwSW5kZXggPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVuZEV4aXRQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHMucHVzaChlbmRFeGl0UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcy5wdXNoKGVuZFBvaW50KTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vU08gLSBubyBhZGRpdGlvbmFsIHBvaW50cyAgICAgUzAg6Kej5Yaz5pa55qGIIOS4jea3u+WKoOS7u+S9leeCuSAg5Z+65pys5LiN5Lya6KKr6YeH55SoXHJcbiAgICAgICAgICAgICAgICB2YXIgczAgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMCcsICdzMCcsIHMwXSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1MxICAgUzEg6Kej5Yaz5pa55qGIICDlj6rmnInkuIDkuKrmipjngrlcclxuICAgICAgICAgICAgICAgIHZhciBzMSA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9maXJzdCB2YXJpYW50ICAg56ys5LiA5Liq5Y+Y5L2TIHMxIHMxXzHmlrnmoYggIOaKmOe6v+eCueWcqCBzdGFydEV4aXRQb2ludOeahFgg5LiOIGVuZEV4aXRQb2ludOeahCBZ5L2N572uXHJcbiAgICAgICAgICAgICAgICB2YXIgczFfMSA9IFBvaW50LmNsb25lQXJyYXkoczEpO1xyXG4gICAgICAgICAgICAgICAgczFfMS5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBuZXcgUG9pbnQoczFfMVtnYXBJbmRleF0ueCwgczFfMVtnYXBJbmRleCArIDFdLnkpKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczEnLCAnczFfMScsIHMxXzFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3NlY29uZCB2YXJpYW50ICDnrKzkuozlj5jkvZMgczEgczEtMuaWueahiCAg5oqY57q/54K55ZyoIGVuZEV4aXRQb2ludOeahFgg5LiOICBzdGFydEV4aXRQb2ludOeahFnkvY3nva5cclxuICAgICAgICAgICAgICAgIHZhciBzMV8yID0gUG9pbnQuY2xvbmVBcnJheShzMSk7XHJcbiAgICAgICAgICAgICAgICBzMV8yLnNwbGljZShnYXBJbmRleCArIDEsIDAsIG5ldyBQb2ludChzMV8yW2dhcEluZGV4ICsgMV0ueCwgczFfMltnYXBJbmRleF0ueSkpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMScsICdzMV8yJywgczFfMl0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1MyICBTMiDop6PlhrPmlrnmoYggIOa3u+WKoOS4pOS4quaKmOeCuVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVmFyaWFudCBJICAgczJfMeaWueahiFxyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzEgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzFfMSA9IG5ldyBQb2ludCgoczJfMVtnYXBJbmRleF0ueCArIHMyXzFbZ2FwSW5kZXggKyAxXS54KSAvIDIsIHMyXzFbZ2FwSW5kZXhdLnkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzFfMiA9IG5ldyBQb2ludCgoczJfMVtnYXBJbmRleF0ueCArIHMyXzFbZ2FwSW5kZXggKyAxXS54KSAvIDIsIHMyXzFbZ2FwSW5kZXggKyAxXS55KTtcclxuICAgICAgICAgICAgICAgIHMyXzEuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfMV8xLCBzMl8xXzIpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl8xJywgczJfMV0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgSUkgIHMyXzHmlrnmoYggIDHmipjnur/ngrkgeDogc3RhcnRFeGl0UG9pbnTnmoRYIOS9jee9riB5OiBzdGFydEV4aXRQb2ludOeahHkrZW5kRXhpdFBvaW5055qEeS8yXHJcbiAgICAgICAgICAgICAgICAvLzHmipjnur/ngrkgeDplbmRFeGl0UG9pbnTnmoR4ICB5OnN0YXJ0RXhpdFBvaW5055qEeStlbmRFeGl0UG9pbnTnmoR5LzJcclxuICAgICAgICAgICAgICAgIHZhciBzMl8yID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl8yXzEgPSBuZXcgUG9pbnQoczJfMltnYXBJbmRleF0ueCwgKHMyXzJbZ2FwSW5kZXhdLnkgKyBzMl8yW2dhcEluZGV4ICsgMV0ueSkgLyAyKTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl8yXzIgPSBuZXcgUG9pbnQoczJfMltnYXBJbmRleCArIDFdLngsIChzMl8yW2dhcEluZGV4XS55ICsgczJfMltnYXBJbmRleCArIDFdLnkpIC8gMik7XHJcbiAgICAgICAgICAgICAgICBzMl8yLnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzJfMSwgczJfMl8yKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfMicsIHMyXzJdKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9WYXJpYW50IElJSVxyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzMgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgLy9maW5kIHRoZSBhbW91bnQgKHN0b3JlZCBpbiBkZWx0YSkgb2YgcGl4ZWxzIHdlIG5lZWQgdG8gbW92ZSByaWdodCBzbyBubyBpbnRlcnNlY3Rpb24gd2l0aCBhIGZpZ3VyZSB3aWxsIGJlIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIC8vIVNlZTogIC9kb2N1bWVudHMvc3BlY3MvY29ubmVjdGVkX2ZpZ3VyZXNfZGVsdGFzLmpwZyBmaWxlXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGVhc3RFeGl0cyA9IFtzMl8zW2dhcEluZGV4XS54ICsgMjAsIHMyXzNbZ2FwSW5kZXggKyAxXS54ICsgMjBdOyAvL2FkZCBwb2ludHMgWCBjb29yZGluYXRlcyB0byBiZSBhYmxlIHRvIGdlbmVyYXRlIFZhcmlhbnQgSUlJIGV2ZW4gaW4gdGhlIGFic2VuY2Ugb2YgZmlndXJlcyA6cFxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWFzdEV4aXRzLnB1c2goc0JvdW5kc1syXSArIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZUJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVhc3RFeGl0cy5wdXNoKGVCb3VuZHNbMl0gKyAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGVhc3RFeGl0ID0gVXRpbC5tYXgoZWFzdEV4aXRzKTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl8zXzEgPSBuZXcgUG9pbnQoZWFzdEV4aXQsIHMyXzNbZ2FwSW5kZXhdLnkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzNfMiA9IG5ldyBQb2ludChlYXN0RXhpdCwgczJfM1tnYXBJbmRleCArIDFdLnkpO1xyXG4gICAgICAgICAgICAgICAgczJfMy5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBzMl8zXzEsIHMyXzNfMik7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MyJywgJ3MyXzMnLCBzMl8zXSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vVmFyaWFudCBJViAgczJfNOaWueahiFxyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzQgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgLy9maW5kIHRoZSBhbW91bnQgKHN0b3JlZCBpbiBkZWx0YSkgb2YgcGl4ZWxzIHdlIG5lZWQgdG8gbW92ZSB1cCBzbyBubyBpbnRlcnNlY3Rpb24gd2l0aCBhIGZpZ3VyZSB3aWxsIGJlIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIC8vIVNlZTogIC9kb2N1bWVudHMvc3BlY3MvY29ubmVjdGVkX2ZpZ3VyZXNfZGVsdGFzLmpwZyBmaWxlXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5vcnRoRXhpdHMgPSBbczJfNFtnYXBJbmRleF0ueSAtIDIwLCBzMl80W2dhcEluZGV4ICsgMV0ueSAtIDIwXTsgLy9hZGQgcG9pbnRzIHkgY29vcmRpbmF0ZXMgdG8gYmUgYWJsZSB0byBnZW5lcmF0ZSBWYXJpYW50IElJSSBldmVuIGluIHRoZSBhYnNlbmNlIG9mIGZpZ3VyZXMgOnBcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcnRoRXhpdHMucHVzaChzQm91bmRzWzFdIC0gMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ydGhFeGl0cy5wdXNoKGVCb3VuZHNbMV0gLSAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5vcnRoRXhpdCA9IFV0aWwubWluKG5vcnRoRXhpdHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzRfMSA9IG5ldyBQb2ludChzMl80W2dhcEluZGV4XS54LCBub3J0aEV4aXQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzRfMiA9IG5ldyBQb2ludChzMl80W2dhcEluZGV4ICsgMV0ueCwgbm9ydGhFeGl0KTtcclxuICAgICAgICAgICAgICAgIHMyXzQuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfNF8xLCBzMl80XzIpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl80JywgczJfNF0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgVlxyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzUgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgLy9maW5kIHRoZSBhbW91bnQgKHN0b3JlZCBpbiBkZWx0YSkgb2YgcGl4ZWxzIHdlIG5lZWQgdG8gbW92ZSBsZWZ0IHNvIG5vIGludGVyc2VjdGlvbiB3aXRoIGEgZmlndXJlIHdpbGwgYmUgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgLy8hU2VlOiAgL2RvY3VtZW50cy9zcGVjcy9jb25uZWN0ZWRfZmlndXJlc19kZWx0YXMuanBnIGZpbGVcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgd2VzdEV4aXRzID0gW3MyXzVbZ2FwSW5kZXhdLnggLSAyMCwgczJfNVtnYXBJbmRleCArIDFdLnggLSAyMF07IC8vYWRkIHBvaW50cyB4IGNvb3JkaW5hdGVzIHRvIGJlIGFibGUgdG8gZ2VuZXJhdGUgVmFyaWFudCBJSUkgZXZlbiBpbiB0aGUgYWJzZW5jZSBvZiBmaWd1cmVzIDpwXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB3ZXN0RXhpdHMucHVzaChzQm91bmRzWzBdIC0gMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2VzdEV4aXRzLnB1c2goZUJvdW5kc1swXSAtIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgd2VzdEV4aXQgPSBVdGlsLm1pbih3ZXN0RXhpdHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzVfMSA9IG5ldyBQb2ludCh3ZXN0RXhpdCwgczJfNVtnYXBJbmRleF0ueSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNV8yID0gbmV3IFBvaW50KHdlc3RFeGl0LCBzMl81W2dhcEluZGV4ICsgMV0ueSk7XHJcbiAgICAgICAgICAgICAgICBzMl81LnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzVfMSwgczJfNV8yKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfNScsIHMyXzVdKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9WYXJpYW50IFZJXHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNiA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIGFtb3VudCAoc3RvcmVkIGluIGRlbHRhKSBvZiBwaXhlbHMgd2UgbmVlZCB0byBtb3ZlIGRvd24gc28gbm8gaW50ZXJzZWN0aW9uIHdpdGggYSBmaWd1cmUgd2lsbCBiZSBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAvLyFTZWU6ICAvZG9jdW1lbnRzL3NwZWNzL2Nvbm5lY3RlZF9maWd1cmVzX2RlbHRhcy5qcGcgZmlsZVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzb3V0aEV4aXRzID0gW3MyXzZbZ2FwSW5kZXhdLnkgKyAyMCwgczJfNltnYXBJbmRleCArIDFdLnkgKyAyMF07IC8vYWRkIHBvaW50cyB5IGNvb3JkaW5hdGVzIHRvIGJlIGFibGUgdG8gZ2VuZXJhdGUgVmFyaWFudCBJSUkgZXZlbiBpbiB0aGUgYWJzZW5jZSBvZiBmaWd1cmVzIDpwXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3V0aEV4aXRzLnB1c2goc0JvdW5kc1szXSArIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZUJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvdXRoRXhpdHMucHVzaChlQm91bmRzWzNdICsgMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzb3V0aEV4aXQgPSBVdGlsLm1heChzb3V0aEV4aXRzKTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl82XzEgPSBuZXcgUG9pbnQoczJfNltnYXBJbmRleF0ueCwgc291dGhFeGl0KTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl82XzIgPSBuZXcgUG9pbnQoczJfNltnYXBJbmRleCArIDFdLngsIHNvdXRoRXhpdCk7XHJcbiAgICAgICAgICAgICAgICBzMl82LnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzZfMSwgczJfNl8yKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfNicsIHMyXzZdKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vRklMVEVSIHNvbHV0aW9uc1xyXG5cclxuICAgICAgICAgICAgICAgIC8qQWxnb3JpdGhtXHJcbiAgICAgICAgICAgICAgICAgKiAwLiBzb2x1dGlvbnMgYXJlIG9yZGVyZWQgZnJvbSBtaW5pbW11biBuciBvZiBwb2ludHMgdG8gbWF4aW11bSA+OilcclxuICAgICAgICAgICAgICAgICAqIDEuIHJlbW92ZSBhbGwgc29sdXRpb25zIHRoYXQgYXJlIG5vdCBvcnRob2dvbmFsIChtYWlubHkgczAgc29sdXRpb24pXHJcbiAgICAgICAgICAgICAgICAgKiAyLiByZW1vdmUgYWxsIHNvbHV0aW9ucyB0aGF0IGdvIGJhY2t3YXJkICh3ZSB3aWxsIG5vdCBuZWVkIHRoZW0gZXZlcilcclxuICAgICAgICAgICAgICAgICAqIDMuIHJlbW92ZSBhbGwgc29sdXRpb25zIHdpdGggaW50ZXJzZWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICogNC4gcGljayBmaXJzdCBjbGFzcyBvZiBzb2x1dGlvbnMgd2l0aCBzYW1lIG5yIG9mIHBvaW50cyAoZXg6IDIpXHJcbiAgICAgICAgICAgICAgICAgKiA1LiBwaWNrIHRoZSBmaXJzdCBzb2x1dGlvbiB3aXRoIDkwIGRlZ3JlZSBhbmdsZXMgKGxlc3MgdHVybmFyb3VuZHMpXHJcbiAgICAgICAgICAgICAgICAgKiAobm90IGludGVyZXN0ZXRlZCkgc29ydCBieSBsZW5ndGggOnBcclxuICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgIC8vMS4gZmlsdGVyIG5vbiBvcnRvZ29uYWwgc29sdXRpb25zIOWIoOmZpOS4jeaYr+ato+S6pOebtOe6v+eahOaWueahiFxyXG4gICAgICAgICAgICAgICAgTG9nLmluZm8oXCJGaWx0ZXIgb3J0aG9nb25hbCBzb2x1dGlvbnMuIEluaXRpYWwgbnVtYmVyIG9mIHNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3J0aG9nb25hbFNvbHV0aW9uID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHNvbHV0aW9ucy5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5vcnRob2dvbmFsUGF0aChzb2x1dGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3J0aG9nb25hbFNvbHV0aW9uLnB1c2goc29sdXRpb25zW2xdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBvcnRob2dvbmFsU29sdXRpb247XHJcbiAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIlxcblxcdE9ydGhvZ29uYWxTb2x1dGlvbnMgPSBcIiArIHNvbHV0aW9ucy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vMi4gZmlsdGVyIGJhY2t3YXJkIHNvbHV0aW9ucyAg6L+H5rukIOWAkumAgOeahOaWueahiFxyXG4gICAgICAgICAgICAgICAgLy9kbyBub3QgYWxsb3cgc3RhcnQgYW5kIGVuZCBwb2ludHMgdG8gY29pbmNpZGUgLSBpZ25vcmUgdGhlbVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0UG9pbnQuZXF1YWxzKGVuZFBvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlN0YXJ0IGFuZCBlbmQgcG9pbnQgY29pbmNpZGUuLi5za2lwIGJhY2t3YXJkIHNvbHV0aW9uLiBJIHRoaW5rIHdlIHdpbGwganVzdCBmYWxsIG9uIHMwIDopXCJcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIkZpbHRlciBiYWNrd2FyZCBzb2x1dGlvbnMuIEluaXRpYWwgbnVtYmVyIG9mIHNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcndhcmRTb2x1dGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgc29sdXRpb25zLmxlbmd0aDsgbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWwuZm9yd2FyZFBhdGgoc29sdXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkU29sdXRpb25zLnB1c2goc29sdXRpb25zW2xdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSB0ZW1wICsgXCJcXG5cXHRcIiArIHNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IGZvcndhcmRTb2x1dGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJcXG5cXHQgRm9yd2FyZFNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbHV0aW9ucy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIkRpc2NhcmRlZCBzb2x1dGlvbnM6IFwiICsgdGVtcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLzMuIEZpbHRlciBub24gaW50ZXJzZWN0aW5nIHNvbHV0aW9ucyAg5Y676Zmk5rKh5pyJ5Lqk6ZuGKCnnmoTmlrnmoYhcclxuICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiRmlsdGVyIG5vbiBpbnRlcnNlY3Rpbmcgc29sdXRpb25zLiBJbml0aWFsIG51bWJlciBvZiBzb2x1dGlvbnMgPSBcIiArIHNvbHV0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vbkludGVyc2VjdGlvblNvbHV0aW9ucyA9IFtdXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHNvbHV0aW9ucy5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAvL0xvZy5pbmZvKFwiU29sdXRpb24gaWQ9IFwiICsgc29sdXRpb25zW2xdWzFdICsgJyBuciBwb2ludHMgPSAnICsgc29sdXRpb24ubGVuZ3RoICsgXCIsIHBvaW50cyA9IFwiICsgc29sdXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnNlY3QgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyTGluZXMgPSBzb2x1dGlvbi5zbGljZSgpOyAvL2p1c3QgYSBzaGFsbG93IGNvcHlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLypJZiBhbnkgYm91bmRzIGp1c3QgdHJpbSB0aGUgc29sdXRpb24uIFNvIHdlIGF2b2lkIHRoZSBzdHJhbmdlIGNhc2Ugd2hlbiBhIGNvbm5lY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgKnN0YXJ0ZXMgZnJvbSBhIHBvaW50IG9uIGEgZmlndXJlIGFuZCBlbmRzIGluc2lkZSBvZiB0aGUgc2FtZSBmaWd1cmUsIGJ1dCBub3Qgb24gYSBjb25uZWN0aW9uIHBvaW50Ki9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZUJvdW5kcyB8fCBzQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaTBubmVyTGluZXMgPSBpbm5lckxpbmVzLnNsaWNlKDAsIGlubmVyTGluZXMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyTGluZXMgPSBpbm5lckxpbmVzLnNsaWNlKDEsIGlubmVyTGluZXMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vTG9nLmluZm8oXCJcXHQgZUJvdW5kcyBwcmVzZW50LGlubmVyTGluZXMgbnIuIHBvaW50cyA9IFwiICsgaW5uZXJMaW5lcy5sZW5ndGggKyBcIiwgcG9pbnRzID0gXCIgKyBpbm5lckxpbmVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9ub3cgdGVzdCBmb3IgaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0ID0gaW50ZXJzZWN0IHx8IFV0aWwucG9seWxpbmVJbnRlcnNlY3RzUmVjdGFuZ2xlKGlubmVyTGluZXMsIHNCb3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZUJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3QgPSBpbnRlcnNlY3QgfHwgVXRpbC5wb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGUoaW5uZXJMaW5lcywgZUJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWludGVyc2VjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub25JbnRlcnNlY3Rpb25Tb2x1dGlvbnMucHVzaChzb2x1dGlvbnNbbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL0lmIGFsbCBzb2x1dGlvbnMgaW50ZXJzZWN0IHRoYW4gdGhpcyBpcyBkZXN0aW55ICA6KSBhbmQganVzdCBpZ25vcmUgdGhlIGludGVyc2VjdGlvbiBmaWx0ZXJcclxuICAgICAgICAgICAgICAgIGlmIChub25JbnRlcnNlY3Rpb25Tb2x1dGlvbnMubGVuZ3RoICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JlYXNpZ24gdG8gc29sdXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zID0gbm9uSW50ZXJzZWN0aW9uU29sdXRpb25zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiXFxuXFx0IG5vbkludGVyc2VjdGlvblNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vNC4gZ2V0IGZpcnN0IGNsYXNzIG9mIHNvbHV0aW9ucyB3aXRoIHNhbWUgbnIgb2YgcG9pbnRzIOmAieaLqeS4juesrOS4gOS4quaWueahiOeCueaVsOS4gOagt+WkmueahOaWueahiO+8iOWboOS4uuesrOS4gOS4quaWueahiOeCueaVsOacgOWwke+8iVxyXG4gICAgICAgICAgICAgICAgTG9nLmluZm8oXCJHZXQgZmlyc3QgY2xhc3Mgb2Ygc29sdXRpb25zIHdpdGggc2FtZSBuciBvZiBwb2ludHNcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc29sdXRpb25zLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJUaGlzIGlzIG5vdCBwb3NzaWJsZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RTb2x1dGlvbiA9IHNvbHV0aW9uc1swXVsyXTsgLy9waWNrIGZpcnN0IHNvbHV0aW9uXHJcbiAgICAgICAgICAgICAgICB2YXIgbnJPZlBvaW50cyA9IGZpcnN0U29sdXRpb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNhbWVOclBvaW50c1NvbHV0aW9uID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBzb2x1dGlvbnMubGVuZ3RoOyBsKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc29sdXRpb24gPSBzb2x1dGlvbnNbbF1bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbHV0aW9uLmxlbmd0aCA9PSBuck9mUG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbWVOclBvaW50c1NvbHV0aW9uLnB1c2goc29sdXRpb25zW2xdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zID0gc2FtZU5yUG9pbnRzU29sdXRpb247XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLyo1LiAg6K6h566X6Lev5b6E5YiG5pWwIO+8jOWPluacgOWIhuaVsOmrmOeahFxyXG4gICAgICAgICAgICAgICAgIFBpY2sgdGhlIGZpcnN0IHNvbHV0aW9uIHdpdGggOTAgZGVncmVlIGFuZ2xlcyAobGVzcyB0dXJuYXJvdW5kcylcclxuICAgICAgICAgICAgICAgICAqaW4gY2FzZSB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc29sdXRpb24gaW4gb3VyIGNsYXNzXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIExvZy5pbmZvKFwicGljayB0aGUgZmlyc3Qgc29sdXRpb24gd2l0aCA5MCBkZWdyZWUgYW5nbGVzIChsZXNzIHR1cm5hcm91bmRzKVwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBzb2xJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHNvbHV0aW9ucy5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5zY29yZVBhdGgoc29sdXRpb25zW3NvbEluZGV4XVsyXSkgPCBVdGlsLnNjb3JlUGF0aChzb2x1dGlvbnNbbF1bMl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbEluZGV4ID0gbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBbc29sdXRpb25zW3NvbEluZGV4XV07XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9TTU9PVEhJTkcgY3VydmVcclxuICAgICAgICBpZiAodHlwZSA9PT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpIHtcclxuICAgICAgICAgICAgdGhpcy5zbW9vdGhDdXJ2ZShzb2x1dGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL0VORCBTTU9PVEhJTkcgY3VydmVcclxuXHJcbiAgICAgICAgTG9nLmdyb3VwRW5kKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBzb2x1dGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNtb290aEN1cnZlID0gZnVuY3Rpb24gKHNvbHV0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHRpb24gPSAzO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKG9wdGlvbikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAvL2RvIG5vdGhpbmdcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAxOiAvL2FkZCBpbnRlcm1lZGlhdGUgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICAvL0FkZCB0aGUgbWlkZGxlIHBvaW50IGZvciBzdGFydCBhbmQgZW5kIHNlZ21lbnQgc28gdGhhdCB3ZSBcImZvcmNlXCIgdGhlXHJcbiAgICAgICAgICAgICAgICAvL2N1cnZlIHRvIGJvdGggY29tZSBcInBlcnBlbmRpY3VsYXJcIiBvbiBib3VuZHMgYW5kIGFsc28gbWFrZSB0aGUgY3VydmVcclxuICAgICAgICAgICAgICAgIC8vXCJmbGVlXCIgbW9yZSBmcm9tIGJvdW5kcyAob24gZXhpdClcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc29sdXRpb25zLmxlbmd0aDsgcysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbFR1cm5pbmdQb2ludHMgPSBzb2x1dGlvbnNbc11bMl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZmlyc3Qgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhMSA9IHNvbFR1cm5pbmdQb2ludHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEyID0gc29sVHVybmluZ1BvaW50c1sxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRNaWRkbGVQb2ludCA9IFV0aWwuZ2V0TWlkZGxlKGExLCBhMik7XHJcbiAgICAgICAgICAgICAgICAgICAgc29sVHVybmluZ1BvaW50cy5zcGxpY2UoMSwgMCwgc3RhcnRNaWRkbGVQb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vbGFzdCBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEzID0gc29sVHVybmluZ1BvaW50c1tzb2xUdXJuaW5nUG9pbnRzLmxlbmd0aCAtIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhNCA9IHNvbFR1cm5pbmdQb2ludHNbc29sVHVybmluZ1BvaW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kTWlkZGxlUG9pbnQgPSBVdGlsLmdldE1pZGRsZShhMywgYTQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNvbFR1cm5pbmdQb2ludHMuc3BsaWNlKHNvbFR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMSwgMCwgZW5kTWlkZGxlUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDI6IC8vcmVtb3ZlIHBvaW50c1xyXG5cclxuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKHNvbHV0aW9ucywgZnVuY3Rpb24oc29sdXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc29sVHlwZSA9IHNvbHV0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb2xUeXBlID09ICdzMScgfHwgc29sVHlwZSA9PSAnczInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2xUdXJuaW5nUG9pbnRzID0gc29sdXRpb25bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbFR1cm5pbmdQb2ludHMuc3BsaWNlKDEsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2xUdXJuaW5nUG9pbnRzLnNwbGljZShzb2xUdXJuaW5nUG9pbnRzLmxlbmd0aCAtIDIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAvKnJlbW92ZSBjb2xpbmVhciBwb2ludCBmb3IgczEgYXMgaXQgc2VlbXMgdGhhdCBtb3JlIGNvbGluZWFyIHBvaW50cyBkbyBub3QgbG9vayBnb29kXHJcbiAgICAgICAgICAgICAgICAgKiBvbiBvcmdhbmljIHNvbHV0aW9ucyA+OkQqL1xyXG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2goc29sdXRpb25zLCBmdW5jdGlvbihzb2x1dGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2xUeXBlID0gc29sdXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbFR5cGUgPT0gJ3MxJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sVHVybmluZ1BvaW50cyA9IHNvbHV0aW9uWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVkdWNlZFNvbHV0aW9uID0gVXRpbC5jb2xsaW5lYXJSZWR1Y3Rpb24oc29sVHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uWzJdID0gcmVkdWNlZFNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfSAvL2VuZCBzd2l0Y2hcclxuXHJcbiAgICB9XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvQ29ubmVjdGlvbk1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5pel5b+X57G7XHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG5cclxuICAgIHZhciBMb2cgID0ge1xyXG4gICAgICAgIExPR19MRVZFTF9OT05FICA6IDAsXHJcblxyXG4gICAgICAgIExPR19MRVZFTF9ERUJVRyA6IDEsXHJcblxyXG4gICAgICAgIExPR19MRVZFTF9JTkZPIDogMixcclxuXHJcbiAgICAgICAgTE9HX0xFVkVMX0VSUk9SIDogMyxcclxuXHJcbiAgICAgICAgbGV2ZWwgOiB0aGlzLkxPR19MRVZFTF9FUlJPUixcclxuICAgICAgICBcclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRoZSBsZXNzIGltcG9ydGFudCBvZiBhbGwgbWVzc2FnZXNcclxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIC0gdGhlIG1lc3NhZ2UgdG8gYmUgbG9nZ2VkXHJcbiAgICAgICAgKiovXHJcbiAgICAgICAgZGVidWc6IGZ1bmN0aW9uIChtZXNzYWdlKXtcclxuICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMubGV2ZWwgPD0gdGhpcy5MT0dfTEVWRUxfREVCVUcpe1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vaW4gRkYgaXMgZGVidWdcclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZS5kZWJ1ZyA9PSAnZnVuY3Rpb24nKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZXsvL1RPRE86IGluIElFIGlzIGxvZ1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBUaGUgY29tbW9ubHkgdXNlZCBsb2cgbWVzc2FnZVxyXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgLSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWRcclxuICAgICAgICAqKi9cclxuICAgICAgICBpbmZvIDogZnVuY3Rpb24gKG1lc3NhZ2Upe1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5sZXZlbCA8PSB0aGlzLkxPR19MRVZFTF9JTkZPKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8obWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRoZSB3b3JzZSBraW5kIG9mIG1lc3NhZ2UuIFVzdWFsbHkgYSBjcmFzaFxyXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgLSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWRcclxuICAgICAgICAqKi9cclxuICAgICAgICBlcnJvciA6IGZ1bmN0aW9uIChtZXNzYWdlKXtcclxuICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMubGV2ZWwgPD0gdGhpcy5MT0dfTEVWRUxfRVJST1Ipe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKlN0YXJ0IGdyb3VwaW5nIHRoZSBsb2cgbWVzc2FnZXNcclxuICAgICAgICAgKkBwYXJhbSB7U3RyaW5nfSB0aXRsZSAtIHRoZSB0aXRsZSBvZiB0aGUgZ3JvdXBcclxuICAgICAgICAgKkBzZWUgPGEgaHJlZj1cImh0dHA6Ly9nZXRmaXJlYnVnLmNvbS9sb2dnaW5nXCI+aHR0cDovL2dldGZpcmVidWcuY29tL2xvZ2dpbmc8L2E+XHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGdyb3VwIDogZnVuY3Rpb24odGl0bGUpe1xyXG4gICAgICAgICAgICBpZih0aGlzLmxldmVsIDw9IHRoaXMuTE9HX0xFVkVMX0lORk8peyAvL2lnbm9yZSBncm91cCBpZiBsZXZlbCBub3QgZGVidWcgb3IgaW5mb1xyXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKXsgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8qKklmIHdlIGRvIG5vdCB0ZXN0IGZvciBncm91cCgpIGZ1bmN0aW9uIHlvdSB3aWxsIGdldCBhbiBlcnJvciBpbiBPcGVyYVxyXG4gICAgICAgICAgICAgICAgICAgICAqYXMgT3BlcmEgaGFzIGl0J3Mgb3duIGNvbnNvbGUuLi53aGljaCBkb2VzIG5vdCBoYXZlIGEgZ3JvdXAoKSBmdW5jdGlvbiovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUuZ3JvdXAgPT09ICdmdW5jdGlvbicpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwKHRpdGxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipFbmRzIGN1cnJlbnQgbWVzc2FnZSBncm91cGluZyovXHJcbiAgICAgICAgZ3JvdXBFbmQgOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBpZih0aGlzLmxldmVsIDw9IHRoaXMuTE9HX0xFVkVMX0lORk8peyAvL2lnbm9yZSBncm91cCBpZiBsZXZlbCBub3QgZGVidWcgb3IgaW5mb1xyXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKXtcclxuICAgICAgICAgICAgICAgICAgICAvKipJZiB3ZSBkbyBub3QgdGVzdCBmb3IgZ3JvdXBFbmQoKSBmdW5jdGlvbiB5b3Ugd2lsbCBnZXQgYW4gZXJyb3IgaW4gT3BlcmFcclxuICAgICAgICAgICAgICAgICAgICAgKmFzIE9wZXJhIGhhcyBpdCdzIG93biBjb25zb2xlLi4ud2hpY2ggZG9lcyBub3QgaGF2ZSBhIGdyb3VwKCkgZnVuY3Rpb24qL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlLmdyb3VwRW5kID09PSAnZnVuY3Rpb24nKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vTG9nLmxldmVsID0gTG9nLkxPR19MRVZFTF9ERUJVRzsgXHJcbiAgICBMb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX0VSUk9SOyBcclxuICAgIC8vTG9nLmxldmVsID0gTG9nLkxPR19MRVZFTF9FUlJPUjtcclxuICAgIC8vTG9nLmxldmVsID0gTG9nLkxPR19MRVZFTF9OT05FO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMb2c7XHJcbiAgICBcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL0xvZy5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDov57nur/mk43kvZznsbtcclxuICogQGF1dGhvciBtaWFvLmN1bnpoaVxyXG4gKi9cclxuXHJcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoJy4uL3NoYXBlcy9TeW1ib2wnKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBpY29uID0gcmVxdWlyZSgnLi9JY29uT3BlcmF0aW9uJyk7XHJcbiAgICBmdW5jdGlvbiBMaW5lT3BlcmF0aW9uTWFuYWdlcihjb25uZWN0aW9uTWFuYWdlciwgYXBpKSB7XHJcbiAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9ucyA9IFtdLFxyXG4gICAgICAgIHRoaXMuaXNFZGl0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gY29ubmVjdGlvbk1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5fYXBpID0gYXBpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogIHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIuYWRkSWNvbihrZXksIG9wdGlvbnMpO1xyXG4gICAgICovXHJcbiAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5wcm90b3R5cGUuYWRkSWNvbiA9IGZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xyXG4gICAgICAgIC8v5Yik5pat5piv5bCP5Zu+5qCH5ZCm5a2Y5ZyoIO+8jOWtmOWcqOWImeebtOaOpei/lOWbnlxyXG4gICAgICAgIHZhciBsaW5lT3BlcmF0aW9uSWNvbiA9IHpyVXRpbC5maW5kKG9wdGlvbnMubGluZU5vZGUuaWNvbnMsIGZ1bmN0aW9uKGljb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGljb24ua2V5ID09PSBrZXk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChsaW5lT3BlcmF0aW9uSWNvbikge1xyXG4gICAgICAgICAgICB0aGlzLmJpbmRPcGVyYXRpb24ob3B0aW9ucy5saW5lTm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBsaW5lT3BlcmF0aW9uID0gdGhpcy5jcmVhdE9wZXJhdGlvbihrZXksIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLl9hcGkuX2dldFBhcmVudFpyKCkuYWRkKGxpbmVPcGVyYXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLmJpbmRPcGVyYXRpb24ob3B0aW9ucy5saW5lTm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5lT3BlcmF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgTGluZU9wZXJhdGlvbk1hbmFnZXIucHJvdG90eXBlLmNyZWF0T3BlcmF0aW9uID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGxpbmVPcGVyYXRpb24gPSBzeW1ib2xVdGlsLmNyZWF0ZVN5bWJvbChvcHRpb25zLmljb25QYXRoLCAwLCAwLCBvcHRpb25zLndpZHRoIHx8IDE1LCBvcHRpb25zLmhlaWdodCB8fCAxNSwgMCwgb3B0aW9ucy5jb2xvcnx8JyNhYWFhYWMnKTtcclxuICAgICAgICBsaW5lT3BlcmF0aW9uLmtleSA9IGtleTtcclxuICAgICAgICBsaW5lT3BlcmF0aW9uLl93aWR0aCA9ICBvcHRpb25zLndpZHRoIHx8IDE1OyAgLy8gcGF0aOaDheWGteS4i+aXoOazleiuoeeul1xyXG4gICAgICAgIGxpbmVPcGVyYXRpb24uX2lzTGluZU9wZXJhdGlvbkljb24gPSB0cnVlO1xyXG4gICAgICAgIGxpbmVPcGVyYXRpb24uaGlkZSgpO1xyXG4gICAgICAgIG9wdGlvbnMubGluZU5vZGUuaWNvbnMucHVzaChsaW5lT3BlcmF0aW9uKTtcclxuICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25zLnB1c2gobGluZU9wZXJhdGlvbik7XHJcblxyXG4gICAgICAgIC8v5bCP5Zu+5qCHIOeCueWHu+S6i+S7tiAg5aaC5p6c5pyJ5Zue6LCD5YiZ6LCD55So5Zue6LCD77yM5ZCm5YiZ5rS+5Y+R5LqL5Lu2XHJcbiAgICAgICAgbGluZU9wZXJhdGlvbi5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhID0gb3B0aW9ucztcclxuICAgICAgICAgICAgICAgIGV2ZW50LmxpbmVOb2RlID0gb3B0aW9ucy5saW5lTm9kZTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soZXZlbnQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiY2xpY2tcIjtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5lbGVtZW50VHlwZSA9IFwiTGluZU9wZXJhdGlvbkljb25cIjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICByZXR1cm4gbGluZU9wZXJhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuoeeul+Wwj+Wbvuagh+eahOS9jee9ru+8jOW5tuaYvuekulxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBjb25uZWN0b3IgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5wcm90b3R5cGUuYmluZE9wZXJhdGlvbiA9IGZ1bmN0aW9uKGNvbm5lY3Rvcikge1xyXG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudFgobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQubm9kZVR5cGUgPT0gXCJTdWJQcm9jZXNzXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzBdICsgcGFyZW50WChub2RlLnBhcmVudClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzBdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBmdW5jdGlvbiBwYXJlbnRZKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50Lm5vZGVUeXBlID09IFwiU3ViUHJvY2Vzc1wiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblsxXSArIHBhcmVudFkobm9kZS5wYXJlbnQpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblsxXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5pc0VkaXQgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcG9pbnRQb3NpdGlvbiA9IGNvbm5lY3Rvci5taWRkbGUoKSwgcG9zWCwgcG9zWTtcclxuICAgICAgICBpZiAoY29ubmVjdG9yLnBhcmVudCAmJiBjb25uZWN0b3IucGFyZW50Lm5vZGVUeXBlID09IFwiU3ViUHJvY2Vzc1wiKSB7XHJcbiAgICAgICAgICAgIHBvc1ggPSBwb2ludFBvc2l0aW9uWzBdICsgcGFyZW50WChjb25uZWN0b3IucGFyZW50KTtcclxuICAgICAgICAgICAgcG9zWSA9IHBvaW50UG9zaXRpb25bMV0gKyBwYXJlbnRZKGNvbm5lY3Rvci5wYXJlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBvc1ggPSBwb2ludFBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICBwb3NZID0gcG9pbnRQb3NpdGlvblsxXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhcnJMZW5ndGggPSB6clV0aWwubWFwKGNvbm5lY3Rvci5pY29ucywgZnVuY3Rpb24oaWNvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gaWNvbi5fd2lkdGg7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciB0b3RhbExlbmd0aCA9IHpyVXRpbC5yZWR1Y2UoYXJyTGVuZ3RoLCBmdW5jdGlvbihwcmV2aW91c1ZhbHVlLGN1cnJlbnRWYWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNWYWx1ZSArIGN1cnJlbnRWYWx1ZSArIDEwO1xyXG4gICAgICAgIH0sIDAgKTtcclxuXHJcbiAgICAgICAgenJVdGlsLmVhY2goY29ubmVjdG9yLmljb25zLCBmdW5jdGlvbihpY29uLCBpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgY29ubmVjdG9yUG9zaXRpb24gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGluZGV4OyBrKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3RvclBvc2l0aW9uICs9IGFyckxlbmd0aFtrXSArIDEwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGljb24uYXR0cihcInBvc2l0aW9uXCIsIFtwb3NYICsgY29ubmVjdG9yUG9zaXRpb24gLSB0b3RhbExlbmd0aCAvIDIsIHBvc1kgKyA1XSk7XHJcbiAgICAgICAgICAgIGljb24uc2hvdygpO1xyXG4gICAgICAgICAgICBpY29uLmF0dGFjaExpbmUgPSBjb25uZWN0b3I7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5wcm90b3R5cGUuaGlkZUFsbExpbmVPcGVyYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB6clV0aWwuZWFjaCh0aGlzLmxpbmVPcGVyYXRpb25zLCBmdW5jdGlvbihsaW5lT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGxpbmVPcGVyYXRpb24uaGlkZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLnByb3RvdHlwZS5hZGREZWxldGVJY29uID0gZnVuY3Rpb24obGluZU5vZGUsb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHRzID0genJVdGlsLmRlZmF1bHRzKHtcclxuICAgICAgICAgICAgaWNvblBhdGg6ICdwYXRoOi8vJyArIGljb24uREVMX1NWRyxcclxuICAgICAgICAgICAgd2lkdGg6IDEyLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDE0LFxyXG4gICAgICAgICAgICBsaW5lTm9kZTogbGluZU5vZGUsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcGkucmVtb3ZlKGUudGFyZ2V0LmF0dGFjaExpbmUpOy8vdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcylcclxuICAgICAgICB9LCBvcHRpb25zLHRydWUpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZEljb24oXCJkZWxldGVcIiwgb3B0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgTGluZU9wZXJhdGlvbk1hbmFnZXIucHJvdG90eXBlLmFkZENoYW5nZUxpbmVUeXBlSWNvbiA9IGZ1bmN0aW9uKGxpbmVOb2RlLG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHpyVXRpbC5kZWZhdWx0cyh7XHJcbiAgICAgICAgICAgIGljb25QYXRoOiAncGF0aDovLycgKyBpY29uLkNIQU5HRV9MSU5FX1RZUEVfU1ZHLFxyXG4gICAgICAgICAgICB3aWR0aDogMTUsXHJcbiAgICAgICAgICAgIGhlaWdodDogMTUsXHJcbiAgICAgICAgICAgIGxpbmVOb2RlOiBsaW5lTm9kZSxcclxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaS5jaGFuZ2VTZWxlY3RDb25uZWN0b3JUeXBlKCk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgIH0sIG9wdGlvbnMsdHJ1ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkSWNvbihcImNoYW5nZVwiLCBvcHRzKVxyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gTGluZU9wZXJhdGlvbk1hbmFnZXI7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9MaW5lT3BlcmF0aW9uTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDovoXliqnnur/mk43kvZznsbtcclxuICogQGF1dGhvciBtaWFvLmN1bnpoaVxyXG4gKi9cclxuXHJcblx0dmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuXHJcbiAgICB2YXIgR3VpZGVsaW5lcyA9IHtcclxuICAgICAgICB2aXJ0dWFsWExpbmU6bnVsbCxcclxuICAgICAgICB2aXJ0dWFsWUxpbmU6bnVsbCxcclxuICAgICAgICBjcmVhdGVHdWlkZWxpbmVzOmZ1bmN0aW9uKHpyKXtcclxuICAgICAgICAgICAgLy/liJvlu7p46L206Jma57q/XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbFhMaW5lID0gbmV3IGdyYXBoaWMuTGluZSh7XHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVEYXNoOiBbNV1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB6OiAzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvL+WIm+W7ulnovbTomZrnur9cclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsWUxpbmUgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZURhc2g6IFs1XVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHo6IDNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHpyLmFkZCh0aGlzLnZpcnR1YWxYTGluZSk7XHJcbiAgICAgICAgICAgIHpyLmFkZCh0aGlzLnZpcnR1YWxZTGluZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBqdWRnZUFsaWdubWVudDpmdW5jdGlvbihub3dSZWN0UG9zaXRpb24sZG9tQXJyYXksbWF4V2lkdGgsbWF4SGVpZ2h0KXtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAvL+W+queOr+WIpOaWreawtOW5s+Wvuem9kFxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gZG9tQXJyYXkubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChub3dSZWN0UG9zaXRpb25bMV0gPT0gZG9tQXJyYXlbal0ucG9zaXRpb25bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnZpcnR1YWxYTGluZS5hdHRyKCdwb3NpdGlvbicsIFswLCBub3dSZWN0UG9zaXRpb25bMV1dKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnZpcnR1YWxYTGluZS5hdHRyKFwic2hhcGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4MjogbWF4V2lkdGhcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudmlydHVhbFhMaW5lLmF0dHIoXCJzaGFwZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyOiAwXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy/lvqrnjq/liKTmlq3lnoLnm7Tlr7npvZBcclxuICAgICAgICAgICAgZm9yICh2YXIgbSA9IDAsIGxlbjEgPSBkb21BcnJheS5sZW5ndGg7IG0gPCBsZW4xOyBtKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChub3dSZWN0UG9zaXRpb25bMF0gPT0gZG9tQXJyYXlbbV0ucG9zaXRpb25bMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnZpcnR1YWxZTGluZS5hdHRyKCdwb3NpdGlvbicsIFtub3dSZWN0UG9zaXRpb25bMF0sIDBdKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnZpcnR1YWxZTGluZS5hdHRyKFwic2hhcGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5MjogbWF4SGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudmlydHVhbFlMaW5lLmF0dHIoXCJzaGFwZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyOiAwXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IEd1aWRlbGluZXM7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9HdWlkZWxpbmVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgb2xkO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSBvbGQgPSBQcm9taXNlO1xuZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICB0cnkgeyBpZiAoUHJvbWlzZSA9PT0gYmx1ZWJpcmQpIFByb21pc2UgPSBvbGQ7IH1cbiAgICBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gYmx1ZWJpcmQ7XG59XG52YXIgYmx1ZWJpcmQgPSByZXF1aXJlKFwiLi9wcm9taXNlXCIpKCk7XG5ibHVlYmlyZC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbm1vZHVsZS5leHBvcnRzID0gYmx1ZWJpcmQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9ibHVlYmlyZC5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbnZhciBtYWtlU2VsZlJlc29sdXRpb25FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcImNpcmN1bGFyIHByb21pc2UgcmVzb2x1dGlvbiBjaGFpblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG59O1xudmFyIHJlZmxlY3RIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uKHRoaXMuX3RhcmdldCgpKTtcbn07XG52YXIgYXBpUmVqZWN0aW9uID0gZnVuY3Rpb24obXNnKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IobXNnKSk7XG59O1xuZnVuY3Rpb24gUHJveHlhYmxlKCkge31cbnZhciBVTkRFRklORURfQklORElORyA9IHt9O1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgZ2V0RG9tYWluO1xuaWYgKHV0aWwuaXNOb2RlKSB7XG4gICAgZ2V0RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXQgPSBwcm9jZXNzLmRvbWFpbjtcbiAgICAgICAgaWYgKHJldCA9PT0gdW5kZWZpbmVkKSByZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59IGVsc2Uge1xuICAgIGdldERvbWFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxudXRpbC5ub3RFbnVtZXJhYmxlUHJvcChQcm9taXNlLCBcIl9nZXREb21haW5cIiwgZ2V0RG9tYWluKTtcblxudmFyIGVzNSA9IHJlcXVpcmUoXCIuL2VzNVwiKTtcbnZhciBBc3luYyA9IHJlcXVpcmUoXCIuL2FzeW5jXCIpO1xudmFyIGFzeW5jID0gbmV3IEFzeW5jKCk7XG5lczUuZGVmaW5lUHJvcGVydHkoUHJvbWlzZSwgXCJfYXN5bmNcIiwge3ZhbHVlOiBhc3luY30pO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciBUeXBlRXJyb3IgPSBQcm9taXNlLlR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG5Qcm9taXNlLlJhbmdlRXJyb3IgPSBlcnJvcnMuUmFuZ2VFcnJvcjtcbnZhciBDYW5jZWxsYXRpb25FcnJvciA9IFByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IgPSBlcnJvcnMuQ2FuY2VsbGF0aW9uRXJyb3I7XG5Qcm9taXNlLlRpbWVvdXRFcnJvciA9IGVycm9ycy5UaW1lb3V0RXJyb3I7XG5Qcm9taXNlLk9wZXJhdGlvbmFsRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcblByb21pc2UuUmVqZWN0aW9uRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcblByb21pc2UuQWdncmVnYXRlRXJyb3IgPSBlcnJvcnMuQWdncmVnYXRlRXJyb3I7XG52YXIgSU5URVJOQUwgPSBmdW5jdGlvbigpe307XG52YXIgQVBQTFkgPSB7fTtcbnZhciBORVhUX0ZJTFRFUiA9IHt9O1xudmFyIHRyeUNvbnZlcnRUb1Byb21pc2UgPSByZXF1aXJlKFwiLi90aGVuYWJsZXNcIikoUHJvbWlzZSwgSU5URVJOQUwpO1xudmFyIFByb21pc2VBcnJheSA9XG4gICAgcmVxdWlyZShcIi4vcHJvbWlzZV9hcnJheVwiKShQcm9taXNlLCBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24sIFByb3h5YWJsZSk7XG52YXIgQ29udGV4dCA9IHJlcXVpcmUoXCIuL2NvbnRleHRcIikoUHJvbWlzZSk7XG4gLypqc2hpbnQgdW51c2VkOmZhbHNlKi9cbnZhciBjcmVhdGVDb250ZXh0ID0gQ29udGV4dC5jcmVhdGU7XG52YXIgZGVidWcgPSByZXF1aXJlKFwiLi9kZWJ1Z2dhYmlsaXR5XCIpKFByb21pc2UsIENvbnRleHQpO1xudmFyIENhcHR1cmVkVHJhY2UgPSBkZWJ1Zy5DYXB0dXJlZFRyYWNlO1xudmFyIFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQgPVxuICAgIHJlcXVpcmUoXCIuL2ZpbmFsbHlcIikoUHJvbWlzZSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgTkVYVF9GSUxURVIpO1xudmFyIGNhdGNoRmlsdGVyID0gcmVxdWlyZShcIi4vY2F0Y2hfZmlsdGVyXCIpKE5FWFRfRklMVEVSKTtcbnZhciBub2RlYmFja0ZvclByb21pc2UgPSByZXF1aXJlKFwiLi9ub2RlYmFja1wiKTtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xuZnVuY3Rpb24gY2hlY2soc2VsZiwgZXhlY3V0b3IpIHtcbiAgICBpZiAoc2VsZiA9PSBudWxsIHx8IHNlbGYuY29uc3RydWN0b3IgIT09IFByb21pc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSBwcm9taXNlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBpbnZva2VkIGRpcmVjdGx5XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhleGVjdXRvcikpO1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgaWYgKGV4ZWN1dG9yICE9PSBJTlRFUk5BTCkge1xuICAgICAgICBjaGVjayh0aGlzLCBleGVjdXRvcik7XG4gICAgfVxuICAgIHRoaXMuX2JpdEZpZWxkID0gMDtcbiAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Byb21pc2UwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlY2VpdmVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZXNvbHZlRnJvbUV4ZWN1dG9yKGV4ZWN1dG9yKTtcbiAgICB0aGlzLl9wcm9taXNlQ3JlYXRlZCgpO1xuICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VDcmVhdGVkXCIsIHRoaXMpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5jYXVnaHQgPSBQcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgdmFyIGNhdGNoSW5zdGFuY2VzID0gbmV3IEFycmF5KGxlbiAtIDEpLFxuICAgICAgICAgICAgaiA9IDAsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBjYXRjaEluc3RhbmNlc1tqKytdID0gaXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcIkNhdGNoIHN0YXRlbWVudCBwcmVkaWNhdGU6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJleHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGl0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaEluc3RhbmNlcy5sZW5ndGggPSBqO1xuICAgICAgICBmbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGNhdGNoRmlsdGVyKGNhdGNoSW5zdGFuY2VzLCBmbiwgdGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgZm4pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmVmbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihyZWZsZWN0SGFuZGxlcixcbiAgICAgICAgcmVmbGVjdEhhbmRsZXIsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0KSB7XG4gICAgaWYgKGRlYnVnLndhcm5pbmdzKCkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgdHlwZW9mIGRpZEZ1bGZpbGwgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZGlkUmVqZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIG1zZyA9IFwiLnRoZW4oKSBvbmx5IGFjY2VwdHMgZnVuY3Rpb25zIGJ1dCB3YXMgcGFzc2VkOiBcIiArXG4gICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyhkaWRGdWxmaWxsKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBtc2cgKz0gXCIsIFwiICsgdXRpbC5jbGFzc1N0cmluZyhkaWRSZWplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dhcm4obXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0KSB7XG4gICAgdmFyIHByb21pc2UgPVxuICAgICAgICB0aGlzLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgcHJvbWlzZS5fc2V0SXNGaW5hbCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbGwoKS5fdGhlbihmbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIEFQUExZLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXQgPSB7XG4gICAgICAgIGlzRnVsZmlsbGVkOiBmYWxzZSxcbiAgICAgICAgaXNSZWplY3RlZDogZmFsc2UsXG4gICAgICAgIGZ1bGZpbGxtZW50VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVqZWN0aW9uUmVhc29uOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmICh0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgcmV0LmZ1bGZpbGxtZW50VmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgIHJldC5pc0Z1bGZpbGxlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICByZXQucmVqZWN0aW9uUmVhc29uID0gdGhpcy5yZWFzb24oKTtcbiAgICAgICAgcmV0LmlzUmVqZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl93YXJuKFwiLmFsbCgpIHdhcyBwYXNzZWQgYXJndW1lbnRzIGJ1dCBpdCBkb2VzIG5vdCB0YWtlIGFueVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlQXJyYXkodGhpcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5jYXVnaHQodXRpbC5vcmlnaW5hdGVzRnJvbVJlamVjdGlvbiwgZm4pO1xufTtcblxuUHJvbWlzZS5nZXROZXdMaWJyYXJ5Q29weSA9IG1vZHVsZS5leHBvcnRzO1xuXG5Qcm9taXNlLmlzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBQcm9taXNlO1xufTtcblxuUHJvbWlzZS5mcm9tTm9kZSA9IFByb21pc2UuZnJvbUNhbGxiYWNrID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB2YXIgbXVsdGlBcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAhIU9iamVjdChhcmd1bWVudHNbMV0pLm11bHRpQXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaChmbikobm9kZWJhY2tGb3JQcm9taXNlKHJldCwgbXVsdGlBcmdzKSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcmV0Ll9yZWplY3RDYWxsYmFjayhyZXN1bHQuZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICghcmV0Ll9pc0ZhdGVTZWFsZWQoKSkgcmV0Ll9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VBcnJheShwcm9taXNlcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5jYXN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXQgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKG9iaik7XG4gICAgaWYgKCEocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIHJldC5fc2V0RnVsZmlsbGVkKCk7XG4gICAgICAgIHJldC5fcmVqZWN0aW9uSGFuZGxlcjAgPSBvYmo7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnJlc29sdmUgPSBQcm9taXNlLmZ1bGZpbGxlZCA9IFByb21pc2UuY2FzdDtcblxuUHJvbWlzZS5yZWplY3QgPSBQcm9taXNlLnJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHJldC5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCB0cnVlKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5zZXRTY2hlZHVsZXIgPSBmdW5jdGlvbihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzeW5jLnNldFNjaGVkdWxlcihmbik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdGhlbiA9IGZ1bmN0aW9uIChcbiAgICBkaWRGdWxmaWxsLFxuICAgIGRpZFJlamVjdCxcbiAgICBfLCAgICByZWNlaXZlcixcbiAgICBpbnRlcm5hbERhdGFcbikge1xuICAgIHZhciBoYXZlSW50ZXJuYWxEYXRhID0gaW50ZXJuYWxEYXRhICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIHByb21pc2UgPSBoYXZlSW50ZXJuYWxEYXRhID8gaW50ZXJuYWxEYXRhIDogbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB2YXIgYml0RmllbGQgPSB0YXJnZXQuX2JpdEZpZWxkO1xuXG4gICAgaWYgKCFoYXZlSW50ZXJuYWxEYXRhKSB7XG4gICAgICAgIHByb21pc2UuX3Byb3BhZ2F0ZUZyb20odGhpcywgMyk7XG4gICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoKHRoaXMuX2JpdEZpZWxkICYgMjA5NzE1MikgIT09IDApKSB7XG4gICAgICAgICAgICBpZiAoISgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLl9ib3VuZFZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0gdGFyZ2V0ID09PSB0aGlzID8gdW5kZWZpbmVkIDogdGhpcy5fYm91bmRUbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ2hhaW5lZFwiLCB0aGlzLCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgaWYgKCEoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICB2YXIgaGFuZGxlciwgdmFsdWUsIHNldHRsZXIgPSB0YXJnZXQuX3NldHRsZVByb21pc2VDdHg7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0YXJnZXQuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZEZ1bGZpbGw7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGFyZ2V0Ll9mdWxmaWxsbWVudEhhbmRsZXIwO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZFJlamVjdDtcbiAgICAgICAgICAgIHRhcmdldC5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0dGxlciA9IHRhcmdldC5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlcjtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IENhbmNlbGxhdGlvbkVycm9yKFwibGF0ZSBjYW5jZWxsYXRpb24gb2JzZXJ2ZXJcIik7XG4gICAgICAgICAgICB0YXJnZXQuX2F0dGFjaEV4dHJhVHJhY2UodmFsdWUpO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZFJlamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jLmludm9rZShzZXR0bGVyLCB0YXJnZXQsIHtcbiAgICAgICAgICAgIGhhbmRsZXI6IGRvbWFpbiA9PT0gbnVsbCA/IGhhbmRsZXJcbiAgICAgICAgICAgICAgICA6ICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgIHV0aWwuZG9tYWluQmluZChkb21haW4sIGhhbmRsZXIpKSxcbiAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICByZWNlaXZlcjogcmVjZWl2ZXIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Ll9hZGRDYWxsYmFja3MoZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgZG9tYWluKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpdEZpZWxkICYgNjU1MzU7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGYXRlU2VhbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxMTc1MDYwNDgpICE9PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzRm9sbG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA2NzEwODg2NCkgPT09IDY3MTA4ODY0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9ICh0aGlzLl9iaXRGaWVsZCAmIC02NTUzNikgfFxuICAgICAgICAobGVuICYgNjU1MzUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMzM1NTQ0MzI7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZUZ1bGZpbGxlZFwiLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTY3NzcyMTY7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZVJlamVjdGVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNjcxMDg4NjQ7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZVJlc29sdmVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldElzRmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDQxOTQzMDQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGaW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNDE5NDMwNCkgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+NjU1MzYpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA2NTUzNjtcbiAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ2FuY2VsbGVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFdpbGxCZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA4Mzg4NjA4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEFzeW5jR3VhcmFudGVlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChhc3luYy5oYXNDdXN0b21TY2hlZHVsZXIoKSkgcmV0dXJuO1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxMzQyMTc3Mjg7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVjZWl2ZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciByZXQgPSBpbmRleCA9PT0gMCA/IHRoaXMuX3JlY2VpdmVyMCA6IHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgM107XG4gICAgaWYgKHJldCA9PT0gVU5ERUZJTkVEX0JJTkRJTkcpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHJldCA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2lzQm91bmQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRWYWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA0IC0gNCArIDJdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxtZW50SGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgMF07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0aW9uSGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgMV07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYm91bmRWYWx1ZSA9IGZ1bmN0aW9uKCkge307XG5cblByb21pc2UucHJvdG90eXBlLl9taWdyYXRlQ2FsbGJhY2swID0gZnVuY3Rpb24gKGZvbGxvd2VyKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gZm9sbG93ZXIuX2JpdEZpZWxkO1xuICAgIHZhciBmdWxmaWxsID0gZm9sbG93ZXIuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgdmFyIHJlamVjdCA9IGZvbGxvd2VyLl9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICB2YXIgcHJvbWlzZSA9IGZvbGxvd2VyLl9wcm9taXNlMDtcbiAgICB2YXIgcmVjZWl2ZXIgPSBmb2xsb3dlci5fcmVjZWl2ZXJBdCgwKTtcbiAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCkgcmVjZWl2ZXIgPSBVTkRFRklORURfQklORElORztcbiAgICB0aGlzLl9hZGRDYWxsYmFja3MoZnVsZmlsbCwgcmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbWlncmF0ZUNhbGxiYWNrQXQgPSBmdW5jdGlvbiAoZm9sbG93ZXIsIGluZGV4KSB7XG4gICAgdmFyIGZ1bGZpbGwgPSBmb2xsb3dlci5fZnVsZmlsbG1lbnRIYW5kbGVyQXQoaW5kZXgpO1xuICAgIHZhciByZWplY3QgPSBmb2xsb3dlci5fcmVqZWN0aW9uSGFuZGxlckF0KGluZGV4KTtcbiAgICB2YXIgcHJvbWlzZSA9IGZvbGxvd2VyLl9wcm9taXNlQXQoaW5kZXgpO1xuICAgIHZhciByZWNlaXZlciA9IGZvbGxvd2VyLl9yZWNlaXZlckF0KGluZGV4KTtcbiAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCkgcmVjZWl2ZXIgPSBVTkRFRklORURfQklORElORztcbiAgICB0aGlzLl9hZGRDYWxsYmFja3MoZnVsZmlsbCwgcmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYWRkQ2FsbGJhY2tzID0gZnVuY3Rpb24gKFxuICAgIGZ1bGZpbGwsXG4gICAgcmVqZWN0LFxuICAgIHByb21pc2UsXG4gICAgcmVjZWl2ZXIsXG4gICAgZG9tYWluXG4pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9sZW5ndGgoKTtcblxuICAgIGlmIChpbmRleCA+PSA2NTUzNSAtIDQpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UwID0gcHJvbWlzZTtcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIwID0gcmVjZWl2ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZnVsZmlsbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyBmdWxmaWxsIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZnVsZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPVxuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gbnVsbCA/IHJlamVjdCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmFzZSA9IGluZGV4ICogNCAtIDQ7XG4gICAgICAgIHRoaXNbYmFzZSArIDJdID0gcHJvbWlzZTtcbiAgICAgICAgdGhpc1tiYXNlICsgM10gPSByZWNlaXZlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmdWxmaWxsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXNbYmFzZSArIDBdID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyBmdWxmaWxsIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZnVsZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpc1tiYXNlICsgMV0gPVxuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gbnVsbCA/IHJlamVjdCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc2V0TGVuZ3RoKGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIGluZGV4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb3h5ID0gZnVuY3Rpb24gKHByb3h5YWJsZSwgYXJnKSB7XG4gICAgdGhpcy5fYWRkQ2FsbGJhY2tzKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmcsIHByb3h5YWJsZSwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUNhbGxiYWNrID0gZnVuY3Rpb24odmFsdWUsIHNob3VsZEJpbmQpIHtcbiAgICBpZiAoKCh0aGlzLl9iaXRGaWVsZCAmIDExNzUwNjA0OCkgIT09IDApKSByZXR1cm47XG4gICAgaWYgKHZhbHVlID09PSB0aGlzKVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0Q2FsbGJhY2sobWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IoKSwgZmFsc2UpO1xuICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlLCB0aGlzKTtcbiAgICBpZiAoIShtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkgcmV0dXJuIHRoaXMuX2Z1bGZpbGwodmFsdWUpO1xuXG4gICAgaWYgKHNob3VsZEJpbmQpIHRoaXMuX3Byb3BhZ2F0ZUZyb20obWF5YmVQcm9taXNlLCAyKTtcblxuICAgIHZhciBwcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcblxuICAgIGlmIChwcm9taXNlID09PSB0aGlzKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdChtYWtlU2VsZlJlc29sdXRpb25FcnJvcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoKCk7XG4gICAgICAgIGlmIChsZW4gPiAwKSBwcm9taXNlLl9taWdyYXRlQ2FsbGJhY2swKHRoaXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9taWdyYXRlQ2FsbGJhY2tBdCh0aGlzLCBpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRGb2xsb3dpbmcoKTtcbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgICAgICB0aGlzLl9zZXRGb2xsb3dlZShwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgIHRoaXMuX2Z1bGZpbGwocHJvbWlzZS5fdmFsdWUoKSk7XG4gICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICB0aGlzLl9yZWplY3QocHJvbWlzZS5fcmVhc29uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZWFzb24gPSBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoXCJsYXRlIGNhbmNlbGxhdGlvbiBvYnNlcnZlclwiKTtcbiAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgICAgICB0aGlzLl9yZWplY3QocmVhc29uKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0Q2FsbGJhY2sgPVxuZnVuY3Rpb24ocmVhc29uLCBzeW5jaHJvbm91cywgaWdub3JlTm9uRXJyb3JXYXJuaW5ncykge1xuICAgIHZhciB0cmFjZSA9IHV0aWwuZW5zdXJlRXJyb3JPYmplY3QocmVhc29uKTtcbiAgICB2YXIgaGFzU3RhY2sgPSB0cmFjZSA9PT0gcmVhc29uO1xuICAgIGlmICghaGFzU3RhY2sgJiYgIWlnbm9yZU5vbkVycm9yV2FybmluZ3MgJiYgZGVidWcud2FybmluZ3MoKSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiYSBwcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgbm9uLWVycm9yOiBcIiArXG4gICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKHJlYXNvbik7XG4gICAgICAgIHRoaXMuX3dhcm4obWVzc2FnZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UodHJhY2UsIHN5bmNocm9ub3VzID8gaGFzU3RhY2sgOiBmYWxzZSk7XG4gICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUZyb21FeGVjdXRvciA9IGZ1bmN0aW9uIChleGVjdXRvcikge1xuICAgIGlmIChleGVjdXRvciA9PT0gSU5URVJOQUwpIHJldHVybjtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdGhpcy5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB0aGlzLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciBzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgdmFyIHIgPSB0aGlzLl9leGVjdXRlKGV4ZWN1dG9yLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBzeW5jaHJvbm91cyk7XG4gICAgfSk7XG4gICAgc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICB0aGlzLl9wb3BDb250ZXh0KCk7XG5cbiAgICBpZiAociAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHIsIHRydWUpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIgPSBmdW5jdGlvbiAoXG4gICAgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlXG4pIHtcbiAgICB2YXIgYml0RmllbGQgPSBwcm9taXNlLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDY1NTM2KSAhPT0gMCkpIHJldHVybjtcbiAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciB4O1xuICAgIGlmIChyZWNlaXZlciA9PT0gQVBQTFkpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB4ID0gZXJyb3JPYmo7XG4gICAgICAgICAgICB4LmUgPSBuZXcgVHlwZUVycm9yKFwiY2Fubm90IC5zcHJlYWQoKSBhIG5vbi1hcnJheTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmFwcGx5KHRoaXMuX2JvdW5kVmFsdWUoKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIGJpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSByZXR1cm47XG5cbiAgICBpZiAoeCA9PT0gTkVYVF9GSUxURVIpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHggPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHguZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyh4LCBwcm9taXNlQ3JlYXRlZCwgXCJcIiwgIHByb21pc2UsIHRoaXMpO1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2soeCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3RhcmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXQgPSB0aGlzO1xuICAgIHdoaWxlIChyZXQuX2lzRm9sbG93aW5nKCkpIHJldCA9IHJldC5fZm9sbG93ZWUoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ZvbGxvd2VlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2VlID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlID0gZnVuY3Rpb24ocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKSB7XG4gICAgdmFyIGlzUHJvbWlzZSA9IHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlO1xuICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgIHZhciBhc3luY0d1YXJhbnRlZWQgPSAoKGJpdEZpZWxkICYgMTM0MjE3NzI4KSAhPT0gMCk7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSB7XG4gICAgICAgIGlmIChpc1Byb21pc2UpIHByb21pc2UuX2ludm9rZUludGVybmFsT25DYW5jZWwoKTtcblxuICAgICAgICBpZiAocmVjZWl2ZXIgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0ICYmXG4gICAgICAgICAgICByZWNlaXZlci5pc0ZpbmFsbHlIYW5kbGVyKCkpIHtcbiAgICAgICAgICAgIHJlY2VpdmVyLmNhbmNlbFByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgaWYgKHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3QoZXJyb3JPYmouZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9PT0gcmVmbGVjdEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwocmVmbGVjdEhhbmRsZXIuY2FsbChyZWNlaXZlcikpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyIGluc3RhbmNlb2YgUHJveHlhYmxlKSB7XG4gICAgICAgICAgICByZWNlaXZlci5fcHJvbWlzZUNhbmNlbGxlZChwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UgfHwgcHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2VBcnJheSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fY2FuY2VsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNlaXZlci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIWlzUHJvbWlzZSkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXN5bmNHdWFyYW50ZWVkKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlcihoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWNlaXZlciBpbnN0YW5jZW9mIFByb3h5YWJsZSkge1xuICAgICAgICBpZiAoIXJlY2VpdmVyLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyLl9wcm9taXNlRnVsZmlsbGVkKHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIuX3Byb21pc2VSZWplY3RlZCh2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZSkge1xuICAgICAgICBpZiAoYXN5bmNHdWFyYW50ZWVkKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UuX3JlamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlciA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHZhciBoYW5kbGVyID0gY3R4LmhhbmRsZXI7XG4gICAgdmFyIHByb21pc2UgPSBjdHgucHJvbWlzZTtcbiAgICB2YXIgcmVjZWl2ZXIgPSBjdHgucmVjZWl2ZXI7XG4gICAgdmFyIHZhbHVlID0gY3R4LnZhbHVlO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIoaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUN0eCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHRoaXMuX3NldHRsZVByb21pc2UoY3R4LnByb21pc2UsIGN0eC5oYW5kbGVyLCBjdHgucmVjZWl2ZXIsIGN0eC52YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZTAgPSBmdW5jdGlvbihoYW5kbGVyLCB2YWx1ZSwgYml0RmllbGQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UwO1xuICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoMCk7XG4gICAgdGhpcy5fcHJvbWlzZTAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVjZWl2ZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NldHRsZVByb21pc2UocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHZhciBiYXNlID0gaW5kZXggKiA0IC0gNDtcbiAgICB0aGlzW2Jhc2UgKyAyXSA9XG4gICAgdGhpc1tiYXNlICsgM10gPVxuICAgIHRoaXNbYmFzZSArIDBdID1cbiAgICB0aGlzW2Jhc2UgKyAxXSA9IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiAxMTc1MDYwNDgpID4+PiAxNikpIHJldHVybjtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMpIHtcbiAgICAgICAgdmFyIGVyciA9IG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCk7XG4gICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdChlcnIpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRGdWxmaWxsZWQoKTtcbiAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCA9IHZhbHVlO1xuXG4gICAgaWYgKChiaXRGaWVsZCAmIDY1NTM1KSA+IDApIHtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAxMzQyMTc3MjgpICE9PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLnNldHRsZVByb21pc2VzKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDExNzUwNjA0OCkgPj4+IDE2KSkgcmV0dXJuO1xuICAgIHRoaXMuX3NldFJlamVjdGVkKCk7XG4gICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IHJlYXNvbjtcblxuICAgIGlmICh0aGlzLl9pc0ZpbmFsKCkpIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jLmZhdGFsRXJyb3IocmVhc29uLCB1dGlsLmlzTm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKChiaXRGaWVsZCAmIDY1NTM1KSA+IDApIHtcbiAgICAgICAgYXN5bmMuc2V0dGxlUHJvbWlzZXModGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlUG9zc2libGVSZWplY3Rpb25IYW5kbGVkKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxQcm9taXNlcyA9IGZ1bmN0aW9uIChsZW4sIHZhbHVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlckF0KGkpO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2VBdChpKTtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcmVjZWl2ZXJBdChpKTtcbiAgICAgICAgdGhpcy5fY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4KGkpO1xuICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlKHByb21pc2UsIGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdFByb21pc2VzID0gZnVuY3Rpb24gKGxlbiwgcmVhc29uKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX3JlamVjdGlvbkhhbmRsZXJBdChpKTtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlQXQoaSk7XG4gICAgICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoaSk7XG4gICAgICAgIHRoaXMuX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleChpKTtcbiAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZShwcm9taXNlLCBoYW5kbGVyLCByZWNlaXZlciwgcmVhc29uKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgdmFyIGxlbiA9IChiaXRGaWVsZCAmIDY1NTM1KTtcblxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgMTY4NDI3NTIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlMCh0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCwgcmVhc29uLCBiaXRGaWVsZCk7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3RQcm9taXNlcyhsZW4sIHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2UwKHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjAsIHZhbHVlLCBiaXRGaWVsZCk7XG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsUHJvbWlzZXMobGVuLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgIH1cbiAgICB0aGlzLl9jbGVhckNhbmNlbGxhdGlvbkRhdGEoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVkVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZGVmZXJSZXNvbHZlKHYpIHt0aGlzLnByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2KTt9XG5mdW5jdGlvbiBkZWZlclJlamVjdCh2KSB7dGhpcy5wcm9taXNlLl9yZWplY3RDYWxsYmFjayh2LCBmYWxzZSk7fVxuXG5Qcm9taXNlLmRlZmVyID0gUHJvbWlzZS5wZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcuZGVwcmVjYXRlZChcIlByb21pc2UuZGVmZXJcIiwgXCJuZXcgUHJvbWlzZVwiKTtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICByZXNvbHZlOiBkZWZlclJlc29sdmUsXG4gICAgICAgIHJlamVjdDogZGVmZXJSZWplY3RcbiAgICB9O1xufTtcblxudXRpbC5ub3RFbnVtZXJhYmxlUHJvcChQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICBcIl9tYWtlU2VsZlJlc29sdXRpb25FcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICBtYWtlU2VsZlJlc29sdXRpb25FcnJvcik7XG5cbnJlcXVpcmUoXCIuL21ldGhvZFwiKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uLFxuICAgIGRlYnVnKTtcbnJlcXVpcmUoXCIuL2JpbmRcIikoUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGRlYnVnKTtcbnJlcXVpcmUoXCIuL2NhbmNlbFwiKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgZGVidWcpO1xucmVxdWlyZShcIi4vZGlyZWN0X3Jlc29sdmVcIikoUHJvbWlzZSk7XG5yZXF1aXJlKFwiLi9zeW5jaHJvbm91c19pbnNwZWN0aW9uXCIpKFByb21pc2UpO1xucmVxdWlyZShcIi4vam9pblwiKShcbiAgICBQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBhc3luYywgZ2V0RG9tYWluKTtcblByb21pc2UuUHJvbWlzZSA9IFByb21pc2U7XG5Qcm9taXNlLnZlcnNpb24gPSBcIjMuNS4wXCI7XG5yZXF1aXJlKCcuL21hcC5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpO1xucmVxdWlyZSgnLi9jYWxsX2dldC5qcycpKFByb21pc2UpO1xucmVxdWlyZSgnLi91c2luZy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgY3JlYXRlQ29udGV4dCwgSU5URVJOQUwsIGRlYnVnKTtcbnJlcXVpcmUoJy4vdGltZXJzLmpzJykoUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKTtcbnJlcXVpcmUoJy4vZ2VuZXJhdG9ycy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIFByb3h5YWJsZSwgZGVidWcpO1xucmVxdWlyZSgnLi9ub2RlaWZ5LmpzJykoUHJvbWlzZSk7XG5yZXF1aXJlKCcuL3Byb21pc2lmeS5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcbnJlcXVpcmUoJy4vcHJvcHMuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbik7XG5yZXF1aXJlKCcuL3JhY2UuanMnKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKTtcbnJlcXVpcmUoJy4vcmVkdWNlLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBkZWJ1Zyk7XG5yZXF1aXJlKCcuL3NldHRsZS5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgZGVidWcpO1xucmVxdWlyZSgnLi9zb21lLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pO1xucmVxdWlyZSgnLi9maWx0ZXIuanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5yZXF1aXJlKCcuL2VhY2guanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5yZXF1aXJlKCcuL2FueS5qcycpKFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKFByb21pc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHV0aWwudG9GYXN0UHJvcGVydGllcyhQcm9taXNlLnByb3RvdHlwZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmdW5jdGlvbiBmaWxsVHlwZXModmFsdWUpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHZhciBwID0gbmV3IFByb21pc2UoSU5URVJOQUwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcC5fcmVqZWN0aW9uSGFuZGxlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX3Byb21pc2UwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9yZWNlaXZlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgLy8gQ29tcGxldGUgc2xhY2sgdHJhY2tpbmcsIG9wdCBvdXQgb2YgZmllbGQtdHlwZSB0cmFja2luZyBhbmQgICAgICAgICAgIFxuICAgIC8vIHN0YWJpbGl6ZSBtYXAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoe2E6IDF9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHtiOiAyfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh7YzogM30pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoMSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKGZ1bmN0aW9uKCl7fSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh1bmRlZmluZWQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoZmFsc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKG5ldyBQcm9taXNlKElOVEVSTkFMKSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGRlYnVnLnNldEJvdW5kcyhBc3luYy5maXJzdExpbmVFcnJvciwgdXRpbC5sYXN0TGluZUVycm9yKTsgICAgICAgICAgICAgICBcbiAgICByZXR1cm4gUHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBlczUgPSByZXF1aXJlKFwiLi9lczVcIik7XG52YXIgY2FuRXZhbHVhdGUgPSB0eXBlb2YgbmF2aWdhdG9yID09IFwidW5kZWZpbmVkXCI7XG5cbnZhciBlcnJvck9iaiA9IHtlOiB7fX07XG52YXIgdHJ5Q2F0Y2hUYXJnZXQ7XG52YXIgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDpcbiAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDpcbiAgICB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDpcbiAgICB0aGlzICE9PSB1bmRlZmluZWQgPyB0aGlzIDogbnVsbDtcblxuZnVuY3Rpb24gdHJ5Q2F0Y2hlcigpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdHJ5Q2F0Y2hUYXJnZXQ7XG4gICAgICAgIHRyeUNhdGNoVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JPYmouZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICB9XG59XG5mdW5jdGlvbiB0cnlDYXRjaChmbikge1xuICAgIHRyeUNhdGNoVGFyZ2V0ID0gZm47XG4gICAgcmV0dXJuIHRyeUNhdGNoZXI7XG59XG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uKENoaWxkLCBQYXJlbnQpIHtcbiAgICB2YXIgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gICAgZnVuY3Rpb24gVCgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IENoaWxkO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yJCA9IFBhcmVudDtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIFBhcmVudC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGlmIChoYXNQcm9wLmNhbGwoUGFyZW50LnByb3RvdHlwZSwgcHJvcGVydHlOYW1lKSAmJlxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZS5jaGFyQXQocHJvcGVydHlOYW1lLmxlbmd0aC0xKSAhPT0gXCIkXCJcbiAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWUgKyBcIiRcIl0gPSBQYXJlbnQucHJvdG90eXBlW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgVC5wcm90b3R5cGUgPSBQYXJlbnQucHJvdG90eXBlO1xuICAgIENoaWxkLnByb3RvdHlwZSA9IG5ldyBUKCk7XG4gICAgcmV0dXJuIENoaWxkLnByb3RvdHlwZTtcbn07XG5cblxuZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gdHJ1ZSB8fCB2YWwgPT09IGZhbHNlIHx8XG4gICAgICAgIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIjtcblxufVxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIG1heWJlV3JhcEFzRXJyb3IobWF5YmVFcnJvcikge1xuICAgIGlmICghaXNQcmltaXRpdmUobWF5YmVFcnJvcikpIHJldHVybiBtYXliZUVycm9yO1xuXG4gICAgcmV0dXJuIG5ldyBFcnJvcihzYWZlVG9TdHJpbmcobWF5YmVFcnJvcikpO1xufVxuXG5mdW5jdGlvbiB3aXRoQXBwZW5kZWQodGFyZ2V0LCBhcHBlbmRlZSkge1xuICAgIHZhciBsZW4gPSB0YXJnZXQubGVuZ3RoO1xuICAgIHZhciByZXQgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHJldFtpXSA9IHRhcmdldFtpXTtcbiAgICB9XG4gICAgcmV0W2ldID0gYXBwZW5kZWU7XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0KG9iaiwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoZXM1LmlzRVM1KSB7XG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG5cbiAgICAgICAgaWYgKGRlc2MgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0ID09IG51bGwgJiYgZGVzYy5zZXQgPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICA/IGRlc2MudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgPyBvYmpba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vdEVudW1lcmFibGVQcm9wKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoaXNQcmltaXRpdmUob2JqKSkgcmV0dXJuIG9iajtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH07XG4gICAgZXM1LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwgZGVzY3JpcHRvcik7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gdGhyb3dlcihyKSB7XG4gICAgdGhyb3cgcjtcbn1cblxudmFyIGluaGVyaXRlZERhdGFLZXlzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBleGNsdWRlZFByb3RvdHlwZXMgPSBbXG4gICAgICAgIEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlXG4gICAgXTtcblxuICAgIHZhciBpc0V4Y2x1ZGVkUHJvdG8gPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGNsdWRlZFByb3RvdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChleGNsdWRlZFByb3RvdHlwZXNbaV0gPT09IHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgaWYgKGVzNS5pc0VTNSkge1xuICAgICAgICB2YXIgZ2V0S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgICB2YXIgdmlzaXRlZEtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgd2hpbGUgKG9iaiAhPSBudWxsICYmICFpc0V4Y2x1ZGVkUHJvdG8ob2JqKSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMgPSBnZXRLZXlzKG9iaik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkS2V5c1trZXldKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZEtleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXNjICE9IG51bGwgJiYgZGVzYy5nZXQgPT0gbnVsbCAmJiBkZXNjLnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9iaiA9IGVzNS5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBpZiAoaXNFeGNsdWRlZFByb3RvKG9iaikpIHJldHVybiBbXTtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgICAgICAgLypqc2hpbnQgZm9yaW46ZmFsc2UgKi9cbiAgICAgICAgICAgIGVudW1lcmF0aW9uOiBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1Byb3AuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4Y2x1ZGVkUHJvdG90eXBlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1Byb3AuY2FsbChleGNsdWRlZFByb3RvdHlwZXNbaV0sIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBlbnVtZXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG59KSgpO1xuXG52YXIgdGhpc0Fzc2lnbm1lbnRQYXR0ZXJuID0gL3RoaXNcXHMqXFwuXFxzKlxcUytcXHMqPS87XG5mdW5jdGlvbiBpc0NsYXNzKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IGVzNS5uYW1lcyhmbi5wcm90b3R5cGUpO1xuXG4gICAgICAgICAgICB2YXIgaGFzTWV0aG9kcyA9IGVzNS5pc0VTNSAmJiBrZXlzLmxlbmd0aCA+IDE7XG4gICAgICAgICAgICB2YXIgaGFzTWV0aG9kc090aGVyVGhhbkNvbnN0cnVjdG9yID0ga2V5cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgIShrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSBcImNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgdmFyIGhhc1RoaXNBc3NpZ25tZW50QW5kU3RhdGljTWV0aG9kcyA9XG4gICAgICAgICAgICAgICAgdGhpc0Fzc2lnbm1lbnRQYXR0ZXJuLnRlc3QoZm4gKyBcIlwiKSAmJiBlczUubmFtZXMoZm4pLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgICAgIGlmIChoYXNNZXRob2RzIHx8IGhhc01ldGhvZHNPdGhlclRoYW5Db25zdHJ1Y3RvciB8fFxuICAgICAgICAgICAgICAgIGhhc1RoaXNBc3NpZ25tZW50QW5kU3RhdGljTWV0aG9kcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRvRmFzdFByb3BlcnRpZXMob2JqKSB7XG4gICAgLypqc2hpbnQgLVcwMjcsLVcwNTUsLVcwMzEqL1xuICAgIGZ1bmN0aW9uIEZha2VDb25zdHJ1Y3RvcigpIHt9XG4gICAgRmFrZUNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG9iajtcbiAgICB2YXIgbCA9IDg7XG4gICAgd2hpbGUgKGwtLSkgbmV3IEZha2VDb25zdHJ1Y3RvcigpO1xuICAgIHJldHVybiBvYmo7XG4gICAgZXZhbChvYmopO1xufVxuXG52YXIgcmlkZW50ID0gL15bYS16JF9dW2EteiRfMC05XSokL2k7XG5mdW5jdGlvbiBpc0lkZW50aWZpZXIoc3RyKSB7XG4gICAgcmV0dXJuIHJpZGVudC50ZXN0KHN0cik7XG59XG5cbmZ1bmN0aW9uIGZpbGxlZFJhbmdlKGNvdW50LCBwcmVmaXgsIHN1ZmZpeCkge1xuICAgIHZhciByZXQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIHJldFtpXSA9IHByZWZpeCArIGkgKyBzdWZmaXg7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNhZmVUb1N0cmluZyhvYmopIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gb2JqICsgXCJcIjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBcIltubyBzdHJpbmcgcmVwcmVzZW50YXRpb25dXCI7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0Vycm9yKG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiZcbiAgICAgICAgICAgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICB0eXBlb2Ygb2JqLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgdHlwZW9mIG9iai5uYW1lID09PSBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBtYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24oZSkge1xuICAgIHRyeSB7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKGUsIFwiaXNPcGVyYXRpb25hbFwiLCB0cnVlKTtcbiAgICB9XG4gICAgY2F0Y2goaWdub3JlKSB7fVxufVxuXG5mdW5jdGlvbiBvcmlnaW5hdGVzRnJvbVJlamVjdGlvbihlKSB7XG4gICAgaWYgKGUgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAoKGUgaW5zdGFuY2VvZiBFcnJvcltcIl9fQmx1ZWJpcmRFcnJvclR5cGVzX19cIl0uT3BlcmF0aW9uYWxFcnJvcikgfHxcbiAgICAgICAgZVtcImlzT3BlcmF0aW9uYWxcIl0gPT09IHRydWUpO1xufVxuXG5mdW5jdGlvbiBjYW5BdHRhY2hUcmFjZShvYmopIHtcbiAgICByZXR1cm4gaXNFcnJvcihvYmopICYmIGVzNS5wcm9wZXJ0eUlzV3JpdGFibGUob2JqLCBcInN0YWNrXCIpO1xufVxuXG52YXIgZW5zdXJlRXJyb3JPYmplY3QgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEoXCJzdGFja1wiIGluIG5ldyBFcnJvcigpKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYW5BdHRhY2hUcmFjZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7dGhyb3cgbmV3IEVycm9yKHNhZmVUb1N0cmluZyh2YWx1ZSkpO31cbiAgICAgICAgICAgIGNhdGNoKGVycikge3JldHVybiBlcnI7fVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNhbkF0dGFjaFRyYWNlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihzYWZlVG9TdHJpbmcodmFsdWUpKTtcbiAgICAgICAgfTtcbiAgICB9XG59KSgpO1xuXG5mdW5jdGlvbiBjbGFzc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbChvYmopO1xufVxuXG5mdW5jdGlvbiBjb3B5RGVzY3JpcHRvcnMoZnJvbSwgdG8sIGZpbHRlcikge1xuICAgIHZhciBrZXlzID0gZXM1Lm5hbWVzKGZyb20pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGZpbHRlcihrZXkpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVzNS5kZWZpbmVQcm9wZXJ0eSh0bywga2V5LCBlczUuZ2V0RGVzY3JpcHRvcihmcm9tLCBrZXkpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIGFzQXJyYXkgPSBmdW5jdGlvbih2KSB7XG4gICAgaWYgKGVzNS5pc0FycmF5KHYpKSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvcikge1xuICAgIHZhciBBcnJheUZyb20gPSB0eXBlb2YgQXJyYXkuZnJvbSA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2KTtcbiAgICB9IDogZnVuY3Rpb24odikge1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIHZhciBpdCA9IHZbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICB2YXIgaXRSZXN1bHQ7XG4gICAgICAgIHdoaWxlICghKChpdFJlc3VsdCA9IGl0Lm5leHQoKSkuZG9uZSkpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGl0UmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBhc0FycmF5ID0gZnVuY3Rpb24odikge1xuICAgICAgICBpZiAoZXM1LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9IGVsc2UgaWYgKHYgIT0gbnVsbCAmJiB0eXBlb2YgdltTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheUZyb20odik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbn1cblxudmFyIGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIGNsYXNzU3RyaW5nKHByb2Nlc3MpLnRvTG93ZXJDYXNlKCkgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiO1xuXG52YXIgaGFzRW52VmFyaWFibGVzID0gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5lbnYgIT09IFwidW5kZWZpbmVkXCI7XG5cbmZ1bmN0aW9uIGVudihrZXkpIHtcbiAgICByZXR1cm4gaGFzRW52VmFyaWFibGVzID8gcHJvY2Vzcy5lbnZba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0TmF0aXZlUHJvbWlzZSgpIHtcbiAgICBpZiAodHlwZW9mIFByb21pc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbigpe30pO1xuICAgICAgICAgICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwocHJvbWlzZSkgPT09IFwiW29iamVjdCBQcm9taXNlXVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkb21haW5CaW5kKHNlbGYsIGNiKSB7XG4gICAgcmV0dXJuIHNlbGYuYmluZChjYik7XG59XG5cbnZhciByZXQgPSB7XG4gICAgaXNDbGFzczogaXNDbGFzcyxcbiAgICBpc0lkZW50aWZpZXI6IGlzSWRlbnRpZmllcixcbiAgICBpbmhlcml0ZWREYXRhS2V5czogaW5oZXJpdGVkRGF0YUtleXMsXG4gICAgZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0OiBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQsXG4gICAgdGhyb3dlcjogdGhyb3dlcixcbiAgICBpc0FycmF5OiBlczUuaXNBcnJheSxcbiAgICBhc0FycmF5OiBhc0FycmF5LFxuICAgIG5vdEVudW1lcmFibGVQcm9wOiBub3RFbnVtZXJhYmxlUHJvcCxcbiAgICBpc1ByaW1pdGl2ZTogaXNQcmltaXRpdmUsXG4gICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgIGlzRXJyb3I6IGlzRXJyb3IsXG4gICAgY2FuRXZhbHVhdGU6IGNhbkV2YWx1YXRlLFxuICAgIGVycm9yT2JqOiBlcnJvck9iaixcbiAgICB0cnlDYXRjaDogdHJ5Q2F0Y2gsXG4gICAgaW5oZXJpdHM6IGluaGVyaXRzLFxuICAgIHdpdGhBcHBlbmRlZDogd2l0aEFwcGVuZGVkLFxuICAgIG1heWJlV3JhcEFzRXJyb3I6IG1heWJlV3JhcEFzRXJyb3IsXG4gICAgdG9GYXN0UHJvcGVydGllczogdG9GYXN0UHJvcGVydGllcyxcbiAgICBmaWxsZWRSYW5nZTogZmlsbGVkUmFuZ2UsXG4gICAgdG9TdHJpbmc6IHNhZmVUb1N0cmluZyxcbiAgICBjYW5BdHRhY2hUcmFjZTogY2FuQXR0YWNoVHJhY2UsXG4gICAgZW5zdXJlRXJyb3JPYmplY3Q6IGVuc3VyZUVycm9yT2JqZWN0LFxuICAgIG9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uOiBvcmlnaW5hdGVzRnJvbVJlamVjdGlvbixcbiAgICBtYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb246IG1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbixcbiAgICBjbGFzc1N0cmluZzogY2xhc3NTdHJpbmcsXG4gICAgY29weURlc2NyaXB0b3JzOiBjb3B5RGVzY3JpcHRvcnMsXG4gICAgaGFzRGV2VG9vbHM6IHR5cGVvZiBjaHJvbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY2hyb21lICYmXG4gICAgICAgICAgICAgICAgIHR5cGVvZiBjaHJvbWUubG9hZFRpbWVzID09PSBcImZ1bmN0aW9uXCIsXG4gICAgaXNOb2RlOiBpc05vZGUsXG4gICAgaGFzRW52VmFyaWFibGVzOiBoYXNFbnZWYXJpYWJsZXMsXG4gICAgZW52OiBlbnYsXG4gICAgZ2xvYmFsOiBnbG9iYWxPYmplY3QsXG4gICAgZ2V0TmF0aXZlUHJvbWlzZTogZ2V0TmF0aXZlUHJvbWlzZSxcbiAgICBkb21haW5CaW5kOiBkb21haW5CaW5kXG59O1xucmV0LmlzUmVjZW50Tm9kZSA9IHJldC5pc05vZGUgJiYgKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KFwiLlwiKS5tYXAoTnVtYmVyKTtcbiAgICByZXR1cm4gKHZlcnNpb25bMF0gPT09IDAgJiYgdmVyc2lvblsxXSA+IDEwKSB8fCAodmVyc2lvblswXSA+IDApO1xufSkoKTtcblxuaWYgKHJldC5pc05vZGUpIHJldC50b0Zhc3RQcm9wZXJ0aWVzKHByb2Nlc3MpO1xuXG50cnkge3Rocm93IG5ldyBFcnJvcigpOyB9IGNhdGNoIChlKSB7cmV0Lmxhc3RMaW5lRXJyb3IgPSBlO31cbm1vZHVsZS5leHBvcnRzID0gcmV0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc0VTNSA9IChmdW5jdGlvbigpe1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzID09PSB1bmRlZmluZWQ7XG59KSgpO1xuXG5pZiAoaXNFUzUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZnJlZXplOiBPYmplY3QuZnJlZXplLFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eTogT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgICBnZXREZXNjcmlwdG9yOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgICAgICBrZXlzOiBPYmplY3Qua2V5cyxcbiAgICAgICAgbmFtZXM6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAgICAgICBnZXRQcm90b3R5cGVPZjogT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuICAgICAgICBpc0VTNTogaXNFUzUsXG4gICAgICAgIHByb3BlcnR5SXNXcml0YWJsZTogZnVuY3Rpb24ob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICAgICAgICAgIHJldHVybiAhISghZGVzY3JpcHRvciB8fCBkZXNjcmlwdG9yLndyaXRhYmxlIHx8IGRlc2NyaXB0b3Iuc2V0KTtcbiAgICAgICAgfVxuICAgIH07XG59IGVsc2Uge1xuICAgIHZhciBoYXMgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgc3RyID0ge30udG9TdHJpbmc7XG4gICAgdmFyIHByb3RvID0ge30uY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gICAgdmFyIE9iamVjdEtleXMgPSBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgICAgICAgICBpZiAoaGFzLmNhbGwobywga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEdldERlc2NyaXB0b3IgPSBmdW5jdGlvbihvLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHt2YWx1ZTogb1trZXldfTtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdERlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG8sIGtleSwgZGVzYykge1xuICAgICAgICBvW2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEZyZWV6ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEdldFByb3RvdHlwZU9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChvYmopLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBBcnJheUlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgaXNBcnJheTogQXJyYXlJc0FycmF5LFxuICAgICAgICBrZXlzOiBPYmplY3RLZXlzLFxuICAgICAgICBuYW1lczogT2JqZWN0S2V5cyxcbiAgICAgICAgZGVmaW5lUHJvcGVydHk6IE9iamVjdERlZmluZVByb3BlcnR5LFxuICAgICAgICBnZXREZXNjcmlwdG9yOiBPYmplY3RHZXREZXNjcmlwdG9yLFxuICAgICAgICBmcmVlemU6IE9iamVjdEZyZWV6ZSxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2Y6IE9iamVjdEdldFByb3RvdHlwZU9mLFxuICAgICAgICBpc0VTNTogaXNFUzUsXG4gICAgICAgIHByb3BlcnR5SXNXcml0YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9lczUuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBmaXJzdExpbmVFcnJvcjtcbnRyeSB7dGhyb3cgbmV3IEVycm9yKCk7IH0gY2F0Y2ggKGUpIHtmaXJzdExpbmVFcnJvciA9IGU7fVxudmFyIHNjaGVkdWxlID0gcmVxdWlyZShcIi4vc2NoZWR1bGVcIik7XG52YXIgUXVldWUgPSByZXF1aXJlKFwiLi9xdWV1ZVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuZnVuY3Rpb24gQXN5bmMoKSB7XG4gICAgdGhpcy5fY3VzdG9tU2NoZWR1bGVyID0gZmFsc2U7XG4gICAgdGhpcy5faXNUaWNrVXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xhdGVRdWV1ZSA9IG5ldyBRdWV1ZSgxNik7XG4gICAgdGhpcy5fbm9ybWFsUXVldWUgPSBuZXcgUXVldWUoMTYpO1xuICAgIHRoaXMuX2hhdmVEcmFpbmVkUXVldWVzID0gZmFsc2U7XG4gICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSB0cnVlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmRyYWluUXVldWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLl9kcmFpblF1ZXVlcygpO1xuICAgIH07XG4gICAgdGhpcy5fc2NoZWR1bGUgPSBzY2hlZHVsZTtcbn1cblxuQXN5bmMucHJvdG90eXBlLnNldFNjaGVkdWxlciA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdmFyIHByZXYgPSB0aGlzLl9zY2hlZHVsZTtcbiAgICB0aGlzLl9zY2hlZHVsZSA9IGZuO1xuICAgIHRoaXMuX2N1c3RvbVNjaGVkdWxlciA9IHRydWU7XG4gICAgcmV0dXJuIHByZXY7XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuaGFzQ3VzdG9tU2NoZWR1bGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1c3RvbVNjaGVkdWxlcjtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5lbmFibGVUcmFtcG9saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSB0cnVlO1xufTtcblxuQXN5bmMucHJvdG90eXBlLmRpc2FibGVUcmFtcG9saW5lSWZOZWNlc3NhcnkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5oYXNEZXZUb29scykge1xuICAgICAgICB0aGlzLl90cmFtcG9saW5lRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbkFzeW5jLnByb3RvdHlwZS5oYXZlSXRlbXNRdWV1ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVGlja1VzZWQgfHwgdGhpcy5faGF2ZURyYWluZWRRdWV1ZXM7XG59O1xuXG5cbkFzeW5jLnByb3RvdHlwZS5mYXRhbEVycm9yID0gZnVuY3Rpb24oZSwgaXNOb2RlKSB7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShcIkZhdGFsIFwiICsgKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUuc3RhY2sgOiBlKSArXG4gICAgICAgICAgICBcIlxcblwiKTtcbiAgICAgICAgcHJvY2Vzcy5leGl0KDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGhyb3dMYXRlcihlKTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUudGhyb3dMYXRlciA9IGZ1bmN0aW9uKGZuLCBhcmcpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBhcmcgPSBmbjtcbiAgICAgICAgZm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IGFyZzsgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbihhcmcpO1xuICAgICAgICB9LCAwKTtcbiAgICB9IGVsc2UgdHJ5IHtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbihhcmcpO1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFzeW5jIHNjaGVkdWxlciBhdmFpbGFibGVcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIEFzeW5jSW52b2tlTGF0ZXIoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICB0aGlzLl9sYXRlUXVldWUucHVzaChmbiwgcmVjZWl2ZXIsIGFyZyk7XG4gICAgdGhpcy5fcXVldWVUaWNrKCk7XG59XG5cbmZ1bmN0aW9uIEFzeW5jSW52b2tlKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgdGhpcy5fbm9ybWFsUXVldWUucHVzaChmbiwgcmVjZWl2ZXIsIGFyZyk7XG4gICAgdGhpcy5fcXVldWVUaWNrKCk7XG59XG5cbmZ1bmN0aW9uIEFzeW5jU2V0dGxlUHJvbWlzZXMocHJvbWlzZSkge1xuICAgIHRoaXMuX25vcm1hbFF1ZXVlLl9wdXNoT25lKHByb21pc2UpO1xuICAgIHRoaXMuX3F1ZXVlVGljaygpO1xufVxuXG5pZiAoIXV0aWwuaGFzRGV2VG9vbHMpIHtcbiAgICBBc3luYy5wcm90b3R5cGUuaW52b2tlTGF0ZXIgPSBBc3luY0ludm9rZUxhdGVyO1xuICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2UgPSBBc3luY0ludm9rZTtcbiAgICBBc3luYy5wcm90b3R5cGUuc2V0dGxlUHJvbWlzZXMgPSBBc3luY1NldHRsZVByb21pc2VzO1xufSBlbHNlIHtcbiAgICBBc3luYy5wcm90b3R5cGUuaW52b2tlTGF0ZXIgPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkKSB7XG4gICAgICAgICAgICBBc3luY0ludm9rZUxhdGVyLmNhbGwodGhpcywgZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4uY2FsbChyZWNlaXZlciwgYXJnKTtcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgICAgICBpZiAodGhpcy5fdHJhbXBvbGluZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIEFzeW5jSW52b2tlLmNhbGwodGhpcywgZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChyZWNlaXZlciwgYXJnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEFzeW5jLnByb3RvdHlwZS5zZXR0bGVQcm9taXNlcyA9IGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkKSB7XG4gICAgICAgICAgICBBc3luY1NldHRsZVByb21pc2VzLmNhbGwodGhpcywgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9zZXR0bGVQcm9taXNlcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5Bc3luYy5wcm90b3R5cGUuX2RyYWluUXVldWUgPSBmdW5jdGlvbihxdWV1ZSkge1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgoKSA+IDApIHtcbiAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBmbi5fc2V0dGxlUHJvbWlzZXMoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWNlaXZlciA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHZhciBhcmcgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBmbi5jYWxsKHJlY2VpdmVyLCBhcmcpO1xuICAgIH1cbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fZHJhaW5RdWV1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZHJhaW5RdWV1ZSh0aGlzLl9ub3JtYWxRdWV1ZSk7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLl9oYXZlRHJhaW5lZFF1ZXVlcyA9IHRydWU7XG4gICAgdGhpcy5fZHJhaW5RdWV1ZSh0aGlzLl9sYXRlUXVldWUpO1xufTtcblxuQXN5bmMucHJvdG90eXBlLl9xdWV1ZVRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1RpY2tVc2VkKSB7XG4gICAgICAgIHRoaXMuX2lzVGlja1VzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zY2hlZHVsZSh0aGlzLmRyYWluUXVldWVzKTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lzVGlja1VzZWQgPSBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXN5bmM7XG5tb2R1bGUuZXhwb3J0cy5maXJzdExpbmVFcnJvciA9IGZpcnN0TGluZUVycm9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvYXN5bmMuanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBzY2hlZHVsZTtcbnZhciBub0FzeW5jU2NoZWR1bGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXN5bmMgc2NoZWR1bGVyIGF2YWlsYWJsZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG59O1xudmFyIE5hdGl2ZVByb21pc2UgPSB1dGlsLmdldE5hdGl2ZVByb21pc2UoKTtcbmlmICh1dGlsLmlzTm9kZSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBHbG9iYWxTZXRJbW1lZGlhdGUgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBQcm9jZXNzTmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xuICAgIHNjaGVkdWxlID0gdXRpbC5pc1JlY2VudE5vZGVcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uKGZuKSB7IEdsb2JhbFNldEltbWVkaWF0ZS5jYWxsKGdsb2JhbCwgZm4pOyB9XG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbihmbikgeyBQcm9jZXNzTmV4dFRpY2suY2FsbChwcm9jZXNzLCBmbik7IH07XG59IGVsc2UgaWYgKHR5cGVvZiBOYXRpdmVQcm9taXNlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgdHlwZW9mIE5hdGl2ZVByb21pc2UucmVzb2x2ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIG5hdGl2ZVByb21pc2UgPSBOYXRpdmVQcm9taXNlLnJlc29sdmUoKTtcbiAgICBzY2hlZHVsZSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIG5hdGl2ZVByb21pc2UudGhlbihmbik7XG4gICAgfTtcbn0gZWxzZSBpZiAoKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiKSAmJlxuICAgICAgICAgICEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgd2luZG93Lm5hdmlnYXRvciAmJlxuICAgICAgICAgICAgKHdpbmRvdy5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSB8fCB3aW5kb3cuY29yZG92YSkpKSB7XG4gICAgc2NoZWR1bGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgb3B0cyA9IHthdHRyaWJ1dGVzOiB0cnVlfTtcbiAgICAgICAgdmFyIHRvZ2dsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZGl2MiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciBvMiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJmb29cIik7XG4gICAgICAgICAgICB0b2dnbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIG8yLm9ic2VydmUoZGl2Miwgb3B0cyk7XG5cbiAgICAgICAgdmFyIHNjaGVkdWxlVG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodG9nZ2xlU2NoZWR1bGVkKSByZXR1cm47XG4gICAgICAgICAgICB0b2dnbGVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGl2Mi5jbGFzc0xpc3QudG9nZ2xlKFwiZm9vXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzY2hlZHVsZShmbikge1xuICAgICAgICAgICAgdmFyIG8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvLm9ic2VydmUoZGl2LCBvcHRzKTtcbiAgICAgICAgICAgIHNjaGVkdWxlVG9nZ2xlKCk7XG4gICAgICAgIH07XG4gICAgfSkoKTtcbn0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHNjaGVkdWxlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIHNldFRpbWVvdXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBzY2hlZHVsZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBzY2hlZHVsZSA9IG5vQXN5bmNTY2hlZHVsZXI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHNjaGVkdWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2Uvc2NoZWR1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGFycmF5TW92ZShzcmMsIHNyY0luZGV4LCBkc3QsIGRzdEluZGV4LCBsZW4pIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgIGRzdFtqICsgZHN0SW5kZXhdID0gc3JjW2ogKyBzcmNJbmRleF07XG4gICAgICAgIHNyY1tqICsgc3JjSW5kZXhdID0gdm9pZCAwO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gUXVldWUoY2FwYWNpdHkpIHtcbiAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fZnJvbnQgPSAwO1xufVxuXG5RdWV1ZS5wcm90b3R5cGUuX3dpbGxCZU92ZXJDYXBhY2l0eSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhcGFjaXR5IDwgc2l6ZTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fcHVzaE9uZSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICB0aGlzLl9jaGVja0NhcGFjaXR5KGxlbmd0aCArIDEpO1xuICAgIHZhciBpID0gKHRoaXMuX2Zyb250ICsgbGVuZ3RoKSAmICh0aGlzLl9jYXBhY2l0eSAtIDEpO1xuICAgIHRoaXNbaV0gPSBhcmc7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoICsgMTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCkgKyAzO1xuICAgIGlmICh0aGlzLl93aWxsQmVPdmVyQ2FwYWNpdHkobGVuZ3RoKSkge1xuICAgICAgICB0aGlzLl9wdXNoT25lKGZuKTtcbiAgICAgICAgdGhpcy5fcHVzaE9uZShyZWNlaXZlcik7XG4gICAgICAgIHRoaXMuX3B1c2hPbmUoYXJnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaiA9IHRoaXMuX2Zyb250ICsgbGVuZ3RoIC0gMztcbiAgICB0aGlzLl9jaGVja0NhcGFjaXR5KGxlbmd0aCk7XG4gICAgdmFyIHdyYXBNYXNrID0gdGhpcy5fY2FwYWNpdHkgLSAxO1xuICAgIHRoaXNbKGogKyAwKSAmIHdyYXBNYXNrXSA9IGZuO1xuICAgIHRoaXNbKGogKyAxKSAmIHdyYXBNYXNrXSA9IHJlY2VpdmVyO1xuICAgIHRoaXNbKGogKyAyKSAmIHdyYXBNYXNrXSA9IGFyZztcbiAgICB0aGlzLl9sZW5ndGggPSBsZW5ndGg7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZyb250ID0gdGhpcy5fZnJvbnQsXG4gICAgICAgIHJldCA9IHRoaXNbZnJvbnRdO1xuXG4gICAgdGhpc1tmcm9udF0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnJvbnQgPSAoZnJvbnQgKyAxKSAmICh0aGlzLl9jYXBhY2l0eSAtIDEpO1xuICAgIHRoaXMuX2xlbmd0aC0tO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX2NoZWNrQ2FwYWNpdHkgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIGlmICh0aGlzLl9jYXBhY2l0eSA8IHNpemUpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplVG8odGhpcy5fY2FwYWNpdHkgPDwgMSk7XG4gICAgfVxufTtcblxuUXVldWUucHJvdG90eXBlLl9yZXNpemVUbyA9IGZ1bmN0aW9uIChjYXBhY2l0eSkge1xuICAgIHZhciBvbGRDYXBhY2l0eSA9IHRoaXMuX2NhcGFjaXR5O1xuICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgdmFyIGZyb250ID0gdGhpcy5fZnJvbnQ7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuX2xlbmd0aDtcbiAgICB2YXIgbW92ZUl0ZW1zQ291bnQgPSAoZnJvbnQgKyBsZW5ndGgpICYgKG9sZENhcGFjaXR5IC0gMSk7XG4gICAgYXJyYXlNb3ZlKHRoaXMsIDAsIHRoaXMsIG9sZENhcGFjaXR5LCBtb3ZlSXRlbXNDb3VudCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvcXVldWUuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBlczUgPSByZXF1aXJlKFwiLi9lczVcIik7XG52YXIgT2JqZWN0ZnJlZXplID0gZXM1LmZyZWV6ZTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBpbmhlcml0cyA9IHV0aWwuaW5oZXJpdHM7XG52YXIgbm90RW51bWVyYWJsZVByb3AgPSB1dGlsLm5vdEVudW1lcmFibGVQcm9wO1xuXG5mdW5jdGlvbiBzdWJFcnJvcihuYW1lUHJvcGVydHksIGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgZnVuY3Rpb24gU3ViRXJyb3IobWVzc2FnZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3ViRXJyb3IpKSByZXR1cm4gbmV3IFN1YkVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IGRlZmF1bHRNZXNzYWdlKTtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJuYW1lXCIsIG5hbWVQcm9wZXJ0eSk7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaGVyaXRzKFN1YkVycm9yLCBFcnJvcik7XG4gICAgcmV0dXJuIFN1YkVycm9yO1xufVxuXG52YXIgX1R5cGVFcnJvciwgX1JhbmdlRXJyb3I7XG52YXIgV2FybmluZyA9IHN1YkVycm9yKFwiV2FybmluZ1wiLCBcIndhcm5pbmdcIik7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBzdWJFcnJvcihcIkNhbmNlbGxhdGlvbkVycm9yXCIsIFwiY2FuY2VsbGF0aW9uIGVycm9yXCIpO1xudmFyIFRpbWVvdXRFcnJvciA9IHN1YkVycm9yKFwiVGltZW91dEVycm9yXCIsIFwidGltZW91dCBlcnJvclwiKTtcbnZhciBBZ2dyZWdhdGVFcnJvciA9IHN1YkVycm9yKFwiQWdncmVnYXRlRXJyb3JcIiwgXCJhZ2dyZWdhdGUgZXJyb3JcIik7XG50cnkge1xuICAgIF9UeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgX1JhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xufSBjYXRjaChlKSB7XG4gICAgX1R5cGVFcnJvciA9IHN1YkVycm9yKFwiVHlwZUVycm9yXCIsIFwidHlwZSBlcnJvclwiKTtcbiAgICBfUmFuZ2VFcnJvciA9IHN1YkVycm9yKFwiUmFuZ2VFcnJvclwiLCBcInJhbmdlIGVycm9yXCIpO1xufVxuXG52YXIgbWV0aG9kcyA9IChcImpvaW4gcG9wIHB1c2ggc2hpZnQgdW5zaGlmdCBzbGljZSBmaWx0ZXIgZm9yRWFjaCBzb21lIFwiICtcbiAgICBcImV2ZXJ5IG1hcCBpbmRleE9mIGxhc3RJbmRleE9mIHJlZHVjZSByZWR1Y2VSaWdodCBzb3J0IHJldmVyc2VcIikuc3BsaXQoXCIgXCIpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZVttZXRob2RzW2ldXSA9IEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXTtcbiAgICB9XG59XG5cbmVzNS5kZWZpbmVQcm9wZXJ0eShBZ2dyZWdhdGVFcnJvci5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICB2YWx1ZTogMCxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbn0pO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlW1wiaXNPcGVyYXRpb25hbFwiXSA9IHRydWU7XG52YXIgbGV2ZWwgPSAwO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZGVudCA9IEFycmF5KGxldmVsICogNCArIDEpLmpvaW4oXCIgXCIpO1xuICAgIHZhciByZXQgPSBcIlxcblwiICsgaW5kZW50ICsgXCJBZ2dyZWdhdGVFcnJvciBvZjpcIiArIFwiXFxuXCI7XG4gICAgbGV2ZWwrKztcbiAgICBpbmRlbnQgPSBBcnJheShsZXZlbCAqIDQgKyAxKS5qb2luKFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXNbaV0gPT09IHRoaXMgPyBcIltDaXJjdWxhciBBZ2dyZWdhdGVFcnJvcl1cIiA6IHRoaXNbaV0gKyBcIlwiO1xuICAgICAgICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGxpbmVzW2pdID0gaW5kZW50ICsgbGluZXNbal07XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgcmV0ICs9IHN0ciArIFwiXFxuXCI7XG4gICAgfVxuICAgIGxldmVsLS07XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIE9wZXJhdGlvbmFsRXJyb3IobWVzc2FnZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPcGVyYXRpb25hbEVycm9yKSlcbiAgICAgICAgcmV0dXJuIG5ldyBPcGVyYXRpb25hbEVycm9yKG1lc3NhZ2UpO1xuICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibmFtZVwiLCBcIk9wZXJhdGlvbmFsRXJyb3JcIik7XG4gICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBtZXNzYWdlO1xuICAgIHRoaXNbXCJpc09wZXJhdGlvbmFsXCJdID0gdHJ1ZTtcblxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwic3RhY2tcIiwgbWVzc2FnZS5zdGFjayk7XG4gICAgfSBlbHNlIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbn1cbmluaGVyaXRzKE9wZXJhdGlvbmFsRXJyb3IsIEVycm9yKTtcblxudmFyIGVycm9yVHlwZXMgPSBFcnJvcltcIl9fQmx1ZWJpcmRFcnJvclR5cGVzX19cIl07XG5pZiAoIWVycm9yVHlwZXMpIHtcbiAgICBlcnJvclR5cGVzID0gT2JqZWN0ZnJlZXplKHtcbiAgICAgICAgQ2FuY2VsbGF0aW9uRXJyb3I6IENhbmNlbGxhdGlvbkVycm9yLFxuICAgICAgICBUaW1lb3V0RXJyb3I6IFRpbWVvdXRFcnJvcixcbiAgICAgICAgT3BlcmF0aW9uYWxFcnJvcjogT3BlcmF0aW9uYWxFcnJvcixcbiAgICAgICAgUmVqZWN0aW9uRXJyb3I6IE9wZXJhdGlvbmFsRXJyb3IsXG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yOiBBZ2dyZWdhdGVFcnJvclxuICAgIH0pO1xuICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShFcnJvciwgXCJfX0JsdWViaXJkRXJyb3JUeXBlc19fXCIsIHtcbiAgICAgICAgdmFsdWU6IGVycm9yVHlwZXMsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRXJyb3I6IEVycm9yLFxuICAgIFR5cGVFcnJvcjogX1R5cGVFcnJvcixcbiAgICBSYW5nZUVycm9yOiBfUmFuZ2VFcnJvcixcbiAgICBDYW5jZWxsYXRpb25FcnJvcjogZXJyb3JUeXBlcy5DYW5jZWxsYXRpb25FcnJvcixcbiAgICBPcGVyYXRpb25hbEVycm9yOiBlcnJvclR5cGVzLk9wZXJhdGlvbmFsRXJyb3IsXG4gICAgVGltZW91dEVycm9yOiBlcnJvclR5cGVzLlRpbWVvdXRFcnJvcixcbiAgICBBZ2dyZWdhdGVFcnJvcjogZXJyb3JUeXBlcy5BZ2dyZWdhdGVFcnJvcixcbiAgICBXYXJuaW5nOiBXYXJuaW5nXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvZXJyb3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcblxuZnVuY3Rpb24gdHJ5Q29udmVydFRvUHJvbWlzZShvYmosIGNvbnRleHQpIHtcbiAgICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIG9iajtcbiAgICAgICAgdmFyIHRoZW4gPSBnZXRUaGVuKG9iaik7XG4gICAgICAgIGlmICh0aGVuID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgcmV0ID0gUHJvbWlzZS5yZWplY3QodGhlbi5lKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChpc0FueUJsdWViaXJkUHJvbWlzZShvYmopKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICBvYmouX3RoZW4oXG4gICAgICAgICAgICAgICAgICAgIHJldC5fZnVsZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV0Ll9yZWplY3QsXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvVGhlbmFibGUob2JqLCB0aGVuLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBkb0dldFRoZW4ob2JqKSB7XG4gICAgcmV0dXJuIG9iai50aGVuO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKG9iaikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkb0dldFRoZW4ob2JqKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqLmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgfVxufVxuXG52YXIgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaXNBbnlCbHVlYmlyZFByb21pc2Uob2JqKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGhhc1Byb3AuY2FsbChvYmosIFwiX3Byb21pc2UwXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZG9UaGVuYWJsZSh4LCB0aGVuLCBjb250ZXh0KSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgdmFyIHJldCA9IHByb21pc2U7XG4gICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3B1c2hDb250ZXh0KCk7XG4gICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcG9wQ29udGV4dCgpO1xuICAgIHZhciBzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgdmFyIHJlc3VsdCA9IHV0aWwudHJ5Q2F0Y2godGhlbikuY2FsbCh4LCByZXNvbHZlLCByZWplY3QpO1xuICAgIHN5bmNocm9ub3VzID0gZmFsc2U7XG5cbiAgICBpZiAocHJvbWlzZSAmJiByZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlc3VsdC5lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXByb21pc2UpIHJldHVybjtcbiAgICAgICAgcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgICAgICBpZiAoIXByb21pc2UpIHJldHVybjtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBzeW5jaHJvbm91cywgdHJ1ZSk7XG4gICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5yZXR1cm4gdHJ5Q29udmVydFRvUHJvbWlzZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS90aGVuYWJsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgYXBpUmVqZWN0aW9uLCBQcm94eWFibGUpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBpc0FycmF5ID0gdXRpbC5pc0FycmF5O1xuXG5mdW5jdGlvbiB0b1Jlc29sdXRpb25WYWx1ZSh2YWwpIHtcbiAgICBzd2l0Y2godmFsKSB7XG4gICAgY2FzZSAtMjogcmV0dXJuIFtdO1xuICAgIGNhc2UgLTM6IHJldHVybiB7fTtcbiAgICBjYXNlIC02OiByZXR1cm4gbmV3IE1hcCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlLl9wcm9wYWdhdGVGcm9tKHZhbHVlcywgMyk7XG4gICAgfVxuICAgIHByb21pc2UuX3NldE9uQ2FuY2VsKHRoaXMpO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX3RvdGFsUmVzb2x2ZWQgPSAwO1xuICAgIHRoaXMuX2luaXQodW5kZWZpbmVkLCAtMik7XG59XG51dGlsLmluaGVyaXRzKFByb21pc2VBcnJheSwgUHJveHlhYmxlKTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KF8sIHJlc29sdmVWYWx1ZUlmRW1wdHkpIHtcbiAgICB2YXIgdmFsdWVzID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGlzLl92YWx1ZXMsIHRoaXMuX3Byb21pc2UpO1xuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5fdGFyZ2V0KCk7XG4gICAgICAgIHZhciBiaXRGaWVsZCA9IHZhbHVlcy5fYml0RmllbGQ7XG4gICAgICAgIDtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuXG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzLl90aGVuKFxuICAgICAgICAgICAgICAgIGluaXQsXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0LFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIHJlc29sdmVWYWx1ZUlmRW1wdHlcbiAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLl92YWx1ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0KHZhbHVlcy5fcmVhc29uKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbHVlcyA9IHV0aWwuYXNBcnJheSh2YWx1ZXMpO1xuICAgIGlmICh2YWx1ZXMgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGVyciA9IGFwaVJlamVjdGlvbihcbiAgICAgICAgICAgIFwiZXhwZWN0aW5nIGFuIGFycmF5IG9yIGFuIGl0ZXJhYmxlIG9iamVjdCBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyh2YWx1ZXMpKS5yZWFzb24oKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2soZXJyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAocmVzb2x2ZVZhbHVlSWZFbXB0eSA9PT0gLTUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVFbXB0eUFycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHRvUmVzb2x1dGlvblZhbHVlKHJlc29sdmVWYWx1ZUlmRW1wdHkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2l0ZXJhdGUodmFsdWVzKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2l0ZXJhdGUgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5nZXRBY3R1YWxMZW5ndGgodmFsdWVzLmxlbmd0aCk7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHRoaXMuc2hvdWxkQ29weVZhbHVlcygpID8gbmV3IEFycmF5KGxlbikgOiB0aGlzLl92YWx1ZXM7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuX3Byb21pc2U7XG4gICAgdmFyIGlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB2YXIgYml0RmllbGQgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodmFsdWVzW2ldLCByZXN1bHQpO1xuXG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYml0RmllbGQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGlmIChiaXRGaWVsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChiaXRGaWVsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eSh0aGlzLCBpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbaV0gPSBtYXliZVByb21pc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRoaXMuX3Byb21pc2VGdWxmaWxsZWQobWF5YmVQcm9taXNlLl92YWx1ZSgpLCBpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdGhpcy5fcHJvbWlzZVJlamVjdGVkKG1heWJlUHJvbWlzZS5fcmVhc29uKCksIGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdGhpcy5fcHJvbWlzZUNhbmNlbGxlZChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKG1heWJlUHJvbWlzZSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1Jlc29sdmVkKSByZXN1bHQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faXNSZXNvbHZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVzID09PSBudWxsO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fZnVsZmlsbCh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpIHx8ICF0aGlzLl9wcm9taXNlLl9pc0NhbmNlbGxhYmxlKCkpIHJldHVybjtcbiAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgIHRoaXMuX3Byb21pc2UuX2NhbmNlbCgpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBmYWxzZSk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX3RvdGFsUmVzb2x2ZWQrKztcbiAgICB0aGlzLl9yZWplY3QocmVhc29uKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5fdmFsdWVzO1xuICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhbHVlcy5jYW5jZWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1tpXSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaV0uY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLmdldEFjdHVhbExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICByZXR1cm4gbGVuO1xufTtcblxucmV0dXJuIFByb21pc2VBcnJheTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNlX2FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciBsb25nU3RhY2tUcmFjZXMgPSBmYWxzZTtcbnZhciBjb250ZXh0U3RhY2sgPSBbXTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gZnVuY3Rpb24oKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IGZ1bmN0aW9uKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IGZ1bmN0aW9uKCkge3JldHVybiBudWxsO307XG5Qcm9taXNlLl9wZWVrQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dCA9IGZ1bmN0aW9uKCkge307XG5cbmZ1bmN0aW9uIENvbnRleHQoKSB7XG4gICAgdGhpcy5fdHJhY2UgPSBuZXcgQ29udGV4dC5DYXB0dXJlZFRyYWNlKHBlZWtDb250ZXh0KCkpO1xufVxuQ29udGV4dC5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl90cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3RyYWNlLl9wcm9taXNlQ3JlYXRlZCA9IG51bGw7XG4gICAgICAgIGNvbnRleHRTdGFjay5wdXNoKHRoaXMuX3RyYWNlKTtcbiAgICB9XG59O1xuXG5Db250ZXh0LnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fdHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdHJhY2UgPSBjb250ZXh0U3RhY2sucG9wKCk7XG4gICAgICAgIHZhciByZXQgPSB0cmFjZS5fcHJvbWlzZUNyZWF0ZWQ7XG4gICAgICAgIHRyYWNlLl9wcm9taXNlQ3JlYXRlZCA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dCgpIHtcbiAgICBpZiAobG9uZ1N0YWNrVHJhY2VzKSByZXR1cm4gbmV3IENvbnRleHQoKTtcbn1cblxuZnVuY3Rpb24gcGVla0NvbnRleHQoKSB7XG4gICAgdmFyIGxhc3RJbmRleCA9IGNvbnRleHRTdGFjay5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dFN0YWNrW2xhc3RJbmRleF07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5Db250ZXh0LkNhcHR1cmVkVHJhY2UgPSBudWxsO1xuQ29udGV4dC5jcmVhdGUgPSBjcmVhdGVDb250ZXh0O1xuQ29udGV4dC5kZWFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7fTtcbkNvbnRleHQuYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgUHJvbWlzZV9wdXNoQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9wb3BDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQ7XG4gICAgdmFyIFByb21pc2VfUGVla0NvbnRleHQgPSBQcm9taXNlLl9wZWVrQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9wZWVrQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9wcm9taXNlQ3JlYXRlZCA9IFByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZDtcbiAgICBDb250ZXh0LmRlYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gUHJvbWlzZV9wdXNoQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBQcm9taXNlX3BvcENvbnRleHQ7XG4gICAgICAgIFByb21pc2UuX3BlZWtDb250ZXh0ID0gUHJvbWlzZV9QZWVrQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3BlZWtDb250ZXh0ID0gUHJvbWlzZV9wZWVrQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gUHJvbWlzZV9wcm9taXNlQ3JlYXRlZDtcbiAgICAgICAgbG9uZ1N0YWNrVHJhY2VzID0gZmFsc2U7XG4gICAgfTtcbiAgICBsb25nU3RhY2tUcmFjZXMgPSB0cnVlO1xuICAgIFByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IENvbnRleHQucHJvdG90eXBlLl9wdXNoQ29udGV4dDtcbiAgICBQcm9taXNlLnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IENvbnRleHQucHJvdG90eXBlLl9wb3BDb250ZXh0O1xuICAgIFByb21pc2UuX3BlZWtDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3BlZWtDb250ZXh0ID0gcGVla0NvbnRleHQ7XG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9wZWVrQ29udGV4dCgpO1xuICAgICAgICBpZiAoY3R4ICYmIGN0eC5fcHJvbWlzZUNyZWF0ZWQgPT0gbnVsbCkgY3R4Ll9wcm9taXNlQ3JlYXRlZCA9IHRoaXM7XG4gICAgfTtcbn07XG5yZXR1cm4gQ29udGV4dDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9jb250ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIENvbnRleHQpIHtcbnZhciBnZXREb21haW4gPSBQcm9taXNlLl9nZXREb21haW47XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcbnZhciBXYXJuaW5nID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpLldhcm5pbmc7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgY2FuQXR0YWNoVHJhY2UgPSB1dGlsLmNhbkF0dGFjaFRyYWNlO1xudmFyIHVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQ7XG52YXIgcG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb247XG52YXIgYmx1ZWJpcmRGcmFtZVBhdHRlcm4gPVxuICAgIC9bXFxcXFxcL11ibHVlYmlyZFtcXFxcXFwvXWpzW1xcXFxcXC9dKHJlbGVhc2V8ZGVidWd8aW5zdHJ1bWVudGVkKS87XG52YXIgbm9kZUZyYW1lUGF0dGVybiA9IC9cXCgoPzp0aW1lcnNcXC5qcyk6XFxkKzpcXGQrXFwpLztcbnZhciBwYXJzZUxpbmVQYXR0ZXJuID0gL1tcXC88XFwoXSguKz8pOihcXGQrKTooXFxkKylcXCk/XFxzKiQvO1xudmFyIHN0YWNrRnJhbWVQYXR0ZXJuID0gbnVsbDtcbnZhciBmb3JtYXRTdGFjayA9IG51bGw7XG52YXIgaW5kZW50U3RhY2tGcmFtZXMgPSBmYWxzZTtcbnZhciBwcmludFdhcm5pbmc7XG52YXIgZGVidWdnaW5nID0gISEodXRpbC5lbnYoXCJCTFVFQklSRF9ERUJVR1wiKSAhPSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZmFsc2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmVudihcIkJMVUVCSVJEX0RFQlVHXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5lbnYoXCJOT0RFX0VOVlwiKSA9PT0gXCJkZXZlbG9wbWVudFwiKSk7XG5cbnZhciB3YXJuaW5ncyA9ICEhKHV0aWwuZW52KFwiQkxVRUJJUkRfV0FSTklOR1NcIikgIT0gMCAmJlxuICAgIChkZWJ1Z2dpbmcgfHwgdXRpbC5lbnYoXCJCTFVFQklSRF9XQVJOSU5HU1wiKSkpO1xuXG52YXIgbG9uZ1N0YWNrVHJhY2VzID0gISEodXRpbC5lbnYoXCJCTFVFQklSRF9MT05HX1NUQUNLX1RSQUNFU1wiKSAhPSAwICYmXG4gICAgKGRlYnVnZ2luZyB8fCB1dGlsLmVudihcIkJMVUVCSVJEX0xPTkdfU1RBQ0tfVFJBQ0VTXCIpKSk7XG5cbnZhciB3Rm9yZ290dGVuUmV0dXJuID0gdXRpbC5lbnYoXCJCTFVFQklSRF9XX0ZPUkdPVFRFTl9SRVRVUk5cIikgIT0gMCAmJlxuICAgICh3YXJuaW5ncyB8fCAhIXV0aWwuZW52KFwiQkxVRUJJUkRfV19GT1JHT1RURU5fUkVUVVJOXCIpKTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCgpO1xuICAgIHRhcmdldC5fYml0RmllbGQgPSAoKHRhcmdldC5fYml0RmllbGQgJiAofjEwNDg1NzYpKSB8XG4gICAgICAgICAgICAgICAgICAgICAgNTI0Mjg4KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9lbnN1cmVQb3NzaWJsZVJlamVjdGlvbkhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCh0aGlzLl9iaXRGaWVsZCAmIDUyNDI4OCkgIT09IDApIHJldHVybjtcbiAgICB0aGlzLl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgIGFzeW5jLmludm9rZUxhdGVyKHRoaXMuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbiwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb25Jc0hhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZmlyZVJlamVjdGlvbkV2ZW50KFwicmVqZWN0aW9uSGFuZGxlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQsIHVuZGVmaW5lZCwgdGhpcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0UmV0dXJuZWROb25VbmRlZmluZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMjY4NDM1NDU2O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JldHVybmVkTm9uVW5kZWZpbmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDI2ODQzNTQ1NikgIT09IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9pc1JlamVjdGlvblVuaGFuZGxlZCgpKSB7XG4gICAgICAgIHZhciByZWFzb24gPSB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbiAgICAgICAgdGhpcy5fc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCgpO1xuICAgICAgICBmaXJlUmVqZWN0aW9uRXZlbnQoXCJ1bmhhbmRsZWRSZWplY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24sIHJlYXNvbiwgdGhpcyk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDI2MjE0NDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MjYyMTQ0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc1VuaGFuZGxlZFJlamVjdGlvbk5vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyNjIxNDQpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTA0ODU3Njtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjEwNDg1NzYpO1xuICAgIGlmICh0aGlzLl9pc1VuaGFuZGxlZFJlamVjdGlvbk5vdGlmaWVkKCkpIHtcbiAgICAgICAgdGhpcy5fdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkKCk7XG4gICAgICAgIHRoaXMuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbklzSGFuZGxlZCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc1JlamVjdGlvblVuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTA0ODU3NikgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3dhcm4gPSBmdW5jdGlvbihtZXNzYWdlLCBzaG91bGRVc2VPd25UcmFjZSwgcHJvbWlzZSkge1xuICAgIHJldHVybiB3YXJuKG1lc3NhZ2UsIHNob3VsZFVzZU93blRyYWNlLCBwcm9taXNlIHx8IHRoaXMpO1xufTtcblxuUHJvbWlzZS5vblBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uID1cbiAgICAgICAgdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgPyAoZG9tYWluID09PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2Uub25VbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQgPVxuICAgICAgICB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIiA/IChkb21haW4gPT09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xufTtcblxudmFyIGRpc2FibGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHt9O1xuUHJvbWlzZS5sb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFzeW5jLmhhdmVJdGVtc1F1ZXVlZCgpICYmICFjb25maWcubG9uZ1N0YWNrVHJhY2VzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmFibGUgbG9uZyBzdGFjayB0cmFjZXMgYWZ0ZXIgcHJvbWlzZXMgaGF2ZSBiZWVuIGNyZWF0ZWRcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICBpZiAoIWNvbmZpZy5sb25nU3RhY2tUcmFjZXMgJiYgbG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICB2YXIgUHJvbWlzZV9jYXB0dXJlU3RhY2tUcmFjZSA9IFByb21pc2UucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZTtcbiAgICAgICAgdmFyIFByb21pc2VfYXR0YWNoRXh0cmFUcmFjZSA9IFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlO1xuICAgICAgICBjb25maWcubG9uZ1N0YWNrVHJhY2VzID0gdHJ1ZTtcbiAgICAgICAgZGlzYWJsZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGFzeW5jLmhhdmVJdGVtc1F1ZXVlZCgpICYmICFjb25maWcubG9uZ1N0YWNrVHJhY2VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuYWJsZSBsb25nIHN0YWNrIHRyYWNlcyBhZnRlciBwcm9taXNlcyBoYXZlIGJlZW4gY3JlYXRlZFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2UgPSBQcm9taXNlX2NhcHR1cmVTdGFja1RyYWNlO1xuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2UgPSBQcm9taXNlX2F0dGFjaEV4dHJhVHJhY2U7XG4gICAgICAgICAgICBDb250ZXh0LmRlYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgICAgIGFzeW5jLmVuYWJsZVRyYW1wb2xpbmUoKTtcbiAgICAgICAgICAgIGNvbmZpZy5sb25nU3RhY2tUcmFjZXMgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlID0gbG9uZ1N0YWNrVHJhY2VzQ2FwdHVyZVN0YWNrVHJhY2U7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlID0gbG9uZ1N0YWNrVHJhY2VzQXR0YWNoRXh0cmFUcmFjZTtcbiAgICAgICAgQ29udGV4dC5hY3RpdmF0ZUxvbmdTdGFja1RyYWNlcygpO1xuICAgICAgICBhc3luYy5kaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5KCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5oYXNMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbmZpZy5sb25nU3RhY2tUcmFjZXMgJiYgbG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQoKTtcbn07XG5cbnZhciBmaXJlRG9tRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgIHV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KG5hbWUudG9Mb3dlckNhc2UoKSwge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGRvbUV2ZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBuZXcgRXZlbnQobmFtZS50b0xvd2VyQ2FzZSgpLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkb21FdmVudC5kZXRhaWwgPSBldmVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZG9tRXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoXCJ0ZXN0aW5ndGhlZXZlbnRcIiwgZmFsc2UsIHRydWUsIHt9KTtcbiAgICAgICAgICAgIHV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgICAgICBkb21FdmVudC5pbml0Q3VzdG9tRXZlbnQobmFtZS50b0xvd2VyQ2FzZSgpLCBmYWxzZSwgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChkb21FdmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufSkoKTtcblxudmFyIGZpcmVHbG9iYWxFdmVudCA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5pc05vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW1pdC5hcHBseShwcm9jZXNzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdXRpbC5nbG9iYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IFwib25cIiArIG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSB1dGlsLmdsb2JhbFttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBtZXRob2QuYXBwbHkodXRpbC5nbG9iYWwsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9XG59KSgpO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdChuYW1lLCBwcm9taXNlKSB7XG4gICAgcmV0dXJuIHtwcm9taXNlOiBwcm9taXNlfTtcbn1cblxudmFyIGV2ZW50VG9PYmplY3RHZW5lcmF0b3IgPSB7XG4gICAgcHJvbWlzZUNyZWF0ZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgIHByb21pc2VGdWxmaWxsZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgIHByb21pc2VSZWplY3RlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgcHJvbWlzZVJlc29sdmVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICBwcm9taXNlQ2FuY2VsbGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICBwcm9taXNlQ2hhaW5lZDogZnVuY3Rpb24obmFtZSwgcHJvbWlzZSwgY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHtwcm9taXNlOiBwcm9taXNlLCBjaGlsZDogY2hpbGR9O1xuICAgIH0sXG4gICAgd2FybmluZzogZnVuY3Rpb24obmFtZSwgd2FybmluZykge1xuICAgICAgICByZXR1cm4ge3dhcm5pbmc6IHdhcm5pbmd9O1xuICAgIH0sXG4gICAgdW5oYW5kbGVkUmVqZWN0aW9uOiBmdW5jdGlvbiAobmFtZSwgcmVhc29uLCBwcm9taXNlKSB7XG4gICAgICAgIHJldHVybiB7cmVhc29uOiByZWFzb24sIHByb21pc2U6IHByb21pc2V9O1xuICAgIH0sXG4gICAgcmVqZWN0aW9uSGFuZGxlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3Rcbn07XG5cbnZhciBhY3RpdmVGaXJlRXZlbnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBnbG9iYWxFdmVudEZpcmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgZ2xvYmFsRXZlbnRGaXJlZCA9IGZpcmVHbG9iYWxFdmVudC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICAgICAgZ2xvYmFsRXZlbnRGaXJlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGRvbUV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBkb21FdmVudEZpcmVkID0gZmlyZURvbUV2ZW50KG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VG9PYmplY3RHZW5lcmF0b3JbbmFtZV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUpO1xuICAgICAgICBkb21FdmVudEZpcmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tRXZlbnRGaXJlZCB8fCBnbG9iYWxFdmVudEZpcmVkO1xufTtcblxuUHJvbWlzZS5jb25maWcgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgb3B0cyA9IE9iamVjdChvcHRzKTtcbiAgICBpZiAoXCJsb25nU3RhY2tUcmFjZXNcIiBpbiBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLmxvbmdTdGFja1RyYWNlcykge1xuICAgICAgICAgICAgUHJvbWlzZS5sb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgfSBlbHNlIGlmICghb3B0cy5sb25nU3RhY2tUcmFjZXMgJiYgUHJvbWlzZS5oYXNMb25nU3RhY2tUcmFjZXMoKSkge1xuICAgICAgICAgICAgZGlzYWJsZUxvbmdTdGFja1RyYWNlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChcIndhcm5pbmdzXCIgaW4gb3B0cykge1xuICAgICAgICB2YXIgd2FybmluZ3NPcHRpb24gPSBvcHRzLndhcm5pbmdzO1xuICAgICAgICBjb25maWcud2FybmluZ3MgPSAhIXdhcm5pbmdzT3B0aW9uO1xuICAgICAgICB3Rm9yZ290dGVuUmV0dXJuID0gY29uZmlnLndhcm5pbmdzO1xuXG4gICAgICAgIGlmICh1dGlsLmlzT2JqZWN0KHdhcm5pbmdzT3B0aW9uKSkge1xuICAgICAgICAgICAgaWYgKFwid0ZvcmdvdHRlblJldHVyblwiIGluIHdhcm5pbmdzT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgd0ZvcmdvdHRlblJldHVybiA9ICEhd2FybmluZ3NPcHRpb24ud0ZvcmdvdHRlblJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoXCJjYW5jZWxsYXRpb25cIiBpbiBvcHRzICYmIG9wdHMuY2FuY2VsbGF0aW9uICYmICFjb25maWcuY2FuY2VsbGF0aW9uKSB7XG4gICAgICAgIGlmIChhc3luYy5oYXZlSXRlbXNRdWV1ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiY2Fubm90IGVuYWJsZSBjYW5jZWxsYXRpb24gYWZ0ZXIgcHJvbWlzZXMgYXJlIGluIHVzZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2xlYXJDYW5jZWxsYXRpb25EYXRhID1cbiAgICAgICAgICAgIGNhbmNlbGxhdGlvbkNsZWFyQ2FuY2VsbGF0aW9uRGF0YTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb3BhZ2F0ZUZyb20gPSBjYW5jZWxsYXRpb25Qcm9wYWdhdGVGcm9tO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fb25DYW5jZWwgPSBjYW5jZWxsYXRpb25PbkNhbmNlbDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldE9uQ2FuY2VsID0gY2FuY2VsbGF0aW9uU2V0T25DYW5jZWw7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayA9XG4gICAgICAgICAgICBjYW5jZWxsYXRpb25BdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjaztcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2V4ZWN1dGUgPSBjYW5jZWxsYXRpb25FeGVjdXRlO1xuICAgICAgICBwcm9wYWdhdGVGcm9tRnVuY3Rpb24gPSBjYW5jZWxsYXRpb25Qcm9wYWdhdGVGcm9tO1xuICAgICAgICBjb25maWcuY2FuY2VsbGF0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKFwibW9uaXRvcmluZ1wiIGluIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMubW9uaXRvcmluZyAmJiAhY29uZmlnLm1vbml0b3JpbmcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5tb25pdG9yaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9maXJlRXZlbnQgPSBhY3RpdmVGaXJlRXZlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdHMubW9uaXRvcmluZyAmJiBjb25maWcubW9uaXRvcmluZykge1xuICAgICAgICAgICAgY29uZmlnLm1vbml0b3JpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9maXJlRXZlbnQgPSBkZWZhdWx0RmlyZUV2ZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlO1xufTtcblxuZnVuY3Rpb24gZGVmYXVsdEZpcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblByb21pc2UucHJvdG90eXBlLl9maXJlRXZlbnQgPSBkZWZhdWx0RmlyZUV2ZW50O1xuUHJvbWlzZS5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbihleGVjdXRvciwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbn07XG5Qcm9taXNlLnByb3RvdHlwZS5fb25DYW5jZWwgPSBmdW5jdGlvbiAoKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9zZXRPbkNhbmNlbCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7IDsgfTtcblByb21pc2UucHJvdG90eXBlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKG9uQ2FuY2VsKSB7XG4gICAgO1xufTtcblByb21pc2UucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZSA9IGZ1bmN0aW9uICgpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2UgPSBmdW5jdGlvbiAoKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9jbGVhckNhbmNlbGxhdGlvbkRhdGEgPSBmdW5jdGlvbigpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX3Byb3BhZ2F0ZUZyb20gPSBmdW5jdGlvbiAocGFyZW50LCBmbGFncykge1xuICAgIDtcbiAgICA7XG59O1xuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25FeGVjdXRlKGV4ZWN1dG9yLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgICAgZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0LCBmdW5jdGlvbihvbkNhbmNlbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkNhbmNlbCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9uQ2FuY2VsIG11c3QgYmUgYSBmdW5jdGlvbiwgZ290OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLnRvU3RyaW5nKG9uQ2FuY2VsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhvbkNhbmNlbCk7XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25BdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhvbkNhbmNlbCkge1xuICAgIGlmICghdGhpcy5faXNDYW5jZWxsYWJsZSgpKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBwcmV2aW91c09uQ2FuY2VsID0gdGhpcy5fb25DYW5jZWwoKTtcbiAgICBpZiAocHJldmlvdXNPbkNhbmNlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh1dGlsLmlzQXJyYXkocHJldmlvdXNPbkNhbmNlbCkpIHtcbiAgICAgICAgICAgIHByZXZpb3VzT25DYW5jZWwucHVzaChvbkNhbmNlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRPbkNhbmNlbChbcHJldmlvdXNPbkNhbmNlbCwgb25DYW5jZWxdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldE9uQ2FuY2VsKG9uQ2FuY2VsKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvbk9uQ2FuY2VsKCkge1xuICAgIHJldHVybiB0aGlzLl9vbkNhbmNlbEZpZWxkO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25TZXRPbkNhbmNlbChvbkNhbmNlbCkge1xuICAgIHRoaXMuX29uQ2FuY2VsRmllbGQgPSBvbkNhbmNlbDtcbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uQ2xlYXJDYW5jZWxsYXRpb25EYXRhKCkge1xuICAgIHRoaXMuX2NhbmNlbGxhdGlvblBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vbkNhbmNlbEZpZWxkID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25Qcm9wYWdhdGVGcm9tKHBhcmVudCwgZmxhZ3MpIHtcbiAgICBpZiAoKGZsYWdzICYgMSkgIT09IDApIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsbGF0aW9uUGFyZW50ID0gcGFyZW50O1xuICAgICAgICB2YXIgYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9IHBhcmVudC5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbDtcbiAgICAgICAgaWYgKGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Ll9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCArIDE7XG4gICAgfVxuICAgIGlmICgoZmxhZ3MgJiAyKSAhPT0gMCAmJiBwYXJlbnQuX2lzQm91bmQoKSkge1xuICAgICAgICB0aGlzLl9zZXRCb3VuZFRvKHBhcmVudC5fYm91bmRUbyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiaW5kaW5nUHJvcGFnYXRlRnJvbShwYXJlbnQsIGZsYWdzKSB7XG4gICAgaWYgKChmbGFncyAmIDIpICE9PSAwICYmIHBhcmVudC5faXNCb3VuZCgpKSB7XG4gICAgICAgIHRoaXMuX3NldEJvdW5kVG8ocGFyZW50Ll9ib3VuZFRvKTtcbiAgICB9XG59XG52YXIgcHJvcGFnYXRlRnJvbUZ1bmN0aW9uID0gYmluZGluZ1Byb3BhZ2F0ZUZyb207XG5cbmZ1bmN0aW9uIGJvdW5kVmFsdWVGdW5jdGlvbigpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy5fYm91bmRUbztcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXQuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQudmFsdWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNDYXB0dXJlU3RhY2tUcmFjZSgpIHtcbiAgICB0aGlzLl90cmFjZSA9IG5ldyBDYXB0dXJlZFRyYWNlKHRoaXMuX3BlZWtDb250ZXh0KCkpO1xufVxuXG5mdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNBdHRhY2hFeHRyYVRyYWNlKGVycm9yLCBpZ25vcmVTZWxmKSB7XG4gICAgaWYgKGNhbkF0dGFjaFRyYWNlKGVycm9yKSkge1xuICAgICAgICB2YXIgdHJhY2UgPSB0aGlzLl90cmFjZTtcbiAgICAgICAgaWYgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpZ25vcmVTZWxmKSB0cmFjZSA9IHRyYWNlLl9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYWNlLmF0dGFjaEV4dHJhVHJhY2UoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKCFlcnJvci5fX3N0YWNrQ2xlYW5lZF9fKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpO1xuICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJzdGFja1wiLFxuICAgICAgICAgICAgICAgIHBhcnNlZC5tZXNzYWdlICsgXCJcXG5cIiArIHBhcnNlZC5zdGFjay5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwiX19zdGFja0NsZWFuZWRfX1wiLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKHJldHVyblZhbHVlLCBwcm9taXNlQ3JlYXRlZCwgbmFtZSwgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQpIHtcbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBwcm9taXNlQ3JlYXRlZCAhPT0gbnVsbCAmJlxuICAgICAgICB3Rm9yZ290dGVuUmV0dXJuKSB7XG4gICAgICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCAmJiBwYXJlbnQuX3JldHVybmVkTm9uVW5kZWZpbmVkKCkpIHJldHVybjtcbiAgICAgICAgaWYgKChwcm9taXNlLl9iaXRGaWVsZCAmIDY1NTM1KSA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChuYW1lKSBuYW1lID0gbmFtZSArIFwiIFwiO1xuICAgICAgICB2YXIgaGFuZGxlckxpbmUgPSBcIlwiO1xuICAgICAgICB2YXIgY3JlYXRvckxpbmUgPSBcIlwiO1xuICAgICAgICBpZiAocHJvbWlzZUNyZWF0ZWQuX3RyYWNlKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2VMaW5lcyA9IHByb21pc2VDcmVhdGVkLl90cmFjZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IGNsZWFuU3RhY2sodHJhY2VMaW5lcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTWF0Y2hlcyA9IGxpbmUubWF0Y2gocGFyc2VMaW5lUGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlckxpbmUgID0gXCJhdCBcIiArIGxpbmVNYXRjaGVzWzFdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjpcIiArIGxpbmVNYXRjaGVzWzJdICsgXCI6XCIgKyBsaW5lTWF0Y2hlc1szXSArIFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RVc2VyTGluZSA9IHN0YWNrWzBdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2VMaW5lcy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFjZUxpbmVzW2ldID09PSBmaXJzdFVzZXJMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdG9yTGluZSA9IFwiXFxuXCIgKyB0cmFjZUxpbmVzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1zZyA9IFwiYSBwcm9taXNlIHdhcyBjcmVhdGVkIGluIGEgXCIgKyBuYW1lICtcbiAgICAgICAgICAgIFwiaGFuZGxlciBcIiArIGhhbmRsZXJMaW5lICsgXCJidXQgd2FzIG5vdCByZXR1cm5lZCBmcm9tIGl0LCBcIiArXG4gICAgICAgICAgICBcInNlZSBodHRwOi8vZ29vLmdsL3JScU1Vd1wiICtcbiAgICAgICAgICAgIGNyZWF0b3JMaW5lO1xuICAgICAgICBwcm9taXNlLl93YXJuKG1zZywgdHJ1ZSwgcHJvbWlzZUNyZWF0ZWQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChuYW1lLCByZXBsYWNlbWVudCkge1xuICAgIHZhciBtZXNzYWdlID0gbmFtZSArXG4gICAgICAgIFwiIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlwiO1xuICAgIGlmIChyZXBsYWNlbWVudCkgbWVzc2FnZSArPSBcIiBVc2UgXCIgKyByZXBsYWNlbWVudCArIFwiIGluc3RlYWQuXCI7XG4gICAgcmV0dXJuIHdhcm4obWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIHdhcm4obWVzc2FnZSwgc2hvdWxkVXNlT3duVHJhY2UsIHByb21pc2UpIHtcbiAgICBpZiAoIWNvbmZpZy53YXJuaW5ncykgcmV0dXJuO1xuICAgIHZhciB3YXJuaW5nID0gbmV3IFdhcm5pbmcobWVzc2FnZSk7XG4gICAgdmFyIGN0eDtcbiAgICBpZiAoc2hvdWxkVXNlT3duVHJhY2UpIHtcbiAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZSh3YXJuaW5nKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5sb25nU3RhY2tUcmFjZXMgJiYgKGN0eCA9IFByb21pc2UuX3BlZWtDb250ZXh0KCkpKSB7XG4gICAgICAgIGN0eC5hdHRhY2hFeHRyYVRyYWNlKHdhcm5pbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZVN0YWNrQW5kTWVzc2FnZSh3YXJuaW5nKTtcbiAgICAgICAgd2FybmluZy5zdGFjayA9IHBhcnNlZC5tZXNzYWdlICsgXCJcXG5cIiArIHBhcnNlZC5zdGFjay5qb2luKFwiXFxuXCIpO1xuICAgIH1cblxuICAgIGlmICghYWN0aXZlRmlyZUV2ZW50KFwid2FybmluZ1wiLCB3YXJuaW5nKSkge1xuICAgICAgICBmb3JtYXRBbmRMb2dFcnJvcih3YXJuaW5nLCBcIlwiLCB0cnVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlY29uc3RydWN0U3RhY2sobWVzc2FnZSwgc3RhY2tzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIHN0YWNrc1tpXS5wdXNoKFwiRnJvbSBwcmV2aW91cyBldmVudDpcIik7XG4gICAgICAgIHN0YWNrc1tpXSA9IHN0YWNrc1tpXS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICBpZiAoaSA8IHN0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgc3RhY2tzW2ldID0gc3RhY2tzW2ldLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlICsgXCJcXG5cIiArIHN0YWNrcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVPckVtcHR5SnVtcHMoc3RhY2tzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHN0YWNrc1tpXS5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgICgoaSArIDEgPCBzdGFja3MubGVuZ3RoKSAmJiBzdGFja3NbaV1bMF0gPT09IHN0YWNrc1tpKzFdWzBdKSkge1xuICAgICAgICAgICAgc3RhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ29tbW9uUm9vdHMoc3RhY2tzKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBzdGFja3NbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzdGFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHByZXYgPSBzdGFja3NbaV07XG4gICAgICAgIHZhciBjdXJyZW50TGFzdEluZGV4ID0gY3VycmVudC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgY3VycmVudExhc3RMaW5lID0gY3VycmVudFtjdXJyZW50TGFzdEluZGV4XTtcbiAgICAgICAgdmFyIGNvbW1vblJvb3RNZWV0UG9pbnQgPSAtMTtcblxuICAgICAgICBmb3IgKHZhciBqID0gcHJldi5sZW5ndGggLSAxOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgaWYgKHByZXZbal0gPT09IGN1cnJlbnRMYXN0TGluZSkge1xuICAgICAgICAgICAgICAgIGNvbW1vblJvb3RNZWV0UG9pbnQgPSBqO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IGNvbW1vblJvb3RNZWV0UG9pbnQ7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHByZXZbal07XG4gICAgICAgICAgICBpZiAoY3VycmVudFtjdXJyZW50TGFzdEluZGV4XSA9PT0gbGluZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQucG9wKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudExhc3RJbmRleC0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gcHJldjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuU3RhY2soc3RhY2spIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IHN0YWNrW2ldO1xuICAgICAgICB2YXIgaXNUcmFjZUxpbmUgPSBcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCIgPT09IGxpbmUgfHxcbiAgICAgICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuLnRlc3QobGluZSk7XG4gICAgICAgIHZhciBpc0ludGVybmFsRnJhbWUgPSBpc1RyYWNlTGluZSAmJiBzaG91bGRJZ25vcmUobGluZSk7XG4gICAgICAgIGlmIChpc1RyYWNlTGluZSAmJiAhaXNJbnRlcm5hbEZyYW1lKSB7XG4gICAgICAgICAgICBpZiAoaW5kZW50U3RhY2tGcmFtZXMgJiYgbGluZS5jaGFyQXQoMCkgIT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IFwiICAgIFwiICsgbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHN0YWNrRnJhbWVzQXNBcnJheShlcnJvcikge1xuICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrLnJlcGxhY2UoL1xccyskL2csIFwiXCIpLnNwbGl0KFwiXFxuXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBzdGFja1tpXTtcbiAgICAgICAgaWYgKFwiICAgIChObyBzdGFjayB0cmFjZSlcIiA9PT0gbGluZSB8fCBzdGFja0ZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA+IDAgJiYgZXJyb3IubmFtZSAhPSBcIlN5bnRheEVycm9yXCIpIHtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZShpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0YWNrQW5kTWVzc2FnZShlcnJvcikge1xuICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIHZhciBtZXNzYWdlID0gZXJyb3IudG9TdHJpbmcoKTtcbiAgICBzdGFjayA9IHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIiAmJiBzdGFjay5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgPyBzdGFja0ZyYW1lc0FzQXJyYXkoZXJyb3IpIDogW1wiICAgIChObyBzdGFjayB0cmFjZSlcIl07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgc3RhY2s6IGVycm9yLm5hbWUgPT0gXCJTeW50YXhFcnJvclwiID8gc3RhY2sgOiBjbGVhblN0YWNrKHN0YWNrKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEFuZExvZ0Vycm9yKGVycm9yLCB0aXRsZSwgaXNTb2Z0KSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICBpZiAodXRpbC5pc09iamVjdChlcnJvcikpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRpdGxlICsgZm9ybWF0U3RhY2soc3RhY2ssIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aXRsZSArIFN0cmluZyhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcmludFdhcm5pbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKG1lc3NhZ2UsIGlzU29mdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnNvbGUubG9nID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpcmVSZWplY3Rpb25FdmVudChuYW1lLCBsb2NhbEhhbmRsZXIsIHJlYXNvbiwgcHJvbWlzZSkge1xuICAgIHZhciBsb2NhbEV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBsb2NhbEV2ZW50RmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicmVqZWN0aW9uSGFuZGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxIYW5kbGVyKHByb21pc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhbEhhbmRsZXIocmVhc29uLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gXCJ1bmhhbmRsZWRSZWplY3Rpb25cIikge1xuICAgICAgICBpZiAoIWFjdGl2ZUZpcmVFdmVudChuYW1lLCByZWFzb24sIHByb21pc2UpICYmICFsb2NhbEV2ZW50RmlyZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdEFuZExvZ0Vycm9yKHJlYXNvbiwgXCJVbmhhbmRsZWQgcmVqZWN0aW9uIFwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZUZpcmVFdmVudChuYW1lLCBwcm9taXNlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE5vbkVycm9yKG9iaikge1xuICAgIHZhciBzdHI7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBzdHIgPSBcIltmdW5jdGlvbiBcIiArXG4gICAgICAgICAgICAob2JqLm5hbWUgfHwgXCJhbm9ueW1vdXNcIikgK1xuICAgICAgICAgICAgXCJdXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gb2JqICYmIHR5cGVvZiBvYmoudG9TdHJpbmcgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBvYmoudG9TdHJpbmcoKSA6IHV0aWwudG9TdHJpbmcob2JqKTtcbiAgICAgICAgdmFyIHJ1c2VsZXNzVG9TdHJpbmcgPSAvXFxbb2JqZWN0IFthLXpBLVowLTkkX10rXFxdLztcbiAgICAgICAgaWYgKHJ1c2VsZXNzVG9TdHJpbmcudGVzdChzdHIpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTdHIgPSBKU09OLnN0cmluZ2lmeShvYmopO1xuICAgICAgICAgICAgICAgIHN0ciA9IG5ld1N0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdHIgPSBcIihlbXB0eSBhcnJheSlcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKFwiKDxcIiArIHNuaXAoc3RyKSArIFwiPiwgbm8gc3RhY2sgdHJhY2UpXCIpO1xufVxuXG5mdW5jdGlvbiBzbmlwKHN0cikge1xuICAgIHZhciBtYXhDaGFycyA9IDQxO1xuICAgIGlmIChzdHIubGVuZ3RoIDwgbWF4Q2hhcnMpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgbWF4Q2hhcnMgLSAzKSArIFwiLi4uXCI7XG59XG5cbmZ1bmN0aW9uIGxvbmdTdGFja1RyYWNlc0lzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxudmFyIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG52YXIgcGFyc2VMaW5lSW5mb1JlZ2V4ID0gL1tcXC88XFwoXShbXjpcXC9dKyk6KFxcZCspOig/OlxcZCspXFwpP1xccyokLztcbmZ1bmN0aW9uIHBhcnNlTGluZUluZm8obGluZSkge1xuICAgIHZhciBtYXRjaGVzID0gbGluZS5tYXRjaChwYXJzZUxpbmVJbmZvUmVnZXgpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxlTmFtZTogbWF0Y2hlc1sxXSxcbiAgICAgICAgICAgIGxpbmU6IHBhcnNlSW50KG1hdGNoZXNbMl0sIDEwKVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0Qm91bmRzKGZpcnN0TGluZUVycm9yLCBsYXN0TGluZUVycm9yKSB7XG4gICAgaWYgKCFsb25nU3RhY2tUcmFjZXNJc1N1cHBvcnRlZCgpKSByZXR1cm47XG4gICAgdmFyIGZpcnN0U3RhY2tMaW5lcyA9IGZpcnN0TGluZUVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBsYXN0U3RhY2tMaW5lcyA9IGxhc3RMaW5lRXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgdmFyIGZpcnN0SW5kZXggPSAtMTtcbiAgICB2YXIgbGFzdEluZGV4ID0gLTE7XG4gICAgdmFyIGZpcnN0RmlsZU5hbWU7XG4gICAgdmFyIGxhc3RGaWxlTmFtZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0U3RhY2tMaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VMaW5lSW5mbyhmaXJzdFN0YWNrTGluZXNbaV0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBmaXJzdEZpbGVOYW1lID0gcmVzdWx0LmZpbGVOYW1lO1xuICAgICAgICAgICAgZmlyc3RJbmRleCA9IHJlc3VsdC5saW5lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0U3RhY2tMaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VMaW5lSW5mbyhsYXN0U3RhY2tMaW5lc1tpXSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGxhc3RGaWxlTmFtZSA9IHJlc3VsdC5maWxlTmFtZTtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IHJlc3VsdC5saW5lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpcnN0SW5kZXggPCAwIHx8IGxhc3RJbmRleCA8IDAgfHwgIWZpcnN0RmlsZU5hbWUgfHwgIWxhc3RGaWxlTmFtZSB8fFxuICAgICAgICBmaXJzdEZpbGVOYW1lICE9PSBsYXN0RmlsZU5hbWUgfHwgZmlyc3RJbmRleCA+PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgaWYgKGJsdWViaXJkRnJhbWVQYXR0ZXJuLnRlc3QobGluZSkpIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgaW5mbyA9IHBhcnNlTGluZUluZm8obGluZSk7XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5maWxlTmFtZSA9PT0gZmlyc3RGaWxlTmFtZSAmJlxuICAgICAgICAgICAgICAgIChmaXJzdEluZGV4IDw9IGluZm8ubGluZSAmJiBpbmZvLmxpbmUgPD0gbGFzdEluZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBDYXB0dXJlZFRyYWNlKHBhcmVudCkge1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLl9wcm9taXNlc0NyZWF0ZWQgPSAwO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGggPSAxICsgKHBhcmVudCA9PT0gdW5kZWZpbmVkID8gMCA6IHBhcmVudC5fbGVuZ3RoKTtcbiAgICBjYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDYXB0dXJlZFRyYWNlKTtcbiAgICBpZiAobGVuZ3RoID4gMzIpIHRoaXMudW5jeWNsZSgpO1xufVxudXRpbC5pbmhlcml0cyhDYXB0dXJlZFRyYWNlLCBFcnJvcik7XG5Db250ZXh0LkNhcHR1cmVkVHJhY2UgPSBDYXB0dXJlZFRyYWNlO1xuXG5DYXB0dXJlZFRyYWNlLnByb3RvdHlwZS51bmN5Y2xlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuX2xlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBzdGFja1RvSW5kZXggPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBub2RlID0gdGhpczsgbm9kZSAhPT0gdW5kZWZpbmVkOyArK2kpIHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUuX3BhcmVudDtcbiAgICB9XG4gICAgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoID0gaTtcbiAgICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gbm9kZXNbaV0uc3RhY2s7XG4gICAgICAgIGlmIChzdGFja1RvSW5kZXhbc3RhY2tdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YWNrVG9JbmRleFtzdGFja10gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGFjayA9IG5vZGVzW2ldLnN0YWNrO1xuICAgICAgICB2YXIgaW5kZXggPSBzdGFja1RvSW5kZXhbY3VycmVudFN0YWNrXTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaW5kZXggIT09IGkpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBub2Rlc1tpbmRleCAtIDFdLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbm9kZXNbaW5kZXggLSAxXS5fbGVuZ3RoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzW2ldLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBub2Rlc1tpXS5fbGVuZ3RoID0gMTtcbiAgICAgICAgICAgIHZhciBjeWNsZUVkZ2VOb2RlID0gaSA+IDAgPyBub2Rlc1tpIC0gMV0gOiB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50ID0gbm9kZXNbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQudW5jeWNsZSgpO1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCA9XG4gICAgICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudC5fbGVuZ3RoICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVudENoaWxkTGVuZ3RoID0gY3ljbGVFZGdlTm9kZS5fbGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpIC0gMjsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICBub2Rlc1tqXS5fbGVuZ3RoID0gY3VycmVudENoaWxkTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaGlsZExlbmd0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQ2FwdHVyZWRUcmFjZS5wcm90b3R5cGUuYXR0YWNoRXh0cmFUcmFjZSA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLl9fc3RhY2tDbGVhbmVkX18pIHJldHVybjtcbiAgICB0aGlzLnVuY3ljbGUoKTtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpO1xuICAgIHZhciBtZXNzYWdlID0gcGFyc2VkLm1lc3NhZ2U7XG4gICAgdmFyIHN0YWNrcyA9IFtwYXJzZWQuc3RhY2tdO1xuXG4gICAgdmFyIHRyYWNlID0gdGhpcztcbiAgICB3aGlsZSAodHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdGFja3MucHVzaChjbGVhblN0YWNrKHRyYWNlLnN0YWNrLnNwbGl0KFwiXFxuXCIpKSk7XG4gICAgICAgIHRyYWNlID0gdHJhY2UuX3BhcmVudDtcbiAgICB9XG4gICAgcmVtb3ZlQ29tbW9uUm9vdHMoc3RhY2tzKTtcbiAgICByZW1vdmVEdXBsaWNhdGVPckVtcHR5SnVtcHMoc3RhY2tzKTtcbiAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKGVycm9yLCBcInN0YWNrXCIsIHJlY29uc3RydWN0U3RhY2sobWVzc2FnZSwgc3RhY2tzKSk7XG4gICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJfX3N0YWNrQ2xlYW5lZF9fXCIsIHRydWUpO1xufTtcblxudmFyIGNhcHR1cmVTdGFja1RyYWNlID0gKGZ1bmN0aW9uIHN0YWNrRGV0ZWN0aW9uKCkge1xuICAgIHZhciB2OHN0YWNrRnJhbWVQYXR0ZXJuID0gL15cXHMqYXRcXHMqLztcbiAgICB2YXIgdjhzdGFja0Zvcm1hdHRlciA9IGZ1bmN0aW9uKHN0YWNrLCBlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIHN0YWNrID09PSBcInN0cmluZ1wiKSByZXR1cm4gc3RhY2s7XG5cbiAgICAgICAgaWYgKGVycm9yLm5hbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0Tm9uRXJyb3IoZXJyb3IpO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICB0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgKz0gNjtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSB2OHN0YWNrRnJhbWVQYXR0ZXJuO1xuICAgICAgICBmb3JtYXRTdGFjayA9IHY4c3RhY2tGb3JtYXR0ZXI7XG4gICAgICAgIHZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlO1xuXG4gICAgICAgIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBibHVlYmlyZEZyYW1lUGF0dGVybi50ZXN0KGxpbmUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVjZWl2ZXIsIGlnbm9yZVVudGlsKSB7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgKz0gNjtcbiAgICAgICAgICAgIGNhcHR1cmVTdGFja1RyYWNlKHJlY2VpdmVyLCBpZ25vcmVVbnRpbCk7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgLT0gNjtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuXG4gICAgaWYgKHR5cGVvZiBlcnIuc3RhY2sgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgZXJyLnN0YWNrLnNwbGl0KFwiXFxuXCIpWzBdLmluZGV4T2YoXCJzdGFja0RldGVjdGlvbkBcIikgPj0gMCkge1xuICAgICAgICBzdGFja0ZyYW1lUGF0dGVybiA9IC9ALztcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICBpbmRlbnRTdGFja0ZyYW1lcyA9IHRydWU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShvKSB7XG4gICAgICAgICAgICBvLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGhhc1N0YWNrQWZ0ZXJUaHJvdztcbiAgICB0cnkgeyB0aHJvdyBuZXcgRXJyb3IoKTsgfVxuICAgIGNhdGNoKGUpIHtcbiAgICAgICAgaGFzU3RhY2tBZnRlclRocm93ID0gKFwic3RhY2tcIiBpbiBlKTtcbiAgICB9XG4gICAgaWYgKCEoXCJzdGFja1wiIGluIGVycikgJiYgaGFzU3RhY2tBZnRlclRocm93ICYmXG4gICAgICAgIHR5cGVvZiBFcnJvci5zdGFja1RyYWNlTGltaXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSB2OHN0YWNrRnJhbWVQYXR0ZXJuO1xuICAgICAgICBmb3JtYXRTdGFjayA9IHY4c3RhY2tGb3JtYXR0ZXI7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShvKSB7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgKz0gNjtcbiAgICAgICAgICAgIHRyeSB7IHRocm93IG5ldyBFcnJvcigpOyB9XG4gICAgICAgICAgICBjYXRjaChlKSB7IG8uc3RhY2sgPSBlLnN0YWNrOyB9XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgLT0gNjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3JtYXRTdGFjayA9IGZ1bmN0aW9uKHN0YWNrLCBlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIHN0YWNrID09PSBcInN0cmluZ1wiKSByZXR1cm4gc3RhY2s7XG5cbiAgICAgICAgaWYgKCh0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlcnJvciA9PT0gXCJmdW5jdGlvblwiKSAmJlxuICAgICAgICAgICAgZXJyb3IubmFtZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvci50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXROb25FcnJvcihlcnJvcik7XG4gICAgfTtcblxuICAgIHJldHVybiBudWxsO1xuXG59KShbXSk7XG5cbmlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS53YXJuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgaWYgKHV0aWwuaXNOb2RlICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGlzU29mdCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gaXNTb2Z0ID8gXCJcXHUwMDFiWzMzbVwiIDogXCJcXHUwMDFiWzMxbVwiO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbG9yICsgbWVzc2FnZSArIFwiXFx1MDAxYlswbVxcblwiKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCF1dGlsLmlzTm9kZSAmJiB0eXBlb2YgKG5ldyBFcnJvcigpLnN0YWNrKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbihtZXNzYWdlLCBpc1NvZnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIiVjXCIgKyBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTb2Z0ID8gXCJjb2xvcjogZGFya29yYW5nZVwiIDogXCJjb2xvcjogcmVkXCIpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxudmFyIGNvbmZpZyA9IHtcbiAgICB3YXJuaW5nczogd2FybmluZ3MsXG4gICAgbG9uZ1N0YWNrVHJhY2VzOiBmYWxzZSxcbiAgICBjYW5jZWxsYXRpb246IGZhbHNlLFxuICAgIG1vbml0b3Jpbmc6IGZhbHNlXG59O1xuXG5pZiAobG9uZ1N0YWNrVHJhY2VzKSBQcm9taXNlLmxvbmdTdGFja1RyYWNlcygpO1xuXG5yZXR1cm4ge1xuICAgIGxvbmdTdGFja1RyYWNlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25maWcubG9uZ1N0YWNrVHJhY2VzO1xuICAgIH0sXG4gICAgd2FybmluZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLndhcm5pbmdzO1xuICAgIH0sXG4gICAgY2FuY2VsbGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5jYW5jZWxsYXRpb247XG4gICAgfSxcbiAgICBtb25pdG9yaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5tb25pdG9yaW5nO1xuICAgIH0sXG4gICAgcHJvcGFnYXRlRnJvbUZ1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHByb3BhZ2F0ZUZyb21GdW5jdGlvbjtcbiAgICB9LFxuICAgIGJvdW5kVmFsdWVGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBib3VuZFZhbHVlRnVuY3Rpb247XG4gICAgfSxcbiAgICBjaGVja0ZvcmdvdHRlblJldHVybnM6IGNoZWNrRm9yZ290dGVuUmV0dXJucyxcbiAgICBzZXRCb3VuZHM6IHNldEJvdW5kcyxcbiAgICB3YXJuOiB3YXJuLFxuICAgIGRlcHJlY2F0ZWQ6IGRlcHJlY2F0ZWQsXG4gICAgQ2FwdHVyZWRUcmFjZTogQ2FwdHVyZWRUcmFjZSxcbiAgICBmaXJlRG9tRXZlbnQ6IGZpcmVEb21FdmVudCxcbiAgICBmaXJlR2xvYmFsRXZlbnQ6IGZpcmVHbG9iYWxFdmVudFxufTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9kZWJ1Z2dhYmlsaXR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIHRyeUNvbnZlcnRUb1Byb21pc2UsIE5FWFRfRklMVEVSKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciBjYXRjaEZpbHRlciA9IHJlcXVpcmUoXCIuL2NhdGNoX2ZpbHRlclwiKShORVhUX0ZJTFRFUik7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQocHJvbWlzZSwgdHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHRoaXMuY2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5jYW5jZWxQcm9taXNlID0gbnVsbDtcbn1cblxuUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dC5wcm90b3R5cGUuaXNGaW5hbGx5SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IDA7XG59O1xuXG5mdW5jdGlvbiBGaW5hbGx5SGFuZGxlckNhbmNlbFJlYWN0aW9uKGZpbmFsbHlIYW5kbGVyKSB7XG4gICAgdGhpcy5maW5hbGx5SGFuZGxlciA9IGZpbmFsbHlIYW5kbGVyO1xufVxuXG5GaW5hbGx5SGFuZGxlckNhbmNlbFJlYWN0aW9uLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgY2hlY2tDYW5jZWwodGhpcy5maW5hbGx5SGFuZGxlcik7XG59O1xuXG5mdW5jdGlvbiBjaGVja0NhbmNlbChjdHgsIHJlYXNvbikge1xuICAgIGlmIChjdHguY2FuY2VsUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY3R4LmNhbmNlbFByb21pc2UuX3JlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmNhbmNlbFByb21pc2UuX2NhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5jYW5jZWxQcm9taXNlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc3VjY2VlZCgpIHtcbiAgICByZXR1cm4gZmluYWxseUhhbmRsZXIuY2FsbCh0aGlzLCB0aGlzLnByb21pc2UuX3RhcmdldCgpLl9zZXR0bGVkVmFsdWUoKSk7XG59XG5mdW5jdGlvbiBmYWlsKHJlYXNvbikge1xuICAgIGlmIChjaGVja0NhbmNlbCh0aGlzLCByZWFzb24pKSByZXR1cm47XG4gICAgZXJyb3JPYmouZSA9IHJlYXNvbjtcbiAgICByZXR1cm4gZXJyb3JPYmo7XG59XG5mdW5jdGlvbiBmaW5hbGx5SGFuZGxlcihyZWFzb25PclZhbHVlKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG4gICAgdmFyIGhhbmRsZXIgPSB0aGlzLmhhbmRsZXI7XG5cbiAgICBpZiAoIXRoaXMuY2FsbGVkKSB7XG4gICAgICAgIHRoaXMuY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJldCA9IHRoaXMuaXNGaW5hbGx5SGFuZGxlcigpXG4gICAgICAgICAgICA/IGhhbmRsZXIuY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCkpXG4gICAgICAgICAgICA6IGhhbmRsZXIuY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksIHJlYXNvbk9yVmFsdWUpO1xuICAgICAgICBpZiAocmV0ID09PSBORVhUX0ZJTFRFUikge1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSBlbHNlIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvbWlzZS5fc2V0UmV0dXJuZWROb25VbmRlZmluZWQoKTtcbiAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJldCwgcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbmNlbFByb21pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlLl9pc0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhc29uID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoXCJsYXRlIGNhbmNlbGxhdGlvbiBvYnNlcnZlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UocmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yT2JqLmUgPSByZWFzb247XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF5YmVQcm9taXNlLmlzUGVuZGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBGaW5hbGx5SGFuZGxlckNhbmNlbFJlYWN0aW9uKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlLl90aGVuKFxuICAgICAgICAgICAgICAgICAgICBzdWNjZWVkLCBmYWlsLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZS5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgY2hlY2tDYW5jZWwodGhpcyk7XG4gICAgICAgIGVycm9yT2JqLmUgPSByZWFzb25PclZhbHVlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tDYW5jZWwodGhpcyk7XG4gICAgICAgIHJldHVybiByZWFzb25PclZhbHVlO1xuICAgIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuX3Bhc3NUaHJvdWdoID0gZnVuY3Rpb24oaGFuZGxlciwgdHlwZSwgc3VjY2VzcywgZmFpbCkge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdGhpcy50aGVuKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICBmYWlsLFxuICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dCh0aGlzLCB0eXBlLCBoYW5kbGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubGFzdGx5ID1cblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoKGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHlIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5SGFuZGxlcik7XG59O1xuXG5cblByb21pc2UucHJvdG90eXBlLnRhcCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoKGhhbmRsZXIsIDEsIGZpbmFsbHlIYW5kbGVyKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRhcENhdGNoID0gZnVuY3Rpb24gKGhhbmRsZXJPclByZWRpY2F0ZSkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmKGxlbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFzc1Rocm91Z2goaGFuZGxlck9yUHJlZGljYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHlIYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAgdmFyIGNhdGNoSW5zdGFuY2VzID0gbmV3IEFycmF5KGxlbiAtIDEpLFxuICAgICAgICAgICAgaiA9IDAsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBjYXRjaEluc3RhbmNlc1tqKytdID0gaXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwidGFwQ2F0Y2ggc3RhdGVtZW50IHByZWRpY2F0ZTogXCJcbiAgICAgICAgICAgICAgICAgICAgKyBcImV4cGVjdGluZyBhbiBvYmplY3QgYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoaXRlbSlcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaEluc3RhbmNlcy5sZW5ndGggPSBqO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoKGNhdGNoRmlsdGVyKGNhdGNoSW5zdGFuY2VzLCBoYW5kbGVyLCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5SGFuZGxlcik7XG4gICAgfVxuXG59O1xuXG5yZXR1cm4gUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9maW5hbGx5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5FWFRfRklMVEVSKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoXCIuL2VzNVwiKS5rZXlzO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG5cbmZ1bmN0aW9uIGNhdGNoRmlsdGVyKGluc3RhbmNlcywgY2IsIHByb21pc2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgYm91bmRUbyA9IHByb21pc2UuX2JvdW5kVmFsdWUoKTtcbiAgICAgICAgcHJlZGljYXRlTG9vcDogZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gaW5zdGFuY2VzW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gRXJyb3IgfHxcbiAgICAgICAgICAgICAgICAoaXRlbSAhPSBudWxsICYmIGl0ZW0ucHJvdG90eXBlIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlDYXRjaChjYikuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlc1ByZWRpY2F0ZSA9IHRyeUNhdGNoKGl0ZW0pLmNhbGwoYm91bmRUbywgZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNQcmVkaWNhdGUgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzUHJlZGljYXRlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hlc1ByZWRpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5Q2F0Y2goY2IpLmNhbGwoYm91bmRUbywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBnZXRLZXlzKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1ba2V5XSAhPSBlW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHByZWRpY2F0ZUxvb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyeUNhdGNoKGNiKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBORVhUX0ZJTFRFUjtcbiAgICB9O1xufVxuXG5yZXR1cm4gY2F0Y2hGaWx0ZXI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvY2F0Y2hfZmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgbWF5YmVXcmFwQXNFcnJvciA9IHV0aWwubWF5YmVXcmFwQXNFcnJvcjtcbnZhciBlcnJvcnMgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG52YXIgT3BlcmF0aW9uYWxFcnJvciA9IGVycm9ycy5PcGVyYXRpb25hbEVycm9yO1xudmFyIGVzNSA9IHJlcXVpcmUoXCIuL2VzNVwiKTtcblxuZnVuY3Rpb24gaXNVbnR5cGVkRXJyb3Iob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgIGVzNS5nZXRQcm90b3R5cGVPZihvYmopID09PSBFcnJvci5wcm90b3R5cGU7XG59XG5cbnZhciByRXJyb3JLZXkgPSAvXig/Om5hbWV8bWVzc2FnZXxzdGFja3xjYXVzZSkkLztcbmZ1bmN0aW9uIHdyYXBBc09wZXJhdGlvbmFsRXJyb3Iob2JqKSB7XG4gICAgdmFyIHJldDtcbiAgICBpZiAoaXNVbnR5cGVkRXJyb3Iob2JqKSkge1xuICAgICAgICByZXQgPSBuZXcgT3BlcmF0aW9uYWxFcnJvcihvYmopO1xuICAgICAgICByZXQubmFtZSA9IG9iai5uYW1lO1xuICAgICAgICByZXQubWVzc2FnZSA9IG9iai5tZXNzYWdlO1xuICAgICAgICByZXQuc3RhY2sgPSBvYmouc3RhY2s7XG4gICAgICAgIHZhciBrZXlzID0gZXM1LmtleXMob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghckVycm9yS2V5LnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgdXRpbC5tYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24ob2JqKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBub2RlYmFja0ZvclByb21pc2UocHJvbWlzZSwgbXVsdGlBcmdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVyciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHByb21pc2UgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdmFyIHdyYXBwZWQgPSB3cmFwQXNPcGVyYXRpb25hbEVycm9yKG1heWJlV3JhcEFzRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHdyYXBwZWQpO1xuICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHdyYXBwZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKCFtdWx0aUFyZ3MpIHtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyICRfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgYXJncyA9IG5ldyBBcnJheShNYXRoLm1heCgkX2xlbiAtIDEsIDApKTsgZm9yKHZhciAkX2kgPSAxOyAkX2kgPCAkX2xlbjsgKyskX2kpIHthcmdzWyRfaSAtIDFdID0gYXJndW1lbnRzWyRfaV07fTtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub2RlYmFja0ZvclByb21pc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9ub2RlYmFjay5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbiwgZGVidWcpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG5cblByb21pc2UubWV0aG9kID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQcm9taXNlLlR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgcmV0Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0cnlDYXRjaChmbikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHByb21pc2VDcmVhdGVkID0gcmV0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgICAgIHZhbHVlLCBwcm9taXNlQ3JlYXRlZCwgXCJQcm9taXNlLm1ldGhvZFwiLCByZXQpO1xuICAgICAgICByZXQuX3Jlc29sdmVGcm9tU3luY1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5hdHRlbXB0ID0gUHJvbWlzZVtcInRyeVwiXSA9IGZ1bmN0aW9uIChmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgcmV0Ll9wdXNoQ29udGV4dCgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZGVidWcuZGVwcmVjYXRlZChcImNhbGxpbmcgUHJvbWlzZS50cnkgd2l0aCBtb3JlIHRoYW4gMSBhcmd1bWVudFwiKTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGN0eCA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgdmFsdWUgPSB1dGlsLmlzQXJyYXkoYXJnKSA/IHRyeUNhdGNoKGZuKS5hcHBseShjdHgsIGFyZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRyeUNhdGNoKGZuKS5jYWxsKGN0eCwgYXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHRyeUNhdGNoKGZuKSgpO1xuICAgIH1cbiAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSByZXQuX3BvcENvbnRleHQoKTtcbiAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoXG4gICAgICAgIHZhbHVlLCBwcm9taXNlQ3JlYXRlZCwgXCJQcm9taXNlLnRyeVwiLCByZXQpO1xuICAgIHJldC5fcmVzb2x2ZUZyb21TeW5jVmFsdWUodmFsdWUpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUZyb21TeW5jVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHV0aWwuZXJyb3JPYmopIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0Q2FsbGJhY2sodmFsdWUuZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxufTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9tZXRob2QuanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGRlYnVnKSB7XG52YXIgY2FsbGVkQmluZCA9IGZhbHNlO1xudmFyIHJlamVjdFRoaXMgPSBmdW5jdGlvbihfLCBlKSB7XG4gICAgdGhpcy5fcmVqZWN0KGUpO1xufTtcblxudmFyIHRhcmdldFJlamVjdGVkID0gZnVuY3Rpb24oZSwgY29udGV4dCkge1xuICAgIGNvbnRleHQucHJvbWlzZVJlamVjdGlvblF1ZXVlZCA9IHRydWU7XG4gICAgY29udGV4dC5iaW5kaW5nUHJvbWlzZS5fdGhlbihyZWplY3RUaGlzLCByZWplY3RUaGlzLCBudWxsLCB0aGlzLCBlKTtcbn07XG5cbnZhciBiaW5kaW5nUmVzb2x2ZWQgPSBmdW5jdGlvbih0aGlzQXJnLCBjb250ZXh0KSB7XG4gICAgaWYgKCgodGhpcy5fYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVDYWxsYmFjayhjb250ZXh0LnRhcmdldCk7XG4gICAgfVxufTtcblxudmFyIGJpbmRpbmdSZWplY3RlZCA9IGZ1bmN0aW9uKGUsIGNvbnRleHQpIHtcbiAgICBpZiAoIWNvbnRleHQucHJvbWlzZVJlamVjdGlvblF1ZXVlZCkgdGhpcy5fcmVqZWN0KGUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICh0aGlzQXJnKSB7XG4gICAgaWYgKCFjYWxsZWRCaW5kKSB7XG4gICAgICAgIGNhbGxlZEJpbmQgPSB0cnVlO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcHJvcGFnYXRlRnJvbSA9IGRlYnVnLnByb3BhZ2F0ZUZyb21GdW5jdGlvbigpO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fYm91bmRWYWx1ZSA9IGRlYnVnLmJvdW5kVmFsdWVGdW5jdGlvbigpO1xuICAgIH1cbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGlzQXJnKTtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fcHJvcGFnYXRlRnJvbSh0aGlzLCAxKTtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgcmV0Ll9zZXRCb3VuZFRvKG1heWJlUHJvbWlzZSk7XG4gICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICBwcm9taXNlUmVqZWN0aW9uUXVldWVkOiBmYWxzZSxcbiAgICAgICAgICAgIHByb21pc2U6IHJldCxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgYmluZGluZ1Byb21pc2U6IG1heWJlUHJvbWlzZVxuICAgICAgICB9O1xuICAgICAgICB0YXJnZXQuX3RoZW4oSU5URVJOQUwsIHRhcmdldFJlamVjdGVkLCB1bmRlZmluZWQsIHJldCwgY29udGV4dCk7XG4gICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihcbiAgICAgICAgICAgIGJpbmRpbmdSZXNvbHZlZCwgYmluZGluZ1JlamVjdGVkLCB1bmRlZmluZWQsIHJldCwgY29udGV4dCk7XG4gICAgICAgIHJldC5fc2V0T25DYW5jZWwobWF5YmVQcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQuX3Jlc29sdmVDYWxsYmFjayh0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEJvdW5kVG8gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAyMDk3MTUyO1xuICAgICAgICB0aGlzLl9ib3VuZFRvID0gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjIwOTcxNTIpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0JvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyMDk3MTUyKSA9PT0gMjA5NzE1Mjtcbn07XG5cblByb21pc2UuYmluZCA9IGZ1bmN0aW9uICh0aGlzQXJnLCB2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLmJpbmQodGhpc0FyZyk7XG59O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2JpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIGRlYnVnKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciBhc3luYyA9IFByb21pc2UuX2FzeW5jO1xuXG5Qcm9taXNlLnByb3RvdHlwZVtcImJyZWFrXCJdID0gUHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFkZWJ1Zy5jYW5jZWxsYXRpb24oKSkgcmV0dXJuIHRoaXMuX3dhcm4oXCJjYW5jZWxsYXRpb24gaXMgZGlzYWJsZWRcIik7XG5cbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGNoaWxkID0gcHJvbWlzZTtcbiAgICB3aGlsZSAocHJvbWlzZS5faXNDYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgIGlmICghcHJvbWlzZS5fY2FuY2VsQnkoY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuX2lzRm9sbG93aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuX2NhbmNlbEJyYW5jaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnQgPSBwcm9taXNlLl9jYW5jZWxsYXRpb25QYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgPT0gbnVsbCB8fCAhcGFyZW50Ll9pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9pc0ZvbGxvd2luZygpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fY2FuY2VsQnJhbmNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2lzRm9sbG93aW5nKCkpIHByb21pc2UuX2ZvbGxvd2VlKCkuY2FuY2VsKCk7XG4gICAgICAgICAgICBwcm9taXNlLl9zZXRXaWxsQmVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIGNoaWxkID0gcHJvbWlzZTtcbiAgICAgICAgICAgIHByb21pc2UgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYnJhbmNoSGFzQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbC0tO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgdGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA8PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NhbmNlbEJ5ID0gZnVuY3Rpb24oY2FuY2VsbGVyKSB7XG4gICAgaWYgKGNhbmNlbGxlciA9PT0gdGhpcykge1xuICAgICAgICB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gMDtcbiAgICAgICAgdGhpcy5faW52b2tlT25DYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYnJhbmNoSGFzQ2FuY2VsbGVkKCk7XG4gICAgICAgIGlmICh0aGlzLl9lbm91Z2hCcmFuY2hlc0hhdmVDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5faW52b2tlT25DYW5jZWwoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWxCcmFuY2hlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9lbm91Z2hCcmFuY2hlc0hhdmVDYW5jZWxsZWQoKSkge1xuICAgICAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxhYmxlKCkpIHJldHVybjtcbiAgICB0aGlzLl9zZXRDYW5jZWxsZWQoKTtcbiAgICBhc3luYy5pbnZva2UodGhpcy5fY2FuY2VsUHJvbWlzZXMsIHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsUHJvbWlzZXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGVuZ3RoKCkgPiAwKSB0aGlzLl9zZXR0bGVQcm9taXNlcygpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0T25DYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9vbkNhbmNlbEZpZWxkID0gdW5kZWZpbmVkO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzQ2FuY2VsbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BlbmRpbmcoKSAmJiAhdGhpcy5faXNDYW5jZWxsZWQoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzQ2FuY2VsbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BlbmRpbmcoKSAmJiAhdGhpcy5pc0NhbmNlbGxlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2RvSW52b2tlT25DYW5jZWwgPSBmdW5jdGlvbihvbkNhbmNlbENhbGxiYWNrLCBpbnRlcm5hbE9ubHkpIHtcbiAgICBpZiAodXRpbC5pc0FycmF5KG9uQ2FuY2VsQ2FsbGJhY2spKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb25DYW5jZWxDYWxsYmFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5fZG9JbnZva2VPbkNhbmNlbChvbkNhbmNlbENhbGxiYWNrW2ldLCBpbnRlcm5hbE9ubHkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvbkNhbmNlbENhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkNhbmNlbENhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxPbmx5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0cnlDYXRjaChvbkNhbmNlbENhbGxiYWNrKS5jYWxsKHRoaXMuX2JvdW5kVmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZS5lKTtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlLmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uQ2FuY2VsQ2FsbGJhY2suX3Jlc3VsdENhbmNlbGxlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pbnZva2VPbkNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbkNhbmNlbENhbGxiYWNrID0gdGhpcy5fb25DYW5jZWwoKTtcbiAgICB0aGlzLl91bnNldE9uQ2FuY2VsKCk7XG4gICAgYXN5bmMuaW52b2tlKHRoaXMuX2RvSW52b2tlT25DYW5jZWwsIHRoaXMsIG9uQ2FuY2VsQ2FsbGJhY2spO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ludm9rZUludGVybmFsT25DYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNDYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgIHRoaXMuX2RvSW52b2tlT25DYW5jZWwodGhpcy5fb25DYW5jZWwoKSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3Vuc2V0T25DYW5jZWwoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jYW5jZWwoKTtcbn07XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9jYW5jZWwuanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xuZnVuY3Rpb24gcmV0dXJuZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG59XG5mdW5jdGlvbiB0aHJvd2VyKCkge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZVtcInJldHVyblwiXSA9XG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkgdmFsdWUuc3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oXG4gICAgICAgIHJldHVybmVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge3ZhbHVlOiB2YWx1ZX0sIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZVtcInRocm93XCJdID1cblByb21pc2UucHJvdG90eXBlLnRoZW5UaHJvdyA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgdGhyb3dlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtyZWFzb246IHJlYXNvbn0sIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5jYXRjaFRocm93ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW4oXG4gICAgICAgICAgICB1bmRlZmluZWQsIHRocm93ZXIsIHVuZGVmaW5lZCwge3JlYXNvbjogcmVhc29ufSwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3JlYXNvbiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHt0aHJvdyBfcmVhc29uO307XG4gICAgICAgIHJldHVybiB0aGlzLmNhdWdodChyZWFzb24sIGhhbmRsZXIpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLmNhdGNoUmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB2YWx1ZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW4oXG4gICAgICAgICAgICB1bmRlZmluZWQsIHJldHVybmVyLCB1bmRlZmluZWQsIHt2YWx1ZTogdmFsdWV9LCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGlmIChfdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSBfdmFsdWUuc3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24oKSB7cmV0dXJuIF92YWx1ZTt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jYXVnaHQodmFsdWUsIGhhbmRsZXIpO1xuICAgIH1cbn07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvZGlyZWN0X3Jlc29sdmUuanNcbi8vIG1vZHVsZSBpZCA9IDE0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xuZnVuY3Rpb24gUHJvbWlzZUluc3BlY3Rpb24ocHJvbWlzZSkge1xuICAgIGlmIChwcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICB0aGlzLl9zZXR0bGVkVmFsdWVGaWVsZCA9IHByb21pc2UuX2lzRmF0ZVNlYWxlZCgpXG4gICAgICAgICAgICA/IHByb21pc2UuX3NldHRsZWRWYWx1ZSgpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSAwO1xuICAgICAgICB0aGlzLl9zZXR0bGVkVmFsdWVGaWVsZCA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5fc2V0dGxlZFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkO1xufTtcblxudmFyIHZhbHVlID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgZ2V0IGZ1bGZpbGxtZW50IHZhbHVlIG9mIGEgbm9uLWZ1bGZpbGxlZCBwcm9taXNlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xufTtcblxudmFyIHJlYXNvbiA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5lcnJvciA9XG5Qcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUucmVhc29uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBnZXQgcmVqZWN0aW9uIHJlYXNvbiBvZiBhIG5vbi1yZWplY3RlZCBwcm9taXNlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xufTtcblxudmFyIGlzRnVsZmlsbGVkID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMDtcbn07XG5cbnZhciBpc1JlamVjdGVkID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMDtcbn07XG5cbnZhciBpc1BlbmRpbmcgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDA7XG59O1xuXG52YXIgaXNSZXNvbHZlZCA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc1Jlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA1MDMzMTY0OCkgIT09IDA7XG59O1xuXG5Qcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgODQ1NDE0NCkgIT09IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fX2lzQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDY1NTM2KSA9PT0gNjU1MzY7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0KCkuX19pc0NhbmNlbGxlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX3RhcmdldCgpLl9iaXRGaWVsZCAmIDg0NTQxNDQpICE9PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzUGVuZGluZy5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNSZWplY3RlZC5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzRnVsZmlsbGVkLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZXNvbHZlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc1Jlc29sdmVkLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWUuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yZWFzb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgdGFyZ2V0Ll91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgcmV0dXJuIHJlYXNvbi5jYWxsKHRhcmdldCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVhc29uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbn07XG5cblByb21pc2UuUHJvbWlzZUluc3BlY3Rpb24gPSBQcm9taXNlSW5zcGVjdGlvbjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9zeW5jaHJvbm91c19pbnNwZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9XG5mdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBhc3luYyxcbiAgICAgICAgIGdldERvbWFpbikge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGNhbkV2YWx1YXRlID0gdXRpbC5jYW5FdmFsdWF0ZTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIHJlamVjdDtcblxuaWYgKCFmYWxzZSkge1xuaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgdmFyIHRoZW5DYWxsYmFjayA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInZhbHVlXCIsIFwiaG9sZGVyXCIsIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLnBJbmRleCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLmNoZWNrRnVsZmlsbG1lbnQodGhpcyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCIucmVwbGFjZSgvSW5kZXgvZywgaSkpO1xuICAgIH07XG5cbiAgICB2YXIgcHJvbWlzZVNldHRlciA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInByb21pc2VcIiwgXCJob2xkZXJcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLnBJbmRleCA9IHByb21pc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCIucmVwbGFjZSgvSW5kZXgvZywgaSkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2VuZXJhdGVIb2xkZXJDbGFzcyA9IGZ1bmN0aW9uKHRvdGFsKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IG5ldyBBcnJheSh0b3RhbCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHByb3BzW2ldID0gXCJ0aGlzLnBcIiArIChpKzEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhc3NpZ25tZW50ID0gcHJvcHMuam9pbihcIiA9IFwiKSArIFwiID0gbnVsbDtcIjtcbiAgICAgICAgdmFyIGNhbmNlbGxhdGlvbkNvZGU9IFwidmFyIHByb21pc2U7XFxuXCIgKyBwcm9wcy5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gXCIgKyBwcm9wICsgXCI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmNhbmNlbCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCI7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIHZhciBwYXNzZWRBcmd1bWVudHMgPSBwcm9wcy5qb2luKFwiLCBcIik7XG4gICAgICAgIHZhciBuYW1lID0gXCJIb2xkZXIkXCIgKyB0b3RhbDtcblxuXG4gICAgICAgIHZhciBjb2RlID0gXCJyZXR1cm4gZnVuY3Rpb24odHJ5Q2F0Y2gsIGVycm9yT2JqLCBQcm9taXNlLCBhc3luYykgeyAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZnVuY3Rpb24gW1RoZU5hbWVdKGZuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtUaGVQcm9wZXJ0aWVzXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMuZm4gPSBmbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMuYXN5bmNOZWVkZWQgPSB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMubm93ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5fY2FsbEZ1bmN0aW9uID0gZnVuY3Rpb24ocHJvbWlzZSkgeyAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHZhciByZXQgPSB0cnlDYXRjaCh0aGlzLmZuKShbVGhlUGFzc2VkQXJndW1lbnRzXSk7ICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3BvcENvbnRleHQoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZXQuZSwgZmFsc2UpOyAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2socmV0KTsgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5jaGVja0Z1bGZpbGxtZW50ID0gZnVuY3Rpb24ocHJvbWlzZSkgeyAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHZhciBub3cgPSArK3RoaXMubm93OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChub3cgPT09IFtUaGVUb3RhbF0pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hc3luY05lZWRlZCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMuaW52b2tlKHRoaXMuX2NhbGxGdW5jdGlvbiwgdGhpcywgcHJvbWlzZSk7ICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbEZ1bmN0aW9uKHByb21pc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7ICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtDYW5jZWxsYXRpb25Db2RlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIFtUaGVOYW1lXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9KHRyeUNhdGNoLCBlcnJvck9iaiwgUHJvbWlzZSwgYXN5bmMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIjtcblxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9cXFtUaGVOYW1lXFxdL2csIG5hbWUpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbVGhlVG90YWxcXF0vZywgdG90YWwpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbVGhlUGFzc2VkQXJndW1lbnRzXFxdL2csIHBhc3NlZEFyZ3VtZW50cylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtUaGVQcm9wZXJ0aWVzXFxdL2csIGFzc2lnbm1lbnQpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbQ2FuY2VsbGF0aW9uQ29kZVxcXS9nLCBjYW5jZWxsYXRpb25Db2RlKTtcblxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwidHJ5Q2F0Y2hcIiwgXCJlcnJvck9ialwiLCBcIlByb21pc2VcIiwgXCJhc3luY1wiLCBjb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRyeUNhdGNoLCBlcnJvck9iaiwgUHJvbWlzZSwgYXN5bmMpO1xuICAgIH07XG5cbiAgICB2YXIgaG9sZGVyQ2xhc3NlcyA9IFtdO1xuICAgIHZhciB0aGVuQ2FsbGJhY2tzID0gW107XG4gICAgdmFyIHByb21pc2VTZXR0ZXJzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgICBob2xkZXJDbGFzc2VzLnB1c2goZ2VuZXJhdGVIb2xkZXJDbGFzcyhpICsgMSkpO1xuICAgICAgICB0aGVuQ2FsbGJhY2tzLnB1c2godGhlbkNhbGxiYWNrKGkgKyAxKSk7XG4gICAgICAgIHByb21pc2VTZXR0ZXJzLnB1c2gocHJvbWlzZVNldHRlcihpICsgMSkpO1xuICAgIH1cblxuICAgIHJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgfTtcbn19XG5cblByb21pc2Uuam9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFzdCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHZhciBmbjtcbiAgICBpZiAobGFzdCA+IDAgJiYgdHlwZW9mIGFyZ3VtZW50c1tsYXN0XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZuID0gYXJndW1lbnRzW2xhc3RdO1xuICAgICAgICBpZiAoIWZhbHNlKSB7XG4gICAgICAgICAgICBpZiAobGFzdCA8PSA4ICYmIGNhbkV2YWx1YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgICAgICAgICAgdmFyIEhvbGRlckNsYXNzID0gaG9sZGVyQ2xhc3Nlc1tsYXN0IC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIGhvbGRlciA9IG5ldyBIb2xkZXJDbGFzcyhmbik7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoZW5DYWxsYmFja3M7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3Q7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShhcmd1bWVudHNbaV0sIHJldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJpdEZpZWxkID0gbWF5YmVQcm9taXNlLl9iaXRGaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihjYWxsYmFja3NbaV0sIHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLCByZXQsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVNldHRlcnNbaV0obWF5YmVQcm9taXNlLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5hc3luY05lZWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHJldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3ZhbHVlKCksIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9yZWplY3QobWF5YmVQcm9taXNlLl9yZWFzb24oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5fY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3NbaV0uY2FsbChyZXQsIG1heWJlUHJvbWlzZSwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghcmV0Ll9pc0ZhdGVTZWFsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLmFzeW5jTmVlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZuID0gdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgaG9sZGVyLmZuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXQuX3NldE9uQ2FuY2VsKGhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyICRfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgYXJncyA9IG5ldyBBcnJheSgkX2xlbik7IGZvcih2YXIgJF9pID0gMDsgJF9pIDwgJF9sZW47ICsrJF9pKSB7YXJnc1skX2ldID0gYXJndW1lbnRzWyRfaV07fTtcbiAgICBpZiAoZm4pIGFyZ3MucG9wKCk7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlQXJyYXkoYXJncykucHJvbWlzZSgpO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gcmV0LnNwcmVhZChmbikgOiByZXQ7XG59O1xuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2Uvam9pbi5qc1xuLy8gbW9kdWxlIGlkID0gMTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlQXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlamVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKSB7XG52YXIgZ2V0RG9tYWluID0gUHJvbWlzZS5fZ2V0RG9tYWluO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcblxuZnVuY3Rpb24gTWFwcGluZ1Byb21pc2VBcnJheShwcm9taXNlcywgZm4sIGxpbWl0LCBfZmlsdGVyKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQocHJvbWlzZXMpO1xuICAgIHRoaXMuX3Byb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gZG9tYWluID09PSBudWxsID8gZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbik7XG4gICAgdGhpcy5fcHJlc2VydmVkVmFsdWVzID0gX2ZpbHRlciA9PT0gSU5URVJOQUxcbiAgICAgICAgPyBuZXcgQXJyYXkodGhpcy5sZW5ndGgoKSlcbiAgICAgICAgOiBudWxsO1xuICAgIHRoaXMuX2xpbWl0ID0gbGltaXQ7XG4gICAgdGhpcy5faW5GbGlnaHQgPSAwO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgYXN5bmMuaW52b2tlKHRoaXMuX2FzeW5jSW5pdCwgdGhpcywgdW5kZWZpbmVkKTtcbn1cbnV0aWwuaW5oZXJpdHMoTWFwcGluZ1Byb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2FzeW5jSW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTIpO1xufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICB2YXIgcHJlc2VydmVkVmFsdWVzID0gdGhpcy5fcHJlc2VydmVkVmFsdWVzO1xuICAgIHZhciBsaW1pdCA9IHRoaXMuX2xpbWl0O1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IChpbmRleCAqIC0xKSAtIDE7XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKGxpbWl0ID49IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2luRmxpZ2h0LS07XG4gICAgICAgICAgICB0aGlzLl9kcmFpblF1ZXVlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsaW1pdCA+PSAxICYmIHRoaXMuX2luRmxpZ2h0ID49IGxpbWl0KSB7XG4gICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlc2VydmVkVmFsdWVzICE9PSBudWxsKSBwcmVzZXJ2ZWRWYWx1ZXNbaW5kZXhdID0gdmFsdWU7XG5cbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjaztcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gcHJvbWlzZS5fYm91bmRWYWx1ZSgpO1xuICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICB2YXIgcmV0ID0gdHJ5Q2F0Y2goY2FsbGJhY2spLmNhbGwocmVjZWl2ZXIsIHZhbHVlLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgICAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBwcm9taXNlQ3JlYXRlZCxcbiAgICAgICAgICAgIHByZXNlcnZlZFZhbHVlcyAhPT0gbnVsbCA/IFwiUHJvbWlzZS5maWx0ZXJcIiA6IFwiUHJvbWlzZS5tYXBcIixcbiAgICAgICAgICAgIHByb21pc2VcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChyZXQuZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJldCwgdGhpcy5fcHJvbWlzZSk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgdmFyIGJpdEZpZWxkID0gbWF5YmVQcm9taXNlLl9iaXRGaWVsZDtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGlmIChsaW1pdCA+PSAxKSB0aGlzLl9pbkZsaWdodCsrO1xuICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSBtYXliZVByb21pc2U7XG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eSh0aGlzLCAoaW5kZXggKyAxKSAqIC0xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbWF5YmVQcm9taXNlLl92YWx1ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IHJldDtcbiAgICB9XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gbGVuZ3RoKSB7XG4gICAgICAgIGlmIChwcmVzZXJ2ZWRWYWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlcih2YWx1ZXMsIHByZXNlcnZlZFZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9kcmFpblF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBsaW1pdCA9IHRoaXMuX2xpbWl0O1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDAgJiYgdGhpcy5faW5GbGlnaHQgPCBsaW1pdCkge1xuICAgICAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgICAgIHZhciBpbmRleCA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKHZhbHVlc1tpbmRleF0sIGluZGV4KTtcbiAgICB9XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZmlsdGVyID0gZnVuY3Rpb24gKGJvb2xlYW5zLCB2YWx1ZXMpIHtcbiAgICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGxlbik7XG4gICAgdmFyIGogPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGJvb2xlYW5zW2ldKSByZXRbaisrXSA9IHZhbHVlc1tpXTtcbiAgICB9XG4gICAgcmV0Lmxlbmd0aCA9IGo7XG4gICAgdGhpcy5fcmVzb2x2ZShyZXQpO1xufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUucHJlc2VydmVkVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXM7XG59O1xuXG5mdW5jdGlvbiBtYXAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBfZmlsdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cblxuICAgIHZhciBsaW1pdCA9IDA7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbmN1cnJlbmN5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgICAgICAgICBuZXcgVHlwZUVycm9yKFwiJ2NvbmN1cnJlbmN5JyBtdXN0IGJlIGEgbnVtYmVyIGJ1dCBpdCBpcyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKG9wdGlvbnMuY29uY3VycmVuY3kpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW1pdCA9IG9wdGlvbnMuY29uY3VycmVuY3k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QgYnV0IGl0IGlzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyhvcHRpb25zKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbWl0ID0gdHlwZW9mIGxpbWl0ID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIGlzRmluaXRlKGxpbWl0KSAmJiBsaW1pdCA+PSAxID8gbGltaXQgOiAwO1xuICAgIHJldHVybiBuZXcgTWFwcGluZ1Byb21pc2VBcnJheShwcm9taXNlcywgZm4sIGxpbWl0LCBfZmlsdGVyKS5wcm9taXNlKCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBtYXAodGhpcywgZm4sIG9wdGlvbnMsIG51bGwpO1xufTtcblxuUHJvbWlzZS5tYXAgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBfZmlsdGVyKSB7XG4gICAgcmV0dXJuIG1hcChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpO1xufTtcblxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY3IgPSBPYmplY3QuY3JlYXRlO1xuaWYgKGNyKSB7XG4gICAgdmFyIGNhbGxlckNhY2hlID0gY3IobnVsbCk7XG4gICAgdmFyIGdldHRlckNhY2hlID0gY3IobnVsbCk7XG4gICAgY2FsbGVyQ2FjaGVbXCIgc2l6ZVwiXSA9IGdldHRlckNhY2hlW1wiIHNpemVcIl0gPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHV0aWwuY2FuRXZhbHVhdGU7XG52YXIgaXNJZGVudGlmaWVyID0gdXRpbC5pc0lkZW50aWZpZXI7XG5cbnZhciBnZXRNZXRob2RDYWxsZXI7XG52YXIgZ2V0R2V0dGVyO1xuaWYgKCFmYWxzZSkge1xudmFyIG1ha2VNZXRob2RDYWxsZXIgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJlbnN1cmVNZXRob2RcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZW5zdXJlTWV0aG9kKG9iaiwgJ21ldGhvZE5hbWUnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgc3dpdGNoKGxlbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0pOyAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0sIHRoaXNbMV0pOyAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0sIHRoaXNbMV0sIHRoaXNbMl0pOyAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG9iai5tZXRob2ROYW1lKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLm1ldGhvZE5hbWUuYXBwbHkob2JqLCB0aGlzKTsgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKC9tZXRob2ROYW1lL2csIG1ldGhvZE5hbWUpKShlbnN1cmVNZXRob2QpO1xufTtcblxudmFyIG1ha2VHZXR0ZXIgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcIm9ialwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiBvYmoucHJvcGVydHlOYW1lOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoXCJwcm9wZXJ0eU5hbWVcIiwgcHJvcGVydHlOYW1lKSk7XG59O1xuXG52YXIgZ2V0Q29tcGlsZWQgPSBmdW5jdGlvbihuYW1lLCBjb21waWxlciwgY2FjaGUpIHtcbiAgICB2YXIgcmV0ID0gY2FjaGVbbmFtZV07XG4gICAgaWYgKHR5cGVvZiByZXQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIWlzSWRlbnRpZmllcihuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gY29tcGlsZXIobmFtZSk7XG4gICAgICAgIGNhY2hlW25hbWVdID0gcmV0O1xuICAgICAgICBjYWNoZVtcIiBzaXplXCJdKys7XG4gICAgICAgIGlmIChjYWNoZVtcIiBzaXplXCJdID4gNTEyKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNhY2hlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIGRlbGV0ZSBjYWNoZVtrZXlzW2ldXTtcbiAgICAgICAgICAgIGNhY2hlW1wiIHNpemVcIl0gPSBrZXlzLmxlbmd0aCAtIDI1NjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuZ2V0TWV0aG9kQ2FsbGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBnZXRDb21waWxlZChuYW1lLCBtYWtlTWV0aG9kQ2FsbGVyLCBjYWxsZXJDYWNoZSk7XG59O1xuXG5nZXRHZXR0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGdldENvbXBpbGVkKG5hbWUsIG1ha2VHZXR0ZXIsIGdldHRlckNhY2hlKTtcbn07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZU1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgZm47XG4gICAgaWYgKG9iaiAhPSBudWxsKSBmbiA9IG9ialttZXRob2ROYW1lXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIk9iamVjdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcob2JqKSArIFwiIGhhcyBubyBtZXRob2QgJ1wiICtcbiAgICAgICAgICAgIHV0aWwudG9TdHJpbmcobWV0aG9kTmFtZSkgKyBcIidcIjtcbiAgICAgICAgdGhyb3cgbmV3IFByb21pc2UuVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gZm47XG59XG5cbmZ1bmN0aW9uIGNhbGxlcihvYmopIHtcbiAgICB2YXIgbWV0aG9kTmFtZSA9IHRoaXMucG9wKCk7XG4gICAgdmFyIGZuID0gZW5zdXJlTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgdGhpcyk7XG59XG5Qcm9taXNlLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgJF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBhcmdzID0gbmV3IEFycmF5KE1hdGgubWF4KCRfbGVuIC0gMSwgMCkpOyBmb3IodmFyICRfaSA9IDE7ICRfaSA8ICRfbGVuOyArKyRfaSkge2FyZ3NbJF9pIC0gMV0gPSBhcmd1bWVudHNbJF9pXTt9O1xuICAgIGlmICghZmFsc2UpIHtcbiAgICAgICAgaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgICAgICAgICB2YXIgbWF5YmVDYWxsZXIgPSBnZXRNZXRob2RDYWxsZXIobWV0aG9kTmFtZSk7XG4gICAgICAgICAgICBpZiAobWF5YmVDYWxsZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVDYWxsZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmdzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFyZ3MucHVzaChtZXRob2ROYW1lKTtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihjYWxsZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmdzLCB1bmRlZmluZWQpO1xufTtcblxuZnVuY3Rpb24gbmFtZWRHZXR0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9ialt0aGlzXTtcbn1cbmZ1bmN0aW9uIGluZGV4ZWRHZXR0ZXIob2JqKSB7XG4gICAgdmFyIGluZGV4ID0gK3RoaXM7XG4gICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBNYXRoLm1heCgwLCBpbmRleCArIG9iai5sZW5ndGgpO1xuICAgIHJldHVybiBvYmpbaW5kZXhdO1xufVxuUHJvbWlzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgIHZhciBpc0luZGV4ID0gKHR5cGVvZiBwcm9wZXJ0eU5hbWUgPT09IFwibnVtYmVyXCIpO1xuICAgIHZhciBnZXR0ZXI7XG4gICAgaWYgKCFpc0luZGV4KSB7XG4gICAgICAgIGlmIChjYW5FdmFsdWF0ZSkge1xuICAgICAgICAgICAgdmFyIG1heWJlR2V0dGVyID0gZ2V0R2V0dGVyKHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICBnZXR0ZXIgPSBtYXliZUdldHRlciAhPT0gbnVsbCA/IG1heWJlR2V0dGVyIDogbmFtZWRHZXR0ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXR0ZXIgPSBuYW1lZEdldHRlcjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldHRlciA9IGluZGV4ZWRHZXR0ZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90aGVuKGdldHRlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb3BlcnR5TmFtZSwgdW5kZWZpbmVkKTtcbn07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvY2FsbF9nZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFByb21pc2UsIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICBjcmVhdGVDb250ZXh0LCBJTlRFUk5BTCwgZGVidWcpIHtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG4gICAgdmFyIFR5cGVFcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKS5UeXBlRXJyb3I7XG4gICAgdmFyIGluaGVyaXRzID0gcmVxdWlyZShcIi4vdXRpbFwiKS5pbmhlcml0cztcbiAgICB2YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xuICAgIHZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG4gICAgdmFyIE5VTEwgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHRocm93ZXIoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZTt9LCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYXN0UHJlc2VydmluZ0Rpc3Bvc2FibGUodGhlbmFibGUpIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodGhlbmFibGUpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlICE9PSB0aGVuYWJsZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLl9pc0Rpc3Bvc2FibGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLl9nZXREaXNwb3NlciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0aGVuYWJsZS5faXNEaXNwb3NhYmxlKCkpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fc2V0RGlzcG9zYWJsZSh0aGVuYWJsZS5fZ2V0RGlzcG9zZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcG9zZShyZXNvdXJjZXMsIGluc3BlY3Rpb24pIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gcmVzb3VyY2VzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBsZW4pIHJldHVybiByZXQuX2Z1bGZpbGwoKTtcbiAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSBjYXN0UHJlc2VydmluZ0Rpc3Bvc2FibGUocmVzb3VyY2VzW2krK10pO1xuICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UgJiZcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX2lzRGlzcG9zYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fZ2V0RGlzcG9zZXIoKS50cnlEaXNwb3NlKGluc3BlY3Rpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzLnByb21pc2UpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRocm93ZXIoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXliZVByb21pc2UuX3RoZW4oaXRlcmF0b3IsIHRocm93ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlcmF0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRvcigpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERpc3Bvc2VyKGRhdGEsIHByb21pc2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuX3Byb21pc2UgPSBwcm9taXNlO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLnJlc291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9taXNlKCkuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZSgpLnZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5VTEw7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS50cnlEaXNwb3NlID0gZnVuY3Rpb24oaW5zcGVjdGlvbikge1xuICAgICAgICB2YXIgcmVzb3VyY2UgPSB0aGlzLnJlc291cmNlKCk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkgY29udGV4dC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHJldCA9IHJlc291cmNlICE9PSBOVUxMXG4gICAgICAgICAgICA/IHRoaXMuZG9EaXNwb3NlKHJlc291cmNlLCBpbnNwZWN0aW9uKSA6IG51bGw7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIGNvbnRleHQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fdW5zZXREaXNwb3NhYmxlKCk7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5pc0Rpc3Bvc2VyID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIChkICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZC5yZXNvdXJjZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGQudHJ5RGlzcG9zZSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRnVuY3Rpb25EaXNwb3NlcihmbiwgcHJvbWlzZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yJChmbiwgcHJvbWlzZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGluaGVyaXRzKEZ1bmN0aW9uRGlzcG9zZXIsIERpc3Bvc2VyKTtcblxuICAgIEZ1bmN0aW9uRGlzcG9zZXIucHJvdG90eXBlLmRvRGlzcG9zZSA9IGZ1bmN0aW9uIChyZXNvdXJjZSwgaW5zcGVjdGlvbikge1xuICAgICAgICB2YXIgZm4gPSB0aGlzLmRhdGEoKTtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwocmVzb3VyY2UsIHJlc291cmNlLCBpbnNwZWN0aW9uKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWF5YmVVbndyYXBEaXNwb3Nlcih2YWx1ZSkge1xuICAgICAgICBpZiAoRGlzcG9zZXIuaXNEaXNwb3Nlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzW3RoaXMuaW5kZXhdLl9zZXREaXNwb3NhYmxlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5wcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFJlc291cmNlTGlzdChsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXNbbGVuZ3RoLTFdID0gbnVsbDtcbiAgICB9XG5cbiAgICBSZXNvdXJjZUxpc3QucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFByb21pc2UudXNpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuIDwgMikgcmV0dXJuIGFwaVJlamVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieW91IG11c3QgcGFzcyBhdCBsZWFzdCAyIGFyZ3VtZW50cyB0byBQcm9taXNlLnVzaW5nXCIpO1xuICAgICAgICB2YXIgZm4gPSBhcmd1bWVudHNbbGVuIC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0O1xuICAgICAgICB2YXIgc3ByZWFkQXJncyA9IHRydWU7XG4gICAgICAgIGlmIChsZW4gPT09IDIgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIHNwcmVhZEFyZ3MgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0ID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgbGVuLS07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc291cmNlcyA9IG5ldyBSZXNvdXJjZUxpc3QobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFyIHJlc291cmNlID0gaW5wdXRbaV07XG4gICAgICAgICAgICBpZiAoRGlzcG9zZXIuaXNEaXNwb3NlcihyZXNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzcG9zZXIgPSByZXNvdXJjZTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZSA9IHJlc291cmNlLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZS5fc2V0RGlzcG9zYWJsZShkaXNwb3Nlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3RoZW4obWF5YmVVbndyYXBEaXNwb3NlciwgbnVsbCwgbnVsbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlczogcmVzb3VyY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgICAgICAgIH0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb3VyY2VzW2ldID0gcmVzb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVmbGVjdGVkUmVzb3VyY2VzID0gbmV3IEFycmF5KHJlc291cmNlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZmxlY3RlZFJlc291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVmbGVjdGVkUmVzb3VyY2VzW2ldID0gUHJvbWlzZS5yZXNvbHZlKHJlc291cmNlc1tpXSkucmVmbGVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdFByb21pc2UgPSBQcm9taXNlLmFsbChyZWZsZWN0ZWRSZXNvdXJjZXMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihpbnNwZWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zcGVjdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3BlY3Rpb24gPSBpbnNwZWN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3BlY3Rpb24uaXNSZWplY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck9iai5lID0gaW5zcGVjdGlvbi5lcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpbnNwZWN0aW9uLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5zcGVjdGlvbnNbaV0gPSBpbnNwZWN0aW9uLnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7XG5cbiAgICAgICAgICAgICAgICBmbiA9IHRyeUNhdGNoKGZuKTtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gc3ByZWFkQXJnc1xuICAgICAgICAgICAgICAgICAgICA/IGZuLmFwcGx5KHVuZGVmaW5lZCwgaW5zcGVjdGlvbnMpIDogZm4oaW5zcGVjdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHByb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoXG4gICAgICAgICAgICAgICAgICAgIHJldCwgcHJvbWlzZUNyZWF0ZWQsIFwiUHJvbWlzZS51c2luZ1wiLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHByb21pc2UgPSByZXN1bHRQcm9taXNlLmxhc3RseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnNwZWN0aW9uID0gbmV3IFByb21pc2UuUHJvbWlzZUluc3BlY3Rpb24ocmVzdWx0UHJvbWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gZGlzcG9zZShyZXNvdXJjZXMsIGluc3BlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzb3VyY2VzLnByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICBwcm9taXNlLl9zZXRPbkNhbmNlbChyZXNvdXJjZXMpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoZGlzcG9zZXIpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDEzMTA3MjtcbiAgICAgICAgdGhpcy5fZGlzcG9zZXIgPSBkaXNwb3NlcjtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX2lzRGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDEzMTA3MikgPiAwO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5fZ2V0RGlzcG9zZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlcjtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MTMxMDcyKTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLmRpc3Bvc2VyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkRpc3Bvc2VyKGZuLCB0aGlzLCBjcmVhdGVDb250ZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9O1xuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvdXNpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgVGltZW91dEVycm9yID0gUHJvbWlzZS5UaW1lb3V0RXJyb3I7XG5cbmZ1bmN0aW9uIEhhbmRsZVdyYXBwZXIoaGFuZGxlKSAge1xuICAgIHRoaXMuaGFuZGxlID0gaGFuZGxlO1xufVxuXG5IYW5kbGVXcmFwcGVyLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbn07XG5cbnZhciBhZnRlclZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIGRlbGF5KCt0aGlzKS50aGVuUmV0dXJuKHZhbHVlKTsgfTtcbnZhciBkZWxheSA9IFByb21pc2UuZGVsYXkgPSBmdW5jdGlvbiAobXMsIHZhbHVlKSB7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgaGFuZGxlO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldCA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAuX3RoZW4oYWZ0ZXJWYWx1ZSwgbnVsbCwgbnVsbCwgbXMsIHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldC5fc2V0T25DYW5jZWwodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICBoYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyByZXQuX2Z1bGZpbGwoKTsgfSwgK21zKTtcbiAgICAgICAgaWYgKGRlYnVnLmNhbmNlbGxhdGlvbigpKSB7XG4gICAgICAgICAgICByZXQuX3NldE9uQ2FuY2VsKG5ldyBIYW5kbGVXcmFwcGVyKGhhbmRsZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB9XG4gICAgcmV0Ll9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAobXMpIHtcbiAgICByZXR1cm4gZGVsYXkobXMsIHRoaXMpO1xufTtcblxudmFyIGFmdGVyVGltZW91dCA9IGZ1bmN0aW9uIChwcm9taXNlLCBtZXNzYWdlLCBwYXJlbnQpIHtcbiAgICB2YXIgZXJyO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBlcnIgPSBtZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyID0gbmV3IFRpbWVvdXRFcnJvcihcIm9wZXJhdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBlcnIgPSBuZXcgVGltZW91dEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB1dGlsLm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihlcnIpO1xuICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICBwcm9taXNlLl9yZWplY3QoZXJyKTtcblxuICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQuY2FuY2VsKCk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gc3VjY2Vzc0NsZWFyKHZhbHVlKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGZhaWx1cmVDbGVhcihyZWFzb24pIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgIHRocm93IHJlYXNvbjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcywgbWVzc2FnZSkge1xuICAgIG1zID0gK21zO1xuICAgIHZhciByZXQsIHBhcmVudDtcblxuICAgIHZhciBoYW5kbGVXcmFwcGVyID0gbmV3IEhhbmRsZVdyYXBwZXIoc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0VGltZW91dCgpIHtcbiAgICAgICAgaWYgKHJldC5pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgYWZ0ZXJUaW1lb3V0KHJldCwgbWVzc2FnZSwgcGFyZW50KTtcbiAgICAgICAgfVxuICAgIH0sIG1zKSk7XG5cbiAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkpIHtcbiAgICAgICAgcGFyZW50ID0gdGhpcy50aGVuKCk7XG4gICAgICAgIHJldCA9IHBhcmVudC5fdGhlbihzdWNjZXNzQ2xlYXIsIGZhaWx1cmVDbGVhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIGhhbmRsZVdyYXBwZXIsIHVuZGVmaW5lZCk7XG4gICAgICAgIHJldC5fc2V0T25DYW5jZWwoaGFuZGxlV3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gdGhpcy5fdGhlbihzdWNjZXNzQ2xlYXIsIGZhaWx1cmVDbGVhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIGhhbmRsZVdyYXBwZXIsIHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS90aW1lcnMuanNcbi8vIG1vZHVsZSBpZCA9IDE0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVqZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJveHlhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Zykge1xudmFyIGVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciBUeXBlRXJyb3IgPSBlcnJvcnMuVHlwZUVycm9yO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgeWllbGRIYW5kbGVycyA9IFtdO1xuXG5mdW5jdGlvbiBwcm9taXNlRnJvbVlpZWxkSGFuZGxlcih2YWx1ZSwgeWllbGRIYW5kbGVycywgdHJhY2VQYXJlbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHlpZWxkSGFuZGxlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdHJhY2VQYXJlbnQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh5aWVsZEhhbmRsZXJzW2ldKSh2YWx1ZSk7XG4gICAgICAgIHRyYWNlUGFyZW50Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICB0cmFjZVBhcmVudC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciByZXQgPSBQcm9taXNlLnJlamVjdChlcnJvck9iai5lKTtcbiAgICAgICAgICAgIHRyYWNlUGFyZW50Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJlc3VsdCwgdHJhY2VQYXJlbnQpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIG1heWJlUHJvbWlzZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb21pc2VTcGF3bihnZW5lcmF0b3JGdW5jdGlvbiwgcmVjZWl2ZXIsIHlpZWxkSGFuZGxlciwgc3RhY2spIHtcbiAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkpIHtcbiAgICAgICAgdmFyIGludGVybmFsID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICB2YXIgX2ZpbmFsbHlQcm9taXNlID0gdGhpcy5fZmluYWxseVByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2UgPSBpbnRlcm5hbC5sYXN0bHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZpbmFsbHlQcm9taXNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaW50ZXJuYWwuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIGludGVybmFsLl9zZXRPbkNhbmNlbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgfVxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gICAgdGhpcy5fZ2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3JGdW5jdGlvbjtcbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgIHRoaXMuX2dlbmVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl95aWVsZEhhbmRsZXJzID0gdHlwZW9mIHlpZWxkSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gW3lpZWxkSGFuZGxlcl0uY29uY2F0KHlpZWxkSGFuZGxlcnMpXG4gICAgICAgIDogeWllbGRIYW5kbGVycztcbiAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fY2FuY2VsbGF0aW9uUGhhc2UgPSBmYWxzZTtcbn1cbnV0aWwuaW5oZXJpdHMoUHJvbWlzZVNwYXduLCBQcm94eWFibGUpO1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9pc1Jlc29sdmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2UgPT09IG51bGw7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcHJvbWlzZSA9IHRoaXMuX2dlbmVyYXRvciA9IG51bGw7XG4gICAgaWYgKGRlYnVnLmNhbmNlbGxhdGlvbigpICYmIHRoaXMuX2ZpbmFsbHlQcm9taXNlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2ZpbmFsbHlQcm9taXNlLl9mdWxmaWxsKCk7XG4gICAgICAgIHRoaXMuX2ZpbmFsbHlQcm9taXNlID0gbnVsbDtcbiAgICB9XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9wcm9taXNlQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSkgcmV0dXJuO1xuICAgIHZhciBpbXBsZW1lbnRzUmV0dXJuID0gdHlwZW9mIHRoaXMuX2dlbmVyYXRvcltcInJldHVyblwiXSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKCFpbXBsZW1lbnRzUmV0dXJuKSB7XG4gICAgICAgIHZhciByZWFzb24gPSBuZXcgUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvcihcbiAgICAgICAgICAgIFwiZ2VuZXJhdG9yIC5yZXR1cm4oKSBzZW50aW5lbFwiKTtcbiAgICAgICAgUHJvbWlzZS5jb3JvdXRpbmUucmV0dXJuU2VudGluZWwgPSByZWFzb247XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UocmVhc29uKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yW1widGhyb3dcIl0pLmNhbGwodGhpcy5fZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2dlbmVyYXRvcltcInJldHVyblwiXSkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIH1cbiAgICB0aGlzLl9jYW5jZWxsYXRpb25QaGFzZSA9IHRydWU7XG4gICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRpbnVlKHJlc3VsdCk7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yLm5leHQpLmNhbGwodGhpcy5fZ2VuZXJhdG9yLCB2YWx1ZSk7XG4gICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIHRoaXMuX2NvbnRpbnVlKHJlc3VsdCk7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2dlbmVyYXRvcltcInRocm93XCJdKVxuICAgICAgICAuY2FsbCh0aGlzLl9nZW5lcmF0b3IsIHJlYXNvbik7XG4gICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIHRoaXMuX2NvbnRpbnVlKHJlc3VsdCk7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5feWllbGRlZFByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5feWllbGRlZFByb21pc2U7XG4gICAgICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgcHJvbWlzZS5jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLnByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZ2VuZXJhdG9yID0gdGhpcy5fZ2VuZXJhdG9yRnVuY3Rpb24uY2FsbCh0aGlzLl9yZWNlaXZlcik7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPVxuICAgICAgICB0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9jb250aW51ZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2U7XG4gICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICBpZiAodGhpcy5fY2FuY2VsbGF0aW9uUGhhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmNhbmNlbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlc3VsdC5lLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgaWYgKHJlc3VsdC5kb25lID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgaWYgKHRoaXMuX2NhbmNlbGxhdGlvblBoYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodmFsdWUsIHRoaXMuX3Byb21pc2UpO1xuICAgICAgICBpZiAoIShtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlID1cbiAgICAgICAgICAgICAgICBwcm9taXNlRnJvbVlpZWxkSGFuZGxlcihtYXliZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5feWllbGRIYW5kbGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlUmVqZWN0ZWQoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkEgdmFsdWUgJXMgd2FzIHlpZWxkZWQgdGhhdCBjb3VsZCBub3QgYmUgdHJlYXRlZCBhcyBhIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXFx1MDAwYVwiLnJlcGxhY2UoXCIlc1wiLCBTdHJpbmcodmFsdWUpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkZyb20gY29yb3V0aW5lOlxcdTAwMGFcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgxLCAtNykuam9pbihcIlxcblwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWF5YmVQcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcbiAgICAgICAgdmFyIGJpdEZpZWxkID0gbWF5YmVQcm9taXNlLl9iaXRGaWVsZDtcbiAgICAgICAgO1xuICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbWF5YmVQcm9taXNlO1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eSh0aGlzLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgUHJvbWlzZS5fYXN5bmMuaW52b2tlKFxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2VGdWxmaWxsZWQsIHRoaXMsIG1heWJlUHJvbWlzZS5fdmFsdWUoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgUHJvbWlzZS5fYXN5bmMuaW52b2tlKFxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2VSZWplY3RlZCwgdGhpcywgbWF5YmVQcm9taXNlLl9yZWFzb24oKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb21pc2VDYW5jZWxsZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2UuY29yb3V0aW5lID0gZnVuY3Rpb24gKGdlbmVyYXRvckZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBnZW5lcmF0b3JGdW5jdGlvbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJnZW5lcmF0b3JGdW5jdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICB2YXIgeWllbGRIYW5kbGVyID0gT2JqZWN0KG9wdGlvbnMpLnlpZWxkSGFuZGxlcjtcbiAgICB2YXIgUHJvbWlzZVNwYXduJCA9IFByb21pc2VTcGF3bjtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ2VuZXJhdG9yID0gZ2VuZXJhdG9yRnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHNwYXduID0gbmV3IFByb21pc2VTcGF3biQodW5kZWZpbmVkLCB1bmRlZmluZWQsIHlpZWxkSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2spO1xuICAgICAgICB2YXIgcmV0ID0gc3Bhd24ucHJvbWlzZSgpO1xuICAgICAgICBzcGF3bi5fZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgICAgICBzcGF3bi5fcHJvbWlzZUZ1bGZpbGxlZCh1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59O1xuXG5Qcm9taXNlLmNvcm91dGluZS5hZGRZaWVsZEhhbmRsZXIgPSBmdW5jdGlvbihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgeWllbGRIYW5kbGVycy5wdXNoKGZuKTtcbn07XG5cblByb21pc2Uuc3Bhd24gPSBmdW5jdGlvbiAoZ2VuZXJhdG9yRnVuY3Rpb24pIHtcbiAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiUHJvbWlzZS5zcGF3bigpXCIsIFwiUHJvbWlzZS5jb3JvdXRpbmUoKVwiKTtcbiAgICBpZiAodHlwZW9mIGdlbmVyYXRvckZ1bmN0aW9uICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImdlbmVyYXRvckZ1bmN0aW9uIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciBzcGF3biA9IG5ldyBQcm9taXNlU3Bhd24oZ2VuZXJhdG9yRnVuY3Rpb24sIHRoaXMpO1xuICAgIHZhciByZXQgPSBzcGF3bi5wcm9taXNlKCk7XG4gICAgc3Bhd24uX3J1bihQcm9taXNlLnNwYXduKTtcbiAgICByZXR1cm4gcmV0O1xufTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9nZW5lcmF0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBhc3luYyA9IFByb21pc2UuX2FzeW5jO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG5cbmZ1bmN0aW9uIHNwcmVhZEFkYXB0ZXIodmFsLCBub2RlYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICBpZiAoIXV0aWwuaXNBcnJheSh2YWwpKSByZXR1cm4gc3VjY2Vzc0FkYXB0ZXIuY2FsbChwcm9taXNlLCB2YWwsIG5vZGViYWNrKTtcbiAgICB2YXIgcmV0ID1cbiAgICAgICAgdHJ5Q2F0Y2gobm9kZWJhY2spLmFwcGx5KHByb21pc2UuX2JvdW5kVmFsdWUoKSwgW251bGxdLmNvbmNhdCh2YWwpKTtcbiAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKHJldC5lKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN1Y2Nlc3NBZGFwdGVyKHZhbCwgbm9kZWJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIHJlY2VpdmVyID0gcHJvbWlzZS5fYm91bmRWYWx1ZSgpO1xuICAgIHZhciByZXQgPSB2YWwgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHRyeUNhdGNoKG5vZGViYWNrKS5jYWxsKHJlY2VpdmVyLCBudWxsKVxuICAgICAgICA6IHRyeUNhdGNoKG5vZGViYWNrKS5jYWxsKHJlY2VpdmVyLCBudWxsLCB2YWwpO1xuICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIocmV0LmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVycm9yQWRhcHRlcihyZWFzb24sIG5vZGViYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IocmVhc29uICsgXCJcIik7XG4gICAgICAgIG5ld1JlYXNvbi5jYXVzZSA9IHJlYXNvbjtcbiAgICAgICAgcmVhc29uID0gbmV3UmVhc29uO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gdHJ5Q2F0Y2gobm9kZWJhY2spLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpLCByZWFzb24pO1xuICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIocmV0LmUpO1xuICAgIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYXNDYWxsYmFjayA9IFByb21pc2UucHJvdG90eXBlLm5vZGVpZnkgPSBmdW5jdGlvbiAobm9kZWJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlYmFjayA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIGFkYXB0ZXIgPSBzdWNjZXNzQWRhcHRlcjtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBPYmplY3Qob3B0aW9ucykuc3ByZWFkKSB7XG4gICAgICAgICAgICBhZGFwdGVyID0gc3ByZWFkQWRhcHRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90aGVuKFxuICAgICAgICAgICAgYWRhcHRlcixcbiAgICAgICAgICAgIGVycm9yQWRhcHRlcixcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBub2RlYmFja1xuICAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2Uvbm9kZWlmeS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFRISVMgPSB7fTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBub2RlYmFja0ZvclByb21pc2UgPSByZXF1aXJlKFwiLi9ub2RlYmFja1wiKTtcbnZhciB3aXRoQXBwZW5kZWQgPSB1dGlsLndpdGhBcHBlbmRlZDtcbnZhciBtYXliZVdyYXBBc0Vycm9yID0gdXRpbC5tYXliZVdyYXBBc0Vycm9yO1xudmFyIGNhbkV2YWx1YXRlID0gdXRpbC5jYW5FdmFsdWF0ZTtcbnZhciBUeXBlRXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvcnNcIikuVHlwZUVycm9yO1xudmFyIGRlZmF1bHRTdWZmaXggPSBcIkFzeW5jXCI7XG52YXIgZGVmYXVsdFByb21pc2lmaWVkID0ge19faXNQcm9taXNpZmllZF9fOiB0cnVlfTtcbnZhciBub0NvcHlQcm9wcyA9IFtcbiAgICBcImFyaXR5XCIsICAgIFwibGVuZ3RoXCIsXG4gICAgXCJuYW1lXCIsXG4gICAgXCJhcmd1bWVudHNcIixcbiAgICBcImNhbGxlclwiLFxuICAgIFwiY2FsbGVlXCIsXG4gICAgXCJwcm90b3R5cGVcIixcbiAgICBcIl9faXNQcm9taXNpZmllZF9fXCJcbl07XG52YXIgbm9Db3B5UHJvcHNQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIG5vQ29weVByb3BzLmpvaW4oXCJ8XCIpICsgXCIpJFwiKTtcblxudmFyIGRlZmF1bHRGaWx0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHV0aWwuaXNJZGVudGlmaWVyKG5hbWUpICYmXG4gICAgICAgIG5hbWUuY2hhckF0KDApICE9PSBcIl9cIiAmJlxuICAgICAgICBuYW1lICE9PSBcImNvbnN0cnVjdG9yXCI7XG59O1xuXG5mdW5jdGlvbiBwcm9wc0ZpbHRlcihrZXkpIHtcbiAgICByZXR1cm4gIW5vQ29weVByb3BzUGF0dGVybi50ZXN0KGtleSk7XG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzaWZpZWQoZm4pIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4uX19pc1Byb21pc2lmaWVkX18gPT09IHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhc1Byb21pc2lmaWVkKG9iaiwga2V5LCBzdWZmaXgpIHtcbiAgICB2YXIgdmFsID0gdXRpbC5nZXREYXRhUHJvcGVydHlPckRlZmF1bHQob2JqLCBrZXkgKyBzdWZmaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQcm9taXNpZmllZCk7XG4gICAgcmV0dXJuIHZhbCA/IGlzUHJvbWlzaWZpZWQodmFsKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gY2hlY2tWYWxpZChyZXQsIHN1ZmZpeCwgc3VmZml4UmVnZXhwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGtleSA9IHJldFtpXTtcbiAgICAgICAgaWYgKHN1ZmZpeFJlZ2V4cC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgIHZhciBrZXlXaXRob3V0QXN5bmNTdWZmaXggPSBrZXkucmVwbGFjZShzdWZmaXhSZWdleHAsIFwiXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXQubGVuZ3RoOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0W2pdID09PSBrZXlXaXRob3V0QXN5bmNTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBwcm9taXNpZnkgYW4gQVBJIHRoYXQgaGFzIG5vcm1hbCBtZXRob2RzIHdpdGggJyVzJy1zdWZmaXhcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiJXNcIiwgc3VmZml4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwcm9taXNpZmlhYmxlTWV0aG9kcyhvYmosIHN1ZmZpeCwgc3VmZml4UmVnZXhwLCBmaWx0ZXIpIHtcbiAgICB2YXIga2V5cyA9IHV0aWwuaW5oZXJpdGVkRGF0YUtleXMob2JqKTtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgdmFyIHBhc3Nlc0RlZmF1bHRGaWx0ZXIgPSBmaWx0ZXIgPT09IGRlZmF1bHRGaWx0ZXJcbiAgICAgICAgICAgID8gdHJ1ZSA6IGRlZmF1bHRGaWx0ZXIoa2V5LCB2YWx1ZSwgb2JqKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAhaXNQcm9taXNpZmllZCh2YWx1ZSkgJiZcbiAgICAgICAgICAgICFoYXNQcm9taXNpZmllZChvYmosIGtleSwgc3VmZml4KSAmJlxuICAgICAgICAgICAgZmlsdGVyKGtleSwgdmFsdWUsIG9iaiwgcGFzc2VzRGVmYXVsdEZpbHRlcikpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrVmFsaWQocmV0LCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCk7XG4gICAgcmV0dXJuIHJldDtcbn1cblxudmFyIGVzY2FwZUlkZW50UmVnZXggPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbJF0pLywgXCJcXFxcJFwiKTtcbn07XG5cbnZhciBtYWtlTm9kZVByb21pc2lmaWVkRXZhbDtcbmlmICghZmFsc2UpIHtcbnZhciBzd2l0Y2hDYXNlQXJndW1lbnRPcmRlciA9IGZ1bmN0aW9uKGxpa2VseUFyZ3VtZW50Q291bnQpIHtcbiAgICB2YXIgcmV0ID0gW2xpa2VseUFyZ3VtZW50Q291bnRdO1xuICAgIHZhciBtaW4gPSBNYXRoLm1heCgwLCBsaWtlbHlBcmd1bWVudENvdW50IC0gMSAtIDMpO1xuICAgIGZvcih2YXIgaSA9IGxpa2VseUFyZ3VtZW50Q291bnQgLSAxOyBpID49IG1pbjsgLS1pKSB7XG4gICAgICAgIHJldC5wdXNoKGkpO1xuICAgIH1cbiAgICBmb3IodmFyIGkgPSBsaWtlbHlBcmd1bWVudENvdW50ICsgMTsgaSA8PSAzOyArK2kpIHtcbiAgICAgICAgcmV0LnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG52YXIgYXJndW1lbnRTZXF1ZW5jZSA9IGZ1bmN0aW9uKGFyZ3VtZW50Q291bnQpIHtcbiAgICByZXR1cm4gdXRpbC5maWxsZWRSYW5nZShhcmd1bWVudENvdW50LCBcIl9hcmdcIiwgXCJcIik7XG59O1xuXG52YXIgcGFyYW1ldGVyRGVjbGFyYXRpb24gPSBmdW5jdGlvbihwYXJhbWV0ZXJDb3VudCkge1xuICAgIHJldHVybiB1dGlsLmZpbGxlZFJhbmdlKFxuICAgICAgICBNYXRoLm1heChwYXJhbWV0ZXJDb3VudCwgMyksIFwiX2FyZ1wiLCBcIlwiKTtcbn07XG5cbnZhciBwYXJhbWV0ZXJDb3VudCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbi5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGZuLmxlbmd0aCwgMTAyMyArIDEpLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuXG5tYWtlTm9kZVByb21pc2lmaWVkRXZhbCA9XG5mdW5jdGlvbihjYWxsYmFjaywgcmVjZWl2ZXIsIG9yaWdpbmFsTmFtZSwgZm4sIF8sIG11bHRpQXJncykge1xuICAgIHZhciBuZXdQYXJhbWV0ZXJDb3VudCA9IE1hdGgubWF4KDAsIHBhcmFtZXRlckNvdW50KGZuKSAtIDEpO1xuICAgIHZhciBhcmd1bWVudE9yZGVyID0gc3dpdGNoQ2FzZUFyZ3VtZW50T3JkZXIobmV3UGFyYW1ldGVyQ291bnQpO1xuICAgIHZhciBzaG91bGRQcm94eVRoaXMgPSB0eXBlb2YgY2FsbGJhY2sgPT09IFwic3RyaW5nXCIgfHwgcmVjZWl2ZXIgPT09IFRISVM7XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNhbGxGb3JBcmd1bWVudENvdW50KGNvdW50KSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRTZXF1ZW5jZShjb3VudCkuam9pbihcIiwgXCIpO1xuICAgICAgICB2YXIgY29tbWEgPSBjb3VudCA+IDAgPyBcIiwgXCIgOiBcIlwiO1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICBpZiAoc2hvdWxkUHJveHlUaGlzKSB7XG4gICAgICAgICAgICByZXQgPSBcInJldCA9IGNhbGxiYWNrLmNhbGwodGhpcywge3thcmdzfX0sIG5vZGViYWNrKTsgYnJlYWs7XFxuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSByZWNlaXZlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBcInJldCA9IGNhbGxiYWNrKHt7YXJnc319LCBub2RlYmFjayk7IGJyZWFrO1xcblwiXG4gICAgICAgICAgICAgICAgOiBcInJldCA9IGNhbGxiYWNrLmNhbGwocmVjZWl2ZXIsIHt7YXJnc319LCBub2RlYmFjayk7IGJyZWFrO1xcblwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQucmVwbGFjZShcInt7YXJnc319XCIsIGFyZ3MpLnJlcGxhY2UoXCIsIFwiLCBjb21tYSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVBcmd1bWVudFN3aXRjaENhc2UoKSB7XG4gICAgICAgIHZhciByZXQgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50T3JkZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJldCArPSBcImNhc2UgXCIgKyBhcmd1bWVudE9yZGVyW2ldICtcIjpcIiArXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVDYWxsRm9yQXJndW1lbnRDb3VudChhcmd1bWVudE9yZGVyW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCArPSBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBkZWZhdWx0OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGkgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgYXJnc1tpXSA9IG5vZGViYWNrOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW0NvZGVGb3JDYWxsXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgYnJlYWs7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKFwiW0NvZGVGb3JDYWxsXVwiLCAoc2hvdWxkUHJveHlUaGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJyZXQgPSBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcXG5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwicmV0ID0gY2FsbGJhY2suYXBwbHkocmVjZWl2ZXIsIGFyZ3MpO1xcblwiKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgdmFyIGdldEZ1bmN0aW9uQ29kZSA9IHR5cGVvZiBjYWxsYmFjayA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChcInRoaXMgIT0gbnVsbCA/IHRoaXNbJ1wiK2NhbGxiYWNrK1wiJ10gOiBmblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiZm5cIjtcbiAgICB2YXIgYm9keSA9IFwiJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHZhciByZXQgPSBmdW5jdGlvbiAoUGFyYW1ldGVycykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgbm9kZWJhY2sgPSBub2RlYmFja0ZvclByb21pc2UocHJvbWlzZSwgXCIgKyBtdWx0aUFyZ3MgKyBcIik7ICAgXFxuXFxcbiAgICAgICAgICAgIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHRyeUNhdGNoKFtHZXRGdW5jdGlvbkNvZGVdKTsgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHN3aXRjaChsZW4pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBbQ29kZUZvclN3aXRjaENhc2VdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhtYXliZVdyYXBBc0Vycm9yKHJldC5lKSwgdHJ1ZSwgdHJ1ZSk7XFxuXFxcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGlmICghcHJvbWlzZS5faXNGYXRlU2VhbGVkKCkpIHByb21pc2UuX3NldEFzeW5jR3VhcmFudGVlZCgpOyAgICAgXFxuXFxcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AocmV0LCAnX19pc1Byb21pc2lmaWVkX18nLCB0cnVlKTsgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgcmV0dXJuIHJldDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICBcIi5yZXBsYWNlKFwiW0NvZGVGb3JTd2l0Y2hDYXNlXVwiLCBnZW5lcmF0ZUFyZ3VtZW50U3dpdGNoQ2FzZSgpKVxuICAgICAgICAucmVwbGFjZShcIltHZXRGdW5jdGlvbkNvZGVdXCIsIGdldEZ1bmN0aW9uQ29kZSk7XG4gICAgYm9keSA9IGJvZHkucmVwbGFjZShcIlBhcmFtZXRlcnNcIiwgcGFyYW1ldGVyRGVjbGFyYXRpb24obmV3UGFyYW1ldGVyQ291bnQpKTtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiUHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWNlaXZlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aXRoQXBwZW5kZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWF5YmVXcmFwQXNFcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJub2RlYmFja0ZvclByb21pc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHJ5Q2F0Y2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZXJyb3JPYmpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibm90RW51bWVyYWJsZVByb3BcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiSU5URVJOQUxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkpKFxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICBmbixcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXIsXG4gICAgICAgICAgICAgICAgICAgIHdpdGhBcHBlbmRlZCxcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVXcmFwQXNFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgbm9kZWJhY2tGb3JQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICB1dGlsLnRyeUNhdGNoLFxuICAgICAgICAgICAgICAgICAgICB1dGlsLmVycm9yT2JqLFxuICAgICAgICAgICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wLFxuICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTCk7XG59O1xufVxuXG5mdW5jdGlvbiBtYWtlTm9kZVByb21pc2lmaWVkQ2xvc3VyZShjYWxsYmFjaywgcmVjZWl2ZXIsIF8sIGZuLCBfXywgbXVsdGlBcmdzKSB7XG4gICAgdmFyIGRlZmF1bHRUaGlzID0gKGZ1bmN0aW9uKCkge3JldHVybiB0aGlzO30pKCk7XG4gICAgdmFyIG1ldGhvZCA9IGNhbGxiYWNrO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb21pc2lmaWVkKCkge1xuICAgICAgICB2YXIgX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gVEhJUykgX3JlY2VpdmVyID0gdGhpcztcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIHZhciBjYiA9IHR5cGVvZiBtZXRob2QgPT09IFwic3RyaW5nXCIgJiYgdGhpcyAhPT0gZGVmYXVsdFRoaXNcbiAgICAgICAgICAgID8gdGhpc1ttZXRob2RdIDogY2FsbGJhY2s7XG4gICAgICAgIHZhciBmbiA9IG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlLCBtdWx0aUFyZ3MpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2IuYXBwbHkoX3JlY2VpdmVyLCB3aXRoQXBwZW5kZWQoYXJndW1lbnRzLCBmbikpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKG1heWJlV3JhcEFzRXJyb3IoZSksIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvbWlzZS5faXNGYXRlU2VhbGVkKCkpIHByb21pc2UuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChwcm9taXNpZmllZCwgXCJfX2lzUHJvbWlzaWZpZWRfX1wiLCB0cnVlKTtcbiAgICByZXR1cm4gcHJvbWlzaWZpZWQ7XG59XG5cbnZhciBtYWtlTm9kZVByb21pc2lmaWVkID0gY2FuRXZhbHVhdGVcbiAgICA/IG1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsXG4gICAgOiBtYWtlTm9kZVByb21pc2lmaWVkQ2xvc3VyZTtcblxuZnVuY3Rpb24gcHJvbWlzaWZ5QWxsKG9iaiwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyLCBtdWx0aUFyZ3MpIHtcbiAgICB2YXIgc3VmZml4UmVnZXhwID0gbmV3IFJlZ0V4cChlc2NhcGVJZGVudFJlZ2V4KHN1ZmZpeCkgKyBcIiRcIik7XG4gICAgdmFyIG1ldGhvZHMgPVxuICAgICAgICBwcm9taXNpZmlhYmxlTWV0aG9kcyhvYmosIHN1ZmZpeCwgc3VmZml4UmVnZXhwLCBmaWx0ZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuOyBpKz0gMikge1xuICAgICAgICB2YXIga2V5ID0gbWV0aG9kc1tpXTtcbiAgICAgICAgdmFyIGZuID0gbWV0aG9kc1tpKzFdO1xuICAgICAgICB2YXIgcHJvbWlzaWZpZWRLZXkgPSBrZXkgKyBzdWZmaXg7XG4gICAgICAgIGlmIChwcm9taXNpZmllciA9PT0gbWFrZU5vZGVQcm9taXNpZmllZCkge1xuICAgICAgICAgICAgb2JqW3Byb21pc2lmaWVkS2V5XSA9XG4gICAgICAgICAgICAgICAgbWFrZU5vZGVQcm9taXNpZmllZChrZXksIFRISVMsIGtleSwgZm4sIHN1ZmZpeCwgbXVsdGlBcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNpZmllZCA9IHByb21pc2lmaWVyKGZuLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU5vZGVQcm9taXNpZmllZChrZXksIFRISVMsIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiwgc3VmZml4LCBtdWx0aUFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKHByb21pc2lmaWVkLCBcIl9faXNQcm9taXNpZmllZF9fXCIsIHRydWUpO1xuICAgICAgICAgICAgb2JqW3Byb21pc2lmaWVkS2V5XSA9IHByb21pc2lmaWVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHV0aWwudG9GYXN0UHJvcGVydGllcyhvYmopO1xuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHByb21pc2lmeShjYWxsYmFjaywgcmVjZWl2ZXIsIG11bHRpQXJncykge1xuICAgIHJldHVybiBtYWtlTm9kZVByb21pc2lmaWVkKGNhbGxiYWNrLCByZWNlaXZlciwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaywgbnVsbCwgbXVsdGlBcmdzKTtcbn1cblxuUHJvbWlzZS5wcm9taXNpZnkgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIGlmIChpc1Byb21pc2lmaWVkKGZuKSkge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuICAgIG9wdGlvbnMgPSBPYmplY3Qob3B0aW9ucyk7XG4gICAgdmFyIHJlY2VpdmVyID0gb3B0aW9ucy5jb250ZXh0ID09PSB1bmRlZmluZWQgPyBUSElTIDogb3B0aW9ucy5jb250ZXh0O1xuICAgIHZhciBtdWx0aUFyZ3MgPSAhIW9wdGlvbnMubXVsdGlBcmdzO1xuICAgIHZhciByZXQgPSBwcm9taXNpZnkoZm4sIHJlY2VpdmVyLCBtdWx0aUFyZ3MpO1xuICAgIHV0aWwuY29weURlc2NyaXB0b3JzKGZuLCByZXQsIHByb3BzRmlsdGVyKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm9taXNpZnlBbGwgPSBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0aGUgdGFyZ2V0IG9mIHByb21pc2lmeUFsbCBtdXN0IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IE9iamVjdChvcHRpb25zKTtcbiAgICB2YXIgbXVsdGlBcmdzID0gISFvcHRpb25zLm11bHRpQXJncztcbiAgICB2YXIgc3VmZml4ID0gb3B0aW9ucy5zdWZmaXg7XG4gICAgaWYgKHR5cGVvZiBzdWZmaXggIT09IFwic3RyaW5nXCIpIHN1ZmZpeCA9IGRlZmF1bHRTdWZmaXg7XG4gICAgdmFyIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgIGlmICh0eXBlb2YgZmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgdmFyIHByb21pc2lmaWVyID0gb3B0aW9ucy5wcm9taXNpZmllcjtcbiAgICBpZiAodHlwZW9mIHByb21pc2lmaWVyICE9PSBcImZ1bmN0aW9uXCIpIHByb21pc2lmaWVyID0gbWFrZU5vZGVQcm9taXNpZmllZDtcblxuICAgIGlmICghdXRpbC5pc0lkZW50aWZpZXIoc3VmZml4KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInN1ZmZpeCBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSB1dGlsLmluaGVyaXRlZERhdGFLZXlzKHRhcmdldCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRhcmdldFtrZXlzW2ldXTtcbiAgICAgICAgaWYgKGtleXNbaV0gIT09IFwiY29uc3RydWN0b3JcIiAmJlxuICAgICAgICAgICAgdXRpbC5pc0NsYXNzKHZhbHVlKSkge1xuICAgICAgICAgICAgcHJvbWlzaWZ5QWxsKHZhbHVlLnByb3RvdHlwZSwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyLFxuICAgICAgICAgICAgICAgIG11bHRpQXJncyk7XG4gICAgICAgICAgICBwcm9taXNpZnlBbGwodmFsdWUsIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllciwgbXVsdGlBcmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNpZnlBbGwodGFyZ2V0LCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIsIG11bHRpQXJncyk7XG59O1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvcHJvbWlzaWZ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFxuICAgIFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgaXNPYmplY3QgPSB1dGlsLmlzT2JqZWN0O1xudmFyIGVzNSA9IHJlcXVpcmUoXCIuL2VzNVwiKTtcbnZhciBFczZNYXA7XG5pZiAodHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiKSBFczZNYXAgPSBNYXA7XG5cbnZhciBtYXBUb0VudHJpZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc2l6ZSA9IDA7XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RW50cnkodmFsdWUsIGtleSkge1xuICAgICAgICB0aGlzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB0aGlzW2luZGV4ICsgc2l6ZV0gPSBrZXk7XG4gICAgICAgIGluZGV4Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hcFRvRW50cmllcyhtYXApIHtcbiAgICAgICAgc2l6ZSA9IG1hcC5zaXplO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIHZhciByZXQgPSBuZXcgQXJyYXkobWFwLnNpemUgKiAyKTtcbiAgICAgICAgbWFwLmZvckVhY2goZXh0cmFjdEVudHJ5LCByZXQpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59KSgpO1xuXG52YXIgZW50cmllc1RvTWFwID0gZnVuY3Rpb24oZW50cmllcykge1xuICAgIHZhciByZXQgPSBuZXcgRXM2TWFwKCk7XG4gICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoIC8gMiB8IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gZW50cmllc1tsZW5ndGggKyBpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gZW50cmllc1tpXTtcbiAgICAgICAgcmV0LnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIFByb3BlcnRpZXNQcm9taXNlQXJyYXkob2JqKSB7XG4gICAgdmFyIGlzTWFwID0gZmFsc2U7XG4gICAgdmFyIGVudHJpZXM7XG4gICAgaWYgKEVzNk1hcCAhPT0gdW5kZWZpbmVkICYmIG9iaiBpbnN0YW5jZW9mIEVzNk1hcCkge1xuICAgICAgICBlbnRyaWVzID0gbWFwVG9FbnRyaWVzKG9iaik7XG4gICAgICAgIGlzTWFwID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IGVzNS5rZXlzKG9iaik7XG4gICAgICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZW50cmllcyA9IG5ldyBBcnJheShsZW4gKiAyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBlbnRyaWVzW2ldID0gb2JqW2tleV07XG4gICAgICAgICAgICBlbnRyaWVzW2kgKyBsZW5dID0ga2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29uc3RydWN0b3IkKGVudHJpZXMpO1xuICAgIHRoaXMuX2lzTWFwID0gaXNNYXA7XG4gICAgdGhpcy5faW5pdCQodW5kZWZpbmVkLCBpc01hcCA/IC02IDogLTMpO1xufVxudXRpbC5pbmhlcml0cyhQcm9wZXJ0aWVzUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWw7XG4gICAgICAgIGlmICh0aGlzLl9pc01hcCkge1xuICAgICAgICAgICAgdmFsID0gZW50cmllc1RvTWFwKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSB7fTtcbiAgICAgICAgICAgIHZhciBrZXlPZmZzZXQgPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoKCk7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhbFt0aGlzLl92YWx1ZXNbaSArIGtleU9mZnNldF1dID0gdGhpcy5fdmFsdWVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc29sdmUodmFsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuZ2V0QWN0dWFsTGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xuICAgIHJldHVybiBsZW4gPj4gMTtcbn07XG5cbmZ1bmN0aW9uIHByb3BzKHByb21pc2VzKSB7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgY2FzdFZhbHVlID0gdHJ5Q29udmVydFRvUHJvbWlzZShwcm9taXNlcyk7XG5cbiAgICBpZiAoIWlzT2JqZWN0KGNhc3RWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImNhbm5vdCBhd2FpdCBwcm9wZXJ0aWVzIG9mIGEgbm9uLW9iamVjdFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfSBlbHNlIGlmIChjYXN0VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldCA9IGNhc3RWYWx1ZS5fdGhlbihcbiAgICAgICAgICAgIFByb21pc2UucHJvcHMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb3BlcnRpZXNQcm9taXNlQXJyYXkoY2FzdFZhbHVlKS5wcm9taXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKGNhc3RWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0Ll9wcm9wYWdhdGVGcm9tKGNhc3RWYWx1ZSwgMik7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cblByb21pc2UucHJvdG90eXBlLnByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9wcyh0aGlzKTtcbn07XG5cblByb21pc2UucHJvcHMgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gcHJvcHMocHJvbWlzZXMpO1xufTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9wcy5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihcbiAgICBQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciByYWNlTGF0ZXIgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHJhY2UoYXJyYXksIHByb21pc2UpO1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gcmFjZShwcm9taXNlcywgcGFyZW50KSB7XG4gICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocHJvbWlzZXMpO1xuXG4gICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHJhY2VMYXRlcihtYXliZVByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VzID0gdXRpbC5hc0FycmF5KHByb21pc2VzKTtcbiAgICAgICAgaWYgKHByb21pc2VzID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhbiBhcnJheSBvciBhbiBpdGVyYWJsZSBvYmplY3QgYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcocHJvbWlzZXMpKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXQuX3Byb3BhZ2F0ZUZyb20ocGFyZW50LCAzKTtcbiAgICB9XG4gICAgdmFyIGZ1bGZpbGwgPSByZXQuX2Z1bGZpbGw7XG4gICAgdmFyIHJlamVjdCA9IHJldC5fcmVqZWN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm9taXNlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgdmFsID0gcHJvbWlzZXNbaV07XG5cbiAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkICYmICEoaSBpbiBwcm9taXNlcykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgUHJvbWlzZS5jYXN0KHZhbCkuX3RoZW4oZnVsZmlsbCwgcmVqZWN0LCB1bmRlZmluZWQsIHJldCwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cblByb21pc2UucmFjZSA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIHJldHVybiByYWNlKHByb21pc2VzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmFjZSh0aGlzLCB1bmRlZmluZWQpO1xufTtcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3JhY2UuanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZUFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZWplY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIElOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Zykge1xudmFyIGdldERvbWFpbiA9IFByb21pc2UuX2dldERvbWFpbjtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG5cbmZ1bmN0aW9uIFJlZHVjdGlvblByb21pc2VBcnJheShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJChwcm9taXNlcyk7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHRoaXMuX2ZuID0gZG9tYWluID09PSBudWxsID8gZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbik7XG4gICAgaWYgKGluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IFByb21pc2UucmVzb2x2ZShpbml0aWFsVmFsdWUpO1xuICAgICAgICBpbml0aWFsVmFsdWUuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgdGhpcy5fY3VycmVudENhbmNlbGxhYmxlID0gbnVsbDtcbiAgICBpZihfZWFjaCA9PT0gSU5URVJOQUwpIHtcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcyA9IEFycmF5KHRoaXMuX2xlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChfZWFjaCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLl9wcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTUpO1xufVxudXRpbC5pbmhlcml0cyhSZWR1Y3Rpb25Qcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2dvdEFjY3VtID0gZnVuY3Rpb24oYWNjdW0pIHtcbiAgICBpZiAodGhpcy5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkICYmIFxuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzICE9PSBudWxsICYmIFxuICAgICAgICBhY2N1bSAhPT0gSU5URVJOQUwpIHtcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcy5wdXNoKGFjY3VtKTtcbiAgICB9XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9lYWNoQ29tcGxldGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9lYWNoVmFsdWVzICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lYWNoVmFsdWVzO1xufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCkge307XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQgPyB0aGlzLl9lYWNoVmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9pbml0aWFsVmFsdWUpO1xufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5zaG91bGRDb3B5VmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3Byb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKHNlbmRlcikge1xuICAgIGlmIChzZW5kZXIgPT09IHRoaXMuX2luaXRpYWxWYWx1ZSkgcmV0dXJuIHRoaXMuX2NhbmNlbCgpO1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICB0aGlzLl9yZXN1bHRDYW5jZWxsZWQkKCk7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRDYW5jZWxsYWJsZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudENhbmNlbGxhYmxlLmNhbmNlbCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5faW5pdGlhbFZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB0aGlzLl9pbml0aWFsVmFsdWUuY2FuY2VsKCk7XG4gICAgfVxufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faXRlcmF0ZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICAgIGlmICh0aGlzLl9pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX2luaXRpYWxWYWx1ZTtcbiAgICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBQcm9taXNlLnJlc29sdmUodmFsdWVzWzBdKTtcbiAgICAgICAgaSA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudENhbmNlbGxhYmxlID0gdmFsdWU7XG5cbiAgICBpZiAoIXZhbHVlLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0ge1xuICAgICAgICAgICAgICAgIGFjY3VtOiBudWxsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNbaV0sXG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgICAgICAgYXJyYXk6IHRoaXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLl90aGVuKGdvdEFjY3VtLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY3R4LCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAgICAgICAuX3RoZW4odGhpcy5fZWFjaENvbXBsZXRlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgdmFsdWUuX3RoZW4oY29tcGxldGVkLCBjb21wbGV0ZWQsIHVuZGVmaW5lZCwgdmFsdWUsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsVmFsdWUpIHtcbiAgICByZXR1cm4gcmVkdWNlKHRoaXMsIGZuLCBpbml0aWFsVmFsdWUsIG51bGwpO1xufTtcblxuUHJvbWlzZS5yZWR1Y2UgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKSB7XG4gICAgcmV0dXJuIHJlZHVjZShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpO1xufTtcblxuZnVuY3Rpb24gY29tcGxldGVkKHZhbHVlT3JSZWFzb24sIGFycmF5KSB7XG4gICAgaWYgKHRoaXMuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICBhcnJheS5fcmVzb2x2ZSh2YWx1ZU9yUmVhc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheS5fcmVqZWN0KHZhbHVlT3JSZWFzb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgdmFyIGFycmF5ID0gbmV3IFJlZHVjdGlvblByb21pc2VBcnJheShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpO1xuICAgIHJldHVybiBhcnJheS5wcm9taXNlKCk7XG59XG5cbmZ1bmN0aW9uIGdvdEFjY3VtKGFjY3VtKSB7XG4gICAgdGhpcy5hY2N1bSA9IGFjY3VtO1xuICAgIHRoaXMuYXJyYXkuX2dvdEFjY3VtKGFjY3VtKTtcbiAgICB2YXIgdmFsdWUgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXMudmFsdWUsIHRoaXMuYXJyYXkuX3Byb21pc2UpO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5hcnJheS5fY3VycmVudENhbmNlbGxhYmxlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZS5fdGhlbihnb3RWYWx1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdvdFZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ290VmFsdWUodmFsdWUpIHtcbiAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgIHZhciBwcm9taXNlID0gYXJyYXkuX3Byb21pc2U7XG4gICAgdmFyIGZuID0gdHJ5Q2F0Y2goYXJyYXkuX2ZuKTtcbiAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciByZXQ7XG4gICAgaWYgKGFycmF5Ll9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0ID0gZm4uY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksIHZhbHVlLCB0aGlzLmluZGV4LCB0aGlzLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gZm4uY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjY3VtLCB2YWx1ZSwgdGhpcy5pbmRleCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBhcnJheS5fY3VycmVudENhbmNlbGxhYmxlID0gcmV0O1xuICAgIH1cbiAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKFxuICAgICAgICByZXQsXG4gICAgICAgIHByb21pc2VDcmVhdGVkLFxuICAgICAgICBhcnJheS5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkID8gXCJQcm9taXNlLmVhY2hcIiA6IFwiUHJvbWlzZS5yZWR1Y2VcIixcbiAgICAgICAgcHJvbWlzZVxuICAgICk7XG4gICAgcmV0dXJuIHJldDtcbn1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9yZWR1Y2UuanNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbiAgICBmdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXksIGRlYnVnKSB7XG52YXIgUHJvbWlzZUluc3BlY3Rpb24gPSBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG5mdW5jdGlvbiBTZXR0bGVkUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHZhbHVlcyk7XG59XG51dGlsLmluaGVyaXRzKFNldHRsZWRQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblNldHRsZWRQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVzb2x2ZWQgPSBmdW5jdGlvbiAoaW5kZXgsIGluc3BlY3Rpb24pIHtcbiAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gaW5zcGVjdGlvbjtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuU2V0dGxlZFByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlSW5zcGVjdGlvbigpO1xuICAgIHJldC5fYml0RmllbGQgPSAzMzU1NDQzMjtcbiAgICByZXQuX3NldHRsZWRWYWx1ZUZpZWxkID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VSZXNvbHZlZChpbmRleCwgcmV0KTtcbn07XG5TZXR0bGVkUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbiwgaW5kZXgpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VJbnNwZWN0aW9uKCk7XG4gICAgcmV0Ll9iaXRGaWVsZCA9IDE2Nzc3MjE2O1xuICAgIHJldC5fc2V0dGxlZFZhbHVlRmllbGQgPSByZWFzb247XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VSZXNvbHZlZChpbmRleCwgcmV0KTtcbn07XG5cblByb21pc2Uuc2V0dGxlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgZGVidWcuZGVwcmVjYXRlZChcIi5zZXR0bGUoKVwiLCBcIi5yZWZsZWN0KClcIik7XG4gICAgcmV0dXJuIG5ldyBTZXR0bGVkUHJvbWlzZUFycmF5KHByb21pc2VzKS5wcm9taXNlKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZXR0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFByb21pc2Uuc2V0dGxlKHRoaXMpO1xufTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9zZXR0bGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbmZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgUmFuZ2VFcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKS5SYW5nZUVycm9yO1xudmFyIEFnZ3JlZ2F0ZUVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpLkFnZ3JlZ2F0ZUVycm9yO1xudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG52YXIgQ0FOQ0VMTEFUSU9OID0ge307XG5cblxuZnVuY3Rpb24gU29tZVByb21pc2VBcnJheSh2YWx1ZXMpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJCh2YWx1ZXMpO1xuICAgIHRoaXMuX2hvd01hbnkgPSAwO1xuICAgIHRoaXMuX3Vud3JhcCA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG59XG51dGlsLmluaGVyaXRzKFNvbWVQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5faG93TWFueSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKFtdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC01KTtcbiAgICB2YXIgaXNBcnJheVJlc29sdmVkID0gaXNBcnJheSh0aGlzLl92YWx1ZXMpO1xuICAgIGlmICghdGhpcy5faXNSZXNvbHZlZCgpICYmXG4gICAgICAgIGlzQXJyYXlSZXNvbHZlZCAmJlxuICAgICAgICB0aGlzLl9ob3dNYW55ID4gdGhpcy5fY2FuUG9zc2libHlGdWxmaWxsKCkpIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHRoaXMuX2dldFJhbmdlRXJyb3IodGhpcy5sZW5ndGgoKSkpO1xuICAgIH1cbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2luaXQoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLnNldFVud3JhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl91bndyYXAgPSB0cnVlO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuaG93TWFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faG93TWFueTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLnNldEhvd01hbnkgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICB0aGlzLl9ob3dNYW55ID0gY291bnQ7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX2FkZEZ1bGZpbGxlZCh2YWx1ZSk7XG4gICAgaWYgKHRoaXMuX2Z1bGZpbGxlZCgpID09PSB0aGlzLmhvd01hbnkoKSkge1xuICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gdGhpcy5ob3dNYW55KCk7XG4gICAgICAgIGlmICh0aGlzLmhvd01hbnkoKSA9PT0gMSAmJiB0aGlzLl91bndyYXApIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuXG59O1xuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl9hZGRSZWplY3RlZChyZWFzb24pO1xuICAgIHJldHVybiB0aGlzLl9jaGVja091dGNvbWUoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlQ2FuY2VsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl92YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHRoaXMuX3ZhbHVlcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5jZWwoKTtcbiAgICB9XG4gICAgdGhpcy5fYWRkUmVqZWN0ZWQoQ0FOQ0VMTEFUSU9OKTtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tPdXRjb21lKCk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fY2hlY2tPdXRjb21lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaG93TWFueSgpID4gdGhpcy5fY2FuUG9zc2libHlGdWxmaWxsKCkpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgQWdncmVnYXRlRXJyb3IoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoKCk7IGkgPCB0aGlzLl92YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YWx1ZXNbaV0gIT09IENBTkNFTExBVElPTikge1xuICAgICAgICAgICAgICAgIGUucHVzaCh0aGlzLl92YWx1ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl90b3RhbFJlc29sdmVkO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3JlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMubGVuZ3RoIC0gdGhpcy5sZW5ndGgoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9hZGRSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl92YWx1ZXMucHVzaChyZWFzb24pO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2FkZEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlc1t0aGlzLl90b3RhbFJlc29sdmVkKytdID0gdmFsdWU7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fY2FuUG9zc2libHlGdWxmaWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCgpIC0gdGhpcy5fcmVqZWN0ZWQoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9nZXRSYW5nZUVycm9yID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBcIklucHV0IGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBcIiArXG4gICAgICAgICAgICB0aGlzLl9ob3dNYW55ICsgXCIgaXRlbXMgYnV0IGNvbnRhaW5zIG9ubHkgXCIgKyBjb3VudCArIFwiIGl0ZW1zXCI7XG4gICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKG1lc3NhZ2UpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3JlamVjdCh0aGlzLl9nZXRSYW5nZUVycm9yKDApKTtcbn07XG5cbmZ1bmN0aW9uIHNvbWUocHJvbWlzZXMsIGhvd01hbnkpIHtcbiAgICBpZiAoKGhvd01hbnkgfCAwKSAhPT0gaG93TWFueSB8fCBob3dNYW55IDwgMCkge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgcG9zaXRpdmUgaW50ZWdlclxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciByZXQgPSBuZXcgU29tZVByb21pc2VBcnJheShwcm9taXNlcyk7XG4gICAgdmFyIHByb21pc2UgPSByZXQucHJvbWlzZSgpO1xuICAgIHJldC5zZXRIb3dNYW55KGhvd01hbnkpO1xuICAgIHJldC5pbml0KCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2Uuc29tZSA9IGZ1bmN0aW9uIChwcm9taXNlcywgaG93TWFueSkge1xuICAgIHJldHVybiBzb21lKHByb21pc2VzLCBob3dNYW55KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiAoaG93TWFueSkge1xuICAgIHJldHVybiBzb21lKHRoaXMsIGhvd01hbnkpO1xufTtcblxuUHJvbWlzZS5fU29tZVByb21pc2VBcnJheSA9IFNvbWVQcm9taXNlQXJyYXk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2Uvc29tZS5qc1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFByb21pc2VNYXAgPSBQcm9taXNlLm1hcDtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFByb21pc2VNYXAodGhpcywgZm4sIG9wdGlvbnMsIElOVEVSTkFMKTtcbn07XG5cblByb21pc2UuZmlsdGVyID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBQcm9taXNlTWFwKHByb21pc2VzLCBmbiwgb3B0aW9ucywgSU5URVJOQUwpO1xufTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9maWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciBQcm9taXNlUmVkdWNlID0gUHJvbWlzZS5yZWR1Y2U7XG52YXIgUHJvbWlzZUFsbCA9IFByb21pc2UuYWxsO1xuXG5mdW5jdGlvbiBwcm9taXNlQWxsVGhpcygpIHtcbiAgICByZXR1cm4gUHJvbWlzZUFsbCh0aGlzKTtcbn1cblxuZnVuY3Rpb24gUHJvbWlzZU1hcFNlcmllcyhwcm9taXNlcywgZm4pIHtcbiAgICByZXR1cm4gUHJvbWlzZVJlZHVjZShwcm9taXNlcywgZm4sIElOVEVSTkFMLCBJTlRFUk5BTCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gUHJvbWlzZVJlZHVjZSh0aGlzLCBmbiwgSU5URVJOQUwsIDApXG4gICAgICAgICAgICAgIC5fdGhlbihwcm9taXNlQWxsVGhpcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5tYXBTZXJpZXMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gUHJvbWlzZVJlZHVjZSh0aGlzLCBmbiwgSU5URVJOQUwsIElOVEVSTkFMKTtcbn07XG5cblByb21pc2UuZWFjaCA9IGZ1bmN0aW9uIChwcm9taXNlcywgZm4pIHtcbiAgICByZXR1cm4gUHJvbWlzZVJlZHVjZShwcm9taXNlcywgZm4sIElOVEVSTkFMLCAwKVxuICAgICAgICAgICAgICAuX3RoZW4ocHJvbWlzZUFsbFRoaXMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBwcm9taXNlcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UubWFwU2VyaWVzID0gUHJvbWlzZU1hcFNlcmllcztcbn07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2VhY2guanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIFNvbWVQcm9taXNlQXJyYXkgPSBQcm9taXNlLl9Tb21lUHJvbWlzZUFycmF5O1xuZnVuY3Rpb24gYW55KHByb21pc2VzKSB7XG4gICAgdmFyIHJldCA9IG5ldyBTb21lUHJvbWlzZUFycmF5KHByb21pc2VzKTtcbiAgICB2YXIgcHJvbWlzZSA9IHJldC5wcm9taXNlKCk7XG4gICAgcmV0LnNldEhvd01hbnkoMSk7XG4gICAgcmV0LnNldFVud3JhcCgpO1xuICAgIHJldC5pbml0KCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2UuYW55ID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIGFueShwcm9taXNlcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFueSh0aGlzKTtcbn07XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9hbnkuanNcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuICAgIC8vcG9seWZpbGwgYmluZFxyXG4gICAgaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xyXG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24ob1RoaXMpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNSBpbnRlcm5hbCBJc0NhbGxhYmxlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcbiAgICAgICAgICAgICAgICBmVG9CaW5kID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGZOT1AgPSBmdW5jdGlvbigpIHt9LFxyXG4gICAgICAgICAgICAgICAgZkJvdW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1AgJiYgb1RoaXMgPyB0aGlzIDogb1RoaXMgfHwgd2luZG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZOT1AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XHJcbiAgICAgICAgICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZCb3VuZDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vcG9seWZpbGwgcmVtb3ZlXHJcbiAgICBpZiAoISgncmVtb3ZlJyBpbiBFbGVtZW50LnByb3RvdHlwZSkpIHtcclxuICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIVN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgpIHtcclxuICAgIFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGggPSBmdW5jdGlvbihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIHN1YmplY3RTdHJpbmcgPSB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicgfHwgIWlzRmluaXRlKHBvc2l0aW9uKSB8fCBNYXRoLmZsb29yKHBvc2l0aW9uKSAhPT0gcG9zaXRpb24gfHwgcG9zaXRpb24gPiBzdWJqZWN0U3RyaW5nLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHN1YmplY3RTdHJpbmcubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb3NpdGlvbiAtPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xyXG4gICAgICAgIHZhciBsYXN0SW5kZXggPSBzdWJqZWN0U3RyaW5nLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBwb3NpdGlvbjtcclxuICAgIH07XHJcbiAgICB9XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvcG9seWZpbGwuanNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKFwiLi9ncmFwaGljXCIpO1xuXG52YXIgX3pyZW5kZXIgPSByZXF1aXJlKFwiLi4venJlbmRlclwiKTtcblxudmFyIHJlZ2lzdGVyUGFpbnRlciA9IF96cmVuZGVyLnJlZ2lzdGVyUGFpbnRlcjtcblxudmFyIFBhaW50ZXIgPSByZXF1aXJlKFwiLi9QYWludGVyXCIpO1xuXG5yZWdpc3RlclBhaW50ZXIoJ3ZtbCcsIFBhaW50ZXIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi92bWwvdm1sLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVudiA9IHJlcXVpcmUoXCIuLi9jb3JlL2VudlwiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciBhcHBseVRyYW5zZm9ybSA9IF92ZWN0b3IuYXBwbHlUcmFuc2Zvcm07XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciBjb2xvclRvb2wgPSByZXF1aXJlKFwiLi4vdG9vbC9jb2xvclwiKTtcblxudmFyIHRleHRDb250YWluID0gcmVxdWlyZShcIi4uL2NvbnRhaW4vdGV4dFwiKTtcblxudmFyIHRleHRIZWxwZXIgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9oZWxwZXIvdGV4dFwiKTtcblxudmFyIFJlY3RUZXh0ID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvbWl4aW4vUmVjdFRleHRcIik7XG5cbnZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL0Rpc3BsYXlhYmxlXCIpO1xuXG52YXIgWkltYWdlID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvSW1hZ2VcIik7XG5cbnZhciBUZXh0ID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvVGV4dFwiKTtcblxudmFyIFBhdGggPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9QYXRoXCIpO1xuXG52YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgR3JhZGllbnQgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9HcmFkaWVudFwiKTtcblxudmFyIHZtbENvcmUgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9OT1RFLVZNTFxuLy8gVE9ETyBVc2UgcHJveHkgbGlrZSBzdmcgaW5zdGVhZCBvZiBvdmVyd3JpdGUgYnJ1c2ggbWV0aG9kc1xudmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgY29zID0gTWF0aC5jb3M7XG52YXIgc2luID0gTWF0aC5zaW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuXG5pZiAoIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgdmFyIGNvbW1hID0gJywnO1xuICB2YXIgaW1hZ2VUcmFuc2Zvcm1QcmVmaXggPSAncHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0JztcbiAgdmFyIFogPSAyMTYwMDtcbiAgdmFyIFoyID0gWiAvIDI7XG4gIHZhciBaTEVWRUxfQkFTRSA9IDEwMDAwMDtcbiAgdmFyIFpfQkFTRSA9IDEwMDA7XG5cbiAgdmFyIGluaXRSb290RWxTdHlsZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGVsLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowO3dpZHRoOjFweDtoZWlnaHQ6MXB4Oyc7XG4gICAgZWwuY29vcmRzaXplID0gWiArICcsJyArIFo7XG4gICAgZWwuY29vcmRvcmlnaW4gPSAnMCwwJztcbiAgfTtcblxuICB2YXIgZW5jb2RlSHRtbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbiAgfTtcblxuICB2YXIgcmdiMlN0ciA9IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgcmV0dXJuICdyZ2IoJyArIFtyLCBnLCBiXS5qb2luKCcsJykgKyAnKSc7XG4gIH07XG5cbiAgdmFyIGFwcGVuZCA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkICYmIHBhcmVudCAmJiBjaGlsZC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZW1vdmUgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCkge1xuICAgIGlmIChjaGlsZCAmJiBwYXJlbnQgJiYgY2hpbGQucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0WkluZGV4ID0gZnVuY3Rpb24gKHpsZXZlbCwgeiwgejIpIHtcbiAgICAvLyB6IOeahOWPluWAvOiMg+WbtOS4uiBbMCwgMTAwMF1cbiAgICByZXR1cm4gKHBhcnNlRmxvYXQoemxldmVsKSB8fCAwKSAqIFpMRVZFTF9CQVNFICsgKHBhcnNlRmxvYXQoeikgfHwgMCkgKiBaX0JBU0UgKyB6MjtcbiAgfTtcblxuICB2YXIgcGFyc2VQZXJjZW50ID0gZnVuY3Rpb24gKHZhbHVlLCBtYXhWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodmFsdWUubGFzdEluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIG1heFZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIFBBVEhcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgdmFyIHNldENvbG9yQW5kT3BhY2l0eSA9IGZ1bmN0aW9uIChlbCwgY29sb3IsIG9wYWNpdHkpIHtcbiAgICB2YXIgY29sb3JBcnIgPSBjb2xvclRvb2wucGFyc2UoY29sb3IpO1xuICAgIG9wYWNpdHkgPSArb3BhY2l0eTtcblxuICAgIGlmIChpc05hTihvcGFjaXR5KSkge1xuICAgICAgb3BhY2l0eSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICBlbC5jb2xvciA9IHJnYjJTdHIoY29sb3JBcnJbMF0sIGNvbG9yQXJyWzFdLCBjb2xvckFyclsyXSk7XG4gICAgICBlbC5vcGFjaXR5ID0gb3BhY2l0eSAqIGNvbG9yQXJyWzNdO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0Q29sb3JBbmRBbHBoYSA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHZhciBjb2xvckFyciA9IGNvbG9yVG9vbC5wYXJzZShjb2xvcik7XG4gICAgcmV0dXJuIFtyZ2IyU3RyKGNvbG9yQXJyWzBdLCBjb2xvckFyclsxXSwgY29sb3JBcnJbMl0pLCBjb2xvckFyclszXV07XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUZpbGxOb2RlID0gZnVuY3Rpb24gKGVsLCBzdHlsZSwgenJFbCkge1xuICAgIC8vIFRPRE8gcGF0dGVyblxuICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcblxuICAgIGlmIChmaWxsICE9IG51bGwpIHtcbiAgICAgIC8vIE1vZGlmaWVkIGZyb20gZXhjYW52YXNcbiAgICAgIGlmIChmaWxsIGluc3RhbmNlb2YgR3JhZGllbnQpIHtcbiAgICAgICAgdmFyIGdyYWRpZW50VHlwZTtcbiAgICAgICAgdmFyIGFuZ2xlID0gMDtcbiAgICAgICAgdmFyIGZvY3VzID0gWzAsIDBdOyAvLyBhZGRpdGlvbmFsIG9mZnNldFxuXG4gICAgICAgIHZhciBzaGlmdCA9IDA7IC8vIHNjYWxlIGZhY3RvciBmb3Igb2Zmc2V0XG5cbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IDE7XG4gICAgICAgIHZhciByZWN0ID0genJFbC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgdmFyIHJlY3RXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgIHZhciByZWN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKGZpbGwudHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICBncmFkaWVudFR5cGUgPSAnZ3JhZGllbnQnO1xuICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB6ckVsLnRyYW5zZm9ybTtcbiAgICAgICAgICB2YXIgcDAgPSBbZmlsbC54ICogcmVjdFdpZHRoLCBmaWxsLnkgKiByZWN0SGVpZ2h0XTtcbiAgICAgICAgICB2YXIgcDEgPSBbZmlsbC54MiAqIHJlY3RXaWR0aCwgZmlsbC55MiAqIHJlY3RIZWlnaHRdO1xuXG4gICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDEsIHAxLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkeCA9IHAxWzBdIC0gcDBbMF07XG4gICAgICAgICAgdmFyIGR5ID0gcDFbMV0gLSBwMFsxXTtcbiAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoZHgsIGR5KSAqIDE4MCAvIE1hdGguUEk7IC8vIFRoZSBhbmdsZSBzaG91bGQgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLlxuXG4gICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgYW5nbGUgKz0gMzYwO1xuICAgICAgICAgIH0gLy8gVmVyeSBzbWFsbCBhbmdsZXMgcHJvZHVjZSBhbiB1bmV4cGVjdGVkIHJlc3VsdCBiZWNhdXNlIHRoZXkgYXJlXG4gICAgICAgICAgLy8gY29udmVydGVkIHRvIGEgc2NpZW50aWZpYyBub3RhdGlvbiBzdHJpbmcuXG5cblxuICAgICAgICAgIGlmIChhbmdsZSA8IDFlLTYpIHtcbiAgICAgICAgICAgIGFuZ2xlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JhZGllbnRUeXBlID0gJ2dyYWRpZW50cmFkaWFsJztcbiAgICAgICAgICB2YXIgcDAgPSBbZmlsbC54ICogcmVjdFdpZHRoLCBmaWxsLnkgKiByZWN0SGVpZ2h0XTtcbiAgICAgICAgICB2YXIgdHJhbnNmb3JtID0genJFbC50cmFuc2Zvcm07XG4gICAgICAgICAgdmFyIHNjYWxlID0genJFbC5zY2FsZTtcbiAgICAgICAgICB2YXIgd2lkdGggPSByZWN0V2lkdGg7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IHJlY3RIZWlnaHQ7XG4gICAgICAgICAgZm9jdXMgPSBbLy8gUGVyY2VudCBpbiBib3VuZGluZyByZWN0XG4gICAgICAgICAgKHAwWzBdIC0gcmVjdC54KSAvIHdpZHRoLCAocDBbMV0gLSByZWN0LnkpIC8gaGVpZ2h0XTtcblxuICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAwLCBwMCwgdHJhbnNmb3JtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aWR0aCAvPSBzY2FsZVswXSAqIFo7XG4gICAgICAgICAgaGVpZ2h0IC89IHNjYWxlWzFdICogWjtcbiAgICAgICAgICB2YXIgZGltZW5zaW9uID0gbWF0aE1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICBzaGlmdCA9IDIgKiAwIC8gZGltZW5zaW9uO1xuICAgICAgICAgIGV4cGFuc2lvbiA9IDIgKiBmaWxsLnIgLyBkaW1lbnNpb24gLSBzaGlmdDtcbiAgICAgICAgfSAvLyBXZSBuZWVkIHRvIHNvcnQgdGhlIGNvbG9yIHN0b3BzIGluIGFzY2VuZGluZyBvcmRlciBieSBvZmZzZXQsXG4gICAgICAgIC8vIG90aGVyd2lzZSBJRSB3b24ndCBpbnRlcnByZXQgaXQgY29ycmVjdGx5LlxuXG5cbiAgICAgICAgdmFyIHN0b3BzID0gZmlsbC5jb2xvclN0b3BzLnNsaWNlKCk7XG4gICAgICAgIHN0b3BzLnNvcnQoZnVuY3Rpb24gKGNzMSwgY3MyKSB7XG4gICAgICAgICAgcmV0dXJuIGNzMS5vZmZzZXQgLSBjczIub2Zmc2V0O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0b3BzLmxlbmd0aDsgLy8gQ29sb3IgYW5kIGFscGhhIGxpc3Qgb2YgZmlyc3QgYW5kIGxhc3Qgc3RvcFxuXG4gICAgICAgIHZhciBjb2xvckFuZEFscGhhTGlzdCA9IFtdO1xuICAgICAgICB2YXIgY29sb3JzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzdG9wID0gc3RvcHNbaV07XG4gICAgICAgICAgdmFyIGNvbG9yQW5kQWxwaGEgPSBnZXRDb2xvckFuZEFscGhhKHN0b3AuY29sb3IpO1xuICAgICAgICAgIGNvbG9ycy5wdXNoKHN0b3Aub2Zmc2V0ICogZXhwYW5zaW9uICsgc2hpZnQgKyAnICcgKyBjb2xvckFuZEFscGhhWzBdKTtcblxuICAgICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvbG9yQW5kQWxwaGFMaXN0LnB1c2goY29sb3JBbmRBbHBoYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgdmFyIGNvbG9yMSA9IGNvbG9yQW5kQWxwaGFMaXN0WzBdWzBdO1xuICAgICAgICAgIHZhciBjb2xvcjIgPSBjb2xvckFuZEFscGhhTGlzdFsxXVswXTtcbiAgICAgICAgICB2YXIgb3BhY2l0eTEgPSBjb2xvckFuZEFscGhhTGlzdFswXVsxXSAqIHN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgdmFyIG9wYWNpdHkyID0gY29sb3JBbmRBbHBoYUxpc3RbMV1bMV0gKiBzdHlsZS5vcGFjaXR5O1xuICAgICAgICAgIGVsLnR5cGUgPSBncmFkaWVudFR5cGU7XG4gICAgICAgICAgZWwubWV0aG9kID0gJ25vbmUnO1xuICAgICAgICAgIGVsLmZvY3VzID0gJzEwMCUnO1xuICAgICAgICAgIGVsLmFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgZWwuY29sb3IgPSBjb2xvcjE7XG4gICAgICAgICAgZWwuY29sb3IyID0gY29sb3IyO1xuICAgICAgICAgIGVsLmNvbG9ycyA9IGNvbG9ycy5qb2luKCcsJyk7IC8vIFdoZW4gY29sb3JzIGF0dHJpYnV0ZSBpcyB1c2VkLCB0aGUgbWVhbmluZ3Mgb2Ygb3BhY2l0eSBhbmQgbzpvcGFjaXR5MlxuICAgICAgICAgIC8vIGFyZSByZXZlcnNlZC5cblxuICAgICAgICAgIGVsLm9wYWNpdHkgPSBvcGFjaXR5MjsgLy8gRklYTUUgZ19vXzpvcGFjaXR5ID9cblxuICAgICAgICAgIGVsLm9wYWNpdHkyID0gb3BhY2l0eTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JhZGllbnRUeXBlID09PSAncmFkaWFsJykge1xuICAgICAgICAgIGVsLmZvY3VzcG9zaXRpb24gPSBmb2N1cy5qb2luKCcsJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZJWE1FIENoYW5nZSBmcm9tIEdyYWRpZW50IGZpbGwgdG8gY29sb3IgZmlsbFxuICAgICAgICBzZXRDb2xvckFuZE9wYWNpdHkoZWwsIGZpbGwsIHN0eWxlLm9wYWNpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgdXBkYXRlU3Ryb2tlTm9kZSA9IGZ1bmN0aW9uIChlbCwgc3R5bGUpIHtcbiAgICAvLyBpZiAoc3R5bGUubGluZUpvaW4gIT0gbnVsbCkge1xuICAgIC8vICAgICBlbC5qb2luc3R5bGUgPSBzdHlsZS5saW5lSm9pbjtcbiAgICAvLyB9XG4gICAgLy8gaWYgKHN0eWxlLm1pdGVyTGltaXQgIT0gbnVsbCkge1xuICAgIC8vICAgICBlbC5taXRlcmxpbWl0ID0gc3R5bGUubWl0ZXJMaW1pdCAqIFo7XG4gICAgLy8gfVxuICAgIC8vIGlmIChzdHlsZS5saW5lQ2FwICE9IG51bGwpIHtcbiAgICAvLyAgICAgZWwuZW5kY2FwID0gc3R5bGUubGluZUNhcDtcbiAgICAvLyB9XG4gICAgaWYgKHN0eWxlLmxpbmVEYXNoICE9IG51bGwpIHtcbiAgICAgIGVsLmRhc2hzdHlsZSA9IHN0eWxlLmxpbmVEYXNoLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUuc3Ryb2tlICE9IG51bGwgJiYgIShzdHlsZS5zdHJva2UgaW5zdGFuY2VvZiBHcmFkaWVudCkpIHtcbiAgICAgIHNldENvbG9yQW5kT3BhY2l0eShlbCwgc3R5bGUuc3Ryb2tlLCBzdHlsZS5vcGFjaXR5KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUZpbGxBbmRTdHJva2UgPSBmdW5jdGlvbiAodm1sRWwsIHR5cGUsIHN0eWxlLCB6ckVsKSB7XG4gICAgdmFyIGlzRmlsbCA9IHR5cGUgPT0gJ2ZpbGwnO1xuICAgIHZhciBlbCA9IHZtbEVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKHR5cGUpWzBdOyAvLyBTdHJva2UgbXVzdCBoYXZlIGxpbmVXaWR0aFxuXG4gICAgaWYgKHN0eWxlW3R5cGVdICE9IG51bGwgJiYgc3R5bGVbdHlwZV0gIT09ICdub25lJyAmJiAoaXNGaWxsIHx8ICFpc0ZpbGwgJiYgc3R5bGUubGluZVdpZHRoKSkge1xuICAgICAgdm1sRWxbaXNGaWxsID8gJ2ZpbGxlZCcgOiAnc3Ryb2tlZCddID0gJ3RydWUnOyAvLyBGSVhNRSBSZW1vdmUgYmVmb3JlIHVwZGF0aW5nLCBvciBzZXQgYGNvbG9yc2Agd2lsbCB0aHJvdyBlcnJvclxuXG4gICAgICBpZiAoc3R5bGVbdHlwZV0gaW5zdGFuY2VvZiBHcmFkaWVudCkge1xuICAgICAgICByZW1vdmUodm1sRWwsIGVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbCkge1xuICAgICAgICBlbCA9IHZtbENvcmUuY3JlYXRlTm9kZSh0eXBlKTtcbiAgICAgIH1cblxuICAgICAgaXNGaWxsID8gdXBkYXRlRmlsbE5vZGUoZWwsIHN0eWxlLCB6ckVsKSA6IHVwZGF0ZVN0cm9rZU5vZGUoZWwsIHN0eWxlKTtcbiAgICAgIGFwcGVuZCh2bWxFbCwgZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bWxFbFtpc0ZpbGwgPyAnZmlsbGVkJyA6ICdzdHJva2VkJ10gPSAnZmFsc2UnO1xuICAgICAgcmVtb3ZlKHZtbEVsLCBlbCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwb2ludHMgPSBbW10sIFtdLCBbXV07XG5cbiAgdmFyIHBhdGhEYXRhVG9TdHJpbmcgPSBmdW5jdGlvbiAocGF0aCwgbSkge1xuICAgIHZhciBNID0gQ01ELk07XG4gICAgdmFyIEMgPSBDTUQuQztcbiAgICB2YXIgTCA9IENNRC5MO1xuICAgIHZhciBBID0gQ01ELkE7XG4gICAgdmFyIFEgPSBDTUQuUTtcbiAgICB2YXIgc3RyID0gW107XG4gICAgdmFyIG5Qb2ludDtcbiAgICB2YXIgY21kU3RyO1xuICAgIHZhciBjbWQ7XG4gICAgdmFyIGk7XG4gICAgdmFyIHhpO1xuICAgIHZhciB5aTtcbiAgICB2YXIgZGF0YSA9IHBhdGguZGF0YTtcbiAgICB2YXIgZGF0YUxlbmd0aCA9IHBhdGgubGVuKCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDspIHtcbiAgICAgIGNtZCA9IGRhdGFbaSsrXTtcbiAgICAgIGNtZFN0ciA9ICcnO1xuICAgICAgblBvaW50ID0gMDtcblxuICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgY2FzZSBNOlxuICAgICAgICAgIGNtZFN0ciA9ICcgbSAnO1xuICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgcG9pbnRzWzBdWzBdID0geGk7XG4gICAgICAgICAgcG9pbnRzWzBdWzFdID0geWk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBMOlxuICAgICAgICAgIGNtZFN0ciA9ICcgbCAnO1xuICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgcG9pbnRzWzBdWzBdID0geGk7XG4gICAgICAgICAgcG9pbnRzWzBdWzFdID0geWk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBROlxuICAgICAgICBjYXNlIEM6XG4gICAgICAgICAgY21kU3RyID0gJyBjICc7XG4gICAgICAgICAgblBvaW50ID0gMztcbiAgICAgICAgICB2YXIgeDEgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHkxID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB4MiA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgeTIgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHgzO1xuICAgICAgICAgIHZhciB5MztcblxuICAgICAgICAgIGlmIChjbWQgPT09IFEpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcXVhZHJhdGljIHRvIGN1YmljIHVzaW5nIGRlZ3JlZSBlbGV2YXRpb25cbiAgICAgICAgICAgIHgzID0geDI7XG4gICAgICAgICAgICB5MyA9IHkyO1xuICAgICAgICAgICAgeDIgPSAoeDIgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgIHkyID0gKHkyICsgMiAqIHkxKSAvIDM7XG4gICAgICAgICAgICB4MSA9ICh4aSArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgeTEgPSAoeWkgKyAyICogeTEpIC8gMztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeDMgPSBkYXRhW2krK107XG4gICAgICAgICAgICB5MyA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb2ludHNbMF1bMF0gPSB4MTtcbiAgICAgICAgICBwb2ludHNbMF1bMV0gPSB5MTtcbiAgICAgICAgICBwb2ludHNbMV1bMF0gPSB4MjtcbiAgICAgICAgICBwb2ludHNbMV1bMV0gPSB5MjtcbiAgICAgICAgICBwb2ludHNbMl1bMF0gPSB4MztcbiAgICAgICAgICBwb2ludHNbMl1bMV0gPSB5MztcbiAgICAgICAgICB4aSA9IHgzO1xuICAgICAgICAgIHlpID0geTM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBBOlxuICAgICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgICAgdmFyIHN4ID0gMTtcbiAgICAgICAgICB2YXIgc3kgPSAxO1xuICAgICAgICAgIHZhciBhbmdsZSA9IDA7XG5cbiAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgLy8gRXh0cmFjdCBTUlQgZnJvbSBtYXRyaXhcbiAgICAgICAgICAgIHggPSBtWzRdO1xuICAgICAgICAgICAgeSA9IG1bNV07XG4gICAgICAgICAgICBzeCA9IHNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgICAgICBzeSA9IHNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBkYXRhW2krK10gKyBhbmdsZTtcbiAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBkYXRhW2krK10gKyBzdGFydEFuZ2xlICsgYW5nbGU7IC8vIEZJWE1FXG4gICAgICAgICAgLy8gdmFyIHBzaSA9IGRhdGFbaSsrXTtcblxuICAgICAgICAgIGkrKztcbiAgICAgICAgICB2YXIgY2xvY2t3aXNlID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB4MCA9IGN4ICsgY29zKHN0YXJ0QW5nbGUpICogcng7XG4gICAgICAgICAgdmFyIHkwID0gY3kgKyBzaW4oc3RhcnRBbmdsZSkgKiByeTtcbiAgICAgICAgICB2YXIgeDEgPSBjeCArIGNvcyhlbmRBbmdsZSkgKiByeDtcbiAgICAgICAgICB2YXIgeTEgPSBjeSArIHNpbihlbmRBbmdsZSkgKiByeTtcbiAgICAgICAgICB2YXIgdHlwZSA9IGNsb2Nrd2lzZSA/ICcgd2EgJyA6ICcgYXQgJztcblxuICAgICAgICAgIGlmIChNYXRoLmFicyh4MCAtIHgxKSA8IDFlLTQpIHtcbiAgICAgICAgICAgIC8vIElFIHdvbid0IHJlbmRlciBhcmNoZXMgZHJhd24gY291bnRlciBjbG9ja3dpc2UgaWYgeDAgPT0geDEuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSA+IDFlLTIpIHtcbiAgICAgICAgICAgICAgLy8gT2Zmc2V0IHgwIGJ5IDEvODAgb2YgYSBwaXhlbC4gVXNlIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAvLyB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCBpbiBiaW5hcnlcbiAgICAgICAgICAgICAgaWYgKGNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgICAgIHgwICs9IDI3MCAvIFo7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEF2b2lkIGNhc2UgZHJhdyBmdWxsIGNpcmNsZVxuICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoeTAgLSBjeSkgPCAxZS00KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsb2Nrd2lzZSAmJiB4MCA8IGN4IHx8ICFjbG9ja3dpc2UgJiYgeDAgPiBjeCkge1xuICAgICAgICAgICAgICAgICAgeTEgLT0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeTEgKz0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xvY2t3aXNlICYmIHkwIDwgY3kgfHwgIWNsb2Nrd2lzZSAmJiB5MCA+IGN5KSB7XG4gICAgICAgICAgICAgICAgeDEgKz0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4MSAtPSAyNzAgLyBaO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RyLnB1c2godHlwZSwgcm91bmQoKChjeCAtIHJ4KSAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSwgcm91bmQoKChjeSAtIHJ5KSAqIHN5ICsgeSkgKiBaIC0gWjIpLCBjb21tYSwgcm91bmQoKChjeCArIHJ4KSAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSwgcm91bmQoKChjeSArIHJ5KSAqIHN5ICsgeSkgKiBaIC0gWjIpLCBjb21tYSwgcm91bmQoKHgwICogc3ggKyB4KSAqIFogLSBaMiksIGNvbW1hLCByb3VuZCgoeTAgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCh4MSAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSwgcm91bmQoKHkxICogc3kgKyB5KSAqIFogLSBaMikpO1xuICAgICAgICAgIHhpID0geDE7XG4gICAgICAgICAgeWkgPSB5MTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgIHZhciBwMCA9IHBvaW50c1swXTtcbiAgICAgICAgICB2YXIgcDEgPSBwb2ludHNbMV07IC8vIHgwLCB5MFxuXG4gICAgICAgICAgcDBbMF0gPSBkYXRhW2krK107XG4gICAgICAgICAgcDBbMV0gPSBkYXRhW2krK107IC8vIHgxLCB5MVxuXG4gICAgICAgICAgcDFbMF0gPSBwMFswXSArIGRhdGFbaSsrXTtcbiAgICAgICAgICBwMVsxXSA9IHAwWzFdICsgZGF0YVtpKytdO1xuXG4gICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAwLCBwMCwgbSk7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMSwgcDEsIG0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHAwWzBdID0gcm91bmQocDBbMF0gKiBaIC0gWjIpO1xuICAgICAgICAgIHAxWzBdID0gcm91bmQocDFbMF0gKiBaIC0gWjIpO1xuICAgICAgICAgIHAwWzFdID0gcm91bmQocDBbMV0gKiBaIC0gWjIpO1xuICAgICAgICAgIHAxWzFdID0gcm91bmQocDFbMV0gKiBaIC0gWjIpO1xuICAgICAgICAgIHN0ci5wdXNoKCAvLyB4MCwgeTBcbiAgICAgICAgICAnIG0gJywgcDBbMF0sIGNvbW1hLCBwMFsxXSwgLy8geDEsIHkwXG4gICAgICAgICAgJyBsICcsIHAxWzBdLCBjb21tYSwgcDBbMV0sIC8vIHgxLCB5MVxuICAgICAgICAgICcgbCAnLCBwMVswXSwgY29tbWEsIHAxWzFdLCAvLyB4MCwgeTFcbiAgICAgICAgICAnIGwgJywgcDBbMF0sIGNvbW1hLCBwMVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAvLyBGSVhNRSBVcGRhdGUgeGksIHlpXG4gICAgICAgICAgc3RyLnB1c2goJyB4ICcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoblBvaW50ID4gMCkge1xuICAgICAgICBzdHIucHVzaChjbWRTdHIpO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgblBvaW50OyBrKyspIHtcbiAgICAgICAgICB2YXIgcCA9IHBvaW50c1trXTtcbiAgICAgICAgICBtICYmIGFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pOyAvLyDkuI0gcm91bmQg5Lya6Z2e5bi45oWiXG5cbiAgICAgICAgICBzdHIucHVzaChyb3VuZChwWzBdICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKHBbMV0gKiBaIC0gWjIpLCBrIDwgblBvaW50IC0gMSA/IGNvbW1hIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5qb2luKCcnKTtcbiAgfTsgLy8gUmV3cml0ZSB0aGUgb3JpZ2luYWwgcGF0aCBtZXRob2RcblxuXG4gIFBhdGgucHJvdG90eXBlLmJydXNoVk1MID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciB2bWxFbCA9IHRoaXMuX3ZtbEVsO1xuXG4gICAgaWYgKCF2bWxFbCkge1xuICAgICAgdm1sRWwgPSB2bWxDb3JlLmNyZWF0ZU5vZGUoJ3NoYXBlJyk7XG4gICAgICBpbml0Um9vdEVsU3R5bGUodm1sRWwpO1xuICAgICAgdGhpcy5fdm1sRWwgPSB2bWxFbDtcbiAgICB9XG5cbiAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHZtbEVsLCAnZmlsbCcsIHN0eWxlLCB0aGlzKTtcbiAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHZtbEVsLCAnc3Ryb2tlJywgc3R5bGUsIHRoaXMpO1xuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgdmFyIG5lZWRUcmFuc2Zvcm0gPSBtICE9IG51bGw7XG4gICAgdmFyIHN0cm9rZUVsID0gdm1sRWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0cm9rZScpWzBdO1xuXG4gICAgaWYgKHN0cm9rZUVsKSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoOyAvLyBHZXQgdGhlIGxpbmUgc2NhbGUuXG4gICAgICAvLyBEZXRlcm1pbmFudCBvZiB0aGlzLm1fIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgICAgLy8gZm9yIHdpZHRoLlxuXG4gICAgICBpZiAobmVlZFRyYW5zZm9ybSAmJiAhc3R5bGUuc3Ryb2tlTm9TY2FsZSkge1xuICAgICAgICB2YXIgZGV0ID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICAgICAgbGluZVdpZHRoICo9IHNxcnQoYWJzKGRldCkpO1xuICAgICAgfVxuXG4gICAgICBzdHJva2VFbC53ZWlnaHQgPSBsaW5lV2lkdGggKyAncHgnO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoIHx8ICh0aGlzLnBhdGggPSBuZXcgUGF0aFByb3h5KCkpO1xuXG4gICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgIHBhdGguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLmJ1aWxkUGF0aChwYXRoLCB0aGlzLnNoYXBlKTtcbiAgICAgIHBhdGgudG9TdGF0aWMoKTtcbiAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2bWxFbC5wYXRoID0gcGF0aERhdGFUb1N0cmluZyhwYXRoLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgdm1sRWwuc3R5bGUuekluZGV4ID0gZ2V0WkluZGV4KHRoaXMuemxldmVsLCB0aGlzLnosIHRoaXMuejIpOyAvLyBBcHBlbmQgdG8gcm9vdFxuXG4gICAgYXBwZW5kKHZtbFJvb3QsIHZtbEVsKTsgLy8gVGV4dFxuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQodm1sUm9vdCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfVxuICB9O1xuXG4gIFBhdGgucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICByZW1vdmUodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG5cbiAgUGF0aC5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIGFwcGVuZCh2bWxSb290LCB0aGlzLl92bWxFbCk7XG4gICAgdGhpcy5hcHBlbmRSZWN0VGV4dCh2bWxSb290KTtcbiAgfTtcbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBJTUFHRVxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICB2YXIgaXNJbWFnZSA9IGZ1bmN0aW9uIChpbWcpIHtcbiAgICAvLyBGSVhNRSBpbWcgaW5zdGFuY2VvZiBJbWFnZSDlpoLmnpwgaW1nIOaYr+S4gOS4quWtl+espuS4sueahOaXtuWAme+8jElFOCDkuIvkvJrmiqXplJlcbiAgICByZXR1cm4gdHlwZW9mIGltZyA9PT0gJ29iamVjdCcgJiYgaW1nLnRhZ05hbWUgJiYgaW1nLnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0lNRyc7IC8vIHJldHVybiBpbWcgaW5zdGFuY2VvZiBJbWFnZTtcbiAgfTsgLy8gUmV3cml0ZSB0aGUgb3JpZ2luYWwgcGF0aCBtZXRob2RcblxuXG4gIFpJbWFnZS5wcm90b3R5cGUuYnJ1c2hWTUwgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIGltYWdlID0gc3R5bGUuaW1hZ2U7IC8vIEltYWdlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHRcblxuICAgIHZhciBvdztcbiAgICB2YXIgb2g7XG5cbiAgICBpZiAoaXNJbWFnZShpbWFnZSkpIHtcbiAgICAgIHZhciBzcmMgPSBpbWFnZS5zcmM7XG5cbiAgICAgIGlmIChzcmMgPT09IHRoaXMuX2ltYWdlU3JjKSB7XG4gICAgICAgIG93ID0gdGhpcy5faW1hZ2VXaWR0aDtcbiAgICAgICAgb2ggPSB0aGlzLl9pbWFnZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbWFnZVJ1bnRpbWVTdHlsZSA9IGltYWdlLnJ1bnRpbWVTdHlsZTtcbiAgICAgICAgdmFyIG9sZFJ1bnRpbWVXaWR0aCA9IGltYWdlUnVudGltZVN0eWxlLndpZHRoO1xuICAgICAgICB2YXIgb2xkUnVudGltZUhlaWdodCA9IGltYWdlUnVudGltZVN0eWxlLmhlaWdodDtcbiAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUud2lkdGggPSAnYXV0byc7XG4gICAgICAgIGltYWdlUnVudGltZVN0eWxlLmhlaWdodCA9ICdhdXRvJzsgLy8gZ2V0IHRoZSBvcmlnaW5hbCBzaXplXG5cbiAgICAgICAgb3cgPSBpbWFnZS53aWR0aDtcbiAgICAgICAgb2ggPSBpbWFnZS5oZWlnaHQ7IC8vIGFuZCByZW1vdmUgb3ZlcmlkZXNcblxuICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS53aWR0aCA9IG9sZFJ1bnRpbWVXaWR0aDtcbiAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUuaGVpZ2h0ID0gb2xkUnVudGltZUhlaWdodDsgLy8gQ2FjaGluZyBpbWFnZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0IGFuZCBzcmNcblxuICAgICAgICB0aGlzLl9pbWFnZVNyYyA9IHNyYztcbiAgICAgICAgdGhpcy5faW1hZ2VXaWR0aCA9IG93O1xuICAgICAgICB0aGlzLl9pbWFnZUhlaWdodCA9IG9oO1xuICAgICAgfVxuXG4gICAgICBpbWFnZSA9IHNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGltYWdlID09PSB0aGlzLl9pbWFnZVNyYykge1xuICAgICAgICBvdyA9IHRoaXMuX2ltYWdlV2lkdGg7XG4gICAgICAgIG9oID0gdGhpcy5faW1hZ2VIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xuICAgIHZhciB5ID0gc3R5bGUueSB8fCAwO1xuICAgIHZhciBkdyA9IHN0eWxlLndpZHRoO1xuICAgIHZhciBkaCA9IHN0eWxlLmhlaWdodDtcbiAgICB2YXIgc3cgPSBzdHlsZS5zV2lkdGg7XG4gICAgdmFyIHNoID0gc3R5bGUuc0hlaWdodDtcbiAgICB2YXIgc3ggPSBzdHlsZS5zeCB8fCAwO1xuICAgIHZhciBzeSA9IHN0eWxlLnN5IHx8IDA7XG4gICAgdmFyIGhhc0Nyb3AgPSBzdyAmJiBzaDtcbiAgICB2YXIgdm1sRWwgPSB0aGlzLl92bWxFbDtcblxuICAgIGlmICghdm1sRWwpIHtcbiAgICAgIC8vIEZJWE1FIOS9v+eUqCBncm91cCDlnKggbGVmdCwgdG9wIOmDveS4jeaYryAwIOeahOaXtuWAmeWwseaXoOazleaYvuekuuS6huOAglxuICAgICAgLy8gdm1sRWwgPSB2bWxDb3JlLmNyZWF0ZU5vZGUoJ2dyb3VwJyk7XG4gICAgICB2bWxFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaW5pdFJvb3RFbFN0eWxlKHZtbEVsKTtcbiAgICAgIHRoaXMuX3ZtbEVsID0gdm1sRWw7XG4gICAgfVxuXG4gICAgdmFyIHZtbEVsU3R5bGUgPSB2bWxFbC5zdHlsZTtcbiAgICB2YXIgaGFzUm90YXRpb24gPSBmYWxzZTtcbiAgICB2YXIgbTtcbiAgICB2YXIgc2NhbGVYID0gMTtcbiAgICB2YXIgc2NhbGVZID0gMTtcblxuICAgIGlmICh0aGlzLnRyYW5zZm9ybSkge1xuICAgICAgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgc2NhbGVYID0gc3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgIHNjYWxlWSA9IHNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICBoYXNSb3RhdGlvbiA9IG1bMV0gfHwgbVsyXTtcbiAgICB9XG5cbiAgICBpZiAoaGFzUm90YXRpb24pIHtcbiAgICAgIC8vIElmIGZpbHRlcnMgYXJlIG5lY2Vzc2FyeSAocm90YXRpb24gZXhpc3RzKSwgY3JlYXRlIHRoZW1cbiAgICAgIC8vIGZpbHRlcnMgYXJlIGJvZy1zbG93LCBzbyBvbmx5IGNyZWF0ZSB0aGVtIGlmIGFiYnNvbHV0ZWx5IG5lY2Vzc2FyeVxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBjaGVjayBkb2Vzbid0IGFjY291bnQgZm9yIHNrZXdzICh3aGljaCBkb24ndCBleGlzdFxuICAgICAgLy8gaW4gdGhlIGNhbnZhcyBzcGVjICh5ZXQpIGFueXdheS5cbiAgICAgIC8vIEZyb20gZXhjYW52YXNcbiAgICAgIHZhciBwMCA9IFt4LCB5XTtcbiAgICAgIHZhciBwMSA9IFt4ICsgZHcsIHldO1xuICAgICAgdmFyIHAyID0gW3gsIHkgKyBkaF07XG4gICAgICB2YXIgcDMgPSBbeCArIGR3LCB5ICsgZGhdO1xuICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCBtKTtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgbSk7XG4gICAgICBhcHBseVRyYW5zZm9ybShwMiwgcDIsIG0pO1xuICAgICAgYXBwbHlUcmFuc2Zvcm0ocDMsIHAzLCBtKTtcbiAgICAgIHZhciBtYXhYID0gbWF0aE1heChwMFswXSwgcDFbMF0sIHAyWzBdLCBwM1swXSk7XG4gICAgICB2YXIgbWF4WSA9IG1hdGhNYXgocDBbMV0sIHAxWzFdLCBwMlsxXSwgcDNbMV0pO1xuICAgICAgdmFyIHRyYW5zZm9ybUZpbHRlciA9IFtdO1xuICAgICAgdHJhbnNmb3JtRmlsdGVyLnB1c2goJ00xMT0nLCBtWzBdIC8gc2NhbGVYLCBjb21tYSwgJ00xMj0nLCBtWzJdIC8gc2NhbGVZLCBjb21tYSwgJ00yMT0nLCBtWzFdIC8gc2NhbGVYLCBjb21tYSwgJ00yMj0nLCBtWzNdIC8gc2NhbGVZLCBjb21tYSwgJ0R4PScsIHJvdW5kKHggKiBzY2FsZVggKyBtWzRdKSwgY29tbWEsICdEeT0nLCByb3VuZCh5ICogc2NhbGVZICsgbVs1XSkpO1xuICAgICAgdm1sRWxTdHlsZS5wYWRkaW5nID0gJzAgJyArIHJvdW5kKG1heFgpICsgJ3B4ICcgKyByb3VuZChtYXhZKSArICdweCAwJzsgLy8gRklYTUUgRFhJbWFnZVRyYW5zZm9ybSDlnKggSUUxMSDnmoTlhbzlrrnmqKHlvI/kuIvkuI3otbfkvZznlKhcblxuICAgICAgdm1sRWxTdHlsZS5maWx0ZXIgPSBpbWFnZVRyYW5zZm9ybVByZWZpeCArICcuTWF0cml4KCcgKyB0cmFuc2Zvcm1GaWx0ZXIuam9pbignJykgKyAnLCBTaXppbmdNZXRob2Q9Y2xpcCknO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobSkge1xuICAgICAgICB4ID0geCAqIHNjYWxlWCArIG1bNF07XG4gICAgICAgIHkgPSB5ICogc2NhbGVZICsgbVs1XTtcbiAgICAgIH1cblxuICAgICAgdm1sRWxTdHlsZS5maWx0ZXIgPSAnJztcbiAgICAgIHZtbEVsU3R5bGUubGVmdCA9IHJvdW5kKHgpICsgJ3B4JztcbiAgICAgIHZtbEVsU3R5bGUudG9wID0gcm91bmQoeSkgKyAncHgnO1xuICAgIH1cblxuICAgIHZhciBpbWFnZUVsID0gdGhpcy5faW1hZ2VFbDtcbiAgICB2YXIgY3JvcEVsID0gdGhpcy5fY3JvcEVsO1xuXG4gICAgaWYgKCFpbWFnZUVsKSB7XG4gICAgICBpbWFnZUVsID0gdm1sQ29yZS5kb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLl9pbWFnZUVsID0gaW1hZ2VFbDtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VFTFN0eWxlID0gaW1hZ2VFbC5zdHlsZTtcblxuICAgIGlmIChoYXNDcm9wKSB7XG4gICAgICAvLyBOZWVkcyBrbm93IGltYWdlIG9yaWdpbmFsIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgIGlmICghKG93ICYmIG9oKSkge1xuICAgICAgICB2YXIgdG1wSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRtcEltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0bXBJbWFnZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgIG93ID0gdG1wSW1hZ2Uud2lkdGg7XG4gICAgICAgICAgb2ggPSB0bXBJbWFnZS5oZWlnaHQ7IC8vIEFkanVzdCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IHRvIGZpdCB0aGUgcmF0aW8gZGVzdGluYXRpb25TaXplIC8gc291cmNlU2l6ZVxuXG4gICAgICAgICAgaW1hZ2VFTFN0eWxlLndpZHRoID0gcm91bmQoc2NhbGVYICogb3cgKiBkdyAvIHN3KSArICdweCc7XG4gICAgICAgICAgaW1hZ2VFTFN0eWxlLmhlaWdodCA9IHJvdW5kKHNjYWxlWSAqIG9oICogZGggLyBzaCkgKyAncHgnOyAvLyBDYWNoaW5nIGltYWdlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHQgYW5kIHNyY1xuXG4gICAgICAgICAgc2VsZi5faW1hZ2VXaWR0aCA9IG93O1xuICAgICAgICAgIHNlbGYuX2ltYWdlSGVpZ2h0ID0gb2g7XG4gICAgICAgICAgc2VsZi5faW1hZ2VTcmMgPSBpbWFnZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0bXBJbWFnZS5zcmMgPSBpbWFnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIG93ICogZHcgLyBzdykgKyAncHgnO1xuICAgICAgICBpbWFnZUVMU3R5bGUuaGVpZ2h0ID0gcm91bmQoc2NhbGVZICogb2ggKiBkaCAvIHNoKSArICdweCc7XG4gICAgICB9XG5cbiAgICAgIGlmICghY3JvcEVsKSB7XG4gICAgICAgIGNyb3BFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjcm9wRWwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgdGhpcy5fY3JvcEVsID0gY3JvcEVsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3JvcEVsU3R5bGUgPSBjcm9wRWwuc3R5bGU7XG4gICAgICBjcm9wRWxTdHlsZS53aWR0aCA9IHJvdW5kKChkdyArIHN4ICogZHcgLyBzdykgKiBzY2FsZVgpO1xuICAgICAgY3JvcEVsU3R5bGUuaGVpZ2h0ID0gcm91bmQoKGRoICsgc3kgKiBkaCAvIHNoKSAqIHNjYWxlWSk7XG4gICAgICBjcm9wRWxTdHlsZS5maWx0ZXIgPSBpbWFnZVRyYW5zZm9ybVByZWZpeCArICcuTWF0cml4KER4PScgKyAtc3ggKiBkdyAvIHN3ICogc2NhbGVYICsgJyxEeT0nICsgLXN5ICogZGggLyBzaCAqIHNjYWxlWSArICcpJztcblxuICAgICAgaWYgKCFjcm9wRWwucGFyZW50Tm9kZSkge1xuICAgICAgICB2bWxFbC5hcHBlbmRDaGlsZChjcm9wRWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW1hZ2VFbC5wYXJlbnROb2RlICE9IGNyb3BFbCkge1xuICAgICAgICBjcm9wRWwuYXBwZW5kQ2hpbGQoaW1hZ2VFbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIGR3KSArICdweCc7XG4gICAgICBpbWFnZUVMU3R5bGUuaGVpZ2h0ID0gcm91bmQoc2NhbGVZICogZGgpICsgJ3B4JztcbiAgICAgIHZtbEVsLmFwcGVuZENoaWxkKGltYWdlRWwpO1xuXG4gICAgICBpZiAoY3JvcEVsICYmIGNyb3BFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHZtbEVsLnJlbW92ZUNoaWxkKGNyb3BFbCk7XG4gICAgICAgIHRoaXMuX2Nyb3BFbCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZpbHRlclN0ciA9ICcnO1xuICAgIHZhciBhbHBoYSA9IHN0eWxlLm9wYWNpdHk7XG5cbiAgICBpZiAoYWxwaGEgPCAxKSB7XG4gICAgICBmaWx0ZXJTdHIgKz0gJy5BbHBoYShvcGFjaXR5PScgKyByb3VuZChhbHBoYSAqIDEwMCkgKyAnKSAnO1xuICAgIH1cblxuICAgIGZpbHRlclN0ciArPSBpbWFnZVRyYW5zZm9ybVByZWZpeCArICcuQWxwaGFJbWFnZUxvYWRlcihzcmM9JyArIGltYWdlICsgJywgU2l6aW5nTWV0aG9kPXNjYWxlKSc7XG4gICAgaW1hZ2VFTFN0eWxlLmZpbHRlciA9IGZpbHRlclN0cjtcbiAgICB2bWxFbC5zdHlsZS56SW5kZXggPSBnZXRaSW5kZXgodGhpcy56bGV2ZWwsIHRoaXMueiwgdGhpcy56Mik7IC8vIEFwcGVuZCB0byByb290XG5cbiAgICBhcHBlbmQodm1sUm9vdCwgdm1sRWwpOyAvLyBUZXh0XG5cbiAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRyYXdSZWN0VGV4dCh2bWxSb290LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICB9XG4gIH07XG5cbiAgWkltYWdlLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgcmVtb3ZlKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcbiAgICB0aGlzLl92bWxFbCA9IG51bGw7XG4gICAgdGhpcy5fY3JvcEVsID0gbnVsbDtcbiAgICB0aGlzLl9pbWFnZUVsID0gbnVsbDtcbiAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICB9O1xuXG4gIFpJbWFnZS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIGFwcGVuZCh2bWxSb290LCB0aGlzLl92bWxFbCk7XG4gICAgdGhpcy5hcHBlbmRSZWN0VGV4dCh2bWxSb290KTtcbiAgfTtcbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBURVhUXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gIHZhciBERUZBVUxUX1NUWUxFX05PUk1BTCA9ICdub3JtYWwnO1xuICB2YXIgZm9udFN0eWxlQ2FjaGUgPSB7fTtcbiAgdmFyIGZvbnRTdHlsZUNhY2hlQ291bnQgPSAwO1xuICB2YXIgTUFYX0ZPTlRfQ0FDSEVfU0laRSA9IDEwMDtcbiAgdmFyIGZvbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIHZhciBnZXRGb250U3R5bGUgPSBmdW5jdGlvbiAoZm9udFN0cmluZykge1xuICAgIHZhciBmb250U3R5bGUgPSBmb250U3R5bGVDYWNoZVtmb250U3RyaW5nXTtcblxuICAgIGlmICghZm9udFN0eWxlKSB7XG4gICAgICAvLyBDbGVhciBjYWNoZVxuICAgICAgaWYgKGZvbnRTdHlsZUNhY2hlQ291bnQgPiBNQVhfRk9OVF9DQUNIRV9TSVpFKSB7XG4gICAgICAgIGZvbnRTdHlsZUNhY2hlQ291bnQgPSAwO1xuICAgICAgICBmb250U3R5bGVDYWNoZSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgc3R5bGUgPSBmb250RWwuc3R5bGU7XG4gICAgICB2YXIgZm9udEZhbWlseTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc3R5bGUuZm9udCA9IGZvbnRTdHJpbmc7XG4gICAgICAgIGZvbnRGYW1pbHkgPSBzdHlsZS5mb250RmFtaWx5LnNwbGl0KCcsJylbMF07XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICBmb250U3R5bGUgPSB7XG4gICAgICAgIHN0eWxlOiBzdHlsZS5mb250U3R5bGUgfHwgREVGQVVMVF9TVFlMRV9OT1JNQUwsXG4gICAgICAgIHZhcmlhbnQ6IHN0eWxlLmZvbnRWYXJpYW50IHx8IERFRkFVTFRfU1RZTEVfTk9STUFMLFxuICAgICAgICB3ZWlnaHQ6IHN0eWxlLmZvbnRXZWlnaHQgfHwgREVGQVVMVF9TVFlMRV9OT1JNQUwsXG4gICAgICAgIHNpemU6IHBhcnNlRmxvYXQoc3R5bGUuZm9udFNpemUgfHwgMTIpIHwgMCxcbiAgICAgICAgZmFtaWx5OiBmb250RmFtaWx5IHx8ICdNaWNyb3NvZnQgWWFIZWknXG4gICAgICB9O1xuICAgICAgZm9udFN0eWxlQ2FjaGVbZm9udFN0cmluZ10gPSBmb250U3R5bGU7XG4gICAgICBmb250U3R5bGVDYWNoZUNvdW50Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvbnRTdHlsZTtcbiAgfTtcblxuICB2YXIgdGV4dE1lYXN1cmVFbDsgLy8gT3ZlcndyaXRlIG1lYXN1cmUgdGV4dCBtZXRob2RcblxuICB0ZXh0Q29udGFpbi4kb3ZlcnJpZGUoJ21lYXN1cmVUZXh0JywgZnVuY3Rpb24gKHRleHQsIHRleHRGb250KSB7XG4gICAgdmFyIGRvYyA9IHZtbENvcmUuZG9jO1xuXG4gICAgaWYgKCF0ZXh0TWVhc3VyZUVsKSB7XG4gICAgICB0ZXh0TWVhc3VyZUVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGV4dE1lYXN1cmVFbC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO3RvcDotMjAwMDBweDtsZWZ0OjA7JyArICdwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOm5vbmU7d2hpdGUtc3BhY2U6cHJlOyc7XG4gICAgICB2bWxDb3JlLmRvYy5ib2R5LmFwcGVuZENoaWxkKHRleHRNZWFzdXJlRWwpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0ZXh0TWVhc3VyZUVsLnN0eWxlLmZvbnQgPSB0ZXh0Rm9udDtcbiAgICB9IGNhdGNoIChleCkgey8vIElnbm9yZSBmYWlsdXJlcyB0byBzZXQgdG8gaW52YWxpZCBmb250LlxuICAgIH1cblxuICAgIHRleHRNZWFzdXJlRWwuaW5uZXJIVE1MID0gJyc7IC8vIERvbid0IHVzZSBpbm5lckhUTUwgb3IgaW5uZXJUZXh0IGJlY2F1c2UgdGhleSBhbGxvdyBtYXJrdXAvd2hpdGVzcGFjZS5cblxuICAgIHRleHRNZWFzdXJlRWwuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHRleHRNZWFzdXJlRWwub2Zmc2V0V2lkdGhcbiAgICB9O1xuICB9KTtcbiAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KCk7XG5cbiAgdmFyIGRyYXdSZWN0VGV4dCA9IGZ1bmN0aW9uICh2bWxSb290LCByZWN0LCB0ZXh0UmVjdCwgZnJvbVRleHRFbCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7XG4gICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0OyAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuXG4gICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcblxuICAgIGlmICghdGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ29udmVydCByaWNoIHRleHQgdG8gcGxhaW4gdGV4dC4gUmljaCB0ZXh0IGlzIG5vdCBzdXBwb3J0ZWQgaW5cbiAgICAvLyBJRTgtLCBidXQgdGFncyBpbiByaWNoIHRleHQgdGVtcGxhdGUgd2lsbCBiZSByZW1vdmVkLlxuXG5cbiAgICBpZiAoc3R5bGUucmljaCkge1xuICAgICAgdmFyIGNvbnRlbnRCbG9jayA9IHRleHRDb250YWluLnBhcnNlUmljaFRleHQodGV4dCwgc3R5bGUpO1xuICAgICAgdGV4dCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRCbG9jay5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW5zID0gY29udGVudEJsb2NrLmxpbmVzW2ldLnRva2VucztcbiAgICAgICAgdmFyIHRleHRMaW5lID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0ZXh0TGluZS5wdXNoKHRva2Vuc1tqXS50ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHQucHVzaCh0ZXh0TGluZS5qb2luKCcnKSk7XG4gICAgICB9XG5cbiAgICAgIHRleHQgPSB0ZXh0LmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIHZhciB4O1xuICAgIHZhciB5O1xuICAgIHZhciBhbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgICB2YXIgdmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduO1xuICAgIHZhciBmb250U3R5bGUgPSBnZXRGb250U3R5bGUoc3R5bGUuZm9udCk7IC8vIEZJWE1FIGVuY29kZUh0bWxBdHRyaWJ1dGUgP1xuXG4gICAgdmFyIGZvbnQgPSBmb250U3R5bGUuc3R5bGUgKyAnICcgKyBmb250U3R5bGUudmFyaWFudCArICcgJyArIGZvbnRTdHlsZS53ZWlnaHQgKyAnICcgKyBmb250U3R5bGUuc2l6ZSArICdweCBcIicgKyBmb250U3R5bGUuZmFtaWx5ICsgJ1wiJztcbiAgICB0ZXh0UmVjdCA9IHRleHRSZWN0IHx8IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdCh0ZXh0LCBmb250LCBhbGlnbiwgdmVydGljYWxBbGlnbik7IC8vIFRyYW5zZm9ybSByZWN0IHRvIHZpZXcgc3BhY2VcblxuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07IC8vIElnbm9yZSB0cmFuc2Zvcm0gZm9yIHRleHQgaW4gb3RoZXIgZWxlbWVudFxuXG4gICAgaWYgKG0gJiYgIWZyb21UZXh0RWwpIHtcbiAgICAgIHRtcFJlY3QuY29weShyZWN0KTtcbiAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0obSk7XG4gICAgICByZWN0ID0gdG1wUmVjdDtcbiAgICB9XG5cbiAgICBpZiAoIWZyb21UZXh0RWwpIHtcbiAgICAgIHZhciB0ZXh0UG9zaXRpb24gPSBzdHlsZS50ZXh0UG9zaXRpb247XG4gICAgICB2YXIgZGlzdGFuY2UgPSBzdHlsZS50ZXh0RGlzdGFuY2U7IC8vIFRleHQgcG9zaXRpb24gcmVwcmVzZW50ZWQgYnkgY29vcmRcblxuICAgICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgICAgeSA9IHJlY3QueSArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMV0sIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCAnbGVmdCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KHRleHRQb3NpdGlvbiwgcmVjdCwgZGlzdGFuY2UpO1xuICAgICAgICB4ID0gcmVzLng7XG4gICAgICAgIHkgPSByZXMueTsgLy8gRGVmYXVsdCBhbGlnbiBhbmQgYmFzZWxpbmUgd2hlbiBoYXMgdGV4dFBvc2l0aW9uXG5cbiAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCByZXMudGV4dEFsaWduO1xuICAgICAgICB2ZXJ0aWNhbEFsaWduID0gdmVydGljYWxBbGlnbiB8fCByZXMudGV4dFZlcnRpY2FsQWxpZ247XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSByZWN0Lng7XG4gICAgICB5ID0gcmVjdC55O1xuICAgIH1cblxuICAgIHggPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WCh4LCB0ZXh0UmVjdC53aWR0aCwgYWxpZ24pO1xuICAgIHkgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WSh5LCB0ZXh0UmVjdC5oZWlnaHQsIHZlcnRpY2FsQWxpZ24pOyAvLyBGb3JjZSBiYXNlbGluZSAnbWlkZGxlJ1xuXG4gICAgeSArPSB0ZXh0UmVjdC5oZWlnaHQgLyAyOyAvLyB2YXIgZm9udFNpemUgPSBmb250U3R5bGUuc2l6ZTtcbiAgICAvLyAxLjc1IGlzIGFuIGFyYml0cmFyeSBudW1iZXIsIGFzIHRoZXJlIGlzIG5vIGluZm8gYWJvdXQgdGhlIHRleHQgYmFzZWxpbmVcbiAgICAvLyBzd2l0Y2ggKGJhc2VsaW5lKSB7XG4gICAgLy8gY2FzZSAnaGFuZ2luZyc6XG4gICAgLy8gY2FzZSAndG9wJzpcbiAgICAvLyAgICAgeSArPSBmb250U2l6ZSAvIDEuNzU7XG4gICAgLy8gICAgIGJyZWFrO1xuICAgIC8vICAgICBjYXNlICdtaWRkbGUnOlxuICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgLy8gICAgIGRlZmF1bHQ6XG4gICAgLy8gICAgIC8vIGNhc2UgbnVsbDpcbiAgICAvLyAgICAgLy8gY2FzZSAnYWxwaGFiZXRpYyc6XG4gICAgLy8gICAgIC8vIGNhc2UgJ2lkZW9ncmFwaGljJzpcbiAgICAvLyAgICAgLy8gY2FzZSAnYm90dG9tJzpcbiAgICAvLyAgICAgICAgIHkgLT0gZm9udFNpemUgLyAyLjI1O1xuICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgLy8gfVxuICAgIC8vIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAvLyAgICAgY2FzZSAnbGVmdCc6XG4gICAgLy8gICAgICAgICBicmVhaztcbiAgICAvLyAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAvLyAgICAgICAgIHggLT0gdGV4dFJlY3Qud2lkdGggLyAyO1xuICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgLy8gICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAvLyAgICAgICAgIHggLT0gdGV4dFJlY3Qud2lkdGg7XG4gICAgLy8gICAgICAgICBicmVhaztcbiAgICAvLyBjYXNlICdlbmQnOlxuICAgIC8vIGFsaWduID0gZWxlbWVudFN0eWxlLmRpcmVjdGlvbiA9PSAnbHRyJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgLy8gYnJlYWs7XG4gICAgLy8gY2FzZSAnc3RhcnQnOlxuICAgIC8vIGFsaWduID0gZWxlbWVudFN0eWxlLmRpcmVjdGlvbiA9PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgLy8gYnJlYWs7XG4gICAgLy8gZGVmYXVsdDpcbiAgICAvLyAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgLy8gfVxuXG4gICAgdmFyIGNyZWF0ZU5vZGUgPSB2bWxDb3JlLmNyZWF0ZU5vZGU7XG4gICAgdmFyIHRleHRWbWxFbCA9IHRoaXMuX3RleHRWbWxFbDtcbiAgICB2YXIgcGF0aEVsO1xuICAgIHZhciB0ZXh0UGF0aEVsO1xuICAgIHZhciBza2V3RWw7XG5cbiAgICBpZiAoIXRleHRWbWxFbCkge1xuICAgICAgdGV4dFZtbEVsID0gY3JlYXRlTm9kZSgnbGluZScpO1xuICAgICAgcGF0aEVsID0gY3JlYXRlTm9kZSgncGF0aCcpO1xuICAgICAgdGV4dFBhdGhFbCA9IGNyZWF0ZU5vZGUoJ3RleHRwYXRoJyk7XG4gICAgICBza2V3RWwgPSBjcmVhdGVOb2RlKCdza2V3Jyk7IC8vIEZJWE1FIFdoeSBoZXJlIGlzIG5vdCBjYW1tZWwgY2FzZVxuICAgICAgLy8gQWxpZ24gJ2NlbnRlcicgc2VlbXMgd3JvbmdcblxuICAgICAgdGV4dFBhdGhFbC5zdHlsZVsndi10ZXh0LWFsaWduJ10gPSAnbGVmdCc7XG4gICAgICBpbml0Um9vdEVsU3R5bGUodGV4dFZtbEVsKTtcbiAgICAgIHBhdGhFbC50ZXh0cGF0aG9rID0gdHJ1ZTtcbiAgICAgIHRleHRQYXRoRWwub24gPSB0cnVlO1xuICAgICAgdGV4dFZtbEVsLmZyb20gPSAnMCAwJztcbiAgICAgIHRleHRWbWxFbC50byA9ICcxMDAwIDAuMDUnO1xuICAgICAgYXBwZW5kKHRleHRWbWxFbCwgc2tld0VsKTtcbiAgICAgIGFwcGVuZCh0ZXh0Vm1sRWwsIHBhdGhFbCk7XG4gICAgICBhcHBlbmQodGV4dFZtbEVsLCB0ZXh0UGF0aEVsKTtcbiAgICAgIHRoaXMuX3RleHRWbWxFbCA9IHRleHRWbWxFbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8g6L+Z6YeM5piv5Zyo5YmN6Z2iIGFwcGVuZENoaWxkIOS/neivgemhuuW6j+eahOWJjeaPkOS4i1xuICAgICAgc2tld0VsID0gdGV4dFZtbEVsLmZpcnN0Q2hpbGQ7XG4gICAgICBwYXRoRWwgPSBza2V3RWwubmV4dFNpYmxpbmc7XG4gICAgICB0ZXh0UGF0aEVsID0gcGF0aEVsLm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjb29yZHMgPSBbeCwgeV07XG4gICAgdmFyIHRleHRWbWxFbFN0eWxlID0gdGV4dFZtbEVsLnN0eWxlOyAvLyBJZ25vcmUgdHJhbnNmb3JtIGZvciB0ZXh0IGluIG90aGVyIGVsZW1lbnRcblxuICAgIGlmIChtICYmIGZyb21UZXh0RWwpIHtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKGNvb3JkcywgY29vcmRzLCBtKTtcbiAgICAgIHNrZXdFbC5vbiA9IHRydWU7XG4gICAgICBza2V3RWwubWF0cml4ID0gbVswXS50b0ZpeGVkKDMpICsgY29tbWEgKyBtWzJdLnRvRml4ZWQoMykgKyBjb21tYSArIG1bMV0udG9GaXhlZCgzKSArIGNvbW1hICsgbVszXS50b0ZpeGVkKDMpICsgJywwLDAnOyAvLyBUZXh0IHBvc2l0aW9uXG5cbiAgICAgIHNrZXdFbC5vZmZzZXQgPSAocm91bmQoY29vcmRzWzBdKSB8fCAwKSArICcsJyArIChyb3VuZChjb29yZHNbMV0pIHx8IDApOyAvLyBMZWZ0IHRvcCBwb2ludCBhcyBvcmlnaW5cblxuICAgICAgc2tld0VsLm9yaWdpbiA9ICcwIDAnO1xuICAgICAgdGV4dFZtbEVsU3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgdGV4dFZtbEVsU3R5bGUudG9wID0gJzBweCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNrZXdFbC5vbiA9IGZhbHNlO1xuICAgICAgdGV4dFZtbEVsU3R5bGUubGVmdCA9IHJvdW5kKHgpICsgJ3B4JztcbiAgICAgIHRleHRWbWxFbFN0eWxlLnRvcCA9IHJvdW5kKHkpICsgJ3B4JztcbiAgICB9XG5cbiAgICB0ZXh0UGF0aEVsLnN0cmluZyA9IGVuY29kZUh0bWxBdHRyaWJ1dGUodGV4dCk7IC8vIFRPRE9cblxuICAgIHRyeSB7XG4gICAgICB0ZXh0UGF0aEVsLnN0eWxlLmZvbnQgPSBmb250O1xuICAgIH0gLy8gRXJyb3IgZm9udCBmb3JtYXRcbiAgICBjYXRjaCAoZSkge31cblxuICAgIHVwZGF0ZUZpbGxBbmRTdHJva2UodGV4dFZtbEVsLCAnZmlsbCcsIHtcbiAgICAgIGZpbGw6IHN0eWxlLnRleHRGaWxsLFxuICAgICAgb3BhY2l0eTogc3R5bGUub3BhY2l0eVxuICAgIH0sIHRoaXMpO1xuICAgIHVwZGF0ZUZpbGxBbmRTdHJva2UodGV4dFZtbEVsLCAnc3Ryb2tlJywge1xuICAgICAgc3Ryb2tlOiBzdHlsZS50ZXh0U3Ryb2tlLFxuICAgICAgb3BhY2l0eTogc3R5bGUub3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoOiBzdHlsZS5saW5lRGFzaFxuICAgIH0sIHRoaXMpO1xuICAgIHRleHRWbWxFbC5zdHlsZS56SW5kZXggPSBnZXRaSW5kZXgodGhpcy56bGV2ZWwsIHRoaXMueiwgdGhpcy56Mik7IC8vIEF0dGFjaGVkIHRvIHJvb3RcblxuICAgIGFwcGVuZCh2bWxSb290LCB0ZXh0Vm1sRWwpO1xuICB9O1xuXG4gIHZhciByZW1vdmVSZWN0VGV4dCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgcmVtb3ZlKHZtbFJvb3QsIHRoaXMuX3RleHRWbWxFbCk7XG4gICAgdGhpcy5fdGV4dFZtbEVsID0gbnVsbDtcbiAgfTtcblxuICB2YXIgYXBwZW5kUmVjdFRleHQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIGFwcGVuZCh2bWxSb290LCB0aGlzLl90ZXh0Vm1sRWwpO1xuICB9O1xuXG4gIHZhciBsaXN0ID0gW1JlY3RUZXh0LCBEaXNwbGF5YWJsZSwgWkltYWdlLCBQYXRoLCBUZXh0XTsgLy8gSW4gY2FzZSBEaXNwbGF5YWJsZSBoYXMgYmVlbiBtaXhlZCBpbiBSZWN0VGV4dFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm90byA9IGxpc3RbaV0ucHJvdG90eXBlO1xuICAgIHByb3RvLmRyYXdSZWN0VGV4dCA9IGRyYXdSZWN0VGV4dDtcbiAgICBwcm90by5yZW1vdmVSZWN0VGV4dCA9IHJlbW92ZVJlY3RUZXh0O1xuICAgIHByb3RvLmFwcGVuZFJlY3RUZXh0ID0gYXBwZW5kUmVjdFRleHQ7XG4gIH1cblxuICBUZXh0LnByb3RvdHlwZS5icnVzaFZNTCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHtcbiAgICAgICAgeDogc3R5bGUueCB8fCAwLFxuICAgICAgICB5OiBzdHlsZS55IHx8IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH0sIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCksIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH1cbiAgfTtcblxuICBUZXh0LnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgfTtcblxuICBUZXh0LnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgdGhpcy5hcHBlbmRSZWN0VGV4dCh2bWxSb290KTtcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvdm1sL2dyYXBoaWMuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZW52ID0gcmVxdWlyZShcIi4uL2NvcmUvZW52XCIpO1xuXG52YXIgdXJuID0gJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJztcbnZhciB3aW4gPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7XG52YXIgdm1sSW5pdGVkID0gZmFsc2U7XG52YXIgZG9jID0gd2luICYmIHdpbi5kb2N1bWVudDtcblxuZnVuY3Rpb24gY3JlYXRlTm9kZSh0YWdOYW1lKSB7XG4gIHJldHVybiBkb0NyZWF0ZU5vZGUodGFnTmFtZSk7XG59IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cblxudmFyIGRvQ3JlYXRlTm9kZTtcblxuaWYgKGRvYyAmJiAhZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICB0cnkge1xuICAgICFkb2MubmFtZXNwYWNlcy56cnZtbCAmJiBkb2MubmFtZXNwYWNlcy5hZGQoJ3pydm1sJywgdXJuKTtcblxuICAgIGRvQ3JlYXRlTm9kZSA9IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQoJzx6cnZtbDonICsgdGFnTmFtZSArICcgY2xhc3M9XCJ6cnZtbFwiPicpO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkb0NyZWF0ZU5vZGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KCc8JyArIHRhZ05hbWUgKyAnIHhtbG5zPVwiJyArIHVybiArICdcIiBjbGFzcz1cInpydm1sXCI+Jyk7XG4gICAgfTtcbiAgfVxufSAvLyBGcm9tIHJhcGhhZWxcblxuXG5mdW5jdGlvbiBpbml0Vk1MKCkge1xuICBpZiAodm1sSW5pdGVkIHx8ICFkb2MpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2bWxJbml0ZWQgPSB0cnVlO1xuICB2YXIgc3R5bGVTaGVldHMgPSBkb2Muc3R5bGVTaGVldHM7XG5cbiAgaWYgKHN0eWxlU2hlZXRzLmxlbmd0aCA8IDMxKSB7XG4gICAgZG9jLmNyZWF0ZVN0eWxlU2hlZXQoKS5hZGRSdWxlKCcuenJ2bWwnLCAnYmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCknKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzExOTQlMjhWUy44NSUyOS5hc3B4XG4gICAgc3R5bGVTaGVldHNbMF0uYWRkUnVsZSgnLnpydm1sJywgJ2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpJyk7XG4gIH1cbn1cblxuZXhwb3J0cy5kb2MgPSBkb2M7XG5leHBvcnRzLmNyZWF0ZU5vZGUgPSBjcmVhdGVOb2RlO1xuZXhwb3J0cy5pbml0Vk1MID0gaW5pdFZNTDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvdm1sL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgenJMb2cgPSByZXF1aXJlKFwiLi4vY29yZS9sb2dcIik7XG5cbnZhciB2bWxDb3JlID0gcmVxdWlyZShcIi4vY29yZVwiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xuXG4vKipcbiAqIFZNTCBQYWludGVyLlxuICpcbiAqIEBtb2R1bGUgenJlbmRlci92bWwvUGFpbnRlclxuICovXG5mdW5jdGlvbiBwYXJzZUludDEwKHZhbCkge1xuICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci92bWwvUGFpbnRlclxuICovXG5cblxuZnVuY3Rpb24gVk1MUGFpbnRlcihyb290LCBzdG9yYWdlKSB7XG4gIHZtbENvcmUuaW5pdFZNTCgpO1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICB2YXIgdm1sVmlld3BvcnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHZtbFJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdm1sVmlld3BvcnQuc3R5bGUuY3NzVGV4dCA9ICdkaXNwbGF5OmlubGluZS1ibG9jaztvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MzAwcHg7aGVpZ2h0OjE1MHB4Oyc7XG4gIHZtbFJvb3Quc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7JztcbiAgcm9vdC5hcHBlbmRDaGlsZCh2bWxWaWV3cG9ydCk7XG4gIHRoaXMuX3ZtbFJvb3QgPSB2bWxSb290O1xuICB0aGlzLl92bWxWaWV3cG9ydCA9IHZtbFZpZXdwb3J0O1xuICB0aGlzLnJlc2l6ZSgpOyAvLyBNb2RpZnkgc3RvcmFnZVxuXG4gIHZhciBvbGREZWxGcm9tU3RvcmFnZSA9IHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2U7XG4gIHZhciBvbGRBZGRUb1N0b3JhZ2UgPSBzdG9yYWdlLmFkZFRvU3RvcmFnZTtcblxuICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgb2xkRGVsRnJvbVN0b3JhZ2UuY2FsbChzdG9yYWdlLCBlbCk7XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLm9uUmVtb3ZlICYmIGVsLm9uUmVtb3ZlKHZtbFJvb3QpO1xuICAgIH1cbiAgfTtcblxuICBzdG9yYWdlLmFkZFRvU3RvcmFnZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIC8vIERpc3BsYXlhYmxlIGFscmVhZHkgaGFzIGEgdm1sIG5vZGVcbiAgICBlbC5vbkFkZCAmJiBlbC5vbkFkZCh2bWxSb290KTtcbiAgICBvbGRBZGRUb1N0b3JhZ2UuY2FsbChzdG9yYWdlLCBlbCk7XG4gIH07XG5cbiAgdGhpcy5fZmlyc3RQYWludCA9IHRydWU7XG59XG5cblZNTFBhaW50ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVk1MUGFpbnRlcixcbiAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAndm1sJztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTERpdkVsZW1lbnR9XG4gICAqL1xuICBnZXRWaWV3cG9ydFJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdm1sVmlld3BvcnQ7XG4gIH0sXG4gIGdldFZpZXdwb3J0Um9vdE9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aWV3cG9ydFJvb3QgPSB0aGlzLmdldFZpZXdwb3J0Um9vdCgpO1xuXG4gICAgaWYgKHZpZXdwb3J0Um9vdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0TGVmdDogdmlld3BvcnRSb290Lm9mZnNldExlZnQgfHwgMCxcbiAgICAgICAgb2Zmc2V0VG9wOiB2aWV3cG9ydFJvb3Qub2Zmc2V0VG9wIHx8IDBcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDliLfmlrBcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlLCB0cnVlKTtcblxuICAgIHRoaXMuX3BhaW50TGlzdChsaXN0KTtcbiAgfSxcbiAgX3BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QpIHtcbiAgICB2YXIgdm1sUm9vdCA9IHRoaXMuX3ZtbFJvb3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbCA9IGxpc3RbaV07XG5cbiAgICAgIGlmIChlbC5pbnZpc2libGUgfHwgZWwuaWdub3JlKSB7XG4gICAgICAgIGlmICghZWwuX19hbHJlYWR5Tm90VmlzaWJsZSkge1xuICAgICAgICAgIGVsLm9uUmVtb3ZlKHZtbFJvb3QpO1xuICAgICAgICB9IC8vIFNldCBhcyBhbHJlYWR5IGludmlzaWJsZVxuXG5cbiAgICAgICAgZWwuX19hbHJlYWR5Tm90VmlzaWJsZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWwuX19hbHJlYWR5Tm90VmlzaWJsZSkge1xuICAgICAgICAgIGVsLm9uQWRkKHZtbFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuX19hbHJlYWR5Tm90VmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChlbC5fX2RpcnR5KSB7XG4gICAgICAgICAgZWwuYmVmb3JlQnJ1c2ggJiYgZWwuYmVmb3JlQnJ1c2goKTtcbiAgICAgICAgICAoZWwuYnJ1c2hWTUwgfHwgZWwuYnJ1c2gpLmNhbGwoZWwsIHZtbFJvb3QpO1xuICAgICAgICAgIGVsLmFmdGVyQnJ1c2ggJiYgZWwuYWZ0ZXJCcnVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZmlyc3RQYWludCkge1xuICAgICAgLy8gRGV0YWNoZWQgZnJvbSBkb2N1bWVudCBhdCBmaXJzdCB0aW1lXG4gICAgICAvLyB0byBhdm9pZCBwYWdlIHJlZnJlc2hpbmcgdG9vIG1hbnkgdGltZXNcbiAgICAgIC8vIEZJWE1FIOWmguaenOavj+asoemDveWFiCByZW1vdmVDaGlsZCDlj6/og73kvJrlr7zoh7TkuIDkupvloavlhYXlkozmj4/ovrnnmoTmlYjmnpzmlLnlj5hcbiAgICAgIHRoaXMuX3ZtbFZpZXdwb3J0LmFwcGVuZENoaWxkKHZtbFJvb3QpO1xuXG4gICAgICB0aGlzLl9maXJzdFBhaW50ID0gZmFsc2U7XG4gICAgfVxuICB9LFxuICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHdpZHRoID0gd2lkdGggPT0gbnVsbCA/IHRoaXMuX2dldFdpZHRoKCkgOiB3aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gaGVpZ2h0ID09IG51bGwgPyB0aGlzLl9nZXRIZWlnaHQoKSA6IGhlaWdodDtcblxuICAgIGlmICh0aGlzLl93aWR0aCAhPSB3aWR0aCB8fCB0aGlzLl9oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdmFyIHZtbFZpZXdwb3J0U3R5bGUgPSB0aGlzLl92bWxWaWV3cG9ydC5zdHlsZTtcbiAgICAgIHZtbFZpZXdwb3J0U3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICB2bWxWaWV3cG9ydFN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgfVxuICB9LFxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yb290LmlubmVySFRNTCA9ICcnO1xuICAgIHRoaXMuX3ZtbFJvb3QgPSB0aGlzLl92bWxWaWV3cG9ydCA9IHRoaXMuc3RvcmFnZSA9IG51bGw7XG4gIH0sXG4gIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9LFxuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICB9LFxuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl92bWxWaWV3cG9ydCkge1xuICAgICAgdGhpcy5yb290LnJlbW92ZUNoaWxkKHRoaXMuX3ZtbFZpZXdwb3J0KTtcbiAgICB9XG4gIH0sXG4gIF9nZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgIHZhciBzdGwgPSByb290LmN1cnJlbnRTdHlsZTtcbiAgICByZXR1cm4gKHJvb3QuY2xpZW50V2lkdGggfHwgcGFyc2VJbnQxMChzdGwud2lkdGgpKSAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdMZWZ0KSAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdSaWdodCkgfCAwO1xuICB9LFxuICBfZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgdmFyIHN0bCA9IHJvb3QuY3VycmVudFN0eWxlO1xuICAgIHJldHVybiAocm9vdC5jbGllbnRIZWlnaHQgfHwgcGFyc2VJbnQxMChzdGwuaGVpZ2h0KSkgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nVG9wKSAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdCb3R0b20pIHwgMDtcbiAgfVxufTsgLy8gTm90IHN1cHBvcnRlZCBtZXRob2RzXG5cbmZ1bmN0aW9uIGNyZWF0ZU1ldGhvZE5vdFN1cHBvcnQobWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgenJMb2coJ0luIElFOC4wIFZNTCBtb2RlIHBhaW50ZXIgbm90IHN1cHBvcnQgbWV0aG9kIFwiJyArIG1ldGhvZCArICdcIicpO1xuICB9O1xufSAvLyBVbnN1cHBvcnRlZCBtZXRob2RzXG5cblxuZWFjaChbJ2dldExheWVyJywgJ2luc2VydExheWVyJywgJ2VhY2hMYXllcicsICdlYWNoQnVpbHRpbkxheWVyJywgJ2VhY2hPdGhlckxheWVyJywgJ2dldExheWVycycsICdtb2RMYXllcicsICdkZWxMYXllcicsICdjbGVhckxheWVyJywgJ3RvRGF0YVVSTCcsICdwYXRoVG9JbWFnZSddLCBmdW5jdGlvbiAobmFtZSkge1xuICBWTUxQYWludGVyLnByb3RvdHlwZVtuYW1lXSA9IGNyZWF0ZU1ldGhvZE5vdFN1cHBvcnQobmFtZSk7XG59KTtcbnZhciBfZGVmYXVsdCA9IFZNTFBhaW50ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi92bWwvUGFpbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=