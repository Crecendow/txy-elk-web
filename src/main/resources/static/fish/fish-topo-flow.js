(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["fishTopoFlow"] = factory();
	else
		root["fishTopoFlow"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Export fishTopo as CommonJS module
	 */
	module.exports = __webpack_require__(2);
	//兼容IE8 引入VML 如果不需要兼容IE8请删除
	__webpack_require__(137);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * fishtopo流程实例
	 * @class fish.topo.FishTopoFlow
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *      var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 */
	
	/**
	 * @event click
	 * 节点或者线段的click事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          this.fishTopo.on("click", function(event) {
	 *              console.log("点击的是：" + event.target.model.get('elementType'));
	 *          });
	 */
	
	/**
	 * @event dblclick
	 * 节点或者线段的双击事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          this.fishTopo.on("dblclick", function(event) {
	 *              console.log("双击的是：" + event.target.model.get('elementType'));
	 *          });
	 */
	
	/**
	 * @event create
	 * 节点与线段创建完毕的事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          this.fishTopo.on("create", function(e) {
	 *               if (me.fishTopo.Flow.isLink(e.target.model)) {
	 *                  console.log("线段创建完毕：" + e.target.model);
	 *               }
	 *          });
	 */
	
	/**
	 * @event delete
	 * 节点与线段创建完毕的事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          //节点删除完毕事件
	 *          this.fishTopo.on("delete", function(event) {
	 *              console.log("删除的是：" + event.target.model.get('elementType'));
	 *          });
	 */
	
	/**
	 * @event dropDrag
	 * 节点移动完成的事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          //节点移动结束事件
	            this.fishTopo.on("dropDrag", function(event) {
	                console.log("移动的节点是："+event.target.model.get('elementType'));
	            });
	 */
	
	
	
	
	    __webpack_require__(3);
	    var graphic = __webpack_require__(4);
	    var Minimap = __webpack_require__(64);
	    var util = __webpack_require__(65);
	    var Point = __webpack_require__(66);
	    var ExtensionAPI = __webpack_require__(68);
	    var Eventful = __webpack_require__(12);
	    var zrender = __webpack_require__(69);
	    var zrUtil = __webpack_require__(5);
	    var OperationNode = __webpack_require__(80);
	    var FlowConnectionManager = __webpack_require__(90);
	    var FlowUtil = __webpack_require__(94);
	    var Constants = __webpack_require__(93);
	    var Model = __webpack_require__(87);
	    var eventTool = __webpack_require__(77);
	    var Connector = __webpack_require__(82);
	    var LineOperationManager = __webpack_require__(123);
	    var Flow = __webpack_require__(119);
	    var flowNode = __webpack_require__(96);
	    var GroupNode = __webpack_require__(95);
	    var flowLink = __webpack_require__(117);
	    var layout = __webpack_require__(124);
	    var textContain = __webpack_require__(26);
	    var ImagePool = __webpack_require__(132);
	    var ToolTipView = __webpack_require__(133);
	    var TooltipModel = __webpack_require__(136);
	    var actions = {};
	    var keyCode = {ENTER:13, ESCAPE:27}
	    function FishTopoFlow(dom, opts) {
	        this.id;
	        this.group = null;
	        this._dom = dom;
	        this.nowZoom = 1;
	        this.canScale = true;
	        this.eagleEye = false;
	        this.eagleEyeNode = null;
	        this.initScaleRatio = 1;
	        this.operationNode = null;
	        this.step = 0;//前进后退计步数
	        this.stepJson = [];//存放每步的json
	        this.selectedNode = null;
	        this.allNodes = [];
	        this.minimap = null;
	        this._api = new ExtensionAPI(this);
	        this.connectionManager = new FlowConnectionManager(this._api);
	        this.lineOperationManager = new LineOperationManager(this.connectionManager,this._api);
	        this._zr = zrender.init(dom, {
	            renderer: opts.renderer || 'canvas',
	            devicePixelRatio: opts.devicePixelRatio
	        });
	        this._tooltipView = new ToolTipView(new TooltipModel(opts.tooltip),this._api);
	        this.Shape = graphic;
	        this.lineOpt = {};  //初始的线段配置信息
	        this.selectedNodes = [];
	        this.model = new Model({});
	        this.model.set(Constants.ELEMENT_TYPE, "scene");
	        this.model.set(Constants.MODE, "normal");
	        this.options = opts;
	        this.cursorMap = {
	            tl: 'nw-resize',
	            tr: 'ne-resize',
	            bl: 'sw-resize',
	            br: 'se-resize',
	            mtr:'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAAYFBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD6T+iNAAAAH3RSTlMA7sUMoYXnEkYYzaaTjQiAQCweBcG7fvnULh2ZdjMy6Fzd7wAAALJJREFUGNN1kFkOwzAIBQHvW/Y6Sbfc/5Y1ltqoljIf2BohBA8qU096xeV5L/+uFH4SpsGAGSKmThCyMz64Ud38Te0meIpHcTP1ndTKvqzSUuQILFMQJAUwIngBLCd0UrJhSRGqzHHU3FcHBVMokqxS38YNGQLQbhmgZZ23sVEXnXVmS467Fq0892SSLaW5SHrN9rz9bXv9EHIB+E9pdMG7Ys48Z2cjxo7FL3k8kPIE13wAmEUIO2ML9YMAAAAASUVORK5CYII=) 10 10, auto'
	        }; // 节点控制点鼠标信息(上左，上右，下左，下右，旋转)
	        this.cursorMaps = [
	            'n-resize',
	            'ne-resize',
	            'e-resize',
	            'se-resize',
	            's-resize',
	            'sw-resize',
	            'w-resize',
	            'nw-resize'
	        ]
	        this.cursorOffset = {
	            tr: 1,
	            br: 3,
	            bl: 5,
	            tl: 7
	        }
	        Eventful.call(this);
	    }
	
	    var fishTopoProto = FishTopoFlow.prototype;
	
	    /**
	     * 获取 fishTopo 实例容器的 dom 节点
	     * @return {HTMLElement}
	     */
	    fishTopoProto.getDom = function () {
	        return this._dom;
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.getZr = function () {
	        return this._zr;
	    };
	    /**
	     * 获取 fishTopo 实例容器的宽度。
	     * @return {number}
	     */
	    fishTopoProto.getWidth = function () {
	        return this._zr.getWidth();
	    };
	
	    /**
	     * 获取 fishTopo 实例容器的高度。
	     * @return {number}
	     */
	    fishTopoProto.getHeight = function () {
	        return this._zr.getHeight();
	    };
	
	
	    /**
	     * 当前实例是否已经被释放。
	     * @return {boolean}
	     */
	    fishTopoProto.isDisposed = function () {
	        return this._disposed;
	    };
	
	    /**
	     * 释放 当前实例
	     */
	    fishTopoProto.dispose = function () {
	        this._disposed = true;
	
	        this._zr.dispose();
	
	        instances[this.id] = null;
	    };
	
	
	    /**
	     * 调整尺寸  在窗口大小发生改变时需要手工调用
	     * @param {number} width 宽度
	     * @param {number} height 高度
	     */
	    fishTopoProto.resize = function () {
	        this._zr.resize();
	
	    };
	
	    fishTopoProto.dispatchAction = function (payload) {
	        if(!actions[payload.type]) {
	            return;
	        }
	    }
	
	    /**
	     * @method option
	     * 修改画布的选项
	     * @param {String} key 键  如：roam linkModify  textEditable等
	     * @param {Boolean|String|Function} value 选项值
	     */
	    fishTopoProto.option = function(key,value) {
	        var model = new Model(this.options);
	        if (arguments.length === 0) {
	            return zrUtil.clone(this.options);
	        } else if (arguments.length === 1) {
	            return model.get(key);
	        } else if (arguments.length === 2) {
	            if (key === "roam") {
	                this.setRoam(value);
	            }
	            return model.set(key,value);
	        }
	    }
	
	
	    fishTopoProto.init = function () {
	        var that = this;
	        var MOUSE_EVENT_NAMES = 'ontouchstart' in window ? ['touchstart', 'touchmove', 'touchend'] : ['mousedown', 'mousemove', 'mouseup'];
	        this.group = new graphic.Group();
	        this.group.model = this.model;
	        this.group.isBg = true;
	        this._zr.add(this.group);
	
	        //是否允许鼠标滚轮放大缩小
	        if (this.options.roam === true) {
	            this.zrScale();
	        }
	
	        this.connectionManager.connectors = [];
	        //mouseup 会在各个node或线的click事件之点执行  在选中节点或线前 先清空选中效果
	        this._zr.on("mouseup", function (e) { // clearSelect
	            // 1. 清空节点的选中效果
	            // this._removeOperationNode();
	            // 2. 点击的线 ，则直接返回
	            var shape = e.target;
	            if (shape && shape.model && Flow.isLink(shape.model)) {
	                return;
	            }
	            if (shape && shape.connector instanceof Connector) {
	                return;
	            }
	            // 3. 清空连接线
	            this.connectionManager.clearSelectCon();
	            // 4. 点击的是线上操作按钮，则直接返回
	            if (shape && shape._isLineOperationIcon && shape._isLineOperationIcon == true) {
	                return;
	            }
	            // 5.隐藏线上操作图标
	            this.lineOperationManager.hideAllLineOperation();
	        }.bind(this));
	
	        this._zr.on("click", function (e) {
	            // 如果点击了控制点，则不会取消选中状态(控制点不在节点范围内)
	            var target = e.target || {};
	            var type = target.type;
	            if (type !== 'ConnectControlLine' && type !== 'ConnectControl') {
	                this.hideConnectorPoint();
	                this.hideConnectorControl();
	                this._removeOperationNode();
	                var nodeTarget = e.target;
	                var shape;
	                if (nodeTarget) {
	                    shape = nodeTarget.model;
	                }
	                if ((nodeTarget && shape && Flow.isLink(shape)) || (nodeTarget && shape && Flow.isNode(
	                        shape))) {
	                    return;
	                }
	            }
	            var params = {};
	            params.event = e;
	            params.type = "click";
	            params.target = this;
	            this._api.trigger(params.type, params);
	        }.bind(this));
	
	        // mouseMode统一在mousedown事件里判断
	        this._zr.on("mousedown", function (e) {
	            if (this.options.mouseMode === 'drag-select') {
	                if ((e.target && e.target.model) ||
	                    (e.target && e.target.lineType && e.target.parent) ||
	                    (e.target && e.target.connector instanceof Connector) ||
	                    (e.target && e.target instanceof graphic.Circle) ||
	                    (e.target && e.target.name === "GROUP_RECT_NAME")) {
	                    return;
	                } else {
	                    this.hideConnectorPoint();
	                    this.hideConnectorControl();
	                    this._removeOperationNode();
	                    this._dragSelect(e.target, e.offsetX, e.offsetY);
	                }
	            }
	
	            if (this.options.mouseMode === 'drag-move') {
	                if ((e.target && e.target.model) || (e.target && e.target.lineType && e.target.parent) ||
	                    (e.target && e.target.connector instanceof Connector) || (e.target && e.target instanceof graphic
	                        .Circle)) {
	                    return;
	                } else {
	                    this._groupDragHandler(e.offsetX, e.offsetY);
	                }
	            }
	        }.bind(this));
	
	        this.on('conPointsGroup:click', function (argument) {
	            this.lineOperationManager.bindOperation(argument.lineNode);
	        }.bind(this));
	
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            this._zr.on(eveName, function (e) {
	                if (that.judgeIfReadMode()) {
	                    return;
	                }
	                var params = {};
	                params.event = e;
	                params.type = eveName;
	                params.target = this;
	                this._api.trigger(params.type, params);
	            }, this);
	        }, this);
	    };
	
	    fishTopoProto.setRoam = function (value) {
	        this._zr.off("mousewheel");//禁止用户缩放画布
	        if (value === true) {
	            this.zrScale();
	        }
	    }
	
	    fishTopoProto.addGroupModel = function (groupNode) {
	        var that = this;
	        groupNode.eachChild(function (node) {
	            if (node.model) {
	                if (node instanceof GroupNode) {
	                    if (node.model && !node.model.option.childs && node.children().length > 0) {
	                        var childs = [];
	                        node.eachChild(function (childNode) {
	                            if (childNode.model) {
	                                if (childNode instanceof GroupNode) {
	                                    if (!childNode.model.option.childs && childNode.children().length > 0) {
	                                        that.addGroupModel(node);
	                                    }
	                                }
	                                childs.push(childNode.model.option);
	                                node.model.option.childs = childs;
	                            }
	                        })
	                    }
	                }
	            }
	        });
	    }
	
	    /**
	     * @method toJson
	     * 导出json
	     * @return {Object} json对象
	     */
	    fishTopoProto.toJson = function () {
	        this.addGroupModel(this.group);
	        return FlowUtil.toJson(this.model, this.group);
	    }
	
	    /**
	     * @method fromJson
	     * 导入json
	     * @param  {Object} json对象
	     * @param {Boolean} isNoCount 是否需要step计数，默认是需要计数
	     */
	    fishTopoProto.fromJson = function (json, isNoCount) {
	        this.clear(true);
	        var model = new Model(json);
	        this.setBackground(model.get(Constants.BACKGROUND));
	        var layoutRootNode = [];
	        FlowUtil.fromJson(this, this.group, model.get(Constants.CHILDS), false, layoutRootNode, isNoCount);
	        // for (var i = 0; i < layoutRootNode.length; i++) {
	        //     this.layoutNode("tree", {
	        //         "node": layoutRootNode[i],
	        //         "type": layoutRootNode[i].treeType
	        //     });
	        // }
	    };
	    /**
	     * 递归初始化组节点的事件
	     * @method addGroupNodeEvent
	     * @param {Object} node group节点对象
	     */
	    fishTopoProto.addGroupNodeEvent = function(node) {
	        var that = this;
	        if (Flow.isGroupNode(node)) {
	            node.willRender(this._api);
	            var groupOptions = node.model.get(Constants.OPTIONS);
	            if (groupOptions.mergedImage) {
	                var styleObj = {
	                    image: groupOptions.mergedImage
	                };
	                if (groupOptions.style && groupOptions.style.text) {
	                    styleObj.text = groupOptions.style.text;
	                    styleObj.textPosition = 'bottom';
	                }
	                styleObj.width = 30;
	                styleObj.height = 30;
	                var groupReplaceImage = new flowNode.Image({
	                    name: 'GROUP_RELATION_IMAGE',
	                    relatedGroupId: node.id,
	                    style: styleObj,
	                    z: node.z || 4,
	                    position: [-5000, -5000]
	                });
	                this.drag(groupReplaceImage);
	                node._relationImage = groupReplaceImage;
	                this.group.add(groupReplaceImage);
	                setTimeout(function () {
	                    groupReplaceImage.hide();
	                }, 300);
	                node.on('dblclick', function (e) {
	                    e.cancelBubble = true;
	                    // 去除选中状态
	                    that.hideConnectorPoint();
	                    that.hideConnectorControl();
	                    that._removeOperationNode();
	                    // 去除组节点相关的连线
	                    that.toggleAllConNodeLine(node, 'hide');
	                    node.merged(that);
	                })
	            }
	            //遍历组中所有节点
	            node.each(function (child) {
	                if (Flow.isGroupNode(child)) {
	                    this.addGroupNodeEvent(child)
	                } else {
	                    this._addGroupNode(node,child);
	                }
	            }, this);
	        }
	        this.addNodeAttrEvent(node, true);
	    }
	    /**
	     * 添加节点或线段到画布 同add方法
	     * @method addNode
	     * @param {Object} node createNode或createLink返回的对象
	     * @param {Object} [option] 参数对象
	     * @param {Boolean} [option.trigger] 是否触发 beforeCreate事件
	     * @returns {Object} 返回添加成功的节点 ，如被用户取消之类则 返回null
	     */
	    /**
	     * 添加节点或线段到画布 同addNode方法
	     * @method add
	     * @param {Object} node createNode或createLink返回的对象
	     * @param {Object} [option] 参数对象
	     * @param {Boolean} isNoCount 是否需要step计数，默认是需要计数
	     * @param {Boolean} [option.trigger] 是否触发 beforeCreate事件
	     * @returns {Object} 返回添加成功的节点 ，如被用户取消之类则 返回null
	     */
	    fishTopoProto.add = fishTopoProto.addNode = function (node, options, isNoCount) {
	        if (!node) return null;
	        var opt = options || {};
	        if(opt.trigger !==false && (!this._trigger('beforeCreate', {target:node}))) {
	            return null;
	        }
	        if (node instanceof Connector) {
	            this.addConnectorAttrEvent(node);
	        } else {
	            this.addGroupNodeEvent(node);
	        }
	        this._trigger("create", {target:node});
	
	        if (node.hoverStyle) {
	            graphic.setHoverStyle(node);
	        }
	
	        this.group.add(node);
	        if (node.relative) {  //必须在加入画布后执行
	            this._handleRelativePostion(node)
	        }
	        if (node.hoverAnimation && this.options.isAnimationEnabled) {
	            flowNode.addHoverAnimation(node);
	        }
	        if (isNoCount != true) {
	            this.stepCounter();
	        }
	        return node;
	    };
	
	
	    fishTopoProto._addGroupNode = function(groupNode, child){
	        if (child instanceof Connector) {
	            this.addConnectorAttrEvent(child);
	        } else {
	            this.addNodeAttrEvent(child, groupNode.options.childDraggable);
	            if (util.isUndefined(child.selectable)) {
	                child.selectable = false;  //组内默认不可选中
	            }
	            if (child.relative) {
	                this._handleRelativePostion(child)
	            }
	            if (child.hoverStyle) {
	                graphic.setHoverStyle(child);
	            }
	        }
	        this._trigger("create", {target:child});
	    };
	
	    /**
	     * 在链路连线上添加文本
	     * @method addTextOnChain
	     * @param {Object} line 链路连线对象
	     * @param {Object} [text] 数组类型，表示多个文本的数据。数组元素可以为字符串，表示每个文本的名字；也可以是个对象，对象中必须指定text属性，其值为文本的名字
	     * @returns {Object} 返回 链路连线对象
	     */
	    fishTopoProto.addTextOnChain = function (line, text) {
	        if (line.options.style.lineType === Connector.TYPE_CHAIN) {
	            this.connectionManager.removeLine(line, this._getParentZr(line));
	            line.options.text.text.push(text);
	            line.options.textContextMenu = line.opt.textContextMenu;   //不然左键菜单没有了！！！
	            var slink = new flowLink.Chain(line.startNode, line.endNode, line.options);
	            this.add(slink);
	            return slink;
	        }
	    }
	
	    /**
	     * 在链路连线上删除指定文本
	     * @method delTextOnChain
	     * @param {Object} txtObj 文本对象
	     * @returns {Object} 返回 链路连线对象
	     */
	    fishTopoProto.delTextOnChain = function (txtObj) {
	        var id = txtObj.id, line = txtObj.parent, pos;
	        if (line.options.style.lineType === Connector.TYPE_CHAIN && zrUtil.isArray(line.options.text.text)) {
	            line.options.text.text.forEach(function (v, i) {
	                if (v.textId === id) {
	                    pos = i;
	                }
	            });
	            line.options.text.text.splice(pos, 1);
	
	            this.connectionManager.removeLine(line, this._getParentZr(line));
	            line.options.textContextMenu = line.opt.textContextMenu;   //不然左键菜单没有了！！！
	            var slink = new flowLink.Chain(line.startNode, line.endNode, line.options);
	            this.add(slink);
	            return slink;
	        }
	    }
	    /**
	     * 在链路连线上修改指定文本
	     * @method delTextOnChain
	     * @param {Object} txtObj 文本对象
	     * @param {String} name 修改的文本
	     * @returns {Object} 返回 链路连线对象
	     */
	    fishTopoProto.modifyTextOnChain = function (txtObj, name) {
	        var id = txtObj.id, line = txtObj.parent;
	        if (line.options.style.lineType === Connector.TYPE_CHAIN && zrUtil.isArray(line.options.text.text)) {
	            line.options.text.text.forEach(function (v, i) {
	                if (v.textId === id) {
	                    v.text = name;
	                }
	            });
	            txtObj.setStyle("text", name);
	            txtObj.parent.refresh();
	        }
	    }
	    fishTopoProto.getparentIgnore = function(node) {
	        if (node.parent) {
	            if (node.parent.ignore === false) {
	                // 继续向上遍历
	                return this.getparentIgnore(node.parent);
	            }
	            return true;
	        }
	        return false;
	    }
	    /**
	     * 递归找出组内所有节点(包含组,relationImage,除GROUP_RECT_NAME外)
	     * @method toggleAllConGroupLine
	     * @param {Object} groupNode 组节点对象
	     * @param {Boolean} ifContainRelationImage 是否包含组节点的_relationImage
	     */
	    fishTopoProto.findGroupNodes = function (groupNode, ifContainRelationImage) {
	        var nodeList = [groupNode];
	        if (ifContainRelationImage && groupNode._relationImage) {
	            nodeList.push(groupNode._relationImage);
	        }
	        function findNodes(node) {
	            if (Flow.isGroupNode(node)) {
	                node._children.forEach(function(childNode) {
	                    if (childNode instanceof Connector || childNode.isIcon || childNode.name === 'GROUP_RECT_NAME') {
	                        // 不处理
	                    } else {
	                        nodeList.push(childNode);
	                        if (ifContainRelationImage && childNode._relationImage) {
	                            nodeList.push(childNode._relationImage);
	                        }
	                    }
	                    if (Flow.isGroupNode(childNode)) {
	                        findNodes(childNode);
	                    }
	                });
	            }
	        }
	        findNodes(groupNode);
	        return nodeList;
	    }
	    /**
	     * 显示隐藏指定节点的连线,父节点和_relationImage需单独做特殊处理
	     * @method toggleAllConNodeLine
	     * @param {Object} node 节点对象
	     * @param {String} type 显示还是隐藏 [hide|show]
	     */
	    fishTopoProto.toggleAllConNodeLine = function (node, type) {
	        var that = this;
	        var groupNodes = [];
	        var judgeFun;
	        if (Flow.isGroupNode(node)) {
	            groupNodes = this.findGroupNodes(node, true);
	            judgeFun = function(line, nodeType) {
	                if (type === 'hide') {
	                    line.hide();
	                }
	                if (type === 'show') {
	                    var currentNode = line[nodeType];
	                    if (currentNode.parent && that.getparentIgnore(currentNode)) {
	                        line.hide();
	                    } else if (Flow.isGroupNode(currentNode) && currentNode.ignore) {
	                        line.hide();
	                    } else if (currentNode.name === 'GROUP_RELATION_IMAGE') {
	                        var currentGroupNode = zrUtil.find(groupNodes, function(childNode) {
	                            return childNode.id === currentNode.relatedGroupId;
	                        });
	                        if (currentGroupNode && that.getparentIgnore(currentGroupNode)) {
	                            line.hide();
	                        } else {
	                            line.show();
	                        }
	                    } else {
	                        line.show();
	                    }
	                }
	            }
	        }
	        var allLine = this.connectionManager.connectors;
	        if (zrUtil.isArray(allLine)) {
	            allLine.forEach(function (line) {
	                if (Flow.isGroupNode(node) && groupNodes.length > 0) {
	                    // 跨组间的连线，只要满足起始点其中之一在组内就隐藏
	                    if (groupNodes.some(function(item) { return item.id === line.startNode.id})) {
	                        judgeFun(line, 'startNode')
	                    }
	                    if (groupNodes.some(function(item) { return item.id === line.endNode.id})) {
	                        judgeFun(line, 'endNode')
	                    }
	                } else {
	                    if (line.startNode.id === node.id || line.endNode.id === node.id) {
	                        type === 'hide' ? line.hide() : line.show();
	                    }
	                }
	            })
	        }
	    };
	
	    fishTopoProto.addConnectorAttrEvent = function (connector) {
	        var that = this;
	        var chainLine = null;
	        if (connector.options.style.lineType === Connector.TYPE_CHAIN) {
	            var key = this.connectionManager.getTwoNodeId(connector.startNode, connector.endNode, connector.options.position);
	            var cons = this.connectionManager.connectorMap.get(key);
	            var orignText = [].concat(connector.options.text.text);
	            if (cons.length > 0) {
	                cons.forEach(function (v) {
	                    if (v.options.style.lineType === Connector.TYPE_CHAIN) {
	                        orignText = orignText.concat(v.options.text.text);
	                        chainLine = v;
	                    }
	                });
	            }
	        }
	        //如果已存在链路
	        if (chainLine) {
	            connector.options.text.text = orignText;
	            this.connectionManager.removeLine(chainLine, this._getParentZr(chainLine));
	        }
	        connector.options.isEdit = !!this.options.linkModify;
	        // 处理线段两端的调整drag事件
	        this.createConnectorDragEvents(connector);
	        connector.on("mousedown", function () {
	            // 取消节点的选中
	            this.hideConnectorPoint();
	            this.hideConnectorControl();
	            this._removeOperationNode();
	            this.isNode = false;
	        }.bind(this));
	        this.connectionManager.add(connector);
	        this.connectionManager.connectorForbidEdit(!this.options.linkModify);
	        //支持双击编辑
	        connector.on("dblclick", function () {
	            if (typeof this.options.text.textEditable == "undefined") {
	                if (that.options.textEditable) {
	                    that.connectorEdit(this);
	                }
	            } else {
	                if (this.options.text.textEditable) {
	                    that.connectorEdit(this);
	                }
	            }
	        });
	    }
	
	    fishTopoProto.addNodeAttrEvent = function (node, childDraggable) {
	        var that = this;
	        if (childDraggable) {
	            this.drag(node);
	        }
	
	        node.attr("operationIcons", node.model.get('options.operationIcons'));
	
	        //侦听节点的click dblclick事件，选中，并派发出去
	        node.on('click', function (event) {
	            var targeNode = this;
	            if (that.judgeIfReadMode(targeNode) || (targeNode.style && targeNode.style.fill === 'none')) {
	                return;
	            }
	            that.nodeClickHandler(targeNode);
	            var params = {};
	            params.event = event;
	            params.type = 'click';
	            params.target = targeNode;
	            that._api.trigger(params.type, params);
	            event.cancelBubble = true;
	
	            // 判断一下是否是组内成组的点击事件，如果是的话，那组也也派发一下
	            if (Flow.isInGroup(targeNode)) {
	                var parentNode = targeNode.parent;
	                if (!parentNode.childDraggable) {
	                    parentNode.trigger('click', {event:event, type:'click',target:parentNode});
	                }
	            }
	        });
	        node.on('dblclick', function (e) {
	            var targeNode = this;
	            if (!targeNode.style || (typeof targeNode.style.textEditable == "undefined")) {
	                if (that.options.textEditable) {
	                    that.nodeEdit(targeNode);
	                }
	            } else {
	                if (targeNode.style.textEditable) {
	                    that.nodeEdit(targeNode);
	                }
	            }
	            var params = {};
	            params.event = e;
	            params.type = 'dblclick';
	            params.target = targeNode;
	            that._api.trigger(params.type, params);
	
	            e.cancelBubble = true;
	        });
	
	        this.allNodes.push(node);
	    }
	
	    fishTopoProto._handleRelativePostion = function(node) {
	        var parentEl = node.parent;
	        var containerInfo = parentEl === this.group
	            ? {
	                width:this._api.getWidth(),
	                height:this._api.getHeight()
	            }
	            : {
	                width:parentEl.getBoundingRect().width,
	                height:parentEl.getBoundingRect().height
	            }
	        layout.positionElement(node, node.relative, containerInfo, node.relative.padding, {boundingMode:node.relative.bounding||'all'});
	    }
	
	    fishTopoProto._getParentZr = function(node) {
	        var parentZr = null;
	        if (node && node.parent) {
	            parentZr = node.parent;
	        } else {
	            parentZr = this.group;
	        }
	        return parentZr;
	    }
	
	    fishTopoProto._removeOperationNode = function() {
	        if (this.operationNode) {
	            this.group.remove(this.operationNode);
	            this.operationNode.cleanup();
	            this.operationNode = null;
	        }
	    }
	
	    /**
	     * 清空当前实例，会移除实例中所有的节点与线
	     * @method clear
	     */
	    fishTopoProto.clear = function (isNoCount) {
	        for (var i = 0; i < this.allNodes.length; i++) {
	            var parentZr = this._getParentZr(this.allNodes[i]);
	            this.connectionManager.deleteSelectCon(this.allNodes[i], parentZr)
	        }
	        this.connectionManager.connectorMap.clear();
	        this.allNodes = [];
	        this.operationNode = null;
	        this.selectedNode = null;
	        this.dragSelectRect = null;
	        this.selectedNodes = [];
	        this.hideConnectorPoint();
	        this.hideConnectorControl();
	        this.connectionManager.connectors = [];
	        this._zr.clear();
	        this.group = new graphic.Group();
	        this.group.isBg = true;
	        this._zr.add(this.group);
	        if (isNoCount != true) {
	            this.stepCounter();
	        }
	    };
	
	    /**
	     * 创建连线的小图标操作
	     * @param {string} key 小图标的名称
	     * @param {Object} options 小图标的相关参数
	     * @param {String} [options.icon] 小图标路径
	     * @param {Object} [options.lineNode] 线段实例
	     * @param {Function} [options.callback] 点击后的回调
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *                  this.fishTopo.addIcon("icon1", {
	     *                      icon: "https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_ca79a146.png",
	     *                      lineNode: lineNode,
	     *                      callback: function(event) {
	     *                          alert(JSON.stringify(event.data))
	     *                      },
	     *                  });
	     */
	    fishTopoProto.addLineIcon = fishTopoProto.addIcon = function (key, options) {
	        this.lineOperationManager.addIcon(key, options);
	    };
	
	    /**
	     * 创建连线的默认删除操作
	     * @param  {Object} lineNode 线
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.lineDefaultIcon(lineNode);
	     */
	    fishTopoProto.lineDefaultIcon = function (lineNode) {
	        this.addLineDeleteIcon(lineNode);
	        this.addLineChangeIcon(lineNode);
	    };
	
	    /**
	     * 创建连线的默认删除操作
	     * @param  {Object} lineNode 线
	     * @param {Object} [options] 连线操作的选项
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.addLineChangeIcon(lineNode);
	     */
	    fishTopoProto.addLineDeleteIcon = function (lineNode,options) {
	        //创建删除
	        this.lineOperationManager.addDeleteIcon(lineNode,options);
	    };
	
	    /**
	     * 创建连线的默认切换类型操作
	     * @param  {Object} lineNode 线
	     * @param {Object} [options] 连线操作的选项
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.addLineChangeIcon(lineNode);
	     */
	    fishTopoProto.addLineChangeIcon = function (lineNode,options) {
	        this.lineOperationManager.addChangeLineTypeIcon(lineNode,options);
	    };
	
	    /**
	     * 变更当前线的类型，如果不传则按顺序取下一个类型。先删除原来的线段 再增加一种类型的线段
	     * @param {String} lineType 欲变更线的类型
	     */
	    fishTopoProto.changeSelectConnectorType = function(lineType) {
	        var nextLineType = lineType;
	        var line = this.connectionManager.selConnector;
	        var originLineType = line.options.style.lineType;
	        if (nextLineType) {
	            if (nextLineType == originLineType) {
	                return;
	            }
	        } else {
	            var arrLineType = [Connector.TYPE_STRAIGHT, Connector.TYPE_JAGGED, Connector.TYPE_CURVE];
	            var index = zrUtil.indexOf(arrLineType, originLineType);
	            nextLineType = arrLineType[(index + 1) % arrLineType.length];
	        }
	
	        //this.remove(line, {trigger:false}); 这样会删除icons
	        this.connectionManager.deleteLine(this._getParentZr(line));
	        this.lineOperationManager.hideAllLineOperation();
	
	        zrUtil.merge(line.options, { dockers: [] }, true);
	        zrUtil.merge(line.options.style, { lineType: nextLineType }, true);
	        var nextLine = this.createConnectorByNodes(line.startNode, line.endNode, line.options, false);
	        if (nextLine) {
	            nextLine.icons = line.icons;
	            nextLine.on('Connector:click', function () {
	                this.lineOperationManager.bindOperation(nextLine);
	            }.bind(this));
	        }
	    }
	
	    /**
	     * @private
	     * 根据point创建节点上的连接点
	     * @param {Object} point x，y坐标  {x:x, y:y}
	     * @param {String} pos x，y坐标 [right|left|top|bottom]
	     * @param {String} lineType x，y坐标 [straight|jagged|curve]
	     */
	    fishTopoProto.createConnectorPoint = function(point, pos, lineType) {
	        var me = this;
	        var pointInstance = new graphic.Circle({
	            shape: {
	                cx: point.x,
	                cy: point.y,
	                r: 4
	            },
	            style: {
	                fill: '#FFFF33',
	                stroke:'#000000'
	            },
	            z : 4,
	            cursor: 'crosshair',
	            draggable: true,
	            lineType: lineType
	        });
	        pointInstance.type = 'ConnectPoint';
	        pointInstance.pos = pos;                //记录是节点上哪个位置的连接点
	        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	            pointInstance.on(eveName, function(e) {
	                var params = {};
	                params.event = e;
	                params.type = "ConnectPoint:" + eveName;
	                me.group.trigger(params.type, params);
	            });
	        });
	        this.group.add(pointInstance);
	    }
	
	    /**
	     * @private
	     * 隐藏节点上的连接点
	     */
	    fishTopoProto.hideConnectorPoint = function() {
	        var that = this;
	        this.group.children().forEach(function (v) {
	            if (v.type === 'ConnectPoint') {
	                that.group.remove(v);
	            }
	        })
	        this.group.off("ConnectPoint:dragstart");
	        this.group.off("ConnectPoint:drag");
	        this.group.off("ConnectPoint:dragend");
	    }
	
	    /**
	     * @private
	     * 根据节点数组动态创建连接点
	     * @param  {Array} lineType 需要展示连接点的节点数组
	     * @param  {String} lineType 连线的线段类型 [straight|jagged|curve]
	     */
	    fishTopoProto.filterConnectPoint = function(targetNodes, lineType) {
	        if (this.judgeIfReadMode()) {
	            return;
	        }
	        if (!this.ifShowConnectorPoint()) {
	            return;
	        }
	        var that = this;
	        var groupNodes = []; // 记录组内节点
	        var outsideNodes = []; // 记录组外节点
	        var nodes = [];
	        if (targetNodes.length > 1) {
	            targetNodes.forEach(function(item) {
	                if (Flow.isGroupNode(item)) {
	                    nodes.push(item);
	                    groupNodes = groupNodes.concat(item.children());
	                } else {
	                    outsideNodes.push(item);
	                }
	            });
	            // 比较组内外节点，过滤组内节点
	            outsideNodes.forEach(function(item) {
	                if (!groupNodes.includes(item)) {
	                    nodes.push(item);
	                }
	            });
	        } else {
	            nodes = targetNodes;
	        }
	        nodes.forEach(function(item) {
	            if (!that.judgeIfReadMode(item) && that.ifShowConnectorPoint(item)) {
	                var rect = util.getRect(item);
	                if (item.parent && Flow.isGroupNode(item.parent)) {
	                    rect.boundingRect.x += Flow.parentX(item.parent);
	                    rect.boundingRect.y += Flow.parentY(item.parent);
	                }
	                var connectorPoint = util.getConnectorPoints(rect, item);
	                that.createConnectorPoint(connectorPoint.left, "left", lineType);
	                that.createConnectorPoint(connectorPoint.right, "right", lineType);
	                that.createConnectorPoint(connectorPoint.top, "top", lineType);
	                that.createConnectorPoint(connectorPoint.bottom, "bottom", lineType);
	            }
	        });
	    }
	
	    /**
	     * 在节点上显示连接点
	     * @param  {String} lineType 连线的线段类型 [straight|jagged|curve]
	     * @param {Object} [options] 连线的线段属性
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *       $('.btn-connect-jagged').click(function(e) {
	     *           fishTopo.showConnectorPoint("jagged", {
	     *               symbol: {
	     *                   // 箭头颜色
	     *                   color: "#BBBBBB"
	     *               },
	     *               style: {
	     *                   // 线条颜色
	     *                   stroke: "#BBBBBB",
	     *               }
	     *           });
	     *       });
	     */
	    fishTopoProto.showConnectorPoint = function(lineType, lineOpt, ifCurrentNode) {
	        var that = this;
	        this.hideConnectorPoint();
	        if (lineType) {
	            this.lineType = lineType; // 缓存线段类型
	        }
	        if (!this.lineType) {
	            this.lineType = 'jagged'; // 线段默认折线类型
	        }
	        if (lineOpt) {
	            this.lineOpt = lineOpt;  //缓存线段的配置信息
	        }
	        if (!ifCurrentNode) {
	            ifCurrentNode = false;
	        }
	        var targetNodes = ifCurrentNode ? [that.selectedNode] : that.allNodes;
	
	        if (!ifCurrentNode) {
	            // 所有节点连接点展示前，首先清除画布上的框选dragSelect
	            that._removeOperationNode();
	            that._releaseSelectNode();
	            that.hideConnectorControl();
	        }
	
	        // 让所有画布中的节点/当前节点显示连接点
	        this.filterConnectPoint(targetNodes, this.lineType);
	
	        // 根据连线点查找节点(考虑优化 创建连接点的时候 就把连接点与node进行绑定，就不用这个复杂的计算了)
	        function findConnectorNode(x, y, offset, pos) {
	            var node, endPos = null;
	            that.allNodes.forEach(function(item) {
	                var rect = util.getRect(item);
	                if (item.parent && Flow.isGroupNode(item.parent)) {
	                    rect.boundingRect.x += Flow.parentX(item.parent);
	                    rect.boundingRect.y += Flow.parentY(item.parent);
	                }
	                var connectorPoint = util.getConnectorPoints(rect, item);
	                if (pos) {
	                    if (Math.abs(connectorPoint[pos].x - x) <= offset && Math.abs(connectorPoint[pos].y - y) <= offset) {
	                        node = item;
	                    }
	                } else {
	                    if (Math.abs(connectorPoint["left"].x - x) <= offset && Math.abs(connectorPoint["left"].y - y) <= offset) {
	                        endPos = "left";
	                        node = item;
	                    } else if (Math.abs(connectorPoint["top"].x - x) <= offset && Math.abs(connectorPoint["top"].y - y) <= offset) {
	                        endPos = "top";
	                        node = item;
	                    } else if (Math.abs(connectorPoint["right"].x - x) <= offset && Math.abs(connectorPoint["right"].y - y) <= offset) {
	                        endPos = "right";
	                        node = item;
	                    } else if (Math.abs(connectorPoint["bottom"].x - x) <= offset && Math.abs(connectorPoint["bottom"].y - y) <= offset) {
	                        endPos = "bottom";
	                        node = item;
	                    }
	                }
	            });
	            return {
	                node: node,
	                endPos: endPos
	            };
	        }
	        this.group.on("ConnectPoint:dragstart", function(e) {
	            // 如果是当前节点显示连接点，需要在拖动剪头时让画布中的其他节点显示连接点
	            if (ifCurrentNode) {
	                that.filterConnectPoint(that.allNodes, that.lineType);
	            }
	            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;
	            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;
	            var arrow = e.event.target;
	            that.reverseConnect = false;   //是否反向连线的标识
	            that.startPos = arrow.pos;
	            that.selectConnNode = findConnectorNode(arrow.shape.cx, arrow.shape.cy, 0, that.startPos).node;
	            arrow.hide();
	            that.lineOperationManager.hideAllLineOperation();
	            that.originNode = null;
	            var point = new Point(x, y);
	            var connector = that.connectionManager.manageTempConnector(that.selectConnNode, point, arrow.lineType, that.startPos);
	            that.group.add(connector);
	        });
	        this.group.on("ConnectPoint:drag", function(e) {
	            var arrow = e.event.target;
	            that._handleLineDrag('drag', e, arrow.lineType);
	        });
	        this.group.on("ConnectPoint:dragend", function(e) {
	            var arrow = e.event.target;
	            that._handleLineDrag('dragend', e, arrow.lineType);
	            arrow.show();
	            arrow.position = [0, 0];
	        });
	    }
	    fishTopoProto.createLineConnectorPoint = function(point, pos, lineType) {
	        var pointInstance = new graphic.Circle({
	            shape: {
	                cx: point.x,
	                cy: point.y,
	                r: 4
	            },
	            style: {
	                fill: '#FFFF33',
	                stroke:'#000000'
	            },
	            z : 4,
	            draggable: true,
	            lineType: lineType
	        });
	        pointInstance.type = 'ConnectPoint';
	        pointInstance.pos = pos;                //记录是节点上哪个位置的连接点
	        this.group.add(pointInstance);
	    }
	
	    fishTopoProto.getRotatedCornerCursor = function(node, pos) {
	        var that = this;
	        var rotation = node.rotation;
	        if (pos === 'mtr') {
	            return that.cursorMap[pos];
	        }
	        if (Math.abs(rotation) > 0) {
	            var angle = -rotation / (Math.PI/180);
	            var n = Math.round((angle % 360) / 45);
	            if (n < 0) {
	                n += 8; // full circle ahead
	            }
	            n += that.cursorOffset[pos];
	            n %= 8;
	            return that.cursorMaps[n];
	        }
	        return that.cursorMap[pos];
	    }
	
	    /**
	     * @private
	     * 根据point创建节点上的控制点
	     * @param {Object} point x，y坐标  {x:x, y:y}
	     * @param {String} pos x，y坐标 [tl|tc|tr|bl|br|mtr] (top-left, top-center, top-right, bottom-left, bottom-right, middle-top-rotate)
	     * @param {String} nodeId 创建控制点时传入当前节点的id，完成节点与控制点的绑定
	     */
	    fishTopoProto.createConnectorControl = function(point, pos, node) {
	        var me = this;
	        var posArr = pos.split(',');
	        if (posArr.length < 2) {
	            var controlCursor = me.getRotatedCornerCursor(node, pos);
	            var pointInstance = new graphic.Rect({
	                shape:{
	                    x: point.x - 4,
	                    y: point.y - 4,
	                    width: 8,
	                    height: 8
	                },
	                style: {
	                    fill: '#ffffff',
	                    stroke:'#000000'
	                },
	                z: 4,
	                rotation: node.rotation,
	                origin: [point.x, point.y],
	                cursor: controlCursor,
	                draggable: true
	            });
	            pointInstance.type = 'ConnectControl';
	            pointInstance.pos = pos;// 记录是节点上哪个位置的连接点
	            var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	            zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	                pointInstance.on(eveName, function(e) {
	                    var params = {};
	                    params.event = e;
	                    params.type = "ConnectControl:" + eveName;
	                    params.nodeId = node.id;
	                    params.cursor = controlCursor;
	                    me.group.trigger(params.type, params);
	                });
	            });
	            this.group.add(pointInstance);
	        } else {
	            // 旋转点与节点之间需要连线
	            var line = new graphic.Line({
	                shape: {
	                    x1: point.top.x,
	                    y1: point.top.y,
	                    x2: point.bottom.x,
	                    y2: point.bottom.y
	                },
	                style: {
	                    lineWidth: 1
	                },
	                z: 1,
	                draggable: false,
	                cursor: 'default'
	            });
	            line.type = 'ConnectControlLine';
	            line.nodeId = node.id;
	            this.group.add(line);
	        }
	    }
	
	    /**
	     * @method returnConnectorControlParam
	     * 返回旋转点和缩放点控制参数
	     * @param  {Object} 当前节点对象
	     */
	    fishTopoProto.returnConnectorControlParam = function(node) {
	        var scaleFlag = typeof node.scaleable === 'boolean' ? node.scaleable : this.options.scaleable;
	        var rotateFlag = typeof node.rotatable === 'boolean' ? node.rotatable : this.options.rotatable;
	        return {
	            scaleable: scaleFlag,
	            rotatable: rotateFlag
	        }
	    }
	
	    fishTopoProto.ifShowConnectorPoint = function(node) {
	        var connectable = node && typeof node.connectable === 'boolean' ? node.connectable : this.options.connectable;
	        return connectable;
	    }
	
	    /**
	     * @private
	     * 隐藏节点上的控制点
	     */
	    fishTopoProto.hideConnectorControl = function() {
	        var that = this;
	        var types = ['ConnectControl', 'ConnectControlLine'];
	        this.group.children().forEach(function (v) {
	            if (types.includes(v.type)) {
	                that.group.remove(v);
	            }
	        })
	        this.group.off("ConnectControl:dragstart");
	        this.group.off("ConnectControl:drag");
	        this.group.off("ConnectControl:dragend");
	    }
	
	    /**
	     * 在节点上显示控制点
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.showConnectorControl();
	    */
	   fishTopoProto.showConnectorControl = function() {
	        if (this.judgeIfReadMode(this.selectedNode)) {
	            return;
	        }
	        var that = this;
	        this.hideConnectorControl();
	        // 让当前节点显示控制点
	        var rect = util.getRect(this.selectedNode);
	        var connectorPoint = util.getConnectorControls(rect, this.selectedNode);
	        var params = this.returnConnectorControlParam(this.selectedNode);
	        if (params.scaleable) {
	            that.createConnectorControl(connectorPoint.tl, "tl", this.selectedNode);
	            that.createConnectorControl(connectorPoint.tr, "tr", this.selectedNode);
	            that.createConnectorControl(connectorPoint.bl, "bl", this.selectedNode);
	            that.createConnectorControl(connectorPoint.br, "br", this.selectedNode);
	        }
	        if (params.rotatable) {
	            that.createConnectorControl(connectorPoint.mtr, "mtr", this.selectedNode);
	            that.createConnectorControl({ top: connectorPoint.mtr, bottom: connectorPoint.tc }, "mtr,tc", this.selectedNode);
	        }
	
	        function findControlNode (id) {
	            var node = null;
	            that.group.children().forEach(function(item) {
	                if (item.id === id) {
	                        node = item;
	                }
	            });
	            return node;
	        }
	
	        this.group.on("ConnectControl:dragstart", function(e) {
	            // 首先清除其他所有节点的控制点和连接点
	            var cursor = e.event.target.cursor;
	            var pos = e.event.target.pos;
	            var posMap = {
	                'tl': 'br',
	                'tr': 'bl',
	                'bl': 'tr',
	                'br': 'tl'
	            };
	            that.selectConnNode = findControlNode(e.nodeId);
	            if (cursor && pos !== 'mtr') {
	                var originNode = zrUtil.find(that.group.children(), function(node) {
	                    return node.pos === posMap[pos];
	                });
	                var currentNode = zrUtil.find(that.group.children(), function (node) {
	                    return node.pos === pos;
	                });
	                var boundingRect = that.selectConnNode.getBoundingRect();
	                that.oppositeShape = zrUtil.clone(originNode.shape);
	                that.currentShape = zrUtil.clone(currentNode.shape);
	                var rect = zrUtil.clone(util.getRect(that.selectConnNode, true));
	                var diagonal = Math.sqrt(Math.pow(rect.width, 2) + Math.pow(rect.height, 2));// 对角线长度
	                that.diagonal = diagonal;
	                that.originRect = zrUtil.clone(rect);
	                that.ifPointCenter = boundingRect.x < -1; // 判断中心点是否在节点中心(原形在中心，矩形在左上角)
	                // 移除node高亮
	                that.selectConnNode.selectStyle && that._api.getZr().removeHover(that.selectConnNode);
	            }
	        });
	        this.group.on("ConnectControl:drag", function(e) {
	            var cursor = e.event.target.cursor;
	            var targetPos = e.event.target.pos;
	            var currentNode = that.selectConnNode;
	            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;
	            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;
	            var rect = util.getRect(currentNode, true);
	            if (targetPos === 'mtr') {
	                // 旋转
	                var r_x = x - currentNode.position[0];
	                var r_y = y - currentNode.position[1];
	                var origins = {
	                    x: rect.x - currentNode.position[0],
	                    y: rect.y - currentNode.position[1]
	                }
	                var rotation = Math.atan2(r_y, r_x);
	                that.selectedNode.attr({
	                    'origin': [origins.x, origins.y],
	                    'rotation': -rotation
	                });
	                var connectorPoint = util.getConnectorPoints(rect, that.selectedNode);
	                var controlPoint = util.getConnectorControls(rect, that.selectedNode);
	                // 节点连线点，控制点位置更新
	                that.group.children().forEach(function (item) {
	                    var pos = item.pos;
	                    if (item.type === 'ConnectControl') {
	                        if (pos === 'mtr') {
	                            item.attr('position', [0, 0]);
	                            item.attr('rotation', 0);
	                        }
	                        item.setShape({ x: controlPoint[pos].x - 4, y: controlPoint[pos].y - 4 });
	                        item.attr({
	                            'origin': [item.shape.x + 4, item.shape.y + 4],
	                            'rotation': -rotation
	                        });
	                    } else if (item.type === 'ConnectControlLine') {
	                        item.setShape({ x1: controlPoint.mtr.x, x2: controlPoint.tc.x, y1: controlPoint.mtr.y, y2: controlPoint.tc.y });
	                    } else if (item.type === 'ConnectPoint') {
	                        item.setShape({ cx: connectorPoint[pos].x, cy: connectorPoint[pos].y });
	                    }
	                });
	            } else {
	                // 缩放(缩放点需要结合旋转角度计算)
	                var ratio = 1,
	                    center = [],
	                    centerPoint = {},
	                    width0, height0;
	                var cursorsY = ['n-resize', 's-resize'];
	                var positionOrg = {
	                    'tl': 'br',
	                    'tr': 'bl',
	                    'bl': 'tr',
	                    'br': 'tl'
	                }
	
	                var scaleNodes = that.group.children().filter(function (node) {
	                    return node.type === 'ConnectControl' && node.pos !== 'mtr'
	                });
	                var currentControlNode = zrUtil.find(scaleNodes, function (node) {
	                    return node.pos === targetPos;
	                });
	
	                if (x <= 8) {
	                    x = 8;
	                }
	                if (y <= 8) {
	                    y = 8;
	                }
	
	                if (cursorsY.includes(cursor)) {
	                    // 获取y轴比例即可
	                    var startY = currentControlNode.shape.y + 4;
	                    ratio = that.currentShape.y >= that.oppositeShape.y ? ((y - that.oppositeShape.y - 4) / (startY - that.oppositeShape.y)) : ((that.oppositeShape.y + 4 - y) / (that.oppositeShape.y - startY));
	                } else {
	                    // 获取x轴比例即可
	                    var startX = currentControlNode.shape.x + 4;
	                    ratio = that.currentShape.x >= that.oppositeShape.x ? ((x - that.oppositeShape.x - 4) / (startX - that.oppositeShape.x)) : ((that.oppositeShape.x + 4 - x) / (that.oppositeShape.x - startX))
	                }
	                if (!/^[0-9]+.?[0-9]*/.test(ratio)) {
	                    ratio = 1;
	                }
	                currentNode.updateShape(ratio);
	
	                var rectScale = util.getRect(currentNode, true);
	                centerPoint = that.ifPointCenter ? { x: that.originRect.x, y: that.originRect.y } : { x: that.originRect.boundingRect.x, y: that.originRect.boundingRect.y };
	                var diagonalNew = Math.sqrt(Math.pow(rectScale.width, 2) + Math.pow(rectScale.height, 2));// 对角线长度
	                switch (cursor) {
	                    // 上,左上
	                    case 'n-resize':
	                    case 'nw-resize':
	                        width0 = (that.oppositeShape.x + 4 - centerPoint.x) * diagonalNew / that.diagonal;
	                        height0 = (that.oppositeShape.y + 4 - centerPoint.y) * diagonalNew / that.diagonal;
	                        center.push(that.oppositeShape.x - width0 + 4, that.oppositeShape.y - height0 + 4);
	                        break;
	                    // 右,右上
	                    case 'e-resize':
	                    case 'ne-resize':
	                        width0 = (centerPoint.x - that.oppositeShape.x - 4) * diagonalNew / that.diagonal;
	                        height0 = (that.oppositeShape.y + 4 - centerPoint.y) * diagonalNew / that.diagonal;
	                        center.push(that.oppositeShape.x + width0 + 4, that.oppositeShape.y - height0 + 4);
	                        break;
	                    // 下，右下
	                    case 's-resize':
	                    case 'se-resize':
	                        width0 = (centerPoint.x - that.oppositeShape.x - 4) * diagonalNew / that.diagonal;
	                        height0 = (centerPoint.y - that.oppositeShape.y - 4) * diagonalNew / that.diagonal;
	                        center.push(that.oppositeShape.x + width0 + 4, that.oppositeShape.y + height0 + 4);
	                        break;
	                    // 左,左下
	                    case 'w-resize':
	                    case 'sw-resize':
	                        width0 = (that.oppositeShape.x + 4 - centerPoint.x) * diagonalNew / that.diagonal;
	                        height0 = (centerPoint.y - that.oppositeShape.y - 4) * diagonalNew / that.diagonal;
	                        center.push(that.oppositeShape.x - width0 + 4, that.oppositeShape.y + height0 + 4);
	                        break;
	                    default:
	                        break;
	                }
	
	                var originScale = {
	                    x: rectScale.x - center[0],
	                    y: rectScale.y - center[1]
	                }
	                currentNode.attr({
	                    'position': center,
	                    'origin': [originScale.x, originScale.y]
	                });
	
	                // 此时节点包围盒需要重新计算
	                var rectNow = util.getRect(currentNode, true);
	                var connectorPointScale = util.getConnectorPoints(rectNow, currentNode);
	                var controlPointScale = util.getConnectorControls(rectNow, currentNode);
	                that.group.children().forEach(function(item) {
	                    var pos = item.pos;
	                    if (pos === targetPos) {
	                        item.attr('position', [0, 0]);
	                    }
	                    if (item.type === 'ConnectControl' && pos !== positionOrg[targetPos]) {
	                        item.setShape({ x: controlPointScale[pos].x - 4, y: controlPointScale[pos].y - 4 });
	                        item.attr('origin', [controlPointScale[pos].x, controlPointScale[pos].y]);
	                    } else if (item.type === 'ConnectControlLine') {
	                        item.setShape({ x1: controlPointScale.mtr.x, x2: controlPointScale.tc.x, y1: controlPointScale.mtr.y, y2: controlPointScale.tc.y });
	
	                    } else if (item.type === 'ConnectPoint') {
	                        item.setShape({ cx: connectorPointScale[pos].x, cy: connectorPointScale[pos].y });
	                    }
	                });
	            }
	            that.operationNode.refreshPostion(that.selectedNode, util.getRect(that.selectedNode));
	            // 1.5 刷新连线
	            that.connectionManager.refreshLineByNode(that.selectedNode);
	            // 1.6 如果是组的话,需要把组内所有结果都刷新一下线
	            if (Flow.isGroupNode(that.selectedNode)) {
	                that.selectedNode.each(function(childNode) {
	                    that.connectionManager.refreshLineByNode(childNode);
	                });
	            }
	
	        });
	        this.group.on("ConnectControl:dragend", function(e) {
	            // 更新节点position
	            var node = that.selectConnNode;
	            var position = node.position;
	            var origin = node.origin;
	            // position origin取整
	            that.selectConnNode.attr('position', [parseInt(position[0], 10), parseInt(position[1], 10)]);
	            if (Array.isArray(origin)) {
	                that.selectConnNode.attr('origin', [parseInt(origin[0], 10), parseInt(origin[1], 10)]);
	            }
	            node.updateShape(1, true);
	            if (node.model) {
	                // 更新model，支持序列化/反序列化
	                node.model.set("options.rotation", node.rotation);
	                node.model.set("options.origin", node.origin);
	                var elementType = node.model.option.elementType;
	                if (elementType === 'Image') {
	                    node.model.set("options.style", node.style);
	                } else {
	                    node.model.set("options.shape", node.shape);
	                }
	            }
	            // 1.4 触发点击
	            that.nodeClickHandler(node);
	            that.stepCounter();
	            that.oppositeShape = null;
	            that.currentShape = null;
	            that.diagonal = null;
	            that.originRect = null;
	            that.ifPointCenter = null;
	        });
	    }
	
	    fishTopoProto.initOperationNode = function (node, ifCurrentNode) {
	        var that = this;
	        if (!ifCurrentNode) {
	            ifCurrentNode = false;
	        }
	        this.operationNode = new OperationNode(node, this.group, this._api);
	        // 根据连线点查找节点(考虑优化 创建连接点的时候 就把连接点与node进行绑定，就不用这个复杂的计算了)
	        function findConnectorNode(x, y, offset, pos) {
	            var node, endPos = null;
	            that.allNodes.forEach(function(item) {
	                var rect = util.getRect(item);
	                if (item.parent && Flow.isGroupNode(item.parent)) {
	                    rect.boundingRect.x += Flow.parentX(item.parent);
	                    rect.boundingRect.y += Flow.parentY(item.parent);
	                }
	                var connectorPoint = util.getConnectorPoints(rect, item);
	                if (pos) {
	                    if (Math.abs(connectorPoint[pos].x - x) <= offset && Math.abs(connectorPoint[pos].y - y) <= offset) {
	                        node = item;
	                    }
	                } else {
	                    if (Math.abs(connectorPoint["left"].x - x) <= offset && Math.abs(connectorPoint["left"].y - y) <= offset) {
	                        endPos = "left";
	                        node = item;
	                    } else if (Math.abs(connectorPoint["top"].x - x) <= offset && Math.abs(connectorPoint["top"].y - y) <= offset) {
	                        endPos = "top";
	                        node = item;
	                    } else if (Math.abs(connectorPoint["right"].x - x) <= offset && Math.abs(connectorPoint["right"].y - y) <= offset) {
	                        endPos = "right";
	                        node = item;
	                    } else if (Math.abs(connectorPoint["bottom"].x - x) <= offset && Math.abs(connectorPoint["bottom"].y - y) <= offset) {
	                        endPos = "bottom";
	                        node = item;
	                    }
	                }
	            });
	            return {
	                node: node,
	                endPos: endPos
	            };
	        }
	        this.operationNode.on(OperationNode.ARROW_DRAGSTART, function (e) {
	            this.hideConnectorPoint();
	            that.filterConnectPoint(that.allNodes, e.event.target.lineType);
	            var x = (e.event.offsetX - this.group.position[0]) / this.nowZoom;
	            var y = (e.event.offsetY - this.group.position[1]) / this.nowZoom;
	            if (e.data) {
	                this.lineOpt = e.data;  //缓存线段的配置信息
	            }
	            //拖拽开始先把 箭头图标 给隐藏
	            var arrow = e.event.target;
	            arrow.hide();
	            var rEndPoint = new Point(x, y);
	            var connector = this.connectionManager.manageTempConnector(this.selectedNode, rEndPoint,
	                arrow.lineType);
	            this.group.add(connector);
	            e.cancelBubble = true;
	        }.bind(this));
	
	        // 侦听 箭头 拖拽事件
	        this.operationNode.on(OperationNode.ARROW_DRAG, function (e) {
	            var x = (e.event.offsetX - this.group.position[0]) / this.nowZoom;
	            var y = (e.event.offsetY - this.group.position[1]) / this.nowZoom;
	            var arrow = e.event.target;
	            var rEndPoint = new Point(x, y);
	            this.connectionManager.manageTempConnector(this.selectedNode, rEndPoint, arrow.lineType);
	            that.group.children().forEach(function (v) {
	                if (v.type === 'ConnectPoint') {
	                    v.attr({style:{fill: "#FFFF33"},scale:[1,1],origin:[v.shape.cx,v.shape.cy]});
	                    if (Math.abs(v.shape.cx - x) <= 10 && Math.abs(v.shape.cy - y) <= 10) {
	                        var res = findConnectorNode(x, y, 10);
	                        that.connectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType, 'right', res.endPos, res.node);
	                        v.attr({style:{fill: "#ff0000"},scale:[1.5,1.5],origin:[v.shape.cx,v.shape.cy],cursor:'pointer'});
	                    }
	                }
	            })
	            e.cancelBubble = true;
	        }.bind(this));
	
	        //侦听 箭头 拖拽结束事件 画线
	        this.operationNode.on(OperationNode.ARROW_DRAGEND, function (e) {
	            e.cancelBubble = true;
	            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;
	            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;
	            var res = findConnectorNode(x, y, 10);
	            var targetNode = res.node;
	            var endPos = res.endPos || 'left';
	            var arrow = e.event.target;
	            //拖拽结束先把 箭头图标 给显示
	            arrow.show();
	            //删除临时线
	            this.connectionManager.removeTempConnector(this.group);
	
	            //1.如果是子节点 内 节点拖拽 则 增加排除子节点的参数
	            // targetNode = findHover(this.allNodes, x, y);
	
	            //2.如果找到目标结点 则画线
	            if (targetNode && (this.selectedNode != targetNode)) {
	                var origin = {};
	                var connectOptions = {
	                    style: {
	                        lineType: arrow.lineType
	                    },
	                    position: {
	                        startPos: 'right',
	                        endPos: endPos
	                    }
	                }
	                var finalOpt = util.mergeOpt(connectOptions, that.lineOpt, true, 'position');
	                var start = that.selectedNode;
	                var end = targetNode;
	                //如果有原始连线存在，则要暴露出去。
	                if (that.originNode) {
	                    origin.startNode = that.selectedNode;
	                    origin.endNode = that.originNode;
	                    origin.options = util.mergeOpt({
	                        style: {
	                            lineType: arrow.lineType
	                        },
	                        position: {
	                            startPos: that.startPos,
	                            endPos: that.originPos
	                        }
	                    }, that.lineOpt, true, 'position');
	                }
	                if(!this._trigger('beforeCreate', {target:this.selectedNode,endNode:targetNode,connectOptions:connectOptions, origin: {}})) {
	                    return null;
	                }
	                that.createConnectorByNodes(start, end, finalOpt);
	            }
	            that.hideConnectorPoint();
	            // 连线成功/失败，当前节点依然是选中状态，需要重新计算虚线和图标位置
	            var node = that.selectedNode;
	            var shapeRect = util.getRect(node, true);
	            // 显示当前节点的连接点
	            that.showConnectorPoint(undefined, undefined, true);
	            that.operationNode.refreshPostion(node, shapeRect);
	        }.bind(this));
	
	        //删除按钮点击事件
	        this.operationNode.on(OperationNode.DELETE_CLICK, function () {
	            this.removeNode(this.selectedNode);
	        }.bind(this));
	        this.group.add(this.operationNode);
	    };
	
	    fishTopoProto.removeSelectedNodes = function() {
	        var that = this;
	        if (this.selectedNodes.length) {
	            this.selectedNodes.forEach(function(item, index) {
	                that.removeNode(item, {}, true);
	                if (index === that.selectedNodes.length - 1) {
	                    that.stepCounter();
	                }
	            });
	            this.selectedNodes = [];
	            this.dragSelectRect.off("mousedown");
	            this.group.remove(this.dragSelectRect);
	        } else if (that.selectedNode) {
	            that.removeNode(that.selectedNode);
	            // 1. 隐藏连线点
	            this.hideConnectorPoint();
	            // 2. 隐藏控制点
	            this.hideConnectorControl();
	            // 3. 隐藏操作node
	            this._removeOperationNode();
	        }
	    };
	
	    fishTopoProto.findNodeChildIds = function (node, childIds) {
	        childIds.push(node.id);
	        node.children().filter(function (v) {
	            var pos = this.allNodes.findIndex(function (item) {
	                return item.id === v.id
	            });
	            return pos !== -1
	        }.bind(this)).forEach(function (sub) {
	            if (Flow.isGroupNode(sub)) {
	                this.findNodeChildIds(sub, childIds);
	            } else {
	                childIds.push(sub.id);
	            }
	        }.bind(this));
	    }
	
	    /**
	     * 移除场景中的某个节点或者线段,同removeNode
	     * @method remove
	     * @param  {Object} node or link 待删除的节点或者线段
	     * @param {Object} [options] 参数
	     * @param {Boolean} [options.trigger=true] 是否触发删除事件
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.remove(peopleNode);
	     */
	
	    /**
	     * 移除场景中的某个节点或者线段,同remove
	     * @method removeNode
	     * @param  {Object} node or link 待删除的节点或者线段
	     * @param {Object} [options] 参数
	     * @param {Boolean} [options.trigger=true] 是否触发删除事件
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.removeNode(peopleNode);
	     */
	    fishTopoProto.remove = fishTopoProto.removeNode = function (delNode, options, isNoCount) {
	        var opt = options || {};
	        if(opt.trigger !==false && (!this._trigger('beforeDelete', {target:delNode}))) {
	            return;
	        }
	        var parentZr = this._getParentZr(delNode);
	        if (delNode instanceof Connector) {
	            // 1.1 删除线段上的操作图标
	            zrUtil.each(delNode.icons, function(lineOperationIcon) {
	                parentZr.remove(lineOperationIcon);
	            })
	            // 1.2 删除当前选中线段
	            this.connectionManager.deleteByLine(delNode,parentZr);
	        } else {
	            //2.1 删除节点
	            parentZr.remove(delNode);
	            var childIds = [];
	            if (Flow.isGroupNode(delNode)) {
	                this.findNodeChildIds(delNode, childIds);
	            } else {
	                childIds.push(delNode.id);
	            }
	            //2.从allNodes数组中删除
	            this.allNodes = this.allNodes.filter(function (v) {
	                return childIds.indexOf(v.id) === -1
	            });
	            //2.3 删除和节点相关联的线段
	            this.connectionManager.deleteSelectCon(delNode, this.group);
	            //2.4 删除节点操作
	            this._removeOperationNode();
	        }
	        // 1. 隐藏连线点
	        this.hideConnectorPoint();
	        // 2. 隐藏控制点
	        this.hideConnectorControl();
	        //3. 清空连接线上的调整位置按钮
	        this.connectionManager.clearSelectCon();
	        //4. 清空连接线上的操作按钮
	        this.lineOperationManager.hideAllLineOperation();
	        if (isNoCount != true) {
	            this.stepCounter();
	        }
	        //4. 派发删除事件
	         this._trigger("delete", {target:delNode});
	    };
	
	    /**
	     * 选中场景中的某个节点,并且触发selectNode事件
	     * @param {Object} node 待选中的节点对象
	     * @since V2.3.0
	     *  **使用范例：**
	     * @example
	     * fishTopo.selectNode(node);
	     */
	
	    fishTopoProto.selectNode = function(node) {
	        if (node) {
	            this.nodeClickHandler(node);
	            this._trigger("selectNode", {target:node});
	        }
	    };
	
	    /**
	     * 根据节点创建连线
	     * @method createConnectorByNodes
	     * @param  {Object} startNode 开始节点
	     * @param  {Object} endNode   结束节点
	     * @param  {Object} options 线段选项 参见{@link fishTopoFlow.link#constructor 构造函数options参数}
	     * @param  {Boolean} trigger 是否触发create事件，默认是触发create事件，设置为false则不触发
	     */
	    fishTopoProto.createConnectorByNodes = function (startNode, endNode, options, trigger) {
	        var linkType = options.style.lineType || Connector.TYPE_STRAIGHT;
	        if (!flowLink[linkType]) {
	            return null;
	        }
	        var Link = flowLink[linkType];
	        var connector = new Link(startNode, endNode, options);
	        this.connectionManager.add(connector);
	
	        if (startNode.parent && endNode.parent && startNode.parent==endNode.parent ) {
	            endNode.parent.add(connector);
	        } else {
	            this.group.add(connector);
	        }
	        this.connectionManager.connectorForbidEdit(!this.options.linkModify);
	        // 处理线段两端的调整drag事件
	        this.createConnectorDragEvents(connector);
	        connector.on("mousedown", function (e) {
	            this.isNode = false;
	            // 取消节点的选中
	            this.hideConnectorPoint();
	            this.hideConnectorControl();
	            this._removeOperationNode();
	            // this.showConnectorPoint(e.target.style.lineType);
	        }.bind(this));
	        connector.on("dblclick", function () {
	            if (this.options.textEditable) {
	                this.connectorEdit(this);
	            }
	        }.bind(this));
	        if (trigger !== false) {
	            this._trigger("create", { target: connector });
	        }
	        this.stepCounter();
	        return connector;
	    };
	
	    /**
	     * 处理连线和连接点drag事件
	     * @method _handleLineDrag
	     * @param  {String} dragType drag类型
	     * @param  {Object} e   event事件对象
	     * @param  {String} lineType 连线类型
	     */
	    fishTopoProto._handleLineDrag = function(dragType, e, lineType) {
	        var that = this;
	        function findConnectorNode(x, y, offset, pos) {
	            var node, endPos = null;
	            that.allNodes.forEach(function(item) {
	                var rect = util.getRect(item);
	                if (item.parent && Flow.isGroupNode(item.parent)) {
	                    rect.boundingRect.x += Flow.parentX(item.parent);
	                    rect.boundingRect.y += Flow.parentY(item.parent);
	                }
	                var connectorPoint = util.getConnectorPoints(rect, item);
	                if (pos) {
	                    if (Math.abs(connectorPoint[pos].x - x) <= offset && Math.abs(connectorPoint[pos].y - y) <= offset) {
	                        node = item;
	                    }
	                } else {
	                    if (Math.abs(connectorPoint["left"].x - x) <= offset && Math.abs(connectorPoint["left"].y - y) <= offset) {
	                        endPos = "left";
	                        node = item;
	                    } else if (Math.abs(connectorPoint["top"].x - x) <= offset && Math.abs(connectorPoint["top"].y - y) <= offset) {
	                        endPos = "top";
	                        node = item;
	                    } else if (Math.abs(connectorPoint["right"].x - x) <= offset && Math.abs(connectorPoint["right"].y - y) <= offset) {
	                        endPos = "right";
	                        node = item;
	                    } else if (Math.abs(connectorPoint["bottom"].x - x) <= offset && Math.abs(connectorPoint["bottom"].y - y) <= offset) {
	                        endPos = "bottom";
	                        node = item;
	                    }
	                }
	            });
	            return {
	                node: node,
	                endPos: endPos
	            };
	        }
	        var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;
	        var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;
	        var point = new Point(x, y);
	        if (dragType === 'drag') {
	            if (that.reverseConnect) {
	                that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, lineType, that.endPos);
	            } else {
	                that.connectionManager.manageTempConnector(that.selectConnNode, point, lineType, that.startPos);
	            }
	            that.group.children().forEach(function (v) {
	                if (v.type === 'ConnectPoint') {
	                    v.attr({style:{fill: "#FFFF33"},scale:[1,1],origin:[v.shape.cx,v.shape.cy]});
	                    if (Math.abs(v.shape.cx - x) <= 10 && Math.abs(v.shape.cy - y) <= 10) {
	                        var res = findConnectorNode(x, y, 10);
	                        if (that.reverseConnect) {
	                            that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, lineType, that.endPos, res.endPos, res.node);
	                        } else {
	                            that.connectionManager.manageTempConnector(that.selectConnNode, point, lineType, that.startPos, res.endPos, res.node);
	                        }
	                        v.attr({style:{fill: "#ff0000"},scale:[1.5,1.5],origin:[v.shape.cx,v.shape.cy],cursor:'pointer'});
	                    }
	                }
	            })
	        }
	        if (dragType === 'dragend') {
	            var res = findConnectorNode(x, y, 10);
	            var targetNode = res.node;
	            var endPos = res.endPos || 'left';
	            //删除临时线
	            that.connectionManager.removeTempConnector(that.group);
	            //2.如果找到目标结点 则画线
	            if (targetNode && (that.selectConnNode.id !== targetNode.id)) {
	                var origin = {};
	                var connectOptions = {
	                    style: {
	                        lineType: lineType
	                    },
	                    position: {
	                        startPos: that.reverseConnect ? endPos : that.startPos,
	                        endPos: that.reverseConnect ? that.endPos : endPos
	                    }
	                }
	                var finalOpt = util.mergeOpt(connectOptions, that.lineOpt, true, 'position');
	                var start = that.reverseConnect ? targetNode : that.selectConnNode;
	                var end = that.reverseConnect ? that.selectConnNode : targetNode;
	                //如果有原始连线存在，则要暴露出去。
	                if (that.originNode) {
	                    origin.startNode = that.reverseConnect ? that.originNode : that.selectConnNode;
	                    origin.endNode = that.reverseConnect ? that.selectConnNode : that.originNode;
	                    origin.options = util.mergeOpt({
	                        style: {
	                            lineType: lineType
	                        },
	                        position: {
	                            startPos: that.reverseConnect ? that.originPos : that.startPos,
	                            endPos: that.reverseConnect ? that.endPos : that.originPos
	                        }
	                    }, that.lineOpt, true, 'position');
	                }
	                if(!that._trigger('beforeCreate', {target: start, endNode: end, connectOptions: finalOpt, origin: origin})) {
	                    return false;
	                }
	                that.createConnectorByNodes(start, end, finalOpt);
	                that.hideConnectorPoint();      //隐藏所有节点上的连接点
	                // 恢复选中样式
	                if (that.operationNode) {
	                    that.showConnectorPoint(undefined, undefined, true);
	                }
	            } else {
	                //还原所有连接点的颜色
	                that.group.children().forEach(function (v) {
	                    if (v.type === 'ConnectPoint') {
	                        v.attr({style:{fill: "#FFFF33"},scale:[1,1],origin:[v.shape.cx,v.shape.cy],cursor:'crosshair'});
	                    }
	                });
	            }
	        }
	    }
	
	    fishTopoProto.createConnectorDragEvents = function (connector) {
	        var that = this;
	        connector.on("dragstart", function (e) {
	            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;
	            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;
	            var opt = this.opt;
	            var lineType = opt.style.lineType;
	            var dockers = this.model.option.options.dockers;
	            var startPoint = dockers[0];
	            var endPoint = dockers[dockers.length - 1];
	            var startDiff = Math.abs(x - startPoint.x) + Math.abs(y - startPoint.y);
	            var endDiff = Math.abs(x - endPoint.x) + Math.abs(y - endPoint.y);
	            if (startDiff > 15 && endDiff > 15) {
	                return;
	            }
	            var point = new Point(x, y);
	            that.filterConnectPoint(that.allNodes, lineType);
	            that.reverseConnect = false;   //是否反向连线的标识
	            that.selectConnNode = connector.startNode;
	            if (endDiff <= 15) {
	                that.selectConnNode = connector.startNode;
	                that.startPos = opt.position.startPos;
	                that.originNode = this.endNode;
	                that.originPos = opt.position.endPos;
	            }
	            if (startDiff <= 15) {
	                that.reverseConnect = true;
	                that.selectConnNode = connector.endNode;
	                that.endPos = opt.position.endPos;
	                that.originNode = this.startNode;
	                that.originPos = opt.position.startPos;
	            }
	            that.connectionManager.deleteByLine(this, that.group);
	            var connectorLine;
	            if (that.reverseConnect) {
	                connectorLine = that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, lineType, that.endPos);
	            } else {
	                connectorLine = that.connectionManager.manageTempConnector(that.selectConnNode, point, lineType, that.startPos);
	            }
	            that.group.add(connectorLine);
	            connectorLine.setSelectedStyle();
	        });
	        connector.on("drag", function (e) {
	            that._handleLineDrag('drag', e, this.opt.style.lineType);
	        });
	        connector.on("dragend", function (e) {
	            that._handleLineDrag('dragend', e, this.opt.style.lineType);
	            that.hideConnectorPoint();
	            that.hideConnectorControl();
	        });
	    }
	
	    /**
	     * @private
	     * 派发创建完成事件  返回fales则取消
	     */
	    fishTopoProto._trigger = function(type, event, data) {
	        var callback = this.options[type];
	
	        if (data === void 0) data = {};
	        if (event === null) {
	            event = {type:type, target:this}
	        } else {
	            event.type = type;
	        }
	        event.data = data;
	        this._api.trigger(event.type, event);
	        return !(zrUtil.isFunction(callback) && callback.apply(this, [event].concat(data)) === false);
	    }
	
	
	    fishTopoProto.nodeClickHandler = function (node) {
	        // 组缩放成的图片节点不可有点击状态
	        if (node.name === 'GROUP_RELATION_IMAGE') {
	            return;
	        }
	        var ifShowPoint = node.type !== 'dragSelect';
	        if (node.parent && node.parent.type === "dragSelect") {
	            ifShowPoint = false;
	        }
	        // 1. 隐藏连线点
	        this.hideConnectorPoint();
	        // 2. 隐藏控制点
	        this.hideConnectorControl();
	        // 3. 隐藏操作node
	        this._removeOperationNode();
	        // 鼠标点下 将操作框 移到对应的节点上
	        if (node.selectable === false) {
	            if (Flow.isInGroup(node)) {
	                var group = node.parent;
	                if (group.selectable === false) {
	                    return;
	                } else {
	                    node = group;   // 如果有组的话，就针对组进行处理
	                }
	            } else {
	                return;
	            }
	        }
	
	        this.selectedNode = node;
	        var shapeRect = util.getRect(node,true);
	        if (!this.operationNode) {
	            this.initOperationNode(node, true);
	        }
	        if (ifShowPoint) {
	            // 显示当前节点的连接点
	            this.showConnectorPoint(undefined, undefined, true);
	            var params = this.returnConnectorControlParam(node);
	            if (params.scaleable || params.rotatable) {
	                // 显示当前节点的控制点
	                this.showConnectorControl();
	            }
	        }
	        // 在存在子流程的情况下 需要把node也传递一下
	        this.operationNode.refreshPostion(node, shapeRect);
	    };
	
	    /**
	     * @private
	     * 节点的移动操作, 为何要自己实现拖动？zredner Group不支持拖动，只能自己实现
	     */
	    fishTopoProto.drag = function (node) {
	        var that = this; // zrender中的一个bug event.target不会带group 只能用that 不能用bind(this)
	        node.on("mousedown", function (event) {
	            var draggingTarget = this;
	            //如果加了属性 draggable:false或者拖拽框选里 则不可以拖动
	            if (that.judgeIfReadMode(draggingTarget) || (this.parent && this.parent.type === "dragSelect") || (node.style && node.style.fill === 'none')) {
	                return;
	            }
	            that._nodeDragHandler(draggingTarget, event.offsetX, event.offsetY);
	            event.cancelBubble = true;
	        });
	    };
	
	    /**
	     * @private
	     * 向上递归节点计算groupRect
	     */
	    fishTopoProto._recurmodifyGroupRect = function(node, groupNode, moveObj) {
	        if (node.name === 'GROUP_RELATION_IMAGE' && groupNode) {
	            // 如果节点是_relationImage节点，用其他处理方式
	            this._removeOperationNode();
	            this._recurmodifyRelationImageGroupRect(node, groupNode, moveObj, true);
	        }
	        if (Flow.isInGroup(node)) {
	            //放入node现有数值，用于重绘group
	            var nodeMessage = {
	                node: node,
	                position: node.position
	            };
	            node.parent.modifyGroupRect(nodeMessage);
	            if (node.parent && Flow.isGroupNode(node.parent)) {
	                this._recurmodifyGroupRect(node.parent);
	            }
	        }
	    }
	
	    /**
	     * @private
	     * 当前移动节点为_relationImage，保证_relationImage相关的groupNode不可超出父groupNode
	     * @param  {Object} image _relationImage节点
	     * @param  {Object} groupNode 与_relationImage节点级联的groupNode
	     * @param  {Object} moveObj _relationImage节点的移动参数
	     * @param  {Boolaen} flag groupNode节点position是否需要加上当前节点的移动参数
	     */
	    fishTopoProto._recurmodifyRelationImageGroupRect = function(image, groupNode, moveObj, flag) {
	        if (Flow.isInGroup(groupNode)) {
	            // 重新计算position
	            var position = zrUtil.clone(groupNode.position);
	            if (flag) {
	                position = [position[0] + moveObj.moveX, position[1] + moveObj.moveY];
	            }
	            var nodeMessage = {
	                node: groupNode,
	                position: position
	            };
	            groupNode.parent.modifyGroupRect(nodeMessage);
	            if (groupNode.parent && Flow.isGroupNode(groupNode.parent)) {
	                this._recurmodifyRelationImageGroupRect(image, groupNode.parent, moveObj, false);
	            }
	        }
	    }
	
	    /**
	     * @private
	     * 组节点向下递归刷新连线
	     */
	    fishTopoProto._recureRefreshLine = function(node) {
	        if (Flow.isGroupNode(node) && node._relationImage) {
	            node.each(function(childNode) {
	                this.connectionManager.refreshLineByNode(childNode);
	                if (Flow.isGroupNode(childNode)) {
	                    if (childNode.ignore && childNode._relationImage) {
	                        // 更新组节点的_relationImage的连线
	                        this.connectionManager.refreshLineByNode(childNode._relationImage);
	                    }
	                    this._recureRefreshLine(childNode);
	                }
	            }.bind(this));
	        } else {
	            this.connectionManager.refreshLineByNode(node);
	        }
	    }
	
	    /**
	     * @private
	     * 创建_relationImage的连线
	     * @param  {Object} relationImage   组缩放图片节点
	     * @param  {Object} relationNode    组节点
	     */
	    fishTopoProto._createRelationImageLine = function(relationImage, relationNode) {
	        var that = this;
	        var starts = [], ends = [];
	        // 跨组间的连线都存在全局
	        var connectors = this.group._children.filter(function(childNode) {
	            return childNode instanceof Connector && childNode.name !== 'GROUP_RELATION_LINE';
	        });
	        var groupInnerNodes = this.findGroupNodes(relationNode);
	        connectors.forEach(function(line, index) {
	            if (groupInnerNodes.some(function(childNode) { return childNode.id === line.endNode.id;})) {
	                if(groupInnerNodes.filter(function(child) { return child.id === line.startNode.id}).length <= 0) {
	                    ends.push({
	                        options: zrUtil.clone(line.opt),
	                        startNode: line.startNode,
	                        endNode: relationImage
	                    });
	                }
	            }
	            if (groupInnerNodes.some(function(childNode) { return childNode.id === line.startNode.id;})) {
	                if(groupInnerNodes.filter(function(child) { return child.id === line.endNode.id}).length <= 0) {
	                    starts.push({
	                        options: zrUtil.clone(line.opt),
	                        startNode: relationImage,
	                        endNode: line.endNode
	                    });
	                }
	            }
	        });
	        // 两个节点间存在多条相同的连线需要单独处理，计算连线间的间隔，避免重合
	        var findIndex = function(lineOptArray, lineOpt) {
	            var index = -1;
	            for (var i = 0; i < lineOptArray.length; i++) {
	                var item = lineOptArray[i][0];
	                if (item.startNode.id === lineOpt.startNode.id && item.endNode.id === lineOpt.endNode.id && JSON.stringify(item.options.position) === JSON.stringify(lineOpt.options.position) && item.options.style.lineType === lineOpt.options.style.lineType) {
	                    index = i;
	                    break;
	                }
	            }
	            return index;
	        }
	        var calculate =  function(lineOptArray) {
	            var length = lineOptArray.length;
	            var position = zrUtil.clone(lineOptArray[0].options.position);
	            var startNode = lineOptArray[0].startNode;
	            var endNode = lineOptArray[0].endNode;
	            var startRect = startNode.getBoundingRect();
	            var endRect = endNode.getBoundingRect();
	            var startLengthKey = (position.startPos === 'top' || position.startPos === 'bottom') ? 'width' : 'height';
	            var endLengthKey = (position.endPos === 'top' || position.endPos === 'bottom') ? 'width' : 'height';
	            var startLen = startRect[startLengthKey];
	            var endLen = endRect[endLengthKey];
	            var startSpace = parseInt(startLen / (length + 1), 10);
	            var endSpace = parseInt(endLen / (length + 1), 10);
	            var ifOdd = length % 2 !== 0;
	            var centerIndex = ifOdd ? Math.ceil(length / 2) : length / 2;
	            lineOptArray.forEach(function(item, index) {
	                if (ifOdd) {
	                    // 奇数
	                    if ((index + 1) < centerIndex) {
	                        item.options.position.startPos = position.startPos + '-' + (startSpace * (centerIndex - index - 1));
	                        item.options.position.endPos = position.endPos + '-' + (endSpace * (centerIndex - index - 1));
	                    } else if ((index + 1) > centerIndex) {
	                        item.options.position.startPos = position.startPos + '+' + (startSpace * (index + 1 - centerIndex));
	                        item.options.position.endPos = position.endPos + '+' + (endSpace * (index + 1 - centerIndex));
	                    }
	                } else {
	                    // 偶数
	                    if ((index + 1) <= centerIndex) {
	                        item.options.position.startPos = position.startPos + '-' + (startSpace * (centerIndex - index));
	                        item.options.position.endPos = position.endPos + '-' + (endSpace * (centerIndex - index));
	                    } else {
	                        item.options.position.startPos = position.startPos + '+' + (startSpace * (index + 1 - centerIndex));
	                        item.options.position.endPos = position.endPos + '+' + (endSpace * (index + 1 - centerIndex));
	                    }
	                }
	            });
	        }
	        var cycle = function(lineOptArray) {
	            if (lineOptArray.length <= 0) {
	                return;
	            }
	            var lineOptChunk = [];
	            lineOptArray.forEach(function(item, index) {
	                if (index === 0) {
	                    lineOptChunk.push([item]);
	                } else {
	                    var filterIndex = findIndex(lineOptChunk, item);
	                    if (filterIndex > -1) {
	                        lineOptChunk[filterIndex].push(item);
	                    } else {
	                        lineOptChunk.push([item])
	                    }
	                }
	            });
	            lineOptChunk.forEach(function(item) {
	                var length = item.length;
	                if (length > 1) {
	                    calculate(item);
	                }
	            });
	            lineOptArray.forEach(function(item) {
	                var lineNode = that.createConnectorByNodes(item.startNode, item.endNode, item.options);
	                lineNode.name = 'GROUP_RELATION_LINE';
	            })
	        }
	        cycle(ends);
	        cycle(starts);
	    }
	
	    /**
	     * @private
	     * 删除_relationImage的连线
	     * @param  {Object} relationImage   组缩放图片节点
	     */
	    fishTopoProto._removeRelationImageLine = function(relationImage) {
	        var that = this;
	        var connectors = this.group._children.filter(function(childNode) {
	            return childNode instanceof Connector && childNode.name === 'GROUP_RELATION_LINE';
	        });
	        if (connectors.length > 0) {
	            connectors.forEach(function(line) {
	                if (line.startNode.id === relationImage.id || line.endNode.id === relationImage.id) {
	                    that.remove(line);
	                }
	            });
	        }
	    }
	
	    /**
	     * @private
	     * 更新组的_relationImage位置
	     * @param  {Object} node   当前组节点
	     * @param  {Object} options   移动参数
	     */
	    fishTopoProto._refreshRelationImagePosition = function(node, isMove) {
	        if (Flow.isGroupNode(node) && isMove === 1) {
	            node.refreshRelationImage();
	        }
	    }
	
	    fishTopoProto._nodeDragHandler = function (node, x, y) {
	        var isMove = 0;
	        var ts = this;
	        var nowGroupPosition = node.position;
	        var groupPositionX = node.position[0];
	        var groupPositionY = node.position[1];
	        var relationImageGroupNode; // 记录_relationImage的父节点
	        node._startX = x;
	        node._startY = y;
	        if (node.name === 'GROUP_RELATION_IMAGE') {
	            relationImageGroupNode = zrUtil.find(this.allNodes, function (childNode) {
	                return childNode.id === node.relatedGroupId;
	            });
	        }
	        if (node.type === "dragSelect") {
	            var allLines = this.group.children().filter(function (v) {
	                return v.model && v.model.option.elementType === "connection";
	            });
	            var nodes = this.dragSelectRect.children().filter(function (v) {
	                return v.name !== "GROUP_RECT_NAME" && v.model && v.model.option.elementType !== "connection";
	            });
	            var lines = this.dragSelectRect.children().filter(function (v) {
	                return v.name !== "GROUP_RECT_NAME" && v.model && v.model.option.elementType === "connection";
	            });
	            allLines.forEach(function (v) {
	                var startNode = zrUtil.find(this.allNodes, function (node) {
	                    return node.id === v.startNode.id
	                });
	                var endNode = zrUtil.find(nodes, function (node) {
	                    return node.id === v.endNode.id
	                });
	                var ifExist = lines.findIndex(function(line) {
	                    return line.id === v.id
	                });
	                if ((startNode || endNode) && ifExist === -1) {
	                    ts.connectionManager.removeLine(v, ts._getParentZr(v));
	                }
	            });
	        }
	        node.trigger("dragstart");
	        // 1、侦听移动事件
	
	        var moveHandler = function (event) {
	            event.cancelBubble = true;
	            var sX = (event.offsetX - node._startX) / (this.nowZoom);
	            var sY = (event.offsetY - node._startY) / (this.nowZoom);
	
	            if ((sX != 0) || (sY != 0)) {
	                isMove = 1;
	            }
	            node.trigger("drag");
	            // 1.1处理组内的情况（如果节点拖动，组也跟着变）
	            this._recurmodifyGroupRect(node, relationImageGroupNode, {
	                moveX: sX,
	                moveY: sY,
	                isMove: isMove
	            });
	            nowGroupPosition[0] = groupPositionX + sX;
	            nowGroupPosition[1] = groupPositionY + sY;
	            node.attr("position", nowGroupPosition);
	            // 组的_relationImage位置更新
	            this._refreshRelationImagePosition(node, isMove);
	            // 1.2 处理告警的情况 （告警随着节点移动）
	            if (node.alarm) {
	                var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm
	                        .getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect()
	                    .height - 3
	                ];
	                node.alarm.attr("position", newAlarmPosition);
	            }
	            // 1.4 触发点击
	            this.nodeClickHandler(node);
	            // 1.5 刷新连线
	            this._recureRefreshLine(node);
	            if (!Flow.isInGroup(node)) {
	                // 组缩放不进行背景颜色切换
	                if (this.group._children.some(function(item) { return item.name === 'GROUP_RELATION_IMAGE'})) {
	                    return;
	                }
	                var group = this.isPosInGroup(this.allNodes, node);
	                for (var i = 0; i < this.allNodes.length; i++) {
	                    var item = this.allNodes[i];
	                    if (Flow.isGroupNode(item)) {
	                        if (group && item.id === group.id && item.id !== node.id) {
	                            item.children().find(function (v) {
	                                return v.name === "GROUP_RECT_NAME"
	                            }).attr("style", {
	                                fill: "#b6e3f5"
	                            });
	                        } else {
	                            //恢复group的背景色
	                            item.children().find(function (v) {
	                                return v.name === "GROUP_RECT_NAME"
	                            }).attr("style", {
	                                fill: "rgba(0,0,0,0)"
	                            });
	                        }
	                    }
	                }
	            }
	        }.bind(this);
	        this._zr.on('mousemove', moveHandler);
	
	
	
	        //2. 拖拽结束
	        var endDragHandler = function () {
	            if (node.model) {
	                node.model.set("options.position", FlowUtil.truncPosition(node.position));
	            }
	
	            this._zr.off('mousemove', moveHandler);
	            this._zr.off('mouseup', endDragHandler);
	            this._zr.off("globalout", endDragHandler);
	
	            //2.1 缩微图
	            if (isMove == 1) {
	                this._trigger("dropDrag", {target:node});
	                node.trigger("dragend");
	                if (this.eagleEye == true) {
	                    this.openEagleEye(this.eagleEyeNode);
	                }
	                if (!Flow.isInGroup(node)) {
	                    // 组缩放不进行背景颜色切换
	                    if (this.group._children.some(function(item) { return item.name === 'GROUP_RELATION_IMAGE'})) {
	                        return;
	                    }
	                    var group = this.isPosInGroup(this.allNodes, node);
	                    if (group) {
	                        for (var i = 0; i < this.allNodes.length; i++) {
	                            var item = this.allNodes[i];
	                            if (Flow.isGroupNode(item) && item.id === group.id && item.id !== node.id) {
	                                var parentZr = this._getParentZr(node);
	                                parentZr.remove(node);
	                                item.add(node);
	                                var nodeX = Flow.isGroupNode(node) ? node.position[0] + node.options.shape.x : node.position[0];
	                                var nodeY = Flow.isGroupNode(node) ? node.position[1] + node.options.shape.y : node.position[1];
	                                var groupX = this.parentX(group);
	                                var groupY = this.parentY(group);
	                                node.attr("position", [nodeX - groupX + item.options.shape.x, nodeY - groupY + item.options.shape.y]);
	                                item.children().find(function (v) {
	                                    return v.name === "GROUP_RECT_NAME"
	                                }).attr("style", {
	                                    fill: "rgba(0,0,0,0)"
	                                });
	                            }
	                        }
	                    }
	                }
	                this.stepCounter();
	            }
	        }.bind(this);
	        this._zr.on('mouseup', endDragHandler);
	        this._zr.on('globalout', endDragHandler);
	    }
	    fishTopoProto.parentX = function (node) {
	        if (node.parent && Flow.isGroupNode(node.parent) && this.group.id !== node.parent.id) {
	            return node.position[0] + node.options.shape.x + this.parentX(node.parent);
	        } else {
	            return node.position[0] + node.options.shape.x;
	        }
	    }
	
	    fishTopoProto.parentY = function (node) {
	        if (node.parent && Flow.isGroupNode(node.parent) && this.group.id !== node.parent.id) {
	            return node.position[1] + node.options.shape.y + this.parentY(node.parent);
	        } else {
	            return node.position[1] + node.options.shape.y;
	        }
	    }
	
	    fishTopoProto.isPosInGroup = function (allNodes, node) {
	        if (allNodes.length > 0) {
	            var res = null;
	            for (var i = 0; i < allNodes.length; i++) {
	                var group = allNodes[i];
	                if (Flow.isGroupNode(group)) {
	                    var groupWidth = group.options.shape.width;
	                    var groupHeight = group.options.shape.height;
	                    var groupX = this.parentX(group);
	                    var groupY = this.parentY(group);
	                    var rect = util.getRect(node, true);
	                    var nodeWidth = rect.width;
	                    var nodeHeight = rect.height;
	                    var nodeX = rect.x - nodeWidth/2;
	                    var nodeY = rect.y - nodeHeight/2;
	                    if (nodeX >= groupX && nodeY >= groupY && nodeX+nodeWidth <= groupX+groupWidth && nodeY+nodeHeight <= groupY+groupHeight) {
	                        var children = group.children();
	                        var sub = this.isPosInGroup(children, node);
	                        res = sub ? sub : group;
	                        break;
	                    }
	                }
	            }
	            return res;
	        }
	        return null
	    }
	
	
	    /**
	     * 创建节点
	     * @method createNode
	     * @param  {String} type 类型 eg. 'Rect'、'Circle'、'Image'、'Group'、'Text'等
	     * @param  {Object} opt 节点选项 详见{@link fishTopoFlow.node Config options}
	     * @param {Object} userData 用户传递的业务数据
	     * @return {Object} 创建的节点对象
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *      var rect = this.fishTopo.createNode("Rect", { //矩形
	     *          shape: {
	     *              width: 100,
	     *              height: 60,
	     *          },
	     *          style: {
	     *              text: "基本矩形",
	     *              fill: "#167CFF",
	     *              stroke: "rgb(255,255,255)",
	     *              textFont: '14px Microsoft YaHei'
	     *          },
	     *          position: [180, 100],
	     *          operationIcons: [{ name: 'DEL' },
	     *              { name: 'STRAIGHT' },
	     *              { name: 'JAGGED' },
	     *              { name: 'CURVE' },
	     *              {
	     *                  name: "custom1",
	     *                  iconPath: "img/host.png",
	     *                  callback: function(e) { alert(e.data.name + " clicked") }  //e.node是当前的节点
	     *              }
	     *          ]
	     *      });
	     */
	    fishTopoProto.createNode = fishTopoProto.creatNode = function (type, opt, userData) {
	        if (!flowNode[type]) {
	            return null;
	        }
	        var Shape = flowNode[type];
	        var node = new Shape(opt);
	
	        Flow.setUserData(node, userData);
	        return node;
	    };
	
	    /**
	     * 根据name获取节点
	     * @param  {String} name 在创建节点中  name属性设置的值
	     * @return {Object}      name对应的节点
	     */
	    fishTopoProto.childOfName = function (name) {
	        var arrResult = [];
	        var childrenNode = this.allNodes;
	        var childrenLine = this.connectionManager.connectors;
	        for (var i = 0; i < childrenNode.length; i++) {
	            if (childrenNode[i].model.get("options.name") && childrenNode[i].model.get("options.name") ==
	                name) {
	                arrResult.push(childrenNode[i]);
	            } else if (childrenNode[i].model.get("userData.name") == name) {
	                arrResult.push(childrenNode[i]);
	            }
	        }
	        for (var j = 0; j < childrenLine.length; j++) {
	            if (childrenLine[j].model.get("options.name") && childrenLine[j].model.get("options.name") ==
	                name) {
	                arrResult.push(childrenLine[j]);
	            } else if (childrenLine[j].model.get("userData.name") == name) {
	                arrResult.push(childrenLine[j]);
	            }
	        }
	        if (arrResult.length > 1) {
	            return arrResult;
	        } else {
	            return arrResult[0];
	        }
	    };
	
	    /**
	     * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(node){ return node.position[0] > 100; });
	     * @param  {Function} cb      回调函数 参数为遍历的节点
	     * @param  {Object}   context 回调函数执行的上下文
	     * @return {Array}           返回查找到的对象
	     */
	    fishTopoProto.findElements = function (cb, context) {
	        var childrenNode = this.allNodes;
	        var childrenLine = this.connectionManager.connectors;
	        var arr = [];
	        for (var i = 0; i < childrenNode.length; i++) {
	            var child = childrenNode[i];
	            if (cb.call(context, child, i)) {
	                arr.push(child);
	            }
	        }
	        for (var j = 0; j < childrenLine.length; j++) {
	            var childL = childrenLine[j];
	            if (cb.call(context, childL, j)) {
	                arr.push(childL);
	            }
	        }
	        return arr;
	    };
	
	    /**
	     * 根据节点查找连线   例如: 默认查找开始节点的连线 findConnectorsByNode(node);
	     * @param  {Object}   node    节点
	     * @param  {Object}   options 是否查找开始节点
	     * @return {Array}            返回查找到的对象
	     */
	    fishTopoProto.findConnectorsByNode = function (node,options) {
	        var opts = options || {};
	        var arr = [];
	        // Default value
	        zrUtil.defaults(opts, {
	            startNode: true
	        });
	        var childrenLine = this.connectionManager.connectors;
	        for (var j = 0; j < childrenLine.length; j++) {
	            var childL = childrenLine[j];
	            if (opts.startNode) {
	                if(childL.startNode.id === node.id) {
	                    arr.push(childL);
	                }
	            } else {
	                if(childL.endNode.id === node.id) {
	                    arr.push(childL);
	                }
	            }
	        }
	        return arr;
	    };
	
	    /**
	     * 设置背景色  或 背景图片
	     * @param {string} imageUrl 背景色  或 背景图片 eg. 'img/bg.jpg'，为‘gridLine’时网格背景
	     * @param {string} isRepeat 是否重复背景  如果重复的话，将使用css的repeat 因为canvas不支持repeat
	     */
	    fishTopoProto.setBackground = function (imageUrl, isRepeat) {
	        if (imageUrl && imageUrl.length > 0) {
	            this.model.set(Constants.BACKGROUND, imageUrl);
	            if (imageUrl.substr(0, 1) == "#" || imageUrl.substr(0, 4) == "rgba") { //如果是颜色创建rect为背景
	                if (!document.createElement('canvas').getContext) {
	                    this._dom.style.backgroundColor = imageUrl;
	                } else {
	                    var imageShape = new this.Shape.Rect({
	                        shape: {
	                            width: this._zr.getWidth(),
	                            height: this._zr.getHeight()
	                        },
	                        style: {
	                            fill: imageUrl
	                        },
	                        cursor: 'default',
	                        z: -1
	                    });
	                    this._zr.add(imageShape);
	                }
	
	            } else if (imageUrl == "gridLine") {
	                this.gridLineGroup = new graphic.Group();
	                this.gridLine(0.2);
	                this._zr.add(this.gridLineGroup);
	            } else {
	                if (!document.createElement('canvas').getContext || isRepeat) {
	                    this._dom.style.backgroundImage = "url(" + imageUrl + ")";
	                    this._dom.style.backgroundRepeat = "repeat";
	                } else {
	                    var imageShape1 = new this.Shape.Image({ //如果是图片创建image为背景
	                        position: [0, 0],
	                        scale: [1, 1],
	                        style: {
	                            x: 0,
	                            y: 0,
	                            image: imageUrl,
	                            width: this._zr.getWidth(),
	                            height: this._zr.getHeight()
	                        },
	                        cursor: 'default',
	                        z: -1
	                    });
	                    this._zr.add(imageShape1);
	                }
	            }
	        }
	    };
	
	    //背景网格线
	    fishTopoProto.gridLine = function (opacity) {
	        var pixel = 10;
	        var widthLen = parseInt(this.getWidth() / pixel);
	        for (var x = 0; x <= widthLen; x++) {
	            var lineX = new graphic.Line({
	                shape: {
	                    x1: x * pixel,
	                    y1: 0,
	                    x2: x * pixel,
	                    y2: this.getHeight()
	                },
	                style: {
	                    lineDash: [1],
	                    opacity: opacity
	                },
	                z: 0,
	                draggable: false,
	                cursor: 'default'
	            });
	            this.gridLineGroup.add(lineX);
	        }
	
	        var heightLen = parseInt(this.getHeight() / pixel, pixel);
	        for (var y = 0; y <= heightLen; y++) {
	            var lineY = new graphic.Line({
	                shape: {
	                    x1: 0,
	                    y1: y * pixel,
	                    x2: this.getWidth(),
	                    y2: y * pixel
	                },
	                style: {
	                    lineDash: [1],
	                    opacity: opacity
	                },
	                z: 0,
	                draggable: false,
	                cursor: 'default'
	            });
	            this.gridLineGroup.add(lineY);
	        }
	    };
	
	    /**
	     * 创建线段
	     * @method createLink
	     * @param  {Object} startNode 开始节点
	     * @param  {Object} endNode   结束节点
	     * @param  {Object} options 线段选项
	     * @param {Object} [options.style] 节点的样式
	     * @param {Number} [options.style.lineWidth=1] 线段的宽度
	     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	     * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	     * @param {Object} [options.symbol] 线段的箭头
	     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	     * @param {Object} [options.text] 线段上的文字
	     * @param {String} [options.text.text] 线段上的文字内容
	     * @param {String} [options.text.color] 线段上的文字颜色
	     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {String} [options.position] 指定线段位置
	     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {Object} [options.position.startOffset] 线段开始位置的偏移
	     * @param {Object} [options.position.endOffset] 线段结束位置的偏移
	     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	     * @param {Object} [options.effect] 线上动态效果
	     * @param {String} [options.effect.show] 是否显示箭头动效
	     * @param {Number} [options.effect.period] 动效移动速度
	     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	     * @param {Number} [options.z] [连线的层级，越大越在前面显示]
	     * @param {Object} userData 用户传递的业务数据
	     * @return {Object} 创建的线段对象
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *      var link = me.fishTopo.createLink(startNode, endNode, {
	     *              symbol: { type: 'arrow', size: 10, color: "rgb(0,200,255)" }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     *              style: { lineWidth: 3, stroke: "rgb(0,200,255)", lineDash: [3,3], lineType: "jagged"  }, //样式
	     *              text: {
	     *                  text: text,
	     *                  color: '#ffffff',
	     *                  textPos:textPos,//文字位置可选值 'start','center','end',默认值为center
	     *                  xOffset:10, //文字位置x偏移量
	     *              },
	     *              pos:'right,left',
	     *              effect: {
	     *                  show: true,//是否显示箭头动效
	     *                  period: 6,//箭头速度
	     *              },
	     *              position:{
	     *                    escapeDistance:[50,30],  //第一条折线的长度，最后一条折线的长度
	     *                    points:["x1,y1","x2,y2"]  不使用自动计算 指定连线的位置数组
	     *              },
	     *              z: 0
	     *          });
	     */
	    fishTopoProto.createLink = fishTopoProto.creatLink = function (startNode, endNode, options, userData) {
	        var linkType = Connector.TYPE_STRAIGHT;
	        if (options && options.style && options.style.lineType) {
	            linkType = options.style.lineType
	        }
	
	        if (!flowLink[linkType]) {
	            return null;
	        }
	        var Link = flowLink[linkType];
	        var connector = new Link(startNode, endNode, options);
	        if (userData) {
	            connector.model.set(Constants.USERDATA, zrUtil.clone(userData));
	        }
	
	        return connector;
	    };
	
	    /**
	     * 根据节点刷新节点所连的线（重新计算线的位置）
	     * @param  {Object} node [节点]
	     */
	    fishTopoProto.refreshLineByNode = function (node) {
	        this.connectionManager.refreshLineByNode(node);
	    };
	
	
	    /**
	     * @private
	     * 线上文字编辑
	     */
	    fishTopoProto.connectorEdit = function (thisConnector) {
	        var lineText = thisConnector.childOfName('lineText');
	        if (!lineText) {
	            return;
	        }
	        var textStyle = {};
	        var textarea = this.createTextArea();
	        var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);
	        var maxWidth = 1.2 * util.getRect(lineText).width * this.nowZoom + 10;
	        Object.keys(lineText.style).forEach(function(key) {
	            if (key !== 'host' && key !== 'text') {
	                textStyle[key] = lineText.style[key];
	            }
	        });
	        textarea.style.width = 1.2 * util.getRect(lineText).width * this.nowZoom + "px";
	        textarea.style.height = (2 * textRect.height || 12) * this.nowZoom + "px";
	        textarea.style.border = "1px dashed #2e2e2e";
	        textarea.innerHTML = lineText.style.text;
	        thisConnector.setStyle({
	            text: {
	                text: ""
	            }
	        })
	        this._dom.appendChild(textarea);
	        this._dom.style.position = "relative";
	        textarea.style.lineHeight = (1.2 * textRect.lineHeight || 12) + "px";
	        textarea.style.top = (lineText.position[1] - textRect.height) * this.nowZoom + this.group
	            .position[1] + "px";
	        textarea.style.left = (lineText.position[0] - 0.55 * textRect.width) * this.nowZoom +
	            this.group.position[0] + "px";
	        textarea.focus();
	        textarea.select();
	        this._textareaResize(textRect, textarea, maxWidth);
	        textarea.onkeyup = function () {
	            textarea.style.width = textRect.width < 60 ? "80px" : textarea.style.width;
	            textarea.style.height = textarea.scrollHeight + 'px';
	        }
	        textarea.onfocusout = function () {
	            textStyle.text = textarea.value || "";
	            thisConnector.setStyle({ text: textStyle });
	            // 更新文字位置
	            thisConnector.refresh();
	            textarea.remove();
	        }
	    };
	    /**
	     * @private
	     * 节点上文字编辑
	     */
	    fishTopoProto.nodeEdit = function (thisNode) {
	        var MAXWIDTH_MULTIPLE_TOP_BOTTOM = 3.3; //text最大宽度与节点宽度的系数，在top/bottom位置
	        var isNotSetText = false;
	        var textarea = this.createTextArea();
	        var nodeText = zrUtil.clone(thisNode.style.text);
	        var textRect = textContain.getBoundingRect(nodeText, thisNode.style.textFont);
	        var textareaWidth = textRect.width < 25 ? (1.2 * textRect.width * this.nowZoom + 10) : 36;
	        var textareaHeight = (2 * textRect.height || 24) * this.nowZoom;
	        textarea.style.width = textareaWidth + 'px';
	        textarea.style.height = textareaHeight + "px";
	        var nodeRect = util.getRect(thisNode);
	        var maxWidth = 1.2 * nodeRect.width * this.nowZoom;
	        textarea.style.lineHeight = (1.2 * textRect.lineHeight || 14.4) + "px";
	        textarea.style.border = "1px dashed #2e2e2e";
	        textarea.innerHTML = thisNode.style.text;
	        textarea.style.maxWidth = maxWidth + 'px';
	        this.setStyle(thisNode, {text: ""});  //先把节点文本给清空，否则删除文本框中文字的时候，会显示出来
	        this._dom.appendChild(textarea);
	        this._dom.style.position = "relative";
	        var offestI = 1;
	        if (thisNode.style.textAlign == "left") {
	            offestI = 0;
	        }
	        if (thisNode.style.textAlign == "right") {
	            offestI = 2;
	        }
	        var offestP = 0;
	        if (thisNode.style.textPosition && thisNode.style.textPosition == "bottom") {
	            offestP = 1;
	            maxWidth = MAXWIDTH_MULTIPLE_TOP_BOTTOM * nodeRect.width * this.nowZoom;
	            textarea.style.maxWidth = maxWidth + "px";
	        }
	        if (thisNode.style.textPosition && thisNode.style.textPosition == "top") {
	            offestP = -1;
	            maxWidth = MAXWIDTH_MULTIPLE_TOP_BOTTOM * nodeRect.width * this.nowZoom;
	            textarea.style.maxWidth = maxWidth + "px";
	        }
	        textarea.style.top = (nodeRect.y - textareaHeight / 2 + offestP * (nodeRect.height - textRect.height /
	            2)) * this.nowZoom + this.group.position[1] + "px";
	        textarea.style.left = (nodeRect.x - offestI * textareaWidth / 2) * this.nowZoom +
	            this.group.position[0] + "px";
	        textarea.focus();
	        textarea.select();
	        textarea.onkeyup = function() {
	            if (event.keyCode == keyCode.ESCAPE) {
	                isNotSetText = true;
	                textarea.blur();
	            } else {
	                var textRect = textContain.getBoundingRect(textarea.value, thisNode.style.textFont);
	                this._textareaResize(textRect, textarea, maxWidth);
	            }
	        }.bind(this);
	
	        textarea.onblur = function() {
	            if (!isNotSetText) {
	                var text = this.handleWrap(textarea.value, textarea.style.maxWidth);
	                this.setStyle(thisNode, {text: text});
	            } else {
	                this.setStyle(thisNode, {text: nodeText});
	            }
	            textarea.remove();
	        }.bind(this);
	    };
	
	    /**
	     * @private
	     * 创建文本域
	     */
	    fishTopoProto.createTextArea = function () {
	        var textarea = document.createElement("textarea");
	        textarea.style.position = "absolute";
	        textarea.style.padding = "6px";
	        textarea.style.resize = "none";
	        textarea.style.whiteSpace = "pre";
	        textarea.style.lineHeight = "125%";
	        textarea.style.overflow = "hidden";
	        textarea.style.border = "0";
	        textarea.spellcheck = false;
	        return textarea;
	    };
	
	    /**
	     * @private
	     * 处理textarea自动换行
	     */
	    fishTopoProto.handleWrap = function (value, width) {
	        var spanNode = document.createElement("span");
	        spanNode.style.position = "absolute";
	        spanNode.style.overflow = "hidden";
	        spanNode.style.border = "0";
	        spanNode.style.padding = "0";
	        spanNode.style.left = "0";
	        spanNode.style.top = "0";
	        this._dom.appendChild(spanNode);
	        var content = value.split("\n");
	        var result = "";
	        content.forEach(function(val, i){
	            var valLength = val.length;
	            if (valLength == 0) {
	                //result += "\n";
	            } else {
	                var pre = "",
	                    innerVal, tempWidth, conWidth;
	                for (var innerI = 0; innerI < valLength; innerI++) {
	                    innerVal = val.charAt(innerI);
	                    spanNode.innerHTML = spanNode.innerHTML + innerVal;
	                    tempWidth = spanNode.clientWidth; //获取添加字符后隐藏域的宽度
	                    conWidth = Number(width.substring(0, width.length - 2));
	                    if (tempWidth > conWidth) {
	                        result += pre; //如果追加字符后隐藏域宽度大于TextArea宽度，则表明该字符为下一行字符，
	                        result += "\n";
	                        spanNode.innerHTML = innerVal;
	                        pre = innerVal;
	                    } else if (innerI == valLength - 1) {
	                        result += pre + innerVal; //最后一个字符
	                        if (i < content.length - 1) {
	                            result += "\n";
	                        }
	                        spanNode.innerHTML = "";
	                        pre = "";
	                    } else {
	                        pre += innerVal; //依次追加到pre变量中
	                    }
	
	                }
	            }
	        });
	        this._dom.removeChild(spanNode);
	        return result;
	    };
	
	    /**
	     * @private
	     * 文本域自适应高宽
	     */
	    fishTopoProto._textareaResize = function (textRect, textarea, width) {
	        var minWidth = 0;
	        textarea.style.width = 0;
	        textarea.style.width = (1.2 * textRect.width) * this.nowZoom + "px";
	        if (width < 60) {
	            minWidth = width;
	        } else {
	            minWidth = 80
	        }
	        if (textRect.width <= minWidth) {
	            textarea.style.width = minWidth + "px";
	        }
	        textarea.style.height = "0px";
	        textarea.style.height = textarea.scrollHeight + 'px';
	        if (textarea.scrollHeight <= 0) {
	            textarea.style.height = "12px";
	        }
	    }
	
	    /**
	     * @method setStyle
	     * 节点更改style里的属性
	     * @param {String} name 节点style里的某个属性名称
	     * @param {String} string 节点style里的某个属性名称对应的值
	     * **使用范例**：
	     *
	     *      @example
	     *          //节点设置文字
	     *         fishtopo.setStyle(node,{text:"例子"});
	     */
	    fishTopoProto.setStyle = function (node, options) {
	        node.setStyle(options);
	        zrUtil.merge(node.model.get("options.style"), options, true);
	    }
	
	    /**
	     * @method setShape
	     * 节点更改shape里的属性
	     * @param {String} name 节点shape里的某个属性名称
	     * @param {String} string 节点shape里的某个属性名称对应的值
	     * **使用范例**：
	     *
	     *      @example
	     *          //矩形节点设置宽
	     *         fishtopo.setShape(node,{width:100});
	     */
	    fishTopoProto.setShape = function (node, options) {
	        node.setShape(options);
	        if (node.model) {
	            zrUtil.merge(node.model.get("options.shape"), options, true);
	        }
	    }
	
	    /**
	     * 创建节点上面的警告
	     * @method createAlarm
	     * @param  {Object} node 节点
	     * @param  {Object} opt  选项值
	     * @param  {Object} [opt.text] 警告的文字
	     * @param  {Object} [opt.textFont] 警告的文字的字体
	     * @param  {Object} [opt.textFill] 警告的文字的颜色
	     * @param  {Object} [opt.textBackground] 警告的背景的颜色
	     * @return {Object} 返回节点上的警告
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *          this.fishTopo.createAlarm(s1,{
	     *          text:"2 W",
	     *          textFont:"4px Microsoft YaHei",
	     *          textFill:"#FFFFFF",
	     *          textBackground:"rgba(255,0,0,0.6)"
	     *      });//创建小图片和节点绑定
	     */
	    fishTopoProto.createAlarm = fishTopoProto.creatAlarm = function (node, opt) {
	        var group = this.createNode("Group", {
	            style: {
	                fill: 'rgba(0,0,0,0)',
	                stroke: 'rgba(0,0,0,0)'
	            }
	        });
	        group.isdraggable = false;
	        var text = this.createNode("Text", { //文字
	            style: {
	                text: opt.text,
	                textFont: opt.textFont,
	                fill: opt.textFill,
	                textBaseline: "top" //垂直对齐,
	            },
	            selectable: false,
	            position: [2, 0],
	            z: 2
	        });
	        text.isdraggable = false;
	        group.add(text);
	        if (Flow.isInGroup(node)) {
	            node.parent.add(group);
	        } else {
	            this.group.add(group);
	        }
	        var groupWidth = group.getBoundingRect().width + 2;
	        var groupHeight = group.getBoundingRect().height + 6;
	        var points = [
	            [0, 0],
	            [groupWidth, 0],
	            [groupWidth, groupHeight],
	            [groupWidth - 3, groupHeight],
	            [groupWidth - 6, groupHeight + 3],
	            [groupWidth - 9, groupHeight],
	            [0, groupHeight],
	            [0, 0]
	        ];
	        var Polyline = this.createNode("Polyline", {
	            shape: {
	                points: points
	            },
	            style: {
	                fill: opt.textBackground,
	                stroke: opt.textBackground
	            },
	            selectable: false,
	            z: 1
	        });
	        Polyline.isdraggable = false;
	        group.add(Polyline);
	        var groupPosition = [node.position[0] + node.getBoundingRect().width - (group.getBoundingRect().width -
	            6), node.position[1] - group.getBoundingRect().height - 3];
	        group.attr("position", groupPosition);
	        node.alarm = group;
	        //设置模型 给json序列化用
	        var model = new Model({});
	        model.set(Constants.ELEMENT_TYPE, Constants.ALARM);
	        model.set(Constants.OPTIONS, zrUtil.clone(opt));
	        model.set(Constants.RELATIONID, node.model.get(Constants.ID));
	        group.model = model;
	        return group;
	    };
	
	    /**
	     * @private
	     * 返回当前画布的数据
	     */
	    fishTopoProto.toDataURL = function (opts) {
	        return FlowUtil.toDataURL(this._zr, opts);
	    };
	
	    fishTopoProto._releaseSelectNode = function () {
	        if (this.dragSelectRect) {
	            var nodes = this.dragSelectRect.children().filter(function (v) {
	                return v.name !== "GROUP_RECT_NAME";
	            });
	            var groupNodesIds = this.group.children()
	                .filter(function (v) {
	                    return v.name !== "GROUP_RECT_NAME";
	                })
	                .map(function(v) {
	                    return v.id
	                });
	            var startX = this.dragSelectRect.position[0];
	            var startY = this.dragSelectRect.position[1];
	            for (var i = 0; i < nodes.length; i++) {
	                var item = nodes[i];
	                var nodeX = Flow.isGroupNode(item) ? item.position[0] + item.options.shape.x : item.position[0];
	                var nodeY = Flow.isGroupNode(item) ? item.position[1] + item.options.shape.y : item.position[1];
	                this.dragSelectRect.remove(item);
	                // group内不存在dragSelectRect节点方可添加
	                if (!groupNodesIds.includes(item.id)) {
	                    this.group.add(item);
	                }
	                if (item.model.option.elementType !== "connection") {
	                    item.attr("position", [nodeX+startX, nodeY+startY]);
	                    this.connectionManager.refreshLineByNode(item);
	                }
	            }
	            this.dragSelectRect.off("mousedown");
	            this.group.remove(this.dragSelectRect);
	        }
	    }
	
	    fishTopoProto._dragSelect = function (node, x, y) {
	        var canvasOffsetX = this.group.position[0];
	        var canvasOffsetY = this.group.position[1];
	        this._releaseSelectNode();  //还原选中的节点
	        this.dragSelectRect = new GroupNode({
	            shape:{ width: 0, height: 0},
	            position:[(x-canvasOffsetX)/this.nowZoom, (y-canvasOffsetY)/this.nowZoom],
	            childDraggable: false,
	            style: {
	                lineDash:[2,2],
	                fill: "rgba(239,222,221,0.7)",
	                stroke: '#ddd'
	            }
	        });
	        this.dragSelectRect.type = "dragSelect";
	        this.group.add(this.dragSelectRect);
	        this.drag(this.dragSelectRect);
	
	        var moveHandler = function (event) {
	            var posX = x <= event.offsetX ? x : event.offsetX;
	            var posY = y <= event.offsetY ? y : event.offsetY;
	            var width = Math.abs(event.offsetX - x);
	            var height = Math.abs(event.offsetY - y);
	            this.dragSelectRect.shape = {
	                width: width/this.nowZoom,
	                height: height/this.nowZoom
	            }
	            this.dragSelectRect.setProperties({shape: {width:width/this.nowZoom, height: height/this.nowZoom}, position: [(posX-canvasOffsetX)/this.nowZoom, (posY-canvasOffsetY)/this.nowZoom]});
	        }.bind(this);
	        this._zr.on('mousemove', moveHandler);
	
	        var endDragHandler = function (event) {
	            this._zr.off('mousemove', moveHandler);
	            this._zr.off('mouseup', endDragHandler);
	            this._zr.off("globalout", endDragHandler);
	
	            var ts = this;
	            var allNodes = this.group.children().filter(function (v) {
	                return v.id !== ts.dragSelectRect.id && v.model && v.model.option.elementType !== "connection";
	            });
	            var allLines = this.group.children().filter(function (v) {
	                return v.model && v.model.option.elementType === "connection";
	            });
	            var startX = this.dragSelectRect.position[0];
	            var startY = this.dragSelectRect.position[1];
	            var width = this.dragSelectRect.options.shape.width;
	            var height = this.dragSelectRect.options.shape.height;
	            var cnt = 0;
	            allNodes.forEach(function (item) {
	                var rect = util.getRect(item, true);
	                var nodeWidth = rect.width;
	                var nodeHeight = rect.height;
	                var nodeX = rect.x - nodeWidth/2;
	                var nodeY = rect.y - nodeHeight/2;
	                if (nodeX >= startX && nodeY >= startY && nodeX+nodeWidth <= startX+width && nodeY+nodeHeight <= startY+height) {
	                    ts.group.remove(item);
	                    ts.dragSelectRect.add(item);
	                    ts.selectedNodes.push(item);
	                    item.attr("position", [item.position[0]-startX, item.position[1]-startY]);
	                    cnt++;
	                }
	            });
	            allLines.forEach(function (item) {
	                var startNode = ts.dragSelectRect.children().find(function (v) {
	                    return v.id === item.startNode.id;
	                });
	                var endNode = ts.dragSelectRect.children().find(function (v) {
	                    return v.id === item.endNode.id;
	                });
	                if (startNode && endNode) {
	                    ts.group.remove(item);
	                    ts.dragSelectRect.add(item);
	                    ts.selectedNodes.push(item);
	                    ts.connectionManager.refreshLineByNode(item.startNode);
	                } else if (startNode || endNode) {
	                    // 删除选框外的节点与内节点间的连线
	                    ts.group.remove(item);
	                }
	            });
	            if (!cnt) {
	                this.dragSelectRect.off("mousedown");
	                this.group.remove(this.dragSelectRect);
	            } else {
	                this.dragSelectRect.childOfName("GROUP_RECT_NAME").attr("style", {
	                    fill: "rgba(0,0,0,0)"
	                });
	            }
	            this.dragSelectRect.model.set("options.position", FlowUtil.truncPosition(this.dragSelectRect.position));
	            this.dragSelectRect.model.set("options.shape", this.dragSelectRect.shape);
	            // this.stepCounter();
	        }.bind(this);
	        this._zr.on('mouseup', endDragHandler);
	        this._zr.on("globalout", endDragHandler);
	    }
	
	    fishTopoProto._groupDragHandler = function (x, y) {
	        // flow中最外层的group移动操作
	        var nowGroupPosition = this.group.position;
	        var groupPositionX = this.group.position[0];
	        var groupPositionY = this.group.position[1];
	
	        var moveHandler = function (event) {
	            var width = this.group.getBoundingRect().width * this.nowZoom;
	            var height = this.group.getBoundingRect().height * this.nowZoom;
	            var gx = this.group.getBoundingRect().x * this.nowZoom;
	            var gy = this.group.getBoundingRect().y * this.nowZoom;
	            var min = [10 - (width + gx), 10 - (height + gy)];
	            var max = [(this._zr.getWidth() - gx) - 10, (this._zr.getHeight() - gy) - 10];
	            var sX = event.offsetX - x;
	            var sY = event.offsetY - y;
	            nowGroupPosition[0] = groupPositionX + sX;
	            nowGroupPosition[1] = groupPositionY + sY;
	            if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] <
	                min[0] || nowGroupPosition[1] < min[1]) {
	                return;
	            } else {
	                this.group.attr("position", nowGroupPosition);
	                if (this.eagleEye == true) {
	                    this.minimap.updataSelectionPosition(nowGroupPosition, this.nowZoom);
	                }
	            }
	        }.bind(this);
	        this._zr.on('mousemove', moveHandler);
	
	        var endDragHandler = function () {
	            this._zr.off('mousemove', moveHandler);
	            this._zr.off('mouseup', endDragHandler);
	            this._zr.off("globalout", endDragHandler);
	        }.bind(this);
	        this._zr.on('mouseup', endDragHandler);
	        this._zr.on("globalout", endDragHandler);
	    };
	
	    fishTopoProto.initScale = function () {
	        var groupMaxWidth = this.group.getBoundingRect().width;
	        var groupMaxHeight = this.group.getBoundingRect().height;
	        var rangeWidth = this.getWidth();
	        var rangeHeight = this.getHeight();
	        var initRatio = 1,
	            pos = [];
	        if (groupMaxWidth / groupMaxHeight > rangeWidth / rangeHeight) {
	            if (groupMaxWidth > rangeWidth) {
	                initRatio = rangeWidth / groupMaxWidth;
	            }
	        } else {
	            if (groupMaxHeight > rangeHeight) {
	                initRatio = rangeHeight / groupMaxHeight;
	            }
	        }
	        pos[0] = Math.abs(this.group.getBoundingRect().x) * initRatio;
	        pos[1] = Math.abs(this.group.getBoundingRect().y) * initRatio;
	        this.group.attr("position", [pos[0], pos[1]]);
	        this.group.attr("scale", [initRatio, initRatio]);
	        this.initScaleRatio = initRatio;
	        var distance = [pos[0], pos[1], this.initScaleRatio, groupMaxWidth, groupMaxHeight];
	        return distance;
	    };
	
		/**
		 * 画布元素在水平方向和垂直方向居中
	     * @param  {Object} boundPos 其中需传入的属性分别为minX,minY,maxX,maxY包围画布上所有节点的最小边框的最小的x坐标、y坐标、最大的x坐标、y坐标
		 */
		fishTopoProto.zrCenter = function (boundPos) {
	        var boundObj;
	        var nowGroupPosition = this.group.position;
	        if (zrUtil.isArray(boundPos)) {
	            boundObj = zrUtil.extend({}, {minX: boundPos[0], minY: boundPos[1], maxX: boundPos[2], maxY: boundPos[3]});
	        } else {
	            boundObj = zrUtil.extend({}, boundPos);
	        }
	        nowGroupPosition[0] = this._zr.dom.offsetWidth/2 - (boundObj.minX + ((boundObj.maxX - boundObj.minX)/2));
	        nowGroupPosition[1] = this._zr.dom.offsetHeight/2 - (boundObj.minY + ((boundObj.maxY - boundObj.minY)/2));
	        this.group.attr("position", nowGroupPosition);
	    };
	
	    fishTopoProto.stepCounter = function() {
	        this.stepJson.splice(this.step, this.stepJson.length - (this.step));
	        this.step += 1;
	        var json = this.toJson();
	        this.stepJson.push(JSON.stringify(json));
	    };
	
	    /**
	     * 放大或者缩小
	     * @param  {String|Number} type 当为字符串时 "enlarge"放大  "narrowing"缩小  当为数值时 缩放的比例  建议0.3-1.7
	     */
	    fishTopoProto.zrScale = function (type) {
	        if (this.options.readonly) {
	            return;
	        }
	        if (type) {
	            var zoomDelta = 0;
	            if (type == "narrowing") {
	                zoomDelta = -0.07;
	                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }
	            if (type == "enlarge") {
	                zoomDelta = 0.07;
	                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }
	            if (!isNaN(type)) {
	                var target = this.group;
	                if (target) {
	                    var zoomScale = type / target.scale[0];
	                    this._zoom = type;
	                    this.nowZoom = type;
	                    this.setScale(this._zr.getWidth() / 2, this._zr.getHeight() / 2,zoomScale);
	                }
	            }
	        } else {
	            this._zr.on('mousewheel', zrUtil.bind(function (e) {
	                eventTool.stop(e.event);
	                var zoomDelta = e.wheelDelta > 0 ? 0.07 : -0.07;
	                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }, this));
	        }
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.zoom = function (zoomDelta, zoomX, zoomY) {
	        if (this.canScale == false) {
	            return;
	        }
	        var target = this.group;
	        if (target) {
	
	            var newZoom = this._zoom = this._zoom || 1;
	            newZoom += zoomDelta;
	
	            newZoom = Number(newZoom.toFixed(2));
	            var zoomScale = newZoom / this._zoom;
	            if (newZoom > this.options.maxScale || newZoom < this.options.minScale) {
	                return;
	            }
	            this._zoom = newZoom;
	
	            this.nowZoom = newZoom;
	
	            this.setScale(zoomX, zoomY, zoomScale);
	        }
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.setScale = function (zoomX, zoomY, zoomScale) {
	        var target = this.group;
	        var pos = target.position;
	        var scale = target.scale;
	        // Keep the mouse center when scaling
	        pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);
	        pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);
	        scale[0] *= zoomScale;
	        scale[1] *= zoomScale;
	        target.attr("position", [pos[0], pos[1]]);
	        target.attr("scale", [scale[0], scale[1]]);
	        if (this.eagleEye == true) {
	            this.minimap.updataSelection(pos[0], pos[1], zoomScale, this.nowZoom);
	        }
	    };
	
	    /**
	     * 鹰眼图
	     * @param  {HTMLElement} eagleEyeNode 显示鹰眼图的div元素
	     */
	    fishTopoProto.openEagleEye = function (eagleEyeNode) {
	        this.eagleEye = true;
	        this.eagleEyeNode = eagleEyeNode;
	        var groupPosition = zrUtil.clone(this.group.position);
	        var groupScale = zrUtil.clone(this.group.scale);
	        this.group.attr("position", [0, 0]);
	        this.group.attr("scale", [1, 1]);
	        var distance = this.initScale();
	        var imgSrc = this.toDataURL();
	        this.group.attr("position", groupPosition);
	        this.group.attr("scale", groupScale);
	        if (this.minimap) {
	            this.minimap.updataMap(imgSrc, this.group.getBoundingRect());
	        } else {
	            this.minimap = new Minimap(this, this.group.position, this.group.getBoundingRect(),
	                eagleEyeNode, distance, imgSrc);
	            setTimeout(zrUtil.bind(function () {
	                this.openEagleEye(this.eagleEyeNode)
	            }, this), 10);
	        }
	        this.minimap.selection.addEventListener("mousedown", function (e) {
	            var startX = e.clientX;
	            var startY = e.clientY;
	            var minimapLeft = Number(this.minimap.selection.style.left.substring(0, this.minimap.selection
	                .style.left.length - 2));
	            var minimapTop = Number(this.minimap.selection.style.top.substring(0, this.minimap.selection
	                .style.top.length - 2));
	            var eagleEyeMove = function (e) {
	                var offsetX = e.clientX - startX;
	                var offsetY = e.clientY - startY;
	                this.minimap.selection.style.left = minimapLeft + offsetX + "px";
	                this.minimap.selection.style.top = minimapTop + offsetY + "px";
	                this.minimap.updataGroupPosition(this.group, this.nowZoom);
	            }.bind(this);
	
	            this.minimap.selection.addEventListener("mousemove", eagleEyeMove);
	
	            var eagleEyeUp = function () {
	                this.minimap.selection.removeEventListener("mousemove", eagleEyeMove);
	                this.minimap.selection.removeEventListener("mouseup", eagleEyeUp);
	            }.bind(this);
	            this.minimap.selection.addEventListener("mouseup", eagleEyeUp);
	        }.bind(this))
	    };
	
	    /**
	     * 根据节点位置变化更新组边框的大小
	     * @param {Object} node 节点
	     * @since V2.3.0
	     */
	    fishTopoProto.refreshGroupByNode = function (node) {//#181
	        if (Flow.isInGroup(node)) {
	            //放入node现有数值，用于重绘group
	            this._recurmodifyGroupRect(node);
	        }
	        this.connectionManager.refreshLineByNode(node);
	        if (Flow.isGroupNode(node)) {
	            node.each(function (childNode) {
	                this.connectionManager.refreshLineByNode(childNode);
	            }.bind(this));
	        }
	    };
	
	    zrUtil.mixin(FishTopoFlow, Eventful);
	
	    // ---------对外暴露fishTopoFlow------------------
	    var idBase = new Date() - 0;
	    var instances = {};
	    var DOM_ATTRIBUTE_KEY = '_fishTopoFlow_instance_';
	
	    /**
	     * fishTopoFlow全局对象，如果是amd方式加载，则直接返回
	     * @class fishTopoFlow
	     * @singleton
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *      var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	     */
	    var fishTopoFlow = {
	        /**
	         * 版本号
	         * @type {String}
	         */
	        version: '3.2.0',
	        dependencies: {
	            zrender: '3.6.3'
	        }
	    };
	
	    /**
	     * 初始化dom元素为 flow对象
	     * @member fishTopoFlow
	     * @param {HTMLElement} dom  一个div元素
	     * @param {Object} opts  传递的选项参数
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'
	     * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化
	     * @param {boolean} [opts.linkModify=false] 是否允许调整线段
	     * @param {boolean} [opts.textEditable=false] 是否允许双击节点编辑文字
	     * @param {boolean} [opts.mouseMode='default'] 设置鼠标在画布上的操作模式，默认为'default'：无任何操作，设为'drag-move'：平移漫游，设为'drag-select'：框选节点
	     * @param {boolean} [opts.roam=true] 是否开启鼠标缩放。默认开启，设为false表示关闭缩放功能。
	     * @param {boolean} [opts.readonly=false] 是否开启只读模式，设为true后画布为只读模式(画布不可缩放，节点和连线无法拖拽,选中,编辑)
	     * @param {Object} [opts.tooltip] tooltip配置项
	     * @param {boolean} [opts.tooltip.show] tooltip配置项:控制tooltip是否显示
	     * @param {boolean} [opts.isAnimationEnabled=true] 是否开启动画,默认为true
	     * @param {boolean} [opts.connectable=true] 是否允许连接,默认为true
	     * @param {boolean} [opts.scaleable=false] 是否允许缩放,默认为false
	     * @param {boolean} [opts.rotatable=false] 是否允许旋转,默认为false
	     * @param {Function} [opts.beforeDelete] 删除节点或边线 之前的回调，如果返回false则不进行后续的删除操作
	     * @param {Object} [opts.beforeCreate] 创建节点或边线 之前的回调，如果返回false则不进行后续的删除操作
	     * @return {fish.topo.FishTopoFlow}
	     */
	    fishTopoFlow.init = function (dom, opts) {
	        if (!dom) {
	            throw new Error('Initialize failed: invalid dom.');
	        }
	
	        opts = opts || {};
	        // Default value
	        zrUtil.defaults(opts, {
	            type: "flow",
	            linkModify: false,
	            textEditable: false,
	            roam: true,
	            mouseMode: 'default',
	            tooltip: {
	                show:true
	            },  //覆盖tooltipModel
	            isAnimationEnabled: true,
	            readonly: false,
	            connectable: true,
	            scaleable: false,
	            rotatable: false,
	            beforeDelete: null,  // 删除之前的事件
	            beforeCreate:null,   //创建节点或连线之前的事件
	            maxScale: 1.7,       //画布放大的最大比例
	            minScale: 0.3        //画布缩小的最小比例
	        });
	
	        var fishTopoFlow = new FishTopoFlow(dom, opts);
	        fishTopoFlow.init();
	        fishTopoFlow.Flow = Flow;
	        fishTopoFlow.id = 'ft_' + idBase++;
	        instances[fishTopoFlow.id] = fishTopoFlow;
	
	        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoFlow.id);
	
	        return fishTopoFlow;
	    };
	
	    /**
	     * 判断当前是否为只读模式
	     */
	    fishTopoProto.judgeIfReadMode = function(node) {
	        var readonly = this.options.readonly;
	        if (readonly) {
	            return true;
	        }
	        if (!readonly && node && node.isdraggable == false) {
	            return true;
	        }
	        return false;
	    }
	
	
	    /**
	     * 获取 dom 容器上的实例。
	     * @member fishTopoFlow
	     * @param  {HTMLElement} dom 一个div元素
	     * @return {fish.topo.FishTopoFlow}
	     */
	    fishTopoFlow.getInstanceByDom = function (dom) {
	        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
	        return instances[key];
	    };
	
	    /**
	     * 销毁实例，实例销毁后无法再被使用。
	     *
	     * @member fishTopoFlow
	     * @param  {Object|string} chart fishTopoBpmn实例 或 fishTopoBpmn的id
	     */
	    fishTopoFlow.dispose = function (chart) {
	        var topo;
	        if (zrUtil.isDom(chart)) {
	            topo = fishTopoFlow.getInstanceByDom(chart);
	        } else if (typeof chart === 'string') {
	            topo = instances[chart];
	        }
	        if ((topo instanceof fishTopoFlow) && !topo.isDisposed()) {
	            topo.dispose();
	        }
	    };
	
	    //暴露出去的类
	    fishTopoFlow.graphic = graphic;
	    fishTopoFlow.node = FlowUtil.registerFlowNode(flowNode);
	    fishTopoFlow.link = flowLink;
	
	    fishTopoFlow.layout = layout;
	    fishTopoFlow.Flow = Flow;
	    fishTopoFlow.constants = Constants;
	    fishTopoFlow.util = util;
	    fishTopoFlow.util['initImagePool'] = ImagePool.initImagePool;
	    zrUtil.each([
	            'map', 'each', 'filter', 'indexOf', 'inherits',
	            'reduce', 'filter', 'bind', 'curry', 'isArray',
	            'isString', 'isObject', 'isFunction', 'extend',
	            'merge', "mergeAll"
	        ],
	        function (name) {
	            fishTopoFlow.util[name] = zrUtil[name];
	        }
	    );
	
	    module.exports = fishTopoFlow;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

	
	    //polyfill bind
	    if (!Function.prototype.bind) {
	        Function.prototype.bind = function(oThis) {
	            if (typeof this !== "function") {
	                // closest thing possible to the ECMAScript 5 internal IsCallable function
	                throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
	            }
	
	            var aArgs = Array.prototype.slice.call(arguments, 1),
	                fToBind = this,
	                fNOP = function() {},
	                fBound = function() {
	                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis || window,
	                        aArgs.concat(Array.prototype.slice.call(arguments)));
	                };
	
	            fNOP.prototype = this.prototype;
	            fBound.prototype = new fNOP();
	
	            return fBound;
	        };
	    }
	
	    //polyfill remove
	    if (!('remove' in Element.prototype)) {
	        Element.prototype.remove = function() {
	            if (this.parentNode) {
	                this.parentNode.removeChild(this);
	            }
	        };
	    }
	
	    if (!String.prototype.endsWith) {
	    String.prototype.endsWith = function(searchString, position) {
	        var subjectString = this.toString();
	        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
	            position = subjectString.length;
	        }
	        position -= searchString.length;
	        var lastIndex = subjectString.indexOf(searchString, position);
	        return lastIndex !== -1 && lastIndex === position;
	    };
	    }
	


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(5);
	
	    var pathTool = __webpack_require__(6);
	    var round = Math.round;
	    var Path = __webpack_require__(7);
	    var colorTool = __webpack_require__(20);
	    var matrix = __webpack_require__(14);
	    var vector = __webpack_require__(15);
	    var Gradient = __webpack_require__(42);
	    var Draggable = __webpack_require__(43);
	
	    var graphic = {};
	    graphic.Util = zrUtil;
	    graphic.Group = __webpack_require__(44);
	
	    graphic.Image = __webpack_require__(45);
	
	    graphic.Text = __webpack_require__(46);
	
	    graphic.textContain = __webpack_require__(26);
	
	    graphic.Circle = __webpack_require__(47);
	
	    graphic.Sector = __webpack_require__(48);
	
	    graphic.Ring = __webpack_require__(51);
	
	    graphic.Polygon = __webpack_require__(52);
	
	    graphic.Polyline = __webpack_require__(56);
	
	    graphic.Rect = __webpack_require__(57);
	
	    graphic.Line = __webpack_require__(58);
	
	    graphic.BezierCurve = __webpack_require__(59);
	
	    graphic.Arc = __webpack_require__(60);
	
	    graphic.LinearGradient = __webpack_require__(61);
	
	    graphic.RadialGradient = __webpack_require__(62);
	
	    graphic.BoundingRect = __webpack_require__(27);
	    graphic.States = __webpack_require__(63);
	    /**
	     * Extend shape with parameters
	     */
	    graphic.extendShape = function (opts) {
	        return Path.extend(opts);
	    };
	
	    /**
	     * Extend path
	     */
	    graphic.extendPath = function (pathData, opts) {
	        return pathTool.extendFromString(pathData, opts);
	    };
	
	    /**
	     * Create a path element from path data string
	     * @param {string} pathData
	     * @param {Object} opts
	     * @param {module:zrender/core/BoundingRect} rect
	     * @param {string} [layout=cover] 'center' or 'cover'
	     */
	    graphic.makePath = function (pathData, opts, rect, layout) {
	        var path = pathTool.createFromString(pathData, opts);
	        Draggable.call(path);
	        var boundingRect = path.getBoundingRect();
	        if (rect) {
	            var aspect = boundingRect.width / boundingRect.height;
	
	            if (layout === 'center') {
	                // Set rect to center, keep width / height ratio.
	                var width = rect.height * aspect;
	                var height;
	                if (width <= rect.width) {
	                    height = rect.height;
	                }
	                else {
	                    width = rect.width;
	                    height = width / aspect;
	                }
	                var cx = rect.x + rect.width / 2;
	                var cy = rect.y + rect.height / 2;
	
	                rect.x = cx - width / 2;
	                rect.y = cy - height / 2;
	                rect.width = width;
	                rect.height = height;
	            }
	
	            this.resizePath(path, rect);
	        }
	
	        zrUtil.inherits(path, Draggable);
	        return path;
	    };
	
	    graphic.mergePath = pathTool.mergePath;
	
	    /**
	     * Resize a path to fit the rect
	     * @param {module:zrender/graphic/Path} path
	     * @param {Object} rect
	     */
	    graphic.resizePath = function (path, rect) {
	        if (!path.applyTransform) {
	            return;
	        }
	
	        var pathRect = path.getBoundingRect();
	
	        var m = pathRect.calculateTransform(rect);
	
	        path.applyTransform(m);
	    };
	
	    /**
	     * Sub pixel optimize line for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x1]
	     * @param {number} [param.shape.y1]
	     * @param {number} [param.shape.x2]
	     * @param {number} [param.shape.y2]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeLine = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	
	        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
	            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
	        }
	        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
	            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
	        }
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize rect for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x]
	     * @param {number} [param.shape.y]
	     * @param {number} [param.shape.width]
	     * @param {number} [param.shape.height]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeRect = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	        var originX = shape.x;
	        var originY = shape.y;
	        var originWidth = shape.width;
	        var originHeight = shape.height;
	        shape.x = subPixelOptimize(shape.x, lineWidth, true);
	        shape.y = subPixelOptimize(shape.y, lineWidth, true);
	        shape.width = Math.max(
	            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,
	            originWidth === 0 ? 0 : 1
	        );
	        shape.height = Math.max(
	            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,
	            originHeight === 0 ? 0 : 1
	        );
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize for canvas
	     *
	     * @param {number} position Coordinate, such as x, y
	     * @param {number} lineWidth Should be nonnegative integer.
	     * @param {boolean=} positiveOrNegative Default false (negative).
	     * @return {number} Optimized position.
	     */
	    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {
	        // Assure that (position + lineWidth / 2) is near integer edge,
	        // otherwise line will be fuzzy in canvas.
	        var doubledPosition = round(position * 2);
	        return (doubledPosition + round(lineWidth)) % 2 === 0
	            ? doubledPosition / 2
	            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
	    };
	
	    /**
	     * @private
	     */
	    function doSingleEnterHover(el) {
	        if (el.__isHover) {
	            return;
	        }
	        if (el.__hoverStlDirty) {
	            var stroke = el.style.stroke;
	            var fill = el.style.fill;
	
	            // Create hoverStyle on mouseover
	            var hoverStyle = el.__hoverStl;
	            var lift = colorTool.lift;
	            hoverStyle.fill = hoverStyle.fill
	                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));
	            hoverStyle.stroke = hoverStyle.stroke
	                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));
	
	            var normalStyle = {};
	            for (var name in hoverStyle) {
	                if (hoverStyle.hasOwnProperty(name)) {
	                    normalStyle[name] = el.style[name];
	                }
	            }
	
	            el.__normalStl = normalStyle;
	
	            el.__hoverStlDirty = false;
	        }
	        el.setStyle(el.__hoverStl);
	        el.z2 += 1;
	
	        el.__isHover = true;
	    }
	
	    /**
	     * @inner
	     */
	    function doSingleLeaveHover(el) {
	        if (!el.__isHover) {
	            return;
	        }
	
	        var normalStl = el.__normalStl;
	        normalStl && el.setStyle(normalStl);
	        el.z2 -= 1;
	
	        el.__isHover = false;
	    }
	
	    /**
	     * @inner
	     */
	    function doEnterHover(el) {
	        (el.type === 'group' || el.type === 'GroupNode')
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleEnterHover(child);
	                }
	            })
	            : doSingleEnterHover(el);
	    }
	    graphic.doEnterHover = doEnterHover;
	    function doLeaveHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleLeaveHover(child);
	                }
	            })
	            : doSingleLeaveHover(el);
	    }
	    graphic.doLeaveHover = doLeaveHover;
	    /**
	     * @inner
	     */
	    function setElementHoverStl(el, hoverStl) {
	        // If element has sepcified hoverStyle, then use it instead of given hoverStyle
	        // Often used when item group has a label element and it's hoverStyle is different
	        el.__hoverStl = el.hoverStyle || hoverStl || {};
	        el.__hoverStlDirty = true;
	    }
	    graphic.setElementHoverStl = setElementHoverStl;
	    /**
	     * @inner
	     */
	    function onElementMouseOver() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function onElementMouseOut() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doLeaveHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function enterEmphasis() {
	        this.__isEmphasis = true;
	        doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function leaveEmphasis() {
	        this.__isEmphasis = false;
	        doLeaveHover(this);
	    }
	
	    /**
	     * Set hover style of element
	     * @param {module:zrender/Element} el
	     * @param {Object} [hoverStyle]
	     */
	    graphic.setHoverStyle = function (el, hoverStyle) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    setElementHoverStl(child, hoverStyle);
	                }
	            })
	            : setElementHoverStl(el, hoverStyle);
	        // Remove previous bound handlers
	        el.on('mouseover', onElementMouseOver)
	          .on('mouseout', onElementMouseOut);
	
	        // Emphasis, normal can be triggered manually
	        el.on('emphasis', enterEmphasis)
	          .on('normal', leaveEmphasis);
	    };
	
	    graphic.setNormalStyle = function(el, options) {
	        if (el.__normalStl) {
	            for (var name in options) {
	                if (el.__normalStl.hasOwnProperty(name)) {
	                    el.__normalStl[name] = options[name];
	                }
	            }
	        }
	    };
	
	    /**
	     * Set text option in the style
	     * @param {Object} textStyle
	     * @param {module:echarts/model/Model} labelModel
	     * @param {string} color
	     */
	    graphic.setText = function (textStyle, labelModel, color) {
	        var labelPosition = labelModel.getShallow('position') || 'inside';
	        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;
	        var textStyleModel = labelModel.getModel('textStyle');
	        zrUtil.extend(textStyle, {
	            textDistance: labelModel.getShallow('distance') || 5,
	            textFont: textStyleModel.getFont(),
	            textPosition: labelPosition,
	            textFill: textStyleModel.getTextColor() || labelColor
	        });
	    };
	
	    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {
	        var postfix = isUpdate ? 'Update' : '';
	        var duration = animatableModel
	            && animatableModel.getShallow('animationDuration' + postfix);
	        var animationEasing = animatableModel
	            && animatableModel.getShallow('animationEasing' + postfix);
	
	        animatableModel && animatableModel.getShallow('animation')
	            ? el.animateTo(props, duration, animationEasing, cb)
	            : (el.attr(props), cb && cb());
	    }
	    /**
	     * Update graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);
	
	    /**
	     * Init graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.initProps = zrUtil.curry(animateOrSetProps, false);
	
	    /**
	     * Get transform matrix of target (param target),
	     * in coordinate of its ancestor (param ancestor)
	     *
	     * @param {module:zrender/mixin/Transformable} target
	     * @param {module:zrender/mixin/Transformable} ancestor
	     */
	    graphic.getTransform = function (target, ancestor) {
	        var mat = matrix.identity([]);
	
	        while (target && target !== ancestor) {
	            matrix.mul(mat, target.getLocalTransform(), mat);
	            target = target.parent;
	        }
	
	        return mat;
	    };
	
	    /**
	     * Apply transform to an vertex.
	     * @param {Array.<number>} vertex [x, y]
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {Array.<number>} [x, y]
	     */
	    graphic.applyTransform = function (vertex, transform, invert) {
	        if (invert) {
	            transform = matrix.invert([], transform);
	        }
	        return vector.applyTransform([], vertex, transform);
	    };
	
	    /**
	     * @param {string} direction 'left' 'right' 'top' 'bottom'
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
	     */
	    graphic.transformDirection = function (direction, transform, invert) {
	
	        // Pick a base, ensure that transform result will not be (0, 0).
	        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[0]);
	        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[2]);
	
	        var vertex = [
	            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,
	            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0
	        ];
	
	        vertex = graphic.applyTransform(vertex, transform, invert);
	
	        return Math.abs(vertex[0]) > Math.abs(vertex[1])
	            ? (vertex[0] > 0 ? 'right' : 'left')
	            : (vertex[1] > 0 ? 'bottom' : 'top');
	    };
	
	    module.exports = graphic;
	


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	/**
	 * @module zrender/core/util
	 */
	// 用于处理merge时无法遍历Date等对象的问题
	var BUILTIN_OBJECT = {
	  '[object Function]': 1,
	  '[object RegExp]': 1,
	  '[object Date]': 1,
	  '[object Error]': 1,
	  '[object CanvasGradient]': 1,
	  '[object CanvasPattern]': 1,
	  // For node-canvas
	  '[object Image]': 1,
	  '[object Canvas]': 1
	};
	var TYPED_ARRAY = {
	  '[object Int8Array]': 1,
	  '[object Uint8Array]': 1,
	  '[object Uint8ClampedArray]': 1,
	  '[object Int16Array]': 1,
	  '[object Uint16Array]': 1,
	  '[object Int32Array]': 1,
	  '[object Uint32Array]': 1,
	  '[object Float32Array]': 1,
	  '[object Float64Array]': 1
	};
	var objToString = Object.prototype.toString;
	var arrayProto = Array.prototype;
	var nativeForEach = arrayProto.forEach;
	var nativeFilter = arrayProto.filter;
	var nativeSlice = arrayProto.slice;
	var nativeMap = arrayProto.map;
	var nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.
	
	var methods = {};
	
	function $override(name, fn) {
	  methods[name] = fn;
	}
	/**
	 * Those data types can be cloned:
	 *     Plain object, Array, TypedArray, number, string, null, undefined.
	 * Those data types will be assgined using the orginal data:
	 *     BUILTIN_OBJECT
	 * Instance of user defined class will be cloned to a plain object, without
	 * properties in prototype.
	 * Other data types is not supported (not sure what will happen).
	 *
	 * Caution: do not support clone Date, for performance consideration.
	 * (There might be a large number of date in `series.data`).
	 * So date should not be modified in and out of echarts.
	 *
	 * @param {*} source
	 * @return {*} new
	 */
	
	
	function clone(source) {
	  if (source == null || typeof source != 'object') {
	    return source;
	  }
	
	  var result = source;
	  var typeStr = objToString.call(source);
	
	  if (typeStr === '[object Array]') {
	    result = [];
	
	    for (var i = 0, len = source.length; i < len; i++) {
	      result[i] = clone(source[i]);
	    }
	  } else if (TYPED_ARRAY[typeStr]) {
	    var Ctor = source.constructor;
	
	    if (source.constructor.from) {
	      result = Ctor.from(source);
	    } else {
	      result = new Ctor(source.length);
	
	      for (var i = 0, len = source.length; i < len; i++) {
	        result[i] = clone(source[i]);
	      }
	    }
	  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
	    result = {};
	
	    for (var key in source) {
	      if (source.hasOwnProperty(key)) {
	        result[key] = clone(source[key]);
	      }
	    }
	  }
	
	  return result;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} target
	 * @param {*} source
	 * @param {boolean} [overwrite=false]
	 */
	
	
	function merge(target, source, overwrite) {
	  // We should escapse that source is string
	  // and enter for ... in ...
	  if (!isObject(source) || !isObject(target)) {
	    return overwrite ? clone(source) : target;
	  }
	
	  for (var key in source) {
	    if (source.hasOwnProperty(key)) {
	      var targetProp = target[key];
	      var sourceProp = source[key];
	
	      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
	        // 如果需要递归覆盖，就递归调用merge
	        merge(targetProp, sourceProp, overwrite);
	      } else if (overwrite || !(key in target)) {
	        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	        // NOTE，在 target[key] 不存在的时候也是直接覆盖
	        target[key] = clone(source[key], true);
	      }
	    }
	  }
	
	  return target;
	}
	/**
	 * @param {Array} targetAndSources The first item is target, and the rests are source.
	 * @param {boolean} [overwrite=false]
	 * @return {*} target
	 */
	
	
	function mergeAll(targetAndSources, overwrite) {
	  var result = targetAndSources[0];
	
	  for (var i = 1, len = targetAndSources.length; i < len; i++) {
	    result = merge(result, targetAndSources[i], overwrite);
	  }
	
	  return result;
	}
	/**
	 * @param {*} target
	 * @param {*} source
	 * @memberOf module:zrender/core/util
	 */
	
	
	function extend(target, source) {
	  for (var key in source) {
	    if (source.hasOwnProperty(key)) {
	      target[key] = source[key];
	    }
	  }
	
	  return target;
	}
	/**
	 * @param {*} target
	 * @param {*} source
	 * @param {boolean} [overlay=false]
	 * @memberOf module:zrender/core/util
	 */
	
	
	function defaults(target, source, overlay) {
	  for (var key in source) {
	    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
	      target[key] = source[key];
	    }
	  }
	
	  return target;
	}
	
	var createCanvas = function () {
	  return methods.createCanvas();
	};
	
	methods.createCanvas = function () {
	  return document.createElement('canvas');
	}; // FIXME
	
	
	var _ctx;
	
	function getContext() {
	  if (!_ctx) {
	    // Use util.createCanvas instead of createCanvas
	    // because createCanvas may be overwritten in different environment
	    _ctx = createCanvas().getContext('2d');
	  }
	
	  return _ctx;
	}
	/**
	 * 查询数组中元素的index
	 * @memberOf module:zrender/core/util
	 */
	
	
	function indexOf(array, value) {
	  if (array) {
	    if (array.indexOf) {
	      return array.indexOf(value);
	    }
	
	    for (var i = 0, len = array.length; i < len; i++) {
	      if (array[i] === value) {
	        return i;
	      }
	    }
	  }
	
	  return -1;
	}
	/**
	 * 构造类继承关系
	 *
	 * @memberOf module:zrender/core/util
	 * @param {Function} clazz 源类
	 * @param {Function} baseClazz 基类
	 */
	
	
	function inherits(clazz, baseClazz) {
	  var clazzPrototype = clazz.prototype;
	
	  function F() {}
	
	  F.prototype = baseClazz.prototype;
	  clazz.prototype = new F();
	
	  for (var prop in clazzPrototype) {
	    clazz.prototype[prop] = clazzPrototype[prop];
	  }
	
	  clazz.prototype.constructor = clazz;
	  clazz.superClass = baseClazz;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Object|Function} target
	 * @param {Object|Function} sorce
	 * @param {boolean} overlay
	 */
	
	
	function mixin(target, source, overlay) {
	  target = 'prototype' in target ? target.prototype : target;
	  source = 'prototype' in source ? source.prototype : source;
	  defaults(target, source, overlay);
	}
	/**
	 * Consider typed array.
	 * @param {Array|TypedArray} data
	 */
	
	
	function isArrayLike(data) {
	  if (!data) {
	    return;
	  }
	
	  if (typeof data == 'string') {
	    return false;
	  }
	
	  return typeof data.length == 'number';
	}
	/**
	 * 数组或对象遍历
	 * @memberOf module:zrender/core/util
	 * @param {Object|Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 */
	
	
	function each(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.forEach && obj.forEach === nativeForEach) {
	    obj.forEach(cb, context);
	  } else if (obj.length === +obj.length) {
	    for (var i = 0, len = obj.length; i < len; i++) {
	      cb.call(context, obj[i], i, obj);
	    }
	  } else {
	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        cb.call(context, obj[key], key, obj);
	      }
	    }
	  }
	}
	/**
	 * 数组映射
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 * @return {Array}
	 */
	
	
	function map(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.map && obj.map === nativeMap) {
	    return obj.map(cb, context);
	  } else {
	    var result = [];
	
	    for (var i = 0, len = obj.length; i < len; i++) {
	      result.push(cb.call(context, obj[i], i, obj));
	    }
	
	    return result;
	  }
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {Object} [memo]
	 * @param {*} [context]
	 * @return {Array}
	 */
	
	
	function reduce(obj, cb, memo, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.reduce && obj.reduce === nativeReduce) {
	    return obj.reduce(cb, memo, context);
	  } else {
	    for (var i = 0, len = obj.length; i < len; i++) {
	      memo = cb.call(context, memo, obj[i], i, obj);
	    }
	
	    return memo;
	  }
	}
	/**
	 * 数组过滤
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 * @return {Array}
	 */
	
	
	function filter(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.filter && obj.filter === nativeFilter) {
	    return obj.filter(cb, context);
	  } else {
	    var result = [];
	
	    for (var i = 0, len = obj.length; i < len; i++) {
	      if (cb.call(context, obj[i], i, obj)) {
	        result.push(obj[i]);
	      }
	    }
	
	    return result;
	  }
	}
	/**
	 * 数组项查找
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 * @return {*}
	 */
	
	
	function find(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  for (var i = 0, len = obj.length; i < len; i++) {
	    if (cb.call(context, obj[i], i, obj)) {
	      return obj[i];
	    }
	  }
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Function} func
	 * @param {*} context
	 * @return {Function}
	 */
	
	
	function bind(func, context) {
	  var args = nativeSlice.call(arguments, 2);
	  return function () {
	    return func.apply(context, args.concat(nativeSlice.call(arguments)));
	  };
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Function} func
	 * @return {Function}
	 */
	
	
	function curry(func) {
	  var args = nativeSlice.call(arguments, 1);
	  return function () {
	    return func.apply(this, args.concat(nativeSlice.call(arguments)));
	  };
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isArray(value) {
	  return objToString.call(value) === '[object Array]';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isFunction(value) {
	  return typeof value === 'function';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isString(value) {
	  return objToString.call(value) === '[object String]';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return type === 'function' || !!value && type == 'object';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isBuiltInObject(value) {
	  return !!BUILTIN_OBJECT[objToString.call(value)];
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isDom(value) {
	  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';
	}
	/**
	 * Whether is exactly NaN. Notice isNaN('a') returns true.
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function eqNaN(value) {
	  return value !== value;
	}
	/**
	 * If value1 is not null, then return value1, otherwise judget rest of values.
	 * Low performance.
	 * @memberOf module:zrender/core/util
	 * @return {*} Final value
	 */
	
	
	function retrieve(values) {
	  for (var i = 0, len = arguments.length; i < len; i++) {
	    if (arguments[i] != null) {
	      return arguments[i];
	    }
	  }
	}
	
	function retrieve2(value0, value1) {
	  return value0 != null ? value0 : value1;
	}
	
	function retrieve3(value0, value1, value2) {
	  return value0 != null ? value0 : value1 != null ? value1 : value2;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Array} arr
	 * @param {number} startIndex
	 * @param {number} endIndex
	 * @return {Array}
	 */
	
	
	function slice() {
	  return Function.call.apply(nativeSlice, arguments);
	}
	/**
	 * Normalize css liked array configuration
	 * e.g.
	 *  3 => [3, 3, 3, 3]
	 *  [4, 2] => [4, 2, 4, 2]
	 *  [4, 3, 2] => [4, 3, 2, 3]
	 * @param {number|Array.<number>} val
	 * @return {Array.<number>}
	 */
	
	
	function normalizeCssArray(val) {
	  if (typeof val === 'number') {
	    return [val, val, val, val];
	  }
	
	  var len = val.length;
	
	  if (len === 2) {
	    // vertical | horizontal
	    return [val[0], val[1], val[0], val[1]];
	  } else if (len === 3) {
	    // top | horizontal | bottom
	    return [val[0], val[1], val[2], val[1]];
	  }
	
	  return val;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {boolean} condition
	 * @param {string} message
	 */
	
	
	function assert(condition, message) {
	  if (!condition) {
	    throw new Error(message);
	  }
	}
	
	var primitiveKey = '__ec_primitive__';
	/**
	 * Set an object as primitive to be ignored traversing children in clone or merge
	 */
	
	function setAsPrimitive(obj) {
	  obj[primitiveKey] = true;
	}
	
	function isPrimitive(obj) {
	  return obj[primitiveKey];
	}
	/**
	 * @constructor
	 * @param {Object} obj Only apply `ownProperty`.
	 */
	
	
	function HashMap(obj) {
	  obj && each(obj, function (value, key) {
	    this.set(key, value);
	  }, this);
	} // Add prefix to avoid conflict with Object.prototype.
	
	
	var HASH_MAP_PREFIX = '_ec_';
	var HASH_MAP_PREFIX_LENGTH = 4;
	HashMap.prototype = {
	  constructor: HashMap,
	  // Do not provide `has` method to avoid defining what is `has`.
	  // (We usually treat `null` and `undefined` as the same, different
	  // from ES6 Map).
	  get: function (key) {
	    return this[HASH_MAP_PREFIX + key];
	  },
	  set: function (key, value) {
	    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly
	    // used in this case: `var someVal = map.set('a', genVal());`
	
	    return value;
	  },
	  // Although util.each can be performed on this hashMap directly, user
	  // should not use the exposed keys, who are prefixed.
	  each: function (cb, context) {
	    context !== void 0 && (cb = bind(cb, context));
	
	    for (var prefixedKey in this) {
	      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));
	    }
	  },
	  // Do not use this method if performance sensitive.
	  removeKey: function (key) {
	    delete this[HASH_MAP_PREFIX + key];
	  }
	};
	
	function createHashMap(obj) {
	  return new HashMap(obj);
	}
	
	function noop() {}
	
	exports.$override = $override;
	exports.clone = clone;
	exports.merge = merge;
	exports.mergeAll = mergeAll;
	exports.extend = extend;
	exports.defaults = defaults;
	exports.createCanvas = createCanvas;
	exports.getContext = getContext;
	exports.indexOf = indexOf;
	exports.inherits = inherits;
	exports.mixin = mixin;
	exports.isArrayLike = isArrayLike;
	exports.each = each;
	exports.map = map;
	exports.reduce = reduce;
	exports.filter = filter;
	exports.find = find;
	exports.bind = bind;
	exports.curry = curry;
	exports.isArray = isArray;
	exports.isFunction = isFunction;
	exports.isString = isString;
	exports.isObject = isObject;
	exports.isBuiltInObject = isBuiltInObject;
	exports.isDom = isDom;
	exports.eqNaN = eqNaN;
	exports.retrieve = retrieve;
	exports.retrieve2 = retrieve2;
	exports.retrieve3 = retrieve3;
	exports.slice = slice;
	exports.normalizeCssArray = normalizeCssArray;
	exports.assert = assert;
	exports.setAsPrimitive = setAsPrimitive;
	exports.isPrimitive = isPrimitive;
	exports.createHashMap = createHashMap;
	exports.noop = noop;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	var PathProxy = __webpack_require__(30);
	
	var transformPath = __webpack_require__(41);
	
	// command chars
	var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
	var mathSqrt = Math.sqrt;
	var mathSin = Math.sin;
	var mathCos = Math.cos;
	var PI = Math.PI;
	
	var vMag = function (v) {
	  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	};
	
	var vRatio = function (u, v) {
	  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	};
	
	var vAngle = function (u, v) {
	  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
	};
	
	function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
	  var psi = psiDeg * (PI / 180.0);
	  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;
	  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;
	  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
	
	  if (lambda > 1) {
	    rx *= mathSqrt(lambda);
	    ry *= mathSqrt(lambda);
	  }
	
	  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
	  var cxp = f * rx * yp / ry;
	  var cyp = f * -ry * xp / rx;
	  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;
	  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;
	  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
	  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
	  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
	  var dTheta = vAngle(u, v);
	
	  if (vRatio(u, v) <= -1) {
	    dTheta = PI;
	  }
	
	  if (vRatio(u, v) >= 1) {
	    dTheta = 0;
	  }
	
	  if (fs === 0 && dTheta > 0) {
	    dTheta = dTheta - 2 * PI;
	  }
	
	  if (fs === 1 && dTheta < 0) {
	    dTheta = dTheta + 2 * PI;
	  }
	
	  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
	}
	
	function createPathProxyFromString(data) {
	  if (!data) {
	    return [];
	  } // command string
	
	
	  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');
	  var n; // create pipes so that we can split the data
	
	  for (n = 0; n < cc.length; n++) {
	    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
	  } // create array
	
	
	  var arr = cs.split('|'); // init context point
	
	  var cpx = 0;
	  var cpy = 0;
	  var path = new PathProxy();
	  var CMD = PathProxy.CMD;
	  var prevCmd;
	
	  for (n = 1; n < arr.length; n++) {
	    var str = arr[n];
	    var c = str.charAt(0);
	    var off = 0;
	    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
	    var cmd;
	
	    if (p.length > 0 && p[0] === '') {
	      p.shift();
	    }
	
	    for (var i = 0; i < p.length; i++) {
	      p[i] = parseFloat(p[i]);
	    }
	
	    while (off < p.length && !isNaN(p[off])) {
	      if (isNaN(p[0])) {
	        break;
	      }
	
	      var ctlPtx;
	      var ctlPty;
	      var rx;
	      var ry;
	      var psi;
	      var fa;
	      var fs;
	      var x1 = cpx;
	      var y1 = cpy; // convert l, H, h, V, and v to L
	
	      switch (c) {
	        case 'l':
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'L':
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'm':
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.M;
	          path.addData(cmd, cpx, cpy);
	          c = 'l';
	          break;
	
	        case 'M':
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.M;
	          path.addData(cmd, cpx, cpy);
	          c = 'L';
	          break;
	
	        case 'h':
	          cpx += p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'H':
	          cpx = p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'v':
	          cpy += p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'V':
	          cpy = p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'C':
	          cmd = CMD.C;
	          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
	          cpx = p[off - 2];
	          cpy = p[off - 1];
	          break;
	
	        case 'c':
	          cmd = CMD.C;
	          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
	          cpx += p[off - 2];
	          cpy += p[off - 1];
	          break;
	
	        case 'S':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.C) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cmd = CMD.C;
	          x1 = p[off++];
	          y1 = p[off++];
	          cpx = p[off++];
	          cpy = p[off++];
	          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	          break;
	
	        case 's':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.C) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cmd = CMD.C;
	          x1 = cpx + p[off++];
	          y1 = cpy + p[off++];
	          cpx += p[off++];
	          cpy += p[off++];
	          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	          break;
	
	        case 'Q':
	          x1 = p[off++];
	          y1 = p[off++];
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, x1, y1, cpx, cpy);
	          break;
	
	        case 'q':
	          x1 = p[off++] + cpx;
	          y1 = p[off++] + cpy;
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, x1, y1, cpx, cpy);
	          break;
	
	        case 'T':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.Q) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	          break;
	
	        case 't':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.Q) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	          break;
	
	        case 'A':
	          rx = p[off++];
	          ry = p[off++];
	          psi = p[off++];
	          fa = p[off++];
	          fs = p[off++];
	          x1 = cpx, y1 = cpy;
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.A;
	          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
	          break;
	
	        case 'a':
	          rx = p[off++];
	          ry = p[off++];
	          psi = p[off++];
	          fa = p[off++];
	          fs = p[off++];
	          x1 = cpx, y1 = cpy;
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.A;
	          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
	          break;
	      }
	    }
	
	    if (c === 'z' || c === 'Z') {
	      cmd = CMD.Z;
	      path.addData(cmd);
	    }
	
	    prevCmd = cmd;
	  }
	
	  path.toStatic();
	  return path;
	} // TODO Optimize double memory cost problem
	
	
	function createPathOptions(str, opts) {
	  var pathProxy = createPathProxyFromString(str);
	  opts = opts || {};
	
	  opts.buildPath = function (path) {
	    if (path.setData) {
	      path.setData(pathProxy.data); // Svg and vml renderer don't have context
	
	      var ctx = path.getContext();
	
	      if (ctx) {
	        path.rebuildPath(ctx);
	      }
	    } else {
	      var ctx = path;
	      pathProxy.rebuildPath(ctx);
	    }
	  };
	
	  opts.applyTransform = function (m) {
	    transformPath(pathProxy, m);
	    this.dirty(true);
	  };
	
	  return opts;
	}
	/**
	 * Create a Path object from path string data
	 * http://www.w3.org/TR/SVG/paths.html#PathData
	 * @param  {Object} opts Other options
	 */
	
	
	function createFromString(str, opts) {
	  return new Path(createPathOptions(str, opts));
	}
	/**
	 * Create a Path class from path string data
	 * @param  {string} str
	 * @param  {Object} opts Other options
	 */
	
	
	function extendFromString(str, opts) {
	  return Path.extend(createPathOptions(str, opts));
	}
	/**
	 * Merge multiple paths
	 */
	// TODO Apply transform
	// TODO stroke dash
	// TODO Optimize double memory cost problem
	
	
	function mergePath(pathEls, opts) {
	  var pathList = [];
	  var len = pathEls.length;
	
	  for (var i = 0; i < len; i++) {
	    var pathEl = pathEls[i];
	
	    if (!pathEl.path) {
	      pathEl.createPathProxy();
	    }
	
	    if (pathEl.__dirtyPath) {
	      pathEl.buildPath(pathEl.path, pathEl.shape, true);
	    }
	
	    pathList.push(pathEl.path);
	  }
	
	  var pathBundle = new Path(opts); // Need path proxy.
	
	  pathBundle.createPathProxy();
	
	  pathBundle.buildPath = function (path) {
	    path.appendPath(pathList); // Svg and vml renderer don't have context
	
	    var ctx = path.getContext();
	
	    if (ctx) {
	      path.rebuildPath(ctx);
	    }
	  };
	
	  return pathBundle;
	}
	
	exports.createFromString = createFromString;
	exports.extendFromString = extendFromString;
	exports.mergePath = mergePath;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	var Displayable = __webpack_require__(8);
	
	var zrUtil = __webpack_require__(5);
	
	var PathProxy = __webpack_require__(30);
	
	var pathContain = __webpack_require__(33);
	
	var Pattern = __webpack_require__(40);
	
	var getCanvasPattern = Pattern.prototype.getCanvasPattern;
	var abs = Math.abs;
	var pathProxyForDraw = new PathProxy(true);
	/**
	 * @alias module:zrender/graphic/Path
	 * @extends module:zrender/graphic/Displayable
	 * @constructor
	 * @param {Object} opts
	 */
	
	function Path(opts) {
	  Displayable.call(this, opts);
	  /**
	   * @type {module:zrender/core/PathProxy}
	   * @readOnly
	   */
	
	  this.path = null;
	}
	
	Path.prototype = {
	  constructor: Path,
	  type: 'path',
	  __dirtyPath: true,
	  strokeContainThreshold: 5,
	  brush: function (ctx, prevEl) {
	    var style = this.style;
	    var path = this.path || pathProxyForDraw;
	    var hasStroke = style.hasStroke();
	    var hasFill = style.hasFill();
	    var fill = style.fill;
	    var stroke = style.stroke;
	    var hasFillGradient = hasFill && !!fill.colorStops;
	    var hasStrokeGradient = hasStroke && !!stroke.colorStops;
	    var hasFillPattern = hasFill && !!fill.image;
	    var hasStrokePattern = hasStroke && !!stroke.image;
	    style.bind(ctx, this, prevEl);
	    this.setTransform(ctx);
	
	    if (this.__dirty) {
	      var rect; // Update gradient because bounding rect may changed
	
	      if (hasFillGradient) {
	        rect = rect || this.getBoundingRect();
	        this._fillGradient = style.getGradient(ctx, fill, rect);
	      }
	
	      if (hasStrokeGradient) {
	        rect = rect || this.getBoundingRect();
	        this._strokeGradient = style.getGradient(ctx, stroke, rect);
	      }
	    } // Use the gradient or pattern
	
	
	    if (hasFillGradient) {
	      // PENDING If may have affect the state
	      ctx.fillStyle = this._fillGradient;
	    } else if (hasFillPattern) {
	      ctx.fillStyle = getCanvasPattern.call(fill, ctx);
	    }
	
	    if (hasStrokeGradient) {
	      ctx.strokeStyle = this._strokeGradient;
	    } else if (hasStrokePattern) {
	      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
	    }
	
	    var lineDash = style.lineDash;
	    var lineDashOffset = style.lineDashOffset;
	    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy
	
	    var scale = this.getGlobalScale();
	    path.setScale(scale[0], scale[1]); // Proxy context
	    // Rebuild path in following 2 cases
	    // 1. Path is dirty
	    // 2. Path needs javascript implemented lineDash stroking.
	    //    In this case, lineDash information will not be saved in PathProxy
	
	    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
	      path.beginPath(ctx); // Setting line dash before build path
	
	      if (lineDash && !ctxLineDash) {
	        path.setLineDash(lineDash);
	        path.setLineDashOffset(lineDashOffset);
	      }
	
	      this.buildPath(path, this.shape, false); // Clear path dirty flag
	
	      if (this.path) {
	        this.__dirtyPath = false;
	      }
	    } else {
	      // Replay path building
	      ctx.beginPath();
	      this.path.rebuildPath(ctx);
	    }
	
	    hasFill && path.fill(ctx);
	
	    if (lineDash && ctxLineDash) {
	      ctx.setLineDash(lineDash);
	      ctx.lineDashOffset = lineDashOffset;
	    }
	
	    hasStroke && path.stroke(ctx);
	
	    if (lineDash && ctxLineDash) {
	      // PENDING
	      // Remove lineDash
	      ctx.setLineDash([]);
	    }
	
	    this.restoreTransform(ctx); // Draw rect text
	
	    if (style.text != null) {
	      this.drawRectText(ctx, this.getBoundingRect());
	    }
	  },
	  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
	  // Like in circle
	  buildPath: function (ctx, shapeCfg, inBundle) {},
	  createPathProxy: function () {
	    this.path = new PathProxy();
	  },
	  getBoundingRect: function () {
	    var rect = this._rect;
	    var style = this.style;
	    var needsUpdateRect = !rect;
	
	    if (needsUpdateRect) {
	      var path = this.path;
	
	      if (!path) {
	        // Create path on demand.
	        path = this.path = new PathProxy();
	      }
	
	      if (this.__dirtyPath) {
	        path.beginPath();
	        this.buildPath(path, this.shape, false);
	      }
	
	      rect = path.getBoundingRect();
	    }
	
	    this._rect = rect;
	
	    if (style.hasStroke()) {
	      // Needs update rect with stroke lineWidth when
	      // 1. Element changes scale or lineWidth
	      // 2. Shape is changed
	      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
	
	      if (this.__dirty || needsUpdateRect) {
	        rectWithStroke.copy(rect); // FIXME Must after updateTransform
	
	        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical
	
	        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill
	
	        if (!style.hasFill()) {
	          w = Math.max(w, this.strokeContainThreshold || 4);
	        } // Consider line width
	        // Line scale can't be 0;
	
	
	        if (lineScale > 1e-10) {
	          rectWithStroke.width += w / lineScale;
	          rectWithStroke.height += w / lineScale;
	          rectWithStroke.x -= w / lineScale / 2;
	          rectWithStroke.y -= w / lineScale / 2;
	        }
	      } // Return rect with stroke
	
	
	      return rectWithStroke;
	    }
	
	    return rect;
	  },
	  contain: function (x, y) {
	    var localPos = this.transformCoordToLocal(x, y);
	    var rect = this.getBoundingRect();
	    var style = this.style;
	    x = localPos[0];
	    y = localPos[1];
	
	    if (rect.contain(x, y)) {
	      var pathData = this.path.data;
	
	      if (style.hasStroke()) {
	        var lineWidth = style.lineWidth;
	        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;
	
	        if (lineScale > 1e-10) {
	          // Only add extra hover lineWidth when there are no fill
	          if (!style.hasFill()) {
	            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
	          }
	
	          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {
	            return true;
	          }
	        }
	      }
	
	      if (style.hasFill()) {
	        return pathContain.contain(pathData, x, y);
	      }
	    }
	
	    return false;
	  },
	
	  /**
	   * @param  {boolean} dirtyPath
	   */
	  dirty: function (dirtyPath) {
	    if (dirtyPath == null) {
	      dirtyPath = true;
	    } // Only mark dirty, not mark clean
	
	
	    if (dirtyPath) {
	      this.__dirtyPath = dirtyPath;
	      this._rect = null;
	    }
	
	    this.__dirty = true;
	    this.__zr && this.__zr.refresh(); // Used as a clipping path
	
	    if (this.__clipTarget) {
	      this.__clipTarget.dirty();
	    }
	  },
	
	  /**
	   * Alias for animate('shape')
	   * @param {boolean} loop
	   */
	  animateShape: function (loop) {
	    return this.animate('shape', loop);
	  },
	  // Overwrite attrKV
	  attrKV: function (key, value) {
	    // FIXME
	    if (key === 'shape') {
	      this.setShape(value);
	      this.__dirtyPath = true;
	      this._rect = null;
	    } else {
	      Displayable.prototype.attrKV.call(this, key, value);
	    }
	  },
	
	  /**
	   * @param {Object|string} key
	   * @param {*} value
	   */
	  setShape: function (key, value) {
	    var shape = this.shape; // Path from string may not have shape
	
	    if (shape) {
	      if (zrUtil.isObject(key)) {
	        for (var name in key) {
	          if (key.hasOwnProperty(name)) {
	            shape[name] = key[name];
	          }
	        }
	      } else {
	        shape[key] = value;
	      }
	
	      this.dirty(true);
	    }
	
	    return this;
	  },
	  getLineScale: function () {
	    var m = this.transform; // Get the line scale.
	    // Determinant of `m` means how much the area is enlarged by the
	    // transformation. So its square root can be used as a scale factor
	    // for width.
	
	    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
	  }
	};
	/**
	 * 扩展一个 Path element, 比如星形，圆等。
	 * Extend a path element
	 * @param {Object} props
	 * @param {string} props.type Path type
	 * @param {Function} props.init Initialize
	 * @param {Function} props.buildPath Overwrite buildPath method
	 * @param {Object} [props.style] Extended default style config
	 * @param {Object} [props.shape] Extended default shape config
	 */
	
	Path.extend = function (defaults) {
	  var Sub = function (opts) {
	    Path.call(this, opts);
	
	    if (defaults.style) {
	      // Extend default style
	      this.style.extendFrom(defaults.style, false);
	    } // Extend default shape
	
	
	    var defaultShape = defaults.shape;
	
	    if (defaultShape) {
	      this.shape = this.shape || {};
	      var thisShape = this.shape;
	
	      for (var name in defaultShape) {
	        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {
	          thisShape[name] = defaultShape[name];
	        }
	      }
	    }
	
	    defaults.init && defaults.init.call(this, opts);
	  };
	
	  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象
	
	  for (var name in defaults) {
	    // Extending prototype values and methods
	    if (name !== 'style' && name !== 'shape') {
	      Sub.prototype[name] = defaults[name];
	    }
	  }
	
	  return Sub;
	};
	
	zrUtil.inherits(Path, Displayable);
	var _default = Path;
	module.exports = _default;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(5);
	
	var Style = __webpack_require__(9);
	
	var Element = __webpack_require__(10);
	
	var RectText = __webpack_require__(24);
	
	/**
	 * 可绘制的图形基类
	 * Base class of all displayable graphic objects
	 * @module zrender/graphic/Displayable
	 */
	
	/**
	 * @alias module:zrender/graphic/Displayable
	 * @extends module:zrender/Element
	 * @extends module:zrender/graphic/mixin/RectText
	 */
	function Displayable(opts) {
	  opts = opts || {};
	  Element.call(this, opts); // Extend properties
	
	  for (var name in opts) {
	    if (opts.hasOwnProperty(name) && name !== 'style') {
	      this[name] = opts[name];
	    }
	  }
	  /**
	   * @type {module:zrender/graphic/Style}
	   */
	
	
	  this.style = new Style(opts.style, this);
	  this._rect = null; // Shapes for cascade clipping.
	
	  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted
	  // Stateful.call(this, opts);
	}
	
	Displayable.prototype = {
	  constructor: Displayable,
	  type: 'displayable',
	
	  /**
	   * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
	   * Dirty flag. From which painter will determine if this displayable object needs brush
	   * @name module:zrender/graphic/Displayable#__dirty
	   * @type {boolean}
	   */
	  __dirty: true,
	
	  /**
	   * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
	   * If ignore drawing of the displayable object. Mouse event will still be triggered
	   * @name module:/zrender/graphic/Displayable#invisible
	   * @type {boolean}
	   * @default false
	   */
	  invisible: false,
	
	  /**
	   * @name module:/zrender/graphic/Displayable#z
	   * @type {number}
	   * @default 0
	   */
	  z: 0,
	
	  /**
	   * @name module:/zrender/graphic/Displayable#z
	   * @type {number}
	   * @default 0
	   */
	  z2: 0,
	
	  /**
	   * z层level，决定绘画在哪层canvas中
	   * @name module:/zrender/graphic/Displayable#zlevel
	   * @type {number}
	   * @default 0
	   */
	  zlevel: 0,
	
	  /**
	   * 是否可拖拽
	   * @name module:/zrender/graphic/Displayable#draggable
	   * @type {boolean}
	   * @default false
	   */
	  draggable: false,
	
	  /**
	   * 是否正在拖拽
	   * @name module:/zrender/graphic/Displayable#draggable
	   * @type {boolean}
	   * @default false
	   */
	  dragging: false,
	
	  /**
	   * 是否相应鼠标事件
	   * @name module:/zrender/graphic/Displayable#silent
	   * @type {boolean}
	   * @default false
	   */
	  silent: false,
	
	  /**
	   * If enable culling
	   * @type {boolean}
	   * @default false
	   */
	  culling: false,
	
	  /**
	   * Mouse cursor when hovered
	   * @name module:/zrender/graphic/Displayable#cursor
	   * @type {string}
	   */
	  cursor: 'pointer',
	
	  /**
	   * If hover area is bounding rect
	   * @name module:/zrender/graphic/Displayable#rectHover
	   * @type {string}
	   */
	  rectHover: false,
	
	  /**
	   * Render the element progressively when the value >= 0,
	   * usefull for large data.
	   * @type {number}
	   */
	  progressive: -1,
	  beforeBrush: function (ctx) {},
	  afterBrush: function (ctx) {},
	
	  /**
	   * 图形绘制方法
	   * @param {CanvasRenderingContext2D} ctx
	   */
	  // Interface
	  brush: function (ctx, prevEl) {},
	
	  /**
	   * 获取最小包围盒
	   * @return {module:zrender/core/BoundingRect}
	   */
	  // Interface
	  getBoundingRect: function () {},
	
	  /**
	   * 判断坐标 x, y 是否在图形上
	   * If displayable element contain coord x, y
	   * @param  {number} x
	   * @param  {number} y
	   * @return {boolean}
	   */
	  contain: function (x, y) {
	    return this.rectContain(x, y);
	  },
	
	  /**
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  traverse: function (cb, context) {
	    cb.call(context, this);
	  },
	
	  /**
	   * 判断坐标 x, y 是否在图形的包围盒上
	   * If bounding rect of element contain coord x, y
	   * @param  {number} x
	   * @param  {number} y
	   * @return {boolean}
	   */
	  rectContain: function (x, y) {
	    var coord = this.transformCoordToLocal(x, y);
	    var rect = this.getBoundingRect();
	    return rect.contain(coord[0], coord[1]);
	  },
	
	  /**
	   * 标记图形元素为脏，并且在下一帧重绘
	   * Mark displayable element dirty and refresh next frame
	   */
	  dirty: function () {
	    this.__dirty = true;
	    this._rect = null;
	    this.__zr && this.__zr.refresh();
	  },
	
	  /**
	   * 图形是否会触发事件
	   * If displayable object binded any event
	   * @return {boolean}
	   */
	  // TODO, 通过 bind 绑定的事件
	  // isSilent: function () {
	  //     return !(
	  //         this.hoverable || this.draggable
	  //         || this.onmousemove || this.onmouseover || this.onmouseout
	  //         || this.onmousedown || this.onmouseup || this.onclick
	  //         || this.ondragenter || this.ondragover || this.ondragleave
	  //         || this.ondrop
	  //     );
	  // },
	
	  /**
	   * Alias for animate('style')
	   * @param {boolean} loop
	   */
	  animateStyle: function (loop) {
	    return this.animate('style', loop);
	  },
	  attrKV: function (key, value) {
	    if (key !== 'style') {
	      Element.prototype.attrKV.call(this, key, value);
	    } else {
	      this.style.set(value);
	    }
	  },
	
	  /**
	   * @param {Object|string} key
	   * @param {*} value
	   */
	  setStyle: function (key, value) {
	    this.style.set(key, value);
	    this.dirty(false);
	    return this;
	  },
	
	  /**
	   * Use given style object
	   * @param  {Object} obj
	   */
	  useStyle: function (obj) {
	    this.style = new Style(obj, this);
	    this.dirty(false);
	    return this;
	  }
	};
	zrUtil.inherits(Displayable, Element);
	zrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);
	
	var _default = Displayable;
	module.exports = _default;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
	// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);
	
	var Style = function (opts, host) {
	  this.extendFrom(opts, false);
	  this.host = host;
	};
	
	function createLinearGradient(ctx, obj, rect) {
	  var x = obj.x == null ? 0 : obj.x;
	  var x2 = obj.x2 == null ? 1 : obj.x2;
	  var y = obj.y == null ? 0 : obj.y;
	  var y2 = obj.y2 == null ? 0 : obj.y2;
	
	  if (!obj.global) {
	    x = x * rect.width + rect.x;
	    x2 = x2 * rect.width + rect.x;
	    y = y * rect.height + rect.y;
	    y2 = y2 * rect.height + rect.y;
	  }
	
	  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
	  return canvasGradient;
	}
	
	function createRadialGradient(ctx, obj, rect) {
	  var width = rect.width;
	  var height = rect.height;
	  var min = Math.min(width, height);
	  var x = obj.x == null ? 0.5 : obj.x;
	  var y = obj.y == null ? 0.5 : obj.y;
	  var r = obj.r == null ? 0.5 : obj.r;
	
	  if (!obj.global) {
	    x = x * width + rect.x;
	    y = y * height + rect.y;
	    r = r * min;
	  }
	
	  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
	  return canvasGradient;
	}
	
	Style.prototype = {
	  constructor: Style,
	
	  /**
	   * @type {module:zrender/graphic/Displayable}
	   */
	  host: null,
	
	  /**
	   * @type {string}
	   */
	  fill: '#000',
	
	  /**
	   * @type {string}
	   */
	  stroke: null,
	
	  /**
	   * @type {number}
	   */
	  opacity: 1,
	
	  /**
	   * @type {Array.<number>}
	   */
	  lineDash: null,
	
	  /**
	   * @type {number}
	   */
	  lineDashOffset: 0,
	
	  /**
	   * @type {number}
	   */
	  shadowBlur: 0,
	
	  /**
	   * @type {number}
	   */
	  shadowOffsetX: 0,
	
	  /**
	   * @type {number}
	   */
	  shadowOffsetY: 0,
	
	  /**
	   * @type {number}
	   */
	  lineWidth: 1,
	
	  /**
	   * If stroke ignore scale
	   * @type {Boolean}
	   */
	  strokeNoScale: false,
	  // Bounding rect text configuration
	  // Not affected by element transform
	
	  /**
	   * @type {string}
	   */
	  text: null,
	
	  /**
	   * If `fontSize` or `fontFamily` exists, `font` will be reset by
	   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
	   * So do not visit it directly in upper application (like echarts),
	   * but use `contain/text#makeFont` instead.
	   * @type {string}
	   */
	  font: null,
	
	  /**
	   * The same as font. Use font please.
	   * @deprecated
	   * @type {string}
	   */
	  textFont: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * @type {string}
	   */
	  fontStyle: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * @type {string}
	   */
	  fontWeight: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * Should be 12 but not '12px'.
	   * @type {number}
	   */
	  fontSize: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * @type {string}
	   */
	  fontFamily: null,
	
	  /**
	   * Reserved for special functinality, like 'hr'.
	   * @type {string}
	   */
	  textTag: null,
	
	  /**
	   * @type {string}
	   */
	  textFill: '#000',
	
	  /**
	   * @type {string}
	   */
	  textStroke: null,
	
	  /**
	   * @type {number}
	   */
	  textWidth: null,
	
	  /**
	   * Only for textBackground.
	   * @type {number}
	   */
	  textHeight: null,
	
	  /**
	   * textStroke may be set as some color as a default
	   * value in upper applicaion, where the default value
	   * of textStrokeWidth should be 0 to make sure that
	   * user can choose to do not use text stroke.
	   * @type {number}
	   */
	  textStrokeWidth: 0,
	
	  /**
	   * @type {number}
	   */
	  textLineHeight: null,
	
	  /**
	   * 'inside', 'left', 'right', 'top', 'bottom'
	   * [x, y]
	   * Based on x, y of rect.
	   * @type {string|Array.<number>}
	   * @default 'inside'
	   */
	  textPosition: 'inside',
	
	  /**
	   * If not specified, use the boundingRect of a `displayable`.
	   * @type {Object}
	   */
	  textRect: null,
	
	  /**
	   * [x, y]
	   * @type {Array.<number>}
	   */
	  textOffset: null,
	
	  /**
	   * @type {string}
	   */
	  textAlign: null,
	
	  /**
	   * @type {string}
	   */
	  textVerticalAlign: null,
	
	  /**
	   * @type {number}
	   */
	  textDistance: 5,
	
	  /**
	   * @type {string}
	   */
	  textShadowColor: 'transparent',
	
	  /**
	   * @type {number}
	   */
	  textShadowBlur: 0,
	
	  /**
	   * @type {number}
	   */
	  textShadowOffsetX: 0,
	
	  /**
	   * @type {number}
	   */
	  textShadowOffsetY: 0,
	
	  /**
	   * @type {string}
	   */
	  textBoxShadowColor: 'transparent',
	
	  /**
	   * @type {number}
	   */
	  textBoxShadowBlur: 0,
	
	  /**
	   * @type {number}
	   */
	  textBoxShadowOffsetX: 0,
	
	  /**
	   * @type {number}
	   */
	  textBoxShadowOffsetY: 0,
	
	  /**
	   * Whether transform text.
	   * Only useful in Path and Image element
	   * @type {boolean}
	   */
	  transformText: false,
	
	  /**
	   * Text rotate around position of Path or Image
	   * Only useful in Path and Image element and transformText is false.
	   */
	  textRotation: 0,
	
	  /**
	   * Text origin of text rotation, like [10, 40].
	   * Based on x, y of rect.
	   * Useful in label rotation of circular symbol.
	   * By default, this origin is textPosition.
	   * Can be 'center'.
	   * @type {string|Array.<number>}
	   */
	  textOrigin: null,
	
	  /**
	   * @type {string}
	   */
	  textBackgroundColor: null,
	
	  /**
	   * @type {string}
	   */
	  textBorderColor: null,
	
	  /**
	   * @type {number}
	   */
	  textBorderWidth: 0,
	
	  /**
	   * @type {number}
	   */
	  textBorderRadius: 0,
	
	  /**
	   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
	   * @type {number|Array.<number>}
	   */
	  textPadding: null,
	
	  /**
	   * Text styles for rich text.
	   * @type {Object}
	   */
	  rich: null,
	
	  /**
	   * {outerWidth, outerHeight, ellipsis, placeholder}
	   * @type {Object}
	   */
	  truncate: null,
	
	  /**
	   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
	   * @type {string}
	   */
	  blend: null,
	
	  /**
	   * @param {CanvasRenderingContext2D} ctx
	   */
	  bind: function (ctx, el, prevEl) {
	    var style = this;
	    var prevStyle = prevEl && prevEl.style;
	    var firstDraw = !prevStyle;
	
	    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	      var prop = STYLE_COMMON_PROPS[i];
	      var styleName = prop[0];
	
	      if (firstDraw || style[styleName] !== prevStyle[styleName]) {
	        // FIXME Invalid property value will cause style leak from previous element.
	        ctx[styleName] = style[styleName] || prop[1];
	      }
	    }
	
	    if (firstDraw || style.fill !== prevStyle.fill) {
	      ctx.fillStyle = style.fill;
	    }
	
	    if (firstDraw || style.stroke !== prevStyle.stroke) {
	      ctx.strokeStyle = style.stroke;
	    }
	
	    if (firstDraw || style.opacity !== prevStyle.opacity) {
	      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
	    }
	
	    if (firstDraw || style.blend !== prevStyle.blend) {
	      ctx.globalCompositeOperation = style.blend || 'source-over';
	    }
	
	    if (this.hasStroke()) {
	      var lineWidth = style.lineWidth;
	      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
	    }
	  },
	  hasFill: function () {
	    var fill = this.fill;
	    return fill != null && fill !== 'none';
	  },
	  hasStroke: function () {
	    var stroke = this.stroke;
	    return stroke != null && stroke !== 'none' && this.lineWidth > 0;
	  },
	
	  /**
	   * Extend from other style
	   * @param {zrender/graphic/Style} otherStyle
	   * @param {boolean} overwrite true: overwrirte any way.
	   *                            false: overwrite only when !target.hasOwnProperty
	   *                            others: overwrite when property is not null/undefined.
	   */
	  extendFrom: function (otherStyle, overwrite) {
	    if (otherStyle) {
	      for (var name in otherStyle) {
	        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {
	          this[name] = otherStyle[name];
	        }
	      }
	    }
	  },
	
	  /**
	   * Batch setting style with a given object
	   * @param {Object|string} obj
	   * @param {*} [obj]
	   */
	  set: function (obj, value) {
	    if (typeof obj === 'string') {
	      this[obj] = value;
	    } else {
	      this.extendFrom(obj, true);
	    }
	  },
	
	  /**
	   * Clone
	   * @return {zrender/graphic/Style} [description]
	   */
	  clone: function () {
	    var newStyle = new this.constructor();
	    newStyle.extendFrom(this, true);
	    return newStyle;
	  },
	  getGradient: function (ctx, obj, rect) {
	    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
	    var canvasGradient = method(ctx, obj, rect);
	    var colorStops = obj.colorStops;
	
	    for (var i = 0; i < colorStops.length; i++) {
	      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
	    }
	
	    return canvasGradient;
	  }
	};
	var styleProto = Style.prototype;
	
	for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	  var prop = STYLE_COMMON_PROPS[i];
	
	  if (!(prop[0] in styleProto)) {
	    styleProto[prop[0]] = prop[1];
	  }
	} // Provide for others
	
	
	Style.getGradient = styleProto.getGradient;
	var _default = Style;
	module.exports = _default;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	var guid = __webpack_require__(11);
	
	var Eventful = __webpack_require__(12);
	
	var Transformable = __webpack_require__(13);
	
	var Animatable = __webpack_require__(16);
	
	var zrUtil = __webpack_require__(5);
	
	/**
	 * @alias module:zrender/Element
	 * @constructor
	 * @extends {module:zrender/mixin/Animatable}
	 * @extends {module:zrender/mixin/Transformable}
	 * @extends {module:zrender/mixin/Eventful}
	 */
	var Element = function (opts) {
	  // jshint ignore:line
	  Transformable.call(this, opts);
	  Eventful.call(this, opts);
	  Animatable.call(this, opts);
	  /**
	   * 画布元素ID
	   * @type {string}
	   */
	
	  this.id = opts.id || guid();
	};
	
	Element.prototype = {
	  /**
	   * 元素类型
	   * Element type
	   * @type {string}
	   */
	  type: 'element',
	
	  /**
	   * 元素名字
	   * Element name
	   * @type {string}
	   */
	  name: '',
	
	  /**
	   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
	   * ZRender instance will be assigned when element is associated with zrender
	   * @name module:/zrender/Element#__zr
	   * @type {module:zrender/ZRender}
	   */
	  __zr: null,
	
	  /**
	   * 图形是否忽略，为true时忽略图形的绘制以及事件触发
	   * If ignore drawing and events of the element object
	   * @name module:/zrender/Element#ignore
	   * @type {boolean}
	   * @default false
	   */
	  ignore: false,
	
	  /**
	   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
	   * 该路径会继承被裁减对象的变换
	   * @type {module:zrender/graphic/Path}
	   * @see http://www.w3.org/TR/2dcontext/#clipping-region
	   * @readOnly
	   */
	  clipPath: null,
	
	  /**
	   * Drift element
	   * @param  {number} dx dx on the global space
	   * @param  {number} dy dy on the global space
	   */
	  drift: function (dx, dy) {
	    switch (this.draggable) {
	      case 'horizontal':
	        dy = 0;
	        break;
	
	      case 'vertical':
	        dx = 0;
	        break;
	    }
	
	    var m = this.transform;
	
	    if (!m) {
	      m = this.transform = [1, 0, 0, 1, 0, 0];
	    }
	
	    m[4] += dx;
	    m[5] += dy;
	    this.decomposeTransform();
	    this.dirty(false);
	  },
	
	  /**
	   * Hook before update
	   */
	  beforeUpdate: function () {},
	
	  /**
	   * Hook after update
	   */
	  afterUpdate: function () {},
	
	  /**
	   * Update each frame
	   */
	  update: function () {
	    this.updateTransform();
	  },
	
	  /**
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  traverse: function (cb, context) {},
	
	  /**
	   * @protected
	   */
	  attrKV: function (key, value) {
	    if (key === 'position' || key === 'scale' || key === 'origin') {
	      // Copy the array
	      if (value) {
	        var target = this[key];
	
	        if (!target) {
	          target = this[key] = [];
	        }
	
	        target[0] = value[0];
	        target[1] = value[1];
	      }
	    } else {
	      this[key] = value;
	    }
	  },
	
	  /**
	   * Hide the element
	   */
	  hide: function () {
	    this.ignore = true;
	    this.__zr && this.__zr.refresh();
	  },
	
	  /**
	   * Show the element
	   */
	  show: function () {
	    this.ignore = false;
	    this.__zr && this.__zr.refresh();
	  },
	
	  /**
	   * @param {string|Object} key
	   * @param {*} value
	   */
	  attr: function (key, value) {
	    if (typeof key === 'string') {
	      this.attrKV(key, value);
	    } else if (zrUtil.isObject(key)) {
	      for (var name in key) {
	        if (key.hasOwnProperty(name)) {
	          this.attrKV(name, key[name]);
	        }
	      }
	    }
	
	    this.dirty(false);
	    return this;
	  },
	
	  /**
	   * @param {module:zrender/graphic/Path} clipPath
	   */
	  setClipPath: function (clipPath) {
	    var zr = this.__zr;
	
	    if (zr) {
	      clipPath.addSelfToZr(zr);
	    } // Remove previous clip path
	
	
	    if (this.clipPath && this.clipPath !== clipPath) {
	      this.removeClipPath();
	    }
	
	    this.clipPath = clipPath;
	    clipPath.__zr = zr;
	    clipPath.__clipTarget = this;
	    this.dirty(false);
	  },
	
	  /**
	   */
	  removeClipPath: function () {
	    var clipPath = this.clipPath;
	
	    if (clipPath) {
	      if (clipPath.__zr) {
	        clipPath.removeSelfFromZr(clipPath.__zr);
	      }
	
	      clipPath.__zr = null;
	      clipPath.__clipTarget = null;
	      this.clipPath = null;
	      this.dirty(false);
	    }
	  },
	
	  /**
	   * Add self from zrender instance.
	   * Not recursively because it will be invoked when element added to storage.
	   * @param {module:zrender/ZRender} zr
	   */
	  addSelfToZr: function (zr) {
	    this.__zr = zr; // 添加动画
	
	    var animators = this.animators;
	
	    if (animators) {
	      for (var i = 0; i < animators.length; i++) {
	        zr.animation.addAnimator(animators[i]);
	      }
	    }
	
	    if (this.clipPath) {
	      this.clipPath.addSelfToZr(zr);
	    }
	  },
	
	  /**
	   * Remove self from zrender instance.
	   * Not recursively because it will be invoked when element added to storage.
	   * @param {module:zrender/ZRender} zr
	   */
	  removeSelfFromZr: function (zr) {
	    this.__zr = null; // 移除动画
	
	    var animators = this.animators;
	
	    if (animators) {
	      for (var i = 0; i < animators.length; i++) {
	        zr.animation.removeAnimator(animators[i]);
	      }
	    }
	
	    if (this.clipPath) {
	      this.clipPath.removeSelfFromZr(zr);
	    }
	  }
	};
	zrUtil.mixin(Element, Animatable);
	zrUtil.mixin(Element, Transformable);
	zrUtil.mixin(Element, Eventful);
	var _default = Element;
	module.exports = _default;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	/**
	 * zrender: 生成唯一id
	 *
	 * @author errorrik (errorrik@gmail.com)
	 */
	var idStart = 0x0907;
	
	function _default() {
	  return idStart++;
	}
	
	module.exports = _default;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

	/**
	 * 事件扩展
	 * @module zrender/mixin/Eventful
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	var arrySlice = Array.prototype.slice;
	/**
	 * 事件分发器
	 * @alias module:zrender/mixin/Eventful
	 * @constructor
	 */
	
	var Eventful = function () {
	  this._$handlers = {};
	};
	
	Eventful.prototype = {
	  constructor: Eventful,
	
	  /**
	   * 单次触发绑定，trigger后销毁
	   *
	   * @param {string} event 事件名
	   * @param {Function} handler 响应函数
	   * @param {Object} context
	   */
	  one: function (event, handler, context) {
	    var _h = this._$handlers;
	
	    if (!handler || !event) {
	      return this;
	    }
	
	    if (!_h[event]) {
	      _h[event] = [];
	    }
	
	    for (var i = 0; i < _h[event].length; i++) {
	      if (_h[event][i].h === handler) {
	        return this;
	      }
	    }
	
	    _h[event].push({
	      h: handler,
	      one: true,
	      ctx: context || this
	    });
	
	    return this;
	  },
	
	  /**
	   * 绑定事件
	   * @param {string} event 事件名
	   * @param {Function} handler 事件处理函数
	   * @param {Object} [context]
	   */
	  on: function (event, handler, context) {
	    var _h = this._$handlers;
	
	    if (!handler || !event) {
	      return this;
	    }
	
	    if (!_h[event]) {
	      _h[event] = [];
	    }
	
	    for (var i = 0; i < _h[event].length; i++) {
	      if (_h[event][i].h === handler) {
	        return this;
	      }
	    }
	
	    _h[event].push({
	      h: handler,
	      one: false,
	      ctx: context || this
	    });
	
	    return this;
	  },
	
	  /**
	   * 是否绑定了事件
	   * @param  {string}  event
	   * @return {boolean}
	   */
	  isSilent: function (event) {
	    var _h = this._$handlers;
	    return _h[event] && _h[event].length;
	  },
	
	  /**
	   * 解绑事件
	   * @param {string} event 事件名
	   * @param {Function} [handler] 事件处理函数
	   */
	  off: function (event, handler) {
	    var _h = this._$handlers;
	
	    if (!event) {
	      this._$handlers = {};
	      return this;
	    }
	
	    if (handler) {
	      if (_h[event]) {
	        var newList = [];
	
	        for (var i = 0, l = _h[event].length; i < l; i++) {
	          if (_h[event][i]['h'] != handler) {
	            newList.push(_h[event][i]);
	          }
	        }
	
	        _h[event] = newList;
	      }
	
	      if (_h[event] && _h[event].length === 0) {
	        delete _h[event];
	      }
	    } else {
	      delete _h[event];
	    }
	
	    return this;
	  },
	
	  /**
	   * 事件分发
	   *
	   * @param {string} type 事件类型
	   */
	  trigger: function (type) {
	    if (this._$handlers[type]) {
	      var args = arguments;
	      var argLen = args.length;
	
	      if (argLen > 3) {
	        args = arrySlice.call(args, 1);
	      }
	
	      var _h = this._$handlers[type];
	      var len = _h.length;
	
	      for (var i = 0; i < len;) {
	        // Optimize advise from backbone
	        switch (argLen) {
	          case 1:
	            _h[i]['h'].call(_h[i]['ctx']);
	
	            break;
	
	          case 2:
	            _h[i]['h'].call(_h[i]['ctx'], args[1]);
	
	            break;
	
	          case 3:
	            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
	
	            break;
	
	          default:
	            // have more than 2 given arguments
	            _h[i]['h'].apply(_h[i]['ctx'], args);
	
	            break;
	        }
	
	        if (_h[i]['one']) {
	          _h.splice(i, 1);
	
	          len--;
	        } else {
	          i++;
	        }
	      }
	    }
	
	    return this;
	  },
	
	  /**
	   * 带有context的事件分发, 最后一个参数是事件回调的context
	   * @param {string} type 事件类型
	   */
	  triggerWithContext: function (type) {
	    if (this._$handlers[type]) {
	      var args = arguments;
	      var argLen = args.length;
	
	      if (argLen > 4) {
	        args = arrySlice.call(args, 1, args.length - 1);
	      }
	
	      var ctx = args[args.length - 1];
	      var _h = this._$handlers[type];
	      var len = _h.length;
	
	      for (var i = 0; i < len;) {
	        // Optimize advise from backbone
	        switch (argLen) {
	          case 1:
	            _h[i]['h'].call(ctx);
	
	            break;
	
	          case 2:
	            _h[i]['h'].call(ctx, args[1]);
	
	            break;
	
	          case 3:
	            _h[i]['h'].call(ctx, args[1], args[2]);
	
	            break;
	
	          default:
	            // have more than 2 given arguments
	            _h[i]['h'].apply(ctx, args);
	
	            break;
	        }
	
	        if (_h[i]['one']) {
	          _h.splice(i, 1);
	
	          len--;
	        } else {
	          i++;
	        }
	      }
	    }
	
	    return this;
	  }
	}; // 对象可以通过 onxxxx 绑定事件
	
	/**
	 * @event module:zrender/mixin/Eventful#onclick
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmouseover
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmouseout
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmousemove
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmousewheel
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmousedown
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmouseup
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondrag
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragstart
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragend
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragenter
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragleave
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragover
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondrop
	 * @type {Function}
	 * @default null
	 */
	
	var _default = Eventful;
	module.exports = _default;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	var matrix = __webpack_require__(14);
	
	var vector = __webpack_require__(15);
	
	/**
	 * 提供变换扩展
	 * @module zrender/mixin/Transformable
	 * @author pissang (https://www.github.com/pissang)
	 */
	var mIdentity = matrix.identity;
	var EPSILON = 5e-5;
	
	function isNotAroundZero(val) {
	  return val > EPSILON || val < -EPSILON;
	}
	/**
	 * @alias module:zrender/mixin/Transformable
	 * @constructor
	 */
	
	
	var Transformable = function (opts) {
	  opts = opts || {}; // If there are no given position, rotation, scale
	
	  if (!opts.position) {
	    /**
	     * 平移
	     * @type {Array.<number>}
	     * @default [0, 0]
	     */
	    this.position = [0, 0];
	  }
	
	  if (opts.rotation == null) {
	    /**
	     * 旋转
	     * @type {Array.<number>}
	     * @default 0
	     */
	    this.rotation = 0;
	  }
	
	  if (!opts.scale) {
	    /**
	     * 缩放
	     * @type {Array.<number>}
	     * @default [1, 1]
	     */
	    this.scale = [1, 1];
	  }
	  /**
	   * 旋转和缩放的原点
	   * @type {Array.<number>}
	   * @default null
	   */
	
	
	  this.origin = this.origin || null;
	};
	
	var transformableProto = Transformable.prototype;
	transformableProto.transform = null;
	/**
	 * 判断是否需要有坐标变换
	 * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
	 */
	
	transformableProto.needLocalTransform = function () {
	  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
	};
	
	transformableProto.updateTransform = function () {
	  var parent = this.parent;
	  var parentHasTransform = parent && parent.transform;
	  var needLocalTransform = this.needLocalTransform();
	  var m = this.transform;
	
	  if (!(needLocalTransform || parentHasTransform)) {
	    m && mIdentity(m);
	    return;
	  }
	
	  m = m || matrix.create();
	
	  if (needLocalTransform) {
	    this.getLocalTransform(m);
	  } else {
	    mIdentity(m);
	  } // 应用父节点变换
	
	
	  if (parentHasTransform) {
	    if (needLocalTransform) {
	      matrix.mul(m, parent.transform, m);
	    } else {
	      matrix.copy(m, parent.transform);
	    }
	  } // 保存这个变换矩阵
	
	
	  this.transform = m;
	  this.invTransform = this.invTransform || matrix.create();
	  matrix.invert(this.invTransform, m);
	};
	
	transformableProto.getLocalTransform = function (m) {
	  return Transformable.getLocalTransform(this, m);
	};
	/**
	 * 将自己的transform应用到context上
	 * @param {CanvasRenderingContext2D} ctx
	 */
	
	
	transformableProto.setTransform = function (ctx) {
	  var m = this.transform;
	  var dpr = ctx.dpr || 1;
	
	  if (m) {
	    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
	  } else {
	    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	  }
	};
	
	transformableProto.restoreTransform = function (ctx) {
	  var dpr = ctx.dpr || 1;
	  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	};
	
	var tmpTransform = [];
	/**
	 * 分解`transform`矩阵到`position`, `rotation`, `scale`
	 */
	
	transformableProto.decomposeTransform = function () {
	  if (!this.transform) {
	    return;
	  }
	
	  var parent = this.parent;
	  var m = this.transform;
	
	  if (parent && parent.transform) {
	    // Get local transform and decompose them to position, scale, rotation
	    matrix.mul(tmpTransform, parent.invTransform, m);
	    m = tmpTransform;
	  }
	
	  var sx = m[0] * m[0] + m[1] * m[1];
	  var sy = m[2] * m[2] + m[3] * m[3];
	  var position = this.position;
	  var scale = this.scale;
	
	  if (isNotAroundZero(sx - 1)) {
	    sx = Math.sqrt(sx);
	  }
	
	  if (isNotAroundZero(sy - 1)) {
	    sy = Math.sqrt(sy);
	  }
	
	  if (m[0] < 0) {
	    sx = -sx;
	  }
	
	  if (m[3] < 0) {
	    sy = -sy;
	  }
	
	  position[0] = m[4];
	  position[1] = m[5];
	  scale[0] = sx;
	  scale[1] = sy;
	  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
	};
	/**
	 * Get global scale
	 * @return {Array.<number>}
	 */
	
	
	transformableProto.getGlobalScale = function () {
	  var m = this.transform;
	
	  if (!m) {
	    return [1, 1];
	  }
	
	  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
	  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
	
	  if (m[0] < 0) {
	    sx = -sx;
	  }
	
	  if (m[3] < 0) {
	    sy = -sy;
	  }
	
	  return [sx, sy];
	};
	/**
	 * 变换坐标位置到 shape 的局部坐标空间
	 * @method
	 * @param {number} x
	 * @param {number} y
	 * @return {Array.<number>}
	 */
	
	
	transformableProto.transformCoordToLocal = function (x, y) {
	  var v2 = [x, y];
	  var invTransform = this.invTransform;
	
	  if (invTransform) {
	    vector.applyTransform(v2, v2, invTransform);
	  }
	
	  return v2;
	};
	/**
	 * 变换局部坐标位置到全局坐标空间
	 * @method
	 * @param {number} x
	 * @param {number} y
	 * @return {Array.<number>}
	 */
	
	
	transformableProto.transformCoordToGlobal = function (x, y) {
	  var v2 = [x, y];
	  var transform = this.transform;
	
	  if (transform) {
	    vector.applyTransform(v2, v2, transform);
	  }
	
	  return v2;
	};
	/**
	 * @static
	 * @param {Object} target
	 * @param {Array.<number>} target.origin
	 * @param {number} target.rotation
	 * @param {Array.<number>} target.position
	 * @param {Array.<number>} [m]
	 */
	
	
	Transformable.getLocalTransform = function (target, m) {
	  m = m || [];
	  mIdentity(m);
	  var origin = target.origin;
	  var scale = target.scale || [1, 1];
	  var rotation = target.rotation || 0;
	  var position = target.position || [0, 0];
	
	  if (origin) {
	    // Translate to origin
	    m[4] -= origin[0];
	    m[5] -= origin[1];
	  }
	
	  matrix.scale(m, m, scale);
	
	  if (rotation) {
	    matrix.rotate(m, m, rotation);
	  }
	
	  if (origin) {
	    // Translate back from origin
	    m[4] += origin[0];
	    m[5] += origin[1];
	  }
	
	  m[4] += position[0];
	  m[5] += position[1];
	  return m;
	};
	
	var _default = Transformable;
	module.exports = _default;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	/**
	 * 3x2矩阵操作类
	 * @exports zrender/tool/matrix
	 */
	var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
	/**
	 * 创建一个单位矩阵
	 * @return {Float32Array|Array.<number>}
	 */
	
	function create() {
	  var out = new ArrayCtor(6);
	  identity(out);
	  return out;
	}
	/**
	 * 设置矩阵为单位矩阵
	 * @param {Float32Array|Array.<number>} out
	 */
	
	
	function identity(out) {
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 1;
	  out[4] = 0;
	  out[5] = 0;
	  return out;
	}
	/**
	 * 复制矩阵
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} m
	 */
	
	
	function copy(out, m) {
	  out[0] = m[0];
	  out[1] = m[1];
	  out[2] = m[2];
	  out[3] = m[3];
	  out[4] = m[4];
	  out[5] = m[5];
	  return out;
	}
	/**
	 * 矩阵相乘
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} m1
	 * @param {Float32Array|Array.<number>} m2
	 */
	
	
	function mul(out, m1, m2) {
	  // Consider matrix.mul(m, m2, m);
	  // where out is the same as m2.
	  // So use temp variable to escape error.
	  var out0 = m1[0] * m2[0] + m1[2] * m2[1];
	  var out1 = m1[1] * m2[0] + m1[3] * m2[1];
	  var out2 = m1[0] * m2[2] + m1[2] * m2[3];
	  var out3 = m1[1] * m2[2] + m1[3] * m2[3];
	  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
	  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
	  out[0] = out0;
	  out[1] = out1;
	  out[2] = out2;
	  out[3] = out3;
	  out[4] = out4;
	  out[5] = out5;
	  return out;
	}
	/**
	 * 平移变换
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 * @param {Float32Array|Array.<number>} v
	 */
	
	
	function translate(out, a, v) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  out[4] = a[4] + v[0];
	  out[5] = a[5] + v[1];
	  return out;
	}
	/**
	 * 旋转变换
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 * @param {number} rad
	 */
	
	
	function rotate(out, a, rad) {
	  var aa = a[0];
	  var ac = a[2];
	  var atx = a[4];
	  var ab = a[1];
	  var ad = a[3];
	  var aty = a[5];
	  var st = Math.sin(rad);
	  var ct = Math.cos(rad);
	  out[0] = aa * ct + ab * st;
	  out[1] = -aa * st + ab * ct;
	  out[2] = ac * ct + ad * st;
	  out[3] = -ac * st + ct * ad;
	  out[4] = ct * atx + st * aty;
	  out[5] = ct * aty - st * atx;
	  return out;
	}
	/**
	 * 缩放变换
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 * @param {Float32Array|Array.<number>} v
	 */
	
	
	function scale(out, a, v) {
	  var vx = v[0];
	  var vy = v[1];
	  out[0] = a[0] * vx;
	  out[1] = a[1] * vy;
	  out[2] = a[2] * vx;
	  out[3] = a[3] * vy;
	  out[4] = a[4] * vx;
	  out[5] = a[5] * vy;
	  return out;
	}
	/**
	 * 求逆矩阵
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 */
	
	
	function invert(out, a) {
	  var aa = a[0];
	  var ac = a[2];
	  var atx = a[4];
	  var ab = a[1];
	  var ad = a[3];
	  var aty = a[5];
	  var det = aa * ad - ab * ac;
	
	  if (!det) {
	    return null;
	  }
	
	  det = 1.0 / det;
	  out[0] = ad * det;
	  out[1] = -ab * det;
	  out[2] = -ac * det;
	  out[3] = aa * det;
	  out[4] = (ac * aty - ad * atx) * det;
	  out[5] = (ab * atx - aa * aty) * det;
	  return out;
	}
	
	exports.create = create;
	exports.identity = identity;
	exports.copy = copy;
	exports.mul = mul;
	exports.translate = translate;
	exports.rotate = rotate;
	exports.scale = scale;
	exports.invert = invert;

/***/ }),
/* 15 */
/***/ (function(module, exports) {

	var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
	/**
	 * 创建一个向量
	 * @param {number} [x=0]
	 * @param {number} [y=0]
	 * @return {Vector2}
	 */
	
	function create(x, y) {
	  var out = new ArrayCtor(2);
	
	  if (x == null) {
	    x = 0;
	  }
	
	  if (y == null) {
	    y = 0;
	  }
	
	  out[0] = x;
	  out[1] = y;
	  return out;
	}
	/**
	 * 复制向量数据
	 * @param {Vector2} out
	 * @param {Vector2} v
	 * @return {Vector2}
	 */
	
	
	function copy(out, v) {
	  out[0] = v[0];
	  out[1] = v[1];
	  return out;
	}
	/**
	 * 克隆一个向量
	 * @param {Vector2} v
	 * @return {Vector2}
	 */
	
	
	function clone(v) {
	  var out = new ArrayCtor(2);
	  out[0] = v[0];
	  out[1] = v[1];
	  return out;
	}
	/**
	 * 设置向量的两个项
	 * @param {Vector2} out
	 * @param {number} a
	 * @param {number} b
	 * @return {Vector2} 结果
	 */
	
	
	function set(out, a, b) {
	  out[0] = a;
	  out[1] = b;
	  return out;
	}
	/**
	 * 向量相加
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	
	function add(out, v1, v2) {
	  out[0] = v1[0] + v2[0];
	  out[1] = v1[1] + v2[1];
	  return out;
	}
	/**
	 * 向量缩放后相加
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @param {number} a
	 */
	
	
	function scaleAndAdd(out, v1, v2, a) {
	  out[0] = v1[0] + v2[0] * a;
	  out[1] = v1[1] + v2[1] * a;
	  return out;
	}
	/**
	 * 向量相减
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	
	function sub(out, v1, v2) {
	  out[0] = v1[0] - v2[0];
	  out[1] = v1[1] - v2[1];
	  return out;
	}
	/**
	 * 向量长度
	 * @param {Vector2} v
	 * @return {number}
	 */
	
	
	function len(v) {
	  return Math.sqrt(lenSquare(v));
	}
	
	var length = len; // jshint ignore:line
	
	/**
	 * 向量长度平方
	 * @param {Vector2} v
	 * @return {number}
	 */
	
	function lenSquare(v) {
	  return v[0] * v[0] + v[1] * v[1];
	}
	
	var lengthSquare = lenSquare;
	/**
	 * 向量乘法
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	function mul(out, v1, v2) {
	  out[0] = v1[0] * v2[0];
	  out[1] = v1[1] * v2[1];
	  return out;
	}
	/**
	 * 向量除法
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	
	function div(out, v1, v2) {
	  out[0] = v1[0] / v2[0];
	  out[1] = v1[1] / v2[1];
	  return out;
	}
	/**
	 * 向量点乘
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @return {number}
	 */
	
	
	function dot(v1, v2) {
	  return v1[0] * v2[0] + v1[1] * v2[1];
	}
	/**
	 * 向量缩放
	 * @param {Vector2} out
	 * @param {Vector2} v
	 * @param {number} s
	 */
	
	
	function scale(out, v, s) {
	  out[0] = v[0] * s;
	  out[1] = v[1] * s;
	  return out;
	}
	/**
	 * 向量归一化
	 * @param {Vector2} out
	 * @param {Vector2} v
	 */
	
	
	function normalize(out, v) {
	  var d = len(v);
	
	  if (d === 0) {
	    out[0] = 0;
	    out[1] = 0;
	  } else {
	    out[0] = v[0] / d;
	    out[1] = v[1] / d;
	  }
	
	  return out;
	}
	/**
	 * 计算向量间距离
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @return {number}
	 */
	
	
	function distance(v1, v2) {
	  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
	}
	
	var dist = distance;
	/**
	 * 向量距离平方
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @return {number}
	 */
	
	function distanceSquare(v1, v2) {
	  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	}
	
	var distSquare = distanceSquare;
	/**
	 * 求负向量
	 * @param {Vector2} out
	 * @param {Vector2} v
	 */
	
	function negate(out, v) {
	  out[0] = -v[0];
	  out[1] = -v[1];
	  return out;
	}
	/**
	 * 插值两个点
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @param {number} t
	 */
	
	
	function lerp(out, v1, v2, t) {
	  out[0] = v1[0] + t * (v2[0] - v1[0]);
	  out[1] = v1[1] + t * (v2[1] - v1[1]);
	  return out;
	}
	/**
	 * 矩阵左乘向量
	 * @param {Vector2} out
	 * @param {Vector2} v
	 * @param {Vector2} m
	 */
	
	
	function applyTransform(out, v, m) {
	  var x = v[0];
	  var y = v[1];
	  out[0] = m[0] * x + m[2] * y + m[4];
	  out[1] = m[1] * x + m[3] * y + m[5];
	  return out;
	}
	/**
	 * 求两个向量最小值
	 * @param  {Vector2} out
	 * @param  {Vector2} v1
	 * @param  {Vector2} v2
	 */
	
	
	function min(out, v1, v2) {
	  out[0] = Math.min(v1[0], v2[0]);
	  out[1] = Math.min(v1[1], v2[1]);
	  return out;
	}
	/**
	 * 求两个向量最大值
	 * @param  {Vector2} out
	 * @param  {Vector2} v1
	 * @param  {Vector2} v2
	 */
	
	
	function max(out, v1, v2) {
	  out[0] = Math.max(v1[0], v2[0]);
	  out[1] = Math.max(v1[1], v2[1]);
	  return out;
	}
	
	exports.create = create;
	exports.copy = copy;
	exports.clone = clone;
	exports.set = set;
	exports.add = add;
	exports.scaleAndAdd = scaleAndAdd;
	exports.sub = sub;
	exports.len = len;
	exports.length = length;
	exports.lenSquare = lenSquare;
	exports.lengthSquare = lengthSquare;
	exports.mul = mul;
	exports.div = div;
	exports.dot = dot;
	exports.scale = scale;
	exports.normalize = normalize;
	exports.distance = distance;
	exports.dist = dist;
	exports.distanceSquare = distanceSquare;
	exports.distSquare = distSquare;
	exports.negate = negate;
	exports.lerp = lerp;
	exports.applyTransform = applyTransform;
	exports.min = min;
	exports.max = max;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	var Animator = __webpack_require__(17);
	
	var log = __webpack_require__(22);
	
	var _util = __webpack_require__(5);
	
	var isString = _util.isString;
	var isFunction = _util.isFunction;
	var isObject = _util.isObject;
	var isArrayLike = _util.isArrayLike;
	var indexOf = _util.indexOf;
	
	/**
	 * @alias modue:zrender/mixin/Animatable
	 * @constructor
	 */
	var Animatable = function () {
	  /**
	   * @type {Array.<module:zrender/animation/Animator>}
	   * @readOnly
	   */
	  this.animators = [];
	};
	
	Animatable.prototype = {
	  constructor: Animatable,
	
	  /**
	   * 动画
	   *
	   * @param {string} path The path to fetch value from object, like 'a.b.c'.
	   * @param {boolean} [loop] Whether to loop animation.
	   * @return {module:zrender/animation/Animator}
	   * @example:
	   *     el.animate('style', false)
	   *         .when(1000, {x: 10} )
	   *         .done(function(){ // Animation done })
	   *         .start()
	   */
	  animate: function (path, loop) {
	    var target;
	    var animatingShape = false;
	    var el = this;
	    var zr = this.__zr;
	
	    if (path) {
	      var pathSplitted = path.split('.');
	      var prop = el; // If animating shape
	
	      animatingShape = pathSplitted[0] === 'shape';
	
	      for (var i = 0, l = pathSplitted.length; i < l; i++) {
	        if (!prop) {
	          continue;
	        }
	
	        prop = prop[pathSplitted[i]];
	      }
	
	      if (prop) {
	        target = prop;
	      }
	    } else {
	      target = el;
	    }
	
	    if (!target) {
	      log('Property "' + path + '" is not existed in element ' + el.id);
	      return;
	    }
	
	    var animators = el.animators;
	    var animator = new Animator(target, loop);
	    animator.during(function (target) {
	      el.dirty(animatingShape);
	    }).done(function () {
	      // FIXME Animator will not be removed if use `Animator#stop` to stop animation
	      animators.splice(indexOf(animators, animator), 1);
	    });
	    animators.push(animator); // If animate after added to the zrender
	
	    if (zr) {
	      zr.animation.addAnimator(animator);
	    }
	
	    return animator;
	  },
	
	  /**
	   * 停止动画
	   * @param {boolean} forwardToLast If move to last frame before stop
	   */
	  stopAnimation: function (forwardToLast) {
	    var animators = this.animators;
	    var len = animators.length;
	
	    for (var i = 0; i < len; i++) {
	      animators[i].stop(forwardToLast);
	    }
	
	    animators.length = 0;
	    return this;
	  },
	
	  /**
	   * Caution: this method will stop previous animation.
	   * So do not use this method to one element twice before
	   * animation starts, unless you know what you are doing.
	   * @param {Object} target
	   * @param {number} [time=500] Time in ms
	   * @param {string} [easing='linear']
	   * @param {number} [delay=0]
	   * @param {Function} [callback]
	   * @param {Function} [forceAnimate] Prevent stop animation and callback
	   *        immediently when target values are the same as current values.
	   *
	   * @example
	   *  // Animate position
	   *  el.animateTo({
	   *      position: [10, 10]
	   *  }, function () { // done })
	   *
	   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	   *  el.animateTo({
	   *      shape: {
	   *          width: 500
	   *      },
	   *      style: {
	   *          fill: 'red'
	   *      }
	   *      position: [10, 10]
	   *  }, 100, 100, 'cubicOut', function () { // done })
	   */
	  // TODO Return animation key
	  animateTo: function (target, time, delay, easing, callback, forceAnimate) {
	    // animateTo(target, time, easing, callback);
	    if (isString(delay)) {
	      callback = easing;
	      easing = delay;
	      delay = 0;
	    } // animateTo(target, time, delay, callback);
	    else if (isFunction(easing)) {
	        callback = easing;
	        easing = 'linear';
	        delay = 0;
	      } // animateTo(target, time, callback);
	      else if (isFunction(delay)) {
	          callback = delay;
	          delay = 0;
	        } // animateTo(target, callback)
	        else if (isFunction(time)) {
	            callback = time;
	            time = 500;
	          } // animateTo(target)
	          else if (!time) {
	              time = 500;
	            } // Stop all previous animations
	
	
	    this.stopAnimation();
	
	    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start
	    // if there is nothing to animate
	
	
	    var animators = this.animators.slice();
	    var count = animators.length;
	
	    function done() {
	      count--;
	
	      if (!count) {
	        callback && callback();
	      }
	    } // No animators. This should be checked before animators[i].start(),
	    // because 'done' may be executed immediately if no need to animate.
	
	
	    if (!count) {
	      callback && callback();
	    } // Start after all animators created
	    // Incase any animator is done immediately when all animation properties are not changed
	
	
	    for (var i = 0; i < animators.length; i++) {
	      animators[i].done(done).start(easing, forceAnimate);
	    }
	  },
	
	  /**
	   * @private
	   * @param {string} path=''
	   * @param {Object} source=this
	   * @param {Object} target
	   * @param {number} [time=500]
	   * @param {number} [delay=0]
	   *
	   * @example
	   *  // Animate position
	   *  el._animateToShallow({
	   *      position: [10, 10]
	   *  })
	   *
	   *  // Animate shape, style and position in 100ms, delayed 100ms
	   *  el._animateToShallow({
	   *      shape: {
	   *          width: 500
	   *      },
	   *      style: {
	   *          fill: 'red'
	   *      }
	   *      position: [10, 10]
	   *  }, 100, 100)
	   */
	  _animateToShallow: function (path, source, target, time, delay) {
	    var objShallow = {};
	    var propertyCount = 0;
	
	    for (var name in target) {
	      if (!target.hasOwnProperty(name)) {
	        continue;
	      }
	
	      if (source[name] != null) {
	        if (isObject(target[name]) && !isArrayLike(target[name])) {
	          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);
	        } else {
	          objShallow[name] = target[name];
	          propertyCount++;
	        }
	      } else if (target[name] != null) {
	        // Attr directly if not has property
	        // FIXME, if some property not needed for element ?
	        if (!path) {
	          this.attr(name, target[name]);
	        } else {
	          // Shape or style
	          var props = {};
	          props[path] = {};
	          props[path][name] = target[name];
	          this.attr(props);
	        }
	      }
	    }
	
	    if (propertyCount > 0) {
	      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
	    }
	
	    return this;
	  }
	};
	var _default = Animatable;
	module.exports = _default;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	var Clip = __webpack_require__(18);
	
	var color = __webpack_require__(20);
	
	var _util = __webpack_require__(5);
	
	var isArrayLike = _util.isArrayLike;
	
	/**
	 * @module echarts/animation/Animator
	 */
	var arraySlice = Array.prototype.slice;
	
	function defaultGetter(target, key) {
	  return target[key];
	}
	
	function defaultSetter(target, key, value) {
	  target[key] = value;
	}
	/**
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} percent
	 * @return {number}
	 */
	
	
	function interpolateNumber(p0, p1, percent) {
	  return (p1 - p0) * percent + p0;
	}
	/**
	 * @param  {string} p0
	 * @param  {string} p1
	 * @param  {number} percent
	 * @return {string}
	 */
	
	
	function interpolateString(p0, p1, percent) {
	  return percent > 0.5 ? p1 : p0;
	}
	/**
	 * @param  {Array} p0
	 * @param  {Array} p1
	 * @param  {number} percent
	 * @param  {Array} out
	 * @param  {number} arrDim
	 */
	
	
	function interpolateArray(p0, p1, percent, out, arrDim) {
	  var len = p0.length;
	
	  if (arrDim == 1) {
	    for (var i = 0; i < len; i++) {
	      out[i] = interpolateNumber(p0[i], p1[i], percent);
	    }
	  } else {
	    var len2 = len && p0[0].length;
	
	    for (var i = 0; i < len; i++) {
	      for (var j = 0; j < len2; j++) {
	        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
	      }
	    }
	  }
	} // arr0 is source array, arr1 is target array.
	// Do some preprocess to avoid error happened when interpolating from arr0 to arr1
	
	
	function fillArr(arr0, arr1, arrDim) {
	  var arr0Len = arr0.length;
	  var arr1Len = arr1.length;
	
	  if (arr0Len !== arr1Len) {
	    // FIXME Not work for TypedArray
	    var isPreviousLarger = arr0Len > arr1Len;
	
	    if (isPreviousLarger) {
	      // Cut the previous
	      arr0.length = arr1Len;
	    } else {
	      // Fill the previous
	      for (var i = arr0Len; i < arr1Len; i++) {
	        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
	      }
	    }
	  } // Handling NaN value
	
	
	  var len2 = arr0[0] && arr0[0].length;
	
	  for (var i = 0; i < arr0.length; i++) {
	    if (arrDim === 1) {
	      if (isNaN(arr0[i])) {
	        arr0[i] = arr1[i];
	      }
	    } else {
	      for (var j = 0; j < len2; j++) {
	        if (isNaN(arr0[i][j])) {
	          arr0[i][j] = arr1[i][j];
	        }
	      }
	    }
	  }
	}
	/**
	 * @param  {Array} arr0
	 * @param  {Array} arr1
	 * @param  {number} arrDim
	 * @return {boolean}
	 */
	
	
	function isArraySame(arr0, arr1, arrDim) {
	  if (arr0 === arr1) {
	    return true;
	  }
	
	  var len = arr0.length;
	
	  if (len !== arr1.length) {
	    return false;
	  }
	
	  if (arrDim === 1) {
	    for (var i = 0; i < len; i++) {
	      if (arr0[i] !== arr1[i]) {
	        return false;
	      }
	    }
	  } else {
	    var len2 = arr0[0].length;
	
	    for (var i = 0; i < len; i++) {
	      for (var j = 0; j < len2; j++) {
	        if (arr0[i][j] !== arr1[i][j]) {
	          return false;
	        }
	      }
	    }
	  }
	
	  return true;
	}
	/**
	 * Catmull Rom interpolate array
	 * @param  {Array} p0
	 * @param  {Array} p1
	 * @param  {Array} p2
	 * @param  {Array} p3
	 * @param  {number} t
	 * @param  {number} t2
	 * @param  {number} t3
	 * @param  {Array} out
	 * @param  {number} arrDim
	 */
	
	
	function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
	  var len = p0.length;
	
	  if (arrDim == 1) {
	    for (var i = 0; i < len; i++) {
	      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
	    }
	  } else {
	    var len2 = p0[0].length;
	
	    for (var i = 0; i < len; i++) {
	      for (var j = 0; j < len2; j++) {
	        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
	      }
	    }
	  }
	}
	/**
	 * Catmull Rom interpolate number
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @param  {number} t2
	 * @param  {number} t3
	 * @return {number}
	 */
	
	
	function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
	  var v0 = (p2 - p0) * 0.5;
	  var v1 = (p3 - p1) * 0.5;
	  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
	}
	
	function cloneValue(value) {
	  if (isArrayLike(value)) {
	    var len = value.length;
	
	    if (isArrayLike(value[0])) {
	      var ret = [];
	
	      for (var i = 0; i < len; i++) {
	        ret.push(arraySlice.call(value[i]));
	      }
	
	      return ret;
	    }
	
	    return arraySlice.call(value);
	  }
	
	  return value;
	}
	
	function rgba2String(rgba) {
	  rgba[0] = Math.floor(rgba[0]);
	  rgba[1] = Math.floor(rgba[1]);
	  rgba[2] = Math.floor(rgba[2]);
	  return 'rgba(' + rgba.join(',') + ')';
	}
	
	function getArrayDim(keyframes) {
	  var lastValue = keyframes[keyframes.length - 1].value;
	  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;
	}
	
	function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
	  var getter = animator._getter;
	  var setter = animator._setter;
	  var useSpline = easing === 'spline';
	  var trackLen = keyframes.length;
	
	  if (!trackLen) {
	    return;
	  } // Guess data type
	
	
	  var firstVal = keyframes[0].value;
	  var isValueArray = isArrayLike(firstVal);
	  var isValueColor = false;
	  var isValueString = false; // For vertices morphing
	
	  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
	  var trackMaxTime; // Sort keyframe as ascending
	
	  keyframes.sort(function (a, b) {
	    return a.time - b.time;
	  });
	  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe
	
	  var kfPercents = []; // Value of each keyframe
	
	  var kfValues = [];
	  var prevValue = keyframes[0].value;
	  var isAllValueEqual = true;
	
	  for (var i = 0; i < trackLen; i++) {
	    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string
	
	    var value = keyframes[i].value; // Check if value is equal, deep check if value is array
	
	    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
	      isAllValueEqual = false;
	    }
	
	    prevValue = value; // Try converting a string to a color array
	
	    if (typeof value == 'string') {
	      var colorArray = color.parse(value);
	
	      if (colorArray) {
	        value = colorArray;
	        isValueColor = true;
	      } else {
	        isValueString = true;
	      }
	    }
	
	    kfValues.push(value);
	  }
	
	  if (!forceAnimate && isAllValueEqual) {
	    return;
	  }
	
	  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value
	
	  for (var i = 0; i < trackLen - 1; i++) {
	    if (isValueArray) {
	      fillArr(kfValues[i], lastValue, arrDim);
	    } else {
	      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
	        kfValues[i] = lastValue;
	      }
	    }
	  }
	
	  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when
	  // animation playback is sequency
	
	  var lastFrame = 0;
	  var lastFramePercent = 0;
	  var start;
	  var w;
	  var p0;
	  var p1;
	  var p2;
	  var p3;
	
	  if (isValueColor) {
	    var rgba = [0, 0, 0, 0];
	  }
	
	  var onframe = function (target, percent) {
	    // Find the range keyframes
	    // kf1-----kf2---------current--------kf3
	    // find kf2 and kf3 and do interpolation
	    var frame; // In the easing function like elasticOut, percent may less than 0
	
	    if (percent < 0) {
	      frame = 0;
	    } else if (percent < lastFramePercent) {
	      // Start from next key
	      // PENDING start from lastFrame ?
	      start = Math.min(lastFrame + 1, trackLen - 1);
	
	      for (frame = start; frame >= 0; frame--) {
	        if (kfPercents[frame] <= percent) {
	          break;
	        }
	      } // PENDING really need to do this ?
	
	
	      frame = Math.min(frame, trackLen - 2);
	    } else {
	      for (frame = lastFrame; frame < trackLen; frame++) {
	        if (kfPercents[frame] > percent) {
	          break;
	        }
	      }
	
	      frame = Math.min(frame - 1, trackLen - 2);
	    }
	
	    lastFrame = frame;
	    lastFramePercent = percent;
	    var range = kfPercents[frame + 1] - kfPercents[frame];
	
	    if (range === 0) {
	      return;
	    } else {
	      w = (percent - kfPercents[frame]) / range;
	    }
	
	    if (useSpline) {
	      p1 = kfValues[frame];
	      p0 = kfValues[frame === 0 ? frame : frame - 1];
	      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
	      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
	
	      if (isValueArray) {
	        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
	      } else {
	        var value;
	
	        if (isValueColor) {
	          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
	          value = rgba2String(rgba);
	        } else if (isValueString) {
	          // String is step(0.5)
	          return interpolateString(p1, p2, w);
	        } else {
	          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
	        }
	
	        setter(target, propName, value);
	      }
	    } else {
	      if (isValueArray) {
	        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
	      } else {
	        var value;
	
	        if (isValueColor) {
	          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
	          value = rgba2String(rgba);
	        } else if (isValueString) {
	          // String is step(0.5)
	          return interpolateString(kfValues[frame], kfValues[frame + 1], w);
	        } else {
	          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
	        }
	
	        setter(target, propName, value);
	      }
	    }
	  };
	
	  var clip = new Clip({
	    target: animator._target,
	    life: trackMaxTime,
	    loop: animator._loop,
	    delay: animator._delay,
	    onframe: onframe,
	    ondestroy: oneTrackDone
	  });
	
	  if (easing && easing !== 'spline') {
	    clip.easing = easing;
	  }
	
	  return clip;
	}
	/**
	 * @alias module:zrender/animation/Animator
	 * @constructor
	 * @param {Object} target
	 * @param {boolean} loop
	 * @param {Function} getter
	 * @param {Function} setter
	 */
	
	
	var Animator = function (target, loop, getter, setter) {
	  this._tracks = {};
	  this._target = target;
	  this._loop = loop || false;
	  this._getter = getter || defaultGetter;
	  this._setter = setter || defaultSetter;
	  this._clipCount = 0;
	  this._delay = 0;
	  this._doneList = [];
	  this._onframeList = [];
	  this._clipList = [];
	};
	
	Animator.prototype = {
	  /**
	   * 设置动画关键帧
	   * @param  {number} time 关键帧时间，单位是ms
	   * @param  {Object} props 关键帧的属性值，key-value表示
	   * @return {module:zrender/animation/Animator}
	   */
	  when: function (time
	  /* ms */
	  , props) {
	    var tracks = this._tracks;
	
	    for (var propName in props) {
	      if (!props.hasOwnProperty(propName)) {
	        continue;
	      }
	
	      if (!tracks[propName]) {
	        tracks[propName] = []; // Invalid value
	
	        var value = this._getter(this._target, propName);
	
	        if (value == null) {
	          // zrLog('Invalid property ' + propName);
	          continue;
	        } // If time is 0
	        //  Then props is given initialize value
	        // Else
	        //  Initialize value from current prop value
	
	
	        if (time !== 0) {
	          tracks[propName].push({
	            time: 0,
	            value: cloneValue(value)
	          });
	        }
	      }
	
	      tracks[propName].push({
	        time: time,
	        value: props[propName]
	      });
	    }
	
	    return this;
	  },
	
	  /**
	   * 添加动画每一帧的回调函数
	   * @param  {Function} callback
	   * @return {module:zrender/animation/Animator}
	   */
	  during: function (callback) {
	    this._onframeList.push(callback);
	
	    return this;
	  },
	  pause: function () {
	    for (var i = 0; i < this._clipList.length; i++) {
	      this._clipList[i].pause();
	    }
	
	    this._paused = true;
	  },
	  resume: function () {
	    for (var i = 0; i < this._clipList.length; i++) {
	      this._clipList[i].resume();
	    }
	
	    this._paused = false;
	  },
	  isPaused: function () {
	    return !!this._paused;
	  },
	  _doneCallback: function () {
	    // Clear all tracks
	    this._tracks = {}; // Clear all clips
	
	    this._clipList.length = 0;
	    var doneList = this._doneList;
	    var len = doneList.length;
	
	    for (var i = 0; i < len; i++) {
	      doneList[i].call(this);
	    }
	  },
	
	  /**
	   * 开始执行动画
	   * @param  {string|Function} [easing]
	   *         动画缓动函数，详见{@link module:zrender/animation/easing}
	   * @param  {boolean} forceAnimate
	   * @return {module:zrender/animation/Animator}
	   */
	  start: function (easing, forceAnimate) {
	    var self = this;
	    var clipCount = 0;
	
	    var oneTrackDone = function () {
	      clipCount--;
	
	      if (!clipCount) {
	        self._doneCallback();
	      }
	    };
	
	    var lastClip;
	
	    for (var propName in this._tracks) {
	      if (!this._tracks.hasOwnProperty(propName)) {
	        continue;
	      }
	
	      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);
	
	      if (clip) {
	        this._clipList.push(clip);
	
	        clipCount++; // If start after added to animation
	
	        if (this.animation) {
	          this.animation.addClip(clip);
	        }
	
	        lastClip = clip;
	      }
	    } // Add during callback on the last clip
	
	
	    if (lastClip) {
	      var oldOnFrame = lastClip.onframe;
	
	      lastClip.onframe = function (target, percent) {
	        oldOnFrame(target, percent);
	
	        for (var i = 0; i < self._onframeList.length; i++) {
	          self._onframeList[i](target, percent);
	        }
	      };
	    } // This optimization will help the case that in the upper application
	    // the view may be refreshed frequently, where animation will be
	    // called repeatly but nothing changed.
	
	
	    if (!clipCount) {
	      this._doneCallback();
	    }
	
	    return this;
	  },
	
	  /**
	   * 停止动画
	   * @param {boolean} forwardToLast If move to last frame before stop
	   */
	  stop: function (forwardToLast) {
	    var clipList = this._clipList;
	    var animation = this.animation;
	
	    for (var i = 0; i < clipList.length; i++) {
	      var clip = clipList[i];
	
	      if (forwardToLast) {
	        // Move to last frame before stop
	        clip.onframe(this._target, 1);
	      }
	
	      animation && animation.removeClip(clip);
	    }
	
	    clipList.length = 0;
	  },
	
	  /**
	   * 设置动画延迟开始的时间
	   * @param  {number} time 单位ms
	   * @return {module:zrender/animation/Animator}
	   */
	  delay: function (time) {
	    this._delay = time;
	    return this;
	  },
	
	  /**
	   * 添加动画结束的回调
	   * @param  {Function} cb
	   * @return {module:zrender/animation/Animator}
	   */
	  done: function (cb) {
	    if (cb) {
	      this._doneList.push(cb);
	    }
	
	    return this;
	  },
	
	  /**
	   * @return {Array.<module:zrender/animation/Clip>}
	   */
	  getClips: function () {
	    return this._clipList;
	  }
	};
	var _default = Animator;
	module.exports = _default;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	var easingFuncs = __webpack_require__(19);
	
	/**
	 * 动画主控制器
	 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
	 * @config life(1000) 动画时长
	 * @config delay(0) 动画延迟时间
	 * @config loop(true)
	 * @config gap(0) 循环的间隔时间
	 * @config onframe
	 * @config easing(optional)
	 * @config ondestroy(optional)
	 * @config onrestart(optional)
	 *
	 * TODO pause
	 */
	function Clip(options) {
	  this._target = options.target; // 生命周期
	
	  this._life = options.life || 1000; // 延时
	
	  this._delay = options.delay || 0; // 开始时间
	  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒
	
	  this._initialized = false; // 是否循环
	
	  this.loop = options.loop == null ? false : options.loop;
	  this.gap = options.gap || 0;
	  this.easing = options.easing || 'Linear';
	  this.onframe = options.onframe;
	  this.ondestroy = options.ondestroy;
	  this.onrestart = options.onrestart;
	  this._pausedTime = 0;
	  this._paused = false;
	}
	
	Clip.prototype = {
	  constructor: Clip,
	  step: function (globalTime, deltaTime) {
	    // Set startTime on first step, or _startTime may has milleseconds different between clips
	    // PENDING
	    if (!this._initialized) {
	      this._startTime = globalTime + this._delay;
	      this._initialized = true;
	    }
	
	    if (this._paused) {
	      this._pausedTime += deltaTime;
	      return;
	    }
	
	    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始
	
	    if (percent < 0) {
	      return;
	    }
	
	    percent = Math.min(percent, 1);
	    var easing = this.easing;
	    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
	    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;
	    this.fire('frame', schedule); // 结束
	
	    if (percent == 1) {
	      if (this.loop) {
	        this.restart(globalTime); // 重新开始周期
	        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
	
	        return 'restart';
	      } // 动画完成将这个控制器标识为待删除
	      // 在Animation.update中进行批量删除
	
	
	      this._needsRemove = true;
	      return 'destroy';
	    }
	
	    return null;
	  },
	  restart: function (globalTime) {
	    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
	    this._startTime = globalTime - remainder + this.gap;
	    this._pausedTime = 0;
	    this._needsRemove = false;
	  },
	  fire: function (eventType, arg) {
	    eventType = 'on' + eventType;
	
	    if (this[eventType]) {
	      this[eventType](this._target, arg);
	    }
	  },
	  pause: function () {
	    this._paused = true;
	  },
	  resume: function () {
	    this._paused = false;
	  }
	};
	var _default = Clip;
	module.exports = _default;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

	/**
	 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
	 * @see http://sole.github.io/tween.js/examples/03_graphs.html
	 * @exports zrender/animation/easing
	 */
	var easing = {
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  linear: function (k) {
	    return k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quadraticIn: function (k) {
	    return k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quadraticOut: function (k) {
	    return k * (2 - k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quadraticInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k;
	    }
	
	    return -0.5 * (--k * (k - 2) - 1);
	  },
	  // 三次方的缓动（t^3）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  cubicIn: function (k) {
	    return k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  cubicOut: function (k) {
	    return --k * k * k + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  cubicInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k * k;
	    }
	
	    return 0.5 * ((k -= 2) * k * k + 2);
	  },
	  // 四次方的缓动（t^4）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quarticIn: function (k) {
	    return k * k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quarticOut: function (k) {
	    return 1 - --k * k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quarticInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k * k * k;
	    }
	
	    return -0.5 * ((k -= 2) * k * k * k - 2);
	  },
	  // 五次方的缓动（t^5）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quinticIn: function (k) {
	    return k * k * k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quinticOut: function (k) {
	    return --k * k * k * k * k + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quinticInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k * k * k * k;
	    }
	
	    return 0.5 * ((k -= 2) * k * k * k * k + 2);
	  },
	  // 正弦曲线的缓动（sin(t)）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  sinusoidalIn: function (k) {
	    return 1 - Math.cos(k * Math.PI / 2);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  sinusoidalOut: function (k) {
	    return Math.sin(k * Math.PI / 2);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  sinusoidalInOut: function (k) {
	    return 0.5 * (1 - Math.cos(Math.PI * k));
	  },
	  // 指数曲线的缓动（2^t）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  exponentialIn: function (k) {
	    return k === 0 ? 0 : Math.pow(1024, k - 1);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  exponentialOut: function (k) {
	    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  exponentialInOut: function (k) {
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if ((k *= 2) < 1) {
	      return 0.5 * Math.pow(1024, k - 1);
	    }
	
	    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
	  },
	  // 圆形曲线的缓动（sqrt(1-t^2)）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  circularIn: function (k) {
	    return 1 - Math.sqrt(1 - k * k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  circularOut: function (k) {
	    return Math.sqrt(1 - --k * k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  circularInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return -0.5 * (Math.sqrt(1 - k * k) - 1);
	    }
	
	    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	  },
	  // 创建类似于弹簧在停止前来回振荡的动画
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  elasticIn: function (k) {
	    var s;
	    var a = 0.1;
	    var p = 0.4;
	
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if (!a || a < 1) {
	      a = 1;
	      s = p / 4;
	    } else {
	      s = p * Math.asin(1 / a) / (2 * Math.PI);
	    }
	
	    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  elasticOut: function (k) {
	    var s;
	    var a = 0.1;
	    var p = 0.4;
	
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if (!a || a < 1) {
	      a = 1;
	      s = p / 4;
	    } else {
	      s = p * Math.asin(1 / a) / (2 * Math.PI);
	    }
	
	    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  elasticInOut: function (k) {
	    var s;
	    var a = 0.1;
	    var p = 0.4;
	
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if (!a || a < 1) {
	      a = 1;
	      s = p / 4;
	    } else {
	      s = p * Math.asin(1 / a) / (2 * Math.PI);
	    }
	
	    if ((k *= 2) < 1) {
	      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
	    }
	
	    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
	  },
	  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  backIn: function (k) {
	    var s = 1.70158;
	    return k * k * ((s + 1) * k - s);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  backOut: function (k) {
	    var s = 1.70158;
	    return --k * k * ((s + 1) * k + s) + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  backInOut: function (k) {
	    var s = 1.70158 * 1.525;
	
	    if ((k *= 2) < 1) {
	      return 0.5 * (k * k * ((s + 1) * k - s));
	    }
	
	    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	  },
	  // 创建弹跳效果
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  bounceIn: function (k) {
	    return 1 - easing.bounceOut(1 - k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  bounceOut: function (k) {
	    if (k < 1 / 2.75) {
	      return 7.5625 * k * k;
	    } else if (k < 2 / 2.75) {
	      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
	    } else if (k < 2.5 / 2.75) {
	      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
	    } else {
	      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
	    }
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  bounceInOut: function (k) {
	    if (k < 0.5) {
	      return easing.bounceIn(k * 2) * 0.5;
	    }
	
	    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
	  }
	};
	var _default = easing;
	module.exports = _default;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	var LRU = __webpack_require__(21);
	
	var kCSSColorTable = {
	  'transparent': [0, 0, 0, 0],
	  'aliceblue': [240, 248, 255, 1],
	  'antiquewhite': [250, 235, 215, 1],
	  'aqua': [0, 255, 255, 1],
	  'aquamarine': [127, 255, 212, 1],
	  'azure': [240, 255, 255, 1],
	  'beige': [245, 245, 220, 1],
	  'bisque': [255, 228, 196, 1],
	  'black': [0, 0, 0, 1],
	  'blanchedalmond': [255, 235, 205, 1],
	  'blue': [0, 0, 255, 1],
	  'blueviolet': [138, 43, 226, 1],
	  'brown': [165, 42, 42, 1],
	  'burlywood': [222, 184, 135, 1],
	  'cadetblue': [95, 158, 160, 1],
	  'chartreuse': [127, 255, 0, 1],
	  'chocolate': [210, 105, 30, 1],
	  'coral': [255, 127, 80, 1],
	  'cornflowerblue': [100, 149, 237, 1],
	  'cornsilk': [255, 248, 220, 1],
	  'crimson': [220, 20, 60, 1],
	  'cyan': [0, 255, 255, 1],
	  'darkblue': [0, 0, 139, 1],
	  'darkcyan': [0, 139, 139, 1],
	  'darkgoldenrod': [184, 134, 11, 1],
	  'darkgray': [169, 169, 169, 1],
	  'darkgreen': [0, 100, 0, 1],
	  'darkgrey': [169, 169, 169, 1],
	  'darkkhaki': [189, 183, 107, 1],
	  'darkmagenta': [139, 0, 139, 1],
	  'darkolivegreen': [85, 107, 47, 1],
	  'darkorange': [255, 140, 0, 1],
	  'darkorchid': [153, 50, 204, 1],
	  'darkred': [139, 0, 0, 1],
	  'darksalmon': [233, 150, 122, 1],
	  'darkseagreen': [143, 188, 143, 1],
	  'darkslateblue': [72, 61, 139, 1],
	  'darkslategray': [47, 79, 79, 1],
	  'darkslategrey': [47, 79, 79, 1],
	  'darkturquoise': [0, 206, 209, 1],
	  'darkviolet': [148, 0, 211, 1],
	  'deeppink': [255, 20, 147, 1],
	  'deepskyblue': [0, 191, 255, 1],
	  'dimgray': [105, 105, 105, 1],
	  'dimgrey': [105, 105, 105, 1],
	  'dodgerblue': [30, 144, 255, 1],
	  'firebrick': [178, 34, 34, 1],
	  'floralwhite': [255, 250, 240, 1],
	  'forestgreen': [34, 139, 34, 1],
	  'fuchsia': [255, 0, 255, 1],
	  'gainsboro': [220, 220, 220, 1],
	  'ghostwhite': [248, 248, 255, 1],
	  'gold': [255, 215, 0, 1],
	  'goldenrod': [218, 165, 32, 1],
	  'gray': [128, 128, 128, 1],
	  'green': [0, 128, 0, 1],
	  'greenyellow': [173, 255, 47, 1],
	  'grey': [128, 128, 128, 1],
	  'honeydew': [240, 255, 240, 1],
	  'hotpink': [255, 105, 180, 1],
	  'indianred': [205, 92, 92, 1],
	  'indigo': [75, 0, 130, 1],
	  'ivory': [255, 255, 240, 1],
	  'khaki': [240, 230, 140, 1],
	  'lavender': [230, 230, 250, 1],
	  'lavenderblush': [255, 240, 245, 1],
	  'lawngreen': [124, 252, 0, 1],
	  'lemonchiffon': [255, 250, 205, 1],
	  'lightblue': [173, 216, 230, 1],
	  'lightcoral': [240, 128, 128, 1],
	  'lightcyan': [224, 255, 255, 1],
	  'lightgoldenrodyellow': [250, 250, 210, 1],
	  'lightgray': [211, 211, 211, 1],
	  'lightgreen': [144, 238, 144, 1],
	  'lightgrey': [211, 211, 211, 1],
	  'lightpink': [255, 182, 193, 1],
	  'lightsalmon': [255, 160, 122, 1],
	  'lightseagreen': [32, 178, 170, 1],
	  'lightskyblue': [135, 206, 250, 1],
	  'lightslategray': [119, 136, 153, 1],
	  'lightslategrey': [119, 136, 153, 1],
	  'lightsteelblue': [176, 196, 222, 1],
	  'lightyellow': [255, 255, 224, 1],
	  'lime': [0, 255, 0, 1],
	  'limegreen': [50, 205, 50, 1],
	  'linen': [250, 240, 230, 1],
	  'magenta': [255, 0, 255, 1],
	  'maroon': [128, 0, 0, 1],
	  'mediumaquamarine': [102, 205, 170, 1],
	  'mediumblue': [0, 0, 205, 1],
	  'mediumorchid': [186, 85, 211, 1],
	  'mediumpurple': [147, 112, 219, 1],
	  'mediumseagreen': [60, 179, 113, 1],
	  'mediumslateblue': [123, 104, 238, 1],
	  'mediumspringgreen': [0, 250, 154, 1],
	  'mediumturquoise': [72, 209, 204, 1],
	  'mediumvioletred': [199, 21, 133, 1],
	  'midnightblue': [25, 25, 112, 1],
	  'mintcream': [245, 255, 250, 1],
	  'mistyrose': [255, 228, 225, 1],
	  'moccasin': [255, 228, 181, 1],
	  'navajowhite': [255, 222, 173, 1],
	  'navy': [0, 0, 128, 1],
	  'oldlace': [253, 245, 230, 1],
	  'olive': [128, 128, 0, 1],
	  'olivedrab': [107, 142, 35, 1],
	  'orange': [255, 165, 0, 1],
	  'orangered': [255, 69, 0, 1],
	  'orchid': [218, 112, 214, 1],
	  'palegoldenrod': [238, 232, 170, 1],
	  'palegreen': [152, 251, 152, 1],
	  'paleturquoise': [175, 238, 238, 1],
	  'palevioletred': [219, 112, 147, 1],
	  'papayawhip': [255, 239, 213, 1],
	  'peachpuff': [255, 218, 185, 1],
	  'peru': [205, 133, 63, 1],
	  'pink': [255, 192, 203, 1],
	  'plum': [221, 160, 221, 1],
	  'powderblue': [176, 224, 230, 1],
	  'purple': [128, 0, 128, 1],
	  'red': [255, 0, 0, 1],
	  'rosybrown': [188, 143, 143, 1],
	  'royalblue': [65, 105, 225, 1],
	  'saddlebrown': [139, 69, 19, 1],
	  'salmon': [250, 128, 114, 1],
	  'sandybrown': [244, 164, 96, 1],
	  'seagreen': [46, 139, 87, 1],
	  'seashell': [255, 245, 238, 1],
	  'sienna': [160, 82, 45, 1],
	  'silver': [192, 192, 192, 1],
	  'skyblue': [135, 206, 235, 1],
	  'slateblue': [106, 90, 205, 1],
	  'slategray': [112, 128, 144, 1],
	  'slategrey': [112, 128, 144, 1],
	  'snow': [255, 250, 250, 1],
	  'springgreen': [0, 255, 127, 1],
	  'steelblue': [70, 130, 180, 1],
	  'tan': [210, 180, 140, 1],
	  'teal': [0, 128, 128, 1],
	  'thistle': [216, 191, 216, 1],
	  'tomato': [255, 99, 71, 1],
	  'turquoise': [64, 224, 208, 1],
	  'violet': [238, 130, 238, 1],
	  'wheat': [245, 222, 179, 1],
	  'white': [255, 255, 255, 1],
	  'whitesmoke': [245, 245, 245, 1],
	  'yellow': [255, 255, 0, 1],
	  'yellowgreen': [154, 205, 50, 1]
	};
	
	function clampCssByte(i) {
	  // Clamp to integer 0 .. 255.
	  i = Math.round(i); // Seems to be what Chrome does (vs truncation).
	
	  return i < 0 ? 0 : i > 255 ? 255 : i;
	}
	
	function clampCssAngle(i) {
	  // Clamp to integer 0 .. 360.
	  i = Math.round(i); // Seems to be what Chrome does (vs truncation).
	
	  return i < 0 ? 0 : i > 360 ? 360 : i;
	}
	
	function clampCssFloat(f) {
	  // Clamp to float 0.0 .. 1.0.
	  return f < 0 ? 0 : f > 1 ? 1 : f;
	}
	
	function parseCssInt(str) {
	  // int or percentage.
	  if (str.length && str.charAt(str.length - 1) === '%') {
	    return clampCssByte(parseFloat(str) / 100 * 255);
	  }
	
	  return clampCssByte(parseInt(str, 10));
	}
	
	function parseCssFloat(str) {
	  // float or percentage.
	  if (str.length && str.charAt(str.length - 1) === '%') {
	    return clampCssFloat(parseFloat(str) / 100);
	  }
	
	  return clampCssFloat(parseFloat(str));
	}
	
	function cssHueToRgb(m1, m2, h) {
	  if (h < 0) {
	    h += 1;
	  } else if (h > 1) {
	    h -= 1;
	  }
	
	  if (h * 6 < 1) {
	    return m1 + (m2 - m1) * h * 6;
	  }
	
	  if (h * 2 < 1) {
	    return m2;
	  }
	
	  if (h * 3 < 2) {
	    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
	  }
	
	  return m1;
	}
	
	function lerpNumber(a, b, p) {
	  return a + (b - a) * p;
	}
	
	function setRgba(out, r, g, b, a) {
	  out[0] = r;
	  out[1] = g;
	  out[2] = b;
	  out[3] = a;
	  return out;
	}
	
	function copyRgba(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  return out;
	}
	
	var colorCache = new LRU(20);
	var lastRemovedArr = null;
	
	function putToCache(colorStr, rgbaArr) {
	  // Reuse removed array
	  if (lastRemovedArr) {
	    copyRgba(lastRemovedArr, rgbaArr);
	  }
	
	  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
	}
	/**
	 * @param {string} colorStr
	 * @param {Array.<number>} out
	 * @return {Array.<number>}
	 * @memberOf module:zrender/util/color
	 */
	
	
	function parse(colorStr, rgbaArr) {
	  if (!colorStr) {
	    return;
	  }
	
	  rgbaArr = rgbaArr || [];
	  var cached = colorCache.get(colorStr);
	
	  if (cached) {
	    return copyRgba(rgbaArr, cached);
	  } // colorStr may be not string
	
	
	  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.
	
	  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.
	
	  if (str in kCSSColorTable) {
	    copyRgba(rgbaArr, kCSSColorTable[str]);
	    putToCache(colorStr, rgbaArr);
	    return rgbaArr;
	  } // #abc and #abc123 syntax.
	
	
	  if (str.charAt(0) === '#') {
	    if (str.length === 4) {
	      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
	
	      if (!(iv >= 0 && iv <= 0xfff)) {
	        setRgba(rgbaArr, 0, 0, 0, 1);
	        return; // Covers NaN.
	      }
	
	      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);
	      putToCache(colorStr, rgbaArr);
	      return rgbaArr;
	    } else if (str.length === 7) {
	      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
	
	      if (!(iv >= 0 && iv <= 0xffffff)) {
	        setRgba(rgbaArr, 0, 0, 0, 1);
	        return; // Covers NaN.
	      }
	
	      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);
	      putToCache(colorStr, rgbaArr);
	      return rgbaArr;
	    }
	
	    return;
	  }
	
	  var op = str.indexOf('('),
	      ep = str.indexOf(')');
	
	  if (op !== -1 && ep + 1 === str.length) {
	    var fname = str.substr(0, op);
	    var params = str.substr(op + 1, ep - (op + 1)).split(',');
	    var alpha = 1; // To allow case fallthrough.
	
	    switch (fname) {
	      case 'rgba':
	        if (params.length !== 4) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        alpha = parseCssFloat(params.pop());
	      // jshint ignore:line
	      // Fall through.
	
	      case 'rgb':
	        if (params.length !== 3) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	
	      case 'hsla':
	        if (params.length !== 4) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        params[3] = parseCssFloat(params[3]);
	        hsla2rgba(params, rgbaArr);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	
	      case 'hsl':
	        if (params.length !== 3) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        hsla2rgba(params, rgbaArr);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	
	      default:
	        return;
	    }
	  }
	
	  setRgba(rgbaArr, 0, 0, 0, 1);
	  return;
	}
	/**
	 * @param {Array.<number>} hsla
	 * @param {Array.<number>} rgba
	 * @return {Array.<number>} rgba
	 */
	
	
	function hsla2rgba(hsla, rgba) {
	  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1
	  // NOTE(deanm): According to the CSS spec s/l should only be
	  // percentages, but we don't bother and let float or percentage.
	
	  var s = parseCssFloat(hsla[1]);
	  var l = parseCssFloat(hsla[2]);
	  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	  var m1 = l * 2 - m2;
	  rgba = rgba || [];
	  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
	
	  if (hsla.length === 4) {
	    rgba[3] = hsla[3];
	  }
	
	  return rgba;
	}
	/**
	 * @param {Array.<number>} rgba
	 * @return {Array.<number>} hsla
	 */
	
	
	function rgba2hsla(rgba) {
	  if (!rgba) {
	    return;
	  } // RGB from 0 to 255
	
	
	  var R = rgba[0] / 255;
	  var G = rgba[1] / 255;
	  var B = rgba[2] / 255;
	  var vMin = Math.min(R, G, B); // Min. value of RGB
	
	  var vMax = Math.max(R, G, B); // Max. value of RGB
	
	  var delta = vMax - vMin; // Delta RGB value
	
	  var L = (vMax + vMin) / 2;
	  var H;
	  var S; // HSL results from 0 to 1
	
	  if (delta === 0) {
	    H = 0;
	    S = 0;
	  } else {
	    if (L < 0.5) {
	      S = delta / (vMax + vMin);
	    } else {
	      S = delta / (2 - vMax - vMin);
	    }
	
	    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
	    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
	    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
	
	    if (R === vMax) {
	      H = deltaB - deltaG;
	    } else if (G === vMax) {
	      H = 1 / 3 + deltaR - deltaB;
	    } else if (B === vMax) {
	      H = 2 / 3 + deltaG - deltaR;
	    }
	
	    if (H < 0) {
	      H += 1;
	    }
	
	    if (H > 1) {
	      H -= 1;
	    }
	  }
	
	  var hsla = [H * 360, S, L];
	
	  if (rgba[3] != null) {
	    hsla.push(rgba[3]);
	  }
	
	  return hsla;
	}
	/**
	 * @param {string} color
	 * @param {number} level
	 * @return {string}
	 * @memberOf module:zrender/util/color
	 */
	
	
	function lift(color, level) {
	  var colorArr = parse(color);
	
	  if (colorArr) {
	    for (var i = 0; i < 3; i++) {
	      if (level < 0) {
	        colorArr[i] = colorArr[i] * (1 - level) | 0;
	      } else {
	        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
	      }
	    }
	
	    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
	  }
	}
	/**
	 * @param {string} color
	 * @return {string}
	 * @memberOf module:zrender/util/color
	 */
	
	
	function toHex(color) {
	  var colorArr = parse(color);
	
	  if (colorArr) {
	    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
	  }
	}
	/**
	 * Map value to color. Faster than lerp methods because color is represented by rgba array.
	 * @param {number} normalizedValue A float between 0 and 1.
	 * @param {Array.<Array.<number>>} colors List of rgba color array
	 * @param {Array.<number>} [out] Mapped gba color array
	 * @return {Array.<number>} will be null/undefined if input illegal.
	 */
	
	
	function fastLerp(normalizedValue, colors, out) {
	  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
	    return;
	  }
	
	  out = out || [];
	  var value = normalizedValue * (colors.length - 1);
	  var leftIndex = Math.floor(value);
	  var rightIndex = Math.ceil(value);
	  var leftColor = colors[leftIndex];
	  var rightColor = colors[rightIndex];
	  var dv = value - leftIndex;
	  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
	  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
	  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
	  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
	  return out;
	}
	/**
	 * @deprecated
	 */
	
	
	var fastMapToColor = fastLerp;
	/**
	 * @param {number} normalizedValue A float between 0 and 1.
	 * @param {Array.<string>} colors Color list.
	 * @param {boolean=} fullOutput Default false.
	 * @return {(string|Object)} Result color. If fullOutput,
	 *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
	 * @memberOf module:zrender/util/color
	 */
	
	function lerp(normalizedValue, colors, fullOutput) {
	  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
	    return;
	  }
	
	  var value = normalizedValue * (colors.length - 1);
	  var leftIndex = Math.floor(value);
	  var rightIndex = Math.ceil(value);
	  var leftColor = parse(colors[leftIndex]);
	  var rightColor = parse(colors[rightIndex]);
	  var dv = value - leftIndex;
	  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');
	  return fullOutput ? {
	    color: color,
	    leftIndex: leftIndex,
	    rightIndex: rightIndex,
	    value: value
	  } : color;
	}
	/**
	 * @deprecated
	 */
	
	
	var mapToColor = lerp;
	/**
	 * @param {string} color
	 * @param {number=} h 0 ~ 360, ignore when null.
	 * @param {number=} s 0 ~ 1, ignore when null.
	 * @param {number=} l 0 ~ 1, ignore when null.
	 * @return {string} Color string in rgba format.
	 * @memberOf module:zrender/util/color
	 */
	
	function modifyHSL(color, h, s, l) {
	  color = parse(color);
	
	  if (color) {
	    color = rgba2hsla(color);
	    h != null && (color[0] = clampCssAngle(h));
	    s != null && (color[1] = parseCssFloat(s));
	    l != null && (color[2] = parseCssFloat(l));
	    return stringify(hsla2rgba(color), 'rgba');
	  }
	}
	/**
	 * @param {string} color
	 * @param {number=} alpha 0 ~ 1
	 * @return {string} Color string in rgba format.
	 * @memberOf module:zrender/util/color
	 */
	
	
	function modifyAlpha(color, alpha) {
	  color = parse(color);
	
	  if (color && alpha != null) {
	    color[3] = clampCssFloat(alpha);
	    return stringify(color, 'rgba');
	  }
	}
	/**
	 * @param {Array.<number>} arrColor like [12,33,44,0.4]
	 * @param {string} type 'rgba', 'hsva', ...
	 * @return {string} Result color. (If input illegal, return undefined).
	 */
	
	
	function stringify(arrColor, type) {
	  if (!arrColor || !arrColor.length) {
	    return;
	  }
	
	  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
	
	  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
	    colorStr += ',' + arrColor[3];
	  }
	
	  return type + '(' + colorStr + ')';
	}
	
	exports.parse = parse;
	exports.lift = lift;
	exports.toHex = toHex;
	exports.fastLerp = fastLerp;
	exports.fastMapToColor = fastMapToColor;
	exports.lerp = lerp;
	exports.mapToColor = mapToColor;
	exports.modifyHSL = modifyHSL;
	exports.modifyAlpha = modifyAlpha;
	exports.stringify = stringify;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	// Simple LRU cache use doubly linked list
	// @module zrender/core/LRU
	
	/**
	 * Simple double linked list. Compared with array, it has O(1) remove operation.
	 * @constructor
	 */
	var LinkedList = function () {
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	  this.head = null;
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	
	  this.tail = null;
	  this._len = 0;
	};
	
	var linkedListProto = LinkedList.prototype;
	/**
	 * Insert a new value at the tail
	 * @param  {} val
	 * @return {module:zrender/core/LRU~Entry}
	 */
	
	linkedListProto.insert = function (val) {
	  var entry = new Entry(val);
	  this.insertEntry(entry);
	  return entry;
	};
	/**
	 * Insert an entry at the tail
	 * @param  {module:zrender/core/LRU~Entry} entry
	 */
	
	
	linkedListProto.insertEntry = function (entry) {
	  if (!this.head) {
	    this.head = this.tail = entry;
	  } else {
	    this.tail.next = entry;
	    entry.prev = this.tail;
	    entry.next = null;
	    this.tail = entry;
	  }
	
	  this._len++;
	};
	/**
	 * Remove entry.
	 * @param  {module:zrender/core/LRU~Entry} entry
	 */
	
	
	linkedListProto.remove = function (entry) {
	  var prev = entry.prev;
	  var next = entry.next;
	
	  if (prev) {
	    prev.next = next;
	  } else {
	    // Is head
	    this.head = next;
	  }
	
	  if (next) {
	    next.prev = prev;
	  } else {
	    // Is tail
	    this.tail = prev;
	  }
	
	  entry.next = entry.prev = null;
	  this._len--;
	};
	/**
	 * @return {number}
	 */
	
	
	linkedListProto.len = function () {
	  return this._len;
	};
	/**
	 * Clear list
	 */
	
	
	linkedListProto.clear = function () {
	  this.head = this.tail = null;
	  this._len = 0;
	};
	/**
	 * @constructor
	 * @param {} val
	 */
	
	
	var Entry = function (val) {
	  /**
	   * @type {}
	   */
	  this.value = val;
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	
	  this.next;
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	
	  this.prev;
	};
	/**
	 * LRU Cache
	 * @constructor
	 * @alias module:zrender/core/LRU
	 */
	
	
	var LRU = function (maxSize) {
	  this._list = new LinkedList();
	  this._map = {};
	  this._maxSize = maxSize || 10;
	  this._lastRemovedEntry = null;
	};
	
	var LRUProto = LRU.prototype;
	/**
	 * @param  {string} key
	 * @param  {} value
	 * @return {} Removed value
	 */
	
	LRUProto.put = function (key, value) {
	  var list = this._list;
	  var map = this._map;
	  var removed = null;
	
	  if (map[key] == null) {
	    var len = list.len(); // Reuse last removed entry
	
	    var entry = this._lastRemovedEntry;
	
	    if (len >= this._maxSize && len > 0) {
	      // Remove the least recently used
	      var leastUsedEntry = list.head;
	      list.remove(leastUsedEntry);
	      delete map[leastUsedEntry.key];
	      removed = leastUsedEntry.value;
	      this._lastRemovedEntry = leastUsedEntry;
	    }
	
	    if (entry) {
	      entry.value = value;
	    } else {
	      entry = new Entry(value);
	    }
	
	    entry.key = key;
	    list.insertEntry(entry);
	    map[key] = entry;
	  }
	
	  return removed;
	};
	/**
	 * @param  {string} key
	 * @return {}
	 */
	
	
	LRUProto.get = function (key) {
	  var entry = this._map[key];
	  var list = this._list;
	
	  if (entry != null) {
	    // Put the latest used entry in the tail
	    if (entry !== list.tail) {
	      list.remove(entry);
	      list.insertEntry(entry);
	    }
	
	    return entry.value;
	  }
	};
	/**
	 * Clear the cache
	 */
	
	
	LRUProto.clear = function () {
	  this._list.clear();
	
	  this._map = {};
	};
	
	var _default = LRU;
	module.exports = _default;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var _config = __webpack_require__(23);
	
	var debugMode = _config.debugMode;
	
	var log = function () {};
	
	if (debugMode === 1) {
	  log = function () {
	    for (var k in arguments) {
	      throw new Error(arguments[k]);
	    }
	  };
	} else if (debugMode > 1) {
	  log = function () {
	    for (var k in arguments) {
	      console.log(arguments[k]);
	    }
	  };
	}
	
	var _default = log;
	module.exports = _default;

/***/ }),
/* 23 */
/***/ (function(module, exports) {

	var dpr = 1; // If in browser environment
	
	if (typeof window !== 'undefined') {
	  dpr = Math.max(window.devicePixelRatio || 1, 1);
	}
	/**
	 * config默认配置项
	 * @exports zrender/config
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	
	/**
	 * debug日志选项：catchBrushException为true下有效
	 * 0 : 不生成debug数据，发布用
	 * 1 : 异常抛出，调试用
	 * 2 : 控制台输出，调试用
	 */
	
	
	var debugMode = 0; // retina 屏幕优化
	
	var devicePixelRatio = dpr;
	exports.debugMode = debugMode;
	exports.devicePixelRatio = devicePixelRatio;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	var textHelper = __webpack_require__(25);
	
	var BoundingRect = __webpack_require__(27);
	
	/**
	 * Mixin for drawing text in a element bounding rect
	 * @module zrender/mixin/RectText
	 */
	var tmpRect = new BoundingRect();
	
	var RectText = function () {};
	
	RectText.prototype = {
	  constructor: RectText,
	
	  /**
	   * Draw text in a rect with specified position.
	   * @param  {CanvasRenderingContext2D} ctx
	   * @param  {Object} rect Displayable rect
	   */
	  drawRectText: function (ctx, rect) {
	    var style = this.style;
	    rect = style.textRect || rect; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true);
	    var text = style.text; // Convert to string
	
	    text != null && (text += '');
	
	    if (!textHelper.needDrawText(text, style)) {
	      return;
	    } // FIXME
	
	
	    ctx.save(); // Transform rect to view space
	
	    var transform = this.transform;
	
	    if (!style.transformText) {
	      if (transform) {
	        tmpRect.copy(rect);
	        tmpRect.applyTransform(transform);
	        rect = tmpRect;
	      }
	    } else {
	      this.setTransform(ctx);
	    } // transformText and textRotation can not be used at the same time.
	
	
	    textHelper.renderText(this, ctx, text, style, rect);
	    ctx.restore();
	  }
	};
	var _default = RectText;
	module.exports = _default;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var _util = __webpack_require__(5);
	
	var retrieve2 = _util.retrieve2;
	var retrieve3 = _util.retrieve3;
	var each = _util.each;
	var normalizeCssArray = _util.normalizeCssArray;
	var isString = _util.isString;
	var isObject = _util.isObject;
	
	var textContain = __webpack_require__(26);
	
	var roundRectHelper = __webpack_require__(29);
	
	var imageHelper = __webpack_require__(28);
	
	// TODO: Have not support 'start', 'end' yet.
	var VALID_TEXT_ALIGN = {
	  left: 1,
	  right: 1,
	  center: 1
	};
	var VALID_TEXT_VERTICAL_ALIGN = {
	  top: 1,
	  bottom: 1,
	  middle: 1
	};
	/**
	 * @param {module:zrender/graphic/Style} style
	 * @return {module:zrender/graphic/Style} The input style.
	 */
	
	function normalizeTextStyle(style) {
	  normalizeStyle(style);
	  each(style.rich, normalizeStyle);
	  return style;
	}
	
	function normalizeStyle(style) {
	  if (style) {
	    style.font = textContain.makeFont(style);
	    var textAlign = style.textAlign;
	    textAlign === 'middle' && (textAlign = 'center');
	    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.
	
	    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
	    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');
	    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';
	    var textPadding = style.textPadding;
	
	    if (textPadding) {
	      style.textPadding = normalizeCssArray(style.textPadding);
	    }
	  }
	}
	/**
	 * @param {CanvasRenderingContext2D} ctx
	 * @param {string} text
	 * @param {module:zrender/graphic/Style} style
	 * @param {Object|boolean} [rect] {x, y, width, height}
	 *                  If set false, rect text is not used.
	 */
	
	
	function renderText(hostEl, ctx, text, style, rect) {
	  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);
	}
	
	function renderPlainText(hostEl, ctx, text, style, rect) {
	  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);
	  var textPadding = style.textPadding;
	  var contentBlock = hostEl.__textCotentBlock;
	
	  if (!contentBlock || hostEl.__dirty) {
	    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);
	  }
	
	  var outerHeight = contentBlock.outerHeight;
	  var textLines = contentBlock.lines;
	  var lineHeight = contentBlock.lineHeight;
	  var boxPos = getBoxPosition(outerHeight, style, rect);
	  var baseX = boxPos.baseX;
	  var baseY = boxPos.baseY;
	  var textAlign = boxPos.textAlign;
	  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.
	
	  applyTextRotation(ctx, style, rect, baseX, baseY);
	  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
	  var textX = baseX;
	  var textY = boxY;
	  var needDrawBg = needDrawBackground(style);
	
	  if (needDrawBg || textPadding) {
	    // Consider performance, do not call getTextWidth util necessary.
	    var textWidth = textContain.getWidth(text, font);
	    var outerWidth = textWidth;
	    textPadding && (outerWidth += textPadding[1] + textPadding[3]);
	    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
	    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
	
	    if (textPadding) {
	      textX = getTextXForPadding(baseX, textAlign, textPadding);
	      textY += textPadding[0];
	    }
	  }
	
	  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be "middle". Otherwise, if using "top", the
	  // text will offset downward a little bit in font "Microsoft YaHei".
	
	  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.
	
	  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);
	  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');
	  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);
	  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.
	
	  textY += lineHeight / 2;
	  var textStrokeWidth = style.textStrokeWidth;
	  var textStroke = getStroke(style.textStroke, textStrokeWidth);
	  var textFill = getFill(style.textFill);
	
	  if (textStroke) {
	    setCtx(ctx, 'lineWidth', textStrokeWidth);
	    setCtx(ctx, 'strokeStyle', textStroke);
	  }
	
	  if (textFill) {
	    setCtx(ctx, 'fillStyle', textFill);
	  }
	
	  for (var i = 0; i < textLines.length; i++) {
	    // Fill after stroke so the outline will not cover the main part.
	    textStroke && ctx.strokeText(textLines[i], textX, textY);
	    textFill && ctx.fillText(textLines[i], textX, textY);
	    textY += lineHeight;
	  }
	}
	
	function renderRichText(hostEl, ctx, text, style, rect) {
	  var contentBlock = hostEl.__textCotentBlock;
	
	  if (!contentBlock || hostEl.__dirty) {
	    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);
	  }
	
	  drawRichText(hostEl, ctx, contentBlock, style, rect);
	}
	
	function drawRichText(hostEl, ctx, contentBlock, style, rect) {
	  var contentWidth = contentBlock.width;
	  var outerWidth = contentBlock.outerWidth;
	  var outerHeight = contentBlock.outerHeight;
	  var textPadding = style.textPadding;
	  var boxPos = getBoxPosition(outerHeight, style, rect);
	  var baseX = boxPos.baseX;
	  var baseY = boxPos.baseY;
	  var textAlign = boxPos.textAlign;
	  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.
	
	  applyTextRotation(ctx, style, rect, baseX, baseY);
	  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
	  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
	  var xLeft = boxX;
	  var lineTop = boxY;
	
	  if (textPadding) {
	    xLeft += textPadding[3];
	    lineTop += textPadding[0];
	  }
	
	  var xRight = xLeft + contentWidth;
	  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
	
	  for (var i = 0; i < contentBlock.lines.length; i++) {
	    var line = contentBlock.lines[i];
	    var tokens = line.tokens;
	    var tokenCount = tokens.length;
	    var lineHeight = line.lineHeight;
	    var usedWidth = line.width;
	    var leftIndex = 0;
	    var lineXLeft = xLeft;
	    var lineXRight = xRight;
	    var rightIndex = tokenCount - 1;
	    var token;
	
	    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {
	      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');
	      usedWidth -= token.width;
	      lineXLeft += token.width;
	      leftIndex++;
	    }
	
	    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {
	      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');
	      usedWidth -= token.width;
	      lineXRight -= token.width;
	      rightIndex--;
	    } // The other tokens are placed as textAlign 'center' if there is enough space.
	
	
	    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;
	
	    while (leftIndex <= rightIndex) {
	      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.
	
	      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');
	      lineXLeft += token.width;
	      leftIndex++;
	    }
	
	    lineTop += lineHeight;
	  }
	}
	
	function applyTextRotation(ctx, style, rect, x, y) {
	  // textRotation only apply in RectText.
	  if (rect && style.textRotation) {
	    var origin = style.textOrigin;
	
	    if (origin === 'center') {
	      x = rect.width / 2 + rect.x;
	      y = rect.height / 2 + rect.y;
	    } else if (origin) {
	      x = origin[0] + rect.x;
	      y = origin[1] + rect.y;
	    }
	
	    ctx.translate(x, y); // Positive: anticlockwise
	
	    ctx.rotate(-style.textRotation);
	    ctx.translate(-x, -y);
	  }
	}
	
	function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
	  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of
	  // the bias of "Microsoft YaHei".
	
	  var textVerticalAlign = token.textVerticalAlign;
	  var y = lineTop + lineHeight / 2;
	
	  if (textVerticalAlign === 'top') {
	    y = lineTop + token.height / 2;
	  } else if (textVerticalAlign === 'bottom') {
	    y = lineTop + lineHeight - token.height / 2;
	  }
	
	  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
	  var textPadding = token.textPadding;
	
	  if (textPadding) {
	    x = getTextXForPadding(x, textAlign, textPadding);
	    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
	  }
	
	  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
	  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');
	  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
	  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
	  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be "middle". Otherwise, if using "top", the
	  // text will offset downward a little bit in font "Microsoft YaHei".
	
	  setCtx(ctx, 'textBaseline', 'middle');
	  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);
	  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
	  var textFill = getFill(tokenStyle.textFill || style.textFill);
	  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.
	
	  if (textStroke) {
	    setCtx(ctx, 'lineWidth', textStrokeWidth);
	    setCtx(ctx, 'strokeStyle', textStroke);
	    ctx.strokeText(token.text, x, y);
	  }
	
	  if (textFill) {
	    setCtx(ctx, 'fillStyle', textFill);
	    ctx.fillText(token.text, x, y);
	  }
	}
	
	function needDrawBackground(style) {
	  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;
	} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}
	// shape: {x, y, width, height}
	
	
	function drawBackground(hostEl, ctx, style, x, y, width, height) {
	  var textBackgroundColor = style.textBackgroundColor;
	  var textBorderWidth = style.textBorderWidth;
	  var textBorderColor = style.textBorderColor;
	  var isPlainBg = isString(textBackgroundColor);
	  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);
	  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');
	  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);
	  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);
	
	  if (isPlainBg || textBorderWidth && textBorderColor) {
	    ctx.beginPath();
	    var textBorderRadius = style.textBorderRadius;
	
	    if (!textBorderRadius) {
	      ctx.rect(x, y, width, height);
	    } else {
	      roundRectHelper.buildPath(ctx, {
	        x: x,
	        y: y,
	        width: width,
	        height: height,
	        r: textBorderRadius
	      });
	    }
	
	    ctx.closePath();
	  }
	
	  if (isPlainBg) {
	    setCtx(ctx, 'fillStyle', textBackgroundColor);
	    ctx.fill();
	  } else if (isObject(textBackgroundColor)) {
	    var image = textBackgroundColor.image;
	    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);
	
	    if (image && imageHelper.isImageReady(image)) {
	      ctx.drawImage(image, x, y, width, height);
	    }
	  }
	
	  if (textBorderWidth && textBorderColor) {
	    setCtx(ctx, 'lineWidth', textBorderWidth);
	    setCtx(ctx, 'strokeStyle', textBorderColor);
	    ctx.stroke();
	  }
	}
	
	function onBgImageLoaded(image, textBackgroundColor) {
	  // Replace image, so that `contain/text.js#parseRichText`
	  // will get correct result in next tick.
	  textBackgroundColor.image = image;
	}
	
	function getBoxPosition(blockHeiht, style, rect) {
	  var baseX = style.x || 0;
	  var baseY = style.y || 0;
	  var textAlign = style.textAlign;
	  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord
	
	  if (rect) {
	    var textPosition = style.textPosition;
	
	    if (textPosition instanceof Array) {
	      // Percent
	      baseX = rect.x + parsePercent(textPosition[0], rect.width);
	      baseY = rect.y + parsePercent(textPosition[1], rect.height);
	    } else {
	      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);
	      baseX = res.x;
	      baseY = res.y; // Default align and baseline when has textPosition
	
	      textAlign = textAlign || res.textAlign;
	      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
	    } // textOffset is only support in RectText, otherwise
	    // we have to adjust boundingRect for textOffset.
	
	
	    var textOffset = style.textOffset;
	
	    if (textOffset) {
	      baseX += textOffset[0];
	      baseY += textOffset[1];
	    }
	  }
	
	  return {
	    baseX: baseX,
	    baseY: baseY,
	    textAlign: textAlign,
	    textVerticalAlign: textVerticalAlign
	  };
	}
	
	function setCtx(ctx, prop, value) {
	  // FIXME ??? performance try
	  // if (ctx.__currentValues[prop] !== value) {
	  // ctx[prop] = ctx.__currentValues[prop] = value;
	  ctx[prop] = value; // }
	
	  return ctx[prop];
	}
	/**
	 * @param {string} [stroke] If specified, do not check style.textStroke.
	 * @param {string} [lineWidth] If specified, do not check style.textStroke.
	 * @param {number} style
	 */
	
	
	function getStroke(stroke, lineWidth) {
	  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?
	  : stroke.image || stroke.colorStops ? '#000' : stroke;
	}
	
	function getFill(fill) {
	  return fill == null || fill === 'none' ? null // TODO pattern and gradient?
	  : fill.image || fill.colorStops ? '#000' : fill;
	}
	
	function parsePercent(value, maxValue) {
	  if (typeof value === 'string') {
	    if (value.lastIndexOf('%') >= 0) {
	      return parseFloat(value) / 100 * maxValue;
	    }
	
	    return parseFloat(value);
	  }
	
	  return value;
	}
	
	function getTextXForPadding(x, textAlign, textPadding) {
	  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
	}
	/**
	 * @param {string} text
	 * @param {module:zrender/Style} style
	 * @return {boolean}
	 */
	
	
	function needDrawText(text, style) {
	  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
	}
	
	exports.normalizeTextStyle = normalizeTextStyle;
	exports.renderText = renderText;
	exports.getStroke = getStroke;
	exports.getFill = getFill;
	exports.needDrawText = needDrawText;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	var BoundingRect = __webpack_require__(27);
	
	var imageHelper = __webpack_require__(28);
	
	var _util = __webpack_require__(5);
	
	var getContext = _util.getContext;
	var extend = _util.extend;
	var retrieve2 = _util.retrieve2;
	var retrieve3 = _util.retrieve3;
	var textWidthCache = {};
	var textWidthCacheCounter = 0;
	var TEXT_CACHE_MAX = 5000;
	var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
	var DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.
	
	var methods = {};
	
	function $override(name, fn) {
	  methods[name] = fn;
	}
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @return {number} width
	 */
	
	
	function getWidth(text, font) {
	  font = font || DEFAULT_FONT;
	  var key = text + ':' + font;
	
	  if (textWidthCache[key]) {
	    return textWidthCache[key];
	  }
	
	  var textLines = (text + '').split('\n');
	  var width = 0;
	
	  for (var i = 0, l = textLines.length; i < l; i++) {
	    // textContain.measureText may be overrided in SVG or VML
	    width = Math.max(measureText(textLines[i], font).width, width);
	  }
	
	  if (textWidthCacheCounter > TEXT_CACHE_MAX) {
	    textWidthCacheCounter = 0;
	    textWidthCache = {};
	  }
	
	  textWidthCacheCounter++;
	  textWidthCache[key] = width;
	  return width;
	}
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @param {string} [textAlign='left']
	 * @param {string} [textVerticalAlign='top']
	 * @param {Array.<number>} [textPadding]
	 * @param {Object} [rich]
	 * @param {Object} [truncate]
	 * @return {Object} {x, y, width, height, lineHeight}
	 */
	
	
	function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
	  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);
	}
	
	function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {
	  var contentBlock = parsePlainText(text, font, textPadding, truncate);
	  var outerWidth = getWidth(text, font);
	
	  if (textPadding) {
	    outerWidth += textPadding[1] + textPadding[3];
	  }
	
	  var outerHeight = contentBlock.outerHeight;
	  var x = adjustTextX(0, outerWidth, textAlign);
	  var y = adjustTextY(0, outerHeight, textVerticalAlign);
	  var rect = new BoundingRect(x, y, outerWidth, outerHeight);
	  rect.lineHeight = contentBlock.lineHeight;
	  return rect;
	}
	
	function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
	  var contentBlock = parseRichText(text, {
	    rich: rich,
	    truncate: truncate,
	    font: font,
	    textAlign: textAlign,
	    textPadding: textPadding
	  });
	  var outerWidth = contentBlock.outerWidth;
	  var outerHeight = contentBlock.outerHeight;
	  var x = adjustTextX(0, outerWidth, textAlign);
	  var y = adjustTextY(0, outerHeight, textVerticalAlign);
	  return new BoundingRect(x, y, outerWidth, outerHeight);
	}
	/**
	 * @public
	 * @param {number} x
	 * @param {number} width
	 * @param {string} [textAlign='left']
	 * @return {number} Adjusted x.
	 */
	
	
	function adjustTextX(x, width, textAlign) {
	  // FIXME Right to left language
	  if (textAlign === 'right') {
	    x -= width;
	  } else if (textAlign === 'center') {
	    x -= width / 2;
	  }
	
	  return x;
	}
	/**
	 * @public
	 * @param {number} y
	 * @param {number} height
	 * @param {string} [textVerticalAlign='top']
	 * @return {number} Adjusted y.
	 */
	
	
	function adjustTextY(y, height, textVerticalAlign) {
	  if (textVerticalAlign === 'middle') {
	    y -= height / 2;
	  } else if (textVerticalAlign === 'bottom') {
	    y -= height;
	  }
	
	  return y;
	}
	/**
	 * @public
	 * @param {stirng} textPosition
	 * @param {Object} rect {x, y, width, height}
	 * @param {number} distance
	 * @return {Object} {x, y, textAlign, textVerticalAlign}
	 */
	
	
	function adjustTextPositionOnRect(textPosition, rect, distance) {
	  var x = rect.x;
	  var y = rect.y;
	  var height = rect.height;
	  var width = rect.width;
	  var halfHeight = height / 2;
	  var textAlign = 'left';
	  var textVerticalAlign = 'top';
	
	  switch (textPosition) {
	    case 'left':
	      x -= distance;
	      y += halfHeight;
	      textAlign = 'right';
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'right':
	      x += distance + width;
	      y += halfHeight;
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'top':
	      x += width / 2;
	      y -= distance;
	      textAlign = 'center';
	      textVerticalAlign = 'bottom';
	      break;
	
	    case 'bottom':
	      x += width / 2;
	      y += height + distance;
	      textAlign = 'center';
	      break;
	
	    case 'inside':
	      x += width / 2;
	      y += halfHeight;
	      textAlign = 'center';
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'insideLeft':
	      x += distance;
	      y += halfHeight;
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'insideRight':
	      x += width - distance;
	      y += halfHeight;
	      textAlign = 'right';
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'insideTop':
	      x += width / 2;
	      y += distance;
	      textAlign = 'center';
	      break;
	
	    case 'insideBottom':
	      x += width / 2;
	      y += height - distance;
	      textAlign = 'center';
	      textVerticalAlign = 'bottom';
	      break;
	
	    case 'insideTopLeft':
	      x += distance;
	      y += distance;
	      break;
	
	    case 'insideTopRight':
	      x += width - distance;
	      y += distance;
	      textAlign = 'right';
	      break;
	
	    case 'insideBottomLeft':
	      x += distance;
	      y += height - distance;
	      textVerticalAlign = 'bottom';
	      break;
	
	    case 'insideBottomRight':
	      x += width - distance;
	      y += height - distance;
	      textAlign = 'right';
	      textVerticalAlign = 'bottom';
	      break;
	  }
	
	  return {
	    x: x,
	    y: y,
	    textAlign: textAlign,
	    textVerticalAlign: textVerticalAlign
	  };
	}
	/**
	 * Show ellipsis if overflow.
	 *
	 * @public
	 * @param  {string} text
	 * @param  {string} containerWidth
	 * @param  {string} font
	 * @param  {number} [ellipsis='...']
	 * @param  {Object} [options]
	 * @param  {number} [options.maxIterations=3]
	 * @param  {number} [options.minChar=0] If truncate result are less
	 *                  then minChar, ellipsis will not show, which is
	 *                  better for user hint in some cases.
	 * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
	 * @return {string}
	 */
	
	
	function truncateText(text, containerWidth, font, ellipsis, options) {
	  if (!containerWidth) {
	    return '';
	  }
	
	  var textLines = (text + '').split('\n');
	  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME
	  // It is not appropriate that every line has '...' when truncate multiple lines.
	
	  for (var i = 0, len = textLines.length; i < len; i++) {
	    textLines[i] = truncateSingleLine(textLines[i], options);
	  }
	
	  return textLines.join('\n');
	}
	
	function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
	  options = extend({}, options);
	  options.font = font;
	  var ellipsis = retrieve2(ellipsis, '...');
	  options.maxIterations = retrieve2(options.maxIterations, 2);
	  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME
	  // Other languages?
	
	  options.cnCharWidth = getWidth('国', font); // FIXME
	  // Consider proportional font?
	
	  var ascCharWidth = options.ascCharWidth = getWidth('a', font);
	  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
	  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.
	
	  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.
	
	  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
	    contentWidth -= ascCharWidth;
	  }
	
	  var ellipsisWidth = getWidth(ellipsis);
	
	  if (ellipsisWidth > contentWidth) {
	    ellipsis = '';
	    ellipsisWidth = 0;
	  }
	
	  contentWidth = containerWidth - ellipsisWidth;
	  options.ellipsis = ellipsis;
	  options.ellipsisWidth = ellipsisWidth;
	  options.contentWidth = contentWidth;
	  options.containerWidth = containerWidth;
	  return options;
	}
	
	function truncateSingleLine(textLine, options) {
	  var containerWidth = options.containerWidth;
	  var font = options.font;
	  var contentWidth = options.contentWidth;
	
	  if (!containerWidth) {
	    return '';
	  }
	
	  var lineWidth = getWidth(textLine, font);
	
	  if (lineWidth <= containerWidth) {
	    return textLine;
	  }
	
	  for (var j = 0;; j++) {
	    if (lineWidth <= contentWidth || j >= options.maxIterations) {
	      textLine += options.ellipsis;
	      break;
	    }
	
	    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
	    textLine = textLine.substr(0, subLength);
	    lineWidth = getWidth(textLine, font);
	  }
	
	  if (textLine === '') {
	    textLine = options.placeholder;
	  }
	
	  return textLine;
	}
	
	function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
	  var width = 0;
	  var i = 0;
	
	  for (var len = text.length; i < len && width < contentWidth; i++) {
	    var charCode = text.charCodeAt(i);
	    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
	  }
	
	  return i;
	}
	/**
	 * @public
	 * @param {string} font
	 * @return {number} line height
	 */
	
	
	function getLineHeight(font) {
	  // FIXME A rough approach.
	  return getWidth('国', font);
	}
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @return {Object} width
	 */
	
	
	function measureText(text, font) {
	  return methods.measureText(text, font);
	} // Avoid assign to an exported variable, for transforming to cjs.
	
	
	methods.measureText = function (text, font) {
	  var ctx = getContext();
	  ctx.font = font || DEFAULT_FONT;
	  return ctx.measureText(text);
	};
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @param {Object} [truncate]
	 * @return {Object} block: {lineHeight, lines, height, outerHeight}
	 *  Notice: for performance, do not calculate outerWidth util needed.
	 */
	
	
	function parsePlainText(text, font, padding, truncate) {
	  text != null && (text += '');
	  var lineHeight = getLineHeight(font);
	  var lines = text ? text.split('\n') : [];
	  var height = lines.length * lineHeight;
	  var outerHeight = height;
	
	  if (padding) {
	    outerHeight += padding[0] + padding[2];
	  }
	
	  if (text && truncate) {
	    var truncOuterHeight = truncate.outerHeight;
	    var truncOuterWidth = truncate.outerWidth;
	
	    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
	      text = '';
	      lines = [];
	    } else if (truncOuterWidth != null) {
	      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
	        minChar: truncate.minChar,
	        placeholder: truncate.placeholder
	      }); // FIXME
	      // It is not appropriate that every line has '...' when truncate multiple lines.
	
	      for (var i = 0, len = lines.length; i < len; i++) {
	        lines[i] = truncateSingleLine(lines[i], options);
	      }
	    }
	  }
	
	  return {
	    lines: lines,
	    height: height,
	    outerHeight: outerHeight,
	    lineHeight: lineHeight
	  };
	}
	/**
	 * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
	 * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
	 *
	 * @public
	 * @param {string} text
	 * @param {Object} style
	 * @return {Object} block
	 * {
	 *      width,
	 *      height,
	 *      lines: [{
	 *          lineHeight,
	 *          width,
	 *          tokens: [[{
	 *              styleName,
	 *              text,
	 *              width,      // include textPadding
	 *              height,     // include textPadding
	 *              textWidth, // pure text width
	 *              textHeight, // pure text height
	 *              lineHeihgt,
	 *              font,
	 *              textAlign,
	 *              textVerticalAlign
	 *          }], [...], ...]
	 *      }, ...]
	 * }
	 * If styleName is undefined, it is plain text.
	 */
	
	
	function parseRichText(text, style) {
	  var contentBlock = {
	    lines: [],
	    width: 0,
	    height: 0
	  };
	  text != null && (text += '');
	
	  if (!text) {
	    return contentBlock;
	  }
	
	  var lastIndex = STYLE_REG.lastIndex = 0;
	  var result;
	
	  while ((result = STYLE_REG.exec(text)) != null) {
	    var matchedIndex = result.index;
	
	    if (matchedIndex > lastIndex) {
	      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
	    }
	
	    pushTokens(contentBlock, result[2], result[1]);
	    lastIndex = STYLE_REG.lastIndex;
	  }
	
	  if (lastIndex < text.length) {
	    pushTokens(contentBlock, text.substring(lastIndex, text.length));
	  }
	
	  var lines = contentBlock.lines;
	  var contentHeight = 0;
	  var contentWidth = 0; // For `textWidth: 100%`
	
	  var pendingList = [];
	  var stlPadding = style.textPadding;
	  var truncate = style.truncate;
	  var truncateWidth = truncate && truncate.outerWidth;
	  var truncateHeight = truncate && truncate.outerHeight;
	
	  if (stlPadding) {
	    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
	    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
	  } // Calculate layout info of tokens.
	
	
	  for (var i = 0; i < lines.length; i++) {
	    var line = lines[i];
	    var lineHeight = 0;
	    var lineWidth = 0;
	
	    for (var j = 0; j < line.tokens.length; j++) {
	      var token = line.tokens[j];
	      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.
	
	      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.
	
	      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.
	
	      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified
	      // as box height of the block.
	      tokenStyle.textHeight, getLineHeight(font));
	      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
	      token.height = tokenHeight;
	      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);
	      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
	      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';
	
	      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
	        return {
	          lines: [],
	          width: 0,
	          height: 0
	        };
	      }
	
	      token.textWidth = getWidth(token.text, font);
	      var tokenWidth = tokenStyle.textWidth;
	      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate
	      // line when box width is needed to be auto.
	
	      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {
	        token.percentWidth = tokenWidth;
	        pendingList.push(token);
	        tokenWidth = 0; // Do not truncate in this case, because there is no user case
	        // and it is too complicated.
	      } else {
	        if (tokenWidthNotSpecified) {
	          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling
	          // `getBoundingRect()` will not get correct result.
	
	          var textBackgroundColor = tokenStyle.textBackgroundColor;
	          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:
	          // (1) If image is not loaded, it will be loaded at render phase and call
	          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded
	          // image, and then the right size will be calculated here at the next tick.
	          // See `graphic/helper/text.js`.
	          // (2) If image loaded, and `textBackgroundColor.image` is image src string,
	          // use `imageHelper.findExistImage` to find cached image.
	          // `imageHelper.findExistImage` will always be called here before
	          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`
	          // which ensures that image will not be rendered before correct size calcualted.
	
	          if (bgImg) {
	            bgImg = imageHelper.findExistImage(bgImg);
	
	            if (imageHelper.isImageReady(bgImg)) {
	              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
	            }
	          }
	        }
	
	        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
	        tokenWidth += paddingW;
	        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;
	
	        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
	          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
	            token.text = '';
	            token.textWidth = tokenWidth = 0;
	          } else {
	            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
	              minChar: truncate.minChar
	            });
	            token.textWidth = getWidth(token.text, font);
	            tokenWidth = token.textWidth + paddingW;
	          }
	        }
	      }
	
	      lineWidth += token.width = tokenWidth;
	      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
	    }
	
	    line.width = lineWidth;
	    line.lineHeight = lineHeight;
	    contentHeight += lineHeight;
	    contentWidth = Math.max(contentWidth, lineWidth);
	  }
	
	  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);
	  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);
	
	  if (stlPadding) {
	    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
	    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
	  }
	
	  for (var i = 0; i < pendingList.length; i++) {
	    var token = pendingList[i];
	    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.
	
	    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
	  }
	
	  return contentBlock;
	}
	
	function pushTokens(block, str, styleName) {
	  var isEmptyStr = str === '';
	  var strs = str.split('\n');
	  var lines = block.lines;
	
	  for (var i = 0; i < strs.length; i++) {
	    var text = strs[i];
	    var token = {
	      styleName: styleName,
	      text: text,
	      isLineHolder: !text && !isEmptyStr
	    }; // The first token should be appended to the last line.
	
	    if (!i) {
	      var tokens = (lines[lines.length - 1] || (lines[0] = {
	        tokens: []
	      })).tokens; // Consider cases:
	      // (1) ''.split('\n') => ['', '\n', ''], the '' at the first item
	      // (which is a placeholder) should be replaced by new token.
	      // (2) A image backage, where token likes {a|}.
	      // (3) A redundant '' will affect textAlign in line.
	      // (4) tokens with the same tplName should not be merged, because
	      // they should be displayed in different box (with border and padding).
	
	      var tokensLen = tokens.length;
	      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the "lineHolder" or
	      // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
	      (text || !tokensLen || isEmptyStr) && tokens.push(token);
	    } // Other tokens always start a new line.
	    else {
	        // If there is '', insert it as a placeholder.
	        lines.push({
	          tokens: [token]
	        });
	      }
	  }
	}
	
	function makeFont(style) {
	  // FIXME in node-canvas fontWeight is before fontStyle
	  // Use `fontSize` `fontFamily` to check whether font properties are defined.
	  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.
	  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;
	}
	
	exports.DEFAULT_FONT = DEFAULT_FONT;
	exports.$override = $override;
	exports.getWidth = getWidth;
	exports.getBoundingRect = getBoundingRect;
	exports.adjustTextX = adjustTextX;
	exports.adjustTextY = adjustTextY;
	exports.adjustTextPositionOnRect = adjustTextPositionOnRect;
	exports.truncateText = truncateText;
	exports.getLineHeight = getLineHeight;
	exports.measureText = measureText;
	exports.parsePlainText = parsePlainText;
	exports.parseRichText = parseRichText;
	exports.makeFont = makeFont;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(15);
	
	var matrix = __webpack_require__(14);
	
	/**
	 * @module echarts/core/BoundingRect
	 */
	var v2ApplyTransform = vec2.applyTransform;
	var mathMin = Math.min;
	var mathMax = Math.max;
	/**
	 * @alias module:echarts/core/BoundingRect
	 */
	
	function BoundingRect(x, y, width, height) {
	  if (width < 0) {
	    x = x + width;
	    width = -width;
	  }
	
	  if (height < 0) {
	    y = y + height;
	    height = -height;
	  }
	  /**
	   * @type {number}
	   */
	
	
	  this.x = x;
	  /**
	   * @type {number}
	   */
	
	  this.y = y;
	  /**
	   * @type {number}
	   */
	
	  this.width = width;
	  /**
	   * @type {number}
	   */
	
	  this.height = height;
	}
	
	BoundingRect.prototype = {
	  constructor: BoundingRect,
	
	  /**
	   * @param {module:echarts/core/BoundingRect} other
	   */
	  union: function (other) {
	    var x = mathMin(other.x, this.x);
	    var y = mathMin(other.y, this.y);
	    this.width = mathMax(other.x + other.width, this.x + this.width) - x;
	    this.height = mathMax(other.y + other.height, this.y + this.height) - y;
	    this.x = x;
	    this.y = y;
	  },
	
	  /**
	   * @param {Array.<number>} m
	   * @methods
	   */
	  applyTransform: function () {
	    var lt = [];
	    var rb = [];
	    var lb = [];
	    var rt = [];
	    return function (m) {
	      // In case usage like this
	      // el.getBoundingRect().applyTransform(el.transform)
	      // And element has no transform
	      if (!m) {
	        return;
	      }
	
	      lt[0] = lb[0] = this.x;
	      lt[1] = rt[1] = this.y;
	      rb[0] = rt[0] = this.x + this.width;
	      rb[1] = lb[1] = this.y + this.height;
	      v2ApplyTransform(lt, lt, m);
	      v2ApplyTransform(rb, rb, m);
	      v2ApplyTransform(lb, lb, m);
	      v2ApplyTransform(rt, rt, m);
	      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
	      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
	      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
	      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
	      this.width = maxX - this.x;
	      this.height = maxY - this.y;
	    };
	  }(),
	
	  /**
	   * Calculate matrix of transforming from self to target rect
	   * @param  {module:zrender/core/BoundingRect} b
	   * @return {Array.<number>}
	   */
	  calculateTransform: function (b) {
	    var a = this;
	    var sx = b.width / a.width;
	    var sy = b.height / a.height;
	    var m = matrix.create(); // 矩阵右乘
	
	    matrix.translate(m, m, [-a.x, -a.y]);
	    matrix.scale(m, m, [sx, sy]);
	    matrix.translate(m, m, [b.x, b.y]);
	    return m;
	  },
	
	  /**
	   * @param {(module:echarts/core/BoundingRect|Object)} b
	   * @return {boolean}
	   */
	  intersect: function (b) {
	    if (!b) {
	      return false;
	    }
	
	    if (!(b instanceof BoundingRect)) {
	      // Normalize negative width/height.
	      b = BoundingRect.create(b);
	    }
	
	    var a = this;
	    var ax0 = a.x;
	    var ax1 = a.x + a.width;
	    var ay0 = a.y;
	    var ay1 = a.y + a.height;
	    var bx0 = b.x;
	    var bx1 = b.x + b.width;
	    var by0 = b.y;
	    var by1 = b.y + b.height;
	    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
	  },
	  contain: function (x, y) {
	    var rect = this;
	    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
	  },
	
	  /**
	   * @return {module:echarts/core/BoundingRect}
	   */
	  clone: function () {
	    return new BoundingRect(this.x, this.y, this.width, this.height);
	  },
	
	  /**
	   * Copy from another rect
	   */
	  copy: function (other) {
	    this.x = other.x;
	    this.y = other.y;
	    this.width = other.width;
	    this.height = other.height;
	  },
	  plain: function () {
	    return {
	      x: this.x,
	      y: this.y,
	      width: this.width,
	      height: this.height
	    };
	  }
	};
	/**
	 * @param {Object|module:zrender/core/BoundingRect} rect
	 * @param {number} rect.x
	 * @param {number} rect.y
	 * @param {number} rect.width
	 * @param {number} rect.height
	 * @return {module:zrender/core/BoundingRect}
	 */
	
	BoundingRect.create = function (rect) {
	  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
	};
	
	var _default = BoundingRect;
	module.exports = _default;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	var LRU = __webpack_require__(21);
	
	var globalImageCache = new LRU(50);
	/**
	 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
	 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
	 */
	
	function findExistImage(newImageOrSrc) {
	  if (typeof newImageOrSrc === 'string') {
	    var cachedImgObj = globalImageCache.get(newImageOrSrc);
	    return cachedImgObj && cachedImgObj.image;
	  } else {
	    return newImageOrSrc;
	  }
	}
	/**
	 * Caution: User should cache loaded images, but not just count on LRU.
	 * Consider if required images more than LRU size, will dead loop occur?
	 *
	 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
	 * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
	 * @param {module:zrender/Element} [hostEl] For calling `dirty`.
	 * @param {Function} [cb] params: (image, cbPayload)
	 * @param {Object} [cbPayload] Payload on cb calling.
	 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
	 */
	
	
	function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
	  if (!newImageOrSrc) {
	    return image;
	  } else if (typeof newImageOrSrc === 'string') {
	    // Image should not be loaded repeatly.
	    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
	      return image;
	    } // Only when there is no existent image or existent image src
	    // is different, this method is responsible for load.
	
	
	    var cachedImgObj = globalImageCache.get(newImageOrSrc);
	    var pendingWrap = {
	      hostEl: hostEl,
	      cb: cb,
	      cbPayload: cbPayload
	    };
	
	    if (cachedImgObj) {
	      image = cachedImgObj.image;
	      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
	    } else {
	      !image && (image = new Image());
	      image.onload = imageOnLoad;
	      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
	        image: image,
	        pending: [pendingWrap]
	      });
	      image.src = image.__zrImageSrc = newImageOrSrc;
	    }
	
	    return image;
	  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas
	  else {
	      return newImageOrSrc;
	    }
	}
	
	function imageOnLoad() {
	  var cachedImgObj = this.__cachedImgObj;
	  this.onload = this.__cachedImgObj = null;
	
	  for (var i = 0; i < cachedImgObj.pending.length; i++) {
	    var pendingWrap = cachedImgObj.pending[i];
	    var cb = pendingWrap.cb;
	    cb && cb(this, pendingWrap.cbPayload);
	    pendingWrap.hostEl.dirty();
	  }
	
	  cachedImgObj.pending.length = 0;
	}
	
	function isImageReady(image) {
	  return image && image.width && image.height;
	}
	
	exports.findExistImage = findExistImage;
	exports.createOrUpdateImage = createOrUpdateImage;
	exports.isImageReady = isImageReady;

/***/ }),
/* 29 */
/***/ (function(module, exports) {

	function buildPath(ctx, shape) {
	  var x = shape.x;
	  var y = shape.y;
	  var width = shape.width;
	  var height = shape.height;
	  var r = shape.r;
	  var r1;
	  var r2;
	  var r3;
	  var r4; // Convert width and height to positive for better borderRadius
	
	  if (width < 0) {
	    x = x + width;
	    width = -width;
	  }
	
	  if (height < 0) {
	    y = y + height;
	    height = -height;
	  }
	
	  if (typeof r === 'number') {
	    r1 = r2 = r3 = r4 = r;
	  } else if (r instanceof Array) {
	    if (r.length === 1) {
	      r1 = r2 = r3 = r4 = r[0];
	    } else if (r.length === 2) {
	      r1 = r3 = r[0];
	      r2 = r4 = r[1];
	    } else if (r.length === 3) {
	      r1 = r[0];
	      r2 = r4 = r[1];
	      r3 = r[2];
	    } else {
	      r1 = r[0];
	      r2 = r[1];
	      r3 = r[2];
	      r4 = r[3];
	    }
	  } else {
	    r1 = r2 = r3 = r4 = 0;
	  }
	
	  var total;
	
	  if (r1 + r2 > width) {
	    total = r1 + r2;
	    r1 *= width / total;
	    r2 *= width / total;
	  }
	
	  if (r3 + r4 > width) {
	    total = r3 + r4;
	    r3 *= width / total;
	    r4 *= width / total;
	  }
	
	  if (r2 + r3 > height) {
	    total = r2 + r3;
	    r2 *= height / total;
	    r3 *= height / total;
	  }
	
	  if (r1 + r4 > height) {
	    total = r1 + r4;
	    r1 *= height / total;
	    r4 *= height / total;
	  }
	
	  ctx.moveTo(x + r1, y);
	  ctx.lineTo(x + width - r2, y);
	  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);
	  ctx.lineTo(x + width, y + height - r3);
	  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);
	  ctx.lineTo(x + r4, y + height);
	  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);
	  ctx.lineTo(x, y + r1);
	  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
	}
	
	exports.buildPath = buildPath;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	var curve = __webpack_require__(31);
	
	var vec2 = __webpack_require__(15);
	
	var bbox = __webpack_require__(32);
	
	var BoundingRect = __webpack_require__(27);
	
	var _config = __webpack_require__(23);
	
	var dpr = _config.devicePixelRatio;
	
	/**
	 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
	 * 可以用于 isInsidePath 判断以及获取boundingRect
	 *
	 * @module zrender/core/PathProxy
	 * @author Yi Shen (http://www.github.com/pissang)
	 */
	// TODO getTotalLength, getPointAtLength
	var CMD = {
	  M: 1,
	  L: 2,
	  C: 3,
	  Q: 4,
	  A: 5,
	  Z: 6,
	  // Rect
	  R: 7
	}; // var CMD_MEM_SIZE = {
	//     M: 3,
	//     L: 3,
	//     C: 7,
	//     Q: 5,
	//     A: 9,
	//     R: 5,
	//     Z: 1
	// };
	
	var min = [];
	var max = [];
	var min2 = [];
	var max2 = [];
	var mathMin = Math.min;
	var mathMax = Math.max;
	var mathCos = Math.cos;
	var mathSin = Math.sin;
	var mathSqrt = Math.sqrt;
	var mathAbs = Math.abs;
	var hasTypedArray = typeof Float32Array != 'undefined';
	/**
	 * @alias module:zrender/core/PathProxy
	 * @constructor
	 */
	
	var PathProxy = function (notSaveData) {
	  this._saveData = !(notSaveData || false);
	
	  if (this._saveData) {
	    /**
	     * Path data. Stored as flat array
	     * @type {Array.<Object>}
	     */
	    this.data = [];
	  }
	
	  this._ctx = null;
	};
	/**
	 * 快速计算Path包围盒（并不是最小包围盒）
	 * @return {Object}
	 */
	
	
	PathProxy.prototype = {
	  constructor: PathProxy,
	  _xi: 0,
	  _yi: 0,
	  _x0: 0,
	  _y0: 0,
	  // Unit x, Unit y. Provide for avoiding drawing that too short line segment
	  _ux: 0,
	  _uy: 0,
	  _len: 0,
	  _lineDash: null,
	  _dashOffset: 0,
	  _dashIdx: 0,
	  _dashSum: 0,
	
	  /**
	   * @readOnly
	   */
	  setScale: function (sx, sy) {
	    this._ux = mathAbs(1 / dpr / sx) || 0;
	    this._uy = mathAbs(1 / dpr / sy) || 0;
	  },
	  getContext: function () {
	    return this._ctx;
	  },
	
	  /**
	   * @param  {CanvasRenderingContext2D} ctx
	   * @return {module:zrender/core/PathProxy}
	   */
	  beginPath: function (ctx) {
	    this._ctx = ctx;
	    ctx && ctx.beginPath();
	    ctx && (this.dpr = ctx.dpr); // Reset
	
	    if (this._saveData) {
	      this._len = 0;
	    }
	
	    if (this._lineDash) {
	      this._lineDash = null;
	      this._dashOffset = 0;
	    }
	
	    return this;
	  },
	
	  /**
	   * @param  {number} x
	   * @param  {number} y
	   * @return {module:zrender/core/PathProxy}
	   */
	  moveTo: function (x, y) {
	    this.addData(CMD.M, x, y);
	    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
	    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
	    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
	    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
	
	    this._x0 = x;
	    this._y0 = y;
	    this._xi = x;
	    this._yi = y;
	    return this;
	  },
	
	  /**
	   * @param  {number} x
	   * @param  {number} y
	   * @return {module:zrender/core/PathProxy}
	   */
	  lineTo: function (x, y) {
	    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment
	    || this._len < 5;
	    this.addData(CMD.L, x, y);
	
	    if (this._ctx && exceedUnit) {
	      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
	    }
	
	    if (exceedUnit) {
	      this._xi = x;
	      this._yi = y;
	    }
	
	    return this;
	  },
	
	  /**
	   * @param  {number} x1
	   * @param  {number} y1
	   * @param  {number} x2
	   * @param  {number} y2
	   * @param  {number} x3
	   * @param  {number} y3
	   * @return {module:zrender/core/PathProxy}
	   */
	  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
	    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
	
	    if (this._ctx) {
	      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
	    }
	
	    this._xi = x3;
	    this._yi = y3;
	    return this;
	  },
	
	  /**
	   * @param  {number} x1
	   * @param  {number} y1
	   * @param  {number} x2
	   * @param  {number} y2
	   * @return {module:zrender/core/PathProxy}
	   */
	  quadraticCurveTo: function (x1, y1, x2, y2) {
	    this.addData(CMD.Q, x1, y1, x2, y2);
	
	    if (this._ctx) {
	      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
	    }
	
	    this._xi = x2;
	    this._yi = y2;
	    return this;
	  },
	
	  /**
	   * @param  {number} cx
	   * @param  {number} cy
	   * @param  {number} r
	   * @param  {number} startAngle
	   * @param  {number} endAngle
	   * @param  {boolean} anticlockwise
	   * @return {module:zrender/core/PathProxy}
	   */
	  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
	    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
	    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
	    this._xi = mathCos(endAngle) * r + cx;
	    this._yi = mathSin(endAngle) * r + cx;
	    return this;
	  },
	  // TODO
	  arcTo: function (x1, y1, x2, y2, radius) {
	    if (this._ctx) {
	      this._ctx.arcTo(x1, y1, x2, y2, radius);
	    }
	
	    return this;
	  },
	  // TODO
	  rect: function (x, y, w, h) {
	    this._ctx && this._ctx.rect(x, y, w, h);
	    this.addData(CMD.R, x, y, w, h);
	    return this;
	  },
	
	  /**
	   * @return {module:zrender/core/PathProxy}
	   */
	  closePath: function () {
	    this.addData(CMD.Z);
	    var ctx = this._ctx;
	    var x0 = this._x0;
	    var y0 = this._y0;
	
	    if (ctx) {
	      this._needsDash() && this._dashedLineTo(x0, y0);
	      ctx.closePath();
	    }
	
	    this._xi = x0;
	    this._yi = y0;
	    return this;
	  },
	
	  /**
	   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
	   * stroke 同样
	   * @param {CanvasRenderingContext2D} ctx
	   * @return {module:zrender/core/PathProxy}
	   */
	  fill: function (ctx) {
	    ctx && ctx.fill();
	    this.toStatic();
	  },
	
	  /**
	   * @param {CanvasRenderingContext2D} ctx
	   * @return {module:zrender/core/PathProxy}
	   */
	  stroke: function (ctx) {
	    ctx && ctx.stroke();
	    this.toStatic();
	  },
	
	  /**
	   * 必须在其它绘制命令前调用
	   * Must be invoked before all other path drawing methods
	   * @return {module:zrender/core/PathProxy}
	   */
	  setLineDash: function (lineDash) {
	    if (lineDash instanceof Array) {
	      this._lineDash = lineDash;
	      this._dashIdx = 0;
	      var lineDashSum = 0;
	
	      for (var i = 0; i < lineDash.length; i++) {
	        lineDashSum += lineDash[i];
	      }
	
	      this._dashSum = lineDashSum;
	    }
	
	    return this;
	  },
	
	  /**
	   * 必须在其它绘制命令前调用
	   * Must be invoked before all other path drawing methods
	   * @return {module:zrender/core/PathProxy}
	   */
	  setLineDashOffset: function (offset) {
	    this._dashOffset = offset;
	    return this;
	  },
	
	  /**
	   *
	   * @return {boolean}
	   */
	  len: function () {
	    return this._len;
	  },
	
	  /**
	   * 直接设置 Path 数据
	   */
	  setData: function (data) {
	    var len = data.length;
	
	    if (!(this.data && this.data.length == len) && hasTypedArray) {
	      this.data = new Float32Array(len);
	    }
	
	    for (var i = 0; i < len; i++) {
	      this.data[i] = data[i];
	    }
	
	    this._len = len;
	  },
	
	  /**
	   * 添加子路径
	   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
	   */
	  appendPath: function (path) {
	    if (!(path instanceof Array)) {
	      path = [path];
	    }
	
	    var len = path.length;
	    var appendSize = 0;
	    var offset = this._len;
	
	    for (var i = 0; i < len; i++) {
	      appendSize += path[i].len();
	    }
	
	    if (hasTypedArray && this.data instanceof Float32Array) {
	      this.data = new Float32Array(offset + appendSize);
	    }
	
	    for (var i = 0; i < len; i++) {
	      var appendPathData = path[i].data;
	
	      for (var k = 0; k < appendPathData.length; k++) {
	        this.data[offset++] = appendPathData[k];
	      }
	    }
	
	    this._len = offset;
	  },
	
	  /**
	   * 填充 Path 数据。
	   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
	   */
	  addData: function (cmd) {
	    if (!this._saveData) {
	      return;
	    }
	
	    var data = this.data;
	
	    if (this._len + arguments.length > data.length) {
	      // 因为之前的数组已经转换成静态的 Float32Array
	      // 所以不够用时需要扩展一个新的动态数组
	      this._expandData();
	
	      data = this.data;
	    }
	
	    for (var i = 0; i < arguments.length; i++) {
	      data[this._len++] = arguments[i];
	    }
	
	    this._prevCmd = cmd;
	  },
	  _expandData: function () {
	    // Only if data is Float32Array
	    if (!(this.data instanceof Array)) {
	      var newData = [];
	
	      for (var i = 0; i < this._len; i++) {
	        newData[i] = this.data[i];
	      }
	
	      this.data = newData;
	    }
	  },
	
	  /**
	   * If needs js implemented dashed line
	   * @return {boolean}
	   * @private
	   */
	  _needsDash: function () {
	    return this._lineDash;
	  },
	  _dashedLineTo: function (x1, y1) {
	    var dashSum = this._dashSum;
	    var offset = this._dashOffset;
	    var lineDash = this._lineDash;
	    var ctx = this._ctx;
	    var x0 = this._xi;
	    var y0 = this._yi;
	    var dx = x1 - x0;
	    var dy = y1 - y0;
	    var dist = mathSqrt(dx * dx + dy * dy);
	    var x = x0;
	    var y = y0;
	    var dash;
	    var nDash = lineDash.length;
	    var idx;
	    dx /= dist;
	    dy /= dist;
	
	    if (offset < 0) {
	      // Convert to positive offset
	      offset = dashSum + offset;
	    }
	
	    offset %= dashSum;
	    x -= offset * dx;
	    y -= offset * dy;
	
	    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
	      idx = this._dashIdx;
	      dash = lineDash[idx];
	      x += dx * dash;
	      y += dy * dash;
	      this._dashIdx = (idx + 1) % nDash; // Skip positive offset
	
	      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
	        continue;
	      }
	
	      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));
	    } // Offset for next lineTo
	
	
	    dx = x - x1;
	    dy = y - y1;
	    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	  },
	  // Not accurate dashed line to
	  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
	    var dashSum = this._dashSum;
	    var offset = this._dashOffset;
	    var lineDash = this._lineDash;
	    var ctx = this._ctx;
	    var x0 = this._xi;
	    var y0 = this._yi;
	    var t;
	    var dx;
	    var dy;
	    var cubicAt = curve.cubicAt;
	    var bezierLen = 0;
	    var idx = this._dashIdx;
	    var nDash = lineDash.length;
	    var x;
	    var y;
	    var tmpLen = 0;
	
	    if (offset < 0) {
	      // Convert to positive offset
	      offset = dashSum + offset;
	    }
	
	    offset %= dashSum; // Bezier approx length
	
	    for (t = 0; t < 1; t += 0.1) {
	      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
	      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
	      bezierLen += mathSqrt(dx * dx + dy * dy);
	    } // Find idx after add offset
	
	
	    for (; idx < nDash; idx++) {
	      tmpLen += lineDash[idx];
	
	      if (tmpLen > offset) {
	        break;
	      }
	    }
	
	    t = (tmpLen - offset) / bezierLen;
	
	    while (t <= 1) {
	      x = cubicAt(x0, x1, x2, x3, t);
	      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier
	      // Bad result if dash is long
	
	      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
	      t += lineDash[idx] / bezierLen;
	      idx = (idx + 1) % nDash;
	    } // Finish the last segment and calculate the new offset
	
	
	    idx % 2 !== 0 && ctx.lineTo(x3, y3);
	    dx = x3 - x;
	    dy = y3 - y;
	    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	  },
	  _dashedQuadraticTo: function (x1, y1, x2, y2) {
	    // Convert quadratic to cubic using degree elevation
	    var x3 = x2;
	    var y3 = y2;
	    x2 = (x2 + 2 * x1) / 3;
	    y2 = (y2 + 2 * y1) / 3;
	    x1 = (this._xi + 2 * x1) / 3;
	    y1 = (this._yi + 2 * y1) / 3;
	
	    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
	  },
	
	  /**
	   * 转成静态的 Float32Array 减少堆内存占用
	   * Convert dynamic array to static Float32Array
	   */
	  toStatic: function () {
	    var data = this.data;
	
	    if (data instanceof Array) {
	      data.length = this._len;
	
	      if (hasTypedArray) {
	        this.data = new Float32Array(data);
	      }
	    }
	  },
	
	  /**
	   * @return {module:zrender/core/BoundingRect}
	   */
	  getBoundingRect: function () {
	    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
	    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
	    var data = this.data;
	    var xi = 0;
	    var yi = 0;
	    var x0 = 0;
	    var y0 = 0;
	
	    for (var i = 0; i < data.length;) {
	      var cmd = data[i++];
	
	      if (i == 1) {
	        // 如果第一个命令是 L, C, Q
	        // 则 previous point 同绘制命令的第一个 point
	        //
	        // 第一个命令为 Arc 的情况下会在后面特殊处理
	        xi = data[i];
	        yi = data[i + 1];
	        x0 = xi;
	        y0 = yi;
	      }
	
	      switch (cmd) {
	        case CMD.M:
	          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	          // 在 closePath 的时候使用
	          x0 = data[i++];
	          y0 = data[i++];
	          xi = x0;
	          yi = y0;
	          min2[0] = x0;
	          min2[1] = y0;
	          max2[0] = x0;
	          max2[1] = y0;
	          break;
	
	        case CMD.L:
	          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
	          xi = data[i++];
	          yi = data[i++];
	          break;
	
	        case CMD.C:
	          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
	          xi = data[i++];
	          yi = data[i++];
	          break;
	
	        case CMD.Q:
	          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
	          xi = data[i++];
	          yi = data[i++];
	          break;
	
	        case CMD.A:
	          // TODO Arc 判断的开销比较大
	          var cx = data[i++];
	          var cy = data[i++];
	          var rx = data[i++];
	          var ry = data[i++];
	          var startAngle = data[i++];
	          var endAngle = data[i++] + startAngle; // TODO Arc 旋转
	
	          var psi = data[i++];
	          var anticlockwise = 1 - data[i++];
	
	          if (i == 1) {
	            // 直接使用 arc 命令
	            // 第一个命令起点还未定义
	            x0 = mathCos(startAngle) * rx + cx;
	            y0 = mathSin(startAngle) * ry + cy;
	          }
	
	          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
	          xi = mathCos(endAngle) * rx + cx;
	          yi = mathSin(endAngle) * ry + cy;
	          break;
	
	        case CMD.R:
	          x0 = xi = data[i++];
	          y0 = yi = data[i++];
	          var width = data[i++];
	          var height = data[i++]; // Use fromLine
	
	          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
	          break;
	
	        case CMD.Z:
	          xi = x0;
	          yi = y0;
	          break;
	      } // Union
	
	
	      vec2.min(min, min, min2);
	      vec2.max(max, max, max2);
	    } // No data
	
	
	    if (i === 0) {
	      min[0] = min[1] = max[0] = max[1] = 0;
	    }
	
	    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	  },
	
	  /**
	   * Rebuild path from current data
	   * Rebuild path will not consider javascript implemented line dash.
	   * @param {CanvasRenderingContext2D} ctx
	   */
	  rebuildPath: function (ctx) {
	    var d = this.data;
	    var x0, y0;
	    var xi, yi;
	    var x, y;
	    var ux = this._ux;
	    var uy = this._uy;
	    var len = this._len;
	
	    for (var i = 0; i < len;) {
	      var cmd = d[i++];
	
	      if (i == 1) {
	        // 如果第一个命令是 L, C, Q
	        // 则 previous point 同绘制命令的第一个 point
	        //
	        // 第一个命令为 Arc 的情况下会在后面特殊处理
	        xi = d[i];
	        yi = d[i + 1];
	        x0 = xi;
	        y0 = yi;
	      }
	
	      switch (cmd) {
	        case CMD.M:
	          x0 = xi = d[i++];
	          y0 = yi = d[i++];
	          ctx.moveTo(xi, yi);
	          break;
	
	        case CMD.L:
	          x = d[i++];
	          y = d[i++]; // Not draw too small seg between
	
	          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
	            ctx.lineTo(x, y);
	            xi = x;
	            yi = y;
	          }
	
	          break;
	
	        case CMD.C:
	          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
	          xi = d[i - 2];
	          yi = d[i - 1];
	          break;
	
	        case CMD.Q:
	          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
	          xi = d[i - 2];
	          yi = d[i - 1];
	          break;
	
	        case CMD.A:
	          var cx = d[i++];
	          var cy = d[i++];
	          var rx = d[i++];
	          var ry = d[i++];
	          var theta = d[i++];
	          var dTheta = d[i++];
	          var psi = d[i++];
	          var fs = d[i++];
	          var r = rx > ry ? rx : ry;
	          var scaleX = rx > ry ? 1 : rx / ry;
	          var scaleY = rx > ry ? ry / rx : 1;
	          var isEllipse = Math.abs(rx - ry) > 1e-3;
	          var endAngle = theta + dTheta;
	
	          if (isEllipse) {
	            ctx.translate(cx, cy);
	            ctx.rotate(psi);
	            ctx.scale(scaleX, scaleY);
	            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
	            ctx.scale(1 / scaleX, 1 / scaleY);
	            ctx.rotate(-psi);
	            ctx.translate(-cx, -cy);
	          } else {
	            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
	          }
	
	          if (i == 1) {
	            // 直接使用 arc 命令
	            // 第一个命令起点还未定义
	            x0 = mathCos(theta) * rx + cx;
	            y0 = mathSin(theta) * ry + cy;
	          }
	
	          xi = mathCos(endAngle) * rx + cx;
	          yi = mathSin(endAngle) * ry + cy;
	          break;
	
	        case CMD.R:
	          x0 = xi = d[i];
	          y0 = yi = d[i + 1];
	          ctx.rect(d[i++], d[i++], d[i++], d[i++]);
	          break;
	
	        case CMD.Z:
	          ctx.closePath();
	          xi = x0;
	          yi = y0;
	      }
	    }
	  }
	};
	PathProxy.CMD = CMD;
	var _default = PathProxy;
	module.exports = _default;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	var _vector = __webpack_require__(15);
	
	var v2Create = _vector.create;
	var v2DistSquare = _vector.distSquare;
	
	/**
	 * 曲线辅助模块
	 * @module zrender/core/curve
	 * @author pissang(https://www.github.com/pissang)
	 */
	var mathPow = Math.pow;
	var mathSqrt = Math.sqrt;
	var EPSILON = 1e-8;
	var EPSILON_NUMERIC = 1e-4;
	var THREE_SQRT = mathSqrt(3);
	var ONE_THIRD = 1 / 3; // 临时变量
	
	var _v0 = v2Create();
	
	var _v1 = v2Create();
	
	var _v2 = v2Create();
	
	function isAroundZero(val) {
	  return val > -EPSILON && val < EPSILON;
	}
	
	function isNotAroundZero(val) {
	  return val > EPSILON || val < -EPSILON;
	}
	/**
	 * 计算三次贝塞尔值
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function cubicAt(p0, p1, p2, p3, t) {
	  var onet = 1 - t;
	  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
	}
	/**
	 * 计算三次贝塞尔导数值
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function cubicDerivativeAt(p0, p1, p2, p3, t) {
	  var onet = 1 - t;
	  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
	}
	/**
	 * 计算三次贝塞尔方程根，使用盛金公式
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} val
	 * @param  {Array.<number>} roots
	 * @return {number} 有效根数目
	 */
	
	
	function cubicRootAt(p0, p1, p2, p3, val, roots) {
	  // Evaluate roots of cubic functions
	  var a = p3 + 3 * (p1 - p2) - p0;
	  var b = 3 * (p2 - p1 * 2 + p0);
	  var c = 3 * (p1 - p0);
	  var d = p0 - val;
	  var A = b * b - 3 * a * c;
	  var B = b * c - 9 * a * d;
	  var C = c * c - 3 * b * d;
	  var n = 0;
	
	  if (isAroundZero(A) && isAroundZero(B)) {
	    if (isAroundZero(b)) {
	      roots[0] = 0;
	    } else {
	      var t1 = -c / b; //t1, t2, t3, b is not zero
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    }
	  } else {
	    var disc = B * B - 4 * A * C;
	
	    if (isAroundZero(disc)) {
	      var K = B / A;
	      var t1 = -b / a + K; // t1, a is not zero
	
	      var t2 = -K / 2; // t2, t3
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        roots[n++] = t2;
	      }
	    } else if (disc > 0) {
	      var discSqrt = mathSqrt(disc);
	      var Y1 = A * b + 1.5 * a * (-B + discSqrt);
	      var Y2 = A * b + 1.5 * a * (-B - discSqrt);
	
	      if (Y1 < 0) {
	        Y1 = -mathPow(-Y1, ONE_THIRD);
	      } else {
	        Y1 = mathPow(Y1, ONE_THIRD);
	      }
	
	      if (Y2 < 0) {
	        Y2 = -mathPow(-Y2, ONE_THIRD);
	      } else {
	        Y2 = mathPow(Y2, ONE_THIRD);
	      }
	
	      var t1 = (-b - (Y1 + Y2)) / (3 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    } else {
	      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
	      var theta = Math.acos(T) / 3;
	      var ASqrt = mathSqrt(A);
	      var tmp = Math.cos(theta);
	      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
	      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
	      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        roots[n++] = t2;
	      }
	
	      if (t3 >= 0 && t3 <= 1) {
	        roots[n++] = t3;
	      }
	    }
	  }
	
	  return n;
	}
	/**
	 * 计算三次贝塞尔方程极限值的位置
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {Array.<number>} extrema
	 * @return {number} 有效数目
	 */
	
	
	function cubicExtrema(p0, p1, p2, p3, extrema) {
	  var b = 6 * p2 - 12 * p1 + 6 * p0;
	  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
	  var c = 3 * p1 - 3 * p0;
	  var n = 0;
	
	  if (isAroundZero(a)) {
	    if (isNotAroundZero(b)) {
	      var t1 = -c / b;
	
	      if (t1 >= 0 && t1 <= 1) {
	        extrema[n++] = t1;
	      }
	    }
	  } else {
	    var disc = b * b - 4 * a * c;
	
	    if (isAroundZero(disc)) {
	      extrema[0] = -b / (2 * a);
	    } else if (disc > 0) {
	      var discSqrt = mathSqrt(disc);
	      var t1 = (-b + discSqrt) / (2 * a);
	      var t2 = (-b - discSqrt) / (2 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        extrema[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        extrema[n++] = t2;
	      }
	    }
	  }
	
	  return n;
	}
	/**
	 * 细分三次贝塞尔曲线
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @param  {Array.<number>} out
	 */
	
	
	function cubicSubdivide(p0, p1, p2, p3, t, out) {
	  var p01 = (p1 - p0) * t + p0;
	  var p12 = (p2 - p1) * t + p1;
	  var p23 = (p3 - p2) * t + p2;
	  var p012 = (p12 - p01) * t + p01;
	  var p123 = (p23 - p12) * t + p12;
	  var p0123 = (p123 - p012) * t + p012; // Seg0
	
	  out[0] = p0;
	  out[1] = p01;
	  out[2] = p012;
	  out[3] = p0123; // Seg1
	
	  out[4] = p0123;
	  out[5] = p123;
	  out[6] = p23;
	  out[7] = p3;
	}
	/**
	 * 投射点到三次贝塞尔曲线上，返回投射距离。
	 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x3
	 * @param {number} y3
	 * @param {number} x
	 * @param {number} y
	 * @param {Array.<number>} [out] 投射点
	 * @return {number}
	 */
	
	
	function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
	  // http://pomax.github.io/bezierinfo/#projections
	  var t;
	  var interval = 0.005;
	  var d = Infinity;
	  var prev;
	  var next;
	  var d1;
	  var d2;
	  _v0[0] = x;
	  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
	  // PENDING
	
	  for (var _t = 0; _t < 1; _t += 0.05) {
	    _v1[0] = cubicAt(x0, x1, x2, x3, _t);
	    _v1[1] = cubicAt(y0, y1, y2, y3, _t);
	    d1 = v2DistSquare(_v0, _v1);
	
	    if (d1 < d) {
	      t = _t;
	      d = d1;
	    }
	  }
	
	  d = Infinity; // At most 32 iteration
	
	  for (var i = 0; i < 32; i++) {
	    if (interval < EPSILON_NUMERIC) {
	      break;
	    }
	
	    prev = t - interval;
	    next = t + interval; // t - interval
	
	    _v1[0] = cubicAt(x0, x1, x2, x3, prev);
	    _v1[1] = cubicAt(y0, y1, y2, y3, prev);
	    d1 = v2DistSquare(_v1, _v0);
	
	    if (prev >= 0 && d1 < d) {
	      t = prev;
	      d = d1;
	    } else {
	      // t + interval
	      _v2[0] = cubicAt(x0, x1, x2, x3, next);
	      _v2[1] = cubicAt(y0, y1, y2, y3, next);
	      d2 = v2DistSquare(_v2, _v0);
	
	      if (next <= 1 && d2 < d) {
	        t = next;
	        d = d2;
	      } else {
	        interval *= 0.5;
	      }
	    }
	  } // t
	
	
	  if (out) {
	    out[0] = cubicAt(x0, x1, x2, x3, t);
	    out[1] = cubicAt(y0, y1, y2, y3, t);
	  } // console.log(interval, i);
	
	
	  return mathSqrt(d);
	}
	/**
	 * 计算二次方贝塞尔值
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function quadraticAt(p0, p1, p2, t) {
	  var onet = 1 - t;
	  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
	}
	/**
	 * 计算二次方贝塞尔导数值
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function quadraticDerivativeAt(p0, p1, p2, t) {
	  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
	}
	/**
	 * 计算二次方贝塞尔方程根
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @param  {Array.<number>} roots
	 * @return {number} 有效根数目
	 */
	
	
	function quadraticRootAt(p0, p1, p2, val, roots) {
	  var a = p0 - 2 * p1 + p2;
	  var b = 2 * (p1 - p0);
	  var c = p0 - val;
	  var n = 0;
	
	  if (isAroundZero(a)) {
	    if (isNotAroundZero(b)) {
	      var t1 = -c / b;
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    }
	  } else {
	    var disc = b * b - 4 * a * c;
	
	    if (isAroundZero(disc)) {
	      var t1 = -b / (2 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    } else if (disc > 0) {
	      var discSqrt = mathSqrt(disc);
	      var t1 = (-b + discSqrt) / (2 * a);
	      var t2 = (-b - discSqrt) / (2 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        roots[n++] = t2;
	      }
	    }
	  }
	
	  return n;
	}
	/**
	 * 计算二次贝塞尔方程极限值
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @return {number}
	 */
	
	
	function quadraticExtremum(p0, p1, p2) {
	  var divider = p0 + p2 - 2 * p1;
	
	  if (divider === 0) {
	    // p1 is center of p0 and p2
	    return 0.5;
	  } else {
	    return (p0 - p1) / divider;
	  }
	}
	/**
	 * 细分二次贝塞尔曲线
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @param  {Array.<number>} out
	 */
	
	
	function quadraticSubdivide(p0, p1, p2, t, out) {
	  var p01 = (p1 - p0) * t + p0;
	  var p12 = (p2 - p1) * t + p1;
	  var p012 = (p12 - p01) * t + p01; // Seg0
	
	  out[0] = p0;
	  out[1] = p01;
	  out[2] = p012; // Seg1
	
	  out[3] = p012;
	  out[4] = p12;
	  out[5] = p2;
	}
	/**
	 * 投射点到二次贝塞尔曲线上，返回投射距离。
	 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x
	 * @param {number} y
	 * @param {Array.<number>} out 投射点
	 * @return {number}
	 */
	
	
	function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
	  // http://pomax.github.io/bezierinfo/#projections
	  var t;
	  var interval = 0.005;
	  var d = Infinity;
	  _v0[0] = x;
	  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
	  // PENDING
	
	  for (var _t = 0; _t < 1; _t += 0.05) {
	    _v1[0] = quadraticAt(x0, x1, x2, _t);
	    _v1[1] = quadraticAt(y0, y1, y2, _t);
	    var d1 = v2DistSquare(_v0, _v1);
	
	    if (d1 < d) {
	      t = _t;
	      d = d1;
	    }
	  }
	
	  d = Infinity; // At most 32 iteration
	
	  for (var i = 0; i < 32; i++) {
	    if (interval < EPSILON_NUMERIC) {
	      break;
	    }
	
	    var prev = t - interval;
	    var next = t + interval; // t - interval
	
	    _v1[0] = quadraticAt(x0, x1, x2, prev);
	    _v1[1] = quadraticAt(y0, y1, y2, prev);
	    var d1 = v2DistSquare(_v1, _v0);
	
	    if (prev >= 0 && d1 < d) {
	      t = prev;
	      d = d1;
	    } else {
	      // t + interval
	      _v2[0] = quadraticAt(x0, x1, x2, next);
	      _v2[1] = quadraticAt(y0, y1, y2, next);
	      var d2 = v2DistSquare(_v2, _v0);
	
	      if (next <= 1 && d2 < d) {
	        t = next;
	        d = d2;
	      } else {
	        interval *= 0.5;
	      }
	    }
	  } // t
	
	
	  if (out) {
	    out[0] = quadraticAt(x0, x1, x2, t);
	    out[1] = quadraticAt(y0, y1, y2, t);
	  } // console.log(interval, i);
	
	
	  return mathSqrt(d);
	}
	
	exports.cubicAt = cubicAt;
	exports.cubicDerivativeAt = cubicDerivativeAt;
	exports.cubicRootAt = cubicRootAt;
	exports.cubicExtrema = cubicExtrema;
	exports.cubicSubdivide = cubicSubdivide;
	exports.cubicProjectPoint = cubicProjectPoint;
	exports.quadraticAt = quadraticAt;
	exports.quadraticDerivativeAt = quadraticDerivativeAt;
	exports.quadraticRootAt = quadraticRootAt;
	exports.quadraticExtremum = quadraticExtremum;
	exports.quadraticSubdivide = quadraticSubdivide;
	exports.quadraticProjectPoint = quadraticProjectPoint;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(15);
	
	var curve = __webpack_require__(31);
	
	/**
	 * @author Yi Shen(https://github.com/pissang)
	 */
	var mathMin = Math.min;
	var mathMax = Math.max;
	var mathSin = Math.sin;
	var mathCos = Math.cos;
	var PI2 = Math.PI * 2;
	var start = vec2.create();
	var end = vec2.create();
	var extremity = vec2.create();
	/**
	 * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
	 * @module zrender/core/bbox
	 * @param {Array<Object>} points 顶点数组
	 * @param {number} min
	 * @param {number} max
	 */
	
	function fromPoints(points, min, max) {
	  if (points.length === 0) {
	    return;
	  }
	
	  var p = points[0];
	  var left = p[0];
	  var right = p[0];
	  var top = p[1];
	  var bottom = p[1];
	  var i;
	
	  for (i = 1; i < points.length; i++) {
	    p = points[i];
	    left = mathMin(left, p[0]);
	    right = mathMax(right, p[0]);
	    top = mathMin(top, p[1]);
	    bottom = mathMax(bottom, p[1]);
	  }
	
	  min[0] = left;
	  min[1] = top;
	  max[0] = right;
	  max[1] = bottom;
	}
	/**
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	
	function fromLine(x0, y0, x1, y1, min, max) {
	  min[0] = mathMin(x0, x1);
	  min[1] = mathMin(y0, y1);
	  max[0] = mathMax(x0, x1);
	  max[1] = mathMax(y0, y1);
	}
	
	var xDim = [];
	var yDim = [];
	/**
	 * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x3
	 * @param {number} y3
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
	  var cubicExtrema = curve.cubicExtrema;
	  var cubicAt = curve.cubicAt;
	  var i;
	  var n = cubicExtrema(x0, x1, x2, x3, xDim);
	  min[0] = Infinity;
	  min[1] = Infinity;
	  max[0] = -Infinity;
	  max[1] = -Infinity;
	
	  for (i = 0; i < n; i++) {
	    var x = cubicAt(x0, x1, x2, x3, xDim[i]);
	    min[0] = mathMin(x, min[0]);
	    max[0] = mathMax(x, max[0]);
	  }
	
	  n = cubicExtrema(y0, y1, y2, y3, yDim);
	
	  for (i = 0; i < n; i++) {
	    var y = cubicAt(y0, y1, y2, y3, yDim[i]);
	    min[1] = mathMin(y, min[1]);
	    max[1] = mathMax(y, max[1]);
	  }
	
	  min[0] = mathMin(x0, min[0]);
	  max[0] = mathMax(x0, max[0]);
	  min[0] = mathMin(x3, min[0]);
	  max[0] = mathMax(x3, max[0]);
	  min[1] = mathMin(y0, min[1]);
	  max[1] = mathMax(y0, max[1]);
	  min[1] = mathMin(y3, min[1]);
	  max[1] = mathMax(y3, max[1]);
	}
	/**
	 * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	
	function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
	  var quadraticExtremum = curve.quadraticExtremum;
	  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero
	
	  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);
	  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);
	  var x = quadraticAt(x0, x1, x2, tx);
	  var y = quadraticAt(y0, y1, y2, ty);
	  min[0] = mathMin(x0, x2, x);
	  min[1] = mathMin(y0, y2, y);
	  max[0] = mathMax(x0, x2, x);
	  max[1] = mathMax(y0, y2, y);
	}
	/**
	 * 从圆弧中计算出最小包围盒，写入`min`和`max`中
	 * @method
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x
	 * @param {number} y
	 * @param {number} rx
	 * @param {number} ry
	 * @param {number} startAngle
	 * @param {number} endAngle
	 * @param {number} anticlockwise
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	
	function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
	  var vec2Min = vec2.min;
	  var vec2Max = vec2.max;
	  var diff = Math.abs(startAngle - endAngle);
	
	  if (diff % PI2 < 1e-4 && diff > 1e-4) {
	    // Is a circle
	    min[0] = x - rx;
	    min[1] = y - ry;
	    max[0] = x + rx;
	    max[1] = y + ry;
	    return;
	  }
	
	  start[0] = mathCos(startAngle) * rx + x;
	  start[1] = mathSin(startAngle) * ry + y;
	  end[0] = mathCos(endAngle) * rx + x;
	  end[1] = mathSin(endAngle) * ry + y;
	  vec2Min(min, start, end);
	  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]
	
	  startAngle = startAngle % PI2;
	
	  if (startAngle < 0) {
	    startAngle = startAngle + PI2;
	  }
	
	  endAngle = endAngle % PI2;
	
	  if (endAngle < 0) {
	    endAngle = endAngle + PI2;
	  }
	
	  if (startAngle > endAngle && !anticlockwise) {
	    endAngle += PI2;
	  } else if (startAngle < endAngle && anticlockwise) {
	    startAngle += PI2;
	  }
	
	  if (anticlockwise) {
	    var tmp = endAngle;
	    endAngle = startAngle;
	    startAngle = tmp;
	  } // var number = 0;
	  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
	
	
	  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
	    if (angle > startAngle) {
	      extremity[0] = mathCos(angle) * rx + x;
	      extremity[1] = mathSin(angle) * ry + y;
	      vec2Min(min, extremity, min);
	      vec2Max(max, extremity, max);
	    }
	  }
	}
	
	exports.fromPoints = fromPoints;
	exports.fromLine = fromLine;
	exports.fromCubic = fromCubic;
	exports.fromQuadratic = fromQuadratic;
	exports.fromArc = fromArc;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	var PathProxy = __webpack_require__(30);
	
	var line = __webpack_require__(34);
	
	var cubic = __webpack_require__(35);
	
	var quadratic = __webpack_require__(36);
	
	var arc = __webpack_require__(37);
	
	var _util = __webpack_require__(38);
	
	var normalizeRadian = _util.normalizeRadian;
	
	var curve = __webpack_require__(31);
	
	var windingLine = __webpack_require__(39);
	
	var CMD = PathProxy.CMD;
	var PI2 = Math.PI * 2;
	var EPSILON = 1e-4;
	
	function isAroundEqual(a, b) {
	  return Math.abs(a - b) < EPSILON;
	} // 临时数组
	
	
	var roots = [-1, -1, -1];
	var extrema = [-1, -1];
	
	function swapExtrema() {
	  var tmp = extrema[0];
	  extrema[0] = extrema[1];
	  extrema[1] = tmp;
	}
	
	function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
	  // Quick reject
	  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
	    return 0;
	  }
	
	  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
	
	  if (nRoots === 0) {
	    return 0;
	  } else {
	    var w = 0;
	    var nExtrema = -1;
	    var y0_, y1_;
	
	    for (var i = 0; i < nRoots; i++) {
	      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon
	
	      var unit = t === 0 || t === 1 ? 0.5 : 1;
	      var x_ = curve.cubicAt(x0, x1, x2, x3, t);
	
	      if (x_ < x) {
	        // Quick reject
	        continue;
	      }
	
	      if (nExtrema < 0) {
	        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
	
	        if (extrema[1] < extrema[0] && nExtrema > 1) {
	          swapExtrema();
	        }
	
	        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
	
	        if (nExtrema > 1) {
	          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
	        }
	      }
	
	      if (nExtrema == 2) {
	        // 分成三段单调函数
	        if (t < extrema[0]) {
	          w += y0_ < y0 ? unit : -unit;
	        } else if (t < extrema[1]) {
	          w += y1_ < y0_ ? unit : -unit;
	        } else {
	          w += y3 < y1_ ? unit : -unit;
	        }
	      } else {
	        // 分成两段单调函数
	        if (t < extrema[0]) {
	          w += y0_ < y0 ? unit : -unit;
	        } else {
	          w += y3 < y0_ ? unit : -unit;
	        }
	      }
	    }
	
	    return w;
	  }
	}
	
	function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
	  // Quick reject
	  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
	    return 0;
	  }
	
	  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
	
	  if (nRoots === 0) {
	    return 0;
	  } else {
	    var t = curve.quadraticExtremum(y0, y1, y2);
	
	    if (t >= 0 && t <= 1) {
	      var w = 0;
	      var y_ = curve.quadraticAt(y0, y1, y2, t);
	
	      for (var i = 0; i < nRoots; i++) {
	        // Remove one endpoint.
	        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
	        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
	
	        if (x_ < x) {
	          // Quick reject
	          continue;
	        }
	
	        if (roots[i] < t) {
	          w += y_ < y0 ? unit : -unit;
	        } else {
	          w += y2 < y_ ? unit : -unit;
	        }
	      }
	
	      return w;
	    } else {
	      // Remove one endpoint.
	      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
	      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
	
	      if (x_ < x) {
	        // Quick reject
	        return 0;
	      }
	
	      return y2 < y0 ? unit : -unit;
	    }
	  }
	} // TODO
	// Arc 旋转
	
	
	function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
	  y -= cy;
	
	  if (y > r || y < -r) {
	    return 0;
	  }
	
	  var tmp = Math.sqrt(r * r - y * y);
	  roots[0] = -tmp;
	  roots[1] = tmp;
	  var diff = Math.abs(startAngle - endAngle);
	
	  if (diff < 1e-4) {
	    return 0;
	  }
	
	  if (diff % PI2 < 1e-4) {
	    // Is a circle
	    startAngle = 0;
	    endAngle = PI2;
	    var dir = anticlockwise ? 1 : -1;
	
	    if (x >= roots[0] + cx && x <= roots[1] + cx) {
	      return dir;
	    } else {
	      return 0;
	    }
	  }
	
	  if (anticlockwise) {
	    var tmp = startAngle;
	    startAngle = normalizeRadian(endAngle);
	    endAngle = normalizeRadian(tmp);
	  } else {
	    startAngle = normalizeRadian(startAngle);
	    endAngle = normalizeRadian(endAngle);
	  }
	
	  if (startAngle > endAngle) {
	    endAngle += PI2;
	  }
	
	  var w = 0;
	
	  for (var i = 0; i < 2; i++) {
	    var x_ = roots[i];
	
	    if (x_ + cx > x) {
	      var angle = Math.atan2(y, x_);
	      var dir = anticlockwise ? 1 : -1;
	
	      if (angle < 0) {
	        angle = PI2 + angle;
	      }
	
	      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
	        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
	          dir = -dir;
	        }
	
	        w += dir;
	      }
	    }
	  }
	
	  return w;
	}
	
	function containPath(data, lineWidth, isStroke, x, y) {
	  var w = 0;
	  var xi = 0;
	  var yi = 0;
	  var x0 = 0;
	  var y0 = 0;
	
	  for (var i = 0; i < data.length;) {
	    var cmd = data[i++]; // Begin a new subpath
	
	    if (cmd === CMD.M && i > 1) {
	      // Close previous subpath
	      if (!isStroke) {
	        w += windingLine(xi, yi, x0, y0, x, y);
	      } // 如果被任何一个 subpath 包含
	      // if (w !== 0) {
	      //     return true;
	      // }
	
	    }
	
	    if (i == 1) {
	      // 如果第一个命令是 L, C, Q
	      // 则 previous point 同绘制命令的第一个 point
	      //
	      // 第一个命令为 Arc 的情况下会在后面特殊处理
	      xi = data[i];
	      yi = data[i + 1];
	      x0 = xi;
	      y0 = yi;
	    }
	
	    switch (cmd) {
	      case CMD.M:
	        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	        // 在 closePath 的时候使用
	        x0 = data[i++];
	        y0 = data[i++];
	        xi = x0;
	        yi = y0;
	        break;
	
	      case CMD.L:
	        if (isStroke) {
	          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
	          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
	        }
	
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.C:
	        if (isStroke) {
	          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
	        }
	
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.Q:
	        if (isStroke) {
	          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
	        }
	
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.A:
	        // TODO Arc 判断的开销比较大
	        var cx = data[i++];
	        var cy = data[i++];
	        var rx = data[i++];
	        var ry = data[i++];
	        var theta = data[i++];
	        var dTheta = data[i++]; // TODO Arc 旋转
	
	        var psi = data[i++];
	        var anticlockwise = 1 - data[i++];
	        var x1 = Math.cos(theta) * rx + cx;
	        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令
	
	        if (i > 1) {
	          w += windingLine(xi, yi, x1, y1, x, y);
	        } else {
	          // 第一个命令起点还未定义
	          x0 = x1;
	          y0 = y1;
	        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
	
	
	        var _x = (x - cx) * ry / rx + cx;
	
	        if (isStroke) {
	          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
	            return true;
	          }
	        } else {
	          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
	        }
	
	        xi = Math.cos(theta + dTheta) * rx + cx;
	        yi = Math.sin(theta + dTheta) * ry + cy;
	        break;
	
	      case CMD.R:
	        x0 = xi = data[i++];
	        y0 = yi = data[i++];
	        var width = data[i++];
	        var height = data[i++];
	        var x1 = x0 + width;
	        var y1 = y0 + height;
	
	        if (isStroke) {
	          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          // FIXME Clockwise ?
	          w += windingLine(x1, y0, x1, y1, x, y);
	          w += windingLine(x0, y1, x0, y0, x, y);
	        }
	
	        break;
	
	      case CMD.Z:
	        if (isStroke) {
	          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          // Close a subpath
	          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含
	          // FIXME subpaths may overlap
	          // if (w !== 0) {
	          //     return true;
	          // }
	        }
	
	        xi = x0;
	        yi = y0;
	        break;
	    }
	  }
	
	  if (!isStroke && !isAroundEqual(yi, y0)) {
	    w += windingLine(xi, yi, x0, y0, x, y) || 0;
	  }
	
	  return w !== 0;
	}
	
	function contain(pathData, x, y) {
	  return containPath(pathData, 0, false, x, y);
	}
	
	function containStroke(pathData, lineWidth, x, y) {
	  return containPath(pathData, lineWidth, true, x, y);
	}
	
	exports.contain = contain;
	exports.containStroke = containStroke;

/***/ }),
/* 34 */
/***/ (function(module, exports) {

	/**
	 * 线段包含判断
	 * @param  {number}  x0
	 * @param  {number}  y0
	 * @param  {number}  x1
	 * @param  {number}  y1
	 * @param  {number}  lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {boolean}
	 */
	function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth;
	  var _a = 0;
	  var _b = x0; // Quick reject
	
	  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
	    return false;
	  }
	
	  if (x0 !== x1) {
	    _a = (y0 - y1) / (x0 - x1);
	    _b = (x0 * y1 - x1 * y0) / (x0 - x1);
	  } else {
	    return Math.abs(x - x0) <= _l / 2;
	  }
	
	  var tmp = _a * x - y + _b;
	
	  var _s = tmp * tmp / (_a * _a + 1);
	
	  return _s <= _l / 2 * _l / 2;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	var curve = __webpack_require__(31);
	
	/**
	 * 三次贝塞尔曲线描边包含判断
	 * @param  {number}  x0
	 * @param  {number}  y0
	 * @param  {number}  x1
	 * @param  {number}  y1
	 * @param  {number}  x2
	 * @param  {number}  y2
	 * @param  {number}  x3
	 * @param  {number}  y3
	 * @param  {number}  lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {boolean}
	 */
	function containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth; // Quick reject
	
	  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
	    return false;
	  }
	
	  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
	  return d <= _l / 2;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	var _curve = __webpack_require__(31);
	
	var quadraticProjectPoint = _curve.quadraticProjectPoint;
	
	/**
	 * 二次贝塞尔曲线描边包含判断
	 * @param  {number}  x0
	 * @param  {number}  y0
	 * @param  {number}  x1
	 * @param  {number}  y1
	 * @param  {number}  x2
	 * @param  {number}  y2
	 * @param  {number}  lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {boolean}
	 */
	function containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth; // Quick reject
	
	  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
	    return false;
	  }
	
	  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
	  return d <= _l / 2;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	var _util = __webpack_require__(38);
	
	var normalizeRadian = _util.normalizeRadian;
	var PI2 = Math.PI * 2;
	/**
	 * 圆弧描边包含判断
	 * @param  {number}  cx
	 * @param  {number}  cy
	 * @param  {number}  r
	 * @param  {number}  startAngle
	 * @param  {number}  endAngle
	 * @param  {boolean}  anticlockwise
	 * @param  {number} lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {Boolean}
	 */
	
	function containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth;
	  x -= cx;
	  y -= cy;
	  var d = Math.sqrt(x * x + y * y);
	
	  if (d - _l > r || d + _l < r) {
	    return false;
	  }
	
	  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
	    // Is a circle
	    return true;
	  }
	
	  if (anticlockwise) {
	    var tmp = startAngle;
	    startAngle = normalizeRadian(endAngle);
	    endAngle = normalizeRadian(tmp);
	  } else {
	    startAngle = normalizeRadian(startAngle);
	    endAngle = normalizeRadian(endAngle);
	  }
	
	  if (startAngle > endAngle) {
	    endAngle += PI2;
	  }
	
	  var angle = Math.atan2(y, x);
	
	  if (angle < 0) {
	    angle += PI2;
	  }
	
	  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

	var PI2 = Math.PI * 2;
	
	function normalizeRadian(angle) {
	  angle %= PI2;
	
	  if (angle < 0) {
	    angle += PI2;
	  }
	
	  return angle;
	}
	
	exports.normalizeRadian = normalizeRadian;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	function windingLine(x0, y0, x1, y1, x, y) {
	  if (y > y0 && y > y1 || y < y0 && y < y1) {
	    return 0;
	  } // Ignore horizontal line
	
	
	  if (y1 === y0) {
	    return 0;
	  }
	
	  var dir = y1 < y0 ? 1 : -1;
	  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon
	
	  if (t === 1 || t === 0) {
	    dir = y1 < y0 ? 0.5 : -0.5;
	  }
	
	  var x_ = t * (x1 - x0) + x0;
	  return x_ > x ? dir : 0;
	}
	
	module.exports = windingLine;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

	var Pattern = function (image, repeat) {
	  // Should do nothing more in this constructor. Because gradient can be
	  // declard by `color: {image: ...}`, where this constructor will not be called.
	  this.image = image;
	  this.repeat = repeat; // Can be cloned
	
	  this.type = 'pattern';
	};
	
	Pattern.prototype.getCanvasPattern = function (ctx) {
	  return ctx.createPattern(this.image, this.repeat || 'repeat');
	};
	
	var _default = Pattern;
	module.exports = _default;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	var PathProxy = __webpack_require__(30);
	
	var _vector = __webpack_require__(15);
	
	var v2ApplyTransform = _vector.applyTransform;
	var CMD = PathProxy.CMD;
	var points = [[], [], []];
	var mathSqrt = Math.sqrt;
	var mathAtan2 = Math.atan2;
	
	function _default(path, m) {
	  var data = path.data;
	  var cmd;
	  var nPoint;
	  var i;
	  var j;
	  var k;
	  var p;
	  var M = CMD.M;
	  var C = CMD.C;
	  var L = CMD.L;
	  var R = CMD.R;
	  var A = CMD.A;
	  var Q = CMD.Q;
	
	  for (i = 0, j = 0; i < data.length;) {
	    cmd = data[i++];
	    j = i;
	    nPoint = 0;
	
	    switch (cmd) {
	      case M:
	        nPoint = 1;
	        break;
	
	      case L:
	        nPoint = 1;
	        break;
	
	      case C:
	        nPoint = 3;
	        break;
	
	      case Q:
	        nPoint = 2;
	        break;
	
	      case A:
	        var x = m[4];
	        var y = m[5];
	        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
	        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
	        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx
	
	        data[i] *= sx;
	        data[i++] += x; // cy
	
	        data[i] *= sy;
	        data[i++] += y; // Scale rx and ry
	        // FIXME Assume psi is 0 here
	
	        data[i++] *= sx;
	        data[i++] *= sy; // Start angle
	
	        data[i++] += angle; // end angle
	
	        data[i++] += angle; // FIXME psi
	
	        i += 2;
	        j = i;
	        break;
	
	      case R:
	        // x0, y0
	        p[0] = data[i++];
	        p[1] = data[i++];
	        v2ApplyTransform(p, p, m);
	        data[j++] = p[0];
	        data[j++] = p[1]; // x1, y1
	
	        p[0] += data[i++];
	        p[1] += data[i++];
	        v2ApplyTransform(p, p, m);
	        data[j++] = p[0];
	        data[j++] = p[1];
	    }
	
	    for (k = 0; k < nPoint; k++) {
	      var p = points[k];
	      p[0] = data[i++];
	      p[1] = data[i++];
	      v2ApplyTransform(p, p, m); // Write back
	
	      data[j++] = p[0];
	      data[j++] = p[1];
	    }
	  }
	}
	
	module.exports = _default;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	/**
	 * @param {Array.<Object>} colorStops
	 */
	var Gradient = function (colorStops) {
	  this.colorStops = colorStops || [];
	};
	
	Gradient.prototype = {
	  constructor: Gradient,
	  addColorStop: function (offset, color) {
	    this.colorStops.push({
	      offset: offset,
	      color: color
	    });
	  }
	};
	var _default = Gradient;
	module.exports = _default;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	// TODO Draggable for group
	// FIXME Draggable on element which has parent rotation or scale
	function Draggable() {
	  this.on('mousedown', this._dragStart, this);
	  this.on('mousemove', this._drag, this);
	  this.on('mouseup', this._dragEnd, this);
	  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;
	  // this._draggingTarget = null;
	  // this._x = 0;
	  // this._y = 0;
	}
	
	Draggable.prototype = {
	  constructor: Draggable,
	  _dragStart: function (e) {
	    var draggingTarget = e.target;
	
	    if (draggingTarget && draggingTarget.draggable) {
	      this._draggingTarget = draggingTarget;
	      draggingTarget.dragging = true;
	      this._x = e.offsetX;
	      this._y = e.offsetY;
	      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);
	    }
	  },
	  _drag: function (e) {
	    var draggingTarget = this._draggingTarget;
	
	    if (draggingTarget) {
	      var x = e.offsetX;
	      var y = e.offsetY;
	      var dx = x - this._x;
	      var dy = y - this._y;
	      this._x = x;
	      this._y = y;
	      draggingTarget.drift(dx, dy, e);
	      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);
	      var dropTarget = this.findHover(x, y, draggingTarget).target;
	      var lastDropTarget = this._dropTarget;
	      this._dropTarget = dropTarget;
	
	      if (draggingTarget !== dropTarget) {
	        if (lastDropTarget && dropTarget !== lastDropTarget) {
	          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);
	        }
	
	        if (dropTarget && dropTarget !== lastDropTarget) {
	          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);
	        }
	      }
	    }
	  },
	  _dragEnd: function (e) {
	    var draggingTarget = this._draggingTarget;
	
	    if (draggingTarget) {
	      draggingTarget.dragging = false;
	    }
	
	    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);
	
	    if (this._dropTarget) {
	      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);
	    }
	
	    this._draggingTarget = null;
	    this._dropTarget = null;
	  }
	};
	
	function param(target, e) {
	  return {
	    target: target,
	    topTarget: e && e.topTarget
	  };
	}
	
	var _default = Draggable;
	module.exports = _default;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(5);
	
	var Element = __webpack_require__(10);
	
	var BoundingRect = __webpack_require__(27);
	
	/**
	 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
	 * @module zrender/graphic/Group
	 * @example
	 *     var Group = require('zrender/container/Group');
	 *     var Circle = require('zrender/graphic/shape/Circle');
	 *     var g = new Group();
	 *     g.position[0] = 100;
	 *     g.position[1] = 100;
	 *     g.add(new Circle({
	 *         style: {
	 *             x: 100,
	 *             y: 100,
	 *             r: 20,
	 *         }
	 *     }));
	 *     zr.add(g);
	 */
	
	/**
	 * @alias module:zrender/graphic/Group
	 * @constructor
	 * @extends module:zrender/mixin/Transformable
	 * @extends module:zrender/mixin/Eventful
	 */
	var Group = function (opts) {
	  opts = opts || {};
	  Element.call(this, opts);
	
	  for (var key in opts) {
	    if (opts.hasOwnProperty(key)) {
	      this[key] = opts[key];
	    }
	  }
	
	  this._children = [];
	  this.__storage = null;
	  this.__dirty = true;
	};
	
	Group.prototype = {
	  constructor: Group,
	  isGroup: true,
	
	  /**
	   * @type {string}
	   */
	  type: 'group',
	
	  /**
	   * 所有子孙元素是否响应鼠标事件
	   * @name module:/zrender/container/Group#silent
	   * @type {boolean}
	   * @default false
	   */
	  silent: false,
	
	  /**
	   * @return {Array.<module:zrender/Element>}
	   */
	  children: function () {
	    return this._children.slice();
	  },
	
	  /**
	   * 获取指定 index 的儿子节点
	   * @param  {number} idx
	   * @return {module:zrender/Element}
	   */
	  childAt: function (idx) {
	    return this._children[idx];
	  },
	
	  /**
	   * 获取指定名字的儿子节点
	   * @param  {string} name
	   * @return {module:zrender/Element}
	   */
	  childOfName: function (name) {
	    var children = this._children;
	
	    for (var i = 0; i < children.length; i++) {
	      if (children[i].name === name) {
	        return children[i];
	      }
	    }
	  },
	
	  /**
	   * @return {number}
	   */
	  childCount: function () {
	    return this._children.length;
	  },
	
	  /**
	   * 添加子节点到最后
	   * @param {module:zrender/Element} child
	   */
	  add: function (child) {
	    if (child && child !== this && child.parent !== this) {
	      this._children.push(child);
	
	      this._doAdd(child);
	    }
	
	    return this;
	  },
	
	  /**
	   * 添加子节点在 nextSibling 之前
	   * @param {module:zrender/Element} child
	   * @param {module:zrender/Element} nextSibling
	   */
	  addBefore: function (child, nextSibling) {
	    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
	      var children = this._children;
	      var idx = children.indexOf(nextSibling);
	
	      if (idx >= 0) {
	        children.splice(idx, 0, child);
	
	        this._doAdd(child);
	      }
	    }
	
	    return this;
	  },
	  _doAdd: function (child) {
	    if (child.parent) {
	      child.parent.remove(child);
	    }
	
	    child.parent = this;
	    var storage = this.__storage;
	    var zr = this.__zr;
	
	    if (storage && storage !== child.__storage) {
	      storage.addToStorage(child);
	
	      if (child instanceof Group) {
	        child.addChildrenToStorage(storage);
	      }
	    }
	
	    zr && zr.refresh();
	  },
	
	  /**
	   * 移除子节点
	   * @param {module:zrender/Element} child
	   */
	  remove: function (child) {
	    var zr = this.__zr;
	    var storage = this.__storage;
	    var children = this._children;
	    var idx = zrUtil.indexOf(children, child);
	
	    if (idx < 0) {
	      return this;
	    }
	
	    children.splice(idx, 1);
	    child.parent = null;
	
	    if (storage) {
	      storage.delFromStorage(child);
	
	      if (child instanceof Group) {
	        child.delChildrenFromStorage(storage);
	      }
	    }
	
	    zr && zr.refresh();
	    return this;
	  },
	
	  /**
	   * 移除所有子节点
	   */
	  removeAll: function () {
	    var children = this._children;
	    var storage = this.__storage;
	    var child;
	    var i;
	
	    for (i = 0; i < children.length; i++) {
	      child = children[i];
	
	      if (storage) {
	        storage.delFromStorage(child);
	
	        if (child instanceof Group) {
	          child.delChildrenFromStorage(storage);
	        }
	      }
	
	      child.parent = null;
	    }
	
	    children.length = 0;
	    return this;
	  },
	
	  /**
	   * 遍历所有子节点
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  eachChild: function (cb, context) {
	    var children = this._children;
	
	    for (var i = 0; i < children.length; i++) {
	      var child = children[i];
	      cb.call(context, child, i);
	    }
	
	    return this;
	  },
	
	  /**
	   * 深度优先遍历所有子孙节点
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  traverse: function (cb, context) {
	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      cb.call(context, child);
	
	      if (child.type === 'group') {
	        child.traverse(cb, context);
	      }
	    }
	
	    return this;
	  },
	  addChildrenToStorage: function (storage) {
	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      storage.addToStorage(child);
	
	      if (child instanceof Group) {
	        child.addChildrenToStorage(storage);
	      }
	    }
	  },
	  delChildrenFromStorage: function (storage) {
	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      storage.delFromStorage(child);
	
	      if (child instanceof Group) {
	        child.delChildrenFromStorage(storage);
	      }
	    }
	  },
	  dirty: function () {
	    this.__dirty = true;
	    this.__zr && this.__zr.refresh();
	    return this;
	  },
	
	  /**
	   * @return {module:zrender/core/BoundingRect}
	   */
	  getBoundingRect: function (includeChildren) {
	    // TODO Caching
	    var rect = null;
	    var tmpRect = new BoundingRect(0, 0, 0, 0);
	    var children = includeChildren || this._children;
	    var tmpMat = [];
	
	    for (var i = 0; i < children.length; i++) {
	      var child = children[i];
	
	      if (child.ignore || child.invisible) {
	        continue;
	      }
	
	      var childRect = child.getBoundingRect();
	      var transform = child.getLocalTransform(tmpMat); // TODO
	      // The boundingRect cacluated by transforming original
	      // rect may be bigger than the actual bundingRect when rotation
	      // is used. (Consider a circle rotated aginst its center, where
	      // the actual boundingRect should be the same as that not be
	      // rotated.) But we can not find better approach to calculate
	      // actual boundingRect yet, considering performance.
	
	      if (transform) {
	        tmpRect.copy(childRect);
	        tmpRect.applyTransform(transform);
	        rect = rect || tmpRect.clone();
	        rect.union(tmpRect);
	      } else {
	        rect = rect || childRect.clone();
	        rect.union(childRect);
	      }
	    }
	
	    return rect || tmpRect;
	  }
	};
	zrUtil.inherits(Group, Element);
	var _default = Group;
	module.exports = _default;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	var Displayable = __webpack_require__(8);
	
	var BoundingRect = __webpack_require__(27);
	
	var zrUtil = __webpack_require__(5);
	
	var imageHelper = __webpack_require__(28);
	
	/**
	 * @alias zrender/graphic/Image
	 * @extends module:zrender/graphic/Displayable
	 * @constructor
	 * @param {Object} opts
	 */
	function ZImage(opts) {
	  Displayable.call(this, opts);
	}
	
	ZImage.prototype = {
	  constructor: ZImage,
	  type: 'image',
	  brush: function (ctx, prevEl) {
	    var style = this.style;
	    var src = style.image; // Must bind each time
	
	    style.bind(ctx, this, prevEl);
	    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);
	
	    if (!image || !imageHelper.isImageReady(image)) {
	      return;
	    } // 图片已经加载完成
	    // if (image.nodeName.toUpperCase() == 'IMG') {
	    //     if (!image.complete) {
	    //         return;
	    //     }
	    // }
	    // Else is canvas
	
	
	    var x = style.x || 0;
	    var y = style.y || 0;
	    var width = style.width;
	    var height = style.height;
	    var aspect = image.width / image.height;
	
	    if (width == null && height != null) {
	      // Keep image/height ratio
	      width = height * aspect;
	    } else if (height == null && width != null) {
	      height = width / aspect;
	    } else if (width == null && height == null) {
	      width = image.width;
	      height = image.height;
	    } // 设置transform
	
	
	    this.setTransform(ctx);
	
	    if (style.sWidth && style.sHeight) {
	      var sx = style.sx || 0;
	      var sy = style.sy || 0;
	      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
	    } else if (style.sx && style.sy) {
	      var sx = style.sx;
	      var sy = style.sy;
	      var sWidth = width - sx;
	      var sHeight = height - sy;
	      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
	    } else {
	      ctx.drawImage(image, x, y, width, height);
	    }
	
	    this.restoreTransform(ctx); // Draw rect text
	
	    if (style.text != null) {
	      this.drawRectText(ctx, this.getBoundingRect());
	    }
	  },
	  getBoundingRect: function () {
	    var style = this.style;
	
	    if (!this._rect) {
	      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
	    }
	
	    return this._rect;
	  }
	};
	zrUtil.inherits(ZImage, Displayable);
	var _default = ZImage;
	module.exports = _default;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	var Displayable = __webpack_require__(8);
	
	var zrUtil = __webpack_require__(5);
	
	var textContain = __webpack_require__(26);
	
	var textHelper = __webpack_require__(25);
	
	/**
	 * @alias zrender/graphic/Text
	 * @extends module:zrender/graphic/Displayable
	 * @constructor
	 * @param {Object} opts
	 */
	var Text = function (opts) {
	  // jshint ignore:line
	  Displayable.call(this, opts);
	};
	
	Text.prototype = {
	  constructor: Text,
	  type: 'text',
	  brush: function (ctx, prevEl) {
	    var style = this.style; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.
	
	    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
	    var text = style.text; // Convert to string
	
	    text != null && (text += ''); // Always bind style
	
	    style.bind(ctx, this, prevEl);
	
	    if (!textHelper.needDrawText(text, style)) {
	      return;
	    }
	
	    this.setTransform(ctx);
	    textHelper.renderText(this, ctx, text, style);
	    this.restoreTransform(ctx);
	  },
	  getBoundingRect: function () {
	    var style = this.style; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true);
	
	    if (!this._rect) {
	      var text = style.text;
	      text != null ? text += '' : text = '';
	      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);
	      rect.x += style.x || 0;
	      rect.y += style.y || 0;
	
	      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {
	        var w = style.textStrokeWidth;
	        rect.x -= w / 2;
	        rect.y -= w / 2;
	        rect.width += w;
	        rect.height += w;
	      }
	
	      this._rect = rect;
	    }
	
	    return this._rect;
	  }
	};
	zrUtil.inherits(Text, Displayable);
	var _default = Text;
	module.exports = _default;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	/**
	 * 圆形
	 * @module zrender/shape/Circle
	 */
	var _default = Path.extend({
	  type: 'circle',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r: 0
	  },
	  buildPath: function (ctx, shape, inBundle) {
	    // Better stroking in ShapeBundle
	    // Always do it may have performence issue ( fill may be 2x more cost)
	    if (inBundle) {
	      ctx.moveTo(shape.cx + shape.r, shape.cy);
	    } // else {
	    //     if (ctx.allocate && !ctx.data.length) {
	    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);
	    //     }
	    // }
	    // Better stroking in ShapeBundle
	    // ctx.moveTo(shape.cx + shape.r, shape.cy);
	
	
	    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	var fixClipWithShadow = __webpack_require__(49);
	
	/**
	 * 扇形
	 * @module zrender/graphic/shape/Sector
	 */
	var _default = Path.extend({
	  type: 'sector',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r0: 0,
	    r: 0,
	    startAngle: 0,
	    endAngle: Math.PI * 2,
	    clockwise: true
	  },
	  brush: fixClipWithShadow(Path.prototype.brush),
	  buildPath: function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var r0 = Math.max(shape.r0 || 0, 0);
	    var r = Math.max(shape.r, 0);
	    var startAngle = shape.startAngle;
	    var endAngle = shape.endAngle;
	    var clockwise = shape.clockwise;
	    var unitX = Math.cos(startAngle);
	    var unitY = Math.sin(startAngle);
	    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
	    ctx.lineTo(unitX * r + x, unitY * r + y);
	    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);
	
	    if (r0 !== 0) {
	      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	    }
	
	    ctx.closePath();
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	var env = __webpack_require__(50);
	
	// Fix weird bug in some version of IE11 (like 11.0.9600.178**),
	// where exception "unexpected call to method or property access"
	// might be thrown when calling ctx.fill or ctx.stroke after a path
	// whose area size is zero is drawn and ctx.clip() is called and
	// shadowBlur is set. See #4572, #3112, #5777.
	// (e.g.,
	//  ctx.moveTo(10, 10);
	//  ctx.lineTo(20, 10);
	//  ctx.closePath();
	//  ctx.clip();
	//  ctx.shadowBlur = 10;
	//  ...
	//  ctx.fill();
	// )
	var shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];
	
	function _default(orignalBrush) {
	  // version string can be: '11.0'
	  return env.browser.ie && env.browser.version >= 11 ? function () {
	    var clipPaths = this.__clipPaths;
	    var style = this.style;
	    var modified;
	
	    if (clipPaths) {
	      for (var i = 0; i < clipPaths.length; i++) {
	        var clipPath = clipPaths[i];
	        var shape = clipPath && clipPath.shape;
	        var type = clipPath && clipPath.type;
	
	        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {
	          for (var j = 0; j < shadowTemp.length; j++) {
	            // It is save to put shadowTemp static, because shadowTemp
	            // will be all modified each item brush called.
	            shadowTemp[j][2] = style[shadowTemp[j][0]];
	            style[shadowTemp[j][0]] = shadowTemp[j][1];
	          }
	
	          modified = true;
	          break;
	        }
	      }
	    }
	
	    orignalBrush.apply(this, arguments);
	
	    if (modified) {
	      for (var j = 0; j < shadowTemp.length; j++) {
	        style[shadowTemp[j][0]] = shadowTemp[j][2];
	      }
	    }
	  } : orignalBrush;
	}
	
	module.exports = _default;

/***/ }),
/* 50 */
/***/ (function(module, exports) {

	/**
	 * echarts设备环境识别
	 *
	 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
	 * @author firede[firede@firede.us]
	 * @desc thanks zepto.
	 */
	var env = {};
	
	if (typeof navigator === 'undefined') {
	  // In node
	  env = {
	    browser: {},
	    os: {},
	    node: true,
	    // Assume canvas is supported
	    canvasSupported: true,
	    svgSupported: true
	  };
	} else {
	  env = detect(navigator.userAgent);
	}
	
	var _default = env; // Zepto.js
	// (c) 2010-2013 Thomas Fuchs
	// Zepto.js may be freely distributed under the MIT license.
	
	function detect(ua) {
	  var os = {};
	  var browser = {}; // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
	  // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
	  // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	  // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	  // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
	  // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
	  // var touchpad = webos && ua.match(/TouchPad/);
	  // var kindle = ua.match(/Kindle\/([\d.]+)/);
	  // var silk = ua.match(/Silk\/([\d._]+)/);
	  // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
	  // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
	  // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
	  // var playbook = ua.match(/PlayBook/);
	  // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
	
	  var firefox = ua.match(/Firefox\/([\d.]+)/); // var safari = webkit && ua.match(/Mobile\//) && !chrome;
	  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
	
	  var ie = ua.match(/MSIE\s([\d.]+)/) // IE 11 Trident/7.0; rv:11.0
	  || ua.match(/Trident\/.+?rv:(([\d.]+))/);
	  var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+
	
	  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:
	  // - discern (more) between multiple browsers on android
	  // - decide if kindle fire in silk mode is android or not
	  // - Firefox on Android doesn't specify the Android version
	  // - possibly devide in os, device and browser hashes
	  // if (browser.webkit = !!webkit) browser.version = webkit[1];
	  // if (android) os.android = true, os.version = android[2];
	  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
	  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
	  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	  // if (webos) os.webos = true, os.version = webos[2];
	  // if (touchpad) os.touchpad = true;
	  // if (blackberry) os.blackberry = true, os.version = blackberry[2];
	  // if (bb10) os.bb10 = true, os.version = bb10[2];
	  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
	  // if (playbook) browser.playbook = true;
	  // if (kindle) os.kindle = true, os.version = kindle[1];
	  // if (silk) browser.silk = true, browser.version = silk[1];
	  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
	  // if (chrome) browser.chrome = true, browser.version = chrome[1];
	
	  if (firefox) {
	    browser.firefox = true;
	    browser.version = firefox[1];
	  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
	  // if (webview) browser.webview = true;
	
	
	  if (ie) {
	    browser.ie = true;
	    browser.version = ie[1];
	  }
	
	  if (edge) {
	    browser.edge = true;
	    browser.version = edge[1];
	  } // It is difficult to detect WeChat in Win Phone precisely, because ua can
	  // not be set on win phone. So we do not consider Win Phone.
	
	
	  if (weChat) {
	    browser.weChat = true;
	  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
	  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
	  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
	  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
	  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));
	
	
	  return {
	    browser: browser,
	    os: os,
	    node: false,
	    // 原生canvas支持，改极端点了
	    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
	    canvasSupported: !!document.createElement('canvas').getContext,
	    svgSupported: typeof SVGRect !== 'undefined',
	    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
	    // works on most browsers
	    // IE10/11 does not support touch event, and MS Edge supports them but not by
	    // default, so we dont check navigator.maxTouchPoints for them here.
	    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
	    // <http://caniuse.com/#search=pointer%20event>.
	    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer
	    // events currently. So we dont use that on other browsers unless tested sufficiently.
	    // Although IE 10 supports pointer event, it use old style and is different from the
	    // standard. So we exclude that. (IE 10 is hardly used on touch device)
	    && (browser.edge || browser.ie && browser.version >= 11)
	  };
	}
	
	module.exports = _default;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	/**
	 * 圆环
	 * @module zrender/graphic/shape/Ring
	 */
	var _default = Path.extend({
	  type: 'ring',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r: 0,
	    r0: 0
	  },
	  buildPath: function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var PI2 = Math.PI * 2;
	    ctx.moveTo(x + shape.r, y);
	    ctx.arc(x, y, shape.r, 0, PI2, false);
	    ctx.moveTo(x + shape.r0, y);
	    ctx.arc(x, y, shape.r0, 0, PI2, true);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	var polyHelper = __webpack_require__(53);
	
	/**
	 * 多边形
	 * @module zrender/shape/Polygon
	 */
	var _default = Path.extend({
	  type: 'polygon',
	  shape: {
	    points: null,
	    smooth: false,
	    smoothConstraint: null
	  },
	  buildPath: function (ctx, shape) {
	    polyHelper.buildPath(ctx, shape, true);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	var smoothSpline = __webpack_require__(54);
	
	var smoothBezier = __webpack_require__(55);
	
	function buildPath(ctx, shape, closePath) {
	  var points = shape.points;
	  var smooth = shape.smooth;
	
	  if (points && points.length >= 2) {
	    if (smooth && smooth !== 'spline') {
	      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
	      ctx.moveTo(points[0][0], points[0][1]);
	      var len = points.length;
	
	      for (var i = 0; i < (closePath ? len : len - 1); i++) {
	        var cp1 = controlPoints[i * 2];
	        var cp2 = controlPoints[i * 2 + 1];
	        var p = points[(i + 1) % len];
	        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
	      }
	    } else {
	      if (smooth === 'spline') {
	        points = smoothSpline(points, closePath);
	      }
	
	      ctx.moveTo(points[0][0], points[0][1]);
	
	      for (var i = 1, l = points.length; i < l; i++) {
	        ctx.lineTo(points[i][0], points[i][1]);
	      }
	    }
	
	    closePath && ctx.closePath();
	  }
	}
	
	exports.buildPath = buildPath;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	var _vector = __webpack_require__(15);
	
	var v2Distance = _vector.distance;
	
	/**
	 * Catmull-Rom spline 插值折线
	 * @module zrender/shape/util/smoothSpline
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	/**
	 * @inner
	 */
	function interpolate(p0, p1, p2, p3, t, t2, t3) {
	  var v0 = (p2 - p0) * 0.5;
	  var v1 = (p3 - p1) * 0.5;
	  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
	}
	/**
	 * @alias module:zrender/shape/util/smoothSpline
	 * @param {Array} points 线段顶点数组
	 * @param {boolean} isLoop
	 * @return {Array}
	 */
	
	
	function _default(points, isLoop) {
	  var len = points.length;
	  var ret = [];
	  var distance = 0;
	
	  for (var i = 1; i < len; i++) {
	    distance += v2Distance(points[i - 1], points[i]);
	  }
	
	  var segs = distance / 2;
	  segs = segs < len ? len : segs;
	
	  for (var i = 0; i < segs; i++) {
	    var pos = i / (segs - 1) * (isLoop ? len : len - 1);
	    var idx = Math.floor(pos);
	    var w = pos - idx;
	    var p0;
	    var p1 = points[idx % len];
	    var p2;
	    var p3;
	
	    if (!isLoop) {
	      p0 = points[idx === 0 ? idx : idx - 1];
	      p2 = points[idx > len - 2 ? len - 1 : idx + 1];
	      p3 = points[idx > len - 3 ? len - 1 : idx + 2];
	    } else {
	      p0 = points[(idx - 1 + len) % len];
	      p2 = points[(idx + 1) % len];
	      p3 = points[(idx + 2) % len];
	    }
	
	    var w2 = w * w;
	    var w3 = w * w2;
	    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
	  }
	
	  return ret;
	}
	
	module.exports = _default;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	var _vector = __webpack_require__(15);
	
	var v2Min = _vector.min;
	var v2Max = _vector.max;
	var v2Scale = _vector.scale;
	var v2Distance = _vector.distance;
	var v2Add = _vector.add;
	var v2Clone = _vector.clone;
	var v2Sub = _vector.sub;
	
	/**
	 * 贝塞尔平滑曲线
	 * @module zrender/shape/util/smoothBezier
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	/**
	 * 贝塞尔平滑曲线
	 * @alias module:zrender/shape/util/smoothBezier
	 * @param {Array} points 线段顶点数组
	 * @param {number} smooth 平滑等级, 0-1
	 * @param {boolean} isLoop
	 * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
	 *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
	 *                           整个折线的包围盒做一个并集用来约束控制点。
	 * @param {Array} 计算出来的控制点数组
	 */
	function _default(points, smooth, isLoop, constraint) {
	  var cps = [];
	  var v = [];
	  var v1 = [];
	  var v2 = [];
	  var prevPoint;
	  var nextPoint;
	  var min, max;
	
	  if (constraint) {
	    min = [Infinity, Infinity];
	    max = [-Infinity, -Infinity];
	
	    for (var i = 0, len = points.length; i < len; i++) {
	      v2Min(min, min, points[i]);
	      v2Max(max, max, points[i]);
	    } // 与指定的包围盒做并集
	
	
	    v2Min(min, min, constraint[0]);
	    v2Max(max, max, constraint[1]);
	  }
	
	  for (var i = 0, len = points.length; i < len; i++) {
	    var point = points[i];
	
	    if (isLoop) {
	      prevPoint = points[i ? i - 1 : len - 1];
	      nextPoint = points[(i + 1) % len];
	    } else {
	      if (i === 0 || i === len - 1) {
	        cps.push(v2Clone(points[i]));
	        continue;
	      } else {
	        prevPoint = points[i - 1];
	        nextPoint = points[i + 1];
	      }
	    }
	
	    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length
	
	    v2Scale(v, v, smooth);
	    var d0 = v2Distance(point, prevPoint);
	    var d1 = v2Distance(point, nextPoint);
	    var sum = d0 + d1;
	
	    if (sum !== 0) {
	      d0 /= sum;
	      d1 /= sum;
	    }
	
	    v2Scale(v1, v, -d0);
	    v2Scale(v2, v, d1);
	    var cp0 = v2Add([], point, v1);
	    var cp1 = v2Add([], point, v2);
	
	    if (constraint) {
	      v2Max(cp0, cp0, min);
	      v2Min(cp0, cp0, max);
	      v2Max(cp1, cp1, min);
	      v2Min(cp1, cp1, max);
	    }
	
	    cps.push(cp0);
	    cps.push(cp1);
	  }
	
	  if (isLoop) {
	    cps.push(cps.shift());
	  }
	
	  return cps;
	}
	
	module.exports = _default;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	var polyHelper = __webpack_require__(53);
	
	/**
	 * @module zrender/graphic/shape/Polyline
	 */
	var _default = Path.extend({
	  type: 'polyline',
	  shape: {
	    points: null,
	    smooth: false,
	    smoothConstraint: null
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    polyHelper.buildPath(ctx, shape, false);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	var roundRectHelper = __webpack_require__(29);
	
	/**
	 * 矩形
	 * @module zrender/graphic/shape/Rect
	 */
	var _default = Path.extend({
	  type: 'rect',
	  shape: {
	    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
	    // r缩写为1         相当于 [1, 1, 1, 1]
	    // r缩写为[1]       相当于 [1, 1, 1, 1]
	    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
	    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
	    r: 0,
	    x: 0,
	    y: 0,
	    width: 0,
	    height: 0
	  },
	  buildPath: function (ctx, shape) {
	    var x = shape.x;
	    var y = shape.y;
	    var width = shape.width;
	    var height = shape.height;
	
	    if (!shape.r) {
	      ctx.rect(x, y, width, height);
	    } else {
	      roundRectHelper.buildPath(ctx, shape);
	    }
	
	    ctx.closePath();
	    return;
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	/**
	 * 直线
	 * @module zrender/graphic/shape/Line
	 */
	var _default = Path.extend({
	  type: 'line',
	  shape: {
	    // Start point
	    x1: 0,
	    y1: 0,
	    // End point
	    x2: 0,
	    y2: 0,
	    percent: 1
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    var x1 = shape.x1;
	    var y1 = shape.y1;
	    var x2 = shape.x2;
	    var y2 = shape.y2;
	    var percent = shape.percent;
	
	    if (percent === 0) {
	      return;
	    }
	
	    ctx.moveTo(x1, y1);
	
	    if (percent < 1) {
	      x2 = x1 * (1 - percent) + x2 * percent;
	      y2 = y1 * (1 - percent) + y2 * percent;
	    }
	
	    ctx.lineTo(x2, y2);
	  },
	
	  /**
	   * Get point at percent
	   * @param  {number} percent
	   * @return {Array.<number>}
	   */
	  pointAt: function (p) {
	    var shape = this.shape;
	    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	var vec2 = __webpack_require__(15);
	
	var _curve = __webpack_require__(31);
	
	var quadraticSubdivide = _curve.quadraticSubdivide;
	var cubicSubdivide = _curve.cubicSubdivide;
	var quadraticAt = _curve.quadraticAt;
	var cubicAt = _curve.cubicAt;
	var quadraticDerivativeAt = _curve.quadraticDerivativeAt;
	var cubicDerivativeAt = _curve.cubicDerivativeAt;
	
	/**
	 * 贝塞尔曲线
	 * @module zrender/shape/BezierCurve
	 */
	var out = [];
	
	function someVectorAt(shape, t, isTangent) {
	  var cpx2 = shape.cpx2;
	  var cpy2 = shape.cpy2;
	
	  if (cpx2 === null || cpy2 === null) {
	    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
	  } else {
	    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];
	  }
	}
	
	var _default = Path.extend({
	  type: 'bezier-curve',
	  shape: {
	    x1: 0,
	    y1: 0,
	    x2: 0,
	    y2: 0,
	    cpx1: 0,
	    cpy1: 0,
	    // cpx2: 0,
	    // cpy2: 0
	    // Curve show percent, for animating
	    percent: 1
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    var x1 = shape.x1;
	    var y1 = shape.y1;
	    var x2 = shape.x2;
	    var y2 = shape.y2;
	    var cpx1 = shape.cpx1;
	    var cpy1 = shape.cpy1;
	    var cpx2 = shape.cpx2;
	    var cpy2 = shape.cpy2;
	    var percent = shape.percent;
	
	    if (percent === 0) {
	      return;
	    }
	
	    ctx.moveTo(x1, y1);
	
	    if (cpx2 == null || cpy2 == null) {
	      if (percent < 1) {
	        quadraticSubdivide(x1, cpx1, x2, percent, out);
	        cpx1 = out[1];
	        x2 = out[2];
	        quadraticSubdivide(y1, cpy1, y2, percent, out);
	        cpy1 = out[1];
	        y2 = out[2];
	      }
	
	      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
	    } else {
	      if (percent < 1) {
	        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
	        cpx1 = out[1];
	        cpx2 = out[2];
	        x2 = out[3];
	        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
	        cpy1 = out[1];
	        cpy2 = out[2];
	        y2 = out[3];
	      }
	
	      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
	    }
	  },
	
	  /**
	   * Get point at percent
	   * @param  {number} t
	   * @return {Array.<number>}
	   */
	  pointAt: function (t) {
	    return someVectorAt(this.shape, t, false);
	  },
	
	  /**
	   * Get tangent at percent
	   * @param  {number} t
	   * @return {Array.<number>}
	   */
	  tangentAt: function (t) {
	    var p = someVectorAt(this.shape, t, true);
	    return vec2.normalize(p, p);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(7);
	
	/**
	 * 圆弧
	 * @module zrender/graphic/shape/Arc
	 */
	var _default = Path.extend({
	  type: 'arc',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r: 0,
	    startAngle: 0,
	    endAngle: Math.PI * 2,
	    clockwise: true
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var r = Math.max(shape.r, 0);
	    var startAngle = shape.startAngle;
	    var endAngle = shape.endAngle;
	    var clockwise = shape.clockwise;
	    var unitX = Math.cos(startAngle);
	    var unitY = Math.sin(startAngle);
	    ctx.moveTo(unitX * r + x, unitY * r + y);
	    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(5);
	
	var Gradient = __webpack_require__(42);
	
	/**
	 * x, y, x2, y2 are all percent from 0 to 1
	 * @param {number} [x=0]
	 * @param {number} [y=0]
	 * @param {number} [x2=1]
	 * @param {number} [y2=0]
	 * @param {Array.<Object>} colorStops
	 * @param {boolean} [globalCoord=false]
	 */
	var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
	  // Should do nothing more in this constructor. Because gradient can be
	  // declard by `color: {type: 'linear', colorStops: ...}`, where
	  // this constructor will not be called.
	  this.x = x == null ? 0 : x;
	  this.y = y == null ? 0 : y;
	  this.x2 = x2 == null ? 1 : x2;
	  this.y2 = y2 == null ? 0 : y2; // Can be cloned
	
	  this.type = 'linear'; // If use global coord
	
	  this.global = globalCoord || false;
	  Gradient.call(this, colorStops);
	};
	
	LinearGradient.prototype = {
	  constructor: LinearGradient
	};
	zrUtil.inherits(LinearGradient, Gradient);
	var _default = LinearGradient;
	module.exports = _default;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(5);
	
	var Gradient = __webpack_require__(42);
	
	/**
	 * x, y, r are all percent from 0 to 1
	 * @param {number} [x=0.5]
	 * @param {number} [y=0.5]
	 * @param {number} [r=0.5]
	 * @param {Array.<Object>} [colorStops]
	 * @param {boolean} [globalCoord=false]
	 */
	var RadialGradient = function (x, y, r, colorStops, globalCoord) {
	  // Should do nothing more in this constructor. Because gradient can be
	  // declard by `color: {type: 'radial', colorStops: ...}`, where
	  // this constructor will not be called.
	  this.x = x == null ? 0.5 : x;
	  this.y = y == null ? 0.5 : y;
	  this.r = r == null ? 0.5 : r; // Can be cloned
	
	  this.type = 'radial'; // If use global coord
	
	  this.global = globalCoord || false;
	  Gradient.call(this, colorStops);
	};
	
	RadialGradient.prototype = {
	  constructor: RadialGradient
	};
	zrUtil.inherits(RadialGradient, Gradient);
	var _default = RadialGradient;
	module.exports = _default;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(5);
	
	var Style = __webpack_require__(9);
	
	var _vector = __webpack_require__(15);
	
	var vec2Copy = _vector.copy;
	
	/**
	 * States machine for managing graphic states
	 */
	
	/**
	 * @typedef {Object} IGraphicState
	 * @property {number} [zlevel]
	 * @property {number} [z]
	 * @property {Array.<number>} {position}
	 * @property {Array.<number>|number} {rotation}
	 * @property {Array.<number>} {scale}
	 * @property {Object} style
	 *
	 * @property {Function} onenter
	 * @property {Function} onleave
	 * @property {Function} ontransition
	 * @property {Array.<IGraphicStateTransition|string>} transition
	 *           Transition object or a string descriptor like '* 30 0 Linear'
	 */
	var transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];
	/**
	 * @module zrender/graphic/States~TransitionObject
	 */
	
	var TransitionObject = function (opts) {
	  if (typeof opts == 'string') {
	    this._fromStr(opts);
	  } else if (opts) {
	    opts.property && (this.property = opts.property);
	    opts.duration != null && (this.duration = opts.duration);
	    opts.easing && (this.easing = opts.easing);
	    opts.delay && (this.delay = opts.delay);
	  }
	
	  if (this.property !== '*') {
	    this.property = this.property.split(',');
	  } else {
	    this.property = transitionProperties;
	  }
	};
	
	TransitionObject.prototype = {
	  constructor: TransitionObject,
	
	  /**
	   * List of all transition properties. Splitted by comma. Must not have spaces in the string.
	   * e.g. 'position,style.color'. '*' will match all the valid properties.
	   * @type {string}
	   * @default *
	   */
	  property: '*',
	
	  /**
	   * @type {string}
	   * @default 'Linear'
	   */
	  easing: 'Linear',
	
	  /**
	   * @type {number}
	   * @default 'number'
	   */
	  duration: 500,
	
	  /**
	   * @type {number}
	   */
	  delay: 0,
	  _fromStr: function (str) {
	    var arr = str.split(/\s+/g);
	    this.property = arr[0];
	    this.duration = +arr[1];
	    this.delay = +arr[2];
	    this.easing = arr[3];
	  }
	};
	/**
	 * @alias module:zrender/graphic/States
	 */
	
	var GraphicStates = function (opts) {
	  opts = opts || {};
	  this._states = {};
	  /**
	   * Target element
	   * @type {zrender/graphic/Displayable|zrender/container/Group}
	   */
	
	  this._el = opts.el;
	  this._subStates = [];
	  this._transitionAnimators = [];
	
	  if (opts.initialState) {
	    this._initialState = opts.initialState;
	  }
	
	  var optsStates = opts.states;
	
	  if (optsStates) {
	    for (var name in optsStates) {
	      if (optsStates.hasOwnProperty(name)) {
	        var state = optsStates[name];
	
	        this._addState(name, state);
	      }
	    }
	  }
	
	  this.setState(this._initialState);
	};
	
	GraphicStates.prototype = {
	  constructor: GraphicStates,
	
	  /**
	   * All other state will be extended from initial state
	   * @type {string}
	   * @private
	   */
	  _initialState: 'normal',
	
	  /**
	   * Current state
	   * @type {string}
	   * @private
	   */
	  _currentState: '',
	  el: function () {
	    return this._el;
	  },
	  _addState: function (name, state) {
	    this._states[name] = state;
	
	    if (state.transition) {
	      state.transition = new TransitionObject(state.transition);
	    } // Extend from initial state
	
	
	    if (name !== this._initialState) {
	      this._extendFromInitial(state);
	    } else {
	      var el = this._el; // setState 的时候自带的 style 和 shape 都会被直接覆盖
	      // 所以这边先把自带的 style 和 shape 扩展到初始状态中
	
	      zrUtil.merge(state.style, el.style, false, false);
	
	      if (state.shape) {
	        zrUtil.merge(state.shape, el.shape, false, true);
	      } else {
	        state.shape = zrUtil.clone(el.shape, true);
	      }
	
	      for (var name in this._states) {
	        if (this._states.hasOwnProperty(name)) {
	          this._extendFromInitial(this._states[name]);
	        }
	      }
	    }
	  },
	  _extendFromInitial: function (state) {
	    var initialState = this._states[this._initialState];
	
	    if (initialState && state !== initialState) {
	      zrUtil.merge(state, initialState, false, true);
	    }
	  },
	  setState: function (name, silent) {
	    if (name === this._currentState && !this.transiting()) {
	      return;
	    }
	
	    var state = this._states[name];
	
	    if (state) {
	      this._stopTransition();
	
	      if (!silent) {
	        var prevState = this._states[this._currentState];
	
	        if (prevState) {
	          prevState.onleave && prevState.onleave.call(this);
	        }
	
	        state.onenter && state.onenter.call(this);
	      }
	
	      this._currentState = name;
	
	      if (this._el) {
	        var el = this._el; // Setting attributes
	
	        if (state.zlevel != null) {
	          el.zlevel = state.zlevel;
	        }
	
	        if (state.z != null) {
	          el.z = state.z;
	        } // SRT
	
	
	        state.position && vec2Copy(el.position, state.position);
	        state.scale && vec2Copy(el.scale, state.scale);
	
	        if (state.rotation != null) {
	          el.rotation = state.rotation;
	        } // Style
	
	
	        if (state.style) {
	          var initialState = this._states[this._initialState];
	          el.style = new Style();
	
	          if (initialState) {
	            el.style.extendFrom(initialState.style, false);
	          }
	
	          if ( // Not initial state
	          name != this._initialState // Not copied from initial state in _extendFromInitial method
	          && initialState.style !== state.style) {
	            el.style.extendFrom(state.style, true);
	          }
	        }
	
	        if (state.shape) {
	          el.shape = zrUtil.clone(state.shape, true);
	        }
	
	        el.dirty();
	      }
	    }
	
	    for (var i = 0; i < this._subStates.length; i++) {
	      this._subStates.setState(name);
	    }
	  },
	  getState: function () {
	    return this._currentState;
	  },
	  transitionState: function (target, done) {
	    if (target === this._currentState && !this.transiting()) {
	      return;
	    }
	
	    var state = this._states[target];
	    var styleShapeReg = /$[style|shape]\./;
	    var self = this; // Animation 去重
	
	    var propPathMap = {};
	
	    if (state) {
	      self._stopTransition();
	
	      var el = self._el;
	
	      if (state.transition && el && el.__zr) {
	        // El can be animated
	        var transitionCfg = state.transition;
	        var property = transitionCfg.property;
	        var animatingCount = 0;
	
	        var animationDone = function () {
	          animatingCount--;
	
	          if (animatingCount === 0) {
	            self.setState(target);
	            done && done();
	          }
	        };
	
	        for (var i = 0; i < property.length; i++) {
	          var propName = property[i]; // Animating all the properties in style or shape
	
	          if (propName === 'style' || propName === 'shape') {
	            if (state[propName]) {
	              for (var key in state[propName]) {
	                if (!state[propName].hasOwnProperty(key)) {
	                  continue;
	                }
	
	                var path = propName + '.' + key;
	
	                if (propPathMap[path]) {
	                  continue;
	                }
	
	                propPathMap[path] = 1;
	                animatingCount += self._animProp(state, propName, key, transitionCfg, animationDone);
	              }
	            }
	          } else {
	            if (propPathMap[propName]) {
	              continue;
	            }
	
	            propPathMap[propName] = 1; // Animating particular property in style or style
	
	            if (propName.match(styleShapeReg)) {
	              // remove 'style.', 'shape.' prefix
	              var subProp = propName.slice(0, 5);
	              propName = propName.slice(6);
	              animatingCount += self._animProp(state, subProp, propName, transitionCfg, animationDone);
	            } else {
	              animatingCount += self._animProp(state, '', propName, transitionCfg, animationDone);
	            }
	          }
	        } // No transition properties
	
	
	        if (animatingCount === 0) {
	          self.setState(target);
	          done && done();
	        }
	      } else {
	        self.setState(target);
	        done && done();
	      }
	    }
	
	    var subStates = self._subStates;
	
	    for (var i = 0; i < subStates.length; i++) {
	      subStates.transitionState(target);
	    }
	  },
	
	  /**
	   * Do transition animation of particular property
	   * @param {Object} state
	   * @param {string} subPropKey
	   * @param {string} key
	   * @param {Object} transitionCfg
	   * @param {Function} done
	   * @private
	   */
	  _animProp: function (state, subPropKey, key, transitionCfg, done) {
	    var el = this._el;
	    var stateObj = subPropKey ? state[subPropKey] : state;
	    var elObj = subPropKey ? el[subPropKey] : el;
	    var availableProp = stateObj && key in stateObj && elObj && key in elObj;
	    var transitionAnimators = this._transitionAnimators;
	
	    if (availableProp) {
	      var obj = {};
	
	      if (stateObj[key] === elObj[key]) {
	        return 0;
	      }
	
	      obj[key] = stateObj[key];
	      var animator = el.animate(subPropKey).when(transitionCfg.duration, obj).delay(transitionCfg.dealy).done(function () {
	        var idx = zrUtil.indexOf(transitionAnimators, 1);
	
	        if (idx > 0) {
	          transitionAnimators.splice(idx, 1);
	        }
	
	        done();
	      }).start(transitionCfg.easing);
	      transitionAnimators.push(animator);
	      return 1;
	    }
	
	    return 0;
	  },
	  _stopTransition: function () {
	    var transitionAnimators = this._transitionAnimators;
	
	    for (var i = 0; i < transitionAnimators.length; i++) {
	      transitionAnimators[i].stop();
	    }
	
	    transitionAnimators.length = 0;
	  },
	  transiting: function () {
	    return this._transitionAnimators.length > 0;
	  },
	  addSubStates: function (states) {
	    this._subStates.push(states);
	  },
	  removeSubStates: function (states) {
	    var idx = zrUtil.indexOf(this._subStates, states);
	
	    if (idx >= 0) {
	      this._subStates.splice(states, 1);
	    }
	  }
	};
	var _default = GraphicStates;
	module.exports = _default;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var zrUtil = __webpack_require__(5);
	    var BoundingRect = __webpack_require__(27);
	    function Minimap(bigCanvas,groupPosition, group,eagleEyeNode,distance,imgSrc) {
	
	        this.bigCanvas = bigCanvas;
	        this.eagleEyeNode = eagleEyeNode;
	        this.distance = distance;
	        this.imgSrc = imgSrc;
	        this.ratio;
	        this.groupRatio;
	        this.group = group;
	        this.img = document.createElement("img");
	        this.selection = document.createElement('div');
	        this.groupPosition = zrUtil.clone(groupPosition);
	        this.selectPosition = [0,0];
	        this.render();
	    }
	
	    Minimap.prototype.render = function() {
	        var that = this;
	        that.ratio = 0.12;
	        var eagleEyeNodeWidth = that.group.width  * that.ratio;
	        var eagleEyeNodeHeight = that.group.height  * that.ratio;
	        that.eagleEyeNode.style.width = eagleEyeNodeWidth+"px";
	        that.eagleEyeNode.style.height = eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+"px";
	        that.eagleEyeNode.style.position="relative";
	        that.eagleEyeNode.style.background = "url("+that.imgSrc+") no-repeat";
	        that.eagleEyeNode.style.backgroundSize = eagleEyeNodeWidth/(that.group.width*that.distance[2]/that.bigCanvas.getWidth())+"px";
	        that.backgroundSize = zrUtil.clone(that.eagleEyeNode.style.backgroundSize);
	        that.eagleEyeNode.innerHTML = "";
	        that.selection.style.border = "1px solid #ff0000";
	        that.selection.style.cursor = "pointer";
	        that.selection.style.width = that.bigCanvas.getWidth()/that.group.width*eagleEyeNodeWidth+"px";
	        that.selection.style.height = that.bigCanvas.getHeight()/that.group.height*eagleEyeNodeHeight+"px";
	        that.selectWidth = that.selection.style.width;
	        that.selectHeight = that.selection.style.height;
	        that.selection.style.position="absolute";
	        that.selection.style.top = 0+"px";
	        that.selection.style.left = 0+"px";
	        that.eagleEyeNode.appendChild(this.selection);
	    };
	    Minimap.prototype.updataSelection = function(offectLeft,offectTop,zoomScale,nowZoom){
	        var that = this;
	        that.zoomScale = zoomScale;
	        this.selection.style.width = this.selection.style.width.replace("px","")/zoomScale+"px";
	        this.selection.style.height = this.selection.style.height.replace("px","")/zoomScale+"px";
	        that.selectPosition[0] = zrUtil.clone(offectLeft)*that.ratio/nowZoom;
	        that.selectPosition[1] = zrUtil.clone(offectTop)*that.ratio/nowZoom;
	        this.selection.style.left = -that.selectPosition[0]+"px";
	        this.selection.style.top = -that.selectPosition[1]+"px";
	    };
	    Minimap.prototype.updataMap = function(imgSrc,newGroup){
	        var that = this;
	        that.eagleEyeNode.style.backgroundImage = "url("+imgSrc+")";
	        var eagleEyeNodeWidth = newGroup.width  * that.ratio;
	        var eagleEyeNodeHeight = newGroup.height  * that.ratio;
	        that.eagleEyeNode.style.width = eagleEyeNodeWidth+"px";
	        that.eagleEyeNode.style.height = eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+"px";
	    };
	    Minimap.prototype.updataSelectionPosition = function(nowGroupPosition,nowZoom){
	        var that = this;
	        that.selectPosition[0] = zrUtil.clone(nowGroupPosition[0])*that.ratio/nowZoom;
	        that.selectPosition[1] = zrUtil.clone(nowGroupPosition[1])*that.ratio/nowZoom;
	        this.selection.style.left = -that.selectPosition[0]+"px";
	        this.selection.style.top = -that.selectPosition[1]+"px";
	    };
	    Minimap.prototype.updataGroupPosition = function(group,nowZoom){
	        var that = this;
	        var positionX = -Number(that.selection.style.left.substring(0,that.selection.style.left.length-2))/that.ratio*nowZoom;
	        var positionY = -Number(that.selection.style.top.substring(0,that.selection.style.top.length-2))/that.ratio*nowZoom;
	        group.attr("position",[positionX,positionY]);
	    };
	
	    module.exports = Minimap;
	


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 工具方法类
	 * @author wang.xiaohu
	 */
	
	    var Point = __webpack_require__(66);
	    var Line = __webpack_require__(67);
	    var BoundingRect = __webpack_require__(27);
	    var zrUtil = __webpack_require__(5);
	    /**
	     * 构造类继承关系
	     *
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    function getUUID() {
	        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),
	            uuid = new Array(36),
	            rnd = 0,
	            r;
	        for (var i = 0; i < 36; i++) {
	            if (i == 8 || i == 13 || i == 18 || i == 23) {
	                uuid[i] = '-';
	            } else if (i == 14) {
	                uuid[i] = '4';
	            } else {
	                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
	                r = rnd & 0xf;
	                rnd = rnd >> 4;
	                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
	            }
	        }
	        return "sid-" + uuid.join('');
	    }
	
	
	    /**
	     * 计算两点之间的距离
	     *@param {Point} p1 - first {Point}
	     *@param {Point} p2 - second {Point}
	     *@return {Number} - the distance between those 2 points. It is always positive.
	     **/
	    function distance(p1, p2) {
	        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
	    }
	
	    /**
	     * 返回一条折线 最长的两个点
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    function getMaxLineLength(points) {
	        var m = distance(points[0], points[1]);
	        var result = [points[0], points[1]];
	        for (var i = 1; i < points.length - 1; i++) {
	
	            if (m < distance(points[i], points[i + 1])) {
	                m = distance(points[i], points[i + 1])
	                result = [points[i], points[i + 1]];
	            }
	        }
	
	        return result;
	    }
	
	    /**Returns the length of a Polyline that would be created with a set of points
	     *@param {Array} v - an {Array} of {Points}
	     *@return {Number} - a positive number equal with total length*/
	    function getPolylineLength(v) {
	        var l = 0;
	        for (var i = 0; i < v.length - 1; i++) {
	            l += distance(v[i], v[i + 1]);
	        }
	
	        return l;
	    }
	
	
	    /**Returns the max of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the maximum number from the vector or NaN if vector is empty
	     **/
	    function max(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m < v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	
	    /**Returns the min of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the minimum number from the vector or NaN if vector is empty
	     *@author alex@scriptoid.com
	     **/
	    function min(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m > v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	    /**
	     * 判断 点数组 是否正交直线路径
	     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function orthogonalPath(v) {
	        if (v.length <= 1) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 1; i++) {
	            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	
	
	    /**
	     *Test to see if 2 {Line}s intersects. They are considered finite segments
	     *and not the infinite lines from geometry
	     *@param {Line} l1 - fist line/segment
	     *@param {Line} l2 - last line/segment
	     *@return {Boolean} true - if the lines intersect or false if not
	     **/
	    function lineIntersectsLine(l1, l2) {
	        // check for two vertical lines
	        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {
	            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,
	                // then check segment bounds for overlapping
	                l1.contains(l2.startPoint.x, l2.startPoint.y) ||
	                l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                // lines are paralel
	                false;
	        }
	        // if one line is vertical, and another line is not vertical
	        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {
	            // let assume l2 is vertical, otherwise exchange them
	            if (l1.startPoint.x == l1.endPoint.x) {
	                var l = l1;
	                l1 = l2;
	                l2 = l;
	            }
	            // finding intersection of 'infinite' lines
	            // equation of the first line is y = ax + b, second: x = c
	            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b = l1.startPoint.y - a * l1.startPoint.x;
	            var x0 = l2.startPoint.x;
	            var y0 = a * x0 + b;
	            return l1.contains(x0, y0) && l2.contains(x0, y0);
	        }
	
	        // check normal case - both lines are not vertical
	        else {
	            //line equation is : y = a*x + b, b = y - a * x
	            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;
	
	            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);
	            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;
	
	            if (a1 == a2) { //paralel lines
	                return b1 == b2 ?
	                    // for coincide lines, check for segment bounds overlapping
	                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                    // not coincide paralel lines have no chance to intersect
	                    false;
	            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment
	
	                /*
	                 * if one of the lines are vertical, then x0 is equal to their x,
	                 * otherwise:
	                 * y1 = a1 * x + b1
	                 * y2 = a2 * x + b2
	                 * => x0 = (b2 - b1) / (a1 - a2)
	                 * => y0 = a1 * x0 + b1
	                 **/
	                x0 = (b2 - b1) / (a1 - a2);
	                y0 = a1 * x0 + b1;
	                return l1.contains(x0, y0) && l2.contains(x0, y0);
	            }
	        }
	    }
	
	    /**
	     *
	     *Tests if a a polyline defined by a set of points intersects a rectangle
	     *@param {Array} points - and {Array} of {Point}s
	     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)
	     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false
	     *
	     *@return true - if line intersects the rectangle, false - if not
	     **/
	    function polylineIntersectsRectangle(points, bounds, closedPolyline) {
	
	
	        //get the 4 lines/segments represented by the bounds
	        var lines = [];
	        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));
	        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));
	        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));
	        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));
	
	        for (var k = 0; k < points.length - 1; k++) {
	            //create a line out of each 2 consecutive points
	            var tempLine = new Line(points[k], points[k + 1]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var i = 0; i < lines.length; i++) {
	                if (lineIntersectsLine(tempLine, lines[i])) {
	                    return true;
	                }
	            }
	        }
	
	        //check the closed figure - that is last point connected to the first
	        if (closedPolyline) {
	            //create a line out of each 2 consecutive points
	            var tempLine1 = new Line(points[points.length - 1], points[0]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var j = 0; j < lines.length; j++) {
	                if (lineIntersectsLine(tempLine1, lines[j])) {
	                    return true;
	                }
	            }
	        }
	
	        return false;
	    }
	
	    /**
	     * 计算路径的分数
	     * Score a ortogonal path made out of Points
	     *Iterates over a set of points (minimum 3)
	     *For each 3 points (i, i+1, i+2) :
	     *  - if the 3rd one is after the 2nd on the same line we add +1
	     *  - if the 3rd is up or down related to the 2nd we do not do anything +0
	     *  - if the 3rd goes back we imediatelly return -1
	     *@param {Array} v - an array of {Point}s
	     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine
	     *  The bigger the number the smooth the path is
	     **/
	    function scorePath(v) {
	        if (v.length <= 2) {
	            return -1;
	        }
	
	        var score = 0;
	        for (var i = 1; i < v.length - 1; i++) {
	            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else { //not on same vertical nor horizontal
	                score--;
	            }
	        }
	
	        return score;
	    }
	
	    /**
	     * 返回数字符号（+ -)
	     * Returns the sign of a number
	     *@param {Number} x - the number
	     *@returns {Number}
	     *@see <a href="http://en.wikipedia.org/wiki/Sign_function">http://en.wikipedia.org/wiki/Sign_function</a>
	     **/
	    function signum(x) {
	        if (x > 0)
	            return 1;
	        else if (x < 0)
	            return -1;
	        else
	            return 0;
	    }
	
	    /**
	     * 判断 点数组 是不是有效路径（没有回路）
	     *Tests if a vector of points is a valid path (not going back)
	     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function forwardPath(v) {
	        if (v.length <= 2) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 2; i++) {
	            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            }
	        }
	
	        return true;
	    }
	
	    /**
	     * 将[x:0,y:0]转化为[0, 0]  给zrender使用
	     * @param  {[type]} points [description]
	     * @param  {[type]} isRevert [description]
	     * @return {[type]}        [description]
	     */
	    function traslatePoints(points, isRevert) {
	        var newPoints = [];
	        if (isRevert) {
	            for (var i = 0; i < points.length; i++) {
	                var point = points[i];
	                newPoints.push(new Point(point[0], point[1]));
	            }
	            return newPoints;
	        } else {
	            for (var j = 0; j < points.length; j++) {
	                var point1 = points[j];
	                newPoints.push([point1.x, point1.y]);
	            }
	            return newPoints;
	        }
	
	
	    }
	
	    function rotationMatrix(angle) {
	        var mReturn = [
	            [Math.cos(angle), -Math.sin(angle), 0],
	            [Math.sin(angle), Math.cos(angle), 0],
	            [0, 0, 1]
	        ];
	        return mReturn;
	    }
	
	    function translationMatrix(dx, dy) {
	        return [
	            [1, 0, dx],
	            [0, 1, dy],
	            [0, 0, 1]
	        ];
	    }
	
	    function scaleMatrix(sx, sy) {
	        if (sy == null) {
	            sy = sx;
	        }
	        return [
	            [sx, 0, 0],
	            [0, sy, 0],
	            [0, 0, 1]
	        ];
	    }
	
	    /** It will return the end point of a line on a given angle (clockwise).
	     * @param {Point} startPoint - the start of the line
	     * @param {Number} length - the length of the line
	     * @param {Number} angle - the angle of the line in radians
	     * @return {Point} - the endPoint of the line
	     */
	    function getEndPoint(startPoint, length, angle) {
	        var endPoint = startPoint.clone();
	        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));
	        endPoint.y -= length;
	        endPoint.transform(rotationMatrix(angle));
	        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));
	        return endPoint;
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} rect [description]
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getConnectorPoints(rect, node) {
	        node = node || {};
	        var boundingRect = zrUtil.clone(rect.boundingRect || rect);
	        var rotation = node.rotation;
	        var points = {
	            left: new Point(boundingRect.x, boundingRect.y + boundingRect.height / 2), //矩形 左中的位置
	            top: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y), //矩形 上中的位置
	            right: new Point(boundingRect.x + boundingRect.width, boundingRect.y + boundingRect.height / 2), //矩形 右中的位置
	            bottom: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y + boundingRect.height), //矩形 下中的位置
	            center: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y + boundingRect.height / 2) //中间位置
	
	        };
	        if (Object.keys(node).length > 0 && Math.abs(rotation) > 0) {
	            var rectNew = rect.boundingRect ? rect : getRect(node);
	            var center = { x: rectNew.x, y: rectNew.y }; // 中心点
	            Object.keys(points).forEach(function(key) {
	                var value = points[key];
	                var x0 = center.x - value.x;
	                var y0 = center.y - value.y;
	                var sin = Math.sin(-rotation);
	                var cos = Math.cos(-rotation);
	                var position_n_x = center.x - (x0 * cos - y0 * sin);
	                var position_n_y = center.y - (x0 * sin + y0 * cos);
	                points[key].x = position_n_x;
	                points[key].y = position_n_y;
	            });
	        }
	        return points;
	    }
	
	    /**
	     * 获取节点外面四个控制点和旋转点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getConnectorControls(rect, node) {
	        node = node || {};
	        var boundingRect = zrUtil.clone(rect.boundingRect);
	        var rotation = node.rotation;
	        var controls = {
	            tl: new Point(boundingRect.x, boundingRect.y), //矩形 左上角位置
	            tc: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y - 4), //矩形 上中位置
	            tr: new Point(boundingRect.x + boundingRect.width, boundingRect.y), //矩形 右上角位置
	            bl: new Point(boundingRect.x, boundingRect.y + boundingRect.height), //矩形 左下角
	            br: new Point(boundingRect.x + boundingRect.width, boundingRect.y + boundingRect.height), //矩形 右下角位置
	            mtr: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y - 20) // 旋转点位置
	        };
	        if (Object.keys(node).length > 0 && Math.abs(rotation) > 0) {
	            var rectNew = rect;
	            var center = { x: rectNew.x, y: rectNew.y }; // 中心点
	            Object.keys(controls).forEach(function(key) {
	                var value = controls[key];
	                var x0 = center.x - value.x;
	                var y0 = center.y - value.y;
	                var sin = Math.sin(-rotation);
	                var cos = Math.cos(-rotation);
	                var position_n_x = center.x - (x0 * cos - y0 * sin);
	                var position_n_y = center.y - (x0 * sin + y0 * cos);
	                controls[key].x = position_n_x;
	                controls[key].y = position_n_y;
	            });
	        }
	        return controls;
	    }
	
	    /**
	     * 根据中心点和旋转弧度，计算旋转后的点坐标
	     * @param  {[object|array]} points [原坐标]
	     * @param  {[object]}       center [中心点]
	     * @param  {[number]}       rotation [旋转弧度]
	     * @return {[type]}      [description]
	     */
	    function calculatePoints(points, center, rotation) {
	        var x = Array.isArray(points) ? points[0] : points.x;
	        var y = Array.isArray(points) ? points[1] : points.y;
	        var x0 = center.x - x;
	        var y0 = center.y - y;
	        var sin = Math.sin(-rotation);
	        var cos = Math.cos(-rotation);
	        var position_n_x = center.x - (x0 * cos - y0 * sin);
	        var position_n_y = center.y - (x0 * sin + y0 * cos);
	        if (Array.isArray(points)) {
	            return [position_n_x, position_n_y];
	        }
	        return {
	            x: position_n_x,
	            y: position_n_y
	        }
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getSoltPoints(node) {
	        return [
	            //top
	            [Math.round(node.getRect().width / 3 /10)*10, 0 ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],
	            //right
	            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],
	            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],
	            //bottom
	            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],
	            //left
	            [0, Math.round(node.getRect().height / 3 /10)*10 ],
	            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]
	
	        ]
	    }
	
	    /**
	     * 计算 p1 p2两点所连接的直线的角度
	     * @param  {[type]} p1 [description]
	     * @param  {[type]} p2 [description]
	     * @return {[type]}    [description]
	     */
	    function tangentRotation(p1, p2) {
	        return -Math.PI / 2 - Math.atan2(
	            p2.y - p1.y, p2.x - p1.x
	        );
	    }
	
	    /**
	     * 判断3点是否在一条直线上
	     * Tests if 3 points are coliniar with matrix determinants.
	     * If the determinat of matrix
	     * /         \
	     * | x1 y1 1 |
	     * | x2 y2 1 |
	     * | x3 y3 1 |
	     * \         /
	     * is zero it means that the points are colinear
	     *@param {Point} p1 - first point
	     *@param {Point} p2 - second point
	     *@param {Point} p3 - third point
	     * @param {Number} precission
	     *@return {Boolean} - true if coliniar and false if not
	     *@author Alex
	     *@see http://en.wikipedia.org/wiki/Determinant
	     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html
	     **/
	    function collinearity(p1, p2, p3, precission) {
	        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);
	
	        if (precission) {
	            return Math.abs(determinant) <= precission;
	        } else {
	            return determinant === 0;
	        }
	    }
	
	
	    /**
	     * 四舍五入 保存decimals的小数
	     **/
	    function enhancedRound(number, decimals) {
	        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	    }
	
	    /**
	     * 获取两点之间的长度
	     **/
	    function getLength(startPoint, endPoint) {
	        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));
	    }
	
	    /**
	     * 获取角度
	     * @param  {[type]} centerPoint  [description]
	     * @param  {[type]} outsidePoint [description]
	     * @param  {[type]} round        [description]
	     * @return {[type]}              [description]
	     */
	    function getAngle(centerPoint, outsidePoint, round) {
	        centerPoint.x = enhancedRound(centerPoint.x, 5);
	        centerPoint.y = enhancedRound(centerPoint.y, 5);
	        outsidePoint.x = enhancedRound(outsidePoint.x, 5);
	        outsidePoint.y = enhancedRound(outsidePoint.y, 5);
	        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));
	        angle = -angle;
	
	        //endAngle+=90;
	        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {
	            angle += Math.PI * 2;
	        }
	        while (angle >= Math.PI * 2) {
	            angle -= Math.PI * 2;
	        }
	        if (isNaN(angle)) { //Nan
	            angle = 0; //we are at center point;
	        }
	        if (round) {
	            angle = Math.round(angle / round) * round
	        }
	        return angle;
	    }
	
	    /**
	     * 获取父节点的position[0]
	     * @param  {object} node  [节点]
	     * @param  {string} parentKey [判断是否有指定父节点的key,对于group是type；对于subprocess是nodeType]
	     * @param  {string} parentValue  [判断是否有指定父节点的value,对于group是GroupNode；对于subprocess是SubProcess]
	     * @return {number}              父节点的position[0]
	     */
	    function getParentX(node, parentKey, parentValue) {
	        if (!parentKey) {
	            parentKey = 'type';
	        }
	        if (!parentValue) {
	            parentValue = 'GroupNode';
	        }
	        if (node.parent && node.parent[parentKey] === parentValue) {
	            return node.position[0] + getParentX(node.parent)
	        } else {
	            return node.position[0]
	        }
	    }
	
	    /**
	     * 获取父节点的position[1]
	     * @param  {object} node  [节点]
	     * @param  {string} parentKey [判断是否有指定父节点的key,对于group是type；对于subprocess是nodeType]
	     * @param  {string} parentValue  [判断是否有指定父节点的value,对于group是GroupNode；对于subprocess是SubProcess]
	     * @return {number}              父节点的position[1]
	     */
	    function getParentY(node, parentKey, parentValue) {
	        if (!parentKey) {
	            parentKey = 'type';
	        }
	        if (!parentValue) {
	            parentValue = 'GroupNode';
	        }
	        if (node.parent && node.parent[parentKey] === parentValue) {
	            return node.position[1] + getParentY(node.parent)
	        } else {
	            return node.position[1]
	        }
	    }
	
	    function getRect(node, isCalcParent) {
	        var clipPath = node.clipPath;
	        var boundingRect = node.getBoundingRect();
	        // 节点裁剪后，以裁剪节点包围盒为准
	        if (clipPath) {
	            boundingRect = clipPath.getBoundingRect();
	        }
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];
	        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];
	        points[2] = [boundingRect.width / 2, boundingRect.height / 2];
	        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];
	        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];
	
	        var positionX = node.position[0];
	        var positionY = node.position[1];
	        //这里要循环判断一把 有没有父节点 并且父节点不是根节点 然后进行相加
	        if (node.parent && isCalcParent) {
	            if (node.parent.type === 'GroupNode' || node.parent.nodeType === 'SubProcess') {
	                positionX += getParentX(node.parent);
	                positionY += getParentY(node.parent);
	            }
	        }
	
	        var boundRect = new BoundingRect(
	                Number(positionX + boundingRect.x),   //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半
	                Number(positionY + boundingRect.y),
	                Number(boundingRect.width),
	                Number(boundingRect.height)
	            );
	        //中心点
	        var cx = Number(positionX) + Number(boundingRect.width) / 2 + Number(boundingRect.x);
	        var cy = Number(positionY) + Number(boundingRect.height) / 2 + Number(boundingRect.y);
	        return {
	            x: Number(cx),
	            y: Number(cy),
	            width: Number(boundingRect.width),
	            height: Number(boundingRect.height),
	            points: points,
	            boundingRect: boundRect
	        };
	    }
	
	    var StackedMap = {
	        createNew: function() {
	            var stack = [];
	
	            return {
	                add: function(key, value) {
	                    var arrKey = this.get(key);
	                    arrKey.push(value)
	
	                },
	                // 获取起始点有offset间隔的arrKey
	                getsimilar: function(key) {
	                    var value = [];
	                    var keyArr = key.split(',');
	                    stack.forEach(function(item) {
	                        var itemKeyArr = item.key.split(',');
	                        if (itemKeyArr[0].indexOf(keyArr[0]) > -1 && itemKeyArr[1].indexOf(keyArr[1]) > -1) {
	                            value = value.concat(item.value);
	                        }
	                    });
	                    if (value.length <= 0) {
	                        stack.push({ key: key, value: value });  
	                    }
	                    return value;
	                },
	                get: function(key) {
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            return stack[i].value;
	                        }
	                    }
	                    //如果没有找到的话，则创建一个新的数组
	                    var value = [];
	                    stack.push({ key: key, value: value });
	                    return value;
	                },
	                keys: function() {
	                    var keys = [];
	                    for (var i = 0; i < stack.length; i++) {
	                        keys.push(stack[i].key);
	                    }
	                    return keys;
	                },
	                top: function() {
	                    return stack[stack.length - 1];
	                },
	                remove: function(key) {
	                    var idx = -1;
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            idx = i;
	                            break;
	                        }
	                    }
	                    return stack.splice(idx, 1)[0];
	                },
	                removeItem: function(key, item) {
	                    var arrKey = this.get(key);
	                    var index = zrUtil.indexOf(arrKey, item);
	                    arrKey.splice(index, 1);
	
	                },
	                removeTop: function() {
	                    return stack.splice(stack.length - 1, 1)[0];
	                },
	                length: function() {
	                    return stack.length;
	                },
	                clear: function() {
	                    stack.splice(0, stack.length);
	                }
	            };
	        }
	    };
	
	    function randomColor() {
	        var arrHex = ["0", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d"],
	            strHex = "#",
	            index;
	        for (var i = 0; i < 6; i++) {
	            index = Math.round(Math.random() * 15);
	            strHex += arrHex[index];
	        }
	        return strHex;
	    }
	
	    function isUndefined(obj) {
	        return obj === void 0;
	    }
	
	    function collinearReduction (v) {
	        var r = [];
	
	        if(v.length < 3){
	            return Point.cloneArray(v);
	        }
	
	        r.push( v[0].clone() );
	        for(var i=1; i < v.length-1; i++){
	            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )
	            {
	                continue;
	            }
	            else{
	                r.push( v[i].clone() );
	            }
	        }
	        r.push( v[v.length-1].clone() );
	
	        return r;
	    }
	
	    // By default, Underscore uses ERB-style template delimiters, change the
	    // following template settings to use alternative delimiters.
	    var templateSettings = {
	        evaluate: /<%([\s\S]+?)%>/g,
	        interpolate: /<%=([\s\S]+?)%>/g,
	        escape: /<%-([\s\S]+?)%>/g
	    };
	
	    // When customizing `templateSettings`, if you don't want to define an
	    // interpolation, evaluation or escaping regex, we need one that is
	    // guaranteed not to match.
	    var noMatch = /(.)^/;
	
	    // Certain characters need to be escaped so that they can be put into a
	    // string literal.
	    var escapes = {
	        "'": "'",
	        '\\': '\\',
	        '\r': 'r',
	        '\n': 'n',
	        '\u2028': 'u2028',
	        '\u2029': 'u2029'
	    };
	
	    var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
	
	    var escapeChar = function(match) {
	        return '\\' + escapes[match];
	    };
	
	    // JavaScript micro-templating, similar to John Resig's implementation.
	    // Underscore templating handles arbitrary delimiters, preserves whitespace,
	    // and correctly escapes quotes within interpolated code.
	    // NB: `oldSettings` only exists for backwards compatibility.
	    function template(text, settings, oldSettings) {
	        if (!settings && oldSettings) settings = oldSettings;
	        settings = settings || {};
	        settings = zrUtil.defaults(settings, templateSettings, true);
	
	        // Combine delimiters into one regular expression via alternation.
	        var matcher = RegExp([
	            (settings.escape || noMatch).source,
	            (settings.interpolate || noMatch).source,
	            (settings.evaluate || noMatch).source
	        ].join('|') + '|$', 'g');
	
	        // Compile the template source, escaping string literals appropriately.
	        var index = 0;
	        var source = "__p+='";
	        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	            source += text.slice(index, offset).replace(escaper, escapeChar);
	            index = offset + match.length;
	
	            if (escape) {
	                source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	            } else if (interpolate) {
	                source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	            } else if (evaluate) {
	                source += "';\n" + evaluate + "\n__p+='";
	            }
	
	            // Adobe VMs need the match returned to produce the correct offest.
	            return match;
	        });
	        source += "';\n";
	
	        // If a variable is not specified, place data values in local scope.
	        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	
	        source = "var __t,__p='',__j=Array.prototype.join," +
	            "print=function(){__p+=__j.call(arguments,'');};\n" +
	            source + 'return __p;\n';
	
	        try {
	            var render = new Function(settings.variable || 'obj', source);
	        } catch (e) {
	            e.source = source;
	            throw e;
	        }
	
	        var template = function(data) {
	            return render.call(this, data);
	        };
	
	        // Provide the compiled source as a convenience for precompilation.
	        var argument = settings.variable || 'obj';
	        template.source = 'function(' + argument + '){\n' + source + '}';
	
	        return template;
	    }
	
	    function isEmpty(obj) {
	        if (obj == null) return true;
	        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;
	    }
	    function mergeOpt(target, source, overwrite, exclude) {
	        // We should escapse that source is string
	        // and enter for ... in ...
	        if (!zrUtil.isObject(source) || !zrUtil.isObject(target)) {
	          return overwrite ? zrUtil.clone(source) : target;
	        }
	
	        for (var key in source) {
	          if (source.hasOwnProperty(key)) {
	            var targetProp = target[key];
	            var sourceProp = source[key];
	
	            if (zrUtil.isObject(sourceProp) && zrUtil.isObject(targetProp) && !zrUtil.isArray(sourceProp) && !zrUtil.isArray(targetProp) && !zrUtil.isDom(sourceProp) && !zrUtil.isDom(targetProp) && !zrUtil.isBuiltInObject(sourceProp) && !zrUtil.isBuiltInObject(targetProp) && !zrUtil.isPrimitive(sourceProp) && !zrUtil.isPrimitive(targetProp)) {
	              // 如果需要递归覆盖，就递归调用merge
	              mergeOpt(targetProp, sourceProp, overwrite, exclude);
	            } else if (overwrite || !(key in target)) {
	              // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	              // NOTE，在 target[key] 不存在的时候也是直接覆盖
	                if (key !== exclude) {
	                    target[key] = zrUtil.clone(source[key], true);
	                }
	            }
	          }
	        }
	        return target;
	    }
	    function Class() {}
	    Class.extend = function(proto) {
	        var base = function() {},
	            member,
	            that = this,
	            subclass = proto && proto.init ? proto.init : function () {
	                that.apply(this, arguments);
	            },
	            fn;
	
	        base.prototype = that.prototype;
	        fn = subclass.fn = subclass.prototype = new base();
	
	        for (member in proto) {
	            if (proto[member] != null && proto[member].constructor === Object) {
	                // Merge object members
	                fn[member] = zrUtil.mergeAll([{}, base.prototype[member], proto[member]],true);
	            } else {
	                fn[member] = proto[member];
	            }
	        }
	
	        fn.constructor = subclass;
	        subclass.extend = that.extend;
	
	        return subclass;
	    };
	
	    module.exports = {
	        inherits: inherits,
	        getUUID: getUUID,
	        distance: distance,
	        getPolylineLength: getPolylineLength,
	        max: max,
	        min: min,
	        isEmpty: isEmpty,
	        mergeOpt: mergeOpt,
	        orthogonalPath: orthogonalPath,
	        polylineIntersectsRectangle: polylineIntersectsRectangle,
	        scorePath: scorePath,
	        forwardPath: forwardPath,
	        traslatePoints: traslatePoints,
	        getEndPoint: getEndPoint,
	        getConnectorPoints: getConnectorPoints,
	        getConnectorControls: getConnectorControls,
	        calculatePoints: calculatePoints,
	        tangentRotation: tangentRotation,
	        collinearity: collinearity,
	        translationMatrix: translationMatrix,
	        scaleMatrix: scaleMatrix,
	        round: enhancedRound,
	        getLength: getLength,
	        getAngle: getAngle,
	        getParentX: getParentX,
	        getParentY: getParentY,
	        getRect: getRect,
	        StackedMap: StackedMap,
	        getMaxLineLength: getMaxLineLength,
	        randomColor: randomColor,
	        template: template,
	        isUndefined: isUndefined,
	        getSoltPoints:getSoltPoints,
	        collinearReduction: collinearReduction,
	        Class:Class
	    };
	


/***/ }),
/* 66 */
/***/ (function(module, exports) {

	
	
	    /**
	      * Creates an instance of Point
	      *
	      *
	      * @constructor
	      * @this {Point}
	      * @param {Number} x The x coordinate of point.
	      * @param {Number} y The y coordinate of point.
	      * Note: Even if it is named Point this class should be named Dot as Dot is closer
	      * then Point from math perspective.
	      **/
	    function Point(x, y){
	        /**The x coordinate of point*/
	        this.x = x;
	
	        /**The y coordinate of point*/
	        this.y = y;
	
	
	    }
	
	    /**Creates a {Point} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Point} a newly constructed Point
	     **/
	    Point.load = function(o){
	        var newPoint = new Point(Number(o.x), Number(o.y));
	        return newPoint;
	    };
	
	
	    /**Creates an array of points from an array of {JSONObject}s
	     *@param {Array} v - the array of JSONObjects
	     *@return an {Array} of {Point}s
	     **/
	    Point.loadArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(Point.load(v[i]));
	        }
	        return newPoints;
	    };
	
	
	    /**Clones an array of points
	     *@param {Array} v - the array of {Point}s
	     *@return an {Array} of {Point}s
	     **/
	    Point.cloneArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(v[i].clone());
	        }
	        return newPoints;
	    };
	
	    Point.prototype = {
	        constructor : Point,
	
	        transform:function(matrix){
	            var oldX = this.x;
	            var oldY = this.y;
	            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];
	            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];
	        },
	
	        /**Tests if this point is similar to other point
	         *@param {Point} anotherPoint - the other point
	         **/
	        equals:function(anotherPoint){
	            if(! (anotherPoint instanceof Point) ){
	                return false;
	            }
	            return (this.x == anotherPoint.x)
	            && (this.y == anotherPoint.y)
	        },
	
	        /**Clone current Point
	         **/
	        clone: function(){
	            var newPoint = new Point(this.x, this.y);
	            return newPoint;
	        },
	
	        add: function(point) {
	            this.x = this.x + point.x;
	            this.y = this.y + point.y;
	            return this;
	        },
	
	        /**Tests to see if a point (x, y) is within a range of current Point
	         *@param {Numeric} x - the x coordinate of tested point
	         *@param {Numeric} y - the x coordinate of tested point
	         *@param {Numeric} radius - the radius of the vicinity
	         **/
	        near:function(x, y, radius){
	            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));
	
	            return (distance <= radius);
	        },
	
	        contains: function(x,y){
	            return this.x == x && this.y == y;
	        },
	
	        toString:function(){
	            return '[' + this.x + ',' + this.y + ']';
	        },
	
	        getPoints:function(){
	            return [this];
	        }
	    };
	    module.exports = Point;


/***/ }),
/* 67 */
/***/ (function(module, exports) {

	
	
	    /**
	      * Creates an instance of a Line. A Line is actually a segment and not a pure
	      * geometrical Line
	      *
	      * @constructor
	      * @this {Line}
	      * @param {Point} startPoint - starting point of the line
	      * @param {Point} endPoint - the ending point of the line
	      **/
	    function Line(startPoint, endPoint){
	        /**Starting {@link Point} of the line*/
	        this.startPoint = startPoint;
	
	        /**Ending {@link Point} of the line*/
	        this.endPoint = endPoint;
	
	        /**Serialization type*/
	        this.oType = 'Line'; //object type used for JSON deserialization
	    }
	
	    /**Creates a {Line} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Line} a newly constructed Line
	     **/
	    Line.load = function(o){
	        var newLine = new Line(
	            Point.load(o.startPoint),
	            Point.load(o.endPoint)
	        );
	
	        return newLine;
	    };
	
	    Line.prototype = {
	        contructor: Line,
	
	
	
	        clone:function(){
	            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());
	            return ret;
	        },
	
	        equals:function(anotherLine){
	            if(!anotherLine instanceof Line){
	                return false;
	            }
	            return this.startPoint.equals(anotherLine.startPoint)
	            && this.endPoint.equals(anotherLine.endPoint)
	        },
	
	        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)
	         * Algorithm: Compute line's equation and see if (x, y) verifies it.
	         * @param {Number} x - the X coordinates
	         * @param {Number} y - the Y coordinates
	         **/
	        contains: function(x, y){
	            // if the point is inside rectangle bounds of the segment
	            if (Math.min(this.startPoint.x, this.endPoint.x) <= x
	                && x <= Math.max(this.startPoint.x, this.endPoint.x)
	                && Math.min(this.startPoint.y, this.endPoint.y) <= y
	                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {
	
	                // check for vertical line
	                if (this.startPoint.x == this.endPoint.x) {
	                    return x == this.startPoint.x;
	                } else { // usual (not vertical) line can be represented as y = a * x + b
	                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);
	                    var b = this.startPoint.y - a * this.startPoint.x;
	                    return y == a * x + b;
	                }
	            } else {
	                return false;
	            }
	        },
	
	        /*
	         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)
	         *@param {Number} x - the x coordinates
	         *@param {Number} y - the y coordinates
	         *@param {Number} radius - the radius to search for
	         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	         *@see "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	         **/
	        near:function(x,y,radius){
	
	            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle
	                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)
	                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))
	                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;
	            }
	
	            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle
	                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)
	                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))
	                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;
	            }
	
	
	            var startX = Math.min(this.endPoint.x,this.startPoint.x);
	            var startY = Math.min(this.endPoint.y,this.startPoint.y);
	            var endX = Math.max(this.endPoint.x,this.startPoint.x);
	            var endY = Math.max(this.endPoint.y,this.startPoint.y);
	
	            /*We will compute the distance from point to the line
	             * by using the algorithm from
	             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	             * */
	
	            //First we need to find a,b,c of the line equation ax + by + c = 0
	            var a = this.endPoint.y - this.startPoint.y;
	            var b = this.startPoint.x - this.endPoint.x;
	            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);
	
	            //Secondly we get the distance "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );
	
	            //Thirdly we get coordinates of closest line's point to target point
	            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates
	            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	
	            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment
	                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment
	
	            return  r;
	
	        },
	
	        /**we need to create a new array each time, or we will affect the actual shape*/
	        getPoints:function(){
	            var points = [];
	            points.push(this.startPoint);
	            points.push(this.endPoint);
	            return points;
	        },
	
	        /**Return the {Point} corresponding the t certain t value
	         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/
	        getPoint: function(t){
	            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;
	            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;
	
	            return new Point(Xp, Yp);
	        },
	
	        // /**
	        //  * Returns the middle of the line
	        //  * @return {Point} the middle point
	        //  * */
	        // getMiddle : function(){
	        //     return Util.getMiddle(this.startPoint, this.endPoint);
	        // },
	
	
	        // getLength : function(){
	        //     return Util.getLength(this.startPoint, this.endPoint);
	        // },
	
	        // /**
	        //  *Get bounds for this line
	        //  *@author Alex Gheorghiu <alex@scriptoid.com>
	        //  **/
	        // getBounds:function(){
	        //     return Util.getBounds(this.getPoints());
	        // },
	
	        /**String representation*/
	        toString:function(){
	            return 'line(' + this.startPoint + ',' + this.endPoint + ')';
	        }
	    };
	    module.exports = Line;
	
	


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(5);
	
	    var apiList = [
	        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',
	        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',
	        "remove", "_getParentZr", "changeSelectConnectorType","_addGroupNode"
	    ];
	
	    function ExtensionAPI(instance) {
	        zrUtil.each(apiList, function (name) {
	            this[name] = zrUtil.bind(instance[name], instance);
	        }, this);
	    }
	
	    module.exports = ExtensionAPI;
	


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	var guid = __webpack_require__(11);
	
	var env = __webpack_require__(50);
	
	var zrUtil = __webpack_require__(5);
	
	var Handler = __webpack_require__(70);
	
	var Storage = __webpack_require__(71);
	
	var Painter = __webpack_require__(73);
	
	var Animation = __webpack_require__(76);
	
	var HandlerProxy = __webpack_require__(78);
	
	/*!
	* ZRender, a high performance 2d drawing library.
	*
	* Copyright (c) 2013, Baidu Inc.
	* All rights reserved.
	*
	* LICENSE
	* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	*/
	var useVML = !env.canvasSupported;
	var painterCtors = {
	  canvas: Painter
	};
	var instances = {}; // ZRender实例map索引
	
	/**
	 * @type {string}
	 */
	
	var version = '3.7.4';
	/**
	 * Initializing a zrender instance
	 * @param {HTMLElement} dom
	 * @param {Object} opts
	 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	 * @param {number} [opts.devicePixelRatio]
	 * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
	 * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
	 * @return {module:zrender/ZRender}
	 */
	
	function init(dom, opts) {
	  var zr = new ZRender(guid(), dom, opts);
	  instances[zr.id] = zr;
	  return zr;
	}
	/**
	 * Dispose zrender instance
	 * @param {module:zrender/ZRender} zr
	 */
	
	
	function dispose(zr) {
	  if (zr) {
	    zr.dispose();
	  } else {
	    for (var key in instances) {
	      if (instances.hasOwnProperty(key)) {
	        instances[key].dispose();
	      }
	    }
	
	    instances = {};
	  }
	
	  return this;
	}
	/**
	 * Get zrender instance by id
	 * @param {string} id zrender instance id
	 * @return {module:zrender/ZRender}
	 */
	
	
	function getInstance(id) {
	  return instances[id];
	}
	
	function registerPainter(name, Ctor) {
	  painterCtors[name] = Ctor;
	}
	
	function delInstance(id) {
	  delete instances[id];
	}
	/**
	 * @module zrender/ZRender
	 */
	
	/**
	 * @constructor
	 * @alias module:zrender/ZRender
	 * @param {string} id
	 * @param {HTMLElement} dom
	 * @param {Object} opts
	 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	 * @param {number} [opts.devicePixelRatio]
	 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
	 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
	 */
	
	
	var ZRender = function (id, dom, opts) {
	  opts = opts || {};
	  /**
	   * @type {HTMLDomElement}
	   */
	
	  this.dom = dom;
	  /**
	   * @type {string}
	   */
	
	  this.id = id;
	  var self = this;
	  var storage = new Storage();
	  var rendererType = opts.renderer; // TODO WebGL
	
	  if (useVML) {
	    if (!painterCtors.vml) {
	      throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
	    }
	
	    rendererType = 'vml';
	  } else if (!rendererType || !painterCtors[rendererType]) {
	    rendererType = 'canvas';
	  }
	
	  var painter = new painterCtors[rendererType](dom, storage, opts);
	  this.storage = storage;
	  this.painter = painter;
	  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;
	  this.handler = new Handler(storage, painter, handerProxy, painter.root);
	  /**
	   * @type {module:zrender/animation/Animation}
	   */
	
	  this.animation = new Animation({
	    stage: {
	      update: zrUtil.bind(this.flush, this)
	    }
	  });
	  this.animation.start();
	  /**
	   * @type {boolean}
	   * @private
	   */
	
	  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画
	  // FIXME 有点ugly
	
	  var oldDelFromStorage = storage.delFromStorage;
	  var oldAddToStorage = storage.addToStorage;
	
	  storage.delFromStorage = function (el) {
	    oldDelFromStorage.call(storage, el);
	    el && el.removeSelfFromZr(self);
	  };
	
	  storage.addToStorage = function (el) {
	    oldAddToStorage.call(storage, el);
	    el.addSelfToZr(self);
	  };
	};
	
	ZRender.prototype = {
	  constructor: ZRender,
	
	  /**
	   * 获取实例唯一标识
	   * @return {string}
	   */
	  getId: function () {
	    return this.id;
	  },
	
	  /**
	   * 添加元素
	   * @param  {module:zrender/Element} el
	   */
	  add: function (el) {
	    this.storage.addRoot(el);
	    this._needsRefresh = true;
	  },
	
	  /**
	   * 删除元素
	   * @param  {module:zrender/Element} el
	   */
	  remove: function (el) {
	    this.storage.delRoot(el);
	    this._needsRefresh = true;
	  },
	
	  /**
	   * Change configuration of layer
	   * @param {string} zLevel
	   * @param {Object} config
	   * @param {string} [config.clearColor=0] Clear color
	   * @param {string} [config.motionBlur=false] If enable motion blur
	   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
	  */
	  configLayer: function (zLevel, config) {
	    this.painter.configLayer(zLevel, config);
	    this._needsRefresh = true;
	  },
	
	  /**
	   * Repaint the canvas immediately
	   */
	  refreshImmediately: function () {
	    // var start = new Date();
	    // Clear needsRefresh ahead to avoid something wrong happens in refresh
	    // Or it will cause zrender refreshes again and again.
	    this._needsRefresh = false;
	    this.painter.refresh();
	    /**
	     * Avoid trigger zr.refresh in Element#beforeUpdate hook
	     */
	
	    this._needsRefresh = false; // var end = new Date();
	    // var log = document.getElementById('log');
	    // if (log) {
	    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);
	    // }
	  },
	
	  /**
	   * Mark and repaint the canvas in the next frame of browser
	   */
	  refresh: function () {
	    this._needsRefresh = true;
	  },
	
	  /**
	   * Perform all refresh
	   */
	  flush: function () {
	    if (this._needsRefresh) {
	      this.refreshImmediately();
	    }
	
	    if (this._needsRefreshHover) {
	      this.refreshHoverImmediately();
	    }
	  },
	
	  /**
	   * Add element to hover layer
	   * @param  {module:zrender/Element} el
	   * @param {Object} style
	   */
	  addHover: function (el, style) {
	    if (this.painter.addHover) {
	      this.painter.addHover(el, style);
	      this.refreshHover();
	    }
	  },
	
	  /**
	   * Add element from hover layer
	   * @param  {module:zrender/Element} el
	   */
	  removeHover: function (el) {
	    if (this.painter.removeHover) {
	      this.painter.removeHover(el);
	      this.refreshHover();
	    }
	  },
	
	  /**
	   * Clear all hover elements in hover layer
	   * @param  {module:zrender/Element} el
	   */
	  clearHover: function () {
	    if (this.painter.clearHover) {
	      this.painter.clearHover();
	      this.refreshHover();
	    }
	  },
	
	  /**
	   * Refresh hover in next frame
	   */
	  refreshHover: function () {
	    this._needsRefreshHover = true;
	  },
	
	  /**
	   * Refresh hover immediately
	   */
	  refreshHoverImmediately: function () {
	    this._needsRefreshHover = false;
	    this.painter.refreshHover && this.painter.refreshHover();
	  },
	
	  /**
	   * Resize the canvas.
	   * Should be invoked when container size is changed
	   * @param {Object} [opts]
	   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
	   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
	   */
	  resize: function (opts) {
	    opts = opts || {};
	    this.painter.resize(opts.width, opts.height);
	    this.handler.resize();
	  },
	
	  /**
	   * Stop and clear all animation immediately
	   */
	  clearAnimation: function () {
	    this.animation.clear();
	  },
	
	  /**
	   * Get container width
	   */
	  getWidth: function () {
	    return this.painter.getWidth();
	  },
	
	  /**
	   * Get container height
	   */
	  getHeight: function () {
	    return this.painter.getHeight();
	  },
	
	  /**
	   * Export the canvas as Base64 URL
	   * @param {string} type
	   * @param {string} [backgroundColor='#fff']
	   * @return {string} Base64 URL
	   */
	  // toDataURL: function(type, backgroundColor) {
	  //     return this.painter.getRenderedCanvas({
	  //         backgroundColor: backgroundColor
	  //     }).toDataURL(type);
	  // },
	
	  /**
	   * Converting a path to image.
	   * It has much better performance of drawing image rather than drawing a vector path.
	   * @param {module:zrender/graphic/Path} e
	   * @param {number} width
	   * @param {number} height
	   */
	  pathToImage: function (e, dpr) {
	    return this.painter.pathToImage(e, dpr);
	  },
	
	  /**
	   * Set default cursor
	   * @param {string} [cursorStyle='default'] 例如 crosshair
	   */
	  setCursorStyle: function (cursorStyle) {
	    this.handler.setCursorStyle(cursorStyle);
	  },
	
	  /**
	   * Find hovered element
	   * @param {number} x
	   * @param {number} y
	   * @return {Object} {target, topTarget}
	   */
	  findHover: function (x, y) {
	    return this.handler.findHover(x, y);
	  },
	
	  /**
	   * Bind event
	   *
	   * @param {string} eventName Event name
	   * @param {Function} eventHandler Handler function
	   * @param {Object} [context] Context object
	   */
	  on: function (eventName, eventHandler, context) {
	    this.handler.on(eventName, eventHandler, context);
	  },
	
	  /**
	   * Unbind event
	   * @param {string} eventName Event name
	   * @param {Function} [eventHandler] Handler function
	   */
	  off: function (eventName, eventHandler) {
	    this.handler.off(eventName, eventHandler);
	  },
	
	  /**
	   * Trigger event manually
	   *
	   * @param {string} eventName Event name
	   * @param {event=} event Event object
	   */
	  trigger: function (eventName, event) {
	    this.handler.trigger(eventName, event);
	  },
	
	  /**
	   * Clear all objects and the canvas.
	   */
	  clear: function () {
	    this.storage.delRoot();
	    this.painter.clear();
	  },
	
	  /**
	   * Dispose self.
	   */
	  dispose: function () {
	    this.animation.stop();
	    this.clear();
	    this.storage.dispose();
	    this.painter.dispose();
	    this.handler.dispose();
	    this.animation = this.storage = this.painter = this.handler = null;
	    delInstance(this.id);
	  }
	};
	exports.version = version;
	exports.init = init;
	exports.dispose = dispose;
	exports.getInstance = getInstance;
	exports.registerPainter = registerPainter;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(5);
	
	var vec2 = __webpack_require__(15);
	
	var Draggable = __webpack_require__(43);
	
	var Eventful = __webpack_require__(12);
	
	/**
	 * Handler
	 * @module zrender/Handler
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (shenyi.914@gmail.com)
	 */
	var SILENT = 'silent';
	
	function makeEventPacket(eveType, targetInfo, event) {
	  return {
	    type: eveType,
	    event: event,
	    // target can only be an element that is not silent.
	    target: targetInfo.target,
	    // topTarget can be a silent element.
	    topTarget: targetInfo.topTarget,
	    cancelBubble: false,
	    offsetX: event.zrX,
	    offsetY: event.zrY,
	    gestureEvent: event.gestureEvent,
	    pinchX: event.pinchX,
	    pinchY: event.pinchY,
	    pinchScale: event.pinchScale,
	    wheelDelta: event.zrDelta,
	    zrByTouch: event.zrByTouch,
	    which: event.which
	  };
	}
	
	function EmptyProxy() {}
	
	EmptyProxy.prototype.dispose = function () {};
	
	var handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
	/**
	 * @alias module:zrender/Handler
	 * @constructor
	 * @extends module:zrender/mixin/Eventful
	 * @param {module:zrender/Storage} storage Storage instance.
	 * @param {module:zrender/Painter} painter Painter instance.
	 * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
	 * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
	 */
	
	var Handler = function (storage, painter, proxy, painterRoot) {
	  Eventful.call(this);
	  this.storage = storage;
	  this.painter = painter;
	  this.painterRoot = painterRoot;
	  proxy = proxy || new EmptyProxy();
	  /**
	   * Proxy of event. can be Dom, WebGLSurface, etc.
	   */
	
	  this.proxy = proxy; // Attach handler
	
	  proxy.handler = this;
	  /**
	   * {target, topTarget, x, y}
	   * @private
	   * @type {Object}
	   */
	
	  this._hovered = {};
	  /**
	   * @private
	   * @type {Date}
	   */
	
	  this._lastTouchMoment;
	  /**
	   * @private
	   * @type {number}
	   */
	
	  this._lastX;
	  /**
	   * @private
	   * @type {number}
	   */
	
	  this._lastY;
	  Draggable.call(this);
	  util.each(handlerNames, function (name) {
	    proxy.on && proxy.on(name, this[name], this);
	  }, this);
	};
	
	Handler.prototype = {
	  constructor: Handler,
	  mousemove: function (event) {
	    var x = event.zrX;
	    var y = event.zrY;
	    var lastHovered = this._hovered;
	    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call
	    // (like 'setOption' or 'dispatchAction') in event handlers, we should find
	    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.
	    // See #6198.
	
	    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
	      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
	      lastHoveredTarget = lastHovered.target;
	    }
	
	    var hovered = this._hovered = this.findHover(x, y);
	    var hoveredTarget = hovered.target;
	    var proxy = this.proxy;
	    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element
	
	    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
	      this.dispatchToElement(lastHovered, 'mouseout', event);
	    } // Mouse moving on one element
	
	
	    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element
	
	    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
	      this.dispatchToElement(hovered, 'mouseover', event);
	    }
	  },
	  mouseout: function (event) {
	    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application
	    // at the same level of painter.getViewportRoot() (e.g., tooltip
	    // dom created by echarts), where 'globalout' event should not
	    // be triggered when mouse enters these doms. (But 'mouseout'
	    // should be triggered at the original hovered element as usual).
	
	    var element = event.toElement || event.relatedTarget;
	    var innerDom;
	
	    do {
	      element = element && element.parentNode;
	    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));
	
	    !innerDom && this.trigger('globalout', {
	      event: event
	    });
	  },
	
	  /**
	   * Resize
	   */
	  resize: function (event) {
	    this._hovered = {};
	  },
	
	  /**
	   * Dispatch event
	   * @param {string} eventName
	   * @param {event=} eventArgs
	   */
	  dispatch: function (eventName, eventArgs) {
	    var handler = this[eventName];
	    handler && handler.call(this, eventArgs);
	  },
	
	  /**
	   * Dispose
	   */
	  dispose: function () {
	    this.proxy.dispose();
	    this.storage = this.proxy = this.painter = null;
	  },
	
	  /**
	   * 设置默认的cursor style
	   * @param {string} [cursorStyle='default'] 例如 crosshair
	   */
	  setCursorStyle: function (cursorStyle) {
	    var proxy = this.proxy;
	    proxy.setCursor && proxy.setCursor(cursorStyle);
	  },
	
	  /**
	   * 事件分发代理
	   *
	   * @private
	   * @param {Object} targetInfo {target, topTarget} 目标图形元素
	   * @param {string} eventName 事件名称
	   * @param {Object} event 事件对象
	   */
	  dispatchToElement: function (targetInfo, eventName, event) {
	    targetInfo = targetInfo || {};
	    var el = targetInfo.target;
	
	    if (el && el.silent) {
	      return;
	    }
	
	    var eventHandler = 'on' + eventName;
	    var eventPacket = makeEventPacket(eventName, targetInfo, event);
	
	    while (el) {
	      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
	      el.trigger(eventName, eventPacket);
	      el = el.parent;
	
	      if (eventPacket.cancelBubble) {
	        break;
	      }
	    }
	
	    if (!eventPacket.cancelBubble) {
	      // 冒泡到顶级 zrender 对象
	      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层
	      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
	
	      this.painter && this.painter.eachOtherLayer(function (layer) {
	        if (typeof layer[eventHandler] == 'function') {
	          layer[eventHandler].call(layer, eventPacket);
	        }
	
	        if (layer.trigger) {
	          layer.trigger(eventName, eventPacket);
	        }
	      });
	    }
	  },
	
	  /**
	   * @private
	   * @param {number} x
	   * @param {number} y
	   * @param {module:zrender/graphic/Displayable} exclude
	   * @return {model:zrender/Element}
	   * @method
	   */
	  findHover: function (x, y, exclude) {
	    var list = this.storage.getDisplayList();
	    var out = {
	      x: x,
	      y: y
	    };
	
	    for (var i = list.length - 1; i >= 0; i--) {
	      var hoverCheckResult;
	
	      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode
	      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
	        !out.topTarget && (out.topTarget = list[i]);
	
	        if (hoverCheckResult !== SILENT) {
	          out.target = list[i];
	          break;
	        }
	      }
	    }
	
	    return out;
	  }
	}; // Common handlers
	
	util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
	  Handler.prototype[name] = function (event) {
	    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
	    var hovered = this.findHover(event.zrX, event.zrY);
	    var hoveredTarget = hovered.target;
	
	    if (name === 'mousedown') {
	      this._downEl = hoveredTarget;
	      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup
	
	      this._upEl = hoveredTarget;
	    } else if (name === 'mosueup') {
	      this._upEl = hoveredTarget;
	    } else if (name === 'click') {
	      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,
	      // including the case that `mousedown` - `mousemove` - `mouseup`,
	      // which should be filtered, otherwise it will bring trouble to
	      // pan and zoom.
	      || !this._downPoint // Arbitrary value
	      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
	        return;
	      }
	
	      this._downPoint = null;
	    }
	
	    this.dispatchToElement(hovered, name, event);
	  };
	});
	
	function isHover(displayable, x, y) {
	  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
	    var el = displayable;
	    var isSilent;
	
	    while (el) {
	      // If clipped by ancestor.
	      // FIXME: If clipPath has neither stroke nor fill,
	      // el.clipPath.contain(x, y) will always return false.
	      if (el.clipPath && !el.clipPath.contain(x, y)) {
	        return false;
	      }
	
	      if (el.silent) {
	        isSilent = true;
	      }
	
	      el = el.parent;
	    }
	
	    return isSilent ? SILENT : true;
	  }
	
	  return false;
	}
	
	util.mixin(Handler, Eventful);
	util.mixin(Handler, Draggable);
	var _default = Handler;
	module.exports = _default;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(5);
	
	var env = __webpack_require__(50);
	
	var Group = __webpack_require__(44);
	
	var timsort = __webpack_require__(72);
	
	/**
	 * Storage内容仓库模块
	 * @module zrender/Storage
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 * @author errorrik (errorrik@gmail.com)
	 * @author pissang (https://github.com/pissang/)
	 */
	// Use timsort because in most case elements are partially sorted
	// https://jsfiddle.net/pissang/jr4x7mdm/8/
	function shapeCompareFunc(a, b) {
	  if (a.zlevel === b.zlevel) {
	    if (a.z === b.z) {
	      // if (a.z2 === b.z2) {
	      //     // FIXME Slow has renderidx compare
	      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
	      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
	      //     return a.__renderidx - b.__renderidx;
	      // }
	      return a.z2 - b.z2;
	    }
	
	    return a.z - b.z;
	  }
	
	  return a.zlevel - b.zlevel;
	}
	/**
	 * 内容仓库 (M)
	 * @alias module:zrender/Storage
	 * @constructor
	 */
	
	
	var Storage = function () {
	  // jshint ignore:line
	  this._roots = [];
	  this._displayList = [];
	  this._displayListLen = 0;
	};
	
	Storage.prototype = {
	  constructor: Storage,
	
	  /**
	   * @param  {Function} cb
	   *
	   */
	  traverse: function (cb, context) {
	    for (var i = 0; i < this._roots.length; i++) {
	      this._roots[i].traverse(cb, context);
	    }
	  },
	
	  /**
	   * 返回所有图形的绘制队列
	   * @param {boolean} [update=false] 是否在返回前更新该数组
	   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
	   *
	   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
	   * @return {Array.<module:zrender/graphic/Displayable>}
	   */
	  getDisplayList: function (update, includeIgnore) {
	    includeIgnore = includeIgnore || false;
	
	    if (update) {
	      this.updateDisplayList(includeIgnore);
	    }
	
	    return this._displayList;
	  },
	
	  /**
	   * 更新图形的绘制队列。
	   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
	   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
	   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
	   */
	  updateDisplayList: function (includeIgnore) {
	    this._displayListLen = 0;
	    var roots = this._roots;
	    var displayList = this._displayList;
	
	    for (var i = 0, len = roots.length; i < len; i++) {
	      this._updateAndAddDisplayable(roots[i], null, includeIgnore);
	    }
	
	    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {
	    //     displayList[i].__renderidx = i;
	    // }
	    // displayList.sort(shapeCompareFunc);
	
	    env.canvasSupported && timsort(displayList, shapeCompareFunc);
	  },
	  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
	    if (el.ignore && !includeIgnore) {
	      return;
	    }
	
	    el.beforeUpdate();
	
	    if (el.__dirty) {
	      el.update();
	    }
	
	    el.afterUpdate();
	    var userSetClipPath = el.clipPath;
	
	    if (userSetClipPath) {
	      // FIXME 效率影响
	      if (clipPaths) {
	        clipPaths = clipPaths.slice();
	      } else {
	        clipPaths = [];
	      }
	
	      var currentClipPath = userSetClipPath;
	      var parentClipPath = el; // Recursively add clip path
	
	      while (currentClipPath) {
	        // clipPath 的变换是基于使用这个 clipPath 的元素
	        currentClipPath.parent = parentClipPath;
	        currentClipPath.updateTransform();
	        clipPaths.push(currentClipPath);
	        parentClipPath = currentClipPath;
	        currentClipPath = currentClipPath.clipPath;
	      }
	    }
	
	    if (el.isGroup) {
	      var children = el._children;
	
	      for (var i = 0; i < children.length; i++) {
	        var child = children[i]; // Force to mark as dirty if group is dirty
	        // FIXME __dirtyPath ?
	
	        if (el.__dirty) {
	          child.__dirty = true;
	        }
	
	        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
	      } // Mark group clean here
	
	
	      el.__dirty = false;
	    } else {
	      el.__clipPaths = clipPaths;
	      this._displayList[this._displayListLen++] = el;
	    }
	  },
	
	  /**
	   * 添加图形(Shape)或者组(Group)到根节点
	   * @param {module:zrender/Element} el
	   */
	  addRoot: function (el) {
	    if (el.__storage === this) {
	      return;
	    }
	
	    if (el instanceof Group) {
	      el.addChildrenToStorage(this);
	    }
	
	    this.addToStorage(el);
	
	    this._roots.push(el);
	  },
	
	  /**
	   * 删除指定的图形(Shape)或者组(Group)
	   * @param {string|Array.<string>} [el] 如果为空清空整个Storage
	   */
	  delRoot: function (el) {
	    if (el == null) {
	      // 不指定el清空
	      for (var i = 0; i < this._roots.length; i++) {
	        var root = this._roots[i];
	
	        if (root instanceof Group) {
	          root.delChildrenFromStorage(this);
	        }
	      }
	
	      this._roots = [];
	      this._displayList = [];
	      this._displayListLen = 0;
	      return;
	    }
	
	    if (el instanceof Array) {
	      for (var i = 0, l = el.length; i < l; i++) {
	        this.delRoot(el[i]);
	      }
	
	      return;
	    }
	
	    var idx = util.indexOf(this._roots, el);
	
	    if (idx >= 0) {
	      this.delFromStorage(el);
	
	      this._roots.splice(idx, 1);
	
	      if (el instanceof Group) {
	        el.delChildrenFromStorage(this);
	      }
	    }
	  },
	  addToStorage: function (el) {
	    el.__storage = this;
	    el.dirty(false);
	    return this;
	  },
	  delFromStorage: function (el) {
	    if (el) {
	      el.__storage = null;
	    }
	
	    return this;
	  },
	
	  /**
	   * 清空并且释放Storage
	   */
	  dispose: function () {
	    this._renderList = this._roots = null;
	  },
	  displayableSortFunc: shapeCompareFunc
	};
	var _default = Storage;
	module.exports = _default;

/***/ }),
/* 72 */
/***/ (function(module, exports) {

	// https://github.com/mziccard/node-timsort
	var DEFAULT_MIN_MERGE = 32;
	var DEFAULT_MIN_GALLOPING = 7;
	var DEFAULT_TMP_STORAGE_LENGTH = 256;
	
	function minRunLength(n) {
	  var r = 0;
	
	  while (n >= DEFAULT_MIN_MERGE) {
	    r |= n & 1;
	    n >>= 1;
	  }
	
	  return n + r;
	}
	
	function makeAscendingRun(array, lo, hi, compare) {
	  var runHi = lo + 1;
	
	  if (runHi === hi) {
	    return 1;
	  }
	
	  if (compare(array[runHi++], array[lo]) < 0) {
	    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
	      runHi++;
	    }
	
	    reverseRun(array, lo, runHi);
	  } else {
	    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
	      runHi++;
	    }
	  }
	
	  return runHi - lo;
	}
	
	function reverseRun(array, lo, hi) {
	  hi--;
	
	  while (lo < hi) {
	    var t = array[lo];
	    array[lo++] = array[hi];
	    array[hi--] = t;
	  }
	}
	
	function binaryInsertionSort(array, lo, hi, start, compare) {
	  if (start === lo) {
	    start++;
	  }
	
	  for (; start < hi; start++) {
	    var pivot = array[start];
	    var left = lo;
	    var right = start;
	    var mid;
	
	    while (left < right) {
	      mid = left + right >>> 1;
	
	      if (compare(pivot, array[mid]) < 0) {
	        right = mid;
	      } else {
	        left = mid + 1;
	      }
	    }
	
	    var n = start - left;
	
	    switch (n) {
	      case 3:
	        array[left + 3] = array[left + 2];
	
	      case 2:
	        array[left + 2] = array[left + 1];
	
	      case 1:
	        array[left + 1] = array[left];
	        break;
	
	      default:
	        while (n > 0) {
	          array[left + n] = array[left + n - 1];
	          n--;
	        }
	
	    }
	
	    array[left] = pivot;
	  }
	}
	
	function gallopLeft(value, array, start, length, hint, compare) {
	  var lastOffset = 0;
	  var maxOffset = 0;
	  var offset = 1;
	
	  if (compare(value, array[start + hint]) > 0) {
	    maxOffset = length - hint;
	
	    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    lastOffset += hint;
	    offset += hint;
	  } else {
	    maxOffset = hint + 1;
	
	    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    var tmp = lastOffset;
	    lastOffset = hint - offset;
	    offset = hint - tmp;
	  }
	
	  lastOffset++;
	
	  while (lastOffset < offset) {
	    var m = lastOffset + (offset - lastOffset >>> 1);
	
	    if (compare(value, array[start + m]) > 0) {
	      lastOffset = m + 1;
	    } else {
	      offset = m;
	    }
	  }
	
	  return offset;
	}
	
	function gallopRight(value, array, start, length, hint, compare) {
	  var lastOffset = 0;
	  var maxOffset = 0;
	  var offset = 1;
	
	  if (compare(value, array[start + hint]) < 0) {
	    maxOffset = hint + 1;
	
	    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    var tmp = lastOffset;
	    lastOffset = hint - offset;
	    offset = hint - tmp;
	  } else {
	    maxOffset = length - hint;
	
	    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    lastOffset += hint;
	    offset += hint;
	  }
	
	  lastOffset++;
	
	  while (lastOffset < offset) {
	    var m = lastOffset + (offset - lastOffset >>> 1);
	
	    if (compare(value, array[start + m]) < 0) {
	      offset = m;
	    } else {
	      lastOffset = m + 1;
	    }
	  }
	
	  return offset;
	}
	
	function TimSort(array, compare) {
	  var minGallop = DEFAULT_MIN_GALLOPING;
	  var length = 0;
	  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
	  var stackLength = 0;
	  var runStart;
	  var runLength;
	  var stackSize = 0;
	  length = array.length;
	
	  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
	    tmpStorageLength = length >>> 1;
	  }
	
	  var tmp = [];
	  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
	  runStart = [];
	  runLength = [];
	
	  function pushRun(_runStart, _runLength) {
	    runStart[stackSize] = _runStart;
	    runLength[stackSize] = _runLength;
	    stackSize += 1;
	  }
	
	  function mergeRuns() {
	    while (stackSize > 1) {
	      var n = stackSize - 2;
	
	      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
	        if (runLength[n - 1] < runLength[n + 1]) {
	          n--;
	        }
	      } else if (runLength[n] > runLength[n + 1]) {
	        break;
	      }
	
	      mergeAt(n);
	    }
	  }
	
	  function forceMergeRuns() {
	    while (stackSize > 1) {
	      var n = stackSize - 2;
	
	      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
	        n--;
	      }
	
	      mergeAt(n);
	    }
	  }
	
	  function mergeAt(i) {
	    var start1 = runStart[i];
	    var length1 = runLength[i];
	    var start2 = runStart[i + 1];
	    var length2 = runLength[i + 1];
	    runLength[i] = length1 + length2;
	
	    if (i === stackSize - 3) {
	      runStart[i + 1] = runStart[i + 2];
	      runLength[i + 1] = runLength[i + 2];
	    }
	
	    stackSize--;
	    var k = gallopRight(array[start2], array, start1, length1, 0, compare);
	    start1 += k;
	    length1 -= k;
	
	    if (length1 === 0) {
	      return;
	    }
	
	    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
	
	    if (length2 === 0) {
	      return;
	    }
	
	    if (length1 <= length2) {
	      mergeLow(start1, length1, start2, length2);
	    } else {
	      mergeHigh(start1, length1, start2, length2);
	    }
	  }
	
	  function mergeLow(start1, length1, start2, length2) {
	    var i = 0;
	
	    for (i = 0; i < length1; i++) {
	      tmp[i] = array[start1 + i];
	    }
	
	    var cursor1 = 0;
	    var cursor2 = start2;
	    var dest = start1;
	    array[dest++] = array[cursor2++];
	
	    if (--length2 === 0) {
	      for (i = 0; i < length1; i++) {
	        array[dest + i] = tmp[cursor1 + i];
	      }
	
	      return;
	    }
	
	    if (length1 === 1) {
	      for (i = 0; i < length2; i++) {
	        array[dest + i] = array[cursor2 + i];
	      }
	
	      array[dest + length2] = tmp[cursor1];
	      return;
	    }
	
	    var _minGallop = minGallop;
	    var count1, count2, exit;
	
	    while (1) {
	      count1 = 0;
	      count2 = 0;
	      exit = false;
	
	      do {
	        if (compare(array[cursor2], tmp[cursor1]) < 0) {
	          array[dest++] = array[cursor2++];
	          count2++;
	          count1 = 0;
	
	          if (--length2 === 0) {
	            exit = true;
	            break;
	          }
	        } else {
	          array[dest++] = tmp[cursor1++];
	          count1++;
	          count2 = 0;
	
	          if (--length1 === 1) {
	            exit = true;
	            break;
	          }
	        }
	      } while ((count1 | count2) < _minGallop);
	
	      if (exit) {
	        break;
	      }
	
	      do {
	        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
	
	        if (count1 !== 0) {
	          for (i = 0; i < count1; i++) {
	            array[dest + i] = tmp[cursor1 + i];
	          }
	
	          dest += count1;
	          cursor1 += count1;
	          length1 -= count1;
	
	          if (length1 <= 1) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest++] = array[cursor2++];
	
	        if (--length2 === 0) {
	          exit = true;
	          break;
	        }
	
	        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
	
	        if (count2 !== 0) {
	          for (i = 0; i < count2; i++) {
	            array[dest + i] = array[cursor2 + i];
	          }
	
	          dest += count2;
	          cursor2 += count2;
	          length2 -= count2;
	
	          if (length2 === 0) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest++] = tmp[cursor1++];
	
	        if (--length1 === 1) {
	          exit = true;
	          break;
	        }
	
	        _minGallop--;
	      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	      if (exit) {
	        break;
	      }
	
	      if (_minGallop < 0) {
	        _minGallop = 0;
	      }
	
	      _minGallop += 2;
	    }
	
	    minGallop = _minGallop;
	    minGallop < 1 && (minGallop = 1);
	
	    if (length1 === 1) {
	      for (i = 0; i < length2; i++) {
	        array[dest + i] = array[cursor2 + i];
	      }
	
	      array[dest + length2] = tmp[cursor1];
	    } else if (length1 === 0) {
	      throw new Error(); // throw new Error('mergeLow preconditions were not respected');
	    } else {
	      for (i = 0; i < length1; i++) {
	        array[dest + i] = tmp[cursor1 + i];
	      }
	    }
	  }
	
	  function mergeHigh(start1, length1, start2, length2) {
	    var i = 0;
	
	    for (i = 0; i < length2; i++) {
	      tmp[i] = array[start2 + i];
	    }
	
	    var cursor1 = start1 + length1 - 1;
	    var cursor2 = length2 - 1;
	    var dest = start2 + length2 - 1;
	    var customCursor = 0;
	    var customDest = 0;
	    array[dest--] = array[cursor1--];
	
	    if (--length1 === 0) {
	      customCursor = dest - (length2 - 1);
	
	      for (i = 0; i < length2; i++) {
	        array[customCursor + i] = tmp[i];
	      }
	
	      return;
	    }
	
	    if (length2 === 1) {
	      dest -= length1;
	      cursor1 -= length1;
	      customDest = dest + 1;
	      customCursor = cursor1 + 1;
	
	      for (i = length1 - 1; i >= 0; i--) {
	        array[customDest + i] = array[customCursor + i];
	      }
	
	      array[dest] = tmp[cursor2];
	      return;
	    }
	
	    var _minGallop = minGallop;
	
	    while (true) {
	      var count1 = 0;
	      var count2 = 0;
	      var exit = false;
	
	      do {
	        if (compare(tmp[cursor2], array[cursor1]) < 0) {
	          array[dest--] = array[cursor1--];
	          count1++;
	          count2 = 0;
	
	          if (--length1 === 0) {
	            exit = true;
	            break;
	          }
	        } else {
	          array[dest--] = tmp[cursor2--];
	          count2++;
	          count1 = 0;
	
	          if (--length2 === 1) {
	            exit = true;
	            break;
	          }
	        }
	      } while ((count1 | count2) < _minGallop);
	
	      if (exit) {
	        break;
	      }
	
	      do {
	        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
	
	        if (count1 !== 0) {
	          dest -= count1;
	          cursor1 -= count1;
	          length1 -= count1;
	          customDest = dest + 1;
	          customCursor = cursor1 + 1;
	
	          for (i = count1 - 1; i >= 0; i--) {
	            array[customDest + i] = array[customCursor + i];
	          }
	
	          if (length1 === 0) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest--] = tmp[cursor2--];
	
	        if (--length2 === 1) {
	          exit = true;
	          break;
	        }
	
	        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
	
	        if (count2 !== 0) {
	          dest -= count2;
	          cursor2 -= count2;
	          length2 -= count2;
	          customDest = dest + 1;
	          customCursor = cursor2 + 1;
	
	          for (i = 0; i < count2; i++) {
	            array[customDest + i] = tmp[customCursor + i];
	          }
	
	          if (length2 <= 1) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest--] = array[cursor1--];
	
	        if (--length1 === 0) {
	          exit = true;
	          break;
	        }
	
	        _minGallop--;
	      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	      if (exit) {
	        break;
	      }
	
	      if (_minGallop < 0) {
	        _minGallop = 0;
	      }
	
	      _minGallop += 2;
	    }
	
	    minGallop = _minGallop;
	
	    if (minGallop < 1) {
	      minGallop = 1;
	    }
	
	    if (length2 === 1) {
	      dest -= length1;
	      cursor1 -= length1;
	      customDest = dest + 1;
	      customCursor = cursor1 + 1;
	
	      for (i = length1 - 1; i >= 0; i--) {
	        array[customDest + i] = array[customCursor + i];
	      }
	
	      array[dest] = tmp[cursor2];
	    } else if (length2 === 0) {
	      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');
	    } else {
	      customCursor = dest - (length2 - 1);
	
	      for (i = 0; i < length2; i++) {
	        array[customCursor + i] = tmp[i];
	      }
	    }
	  }
	
	  this.mergeRuns = mergeRuns;
	  this.forceMergeRuns = forceMergeRuns;
	  this.pushRun = pushRun;
	}
	
	function sort(array, compare, lo, hi) {
	  if (!lo) {
	    lo = 0;
	  }
	
	  if (!hi) {
	    hi = array.length;
	  }
	
	  var remaining = hi - lo;
	
	  if (remaining < 2) {
	    return;
	  }
	
	  var runLength = 0;
	
	  if (remaining < DEFAULT_MIN_MERGE) {
	    runLength = makeAscendingRun(array, lo, hi, compare);
	    binaryInsertionSort(array, lo, hi, lo + runLength, compare);
	    return;
	  }
	
	  var ts = new TimSort(array, compare);
	  var minRun = minRunLength(remaining);
	
	  do {
	    runLength = makeAscendingRun(array, lo, hi, compare);
	
	    if (runLength < minRun) {
	      var force = remaining;
	
	      if (force > minRun) {
	        force = minRun;
	      }
	
	      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
	      runLength = force;
	    }
	
	    ts.pushRun(lo, runLength);
	    ts.mergeRuns();
	    remaining -= runLength;
	    lo += runLength;
	  } while (remaining !== 0);
	
	  ts.forceMergeRuns();
	}
	
	module.exports = sort;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	var _config = __webpack_require__(23);
	
	var devicePixelRatio = _config.devicePixelRatio;
	
	var util = __webpack_require__(5);
	
	var log = __webpack_require__(22);
	
	var BoundingRect = __webpack_require__(27);
	
	var timsort = __webpack_require__(72);
	
	var Layer = __webpack_require__(74);
	
	var requestAnimationFrame = __webpack_require__(75);
	
	var Image = __webpack_require__(45);
	
	/**
	 * Default canvas painter
	 * @module zrender/Painter
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	// PENDIGN
	// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
	//
	// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
	var MAX_PROGRESSIVE_LAYER_NUMBER = 5;
	
	function parseInt10(val) {
	  return parseInt(val, 10);
	}
	
	function isLayerValid(layer) {
	  if (!layer) {
	    return false;
	  }
	
	  if (layer.__builtin__) {
	    return true;
	  }
	
	  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {
	    return false;
	  }
	
	  return true;
	}
	
	function preProcessLayer(layer) {
	  layer.__unusedCount++;
	}
	
	function postProcessLayer(layer) {
	  if (layer.__unusedCount == 1) {
	    layer.clear();
	  }
	}
	
	var tmpRect = new BoundingRect(0, 0, 0, 0);
	var viewRect = new BoundingRect(0, 0, 0, 0);
	
	function isDisplayableCulled(el, width, height) {
	  tmpRect.copy(el.getBoundingRect());
	
	  if (el.transform) {
	    tmpRect.applyTransform(el.transform);
	  }
	
	  viewRect.width = width;
	  viewRect.height = height;
	  return !tmpRect.intersect(viewRect);
	}
	
	function isClipPathChanged(clipPaths, prevClipPaths) {
	  if (clipPaths == prevClipPaths) {
	    // Can both be null or undefined
	    return false;
	  }
	
	  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
	    return true;
	  }
	
	  for (var i = 0; i < clipPaths.length; i++) {
	    if (clipPaths[i] !== prevClipPaths[i]) {
	      return true;
	    }
	  }
	}
	
	function doClip(clipPaths, ctx) {
	  for (var i = 0; i < clipPaths.length; i++) {
	    var clipPath = clipPaths[i];
	    clipPath.setTransform(ctx);
	    ctx.beginPath();
	    clipPath.buildPath(ctx, clipPath.shape);
	    ctx.clip(); // Transform back
	
	    clipPath.restoreTransform(ctx);
	  }
	}
	
	function createRoot(width, height) {
	  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
	
	  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';
	  return domRoot;
	}
	/**
	 * @alias module:zrender/Painter
	 * @constructor
	 * @param {HTMLElement} root 绘图容器
	 * @param {module:zrender/Storage} storage
	 * @param {Object} opts
	 */
	
	
	var Painter = function (root, storage, opts) {
	  this.type = 'canvas'; // In node environment using node-canvas
	
	  var singleCanvas = !root.nodeName // In node ?
	  || root.nodeName.toUpperCase() === 'CANVAS';
	  this._opts = opts = util.extend({}, opts || {});
	  /**
	   * @type {number}
	   */
	
	  this.dpr = opts.devicePixelRatio || devicePixelRatio;
	  /**
	   * @type {boolean}
	   * @private
	   */
	
	  this._singleCanvas = singleCanvas;
	  /**
	   * 绘图容器
	   * @type {HTMLElement}
	   */
	
	  this.root = root;
	  var rootStyle = root.style;
	
	  if (rootStyle) {
	    rootStyle['-webkit-tap-highlight-color'] = 'transparent';
	    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';
	    root.innerHTML = '';
	  }
	  /**
	   * @type {module:zrender/Storage}
	   */
	
	
	  this.storage = storage;
	  /**
	   * @type {Array.<number>}
	   * @private
	   */
	
	  var zlevelList = this._zlevelList = [];
	  /**
	   * @type {Object.<string, module:zrender/Layer>}
	   * @private
	   */
	
	  var layers = this._layers = {};
	  /**
	   * @type {Object.<string, Object>}
	   * @type {private}
	   */
	
	  this._layerConfig = {};
	
	  if (!singleCanvas) {
	    this._width = this._getSize(0);
	    this._height = this._getSize(1);
	    var domRoot = this._domRoot = createRoot(this._width, this._height);
	    root.appendChild(domRoot);
	  } else {
	    if (opts.width != null) {
	      root.width = opts.width;
	    }
	
	    if (opts.height != null) {
	      root.height = opts.height;
	    } // Use canvas width and height directly
	
	
	    var width = root.width;
	    var height = root.height;
	    this._width = width;
	    this._height = height; // Create layer if only one given canvas
	    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height
	
	    var mainLayer = new Layer(root, this, 1);
	    mainLayer.initContext(); // FIXME Use canvas width and height
	    // mainLayer.resize(width, height);
	
	    layers[0] = mainLayer;
	    zlevelList.push(0);
	    this._domRoot = root;
	  } // Layers for progressive rendering
	
	
	  this._progressiveLayers = [];
	  /**
	   * @type {module:zrender/Layer}
	   * @private
	   */
	
	  this._hoverlayer;
	  this._hoverElements = [];
	};
	
	Painter.prototype = {
	  constructor: Painter,
	  getType: function () {
	    return 'canvas';
	  },
	
	  /**
	   * If painter use a single canvas
	   * @return {boolean}
	   */
	  isSingleCanvas: function () {
	    return this._singleCanvas;
	  },
	
	  /**
	   * @return {HTMLDivElement}
	   */
	  getViewportRoot: function () {
	    return this._domRoot;
	  },
	  getViewportRootOffset: function () {
	    var viewportRoot = this.getViewportRoot();
	
	    if (viewportRoot) {
	      return {
	        offsetLeft: viewportRoot.offsetLeft || 0,
	        offsetTop: viewportRoot.offsetTop || 0
	      };
	    }
	  },
	
	  /**
	   * 刷新
	   * @param {boolean} [paintAll=false] 强制绘制所有displayable
	   */
	  refresh: function (paintAll) {
	    var list = this.storage.getDisplayList(true);
	    var zlevelList = this._zlevelList;
	
	    this._paintList(list, paintAll); // Paint custum layers
	
	
	    for (var i = 0; i < zlevelList.length; i++) {
	      var z = zlevelList[i];
	      var layer = this._layers[z];
	
	      if (!layer.__builtin__ && layer.refresh) {
	        layer.refresh();
	      }
	    }
	
	    this.refreshHover();
	
	    if (this._progressiveLayers.length) {
	      this._startProgessive();
	    }
	
	    return this;
	  },
	  addHover: function (el, hoverStyle) {
	    if (el.__hoverMir) {
	      return;
	    }
	
	    var elMirror = new el.constructor({
	      style: el.style,
	      shape: el.shape
	    });
	    elMirror.__from = el;
	    el.__hoverMir = elMirror;
	    elMirror.setStyle(hoverStyle);
	
	    this._hoverElements.push(elMirror);
	  },
	  removeHover: function (el) {
	    var elMirror = el.__hoverMir;
	    var hoverElements = this._hoverElements;
	    var idx = util.indexOf(hoverElements, elMirror);
	
	    if (idx >= 0) {
	      hoverElements.splice(idx, 1);
	    }
	
	    el.__hoverMir = null;
	  },
	  clearHover: function (el) {
	    var hoverElements = this._hoverElements;
	
	    for (var i = 0; i < hoverElements.length; i++) {
	      var from = hoverElements[i].__from;
	
	      if (from) {
	        from.__hoverMir = null;
	      }
	    }
	
	    hoverElements.length = 0;
	  },
	  refreshHover: function () {
	    var hoverElements = this._hoverElements;
	    var len = hoverElements.length;
	    var hoverLayer = this._hoverlayer;
	    hoverLayer && hoverLayer.clear();
	
	    if (!len) {
	      return;
	    }
	
	    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel
	    // FIXME?
	
	    if (!hoverLayer) {
	      hoverLayer = this._hoverlayer = this.getLayer(1e5);
	    }
	
	    var scope = {};
	    hoverLayer.ctx.save();
	
	    for (var i = 0; i < len;) {
	      var el = hoverElements[i];
	      var originalEl = el.__from; // Original el is removed
	      // PENDING
	
	      if (!(originalEl && originalEl.__zr)) {
	        hoverElements.splice(i, 1);
	        originalEl.__hoverMir = null;
	        len--;
	        continue;
	      }
	
	      i++; // Use transform
	      // FIXME style and shape ?
	
	      if (!originalEl.invisible) {
	        el.transform = originalEl.transform;
	        el.invTransform = originalEl.invTransform;
	        el.__clipPaths = originalEl.__clipPaths; // el.
	
	        this._doPaintEl(el, hoverLayer, true, scope);
	      }
	    }
	
	    hoverLayer.ctx.restore();
	  },
	  _startProgessive: function () {
	    var self = this;
	
	    if (!self._furtherProgressive) {
	      return;
	    } // Use a token to stop progress steps triggered by
	    // previous zr.refresh calling.
	
	
	    var token = self._progressiveToken = +new Date();
	    self._progress++;
	    requestAnimationFrame(step);
	
	    function step() {
	      // In case refreshed or disposed
	      if (token === self._progressiveToken && self.storage) {
	        self._doPaintList(self.storage.getDisplayList());
	
	        if (self._furtherProgressive) {
	          self._progress++;
	          requestAnimationFrame(step);
	        } else {
	          self._progressiveToken = -1;
	        }
	      }
	    }
	  },
	  _clearProgressive: function () {
	    this._progressiveToken = -1;
	    this._progress = 0;
	    util.each(this._progressiveLayers, function (layer) {
	      layer.__dirty && layer.clear();
	    });
	  },
	  _paintList: function (list, paintAll) {
	    if (paintAll == null) {
	      paintAll = false;
	    }
	
	    this._updateLayerStatus(list);
	
	    this._clearProgressive();
	
	    this.eachBuiltinLayer(preProcessLayer);
	
	    this._doPaintList(list, paintAll);
	
	    this.eachBuiltinLayer(postProcessLayer);
	  },
	  _doPaintList: function (list, paintAll) {
	    var currentLayer;
	    var currentZLevel;
	    var ctx; // var invTransform = [];
	
	    var scope;
	    var progressiveLayerIdx = 0;
	    var currentProgressiveLayer;
	    var width = this._width;
	    var height = this._height;
	    var layerProgress;
	    var frame = this._progress;
	
	    function flushProgressiveLayer(layer) {
	      var dpr = ctx.dpr || 1;
	      ctx.save();
	      ctx.globalAlpha = 1;
	      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame
	
	      currentLayer.__dirty = true;
	      ctx.setTransform(1, 0, 0, 1, 0, 0);
	      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
	      ctx.restore();
	    }
	
	    for (var i = 0, l = list.length; i < l; i++) {
	      var el = list[i];
	      var elZLevel = this._singleCanvas ? 0 : el.zlevel;
	      var elFrame = el.__frame; // Flush at current context
	      // PENDING
	
	      if (elFrame < 0 && currentProgressiveLayer) {
	        flushProgressiveLayer(currentProgressiveLayer);
	        currentProgressiveLayer = null;
	      } // Change draw layer
	
	
	      if (currentZLevel !== elZLevel) {
	        if (ctx) {
	          ctx.restore();
	        } // Reset scope
	
	
	        scope = {}; // Only 0 zlevel if only has one canvas
	
	        currentZLevel = elZLevel;
	        currentLayer = this.getLayer(currentZLevel);
	
	        if (!currentLayer.__builtin__) {
	          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);
	        }
	
	        ctx = currentLayer.ctx;
	        ctx.save(); // Reset the count
	
	        currentLayer.__unusedCount = 0;
	
	        if (currentLayer.__dirty || paintAll) {
	          currentLayer.clear();
	        }
	      }
	
	      if (!(currentLayer.__dirty || paintAll)) {
	        continue;
	      }
	
	      if (elFrame >= 0) {
	        // Progressive layer changed
	        if (!currentProgressiveLayer) {
	          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];
	          currentProgressiveLayer.ctx.save();
	          currentProgressiveLayer.renderScope = {};
	
	          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {
	            // flushProgressiveLayer(currentProgressiveLayer);
	            // Quick jump all progressive elements
	            // All progressive element are not dirty, jump over and flush directly
	            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;
	
	            continue;
	          }
	
	          layerProgress = currentProgressiveLayer.__progress;
	
	          if (!currentProgressiveLayer.__dirty) {
	            // Keep rendering
	            frame = layerProgress;
	          }
	
	          currentProgressiveLayer.__progress = frame + 1;
	        }
	
	        if (elFrame === frame) {
	          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
	        }
	      } else {
	        this._doPaintEl(el, currentLayer, paintAll, scope);
	      }
	
	      el.__dirty = false;
	    }
	
	    if (currentProgressiveLayer) {
	      flushProgressiveLayer(currentProgressiveLayer);
	    } // Restore the lastLayer ctx
	
	
	    ctx && ctx.restore(); // If still has clipping state
	    // if (scope.prevElClipPaths) {
	    //     ctx.restore();
	    // }
	
	    this._furtherProgressive = false;
	    util.each(this._progressiveLayers, function (layer) {
	      if (layer.__maxProgress >= layer.__progress) {
	        this._furtherProgressive = true;
	      }
	    }, this);
	  },
	  _doPaintEl: function (el, currentLayer, forcePaint, scope) {
	    var ctx = currentLayer.ctx;
	    var m = el.transform;
	
	    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element
	    !el.invisible // Ignore transparent element
	    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas
	    // Draw a scale 0 element can cause all following draw wrong
	    // And setTransform with scale 0 will cause set back transform failed.
	    && !(m && !m[0] && !m[3]) // Ignore culled element
	    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
	      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements
	
	      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {
	        // If has previous clipping state, restore from it
	        if (scope.prevElClipPaths) {
	          scope.prevClipLayer.ctx.restore();
	          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored
	
	          scope.prevEl = null;
	        } // New clipping state
	
	
	        if (clipPaths) {
	          ctx.save();
	          doClip(clipPaths, ctx);
	          scope.prevClipLayer = currentLayer;
	          scope.prevElClipPaths = clipPaths;
	        }
	      }
	
	      el.beforeBrush && el.beforeBrush(ctx);
	      el.brush(ctx, scope.prevEl || null);
	      scope.prevEl = el;
	      el.afterBrush && el.afterBrush(ctx);
	    }
	  },
	
	  /**
	   * 获取 zlevel 所在层，如果不存在则会创建一个新的层
	   * @param {number} zlevel
	   * @return {module:zrender/Layer}
	   */
	  getLayer: function (zlevel) {
	    if (this._singleCanvas) {
	      return this._layers[0];
	    }
	
	    var layer = this._layers[zlevel];
	
	    if (!layer) {
	      // Create a new layer
	      layer = new Layer('zr_' + zlevel, this, this.dpr);
	      layer.__builtin__ = true;
	
	      if (this._layerConfig[zlevel]) {
	        util.merge(layer, this._layerConfig[zlevel], true);
	      }
	
	      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document
	      // Or excanvas will get 0px clientWidth and clientHeight
	
	      layer.initContext();
	    }
	
	    return layer;
	  },
	  insertLayer: function (zlevel, layer) {
	    var layersMap = this._layers;
	    var zlevelList = this._zlevelList;
	    var len = zlevelList.length;
	    var prevLayer = null;
	    var i = -1;
	    var domRoot = this._domRoot;
	
	    if (layersMap[zlevel]) {
	      log('ZLevel ' + zlevel + ' has been used already');
	      return;
	    } // Check if is a valid layer
	
	
	    if (!isLayerValid(layer)) {
	      log('Layer of zlevel ' + zlevel + ' is not valid');
	      return;
	    }
	
	    if (len > 0 && zlevel > zlevelList[0]) {
	      for (i = 0; i < len - 1; i++) {
	        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
	          break;
	        }
	      }
	
	      prevLayer = layersMap[zlevelList[i]];
	    }
	
	    zlevelList.splice(i + 1, 0, zlevel);
	    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.
	    // (It can be a WebGL layer and assigned to a ZImage element)
	    // But it still under management of zrender.
	
	    if (!layer.virtual) {
	      if (prevLayer) {
	        var prevDom = prevLayer.dom;
	
	        if (prevDom.nextSibling) {
	          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
	        } else {
	          domRoot.appendChild(layer.dom);
	        }
	      } else {
	        if (domRoot.firstChild) {
	          domRoot.insertBefore(layer.dom, domRoot.firstChild);
	        } else {
	          domRoot.appendChild(layer.dom);
	        }
	      }
	    }
	  },
	  // Iterate each layer
	  eachLayer: function (cb, context) {
	    var zlevelList = this._zlevelList;
	    var z;
	    var i;
	
	    for (i = 0; i < zlevelList.length; i++) {
	      z = zlevelList[i];
	      cb.call(context, this._layers[z], z);
	    }
	  },
	  // Iterate each buildin layer
	  eachBuiltinLayer: function (cb, context) {
	    var zlevelList = this._zlevelList;
	    var layer;
	    var z;
	    var i;
	
	    for (i = 0; i < zlevelList.length; i++) {
	      z = zlevelList[i];
	      layer = this._layers[z];
	
	      if (layer.__builtin__) {
	        cb.call(context, layer, z);
	      }
	    }
	  },
	  // Iterate each other layer except buildin layer
	  eachOtherLayer: function (cb, context) {
	    var zlevelList = this._zlevelList;
	    var layer;
	    var z;
	    var i;
	
	    for (i = 0; i < zlevelList.length; i++) {
	      z = zlevelList[i];
	      layer = this._layers[z];
	
	      if (!layer.__builtin__) {
	        cb.call(context, layer, z);
	      }
	    }
	  },
	
	  /**
	   * 获取所有已创建的层
	   * @param {Array.<module:zrender/Layer>} [prevLayer]
	   */
	  getLayers: function () {
	    return this._layers;
	  },
	  _updateLayerStatus: function (list) {
	    var layers = this._layers;
	    var progressiveLayers = this._progressiveLayers;
	    var elCountsLastFrame = {};
	    var progressiveElCountsLastFrame = {};
	    this.eachBuiltinLayer(function (layer, z) {
	      elCountsLastFrame[z] = layer.elCount;
	      layer.elCount = 0;
	      layer.__dirty = false;
	    });
	    util.each(progressiveLayers, function (layer, idx) {
	      progressiveElCountsLastFrame[idx] = layer.elCount;
	      layer.elCount = 0;
	      layer.__dirty = false;
	    });
	    var progressiveLayerCount = 0;
	    var currentProgressiveLayer;
	    var lastProgressiveKey;
	    var frameCount = 0;
	
	    for (var i = 0, l = list.length; i < l; i++) {
	      var el = list[i];
	      var zlevel = this._singleCanvas ? 0 : el.zlevel;
	      var layer = layers[zlevel];
	      var elProgress = el.progressive;
	
	      if (layer) {
	        layer.elCount++;
	        layer.__dirty = layer.__dirty || el.__dirty;
	      } /////// Update progressive
	
	
	      if (elProgress >= 0) {
	        // Fix wrong progressive sequence problem.
	        if (lastProgressiveKey !== elProgress) {
	          lastProgressiveKey = elProgress;
	          frameCount++;
	        }
	
	        var elFrame = el.__frame = frameCount - 1;
	
	        if (!currentProgressiveLayer) {
	          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
	          currentProgressiveLayer = progressiveLayers[idx];
	
	          if (!currentProgressiveLayer) {
	            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);
	            currentProgressiveLayer.initContext();
	          }
	
	          currentProgressiveLayer.__maxProgress = 0;
	        }
	
	        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
	        currentProgressiveLayer.elCount++;
	        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);
	
	        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
	          // Should keep rendering this  layer because progressive rendering is not finished yet
	          layer.__dirty = true;
	        }
	      } else {
	        el.__frame = -1;
	
	        if (currentProgressiveLayer) {
	          currentProgressiveLayer.__nextIdxNotProg = i;
	          progressiveLayerCount++;
	          currentProgressiveLayer = null;
	        }
	      }
	    }
	
	    if (currentProgressiveLayer) {
	      progressiveLayerCount++;
	      currentProgressiveLayer.__nextIdxNotProg = i;
	    } // 层中的元素数量有发生变化
	
	
	    this.eachBuiltinLayer(function (layer, z) {
	      if (elCountsLastFrame[z] !== layer.elCount) {
	        layer.__dirty = true;
	      }
	    });
	    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
	    util.each(progressiveLayers, function (layer, idx) {
	      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
	        el.__dirty = true;
	      }
	
	      if (layer.__dirty) {
	        layer.__progress = 0;
	      }
	    });
	  },
	
	  /**
	   * 清除hover层外所有内容
	   */
	  clear: function () {
	    this.eachBuiltinLayer(this._clearLayer);
	    return this;
	  },
	  _clearLayer: function (layer) {
	    layer.clear();
	  },
	
	  /**
	   * 修改指定zlevel的绘制参数
	   *
	   * @param {string} zlevel
	   * @param {Object} config 配置对象
	   * @param {string} [config.clearColor=0] 每次清空画布的颜色
	   * @param {string} [config.motionBlur=false] 是否开启动态模糊
	   * @param {number} [config.lastFrameAlpha=0.7]
	   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	   */
	  configLayer: function (zlevel, config) {
	    if (config) {
	      var layerConfig = this._layerConfig;
	
	      if (!layerConfig[zlevel]) {
	        layerConfig[zlevel] = config;
	      } else {
	        util.merge(layerConfig[zlevel], config, true);
	      }
	
	      var layer = this._layers[zlevel];
	
	      if (layer) {
	        util.merge(layer, layerConfig[zlevel], true);
	      }
	    }
	  },
	
	  /**
	   * 删除指定层
	   * @param {number} zlevel 层所在的zlevel
	   */
	  delLayer: function (zlevel) {
	    var layers = this._layers;
	    var zlevelList = this._zlevelList;
	    var layer = layers[zlevel];
	
	    if (!layer) {
	      return;
	    }
	
	    layer.dom.parentNode.removeChild(layer.dom);
	    delete layers[zlevel];
	    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
	  },
	
	  /**
	   * 区域大小变化后重绘
	   */
	  resize: function (width, height) {
	    var domRoot = this._domRoot; // FIXME Why ?
	
	    domRoot.style.display = 'none'; // Save input w/h
	
	    var opts = this._opts;
	    width != null && (opts.width = width);
	    height != null && (opts.height = height);
	    width = this._getSize(0);
	    height = this._getSize(1);
	    domRoot.style.display = ''; // 优化没有实际改变的resize
	
	    if (this._width != width || height != this._height) {
	      domRoot.style.width = width + 'px';
	      domRoot.style.height = height + 'px';
	
	      for (var id in this._layers) {
	        if (this._layers.hasOwnProperty(id)) {
	          this._layers[id].resize(width, height);
	        }
	      }
	
	      util.each(this._progressiveLayers, function (layer) {
	        layer.resize(width, height);
	      });
	      this.refresh(true);
	    }
	
	    this._width = width;
	    this._height = height;
	    return this;
	  },
	
	  /**
	   * 清除单独的一个层
	   * @param {number} zlevel
	   */
	  clearLayer: function (zlevel) {
	    var layer = this._layers[zlevel];
	
	    if (layer) {
	      layer.clear();
	    }
	  },
	
	  /**
	   * 释放
	   */
	  dispose: function () {
	    this.root.innerHTML = '';
	    this.root = this.storage = this._domRoot = this._layers = null;
	  },
	
	  /**
	   * Get canvas which has all thing rendered
	   * @param {Object} opts
	   * @param {string} [opts.backgroundColor]
	   * @param {number} [opts.pixelRatio]
	   */
	  getRenderedCanvas: function (opts) {
	    opts = opts || {};
	
	    if (this._singleCanvas) {
	      return this._layers[0].dom;
	    }
	
	    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
	    imageLayer.initContext();
	    imageLayer.clearColor = opts.backgroundColor;
	    imageLayer.clear();
	    var displayList = this.storage.getDisplayList(true);
	    var scope = {};
	    var zlevel;
	    var self = this;
	
	    function findAndDrawOtherLayer(smaller, larger) {
	      var zlevelList = self._zlevelList;
	
	      if (smaller == null) {
	        smaller = -Infinity;
	      }
	
	      var intermediateLayer;
	
	      for (var i = 0; i < zlevelList.length; i++) {
	        var z = zlevelList[i];
	        var layer = self._layers[z];
	
	        if (!layer.__builtin__ && z > smaller && z < larger) {
	          intermediateLayer = layer;
	          break;
	        }
	      }
	
	      if (intermediateLayer && intermediateLayer.renderToCanvas) {
	        imageLayer.ctx.save();
	        intermediateLayer.renderToCanvas(imageLayer.ctx);
	        imageLayer.ctx.restore();
	      }
	    }
	
	    for (var i = 0; i < displayList.length; i++) {
	      var el = displayList[i];
	
	      if (el.zlevel !== zlevel) {
	        findAndDrawOtherLayer(zlevel, el.zlevel);
	        zlevel = el.zlevel;
	      }
	
	      this._doPaintEl(el, imageLayer, true, scope);
	    }
	
	    findAndDrawOtherLayer(zlevel, Infinity);
	    return imageLayer.dom;
	  },
	
	  /**
	   * 获取绘图区域宽度
	   */
	  getWidth: function () {
	    return this._width;
	  },
	
	  /**
	   * 获取绘图区域高度
	   */
	  getHeight: function () {
	    return this._height;
	  },
	  _getSize: function (whIdx) {
	    var opts = this._opts;
	    var wh = ['width', 'height'][whIdx];
	    var cwh = ['clientWidth', 'clientHeight'][whIdx];
	    var plt = ['paddingLeft', 'paddingTop'][whIdx];
	    var prb = ['paddingRight', 'paddingBottom'][whIdx];
	
	    if (opts[wh] != null && opts[wh] !== 'auto') {
	      return parseFloat(opts[wh]);
	    }
	
	    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.
	
	    var stl = document.defaultView.getComputedStyle(root);
	    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
	  },
	  pathToImage: function (path, dpr) {
	    dpr = dpr || this.dpr;
	    var canvas = document.createElement('canvas');
	    var ctx = canvas.getContext('2d');
	    var rect = path.getBoundingRect();
	    var style = path.style;
	    var shadowBlurSize = style.shadowBlur;
	    var shadowOffsetX = style.shadowOffsetX;
	    var shadowOffsetY = style.shadowOffsetY;
	    var lineWidth = style.hasStroke() ? style.lineWidth : 0;
	    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
	    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
	    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
	    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
	    var width = rect.width + leftMargin + rightMargin;
	    var height = rect.height + topMargin + bottomMargin;
	    canvas.width = width * dpr;
	    canvas.height = height * dpr;
	    ctx.scale(dpr, dpr);
	    ctx.clearRect(0, 0, width, height);
	    ctx.dpr = dpr;
	    var pathTransform = {
	      position: path.position,
	      rotation: path.rotation,
	      scale: path.scale
	    };
	    path.position = [leftMargin - rect.x, topMargin - rect.y];
	    path.rotation = 0;
	    path.scale = [1, 1];
	    path.updateTransform();
	
	    if (path) {
	      path.brush(ctx);
	    }
	
	    var ImageShape = Image;
	    var imgShape = new ImageShape({
	      style: {
	        x: 0,
	        y: 0,
	        image: canvas
	      }
	    });
	
	    if (pathTransform.position != null) {
	      imgShape.position = path.position = pathTransform.position;
	    }
	
	    if (pathTransform.rotation != null) {
	      imgShape.rotation = path.rotation = pathTransform.rotation;
	    }
	
	    if (pathTransform.scale != null) {
	      imgShape.scale = path.scale = pathTransform.scale;
	    }
	
	    return imgShape;
	  }
	};
	var _default = Painter;
	module.exports = _default;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(5);
	
	var _config = __webpack_require__(23);
	
	var devicePixelRatio = _config.devicePixelRatio;
	
	var Style = __webpack_require__(9);
	
	var Pattern = __webpack_require__(40);
	
	/**
	 * @module zrender/Layer
	 * @author pissang(https://www.github.com/pissang)
	 */
	function returnFalse() {
	  return false;
	}
	/**
	 * 创建dom
	 *
	 * @inner
	 * @param {string} id dom id 待用
	 * @param {Painter} painter painter instance
	 * @param {number} number
	 */
	
	
	function createDom(id, painter, dpr) {
	  var newDom = util.createCanvas();
	  var width = painter.getWidth();
	  var height = painter.getHeight();
	  var newDomStyle = newDom.style; // 没append呢，请原谅我这样写，清晰~
	
	  newDomStyle.position = 'absolute';
	  newDomStyle.left = 0;
	  newDomStyle.top = 0;
	  newDomStyle.width = width + 'px';
	  newDomStyle.height = height + 'px';
	  newDom.width = width * dpr;
	  newDom.height = height * dpr; // id不作为索引用，避免可能造成的重名，定义为私有属性
	
	  newDom.setAttribute('data-zr-dom-id', id);
	  return newDom;
	}
	/**
	 * @alias module:zrender/Layer
	 * @constructor
	 * @extends module:zrender/mixin/Transformable
	 * @param {string} id
	 * @param {module:zrender/Painter} painter
	 * @param {number} [dpr]
	 */
	
	
	var Layer = function (id, painter, dpr) {
	  var dom;
	  dpr = dpr || devicePixelRatio;
	
	  if (typeof id === 'string') {
	    dom = createDom(id, painter, dpr);
	  } // Not using isDom because in node it will return false
	  else if (util.isObject(id)) {
	      dom = id;
	      id = dom.id;
	    }
	
	  this.id = id;
	  this.dom = dom;
	  var domStyle = dom.style;
	
	  if (domStyle) {
	    // Not in node
	    dom.onselectstart = returnFalse; // 避免页面选中的尴尬
	
	    domStyle['-webkit-user-select'] = 'none';
	    domStyle['user-select'] = 'none';
	    domStyle['-webkit-touch-callout'] = 'none';
	    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	    domStyle['padding'] = 0;
	    domStyle['margin'] = 0;
	    domStyle['border-width'] = 0;
	  }
	
	  this.domBack = null;
	  this.ctxBack = null;
	  this.painter = painter;
	  this.config = null; // Configs
	
	  /**
	   * 每次清空画布的颜色
	   * @type {string}
	   * @default 0
	   */
	
	  this.clearColor = 0;
	  /**
	   * 是否开启动态模糊
	   * @type {boolean}
	   * @default false
	   */
	
	  this.motionBlur = false;
	  /**
	   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	   * @type {number}
	   * @default 0.7
	   */
	
	  this.lastFrameAlpha = 0.7;
	  /**
	   * Layer dpr
	   * @type {number}
	   */
	
	  this.dpr = dpr;
	};
	
	Layer.prototype = {
	  constructor: Layer,
	  elCount: 0,
	  __dirty: true,
	  initContext: function () {
	    this.ctx = this.dom.getContext('2d');
	    this.ctx.__currentValues = {};
	    this.ctx.dpr = this.dpr;
	  },
	  createBackBuffer: function () {
	    var dpr = this.dpr;
	    this.domBack = createDom('back-' + this.id, this.painter, dpr);
	    this.ctxBack = this.domBack.getContext('2d');
	    this.ctxBack.__currentValues = {};
	
	    if (dpr != 1) {
	      this.ctxBack.scale(dpr, dpr);
	    }
	  },
	
	  /**
	   * @param  {number} width
	   * @param  {number} height
	   */
	  resize: function (width, height) {
	    var dpr = this.dpr;
	    var dom = this.dom;
	    var domStyle = dom.style;
	    var domBack = this.domBack;
	    domStyle.width = width + 'px';
	    domStyle.height = height + 'px';
	    dom.width = width * dpr;
	    dom.height = height * dpr;
	
	    if (domBack) {
	      domBack.width = width * dpr;
	      domBack.height = height * dpr;
	
	      if (dpr != 1) {
	        this.ctxBack.scale(dpr, dpr);
	      }
	    }
	  },
	
	  /**
	   * 清空该层画布
	   * @param {boolean} clearAll Clear all with out motion blur
	   */
	  clear: function (clearAll) {
	    var dom = this.dom;
	    var ctx = this.ctx;
	    var width = dom.width;
	    var height = dom.height;
	    var clearColor = this.clearColor;
	    var haveMotionBLur = this.motionBlur && !clearAll;
	    var lastFrameAlpha = this.lastFrameAlpha;
	    var dpr = this.dpr;
	
	    if (haveMotionBLur) {
	      if (!this.domBack) {
	        this.createBackBuffer();
	      }
	
	      this.ctxBack.globalCompositeOperation = 'copy';
	      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
	    }
	
	    ctx.clearRect(0, 0, width, height);
	
	    if (clearColor) {
	      var clearColorGradientOrPattern; // Gradient
	
	      if (clearColor.colorStops) {
	        // Cache canvas gradient
	        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
	          x: 0,
	          y: 0,
	          width: width,
	          height: height
	        });
	        clearColor.__canvasGradient = clearColorGradientOrPattern;
	      } // Pattern
	      else if (clearColor.image) {
	          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
	        }
	
	      ctx.save();
	      ctx.fillStyle = clearColorGradientOrPattern || clearColor;
	      ctx.fillRect(0, 0, width, height);
	      ctx.restore();
	    }
	
	    if (haveMotionBLur) {
	      var domBack = this.domBack;
	      ctx.save();
	      ctx.globalAlpha = lastFrameAlpha;
	      ctx.drawImage(domBack, 0, 0, width, height);
	      ctx.restore();
	    }
	  }
	};
	var _default = Layer;
	module.exports = _default;

/***/ }),
/* 75 */
/***/ (function(module, exports) {

	var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
	window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {
	  setTimeout(func, 16);
	};
	
	module.exports = _default;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(5);
	
	var _event = __webpack_require__(77);
	
	var Dispatcher = _event.Dispatcher;
	
	var requestAnimationFrame = __webpack_require__(75);
	
	var Animator = __webpack_require__(17);
	
	/**
	 * 动画主类, 调度和管理所有动画控制器
	 *
	 * @module zrender/animation/Animation
	 * @author pissang(https://github.com/pissang)
	 */
	// TODO Additive animation
	// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
	// https://developer.apple.com/videos/wwdc2014/#236
	
	/**
	 * @typedef {Object} IZRenderStage
	 * @property {Function} update
	 */
	
	/**
	 * @alias module:zrender/animation/Animation
	 * @constructor
	 * @param {Object} [options]
	 * @param {Function} [options.onframe]
	 * @param {IZRenderStage} [options.stage]
	 * @example
	 *     var animation = new Animation();
	 *     var obj = {
	 *         x: 100,
	 *         y: 100
	 *     };
	 *     animation.animate(node.position)
	 *         .when(1000, {
	 *             x: 500,
	 *             y: 500
	 *         })
	 *         .when(2000, {
	 *             x: 100,
	 *             y: 100
	 *         })
	 *         .start('spline');
	 */
	var Animation = function (options) {
	  options = options || {};
	  this.stage = options.stage || {};
	
	  this.onframe = options.onframe || function () {}; // private properties
	
	
	  this._clips = [];
	  this._running = false;
	  this._time;
	  this._pausedTime;
	  this._pauseStart;
	  this._paused = false;
	  Dispatcher.call(this);
	};
	
	Animation.prototype = {
	  constructor: Animation,
	
	  /**
	   * 添加 clip
	   * @param {module:zrender/animation/Clip} clip
	   */
	  addClip: function (clip) {
	    this._clips.push(clip);
	  },
	
	  /**
	   * 添加 animator
	   * @param {module:zrender/animation/Animator} animator
	   */
	  addAnimator: function (animator) {
	    animator.animation = this;
	    var clips = animator.getClips();
	
	    for (var i = 0; i < clips.length; i++) {
	      this.addClip(clips[i]);
	    }
	  },
	
	  /**
	   * 删除动画片段
	   * @param {module:zrender/animation/Clip} clip
	   */
	  removeClip: function (clip) {
	    var idx = util.indexOf(this._clips, clip);
	
	    if (idx >= 0) {
	      this._clips.splice(idx, 1);
	    }
	  },
	
	  /**
	   * 删除动画片段
	   * @param {module:zrender/animation/Animator} animator
	   */
	  removeAnimator: function (animator) {
	    var clips = animator.getClips();
	
	    for (var i = 0; i < clips.length; i++) {
	      this.removeClip(clips[i]);
	    }
	
	    animator.animation = null;
	  },
	  _update: function () {
	    var time = new Date().getTime() - this._pausedTime;
	
	    var delta = time - this._time;
	    var clips = this._clips;
	    var len = clips.length;
	    var deferredEvents = [];
	    var deferredClips = [];
	
	    for (var i = 0; i < len; i++) {
	      var clip = clips[i];
	      var e = clip.step(time, delta); // Throw out the events need to be called after
	      // stage.update, like destroy
	
	      if (e) {
	        deferredEvents.push(e);
	        deferredClips.push(clip);
	      }
	    } // Remove the finished clip
	
	
	    for (var i = 0; i < len;) {
	      if (clips[i]._needsRemove) {
	        clips[i] = clips[len - 1];
	        clips.pop();
	        len--;
	      } else {
	        i++;
	      }
	    }
	
	    len = deferredEvents.length;
	
	    for (var i = 0; i < len; i++) {
	      deferredClips[i].fire(deferredEvents[i]);
	    }
	
	    this._time = time;
	    this.onframe(delta);
	    this.trigger('frame', delta);
	
	    if (this.stage.update) {
	      this.stage.update();
	    }
	  },
	  _startLoop: function () {
	    var self = this;
	    this._running = true;
	
	    function step() {
	      if (self._running) {
	        requestAnimationFrame(step);
	        !self._paused && self._update();
	      }
	    }
	
	    requestAnimationFrame(step);
	  },
	
	  /**
	   * 开始运行动画
	   */
	  start: function () {
	    this._time = new Date().getTime();
	    this._pausedTime = 0;
	
	    this._startLoop();
	  },
	
	  /**
	   * 停止运行动画
	   */
	  stop: function () {
	    this._running = false;
	  },
	
	  /**
	   * Pause
	   */
	  pause: function () {
	    if (!this._paused) {
	      this._pauseStart = new Date().getTime();
	      this._paused = true;
	    }
	  },
	
	  /**
	   * Resume
	   */
	  resume: function () {
	    if (this._paused) {
	      this._pausedTime += new Date().getTime() - this._pauseStart;
	      this._paused = false;
	    }
	  },
	
	  /**
	   * 清除所有动画片段
	   */
	  clear: function () {
	    this._clips = [];
	  },
	
	  /**
	   * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
	   * @param  {Object} target
	   * @param  {Object} options
	   * @param  {boolean} [options.loop=false] 是否循环播放动画
	   * @param  {Function} [options.getter=null]
	   *         如果指定getter函数，会通过getter函数取属性值
	   * @param  {Function} [options.setter=null]
	   *         如果指定setter函数，会通过setter函数设置属性值
	   * @return {module:zrender/animation/Animation~Animator}
	   */
	  // TODO Gap
	  animate: function (target, options) {
	    options = options || {};
	    var animator = new Animator(target, options.loop, options.getter, options.setter);
	    this.addAnimator(animator);
	    return animator;
	  }
	};
	util.mixin(Animation, Dispatcher);
	var _default = Animation;
	module.exports = _default;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	var Eventful = __webpack_require__(12);
	
	exports.Dispatcher = Eventful;
	
	var env = __webpack_require__(50);
	
	/**
	 * 事件辅助类
	 * @module zrender/core/event
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;
	var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
	
	function getBoundingClientRect(el) {
	  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
	  return el.getBoundingClientRect ? el.getBoundingClientRect() : {
	    left: 0,
	    top: 0
	  };
	} // `calculate` is optional, default false
	
	
	function clientToLocal(el, e, out, calculate) {
	  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative
	  // to the padding edge of the target element. The only browser using this convention
	  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
	  // not support the properties.
	  // (see http://www.jacklmoore.com/notes/mouse-position/)
	  // In zr painter.dom, padding edge equals to border edge.
	  // FIXME
	  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and
	  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y
	  // is too complex. So css-transfrom dont support in this case temporarily.
	
	  if (calculate || !env.canvasSupported) {
	    defaultGetZrXY(el, e, out);
	  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
	  // ancestor element, so we should make sure el is positioned (e.g., not position:static).
	  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
	  // zoom-factor, overflow / opacity layers, transforms ...)
	  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
	  // <https://bugs.jquery.com/ticket/8523#comment:14>
	  // BTW3, In ff, offsetX/offsetY is always 0.
	  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
	      out.zrX = e.layerX;
	      out.zrY = e.layerY;
	    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
	    else if (e.offsetX != null) {
	        out.zrX = e.offsetX;
	        out.zrY = e.offsetY;
	      } // For some other device, e.g., IOS safari.
	      else {
	          defaultGetZrXY(el, e, out);
	        }
	
	  return out;
	}
	
	function defaultGetZrXY(el, e, out) {
	  // This well-known method below does not support css transform.
	  var box = getBoundingClientRect(el);
	  out.zrX = e.clientX - box.left;
	  out.zrY = e.clientY - box.top;
	}
	/**
	 * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.
	 * `calculate` is optional, default false.
	 */
	
	
	function normalizeEvent(el, e, calculate) {
	  e = e || window.event;
	
	  if (e.zrX != null) {
	    return e;
	  }
	
	  var eventType = e.type;
	  var isTouch = eventType && eventType.indexOf('touch') >= 0;
	
	  if (!isTouch) {
	    clientToLocal(el, e, e, calculate);
	    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
	  } else {
	    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];
	    touch && clientToLocal(el, touch, e, calculate);
	  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;
	  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js
	  // If e.which has been defined, if may be readonly,
	  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which
	
	
	  var button = e.button;
	
	  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
	    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
	  }
	
	  return e;
	}
	
	function addEventListener(el, name, handler) {
	  if (isDomLevel2) {
	    el.addEventListener(name, handler);
	  } else {
	    el.attachEvent('on' + name, handler);
	  }
	}
	
	function removeEventListener(el, name, handler) {
	  if (isDomLevel2) {
	    el.removeEventListener(name, handler);
	  } else {
	    el.detachEvent('on' + name, handler);
	  }
	}
	/**
	 * preventDefault and stopPropagation.
	 * Notice: do not do that in zrender. Upper application
	 * do that if necessary.
	 *
	 * @memberOf module:zrender/core/event
	 * @method
	 * @param {Event} e : event对象
	 */
	
	
	var stop = isDomLevel2 ? function (e) {
	  e.preventDefault();
	  e.stopPropagation();
	  e.cancelBubble = true;
	} : function (e) {
	  e.returnValue = false;
	  e.cancelBubble = true;
	};
	
	function notLeftMouse(e) {
	  // If e.which is undefined, considered as left mouse event.
	  return e.which > 1;
	} // 做向上兼容
	
	
	exports.clientToLocal = clientToLocal;
	exports.normalizeEvent = normalizeEvent;
	exports.addEventListener = addEventListener;
	exports.removeEventListener = removeEventListener;
	exports.stop = stop;
	exports.notLeftMouse = notLeftMouse;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	var _event = __webpack_require__(77);
	
	var addEventListener = _event.addEventListener;
	var removeEventListener = _event.removeEventListener;
	var normalizeEvent = _event.normalizeEvent;
	
	var zrUtil = __webpack_require__(5);
	
	var Eventful = __webpack_require__(12);
	
	var env = __webpack_require__(50);
	
	var GestureMgr = __webpack_require__(79);
	
	var TOUCH_CLICK_DELAY = 300;
	var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
	var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];
	var pointerEventNames = {
	  pointerdown: 1,
	  pointerup: 1,
	  pointermove: 1,
	  pointerout: 1
	};
	var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {
	  var nm = name.replace('mouse', 'pointer');
	  return pointerEventNames[nm] ? nm : name;
	});
	
	function eventNameFix(name) {
	  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;
	}
	
	function processGesture(proxy, event, stage) {
	  var gestureMgr = proxy._gestureMgr;
	  stage === 'start' && gestureMgr.clear();
	  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);
	  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.
	
	  if (gestureInfo) {
	    var type = gestureInfo.type;
	    event.gestureEvent = type;
	    proxy.handler.dispatchToElement({
	      target: gestureInfo.target
	    }, type, gestureInfo.event);
	  }
	} // function onMSGestureChange(proxy, event) {
	//     if (event.translationX || event.translationY) {
	//         // mousemove is carried by MSGesture to reduce the sensitivity.
	//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
	//     }
	//     if (event.scale !== 1) {
	//         event.pinchX = event.offsetX;
	//         event.pinchY = event.offsetY;
	//         event.pinchScale = event.scale;
	//         proxy.handler.dispatchToElement(event.target, 'pinch', event);
	//     }
	// }
	
	/**
	 * Prevent mouse event from being dispatched after Touch Events action
	 * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
	 * 1. Mobile browsers dispatch mouse events 300ms after touchend.
	 * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
	 * Result: Blocking Mouse Events for 700ms.
	 */
	
	
	function setTouchTimer(instance) {
	  instance._touching = true;
	  clearTimeout(instance._touchTimer);
	  instance._touchTimer = setTimeout(function () {
	    instance._touching = false;
	  }, 700);
	}
	
	var domHandlers = {
	  /**
	   * Mouse move handler
	   * @inner
	   * @param {Event} event
	   */
	  mousemove: function (event) {
	    event = normalizeEvent(this.dom, event);
	    this.trigger('mousemove', event);
	  },
	
	  /**
	   * Mouse out handler
	   * @inner
	   * @param {Event} event
	   */
	  mouseout: function (event) {
	    event = normalizeEvent(this.dom, event);
	    var element = event.toElement || event.relatedTarget;
	
	    if (element != this.dom) {
	      while (element && element.nodeType != 9) {
	        // 忽略包含在root中的dom引起的mouseOut
	        if (element === this.dom) {
	          return;
	        }
	
	        element = element.parentNode;
	      }
	    }
	
	    this.trigger('mouseout', event);
	  },
	
	  /**
	   * Touch开始响应函数
	   * @inner
	   * @param {Event} event
	   */
	  touchstart: function (event) {
	    // Default mouse behaviour should not be disabled here.
	    // For example, page may needs to be slided.
	    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
	    // mouse event in upper applicatoin.
	
	    event.zrByTouch = true;
	    this._lastTouchMoment = new Date();
	    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should
	    // be triggered, and must before `mousedown` triggered.
	
	    domHandlers.mousemove.call(this, event);
	    domHandlers.mousedown.call(this, event);
	    setTouchTimer(this);
	  },
	
	  /**
	   * Touch移动响应函数
	   * @inner
	   * @param {Event} event
	   */
	  touchmove: function (event) {
	    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
	    // mouse event in upper applicatoin.
	
	    event.zrByTouch = true;
	    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether
	    // there is gestrue event, because mouse move and pinch may
	    // be used at the same time.
	
	    domHandlers.mousemove.call(this, event);
	    setTouchTimer(this);
	  },
	
	  /**
	   * Touch结束响应函数
	   * @inner
	   * @param {Event} event
	   */
	  touchend: function (event) {
	    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
	    // mouse event in upper applicatoin.
	
	    event.zrByTouch = true;
	    processGesture(this, event, 'end');
	    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
	    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
	    // we can conveniently implement "hover style" in both PC and touch device just
	    // by listening to `mouseover` to add "hover style" and listening to `mouseout`
	    // to remove "hover style" on an element, without any additional code for
	    // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
	    // style" will remain for user view)
	    // click event should always be triggered no matter whether
	    // there is gestrue event. System click can not be prevented.
	
	    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
	      domHandlers.click.call(this, event);
	    }
	
	    setTouchTimer(this);
	  },
	  pointerdown: function (event) {
	    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {
	    //     this._msGesture.addPointer(event.pointerId);
	    // }
	  },
	  pointermove: function (event) {
	    // FIXME
	    // pointermove is so sensitive that it always triggered when
	    // tap(click) on touch screen, which affect some judgement in
	    // upper application. So, we dont support mousemove on MS touch
	    // device yet.
	    if (!isPointerFromTouch(event)) {
	      domHandlers.mousemove.call(this, event);
	    }
	  },
	  pointerup: function (event) {
	    domHandlers.mouseup.call(this, event);
	  },
	  pointerout: function (event) {
	    // pointerout will be triggered when tap on touch screen
	    // (IE11+/Edge on MS Surface) after click event triggered,
	    // which is inconsistent with the mousout behavior we defined
	    // in touchend. So we unify them.
	    // (check domHandlers.touchend for detailed explanation)
	    if (!isPointerFromTouch(event)) {
	      domHandlers.mouseout.call(this, event);
	    }
	  }
	};
	
	function isPointerFromTouch(event) {
	  var pointerType = event.pointerType;
	  return pointerType === 'pen' || pointerType === 'touch';
	} // function useMSGuesture(handlerProxy, event) {
	//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
	// }
	// Common handlers
	
	
	zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
	  domHandlers[name] = function (event) {
	    event = normalizeEvent(this.dom, event);
	    this.trigger(name, event);
	  };
	});
	/**
	 * 为控制类实例初始化dom 事件处理函数
	 *
	 * @inner
	 * @param {module:zrender/Handler} instance 控制类实例
	 */
	
	function initDomHandler(instance) {
	  zrUtil.each(touchHandlerNames, function (name) {
	    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	  });
	  zrUtil.each(pointerHandlerNames, function (name) {
	    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	  });
	  zrUtil.each(mouseHandlerNames, function (name) {
	    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
	  });
	
	  function makeMouseHandler(fn, instance) {
	    return function () {
	      if (instance._touching) {
	        return;
	      }
	
	      return fn.apply(instance, arguments);
	    };
	  }
	}
	
	function HandlerDomProxy(dom) {
	  Eventful.call(this);
	  this.dom = dom;
	  /**
	   * @private
	   * @type {boolean}
	   */
	
	  this._touching = false;
	  /**
	   * @private
	   * @type {number}
	   */
	
	  this._touchTimer;
	  /**
	   * @private
	   * @type {module:zrender/core/GestureMgr}
	   */
	
	  this._gestureMgr = new GestureMgr();
	  this._handlers = {};
	  initDomHandler(this);
	
	  if (env.pointerEventsSupported) {
	    // Only IE11+/Edge
	    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
	    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
	    // at the same time.
	    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
	    // screen, which do not occurs in pointer event.
	    // So we use pointer event to both detect touch gesture and mouse behavior.
	    mountHandlers(pointerHandlerNames, this); // FIXME
	    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
	    // which does not prevent defuault behavior occasionally (which may cause view port
	    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.
	    // So we have to not to use MSGesture and not to support touchmove and pinch on MS
	    // touch screen. And we only support click behavior on MS touch screen now.
	    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
	    // We dont support touch on IE on win7.
	    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
	    // if (typeof MSGesture === 'function') {
	    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
	    //     dom.addEventListener('MSGestureChange', onMSGestureChange);
	    // }
	  } else {
	    if (env.touchEventsSupported) {
	      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
	      // addEventListener(root, 'mouseout', this._mouseoutHandler);
	    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface
	    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
	    // mouse event can not be handle in those devices.
	    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
	    // mouseevent after touch event triggered, see `setTouchTimer`.
	
	
	    mountHandlers(mouseHandlerNames, this);
	  }
	
	  function mountHandlers(handlerNames, instance) {
	    zrUtil.each(handlerNames, function (name) {
	      addEventListener(dom, eventNameFix(name), instance._handlers[name]);
	    }, instance);
	  }
	}
	
	var handlerDomProxyProto = HandlerDomProxy.prototype;
	
	handlerDomProxyProto.dispose = function () {
	  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);
	
	  for (var i = 0; i < handlerNames.length; i++) {
	    var name = handlerNames[i];
	    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
	  }
	};
	
	handlerDomProxyProto.setCursor = function (cursorStyle) {
	  this.dom.style.cursor = cursorStyle || 'default';
	};
	
	zrUtil.mixin(HandlerDomProxy, Eventful);
	var _default = HandlerDomProxy;
	module.exports = _default;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	var eventUtil = __webpack_require__(77);
	
	/**
	 * Only implements needed gestures for mobile.
	 */
	var GestureMgr = function () {
	  /**
	   * @private
	   * @type {Array.<Object>}
	   */
	  this._track = [];
	};
	
	GestureMgr.prototype = {
	  constructor: GestureMgr,
	  recognize: function (event, target, root) {
	    this._doTrack(event, target, root);
	
	    return this._recognize(event);
	  },
	  clear: function () {
	    this._track.length = 0;
	    return this;
	  },
	  _doTrack: function (event, target, root) {
	    var touches = event.touches;
	
	    if (!touches) {
	      return;
	    }
	
	    var trackItem = {
	      points: [],
	      touches: [],
	      target: target,
	      event: event
	    };
	
	    for (var i = 0, len = touches.length; i < len; i++) {
	      var touch = touches[i];
	      var pos = eventUtil.clientToLocal(root, touch, {});
	      trackItem.points.push([pos.zrX, pos.zrY]);
	      trackItem.touches.push(touch);
	    }
	
	    this._track.push(trackItem);
	  },
	  _recognize: function (event) {
	    for (var eventName in recognizers) {
	      if (recognizers.hasOwnProperty(eventName)) {
	        var gestureInfo = recognizers[eventName](this._track, event);
	
	        if (gestureInfo) {
	          return gestureInfo;
	        }
	      }
	    }
	  }
	};
	
	function dist(pointPair) {
	  var dx = pointPair[1][0] - pointPair[0][0];
	  var dy = pointPair[1][1] - pointPair[0][1];
	  return Math.sqrt(dx * dx + dy * dy);
	}
	
	function center(pointPair) {
	  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
	}
	
	var recognizers = {
	  pinch: function (track, event) {
	    var trackLen = track.length;
	
	    if (!trackLen) {
	      return;
	    }
	
	    var pinchEnd = (track[trackLen - 1] || {}).points;
	    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
	
	    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
	      var pinchScale = dist(pinchEnd) / dist(pinchPre);
	      !isFinite(pinchScale) && (pinchScale = 1);
	      event.pinchScale = pinchScale;
	      var pinchCenter = center(pinchEnd);
	      event.pinchX = pinchCenter[0];
	      event.pinchY = pinchCenter[1];
	      return {
	        type: 'pinch',
	        target: track[0].target,
	        event: event
	      };
	    }
	  } // Only pinch currently.
	
	};
	var _default = GestureMgr;
	module.exports = _default;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 选中节点后，出现的操作框及按钮
	 * @author wang.xiaohu
	 */
	
	    var Node = __webpack_require__(81);
	    var zrUtil = __webpack_require__(5);
	    var Util = __webpack_require__(65);
	    var graphic = __webpack_require__(4);
	    var Connector = __webpack_require__(82);
	    var env = __webpack_require__(50);
	    var icon = __webpack_require__(89);
	    var symbolUtil = __webpack_require__(83);
	    function OperationNode(node, zr, api,forbidEdit) {
	        Node.call(this);
	        this.node = node;
	        this.zr = zr;
	        this.forbidEdit = forbidEdit;
	        this._api = api;
	        this.render();
	    }
	
	    //事件
	    OperationNode.ARROW_DRAGEND = "OperationNode:dragendArrow";
	    OperationNode.ARROW_DRAG = "OperationNode:dragArrow";
	    OperationNode.ARROW_DRAGSTART = "OperationNode:dragstartArrow";
	    OperationNode.DELETE_CLICK = "OperationNode:deleteClick";
	    OperationNode.DEL = "DEL";
	    OperationNode.COMMENT_CLICK = "OperationNode:commentClick";
	    OperationNode.COMMENT = "COMMENT";
	        //内置操作图标的图像
	    OperationNode.opicons = {
	        STRAIGHT: icon.STRAIGHT_SVG,
	        JAGGED: icon.JAGGED_SVG,
	        CURVE: icon.CURVE_SVG,
	        DEL: icon.DEL_SVG,
	        COMMENT: icon.COMMENT_SVG
	    };
	
	    OperationNode.prototype.render = function() {
	        this.renderBase();
	        if (!this.forbidEdit) {
	            this.renderOther();
	        }
	    };
	
	    OperationNode.prototype.renderBase = function() {
	        this.createOperation();
	    };
	
	    OperationNode.prototype.createOperation = function() {
	        var me = this;
	        var ifShowNodeOperationIcons = this.node.operationIcons;
	        if (this.node.parent && this.node.parent.type === 'dragSelect') {
	            ifShowNodeOperationIcons = false;
	        }
	        if (!this.node.selectStyle) {
	            this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });
	            this.virtualRect.isSelfComputePos = true;  // 自己计算位置
	            this.add(this.virtualRect);
	        } else {
	             if (this.node.type === 'ZPath') {  //addHover需要从它自身的构造函数中创建。1.Painter中addHover源码是根据shape与style创建 2.path中的构造函数是返回另一个元素
	                this.node._zCloneStyle = this.node.style.clone();
	                 this.node.setStyle(this.node.selectStyle);
	             } else if(this.node.setOrCancelSelectStyle) {
	                this.node.setOrCancelSelectStyle(true);
	             } else {
	                this._api.getZr().addHover(this.node, this.node.selectStyle);
	             }
	
	        }
	
	        if (ifShowNodeOperationIcons) {
	            zrUtil.each(this.node.operationIcons, function(item) {
	                //检查是否是内置图标
	                var opIconInstance = null;
	                var operationIcon = OperationNode.opicons[item.name.toUpperCase() + ""]
	                if (operationIcon) {
	
	                    if (this.forbidEdit) {
	                        return;
	                    }
	                    if (item.hidden) {
	                        return;
	                    }
	                    if (item.name == OperationNode.DEL) {
	                        //垃圾桶
	                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },z:me.node.z+1,rectHover: true }, { x: 0, y: 0, width: 10, height: 15 });
	
	                        if(item.callback){
	                            opIconInstance.on("click", function(e) {
	                                e.data = item;
	                                e.node = me.node;  // 将所附的节点也传递出去
	                                if (item.callback) {
	                                    item.callback(e);
	                                }
	                            });
	                        }else{
	                            opIconInstance.on("click", function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.target = this;
	                                params.type = OperationNode.DELETE_CLICK;
	                                me.trigger(params.type, params);
	                            });
	                        }
	                    } else if (item.name == OperationNode.COMMENT) {
	                        var rect = { x: 0, y: 0, width: 16, height: 16 };
	                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' }, z:me.node.z+2, rectHover: true }, rect);
	                        opIconInstance.on("click", function(e) {
	                            var params = {};
	                            params.event = e;
	                            params.target = this;
	                            params.type = OperationNode.COMMENT_CLICK;
	                            me.trigger(params.type, params);
	                        });
	                    } else {
	                        var rectOther = { x: 0, y: 0, width: 15, height: 15 };
	                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },draggable:true,z:me.node.z+2,lineType: Connector["TYPE_" + item.name.toUpperCase()],rectHover: true }, rectOther);
	                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	                            opIconInstance.on(eveName, function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.data = item.options
	                                params.type = "OperationNode:" + eveName + "Arrow";
	                                me.trigger(params.type, params);
	                            });
	                        });
	                    }
	
	                } else {
	                    opIconInstance = symbolUtil.createSymbol(item.iconPath, 0, 0, item.width || 15, item.height || 15, me.node.z+1, item.color||'#000');
	                    opIconInstance.on("click", function(e) {
	                        e.data = item;
	                        e.node = me.node;  // 将所附的节点也传递出去
	                        if (item.callback) {
	                            item.callback(e);
	                        }
	                        var param = {event:e, type:"OperationNode:" + item.name + "Click"};
	                        me._api.trigger(param.type, param);
	                    });
	                }
	                opIconInstance.name = item.name;
	                me.add(opIconInstance);
	            });
	        }
	    };
	
	    OperationNode.prototype.refreshPostion = function(node, nodeRect) {
	        var i = 0;
	        var rbPoint = zrUtil.clone(nodeRect.points[2]); //取右下角坐标
	        var rotation = node.rotation;
	        var angle = rotation / (Math.PI/180);
	        if (Math.abs(rotation) > 0) {
	            var connectorControls = Util.getConnectorControls(nodeRect, node);
	            var brControl = connectorControls.br;
	            rbPoint = [brControl.x - nodeRect.x,  brControl.y - nodeRect.y];
	        }
	        //1.定位虚框
	        if (this.virtualRect) {
	            this.virtualRect.setShape({ points: nodeRect.points });
	            if (node.parent && node.parent.childDraggable) {
	                this.virtualRect.attr('z', node.parent.z + 1)
	            }
	            this.virtualRect.attr('rotation', rotation);
	        }
	        //2.定位每个小图标
	        this.eachChild(function(nodeItem) {
	            if (!nodeItem.isSelfComputePos) {
	                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离
	                nodeItem.attr("position", [angle >= 0 ? rbPoint[0] + 8 + (i++ * 20) : rbPoint[0] - 20 - (i++ * 20), rbPoint[1] - 10]);
	            }
	        });
	
	        this.refreshPositionOther(node,nodeRect);
	    };
	
	    OperationNode.prototype.renderOther = function() {
	        //留给扩展使用
	    };
	    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {
	        //留给扩展使用
	        //3.定位整个operationNode
	        if ((node.parent && node.parent.isBg && node.parent.isBg == true) || (node.parent.type === "GroupNode")) {
	            this.attr("position", [nodeRect.x, nodeRect.y])
	        } else {
	            var nodeShapeX = node.shape? node.shape.x:0;
	            var nodeSahpeY = node.shape? node.shape.y:0;
	            this.attr("position", [nodeRect.x + node.parent.position[0]+nodeShapeX, nodeRect.y + node.parent.position[1]+nodeSahpeY])
	        }
	    };
	
	    OperationNode.prototype.cleanup = function() {
	        if(this.node.selectStyle) {
	            if (this.node.type === 'ZPath') {
	                this.node.setStyle(this.node._zCloneStyle);
	            } else if(this.node.setOrCancelSelectStyle) {
	                this.node.setOrCancelSelectStyle(false);
	             } else {
	                this._api.getZr().removeHover(this.node);
	            }
	
	        }
	    };
	
	    zrUtil.inherits(OperationNode, Node);
	    module.exports = OperationNode;
	


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var graphic = __webpack_require__(4);
	    var util = __webpack_require__(65)
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    function Node() {
	        this.resourceId = util.getUUID(); // 生成节点ID
	        graphic.Group.call(this);
	    }
	
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.render = function() {};
	
	    /**
	     * 由父类实现
	     * @param  {[type]} json [description]
	     * @return {[type]}      [description]
	     */
	    Node.prototype.getRect = function(json) {};
	
	    /**
	     * drawText
	     * @description 画一个文本
	     * @param {string} name
	     * @param {string} color
	     */
	    Node.prototype.drawText = function(name, color, position) {
	        var textName = this.bpmnInfo.name, x, y;
	        if(name != null){
	            textName = name;
	        }
	        var text = new graphic.Text({
	            style: {
	                text: textName,
	                color: color ? color : this.options.text.color,
	                textFont: '12px Microsoft YaHei'
	            },
	            zlevel: 20
	        });
	        //文字绘制的位置 
	        position = position ? position : 'init';
	        switch (position) {
	            //节点下方居中位置
	            case 'init': 
	                //x = 中心点.x - 起始位置.x - 文字宽度的一半
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                //y = 中心点.y - 起始位置.y + 偏移值（6）
	                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;
	                break;
	            //节点内部居中位置
	            case 'center':
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            //节点内部居左位置
	            case 'left': 
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width + 6;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            default: break;
	        }
	        text.attr("style", { x: x, y: y });
	        return {
	            text: text,
	            rect: text.getBoundingRect()
	        };
	    };
	    /**
	     * refreshText
	     * @description 刷新文本
	     */
	    Node.prototype.refreshText = function(pos) {
	        var text = this.childOfName("Title"), x, y;
	        pos = pos ? pos : 'init';
	        switch (pos) {
	            case 'init': 
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;
	                break;
	            case 'center':
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            case 'left':
	                x = 2;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            default: break;
	        }
	        text.attr("style", { x: x, y: y });
	    };
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.toJSON = function() {};
	
	    graphic.Util.inherits(Node, graphic.Group);
	    module.exports = Node;
	


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连接线
	 * @author wang.xiaohu
	 */
	
	    var Util = __webpack_require__(65);
	    var zrUtil = __webpack_require__(5);
	    var vec2 = __webpack_require__(15);
	    var graphic = __webpack_require__(4);
	    var Node = __webpack_require__(81);
	    var symbolUtil = __webpack_require__(83);
	    var Handle = __webpack_require__(84);
	    var EffectLine = __webpack_require__(85);
	    var ConnectionPoint = __webpack_require__(86);
	    var Point = __webpack_require__(66);
	    var Model = __webpack_require__(87);
	
	    Connector.TYPE_STRAIGHT = 'straight';
	    Connector.TYPE_JAGGED = 'jagged';
	    Connector.TYPE_CURVE = 'curve';
	    Connector.TYPE_CHAIN = 'chain';
	    Connector.RADIUS = 3;
	    Connector.START_NODE = "startNode";
	    Connector.END_NODE = "endNode";
	    Connector.LEFT = "left";
	    Connector.RIGHT = "right";
	    Connector.TOP = "top";
	    Connector.BOTTOM = "bottom";
	    Connector.BOTTOM = "bottom";
	    Connector.SEPERATOR = "-";
	    Connector.NORMAL_COLOR = "#000";
	    Connector.SELECTED_COLOR = '#74B7E0';
	    Connector.CHILD_NAME = ['lineText', 'lineImage'];
	    /**
	     * 构造函数
	     * @param {[type]} options [description]
	     */
	    function Connector(options) {
	        Node.call(this);
	        this.opt = options || {};
	        if (this.opt.model) {
	            this.resourceId = this.opt.model.get("resourceId");
	            this.model = this.opt.model;
	            this.opt = this.opt.model.option;
	        } else {
	            this.resourceId = Util.getUUID(); // 生成节点ID
	            this.model = new Model({});
	        }
	        var defaultOptions = {
	            symbol: { type: "arrow", size: 10, color: Connector.NORMAL_COLOR, both:false, offset:0 }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	            style: { lineWidth: 1, stroke: Connector.NORMAL_COLOR, lineType: Connector.TYPE_STRAIGHT }, //样式
	            hoverStyle: { lineWidth: 2, stroke: Connector.SELECTED_COLOR }, //移上去的样式
	            arrowHoverStyle: { fill: Connector.SELECTED_COLOR},
	            shape: { points: null, smooth: false, smoothConstraint: null }, //形状
	            position: { startPos:null, endPos:null,  //指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	                        startOffset:[0,0],  // 起始线段离节点的偏移
	                        endOffset:[0,0],    // 终止线段离节点的偏移
	                        escapeDistance:[30,30], // 第一条折线的长度，最后一条折线的长度
	                        points:null    //不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	                    },
	            autoChangePosition: false,
	            textContextMenu: null,
	            isEdit: true, //是否可编辑
	            text: {
	                text: null,
	                textFill: '#000000', // 文本颜色
	                textFont: '12px Microsoft YaHei',
	                textPos: 'center',
	                textRotateable: true
	            },
	            image: {
	                image: null,
	                width: 50,
	                height: 50,
	                // style: {
	                //     // image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAAyCAYAAAAA9rgCAAAEZklEQVRoQ+2aXYgbVRTHz/8muwSJWPx4sFgoaBUrWorUL8SK9UGhFCt2URRhQai6uLDZyR0DhTaIZu/NZPdNrYL4haKlflDwoSgUVKrYIhRaP7B92Ibtg1JfIqzZnRy5y0Rmx2R3MqlJZpN5nDnn3v/vnnvnnvsBavBora8HcFutVtvS6HsvvxNCnAdwipnPZLPZv4JaEXyhtS4SkdXLUCG1zQoh9lmW9Z7ffhmw1nqWiDaELDAWZsyct237QF3sv8Ba6++I6M5YULQu8j4p5dfGbQlYKXUAwP7Wy4mNxy8Abjdjug78IYDHffLLzPySbdtvxAbJE+o4zmbXdUeCARRC3GFZ1g91YNMCN/rgDkkpR+IGW9ertd5JREcC+kellG8vAWut2f8xONDjCN6MaQBsojmIcAz79KBLewnIYAz30hguFou7mXkTgN+FELOTk5NfhR1dsevSWuuPiWhPAPBTKeWjYaBjBayUOmFSwSZgz0spX1sNOjbATbKkZXzJZPKqTCZzcSXo2AArpSYBOCvBALgrm81+vyaAi8XiKDO/tRKMEOJmy7J+XhPApVJph+u6XzaDAfBrpVLZks/n5zsOPDMzs25hYWEjM/9h23Z5tR9J2O9a60+IaHcj+0Qi8WCY6emSjOFCoXC/EGIPgHuIaCMRrfOJOk1ER4noODMfb7cBtNbPEdGrvvLnvDX662Eari1gpVQWgJkTt4WpzEteCul0+pWxsbFKWJ+g3fT09JWu625i5oupVGp2fHz877BlRQbWWheI6MWwFfntAPwI4CnLss5E8W/Hpx3gZZsDEUScFkKMdBr6kgEz828APgdweHFx8cL8/PxcOp3eWqvVHgbwUJOdz8NSysciNFZkl8jA3o7mdq/mopTyi1WmA2k2QoM2AJ7NZrMHIxO06BgZuMV6lsy11k8T0TsB33IymdyeyWTORSmzVZ+OAnvQJsom2v7nAynlk62Kj2LfcWDHca6u1WrfENFNfsHM/LJt2/uiQLTi03FgL8rPENGbQaHMvCFMYlIoFLYJIcwy8VYAmwF8S0QnmfmUlPLsKv+ShlvP//sWj9ba5MU7Goi7V0ppAP7zTE1NmZODJwA8sgLUR8zs2LZ9opFNVyJshCildplprIlwk4YeNWe6ruuWhRAPMPMogGtCdt8qETmu6zq5XO5Pv0/XgL2ubfLfvSEhopj9RET7pZSH6s5dBfagTZR3RaCZMwsSAOeY2SxY7iai6xqVMzQ0tH5iYuKCV193xnCgmzX8iTVphLPM/P7w8PDBOoQvei8w8ziAG/y+9RPCngE2QnzHmSbVvKUB7GcA3q1UKkfy+fxisx7hraQMuJnrLyOiYwB21u91dL1LNxKulLo8mUxeW61W1ycSifOpVKrcyhLQlFkqlbZWq9UrcrncsZ75aUUYt2279GSE26ZaoYAB8OAwzdc91vyBuFKqvy61KKX67tpSf11M81Kx/rl66MtR++dyqQ+6f64P+6DX7AXxfwANvfFgWcCyjAAAAABJRU5ErkJggg==",
	                //     // width:50,
	                //     // height:50
	                // },
	                imagePos: 'center',
	                imageRotateable: true // 图片是否跟随线段旋转
	            },
	            z: 0
	        }
	
	        this.options = Util.mergeOpt(defaultOptions, this.opt, true, 'textContextMenu');
	        this.handles = [];
	        this.conPointsGroup = new graphic.Group();
	        this.startNode = null;
	        this.endNode = null;
	        this.line = null;
	        this.groupCurve = new graphic.Group();
	        this.icons = []; // 用于存储线段上面的操作图标
	        this.render();
	    }
	
	        /**
	     * 创建连线节点
	     * @param  {[Object]} options [节点参数]
	     * @param  {[String]} type [节点类型] 'text' 'image'
	     */
	    Connector.prototype.createLineNode = function(options, type) {
	        var that = this;
	        var text = null;
	        if (!type) {
	            type = 'text';
	        }
	        var nodeName = zrUtil.find(Connector.CHILD_NAME, function(name) {
	            return name.toLocaleLowerCase().indexOf(type) > -1;
	        });
	        if (zrUtil.isArray(options[type]) && this.options.style.lineType == Connector.TYPE_CHAIN) {
	            options[type].forEach(function (v, i) {
	                var content = that.drawText(nodeName+"-"+i, v, 0, 0, type);
	                if (zrUtil.isString(v)) {
	                    var obj = {};
	                    obj[type] = v;
	                    obj[type+'Id'] = content.text.id;
	                    that.options[type][type][i] = obj;
	                } else {
	                    that.options[type][type][i].textId = content.text.id;
	                }
	                that.add(content.text);
	                that.createNodeContextMenu(content.text);
	            });
	        } else {
	            text = this.drawText(nodeName, options, 0, 0, type);
	            this.add(text.text);
	        }
	        if (text) {
	            that.createNodeContextMenu(text.text);
	        }
	    }
	
	    Connector.prototype.ifLineNodeRotateable = function(type) {
	        if (!type) {
	            type = 'text';
	        }
	        if (this.options.style.lineType == Connector.TYPE_STRAIGHT) {
	            if ((type === 'text' && this.options.text.textRotateable) || (type === 'image' && this.options.image.imageRotateable))
	            return true;
	        }
	        return false;
	    }
	
	    /**
	     * 更新连线的文字/图片节点
	     * @param  {[Object]} lineNode [节点]
	     * @param  {[Object]} options [节点参数]
	     * @param  {[String]} type [节点类型] 'text' 'image'
	     */
	    Connector.prototype.refreshLineNode = function(lineNode, options, type) {
	        var self = this, lineNodeArr = [], nodeName = Connector.CHILD_NAME[0];
	        if (!type) {
	            type = 'text';
	        }
	        nodeName = zrUtil.find(Connector.CHILD_NAME, function(name) {
	            return name.toLocaleLowerCase().indexOf(type) > -1;
	        });
	        if (this.options.style.lineType == Connector.TYPE_CHAIN && zrUtil.isArray(options[type])) {
	            options[type].forEach(function (v, i) {
	                lineNodeArr.push(self.childOfName(nodeName+'-'+i));
	            });
	        } else if (!lineNode && options[type]) {
	            var text = this.drawText(nodeName, options, 0, 0, type);
	            this.add(text.text);
	            lineNode = this.childOfName(nodeName);
	        }
	        if (lineNodeArr.length > 0) {
	            var cnt = lineNodeArr.length,
	                distance = this.turningPoints[1].x - this.turningPoints[0].x,
	                gap = parseInt(distance/cnt),
	                pos = -(gap) * parseInt(cnt/2);
	
	                lineNodeArr.forEach(function (v, i) {
	                var textPoint = self.getTextPostion(options, v), way = '';
	
	                var rate = self.getTextRotation(textPoint, v);
	                if (Math.abs(rate) === 0) {
	                    rate = 0;
	                } else {
	                    way = rate > 0 ? 'plus' : 'minus';
	                }
	                rate = Math.abs(rate);
	                var deg = (180*rate)/Math.PI;
	                var rotation = null, length = null;
	                if (type === 'text') {
	                    v.setStyle("text", zrUtil.isString(options[type][i]) ? options[type][i] : options[type][i].text);
	                    // 更新文字矩形包围盒
	                    var textBoundingRect = self.getTextBoundingRect(v.style);
	                    v.setShape({
	                        width: textBoundingRect.width,
	                        height: textBoundingRect.height
	                    });
	                }
	
	                if (way) {
	                    rotation = deg > 90 ? ((deg-45)*Math.PI)/180 : ((45+deg)*Math.PI)/180;
	                    rotation = way === 'minus' ? -(rotation) : rotation;
	                } else {
	                    rotation = (45*Math.PI)/180
	                }
	                v.attr('rotation', rotation);
	
	                if (deg === 90) {
	                    textPoint[1] -= pos;
	                } else {
	                    textPoint[0] += pos;
	                    if (rate !== 0) {
	                        length = Math.tan(deg*Math.PI/180)*pos;
	                        if (pos > 0) {
	                            textPoint[1] -= way === 'plus' ? length : -(length);
	                        } else {
	                            textPoint[1] += way === 'plus' ? -(length) : (length);
	                        }
	                    }
	                }
	
	                v.attr("position", textPoint);
	                pos += gap;
	            });
	        }
	        if (lineNode) {
	            if (type === 'text') {
	                lineNode.setStyle("text", options[type]);
	                var textRect = this.getTextBoundingRect(options);
	                lineNode.setShape({
	                    width: textRect.width,
	                    height: textRect.height
	                });
	            }
	            var textPoint = this.getTextPostion(options, lineNode);
	            if (this.ifLineNodeRotateable(type)) { //#187
	                lineNode.attr('rotation', this.getTextRotation(textPoint, lineNode));
	            }
	            lineNode.attr("position", textPoint);
	        }
	    }
	
	
	    /**
	     * 重新画线，如果传空则根据turningPoints 重新画线
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    Connector.prototype.refresh = function(arrPoints) {
	        var that = this;
	        if (arrPoints) {
	            this.turningPoints = arrPoints;
	        }
	        //将[x:0,y:0]转化为[0, 0]  给zrender使用
	        var points = Util.traslatePoints(this.turningPoints);
	
	        if ((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {
	            this.modifyCurve(this.turningPoints);
	        } else {
	            this.line.attr('shape', { points: points });
	        }
	
	        // 更新线段文字/图片节点
	        Connector.CHILD_NAME.forEach(function(name) {
	            var lineNode = that.childOfName(name);
	            var type = name === Connector.CHILD_NAME[0] ? 'text' : 'image';
	            that.refreshLineNode(lineNode, that.options[type], type);
	        });
	
	        this.refreshFromToSymbol(points);
	        this.refreshHandles();
	    };
	    /**
	     * 创建线上节点的右击监听
	     * @return {[type]} [description]
	     */
	    Connector.prototype.createNodeContextMenu = function (node) {
	        if (node && this.opt.textContextMenu) {
	            var textContextMenu = this.opt.textContextMenu;
	            node.on("contextmenu",function(e) {
	                e.event.preventDefault();
	                e.event.stopPropagation();
	                textContextMenu.buildMenu(e.event,this);
	            })
	        }
	    }
	    /**
	     * 渲染
	     * @return {[type]} [description]
	     */
	    Connector.prototype.render = function() {
	        var that = this;
	        //1.创建箭头
	        this.renderFromToSymbol();
	
	        //2.创建线
	        this.curveLine = new graphic.BezierCurve({
	            //position: this.options.position,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.groupCurve.add(this.curveLine);
	        this.add(this.groupCurve);
	        this.add(this.conPointsGroup);
	        this.polyLine = new graphic.Polyline({
	            //position: this.options.position,
	            shape: this.options.shape,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.add(this.polyLine);
	
	        if ((this.options.style.lineType == Connector.TYPE_CURVE)) {
	            this.line = this.groupCurve;
	            this.createHoverStyle(this.curveLine);
	            this.polyLine.hide();
	        } else {
	            this.line = this.polyLine;
	            this.createHoverStyle(this.polyLine);
	            this.curveLine.hide();
	        }
	
	        //3.侦听线事件
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click']; //'click', 'dblclick', 'mouseover', 'mouseout'
	        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	            this.line.on(eveName, zrUtil.bind(function(e) {
	                e.cancelBubble = true;
	                var params = {};
	                params.event = e;
	                params.type = "Connector:" + eveName;
	                params.target = that;
	                this.trigger(params.type, params);
	                if (this.options.isEdit == false) {
	                    return; }
	                that.setSelectedStyle(this);
	                if (this.handles.length < 1) {
	                    this.shapeSetHandle();
	                }
	
	            }, this));
	        }, this);
	
	        //4.创建线上文本
	        if (this.options.text.text) {
	            this.createLineNode(this.options.text, 'text');
	        }
	        // // 5.创建线上图片节点
	        if (this.options.image.image) {
	            this.createLineNode(this.options.image, 'image');
	        }
	    };
	
	    Connector.prototype.renderFromToSymbol = function(options) {
	        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle
	        if (symbolTo) {
	            this.add(symbolTo);
	        }
	        //如果双向箭头 则再创建首箭头
	        if (this.options.symbol.both) {
	            var symbolFrom = this.createSymbol('fromSymbol', this.options); //arrow,triangle
	            if (symbolFrom) {
	                this.add(symbolFrom);
	            }
	        }
	    }
	
	    Connector.prototype.refreshFromToSymbol = function(points) {
	        var symbolTo = this.childOfName('toSymbol');
	        var symbolFrom = this.childOfName('fromSymbol');
	        var position = [], offset = this.options.symbol.offset;
	        if (symbolTo) {
	            if (this.options.effect && this.options.effect.show) {
	                new EffectLine(symbolTo, this.options, this.groupCurve, this.polyLine);
	            } else {
	                position = points[points.length - 1];
	                if (this.options.style.lineType !== Connector.TYPE_CURVE) {
	                    var distance = vec2.distance(points[points.length - 1], points[points.length - 2]);
	                    if (offset <= distance) {
	                        position = vec2.lerp(
	                            [], points[points.length - 1], points[points.length - 2],
	                            offset / distance);
	                    } else {
	                        position = points[points.length - 1];
	                    }
	                }
	                symbolTo.attr('position', position);
	                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]));
	            }
	        }
	
	        if (symbolFrom) {
	            position = points[0];
	            if (this.options.style.lineType !== Connector.TYPE_CURVE) {
	                var distanceFrom = vec2.distance(points[0], points[1]);
	                if (offset <= distanceFrom) {
	                    position = vec2.lerp(
	                        [], points[0], points[1],
	                        offset / distanceFrom);
	                } else {
	                    position = points[0];
	                }
	            }
	            symbolFrom.attr('position', position);
	            symbolFrom.attr('rotation', Util.tangentRotation(this.turningPoints[1], this.turningPoints[0]));
	        }
	    }
	    /**
	     * 设置style
	     * @param {object} options 样式对象
	     * @param {boolean} notSaveModel 设置样式是否保存到模型中,默认是false
	     */
	    Connector.prototype.setStyle = function(options,notSaveModel) {
	        var lineOpt = {};
	        var symbolTo = null;
	        var notLineKeys = ['text', 'image', 'symbol'];
	        // if (options.color) {
	        //     if (this.options.style.lineType == Connector.TYPE_CURVE) {
	        //         this.groupCurve.eachChild(function(curve) {
	        //             curve.attr("style", { stroke: options.color });
	        //             graphic.setNormalStyle(curve, { stroke: options.color });
	        //         });
	        //     } else {
	        //         this.polyLine.attr("style", { stroke: options.color });
	        //         graphic.setNormalStyle(this.polyLine, { stroke: options.color });
	        //     }
	        //     symbolTo = this.childOfName('toSymbol');
	        //     if (symbolTo) {
	        //         symbolTo.attr("style", { fill: options.color });
	        //         graphic.setNormalStyle(symbolTo, { fill: options.color });
	        //     }
	        //     if(!notSaveModel) {
	        //         this.options.style.stroke = options.color;
	        //         this.model.set("options.style.stroke", options.color);
	        //         this.model.set("options.symbol.color", options.color);
	        //         this.options.symbol.color = options.color;
	        //     }
	        // }
	
	        if (options.text) {
	            var lineText = this.childOfName(Connector.CHILD_NAME[0]);
	            //开始没有创建文本，后来传进来text了，需要先创建文本
	            if (!lineText && options.text.text) {
	                var text = this.drawText(Connector.CHILD_NAME[0], options.text, 0, 0);
	                this.add(text.text);
	                lineText = this.childOfName(Connector.CHILD_NAME[0]);
	            }
	
	            if (options.text.text || options.text.text == "") {
	                lineText.setStyle("text", options.text.text);
	                this.options.text.text = options.text.text;
	            }
	            var textPoint = this.getTextPostion(options.text);
	            lineText.attr("position", textPoint);
	            if (options.text.textPos) {
	                this.options.text.textPos = options.text.textPos;
	            }
	            if (options.text.offset) { //#187
	                this.options.text.offset = options.text.offset;
	            }
	
	            if (options.text.color) {
	                lineText.attr("style", {
	                    textFill: options.text.color
	                });
	                this.options.text.textFill = options.text.color;
	            }
	
	            if (options.text.textFont) {
	                lineText.attr("style", {
	                    textFont:options.text.textFont
	                });
	                this.options.text.textFont = options.text.textFont;
	            }
	
	            if (options.text.textFill) {
	                lineText.attr("style", {
	                    textFill: options.text.textFill
	                });
	                this.options.text.textFill = options.text.textFill;
	            }
	            this.model.set("options.text", options.text);
	        }
	
	        if (options.image) {
	            var lineImage = this.childOfName(Connector.CHILD_NAME[1]);
	            //开始没有创建图片，后来传进来image了，需要先创建图片
	            if (!lineImage && options.image.image) {
	                var image = this.drawText(Connector.CHILD_NAME[1], options.image, 0, 0, 'image');
	                this.add(image.text);
	                lineImage = this.childOfName(Connector.CHILD_NAME[1]);
	            }
	            var imagePoint = this.getTextPostion(options.image, lineImage);
	            lineImage.attr("position", imagePoint);
	            Object.keys(options).forEach(function(key) {
	                this.options.image[key] = options[key];
	            }.bind(this));
	            if (options.image.offset) { //#187
	                this.options.image.offset = options.image.offset;
	            }
	            this.model.set("options.image", options.image);
	        }
	
	        if (options.symbol) {
	            if (options.symbol.type) {
	                this.options.symbol.type = options.symbol.type;
	                this.model.set("options.symbol.type", options.symbol.type);
	            }
	            if (options.symbol.size) {
	                this.options.symbol.size = options.symbol.size;
	                this.model.set("options.symbol.size", options.symbol.size);
	            }
	            if (options.symbol.color) {
	                this.options.symbol.color = options.symbol.color;
	                this.model.set("options.symbol.color", options.symbol.color);
	            }
	            if (options.symbol.z) {
	                this.options.symbol.z = options.symbol.z;
	                this.model.set("options.symbol.z", options.symbol.z);
	            }
	
	            symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) {
	                this.remove(symbolTo);
	            }
	            var symbol = this.createSymbol("toSymbol", this.model.get("options"))
	            if (symbol) {
	                this.add(symbol);
	            }
	        }
	        Object.keys(options).forEach(function(key) {
	            if (notLineKeys.indexOf(key) < 0) {
	                lineOpt[key] = options[key];
	            }
	        });
	        if (JSON.stringify(lineOpt) !== '{}') {
	            if (lineOpt.color) {
	                lineOpt.stroke = lineOpt.color;
	            }
	            if (lineOpt.stroke) {
	                lineOpt.color = lineOpt.stroke;
	            }
	            if (this.options.style.lineType == Connector.TYPE_CURVE) {
	                this.groupCurve.eachChild(function(curve) {
	                    curve.attr("style", lineOpt);
	                    graphic.setNormalStyle(curve, lineOpt);
	                });
	            } else {
	                this.polyLine.attr("style", lineOpt);
	                graphic.setNormalStyle(this.polyLine, lineOpt);
	            }
	            symbolTo = this.childOfName('toSymbol');
	            if (symbolTo && lineOpt.color) {
	                symbolTo.attr("style", { fill: lineOpt.color });
	                graphic.setNormalStyle(symbolTo, { fill: lineOpt.color });
	            }
	            if(!notSaveModel) {
	                Object.keys(lineOpt).forEach(function(key) {
	                    this.options.style[key] = lineOpt[key];
	                    this.model.set("options.style"+ key, lineOpt[key]);
	                }.bind(this));
	                if (lineOpt.color) {
	                    this.options.symbol.color = lineOpt.color;
	                }
	            }
	        }
	        this.refresh();
	    };
	
	    /**
	     * 设置选中style
	     */
	    Connector.prototype.setSelectedStyle = function() {
	        // 选中的连线层级是最高的
	        var symbolTo;
	        this.setStyle(this.options.hoverStyle, true);
	        if (this.options.style.lineType == Connector.TYPE_CURVE) {
	            this.groupCurve.eachChild(function(curve) {
	                curve.attr("z", this.options.z + 2);
	            }.bind(this));
	        } else {
	            this.polyLine.attr('z', this.options.z + 2);
	        }
	        symbolTo = this.childOfName('toSymbol');
	        if (symbolTo) {
	            symbolTo.attr("z", this.options.z + 2);
	        }
	    };
	
	    /**
	     * 设置取消选中style
	     */
	    Connector.prototype.removeSelectedStyle = function() {
	        var symbolTo;
	        this.setStyle({color:this.options.style.stroke,lineWidth:this.options.style.lineWidth},true);
	        if (this.options.style.lineType == Connector.TYPE_CURVE) {
	            this.groupCurve.eachChild(function(curve) {
	                curve.attr("z", this.options.z);
	            }.bind(this));
	        } else {
	            this.polyLine.attr('z', this.options.z);
	        }
	        symbolTo = this.childOfName('toSymbol');
	        if (symbolTo) {
	            symbolTo.attr("z", this.options.z);
	        }
	    };
	
	    /**
	     * 获取线段节点的位置
	     * @param  {Object} text {text:'', color:'', textPos:''}
	     * @return {Object}      {x,y}
	     */
	    Connector.prototype.getTextPostion = function(text, node) {
	        var textPostion = [];
	        var textRect = text.image && node ? node.getBoundingRect() : this.getTextBoundingRect(text);
	        var textWidth = textRect.width;
	        var textHeight = textRect.height || 12;
	        var pos;
	        if (text && (text.textPos || text.imagePos)) {
	            var offset = text.offset || 0;
	            var arrOffset = offset;
	            pos = text.textPos || text.imagePos;
	            if (!zrUtil.isArray(offset)) {
	                arrOffset = [offset, 0];
	            }
	            var pointsOrigin = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]]);
	            var points = [], beizierPoints =[];
	              var angle = Util.getAngle(pointsOrigin[0], pointsOrigin[1]);
	            var length, newPoint;
	            if (this.options.style.lineType == Connector.TYPE_CURVE) {
	                beizierPoints = this.getPointsFromCurve();
	            }
	            pointsOrigin.forEach(function(item) {
	                var itemCopy = new Point(item.x, pointsOrigin[1].x >= pointsOrigin[0].x ? item.y - textHeight / 2 : item.y + textHeight / 2);
	                points.push(itemCopy);
	            });
	            switch(pos) {
	                case 'start':
	                    if (this.options.style.lineType === Connector.TYPE_STRAIGHT) {
	                        length = arrOffset[0];
	                        newPoint = Util.getEndPoint(points[0], length, angle);
	                        textPostion = [newPoint.x, newPoint.y + arrOffset[1]];
	                    } else {
	                        textPostion = [this.turningPoints[0].x - textWidth / 2 + arrOffset[0], this.turningPoints[0].y + arrOffset[1] - textHeight / 2];
	                    }
	                    break;
	                case 'end':
	                    if (this.options.style.lineType === Connector.TYPE_STRAIGHT && !this.options.text.textRotateable) {
	                        length = Util.distance(points[0], points[1]);
	                        newPoint = Util.getEndPoint(points[0], length, angle);
	                        textPostion = [newPoint.x  - textWidth + arrOffset[0], newPoint.y + arrOffset[1]];
	                    } else {
	                        length = Util.distance(points[0], points[1]) - textWidth + arrOffset[0];
	                        newPoint = Util.getEndPoint(points[0], length, angle);
	                        textPostion = [newPoint.x, newPoint.y + arrOffset[1]];
	                    }
	                    break;
	                default:
	                    var midPoint = this.middle(text);
	                    if (this.ifLineNodeRotateable(text.image ? 'image' : 'text')) {
	                          var rotate = this.getTextRotation(text);
	                          var positionBefore = [midPoint[0] - textWidth / 2, midPoint[1] - textHeight / 2];
	                          textPostion = Util.calculatePoints(positionBefore, {x: midPoint[0], y: midPoint[1]}, rotate);
	                    } else if (this.options.style.lineType == Connector.TYPE_CURVE) {
	                        // 曲线的文字position单独计算
	                        var arr = [];
	                        beizierPoints.forEach(function(item) {
	                            arr = arr.concat(item);
	                        });
	                        var index = Math.round(arr.length / 2);
	                        textPostion = [arr[index].x - textWidth / 2, arr[index].y -textHeight / 2];
	                    } else {
	                        textPostion = [midPoint[0] + arrOffset[0], midPoint[1] + arrOffset[1]];
	                        if (this.options.style.lineType !== Connector.TYPE_CHAIN) {
	                            textPostion = [textPostion[0] - textWidth / 2, textPostion[1] - textHeight / 2];
	                        }
	                    }
	                    break;
	            }
	        } else {
	            var position = this.middle(text);
	            textPostion = [position[0] - textWidth / 2, position[1]];
	        }
	
	        return textPostion;
	    };
	
	    /**
	     * 获取线段的旋转角度
	     * @param  {Object} textPostion {x,y}
	     * @return {Number}             角度值
	     */
	    Connector.prototype.getTextRotation = function(options) {
	        //计算出极坐标的角度
	        var points = Util.getMaxLineLength(this.turningPoints);
	        var midPoint = this.middle(options);
	        var angle = -Math.atan2(points[1].y - midPoint[1], points[1].x - midPoint[0]); //,Math.PI/2
	        return angle;
	    };
	
	    Connector.prototype.createHoverStyle = function(el) {
	        if (this.options.hoverStyle && this.options.isEdit) {
	            graphic.setElementHoverStl(el, this.options.hoverStyle);
	
	            var symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) { graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle); }
	
	            el.on('mouseover', zrUtil.bind(function() {
	                graphic.doEnterHover(el);
	                if (symbolTo) { graphic.doEnterHover(symbolTo); }
	
	                this.groupCurve.eachChild(function(line) {
	                    graphic.doEnterHover(line);
	                });
	            }, this))
	            .on('mousemove', zrUtil.bind(function(e) {
	                var startPoint = this.turningPoints[0];
	                var endPoint = this.turningPoints[this.turningPoints.length - 1];
	                var startDiff = Math.abs(e.event.offsetX - startPoint.x) + Math.abs(e.event.offsetY - startPoint.y);
	                var endDiff = Math.abs(e.event.offsetX - endPoint.x) + Math.abs(e.event.offsetY - endPoint.y);
	                if (startDiff <= 15 || endDiff <= 15) {
	                    el.cursor = 'move';
	                    el.draggable = true;
	                } else {
	                    el.cursor = 'pointer';
	                    el.draggable = false;
	                }
	            }, this))
	            .on('mouseout', zrUtil.bind(function() {
	                graphic.doLeaveHover(el);
	                if (symbolTo) { graphic.doLeaveHover(symbolTo); }
	                this.groupCurve.eachChild(function(line) {
	                    graphic.doLeaveHover(line);
	                });
	            }, this));
	        }
	    };
	    /**
	     * 创建Node的连接点
	     * @private
	     *
	     * @return {[type]} [description]
	     */
	    Connector.prototype.createAllconnectionPoint = function() {
	        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);
	        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length - 1].clone(), ConnectionPoint.TYPE_CONNECTOR);
	    };
	
	    /**
	     * 创建连接点
	     * @private
	     * @param  {[type]} shape [description]
	     * @param  {[type]} point [description]
	     * @param  {[type]} type  [description]
	     * @return {[type]}       [description]
	     */
	    Connector.prototype.connectionPointCreate = function(shape, point, type) {
	        var conPoint = new ConnectionPoint(this, point, type, this.options);
	        this.conPointsGroup.add(conPoint.shape);
	    };
	
	    /**
	     * 清空控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.clearHandles = function() {
	        for (var i = 0; i < this.handles.length; i++) {
	            this.remove(this.handles[i].handleShape);
	        }
	        this.handles = [];
	        if (this.conPointsGroup) {
	            this.conPointsGroup.removeAll();
	        }
	        //恢复原来的颜色
	        this.removeSelectedStyle();
	    };
	
	    /**
	     * 更新控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.refreshHandles = function() {
	        var points = this.turningPoints;
	        var beizierPoints = [];
	        var x, y, type;
	        if (this.handles.length > 0) {
	            if (this.options.style.lineType == Connector.TYPE_CURVE) {
	                // 获取曲线的路径点集合
	                beizierPoints = this.getPointsFromCurve();
	            }
	            for(var i = 0; i < this.handles.length; i++) {
	                var associatedPoint = this.handles[i].associatedPoint;
	                type = this.handles[i].type;
	                var index = points.findIndex(function(item) {
	                    return item.x == associatedPoint.x && item.y == associatedPoint.y;
	                });
	                if (index > 1) {
	                    if (type == 'h') {
	                        x = points[index - 1].x;
	                        y = (points[index - 1].y + points[index].y) / 2;
	                    } else if (type == 'v') {
	                        x = (points[index - 1].x + points[index].x) / 2;
	                        y = points[index - 1].y;
	                    }
	                    if (this.options.style.lineType == Connector.TYPE_CURVE && beizierPoints.length > 0) {
	                        var beizierPoint = zrUtil.find(beizierPoints[index - 2], function(point) {
	                            var dValue;
	                            if (type === 'h') {
	                                dValue = Math.abs(point.y - y);
	                            } else if (type === 'v') {
	                                dValue = Math.abs(point.x - x);
	                            }
	                            return dValue < 1;
	                        });
	                        if (beizierPoint) {
	                            x = beizierPoint.x;
	                            y = beizierPoint.y;
	                        }
	                    }
	                    this.handles[i].update(x, y);
	                }
	            }
	        }
	    }
	
	    /**
	     * 创建拆线 线断的控制点
	     * 曲线控制点位置计算精确
	     * @return {[type]} [description]
	     */
	    Connector.prototype.shapeSetHandle = function() {
	        var points = this.turningPoints;
	        // 获取曲线的路径点集合
	        var beizierPoints = this.getPointsFromCurve();
	        var type;
	        for (var i = 1; i < points.length - 2; i++) {
	            var h;
	            var x, y;
	            //是否在一条线上
	            var isCollineaityFirst = Util.collinearity(points[i - 1], points[i], points[i + 1]);
	            var isCollineaitySecond = Util.collinearity(points[i], points[i + 1], points[i + 2]);
	            if ((!isCollineaityFirst && (!isCollineaitySecond || points[i + 1].equals(points[i + 2]))) || ((!isCollineaityFirst || points[i - 1].equals(points[i])) && !isCollineaitySecond)) {
	
	                if (points[i].x === points[i + 1].x) { //same vertical
	                    x = points[i].x;
	                    y = (points[i].y + points[i + 1].y) / 2;
	                    type = 'h';
	                } else if (points[i].y === points[i + 1].y) { // same horizontal
	                    x = (points[i].x + points[i + 1].x) / 2;
	                    y = points[i].y;
	                    type = 'v';
	                }
	                if (x && y) {
	                    if (this.options.style.lineType == Connector.TYPE_CURVE && beizierPoints.length > 0) {
	                        var beizierPoint = zrUtil.find(beizierPoints[i - 1], function(point) {
	                            var dValue;
	                            if (type === 'h') {
	                                dValue = Math.abs(point.y - y);
	                            } else if (type === 'v') {
	                                dValue = Math.abs(point.x - x);
	                            }
	                            return dValue < 1;
	                        });
	                        if (beizierPoint) {
	                            x = beizierPoint.x;
	                            y = beizierPoint.y;
	                        }
	                    }
	                    h = new Handle(type, x, y, this);
	                    h.associatedPoint = points[i + 1]; // 连线控制点与this.turningPoints关联
	                }
	                if (h) {
	                    this.add(h.handleShape);
	                    this.handles.push(h);
	                }
	
	            }
	        }
	    };
	
	
	    /**
	     * 创建箭头
	     * @param  {[type]} name       [description]
	     * @param  {[type]} options [description]
	     * @return {[type]}            [description]
	     */
	    Connector.prototype.createSymbol = function(name, options) {
	        var symbolType = options.symbol.type;
	        var symbolSize = options.symbol.size;
	        if (symbolType === 'none') {
	            return;
	        }
	
	        if (!zrUtil.isArray(symbolSize)) {
	            symbolSize = [symbolSize, symbolSize];
	        }
	
	        var symbolZIndex = options.z;
	
	        if (options.symbol.z) { symbolZIndex = options.symbol.z }
	
	        var symbolPath = symbolUtil.createSymbol(
	            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,
	            symbolSize[0], symbolSize[1], symbolZIndex, options.symbol.color
	        );
	        symbolPath.name = name;
	
	        return symbolPath;
	    };
	
	    Connector.prototype.draw = function(name, content) {
	
	    }
	
	    /**
	     * 绘制线段上的文本
	     * 用矩形代替文本
	     * @param  {[type]} content [description]
	     * @param  {[type]} name [description]
	     * @param  {[type]} x       [description]
	     * @param  {[type]} y       [description]
	     * @param  {[type]} color   [description]
	     * @return {[type]}         [description]
	     */
	    Connector.prototype.drawText = function(name, content, x, y, type) {
	        if (!type) {
	            type = 'text';
	        }
	        var opt = zrUtil.isString(content) ? (type === 'text' ? {text:content, x:x, y:y} : {image:content, x:x, y:y})
	                                           : zrUtil.defaults({x:x, y:y}, content, true);
	
	        var textStyle = zrUtil.defaults(zrUtil.clone(this.options.text), opt, true);
	        var node;
	        if (type === 'text') {
	            var textBoundingRect = this.getTextBoundingRect(textStyle);
	            textStyle = zrUtil.defaults(textStyle, { fill: '#F9F9F9', transformText: true }, true);
	            node = new graphic.Rect({
	                shape: { width: textBoundingRect.width, height: textBoundingRect.height },
	                style: textStyle,
	                zlevel: 20,
	                name : name
	            });
	        } else {
	            node = new graphic.Image({
	                type: 'LinkImage',
	                style: textStyle,
	                zlevel: 20,
	                name : name
	            });
	        }
	        return {
	            text: node,
	            rect: node.getBoundingRect()
	        };
	    };
	     /**
	     * 获取线段文本包围盒
	     * @param  {[type]} content [description]
	     * @return {[type]}         [description]
	     */
	    Connector.prototype.getTextBoundingRect = function(text) {
	        var textRect = graphic.textContain.getBoundingRect(text.text, text.textFont);
	        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	        var textHeight = textRect.height || 12;
	        return {
	            width: textWidth,
	            height: textHeight
	        }
	    };
	
	    /**
	     * 获取线段的中间值
	     * @return {[type]} text
	     */
	    Connector.prototype.middle = function() {
	
	        if (this.options.style.lineType == Connector.TYPE_STRAIGHT || this.options.style.lineType == Connector.TYPE_CHAIN) {
	            var points = Util.getMaxLineLength(this.turningPoints);
	            //如果是求线段上的文字的中间值
	            // if(text) {
	            //     //取出字的长度，计算角度，
	            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	            //     var angle = Util.getAngle(points[0],points[1]);
	            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;
	            //     var newPoint = Util.getEndPoint(points[0], length, angle);
	            //     return [newPoint.x, newPoint.y];
	            // } else {
	            //     var middleX = (points[0].x + points[1].x)/2;
	            //     var middleY = (points[0].y + points[1].y) /2;
	            //     return [middleX, middleY];
	            // }
	            var middleX = (points[0].x + points[1].x) / 2;
	            var middleY = (points[0].y + points[1].y) / 2;
	            return [middleX, middleY];
	        } else if (this.options.style.lineType == Connector.TYPE_JAGGED) {
	
	            //find total distance
	            var distance = this.getLength();
	
	            //find between what turning points the half distance is
	            var index = -1;
	            var ellapsedDistance = 0;
	            for (var i = 0; i < this.turningPoints.length - 1; i++) {
	                index = i;
	                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);
	                if (ellapsedDistance + segment < distance / 2) {
	                    ellapsedDistance += segment;
	                } else {
	                    break;
	                }
	            }
	
	            //we have the middle distance somewhere between i(ndex) and i(ndex)+1
	            if (index != -1) {
	                var missingDistance = distance / 2 - ellapsedDistance;
	                if (Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3)) { //vertical segment (same x)
	                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];
	                } else if (Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3)) { //horizontal segment (same y)
	                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];
	                } else {
	                    console.error("Connector:middle() - this should never happen " + this.turningPoints[index] + " " + this.turningPoints[index + 1] + " nr of points " + this.turningPoints.length);
	                }
	
	            }
	        } else if (this.options.style.lineType == Connector.TYPE_CURVE) {
	            var t = 0.5;
	            var l = this.getLength();
	
	            var walked = 0;
	            for (var j = 0; j < this.turningPoints.length - 1; j++) {
	                if (walked + Util.distance(this.turningPoints[j], this.turningPoints[j + 1]) > l * t) {
	                    break;
	                }
	
	                walked += Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);
	            }
	
	            var rest = l * t - walked;
	            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);
	
	            //find the position/ration of the middle of Polyline on current segment
	            var segmentPercent = rest / currentSegmentLength;
	
	            var Xp = segmentPercent * (this.turningPoints[j + 1].x - this.turningPoints[j].x) + this.turningPoints[j].x;
	            var Yp = segmentPercent * (this.turningPoints[j + 1].y - this.turningPoints[j].y) + this.turningPoints[j].y;
	
	            return [Xp, Yp];
	
	        }
	
	        return null;
	    };
	
	    /**
	     * find total distance
	     * @return {Number} [description]
	     */
	    Connector.prototype.getLength = function() {
	        //find total distance
	        var distance = 0;
	        for (var i = 0; i < this.turningPoints.length - 1; i++) {
	            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);
	        }
	        return distance;
	    };
	
	    /**
	     * 转JSON对象 bpmn使用
	     * @return {[type]} [description]
	     */
	    Connector.prototype.toJSON = function() {
	
	        this.model.set("resourceId", this.resourceId);
	        this.model.set("properties.type", 14);
	
	        this.model.set("bounds.upperLeft.x", this.position[0]);
	        this.model.set("bounds.upperLeft.y", this.position[1]);
	        this.model.set("bounds.lowerRight.x", parseInt(this.position[0] + this.getBoundingRect().width));
	        this.model.set("bounds.lowerRight.y", parseInt(this.position[1] + this.getBoundingRect().height));
	        this.model.set("style.sPos", this.options.position.startPos);
	        this.model.set("style.ePos", this.options.position.endPos);
	        this.model.set("style.lineDash", this.options.style.lineDash);
	        this.model.set("style.stroke", this.options.style.stroke);
	        this.model.set("symbol.type", this.options.symbol.type);
	        this.model.set("dockers", this.turningPoints);
	        return this.model.option;
	    };
	
	    /**
	     * refreshModel  flow当序列化的时候调用 更新线段的位置 及线上的icons
	     * @return {[type]} [description]
	     */
	    Connector.prototype.refreshModel = function() {
	        this.model.set("options", zrUtil.clone(this.options));
	        this.model.set("options.dockers", this.turningPoints);
	        var icons = [];
	        for (var i = 0; i < this.icons.length; i++) {
	            var iconNode = this.icons[i];
	            var option = [iconNode.key, {
	                icon: iconNode.style.image,
	                width: iconNode.style.width,
	                height: iconNode.style.height
	            }];
	            icons.push(option);
	        }
	        this.model.set("icons", icons);
	    };
	
	    /**
	     * 调整曲线的形状
	     * @param  {array} points 点数组
	     * @return {void}
	     */
	    Connector.prototype.modifyCurve = function(points) {
	        var sol = this.getCurvePoint(points);
	
	        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段
	        var willDelCurves = [];
	        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve; j++) {
	            willDelCurves.push(this.groupCurve.childAt(j));
	        }
	        zrUtil.each(willDelCurves, function(curve) {
	            this.groupCurve.remove(curve);
	        }, this);
	        // 2. 遍历曲线   如果存在则直接设置形状，否则创建
	        for (var i = 0; i < sol.length; i++) {
	            var line = this.groupCurve.childAt(i);
	            if (line) {
	                line.attr('shape', sol[i]);
	            } else {
	                var cure = new graphic.BezierCurve({
	                   // position: this.options.position,
	                    style: this.options.style,
	                    shape: sol[i],
	                    z: this.options.z
	                });
	                this.groupCurve.add(cure);
	                this.createHoverStyle(cure);
	            }
	        }
	    };
	
	    /**
	     * @desc 获取点，这里可以设置点的个数
	     * @param {number} num 点个数
	     * @param {Array} p1 点坐标
	     * @param {Array} p2 点坐标
	     * @param {Array} p3 点坐标
	     * @param {Array} p4 点坐标
	     * 如果参数是 num, p1, p2 为一阶贝塞尔
	     * 如果参数是 num, p1, c1, p2 为二阶贝塞尔
	     * 如果参数是 num, p1, c1, c2, p2 为三阶贝塞尔
	     */
	    Connector.prototype.getBezierPoints = function(point, num) {
	        var points = [];
	        var func = null;
	        var start = point.start;
	        var cp1 = point.cp1;
	        var cp2 = point.cp2;
	        var end = point.end;
	        if (!num || num <= 50) {
	            num = 50;
	        }
	        if (!cp1 && !cp2) {
	            func = this.oneBezier;
	        } else if (cp1 && !cp2) {
	            func = this.twoBezier;
	        } else if (cp1 && cp2) {
	            func = this.threeBezier;
	        }
	        for (var i = 0; i < num; i++) {
	            points.push(func(i / num, start, cp1, cp2, end));
	        }
	        points.push(end);
	        return points;
	    };
	
	    /**
	     * @desc 一阶贝塞尔
	     * @param {number} t 当前百分比
	     * @param {Array} start 起点坐标
	     * @param {Array} end 终点坐标
	     */
	    Connector.prototype.oneBezier = function(t, start, cp1, cp2, end) {
	        var x1 = start.x1;
	        var y1 = start.y1;
	        var x2 = end.x2;
	        var y2 = end.y2;
	        return {
	            x: x1 + (x2 - x1) * t,
	            y: y1 + (y2 - y1) * t
	        }
	    };
	
	    /**
	     * @desc 二阶贝塞尔
	     * @param {number} t 当前百分比
	     * @param {Array} start 起点坐标
	     * @param {Array} end 终点坐标
	     * @param {Array} cp1 控制点
	     */
	    Connector.prototype.twoBezier = function(t, start, cp1, cp2, end) {
	        var x1 = start.x1;
	        var y1 = start.y1;
	        var x2 = end.x2;
	        var y2 = end.y2;
	        var cpx1 = cp1.cpx1;
	        var cpy1 = cp1.cpy1;
	        var x = (1 - t) * (1 - t) * x1 + 2 * t * (1 - t) * cpx1 + t * t * x2;
	        var y = (1 - t) * (1 - t) * y1 + 2 * t * (1 - t) * cpy1 + t * t * y2;
	        return {
	            x: x,
	            y: y
	        }
	    };
	
	    /**
	     * @desc 三阶贝塞尔
	     * @param {number} t 当前百分比
	     * @param {Array} start 起点坐标
	     * @param {Array} end 终点坐标
	     * @param {Array} cp1 控制点
	     * @param {Array} cp2 控制点
	     */
	    Connector.prototype.threeBezier = function(t, start, cp1, cp2, end) {
	        var x1 = start.x1;
	        var y1 = start.y1;
	        var x2 = end.x2;
	        var y2 = end.y2;
	        var cpx1 = cp1.cpx1;
	        var cpy1 = cp1.cpy1;
	        var cpx2 = cp2.cpx2;
	        var cpy2 = cp2.cpy2;
	        var x =
	            x1 * (1 - t) * (1 - t) * (1 - t) +
	            3 * cpx1 * t * (1 - t) * (1 - t) +
	            3 * cpx2 * t * t * (1 - t) +
	            x2 * t * t * t;
	        var y =
	            y1 * (1 - t) * (1 - t) * (1 - t) +
	            3 * cpy1 * t * (1 - t) * (1 - t) +
	            3 * cpy2 * t * t * (1 - t) +
	            y2 * t * t * t;
	        return {
	            x: x,
	            y: y
	        }
	    };
	
	    /**
	     * 获取曲线上的点轨迹
	     * @return {array}
	     */
	    Connector.prototype.getPointsFromCurve = function() {
	        var that = this;
	        var percent = 0;
	        var points = this.turningPoints;
	        var maxMinPoints = Util.getMaxLineLength(points);
	        var beizierPoints = [];
	        percent = parseInt(maxMinPoints[0].x - maxMinPoints[1].x);
	        if ((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {
	            var sols = this.transformCurvePoint(this.getCurvePoint(points));
	            if (sols.length > 0) {
	                sols.forEach(function(item) {
	                    beizierPoints.push(that.getBezierPoints(item, percent))
	                });
	            }
	        }
	        return beizierPoints;
	    }
	
	    /**
	     * 根据传入的点数组转换成需要的类型
	     * @param  {array} sol 点数组
	     * @return {object}
	     */
	    Connector.prototype.transformCurvePoint = function(sol) {
	        var points = [];
	        sol.forEach(function(point) {
	            var pointParam = {};
	            if (point.x1 && point.y1) {
	                pointParam.start = {
	                    x1: point.x1,
	                    y1: point.y1
	                }
	            }
	            if (point.cpx1 && point.cpy1) {
	                pointParam.cp1 = {
	                    cpx1: point.cpx1,
	                    cpy1: point.cpy1
	                }
	            }
	            if (point.cpx2 && point.cpy2) {
	                pointParam.cp2 = {
	                    cpx2: point.cpx2,
	                    cpy2: point.cpy2
	                }
	            }
	            if (point.x2 && point.y2) {
	                pointParam.end = {
	                    x2: point.x2,
	                    y2: point.y2
	                }
	            }
	            points.push(pointParam);
	        });
	        return points;
	    }
	
	    /**
	     * 根据传入的点数组计算曲线的点
	     * @param  {array} P 点数组
	     * @return {object}        曲线的点数组
	     */
	    Connector.prototype.getCurvePoint = function(P) {
	        var n = P.length;
	        var sol = [];
	        if (n === 3) {
	            sol.push({
	                x1: P[0].x,
	                y1: P[0].y,
	                cpx1: P[1].x,
	                cpy1: P[1].y,
	                x2: P[2].x,
	                y2: P[2].y
	            });
	            return sol;
	        } else if (n === 4) {
	            sol.push({
	                x1: P[0].x,
	                y1: P[0].y,
	                cpx1: P[1].x,
	                cpy1: P[1].y,
	                cpx2: P[2].x,
	                cpy2: P[2].y,
	                x2: P[3].x,
	                y2: P[3].y
	            });
	            return sol;
	        }
	
	
	        /**Computes the sum between two point
	         *@param p1 - {Point}
	         *@param p2 - {Point}
	         *@return {Point} the sum of initial points
	         **/
	        function sum(p1, p2) {
	            return new Point(p1.x + p2.x, p1.y + p2.y);
	        }
	
	
	        /**Computes the division of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function divide(p, nr) {
	            if (nr == 0) {
	                throw "Division by zero not allowed (yet :) " + this.callee;
	            }
	            return new Point(p.x / nr, p.y / nr);
	        }
	
	        /**Computes the multiplication of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function multiply(p, nr) {
	            return new Point(p.x * nr, p.y * nr);
	        }
	
	
	
	
	        /*
	         *I do not get why first 4 must be 0 and last 3 of same value.....
	         *but otherwise we will get division by zero
	         */
	        var k = [0, 0, 0];
	
	        var j;
	        for (j = 0; j <= n - 3; j++) {
	            k.push(j);
	        }
	
	        k.push(n - 3, n - 3);
	
	
	
	        for (var i = 1; i <= n - 3; i++) {
	            //q1 - compute start point
	            var q1 = divide(sum(multiply(P[i], k[i + 4] - k[i + 2]), multiply(P[i + 1], k[i + 2] - k[i + 1])), k[i + 4] - k[i + 1]);
	
	            //q0 - compute 1st controll point
	            var q_01 = (k[i + 3] - k[i + 2]) / (k[i + 3] - k[i + 1]);
	            var q_02 = divide(sum(multiply(P[i - 1], k[i + 3] - k[i + 2]), multiply(P[i], k[i + 2] - k[i])), k[i + 3] - k[i]);
	            var q_03 = multiply(q1, (k[i + 2] - k[i + 1]) / (k[i + 3] - k[i + 1]));
	            var q0 = sum(multiply(q_02, q_01), q_03);
	
	            //q2 - compute 2nd controll point
	            var q2 = divide(sum(multiply(P[i], k[i + 4] - k[i + 3]), multiply(P[i + 1], k[i + 3] - k[i + 1])), k[i + 4] - k[i + 1]);
	
	            //q3 - compute end point
	            var q_31 = (k[i + 3] - k[i + 2]) / (k[i + 4] - k[i + 2]);
	            var q_32 = divide(sum(multiply(P[i + 1], k[i + 5] - k[i + 3]), multiply(P[i + 2], k[i + 3] - k[i + 2])), k[i + 5] - k[i + 2]);
	            var q_33 = multiply(q2, (k[i + 4] - k[i + 3]) / (k[i + 4] - k[i + 2]));
	            var q3 = sum(multiply(q_32, q_31), q_33);
	
	            //store solution
	            //
	            sol.push({
	                x1: q0.x,
	                y1: q0.y,
	                cpx1: q1.x,
	                cpy1: q1.y,
	                cpx2: q2.x,
	                cpy2: q2.y,
	                x2: q3.x,
	                y2: q3.y
	            });
	        }
	
	        return sol;
	    };
	
	
	    Util.inherits(Connector, Node);
	
	    module.exports = Connector;
	
	


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// Symbol factory
	
	
	    var graphic = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(27);
	    /**
	     * Triangle shape
	     * @inner
	     */
	    var Triangle = graphic.extendShape({
	        type: 'triangle',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy + height);
	            path.lineTo(cx - width, cy + height);
	            path.closePath();
	        }
	    });
	    /**
	     * Diamond shape
	     * @inner
	     */
	    var Diamond = graphic.extendShape({
	        type: 'diamond',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy);
	            path.lineTo(cx, cy + height);
	            path.lineTo(cx - width, cy);
	            path.closePath();
	        }
	    });
	
	    /**
	     * Pin shape
	     * @inner
	     */
	    var Pin = graphic.extendShape({
	        type: 'pin',
	        shape: {
	            // x, y on the cusp
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (path, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var w = shape.width / 5 * 3;
	            // Height must be larger than width
	            var h = Math.max(w, shape.height);
	            var r = w / 2;
	
	            // Dist on y with tangent point and circle center
	            var dy = r * r / (h - r);
	            var cy = y - h + r + dy;
	            var angle = Math.asin(dy / r);
	            // Dist on x with tangent point and circle center
	            var dx = Math.cos(angle) * r;
	
	            var tanX = Math.sin(angle);
	            var tanY = Math.cos(angle);
	
	            path.arc(
	                x, cy, r,
	                Math.PI - angle,
	                Math.PI * 2 + angle
	            );
	
	            var cpLen = r * 0.6;
	            var cpLen2 = r * 0.7;
	            path.bezierCurveTo(
	                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,
	                x, y - cpLen2,
	                x, y
	            );
	            path.bezierCurveTo(
	                x, y - cpLen2,
	                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,
	                x - dx, cy + dy
	            );
	            path.closePath();
	        }
	    });
	
	    /**
	     * Arrow shape
	     * @inner
	     */
	    var Arrow = graphic.extendShape({
	
	        type: 'arrow',
	
	        shape: {
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var height = shape.height;
	            var width = shape.width;
	            var x = shape.x;
	            var y = shape.y;
	            var dx = width / 3 * 2;
	            ctx.moveTo(x, y);
	            ctx.lineTo(x + dx, y + height);
	            ctx.lineTo(x, y + height / 4 * 3);
	            ctx.lineTo(x - dx, y + height);
	            ctx.lineTo(x, y);
	            ctx.closePath();
	        }
	    });
	
	    /**
	     * Map of path contructors
	     * @type {Object.<string, module:zrender/graphic/Path>}
	     */
	    var symbolCtors = {
	        line: graphic.Line,
	
	        rect: graphic.Rect,
	
	        roundRect: graphic.Rect,
	
	        square: graphic.Rect,
	
	        circle: graphic.Circle,
	
	        diamond: Diamond,
	
	        pin: Pin,
	
	        arrow: Arrow,
	
	        triangle: Triangle
	    };
	
	    var symbolShapeMakers = {
	
	        line: function (x, y, w, h, shape) {
	            // FIXME
	            shape.x1 = x;
	            shape.y1 = y + h / 2;
	            shape.x2 = x + w;
	            shape.y2 = y + h / 2;
	        },
	
	        rect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        roundRect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	            shape.r = Math.min(w, h) / 4;
	        },
	
	        square: function (x, y, w, h, shape) {
	            var size = Math.min(w, h);
	            shape.x = x;
	            shape.y = y;
	            shape.width = size;
	            shape.height = size;
	        },
	
	        circle: function (x, y, w, h, shape) {
	            // Put circle in the center of square
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.r = Math.min(w, h) / 2;
	        },
	
	        diamond: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        pin: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        arrow: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        triangle: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        }
	    };
	
	    var symbolBuildProxies = {};
	    for (var name in symbolCtors) {
	        symbolBuildProxies[name] = new symbolCtors[name]();
	    }
	
	    var Symbol = graphic.extendShape({
	
	        type: 'symbol',
	
	        shape: {
	            symbolType: '',
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        beforeBrush: function () {
	            var style = this.style;
	            var shape = this.shape;
	            // FIXME
	            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
	                style.textPosition = ['50%', '40%'];
	                style.textAlign = 'center';
	                style.textVerticalAlign = 'middle';
	            }
	        },
	
	        buildPath: function (ctx, shape) {
	            var symbolType = shape.symbolType;
	            var proxySymbol = symbolBuildProxies[symbolType];
	            if (shape.symbolType !== 'none') {
	                if (!proxySymbol) {
	                    // Default rect
	                    symbolType = 'rect';
	                    proxySymbol = symbolBuildProxies[symbolType];
	                }
	                symbolShapeMakers[symbolType](
	                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape
	                );
	                proxySymbol.buildPath(ctx, proxySymbol.shape);
	            }
	        }
	    });
	
	    // Provide setColor helper method to avoid determine if set the fill or stroke outside
	    var symbolPathSetColor = function (color) {
	        if (this.type !== 'image') {
	            var symbolStyle = this.style;
	            var symbolShape = this.shape;
	            if (symbolShape && symbolShape.symbolType === 'line') {
	                symbolStyle.stroke = color;
	            }
	            else if (this.__isEmptyBrush) {
	                symbolStyle.stroke = color;
	                symbolStyle.fill = '#fff';
	            }
	            else {
	                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
	                symbolStyle.fill && (symbolStyle.fill = color);
	                symbolStyle.stroke && (symbolStyle.stroke = color);
	            }
	            this.dirty();
	        }
	    };
	
	    var symbolUtil = {
	        /**
	         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
	         * @param {string} symbolType
	         * @param {number} x
	         * @param {number} y
	         * @param {number} w
	         * @param {number} h
	         * @param {number} z
	         * @param {string} color
	         */
	        createSymbol: function (symbolType, x, y, w, h, z, color) {
	            var isEmpty = symbolType.indexOf('empty') === 0;
	            if (isEmpty) {
	                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
	            }
	            var symbolPath;
	
	            if (symbolType.indexOf('image://') === 0) {
	                symbolPath = new graphic.Image({
	                    style: {
	                        image: symbolType.slice(8),
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	            else if (symbolType.indexOf('path://') === 0) {
	                symbolPath = graphic.makePath(symbolType.slice(7), {z: z, rectHover: true}, new BoundingRect(x, y, w, h));
	            }
	            else {
	                symbolPath = new Symbol({
	                    shape: {
	                        symbolType: symbolType,
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	
	            symbolPath.__isEmptyBrush = isEmpty;
	
	            symbolPath.setColor = symbolPathSetColor;
	
	            symbolPath.setColor(color);
	
	            return symbolPath;
	        }
	    };
	
	    module.exports = symbolUtil;
	


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 画句柄
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(4);
	    var Util = __webpack_require__(65);
	    function Handle(type, x, y, connector){
	        this.type = type;
	
	        this.x = x;
	
	        this.y = y;
	
	        this.visible = true;
	
	        this.connector = connector;
	
	        this.handleShape = new graphic.Circle({
	            shape: {
	                cx: x,
	                cy: y,
	                r: Handle.RADIUS
	            },
	
	            style: {
	                fill: "rgb(0,255,0)",
	                stroke:"rgb(0,0,0)"
	            },
	            zlevel : connector.options.z + 2,  //节点Z为1 线段为0;
	            draggable:true
	        });
	
	        var that = this;
	        this.handleShape.on("drag", function(e) {
	            that.actionConnector(e.offsetX,e.offsetY);
	        });
	       // return this.circle;
	    }
	
	    Handle.RADIUS = 4;
	
	    Handle.prototype = {
	
	        constructor : Handle,
	
	        equals : function(anotherHandle){
	            if(!anotherHandle instanceof Handle){
	                return false;
	            }
	
	            return this.type == anotherHandle.type
	            && this.x == anotherHandle.x
	            && this.y == anotherHandle.y
	            && this.visible == anotherHandle.visible;
	        },
	        update: function (x, y) {
	            this.handleShape.attr('position', [0, 0]);
	            this.x = x;
	            this.y = y;
	            this.handleShape.setShape({
	                cx: x,
	                cy: y
	            });
	        },
	
	        /**
	         * 移动句柄
	         * @param  {[type]} newX [description]
	         * @param  {[type]} newY [description]
	         * @return {[type]}      [description]
	         */
	        actionConnector: function(newX, newY){
	            switch(this.type){
	                case 'v':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if (this.associatedPoint && this.connector.turningPoints[i].x == this.associatedPoint.x && this.connector.turningPoints[i].y == this.associatedPoint.y) {
	                            index = i;
	                            break;
	                        }
	                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y
	                            && this.connector.turningPoints[i].y == this.y
	                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x
	                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)
	                        {
	                            index = i;
	                        }
	                    }
	                    var deltaY = newY - this.y;
	                    var translationMatrix = Util.translationMatrix(0, deltaY);
	
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	
	                    break;
	
	                case 'h':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if (this.associatedPoint && this.connector.turningPoints[i].x == this.associatedPoint.x && this.connector.turningPoints[i].y == this.associatedPoint.y) {
	                            index = i;
	                            break;
	                        }
	                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x
	                            && this.connector.turningPoints[i].x == this.x
	                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y
	                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)
	                            {
	                            index = i;
	                        }
	                    }
	                    var deltaX = newX-this.x;
	                    var translationMatrix = Util.translationMatrix(deltaX, 0);
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	
	                    break;
	            }
	           //. this.shape.updateMiddleText();
	        }
	    };
	    module.exports = Handle;
	
	
	


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连线动态效果
	 * @author miao.cunzhi
	 */
	
	    var zrUtil = __webpack_require__(5);
	    var vec2 = __webpack_require__(15);
	    var curveUtil = __webpack_require__(31);
	    var symbolUtil = __webpack_require__(83);
	
	    function EffectLine(symbol, options, groupCurve, polyLine) {
	        this._lastFrame = 0;
	        this._lastFramePercent = 0;
	        this.symbol = symbol;
	        this.groupCurve = groupCurve;
	        this.initSymbol(options, polyLine);
	    }
	    var EffectLineProto = EffectLine.prototype;
	
	    EffectLineProto.initSymbol = function(options, polyLine) {
	        var that = this;
	        this.symbol.z2 = 100;
	        this.symbol.culling = true;
	        var period = options.effect.period * 1000;
	        this.symbol.__t = 0;
	        this.symbol.stopAnimation();
	        if ((options.style.lineType == "curve")) {
	            if (this.groupCurve) {
	                var i = 0;
	                period = period / this.groupCurve._children.length;
	                this.groupCurveAnimate(this.groupCurve._children[0], i, period);
	            }
	
	        } else {
	            this.symbol.animate('', true)
	                .when(period, {
	                    __t: 1
	                })
	                .delay(0)
	                .during(function() {
	                    that.updateSymbolPositionPolyline();
	                })
	                .start();
	            this.setAnimationPointsPolyline(polyLine.shape.points);
	        }
	
	    };
	
	    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {
	        var that = this;
	        if (curveLine == undefined) {
	            curveLine = this.groupCurve._children[0];
	            i = 0;
	        }
	        var points;
	        var pos = curveLine.shape;
	        points = [
	            [pos.x1, pos.y1],
	            [pos.x2, pos.y2],
	            [pos.cpx1, pos.cpy1],
	            [pos.cpx2, pos.cpy2]
	        ];
	        this.setAnimationPointsBezierCurve(points);
	        this.symbol.animate('')
	            .when(period, {
	                __t: 1
	            })
	            .delay(0)
	            .during(function() {
	                that.updateSymbolPositionBezierCurve();
	            })
	            .done(function() {
	                that.symbol.__t = 0;
	                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);
	            })
	            .start();
	
	    };
	
	
	    EffectLineProto.setAnimationPointsBezierCurve = function(points) {
	        this.symbol.__p1 = points[0];
	        this.symbol.__p2 = points[1];
	        this.symbol.__cp1 = points[2] || [
	            (points[0][0] + points[1][0]) / 2,
	            (points[0][1] + points[1][1]) / 2
	        ];
	        this.symbol.__cp2 = points[3];
	    };
	
	    EffectLineProto.updateSymbolPositionBezierCurve = function() {
	        var p1 = this.symbol.__p1;
	        var p2 = this.symbol.__p2;
	        var cp1 = this.symbol.__cp1;
	        var cp2 = this.symbol.__cp2;
	        var t = this.symbol.__t;
	        var pos = this.symbol.position;
	        var tx, ty;
	        if (cp2[0] != undefined) {
	            var cubicAt = curveUtil.cubicAt;
	            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;
	            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);
	            // Tangent
	            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);
	        } else {
	            var quadraticAt = curveUtil.quadraticAt;
	            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;
	            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);
	            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);
	            // Tangent
	            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);
	            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
	        }
	        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
	
	        this.symbol.ignore = false;
	    };
	
	    EffectLineProto.setAnimationPointsPolyline = function(points) {
	        this._points = points;
	        var accLenArr = [0];
	        var len = 0;
	        for (var i = 1; i < points.length; i++) {
	            var p1 = points[i - 1];
	            var p2 = points[i];
	            len += vec2.dist(p1, p2);
	            accLenArr.push(len);
	        }
	        if (len === 0) {
	            return;
	        }
	
	        for (var j = 0; j < accLenArr.length; j++) {
	            accLenArr[j] /= len;
	        }
	        this._offsets = accLenArr;
	        this._length = len;
	        this.symbol._lastFrame = 0;
	        this.symbol.__lastFramePercent = 0;
	    };
	
	    EffectLineProto.updateSymbolPositionPolyline = function() {
	        var t = this.symbol.__t;
	        var points = this._points;
	        var offsets = this._offsets;
	        var len = points.length;
	
	        if (!offsets) {
	            // Has length 0
	            return;
	        }
	
	        var lastFrame = this._lastFrame;
	        var frame;
	
	        if (t < this._lastFramePercent) {
	            // Start from the next frame
	            // PENDING start from lastFrame ?
	            var start = Math.min(lastFrame + 1, len - 1);
	            for (frame = start; frame >= 0; frame--) {
	                if (offsets[frame] <= t) {
	                    break;
	                }
	            }
	            // PENDING really need to do this ?
	            frame = Math.min(frame, len - 2);
	        } else {
	            for (var frame = lastFrame; frame < len; frame++) {
	                if (offsets[frame] > t) {
	                    break;
	                }
	            }
	            frame = Math.min(frame - 1, len - 2);
	        }
	        vec2.lerp(
	            this.symbol.position, points[frame], points[frame + 1],
	            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])
	        );
	
	        this._lastFrame = frame;
	        this._lastFramePercent = t;
	        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);
	        this.symbol.rotation = angle - Math.PI / 2;
	        this.symbol.ignore = false;
	    };
	    module.exports = EffectLine;
	


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 控制点
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(4);
	    function ConnectionPoint(connector, point, type, options){
	        this.connector = connector;
	
	        this.point = point.clone();
	
	        this.type = type;
	
	        this.color = ConnectionPoint.NORMAL_COLOR;
	
	        this.oType = 'ConnectionPoint';
	
	        this.shape = new graphic.Circle({
	            shape: {
	                cx: this.point.x,
	                cy: this.point.y,
	                r: ConnectionPoint.RADIUS
	            },
	
	            style: {
	                fill: this.color,
	                stroke:'#000000'
	            },
	            z : options.z + 2  //节点Z为1 线段为0;
	        });
	        this.shape.type =  this.type;
	
	        this.shape.connector = connector;
	        //return this.circle;
	    }
	
	    ConnectionPoint.NORMAL_COLOR = "#FFFF33"; //yellow.
	
	    ConnectionPoint.OVER_COLOR = "#FF9900"; //orange
	
	    ConnectionPoint.CONNECTED_COLOR = "#ff0000"; //red
	
	    ConnectionPoint.RADIUS = 4;
	
	    ConnectionPoint.TYPE_FIGURE = 'figure';
	
	    ConnectionPoint.TYPE_CONNECTOR = 'connector';
	
	    ConnectionPoint.prototype = {
	
	        constructor : ConnectionPoint,
	
	        equals : function(anotherConnectionPoint){
	            return this.point.equals(anotherConnectionPoint.point)
	            && this.connector == anotherConnectionPoint.connector
	            && this.type == anotherConnectionPoint.type
	            && this.color == anotherConnectionPoint.color
	            && this.radius == anotherConnectionPoint.radius;
	        }
	
	
	    };
	    module.exports = ConnectionPoint;
	
	
	


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 节点等的模型
	 * 里面存的数据用来处理序列化和反序列化
	 * @class fish.topo.model
	 */
	
	
	    var zrUtil = __webpack_require__(5);
	    var clazzUtil = __webpack_require__(88);
	
	    function Model(option, parentModel,  extraOpt) {
	        this.parentModel = parentModel;
	        this.option = option;
	
	        // Simple optimization
	        if (this.init) {
	            if (arguments.length <= 3) {
	                this.init(option, parentModel,  extraOpt);
	            }
	            else {
	                this.init.apply(this, arguments);
	            }
	        }
	    }
	
	    Model.prototype = {
	
	        constructor: Model,
	
	        /**
	         * Model 的初始化函数
	         * @private
	         * @param {Object} option
	         */
	        init: function (option) {
	            zrUtil.merge(option, this.getDefaultOption());
	        },
	
	        getDefaultOption: function () {
	            if (!this.hasOwnProperty('__defaultOption')) {
	                var optList = [];
	                var Class = this.constructor;
	                while (Class) {
	                    var opt = Class.prototype.defaultOption;
	                    opt && optList.push(opt);
	                    Class = Class.superClass;
	                }
	
	                var defaultOption = {};
	                for (var i = optList.length - 1; i >= 0; i--) {
	                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);
	                }
	                this.__defaultOption = defaultOption;
	            }
	            return this.__defaultOption;
	        },
	
	        /**
	         * @private
	         */
	        mergeOption: function (option) {
	            zrUtil.merge(this.option, option, true);
	        },
	
	        /**
	         * 获取model的某个属性的值
	         * @param {string} path model中的属性
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.get("options.text");
	         */
	        get: function (path, ignoreParent) {
	            if (!path) {
	                return this.option;
	            }
	
	            if (typeof path === 'string') {
	                path = path.split('.');
	            }
	
	            var obj = this.option;
	            var parentModel = this.parentModel;
	            for (var i = 0; i < path.length; i++) {
	                // obj could be number/string/... (like 0)
	                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;
	                if (obj == null) {
	                    break;
	                }
	            }
	            if (obj == null && parentModel && !ignoreParent) {
	                obj = parentModel.get(path);
	            }
	            return obj;
	        },
	
	        /**
	         * 设置model的某个属性的值
	         * @param {string} path model中的属性
	         * @param {String} value 所需要设置的值
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.set("options.text","例子");
	         */
	        set: function (path, value) {
	            var obj = this.option;
	
	            if (path.indexOf(".") == -1) {
	                obj[path] = value;
	            } else {
	                var fieldArray  = path.split('.');
	                var n = fieldArray.length;
	                var currentRef = obj;
	                var fieldName;
	
	                for (var i = 0; i < n - 1; i++) {
	                    fieldName = fieldArray[i];
	                    if(currentRef[fieldName] == null) {
	                        currentRef[fieldName] = {};
	                    }
	                    currentRef = currentRef[fieldName];
	                }
	                fieldName = fieldArray[n-1];
	                currentRef[fieldName] = value;
	            }
	        },
	
	        /**
	         * @private
	         */
	        getShallow: function (key, ignoreParent) {
	            var option = this.option;
	            var val = option && option[key];
	            var parentModel = this.parentModel;
	            if (val == null && parentModel && !ignoreParent) {
	                val = parentModel.getShallow(key);
	            }
	            return val;
	        },
	
	        /**
	         * @private
	         */
	        getModel: function (path, parentModel) {
	            var obj = this.get(path, true);
	            var thisParentModel = this.parentModel;
	            var model = new Model(
	                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))
	            );
	            return model;
	        },
	
	        /**
	         *清空model的option
	         * @private
	         */
	        isEmpty: function () {
	            return this.option == null;
	        },
	
	        restoreData: function () {},
	
	        /**
	         * @private
	         */
	        clone: function () {
	            var Ctor = this.constructor;
	            return new Ctor(zrUtil.clone(this.option));
	        }
	    };
	
	    // Enable Model.extend.
	    clazzUtil.enableClassExtend(Model);
	
	    module.exports = Model;
	


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var zrUtil = __webpack_require__(5);
	
	    var clazz = {};
	
	    var TYPE_DELIMITER = '.';
	    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';
	    /**
	     * @public
	     */
	    var parseClassType = clazz.parseClassType = function (componentType) {
	        var ret = {main: '', sub: ''};
	        if (componentType) {
	            componentType = componentType.split(TYPE_DELIMITER);
	            ret.main = componentType[0] || '';
	            ret.sub = componentType[1] || '';
	        }
	        return ret;
	    };
	    /**
	     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数
	     */
	    clazz.enableClassExtend = function (RootClass, preConstruct) {
	        RootClass.extend = function (proto) {
	            var ExtendedClass = function () {
	                preConstruct && preConstruct.apply(this, arguments);
	                RootClass.apply(this, arguments);
	            };
	
	            zrUtil.extend(ExtendedClass.prototype, proto);
	
	            ExtendedClass.extend = this.extend;
	            ExtendedClass.superCall = superCall;
	            ExtendedClass.superApply = superApply;
	            zrUtil.inherits(ExtendedClass, this);
	            ExtendedClass.superClass = this;
	
	            return ExtendedClass;
	        };
	    };
	
	    // superCall should have class info, which can not be fetch from 'this'.
	    // Consider this case:
	    // class A has method f,
	    // class B inherits class A, overrides method f, f call superApply('f'),
	    // class C inherits class B, do not overrides method f,
	    // then when method of class C is called, dead loop occured.
	    function superCall(context, methodName) {
	        var args = zrUtil.slice(arguments, 2);
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    function superApply(context, methodName, args) {
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    /**
	     * @param {Object} entity
	     * @param {Object} options
	     * @param {boolean} [options.registerWhenExtend]
	     * @public
	     */
	    clazz.enableClassManagement = function (entity, options) {
	        options = options || {};
	
	        /**
	         * Component model classes
	         * key: componentType,
	         * value:
	         *     componentClass, when componentType is 'xxx'
	         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
	         * @type {Object}
	         */
	        var storage = {};
	
	        entity.registerClass = function (Clazz, componentType) {
	            if (componentType) {
	                componentType = parseClassType(componentType);
	
	                if (!componentType.sub) {
	                    if (storage[componentType.main]) {
	                        //已经注册过了，直接返回
	                        return;
	                    }
	                    storage[componentType.main] = Clazz;
	                }
	                else if (componentType.sub !== IS_CONTAINER) {
	                    var container = makeContainer(componentType);
	                    container[componentType.sub] = Clazz;
	                }
	            }
	            return Clazz;
	        };
	
	        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {
	            var Clazz = storage[componentTypeMain];
	
	            if (Clazz && Clazz[IS_CONTAINER]) {
	                Clazz = subType ? Clazz[subType] : null;
	            }
	
	            if (throwWhenNotFound && !Clazz) {
	                throw new Error(
	                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'
	                );
	            }
	
	            return Clazz;
	        };
	
	        entity.getClassesByMainType = function (componentType) {
	            componentType = parseClassType(componentType);
	
	            var result = [];
	            var obj = storage[componentType.main];
	
	            if (obj && obj[IS_CONTAINER]) {
	                zrUtil.each(obj, function (o, type) {
	                    type !== IS_CONTAINER && result.push(o);
	                });
	            }
	            else {
	                result.push(obj);
	            }
	
	            return result;
	        };
	
	        entity.hasClass = function (componentType) {
	            // Just consider componentType.main.
	            componentType = parseClassType(componentType);
	            return !!storage[componentType.main];
	        };
	
	        /**
	         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
	         */
	        entity.getAllClassMainTypes = function () {
	            var types = [];
	            zrUtil.each(storage, function (obj, type) {
	                types.push(type);
	            });
	            return types;
	        };
	
	        /**
	         * If a main type is container and has sub types
	         * @param  {string}  componentType
	         * @return {boolean}
	         */
	        entity.hasSubTypes = function (componentType) {
	            componentType = parseClassType(componentType);
	            var obj = storage[componentType.main];
	            return obj && obj[IS_CONTAINER];
	        };
	
	        entity.parseClassType = parseClassType;
	
	        function makeContainer(componentType) {
	            var container = storage[componentType.main];
	            if (!container || !container[IS_CONTAINER]) {
	                container = storage[componentType.main] = {};
	                container[IS_CONTAINER] = true;
	            }
	            return container;
	        }
	
	        if (options.registerWhenExtend) {
	            var originalExtend = entity.extend;
	            if (originalExtend) {
	                entity.extend = function (proto) {
	                    var ExtendedClass = originalExtend.call(this, proto);
	                    return entity.registerClass(ExtendedClass, proto.type);
	                };
	            }
	        }
	
	        return entity;
	    };
	
	    module.exports = clazz;
	


/***/ }),
/* 89 */
/***/ (function(module, exports) {

	/**
	 * 操作图标类
	 * @author wang.xiaohu
	 */
	
	
	    var IconOperation = {
	        STRAIGHT_SVG: 'M937.353846 724.676923C882.215385 669.538462 795.569231 661.661538 732.553846 701.046154L362.338462 330.830769C401.723077 267.815385 393.846154 181.169231 338.707692 126.030769 267.815385 55.138462 165.415385 55.138462 94.523077 126.030769 23.630769 196.923077 23.630769 299.323077 94.523077 370.215385 149.661538 425.353846 236.307692 433.230769 299.323077 393.846154L669.538462 764.061538C630.153846 827.076923 638.030769 913.723077 693.169231 968.861538 764.061538 1039.753846 866.461538 1039.753846 937.353846 968.861538 1000.369231 897.969231 1000.369231 795.569231 937.353846 724.676923L937.353846 724.676923ZM275.692308 307.2C244.184615 338.707692 189.046154 338.707692 157.538462 307.2 126.030769 275.692308 126.030769 220.553846 157.538462 189.046154 189.046154 157.538462 244.184615 157.538462 275.692308 189.046154 307.2 220.553846 307.2 267.815385 275.692308 307.2L275.692308 307.2ZM874.338462 913.723077C842.830769 945.230769 787.692308 945.230769 756.184615 913.723077 724.676923 882.215385 724.676923 827.076923 756.184615 795.569231 787.692308 764.061538 842.830769 764.061538 874.338462 795.569231 905.846154 827.076923 905.846154 874.338462 874.338462 913.723077L874.338462 913.723077Z',
	        JAGGED_SVG: 'M204.8 819.2l-51.2-102.4 204.8-307.2 51.2 102.4-204.8 307.2zM409.6 512l51.2-102.4 153.6 204.8-51.2 102.4-153.6-204.8zM819.2 204.8l51.2 102.4-204.8 409.6-51.2-102.4 204.8-409.6z                                    M153.6 716.8c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H102.4v-102.4h102.4v102.4zM409.6 204.8C322.56 204.8 256 271.36 256 358.4s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H358.4V307.2h102.4v102.4zM614.4 614.4c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4v-102.4h102.4v102.4zM870.4 0c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4V102.4h102.4v102.4z',
	        CURVE_SVG: 'M1014.285039 824.024234l-145.168428-144.37205c-12.969593-12.855825-37.543559-14.505466-44.597197 2.332252-1.877178 4.550734-2.275367 17.179022-2.275368 17.179022v97.556369H330.935383a118.319095 118.319095 0 0 1-118.546632-117.920905A118.319095 118.319095 0 0 1 330.992267 560.878016h445.516899c121.561493 0 220.426198-98.352747 220.426198-219.23163s-98.864705-219.174746-220.426198-219.174746H340.491925A174.236244 174.236244 0 0 0 174.105698 0 173.78117 173.78117 0 0 0 0.040107 173.09856a173.78117 173.78117 0 0 0 174.065591 173.09856 174.236244 174.236244 0 0 0 166.386227-122.471639h436.017241c65.416807 0 118.603516 52.902288 118.603515 117.920905A118.319095 118.319095 0 0 1 776.509166 459.624176H330.992267c-121.504609 0-220.369314 98.352747-220.369314 219.23163s98.864705 219.174746 220.369314 219.174746h491.194895v92.550561s0 14.221045 2.332252 19.795695c7.053638 16.894602 31.627604 17.577212 44.597197 4.664502l145.111543-144.315165a32.879056 32.879056 0 0 0 0-46.645027zM174.105698 244.94328c-39.818926 0-72.242909-32.25333-72.242909-71.84472s32.423983-71.787835 72.242909-71.787835c39.818926 0 72.186025 32.196446 72.186025 71.787835 0 39.591389-32.423983 71.787835-72.242909 71.787836z',
	        DEL_SVG: 'M980.992 256h-84.992v683.008c0 47.104-37.888 84.992-84.992 84.992H212.992c-47.104 0-84.992-37.888-84.992-84.992V256H43.008C19.456 256 0 236.544 0 212.992c0-23.552 19.456-43.008 43.008-43.008H256V84.992C256 37.888 293.888 0 340.992 0h340.992C730.112 0 768 37.888 768 84.992v84.992h214.016c23.552 0 43.008 19.456 43.008 43.008-1.024 23.552-20.48 43.008-44.032 43.008zM683.008 84.992H340.992v84.992h340.992V84.992zM212.992 939.008h596.992V256H212.992v683.008z m171.008-470.016v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-23.552 19.456-43.008 43.008-43.008 23.552 1.024 43.008 19.456 43.008 43.008zM512 427.008c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z m171.008 0c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z',
	        COMMENT_SVG: 'M209.92 152.064l572.416 1.536c12.8 0 23.04 10.24 23.04 23.04v237.568c0 12.8 10.24 23.04 23.04 23.04s23.04-10.24 23.04-23.04V125.44c0-12.8-10.24-23.04-23.04-23.04H158.72c-12.8 0-23.04 10.24-23.04 23.04v773.12c0 12.8 10.24 23.04 23.04 23.04h236.032c12.8 0 23.04-10.24 23.04-23.04s-10.24-22.528-22.528-23.04l-185.856-1.536c-12.8 0-22.528-10.24-22.528-23.04V174.592c0-12.288 10.24-22.528 23.04-22.528z                                            M268.8 570.368h159.232c13.312 0 24.064 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.064-10.752-24.576-24.064v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0-312.32h441.344c13.312 0 24.576 10.752 24.576 24.576v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.576-10.752-24.576-24.576v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0.512 155.648h269.312c13.312 0 24.576 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H269.312c-13.312 0-24.576-10.752-24.576-24.064v-2.56c0-13.824 10.752-24.576 24.576-24.576z m471.04 13.312l-246.784 339.456c-1.536 2.56-2.56 5.632-2.56 8.704l-1.536 132.096c0 9.728 9.728 16.896 18.944 14.336l122.88-37.888c3.072-1.024 5.632-3.072 7.68-5.632l246.784-338.944c4.608-6.144 3.584-15.36-2.56-19.968l-121.344-94.72c-7.168-5.632-16.896-4.096-21.504 2.56z m23.04 67.584l51.2 39.936c2.048 1.536 2.56 5.12 1.024 7.168l-26.112 35.84c-1.536 2.56-5.12 3.072-7.68 1.024l-51.712-38.912c-2.048-1.536-2.56-4.608-1.024-7.168l26.624-37.376c2.048-1.536 5.632-2.048 7.68-0.512z m-165.888 341.504l-35.328 10.752c-9.216 3.072-18.944-4.096-18.944-13.824l0.512-40.96c0-3.072 1.024-6.144 2.56-8.704l137.216-187.904c1.536-2.56 5.12-2.56 7.168-1.024l51.2 38.4c2.56 2.048 3.072 5.12 1.024 7.68l-137.728 189.952c-2.048 2.56-4.608 4.608-7.68 5.632z',
	        CHANGE_LINE_TYPE_SVG: 'M1008 335.2 1008 335.2l-160 144 0 0c-8.8 8-20 12.8-32 12.8-26.4 0-48-21.6-48-48 0-14.4 6.4-26.4 16-35.2l0 0 67.2-60L560 348.8c0 0 0 0 0 0L464 348.8l0 0L352 348.8 48 348.8c-26.4 0-48-21.6-48-48 0-26.4 21.6-48 48-48l124.8 0 0 0L416 252.8l0 0 208 0 0 0 227.2 0L784 192l0 0c-9.6-8.8-16-21.6-16-35.2 0-26.4 21.6-48 48-48 12 0 23.2 4.8 32 12.8l0 0 160 144 0 0c9.6 8.8 16 21.6 16 35.2C1024 314.4 1017.6 326.4 1008 335.2zM16 680.8 16 680.8l160-144 0 0c8.8-8 20-12.8 32-12.8 26.4 0 48 21.6 48 48 0 14.4-6.4 26.4-16 35.2l0 0-67.2 60L400 667.2l0 0 208 0 0 0 243.2 0 0 0L976 667.2c26.4 0 48 21.6 48 48 0 26.4-21.6 48-48 48L672 763.2 560 763.2c0 0 0 0 0 0L464 763.2l0 0L172.8 763.2 240 824l0 0c9.6 8.8 16 21.6 16 35.2 0 26.4-21.6 48-48 48-12 0-23.2-4.8-32-12.8l0 0L16 752l0 0c-9.6-8.8-16-21.6-16-35.2C0 701.6 6.4 689.6 16 680.8z'
	    }
	    module.exports = IconOperation;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * flow连线管理类
	 * @author miao.cunzhi
	 */
	
	    var zrUtil = __webpack_require__(5);
	    var ConnectionManager = __webpack_require__(91);
	    var Connector = __webpack_require__(82);
	    var Util = __webpack_require__(65);
	    var Point = __webpack_require__(66);
	    var Constants = __webpack_require__(93);
	
	    function FlowConnectionManager(api) {
	        ConnectionManager.call(this);
	        this.bundleOffset = 30; //多线段的偏移
	        this.bundleGap = 20; // 多线段的间隔
	        this.connectorMap = Util.StackedMap.createNew(); //存放多线段
	        this._api = api;
	    }
	
	    FlowConnectionManager.prototype.add = function(connector) {
	        this.connectors.push(connector);
	        //1.处理事件
	        this.handleConnectorEvent(connector);
	        //2.判断是否两节点相联
	        if(connector.startNode && connector.endNode) {
	            var key = this.getTwoNodeId(connector.startNode, connector.endNode, connector.options.position);
	            this.connectorMap.add(key, connector);
	
	            this.handleConnectorShrink(connector);
	
	            this.bundleOffset = connector.options.bundleOffset || this.bundleOffset;
	            this.bundleGap = connector.options.bundleGap || this.bundleGap;
	            //2. 获取这个key对应的线段数组
	            var arrCons = this.connectorMap.get(key);
	            if (arrCons.length == 1) {
	                //两个节点只有一个连线的情况
	                //判断一下 model里有没有dockers，如果有则调用构造point数组  或者调用refreshConnector计算如何画线
	                var dockers = connector.options.dockers;
	                var points = [];
	                if (dockers && dockers.length >= 2) {
	                    points = Point.loadArray(dockers);
	                    connector.refresh(points);
	                } else {
	                    if (connector.options.position.points) {
	                        var arrStartEndPoint = this.getStartEndPoint(connector);
	                        points = connector.options.position.points;
	                        points.unshift(arrStartEndPoint[0]);
	                        points.push(arrStartEndPoint[1]);
	                        connector.refresh(points);
	                    } else {
	                        this.refreshConnector(arrCons[0], true);
	                    }
	                }
	            } else if (arrCons.length > 1) {
	                //两个节点有多个连线的情况
	                this.refreshCons(arrCons);
	            }
	        } else {
	            //处理没有 起始节点与终止节点时的连线
	            this.handleConnectorPoints(connector)
	        }
	
	        //3.设置模型
	        this.handleConnectorModel(connector);
	        return connector;
	    }
	
	    FlowConnectionManager.prototype.handleConnectorEvent = function(connector) {
	        if (connector.conPointsGroup) {
	            connector.conPointsGroup.on("click", function(e) {
	                var arrSplit = e.target.type.split(Connector.SEPERATOR);
	                var connector = e.target.connector;
	                if (arrSplit[0] === Connector.START_NODE) {
	                    connector.options.position.startPos = arrSplit[1];
	                } else if (arrSplit[0] === Connector.END_NODE) {
	                    connector.options.position.endPos = arrSplit[1];
	                }
	                this.refreshConnector(connector, true);
	                e.cancelBubble = true;
	                var params = {};
	                params.event = e;
	                params.type = "conPointsGroup:click";
	                params.lineNode = this.selConnector;
	                this._api.trigger(params.type, params);
	            }.bind(this));
	        }
	
	
	        var MOUSE_EVENT_NAMES = ['click', 'dblclick'];
	        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	            connector.on("Connector:" + eveName, function(e) {
	                var selected = e.target;
	                if (this.selConnector !== selected) {
	                    this.selConnector && this.refreshConnector(this.selConnector);
	                    this.selConnector = selected;
	                }
	                e.cancelBubble = true;
	                var params = {};
	                params.event = e;
	                params.type = eveName;
	                params.target = this.selConnector;
	                this._api.trigger(params.type, params);
	            }.bind(this));
	        }.bind(this));
	    }
	
	    FlowConnectionManager.prototype.handleConnectorModel = function(connector) {
	        connector.model.set(Constants.ELEMENT_TYPE, Constants.CONNECTION);
	        if(connector.startNode && connector.endNode) {
	            connector.model.set(Constants.START_ID, connector.startNode.id);
	            connector.model.set(Constants.END_ID, connector.endNode.id);
	        }
	        connector.model.set(Constants.OPTIONS, zrUtil.clone(connector.options));
	    }
	
	    FlowConnectionManager.prototype.handleConnectorShrink = function(connector) {
	        var that = this;
	        //双击收紧为一条线
	        // 缩略图多线段双击合成单线段
	        connector.line.on("dblclick", function() {
	            if (connector.options.isShrink == false) {
	                return;
	            }
	            var con = this.parent;
	            var startNode = con.startNode;
	            var endNode = con.endNode;
	            var position = zrUtil.clone(connector.options.position);
	            var offsetSign;
	            if (position.startPos.indexOf('-') > -1) {
	                offsetSign = '-';
	            }
	            if (position.startPos.indexOf('+') > -1) {
	                offsetSign = '+';
	            }
	            position.startPos = position.startPos.split(offsetSign)[0];
	            if (position.endPos.indexOf('-') > -1) {
	                offsetSign = '-';
	            }
	            if (position.endPos.indexOf('+') > -1) {
	                offsetSign = '+';
	            }
	            position.endPos = position.endPos.split(offsetSign)[0];
	            //1.获取所有的线段
	            var key = that.getTwoNodeId(startNode, endNode, position);
	            var cons = that.connectorMap.getsimilar(key);
	            if (cons.length == 1) {
	                return
	            }
	            //2.判断线是否处于隐藏状态
	            //2.将除中间的一条线进行隐藏
	            var half = parseInt(cons.length / 2);
	            for (var i = 0; i < cons.length; i++) {
	                if (i != (half)) {
	                    if (cons[i].ignore) {
	                        cons[i].show();
	                    } else {
	                        cons[i].hide();
	                    }
	                }
	            }
	        })
	    }
	
	    //处理没有 起始节点与终止节点时的连线
	    FlowConnectionManager.prototype.handleConnectorPoints = function(connector) {
	        var options = connector.options;
	        var dockers = connector.options.dockers;
	        if (dockers && dockers.length >= 2) {
	            var points = Point.loadArray(dockers);
	            connector.refresh(points);
	        } else {
	            if (options.position && options.position.points) {
	                var oPoints = options.position.points;
	                connector.refresh(oPoints);
	            }
	        }
	    }
	
	    FlowConnectionManager.prototype.getTwoNodeId = function(startNode, endNode, pos) {
	        return startNode.id + '-' + pos.startPos + "," + endNode.id + '-' + pos.endPos;
	    }
	    //处理多条线段
	    FlowConnectionManager.prototype.refreshCons = function(arrCons) {
	        //如果是折线的话
	        if (arrCons[0].options.style.lineType == Connector.TYPE_JAGGED) {
	            for (var i = 0; i < arrCons.length; i++) {
	                this.refreshConnector(arrCons[i], true);
	            }
	        } else {
	            this.refreshConsStraight(arrCons);
	        }
	    }
	
	    //处理多条线段(直线)
	    FlowConnectionManager.prototype.refreshConsStraight = function(arrCons) {
	        var half = parseInt(arrCons.length / 2);
	        var arrConnectResult = []
	
	        var startNode = arrCons[0].startNode;
	        var endNode = arrCons[0].endNode;
	        // 修复节点在组内包围盒需加上组的position
	        var sRect = Util.getRect(startNode, true);
	        var eRect = Util.getRect(endNode, true);
	        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);
	        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);
	        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	        var position = arrCons[0].options.position;
	        if (!position.startPos || !position.endPos) {
	            if (sRect.x < eRect.x) {
	                position.startPos = "right";
	                position.endPos = "left";
	            } else {
	                position.startPos = "left";
	                position.endPos = "right";
	            }
	        }
	
	        var startPoint = sConnectorPoint[position.startPos];
	        var endPoint = eConnectorPoint[position.endPos];
	        var angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);
	        var points = [];
	        for (var i = half; i >= 1; i--) {
	            points = []; //var points = [];
	            points.push(startPoint); //
	            // points.push(new Point(startPoint.x + bundleOffset , startPoint.y + i * bundleGap));
	            // points.push(new Point(endPoint.x - bundleOffset , startPoint.y + i * bundleGap)); //startPoint.x + bundleOffset
	            var secondPoint = startPoint.clone();
	
	            //secondPoint.x =  secondPoint.x + this.bundleOffset;
	            secondPoint.transform(Util.translationMatrix(0, this.bundleGap * i));
	            //secondPoint = this.boundOffsetXY(secondPoint, true);
	            //
	            //直角坐标 x, 和 y, 计算出极坐标
	
	
	            //从极坐标计算出直角坐标
	            secondPoint.x = secondPoint.x + this.bundleOffset * Math.cos(angle);
	            secondPoint.y = secondPoint.y + this.bundleOffset * Math.sin(angle);
	
	
	
	            //secondPoint.transform(Util.scaleMatrix(0.5));
	            points.push(secondPoint);
	
	            var thirdPoint = endPoint.clone();
	            //thirdPoint.x =  thirdPoint.x - this.bundleOffset;
	
	
	
	            thirdPoint.transform(Util.translationMatrix(0, this.bundleGap * i));
	            //thirdPoint = this.boundOffsetXY(thirdPoint, false);
	            //secondPoint.transform(Util.scaleMatrix(0.5));
	            //
	            //直角坐标 x, 和 y, 计算出极坐标
	
	            //从极坐标计算出直角坐标
	            thirdPoint.x = thirdPoint.x - this.bundleOffset * Math.cos(angle);
	            thirdPoint.y = thirdPoint.y - this.bundleOffset * Math.sin(angle);
	
	            points.push(thirdPoint);
	
	            points.push(endPoint);
	            arrConnectResult.push(points);
	        }
	
	        arrConnectResult.push([startPoint, endPoint]);
	
	        var upHalf = Math.ceil(arrCons.length / 2);
	        for (i = 1; i < upHalf; i++) {
	            points = []; //var points = [];
	            points.push(startPoint);
	            var secPoint = startPoint.clone();
	            //secPoint.x =  secPoint.x + this.bundleOffset;
	            secPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));
	            secPoint.x = secPoint.x + this.bundleOffset * Math.cos(angle);
	            secPoint.y = secPoint.y + this.bundleOffset * Math.sin(angle);
	            points.push(secPoint);
	
	            var thdPoint = endPoint.clone();
	            //thdPoint.x =  thdPoint.x - this.bundleOffset;
	            thdPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));
	            //从极坐标计算出直角坐标
	            thdPoint.x = thdPoint.x - this.bundleOffset * Math.cos(angle);
	            thdPoint.y = thdPoint.y - this.bundleOffset * Math.sin(angle);
	            //secondPoint.transform(Util.scaleMatrix(0.5));
	            points.push(thdPoint);
	
	            points.push(endPoint);
	            arrConnectResult.push(points);
	        }
	
	
	        for (i = 0; i < arrConnectResult.length; i++) {
	            arrCons[i].refresh(arrConnectResult[i]);
	        }
	
	    }
	
	    FlowConnectionManager.prototype.boundOffsetXY = function(point, isPositive) {
	        var resultPoint = point.clone();
	        //直角坐标 x, 和 y, 计算出极坐标
	        var angle = Math.atan2(resultPoint.y, resultPoint.x);
	        var r = Math.sqrt(Math.pow(resultPoint.x, 2) + Math.pow(resultPoint.y, 2));
	        if (isPositive) {
	            r = r + this.bundleOffset;
	        } else {
	            r = r - this.bundleOffset;
	        }
	
	
	        //从极坐标计算出直角坐标
	        resultPoint.x = r * Math.cos(angle);
	        resultPoint.y = r * Math.sin(angle);
	        return resultPoint;
	    }
	
	    /**
	     * 设置线段的模型数据  (类型 文字)
	     * @param {[type]} connector [description]
	     * @param {[type]} option    [description]
	     */
	    FlowConnectionManager.prototype.setModel = function(connector, option) {
	        var originLineType = connector.model.get("style.lineType");
	        connector.model.mergeOption(option);
	        zrUtil.merge(connector.model.get("options"), option, true);
	        if (originLineType !== option.style.lineType) {
	            this.refreshConnector(connector, true);
	        }
	    }
	
	    /**
	     * 删除指定的线
	     * @param connector 欲删除的连线
	     * @param _zr zr
	     */
	    ConnectionManager.prototype.deleteByLine = function (connector,_zr) {
	        //1.将线 所联的startNode的outgoing数据删除
	        if(connector.startNode){
	            var startNodeOutgoing = connector.startNode.model.get("outgoing");
	            index = zrUtil.indexOf(startNodeOutgoing, connector.resourceId);
	            if (index != -1) {
	                startNodeOutgoing.splice(index, 1);
	            }
	
	            if (this.connectorMap) {
	                var key = this.getTwoNodeId(connector.startNode, connector.endNode, connector.options.position);
	                this.connectorMap.removeItem(key, connector);
	            }
	        }
	
	
	        //2.从_zr上删除
	        _zr.remove(connector);
	
	
	        //3.从线数据中删除
	        var index = zrUtil.indexOf(this.connectors, connector);
	        if (index != -1) {
	            this.connectors.splice(index, 1);
	        }
	        if (this.selConnector === connector) {
	            this.selConnector = null;
	        }
	    }
	    /**
	     * 刷新连接线
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    FlowConnectionManager.prototype.refreshLineByNode = function(node) {
	        // 判断这个节点是否有多条线段
	        var keys = this.connectorMap.keys();
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (key.indexOf(node.id) != -1) {
	                var arrCons = this.connectorMap.get(key);
	                this.countLinePos(arrCons)
	                if (arrCons.length == 1) {
	                    //两个节点只有一个连线的情况
	                    this.refreshConnector(arrCons[0], true);
	                } else if (arrCons.length > 1) {
	                    //两个节点有多个连线的情况
	                    this.refreshCons(arrCons);
	                }
	            }
	        }
	    }
	
	    /**
	     * 刷新连接线
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    FlowConnectionManager.prototype.toggleLineByNode = function(node, isShow) {
	        // 判断这个节点是否有多条线段
	        var keys = this.connectorMap.keys();
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (key.indexOf(node.id) != -1) {
	                var arrCons = this.connectorMap.get(key);
	
	                zrUtil.each(arrCons, function(connection) {
	                    if(isShow) {
	                        connection.show();
	                    } else {
	                        connection.hide();
	                    }
	                })
	            }
	        }
	    }
	    /**
	     * 重新调整线的位置
	     */
	    FlowConnectionManager.prototype.countLinePos = function(arrCons) {
	        zrUtil.each(arrCons, function(connector) {
	            var options = connector.options;
	            if (options.autoChangePosition == true) {
	                var sRect = Util.getRect(connector.startNode).boundingRect;
	                var eRect = Util.getRect(connector.endNode).boundingRect;
	                var startPos = options.position.startPos;
	                var endPos = options.position.endPos;
	                var startPosNow = this.posIsChange(startPos, sRect, eRect, "startNode");
	                var endPosNow = this.posIsChange(endPos, sRect, eRect, "endNode");
	                if (startPos != startPosNow || endPos != endPosNow) {
	                    options.position.startPos = startPosNow;
	                    options.position.endPos = endPosNow;
	                }
	            }
	        },this);
	    }
	
	    FlowConnectionManager.prototype.posIsChange = function(pos, sRect, eRect, nodeType) {
	        var newPos
	        if (pos.indexOf("top") != -1 || pos.indexOf("bottom") != -1) {
	            if (sRect.y + sRect.height < eRect.y) {
	                if (nodeType == "startNode") {
	                    newPos = pos.replace(/(top|bottom)/g, "bottom");
	                } else {
	                    newPos = pos.replace(/(top|bottom)/g, "top");
	                }
	            } else if (eRect.y + eRect.height < sRect.y) {
	                if (nodeType == "endNode") {
	                    newPos = pos.replace(/(top|bottom)/g, "bottom");
	                } else {
	                    newPos = pos.replace(/(top|bottom)/g, "top");
	                }
	            } else if (sRect.x + sRect.width < eRect.x) {
	                if (nodeType == "startNode") {
	                    newPos = pos.replace(/(top|bottom)/g, "right");
	                } else {
	                    newPos = pos.replace(/(top|bottom)/g, "left");
	                }
	            } else if (eRect.x + eRect.width < sRect.x) {
	                if (nodeType == "endNode") {
	                    newPos = pos.replace(/(top|bottom)/g, "right");
	                } else {
	                    newPos = pos.replace(/(top|bottom)/g, "left");
	                }
	            }else {
	                newPos = pos;
	            }
	        } else if (pos.indexOf("left") != -1 || pos.indexOf("right") != -1) {
	            if (sRect.x + sRect.width < eRect.x) {
	                if (nodeType == "startNode") {
	                    newPos = pos.replace(/(right|left)/g, "right");
	                } else {
	                    newPos = pos.replace(/(right|left)/g, "left");
	                }
	            } else if (eRect.x + eRect.width < sRect.x) {
	                if (nodeType == "endNode") {
	                    newPos = pos.replace(/(right|left)/g, "right");
	                } else {
	                    newPos = pos.replace(/(right|left)/g, "left");
	                }
	            } else if (sRect.y + sRect.height < eRect.y) {
	                if (nodeType == "startNode") {
	                    newPos = pos.replace(/(right|left)/g, "bottom");
	                } else {
	                    newPos = pos.replace(/(right|left)/g, "top");
	                }
	            } else if (eRect.y + eRect.height < sRect.y) {
	                if (nodeType == "endNode") {
	                    newPos = pos.replace(/(right|left)/g, "bottom");
	                } else {
	                    newPos = pos.replace(/(right|left)/g, "top");
	                }
	            } else {
	                newPos = pos;
	            }
	        } else {
	            newPos = pos;
	        }
	        return newPos;
	    }
	
	
	    zrUtil.inherits(FlowConnectionManager, ConnectionManager);
	    module.exports = FlowConnectionManager;
	


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连线管理类
	 * @author wang.xiaohu
	 */
	
	    var Util = __webpack_require__(65);
	    var Point = __webpack_require__(66);
	    var Connector = __webpack_require__(82);
	    var Log = __webpack_require__(92);
	    var zrUtil = __webpack_require__(5);
	
	    function ConnectionManager() {
	        this.connectors = []; //当前画布所有的线段
	        this.selConnector = null; //当前选中的线段
	        this.tempConnector = null; //临时线段
	    }
	
	    /**
	     * 设置线的不可编辑
	     * @param  {[type]} forbidEdit [description]
	     * @return {[type]}            [description]
	     */
	    ConnectionManager.prototype.connectorForbidEdit = function (forbidEdit) {
	        for (var i = 0; i < this.connectors.length; i++) {
	            this.connectors[i].options.isEdit = !forbidEdit;
	        }
	        if (forbidEdit) {
	            this.removeConnectorEventListener();
	        }
	    }
	
	    /**
	     * 移除线条监听事件
	     */
	    ConnectionManager.prototype.removeConnectorEventListener = function () {
	        if (this.connectors.length > 0) {
	            this.connectors.forEach(function(connector) {
	                connector.polyLine.off('mouseover');
	                connector.polyLine.off('mousemove');
	                connector.polyLine.off('mouseout');
	                connector.curveLine.off('mouseover');
	                connector.curveLine.off('mousemove');
	                connector.curveLine.off('mouseout');
	            });
	        }
	    }
	
	
	    /**
	     * 清空连接线上的调整位置按钮
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.clearSelectCon = function () {
	        if (this.selConnector != null) {
	            this.refreshConnector(this.selConnector);
	        }
	    }
	    /**
	     * 删除和节点相关联的连接线
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.deleteSelectCon = function (node, _zr) {
	        for (var i = 0; i < this.connectors.length; i++) {
	            if (this.connectors[i].startNode == node || this.connectors[i].endNode == node) {
	                //1.将线 所联的startNode的outgoing数据删除
	                var startNodeOutgoing = this.connectors[i].startNode.model.get("outgoing");
	                var index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);
	                if (index != -1) {
	                    startNodeOutgoing.splice(index, 1);
	                }
	                //2.从_zr上删除
	                _zr.remove(this.connectors[i]);
	                this.connectors.splice(i, 1);
	                i--;
	                this.selConnector = null;
	            }
	        }
	    }
	    ConnectionManager.prototype.removeLine = function (line, zr) {
	        this.selConnector = line;
	        this.deleteLine(zr);
	    }
	    /**
	     * 删除选定的线
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.deleteLine = function (_zr) {
	        //1.将线 所联的startNode的outgoing数据删除
	        if(this.selConnector.startNode){
	            var startNodeOutgoing = this.selConnector.startNode.model.get("outgoing");
	            index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);
	            if (index != -1) {
	                startNodeOutgoing.splice(index, 1);
	            }
	
	            if (this.connectorMap) {
	                var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode, this.selConnector.options.position);
	                this.connectorMap.removeItem(key, this.selConnector);
	            }
	        }
	
	
	        //2.从_zr上删除
	        _zr.remove(this.selConnector);
	
	
	        //3.从线数据中删除
	        var index = zrUtil.indexOf(this.connectors, this.selConnector);
	        if (index != -1) {
	            this.connectors.splice(index, 1);
	        }
	        this.selConnector = null;
	    }
	
	    /**
	     * 重新画线
	     * @param  {[type]} connector          [description]
	     * @param  {[type]} force
	     * @return {[type]}                    [description]
	     */
	    ConnectionManager.prototype.refreshConnector = function (connector, force) {
	        // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘
	        if (force || (!connector.turningPoints) || (connector.turningPoints.length < 2)) {
	            if (connector.model && connector.model.get("style.lineType")) {
	                connector.options.style.lineType = connector.model.get("style.lineType");
	            }
	            var arrStartEndPoint = this.getStartEndPoint(connector);
	            var escapeDistance = null;
	            if (connector.options.position && connector.options.position.escapeDistance) {
	                escapeDistance = connector.options.position.escapeDistance;
	            }
	            var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0],
	                arrStartEndPoint[1],
	                arrStartEndPoint[2], arrStartEndPoint[3], escapeDistance); // TYPE_STRAIGHT TYPE_JAGGED
	
	            connector.refresh(solutions[0][2]);
	        }
	
	        connector.clearHandles(); //清空handle
	    }
	
	
	    ConnectionManager.prototype.getStartEndPoint = function (connector) {
	        var startNode = connector.startNode;
	        var endNode = connector.endNode;
	        var isNotInSameGroup = true;
	        isNotInSameGroup = startNode.parent !== endNode.parent;
	
	        var sRect = Util.getRect(startNode, isNotInSameGroup).boundingRect;
	        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(
	            sRect.y) + Number(sRect.height)];
	
	        var eRect = Util.getRect(endNode, isNotInSameGroup).boundingRect;
	        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(
	            eRect.y) + Number(eRect.height)];
	
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);
	        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);
	
	        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	        var position = connector.options.position;
	        if (position.direction) {
	            var posArr = position.direction.split(',');
	            position.startPos = posArr[0];
	            position.endPos = posArr[1];
	        }
	        if (!position.startPos || !position.endPos) {
	            if (sRect.x < eRect.x) {
	                position.startPos = "right";
	                position.endPos = "left";
	            } else {
	                position.startPos = "left";
	                position.endPos = "right";
	            }
	        }
	        var startPoint = this.calcPointExpression(position.startPos, sConnectorPoint);
	        var endPoint = this.calcPointExpression(position.endPos, eConnectorPoint);
	        startPoint.add(new Point(position.startOffset[0], position.startOffset[1]));
	        endPoint.add(new Point(position.endOffset[0], position.endOffset[1]));
	        return [startPoint, endPoint, sBounds, eBounds];
	    }
	
	    ConnectionManager.prototype.calcPointExpression = function (pos, point) {
	        var variable = {
	            top: point.top.x,
	            left: point.left.y,
	            right: point.right.y,
	            bottom: point.bottom.x,
	            center: point.center.x
	        };
	
	        var expression = "<% print(" + pos + ") %>";
	        var val = parseInt(Util.template(expression)(variable));
	        if (pos.indexOf("top") != -1) {
	            return new Point(val, point.top.y);
	        } else if (pos.indexOf("left") != -1) {
	            return new Point(point.left.x, val);
	        } else if (pos.indexOf("right") != -1) {
	            return new Point(point.right.x, val);
	        } else if (pos.indexOf("bottom") != -1) {
	            return new Point(val, point.bottom.y);
	        } else if (pos.indexOf("center") != -1) {
	            return new Point(val, point.bottom.y);
	        } else {
	            throw new Error("pos参数错误");
	        }
	    }
	
	    /**
	     * 创建或修改临时线
	     * @param  {[type]} startNode             [description]
	     * @param  {[type]} rEndPoint             [description]
	     * @param  {[type]} lineType              [description]
	     * @param  {[type]} startPos              [description]
	     * @return {[type]}                       [description]
	     */
	    ConnectionManager.prototype.manageTempConnector = function (startNode, rEndPoint, lineType, startPos, endPos, endNode) {
	        var eRect = null;
	        var eBounds = null;
	        var sRect = Util.getRect(startNode, true).boundingRect;
	        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(
	            sRect.y) + Number(sRect.height)];
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);
	
	        if (!this.tempConnector) {
	            this.tempConnector = new Connector({
	                isEdit: false,
	                style: {
	                    lineType: lineType
	                }
	            });
	        }
	
	        var connector = this.tempConnector;
	        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	        var position = connector.options.position;
	        position.startPos = startPos ? startPos : (sRect.x < rEndPoint.x ? "right" : "left");
	        position.endPos = endPos ? endPos : (sRect.x < rEndPoint.x ? "left" : "right");
	
	        connector.options.style.lineType = lineType;
	        if (endNode) {
	            eRect = Util.getRect(endNode, true).boundingRect;
	            eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(
	                eRect.y) + Number(eRect.height)];
	        }
	        var solutions = this.connector2Points(lineType, sConnectorPoint[position.startPos], rEndPoint,
	            sBounds, eBounds); // TYPE_STRAIGHT TYPE_JAGGED
	
	        connector.refresh(solutions[0][2]);
	        return connector;
	    }
	
	    /**
	     * 创建或修改临时反转线
	     * @param  {[type]} startPoint              [description]
	     * @param  {[type]} endNode                 [description]
	     * @param  {[type]} lineType                [description]
	     * @param  {[type]} endPos                  [description]
	     * @return {[type]}                         [description]
	     */
	    ConnectionManager.prototype.manageReverseTempConnector = function (startPoint, endNode, lineType, endPos, startPos, startNode) {
	        var sRect = null;
	        var sBounds = null;
	        var eRect = Util.getRect(endNode, true).boundingRect;
	        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(eRect.y) + Number(eRect.height)];
	        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);
	        if (!this.tempConnector) {
	            this.tempConnector = new Connector({
	                isEdit: false,
	                style: {
	                    lineType: lineType
	                }
	            });
	        }
	        var connector = this.tempConnector;
	        var position = connector.options.position;
	        position.endPos = endPos ? endPos : (eRect.x < startPoint.x ? "right" : "left");
	        position.startPos = startPos ? startPos : (eRect.x < startPoint.x ? "left" : "right");
	
	        connector.options.style.lineType = lineType;
	        if (startNode) {
	            sRect = Util.getRect(startNode, true).boundingRect;
	            sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(
	            sRect.y) + Number(sRect.height)];
	        }
	        var solutions = this.connector2Points(lineType, startPoint, eConnectorPoint[position.endPos],
	            sBounds, eBounds); // TYPE_STRAIGHT TYPE_JAGGED
	
	        connector.refresh(solutions[0][2]);
	        return connector;
	    }
	
	    /**
	     * 删除临时线
	     * @param  {[type]} zr             [description]
	     */
	    ConnectionManager.prototype.removeTempConnector = function (zr) {
	        if (this.tempConnector) {
	            zr.remove(this.tempConnector);
	            this.tempConnector = null;
	        }
	    }
	
	
	    /**
	     * 算出 两个节点 指定两个点如何联线
	     * @param  {[type]} type       [description]
	     * @param  {[type]} startPoint [description]
	     * @param  {[type]} endPoint   [description]
	     * @param  {[type]} sBounds    [description]
	     * @param  {[type]} eBounds    [description]
	     * @return {[type]}            [description]
	     */
	    ConnectionManager.prototype.connector2Points = function (type, startPoint, endPoint, sBounds, eBounds,
	        escapeDistance) {
	        var figureEscapeDistance = [30, 30];
	        if (escapeDistance) {
	            if (!zrUtil.isArray(escapeDistance)) {
	                figureEscapeDistance = [escapeDistance, escapeDistance];
	            } else {
	                figureEscapeDistance = escapeDistance;
	            }
	        }
	
	        Log.group("connectionManager: connector2Points");
	
	
	        Log.info("ConnectionManager: connector2Points (" + type + ", " + startPoint + ", " + endPoint +
	            ", " + sBounds + ", " + eBounds + ')');
	        var solutions = [];
	
	
	
	        switch (type) {
	            case Connector.TYPE_CHAIN:
	
	            case Connector.TYPE_STRAIGHT: //直线
	                var points = [startPoint.clone(), endPoint.clone()];
	                solutions.push(['straight', 'straight', points]);
	                break;
	
	            case Connector.TYPE_CURVE: //曲线
	
	            case Connector.TYPE_JAGGED: //折线
	                var startExitPoint = null;
	                var endExitPoint = null;
	
	                //find start exit point  寻找开始出口
	                if (sBounds != null) {
	                    var potentialExits = [];
	
	                    potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北
	                    potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东
	                    potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南
	                    potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西
	
	                    //pick closest exit point  寻找与 startPoint 最靠近的出口点
	                    startExitPoint = potentialExits[0];
	                    for (var i = 1; i < potentialExits.length; i++) {
	                        if (Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint,
	                                startExitPoint)) {
	                            startExitPoint = potentialExits[i];
	                        }
	                    }
	                }
	
	
	                //find end exit point  寻找结束出口
	                if (eBounds != null) {
	                    var potentialExits = [];
	
	                    potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north
	                    potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east
	                    potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south
	                    potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west
	
	                    //pick closest exit point  寻找与 endPoint 最靠近的出口点
	                    endExitPoint = potentialExits[0];
	                    for (var i = 1; i < potentialExits.length; i++) {
	                        if (Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint,
	                                endExitPoint)) {
	                            endExitPoint = potentialExits[i];
	                        }
	                    }
	                }
	
	                //Basic solution 最基本的解决方案   为其他解决方案做准备
	                var s = [startPoint];
	                var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT
	                if (startExitPoint) {
	                    s.push(startExitPoint);
	                    gapIndex = 1;
	                }
	                if (endExitPoint) {
	                    s.push(endExitPoint);
	                }
	                s.push(endPoint);
	
	
	
	                //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用
	                var s0 = Point.cloneArray(s);
	                solutions.push(['s0', 's0', s0]);
	
	
	
	                //S1   S1 解决方案  只有一个折点
	                var s1 = Point.cloneArray(s);
	
	                //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置
	                var s1_1 = Point.cloneArray(s1);
	                s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x, s1_1[gapIndex + 1].y));
	                solutions.push(['s1', 's1_1', s1_1]);
	
	                //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置
	                var s1_2 = Point.cloneArray(s1);
	                s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex + 1].x, s1_2[gapIndex].y));
	                solutions.push(['s1', 's1_2', s1_2]);
	
	
	                //S2  S2 解决方案  添加两个折点
	
	                //Variant I   s2_1方案
	                var s2_1 = Point.cloneArray(s);
	                var s2_1_1 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex].y);
	                var s2_1_2 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex + 1].y);
	                s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);
	                solutions.push(['s2', 's2_1', s2_1]);
	
	
	                //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2
	                //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2
	                var s2_2 = Point.cloneArray(s);
	                var s2_2_1 = new Point(s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);
	                var s2_2_2 = new Point(s2_2[gapIndex + 1].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);
	                s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);
	                solutions.push(['s2', 's2_2', s2_2]);
	
	
	                //Variant III
	                var s2_3 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex + 1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    eastExits.push(sBounds[2] + 20);
	                }
	
	                if (eBounds) {
	                    eastExits.push(eBounds[2] + 20);
	                }
	
	                var eastExit = Util.max(eastExits);
	                var s2_3_1 = new Point(eastExit, s2_3[gapIndex].y);
	                var s2_3_2 = new Point(eastExit, s2_3[gapIndex + 1].y);
	                s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);
	                solutions.push(['s2', 's2_3', s2_3]);
	
	
	                //Variant IV  s2_4方案
	                var s2_4 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex + 1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    northExits.push(sBounds[1] - 20);
	                }
	
	                if (eBounds) {
	                    northExits.push(eBounds[1] - 20);
	                }
	
	                var northExit = Util.min(northExits);
	                var s2_4_1 = new Point(s2_4[gapIndex].x, northExit);
	                var s2_4_2 = new Point(s2_4[gapIndex + 1].x, northExit);
	                s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);
	                solutions.push(['s2', 's2_4', s2_4]);
	
	
	                //Variant V
	                var s2_5 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex + 1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    westExits.push(sBounds[0] - 20);
	                }
	
	                if (eBounds) {
	                    westExits.push(eBounds[0] - 20);
	                }
	
	                var westExit = Util.min(westExits);
	                var s2_5_1 = new Point(westExit, s2_5[gapIndex].y);
	                var s2_5_2 = new Point(westExit, s2_5[gapIndex + 1].y);
	                s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);
	                solutions.push(['s2', 's2_5', s2_5]);
	
	
	                //Variant VI
	                var s2_6 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex + 1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    southExits.push(sBounds[3] + 20);
	                }
	
	                if (eBounds) {
	                    southExits.push(eBounds[3] + 20);
	                }
	
	                var southExit = Util.max(southExits);
	                var s2_6_1 = new Point(s2_6[gapIndex].x, southExit);
	                var s2_6_2 = new Point(s2_6[gapIndex + 1].x, southExit);
	                s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);
	                solutions.push(['s2', 's2_6', s2_6]);
	
	
	
	                //FILTER solutions
	
	                /*Algorithm
	                 * 0. solutions are ordered from minimmun nr of points to maximum >:)
	                 * 1. remove all solutions that are not orthogonal (mainly s0 solution)
	                 * 2. remove all solutions that go backward (we will not need them ever)
	                 * 3. remove all solutions with intersections
	                 * 4. pick first class of solutions with same nr of points (ex: 2)
	                 * 5. pick the first solution with 90 degree angles (less turnarounds)
	                 * (not interesteted) sort by length :p
	                 */
	
	                //1. filter non ortogonal solutions 删除不是正交直线的方案
	                Log.info("Filter orthogonal solutions. Initial number of solutions = " + solutions.length);
	                var orthogonalSolution = [];
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    if (Util.orthogonalPath(solution)) {
	                        orthogonalSolution.push(solutions[l]);
	                    }
	                }
	                solutions = orthogonalSolution;
	                Log.info("\n\tOrthogonalSolutions = " + solutions.length);
	
	                //2. filter backward solutions  过滤 倒退的方案
	                //do not allow start and end points to coincide - ignore them
	                if (startPoint.equals(endPoint)) {
	                    Log.info(
	                        "Start and end point coincide...skip backward solution. I think we will just fall on s0 :)"
	                    );
	                } else {
	                    Log.info("Filter backward solutions. Initial number of solutions = " + solutions.length);
	                    var forwardSolutions = [];
	                    var temp = '';
	                    for (var l = 0; l < solutions.length; l++) {
	                        var solution = solutions[l][2];
	                        if (Util.forwardPath(solution)) {
	                            forwardSolutions.push(solutions[l]);
	                        } else {
	                            temp = temp + "\n\t" + solution;
	                        }
	                    }
	                    solutions = forwardSolutions;
	                    Log.info("\n\t ForwardSolutions = " + solutions.length);
	                    if (solutions.length == 0) {
	                        Log.info("Discarded solutions: " + temp);
	                    }
	                }
	
	
	                //3. Filter non intersecting solutions  去除没有交集()的方案
	                Log.info("Filter non intersecting solutions. Initial number of solutions = " + solutions.length);
	                var nonIntersectionSolutions = []
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    //Log.info("Solution id= " + solutions[l][1] + ' nr points = ' + solution.length + ", points = " + solution);
	                    var intersect = false;
	
	                    var innerLines = solution.slice(); //just a shallow copy
	
	                    /*If any bounds just trim the solution. So we avoid the strange case when a connection
	                     *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/
	                    if (eBounds || sBounds) {
	                        //i0nnerLines = innerLines.slice(0, innerLines.length - 1);
	                        innerLines = innerLines.slice(1, innerLines.length - 1);
	                        //Log.info("\t eBounds present,innerLines nr. points = " + innerLines.length + ", points = " + innerLines);
	                    }
	
	
	
	                    //now test for intersection
	                    if (sBounds) {
	                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);
	                    }
	                    if (eBounds) {
	                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);
	                    }
	
	                    if (!intersect) {
	                        nonIntersectionSolutions.push(solutions[l]);
	                    }
	                }
	
	                //If all solutions intersect than this is destiny  :) and just ignore the intersection filter
	                if (nonIntersectionSolutions.length != 0) {
	                    //reasign to solutions
	                    solutions = nonIntersectionSolutions;
	                }
	
	                Log.info("\n\t nonIntersectionSolutions = " + solutions.length);
	
	
	                //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）
	                Log.info("Get first class of solutions with same nr of points");
	                if (solutions.length == 0) {
	                    Log.info("This is not possible");
	                }
	
	                var firstSolution = solutions[0][2]; //pick first solution
	                var nrOfPoints = firstSolution.length;
	                var sameNrPointsSolution = [];
	
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    if (solution.length == nrOfPoints) {
	                        sameNrPointsSolution.push(solutions[l]);
	                    }
	                }
	
	                solutions = sameNrPointsSolution;
	
	
	
	
	                /*5.  计算路径分数 ，取最分数高的
	                 Pick the first solution with 90 degree angles (less turnarounds)
	                 *in case we have more than one solution in our class
	                 */
	                Log.info("pick the first solution with 90 degree angles (less turnarounds)");
	                var solIndex = 0;
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    if (Util.scorePath(solutions[solIndex][2]) < Util.scorePath(solutions[l][2])) {
	                        solIndex = l;
	                    }
	                }
	                solutions = [solutions[solIndex]];
	
	
	                break;
	        }
	
	        //SMOOTHING curve
	        if (type === Connector.TYPE_CURVE) {
	            this.smoothCurve(solutions);
	        }
	        //END SMOOTHING curve
	
	        Log.groupEnd();
	
	        return solutions;
	    }
	
	    ConnectionManager.prototype.smoothCurve = function (solutions) {
	        var option = 3;
	
	        switch (option) {
	            case 0:
	                //do nothing
	                break;
	
	            case 1: //add intermediate points
	                //Add the middle point for start and end segment so that we "force" the
	                //curve to both come "perpendicular" on bounds and also make the curve
	                //"flee" more from bounds (on exit)
	                for (var s = 0; s < solutions.length; s++) {
	                    var solTurningPoints = solutions[s][2];
	
	                    //first segment
	                    var a1 = solTurningPoints[0];
	                    var a2 = solTurningPoints[1];
	                    var startMiddlePoint = Util.getMiddle(a1, a2);
	                    solTurningPoints.splice(1, 0, startMiddlePoint);
	
	                    //last segment
	                    var a3 = solTurningPoints[solTurningPoints.length - 2];
	                    var a4 = solTurningPoints[solTurningPoints.length - 1];
	                    var endMiddlePoint = Util.getMiddle(a3, a4);
	                    solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);
	                }
	                break;
	
	            case 2: //remove points
	
	                zrUtil.each(solutions, function(solution) {
	                    var solType = solution[0];
	                    if (solType == 's1' || solType == 's2') {
	                        var solTurningPoints = solution[2];
	                        solTurningPoints.splice(1, 1);
	                        solTurningPoints.splice(solTurningPoints.length - 2, 1);
	                    }
	                });
	                break;
	
	            case 3:
	                /*remove colinear point for s1 as it seems that more colinear points do not look good
	                 * on organic solutions >:D*/
	                zrUtil.each(solutions, function(solution) {
	                    var solType = solution[0];
	                    if (solType == 's1') {
	                        var solTurningPoints = solution[2];
	                        var reducedSolution = Util.collinearReduction(solTurningPoints);
	                        solution[2] = reducedSolution;
	                    }
	                });
	                break;
	        } //end switch
	
	    }
	
	    module.exports = ConnectionManager;


/***/ }),
/* 92 */
/***/ (function(module, exports) {

	/**
	 * 日志类
	 * @author wang.xiaohu
	 */
	
	
	    var Log  = {
	        LOG_LEVEL_NONE  : 0,
	
	        LOG_LEVEL_DEBUG : 1,
	
	        LOG_LEVEL_INFO : 2,
	
	        LOG_LEVEL_ERROR : 3,
	
	        level : this.LOG_LEVEL_ERROR,
	        
	        /**
	        * The less important of all messages
	        * @param {String} message - the message to be logged
	        **/
	        debug: function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_DEBUG){
	                    
	                    //in FF is debug
	                    if(typeof console.debug == 'function'){
	                        console.debug(message);
	                    }
	                    else{//TODO: in IE is log
	    //                    console.info(message);
	                    }
	                }
	            }
	        },
	
	
	        /**
	        * The commonly used log message
	        * @param {String} message - the message to be logged
	        **/
	        info : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_INFO){
	                    console.info(message);
	                }
	            }
	        },
	
	        /**
	        * The worse kind of message. Usually a crash
	        * @param {String} message - the message to be logged
	        **/
	        error : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_ERROR){
	                    console.error(message);
	                }
	            }
	        },
	
	        /**
	         *Start grouping the log messages
	         *@param {String} title - the title of the group
	         *@see <a href="http://getfirebug.com/logging">http://getfirebug.com/logging</a>
	         **/
	        group : function(title){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){           
	                    /**If we do not test for group() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.group === 'function'){
	                        console.group(title);
	                    }
	                }
	            }
	        },
	
	        /**Ends current message grouping*/
	        groupEnd : function(){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){
	                    /**If we do not test for groupEnd() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.groupEnd === 'function'){
	                        console.groupEnd();
	                    }
	                }
	            }
	        }
	
	    };
	
	    //Log.level = Log.LOG_LEVEL_DEBUG; 
	    Log.level = Log.LOG_LEVEL_ERROR; 
	    //Log.level = Log.LOG_LEVEL_ERROR;
	    //Log.level = Log.LOG_LEVEL_NONE;
	    module.exports = Log;
	    


/***/ }),
/* 93 */
/***/ (function(module, exports) {

	/**
	 * 常量定义
	 */
	
		module.exports = 	{
			ELEMENT_TYPE: "elementType",
			MODE: "mode",
			BACKGROUND: "backgroud",
			OPTIONS: "options",
			USERDATA: "userData",
			ID: "id",
			START_ID: "startNodeId",
			END_ID: "endNodeId",
			ALARM: "Alarm",
			RELATIONID:"relationId",
			RELATION_IMAGE:"relationImage",
			GROUP: "Group",
			GROUP_NODE:"GroupNode",
			CONNECTION: "connection",
			CHILDS: "childs",
			TREE_ROOT: "treeRoot",
			DOCKERS:"options.dockers",
			STYLE_LINETYPE:"style.lineType",
			LINEOPERATIONICON:"LineOperationIcon",
			DEL:"DEL",
			LINK:"straight",
			FOLD:"jagged",
			CURVE:"curve"
		};
	


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Flow工具类
	 * @author wang.xiaohu9
	 */
	
	    var Constants = __webpack_require__(93);
	    var zrUtil = __webpack_require__(5);
	    var GroupNode = __webpack_require__(95);
	    var Rect = __webpack_require__(97);
	    var Circle = __webpack_require__(98);
	    var Image = __webpack_require__(99);
	    var Text = __webpack_require__(100);
	    var Sector = __webpack_require__(101);
	    var Ring = __webpack_require__(102);
	    var Ellipse = __webpack_require__(103);
	    var Heart = __webpack_require__(104);
	    var Droplet = __webpack_require__(105);
	    var Rose = __webpack_require__(106);
	    var Isogon = __webpack_require__(107);
	    var Polygon = __webpack_require__(108);
	    var Line = __webpack_require__(109);
	    var Polyline = __webpack_require__(110);
	    var BezierCurve = __webpack_require__(111);
	    var Arc = __webpack_require__(112);
	    var Star = __webpack_require__(113);
	    var Trochoid = __webpack_require__(114);
	    var Path = __webpack_require__(115);
	    var IconButton = __webpack_require__(116);
	    var Connector = __webpack_require__(82);
	    var flowLink = __webpack_require__(117);
	    /**
	     * 根据结点数组 导出JSON格式的数据
	     *
	     * @param {Array} model 总的模型
	     * @return {JSON} JSON格式的数据
	     */
	    function toJson(model, group) {
	        var jsonArr = [];
	        group.eachChild(function (node) {
	            if (node.model) {
	                //如果是组的话
	                if (node instanceof GroupNode) {
	                    var childArr = [];
	                    node.eachChild(function (childNode) {
	                        if (childNode.model) {
	                            if (childNode instanceof Connector) {
	                                childNode.refreshModel();
	                            } else {
	                                childNode.model.set("options.position", childNode.position);
	                            }
	                            childArr.push(childNode.model.option);
	                        }
	                    });
	                    node.model.set(Constants.CHILDS, childArr);
	                }
	                if (node instanceof Connector) {
	                    node.refreshModel();
	                }
	                jsonArr.push(node.model.option);
	
	            }
	
	        })
	        model.set(Constants.CHILDS, jsonArr);
	        // 图片ZImage节点的model删除host节点,JSON.stringify()报对象循环引用错误
	        var option = Object.assign({}, model.option);
	        option.childs.forEach(function(item) {
	            if (item.options && item.options.style && item.options.style.host) {
	                delete item.options.style.host;
	            }
	        });
	        return option;
	    }
	
	    /**
	     * 根据 JSON 生成节点
	     * @param  {[type]} fishTopoflow [description]
	     * @param  {[type]} json         [description]
	     * @param {Boolean} isNoCount 是否需要step计数，默认是需要计数
	     * @return {[type]}              [description]
	     */
	    function fromJson(fishTopoflow, group, childShapes, isChild, layoutRootNode, isNoCount) {
	        var connectors = [];
	        // 1.先创建节点  遍历形状 获取模型
	        for (var i = 0; i < childShapes.length; i++) {
	            var shape = childShapes[i];
	            if (shape.elementType === Constants.CONNECTION) {
	                connectors.push(shape);
	            } else if (shape.elementType === Constants.ALARM) {
	                var relationNode = findNodeById(fishTopoflow.allNodes, shape.relationId);
	                fishTopoflow.createAlarm(relationNode, shape.options);
	            } else if ((shape.elementType === Constants.GROUP_NODE) || (shape.elementType === Constants.GROUP)) {
	                // 解决反序列组，组连线无法匹配组问题
	                // shape.options.id = shape.id;
	                var createdGroup = fishTopoflow.createNode(Constants.GROUP, shape.options, shape.userData);
	                if (shape.childs) {
	                    fromJson(fishTopoflow, createdGroup, shape.childs, true, layoutRootNode, isNoCount);
	                }
	
	                // 判断组节点是否有父节点
	                if (isChild) {
	                    group.add(createdGroup);
	                } else {
	                    fishTopoflow.addNode(createdGroup, {}, isNoCount);
	                }
	
	
	            } else {
	                // 根据options创建节点
	                var node = fishTopoflow.createNode(shape.elementType, shape.options, shape.userData);
	                if (isChild) {
	                    group.add(node);
	                } else {
	                    fishTopoflow.addNode(node, {}, isNoCount);
	                }
	
	                if (shape.options.layout) {
	                    if (shape.options.layout.layout === Constants.TREE_ROOT) {
	                        var nodeForLayout = findNodeById(fishTopoflow.allNodes, shape.id)
	                        layoutRootNode.push(nodeForLayout);
	                        //  fishTopo.layoutNode("tree",{"node":node});
	                    }
	                }
	
	            }
	        }
	
	        // 2. 再创建线
	        zrUtil.each(connectors, function (line) {
	            var startNode = findNodeById(fishTopoflow.allNodes, line.startNodeId);
	            var endNode = findNodeById(fishTopoflow.allNodes, line.endNodeId);
	            if (startNode && endNode) {
	                var link = fishTopoflow.createLink(startNode, endNode, line.options, line.userData);
	                if (isChild) {
	                    group.add(link);
	                } else {
	                    fishTopoflow.addNode(link, {}, isNoCount);
	                }
	            }else{
	                var thisLink = flowLink.Link.createByPoint(line.options,line.userData);
	                if (isChild) {
	                    group.add(thisLink);
	                } else {
	                    fishTopoflow.addNode(thisLink, {}, isNoCount);
	                }
	            }
	        })
	    }
	
	    /**
	     * 根据id在group中查找,  因组内子节点之间的连线,在group中查找不到,所以要在allNodes里面取
	     * @param  {[type]} group  [description]
	     * @param  {[type]} nodeId [description]
	     * @return {[type]}        [description]
	     */
	    function findNodeById(allNodes, nodeId) {
	        var retNode = null;
	        allNodes.forEach(function (node) {
	            if (node.id === nodeId) {
	                retNode = node;
	            }
	        });
	        return retNode;
	    }
	
	    /**
	     * Get canvas which has all thing rendered
	     * @param {Object} opts
	     * @param {string} [opts.backgroundColor]
	     */
	    function getRenderedCanvas(zr, opts) {
	        opts = opts || {};
	        opts.pixelRatio = opts.pixelRatio || 1;
	        opts.backgroundColor = opts.backgroundColor ||
	            "#FFFFFF";
	        var list = zr.storage.getDisplayList();
	        // Stop animations
	        zrUtil.each(list, function (el) {
	            var animators = el.animators;
	            var len = animators.length;
	            for (var i = 0; i < len; i++) {
	                animators[i].stop(false);
	            }
	        });
	        return zr.painter.getRenderedCanvas(opts);
	    }
	
	    function toDataURL(zr, opts) {
	        opts = opts || {};
	        var url = getRenderedCanvas(zr, opts).toDataURL(
	            'image/' + (opts && opts.type || 'png')
	        );
	        var list = zr.storage.getDisplayList();
	        // Start animations
	        zrUtil.each(list, function (el) {
	            var animators = el.animators;
	            var len = animators.length;
	            for (var i = 0; i < len; i++) {
	                animators[i].start();
	            }
	        });
	        return url;
	    }
	
	    function truncPosition(position) {
	        var x = parseInt(position[0], 10);
	        var y = parseInt(position[1], 10);
	        if (x < 0) {
	            x = 0
	        }
	        if (y < 0) {
	            y = 0
	        }
	        return [x, y];
	    }
	
	    function registerFlowNode(flowNode) {
	        var nodeCtors = {
	            Rect: Rect,
	            Circle: Circle,
	            Image: Image,
	            Text: Text,
	            Sector: Sector,
	            Ring: Ring,
	            Ellipse: Ellipse,
	            Heart: Heart,
	            Droplet: Droplet,
	            Rose: Rose,
	            Isogon: Isogon,
	            Polygon: Polygon,
	            Line: Line,
	            Polyline: Polyline,
	            BezierCurve: BezierCurve,
	            Arc: Arc,
	            Star: Star,
	            Trochoid: Trochoid,
	            Path: Path,
	            Group: GroupNode,
	            IconButton: IconButton
	        }
	        for (var name in nodeCtors) {
	            flowNode[name] = nodeCtors[name]
	        }
	        return flowNode;
	    }
	
	    /**
	     * Normalize css liked array configuration
	     * e.g.
	     *  3 => [3, 3, 3, 3]
	     *  [4, 2] => [4, 2, 4, 2]
	     *  [4, 3, 2] => [4, 3, 2, 3]
	     * @param {number|Array.<number>} val
	     */
	    function normalizeCssArray(val) {
	        var len = val.length;
	        if (typeof (val) === 'number') {
	            return [val, val, val, val];
	        } else if (len === 2) {
	            // vertical | horizontal
	            return [val[0], val[1], val[0], val[1]];
	        } else if (len === 3) {
	            // top | horizontal | bottom
	            return [val[0], val[1], val[2], val[1]];
	        }
	        return val;
	    }
	
	    function _trim(str) {
	        return str.replace(/^\s+/, '').replace(/\s+$/, '');
	    }
	
	    function parsePercent(percent, all) {
	        switch (percent) {
	            case 'center':
	            case 'middle':
	                percent = '50%';
	                break;
	            case 'left':
	            case 'top':
	                percent = '0%';
	                break;
	            case 'right':
	            case 'bottom':
	                percent = '100%';
	                break;
	        }
	        if (typeof percent === 'string') {
	            if (_trim(percent).match(/%$/)) {
	                return parseFloat(percent) / 100 * all;
	            }
	
	            return parseFloat(percent);
	        }
	
	        return percent == null ? NaN : +percent;
	    }
	
	
	
	    /**
	     * @param {string} str
	     * @param {boolean} [upperCaseFirst=false]
	     * @return {string} str
	     */
	    function toCamelCase(str, upperCaseFirst) {
	        str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {
	            return group1.toUpperCase();
	        });
	
	        if (upperCaseFirst && str) {
	            str = str.charAt(0).toUpperCase() + str.slice(1);
	        }
	
	        return str;
	    }
	    /**
	     * Enable property storage to any host object.
	     * Notice: Serialization is not supported.
	     *
	     * For example:
	     * var get = modelUitl.makeGetter();
	     *
	     * function some(hostObj) {
	     *      get(hostObj)._someProperty = 1212;
	     *      ...
	     * }
	     *
	     * @return {Function}
	     */
	    var makeGetter = (function () {
	        var index = 0;
	        return function () {
	            var key = '\0__topo_prop_getter_' + index++;
	            return function (hostObj) {
	                return hostObj[key] || (hostObj[key] = {});
	            };
	        };
	    })();
	    var encodeHTML = function (source) {
	        return String(source)
	            .replace(/&/g, '&amp;')
	            .replace(/</g, '&lt;')
	            .replace(/>/g, '&gt;')
	            .replace(/"/g, '&quot;')
	            .replace(/'/g, '&#39;');
	    };
	
	    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
	
	    var wrapVar = function (varName, seriesIdx) {
	        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';
	    };
	    /**
	     * Template formatter
	     * @param {string} tpl
	     * @param {Array.<Object>|Object} paramsList
	     * @param {boolean} [encode=false]
	     * @return {string}
	     */
	    function formatTpl(tpl, paramsList, encode) {
	        if (!zrUtil.isArray(paramsList)) {
	            paramsList = [paramsList];
	        }
	        var seriesLen = paramsList.length;
	        if (!seriesLen) {
	            return '';
	        }
	
	        var $vars = paramsList[0].$vars || [];
	        for (var i = 0; i < $vars.length; i++) {
	            var alias = TPL_VAR_ALIAS[i];
	            var val = wrapVar(alias, 0);
	            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);
	        }
	        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
	            for (var k = 0; k < $vars.length; k++) {
	                var ret = paramsList[seriesIdx][$vars[k]];
	                tpl = tpl.replace(
	                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),
	                    encode ? encodeHTML(ret) : ret
	                );
	            }
	        }
	
	        return tpl;
	    }
	
	
	    module.exports = {
	        toJson: toJson,
	        fromJson: fromJson,
	        toDataURL: toDataURL,
	        truncPosition: truncPosition,
	        registerFlowNode: registerFlowNode,
	        normalizeCssArray: normalizeCssArray,
	        parsePercent: parsePercent,
	        toCamelCase: toCamelCase,
	        makeGetter: makeGetter,
	        formatTpl: formatTpl,
	        findNodeById: findNodeById
	    };


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 组， 组中元素的坐标都是相对于这个组的<br>
	 * @class fishTopoFlow.node.GroupNode
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var group1 = new node.Group({
	 *           position:[60,50]
	 *       });
	 *
	 *       var rect1 = new node.Rect({
	 *           shape:{width:120,height:30},
	 *           style:{text:"标题", fill:"#FFB90F",stroke:"#bbbbbb"},
	 *           position:[0,0],
	 *           selectable:false
	 *       });
	 *
	 *       var rect2 = new node.Rect({
	 *           shape:{width:120,height:60},
	 *           style:{text:"内容", fill:"#FFFFFF",stroke:"#bbbbbb"},
	 *           position:[0,30],
	 *           selectable:false
	 *       });
	 *
	 *       group1.add(rect1);
	 *       group1.add(rect2);
	 *       fishTopo.add(group1);
	 */
	
	
	
	    var zrUtil = __webpack_require__(5);
	    var BoundingRect = __webpack_require__(27);
	    var graphic = __webpack_require__(4);
	    var util = __webpack_require__(65);
	    var Connector = __webpack_require__(82);
	    var flowNode =__webpack_require__(96);
	
	    function GroupNode(opts) {
	        this.model = flowNode.genModel("GroupNode", opts);
	        graphic.Group.call(this, opts);
	
	        var defaultOptions = {
	            shape: {
	                width: 5,
	                height: 5,
	                r: 5
	            },
	            style: {
	                fill: 'rgba(0,0,0,0)',//'#f9f9f9',
	                stroke: 'rgba(0,0,0,0)'//'#bbbbbb'
	            },
	            position: [0, 0]
	        };
	        this.options = zrUtil.merge(defaultOptions, opts, true);
	        //函数无法clone 原型clone不上
	        this.options.layout = opts.layout;
	        this.max = [1024, 960];
	        this.render(this.options);
	    }
	    GroupNode.RECT_NAME = "GROUP_RECT_NAME";
	    GroupNode.prototype = {
	        constructor: GroupNode,
	        type: "GroupNode",
	        render: function (model) {
	            var rect = new graphic.Rect({
	                shape: model.shape,
	                style: model.style,
	                //silent:true, //加上后 拖动 组中没有子元素的地方 无法手动了
	                z: 1
	            });
	            rect.name = GroupNode.RECT_NAME;
	            this.add(rect);
	            this.position = model.position;
	            this.mergedImage = model.mergedImage;
	        },
	        rectContain: function (x, y) {
	            var rect = util.getRect(this);
	            return rect.boundingRect.contain(x, y);
	        },
	
	        add: function(child) {
	            if (child && child !== this && child.parent !== this) {
	                this._children.push(child);
	                this._doAdd(child);
	            }
	            this._api && this._api._addGroupNode(this,child);
	            return this;
	
	        },
	
	        /**
	         * 遍历组中每一个子节点
	         * @param  {Function} cb 回调函数cb
	         * @param  {Object} context   上下文context
	         */
	        each: function (cb, context) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                if (child.name != GroupNode.RECT_NAME) {
	                    cb.call(context, child, i);
	                }
	            }
	            return this;
	        },
	        // 设置 group中框形大小为 group的包围和
	        willRender:function (api) {
	            if (this.options.layout) {
	                this.setLayout(this.options.layout);
	            }
	            this.setProperties({
	                shape: {
	                    width: this.getBoundingRect().width,
	                    height: this.getBoundingRect().height
	                }
	            });
	            this._api = api;
	        },
	
	        setLayout: function(Layout) {
	            Layout.run(this);
	        },
	
	        getRect: function () {
	            var boundingRect = this.getBoundingRect();
	            var clipPath = this.clipPath;
	            // 节点裁剪后，以裁剪节点包围盒为准
	            if (clipPath) {
	                boundingRect = clipPath.getBoundingRect();
	            }
	            //创建最小包围盒虚线
	            var points = [];
	            points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];
	            points[1] = [boundingRect.width / 2, -boundingRect.height / 2];
	            points[2] = [boundingRect.width / 2, boundingRect.height / 2];
	            points[3] = [-boundingRect.width / 2, boundingRect.height / 2];
	            points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];
	
	            var boundRect = new BoundingRect(this.position[0],
	                this.position[1],
	                boundingRect.width, boundingRect.height);
	            return {
	                x: this.position[0] + boundingRect.width / 2,
	                y: this.position[1] + boundingRect.height / 2,
	                width: boundingRect.width,
	                height: boundingRect.height,
	                points: points,
	                boundingRect: boundRect
	            };
	        },
	        /**
	         * 拖拽组内节点的时候，动态更改背景rect的大小
	         * @param nodeMessage 拖拽的组内节点的信息
	         */
	        modifyGroupRect: function (nodeMessage) {
	            //1.重置背景rect 的长宽
	            var minLength = this.options.shape.r;
	            this.setProperties({
	                shape: {
	                    width: minLength,
	                    height: minLength,
	                    r: minLength
	                }
	            });
	            var position = zrUtil.clone(nodeMessage.position);
	            var boundingRect = this.getBoundingRect();
	            var width = boundingRect.width;
	            var height = boundingRect.height;
	            var rectShape = {
	                x: 0,
	                y: 0
	            };
	            if (nodeMessage.node instanceof GroupNode) {
	                rectShape = nodeMessage.node.childOfName(GroupNode.RECT_NAME).shape;
	            }
	            position = [position[0] + rectShape.x, position[1] + rectShape.y];
	            var minX = position[0],
	                minY = position[1];
	            var maxX = position[0],
	                maxY = position[1];
	            var maxXNode = nodeMessage.node, maxYNode = nodeMessage.node;
	            for (var i = 1; i < this._children.length; i++) {
	                if (this._children[i] instanceof Connector || this._children[i].isIcon == true || this._children[i].name === GroupNode.RECT_NAME) {
	                    continue;
	                } else {
	                    var childPosition = zrUtil.clone(this._children[i].position);
	                    if (this._children[i] instanceof GroupNode) {
	                        var shape = zrUtil.clone(this._children[i].childOfName(GroupNode.RECT_NAME).shape);
	                        childPosition = [childPosition[0] + shape.x, childPosition[1] + shape.y]
	                    }
	                    if (minX > this._children[i].position[0]) {
	                        minX = this._children[i].position[0];
	                    }
	                    if (maxX < this._children[i].position[0]) {
	                        maxX = this._children[i].position[0];
	                        maxXNode = this._children[i];
	                    }
	                    if (minY > this._children[i].position[1]) {
	                        minY = this._children[i].position[1];
	                    }
	                    if (maxY < this._children[i].position[1]) {
	                        maxY = this._children[i].position[1];
	                        maxYNode = this._children[i];
	                    }
	                }
	            }
	            // 如果组节点自定义了shape宽高，按照自定义配置计算
	            if (this.shape && this.shape.width && this.shape.height) {
	                var nodeRect = nodeMessage.node.getBoundingRect();
	                width = this.shape.width;
	                height = this.shape.height;
	                if (minX < 0) {
	                    width += Math.abs(minX);
	                    position[0] = minX;
	                    var rectMaxX = maxXNode.getBoundingRect();
	                    if (maxX + rectMaxX.width + Math.abs(minX) > width) {
	                        width += (maxX + rectMaxX.width + Math.abs(minX) - width);
	                    }
	                }
	                if (minY < 0) {
	                    height += Math.abs(minY);
	                    position[1] = minY;
	                    var rectMaxY = maxYNode.getBoundingRect();
	                    if (maxY + rectMaxY.height + Math.abs(minY) > height) {
	                        height += (maxY + rectMaxY.height + Math.abs(minY) - height);
	                    }
	                }
	                if (maxX > width) {
	                    width = maxX + maxXNode.getBoundingRect().width;
	                }
	                if (maxY > height) {
	                    height = maxY + maxYNode.getBoundingRect().height;
	                }
	                if (nodeRect.width + position[0] > width) {
	                    width = nodeRect.width + position[0];
	                }
	                if (nodeRect.height + position[1] > height) {
	                    height = nodeRect.height + position[1];
	                }
	            }
	            if (nodeMessage.node.alarm) {
	                var newAlarmPosition = [position[0] + nodeMessage.node.getBoundingRect().width - (nodeMessage.node.alarm
	                        .getBoundingRect().width - 6), position[1] - nodeMessage.node.alarm.getBoundingRect()
	                    .height - 3
	                ];
	                nodeMessage.node.alarm.attr("position", newAlarmPosition);
	            }
	            //改变背景rect的长宽和位置
	            this.setProperties({
	                shape: {
	                    width: width,
	                    height: height,
	                    x: position[0] < 0 ? position[0] : 0,
	                    y: position[1] < 0 ? position[1] : 0
	                }
	            });
	        },
	        setProperties: function (opt) {
	            var rect = this.childOfName(GroupNode.RECT_NAME);
	            rect.setShape(opt.shape);
	           // rect.attr("style", opt.style);
	            this.attr('position', opt.position);
	           // this.attr("shape", opt.shape);
	        },
	
	        getparentIgnore: function(node) {
	            if (node.parent) {
	                if (node.parent.ignore === false) {
	                    // 继续向上遍历
	                    return this.getparentIgnore(node.parent);
	                }
	                return true;
	            }
	            return false;
	        },
	        showChildrenRelationImage: function(groupNode) {
	            var that = this;
	            groupNode._children.forEach(function(node) {
	                if (node._relationImage && node.ignore === true && !that.getparentIgnore(node)) {
	                    node._relationImage.show();
	                }
	                if (node instanceof GroupNode) {
	                    that.showChildrenRelationImage(node);
	                }
	            });
	        },
	        hideChildrenRelationImage: function(groupNode) {
	            var that = this;
	            groupNode._children.forEach(function(node) {
	                if (node._relationImage) {
	                    node._relationImage.hide();
	                }
	                if (node instanceof GroupNode) {
	                    that.hideChildrenRelationImage(node);
	                }
	            });
	        },
	        calculateRelationImage: function(node) {
	            var rect = node._relationImage.getRect ? node._relationImage.getBoundingRect() : util.getRect(node._relationImage);
	            var width = rect.width || 30;
	            var height = rect.height || 30;
	            var position = zrUtil.clone(node.position);
	            var shape = zrUtil.clone(node.childOfName(GroupNode.RECT_NAME).shape);
	            if (node.parent && node.parent instanceof GroupNode) {
	                position[0] += util.getParentX(node.parent);
	                position[1] += util.getParentY(node.parent);
	            }
	            //计算合并后的小图片的position
	            var relationImagePosition = [position[0] + shape.x + (shape.width / 2 - width / 2), position[1] + shape.y + (shape.height / 2 - height / 2)];
	            return {
	                width: width,
	                height: height,
	                position: relationImagePosition
	            };
	        },
	        calculateGroupNode: function() {
	            var imagePosition = zrUtil.clone(this._relationImage.position);
	            var imageRect = this._relationImage.getRect ? this._relationImage.getBoundingRect() : util.getRect(this._relationImage);
	            var shape = zrUtil.clone(this.childOfName(GroupNode.RECT_NAME).shape);
	            var width = imageRect.width || 30;
	            var height = imageRect.height || 30;
	            var position = [];
	            position = [imagePosition[0] - shape.x - (shape.width / 2 - width / 2), imagePosition[1] - shape.y - (shape.height / 2 - height / 2)];
	            if (this.parent && this.parent instanceof GroupNode) {
	                position[0] -= util.getParentX(this.parent);
	                position[1] -= util.getParentY(this.parent);
	            }
	            return position;
	        },
	        refreshRelationImage: function() {
	            var that = this;
	            var refresh = function(node) {
	                if (node instanceof GroupNode) {
	                    node._children.forEach(function(childNode) {
	                        if (childNode instanceof GroupNode ) {
	                            if (childNode.ignore && childNode._relationImage) {
	                                var rect = that.calculateRelationImage(childNode);
	                                childNode._relationImage.attr("position", rect.position);
	                            }
	                            refresh(childNode);
	                        }
	                    })
	                }
	            }
	            refresh(this);
	        },
	        merged: function (flow) {
	            var that = this;
	            //给小图片设置属性，隐藏group
	            var relationImageRect = this.calculateRelationImage(this);
	            var width = relationImageRect.width;
	            var height = relationImageRect.height;
	            var relationImagePosition = relationImageRect.position;
	            this._relationImage.attr("style", {
	                image: this.mergedImage,
	                width: width,
	                height: height
	            });
	            this._relationImage.attr("position", relationImagePosition);
	            if (width > 0 && height > 0) {
	                this.hide();
	                this.hideChildrenRelationImage(this);
	                this._relationImage.show();
	                if (flow) {
	                    flow._createRelationImageLine(this._relationImage, this);
	                }
	            }
	
	            //双击图片放出组
	            this._relationImage.on("dblclick", function () {
	                //设置组的位置根据小图片的偏移量来计算
	                that.attr('position', that.calculateGroupNode());
	                this.hide();
	                that.show();
	                that.showChildrenRelationImage(that);
	                // 组节点相关连接点展示
	                if (flow) {
	                    // 删除图片节点的连线
	                    flow._removeRelationImageLine(this);
	                    // 展示连线
	                    flow.toggleAllConNodeLine(that, 'show');
	                    // 刷新连线
	                    flow._recureRefreshLine(that);
	                }
	            });
	            return this._relationImage;
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.options.shape;
	            var newW = Number(shape.width * scaleRatio);
	            var newH = Number(newW * shape.height / shape.width);
	            if (ifParse) {
	                newW = parseInt(newW, 10);
	                newH = parseInt(newH, 10);
	            }
	            // 按比例缩放
	            this.setProperties({
	                shape: {
	                    width: newW,
	                    height: newH
	                }
	            });
	            // 更新组内节点
	            this.children().forEach(function(v) {
	                var position = v.position;
	                if (v.name !== GroupNode.RECT_NAME && !(v instanceof Connector) && v.type !== 'ZPath') {
	                    // 每个节点的position更新
	                    v.updateShape(ratio, ifParse);
	                    v.attr('position', [position[0] * scaleRatio, position[1] * scaleRatio]);
	                } else if (v.type === 'ZPath') {
	                    var rect = v.rect;
	                    rect.height = rect.height * scaleRatio;
	                    rect.width = rect.width * scaleRatio;
	                    v.attr({
	                        position: [position[0] * scaleRatio, position[1] * scaleRatio],
	                        rect: rect
	                    });
	                }
	            });
	        }
	    }
	
	    zrUtil.inherits(GroupNode, graphic.Group);
	    module.exports = GroupNode;
	
	/**
	 * @method add
	 * 将节点加入到这个组中最后
	 * @param {Object} node 欲添加到组的节点
	 */
	/**
	 * @method removeAll
	 * 移除所有子节点
	 */
	
	/**
	 * @method remove
	 * 移除所有子节点
	 * @param {Object} child 子节点
	 */
	/**
	 * @method childOfName
	 * 获取指定名字的儿子节点
	 * @param {String} name
	 * @return {Object} 节点
	 */
	/**
	 * @method traverse
	 * 深度优先遍历所有子孙节点（each只遍历子节点）
	 * @param {String} name
	 * @return {Object} 节点
	 */
	
	/**
	 * @cfg {String} mergedImage=''  控制当双击时 组可以缩小为指定的图形。
	 */
	
	/**
	 * @cfg {Boolean} childDraggable=false  控制组内成员是否可以拖动
	 */
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * fishTopoFlow的node对象，框架提供的节点都放在这个对象下。通过extend方法创建自定义节点<br>
	 * @class fishTopoFlow.node
	 * @abstract
	 *
	    * **使用范例**：
	    *
	    *      @example
	    *       var node = fishTopoFlow.node;
	    *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	    *      var Diamond = node.extend({
	    *          type: 'Diamond',
	    *          shape: {
	    *              width: 0,
	    *              height: 0
	    *          },
	    *          buildPath: function (path, shape) {
	    *              var cx = 0;
	    *              var cy = 0;
	    *              var width = shape.width / 2;
	    *              var height = shape.height / 2;
	    *              path.moveTo(cx, cy - height);
	    *              path.lineTo(cx + width, cy);
	    *              path.lineTo(cx, cy + height);
	    *              path.lineTo(cx - width, cy);
	    *              path.closePath();
	    *          }
	    *      });
	    *        var diamod = new Diamond({
	    *            shape: {
	    *                width:50,
	    *                height:50
	    *            },
	    *            position:[60,60]
	    *        })
	    *        fishTopo.add(diamod);
	 */
	
	    var Path = __webpack_require__(7);
	    var Constants = __webpack_require__(93);
	    var zrUtil = __webpack_require__(5);
	    var util = __webpack_require__(65);
	    var Model = __webpack_require__(87);
	    var flowNode = {};
	    /**
	     * 构造模型
	     * @private
	     */
	    flowNode.genModel = function (type, opts) {
	        var model = new Model({});
	        // 没有id的时候，缺少给一个UUID。创建节点或者反序列化的时候 节点的ID取的是opts.id
			if (!opts.id) {
				opts.id = util.getUUID();
	        }
	        if (opts.style && opts.style.textLineHeight !== 0 && !opts.style.rich) { //#170
	            opts.style.rich = {};
	        }
	        model.set(Constants.ELEMENT_TYPE, type);
	        // 防止 new el.constructor({ style: el.style,shape: el.shape }); zrUtil.clone报错
	        if (opts.style && opts.style.host) {
	            delete opts.style.host;
	        }
	        model.set(Constants.OPTIONS, zrUtil.clone(opts));
	        if ("draggable" in opts) {
	            opts.isdraggable = opts.draggable;
	            delete opts.draggable;
	        }
	        if (!opts.z) {
	            opts.z = 1; //节点默认为1，线段0;
	        }
	
	        if (util.isUndefined(opts.hoverAnimation)) {
	            opts.hoverAnimation = false;
	        }
	
	        if (util.isUndefined(opts.selectable)) {
	            opts.selectable = true;  //默认可以选中
	        }
	        return model;
	    }
	
	    flowNode.addHoverAnimation = function(node) {
	        var scale = zrUtil.clone(node.scale) || [1,1];
	        var onEmphasis = function() {
	            this.animateTo({
	                scale: [scale[0] * 1.1, scale[1] * 1.1]
	            }, 400, 'elasticOut');
	        };
	        var onNormal = function() {
	            this.animateTo({
	                scale: scale
	            }, 400, 'elasticOut');
	        };
	        node.on('mouseover', onEmphasis)
	            .on('mouseout', onNormal)
	            .on('emphasis', onEmphasis)
	            .on('normal', onNormal);
	    }
	
	    /**
	     * @method extend
	     * 扩展一个 自定义节点, 比如钻石形等。
	     * @param {Object} props
	     * @param {string} props.type 自定义结节的名称 Path type
	     * @param {Function} [props.init] 初始化 Initialize
	     * @param {Function} props.buildPath 进行构建节点 Overwrite buildPath method
	     * @param {Object} [props.style] 缺省样式 Extended default style config
	     * @param {Object} [props.shape] 缺省节点参数 Extended default shape config
	     *
	     */
	    flowNode.extend = function (defaults) {
	        var Sub = function (opts) {
	            this.model = flowNode.genModel(defaults.type, opts);
	            Path.call(this, opts);
	
	            if (defaults.style) {
	                // Extend default style
	                this.style.extendFrom(defaults.style, false);
	            }
	
	            // Extend default shape
	            var defaultShape = defaults.shape;
	            if (defaultShape) {
	                this.shape = this.shape || {};
	                var thisShape = this.shape;
	                for (var name in defaultShape) {
	                    if (
	                        // eslint-disable-next-line no-prototype-builtins
	                        !thisShape.hasOwnProperty(name)
	                        // eslint-disable-next-line no-prototype-builtins
	                        && defaultShape.hasOwnProperty(name)
	                    ) {
	                        thisShape[name] = defaultShape[name];
	                    }
	                }
	            }
	
	            defaults.init && defaults.init.call(this, opts);
	
	        };
	
	        zrUtil.inherits(Sub, Path);
	
	        // FIXME 不能 extend position, rotation 等引用对象
	        for (var name in defaults) {
	            // Extending prototype values and methods
	            if (name !== 'style' && name !== 'shape') {
	                Sub.prototype[name] = defaults[name];
	            }
	        }
	        // 重写setStyle
	        Sub.prototype.setStyle = function(key, value) {
	            var options = {};
	            if (typeof key === 'string' && value) {
	                options[key] = value;
	            } else {
	                options = key;
	            }
	            this.style.set(key, value);
	            this.dirty(false);
	            zrUtil.merge(this.model.get("options.style"), options, true);
	            return this;
	        }
	
	        return Sub;
	    };
	    module.exports = flowNode;
	
	
	/**
	 * @cfg {Array} position 节点的位置,统一使用position进行定位[x,y] eg. [100,100]
	 */
	
	/**
	 * @cfg {Object} style 样式参数
	 * @cfg {string} style.fill=#000 填充色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red | gradient 注：单独文字使用textFill
	 * @cfg {string} style.stroke=null 笔画颜色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red | gradient 注：单独文字使用textStoke
	 * @cfg {number} style.lineWidth=1 笔画宽度
	 * @cfg {Array} style.lineDash=null 笔画的虚线间隔，参数为交替绘制线段和间距长度的数字 参见[lineDashOffset](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setLineDash) eg. lineDash:[6,10]
	 * @cfg {number} style.lineDashOffset=0  笔画的虚线偏移量 参见[lineDashOffset](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset)
	 * @cfg {string} style.text="" 节点上显示的文本,可以使用 \n 来换行
	 * @cfg {string} style.textFont='12px sans-serif' 字体大小、字体类型、粗细、字体样式。格式参见[css font](https://developer.mozilla.org/en-US/docs/Web/CSS/font) eg.textFont: 'italic bolder 14px Microsoft YaHei'
	 * @cfg {string} style.fontStyle=null 字体样式
	 * @cfg {string} style.fontWeight=#000 字体粗细
	 * @cfg {number} style.fontSize=null 字体大小
	 * @cfg {string} style.fontFamily=null 字体类型
	 * @cfg {string} style.textFill=#000 节点上文本的填充色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red
	 * @cfg {string} style.textStoke=null 节点上文本的描边色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red
	 * @cfg {string|Array} style.textPosition="" 文本在节点中的位置left|right|top|bottom|inside|insideLeft|insideRight|insideTop|insideBottom|insideTopLeft|insideTopRight|insideBottomLeft|insideBottomRight|[x,y]|[%,%]
	 * @cfg {string} style.textBaseline="alphabetic" 当前文本基线的属性 "top" || "hanging" || "middle" || "alphabetic" || "ideographic" || "bottom" 参见[css font](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/textBaseline)
	 * @cfg {Array} style.textOffset=null 文本在节点的偏移值[x,y] eg. [10,10]
	 * @cfg {string} style.textAlign="" 文本在节点中的对齐方式 left | center | right
	 * @cfg {string} style.textVerticalAlign=null 文本在节点中的垂直对齐方式 top | middle | bottom
	 * @cfg {number} style.textDistance=5 文字的相对textPos的偏移量 eg. textPosition='left' textDistance=5 则文字的x坐标的值为 (left的坐标x值) -5
	 * @cfg {string} style.textShadowColor='transparent' 文字阴影颜色
	 * @cfg {number} style.textShadowBlur=0 文本阴影宽度 参见[shadowBlur](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur)
	 * @cfg {number} style.textShadowOffsetX=0 文本阴影 X 方向偏移 参见shadowOffsetX[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX]
	 * @cfg {number} style.textShadowOffsetY=0 文本阴影 Y 方向偏移 参见shadowOffsetY[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY]
	 * @cfg {number} style.textRotation=0 文本旋转的角度
	 * @cfg {number} style.textBorderWidth=0 文字描边宽度
	 * @cfg {string} style.textBorderColor=null 文字描边颜色
	 * @cfg {number} style.textBorderRadius=0 文字描边半径
	 * @cfg {string|Object} style.textBackgroundColor=null 文字背景(颜色或图片) eg. '#333' | {image:'./asset/img/clund.png'}
	 * @cfg {number|Array} style.textPadding=null 文字padding  eg. `2` or `[2, 4]` or `[2, 3, 4, 5]`
	 * @cfg {Object} style.rich=null 富文本样式属性
	 * @cfg {number} style.textLineHeight=0 文字的行高
	 * @cfg {number} style.opacity=1 图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形。
	 * @cfg {number} style.shadowBlur=0 阴影宽度 参见[shadowBlur](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur)
	 * @cfg {number} style.shadowOffsetX=0 阴影 X 方向偏移 参见shadowOffsetX[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX]
	 * @cfg {number} style.shadowOffsetY=0 阴影 Y 方向偏移 参见shadowOffsetY[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY]
	 * @cfg {string} style.shadowColor='#000' 阴影颜色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red 参见[shadowColor](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowColor)
	 * @cfg {string} style.image="" 图片的路径 用于Image
	 * @cfg {number} style.width 图片的宽度 用于Image
	 * @cfg {number} style.height 图片的高度 用于Image
	 */
	
	 /**
	 * @cfg {Object} hoverStyle hover样式, 参数见style
	  */
	 /**
	 * @cfg {Object} selectStyle 选中节点的样式, 参数见style;  默认是一个虚的边框;  设为空对象则不显示选中边框;
	*/
	/**
	 * @cfg {Boolean} draggable=true 是否可以被拖拽。
	 */
	
	/**
	 * @cfg {Boolean} ignore=false 是否隐藏状态（只读），fasle:隐藏,true:不隐藏
	 */
	
	/**
	 * @cfg {Boolean} selectable=true 节点是否可选中，默认是true
	 */
	
	/**
	 * @cfg {String} id 为了避免重复，目前由系统自动生成，如果不需要用可以忽略。建议使用nmae
	 */
	
	/**
	 *  @cfg {Boolean} hoverAnimation=false 是否开启 hover 在节点上的提示动画效果。，默认是false
	 */
	
	/**
	 * @cfg {String} name 指定节点的name, 可以使用childOfName等函数根据name查找节点
	 */
	
	/**
	 * @cfg {String} tooltip 节点的tooltip 内容可以包括HTML标签
	 */
	
	/**
	 * @cfg {Object} relative relative描述怎么根据父元素进行定位，设置了relative属性 就不需要设置position。支持：left、right、top、bottom
	 * @cfg {Number|String} relative.left  距离父元素左边的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.left 和 right 只有一个可以生效。
	 * @cfg {Number|String} relative.right  距离父元素右边的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.left 和 right 只有一个可以生效。
	 * @cfg {Number|String} relative.top  距离父元素顶部的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.top 和 bottom 只有一个可以生效。
	 * @cfg {Number|String} relative.bottom  距离父元素底部的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.top 和 bottom 只有一个可以生效。
	 * @cfg {String} [bounding='all'] 决定此图形元素在定位时，对自身的包围盒计算方式。 1.'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。2.'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。
	 */
	
	/**
	 * @cfg {Array} scale 节点的缩放因子, [x,y] 水平与垂直方向的 eg. [1,1]
	 */
	
	/**
	 * @cfg {number} rotation 节点的旋转因子, 单位是角度 eg. 0.5* Math.PI
	 */
	
	/**
	 * @cfg {Array} origin 旋转和缩放的原点, [x,y] eg. [75,75]
	 */
	
	/**
	 * @cfg {number} z=0  z方向的高度，决定层叠关系。类似css zIndex
	 */
	
	/**
	 * @cfg {number} zlevel=0  决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。
	 */
	
	/**
	 * @cfg {Boolean} silent=false  是否不响应鼠标以及触摸事件。
	 */
	/**
	 * @cfg {Boolean} invisible=false  节点是否可见。
	 */
	
	/**
	 * @cfg {Object} parent  节点的父元素
	 */
	/**
	 * @cfg {Object} operationIcons  节点操作为选中的节点，提供默认操作或用户自定义操作。
	 * @cfg {String} operationIcons.name 设置节点名称，可选值有constants.DEL(删除)，constants.LINK（直线），constants.FOLD（折线），constants.CURVE(曲线)，以及自定义名称
	 * @cfg {String} operationIcons.iconPath 设置自定义节点图标路径
	 * @cfg {Function} operationIcons.callback 设置节点被点击（click）的回调函数
	 * **使用范例**：
	 *
	 *      @example
	 *       var image1 = new node.Image({
	 *           style: {
	 *               image: "img/img-cic/icon-send-sms.svg",
	 *               width:120,
	 *               height:70,
	 *               text:"操作:线段",
	 *               textPosition:"insideBottom"
	 *           },
	 *           position:[60,60],
	 *           operationIcons: [
	 *               { name: constants.LINK} ,
	 *               { name: constants.FOLD },
	 *               { name: constants.CURVE }
	 *           ]
	 *       });
	 */
	
	/**
	 * @property {Object} states
	 * 用于设置节点的状态
	 */
	
	
	/**
	 * @property {Object} model
	 * 节点的模型，用于存储序列化数据 以及用户自定义数据
	 */
	
	/**
	 * @method attr
	 * 设置节点属性
	 * @param {String|Object} key 设置的属性。可以是 string 类型的属性名称，或者 Object 类型的属性及其值
	 * @param {*} 属性值
	 * **使用范例**
	 *
	 * @example
	 *
	 * node.attr('position', [100, 200]);
	 * node.attr({
	 *     style: {
	 *         fill: 'red'
	 *     },
	 *     shape: {
	 *         x: 100
	 *     }
	 * });
	 */
	
	/**
	 * @method setStyle
	 * 创建节点后，设置节点的样式（style属性）
	 * @param {String} key 键名
	 * @param {*} value 键值
	 * @return {Object} 返回节点对象自身
	 */
	
	/**
	 * @method setShape
	 * 创建节点后，设置节点的形状（shape属性）
	 * @param {String} key 键名
	 * @param {*} value 键值
	 * @return {Object} 返回节点对象自身
	 */
	
	/**
	 * @method hide
	 * 隐藏节点
	 */
	
	/**
	 * @method show
	 * 显示节点
	 */
	
	
	/**
	 * @method on
	 * 绑定事件
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 * @param {Object} [context] 上下文
	 */
	
	/**
	 * @method off
	 * 解绑事件
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 */
	
	/**
	 * @method one
	 * 单次触发绑定,trigger后销毁
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 * @param {Object} [context] 上下文
	 */
	
	/**
	 * @method trigger
	 * 事件分发
	 * @param {String} type 事件类型
	 */
	
	/**
	 * @method isSilent
	 * 是否绑定了事件
	 * @param {String} event 事件名
	 * @return {boolean}
	 */
	
	/**
	 * @method animate
	 * 动画
	 * @param {String} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性
	 * @param {Boolean} [loop] 动画是否循环
	 * @return {Object} 返回Animator对象
	 * **使用范例**：
	 *
	 *      @example
	 *      el.animate('style', false)
	 *         .when(1000, {x: 10} )
	 *         .done(function(){ // Animation done })
	 *         .start()
	 */
	
	/**
	 * @method stopAnimation
	 * 停止动画
	 * @param {boolean} forwardToLast 是否在停止前移动到最后一帧
	 */
	
	/**
	 * @method animateTo
	 * 从一动属性过渡到另一种属性的动画
	 * @param {Object} target 目前属性
	 * @param {number} [time=500] 动画时间 单位ms
	 * @param {string} [easing='linear'] 动画函数 参见[缓动示例](http://echarts.baidu.com/gallery/editor.html?c=line-easing)
	 * @param {number} [delay=0] 延时时间
	 * @param {Function} [callback] 动画结束回调
	 * **使用范例**：
	 *
	 *      @example
	 *          // Animate position
	 *          el.animateTo({
	 *              position: [10, 10]
	 *          }, function () { // done })
	 *
	 *          // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	 *          el.animateTo({
	 *              shape: {
	 *                  width: 500
	 *              },
	 *              style: {
	 *                  fill: 'red'
	 *              }
	 *              position: [10, 10]
	 *          }, 100, 100, 'cubicOut', function () { // done })
	 */
	
	/**
	 * @event click
	 * 单击事件
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('click', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event dblclick
	 * 当双击元素时，会发生 dblclick 事件。
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('dblclick', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event mouseover
	 * 当鼠标指针位于元素上方时，会发生 mouseover 事件
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mouseover', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event mouseout
	 * 当鼠标指针从元素上移开时，发生 mouseout 事件。
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mouseout', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	
	/**
	 * @event mousemove
	 * 当鼠标指针在指定的元素中移动时，就会发生 mousemove 事件
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mousemove', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	
	/**
	 * @event mousewheel
	 * 当用户在指定的元素时滚动鼠标滑轮时,就会发生 mousewheel事件
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mousewheel', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	
	/**
	 * @event mousedown
	 * 当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mousedown', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	
	/**
	 * @event mouseup
	 * 当在元素上放松鼠标按钮时，会发生 mouseup 事件。
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mouseup', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event contextmenu
	 * 当在元素上点击鼠标右键时，会发生 contextmenu 事件。
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象，如果想阻止默认的浏览器右键菜单请使用 event.event.preventDefault(); event.event.stopPropagation();
	
	 * <pre>
	 * node.on('contextmenu', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event dragstart
	 * 当开始拖动节点的时候，会发生 dragstart 事件。
	 *
	 * <pre>
	 * node.on('dragstart', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	
	/**
	 * @event drag
	 * 当拖动节点的时候，会发生 drag 事件。
	 *
	 * <pre>
	 * node.on('drag', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event dragend
	 * 当拖动节点结束的时候，会发生 dragend 事件。
	 *
	 * <pre>
	 * node.on('dragend', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 矩形<br>
	 * @class fishTopoFlow.node.Rect
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var rect = new node.Rect({
	 *           shape:{width:100,height:60},
	 *           position:[20,20]
	 *       });
	 *       fishTopo.add(rect);
	 */
	
	    var roundRectHelper = __webpack_require__(29);
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Rect',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Array} shape.points=null 拆线点的坐标 可以从AI中获取。
	         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑
	         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效
	         */
	        shape: {
	            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
	            // r缩写为1         相当于 [1, 1, 1, 1]
	            // r缩写为[1]       相当于 [1, 1, 1, 1]
	            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
	            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
	            x: 0,
	            y: 0,
	            r: 0,
	            width: 50,
	            height: 50
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = 0;
	            var y = 0;
	            var width = shape.width;
	            var height = shape.height;
	            if (!shape.r) {
	                ctx.rect(x, y, width, height);
	            }
	            else {
	                roundRectHelper.buildPath(ctx, shape);
	            }
	            ctx.closePath();
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newW = Number(shape.width * scaleRatio);
	            var newH = Number(newW * shape.height / shape.width);
	            if (ifParse) {
	                newW = parseInt(newW, 10);
	                newH = parseInt(newH, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                width: newW,
	                height: newH
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 圆形<br>
	 * @class fishTopoFlow.node.Circle
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var circle = new node.Circle({
	 *           shape:{r:24},
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(circle);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Circle',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=20 半径。
	         */
	        shape: {
	            r: 20
	        },
	
	        buildPath : function (ctx, shape, inBundle) {
	            // Better stroking in ShapeBundle
	            // Always do it may have performence issue ( fill may be 2x more cost)
	            if (inBundle) {
	                ctx.moveTo(shape.r, 0);
	            }
	            // Better stroking in ShapeBundle
	            // ctx.moveTo(shape.cx + shape.r, shape.cy);
	            ctx.arc(0, 0, shape.r, 0, Math.PI * 2, true);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = Number(shape.r * scaleRatio);
	            if (ifParse) {
	                newR = parseInt(newR, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                r: newR
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 图片节点<br>
	 * @class fishTopoFlow.node.Image
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var image = new node.Image({
	 *           style: {
	 *               image: "../../examples/flow/img/img-cic/start.svg",
	 *               width:120,
	 *               height:70,
	 *               text:"Event Name"
	 *           },
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(image);
	 */
	
	
	    var Displayable = __webpack_require__(8);
	    var BoundingRect = __webpack_require__(27);
	    var zrUtil = __webpack_require__(5);
	    var flowNode = __webpack_require__(96);
	    var LRU = __webpack_require__(21);
	    var globalImageCache = new LRU(50);
	
	
	    function ZImage(opts) {
	        this.model = flowNode.genModel("Image", opts);
	        Displayable.call(this, opts);
	
	        if (window.jQuery) {   //判断jQuery是否存在
	            this.resultDeferrd = jQuery.Deferred();
	            this.result = this.resultDeferrd.promise();
	        }
	    }
	
	    ZImage.prototype = {
	
	        constructor: ZImage,
	
	        type: 'Image',
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var src = style.image;
	            var image;
	
	            // Must bind each time
	            style.bind(ctx, this, prevEl);
	            // style.image is a url string
	            if (typeof src === 'string') {
	                image = this._image;
	                if (image && image.src !== src) { //#171
	                    image = null;
	                }
	            }
	            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas
	            else {
	                image = src;
	                image.isLoaded = true;
	            }
	            // FIXME Case create many images with src
	            if (!image && src) {
	                // Try get from global image cache
	                var cachedImgObj = globalImageCache.get(src);
	                if (!cachedImgObj) {
	                    // Create a new image
	                    image = new Image();
	                    image.isLoaded = false;
	                    image.onload = function () {
	                        image.isLoaded = true;
	                        image.onload = null;
	                        for (var i = 0; i < cachedImgObj.pending.length; i++) {
	                            cachedImgObj.pending[i].dirty();
	                        }
	                    };
	                    cachedImgObj = {
	                        image: image,
	                        pending: [this]
	                    };
	                    image.src = src;
	                    globalImageCache.put(src, cachedImgObj);
	                    this._image = image;
	                    return;
	                }
	                else {
	                    image = cachedImgObj.image;
	                    this._image = image;
	                    // Image is not complete finish, add to pending list  如果使用的svg图片, IE11下就算加载成功image.width, image.height也都是为0
	                    if ((!image.width || !image.height) && (!image.src.endsWith("svg"))) {
	                        cachedImgObj.pending.push(this);
	                        return;
	                    }
	                }
	            }
	
	            if (image) {
	                // 图片已经加载完成
	                // if (image.nodeName.toUpperCase() == 'IMG') {
	                //     if (!image.complete) {
	                //         return;
	                //     }
	                // }
	                // Else is canvas
	
	                var x = style.x || 0;
	                var y = style.y || 0;
	                // 如果使用的svg图片, IE11下就算加载成功image.width, image.height也都是为0
	                //此处如不注释, 会导致IE11下svg图片无法使用
	                // 图片加载失败
	                // if (!image.width || !image.height) {
	                //     return;
	                // }
	                if (!image.isLoaded) {
	                    if (window.jQuery) {
	                        this.resultDeferrd.reject(image);
	                    }
	                    return;
	                }
	
	                var width = style.width;
	                var height = style.height;
	                var aspect = image.width / image.height;
	                if (width == null && height != null) {
	                    // Keep image/height ratio
	                    width = height * aspect;
	                }
	                else if (height == null && width != null) {
	                    height = width / aspect;
	                }
	                else if (width == null && height == null) {
	                    width = image.width;
	                    height = image.height;
	                }
	
	                // 设置transform
	                this.setTransform(ctx);
	
	                if (style.sWidth && style.sHeight) {
	                    var sx = style.sx || 0;
	                    var sy = style.sy || 0;
	                    ctx.drawImage(
	                        image,
	                        sx, sy, style.sWidth, style.sHeight,
	                        x, y, width, height
	                    );
	                }
	                else if (style.sx && style.sy) {
	                    var sx2 = style.sx;
	                    var sy2 = style.sy;
	                    var sWidth = width - sx2;
	                    var sHeight = height - sy2;
	                    ctx.drawImage(
	                        image,
	                        sx2, sy2, sWidth, sHeight,
	                        x, y, width, height
	                    );
	                }
	                else {
	                    ctx.drawImage(image, x, y, width, height);
	                }
	                // 如果没设置宽和高的话自动根据图片宽高设置
	                if (style.width == null) {
	                    style.width = width;
	                }
	                if (style.height == null) {
	                    style.height = height;
	                }
	
	                this.restoreTransform(ctx);
	
	                // Draw rect text
	                if (style.text != null) {
	                    this.drawRectText(ctx, this.getBoundingRect());
	                }
	                if (window.jQuery) {
	                    this.resultDeferrd.resolve(image);
	                }
	            }
	        },
	
	        getBoundingRect: function () {
	            var style = this.style;
	            if (! this._rect) {
	                this._rect = new BoundingRect(
	                    style.x || 0, style.y || 0, style.width || 0, style.height || 0
	                );
	            }
	            return this._rect;
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var style = this.style;
	            var newW = Number(style.width * scaleRatio);
	            var newH = Number(newW * style.height / style.width);
	            if (ifParse) {
	                newW = parseInt(newW, 10);
	                newH = parseInt(newH, 10);
	            }
	            // 按比例缩放
	            this.setStyle({
	                width: newW,
	                height: newH
	            });
	        },
	        // image不继承flowNode，需单独定义setStyle方法
	        setStyle: function (key, value) {
	            var options = {};
	            if (typeof key === 'string' && value) {
	                options[key] = value;
	            } else {
	                options = key;
	            }
	            this.style.set(key, value);
	            this.dirty(false);
	            zrUtil.merge(this.model.get("options.style"), options, true);
	            return this;
	        }
	    };
	
	    zrUtil.inherits(ZImage, Displayable);
	
	    module.exports = ZImage;
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 文本<br>
	 * @class fishTopoFlow.node.Text
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var text = new node.Text({
	 *           style:{text:"文本也可以作为独立的节点进行拖拽",fill:"#ff0000", textFont:"16px Microsoft YaHei"},
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(text);
	 */
	
	    var Text = __webpack_require__(46);
	    var zrUtil = __webpack_require__(5);
	    var flowNode = __webpack_require__(96);
	    function ZText(opts) {
	        var defaultOptions = {
	            style:{textBaseline:"top"}   // 默认值  这样选中时的框才正确
	        };
	        var options = zrUtil.merge(defaultOptions, opts, true);
	        this.model = flowNode.genModel("Text", options);
	        Text.call(this, options);
	    }
	
	    ZText.prototype = {
	        constructor: ZText,
	
	        type: 'Text',
	
	        updateShape: function () {
	            
	        }
	    }
	    zrUtil.inherits(ZText, Text);
	    module.exports = ZText;
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 扇形<br>
	 * @class fishTopoFlow.node.Sector
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var sector = new node.Sector({
	 *           shape: {r:30, startAngle:0, endAngle:Math.PI * 0.5}, // startAngle\endAngle是弧度单位
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(sector);
	 */
	
	    var env = __webpack_require__(50);
	    var Path = __webpack_require__(7);
	
	    var shadowTemp = [
	        ['shadowBlur', 0],
	        ['shadowColor', '#000'],
	        ['shadowOffsetX', 0],
	        ['shadowOffsetY', 0]
	    ];
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Sector',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=0 外半径。
	         * @cfg {Number} shape.r0=0 内半径。
	         * @cfg {Number} shape.startAngle=0 开始弧度。
	         * @cfg {Number} shape.endAngle=Math.PI * 2  结束弧度。
	         * @cfg {Boolean} shape.clockwise=true 是否顺时针。
	         */
	        shape: {
	            cx: 0,
	
	            cy: 0,
	
	            r0: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'
	            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),
	            // where exception "unexpected call to method or property access"
	            // might be thrown when calling ctx.fill after a path whose area size
	            // is zero is drawn and ctx.clip() is called and shadowBlur is set.
	            // (e.g.,
	            //  ctx.moveTo(10, 10);
	            //  ctx.lineTo(20, 10);
	            //  ctx.closePath();
	            //  ctx.clip();
	            //  ctx.shadowBlur = 10;
	            //  ...
	            //  ctx.fill();
	            // )
	            ? function () {
	                var clipPaths = this.__clipPaths;
	                var style = this.style;
	                var modified;
	
	                if (clipPaths) {
	                    for (var i = 0; i < clipPaths.length; i++) {
	                        var shape = clipPaths[i] && clipPaths[i].shape;
	                        if (shape && shape.startAngle === shape.endAngle) {
	                            for (var j = 0; j < shadowTemp.length; j++) {
	                                shadowTemp[j][2] = style[shadowTemp[j][0]];
	                                style[shadowTemp[j][0]] = shadowTemp[j][1];
	                            }
	                            modified = true;
	                            break;
	                        }
	                    }
	                }
	
	                Path.prototype.brush.apply(this, arguments);
	
	                if (modified) {
	                    for (var k = 0; k < shadowTemp.length; k++) {
	                        style[shadowTemp[k][0]] = shadowTemp[k][2];
	                    }
	                }
	            }
	            : Path.prototype.brush,
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r0 = Math.max(shape.r0 || 0, 0);
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
	
	            ctx.lineTo(unitX * r + x, unitY * r + y);
	
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	
	            ctx.lineTo(
	                Math.cos(endAngle) * r0 + x,
	                Math.sin(endAngle) * r0 + y
	            );
	
	            if (r0 !== 0) {
	                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	            }
	
	            ctx.closePath();
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = Number(shape.r * scaleRatio);
	            var newR0 = Number(shape.r0 * scaleRatio);
	            if (ifParse) {
	                newR = parseInt(newR, 10);
	                newR0 = parseInt(newR0, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                r: newR,
	                r0: newR0
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 环形<br>
	 * @class fishTopoFlow.node.Ring
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var ring = new node.Ring({
	 *           shape: {r:30,  r0:10},  // r0 内半径
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(ring);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	         type: 'Ring',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=0 外半径。
	         * @cfg {Number} shape.r0=0 内半径。
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            r0: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var PI2 = Math.PI * 2;
	            ctx.moveTo(x + shape.r, y);
	            ctx.arc(x, y, shape.r, 0, PI2, false);
	            ctx.moveTo(x + shape.r0, y);
	            ctx.arc(x, y, shape.r0, 0, PI2, true);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = Number(shape.r * scaleRatio);
	            var newR0 = Number(shape.r0 * scaleRatio);
	            if (ifParse) {
	                newR = parseInt(newR, 10);
	                newR0 = parseInt(newR0, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                r: newR,
	                r0: newR0
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 椭圆<br>
	 * @class fishTopoFlow.node.Droplet
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var ellipse = new node.Ellipse({
	 *           shape: {rx:70,  ry:30},  // rx:椭圆横半轴长 ry:椭圆纵半轴长
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(ellipse);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Ellipse',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.rx=0 椭圆横半轴长
	         * @cfg {Number} shape.ry=0 椭圆纵半轴长
	         */
	        shape: {
	            rx: 0, ry: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var k = 0.5522848;
	            var x = 0;
	            var y = 0;
	            var a = shape.rx;
	            var b = shape.ry;
	            var ox = a * k; // 水平控制点偏移量
	            var oy = b * k; // 垂直控制点偏移量
	            // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线
	            ctx.moveTo(x - a, y);
	            ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
	            ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
	            ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
	            ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
	            ctx.closePath();
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newRx = Number(shape.rx * scaleRatio);
	            var newRy = Number(newRx * shape.ry / shape.rx);
	            if (ifParse) {
	                newRx = parseInt(newRx, 10);
	                newRy = parseInt(newRy, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                rx: newRx,
	                ry: newRy
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 心形<br>
	 * @class fishTopoFlow.node.Heart
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var heart  = new node.Heart({
	 *           shape: {width:40,  height:50},
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(heart );
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Heart',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.cx=0 中心在父节点坐标系（以父节点左上角为原点）中的横坐标值。
	         * @cfg {Number} shape.cy=0 中心在父节点坐标系（以父节点左上角为原点）中的纵坐标值。
	         * @cfg {Number} shape.width=0 宽度。
	         * @cfg {Number} shape.height=0 高度。
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var a = shape.width;
	            var b = shape.height;
	            ctx.moveTo(x, y);
	            ctx.bezierCurveTo(
	                x + a / 2, y - b * 2 / 3,
	                x + a * 2, y + b / 3,
	                x, y + b
	            );
	            ctx.bezierCurveTo(
	                x - a *  2, y + b / 3,
	                x - a / 2, y - b * 2 / 3,
	                x, y
	            );
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newWidth = Number(shape.width * scaleRatio);
	            var newHeight = Number(newWidth * shape.height / shape.width);
	            if (ifParse) {
	                newWidth = parseInt(newWidth, 10);
	                newHeight = parseInt(newHeight, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                width: newWidth,
	                height: newHeight
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 水滴形<br>
	 * @class fishTopoFlow.node.Droplet
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var droplet = new node.Droplet({
	 *           shape: {width:10,  height:30},
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(droplet);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Droplet',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.width=0 宽度。
	         * @cfg {Number} shape.height=0 高度。
	         */
	        shape: {
	            cx: 0, cy: 0,
	            width: 0, height: 0
	        },
	
	        buildPath : function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var a = shape.width;
	            var b = shape.height;
	
	            ctx.moveTo(x, y + a);
	            ctx.bezierCurveTo(
	                x + a,
	                y + a,
	                x + a * 3 / 2,
	                y - a / 3,
	                x,
	                y - b
	            );
	            ctx.bezierCurveTo(
	                x - a * 3 / 2,
	                y - a / 3,
	                x - a,
	                y + a,
	                x,
	                y + a
	            );
	            ctx.closePath();
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newWidth = Number(shape.width * scaleRatio);
	            var newHeight = Number(newWidth * shape.height / shape.width);
	            if (ifParse) {
	                newWidth = parseInt(newWidth, 10);
	                newHeight = parseInt(newHeight, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                width: newWidth,
	                height: newHeight
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 玫瑰形<br>
	 * @class fishTopoFlow.node.Rose
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var rose = new node.Rose({
	 *           shape: {r:[35], k:7, n:4},
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(rose);
	 */
	
	    var sin = Math.sin;
	    var cos = Math.cos;
	    var radian = Math.PI / 180;
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Rose',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Array} shape.r=[]
	         * @cfg {Number} shape.k=0
	         * @cfg {Number} shape.n=1
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: [],
	            k: 0,
	            n: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null,
	            lineWidth: 2
	        },
	
	        buildPath: function (ctx, shape) {
	            var x;
	            var y;
	            var R = shape.r;
	            var r;
	            var k = shape.k;
	            var n = shape.n;
	
	            var x0 = shape.cx;
	            var y0 = shape.cy;
	
	            ctx.moveTo(x0, y0);
	
	            for (var i = 0, len = R.length; i < len ; i++) {
	                r = R[i];
	
	                for (var j = 0; j <= 360 * n; j++) {
	                    x = r
	                         * sin(k / n * j % 360 * radian)
	                         * cos(j * radian)
	                         + x0;
	                    y = r
	                         * sin(k / n * j % 360 * radian)
	                         * sin(j * radian)
	                         + y0;
	                    ctx.lineTo(x, y);
	                }
	            }
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = [];
	            shape.r.forEach(function (v) {
	                newR.push(Number(v * scaleRatio))
	            });
	            if (ifParse) {
	                newR.forEach(function (v) {
	                    v = parseInt(v, 10);
	                });
	            }
	            // 按比例缩放
	            this.setShape({
	                r: newR
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 正多边形<br>
	 * @class fishTopoFlow.node.Isogon
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var isogon = new node.Isogon({
	 *           shape: {r:40,  n:9},  // r半径 n几个边
	 *           position:[60,50]
	 *       });
	 *       fishTopo.add(isogon);
	 */
	
	    var PI = Math.PI;
	    var sin = Math.sin;
	    var cos = Math.cos;
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Isogon',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=0 半径
	         * @cfg {Number} shape.n=0 几个边
	         */
	       shape: {
	            x: 0, y: 0,
	            r: 0, n: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var n = shape.n;
	            if (!n || n < 2) {
	                return;
	            }
	
	            var x = shape.x;
	            var y = shape.y;
	            var r = shape.r;
	
	            var dStep = 2 * PI / n;
	            var deg = -PI / 2;
	
	            ctx.moveTo(x + r * cos(deg), y + r * sin(deg));
	            for (var i = 0, end = n - 1; i < end; i++) {
	                deg += dStep;
	                ctx.lineTo(x + r * cos(deg), y + r * sin(deg));
	            }
	
	            ctx.closePath();
	
	            return;
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = Number(shape.r * scaleRatio);
	            if (ifParse) {
	                newR = parseInt(newR, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                r: newR
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 多边形<br>
	 * @class fishTopoFlow.node.Polygon
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var polygon = new node.Polygon({
	 *           shape: {points:[[85.275,0], [100,25.41], [85.275,50.821], [14.138,50.821], [0,25.41], [14.138,0]]},  // r半径 n几个边
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(polygon);
	 */
	
	    var polyHelper = __webpack_require__(53);
	
	    module.exports = __webpack_require__(96).extend({
	
	       type: 'Polygon',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Array} shape.points=null 多边形点的坐标 可以从AI中获取。
	         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑
	         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效
	         */
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, true);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var pointsNew = [];
	            shape.points.forEach(function(item) {
	                pointsNew.push([Number(item[0] * scaleRatio), Number(item[1] * scaleRatio)]);
	            });
	            if (ifParse) {
	                pointsNew.forEach(function(item) {
	                    item[0] = parseInt(item[0], 10);
	                    item[1] = parseInt(item[1], 10);
	                });
	            }
	            // 按比例缩放
	            this.setShape({
	                points: pointsNew
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 直线<br>
	 * @class fishTopoFlow.node.Line
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var line = new node.Line({
	 *           shape: {x1:60,  y1:60, x2:100, y2:100},  // x 起点 y终点
	 *           style: {lineWidth:3}
	 *       });
	 *       fishTopo.add(line);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Line',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.x1=0 起始点的横坐标值。
	         * @cfg {Number} shape.y1=0 起始点的纵坐标值。
	         * @cfg {Number} shape.x2=0 终止点的横坐标值。
	         * @cfg {Number} shape.y2=0 终止点的纵坐标值。
	         */
	        shape: {
	            // Start point
	            x1: 0,
	            y1: 0,
	            // End point
	            x2: 0,
	            y2: 0,
	
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var percent = shape.percent;
	
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (percent < 1) {
	                x2 = x1 * (1 - percent) + x2 * percent;
	                y2 = y1 * (1 - percent) + y2 * percent;
	            }
	            ctx.lineTo(x2, y2);
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} percent
	         * @return {Array.<number>}
	         */
	        pointAt: function (p) {
	            var shape = this.shape;
	            return [
	                shape.x1 * (1 - p) + shape.x2 * p,
	                shape.y1 * (1 - p) + shape.y2 * p
	            ];
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newX1 = Number(shape.x1 * scaleRatio);
	            var newX2 = Number(shape.x2 * scaleRatio);
	            var newY1 = Number(shape.y1 * scaleRatio);
	            var newY2 = Number(shape.y2 * scaleRatio);
	            if (ifParse) {
	                newX1 = parseInt(newX1, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                x1: newX1,
	                y1: newY1,
	                x2: newX2,
	                y2: newY2
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 拆线<br>
	 * @class fishTopoFlow.node.Polyline
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var polyline = new node.Polyline({
	 *           shape: {points:[[57,138],[95,184],[115,166],[151,184] ]}
	 *       });
	 *       fishTopo.add(polyline);
	 */
	
	    var polyHelper = __webpack_require__(53);
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Polyline',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Array} shape.points=null 拆线点的坐标 可以从AI中获取。
	         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑
	         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效
	         */
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        style: {
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, false);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var pointsNew = [];
	            shape.points.forEach(function(item) {
	                pointsNew.push([Number(item[0] * scaleRatio), Number(item[1] * scaleRatio)]);
	            });
	            if (ifParse) {
	                pointsNew.forEach(function(item) {
	                    item[0] = parseInt(item[0], 10);
	                    item[1] = parseInt(item[1], 10);
	                });
	            }
	            // 按比例缩放
	            this.setShape({
	                points: pointsNew
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 贝塞尔曲线<br>
	 * @class fishTopoFlow.node.BezierCurve
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var bezierCurve = new node.BezierCurve({
	 *           shape: {x1:0, y1:100, cpx1:0, cpy1:0, cpx2:0, cpy2:0, x2:100, y2:0},
	 *           position: [60, 60]
	 *       });
	 *       fishTopo.add(bezierCurve);
	 */
	
	
	    var curveTool = __webpack_require__(31);
	    var vec2 = __webpack_require__(15);
	    var quadraticSubdivide = curveTool.quadraticSubdivide;
	    var cubicSubdivide = curveTool.cubicSubdivide;
	    var quadraticAt = curveTool.quadraticAt;
	    var cubicAt = curveTool.cubicAt;
	    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;
	    var cubicDerivativeAt = curveTool.cubicDerivativeAt;
	
	    var out = [];
	
	    function someVectorAt(shape, t, isTangent) {
	        var cpx2 = shape.cpx2;
	        var cpy2 = shape.cpy2;
	        if (cpx2 === null || cpy2 === null) {
	            return [
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
	            ];
	        }
	        else {
	            return [
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
	            ];
	        }
	    }
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'BezierCurve',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.x1=0 起始点的横坐标值。
	         * @cfg {Number} shape.y1=0 起始点的纵坐标值。
	         * @cfg {Number} shape.x2=0 终止点的横坐标值。
	         * @cfg {Number} shape.y2=0 终止点的纵坐标值。
	         * @cfg {Number} shape.cpx1=0 控制点的横坐标值。
	         * @cfg {Boolean} shape.cpx2=0 控制点的纵坐标值。
	         */
	        shape: {
	            x1: 0,
	            y1: 0,
	            x2: 0,
	            y2: 0,
	            cpx1: 0,
	            cpy1: 0,
	
	            // Curve show percent, for animating
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var cpx1 = shape.cpx1;
	            var cpy1 = shape.cpy1;
	            var cpx2 = shape.cpx2;
	            var cpy2 = shape.cpy2;
	            var percent = shape.percent;
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (cpx2 == null || cpy2 == null) {
	                if (percent < 1) {
	                    quadraticSubdivide(
	                        x1, cpx1, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    x2 = out[2];
	                    quadraticSubdivide(
	                        y1, cpy1, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    y2 = out[2];
	                }
	
	                ctx.quadraticCurveTo(
	                    cpx1, cpy1,
	                    x2, y2
	                );
	            }
	            else {
	                if (percent < 1) {
	                    cubicSubdivide(
	                        x1, cpx1, cpx2, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    cpx2 = out[2];
	                    x2 = out[3];
	                    cubicSubdivide(
	                        y1, cpy1, cpy2, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    cpy2 = out[2];
	                    y2 = out[3];
	                }
	                ctx.bezierCurveTo(
	                    cpx1, cpy1,
	                    cpx2, cpy2,
	                    x2, y2
	                );
	            }
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        pointAt: function (t) {
	            return someVectorAt(this.shape, t, false);
	        },
	
	        /**
	         * Get tangent at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        tangentAt: function (t) {
	            var p = someVectorAt(this.shape, t, true);
	            return vec2.normalize(p, p);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var pointsNew = {};
	            Object.keys(shape).forEach(function (key) {
	                var value = shape[key];
	                if (key !== 'percent') {
	                    pointsNew[key] = Number(value * scaleRatio);
	                } else {
	                    pointsNew[key] = value;
	                }
	            });
	            if (ifParse) {
	                Object.keys(pointsNew).forEach(function(key) {
	                    pointsNew[key] = parseInt(pointsNew[key], 10);
	                });
	            }
	            // 按比例缩放
	            this.setShape(pointsNew);
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 圆弧<br>
	 * @class fishTopoFlow.node.Arc
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var arc = new node.Arc({
	 *           shape: {r:50, startAngle:0, endAngle:1.2*Math.PI},
	 *           position: [60, 60]
	 *       });
	 *       fishTopo.add(arc);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Arc',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=0 半径。
	         * @cfg {Number} shape.startAngle=0 开始弧度。
	         * @cfg {Number} shape.endAngle=Math.PI * 2  结束弧度。
	         * @cfg {Boolean} shape.clockwise=true 是否顺时针。
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            startAngle: 0,
	            endAngle: Math.PI * 2,
	            clockwise: true
	        },
	
	        style: {
	
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r + x, unitY * r + y);
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = Number(shape.r * scaleRatio);
	            if (ifParse) {
	                newR = parseInt(newR, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                r: newR
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 星形<br>
	 * @class fishTopoFlow.node.Star
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var star = new node.Star({
	 *           shape: {n:7, r:30},  //r半径 n几个角
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(star);
	 */
	
	    var PI = Math.PI;
	
	    var cos = Math.cos;
	    var sin = Math.sin;
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Star',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.n=3 几个角。
	         * @cfg {Number} shape.r=0 外半径。
	         * @cfg {Number} shape.r0=0 内半径。
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            n: 3,
	            r0: null,
	            r: 0
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var n = shape.n;
	            if (!n || n < 2) {
	                return;
	            }
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r = shape.r;
	            var r0 = shape.r0;
	
	            // 如果未指定内部顶点外接圆半径，则自动计算
	            if (r0 == null) {
	                r0 = n > 4
	                    // 相隔的外部顶点的连线的交点，
	                    // 被取为内部交点，以此计算r0
	                    ? r * cos(2 * PI / n) / cos(PI / n)
	                    // 二三四角星的特殊处理
	                    : r / 3;
	            }
	
	            var dStep = PI / n;
	            var deg = -PI / 2;
	            var xStart = x + r * cos(deg);
	            var yStart = y + r * sin(deg);
	            deg += dStep;
	
	            // 记录边界点，用于判断inside
	            ctx.moveTo(xStart, yStart);
	            for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {
	                ri = i % 2 === 0 ? r0 : r;
	                ctx.lineTo(x + ri * cos(deg), y + ri * sin(deg));
	                deg += dStep;
	            }
	
	            ctx.closePath();
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = Number(shape.r * scaleRatio);
	            if (ifParse) {
	                newR = parseInt(newR, 10);
	            }
	            // 按比例缩放
	            this.setShape({
	                r: newR
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 旋轮曲线<br>
	 * @class fishTopoFlow.node.Trochoid
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var trochoid = new node.Trochoid({
	 *           shape: {r:50, r0:35, d:30, location:null},  //r半径 n几个角
	 *           position:[60,60],
	 *           tooltip: "旋轮曲线"
	 *       });
	 *       fishTopo.add(trochoid);
	 */
	
	
	    var cos = Math.cos;
	    var sin = Math.sin;
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Trochoid',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=0 外半径。
	         * @cfg {Number} shape.r0=0 内半径。
	         * @cfg {Number} shape.d=0
	         * @cfg {Number} shape.location='out'
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            r0: 0,
	            d: 0,
	            location: 'out'
	        },
	
	        style: {
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1;
	            var y1;
	            var x2;
	            var y2;
	            var R = shape.r;
	            var r = shape.r0;
	            var d = shape.d;
	            var offsetX = shape.cx;
	            var offsetY = shape.cy;
	            var delta = shape.location == 'out' ? 1 : -1;
	
	            if (shape.location && R <= r) {
	                return;
	            }
	
	            var num = 0;
	            var i = 1;
	            var theta;
	
	            x1 = (R + delta * r) * cos(0)
	                - delta * d * cos(0) + offsetX;
	            y1 = (R + delta * r) * sin(0)
	                - d * sin(0) + offsetY;
	
	            ctx.moveTo(x1, y1);
	
	            // 计算结束时的i
	            do {
	                num++;
	            }
	            while ((r * num) % (R + delta * r) !== 0);
	
	            do {
	                theta = Math.PI / 180 * i;
	                x2 = (R + delta * r) * cos(theta)
	                     - delta * d * cos((R / r +  delta) * theta)
	                     + offsetX;
	                y2 = (R + delta * r) * sin(theta)
	                     - d * sin((R / r + delta) * theta)
	                     + offsetY;
	                ctx.lineTo(x2, y2);
	                i++;
	            }
	            while (i <= (r * num) / (R + delta * r) * 360);
	
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.shape;
	            var newR = Number(shape.r * scaleRatio);
	            var newR0 = Number(shape.r0 * scaleRatio);
	            var newD = Number(shape.d * scaleRatio);
	            newR = parseInt(newR, 10);
	            newR0 = parseInt(newR0, 10);
	            newD = parseInt(newD, 10);
	            // 按比例缩放
	            this.setShape({
	                r: newR,
	                r0: newR0,
	                d: newD
	            });
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 路径<br>
	 * @class fishTopoFlow.node.Path
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var path = new node.Path({
	 *           pathData: 'M9 0l8 8-17 17 7 7 17-17 8 8v-23h-23z',
	 *           rect: {x:0,y:0,width:30,height:30},
	 *           position: [60,60]
	 *       });
	 *       fishTopo.add(path);
	 */
	
	    var pathTool = __webpack_require__(6);
	    var Draggable = __webpack_require__(43);
	    var zrUtil = __webpack_require__(5);
	    var flowNode = __webpack_require__(96);
	
	    function ZPath(opts) {
	        /**
	         * @cfg {Object} options 参数
	         * @cfg {String} options.pathData path数据。
	         * @cfg {Object} options.rect 图形的大小。
	         * @cfg {Object} options.rect.width 图形的宽度。
	         * @cfg {Object} options.rect.height 图形的高度。
	         * @cfg {Number} [options.layout=null] 默认为null  仅支持"center"
	         *
	         */
	        var defaultOptions = {
	            style:{ fill: 'none',stroke: '#2c2c2c'},
	            rect:{x:0,y:0,width:0,height:0},
	            rectHover: true
	        }
	
	        var pathData = opts.pathData;
	        var model = flowNode.genModel("Path", opts);
	        delete opts.pathData;
	        this.options = zrUtil.merge(defaultOptions, opts, true);
	        var path = pathTool.createFromString(pathData, this.options);
	        path.model = model;
	        Draggable.call(path);
	        var boundingRect = path.getBoundingRect();
	        var rect = this.options.rect;
	        var layout = opts.layout;
	        if (rect) {
	            var aspect = boundingRect.width / boundingRect.height;
	
	            if (layout === 'center') {
	                // Set rect to center, keep width / height ratio.
	                var width = rect.height * aspect;
	                var height;
	                if (width <= rect.width) {
	                    height = rect.height;
	                }
	                else {
	                    width = rect.width;
	                    height = width / aspect;
	                }
	                var cx = rect.x + rect.width / 2;
	                var cy = rect.y + rect.height / 2;
	
	                rect.x = cx - width / 2;
	                rect.y = cy - height / 2;
	                rect.width = width;
	                rect.height = height;
	            }
	
	            this.resizePath(path, rect);
	        }
	        path.type = 'ZPath';
	        return path;
	    }
	
	    ZPath.prototype = {
	
	        constructor: ZPath,
	
	        type: 'ZPath',
	        /**
	         * Resize a path to fit the rect
	         */
	        resizePath: function (path, rect) {
	                if (!path.applyTransform) {
	                    return;
	                }
	
	                var pathRect = path.getBoundingRect();
	
	                var m = pathRect.calculateTransform(rect);
	
	                path.applyTransform(m);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var rect = this.rect;
	            var newW = Number(rect.width * scaleRatio);
	            var newH = Number(newW * rect.height / rect.width);
	            if (ifParse) {
	                newW = parseInt(newW, 10);
	                newH = parseInt(newH, 10);
	            }
	            rect.width = newW;
	            rect.height = newH;
	            // 按比例缩放
	            this.attr('rect', rect);
	        }
	    }
	    zrUtil.inherits(ZPath, Draggable);
	    module.exports = ZPath;
	
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 图形按钮<br>
	 * @class fishTopoFlow.node.IconButton
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var iconButton   = new node.IconButton({
	 *          title:'IconButton',
	 *          icon:'path://M432.45,595.444c0,2.177-4.661,6.82-11.305,6.82c-6.475,0-11.306-4.567-11.306-6.82s4.852-6.812,11.306-6.812C427.841,588.632,432.452,593.191,432.45,595.444L432.45,595.444z M421.155,589.876c-3.009,0-5.448,2.495-5.448,5.572s2.439,5.572,5.448,5.572c3.01,0,5.449-2.495,5.449-5.572C426.604,592.371,424.165,589.876,421.155,589.876L421.155,589.876z M421.146,591.891c-1.916,0-3.47,1.589-3.47,3.549c0,1.959,1.554,3.548,3.47,3.548s3.469-1.589,3.469-3.548C424.614,593.479,423.062,591.891,421.146,591.891L421.146,591.891zM421.146,591.891',
	 *          itemSize:50,
	 *          position:[60,60]
	 *       });
	 *       fishTopo.add(iconButton);
	 */
	
	
	
	    var zrUtil = __webpack_require__(5);
	    var graphic = __webpack_require__(4);
	    var flowNode = __webpack_require__(96);
	
	    function IconButton(opts) {
	
	        /**
	         * @cfg {Object} options 构造参数
	         * @cfg {String} options.title="" 鼠标移上去显示的文字
	         * @cfg {String} options.icon="" Icon 的 path 字符串，支持使用自定义的 svg path 作为 icon，格式参见 [SVG PathData](https://www.w3.org/TR/SVG/paths.html#PathData)。可以从 Adobe Illustrator 等工具编辑导出。
	         * @cfg {Number} options.itemSize=15  icon 的大小
	         * @cfg {Object} options.iconStyle  图标样式
	         * @cfg {Object} options.iconStyle.normal 正常的样式
	         * @cfg {Number} options.iconStyle.normal.stroke='#666' 正常的样式（描边色）
	         * @cfg {Number} options.iconStyle.normal.fill='none' 正常的样式（填充色）
	         * @cfg {Object} options.iconStyle.emphasis 高亮状态下的样式
	         * @cfg {Number} options.iconStyle.emphasis.stroke='#666' 高亮状态下的样式（描边色）
	         * @cfg {Number} options.iconStyle.emphasis.fill='none' 高亮状态下的样式（填充色）
	         */
	        var defaultOptions = {
	            backgroundColor: 'transparent',
	            borderColor: '#ccc',
	            draggable:false,
	            selectable:false,
	            borderWidth: 0,
	            itemSize: 15,
	            showTitle: true,
	            icon:"",  //Icon 的 path 字符串，支持使用自定义的 svg path 作为 icon，格式参见 SVG PathData。可以从 Adobe Illustrator 等工具编辑导出。
	            iconStyle: {
	                normal: {
	                    stroke: '#666',
	                    fill: 'none'
	                },
	                emphasis: {
	                    stroke: '#3E98c5'
	                }
	            }
	        };
	        this.options = zrUtil.merge(defaultOptions, opts, true);
	
	        this.model = flowNode.genModel("IconButton", this.options);
	        graphic.Group.call(this, this.options);
	        this.render();
	    }
	    IconButton.prototype = {
	        constructor: IconButton,
	        type: "IconButton",
	        render: function () {
	            var normalStyle = this.options.iconStyle.normal;
	            var hoverStyle = this.options.iconStyle.emphasis;
	            var itemSize = this.options.itemSize;
	            var icon = this.options.icon;
	            var style = {
	                x: -itemSize / 2,
	                y: -itemSize / 2,
	                width: itemSize,
	                height: itemSize
	            };
	            var path = icon.indexOf('image://') === 0 ?
	                (
	                    style.image = icon.slice(8),
	                    new graphic.Image({
	                        style: style
	                    })
	                ) :
	                graphic.makePath(
	                    icon.replace('path://', ''), {
	                        style: normalStyle,
	                        hoverStyle: hoverStyle,
	                        rectHover: true
	                    },
	                    style,
	                    'center'
	                );
	
	            graphic.setHoverStyle(path);
	
	            if (this.options.showTitle) {
	                path.__title = this.options.title;
	                path.on('mouseover', function () {
	                        // Should not reuse above hoverStyle, which might be modified.
	                        path.setStyle({
	                            text: this.options.title,
	                            textPosition: hoverStyle.textPosition || 'bottom',
	                            textFill: hoverStyle.fill || hoverStyle.stroke || '#000',
	                            textAlign: hoverStyle.textAlign || 'center'
	                        });
	                    }.bind(this))
	                    .on('mouseout', function () {
	                        path.setStyle({
	                            textFill: null
	                        });
	                    });
	            }
	
	            path.trigger('normal');
	            this.add(path);
	        }
	    }
	
	    zrUtil.inherits(IconButton, graphic.Group);
	    module.exports = IconButton;
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * fishTopoFlow的link对象，框架提供的连线都放在这个对象下。
	 * @class fishTopoFlow.link
	 * @abstract
	 */
	
	    var Link = __webpack_require__(118);
	    var Fold = __webpack_require__(120);
	    var Curve = __webpack_require__(121);
	    var Chain = __webpack_require__(122);
	    var Connector = __webpack_require__(82);
	    var flowLink = {};
	    flowLink.Link = flowLink[Connector.TYPE_STRAIGHT] = Link;
	    flowLink.Fold = flowLink[Connector.TYPE_JAGGED] = Fold;
	    flowLink.Curve = flowLink[Connector.TYPE_CURVE] = Curve;
	    flowLink.Chain = flowLink[Connector.TYPE_CHAIN] = Chain;
	    module.exports = flowLink;
	
	
	/**
	 * @method constructor
	 * 连线的构造函数
	 * @param  {Object} startNode 开始节点
	 * @param  {Object} endNode   结束节点
	 * @param  {Object} options 线段选项
	 * @param {Object} [options.style] 节点的样式
	 * @param {Number} [options.style.lineWidth=1] 线段的宽度
	 * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	 * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	 * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	 * @param {Object} [options.symbol] 线段的箭头
	 * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	 * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	 * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	 * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	 * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]
	 * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0；此属性只针对直线和折线类型有效，如果是折线，offset最大值不能超过options.bundleOffset(默认是30)设置的值 since V2.3.0
	 * @param {Object} [options.text] 线段上的文字
	 * @param {String} [options.text.text] 线段上的文字内容
	 * @param {String} [options.text.color] 线段上的文字颜色
	 * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	 * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	 * @param {Boolean} [options.text.textRotateable] 文字随线段旋转, 默认值为true
	 * @param {Object} [options.image] 线段上的图片节点
	 * @param {String} [options.image.image] 线段上的图片节点的路径
	 * @param {String} [options.image.imagePos] 线段上的图片节点位置可选值 'start','center','end',默认值为center
	 * @param {Number|Array} [options.image.offset] 线段上的图片位置偏移量,为number则是x偏移 array则为[x,y]
	 * @param {Boolean} [options.image.imageRotateable] 图片随线段旋转, 默认值为true
	 * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	 * @param {String} [options.position] 指定线段位置
	 * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	 * @param {Object} [options.position.startOffset] 线段开始位置的偏移
	 * @param {Object} [options.position.endOffset] 线段结束位置的偏移
	 * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	 * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	 * @param {Object} [options.effect] 线上动态效果
	 * @param {String} [options.effect.show] 是否显示箭头动效
	 * @param {Number} [options.effect.period] 动效移动速度
	 * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	 * @param {Number} [options.z] 连线的层级，越大越在前面显示
	 * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)
	 * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)
	 * @return {Object} 返回创建成功的连线对象
	 */
	
	
	/**
	 * @method setStyle
	 * 创建连线后，设置连线的样式
	 * @param {Object} options 对应创建节点，传递的options参数
	 * @param {Object} [options.text] 连线文字的样式
	 * @param {Object} [options.symbol] 连线箭头的样式
	 * @param {String} [options.color] 连线的颜色
	 */
	/**
	 * @method on
	 * 绑定事件
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 * @param {Object} [context] 上下文
	 */
	
	/**
	 * @method off
	 * 解绑事件
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 */
	
	/**
	 * @method one
	 * 单次触发绑定,trigger后销毁
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 * @param {Object} [context] 上下文
	 */
	
	/**
	 * @method trigger
	 * 事件分发
	 * @param {String} type 事件类型
	 */
	/**
	 * @event click
	 * 单击事件
	 *
	 * <pre>
	 * flink.on('Connector:click', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event dblclick
	 * 当双击元素时，会发生 dblclick 事件。
	 *
	 * <pre>
	 * flink.on('Connector:dblclick', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 直线<br>
	 * @class fishTopoFlow.link.Link
	 * @extends fishTopoFlow.link
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var link = fishTopoFlow.link;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       //节点
	 *       function newNode(x, y, w, h) {
	 *           var rect = new node.Rect({
	 *               shape: {width: w,height: h},
	 *               position: [x, y],
	 *               style: {fill: "#167CFF"}
	 *           });
	 *           fishTopo.add(rect);
	 *           return rect;
	 *       }
	 *       //简单连线
	 *       function newLink(startNode, endNode, text, dashedPattern) {
	 *           var slink = new link.Link(startNode, endNode, {
	 *               style: {lineDash: [dashedPattern]},
	 *               text: {text: text}
	 *           })
	 *           fishTopo.add(slink);
	 *           return slink;
	 *       }
	 *       var from = newNode(100, 60, 30, 30);
	 *       var to = newNode(300, 60, 30, 30);
	 *       newLink(from, to, '虚线带箭头', 5);
	 */
	
	    var Connector = __webpack_require__(82);
	    var Flow = __webpack_require__(119);
	
	    function Link(startNode,endNode,options) {
	        var opt = Flow.translateLinkOptions(options);
	        //默认就是直线
	        var connector = new Connector(opt);
	        connector.startNode = startNode;
	        connector.endNode = endNode;
	
	        return connector;
	    }
	    /**
	     * @method createByPoint
	     * 用户指定连线的点，来进行画线
	     * @param  {Object} options 线段选项
	     * @param {Object} [options.style] 节点的样式
	     * @param {Number} [options.style.lineWidth=1] 线段的宽度
	     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	     * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	     * @param {Object} [options.symbol] 线段的箭头
	     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]
	     * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0 since V2.3.0
	     * @param {Object} [options.text] 线段上的文字
	     * @param {String} [options.text.text] 线段上的文字内容
	     * @param {String} [options.text.textFill] 线段上的文字颜色
	     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	     * @param {Boolean} [options.text.textRotateable] 文字随线段旋转, 默认值为true
	     * @param {Object} [options.image] 线段上的图片节点
	     * @param {String} [options.image.image] 线段上的图片节点的路径
	     * @param {String} [options.image.imagePos] 线段上的图片节点位置可选值 'start','center','end',默认值为center
	     * @param {Number|Array} [options.image.offset] 线段上的图片位置偏移量,为number则是x偏移 array则为[x,y]
	     * @param {Boolean} [options.image.imageRotateable] 图片随线段旋转, 默认值为true
	     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {String} [options.position] 指定线段位置
	     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {Object} [options.position.startOffset] 线段开始位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10
	     * @param {Object} [options.position.endOffset] 线段结束位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10
	     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	     * @param {Object} [options.effect] 线上动态效果
	     * @param {String} [options.effect.show] 是否显示箭头动效
	     * @param {Number} [options.effect.period] 动效移动速度
	     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	     * @param {Number} [options.z] 连线的层级，越大越在前面显示
	     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)
	     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)
	     */
	    Link.createByPoint = function(options) {
	        var opt = Flow.translateLinkOptions(options);
	        //默认就是直线
	        var connector = new Connector(opt);
	        return connector;
	    }
	
	    module.exports = Link;
	
	


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Flow静态方法类
	 * @class fish.topo.FishTopoFlow.Flow
	 */
	
	
	    var Constants = __webpack_require__(93);
	    var GroupNode = __webpack_require__(95);
	    var util = __webpack_require__(65);
	    var Flow = {
	        FLOW_TYPE: "elementType",
	        LINK: "connection",
	        RECT: "Rect",
	        Group: 'Group',
	        IMAGE: 'Image',
	        TEXT: 'Text',
	        CIRCLE: 'Circle',
	        SECTOR: 'Sector',
	        RING: 'Ring',
	        POLYGON: 'Polygon',
	        POLYLINE: 'Polyline',
	        LINE: 'Line',
	        BEZIERCURVE: 'Beziercurve',
	        ARC: 'Arc',
	        SCENE:'scene',
	
	        /**
	         * @method setUserData
	         * 设置用户数据
	         * @param {Object} node 需要设置数据的节点
	         * @param {Object} obj 数据
	         * **使用范例**：
	         *
	         *      @example
	         *      //设置自定义数据
	         *      this.fishTopo.Flow.setUserData(rect, { customObj: "rect" });
	         */
	        setUserData: function(node, obj) {
	            node.model.set(Constants.USERDATA, obj);
	        },
	        /**
	         * 获取设置的用户数据
	         * @param {Object} node 需要获取数据的节点
	         * @return {String}      数据
	         * **使用范例**：
	         *
	         *      @example
	         *      //获取自定义数据
	         *      this.fishTopo.Flow.getUserData(rect);
	         */
	        getUserData: function(node) {
	            var userData = node.model.get(Constants.USERDATA);
	            if (util.isUndefined(userData)) {
	                userData = {};
	            }
	            return userData;
	        },
	        /**
	         * 判断是否是连线
	         * @param {Object} model 对象的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是连线
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isLink(nodeModel)) { return true;}
	         */
	        isLink: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.LINK;
	        },
	        /**
	         * 判断是否是节点
	         * @param {Object} model 对象的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isNode(nodeModel)) { return true;}
	         */
	
	        isNode: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            var isNode;
	            if(elementType !=  Flow.LINK && elementType !=  Flow.SCENE){
	                isNode = true;
	            }else{
	                isNode = false;
	            }
	            return isNode;
	        },
	
	        isInGroup: function(node) {
	            return node.parent && node.parent instanceof GroupNode;
	        },
	
	        isGroupNode: function(node) {
	            return node instanceof GroupNode;
	        },
	        parentX: function(node) {
	            if (node.parent && Flow.isGroupNode(node.parent)) {
	                return node.position[0] + Flow.parentX(node.parent)
	            } else {
	                return node.position[0]
	            }
	        },
	        parentY: function(node) {
	            if (node.parent && Flow.isGroupNode(node.parent)) {
	                return node.position[1] + Flow.parentY(node.parent)
	            } else {
	                return node.position[1]
	            }
	        },
	
	        /**
	         * 判断节点是否是矩形节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是矩形节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isRect(nodeModel)) { return true;}
	         */
	        isRect: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return  elementType == Flow.RECT;
	        },
	        /**
	         * 判断节点是否是图片节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是图片节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isImage(nodeModel)) { return true;}
	         */
	        isImage: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.IMAGE;
	        },
	        /**
	         * 判断节点是否是文字节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是文字节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isText(nodeModel)) { return true;}
	         */
	        isText: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.TEXT;
	        },
	        /**
	         * 判断节点是否是圆形节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是圆形节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isCircle(nodeModel)) { return true;}
	         */
	        isCircle: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.CIRCLE;
	        },
	        /**
	         * 获取节点的类型
	         * @param {Object} model 节点的model
	         * **使用范例**：
	         *
	         *      @example
	         *      //获取节点类型
	         *      var nodeModel = e.target.model;
	         *      return this.fishTopo.Flow.getType(nodeModel);
	         */
	        getType: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType;
	        },
	        translateLinkOptions: function(options) {
	            if (options) {
	                if (options.pos) {
	                    var arrPos = options.pos.split(",");
	                    if (arrPos.length >= 2) {
	                        if (!options.position) {
	                            options.position = {};
	                        }
	                        options.position.startPos = arrPos[0];
	                        options.position.endPos = arrPos[1];
	                    }
	                }
	                if (options.text && options.text.color) {
	                    options.text.textFill = options.text.color;
	                }
	            }
	            return options;
	        }
	    };
	
	    module.exports = Flow;
	


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 折线<br>
	 * @class fishTopoFlow.link.Fold
	 * @extends fishTopoFlow.link
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var link = fishTopoFlow.link;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       //节点
	 *       function newNode(x, y, w, h) {
	 *           var rect = new node.Rect({
	 *               shape: {width: w,height: h},
	 *               position: [x, y],
	 *               style: {fill: "#167CFF"}
	 *           });
	 *           fishTopo.add(rect);
	 *           return rect;
	 *       }
	 *       //折线
	 *       function newFoldLink(startNode, endNode, text, direction, dashedPattern) {
	 *           var flink = new link.Fold(startNode, endNode, {
	 *               style: {lineDash: [dashedPattern]},
	 *               text: {text: text},
	 *               pos: direction
	 *           })
	 *           fishTopo.add(flink);
	 *           return flink;
	 *       }
	 *       var from = newNode(100, 40, 30, 30);
	 *       var to = newNode(300, 80, 30, 30);
	 *       newFoldLink(from, to, '折线');
	 */
	
	    var Connector = __webpack_require__(82);
	    var zrUtil = __webpack_require__(5);
	    var Flow = __webpack_require__(119);
	
	    function Fold(startNode,endNode,options) {
	        //折线
	        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_JAGGED}}, options, true);
	        opt = Flow.translateLinkOptions(opt);
	        var connector = new Connector(opt);
	        connector.startNode = startNode;
	        connector.endNode = endNode;
	
	        return connector;
	    }
	
	    /**
	     * @method createByPoint
	     * 用户指定连线的点，来进行画线
	     * @param  {Object} options 线段选项
	     * @param {Object} [options.style] 节点的样式
	     * @param {Number} [options.style.lineWidth=1] 线段的宽度
	     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	     * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	     * @param {Object} [options.symbol] 线段的箭头
	     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]
	     * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0；offset最大值不能超过options.bundleOffset(默认30) 设置的值 since V2.3.0
	     * @param {Object} [options.text] 线段上的文字
	     * @param {String} [options.text.text] 线段上的文字内容
	     * @param {String} [options.text.color] 线段上的文字颜色
	     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {String} [options.position] 指定线段位置
	     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {Object} [options.position.startOffset] 线段开始位置的偏移
	     * @param {Object} [options.position.endOffset] 线段结束位置的偏移
	     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	     * @param {Object} [options.effect] 线上动态效果
	     * @param {String} [options.effect.show] 是否显示箭头动效
	     * @param {Number} [options.effect.period] 动效移动速度
	     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	     * @param {Number} [options.z] 连线的层级，越大越在前面显示
	     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)
	     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)
	     */
	    Fold.createByPoint = function(options) {
	        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_JAGGED}}, options, true);
	        opt = Flow.translateLinkOptions(opt);
	        var connector = new Connector(opt);
	        return connector;
	    }
	    module.exports = Fold;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 曲线<br>
	 * @class fishTopoFlow.link.Curve
	 * @extends fishTopoFlow.link
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var link = fishTopoFlow.link;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       //节点
	 *       function newNode(x, y, w, h) {
	 *           var rect = new node.Rect({
	 *               shape: {width: w,height: h},
	 *               position: [x, y],
	 *               style: {fill: "#167CFF"}
	 *           });
	 *           fishTopo.add(rect);
	 *           return rect;
	 *       }
	 *       //曲线
	 *       function newCurveLink(startNode, endNode, text, direction, dashedPattern) {
	 *           var clink = new link.Curve(startNode, endNode, {
	 *               style: {lineDash: [dashedPattern]},
	 *               text: {text: text},
	 *               pos: direction
	 *           })
	 *           fishTopo.add(clink);
	 *           return clink;
	 *       }
	 *       var from = newNode(100, 40, 30, 30);
	 *       var to = newNode(300, 80, 30, 30);
	 *       newCurveLink(from, to, '曲线');
	 */
	
	    var Connector = __webpack_require__(82);
	    var zrUtil = __webpack_require__(5);
	    var Flow = __webpack_require__(119);
	    function Curve(startNode,endNode,options) {
	        //曲线
	        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_CURVE}}, options, true);
	        opt = Flow.translateLinkOptions(opt);
	
	        var connector = new Connector(opt);
	        connector.startNode = startNode;
	        connector.endNode = endNode;
	
	        return connector;
	    }
	    /**
	     * @method createByPoint
	     * 用户指定连线的点，来进行画线
	     * @param  {Object} options 线段选项
	     * @param {Object} [options.style] 节点的样式
	     * @param {Number} [options.style.lineWidth=1] 线段的宽度
	     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	     * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	     * @param {Object} [options.symbol] 线段的箭头
	     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]
	     * @param {Object} [options.text] 线段上的文字
	     * @param {String} [options.text.text] 线段上的文字内容
	     * @param {String} [options.text.color] 线段上的文字颜色
	     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {String} [options.position] 指定线段位置
	     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {Object} [options.position.startOffset] 线段开始位置的偏移
	     * @param {Object} [options.position.endOffset] 线段结束位置的偏移
	     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	     * @param {Object} [options.effect] 线上动态效果
	     * @param {String} [options.effect.show] 是否显示箭头动效
	     * @param {Number} [options.effect.period] 动效移动速度
	     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	     * @param {Number} [options.z] 连线的层级，越大越在前面显示
	     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)
	     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)
	     */
	    Curve.createByPoint = function(options) {
	        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_CURVE}}, options, true);
	        opt = Flow.translateLinkOptions(opt);
	        var connector = new Connector(opt);
	        return connector;
	    }
	    module.exports = Curve;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 链路 支持线上多文本展示， 最大的不同是text.text对象为数组类型，表示多个文本的数据。数组元素可以为字符串，表示每个文本的名字；也可以是个对象，对象中必须指定text属性，其值为文本的名字，其余属性则为业务侧自定义的<br>
	 * @class fishTopoFlow.link.Chain
	 * @extends fishTopoFlow.link
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var link = fishTopoFlow.link;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       //节点
	 *       function newNode(x, y, w, h) {
	 *           var rect = new node.Rect({
	 *               shape: {width: w,height: h},
	 *               position: [x, y],
	 *               style: {fill: "#167CFF"}
	 *           });
	 *           fishTopo.add(rect);
	 *           return rect;
	 *       }
	 *       //节点间链路
	 *       function newChain(startNode, endNode, text, dashedPattern) {
	 *           var slink = new link.Chain(startNode, endNode, {
	 *               style: {lineDash: [dashedPattern]},
	 *               text: {text: text}
	 *           })
	 *           fishTopo.add(slink);
	 *           return slink;
	 *       }
	 *       var from = newNode(100, 60, 30, 30);
	 *       var to = newNode(300, 60, 30, 30);
	 *       newChain(from, to, [{text: '倾斜文本1', linkId: 100}, {text: '倾斜文本2', linkId: 111}, {text: '倾斜文本3', linkId: 112}], 5);
	 */
	
	    var Connector = __webpack_require__(82);
	    var Flow = __webpack_require__(119);
	
	    function Chain(startNode,endNode,options) {
	        options.style.lineType = Connector.TYPE_CHAIN
	        var opt = Flow.translateLinkOptions(options);
	        var connector = new Connector(opt);
	        connector.startNode = startNode;
	        connector.endNode = endNode;
	
	        return connector;
	    }
	    /**
	     * @method createByPoint
	     * 用户指定连线的点，来进行画线
	     * @param  {Object} options 线段选项
	     * @param {Object} [options.style] 节点的样式
	     * @param {Number} [options.style.lineWidth=1] 线段的宽度
	     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	     * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	     * @param {Object} [options.symbol] 线段的箭头
	     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]
	     * @param {Number} [options.symbol.offset] 设置箭头在连线上的偏移量，默认是0 since V2.3.0
	     * @param {Object} [options.text] 线段上的文字
	     * @param {Object} [options.text.text] 为数组类型，表示多个文本的数据。数组元素可以为字符串，表示每个文本的名字；也可以是个对象，对象中必须指定text属性，其值为文本的名字，其余属性则为业务侧自定义的
	     * @param {String} [options.text.color] 线段上的文字颜色
	     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {String} [options.position] 指定线段位置
	     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {Object} [options.position.startOffset] 线段开始位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10
	     * @param {Object} [options.position.endOffset] 线段结束位置的偏移[x,y]   eg. startOffset:[0,10] 在x上偏移0 y上偏移10
	     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	     * @param {Object} [options.effect] 线上动态效果
	     * @param {String} [options.effect.show] 是否显示箭头动效
	     * @param {Number} [options.effect.period] 动效移动速度
	     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	     * @param {Number} [options.z] 连线的层级，越大越在前面显示
	     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)
	     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)
	     */
	    Chain.createByPoint = function(options) {
	        var opt = Flow.translateLinkOptions(options);
	        var connector = new Connector(opt);
	        return connector;
	    }
	
	    module.exports = Chain;
	
	


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连线操作类
	 * @author miao.cunzhi
	 */
	
	    var symbolUtil = __webpack_require__(83);
	    var zrUtil = __webpack_require__(5);
	    var icon = __webpack_require__(89);
	    function LineOperationManager(connectionManager, api) {
	        this.lineOperations = [],
	        this.isEdit = true;
	        this.connectionManager = connectionManager;
	        this._api = api;
	    }
	
	    /**
	     *  this.lineOperationManager.addIcon(key, options);
	     */
	    LineOperationManager.prototype.addIcon = function(key, options) {
	        //判断是小图标否存在 ，存在则直接返回
	        var lineOperationIcon = zrUtil.find(options.lineNode.icons, function(icon) {
	            return icon.key === key;
	        });
	
	        if (lineOperationIcon) {
	            this.bindOperation(options.lineNode);
	            return;
	        }else {
	            var lineOperation = this.creatOperation(key, options);
	            this._api._getParentZr().add(lineOperation);
	            this.bindOperation(options.lineNode);
	            return lineOperation;
	        }
	    }
	
	
	    LineOperationManager.prototype.creatOperation = function(key, options) {
	        var lineOperation = symbolUtil.createSymbol(options.iconPath, 0, 0, options.width || 15, options.height || 15, 0, options.color||'#aaaaac');
	        lineOperation.key = key;
	        lineOperation._width =  options.width || 15;  // path情况下无法计算
	        lineOperation._isLineOperationIcon = true;
	        lineOperation.hide();
	        options.lineNode.icons.push(lineOperation);
	        this.lineOperations.push(lineOperation);
	
	        //小图标 点击事件  如果有回调则调用回调，否则派发事件
	        lineOperation.on("click", function(event) {
	            if (options.callback) {
	                event.data = options;
	                event.lineNode = options.lineNode;
	                options.callback(event);
	            } else {
	                var params = {};
	                params.event = event;
	                params.type = "click";
	                params.elementType = "LineOperationIcon";
	                this._api.trigger(params.type, params);
	            }
	        }.bind(this));
	        return lineOperation;
	    }
	
	    /**
	     * 计算小图标的位置，并显示
	     * @param  {[type]} connector [description]
	     * @return {[type]}           [description]
	     */
	    LineOperationManager.prototype.bindOperation = function(connector) {
	        function parentX(node) {
	            if (node.parent && node.parent.nodeType == "SubProcess") {
	                return node.position[0] + parentX(node.parent)
	            } else {
	                return node.position[0]
	            }
	        }
	    
	        function parentY(node) {
	            if (node.parent && node.parent.nodeType == "SubProcess") {
	                return node.position[1] + parentY(node.parent)
	            } else {
	                return node.position[1]
	            }
	        }
	
	        if (this.isEdit == false) {
	            return;
	        }
	        var pointPosition = connector.middle(), posX, posY;
	        if (connector.parent && connector.parent.nodeType == "SubProcess") {
	            posX = pointPosition[0] + parentX(connector.parent);
	            posY = pointPosition[1] + parentY(connector.parent);
	        } else {
	            posX = pointPosition[0];
	            posY = pointPosition[1];
	        }
	
	        var arrLength = zrUtil.map(connector.icons, function(icon) {
	            return icon._width;
	        });
	
	        var totalLength = zrUtil.reduce(arrLength, function(previousValue,currentValue) {
	            return previousValue + currentValue + 10;
	        }, 0 );
	
	        zrUtil.each(connector.icons, function(icon, index) {
	            var connectorPosition = 0;
	            for (var k = 0; k < index; k++) {
	                connectorPosition += arrLength[k] + 10;
	            }
	            icon.attr("position", [posX + connectorPosition - totalLength / 2, posY + 5]);
	            icon.show();
	            icon.attachLine = connector;
	        })
	    }
	
	    LineOperationManager.prototype.hideAllLineOperation = function() {
	        zrUtil.each(this.lineOperations, function(lineOperation) {
	            lineOperation.hide();
	        });
	    }
	
	    LineOperationManager.prototype.addDeleteIcon = function(lineNode,options) {
	        var opts = zrUtil.defaults({
	            iconPath: 'path://' + icon.DEL_SVG,
	            width: 12,
	            height: 14,
	            lineNode: lineNode,
	            callback: function(e) {
	                this._api.remove(e.target.attachLine);//this.connectionManager.selConnector);
	            }.bind(this)
	        }, options,true);
	
	        this.addIcon("delete", opts);
	    }
	
	    LineOperationManager.prototype.addChangeLineTypeIcon = function(lineNode,options) {
	        var opts = zrUtil.defaults({
	            iconPath: 'path://' + icon.CHANGE_LINE_TYPE_SVG,
	            width: 15,
	            height: 15,
	            lineNode: lineNode,
	            callback: function () {
	                this._api.changeSelectConnectorType();
	            }.bind(this)
	        }, options,true);
	
	        this.addIcon("change", opts)
	    }
	
	    module.exports = LineOperationManager;
	


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * fishTopoFlow的layout对象，框架提供的布局都放在这个对象下。通过addCustomLayout方法添加自定义布局
	 * @class fishTopoFlow.layout
	 * @abstract
	 */
	
	    var BoundingRect = __webpack_require__(27);
	    var zrUtil = __webpack_require__(5);
	    var flowUtil = __webpack_require__(94);
	    var HLayout = __webpack_require__(125);
	    var VLayout = __webpack_require__(126);
	    var TreeLayout = __webpack_require__(127);
	    var ForceLayout = __webpack_require__(130);
	    var parsePercent = flowUtil.parsePercent;
	    var Tree = __webpack_require__(128);
	    var layout = {};
	    layout.HLayout = HLayout;
	    layout.VLayout = VLayout;
	    layout.TreeLayout = TreeLayout;
	    layout.ForceLayout = ForceLayout;
	    layout.Tree = Tree
	
	    /**
	     * @method addCustomLayout
	     * 添加自定义布局类
	     * @param {Object} customLayout 自定义布局的类
	     */
	    layout.addCustomLayout = function(customLayout) {
	        layout.customLayout = customLayout;
	    }
	
	
	    layout.getLayoutRect = function (positionInfo, containerRect, margin) {
	        margin = flowUtil.normalizeCssArray(margin || 0);
	
	        var containerWidth = containerRect.width;
	        var containerHeight = containerRect.height;
	
	        var left = parsePercent(positionInfo.left, containerWidth);
	        var top = parsePercent(positionInfo.top, containerHeight);
	        var right = parsePercent(positionInfo.right, containerWidth);
	        var bottom = parsePercent(positionInfo.bottom, containerHeight);
	        var width = parsePercent(positionInfo.width, containerWidth);
	        var height = parsePercent(positionInfo.height, containerHeight);
	
	        var verticalMargin = margin[2] + margin[0];
	        var horizontalMargin = margin[1] + margin[3];
	        var aspect = positionInfo.aspect;
	
	        // If width is not specified, calculate width from left and right
	        if (isNaN(width)) {
	            width = containerWidth - right - horizontalMargin - left;
	        }
	        if (isNaN(height)) {
	            height = containerHeight - bottom - verticalMargin - top;
	        }
	
	        // If width and height are not given
	        // 1. Graph should not exceeds the container
	        // 2. Aspect must be keeped
	        // 3. Graph should take the space as more as possible
	        if (isNaN(width) && isNaN(height)) {
	            if (aspect > containerWidth / containerHeight) {
	                width = containerWidth * 0.8;
	            }
	            else {
	                height = containerHeight * 0.8;
	            }
	        }
	
	        if (aspect != null) {
	            // Calculate width or height with given aspect
	            if (isNaN(width)) {
	                width = aspect * height;
	            }
	            if (isNaN(height)) {
	                height = width / aspect;
	            }
	        }
	
	        // If left is not specified, calculate left from right and width
	        if (isNaN(left)) {
	            left = containerWidth - right - width - horizontalMargin;
	        }
	        if (isNaN(top)) {
	            top = containerHeight - bottom - height - verticalMargin;
	        }
	
	        // Align left and top
	        switch (positionInfo.left || positionInfo.right) {
	            case 'center':
	                left = containerWidth / 2 - width / 2 - margin[3];
	                break;
	            case 'right':
	                left = containerWidth - width - horizontalMargin;
	                break;
	        }
	        switch (positionInfo.top || positionInfo.bottom) {
	            case 'middle':
	            case 'center':
	                top = containerHeight / 2 - height / 2 - margin[0];
	                break;
	            case 'bottom':
	                top = containerHeight - height - verticalMargin;
	                break;
	        }
	        // If something is wrong and left, top, width, height are calculated as NaN
	        left = left || 0;
	        top = top || 0;
	        if (isNaN(width)) {
	            // Width may be NaN if only one value is given except width
	            width = containerWidth - left - (right || 0);
	        }
	        if (isNaN(height)) {
	            // Height may be NaN if only one value is given except height
	            height = containerHeight - top - (bottom || 0);
	        }
	
	        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);
	        rect.margin = margin;
	        return rect;
	    };
	
	
	    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {
	        var h = !opt || !opt.hv || opt.hv[0];
	        var v = !opt || !opt.hv || opt.hv[1];
	        var boundingMode = opt && opt.boundingMode || 'all';
	
	        if (!h && !v) {
	            return;
	        }
	
	        var rect;
	        if (boundingMode === 'raw') {
	            rect = (el.type === 'group' || el.type === 'GroupNode')
	                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)
	                : el.getBoundingRect();
	        }
	        else {
	            rect = el.getBoundingRect();
	            if (el.needLocalTransform()) {
	                var transform = el.getLocalTransform();
	                // Notice: raw rect may be inner object of el,
	                // which should not be modified.
	                rect = rect.clone();
	                rect.applyTransform(transform);
	            }
	        }
	
	        positionInfo = layout.getLayoutRect(
	            zrUtil.defaults(
	                {width: rect.width, height: rect.height},
	                positionInfo
	            ),
	            containerRect,
	            margin
	        );
	
	        // Because 'tranlate' is the last step in transform
	        // (see zrender/core/Transformable#getLocalTransfrom),
	        // we can just only modify el.position to get final result.
	        var elPos = el.position;
	        var dx = h ? positionInfo.x - rect.x : 0;
	        var dy = v ? positionInfo.y - rect.y : 0;
	
	        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);
	    };
	
	
	    module.exports = layout;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 水平布局<br>
	 * @class fishTopoFlow.layout.HLayout
	 * @extends fishTopoFlow.layout
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var layout = fishTopoFlow.layout;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       function newNode(group,text) {
	 *           var rect = new node.Rect({
	 *                   shape:{width:25,height:25},
	 *                   style: {text:text,fill: "#167CFF"}
	 *               });
	 *           group.add(rect);
	 *           return rect;
	 *       }
	 *       var hGroup =  new node.Group({
	 *           style: {
	 *               text: "水平布局",
	 *               textPosition:"bottom"
	 *           },
	 *           position:[50,50],
	 *           layout : new layout.HLayout({gap:10})
	 *       });
	 *       newNode(hGroup, "A_1")
	 *       newNode(hGroup, "A_2");
	 *       newNode(hGroup, "A_3");
	 *       newNode(hGroup, "A_4");
	 *       newNode(hGroup, "A_5");
	 *       fishTopo.add(hGroup);
	 */
	
	            var zrUtil = __webpack_require__(5);
	             var Connector = __webpack_require__(82);
	            function HLayout(opts) {
	                /**
	                 * @cfg {Number} gap 节点之间的间隔
	                 */
	                /**
	                 * @cfg {Number} maxHeight=Infinity 组最大的宽度，如果超过会换行
	                 */
	                var defaultOptions = {
	                    gap: 5,
	                    maxWidth: Infinity
	                };
	                this.options = zrUtil.merge(defaultOptions, opts, true);
	            }
	            /**
	             * @method run
	             * 进行垂直布局，一般不需要调用，直接将布局类 赋值给组layout 属性即可
	             * @param {Object} group 需要进行垂直布局的组
	             */
	            HLayout.prototype.run = function(group)  {
	                var x = 0;
	                var y = 0;
	                var currentLineMaxSize = 0;
	                group.each(function (child, idx) {
	                    if (child instanceof Connector) {
	                        return;
	                    }
	
	                    var position = child.position;
	                    var rect = child.getBoundingRect();
	                    var nextChild = group.childAt(idx + 1);
	                    var nextChildRect = nextChild && nextChild.getBoundingRect();
	                    var nextX;
	
	                    var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);
	                    nextX = x + moveX;
	                    // Wrap when width exceeds maxWidth or meet a `newline` group
	                    if (nextX > this.options.maxWidth || child.newline) {
	                        x = 0;
	                        nextX = moveX;
	                        y += currentLineMaxSize + parseInt(this.options.gap,10);
	                        currentLineMaxSize = rect.height;
	                    } else {
	                        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
	                    }
	
	                    if (child.newline) {
	                        return;
	                    }
	
	                    position[0] = x;
	                    position[1] = y;
	                    x = nextX + this.options.gap;
	                },this);
	
	                return HLayout;
	            }
	        module.exports = HLayout;
	
	/**
	 * @method addCustomLayout
	 * @hide
	 */

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 垂直布局<br>
	 * @class fishTopoFlow.layout.VLayout
	 * @extends fishTopoFlow.layout
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var layout = fishTopoFlow.layout;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       function newNode(group,text) {
	 *           var rect = new node.Rect({
	 *                   shape:{width:25,height:25},
	 *                   style: {text:text,fill: "#167CFF"}
	 *               });
	 *           group.add(rect);
	 *           return rect;
	 *       }
	 *       var vGroup =  new node.Group({
	 *           style: {
	 *               text: "垂直布局",
	 *               textPosition:"bottom"
	 *           },
	 *           position:[60,60],
	 *           layout : new layout.VLayout({gap:10})
	 *       });
	*
	 *       newNode(vGroup, "A_1")
	 *       newNode(vGroup, "A_2");
	 *       newNode(vGroup, "A_3");
	 *       newNode(vGroup, "A_4");
	 *       newNode(vGroup, "A_5");
	 *       fishTopo.add(vGroup);
	 */
	
	            var zrUtil = __webpack_require__(5);
	            var Connector = __webpack_require__(82);
	            function VLayout(opts) {
	                /**
	                 * @cfg {Number} gap 节点之间的间隔
	                 */
	                /**
	                 * @cfg {Number} maxHeight=Infinity 组最大的高度，如果超过会换行
	                 */
	                var defaultOptions = {
	                    gap: 5,
	                    maxHeight: Infinity
	                };
	                this.options = zrUtil.merge(defaultOptions, opts, true);
	            }
	
	            /**
	             * @method run
	             * 进行垂直布局，一般不需要调用，直接将布局类 赋值给组layout 属性即可
	             * @param {Object} group 需要进行垂直布局的组
	             */
	            VLayout.prototype.run = function(group)  {
	                var x = 0;
	                var y = 0;
	                var currentLineMaxSize = 0;
	                group.each(function (child, idx) {
	                    if (child instanceof Connector) {
	                        return;
	                    }
	
	                    var position = child.position;
	                    var rect = child.getBoundingRect();
	                    var nextChild = group.childAt(idx + 1);
	                    var nextChildRect = nextChild && nextChild.getBoundingRect();
	                    var nextY;
	
	                    var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);
	                    nextY = y + moveY;
	                    // Wrap when width exceeds maxHeight or meet a `newline` group
	                    if (nextY > this.options.maxHeight || child.newline) {
	                        x += currentLineMaxSize + parseInt(this.options.gap,10);
	                        y = 0;
	                        nextY = moveY;
	                        currentLineMaxSize = rect.width;
	                    }
	                    else {
	                        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
	                    }
	
	                    if (child.newline) {
	                        return;
	                    }
	
	                    position[0] = x;
	                    position[1] = y;
	                    y = nextY + this.options.gap;
	                },this);
	
	                return VLayout;
	            }
	        module.exports = VLayout;
	
	
	/**
	 * @method addCustomLayout
	 * @hide
	 */

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 树布局<br>
	 * @class fishTopoFlow.layout.TreeLayout
	 * @extends fishTopoFlow.layout
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var layout = fishTopoFlow.layout;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       function newNode(data) {
	 *           var circle = new node.Circle({
	 *               shape: { r: 15 },
	 *               style: { fill: "#4883b4" },
	 *               name: data.name
	 *           });
	 *           return circle;
	 *       }
	 *       var options = {
	 *           createNodeFunction: newNode,
	 *           data:[{
	 *               name: '根节点',
	 *               children: [
	 *                   {   name: '节点1',
	 *                       children: [
	 *                           {name: '叶子节点1'},
	 *                           {name: '叶子节点2'},
	 *                           {name: '叶子节点3'},
	 *                           {name: '叶子节点4'},
	 *                           {name: '叶子节点5'},
	 *                           {name: '叶子节点6'}
	 *                       ]
	 *                   },
	 *                   {   name: '节点2',
	 *                       children: [
	 *                           {name: '叶子节点7'},
	 *                           {name: '叶子节点8'}]
	 *                   },
	 *                   {   name: '节点3',
	 *                       children: [
	 *                           {name: '叶子节点9'},
	 *                           {name: '叶子节点10'},
	 *                           {name: '叶子节点11'},
	 *                           {name: '叶子节点12'}
	 *                       ]
	 *                   }
	 *               ]
	 *           }]
	 *       }
	*
	 *       var treeLayout = new layout.TreeLayout({
	 *           fishTopo:fishTopo,
	 *           rootLocation:{x:'center', y:50},
	 *           nodePadding:1
	 *       });
	 *       treeLayout.doLayout(options);
	 */
	
	            var zrUtil = __webpack_require__(5);
	            var BoundingRect = __webpack_require__(27);
	            var flowUtil = __webpack_require__(94);
	            var parsePercent = flowUtil.parsePercent;
	            var TreeData = __webpack_require__(128);  // 数据依赖
	            var TreeHelper = __webpack_require__(129); // 布局依赖
	            function TreeLayout(opts) {
	                /**
	                 * @cfg {Object} fishTopo fishTopo实例
	                 */
	                /**
	                 * @cfg {Object} rootLocation 根节点坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number
	                 * @cfg {Number|String} rootLocation.x  根节点横坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number
	                 * @cfg {Number|String} rootLocation.y  根节点纵坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number
	                 */
	                /**
	                 * @cfg {Number} layerPadding=100 层间距,默认:100
	                 */
	                /**
	                 * @cfg {Number} nodePadding=30 节点间距,默认:30
	                 */
	                /**
	                 *@cfg {String} direction 树的方向可选：'vertical' | 'horizontal' ,默认:vertical
	                 */
	                /**
	                 * @cfg {Object} lineStyle 连线的样式  参见{@link fishTopoFlow.link#constructor 构造函数options参数}
	                 */
	                var defaultOptions = {
	                    orient:'vertical',  // vertical,horizontal
	                    nodePadding:30, //节点间距
	                    layerPadding:100,  //层间距
	                    rootLocation: {x:100, y:230}, // 根节点坐标，支持绝对值（px）、字符和百分比
	                    animateTime : 500,
	                    lineStyle: {pos:'bottom,top', symbol:{type:'none'}}
	                };
	                if (opts.orient === 'horizontal') {
	                    defaultOptions.lineStyle.pos = 'right,left';
	                }
	
	                this.options = zrUtil.defaults(defaultOptions, opts, true);
	                this.nodePadding = this.options.nodePadding;
	                this.layerPadding = this.options.layerPadding;
	                this.fishTopo = this.options.fishTopo;
	                this._layerOffsets = [];
	                this._layers = [];
	                this._hideNodes = [];
	            }
	
	            /**
	             * @method layoutByRootNode
	             * 根据根节点及连线的关系 ，生成树
	             * @param {Object} rootNode 树的根节点
	             * @return {Object} boundingbox 包围和
	             */
	            TreeLayout.prototype.layoutByRootNode = function(rootNode) {
	                var connectors = this.fishTopo.connectionManager.connectors;  //所有线段的数组
	                //递归生成树型数据结构
	                function traverseNode(parentNode, treeData) {
	                    var childrenData = [];
	                    var childrenNode = [];
	                    //1.根据连线，找出起始节点的所有子节点
	                    zrUtil.each(connectors, function(connector) {
	                        if(connector.startNode === parentNode) {
	                            if(!connector.endNode.exclude) {   //如果是排斥的节点则不加入
	                                childrenNode.push(connector.endNode);
	                            }
	                        }
	                    })
	
	                    if (childrenNode.length > 0) {
	                        //2.遍历子节点
	                        zrUtil.each(childrenNode, function(node) {
	                             var nodeData = {name: node.id, node:node};
	                             childrenData.push(nodeData);
	                             traverseNode(node, nodeData);
	                        })
	                    }
	                    //3.将子节点放入children中
	                    if (childrenData.length > 0) {
	                        treeData.children = childrenData;
	                    }
	                }
	                var rootTreeData = {name: rootNode.id, node:rootNode};
	                traverseNode(rootNode,rootTreeData);
	                return this.doLayout({data:[rootTreeData]}, true);
	            }
	
	            /**
	             * @method doLayout
	             * 根据传过来树型结构数据进行树布局
	             * @param {Object} treeData 树形数据
	             * @param {Function} treeData.createNodeFunction=null 创建节点的函数 会把data中的数据 传递过去  如果没有默认就是创建圆形
	             * @param {Object} treeData.data 创建树布局数据（必须包括name属性）
	             * @param {boolean} isNotBuildLink=true 默认是自动创建连线，传true则不会自动创建连线
	             * @return {Object} boundingbox 包围和
	             */
	            TreeLayout.prototype.doLayout = function(treeData, isNotBuildLink)  {
	                var rootData = treeData.data[0];
	                this.treeData = treeData;
	
	                this.tree = TreeData.fromOptionData(rootData.name, rootData.children);
	                this.tree.root.data = rootData;
	
	
	                this._buildNode(treeData);
	
	                //根据root坐标 方向 对每个节点的坐标进行映射
	                this._setTreeShape(function() {
	                    this._buildAllLink(isNotBuildLink);
	                }.bind(this));
	
	                return this.getBoundingRect();
	            }
	
	            /**
	             * @private
	             * @method _buildAllLink
	             * 递归画出连接线 与设置节点坐标
	             */
	             TreeLayout.prototype._buildAllLink = function (isNotBuildLink) {
	                this.tree.traverse(function(treeNode) {
	                    //画连接线
	                    if (treeNode.children.length > 0 && !isNotBuildLink) {
	                        this._buildLinkByParent(treeNode, this.treeData.createLinkFunction)
	                    } else {
	                        this.fishTopo.connectionManager.refreshLineByNode(treeNode.data.node);
	                    }
	                },this)
	             }
	
	
	            /**
	             * @method getBoundingRect
	             * 计算出树的包围和
	             * @return {Object} boundingbox 包围和
	             */
	            TreeLayout.prototype.getBoundingRect = function() {
	                var rect = null;
	                this.tree.traverse(function(treeNode) {
	                    var childRect = BoundingRect.create({x:treeNode.layout.position[0], y:treeNode.layout.position[1], width:treeNode.layout.width, height: treeNode.layout.height});
	                    if (!rect) rect = childRect.clone();
	                    rect.union(childRect);
	                },this)
	                return rect;
	            }
	
	
	
	            TreeLayout.prototype._setTreeShape = function(doneCallback) {
	                var animateCount = 0;
	                var treeHelper = new TreeHelper(
	                    {
	                        nodePadding: this.nodePadding,
	                        layerPadding: this.layerPadding
	                    }
	                );
	
	
	                this.tree.traverse(function(treeNode) {
	                    if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){
	                        var boundingRect = treeNode.data.node.getBoundingRect();
	                        treeNode.layout = {
	                            width: treeNode.data.node._width || boundingRect.width,
	                            height: treeNode.data.node._height || boundingRect.height
	                        }
	                    }
	
	                },this);
	                treeHelper._hideNodes = this._hideNodes;
	                treeHelper.run(this.tree);
	                // 树的方向
	                var orient = this.options.orient;
	                var rootX = this.options.rootLocation.x;
	                var rootY = this.options.rootLocation.y;
	                var zrWidth = this.fishTopo.getWidth();
	                var zrHeight = this.fishTopo.getHeight();
	                if (rootX === 'center') {
	                    rootX = zrWidth * 0.5;
	                }
	                else {
	                    rootX = parsePercent(rootX, zrWidth);
	                }
	                if (rootY === 'center') {
	                    rootY = zrHeight * 0.5;
	                }
	                else {
	                    rootY = parsePercent(rootY, zrHeight);
	                }
	                rootY = parsePercent(rootY, zrHeight);
	                // 水平树
	                if (orient === 'horizontal') {
	                    rootX = isNaN(rootX) ? 10 : rootX;
	                    rootY = isNaN(rootY) ? zrHeight * 0.5 : rootY;
	                }
	                // 纵向树
	                else {
	                    rootX = isNaN(rootX) ? zrWidth * 0.5 : rootX;
	                    rootY = isNaN(rootY) ? 10 : rootY;
	                }
	                // tree layout自动算出来的root的坐标
	                var originRootX = this.tree.root.layout.position[0];
	
	                var treeNodeCount = treeHelper.count(this.tree) - this._hideNodes.length;
	                var minY = Infinity;
	
	                this.tree.traverse(
	                    function (treeNode) {
	                        var x;
	                        var y;
	                        if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){
	                            if (orient === 'vertical' && this.options.direction === 'inverse') {
	                                x = treeNode.layout.position[0] - originRootX + rootX;
	                                y = rootY - treeNode.layout.position[1];
	                            }
	                            else if (orient === 'vertical') {
	                                x = treeNode.layout.position[0] - originRootX + rootX;
	                                y = treeNode.layout.position[1] + rootY;
	                            }
	                            else if (orient === 'horizontal' && this.options.direction === 'inverse') {
	                                y = treeNode.layout.position[0] - originRootX + rootY;
	                                x = rootX - treeNode.layout.position[1];
	                            }
	                            else if (orient === 'horizontal') {
	                                y = treeNode.layout.position[0] - originRootX + rootY;
	                                x = treeNode.layout.position[1] + rootX;
	                            }
	                            treeNode.layout.__x = x;
	                            treeNode.layout.__y = y;
	                            if (y < minY) {
	                                minY = y;
	                            }
	                        }
	                    },
	                    this
	                );
	
	                this.tree.traverse(function (treeNode) {
	                    if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){
	                        if (minY > 0) {
	                            treeNode.layout.position[0] = treeNode.layout.__x;
	                            treeNode.layout.position[1] = treeNode.layout.__y;
	                        } else  {
	                            treeNode.layout.position[0] = treeNode.layout.__x;
	                            treeNode.layout.position[1] = treeNode.layout.__y - minY;
	                        }
	
	                        treeNode.data.node.animateTo({
	                            position: [treeNode.layout.position[0], treeNode.layout.position[1]]
	                        }, this.options.animateTime, function() {
	                            if (++animateCount === treeNodeCount) {
	                                doneCallback();
	                            }
	                        }.bind(this));
	                        //节点有孩子才显示 收缩按钮
	                        if(this._hideNodes.length == 0){
	                            if (treeNode.children.length > 0 && treeNode.data.node._toggleShrink) {
	                                treeNode.data.node._toggleShrink(true);
	                            }
	                        }
	                    }
	
	                },this)
	            }
	
	            TreeLayout.prototype._buildNode = function(treeData) {
	                if(!treeData.createNodeFunction) {
	                    treeData.createNodeFunction = this._defaultCreateNodeFunction;
	                }
	                //判断一下是否有node 如果没有则自己创建
	                this.tree.traverse(function(treeNode) {
	                    if(!treeNode.data.node) {
	                        var createNodeFunction = treeNode.data.createNodeFunction || treeData.createNodeFunction;
	                        var node = createNodeFunction(treeNode.data, this);
	                        node._childShow = true;
	                        this.fishTopo.add(node);
	                        treeNode.data.node = node;
	                    }
	                },this);
	            }
	
	            TreeLayout.prototype._defaultCreateNodeFunction = function(item) {
	                var circle = this.fishTopo.createNode("Circle",{
	                    shape: { r: 15 },
	                    style: { fill: "#4883b4" },
	                    name: item.lable || item.name
	                });
	                return circle;
	            }
	
	            TreeLayout.prototype._buildLinkByParent = function (parentTreeNode, createLinkFunction) {
	                for (var i = 0, childLength = parentTreeNode.children.length; i < childLength; i++) {
	                    this._buildLink(parentTreeNode, parentTreeNode.children[i], createLinkFunction);
	                }
	            };
	
	
	            TreeLayout.prototype._buildLink = function (startTreeNode, endTreeNode, createLinkFunction) {
	                    var connector = null;
	                    var startNode = startTreeNode.data.node;
	                    var endNode = endTreeNode.data.node;
	                    if(createLinkFunction) {
	                        var paramObj =  endTreeNode.data;
	                        paramObj.startNode = startNode;
	                        paramObj.endNode = endNode;
	                        connector = createLinkFunction(paramObj);
	                    } else {
	                        var linkStyle = this.options.lineStyle;
	                        if (endTreeNode.data.lineStyle) {
	                            linkStyle = zrUtil.merge(zrUtil.clone(linkStyle), endTreeNode.data.lineStyle, true);
	                        }
	                        connector = this.fishTopo.createLink(startNode,endNode,linkStyle)
	                    }
	                    this.fishTopo.add(connector);
	            };
	
	            /**
	             * @method addChild
	             * 在指定topo节点下新增一个子节点
	             * @param {Object} treeNode 要增加子节点的topo节点
	             * @param {Object} data 新增子节点的数据
	             * @param {Function} callback 增加完子节点之后触发的回调函数
	             * @return {Object} 新增加的子节点
	             */
	            TreeLayout.prototype.addChild = function (treeNode, data, callback) {
	                var newTreeNode = (new TreeData(data.name)).root;
	                newTreeNode.data = data;
	
	                var node = this.treeData.createNodeFunction(newTreeNode.data, this);
	                node._childShow = true;
	                if (treeNode.children.length >= 1) {
	                    node.attr('position', zrUtil.clone(treeNode.children[treeNode.children.length - 1].layout.position));
	                } else {
	                    node.attr('position', zrUtil.clone(treeNode.layout.position));
	                }
	
	                this.fishTopo.add(node);
	                newTreeNode.data.node = node;
	                setTimeout(function () {
	                    this._buildLink(treeNode, newTreeNode, this.treeData.createLinkFunction);
	                }.bind(this), this.options.animateTime);
	
	                treeNode.add(newTreeNode);
	                this.refreshPositionAndLine(callback);
	                return node;
	            };
	
	            /**
	             * @method toggleChild
	             * 展示或者隐藏选中topo节点下的子节点以及与子节点之间的连线
	             * @param {Object} node 树节点
	             */
	            TreeLayout.prototype.toggleChild = function (node) {
	                var toggleTreeNode = this.findTreeNodeByNode(node);
	                if (node._childShow) {
	                    toggleTreeNode.traverse(function (treeNode) {
	                        if (treeNode.data.node !== node) {
	                            treeNode.data.node.hide();
	                            if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){
	                                this._hideNodes.push(treeNode);
	                            }
	                            this.fishTopo.connectionManager.toggleLineByNode(treeNode.data.node, false);
	                            if (treeNode.children.length > 0) {
	                                treeNode.data.node._childShow = false;
	                                treeNode.data.node._toggleShrink && treeNode.data.node._toggleShrink(false);
	                            }
	                        }
	                    },this);
	                    node._childShow = false;
	                    node._toggleShrink && node._toggleShrink(false);
	                    this.refreshPositionAndLine();
	                } else {
	                    toggleTreeNode.traverse(function (treeNode) {
	                        if (treeNode.data.node !== node) {
	                            treeNode.data.node.show();
	                            this._hideNodes.splice(zrUtil.indexOf(this._hideNodes, treeNode),1);
	                            this.fishTopo.connectionManager.toggleLineByNode(treeNode.data.node, true);
	                            if (treeNode.children.length > 0) {
	                                treeNode.data.node._childShow = true;
	                                treeNode.data.node._toggleShrink && treeNode.data.node._toggleShrink(true);
	                            }
	                        }
	                    },this);
	                    node._childShow = true;
	                    node._toggleShrink && node._toggleShrink(true);
	                    this.refreshPositionAndLine();
	                }
	            };
	
	            /**
	             * @method findTreeNodeByNode
	             * 根据topo节点找到树的节点
	             * @param {Object} node topo节点
	             * @return {Object} 
	             */
	            TreeLayout.prototype.findTreeNodeByNode = function (node) {
	                var returnTreeNode = null;
	                this.tree.traverse(function (treeNode) {
	                    if (treeNode.data.node === node) {
	                        returnTreeNode = treeNode;
	                    }
	                });
	                return returnTreeNode;
	            };
	
	            /**
	             * @method removeNode
	             * 删除选中topo节点
	             * @param {Object} node topo节点
	             * @return {Boolean} 删除是否成功
	             */
	            TreeLayout.prototype.removeNode = function (node) {
	                var treeNode = this.findTreeNodeByNode(node);
	                var parentTreeNode = treeNode.parent;
	                if (!parentTreeNode) return false;
	                //遍历 topo中删除自己及孩子节点
	                treeNode.traverse(function (eachTreeNode) {
	                    this.fishTopo.remove(eachTreeNode.data.node); //删除节点
	                },this)
	
	                parentTreeNode.remove(treeNode);
	
	                //判断一下父节点是不是没有了,如果没有的话,要把线与+-号给隐藏掉
	                if (parentTreeNode.children.length === 0) {
	                    parentTreeNode.data.node._hideToggle && parentTreeNode.data.node._hideToggle();
	                }
	
	                //重新生成数据
	                this.refreshPositionAndLine();
	                return true;
	            };
	
	            /**
	             * @method removeChildren
	             * 删除选中topo节点下的所有子节点
	             * @param {Object} node topo节点
	             * @return {Boolean} 删除是否成功
	             */
	            TreeLayout.prototype.removeChildren = function (node) {
	                var treeNode = this.findTreeNodeByNode(node);
	                //遍历 topo中删除孩子节点
	                treeNode.traverse(function (eachTreeNode) {
	                    if (eachTreeNode !== treeNode) {
	                        this.fishTopo.remove(eachTreeNode.data.node); //删除节点
	                    }
	                },this)
	
	                treeNode.removeAllChildren();
	                node._hideToggle && node._hideToggle(); //this._hidePath(node);
	
	                //重新生成数据
	                this.refreshPositionAndLine();
	                return true;
	            };
	
	            /**
	             * @method refreshPositionAndLine
	             * 刷新当前树布局中所有节点的位置和节点之间的连线
	             * @param {Function} callback 刷新之后所触发的回调函数
	             */
	            TreeLayout.prototype.refreshPositionAndLine = function (callback) {
	                this.tree.root.updateDepthAndHeight(0);
	                this._setTreeShape(function () {
	                    this.tree.traverse(function (eachTreeNode) {
	                        this.fishTopo.connectionManager.refreshLineByNode(eachTreeNode.data.node);
	                    }, this);
	                    callback && callback();
	                }.bind(this));
	            }
	
	            /**
	             * @method changePosition
	             * 更改当前topo节点在其兄弟节点中的位置
	             * @param {Object} node 树节点
	             * @param {String} direction 节点移动的方向，next表示往下移动，prev表示往上移动
	             */
	            TreeLayout.prototype.changePosition = function (node, direction) {
	                var parentNode = node.parent;
	                var nowIndex = zrUtil.indexOf(parentNode.children, node);
	                var targetIndex;
	                if(direction == "next"){
	                    targetIndex = nowIndex + 1;
	                }else if(direction == "prev"){
	                    targetIndex = nowIndex - 1;
	                }
	                var targetNode = parentNode.children[targetIndex];
	                if(targetNode){
	                    var storage = targetNode;
	                    parentNode.children[targetIndex] = node;
	                    parentNode.children[nowIndex] = storage;
	                }
	                this.refreshPositionAndLine();
	                this.fishTopo.trigger('treeLayout:changePosition',{
	                    node:node,
	                    parentNode:parentNode,
	                    targetNode:targetNode
	                })
	            }
	
	        module.exports = TreeLayout;
	
	
	/**
	 * @method addCustomLayout
	 * @hide
	 */

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var zrUtil = __webpack_require__(5);
	
	    /**
	     * @constructor TreeNode
	     * @param {string} id Node ID
	     * @param {Object} [data]
	     */
	    function TreeNode(id, data) {
	        /**
	         * @type {string}
	         */
	        this.id = id;
	        /**
	         * 节点的深度
	         * @type {number}
	         */
	        this.depth = 0;
	        /**
	         * 以当前节点为根节点的子树的高度
	         * @type {number}
	         */
	        this.height = 0;
	        /**
	         * 子节点列表
	         * @type {Array.<TreeNode>}
	         */
	        this.children = [];
	
	        /**
	         * @type {TreeNode}
	         */
	        this.parent = null;
	
	        /**
	         * 存储的用户数据
	         * @type {Object}
	         */
	        this.data = data || null;
	    }
	
	    /**
	     * 添加子节点
	     * @param {TreeNode} child
	     */
	    TreeNode.prototype.add = function (child) {
	        var children = this.children;
	        if (child.parent === this) {
	            return;
	        }
	
	        children.push(child);
	        child.parent = this;
	    };
	
	    /**
	     * 移除子节点
	     * @param {TreeNode} child
	     */
	    TreeNode.prototype.remove = function (child) {
	        var children = this.children;
	        var idx = zrUtil.indexOf(children, child);
	        if (idx >= 0) {
	            children.splice(idx, 1);
	            child.parent = null;
	        }
	    };
	
	     TreeNode.prototype.removeAllChildren = function () {
	         var children = this.children;
	         for (var i = 0; i < children.length; i++) {
	             var child = children[i];
	            child.parent = null;
	         }
	        this.children = [];
	     }
	
	    /**
	     * 遍历当前节点及其所有子节点
	     * @param  {Function} cb
	     * @param  {Object}   [context]
	     */
	    TreeNode.prototype.traverse = function (cb, context) {
	        cb.call(context, this);
	
	        for (var i = 0; i < this.children.length; i++) {
	            this.children[i].traverse(cb, context);
	        }
	    };
	
	    /**
	     * 遍历节前节点及所有子节点的数量
	     */
	    TreeNode.prototype.count = function () {
	        var count = 0;
	        this.traverse(function() {
	            count++;
	         });
	        return count;
	    }
	
	    /**
	     * 更新当前树及所有子树的高度和深度
	     * @param  {number} depth
	     */
	    TreeNode.prototype.updateDepthAndHeight = function (depth) {
	        var height = 0;
	        this.depth = depth;
	        for (var i = 0; i < this.children.length; i++) {
	            var child = this.children[i];
	            child.updateDepthAndHeight(depth + 1);
	            if (child.height > height) {
	                height = child.height;
	            }
	        }
	        this.height = height + 1;
	    };
	
	    /**
	     * @param  {string} id
	     * @return TreeNode
	     */
	    TreeNode.prototype.getNodeById = function (id) {
	        if (this.id === id) {
	            return this;
	        }
	        for (var i = 0; i < this.children.length; i++) {
	            var res = this.children[i].getNodeById(id);
	            if (res) {
	                return res;
	            }
	        }
	    };
	
	    /**
	     * @constructor
	     * @alias module:echarts/data/Tree
	     * @param {string} id
	     */
	    function Tree(id) {
	        /**
	         * @type {TreeNode}
	         */
	        this.root = new TreeNode(id);
	    }
	
	    /**
	     * 遍历树的所有子节点(深度优先遍历)
	     * @param  {Function} cb
	     * @param  {Object}   [context]
	     */
	    Tree.prototype.traverse = function(cb, context) {
	        this.root.traverse(cb, context);
	    };
	
	    /**
	     * 生成子树
	     * @param  {string} id 子树根节点 id
	     * @return {module:echarts/data/Tree}
	     */
	    Tree.prototype.getSubTree = function(id) {
	        var root = this.getNodeById(id);
	        if (root) {
	            var tree = new Tree(root.id);
	            tree.root = root;
	            return tree;
	        }
	    };
	
	    /**
	     * @param  {string} id
	     * @return TreeNode
	     */
	    Tree.prototype.getNodeById = function (id) {
	        return this.root.getNodeById(id);
	    };
	
	
	    /**
	     * 从 option 里的 data 数据构建树
	     * @param {string} id
	     * @param {Array.<Object>} data
	     * @return Tree
	     */
	    Tree.fromOptionData = function (id, data) {
	        var tree = new Tree(id);
	        var rootNode = tree.root;
	        // Root node
	        rootNode.data = {
	            name: id,
	            children: data
	        };
	
	        function buildHierarchy(dataNode, parentNode) {
	            var node = new TreeNode(dataNode.name, dataNode);
	            parentNode.add(node);
	            // 遍历添加子节点
	            var children = dataNode.children;
	            if (children) {
	                for (var i = 0; i < children.length; i++) {
	                    buildHierarchy(children[i], node);
	                }
	            }
	        }
	
	        for (var i = 0; i < data.length; i++) {
	            buildHierarchy(data[i], rootNode);
	        }
	
	        tree.root.updateDepthAndHeight(0);
	
	        return tree;
	    };
	
	
	    Tree.fromDataSource = function (dataSource, rootItem) {
	
	        function _findChildItem(nodeName) {
	            return zrUtil.filter(dataSource.link,function(item){
	                if(item.from === nodeName && !item.pos) {  // 数据中有pos属性的不是子节点
	                    return item;
	                }
	            });
	        }
	
	
	        function buildHierarchy(root) {
	            var childItem = _findChildItem(root.id);
	            for (var i = 0; i < childItem.length; i++) {
	                var item = childItem[i];
	                var childTreeNode = treeNodesMap[item.to];
	                root.children.push(childTreeNode);
	                buildHierarchy(childTreeNode);
	            }
	        }
	
	        var treeNodesMap = {};
	        for (var i = 0; i < dataSource.node.length; i++) {
	            var node = dataSource.node[i];
	            var treeNode = new TreeNode(node.name,node);
	            treeNodesMap[node.name] = treeNode;
	        }
	
	        var tree = new Tree(rootItem.name);
	        var rootNode = tree.root;
	        // Root node
	        rootNode.data = rootItem;
	
	
	        buildHierarchy(tree.root);
	        tree.root.updateDepthAndHeight(0);
	
	        return tree;
	    };
	
	    module.exports = Tree;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var vec2 = __webpack_require__(15);
	    var zrUtil = __webpack_require__(5);
	
	    function TreeHelper(opts) {
	        opts = opts || {};
	
	        this.nodePadding = opts.nodePadding || 30;
	
	        this.layerPadding = opts.layerPadding || 100;
	
	        this._layerOffsets = [];
	
	        this._layers = [];
	
	        this._hideNodes = [];
	    }
	
	    TreeHelper.prototype.count = function (tree) {
	        var count = 0;
	        tree.traverse(function() {
	            count++;
	         });
	        return count;
	    }
	
	    TreeHelper.prototype.run = function (tree) {
	        this._layerOffsets.length = 0;
	        for (var i = 0; i < tree.root.height + 1; i++) {
	            this._layerOffsets[i] = 0;
	            this._layers[i] = [];
	        }
	        this._updateNodeXPosition(tree.root);
	        var root = tree.root;
	        this._updateNodeYPosition(root, 0, root.layout.height);
	    };
	
	    TreeHelper.prototype._updateNodeXPosition = function (node) {
	        var minX = Infinity;
	        var maxX = -Infinity;
	        node.layout.position = node.layout.position || vec2.create();
	        for (var i = 0; i < node.children.length; i++) {
	            var child = node.children[i];
	            if(zrUtil.indexOf(this._hideNodes, child) == -1){
	                this._updateNodeXPosition(child);
	                var x = child.layout.position[0];
	                if (x < minX) {
	                    minX = x;
	                }
	                if (x > maxX) {
	                    maxX = x;
	                }
	            }
	        }
	        if (node.children.length > 0 && (zrUtil.indexOf(this._hideNodes, node.children[0]) == -1)) {
	            node.layout.position[0] = (minX + maxX) / 2;
	        } else {
	            node.layout.position[0] = 0;
	            node.height = 0;   // 隐藏节点的 深度设为0
	        }
	        var off = this._layerOffsets[node.depth] || 0;
	        if (off > node.layout.position[0]) {
	            var shift = off - node.layout.position[0];
	            this._shiftSubtree(node, shift);
	            for (var j = node.depth + 1; j < node.height + node.depth; j++) {
	                this._layerOffsets[j] += shift;
	            }
	        }
	        this._layerOffsets[node.depth] = node.layout.position[0] + node.layout.width + this.nodePadding;
	
	        if(zrUtil.indexOf(this._layers[node.depth], node) == -1){
	            this._layers[node.depth].push(node);
	        }
	    };
	
	    TreeHelper.prototype._shiftSubtree = function (root, offset) {
	        root.layout.position[0] += offset;
	        for (var i = 0; i < root.children.length; i++) {
	            if(zrUtil.indexOf(this._hideNodes,root.children[i]) == -1){
	                this._shiftSubtree(root.children[i], offset);
	            }
	        }
	    };
	
	    TreeHelper.prototype._updateNodeYPosition = function (node, y, prevLayerHeight) {
	        if(zrUtil.indexOf(this._hideNodes,node) == -1){
	            node.layout.position[1] = y;
	            var layerHeight = 0;
	            for (var i = 0; i < node.children.length; i++) {
	                layerHeight = Math.max(node.children[i].layout.height, layerHeight);
	            }
	            var layerPadding = this.layerPadding;
	            if (typeof (layerPadding) === 'function') {
	                layerPadding = layerPadding(node.depth);
	            }
	            for (var j = 0; j < node.children.length; j++) {
	                this._updateNodeYPosition(node.children[j], y + layerPadding + prevLayerHeight, layerHeight);
	            }
	        }
	
	    };
	    module.exports = TreeHelper;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 力导向布局<br>
	 * @class fishTopoFlow.layout.ForceLayout
	 * @extends fishTopoFlow.layout
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var layout = fishTopoFlow.layout;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       function newNode(data) {
	 *           var circle = new node.Circle({
	 *               shape: { r: 15 },
	 *               style: { fill: "#4883b4" },
	 *               name: data.name
	 *           });
	 *           return circle;
	 *       }
	 *       var options = {
	 *           createNodeFunction: newNode,
	 *           data:[{nodes:[
	 *                           {name: '节点1'},
	 *                           {name: '节点2'},
	 *                           {name: '节点3'},
	 *                           {name: '节点4'},
	 *                           {name: '节点5'},
	 *                           {name: '节点6'},
	 *                           {name: '节点7'},
	 *                           {name: '节点8'}
	 *                       ],
	 *                   links:[
	 *                           {source:'节点1', target:'节点2'},
	 *                           {source:'节点2', target:'节点3'},
	 *                           {source:'节点3', target:'节点4'},
	 *                           {source:'节点4', target:'节点5'},
	 *                           {source:'节点5', target:'节点6'},
	 *                           {source:'节点6', target:'节点7'},
	 *                           {source:'节点7', target:'节点8'}
	 *                       ]
	 *           }]
	 *       }
	 *       var forceLayout = new layout.ForceLayout({
	 *          fishTopo:fishTopo,
	 *           repulsion: 200
	 *       });
	 *       forceLayout.doLayout(options);
	 */
	
	
	
	    var forceHelper = __webpack_require__(131);
	    var vec2 = __webpack_require__(15);
	    var zrUtil = __webpack_require__(5);
	    function ForceLayout(opts) {
	         /**
	         * @cfg {Object} fishTopo fishTopo实例
	         */
	         /**
	         * @cfg {Number} [repulsion=100] 节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100
	         */
	         /**
	         * @cfg {Number} [gravity=0.1] 节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1
	         */
	        /**
	         * @cfg {Number} [edgeLength=30] 边的两个节点之间的距离，这个距离也会受 repulsion影响。 默认为30
	         */
	        /**
	         * @cfg {Boolean} [once=true] 是否只进行布局一次。<br/>
	         * 如果设置为false，在布局结束以后，再拖拽节点，节点的定位会设置为fixed，释放被拖拽的节点，节点会回到原来的位置, 导致重新布局，同样会再次触发forceLayoutEnd事件。
	         */
	        /**
	         * @cfg {Object} [rect] 布局显示范围
	         *
	         * @cfg {Object} [rect.x] 布局显示范围x坐标
	         * @cfg {Object} [rect.y] 布局显示范围y坐标
	         * @cfg {Object} [rect.width] 布局显示宽度
	         * @cfg {Object} [rect.height] 布局显示高度
	         */
	        /**
	         * @cfg {Boolean} [layoutAnimation=true] 是否显示布局动画
	         */
	        /**
	         * @cfg {Object} [lineStyle] 连线的样式  参见{@link fishTopoFlow.link#constructor 构造函数options参数}
	         */
	        this.fishTopo = opts.fishTopo;
	        var defaultOptions = {
	            repulsion: 100,  //节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100
	            gravity: 0.1, //节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1
	            edgeLength: 30, // 边的两个节点之间的距离，这个距离也会受 repulsion。 默认为30
	            once:true,
	            layoutAnimation:true,
	            rect: {x:0, y:0, width:this.fishTopo.getWidth() ,height:this.fishTopo.getHeight()},
	            lineStyle: {symbol:{type:'none'}},
	            preservedPoints: {}
	        };
	
	        this.options = zrUtil.defaults(defaultOptions, opts, true);
	    }
	
	    /**
	     * @method doLayout
	     * 根据forceData进行力导向布局
	     * @param {Object} forceData 力导向数据
	     * @param {Function} forceData.createNodeFunction=null 创建节点的函数 会把data中nodes的数据 传递过去  如果没有默认就是创建圆形
	     * @param {Function} forceData.createLinkFunction=null 创建线段函数，参数是data.links数据，如果没有默认创建直线 since V2.3.0
	     * @param {Object} forceData.data 创建力导向布局数据
	     * @param {Object} forceData.data.nodes 创建力导向布局节点的对象数据（必须包括name属性）
	     * @param {Object} forceData.data.links 创建力导向布局连线的对象数据（必须包括name属性）
	     *
	     */
	    ForceLayout.prototype.doLayout = function(forceData) {
	         var rootData = forceData.data[0];
	         this.allNodes = this._buildNode(rootData.nodes, forceData.createNodeFunction);
	         this.allLinks = this._buildLinks(rootData.links, forceData.createLinkFunction);
	         this._forceIns();
	
	         this._startForceLayoutIteration();
	    }
	    /**
	     * @method autoLayout
	     * 根据已有节点进行力导向布局
	     * @since V2.3.0
	     */
	    ForceLayout.prototype.autoLayout = function() {
	        this.allNodes = this.fishTopo.allNodes;
	        this.allLinks = this.fishTopo.connectionManager.connectors;
	        this._forceIns();
	        this._startForceLayoutIteration();
	    }
	
	    ForceLayout.prototype._buildNode = function(datas, createNodeFunction) {
	        if(!fish.isFunction(createNodeFunction)) {
	            createNodeFunction = this._defaultCreateNodeFunction.bind(this);
	        }
	        var allNodes = [];
	        //判断一下是否有node 如果没有则自己创建
	        zrUtil.each(datas,  function(item,idx) {
	            if(!item.node) {
	                var createNode = item.createNodeFunction || createNodeFunction;
	                var node = createNode(item);
	                this.fishTopo.add(node);
	                this._addNodeEvent(node,idx);
	                allNodes.push(node);
	            }
	        },this);
	        return allNodes;
	    }
	
	    ForceLayout.prototype._addNodeEvent = function(node,idx) {
	        if(!this.options.once) {
	            node.on('drag', function() {
	                if(this.options.forceLayout) {
	                    this.options.forceLayout.warmUp();
	                    !this._layouting && this._startForceLayoutIteration();
	                    this.options.forceLayout.setFixed(idx);
	                }
	            },this).on('dragend', function() {
	                if(this.options.forceLayout) {
	                    this.options.forceLayout.setUnfixed(idx);
	                }
	            },this)
	        }
	    }
	
	    ForceLayout.prototype._defaultCreateNodeFunction = function(item) {
	        var circle = this.fishTopo.createNode("Circle",{
	            shape: { r: 15 },
	            style: { fill: "#4883b4" },
	            name: item.lable || item.name
	        });
	        return circle;
	    }
	
	    ForceLayout.prototype._buildLinks = function(links,createLinkFunction) {
	        var allLinks = [];
	
	        zrUtil.each(links, function(link) {
	            var startNode = this.fishTopo.childOfName(link.source);
	            var endNode = this.fishTopo.childOfName(link.target);
	            if(startNode && endNode) {
	                 var connector = null;
	                if(createLinkFunction) {
	                    var paramObj = link;
	                    paramObj.startNode = startNode;
	                    paramObj.endNode = endNode;
	                    connector = createLinkFunction(paramObj);
	                } else {
	                    var linkStyle = this.options.lineStyle;
	                    if (link.style) {
	                        linkStyle = zrUtil.merge(zrUtil.clone(linkStyle), link.style, true);
	                    }
	                    connector = this.fishTopo.createLink(startNode,endNode,linkStyle);
	                }
	                this.fishTopo.add(connector);
	                allLinks.push(connector);
	            }
	        },this);
	        return allLinks;
	    }
	
	
	    ForceLayout.prototype._forceIns = function() {
	        var rect = this.options.rect;
	        var self = this;
	        var preservedPoints = this.options.preservedPoints;
	        var nodes = zrUtil.map(this.allNodes, function(node) {
	            var rep = this.options.repulsion; node.w = rep; node.rep = rep; node.p = null;
	            return {
	                w: rep,
	                rep: rep,
	                p: null
	            };
	        },this);
	        if (preservedPoints) {
	            zrUtil.each(this.allNodes, function(node,idx) {
	                node.attr("position", preservedPoints[idx]);
	            })
	        }
	        zrUtil.each(this.allLinks, function(link) {
	            link.n1 = link.startNode,
	            link.n2 = link.endNode,
	            link.d = this.options.edgeLength;
	            link.curveness = 0;
	        },this)
	
	        var forceInstance = forceHelper(this.allNodes, this.allLinks, {
	            rect: rect,
	            gravity: this.options.gravity
	        });
	        var oldStep = forceInstance.step;
	        forceInstance.step = function(cb) {
	            zrUtil.each(this.allNodes, function(node) {
	                if (nodes.fixed) {
	                    vec2.copy(nodes.p, nodes.position);
	                }
	            })
	
	            oldStep(function(allNodes, allLinks, stopped) {
	                for (var i = 0, l = allNodes.length; i < l; i++) {
	                    if (!allNodes[i].fixed) {
	                        allNodes[i].attr("position", allNodes[i].p);
	                    }
	                    preservedPoints[i] = allNodes[i].p;
	                }
	
	                zrUtil.each(allLinks, function(connector) {
	                    self.fishTopo.connectionManager.refreshConnector(connector, true);
	                })
	
	                cb && cb(stopped);
	            });
	        };
	        this.options.forceLayout = forceInstance;
	        this.options.preservedPoints = preservedPoints;
	        // Step to get the layout
	        forceInstance.step();
	    }
	
	
	    ForceLayout.prototype._startForceLayoutIteration = function () {
	        var self = this;
	        var layoutAnimation = this.options.layoutAnimation;
	        (function step() {
	            self.options.forceLayout.step(function (stopped) {
	                self._layouting = !stopped;
	                if (self._layouting) {
	                    if (layoutAnimation) {
	                        self._layoutTimeout = setTimeout(step, 16)
	                    } else {
	                        step();
	                    }
	                } else {
	                     self.fishTopo.trigger("forceLayoutEnd");  //派发布局结束事件
	                }
	            })
	        })();
	    };
	    module.exports = ForceLayout;
	
	/**
	 * @method addCustomLayout
	 * @hide
	 */
	
	/**
	 * @event forceLayoutEnd
	 * 布局结束事件
	 *
	 * <pre>
	 * fishtopo.on('forceLayoutEnd', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var vec2 = __webpack_require__(15);
	    var scaleAndAdd = vec2.scaleAndAdd;
	
	    // function adjacentNode(n, e) {
	    //     return e.n1 === n ? e.n2 : e.n1;
	    // }
	
	    module.exports = function (nodes, edges, opts) {
	        var rect = opts.rect;
	        var width = rect.width;
	        var height = rect.height;
	        var center = [rect.x + width / 2, rect.y + height / 2];
	        // var scale = opts.scale || 1;
	        var gravity = opts.gravity == null ? 0.1 : opts.gravity;
	
	        // for (var i = 0; i < edges.length; i++) {
	        //     var e = edges[i];
	        //     var n1 = e.n1;
	        //     var n2 = e.n2;
	        //     n1.edges = n1.edges || [];
	        //     n2.edges = n2.edges || [];
	        //     n1.edges.push(e);
	        //     n2.edges.push(e);
	        // }
	        // Init position
	        for (var i = 0; i < nodes.length; i++) {
	            var n = nodes[i];
	            if (!n.p) {
	                // Use the position from first adjecent node with defined position
	                // Or use a random position
	                // From d3
	                // if (n.edges) {
	                //     var j = -1;
	                //     while (++j < n.edges.length) {
	                //         var e = n.edges[j];
	                //         var other = adjacentNode(n, e);
	                //         if (other.p) {
	                //             n.p = vec2.clone(other.p);
	                //             break;
	                //         }
	                //     }
	                // }
	                // if (!n.p) {
	                    n.p = vec2.create(
	                        width * (Math.random() - 0.5) + center[0],
	                        height * (Math.random() - 0.5) + center[1]
	                    );
	                // }
	            }
	            n.pp = vec2.clone(n.p);
	            n.edges = null;
	        }
	
	        // Formula in 'Graph Drawing by Force-directed Placement'
	        // var k = scale * Math.sqrt(width * height / nodes.length);
	        // var k2 = k * k;
	
	        var friction = 0.6;
	
	        return {
	            warmUp: function () {
	                friction = 0.5;
	            },
	
	            setFixed: function (idx) {
	                nodes[idx].fixed = true;
	            },
	
	            setUnfixed: function (idx) {
	                nodes[idx].fixed = false;
	            },
	
	            step: function (cb) {
	                var v12 = [];
	                var nLen = nodes.length;
	                for (var i = 0; i < edges.length; i++) {
	                    var e = edges[i];
	                    var n1 = e.n1;
	                    var n2 = e.n2;
	
	                    vec2.sub(v12, n2.p, n1.p);
	                    var d = vec2.len(v12) - e.d;
	                    var w = n2.w / (n1.w + n2.w);
	                    vec2.normalize(v12, v12);
	
	                    !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);
	                    !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);
	                }
	                // Gravity
	                for (var i = 0; i < nLen; i++) {
	                    var n = nodes[i];
	                    if (!n.fixed) {
	                        vec2.sub(v12, center, n.p);
	                        // var d = vec2.len(v12);
	                        // vec2.scale(v12, v12, 1 / d);
	                        // var gravityFactor = gravity;
	                        vec2.scaleAndAdd(n.p, n.p, v12, gravity * friction);
	                    }
	                }
	
	                // Repulsive
	                // PENDING
	                for (var i = 0; i < nLen; i++) {
	                    var n1 = nodes[i];
	                    for (var j = i + 1; j < nLen; j++) {
	                        var n2 = nodes[j];
	                        vec2.sub(v12, n2.p, n1.p);
	                        var d = vec2.len(v12);
	                        if (d === 0) {
	                            // Random repulse
	                            vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);
	                            d = 1;
	                        }
	                        var repFact = (n1.rep + n2.rep) / d / d;
	                        !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);
	                        !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);
	                    }
	                }
	                var v = [];
	                for (var i = 0; i < nLen; i++) {
	                    var n = nodes[i];
	                    if (!n.fixed) {
	                        vec2.sub(v, n.p, n.pp);
	                        vec2.scaleAndAdd(n.p, n.p, v, friction);
	                        vec2.copy(n.pp, n.p);
	                    }
	                }
	
	                friction = friction * 0.992;
	
	                cb && cb(nodes, edges, friction < 0.01);
	            }
	        };
	    }
	


/***/ }),
/* 132 */
/***/ (function(module, exports) {

	/**
	 * 工具类
	 * @class fishTopoFlow.util
	 */
	
	/**
	 * @method initImagePool
	 * 初始化图片池  用于对图片加载进行管理
	 * @param {number} max 最大连接数。数值。
	 * @returns {{load: Function, info: Function}}
	 *
	 * **使用范例**：
	 *
	 *      @example
	        var imagepool = fishTopoFlow.util.initImagePool(100);
	        imagepool.load(grayArray, {
	            success: function(imgs) {
	            },
	            once: true
	        });
	 */
	
	/**
	 * @method inherits
	 * 构造类继承关系
	 *
	 * @param {Function} clazz 源类
	 * @param {Function} baseClazz 基类
	 */
	
	
	    var emptyFn = function() {};
	    //初始默认配置
	    var config_default = {
	        //线程池"线程"数量
	        thread: 5,
	        //图片加载失败重试次数
	        //重试2次，加上原有的一次，总共是3次
	        "tries": 2
	    };
	    //工具
	    var _helpers = {
	        //设置dom属性
	        setAttr: (function() {
	            var img = new Image();
	            //判断浏览器是否支持HTML5 dataset
	            if (img.dataset) {
	                return function(dom, name, value) {
	                    dom.dataset[name] = value;
	                    return value;
	                };
	            } else {
	                return function(dom, name, value) {
	                    dom.setAttribute("data-" + name, value);
	                    return value;
	                };
	            }
	        }()),
	        //获取dom属性
	        getAttr: (function() {
	            var img = new Image();
	            //判断浏览器是否支持HTML5 dataset
	            if (img.dataset) {
	                return function(dom, name) {
	                    if(!dom.dataset[name]){
	                        return dom.getAttribute("data-" + name);
	                    }else{
	                        return dom.dataset[name];
	                    }
	                };
	            } else {
	                return function(dom, name) {
	                    return dom.getAttribute("data-" + name);
	                };
	            }
	        }())
	    };
	    /**
	     * 构造方法
	     * @private
	     * @param max 最大连接数。数值。
	     */
	    function ImagePool(max) {
	        //最大并发数量
	        this.max = max || config_default.thread;
	        this.linkHead = null;
	        this.linkNode = null;
	        //加载池
	        //[{img: dom,free: true, node: node}]
	        //node
	        //{src: "", options: {success: "fn",error: "fn", once: true}, tries: 0}
	        this.pool = [];
	    }
	    /**
	     * 初始化
	     * @private
	     */
	    ImagePool.prototype.initPool = function() {
	        var i, img, obj, _s;
	        _s = this;
	        for (i = 0; i < this.max; i++) {
	            obj = {};
	            img = new Image();
	            _helpers.setAttr(img, "id", i);
	            img.onload = function() {
	                //回调
	                _s.notice(_s.getNode(this), "success", this);
	                //处理任务
	                _s.executeLink(this);
	            };
	            img.onerror = function() {
	                var node = _s.getNode(this);
	                //判断尝试次数
	                if (node.tries < config_default.tries) {
	                    node.tries = node.tries+1;
	                    //再次追加到任务链表末尾
	                    _s.appendNode(_s.createNode(node.src, node.options, node.notice, node.group, node.tries));
	                } else {
	                    //error回调
	                    //node.options.error.call(null, this.src);
	                    _s.notice(node, "error", this);
	                }
	                //处理任务
	                _s.executeLink(this);
	            };
	            obj.img = img;
	            obj.free = true;
	            this.pool.push(obj);
	        }
	    };
	    /**
	     * 回调封装
	     * @private
	     * @param node 节点。对象。
	     * @param status 状态。字符串。可选值：success(成功)|error(失败)
	     * @param img 图片。
	     */
	    ImagePool.prototype.notice = function(node, status, img) {
	        node.notice(status, img);
	    };
	    /**
	     * 处理链表任务
	     * @private
	     * @param dom 图像dom对象。对象。
	     */
	    ImagePool.prototype.executeLink = function(dom) {
	        //判断链表是否存在节点
	        if (this.linkHead) {
	            //加载下一个图片
	            this.setSrc(dom, this.linkHead);
	            //去除链表头
	            this.shiftNode();
	        } else {
	            //设置自身状态为空闲
	            this.status(dom, true);
	        }
	    };
	    /**
	     * 获取空闲"线程"
	     * @private
	     */
	    ImagePool.prototype.getFree = function() {
	        var length, i;
	        for (i = 0, length = this.pool.length; i < length; i++) {
	            if (this.pool[i].free) {
	                return this.pool[i];
	            }
	        }
	        return null;
	    };
	    /**
	     * 封装src属性设置
	     * 因为改变src属性相当于加载图片，所以把操作封装起来
	     * @private
	     * @param dom 图像dom对象。对象。
	     * @param node 节点。对象。
	     */
	    ImagePool.prototype.setSrc = function(dom, node) {
	        //设置池中的"线程"为非空闲状态
	        this.status(dom, false);
	        //关联节点
	        this.setNode(dom, node);
	        //加载图片
	        dom.src = node.src;
	    };
	    /**
	     * 更新池中的"线程"状态
	     * @private
	     * @param dom 图像dom对象。对象。
	     * @param status 状态。布尔。可选值：true(空闲)|false(非空闲)
	     */
	    ImagePool.prototype.status = function(dom, status) {
	        var id = _helpers.getAttr(dom, "id");
	        if(id){
	            this.pool[id].free = status;
	        }
	
	        //空闲状态，清除关联的节点
	        if (status) {
	            this.pool[id].node = null;
	        }
	    };
	    /**
	     * 更新池中的"线程"的关联节点
	     * @private
	     * @param dom 图像dom对象。对象。
	     * @param node 节点。对象。
	     */
	    ImagePool.prototype.setNode = function(dom, node) {
	        var id = _helpers.getAttr(dom, "id");
	        if(id){
	            this.pool[id].node = node;
	            return this.pool[id].node === node;
	        }
	
	    };
	    /**
	     * 获取池中的"线程"的关联节点
	     * @private
	     * @param dom 图像dom对象。对象。
	     */
	    ImagePool.prototype.getNode = function(dom) {
	        var id = _helpers.getAttr(dom, "id");
	        if(id){
	            return this.pool[id].node;
	        }
	
	    };
	    /**
	     * 对外接口，加载图片
	     * @private
	     * @param src 可以是src字符串，也可以是src字符串数组。
	     * @param options 用户自定义参数。包含：success回调、error回调、once标识。
	     */
	    ImagePool.prototype._load = function(src, options) {
	        var srcs = [],
	            free = null,
	            length = 0,
	            i = 0,
	            //只初始化一次回调策略
	            notice = (function() {
	                if (options.once) {
	                    return function(status, img) {
	                        var g = this.group,
	                            o = this.options;
	                        //记录
	                        g[status].push(img);
	                        //判断改组是否全部处理完成
	                        if (g.success.length + g.error.length === g.count) {
	                            //异步
	                            //实际上是作为另一个任务单独执行，防止回调函数执行时间过长影响图片加载速度
	                            setTimeout(function() {
	                                o.success.call(null, g.success, g.error, g.count);
	                            }, 1);
	                        }
	                    };
	                } else {
	                    return function(status, img) {
	                        var o = this.options;
	                        //直接回调
	                        setTimeout(function() {
	                            o[status].call(null, img);
	                        }, 1);
	                    };
	                }
	            }()),
	            group = {
	                count: 0,
	                success: [],
	                error: []
	            },
	            node = null;
	        options = options || {};
	        options.success = options.success || emptyFn;
	        options.error = options.error || emptyFn;
	        srcs = srcs.concat(src);
	        //设置组元素个数
	        group.count = srcs.length;
	        //遍历需要加载的图片
	        for (i = 0, length = srcs.length; i < length; i++) {
	            //创建节点
	            node = this.createNode(srcs[i], options, notice, group);
	            //判断线程池是否有空闲
	            free = this.getFree();
	            if (free) {
	                //有空闲，则立即加载图片
	                this.setSrc(free.img, node);
	            } else {
	                //没有空闲，将任务添加到链表
	                this.appendNode(node);
	            }
	        }
	    };
	    /**
	     * 获取内部状态信息
	     * @private
	     * @returns {Object}
	     */
	    ImagePool.prototype._info = function() {
	        var info = {},
	            length = 0,
	            i = 0,
	            node = null;
	        //线程
	        info.thread = {};
	        //线程总数量
	        info.thread.count = this.pool.length;
	        //空闲线程数量
	        info.thread.free = 0;
	        //任务
	        info.task = {};
	        //待处理任务数量
	        info.task.count = 0;
	        //获取空闲"线程"数量
	        for (i = 0, length = this.pool.length; i < length; i++) {
	            if (this.pool[i].free) {
	                info.thread.free = info.thread.free + 1;
	            }
	        }
	        //获取任务数量(任务链长度)
	        node = this.linkHead;
	        if (node) {
	            info.task.count = info.task.count + 1;
	            while (node.next) {
	                info.task.count = info.task.count + 1;
	                node = node.next;
	            }
	        }
	        return info;
	    };
	
	    /**
	     * 创建节点
	     * @private
	     * @param src 图片路径。字符串。
	     * @param options 用户自定义参数。包含：success回调、error回调、once标识。
	     * @param notice 回调策略。 函数。
	     * @param group 组信息。对象。{count: 0, success: [], error: []}
	     * @param tr 出错重试次数。数值。默认为0。
	     * @returns {Object}
	     */
	    ImagePool.prototype.createNode = function(src, options, notice, group, tr) {
	        var node = {};
	        node.src = src;
	        node.options = options;
	        node.notice = notice;
	        node.group = group;
	        node.tries = tr || 0;
	        return node;
	    };
	    /**
	     * 向任务链表末尾追加节点
	     * @private
	     * @param node 节点。对象。
	     */
	    ImagePool.prototype.appendNode = function(node) {
	        //判断链表是否为空
	        if (!this.linkHead) {
	            this.linkHead = node;
	            this.linkNode = node;
	        } else {
	            this.linkNode.next = node;
	            this.linkNode = node;
	        }
	    };
	    /**
	     * 删除链表头
	     * @private
	     */
	    ImagePool.prototype.shiftNode = function() {
	        //判断链表是否存在节点
	        if (this.linkHead) {
	            //修改链表头
	            this.linkHead = this.linkHead.next || null;
	        }
	    };
	    /**
	     * 初始化图片池
	     * @param {number} max 最大连接数。数值。
	     * @returns {{load: Function, info: Function}}
	     */
	    var initImagePool = function(max) {
	        var instance = new ImagePool(max);
	        instance.initPool();
	        return {
	            /**
	             * 加载图片
	             * @param {string|Array} src 可以是src字符串，也可以是src字符串数组。
	             * @param {Object} options 用户自定义参数。包含：success回调、error回调、once标识。
	             * @param {Function} [options.success] success回调
	             * @param {Function} [options.error] error回调
	             * @param {boolean} [options.once] 是否全部加载完毕后，一次回调
	             */
	            load: function() {
	                instance._load.apply(instance, arguments);
	            },
	            /**
	             * 获取内部状态信息
	             * @returns {Object}
	             */
	            info: function() {
	                return instance._info.call(instance);
	            }
	        };
	    };
	
	    module.exports = { initImagePool: initImagePool }
	


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var TooltipContent = __webpack_require__(134);
	    var globalListener = __webpack_require__(135);
	    var Model = __webpack_require__(87);
	    var zrUtil = __webpack_require__(5);
	    var env = __webpack_require__(50);
	    var flowUtil = __webpack_require__(94);
	    var layout = __webpack_require__(124);
	    function TooltipView(tooltipModel, api) {
	        this._tooltipContent = new TooltipContent(api.getDom(),api);
	        this._api = api;
	        this._tooltipModel = tooltipModel;
	        this._alwaysShowContent = tooltipModel.get('alwaysShowContent');
	        this._initGloablListener();
	    }
	
	    TooltipView.prototype._initGloablListener = function() {
	        var triggerOn = this._tooltipModel.get('triggerOn');
	        // 当有 'click' | 'mousemove' | 'none' 事件时触发回调
	        globalListener.register(
	            'itemTooltip',
	            this._api,
	            function(currTrigger, e, dispatchAction){
	                if (triggerOn !== 'none') {
	                    if (triggerOn.indexOf(currTrigger) >= 0 ) {
	                        this._tryShow(e, dispatchAction);
	                    }
	                    else if (currTrigger === 'leave') {
	                        this._hide(dispatchAction)
	                    }
	                }
	            }.bind(this)
	        )
	    };
	
	    TooltipView.prototype._tryShow = function(e, dispatchAction) {
	            var el = e.target;
	            var tooltipModel = this._tooltipModel;
	
	            if (!tooltipModel) {
	                return;
	            }
	
	            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed
	            this._lastX = e.offsetX;
	            this._lastY = e.offsetY;
	
	            if (el && el.tooltip) {
	                this._showComponentItemTooltip(e, el);
	            }
	            else {
	                this._hide(dispatchAction);
	            }
	    };
	
	     TooltipView.prototype._hide = function(dispatchAction) {
	            // Do not directly hideLater here, because this behavior may be prevented
	            // in dispatchAction when showTip is dispatched.
	
	            // FIXME
	            // duplicated hideTip if manuallyHideTip is called from dispatchAction.
	            this._lastDataByCoordSys = null;
	            dispatchAction({
	                type: 'hideTip',
	                from: this.uid
	            });
	            this.manuallyHideTip();
	        };
	
	       TooltipView.prototype.dispose = function () {
	            if (env.node) {
	                return;
	            }
	            this._tooltipContent.hide();
	            globalListener.unregister('itemTooltip', this._api);
	        };
	
	        TooltipView.prototype.manuallyHideTip = function () {
	            var tooltipContent = this._tooltipContent;
	
	            if (!this._alwaysShowContent) {
	                tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
	            }
	
	            this._lastX = this._lastY = null;
	
	
	        },
	
	    TooltipView.prototype._showComponentItemTooltip = function (e, el) {
	            var tooltipOpt = el.tooltip;
	            if (typeof tooltipOpt === 'string') {
	                var content = tooltipOpt;
	                tooltipOpt = {
	                    content: content,
	                    // Fixed formatter
	                    formatter: content
	                };
	            }
	            var subTooltipModel = new Model(tooltipOpt, this._tooltipModel);
	            var defaultHtml = subTooltipModel.get('content');
	            var asyncTicket = Math.random();
	
	            // Do not check whether `trigger` is 'none' here, because `trigger`
	            // only works on cooridinate system. In fact, we have not found case
	            // that requires setting `trigger` nothing on component yet.
	
	            this._showOrMove(subTooltipModel, function () {
	                this._showTooltipContent(
	                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},
	                    asyncTicket, e.offsetX, e.offsetY, e.position, el
	                );
	            });
	
	
	        };
	
	      TooltipView.prototype._showOrMove = function (tooltipModel, cb) {
	            // showDelay is used in this case: tooltip.enterable is set
	            // as true. User intent to move mouse into tooltip and click
	            // something. `showDelay` makes it easyer to enter the content
	            // but tooltip do not move immediately.
	            var delay = tooltipModel.get('showDelay');
	            cb = zrUtil.bind(cb, this);
	            clearTimeout(this._showTimout);
	            delay > 0
	                ? (this._showTimout = setTimeout(cb, delay))
	                : cb();
	        };
	
	        TooltipView.prototype._showTooltipContent = function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {
	            // Reset ticket
	            this._ticket = '';
	
	            if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {
	                return;
	            }
	
	            var tooltipContent = this._tooltipContent;
	
	            var formatter = tooltipModel.get('formatter');
	            positionExpr = positionExpr || tooltipModel.get('position');
	            var html = defaultHtml;
	
	            if (formatter && typeof formatter === 'string') {
	                html = flowUtil.formatTpl(formatter, params, true);
	            }
	            else if (typeof formatter === 'function') {
	                var callback = function (cbTicket, html) {
	                    if (cbTicket === this._ticket) {
	                        tooltipContent.setContent(html);
	                        this._updatePosition(
	                            tooltipModel, positionExpr, x, y, tooltipContent, params, el
	                        );
	                    }
	                }.bind(this);
	                this._ticket = asyncTicket;
	                html = formatter(params, asyncTicket, callback);
	            }
	
	            tooltipContent.setContent(html);
	            tooltipContent.show(tooltipModel);
	
	            this._updatePosition(
	                tooltipModel, positionExpr, x, y, tooltipContent, params, el
	            );
	        };
	
	        /**
	         * @param  {string|Function|Array.<number>} positionExpr
	         * @param  {number} x Mouse x
	         * @param  {number} y Mouse y
	         * @param  {boolean} confine Whether confine tooltip content in view rect.
	         * @param  {Object|<Array.<Object>} params
	         * @param  {module:zrender/Element} el target element
	         * @param  {module:echarts/ExtensionAPI} api
	         * @return {Array.<number>}
	         */
	        TooltipView.prototype._updatePosition = function (tooltipModel, positionExpr, x, y, content, params, el) {
	            var viewWidth = this._api.getWidth();
	            var viewHeight = this._api.getHeight();
	            positionExpr = positionExpr || tooltipModel.get('position');
	
	            var contentSize = content.getSize();
	            var align = tooltipModel.get('align');
	            var vAlign = tooltipModel.get('verticalAlign');
	            var rect = el && el.getBoundingRect().clone();
	            el && rect.applyTransform(el.transform);
	
	            if (typeof positionExpr === 'function') {
	                // Callback of position can be an array or a string specify the position
	                positionExpr = positionExpr([x, y], params, content.el, rect, {
	                    viewSize: [viewWidth, viewHeight],
	                    contentSize: contentSize.slice()
	                });
	            }
	
	            if (zrUtil.isArray(positionExpr)) {
	                x = flowUtil.parsePercent(positionExpr[0], viewWidth);
	                y = flowUtil.parsePercent(positionExpr[1], viewHeight);
	            }
	            else if (zrUtil.isObject(positionExpr)) {
	                positionExpr.width = contentSize[0];
	                positionExpr.height = contentSize[1];
	                var layoutRect = layout.getLayoutRect(
	                    positionExpr, {width: viewWidth, height: viewHeight}
	                );
	                x = layoutRect.x;
	                y = layoutRect.y;
	                align = null;
	                // When positionExpr is left/top/right/bottom,
	                // align and verticalAlign will not work.
	                vAlign = null;
	            }
	            // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element
	            else if (typeof positionExpr === 'string' && el) {
	                var pos = calcTooltipPosition(
	                    positionExpr, rect, contentSize
	                );
	                x = pos[0];
	                y = pos[1];
	            }
	            else {
	                var pos1 = refixTooltipPosition(
	                    x, y, content.el, viewWidth, viewHeight, align ? 0 : 20, vAlign ? 0 : 20
	                );
	                x = pos1[0];
	                y = pos1[1];
	            }
	
	            align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);
	            vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);
	
	            if (tooltipModel.get('confine')) {
	                var pos2 = confineTooltipPosition(
	                    x, y, content.el, viewWidth, viewHeight
	                );
	                x = pos2[0];
	                y = pos2[1];
	            }
	
	            content.moveTo(x, y);
	        }
	
	    function calcTooltipPosition(position, rect, contentSize) {
	        var domWidth = contentSize[0];
	        var domHeight = contentSize[1];
	        var gap = 5;
	        var x = 0;
	        var y = 0;
	        var rectWidth = rect.width;
	        var rectHeight = rect.height;
	        switch (position) {
	            case 'inside':
	                x = rect.x + rectWidth / 2 - domWidth / 2;
	                y = rect.y + rectHeight / 2 - domHeight / 2;
	                break;
	            case 'top':
	                x = rect.x + rectWidth / 2 - domWidth / 2;
	                y = rect.y - domHeight - gap;
	                break;
	            case 'bottom':
	                x = rect.x + rectWidth / 2 - domWidth / 2;
	                y = rect.y + rectHeight + gap;
	                break;
	            case 'left':
	                x = rect.x - domWidth - gap;
	                y = rect.y + rectHeight / 2 - domHeight / 2;
	                break;
	            case 'right':
	                x = rect.x + rectWidth + gap;
	                y = rect.y + rectHeight / 2 - domHeight / 2;
	        }
	        return [x, y];
	    }
	    function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {
	        var width = el.clientWidth;
	        var height = el.clientHeight;
	
	        if (x + width + gapH > viewWidth) {
	            x -= width + gapH;
	        }
	        else {
	            x += gapH;
	        }
	        if (y + height + gapV > viewHeight) {
	            y -= height + gapV;
	        }
	        else {
	            y += gapV;
	        }
	        return [x, y];
	    }
	
	    function isCenterAlign(align) {
	        return align === 'center' || align === 'middle';
	    }
	
	    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {
	        var width = el.clientWidth;
	        var height = el.clientHeight;
	
	        x = Math.min(x + width, viewWidth) - width;
	        y = Math.min(y + height, viewHeight) - height;
	        x = Math.max(x, 0);
	        y = Math.max(y, 0);
	
	        return [x, y];
	    }
	    module.exports = TooltipView;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var zrUtil = __webpack_require__(5);
	    var zrColor = __webpack_require__(20);
	    var env = __webpack_require__(50);
	    var eventUtil = __webpack_require__(77);
	    var flowUtil = __webpack_require__(94);
	    var toCamelCase = flowUtil.toCamelCase;
	    var normalizeCssArray = flowUtil.normalizeCssArray;
	    var each = zrUtil.each;
	
	
	    var vendors = ['', '-webkit-', '-moz-', '-o-'];
	
	    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:999;';//fish popup zindex:1050
	    /**
	     * @param {number} duration
	     * @return {string}
	     * @inner
	     */
	    function assembleTransition(duration) {
	        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';
	        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','
	                            + 'top ' + duration + 's ' + transitionCurve;
	        return zrUtil.map(vendors, function (vendorPrefix) {
	            return vendorPrefix + 'transition:' + transitionText;
	        }).join(';');
	    }
	
	    /**
	     * @param {Object} textStyle
	     * @return {string}
	     * @inner
	     */
	    function assembleFont(textStyleModel) {
	        var cssText = [];
	
	        var fontSize = textStyleModel.get('fontSize');
	        var color = textStyleModel.get("color");
	
	        color && cssText.push('color:' + color);
	
	        var font = textStyleModel.get("font");
	        font && cssText.push('font:' + font);
	
	        fontSize &&
	            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');
	
	        each(['decoration', 'align'], function (name) {
	            var val = textStyleModel.get(name);
	            val && cssText.push('text-' + name + ':' + val);
	        });
	
	        return cssText.join(';');
	    }
	    /**
	     * @param {Object} tooltipModel
	     * @return {string}
	     * @inner
	     */
	    function assembleCssText(tooltipModel) {
	
	        var cssText = [];
	
	        var transitionDuration = tooltipModel.get('transitionDuration');
	        var backgroundColor = tooltipModel.get('backgroundColor');
	        var textStyleModel = tooltipModel.getModel('textStyle');
	        var padding = tooltipModel.get('padding');
	
	        // Animation transition. Do not animate when transitionDuration is 0.
	        transitionDuration &&
	            cssText.push(assembleTransition(transitionDuration));
	
	        if (backgroundColor) {
	            if (env.canvasSupported) {
	                cssText.push('background-Color:' + backgroundColor);
	            }
	            else {
	                // for ie
	                cssText.push(
	                    'background-Color:#' + zrColor.toHex(backgroundColor)
	                );
	                cssText.push('filter:alpha(opacity=70)');
	            }
	        }
	
	        // Border style
	        each(['width', 'color', 'radius'], function (name) {
	            var borderName = 'border-' + name;
	            var camelCase = toCamelCase(borderName);
	            var val = tooltipModel.get(camelCase);
	            val != null &&
	                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
	        });
	
	        // Text style
	        cssText.push(assembleFont(textStyleModel));
	
	        // Padding
	        if (padding != null) {
	            cssText.push('padding:' + normalizeCssArray(padding).join('px ') + 'px');
	        }
	
	        return cssText.join(';') + ';';
	    }
	    /**
	     *
	     *
	     * @param {any} container
	     * @param {any} api
	     */
	    function TooltipContent(container, api) {
	        var el = document.createElement('div');
	        var zr = this._zr = api.getZr();
	
	        this.el = el;
	
	        this._x = api.getWidth() / 2;
	        this._y = api.getHeight() / 2;
	
	        container.appendChild(el);
	
	        this._container = container;
	
	        this._show = false;
	
	        /**
	         * @private
	         */
	        this._hideTimeout;
	
	        var self = this;
	        el.onmouseenter = function () {
	            // clear the timeout in hideLater and keep showing tooltip
	            if (self._enterable) {
	                clearTimeout(self._hideTimeout);
	                self._show = true;
	            }
	            self._inContent = true;
	        };
	        el.onmousemove = function (e) {
	            e = e || window.event;
	            if (!self._enterable) {
	                // Try trigger zrender event to avoid mouse
	                // in and out shape too frequently
	                var handler = zr.handler;
	                eventUtil.normalizeEvent(container, e, true);
	                handler.dispatch('mousemove', e);
	            }
	        };
	        el.onmouseleave = function () {
	            if (self._enterable) {
	                if (self._show) {
	                    self.hideLater(self._hideDelay);
	                }
	            }
	            self._inContent = false;
	        };
	    }
	    TooltipContent.prototype = {
	
	        constructor: TooltipContent,
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        _enterable: true,
	
	        /**
	         * Update when tooltip is rendered
	         */
	        update: function () {
	            // FIXME
	            // Move this logic to ec main?
	            var container = this._container;
	            var stl = container.currentStyle
	                || document.defaultView.getComputedStyle(container);
	            var domStyle = container.style;
	            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {
	                domStyle.position = 'relative';
	            }
	            // Hide the tooltip
	            // PENDING
	            // this.hide();
	        },
	
	        show: function (tooltipModel) {
	            clearTimeout(this._hideTimeout);
	            var el = this.el;
	
	            el.style.cssText = gCssText + assembleCssText(tooltipModel)
	                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore
	                + ';left:' + this._x + 'px;top:' + this._y + 'px;'
	                + (tooltipModel.get('extraCssText') || '');
	
	            el.style.display = el.innerHTML ?  'block' : 'none';
	
	            this._show = true;
	        },
	
	        setContent: function (content) {
	            this.el.innerHTML = content;
	        },
	
	        setEnterable: function (enterable) {
	            this._enterable = enterable;
	        },
	
	        getSize: function () {
	            var el = this.el;
	            return [el.clientWidth, el.clientHeight];
	        },
	
	        moveTo: function (x, y) {
	            // xy should be based on canvas root. But tooltipContent is
	            // the sibling of canvas root. So padding of ec container
	            // should be considered here.
	            var zr = this._zr;
	            var viewportRoot;
	            if (zr && zr.painter && (viewportRoot = zr.painter.getViewportRoot())) {
	                x += viewportRoot.offsetLeft || 0;
	                y += viewportRoot.offsetTop || 0;
	            }
	
	            var style = this.el.style;
	            style.left = x + 'px';
	            style.top = y + 'px';
	
	            this._x = x;
	            this._y = y;
	        },
	
	        hide: function () {
	            this.el.style.display = 'none';
	            this._show = false;
	        },
	
	        hideLater: function (time) {
	            if (this._show && !(this._inContent && this._enterable)) {
	                if (time) {
	                    this._hideDelay = time;
	                    // Set show false to avoid invoke hideLater mutiple times
	                    this._show = false;
	                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
	                }
	                else {
	                    this.hide();
	                }
	            }
	        },
	
	        isShow: function () {
	            return this._show;
	        }
	    };
	
	    module.exports = TooltipContent;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var env = __webpack_require__(50);
	    var zrUtil = __webpack_require__(5);
	    var get = __webpack_require__(94).makeGetter();
	
	    var each = zrUtil.each;
	
	    var globalListener = {};
	
	    /**
	     * @param key 注册的字符串
	     * @param api ExtensionAPI
	     * @param handler 处理回调
	     */
	    globalListener.register = function (key, api, handler) {
	        if (env.node) {   //node环境下不执行
	            return;
	        }
	        //判断zrender的 records  并初始化
	        var zr = api.getZr();
	        get(zr).records || (get(zr).records = {});
	
	        initGlobalListeners(zr, api);
	
	        //将回调加入record
	        var record = get(zr).records[key] || (get(zr).records[key] = {});
	        record.handler = handler;
	    };
	
	    /**
	     * 初始化全局侦听
	     *
	     * @param {object} zr   zrender
	     * @param {object} api  ExtensionAPI
	     * @returns
	     */
	    function initGlobalListeners(zr, api) {
	        if (get(zr).initialized) {   //避免重复初始化
	            return;
	        }
	
	        get(zr).initialized = true;
	
	        //侦听事件
	        useHandler('click', zrUtil.curry(doEnter, 'click'));
	        useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove'));
	        // useHandler('mouseout', onLeave);
	        useHandler('globalout', onLeave);
	
	        function useHandler(eventType, cb) {
	            zr.on(eventType, function (e) {
	                var dis = makeDispatchAction(api);
	                //遍历注册的 所有records， 并进行调用
	                each(get(zr).records, function (record) {
	                    record && cb(record, e, dis.dispatchAction);
	                });
	
	                dispatchTooltipFinally(dis.pendings, api);
	            });
	        }
	    }
	
	    function dispatchTooltipFinally(pendings, api) {
	        var showLen = pendings.showTip.length;
	        var hideLen = pendings.hideTip.length;
	
	        var actuallyPayload;
	        if (showLen) {
	            actuallyPayload = pendings.showTip[showLen - 1];
	        }
	        else if (hideLen) {
	            actuallyPayload = pendings.hideTip[hideLen - 1];
	        }
	        if (actuallyPayload) {
	            actuallyPayload.dispatchAction = null;
	            api.dispatchAction(actuallyPayload);
	        }
	    }
	
	    function onLeave(record, e, dispatchAction) {
	        record.handler('leave', null, dispatchAction);
	    }
	
	    function doEnter(currTrigger, record, e, dispatchAction) {
	        record.handler(currTrigger, e, dispatchAction);
	    }
	
	    /**
	     * 派发action   行将发生的
	     *
	     * @param {any} api
	     * @returns
	     */
	    function makeDispatchAction(api) {
	        var pendings = {
	            showTip: [],
	            hideTip: []
	        };
	        // FIXME
	        // better approach?
	        // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,
	        // which may be conflict, (axisPointer call showTip but tooltip call hideTip);
	        // So we have to add "final stage" to merge those dispatched actions.
	        var dispatchAction = function (payload) {
	            var pendingList = pendings[payload.type];
	            if (pendingList) {
	                pendingList.push(payload);
	            }
	            else {
	                payload.dispatchAction = dispatchAction;
	                api.dispatchAction(payload);
	            }
	        };
	
	        return {
	            dispatchAction: dispatchAction,
	            pendings: pendings
	        };
	    }
	
	    /**
	     * @param {string} key
	     * @param {module:echarts/ExtensionAPI} api
	     */
	    globalListener.unregister = function (key, api) {
	        if (env.node) {
	            return;
	        }
	        var zr = api.getZr();
	        var record = (get(zr).records || {})[key];
	        if (record) {
	            get(zr).records[key] = null;
	        }
	    };
	
	    module.exports = globalListener;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var Model = __webpack_require__(87);
	    module.exports = Model.extend({
	
	        type: 'tooltip',
	
	        defaultOption: {
	            zlevel: 0,
	
	            z: 8,
	
	            show: true,
	
	            // tooltip主体内容
	            showContent: true,
	
	
	
	            // 'click' | 'mousemove' | 'none'
	            triggerOn: 'mousemove',
	
	            alwaysShowContent: false,
	
	            displayMode: 'single', // 'single' | 'multipleByCoordSys'
	
	            // 位置 {Array} | {Function}
	            // position: null
	            // Consider triggered from axisPointer handle, verticalAlign should be 'middle'
	            // align: null,
	            // verticalAlign: null,
	
	            // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。
	            confine: false,
	
	            // 内容格式器：{string}（Template） ¦ {Function}
	            // formatter: null
	
	            showDelay: 0,
	
	            // 隐藏延迟，单位ms
	            hideDelay: 100,
	
	            // 动画变换时间，单位s
	            transitionDuration: 0.4,
	
	            enterable: false,
	
	            // 提示背景颜色，默认为透明度为0.7的黑色
	            backgroundColor: 'rgba(50,50,50,0.7)',
	
	            // 提示边框颜色
	            borderColor: '#333',
	
	            // 提示边框圆角，单位px，默认为4
	            borderRadius: 4,
	
	            // 提示边框线宽，单位px，默认为0（无边框）
	            borderWidth: 0,
	
	            // 提示内边距，单位px，默认各方向内边距为5，
	            // 接受数组分别设定上右下左边距，同css
	            padding: 5,
	
	            // Extra css text
	            extraCssText: '',
	
	            textStyle: {
	                color: '#fff',
	                fontSize: 14
	            }
	        }
	    });


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(138);
	
	var _zrender = __webpack_require__(69);
	
	var registerPainter = _zrender.registerPainter;
	
	var Painter = __webpack_require__(140);
	
	registerPainter('vml', Painter);

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	var env = __webpack_require__(50);
	
	var _vector = __webpack_require__(15);
	
	var applyTransform = _vector.applyTransform;
	
	var BoundingRect = __webpack_require__(27);
	
	var colorTool = __webpack_require__(20);
	
	var textContain = __webpack_require__(26);
	
	var textHelper = __webpack_require__(25);
	
	var RectText = __webpack_require__(24);
	
	var Displayable = __webpack_require__(8);
	
	var ZImage = __webpack_require__(45);
	
	var Text = __webpack_require__(46);
	
	var Path = __webpack_require__(7);
	
	var PathProxy = __webpack_require__(30);
	
	var Gradient = __webpack_require__(42);
	
	var vmlCore = __webpack_require__(139);
	
	// http://www.w3.org/TR/NOTE-VML
	// TODO Use proxy like svg instead of overwrite brush methods
	var CMD = PathProxy.CMD;
	var round = Math.round;
	var sqrt = Math.sqrt;
	var abs = Math.abs;
	var cos = Math.cos;
	var sin = Math.sin;
	var mathMax = Math.max;
	
	if (!env.canvasSupported) {
	  var comma = ',';
	  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';
	  var Z = 21600;
	  var Z2 = Z / 2;
	  var ZLEVEL_BASE = 100000;
	  var Z_BASE = 1000;
	
	  var initRootElStyle = function (el) {
	    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';
	    el.coordsize = Z + ',' + Z;
	    el.coordorigin = '0,0';
	  };
	
	  var encodeHtmlAttribute = function (s) {
	    return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
	  };
	
	  var rgb2Str = function (r, g, b) {
	    return 'rgb(' + [r, g, b].join(',') + ')';
	  };
	
	  var append = function (parent, child) {
	    if (child && parent && child.parentNode !== parent) {
	      parent.appendChild(child);
	    }
	  };
	
	  var remove = function (parent, child) {
	    if (child && parent && child.parentNode === parent) {
	      parent.removeChild(child);
	    }
	  };
	
	  var getZIndex = function (zlevel, z, z2) {
	    // z 的取值范围为 [0, 1000]
	    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
	  };
	
	  var parsePercent = function (value, maxValue) {
	    if (typeof value === 'string') {
	      if (value.lastIndexOf('%') >= 0) {
	        return parseFloat(value) / 100 * maxValue;
	      }
	
	      return parseFloat(value);
	    }
	
	    return value;
	  };
	  /***************************************************
	   * PATH
	   **************************************************/
	
	
	  var setColorAndOpacity = function (el, color, opacity) {
	    var colorArr = colorTool.parse(color);
	    opacity = +opacity;
	
	    if (isNaN(opacity)) {
	      opacity = 1;
	    }
	
	    if (colorArr) {
	      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
	      el.opacity = opacity * colorArr[3];
	    }
	  };
	
	  var getColorAndAlpha = function (color) {
	    var colorArr = colorTool.parse(color);
	    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];
	  };
	
	  var updateFillNode = function (el, style, zrEl) {
	    // TODO pattern
	    var fill = style.fill;
	
	    if (fill != null) {
	      // Modified from excanvas
	      if (fill instanceof Gradient) {
	        var gradientType;
	        var angle = 0;
	        var focus = [0, 0]; // additional offset
	
	        var shift = 0; // scale factor for offset
	
	        var expansion = 1;
	        var rect = zrEl.getBoundingRect();
	        var rectWidth = rect.width;
	        var rectHeight = rect.height;
	
	        if (fill.type === 'linear') {
	          gradientType = 'gradient';
	          var transform = zrEl.transform;
	          var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];
	
	          if (transform) {
	            applyTransform(p0, p0, transform);
	            applyTransform(p1, p1, transform);
	          }
	
	          var dx = p1[0] - p0[0];
	          var dy = p1[1] - p0[1];
	          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.
	
	          if (angle < 0) {
	            angle += 360;
	          } // Very small angles produce an unexpected result because they are
	          // converted to a scientific notation string.
	
	
	          if (angle < 1e-6) {
	            angle = 0;
	          }
	        } else {
	          gradientType = 'gradientradial';
	          var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	          var transform = zrEl.transform;
	          var scale = zrEl.scale;
	          var width = rectWidth;
	          var height = rectHeight;
	          focus = [// Percent in bounding rect
	          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];
	
	          if (transform) {
	            applyTransform(p0, p0, transform);
	          }
	
	          width /= scale[0] * Z;
	          height /= scale[1] * Z;
	          var dimension = mathMax(width, height);
	          shift = 2 * 0 / dimension;
	          expansion = 2 * fill.r / dimension - shift;
	        } // We need to sort the color stops in ascending order by offset,
	        // otherwise IE won't interpret it correctly.
	
	
	        var stops = fill.colorStops.slice();
	        stops.sort(function (cs1, cs2) {
	          return cs1.offset - cs2.offset;
	        });
	        var length = stops.length; // Color and alpha list of first and last stop
	
	        var colorAndAlphaList = [];
	        var colors = [];
	
	        for (var i = 0; i < length; i++) {
	          var stop = stops[i];
	          var colorAndAlpha = getColorAndAlpha(stop.color);
	          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);
	
	          if (i === 0 || i === length - 1) {
	            colorAndAlphaList.push(colorAndAlpha);
	          }
	        }
	
	        if (length >= 2) {
	          var color1 = colorAndAlphaList[0][0];
	          var color2 = colorAndAlphaList[1][0];
	          var opacity1 = colorAndAlphaList[0][1] * style.opacity;
	          var opacity2 = colorAndAlphaList[1][1] * style.opacity;
	          el.type = gradientType;
	          el.method = 'none';
	          el.focus = '100%';
	          el.angle = angle;
	          el.color = color1;
	          el.color2 = color2;
	          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2
	          // are reversed.
	
	          el.opacity = opacity2; // FIXME g_o_:opacity ?
	
	          el.opacity2 = opacity1;
	        }
	
	        if (gradientType === 'radial') {
	          el.focusposition = focus.join(',');
	        }
	      } else {
	        // FIXME Change from Gradient fill to color fill
	        setColorAndOpacity(el, fill, style.opacity);
	      }
	    }
	  };
	
	  var updateStrokeNode = function (el, style) {
	    // if (style.lineJoin != null) {
	    //     el.joinstyle = style.lineJoin;
	    // }
	    // if (style.miterLimit != null) {
	    //     el.miterlimit = style.miterLimit * Z;
	    // }
	    // if (style.lineCap != null) {
	    //     el.endcap = style.lineCap;
	    // }
	    if (style.lineDash != null) {
	      el.dashstyle = style.lineDash.join(' ');
	    }
	
	    if (style.stroke != null && !(style.stroke instanceof Gradient)) {
	      setColorAndOpacity(el, style.stroke, style.opacity);
	    }
	  };
	
	  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {
	    var isFill = type == 'fill';
	    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth
	
	    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {
	      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error
	
	      if (style[type] instanceof Gradient) {
	        remove(vmlEl, el);
	      }
	
	      if (!el) {
	        el = vmlCore.createNode(type);
	      }
	
	      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
	      append(vmlEl, el);
	    } else {
	      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';
	      remove(vmlEl, el);
	    }
	  };
	
	  var points = [[], [], []];
	
	  var pathDataToString = function (path, m) {
	    var M = CMD.M;
	    var C = CMD.C;
	    var L = CMD.L;
	    var A = CMD.A;
	    var Q = CMD.Q;
	    var str = [];
	    var nPoint;
	    var cmdStr;
	    var cmd;
	    var i;
	    var xi;
	    var yi;
	    var data = path.data;
	    var dataLength = path.len();
	
	    for (i = 0; i < dataLength;) {
	      cmd = data[i++];
	      cmdStr = '';
	      nPoint = 0;
	
	      switch (cmd) {
	        case M:
	          cmdStr = ' m ';
	          nPoint = 1;
	          xi = data[i++];
	          yi = data[i++];
	          points[0][0] = xi;
	          points[0][1] = yi;
	          break;
	
	        case L:
	          cmdStr = ' l ';
	          nPoint = 1;
	          xi = data[i++];
	          yi = data[i++];
	          points[0][0] = xi;
	          points[0][1] = yi;
	          break;
	
	        case Q:
	        case C:
	          cmdStr = ' c ';
	          nPoint = 3;
	          var x1 = data[i++];
	          var y1 = data[i++];
	          var x2 = data[i++];
	          var y2 = data[i++];
	          var x3;
	          var y3;
	
	          if (cmd === Q) {
	            // Convert quadratic to cubic using degree elevation
	            x3 = x2;
	            y3 = y2;
	            x2 = (x2 + 2 * x1) / 3;
	            y2 = (y2 + 2 * y1) / 3;
	            x1 = (xi + 2 * x1) / 3;
	            y1 = (yi + 2 * y1) / 3;
	          } else {
	            x3 = data[i++];
	            y3 = data[i++];
	          }
	
	          points[0][0] = x1;
	          points[0][1] = y1;
	          points[1][0] = x2;
	          points[1][1] = y2;
	          points[2][0] = x3;
	          points[2][1] = y3;
	          xi = x3;
	          yi = y3;
	          break;
	
	        case A:
	          var x = 0;
	          var y = 0;
	          var sx = 1;
	          var sy = 1;
	          var angle = 0;
	
	          if (m) {
	            // Extract SRT from matrix
	            x = m[4];
	            y = m[5];
	            sx = sqrt(m[0] * m[0] + m[1] * m[1]);
	            sy = sqrt(m[2] * m[2] + m[3] * m[3]);
	            angle = Math.atan2(-m[1] / sy, m[0] / sx);
	          }
	
	          var cx = data[i++];
	          var cy = data[i++];
	          var rx = data[i++];
	          var ry = data[i++];
	          var startAngle = data[i++] + angle;
	          var endAngle = data[i++] + startAngle + angle; // FIXME
	          // var psi = data[i++];
	
	          i++;
	          var clockwise = data[i++];
	          var x0 = cx + cos(startAngle) * rx;
	          var y0 = cy + sin(startAngle) * ry;
	          var x1 = cx + cos(endAngle) * rx;
	          var y1 = cy + sin(endAngle) * ry;
	          var type = clockwise ? ' wa ' : ' at ';
	
	          if (Math.abs(x0 - x1) < 1e-4) {
	            // IE won't render arches drawn counter clockwise if x0 == x1.
	            if (Math.abs(endAngle - startAngle) > 1e-2) {
	              // Offset x0 by 1/80 of a pixel. Use something
	              // that can be represented in binary
	              if (clockwise) {
	                x0 += 270 / Z;
	              }
	            } else {
	              // Avoid case draw full circle
	              if (Math.abs(y0 - cy) < 1e-4) {
	                if (clockwise && x0 < cx || !clockwise && x0 > cx) {
	                  y1 -= 270 / Z;
	                } else {
	                  y1 += 270 / Z;
	                }
	              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {
	                x1 += 270 / Z;
	              } else {
	                x1 -= 270 / Z;
	              }
	            }
	          }
	
	          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));
	          xi = x1;
	          yi = y1;
	          break;
	
	        case CMD.R:
	          var p0 = points[0];
	          var p1 = points[1]; // x0, y0
	
	          p0[0] = data[i++];
	          p0[1] = data[i++]; // x1, y1
	
	          p1[0] = p0[0] + data[i++];
	          p1[1] = p0[1] + data[i++];
	
	          if (m) {
	            applyTransform(p0, p0, m);
	            applyTransform(p1, p1, m);
	          }
	
	          p0[0] = round(p0[0] * Z - Z2);
	          p1[0] = round(p1[0] * Z - Z2);
	          p0[1] = round(p0[1] * Z - Z2);
	          p1[1] = round(p1[1] * Z - Z2);
	          str.push( // x0, y0
	          ' m ', p0[0], comma, p0[1], // x1, y0
	          ' l ', p1[0], comma, p0[1], // x1, y1
	          ' l ', p1[0], comma, p1[1], // x0, y1
	          ' l ', p0[0], comma, p1[1]);
	          break;
	
	        case CMD.Z:
	          // FIXME Update xi, yi
	          str.push(' x ');
	      }
	
	      if (nPoint > 0) {
	        str.push(cmdStr);
	
	        for (var k = 0; k < nPoint; k++) {
	          var p = points[k];
	          m && applyTransform(p, p, m); // 不 round 会非常慢
	
	          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');
	        }
	      }
	    }
	
	    return str.join('');
	  }; // Rewrite the original path method
	
	
	  Path.prototype.brushVML = function (vmlRoot) {
	    var style = this.style;
	    var vmlEl = this._vmlEl;
	
	    if (!vmlEl) {
	      vmlEl = vmlCore.createNode('shape');
	      initRootElStyle(vmlEl);
	      this._vmlEl = vmlEl;
	    }
	
	    updateFillAndStroke(vmlEl, 'fill', style, this);
	    updateFillAndStroke(vmlEl, 'stroke', style, this);
	    var m = this.transform;
	    var needTransform = m != null;
	    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];
	
	    if (strokeEl) {
	      var lineWidth = style.lineWidth; // Get the line scale.
	      // Determinant of this.m_ means how much the area is enlarged by the
	      // transformation. So its square root can be used as a scale factor
	      // for width.
	
	      if (needTransform && !style.strokeNoScale) {
	        var det = m[0] * m[3] - m[1] * m[2];
	        lineWidth *= sqrt(abs(det));
	      }
	
	      strokeEl.weight = lineWidth + 'px';
	    }
	
	    var path = this.path || (this.path = new PathProxy());
	
	    if (this.__dirtyPath) {
	      path.beginPath();
	      this.buildPath(path, this.shape);
	      path.toStatic();
	      this.__dirtyPath = false;
	    }
	
	    vmlEl.path = pathDataToString(path, this.transform);
	    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root
	
	    append(vmlRoot, vmlEl); // Text
	
	    if (style.text != null) {
	      this.drawRectText(vmlRoot, this.getBoundingRect());
	    } else {
	      this.removeRectText(vmlRoot);
	    }
	  };
	
	  Path.prototype.onRemove = function (vmlRoot) {
	    remove(vmlRoot, this._vmlEl);
	    this.removeRectText(vmlRoot);
	  };
	
	  Path.prototype.onAdd = function (vmlRoot) {
	    append(vmlRoot, this._vmlEl);
	    this.appendRectText(vmlRoot);
	  };
	  /***************************************************
	   * IMAGE
	   **************************************************/
	
	
	  var isImage = function (img) {
	    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错
	    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;
	  }; // Rewrite the original path method
	
	
	  ZImage.prototype.brushVML = function (vmlRoot) {
	    var style = this.style;
	    var image = style.image; // Image original width, height
	
	    var ow;
	    var oh;
	
	    if (isImage(image)) {
	      var src = image.src;
	
	      if (src === this._imageSrc) {
	        ow = this._imageWidth;
	        oh = this._imageHeight;
	      } else {
	        var imageRuntimeStyle = image.runtimeStyle;
	        var oldRuntimeWidth = imageRuntimeStyle.width;
	        var oldRuntimeHeight = imageRuntimeStyle.height;
	        imageRuntimeStyle.width = 'auto';
	        imageRuntimeStyle.height = 'auto'; // get the original size
	
	        ow = image.width;
	        oh = image.height; // and remove overides
	
	        imageRuntimeStyle.width = oldRuntimeWidth;
	        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src
	
	        this._imageSrc = src;
	        this._imageWidth = ow;
	        this._imageHeight = oh;
	      }
	
	      image = src;
	    } else {
	      if (image === this._imageSrc) {
	        ow = this._imageWidth;
	        oh = this._imageHeight;
	      }
	    }
	
	    if (!image) {
	      return;
	    }
	
	    var x = style.x || 0;
	    var y = style.y || 0;
	    var dw = style.width;
	    var dh = style.height;
	    var sw = style.sWidth;
	    var sh = style.sHeight;
	    var sx = style.sx || 0;
	    var sy = style.sy || 0;
	    var hasCrop = sw && sh;
	    var vmlEl = this._vmlEl;
	
	    if (!vmlEl) {
	      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。
	      // vmlEl = vmlCore.createNode('group');
	      vmlEl = vmlCore.doc.createElement('div');
	      initRootElStyle(vmlEl);
	      this._vmlEl = vmlEl;
	    }
	
	    var vmlElStyle = vmlEl.style;
	    var hasRotation = false;
	    var m;
	    var scaleX = 1;
	    var scaleY = 1;
	
	    if (this.transform) {
	      m = this.transform;
	      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
	      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
	      hasRotation = m[1] || m[2];
	    }
	
	    if (hasRotation) {
	      // If filters are necessary (rotation exists), create them
	      // filters are bog-slow, so only create them if abbsolutely necessary
	      // The following check doesn't account for skews (which don't exist
	      // in the canvas spec (yet) anyway.
	      // From excanvas
	      var p0 = [x, y];
	      var p1 = [x + dw, y];
	      var p2 = [x, y + dh];
	      var p3 = [x + dw, y + dh];
	      applyTransform(p0, p0, m);
	      applyTransform(p1, p1, m);
	      applyTransform(p2, p2, m);
	      applyTransform(p3, p3, m);
	      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
	      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
	      var transformFilter = [];
	      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));
	      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用
	
	      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';
	    } else {
	      if (m) {
	        x = x * scaleX + m[4];
	        y = y * scaleY + m[5];
	      }
	
	      vmlElStyle.filter = '';
	      vmlElStyle.left = round(x) + 'px';
	      vmlElStyle.top = round(y) + 'px';
	    }
	
	    var imageEl = this._imageEl;
	    var cropEl = this._cropEl;
	
	    if (!imageEl) {
	      imageEl = vmlCore.doc.createElement('div');
	      this._imageEl = imageEl;
	    }
	
	    var imageELStyle = imageEl.style;
	
	    if (hasCrop) {
	      // Needs know image original width and height
	      if (!(ow && oh)) {
	        var tmpImage = new Image();
	        var self = this;
	
	        tmpImage.onload = function () {
	          tmpImage.onload = null;
	          ow = tmpImage.width;
	          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize
	
	          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src
	
	          self._imageWidth = ow;
	          self._imageHeight = oh;
	          self._imageSrc = image;
	        };
	
	        tmpImage.src = image;
	      } else {
	        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
	      }
	
	      if (!cropEl) {
	        cropEl = vmlCore.doc.createElement('div');
	        cropEl.style.overflow = 'hidden';
	        this._cropEl = cropEl;
	      }
	
	      var cropElStyle = cropEl.style;
	      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
	      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
	      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';
	
	      if (!cropEl.parentNode) {
	        vmlEl.appendChild(cropEl);
	      }
	
	      if (imageEl.parentNode != cropEl) {
	        cropEl.appendChild(imageEl);
	      }
	    } else {
	      imageELStyle.width = round(scaleX * dw) + 'px';
	      imageELStyle.height = round(scaleY * dh) + 'px';
	      vmlEl.appendChild(imageEl);
	
	      if (cropEl && cropEl.parentNode) {
	        vmlEl.removeChild(cropEl);
	        this._cropEl = null;
	      }
	    }
	
	    var filterStr = '';
	    var alpha = style.opacity;
	
	    if (alpha < 1) {
	      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';
	    }
	
	    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';
	    imageELStyle.filter = filterStr;
	    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root
	
	    append(vmlRoot, vmlEl); // Text
	
	    if (style.text != null) {
	      this.drawRectText(vmlRoot, this.getBoundingRect());
	    }
	  };
	
	  ZImage.prototype.onRemove = function (vmlRoot) {
	    remove(vmlRoot, this._vmlEl);
	    this._vmlEl = null;
	    this._cropEl = null;
	    this._imageEl = null;
	    this.removeRectText(vmlRoot);
	  };
	
	  ZImage.prototype.onAdd = function (vmlRoot) {
	    append(vmlRoot, this._vmlEl);
	    this.appendRectText(vmlRoot);
	  };
	  /***************************************************
	   * TEXT
	   **************************************************/
	
	
	  var DEFAULT_STYLE_NORMAL = 'normal';
	  var fontStyleCache = {};
	  var fontStyleCacheCount = 0;
	  var MAX_FONT_CACHE_SIZE = 100;
	  var fontEl = document.createElement('div');
	
	  var getFontStyle = function (fontString) {
	    var fontStyle = fontStyleCache[fontString];
	
	    if (!fontStyle) {
	      // Clear cache
	      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
	        fontStyleCacheCount = 0;
	        fontStyleCache = {};
	      }
	
	      var style = fontEl.style;
	      var fontFamily;
	
	      try {
	        style.font = fontString;
	        fontFamily = style.fontFamily.split(',')[0];
	      } catch (e) {}
	
	      fontStyle = {
	        style: style.fontStyle || DEFAULT_STYLE_NORMAL,
	        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
	        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
	        size: parseFloat(style.fontSize || 12) | 0,
	        family: fontFamily || 'Microsoft YaHei'
	      };
	      fontStyleCache[fontString] = fontStyle;
	      fontStyleCacheCount++;
	    }
	
	    return fontStyle;
	  };
	
	  var textMeasureEl; // Overwrite measure text method
	
	  textContain.$override('measureText', function (text, textFont) {
	    var doc = vmlCore.doc;
	
	    if (!textMeasureEl) {
	      textMeasureEl = doc.createElement('div');
	      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';
	      vmlCore.doc.body.appendChild(textMeasureEl);
	    }
	
	    try {
	      textMeasureEl.style.font = textFont;
	    } catch (ex) {// Ignore failures to set to invalid font.
	    }
	
	    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.
	
	    textMeasureEl.appendChild(doc.createTextNode(text));
	    return {
	      width: textMeasureEl.offsetWidth
	    };
	  });
	  var tmpRect = new BoundingRect();
	
	  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {
	    var style = this.style; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true);
	    var text = style.text; // Convert to string
	
	    text != null && (text += '');
	
	    if (!text) {
	      return;
	    } // Convert rich text to plain text. Rich text is not supported in
	    // IE8-, but tags in rich text template will be removed.
	
	
	    if (style.rich) {
	      var contentBlock = textContain.parseRichText(text, style);
	      text = [];
	
	      for (var i = 0; i < contentBlock.lines.length; i++) {
	        var tokens = contentBlock.lines[i].tokens;
	        var textLine = [];
	
	        for (var j = 0; j < tokens.length; j++) {
	          textLine.push(tokens[j].text);
	        }
	
	        text.push(textLine.join(''));
	      }
	
	      text = text.join('\n');
	    }
	
	    var x;
	    var y;
	    var align = style.textAlign;
	    var verticalAlign = style.textVerticalAlign;
	    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?
	
	    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px "' + fontStyle.family + '"';
	    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign); // Transform rect to view space
	
	    var m = this.transform; // Ignore transform for text in other element
	
	    if (m && !fromTextEl) {
	      tmpRect.copy(rect);
	      tmpRect.applyTransform(m);
	      rect = tmpRect;
	    }
	
	    if (!fromTextEl) {
	      var textPosition = style.textPosition;
	      var distance = style.textDistance; // Text position represented by coord
	
	      if (textPosition instanceof Array) {
	        x = rect.x + parsePercent(textPosition[0], rect.width);
	        y = rect.y + parsePercent(textPosition[1], rect.height);
	        align = align || 'left';
	      } else {
	        var res = textContain.adjustTextPositionOnRect(textPosition, rect, distance);
	        x = res.x;
	        y = res.y; // Default align and baseline when has textPosition
	
	        align = align || res.textAlign;
	        verticalAlign = verticalAlign || res.textVerticalAlign;
	      }
	    } else {
	      x = rect.x;
	      y = rect.y;
	    }
	
	    x = textContain.adjustTextX(x, textRect.width, align);
	    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'
	
	    y += textRect.height / 2; // var fontSize = fontStyle.size;
	    // 1.75 is an arbitrary number, as there is no info about the text baseline
	    // switch (baseline) {
	    // case 'hanging':
	    // case 'top':
	    //     y += fontSize / 1.75;
	    //     break;
	    //     case 'middle':
	    //         break;
	    //     default:
	    //     // case null:
	    //     // case 'alphabetic':
	    //     // case 'ideographic':
	    //     // case 'bottom':
	    //         y -= fontSize / 2.25;
	    //         break;
	    // }
	    // switch (align) {
	    //     case 'left':
	    //         break;
	    //     case 'center':
	    //         x -= textRect.width / 2;
	    //         break;
	    //     case 'right':
	    //         x -= textRect.width;
	    //         break;
	    // case 'end':
	    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';
	    // break;
	    // case 'start':
	    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';
	    // break;
	    // default:
	    //     align = 'left';
	    // }
	
	    var createNode = vmlCore.createNode;
	    var textVmlEl = this._textVmlEl;
	    var pathEl;
	    var textPathEl;
	    var skewEl;
	
	    if (!textVmlEl) {
	      textVmlEl = createNode('line');
	      pathEl = createNode('path');
	      textPathEl = createNode('textpath');
	      skewEl = createNode('skew'); // FIXME Why here is not cammel case
	      // Align 'center' seems wrong
	
	      textPathEl.style['v-text-align'] = 'left';
	      initRootElStyle(textVmlEl);
	      pathEl.textpathok = true;
	      textPathEl.on = true;
	      textVmlEl.from = '0 0';
	      textVmlEl.to = '1000 0.05';
	      append(textVmlEl, skewEl);
	      append(textVmlEl, pathEl);
	      append(textVmlEl, textPathEl);
	      this._textVmlEl = textVmlEl;
	    } else {
	      // 这里是在前面 appendChild 保证顺序的前提下
	      skewEl = textVmlEl.firstChild;
	      pathEl = skewEl.nextSibling;
	      textPathEl = pathEl.nextSibling;
	    }
	
	    var coords = [x, y];
	    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element
	
	    if (m && fromTextEl) {
	      applyTransform(coords, coords, m);
	      skewEl.on = true;
	      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position
	
	      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin
	
	      skewEl.origin = '0 0';
	      textVmlElStyle.left = '0px';
	      textVmlElStyle.top = '0px';
	    } else {
	      skewEl.on = false;
	      textVmlElStyle.left = round(x) + 'px';
	      textVmlElStyle.top = round(y) + 'px';
	    }
	
	    textPathEl.string = encodeHtmlAttribute(text); // TODO
	
	    try {
	      textPathEl.style.font = font;
	    } // Error font format
	    catch (e) {}
	
	    updateFillAndStroke(textVmlEl, 'fill', {
	      fill: style.textFill,
	      opacity: style.opacity
	    }, this);
	    updateFillAndStroke(textVmlEl, 'stroke', {
	      stroke: style.textStroke,
	      opacity: style.opacity,
	      lineDash: style.lineDash
	    }, this);
	    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root
	
	    append(vmlRoot, textVmlEl);
	  };
	
	  var removeRectText = function (vmlRoot) {
	    remove(vmlRoot, this._textVmlEl);
	    this._textVmlEl = null;
	  };
	
	  var appendRectText = function (vmlRoot) {
	    append(vmlRoot, this._textVmlEl);
	  };
	
	  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText
	
	  for (var i = 0; i < list.length; i++) {
	    var proto = list[i].prototype;
	    proto.drawRectText = drawRectText;
	    proto.removeRectText = removeRectText;
	    proto.appendRectText = appendRectText;
	  }
	
	  Text.prototype.brushVML = function (vmlRoot) {
	    var style = this.style;
	
	    if (style.text != null) {
	      this.drawRectText(vmlRoot, {
	        x: style.x || 0,
	        y: style.y || 0,
	        width: 0,
	        height: 0
	      }, this.getBoundingRect(), true);
	    } else {
	      this.removeRectText(vmlRoot);
	    }
	  };
	
	  Text.prototype.onRemove = function (vmlRoot) {
	    this.removeRectText(vmlRoot);
	  };
	
	  Text.prototype.onAdd = function (vmlRoot) {
	    this.appendRectText(vmlRoot);
	  };
	}

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	var env = __webpack_require__(50);
	
	var urn = 'urn:schemas-microsoft-com:vml';
	var win = typeof window === 'undefined' ? null : window;
	var vmlInited = false;
	var doc = win && win.document;
	
	function createNode(tagName) {
	  return doCreateNode(tagName);
	} // Avoid assign to an exported variable, for transforming to cjs.
	
	
	var doCreateNode;
	
	if (doc && !env.canvasSupported) {
	  try {
	    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);
	
	    doCreateNode = function (tagName) {
	      return doc.createElement('<zrvml:' + tagName + ' class="zrvml">');
	    };
	  } catch (e) {
	    doCreateNode = function (tagName) {
	      return doc.createElement('<' + tagName + ' xmlns="' + urn + '" class="zrvml">');
	    };
	  }
	} // From raphael
	
	
	function initVML() {
	  if (vmlInited || !doc) {
	    return;
	  }
	
	  vmlInited = true;
	  var styleSheets = doc.styleSheets;
	
	  if (styleSheets.length < 31) {
	    doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');
	  } else {
	    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
	    styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');
	  }
	}
	
	exports.doc = doc;
	exports.createNode = createNode;
	exports.initVML = initVML;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	var zrLog = __webpack_require__(22);
	
	var vmlCore = __webpack_require__(139);
	
	var _util = __webpack_require__(5);
	
	var each = _util.each;
	
	/**
	 * VML Painter.
	 *
	 * @module zrender/vml/Painter
	 */
	function parseInt10(val) {
	  return parseInt(val, 10);
	}
	/**
	 * @alias module:zrender/vml/Painter
	 */
	
	
	function VMLPainter(root, storage) {
	  vmlCore.initVML();
	  this.root = root;
	  this.storage = storage;
	  var vmlViewport = document.createElement('div');
	  var vmlRoot = document.createElement('div');
	  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';
	  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';
	  root.appendChild(vmlViewport);
	  this._vmlRoot = vmlRoot;
	  this._vmlViewport = vmlViewport;
	  this.resize(); // Modify storage
	
	  var oldDelFromStorage = storage.delFromStorage;
	  var oldAddToStorage = storage.addToStorage;
	
	  storage.delFromStorage = function (el) {
	    oldDelFromStorage.call(storage, el);
	
	    if (el) {
	      el.onRemove && el.onRemove(vmlRoot);
	    }
	  };
	
	  storage.addToStorage = function (el) {
	    // Displayable already has a vml node
	    el.onAdd && el.onAdd(vmlRoot);
	    oldAddToStorage.call(storage, el);
	  };
	
	  this._firstPaint = true;
	}
	
	VMLPainter.prototype = {
	  constructor: VMLPainter,
	  getType: function () {
	    return 'vml';
	  },
	
	  /**
	   * @return {HTMLDivElement}
	   */
	  getViewportRoot: function () {
	    return this._vmlViewport;
	  },
	  getViewportRootOffset: function () {
	    var viewportRoot = this.getViewportRoot();
	
	    if (viewportRoot) {
	      return {
	        offsetLeft: viewportRoot.offsetLeft || 0,
	        offsetTop: viewportRoot.offsetTop || 0
	      };
	    }
	  },
	
	  /**
	   * 刷新
	   */
	  refresh: function () {
	    var list = this.storage.getDisplayList(true, true);
	
	    this._paintList(list);
	  },
	  _paintList: function (list) {
	    var vmlRoot = this._vmlRoot;
	
	    for (var i = 0; i < list.length; i++) {
	      var el = list[i];
	
	      if (el.invisible || el.ignore) {
	        if (!el.__alreadyNotVisible) {
	          el.onRemove(vmlRoot);
	        } // Set as already invisible
	
	
	        el.__alreadyNotVisible = true;
	      } else {
	        if (el.__alreadyNotVisible) {
	          el.onAdd(vmlRoot);
	        }
	
	        el.__alreadyNotVisible = false;
	
	        if (el.__dirty) {
	          el.beforeBrush && el.beforeBrush();
	          (el.brushVML || el.brush).call(el, vmlRoot);
	          el.afterBrush && el.afterBrush();
	        }
	      }
	
	      el.__dirty = false;
	    }
	
	    if (this._firstPaint) {
	      // Detached from document at first time
	      // to avoid page refreshing too many times
	      // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变
	      this._vmlViewport.appendChild(vmlRoot);
	
	      this._firstPaint = false;
	    }
	  },
	  resize: function (width, height) {
	    var width = width == null ? this._getWidth() : width;
	    var height = height == null ? this._getHeight() : height;
	
	    if (this._width != width || this._height != height) {
	      this._width = width;
	      this._height = height;
	      var vmlViewportStyle = this._vmlViewport.style;
	      vmlViewportStyle.width = width + 'px';
	      vmlViewportStyle.height = height + 'px';
	    }
	  },
	  dispose: function () {
	    this.root.innerHTML = '';
	    this._vmlRoot = this._vmlViewport = this.storage = null;
	  },
	  getWidth: function () {
	    return this._width;
	  },
	  getHeight: function () {
	    return this._height;
	  },
	  clear: function () {
	    if (this._vmlViewport) {
	      this.root.removeChild(this._vmlViewport);
	    }
	  },
	  _getWidth: function () {
	    var root = this.root;
	    var stl = root.currentStyle;
	    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;
	  },
	  _getHeight: function () {
	    var root = this.root;
	    var stl = root.currentStyle;
	    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;
	  }
	}; // Not supported methods
	
	function createMethodNotSupport(method) {
	  return function () {
	    zrLog('In IE8.0 VML mode painter not support method "' + method + '"');
	  };
	} // Unsupported methods
	
	
	each(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {
	  VMLPainter.prototype[name] = createMethodNotSupport(name);
	});
	var _default = VMLPainter;
	module.exports = _default;

/***/ })
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA0N2FkZTI2NGIwMWRiMDBmYTExZCIsIndlYnBhY2s6Ly8vLi9pbmRleC5mbG93LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvRmlzaFRvcG9GbG93LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS91dGlsLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdG9vbC9wYXRoLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9FbGVtZW50LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9ndWlkLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9UcmFuc2Zvcm1hYmxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9tYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL0FuaW1hdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQ2xpcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9MUlUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci90ZXh0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi90ZXh0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9pbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvUGF0aFByb3h5LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9jdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvYmJveC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi91dGlsLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi93aW5kaW5nTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0dGVybi5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3Rvb2wvdHJhbnNmb3JtUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9UZXh0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ZpeENsaXBXaXRoU2hhZG93LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9lbnYuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9TdGF0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9taW5pbWFwLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL1BvaW50LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTGluZVN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL0V4dGVuc2lvbkFwaS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3pyZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9IYW5kbGVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvU3RvcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdGltc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL1BhaW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9MYXllci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0aW9uLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL09wZXJhdGlvbk5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Ob2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvSGFuZGxlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0VmZmVjdExpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdGlvblBvaW50LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9jbGF6ei5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvSWNvbk9wZXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL21hbmFnZXIvRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9Db25uZWN0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL0xvZy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL3V0aWwvRmxvd0NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL3V0aWwvRmxvd1V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0dyb3VwTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvZmxvd05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1JlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1NlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvUmluZy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvRWxsaXBzZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvSGVhcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0Ryb3BsZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1Jvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0lzb2dvbi5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvUG9seWdvbi5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvUG9seWxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0JlemllckN1cnZlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9BcmMuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1N0YXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1Ryb2Nob2lkLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9QYXRoLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9JY29uQnV0dG9uLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGluay9mbG93TGluay5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xpbmsvTGluay5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL0Zsb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9saW5rL0ZvbGQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9saW5rL0N1cnZlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGluay9DaGFpbi5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvTGluZU9wZXJhdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvbGF5b3V0LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L0hMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvVkxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xheW91dC9UcmVlTGF5b3V0LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvZGF0YS9UcmVlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L3RyZWVIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvRm9yY2VMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvZm9yY2VIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9JbWFnZVBvb2wuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi90b29sdGlwL1Rvb2x0aXBWaWV3LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvdG9vbHRpcC9Ub29sdGlwQ29udGVudC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL3Rvb2x0aXAvZ2xvYmFsTGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi90b29sdGlwL1Rvb2x0aXBNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3ZtbC92bWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi92bWwvZ3JhcGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3ZtbC9jb3JlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdm1sL1BhaW50ZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUE4RSxXQUFXO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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TztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNB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QSxjQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FB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QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsNEJBQTRCO0FBQ3ZDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyw0QkFBNEI7QUFDdkMsWUFBVyw0QkFBNEI7QUFDdkM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLDRCQUE0QjtBQUN2QyxZQUFXLDRCQUE0QjtBQUN2QyxZQUFXLDRCQUE0QjtBQUN2Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsNEJBQTRCO0FBQ3ZDLFlBQVcsNEJBQTRCO0FBQ3ZDLFlBQVcsNEJBQTRCO0FBQ3ZDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyw0QkFBNEI7QUFDdkMsWUFBVyw0QkFBNEI7QUFDdkMsWUFBVyxPQUFPO0FBQ2xCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsNEJBQTRCO0FBQ3ZDLFlBQVcsNEJBQTRCO0FBQ3ZDLFlBQVcsNEJBQTRCO0FBQ3ZDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsNEJBQTRCO0FBQ3ZDLFlBQVcsNEJBQTRCO0FBQ3ZDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLGVBQWU7QUFDMUIsYUFBWTtBQUNaO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7OztBQUdILDRCQUEyQjs7QUFFM0Isc0RBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNB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TztBQUNsQixhQUFZLDBDQUEwQztBQUN0RDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixpQ0FBaUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUM7Ozs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQjs7Ozs7O0FDaEZBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsU0FBUztBQUM3QixxQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLGlDQUFpQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSTs7Ozs7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCLE9BQU87QUFDeEIsa0JBQWlCLE9BQU87QUFDeEIsa0JBQWlCLE9BQU87QUFDeEIsa0JBQWlCLE9BQU87QUFDeEIsa0JBQWlCLE9BQU87QUFDeEIsa0JBQWlCLE9BQU87QUFDeEIsa0JBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRCxvQkFBb0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixxQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixxQkFBb0IsUUFBUTtBQUM1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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsNEJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBc0Q7QUFDdEQsY0FBYTtBQUNiLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCLHVDQUF1QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7Ozs7OztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUErRSxXQUFXO0FBQzFGO0FBQ0E7QUFDQSw2QkFBNEIsbUJBQW1CO0FBQy9DLDhCQUE2QjtBQUM3QixtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQSwyQ0FBMEMsT0FBTztBQUNqRCxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0EsMEJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEk7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUErRSxXQUFXO0FBQzFGO0FBQ0E7QUFDQSw2QkFBNEIsbUJBQW1CO0FBQy9DLDhCQUE2QjtBQUM3QixtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQSwyQ0FBMEMsT0FBTztBQUNqRCxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQSwwQkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJOzs7Ozs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsUUFBUTtBQUNqQywwQkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0EsK0JBQThCLGNBQWM7QUFDNUMsK0JBQThCLGNBQWM7QUFDNUMsK0JBQThCLGNBQWM7QUFDNUMsK0JBQThCLGNBQWM7QUFDNUMsK0JBQThCLGNBQWM7QUFDNUMsK0JBQThCO0FBQzlCO0FBQ0EsdUJBQXNCO0FBQ3RCLHVCQUFzQjtBQUN0QjtBQUNBLCtCQUE4QixjQUFjO0FBQzVDLCtCQUE4QixjQUFjO0FBQzVDLHVCQUFzQjtBQUN0Qix1QkFBc0I7QUFDdEI7QUFDQSwrQkFBOEIsY0FBYztBQUM1QywrQkFBOEIsZUFBZTtBQUM3QywrQkFBOEIsZUFBZTtBQUM3QywrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLGlCQUFpQjtBQUM1QztBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQW1EO0FBQ25ELHVEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsMEJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBLDBCQUF5QixPQUFPO0FBQ2hDLDBCQUF5QixjQUFjO0FBQ3ZDLDBCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQSwwQkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0EsMEJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBLHlCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSwwQkFBeUIsT0FBTyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxhQUFhO0FBQ2hEO0FBQ0EsaUNBQWdDLDBCQUEwQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixPQUFPO0FBQzlCLHlCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSw2RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQSx1Q0FBc0Msb0JBQW9CO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixPQUFPO0FBQzlCLHdCQUF1QixTQUFTO0FBQ2hDLHdCQUF1QixPQUFPO0FBQzlCLHdCQUF1QixRQUFRO0FBQy9CLHlCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUF5RCwwSEFBMEg7QUFDbkw7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSw2QkFBNEIsUUFBUTtBQUNwQyw2QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQSw4RUFBNkUsaUJBQWlCO0FBQzlGO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLE9BQU87QUFDOUIsd0JBQXVCLE9BQU87QUFDOUIsd0JBQXVCLFNBQVM7QUFDaEMseUJBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLE9BQU87QUFDOUIseUJBQXdCLE87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsT0FBTztBQUM5Qix5QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFpRTtBQUNqRSxrQkFBaUI7O0FBRWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixPQUFPO0FBQzlCLHlCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFxRTtBQUNyRTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQSx3REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLGtCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsT0FBTztBQUM5Qix3QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSTs7Ozs7OztBQ2xqQkE7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixTQUFTO0FBQ3pCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLFNBQVM7QUFDekIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLGlCQUFpQjtBQUN4QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSwwREFBeUQ7QUFDekQ7QUFDQTtBQUNBLGNBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBLDRCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQzlQQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0MsOEJBQThCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBK0UsV0FBVztBQUMxRjtBQUNBO0FBQ0EsMEJBQXlCLFFBQVE7QUFDakMsMEJBQXlCLGtCQUFrQjtBQUMzQztBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQiwrQkFBOEIsWUFBWTtBQUMxQywrQkFBOEIsWUFBWTtBQUMxQywrQkFBOEIsWUFBWTtBQUMxQywrQkFBOEIsWUFBWTtBQUMxQywrQkFBOEIsWUFBWTtBQUMxQywrQkFBOEIsWUFBWTtBQUMxQywrQkFBOEIsWUFBWTtBQUMxQywrQkFBOEI7QUFDOUI7QUFDQTtBQUNBLCtCQUE4QiwyQkFBMkI7QUFDekQsK0JBQThCLDJCQUEyQjtBQUN6RCwrQkFBOEIsMkJBQTJCO0FBQ3pELCtCQUE4QiwyQkFBMkI7QUFDekQsK0JBQThCLDJCQUEyQjtBQUN6RCwrQkFBOEIsMkJBQTJCO0FBQ3pELCtCQUE4QjtBQUM5QjtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0Esa0JBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSxrQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QjtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCLGtCQUFpQixPQUFPO0FBQ3hCLGtCQUFpQixPQUFPO0FBQ3hCLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSxrQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0Esa0JBQWlCLE9BQU8sdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsMkVBQTJFO0FBQzlGLHlCQUF3QixRQUFRLGFBQWE7QUFDN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsU0FBUztBQUN4QixnQkFBZSxTQUFTO0FBQ3hCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBb0IsUUFBUTtBQUM1QixxQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxjQUFjLGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0EscURBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLDhEQUE2RDtBQUM3RDtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOzs7Ozs7Ozs7QUNwU0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQixVQUFVO0FBQ3pDO0FBQ0Esd0NBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsU0FBUztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksZ0NBQWdDO0FBQzVDO0FBQ0EsWUFBVyxtQkFBbUIsc0NBQXNDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUN0SUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFtQixNQUFNLElBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBc0IsT0FBTyxjQUFjO0FBQzNDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7Ozs7O0FDeEVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlDOzs7Ozs7QUNSQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMEMsT0FBTyxNQUFNLFVBQVUsV0FBVztBQUM1RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBeUMsd0JBQXdCO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBLDJCIiwiZmlsZSI6ImZpc2hUb3BvRmxvdy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImZpc2hUb3BvRmxvd1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJmaXNoVG9wb0Zsb3dcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNDdhZGUyNjRiMDFkYjAwZmExMWQiLCIvKipcclxuICogRXhwb3J0IGZpc2hUb3BvIGFzIENvbW1vbkpTIG1vZHVsZVxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvRmlzaFRvcG9GbG93LmpzJyk7XHJcbi8v5YW85a65SUU4IOW8leWFpVZNTCDlpoLmnpzkuI3pnIDopoHlhbzlrrlJRTjor7fliKDpmaRcclxucmVxdWlyZSgnenJlbmRlci9saWIvdm1sL3ZtbCcpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2luZGV4LmZsb3cuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIGZpc2h0b3Bv5rWB56iL5a6e5L6LXHJcbiAqIEBjbGFzcyBmaXNoLnRvcG8uRmlzaFRvcG9GbG93XHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGNsaWNrXHJcbiAqIOiKgueCueaIluiAhee6v+auteeahGNsaWNr5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7YgZXZlbnQudGFyZ2V05Li655uu5qCH5a+56LGhIGV2ZW50LnRhcmdldC5tb2RlbOS4uuebruagh+WvueixoeeahOS4muWKoeaVsOaNrlxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgICAgdGhpcy5maXNoVG9wby5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAqICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIueCueWHu+eahOaYr++8mlwiICsgZXZlbnQudGFyZ2V0Lm1vZGVsLmdldCgnZWxlbWVudFR5cGUnKSk7XHJcbiAqICAgICAgICAgIH0pO1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgZGJsY2xpY2tcclxuICog6IqC54K55oiW6ICF57q/5q6155qE5Y+M5Ye75LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7YgZXZlbnQudGFyZ2V05Li655uu5qCH5a+56LGhIGV2ZW50LnRhcmdldC5tb2RlbOS4uuebruagh+WvueixoeeahOS4muWKoeaVsOaNrlxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgICAgdGhpcy5maXNoVG9wby5vbihcImRibGNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAqICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuWPjOWHu+eahOaYr++8mlwiICsgZXZlbnQudGFyZ2V0Lm1vZGVsLmdldCgnZWxlbWVudFR5cGUnKSk7XHJcbiAqICAgICAgICAgIH0pO1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgY3JlYXRlXHJcbiAqIOiKgueCueS4jue6v+auteWIm+W7uuWujOavleeahOS6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2IGV2ZW50LnRhcmdldOS4uuebruagh+WvueixoSBldmVudC50YXJnZXQubW9kZWzkuLrnm67moIflr7nosaHnmoTkuJrliqHmlbDmja5cclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgICAgIHRoaXMuZmlzaFRvcG8ub24oXCJjcmVhdGVcIiwgZnVuY3Rpb24oZSkge1xyXG4gKiAgICAgICAgICAgICAgIGlmIChtZS5maXNoVG9wby5GbG93LmlzTGluayhlLnRhcmdldC5tb2RlbCkpIHtcclxuICogICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIue6v+auteWIm+W7uuWujOavle+8mlwiICsgZS50YXJnZXQubW9kZWwpO1xyXG4gKiAgICAgICAgICAgICAgIH1cclxuICogICAgICAgICAgfSk7XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBkZWxldGVcclxuICog6IqC54K55LiO57q/5q615Yib5bu65a6M5q+V55qE5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7YgZXZlbnQudGFyZ2V05Li655uu5qCH5a+56LGhIGV2ZW50LnRhcmdldC5tb2RlbOS4uuebruagh+WvueixoeeahOS4muWKoeaVsOaNrlxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgICAgLy/oioLngrnliKDpmaTlrozmr5Xkuovku7ZcclxuICogICAgICAgICAgdGhpcy5maXNoVG9wby5vbihcImRlbGV0ZVwiLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLliKDpmaTnmoTmmK/vvJpcIiArIGV2ZW50LnRhcmdldC5tb2RlbC5nZXQoJ2VsZW1lbnRUeXBlJykpO1xyXG4gKiAgICAgICAgICB9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGRyb3BEcmFnXHJcbiAqIOiKgueCueenu+WKqOWujOaIkOeahOS6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2IGV2ZW50LnRhcmdldOS4uuebruagh+WvueixoSBldmVudC50YXJnZXQubW9kZWzkuLrnm67moIflr7nosaHnmoTkuJrliqHmlbDmja5cclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgICAgIC8v6IqC54K556e75Yqo57uT5p2f5LqL5Lu2XHJcbiAgICAgICAgICAgIHRoaXMuZmlzaFRvcG8ub24oXCJkcm9wRHJhZ1wiLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLnp7vliqjnmoToioLngrnmmK/vvJpcIitldmVudC50YXJnZXQubW9kZWwuZ2V0KCdlbGVtZW50VHlwZScpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAqL1xyXG5cclxuXHJcblxyXG5cclxuICAgIHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvcG9seWZpbGwuanNcIik7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBNaW5pbWFwID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9taW5pbWFwLmpzXCIpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgUG9pbnQgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIEV4dGVuc2lvbkFQSSA9IHJlcXVpcmUoJy4vRXh0ZW5zaW9uQXBpJyk7XHJcbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bCcpO1xyXG4gICAgdmFyIHpyZW5kZXIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi96cmVuZGVyJyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgT3BlcmF0aW9uTm9kZSA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9PcGVyYXRpb25Ob2RlLmpzXCIpO1xyXG4gICAgdmFyIEZsb3dDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuL21hbmFnZXIvRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLmpzXCIpO1xyXG4gICAgdmFyIEZsb3dVdGlsID0gcmVxdWlyZShcIi4vdXRpbC9GbG93VXRpbC5qc1wiKTtcclxuICAgIHZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi91dGlsL0Zsb3dDb25zdGFudHMuanNcIik7XHJcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21vZGVsLmpzXCIpO1xyXG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQnKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgTGluZU9wZXJhdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvTGluZU9wZXJhdGlvbk1hbmFnZXIuanNcIik7XHJcbiAgICB2YXIgRmxvdyA9IHJlcXVpcmUoXCIuL0Zsb3cuanNcIik7XHJcbiAgICB2YXIgZmxvd05vZGUgPSByZXF1aXJlKFwiLi9ub2RlL2Zsb3dOb2RlXCIpO1xyXG4gICAgdmFyIEdyb3VwTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvR3JvdXBOb2RlXCIpO1xyXG4gICAgdmFyIGZsb3dMaW5rID0gcmVxdWlyZShcIi4vbGluay9mbG93TGlua1wiKTtcclxuICAgIHZhciBsYXlvdXQgPSByZXF1aXJlKFwiLi9sYXlvdXQvbGF5b3V0XCIpO1xyXG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29udGFpbi90ZXh0Jyk7XHJcbiAgICB2YXIgSW1hZ2VQb29sID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9JbWFnZVBvb2wuanNcIik7XHJcbiAgICB2YXIgVG9vbFRpcFZpZXcgPSByZXF1aXJlKFwiLi90b29sdGlwL1Rvb2x0aXBWaWV3XCIpO1xyXG4gICAgdmFyIFRvb2x0aXBNb2RlbCA9IHJlcXVpcmUoXCIuL3Rvb2x0aXAvVG9vbHRpcE1vZGVsXCIpO1xyXG4gICAgdmFyIGFjdGlvbnMgPSB7fTtcclxuICAgIHZhciBrZXlDb2RlID0ge0VOVEVSOjEzLCBFU0NBUEU6Mjd9XHJcbiAgICBmdW5jdGlvbiBGaXNoVG9wb0Zsb3coZG9tLCBvcHRzKSB7XHJcbiAgICAgICAgdGhpcy5pZDtcclxuICAgICAgICB0aGlzLmdyb3VwID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9kb20gPSBkb207XHJcbiAgICAgICAgdGhpcy5ub3dab29tID0gMTtcclxuICAgICAgICB0aGlzLmNhblNjYWxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmVhZ2xlRXllID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lYWdsZUV5ZU5vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5pdFNjYWxlUmF0aW8gPSAxO1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGVwID0gMDsvL+WJjei/m+WQjumAgOiuoeatpeaVsFxyXG4gICAgICAgIHRoaXMuc3RlcEpzb24gPSBbXTsvL+WtmOaUvuavj+atpeeahGpzb25cclxuICAgICAgICB0aGlzLnNlbGVjdGVkTm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hbGxOb2RlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubWluaW1hcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fYXBpID0gbmV3IEV4dGVuc2lvbkFQSSh0aGlzKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IEZsb3dDb25uZWN0aW9uTWFuYWdlcih0aGlzLl9hcGkpO1xyXG4gICAgICAgIHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIgPSBuZXcgTGluZU9wZXJhdGlvbk1hbmFnZXIodGhpcy5jb25uZWN0aW9uTWFuYWdlcix0aGlzLl9hcGkpO1xyXG4gICAgICAgIHRoaXMuX3pyID0genJlbmRlci5pbml0KGRvbSwge1xyXG4gICAgICAgICAgICByZW5kZXJlcjogb3B0cy5yZW5kZXJlciB8fCAnY2FudmFzJyxcclxuICAgICAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogb3B0cy5kZXZpY2VQaXhlbFJhdGlvXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fdG9vbHRpcFZpZXcgPSBuZXcgVG9vbFRpcFZpZXcobmV3IFRvb2x0aXBNb2RlbChvcHRzLnRvb2x0aXApLHRoaXMuX2FwaSk7XHJcbiAgICAgICAgdGhpcy5TaGFwZSA9IGdyYXBoaWM7XHJcbiAgICAgICAgdGhpcy5saW5lT3B0ID0ge307ICAvL+WIneWni+eahOe6v+autemFjee9ruS/oeaBr1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWROb2RlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBuZXcgTW9kZWwoe30pO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KENvbnN0YW50cy5FTEVNRU5UX1RZUEUsIFwic2NlbmVcIik7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoQ29uc3RhbnRzLk1PREUsIFwibm9ybWFsXCIpO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdHM7XHJcbiAgICAgICAgdGhpcy5jdXJzb3JNYXAgPSB7XHJcbiAgICAgICAgICAgIHRsOiAnbnctcmVzaXplJyxcclxuICAgICAgICAgICAgdHI6ICduZS1yZXNpemUnLFxyXG4gICAgICAgICAgICBibDogJ3N3LXJlc2l6ZScsXHJcbiAgICAgICAgICAgIGJyOiAnc2UtcmVzaXplJyxcclxuICAgICAgICAgICAgbXRyOid1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCUUFBQUFVQ0FNQUFBQzZWKzAvQUFBQVlGQk1WRVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRDZUK2lOQUFBQUgzUlNUbE1BN3NVTW9ZWG5Fa1lZemFhVGpRaUFRQ3dlQmNHN2Z2blVMaDJaZGpNeTZGemQ3d0FBQUxKSlJFRlVHTk4xa0ZrT3d6QUlCUUh2Vy9ZNlNiZmMvNVkxbHRxb2xqSWYyQm9oQkE4cVUwOTZ4ZVY1TC8rdUZINFNwc0dBR1NLbVRoQ3lNejY0VWQzOFRlMG1lSXBIY1RQMW5kVEt2cXpTVXVRSUxGTVFKQVV3SW5nQkxDZDBVckpoU1JHcXpISFUzRmNIQlZNb2txeFMzOFlOR1FMUWJobWdaWjIzc1ZFWG5YVm1TNDY3RnEwODkyU1NMYVc1U0hyTjlyejliWHY5RUhJQitFOXBkTUc3WXM0OFoyY2p4bzdGTDNrOGtQSUUxM3dBbUVVSU8yTUw5WU1BQUFBQVNVVk9SSzVDWUlJPSkgMTAgMTAsIGF1dG8nXHJcbiAgICAgICAgfTsgLy8g6IqC54K55o6n5Yi254K56byg5qCH5L+h5oGvKOS4iuW3pu+8jOS4iuWPs++8jOS4i+W3pu+8jOS4i+WPs++8jOaXi+i9rClcclxuICAgICAgICB0aGlzLmN1cnNvck1hcHMgPSBbXHJcbiAgICAgICAgICAgICduLXJlc2l6ZScsXHJcbiAgICAgICAgICAgICduZS1yZXNpemUnLFxyXG4gICAgICAgICAgICAnZS1yZXNpemUnLFxyXG4gICAgICAgICAgICAnc2UtcmVzaXplJyxcclxuICAgICAgICAgICAgJ3MtcmVzaXplJyxcclxuICAgICAgICAgICAgJ3N3LXJlc2l6ZScsXHJcbiAgICAgICAgICAgICd3LXJlc2l6ZScsXHJcbiAgICAgICAgICAgICdudy1yZXNpemUnXHJcbiAgICAgICAgXVxyXG4gICAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0ID0ge1xyXG4gICAgICAgICAgICB0cjogMSxcclxuICAgICAgICAgICAgYnI6IDMsXHJcbiAgICAgICAgICAgIGJsOiA1LFxyXG4gICAgICAgICAgICB0bDogN1xyXG4gICAgICAgIH1cclxuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmaXNoVG9wb1Byb3RvID0gRmlzaFRvcG9GbG93LnByb3RvdHlwZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPliBmaXNoVG9wbyDlrp7kvovlrrnlmajnmoQgZG9tIOiKgueCuVxyXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZ2V0RG9tID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kb207XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5nZXRaciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fenI7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5YgZmlzaFRvcG8g5a6e5L6L5a655Zmo55qE5a695bqm44CCXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pyLmdldFdpZHRoKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+WIGZpc2hUb3BvIOWunuS+i+WuueWZqOeahOmrmOW6puOAglxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fenIuZ2V0SGVpZ2h0KCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOW9k+WJjeWunuS+i+aYr+WQpuW3sue7j+iiq+mHiuaUvuOAglxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5pc0Rpc3Bvc2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDph4rmlL4g5b2T5YmN5a6e5L6LXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuX3pyLmRpc3Bvc2UoKTtcclxuXHJcbiAgICAgICAgaW5zdGFuY2VzW3RoaXMuaWRdID0gbnVsbDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6LCD5pW05bC65a+4ICDlnKjnqpflj6PlpKflsI/lj5HnlJ/mlLnlj5jml7bpnIDopoHmiYvlt6XosIPnlKhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCDlrr3luqZcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQg6auY5bqmXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8ucmVzaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3pyLnJlc2l6ZSgpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5kaXNwYXRjaEFjdGlvbiA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XHJcbiAgICAgICAgaWYoIWFjdGlvbnNbcGF5bG9hZC50eXBlXSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBvcHRpb25cclxuICAgICAqIOS/ruaUueeUu+W4g+eahOmAiemhuVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSDplK4gIOWmgu+8mnJvYW0gbGlua01vZGlmeSAgdGV4dEVkaXRhYmxl562JXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfEZ1bmN0aW9ufSB2YWx1ZSDpgInpobnlgLxcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5vcHRpb24gPSBmdW5jdGlvbihrZXksdmFsdWUpIHtcclxuICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwodGhpcy5vcHRpb25zKTtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4genJVdGlsLmNsb25lKHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb2RlbC5nZXQoa2V5KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJyb2FtXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Um9hbSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1vZGVsLnNldChrZXksdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgTU9VU0VfRVZFTlRfTkFNRVMgPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgPyBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJ10gOiBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCddO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAubW9kZWwgPSB0aGlzLm1vZGVsO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAuaXNCZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fenIuYWRkKHRoaXMuZ3JvdXApO1xyXG5cclxuICAgICAgICAvL+aYr+WQpuWFgeiuuOm8oOagh+a7mui9ruaUvuWkp+e8qeWwj1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucm9hbSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnpyU2NhbGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycyA9IFtdO1xyXG4gICAgICAgIC8vbW91c2V1cCDkvJrlnKjlkITkuKpub2Rl5oiW57q/55qEY2xpY2vkuovku7bkuYvngrnmiafooYwgIOWcqOmAieS4reiKgueCueaIlue6v+WJjSDlhYjmuIXnqbrpgInkuK3mlYjmnpxcclxuICAgICAgICB0aGlzLl96ci5vbihcIm1vdXNldXBcIiwgZnVuY3Rpb24gKGUpIHsgLy8gY2xlYXJTZWxlY3RcclxuICAgICAgICAgICAgLy8gMS4g5riF56m66IqC54K555qE6YCJ5Lit5pWI5p6cXHJcbiAgICAgICAgICAgIC8vIHRoaXMuX3JlbW92ZU9wZXJhdGlvbk5vZGUoKTtcclxuICAgICAgICAgICAgLy8gMi4g54K55Ye755qE57q/IO+8jOWImeebtOaOpei/lOWbnlxyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBlLnRhcmdldDtcclxuICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLm1vZGVsICYmIEZsb3cuaXNMaW5rKHNoYXBlLm1vZGVsKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5jb25uZWN0b3IgaW5zdGFuY2VvZiBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAzLiDmuIXnqbrov57mjqXnur9cclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jbGVhclNlbGVjdENvbigpO1xyXG4gICAgICAgICAgICAvLyA0LiDngrnlh7vnmoTmmK/nur/kuIrmk43kvZzmjInpkq7vvIzliJnnm7TmjqXov5Tlm55cclxuICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLl9pc0xpbmVPcGVyYXRpb25JY29uICYmIHNoYXBlLl9pc0xpbmVPcGVyYXRpb25JY29uID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyA1LumakOiXj+e6v+S4iuaTjeS9nOWbvuagh1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmhpZGVBbGxMaW5lT3BlcmF0aW9uKCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgdGhpcy5fenIub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvLyDlpoLmnpzngrnlh7vkuobmjqfliLbngrnvvIzliJnkuI3kvJrlj5bmtojpgInkuK3nirbmgIEo5o6n5Yi254K55LiN5Zyo6IqC54K56IyD5Zu05YaFKVxyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwge307XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGFyZ2V0LnR5cGU7XHJcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSAnQ29ubmVjdENvbnRyb2xMaW5lJyAmJiB0eXBlICE9PSAnQ29ubmVjdENvbnRyb2wnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JQb2ludCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlQ29ubmVjdG9yQ29udHJvbCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlT3BlcmF0aW9uTm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVUYXJnZXQgPSBlLnRhcmdldDtcclxuICAgICAgICAgICAgICAgIHZhciBzaGFwZTtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUgPSBub2RlVGFyZ2V0Lm1vZGVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChub2RlVGFyZ2V0ICYmIHNoYXBlICYmIEZsb3cuaXNMaW5rKHNoYXBlKSkgfHwgKG5vZGVUYXJnZXQgJiYgc2hhcGUgJiYgRmxvdy5pc05vZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiY2xpY2tcIjtcclxuICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIC8vIG1vdXNlTW9kZee7n+S4gOWcqG1vdXNlZG93buS6i+S7tumHjOWIpOaWrVxyXG4gICAgICAgIHRoaXMuX3pyLm9uKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubW91c2VNb2RlID09PSAnZHJhZy1zZWxlY3QnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGUudGFyZ2V0ICYmIGUudGFyZ2V0Lm1vZGVsKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChlLnRhcmdldCAmJiBlLnRhcmdldC5saW5lVHlwZSAmJiBlLnRhcmdldC5wYXJlbnQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGUudGFyZ2V0ICYmIGUudGFyZ2V0LmNvbm5lY3RvciBpbnN0YW5jZW9mIENvbm5lY3RvcikgfHxcclxuICAgICAgICAgICAgICAgICAgICAoZS50YXJnZXQgJiYgZS50YXJnZXQgaW5zdGFuY2VvZiBncmFwaGljLkNpcmNsZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoZS50YXJnZXQgJiYgZS50YXJnZXQubmFtZSA9PT0gXCJHUk9VUF9SRUNUX05BTUVcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlQ29ubmVjdG9yQ29udHJvbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZU9wZXJhdGlvbk5vZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnU2VsZWN0KGUudGFyZ2V0LCBlLm9mZnNldFgsIGUub2Zmc2V0WSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubW91c2VNb2RlID09PSAnZHJhZy1tb3ZlJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKChlLnRhcmdldCAmJiBlLnRhcmdldC5tb2RlbCkgfHwgKGUudGFyZ2V0ICYmIGUudGFyZ2V0LmxpbmVUeXBlICYmIGUudGFyZ2V0LnBhcmVudCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoZS50YXJnZXQgJiYgZS50YXJnZXQuY29ubmVjdG9yIGluc3RhbmNlb2YgQ29ubmVjdG9yKSB8fCAoZS50YXJnZXQgJiYgZS50YXJnZXQgaW5zdGFuY2VvZiBncmFwaGljXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5DaXJjbGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncm91cERyYWdIYW5kbGVyKGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIHRoaXMub24oJ2NvblBvaW50c0dyb3VwOmNsaWNrJywgZnVuY3Rpb24gKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIuYmluZE9wZXJhdGlvbihhcmd1bWVudC5saW5lTm9kZSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uIChldmVOYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3pyLm9uKGV2ZU5hbWUsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5qdWRnZUlmUmVhZE1vZGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IGV2ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5zZXRSb2FtID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fenIub2ZmKFwibW91c2V3aGVlbFwiKTsvL+emgeatoueUqOaIt+e8qeaUvueUu+W4g1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnpyU2NhbGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5hZGRHcm91cE1vZGVsID0gZnVuY3Rpb24gKGdyb3VwTm9kZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBncm91cE5vZGUuZWFjaENoaWxkKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLm1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEdyb3VwTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm1vZGVsICYmICFub2RlLm1vZGVsLm9wdGlvbi5jaGlsZHMgJiYgbm9kZS5jaGlsZHJlbigpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLm1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSBpbnN0YW5jZW9mIEdyb3VwTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZS5tb2RlbC5vcHRpb24uY2hpbGRzICYmIGNoaWxkTm9kZS5jaGlsZHJlbigpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkR3JvdXBNb2RlbChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHMucHVzaChjaGlsZE5vZGUubW9kZWwub3B0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1vZGVsLm9wdGlvbi5jaGlsZHMgPSBjaGlsZHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHRvSnNvblxyXG4gICAgICog5a+85Ye6anNvblxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBqc29u5a+56LGhXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8udG9Kc29uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWRkR3JvdXBNb2RlbCh0aGlzLmdyb3VwKTtcclxuICAgICAgICByZXR1cm4gRmxvd1V0aWwudG9Kc29uKHRoaXMubW9kZWwsIHRoaXMuZ3JvdXApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBmcm9tSnNvblxyXG4gICAgICog5a+85YWlanNvblxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBqc29u5a+56LGhXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzTm9Db3VudCDmmK/lkKbpnIDopoFzdGVw6K6h5pWw77yM6buY6K6k5piv6ZyA6KaB6K6h5pWwXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZnJvbUpzb24gPSBmdW5jdGlvbiAoanNvbiwgaXNOb0NvdW50KSB7XHJcbiAgICAgICAgdGhpcy5jbGVhcih0cnVlKTtcclxuICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoanNvbik7XHJcbiAgICAgICAgdGhpcy5zZXRCYWNrZ3JvdW5kKG1vZGVsLmdldChDb25zdGFudHMuQkFDS0dST1VORCkpO1xyXG4gICAgICAgIHZhciBsYXlvdXRSb290Tm9kZSA9IFtdO1xyXG4gICAgICAgIEZsb3dVdGlsLmZyb21Kc29uKHRoaXMsIHRoaXMuZ3JvdXAsIG1vZGVsLmdldChDb25zdGFudHMuQ0hJTERTKSwgZmFsc2UsIGxheW91dFJvb3ROb2RlLCBpc05vQ291bnQpO1xyXG4gICAgICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0Um9vdE5vZGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyAgICAgdGhpcy5sYXlvdXROb2RlKFwidHJlZVwiLCB7XHJcbiAgICAgICAgLy8gICAgICAgICBcIm5vZGVcIjogbGF5b3V0Um9vdE5vZGVbaV0sXHJcbiAgICAgICAgLy8gICAgICAgICBcInR5cGVcIjogbGF5b3V0Um9vdE5vZGVbaV0udHJlZVR5cGVcclxuICAgICAgICAvLyAgICAgfSk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6YCS5b2S5Yid5aeL5YyW57uE6IqC54K555qE5LqL5Lu2XHJcbiAgICAgKiBAbWV0aG9kIGFkZEdyb3VwTm9kZUV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBncm91cOiKgueCueWvueixoVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZEdyb3VwTm9kZUV2ZW50ID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBpZiAoRmxvdy5pc0dyb3VwTm9kZShub2RlKSkge1xyXG4gICAgICAgICAgICBub2RlLndpbGxSZW5kZXIodGhpcy5fYXBpKTtcclxuICAgICAgICAgICAgdmFyIGdyb3VwT3B0aW9ucyA9IG5vZGUubW9kZWwuZ2V0KENvbnN0YW50cy5PUFRJT05TKTtcclxuICAgICAgICAgICAgaWYgKGdyb3VwT3B0aW9ucy5tZXJnZWRJbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlT2JqID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiBncm91cE9wdGlvbnMubWVyZ2VkSW1hZ2VcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBPcHRpb25zLnN0eWxlICYmIGdyb3VwT3B0aW9ucy5zdHlsZS50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVPYmoudGV4dCA9IGdyb3VwT3B0aW9ucy5zdHlsZS50ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlT2JqLnRleHRQb3NpdGlvbiA9ICdib3R0b20nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3R5bGVPYmoud2lkdGggPSAzMDtcclxuICAgICAgICAgICAgICAgIHN0eWxlT2JqLmhlaWdodCA9IDMwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwUmVwbGFjZUltYWdlID0gbmV3IGZsb3dOb2RlLkltYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnR1JPVVBfUkVMQVRJT05fSU1BR0UnLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRHcm91cElkOiBub2RlLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZU9iaixcclxuICAgICAgICAgICAgICAgICAgICB6OiBub2RlLnogfHwgNCxcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogWy01MDAwLCAtNTAwMF1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnKGdyb3VwUmVwbGFjZUltYWdlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUuX3JlbGF0aW9uSW1hZ2UgPSBncm91cFJlcGxhY2VJbWFnZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKGdyb3VwUmVwbGFjZUltYWdlKTtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUmVwbGFjZUltYWdlLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIH0sIDMwMCk7XHJcbiAgICAgICAgICAgICAgICBub2RlLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOWOu+mZpOmAieS4reeKtuaAgVxyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5oaWRlQ29ubmVjdG9yQ29udHJvbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX3JlbW92ZU9wZXJhdGlvbk5vZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDljrvpmaTnu4ToioLngrnnm7jlhbPnmoTov57nur9cclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnRvZ2dsZUFsbENvbk5vZGVMaW5lKG5vZGUsICdoaWRlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tZXJnZWQodGhhdCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8v6YGN5Y6G57uE5Lit5omA5pyJ6IqC54K5XHJcbiAgICAgICAgICAgIG5vZGUuZWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChGbG93LmlzR3JvdXBOb2RlKGNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkR3JvdXBOb2RlRXZlbnQoY2hpbGQpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEdyb3VwTm9kZShub2RlLGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkTm9kZUF0dHJFdmVudChub2RlLCB0cnVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5re75Yqg6IqC54K55oiW57q/5q615Yiw55S75biDIOWQjGFkZOaWueazlVxyXG4gICAgICogQG1ldGhvZCBhZGROb2RlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBjcmVhdGVOb2Rl5oiWY3JlYXRlTGlua+i/lOWbnueahOWvueixoVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25dIOWPguaVsOWvueixoVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9uLnRyaWdnZXJdIOaYr+WQpuinpuWPkSBiZWZvcmVDcmVhdGXkuovku7ZcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IOi/lOWbnua3u+WKoOaIkOWKn+eahOiKgueCuSDvvIzlpoLooqvnlKjmiLflj5bmtojkuYvnsbvliJkg6L+U5ZuebnVsbFxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIOa3u+WKoOiKgueCueaIlue6v+auteWIsOeUu+W4gyDlkIxhZGROb2Rl5pa55rOVXHJcbiAgICAgKiBAbWV0aG9kIGFkZFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgY3JlYXRlTm9kZeaIlmNyZWF0ZUxpbmvov5Tlm57nmoTlr7nosaFcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uXSDlj4LmlbDlr7nosaFcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNOb0NvdW50IOaYr+WQpumcgOimgXN0ZXDorqHmlbDvvIzpu5jorqTmmK/pnIDopoHorqHmlbBcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbi50cmlnZ2VyXSDmmK/lkKbop6blj5EgYmVmb3JlQ3JlYXRl5LqL5Lu2XHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSDov5Tlm57mt7vliqDmiJDlip/nmoToioLngrkg77yM5aaC6KKr55So5oi35Y+W5raI5LmL57G75YiZIOi/lOWbnm51bGxcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5hZGQgPSBmaXNoVG9wb1Byb3RvLmFkZE5vZGUgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucywgaXNOb0NvdW50KSB7XHJcbiAgICAgICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcclxuICAgICAgICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBpZihvcHQudHJpZ2dlciAhPT1mYWxzZSAmJiAoIXRoaXMuX3RyaWdnZXIoJ2JlZm9yZUNyZWF0ZScsIHt0YXJnZXQ6bm9kZX0pKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRDb25uZWN0b3JBdHRyRXZlbnQobm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRHcm91cE5vZGVFdmVudChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcImNyZWF0ZVwiLCB7dGFyZ2V0Om5vZGV9KTtcclxuXHJcbiAgICAgICAgaWYgKG5vZGUuaG92ZXJTdHlsZSkge1xyXG4gICAgICAgICAgICBncmFwaGljLnNldEhvdmVyU3R5bGUobm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmdyb3VwLmFkZChub2RlKTtcclxuICAgICAgICBpZiAobm9kZS5yZWxhdGl2ZSkgeyAgLy/lv4XpobvlnKjliqDlhaXnlLvluIPlkI7miafooYxcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlUmVsYXRpdmVQb3N0aW9uKG5vZGUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLmhvdmVyQW5pbWF0aW9uICYmIHRoaXMub3B0aW9ucy5pc0FuaW1hdGlvbkVuYWJsZWQpIHtcclxuICAgICAgICAgICAgZmxvd05vZGUuYWRkSG92ZXJBbmltYXRpb24obm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc05vQ291bnQgIT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0ZXBDb3VudGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5fYWRkR3JvdXBOb2RlID0gZnVuY3Rpb24oZ3JvdXBOb2RlLCBjaGlsZCl7XHJcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ29ubmVjdG9yQXR0ckV2ZW50KGNoaWxkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmFkZE5vZGVBdHRyRXZlbnQoY2hpbGQsIGdyb3VwTm9kZS5vcHRpb25zLmNoaWxkRHJhZ2dhYmxlKTtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoY2hpbGQuc2VsZWN0YWJsZSkpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLnNlbGVjdGFibGUgPSBmYWxzZTsgIC8v57uE5YaF6buY6K6k5LiN5Y+v6YCJ5LitXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoaWxkLnJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVSZWxhdGl2ZVBvc3Rpb24oY2hpbGQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoaWxkLmhvdmVyU3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZShjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcImNyZWF0ZVwiLCB7dGFyZ2V0OmNoaWxkfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Zyo6ZO+6Lev6L+e57q/5LiK5re75Yqg5paH5pysXHJcbiAgICAgKiBAbWV0aG9kIGFkZFRleHRPbkNoYWluXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGluZSDpk77ot6/ov57nur/lr7nosaFcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdGV4dF0g5pWw57uE57G75Z6L77yM6KGo56S65aSa5Liq5paH5pys55qE5pWw5o2u44CC5pWw57uE5YWD57Sg5Y+v5Lul5Li65a2X56ym5Liy77yM6KGo56S65q+P5Liq5paH5pys55qE5ZCN5a2X77yb5Lmf5Y+v5Lul5piv5Liq5a+56LGh77yM5a+56LGh5Lit5b+F6aG75oyH5a6adGV4dOWxnuaAp++8jOWFtuWAvOS4uuaWh+acrOeahOWQjeWtl1xyXG4gICAgICogQHJldHVybnMge09iamVjdH0g6L+U5ZueIOmTvui3r+i/nue6v+WvueixoVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZFRleHRPbkNoYWluID0gZnVuY3Rpb24gKGxpbmUsIHRleHQpIHtcclxuICAgICAgICBpZiAobGluZS5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09PSBDb25uZWN0b3IuVFlQRV9DSEFJTikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlbW92ZUxpbmUobGluZSwgdGhpcy5fZ2V0UGFyZW50WnIobGluZSkpO1xyXG4gICAgICAgICAgICBsaW5lLm9wdGlvbnMudGV4dC50ZXh0LnB1c2godGV4dCk7XHJcbiAgICAgICAgICAgIGxpbmUub3B0aW9ucy50ZXh0Q29udGV4dE1lbnUgPSBsaW5lLm9wdC50ZXh0Q29udGV4dE1lbnU7ICAgLy/kuI3nhLblt6bplK7oj5zljZXmsqHmnInkuobvvIHvvIHvvIFcclxuICAgICAgICAgICAgdmFyIHNsaW5rID0gbmV3IGZsb3dMaW5rLkNoYWluKGxpbmUuc3RhcnROb2RlLCBsaW5lLmVuZE5vZGUsIGxpbmUub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHNsaW5rKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNsaW5rO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWcqOmTvui3r+i/nue6v+S4iuWIoOmZpOaMh+WumuaWh+acrFxyXG4gICAgICogQG1ldGhvZCBkZWxUZXh0T25DaGFpblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR4dE9iaiDmlofmnKzlr7nosaFcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IOi/lOWbniDpk77ot6/ov57nur/lr7nosaFcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5kZWxUZXh0T25DaGFpbiA9IGZ1bmN0aW9uICh0eHRPYmopIHtcclxuICAgICAgICB2YXIgaWQgPSB0eHRPYmouaWQsIGxpbmUgPSB0eHRPYmoucGFyZW50LCBwb3M7XHJcbiAgICAgICAgaWYgKGxpbmUub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PT0gQ29ubmVjdG9yLlRZUEVfQ0hBSU4gJiYgenJVdGlsLmlzQXJyYXkobGluZS5vcHRpb25zLnRleHQudGV4dCkpIHtcclxuICAgICAgICAgICAgbGluZS5vcHRpb25zLnRleHQudGV4dC5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodi50ZXh0SWQgPT09IGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxpbmUub3B0aW9ucy50ZXh0LnRleHQuc3BsaWNlKHBvcywgMSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlbW92ZUxpbmUobGluZSwgdGhpcy5fZ2V0UGFyZW50WnIobGluZSkpO1xyXG4gICAgICAgICAgICBsaW5lLm9wdGlvbnMudGV4dENvbnRleHRNZW51ID0gbGluZS5vcHQudGV4dENvbnRleHRNZW51OyAgIC8v5LiN54S25bem6ZSu6I+c5Y2V5rKh5pyJ5LqG77yB77yB77yBXHJcbiAgICAgICAgICAgIHZhciBzbGluayA9IG5ldyBmbG93TGluay5DaGFpbihsaW5lLnN0YXJ0Tm9kZSwgbGluZS5lbmROb2RlLCBsaW5lLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChzbGluayk7XHJcbiAgICAgICAgICAgIHJldHVybiBzbGluaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWcqOmTvui3r+i/nue6v+S4iuS/ruaUueaMh+WumuaWh+acrFxyXG4gICAgICogQG1ldGhvZCBkZWxUZXh0T25DaGFpblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR4dE9iaiDmlofmnKzlr7nosaFcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIOS/ruaUueeahOaWh+acrFxyXG4gICAgICogQHJldHVybnMge09iamVjdH0g6L+U5ZueIOmTvui3r+i/nue6v+WvueixoVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLm1vZGlmeVRleHRPbkNoYWluID0gZnVuY3Rpb24gKHR4dE9iaiwgbmFtZSkge1xyXG4gICAgICAgIHZhciBpZCA9IHR4dE9iai5pZCwgbGluZSA9IHR4dE9iai5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKGxpbmUub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PT0gQ29ubmVjdG9yLlRZUEVfQ0hBSU4gJiYgenJVdGlsLmlzQXJyYXkobGluZS5vcHRpb25zLnRleHQudGV4dCkpIHtcclxuICAgICAgICAgICAgbGluZS5vcHRpb25zLnRleHQudGV4dC5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodi50ZXh0SWQgPT09IGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdi50ZXh0ID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHR4dE9iai5zZXRTdHlsZShcInRleHRcIiwgbmFtZSk7XHJcbiAgICAgICAgICAgIHR4dE9iai5wYXJlbnQucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpc2hUb3BvUHJvdG8uZ2V0cGFyZW50SWdub3JlID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQuaWdub3JlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgLy8g57un57ut5ZCR5LiK6YGN5Y6GXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRwYXJlbnRJZ25vcmUobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOmAkuW9kuaJvuWHuue7hOWGheaJgOacieiKgueCuSjljIXlkKvnu4QscmVsYXRpb25JbWFnZSzpmaRHUk9VUF9SRUNUX05BTUXlpJYpXHJcbiAgICAgKiBAbWV0aG9kIHRvZ2dsZUFsbENvbkdyb3VwTGluZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyb3VwTm9kZSDnu4ToioLngrnlr7nosaFcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWZDb250YWluUmVsYXRpb25JbWFnZSDmmK/lkKbljIXlkKvnu4ToioLngrnnmoRfcmVsYXRpb25JbWFnZVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmZpbmRHcm91cE5vZGVzID0gZnVuY3Rpb24gKGdyb3VwTm9kZSwgaWZDb250YWluUmVsYXRpb25JbWFnZSkge1xyXG4gICAgICAgIHZhciBub2RlTGlzdCA9IFtncm91cE5vZGVdO1xyXG4gICAgICAgIGlmIChpZkNvbnRhaW5SZWxhdGlvbkltYWdlICYmIGdyb3VwTm9kZS5fcmVsYXRpb25JbWFnZSkge1xyXG4gICAgICAgICAgICBub2RlTGlzdC5wdXNoKGdyb3VwTm9kZS5fcmVsYXRpb25JbWFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGZpbmROb2Rlcyhub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChGbG93LmlzR3JvdXBOb2RlKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLl9jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUgaW5zdGFuY2VvZiBDb25uZWN0b3IgfHwgY2hpbGROb2RlLmlzSWNvbiB8fCBjaGlsZE5vZGUubmFtZSA9PT0gJ0dST1VQX1JFQ1RfTkFNRScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5LiN5aSE55CGXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUxpc3QucHVzaChjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWZDb250YWluUmVsYXRpb25JbWFnZSAmJiBjaGlsZE5vZGUuX3JlbGF0aW9uSW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVMaXN0LnB1c2goY2hpbGROb2RlLl9yZWxhdGlvbkltYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoRmxvdy5pc0dyb3VwTm9kZShjaGlsZE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmROb2RlcyhjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmROb2Rlcyhncm91cE5vZGUpO1xyXG4gICAgICAgIHJldHVybiBub2RlTGlzdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5pi+56S66ZqQ6JeP5oyH5a6a6IqC54K555qE6L+e57q/LOeItuiKgueCueWSjF9yZWxhdGlvbkltYWdl6ZyA5Y2V54us5YGa54m55q6K5aSE55CGXHJcbiAgICAgKiBAbWV0aG9kIHRvZ2dsZUFsbENvbk5vZGVMaW5lXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSDoioLngrnlr7nosaFcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOaYvuekuui/mOaYr+makOiXjyBbaGlkZXxzaG93XVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnRvZ2dsZUFsbENvbk5vZGVMaW5lID0gZnVuY3Rpb24gKG5vZGUsIHR5cGUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGdyb3VwTm9kZXMgPSBbXTtcclxuICAgICAgICB2YXIganVkZ2VGdW47XHJcbiAgICAgICAgaWYgKEZsb3cuaXNHcm91cE5vZGUobm9kZSkpIHtcclxuICAgICAgICAgICAgZ3JvdXBOb2RlcyA9IHRoaXMuZmluZEdyb3VwTm9kZXMobm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGp1ZGdlRnVuID0gZnVuY3Rpb24obGluZSwgbm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnaGlkZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnc2hvdycpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBsaW5lW25vZGVUeXBlXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUucGFyZW50ICYmIHRoYXQuZ2V0cGFyZW50SWdub3JlKGN1cnJlbnROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEZsb3cuaXNHcm91cE5vZGUoY3VycmVudE5vZGUpICYmIGN1cnJlbnROb2RlLmlnbm9yZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnROb2RlLm5hbWUgPT09ICdHUk9VUF9SRUxBVElPTl9JTUFHRScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRHcm91cE5vZGUgPSB6clV0aWwuZmluZChncm91cE5vZGVzLCBmdW5jdGlvbihjaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGUuaWQgPT09IGN1cnJlbnROb2RlLnJlbGF0ZWRHcm91cElkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRHcm91cE5vZGUgJiYgdGhhdC5nZXRwYXJlbnRJZ25vcmUoY3VycmVudEdyb3VwTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lLnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFsbExpbmUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnM7XHJcbiAgICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KGFsbExpbmUpKSB7XHJcbiAgICAgICAgICAgIGFsbExpbmUuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKEZsb3cuaXNHcm91cE5vZGUobm9kZSkgJiYgZ3JvdXBOb2Rlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6Leo57uE6Ze055qE6L+e57q/77yM5Y+q6KaB5ruh6Laz6LW35aeL54K55YW25Lit5LmL5LiA5Zyo57uE5YaF5bCx6ZqQ6JePXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwTm9kZXMuc29tZShmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpdGVtLmlkID09PSBsaW5lLnN0YXJ0Tm9kZS5pZH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGp1ZGdlRnVuKGxpbmUsICdzdGFydE5vZGUnKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBOb2Rlcy5zb21lKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uaWQgPT09IGxpbmUuZW5kTm9kZS5pZH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGp1ZGdlRnVuKGxpbmUsICdlbmROb2RlJylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnN0YXJ0Tm9kZS5pZCA9PT0gbm9kZS5pZCB8fCBsaW5lLmVuZE5vZGUuaWQgPT09IG5vZGUuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gJ2hpZGUnID8gbGluZS5oaWRlKCkgOiBsaW5lLnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZENvbm5lY3RvckF0dHJFdmVudCA9IGZ1bmN0aW9uIChjb25uZWN0b3IpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNoYWluTGluZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKGNvbm5lY3Rvci5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09PSBDb25uZWN0b3IuVFlQRV9DSEFJTikge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5nZXRUd29Ob2RlSWQoY29ubmVjdG9yLnN0YXJ0Tm9kZSwgY29ubmVjdG9yLmVuZE5vZGUsIGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmFyIGNvbnMgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rvck1hcC5nZXQoa2V5KTtcclxuICAgICAgICAgICAgdmFyIG9yaWduVGV4dCA9IFtdLmNvbmNhdChjb25uZWN0b3Iub3B0aW9ucy50ZXh0LnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoY29ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodi5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09PSBDb25uZWN0b3IuVFlQRV9DSEFJTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnblRleHQgPSBvcmlnblRleHQuY29uY2F0KHYub3B0aW9ucy50ZXh0LnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbkxpbmUgPSB2O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5aaC5p6c5bey5a2Y5Zyo6ZO+6LevXHJcbiAgICAgICAgaWYgKGNoYWluTGluZSkge1xyXG4gICAgICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy50ZXh0LnRleHQgPSBvcmlnblRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVtb3ZlTGluZShjaGFpbkxpbmUsIHRoaXMuX2dldFBhcmVudFpyKGNoYWluTGluZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy5pc0VkaXQgPSAhIXRoaXMub3B0aW9ucy5saW5rTW9kaWZ5O1xyXG4gICAgICAgIC8vIOWkhOeQhue6v+auteS4pOerr+eahOiwg+aVtGRyYWfkuovku7ZcclxuICAgICAgICB0aGlzLmNyZWF0ZUNvbm5lY3RvckRyYWdFdmVudHMoY29ubmVjdG9yKTtcclxuICAgICAgICBjb25uZWN0b3Iub24oXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyDlj5bmtojoioLngrnnmoTpgInkuK1cclxuICAgICAgICAgICAgdGhpcy5oaWRlQ29ubmVjdG9yUG9pbnQoKTtcclxuICAgICAgICAgICAgdGhpcy5oaWRlQ29ubmVjdG9yQ29udHJvbCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVPcGVyYXRpb25Ob2RlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNOb2RlID0gZmFsc2U7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9yRm9yYmlkRWRpdCghdGhpcy5vcHRpb25zLmxpbmtNb2RpZnkpO1xyXG4gICAgICAgIC8v5pSv5oyB5Y+M5Ye757yW6L6RXHJcbiAgICAgICAgY29ubmVjdG9yLm9uKFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy50ZXh0LnRleHRFZGl0YWJsZSA9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnRleHRFZGl0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdG9yRWRpdCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dC50ZXh0RWRpdGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3RvckVkaXQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZE5vZGVBdHRyRXZlbnQgPSBmdW5jdGlvbiAobm9kZSwgY2hpbGREcmFnZ2FibGUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGNoaWxkRHJhZ2dhYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZyhub2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5vZGUuYXR0cihcIm9wZXJhdGlvbkljb25zXCIsIG5vZGUubW9kZWwuZ2V0KCdvcHRpb25zLm9wZXJhdGlvbkljb25zJykpO1xyXG5cclxuICAgICAgICAvL+S+puWQrOiKgueCueeahGNsaWNrIGRibGNsaWNr5LqL5Lu277yM6YCJ5Lit77yM5bm25rS+5Y+R5Ye65Y67XHJcbiAgICAgICAgbm9kZS5vbignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdlTm9kZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0aGF0Lmp1ZGdlSWZSZWFkTW9kZSh0YXJnZU5vZGUpIHx8ICh0YXJnZU5vZGUuc3R5bGUgJiYgdGFyZ2VOb2RlLnN0eWxlLmZpbGwgPT09ICdub25lJykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0Lm5vZGVDbGlja0hhbmRsZXIodGFyZ2VOb2RlKTtcclxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBldmVudDtcclxuICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSAnY2xpY2snO1xyXG4gICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGFyZ2VOb2RlO1xyXG4gICAgICAgICAgICB0aGF0Ll9hcGkudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIOWIpOaWreS4gOS4i+aYr+WQpuaYr+e7hOWGheaIkOe7hOeahOeCueWHu+S6i+S7tu+8jOWmguaenOaYr+eahOivne+8jOmCo+e7hOS5n+S5n+a0vuWPkeS4gOS4i1xyXG4gICAgICAgICAgICBpZiAoRmxvdy5pc0luR3JvdXAodGFyZ2VOb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSB0YXJnZU5vZGUucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnROb2RlLmNoaWxkRHJhZ2dhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS50cmlnZ2VyKCdjbGljaycsIHtldmVudDpldmVudCwgdHlwZTonY2xpY2snLHRhcmdldDpwYXJlbnROb2RlfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBub2RlLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZU5vZGUgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIXRhcmdlTm9kZS5zdHlsZSB8fCAodHlwZW9mIHRhcmdlTm9kZS5zdHlsZS50ZXh0RWRpdGFibGUgPT0gXCJ1bmRlZmluZWRcIikpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMudGV4dEVkaXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5ub2RlRWRpdCh0YXJnZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdlTm9kZS5zdHlsZS50ZXh0RWRpdGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Lm5vZGVFZGl0KHRhcmdlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICBwYXJhbXMudHlwZSA9ICdkYmxjbGljayc7XHJcbiAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0YXJnZU5vZGU7XHJcbiAgICAgICAgICAgIHRoYXQuX2FwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG5cclxuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFsbE5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5faGFuZGxlUmVsYXRpdmVQb3N0aW9uID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIHZhciBwYXJlbnRFbCA9IG5vZGUucGFyZW50O1xyXG4gICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcGFyZW50RWwgPT09IHRoaXMuZ3JvdXBcclxuICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDp0aGlzLl9hcGkuZ2V0V2lkdGgoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDp0aGlzLl9hcGkuZ2V0SGVpZ2h0KClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOnBhcmVudEVsLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OnBhcmVudEVsLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgbGF5b3V0LnBvc2l0aW9uRWxlbWVudChub2RlLCBub2RlLnJlbGF0aXZlLCBjb250YWluZXJJbmZvLCBub2RlLnJlbGF0aXZlLnBhZGRpbmcsIHtib3VuZGluZ01vZGU6bm9kZS5yZWxhdGl2ZS5ib3VuZGluZ3x8J2FsbCd9KTtcclxuICAgIH1cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLl9nZXRQYXJlbnRaciA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICB2YXIgcGFyZW50WnIgPSBudWxsO1xyXG4gICAgICAgIGlmIChub2RlICYmIG5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHBhcmVudFpyID0gbm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGFyZW50WnIgPSB0aGlzLmdyb3VwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyZW50WnI7XHJcbiAgICB9XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5fcmVtb3ZlT3BlcmF0aW9uTm9kZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9wZXJhdGlvbk5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmUodGhpcy5vcGVyYXRpb25Ob2RlKTtcclxuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlLmNsZWFudXAoKTtcclxuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmuIXnqbrlvZPliY3lrp7kvovvvIzkvJrnp7vpmaTlrp7kvovkuK3miYDmnInnmoToioLngrnkuI7nur9cclxuICAgICAqIEBtZXRob2QgY2xlYXJcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5jbGVhciA9IGZ1bmN0aW9uIChpc05vQ291bnQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudFpyID0gdGhpcy5fZ2V0UGFyZW50WnIodGhpcy5hbGxOb2Rlc1tpXSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZGVsZXRlU2VsZWN0Q29uKHRoaXMuYWxsTm9kZXNbaV0sIHBhcmVudFpyKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rvck1hcC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuYWxsTm9kZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWROb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRyYWdTZWxlY3RSZWN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkTm9kZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JQb2ludCgpO1xyXG4gICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvckNvbnRyb2woKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl96ci5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAuaXNCZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fenIuYWRkKHRoaXMuZ3JvdXApO1xyXG4gICAgICAgIGlmIChpc05vQ291bnQgIT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0ZXBDb3VudGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uui/nue6v+eahOWwj+Wbvuagh+aTjeS9nFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSDlsI/lm77moIfnmoTlkI3np7BcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOWwj+Wbvuagh+eahOebuOWFs+WPguaVsFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmljb25dIOWwj+Wbvuagh+i3r+W+hFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxpbmVOb2RlXSDnur/mrrXlrp7kvotcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXSDngrnlh7vlkI7nmoTlm57osINcclxuICAgICAqXHJcbiAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICAgICAgICAgICAgICB0aGlzLmZpc2hUb3BvLmFkZEljb24oXCJpY29uMVwiLCB7XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBpY29uOiBcImh0dHBzOi8vc3MwLmJkc3RhdGljLmNvbS81YVYxYmpxaF9RMjNvZENmL3N0YXRpYy9zdXBlcm1hbi9pbWcvbG9nb190b3BfY2E3OWExNDYucG5nXCIsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBsaW5lTm9kZTogbGluZU5vZGUsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydChKU09OLnN0cmluZ2lmeShldmVudC5kYXRhKSlcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZExpbmVJY29uID0gZmlzaFRvcG9Qcm90by5hZGRJY29uID0gZnVuY3Rpb24gKGtleSwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIuYWRkSWNvbihrZXksIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uui/nue6v+eahOm7mOiupOWIoOmZpOaTjeS9nFxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBsaW5lTm9kZSDnur9cclxuICAgICAqXHJcbiAgICAgKiAgKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgZmlzaFRvcG8ubGluZURlZmF1bHRJY29uKGxpbmVOb2RlKTtcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5saW5lRGVmYXVsdEljb24gPSBmdW5jdGlvbiAobGluZU5vZGUpIHtcclxuICAgICAgICB0aGlzLmFkZExpbmVEZWxldGVJY29uKGxpbmVOb2RlKTtcclxuICAgICAgICB0aGlzLmFkZExpbmVDaGFuZ2VJY29uKGxpbmVOb2RlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rov57nur/nmoTpu5jorqTliKDpmaTmk43kvZxcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbGluZU5vZGUg57q/XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIOi/nue6v+aTjeS9nOeahOmAiemhuVxyXG4gICAgICpcclxuICAgICAqICAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICBmaXNoVG9wby5hZGRMaW5lQ2hhbmdlSWNvbihsaW5lTm9kZSk7XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uYWRkTGluZURlbGV0ZUljb24gPSBmdW5jdGlvbiAobGluZU5vZGUsb3B0aW9ucykge1xyXG4gICAgICAgIC8v5Yib5bu65Yig6ZmkXHJcbiAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5hZGREZWxldGVJY29uKGxpbmVOb2RlLG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uui/nue6v+eahOm7mOiupOWIh+aNouexu+Wei+aTjeS9nFxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBsaW5lTm9kZSDnur9cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10g6L+e57q/5pON5L2c55qE6YCJ6aG5XHJcbiAgICAgKlxyXG4gICAgICogICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgIGZpc2hUb3BvLmFkZExpbmVDaGFuZ2VJY29uKGxpbmVOb2RlKTtcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5hZGRMaW5lQ2hhbmdlSWNvbiA9IGZ1bmN0aW9uIChsaW5lTm9kZSxvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5hZGRDaGFuZ2VMaW5lVHlwZUljb24obGluZU5vZGUsb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Y+Y5pu05b2T5YmN57q/55qE57G75Z6L77yM5aaC5p6c5LiN5Lyg5YiZ5oyJ6aG65bqP5Y+W5LiL5LiA5Liq57G75Z6L44CC5YWI5Yig6Zmk5Y6f5p2l55qE57q/5q61IOWGjeWinuWKoOS4gOenjeexu+Wei+eahOe6v+autVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmVUeXBlIOassuWPmOabtOe6v+eahOexu+Wei1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNoYW5nZVNlbGVjdENvbm5lY3RvclR5cGUgPSBmdW5jdGlvbihsaW5lVHlwZSkge1xyXG4gICAgICAgIHZhciBuZXh0TGluZVR5cGUgPSBsaW5lVHlwZTtcclxuICAgICAgICB2YXIgbGluZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc2VsQ29ubmVjdG9yO1xyXG4gICAgICAgIHZhciBvcmlnaW5MaW5lVHlwZSA9IGxpbmUub3B0aW9ucy5zdHlsZS5saW5lVHlwZTtcclxuICAgICAgICBpZiAobmV4dExpbmVUeXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXh0TGluZVR5cGUgPT0gb3JpZ2luTGluZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBhcnJMaW5lVHlwZSA9IFtDb25uZWN0b3IuVFlQRV9TVFJBSUdIVCwgQ29ubmVjdG9yLlRZUEVfSkFHR0VELCBDb25uZWN0b3IuVFlQRV9DVVJWRV07XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHpyVXRpbC5pbmRleE9mKGFyckxpbmVUeXBlLCBvcmlnaW5MaW5lVHlwZSk7XHJcbiAgICAgICAgICAgIG5leHRMaW5lVHlwZSA9IGFyckxpbmVUeXBlWyhpbmRleCArIDEpICUgYXJyTGluZVR5cGUubGVuZ3RoXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdGhpcy5yZW1vdmUobGluZSwge3RyaWdnZXI6ZmFsc2V9KTsg6L+Z5qC35Lya5Yig6ZmkaWNvbnNcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmRlbGV0ZUxpbmUodGhpcy5fZ2V0UGFyZW50WnIobGluZSkpO1xyXG4gICAgICAgIHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIuaGlkZUFsbExpbmVPcGVyYXRpb24oKTtcclxuXHJcbiAgICAgICAgenJVdGlsLm1lcmdlKGxpbmUub3B0aW9ucywgeyBkb2NrZXJzOiBbXSB9LCB0cnVlKTtcclxuICAgICAgICB6clV0aWwubWVyZ2UobGluZS5vcHRpb25zLnN0eWxlLCB7IGxpbmVUeXBlOiBuZXh0TGluZVR5cGUgfSwgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIG5leHRMaW5lID0gdGhpcy5jcmVhdGVDb25uZWN0b3JCeU5vZGVzKGxpbmUuc3RhcnROb2RlLCBsaW5lLmVuZE5vZGUsIGxpbmUub3B0aW9ucywgZmFsc2UpO1xyXG4gICAgICAgIGlmIChuZXh0TGluZSkge1xyXG4gICAgICAgICAgICBuZXh0TGluZS5pY29ucyA9IGxpbmUuaWNvbnM7XHJcbiAgICAgICAgICAgIG5leHRMaW5lLm9uKCdDb25uZWN0b3I6Y2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmJpbmRPcGVyYXRpb24obmV4dExpbmUpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiDmoLnmja5wb2ludOWIm+W7uuiKgueCueS4iueahOi/nuaOpeeCuVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50IHjvvIx55Z2Q5qCHICB7eDp4LCB5Onl9XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zIHjvvIx55Z2Q5qCHIFtyaWdodHxsZWZ0fHRvcHxib3R0b21dXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZVR5cGUgeO+8jHnlnZDmoIcgW3N0cmFpZ2h0fGphZ2dlZHxjdXJ2ZV1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5jcmVhdGVDb25uZWN0b3JQb2ludCA9IGZ1bmN0aW9uKHBvaW50LCBwb3MsIGxpbmVUeXBlKSB7XHJcbiAgICAgICAgdmFyIG1lID0gdGhpcztcclxuICAgICAgICB2YXIgcG9pbnRJbnN0YW5jZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogcG9pbnQueCxcclxuICAgICAgICAgICAgICAgIGN5OiBwb2ludC55LFxyXG4gICAgICAgICAgICAgICAgcjogNFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNGRkZGMzMnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6IDogNCxcclxuICAgICAgICAgICAgY3Vyc29yOiAnY3Jvc3NoYWlyJyxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBsaW5lVHlwZTogbGluZVR5cGVcclxuICAgICAgICB9KTtcclxuICAgICAgICBwb2ludEluc3RhbmNlLnR5cGUgPSAnQ29ubmVjdFBvaW50JztcclxuICAgICAgICBwb2ludEluc3RhbmNlLnBvcyA9IHBvczsgICAgICAgICAgICAgICAgLy/orrDlvZXmmK/oioLngrnkuIrlk6rkuKrkvY3nva7nmoTov57mjqXngrlcclxuICAgICAgICB2YXIgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2RyYWdzdGFydCcsICdkcmFnJywgJ2RyYWdlbmQnXTtcclxuICAgICAgICB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24oZXZlTmFtZSkge1xyXG4gICAgICAgICAgICBwb2ludEluc3RhbmNlLm9uKGV2ZU5hbWUsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiQ29ubmVjdFBvaW50OlwiICsgZXZlTmFtZTtcclxuICAgICAgICAgICAgICAgIG1lLmdyb3VwLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAuYWRkKHBvaW50SW5zdGFuY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOmakOiXj+iKgueCueS4iueahOi/nuaOpeeCuVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmhpZGVDb25uZWN0b3JQb2ludCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGlzLmdyb3VwLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAodi50eXBlID09PSAnQ29ubmVjdFBvaW50Jykge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5ncm91cC5yZW1vdmUodik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMuZ3JvdXAub2ZmKFwiQ29ubmVjdFBvaW50OmRyYWdzdGFydFwiKTtcclxuICAgICAgICB0aGlzLmdyb3VwLm9mZihcIkNvbm5lY3RQb2ludDpkcmFnXCIpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAub2ZmKFwiQ29ubmVjdFBvaW50OmRyYWdlbmRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5qC55o2u6IqC54K55pWw57uE5Yqo5oCB5Yib5bu66L+e5o6l54K5XHJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gbGluZVR5cGUg6ZyA6KaB5bGV56S66L+e5o6l54K555qE6IqC54K55pWw57uEXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGxpbmVUeXBlIOi/nue6v+eahOe6v+auteexu+WeiyBbc3RyYWlnaHR8amFnZ2VkfGN1cnZlXVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmZpbHRlckNvbm5lY3RQb2ludCA9IGZ1bmN0aW9uKHRhcmdldE5vZGVzLCBsaW5lVHlwZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmp1ZGdlSWZSZWFkTW9kZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmlmU2hvd0Nvbm5lY3RvclBvaW50KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGdyb3VwTm9kZXMgPSBbXTsgLy8g6K6w5b2V57uE5YaF6IqC54K5XHJcbiAgICAgICAgdmFyIG91dHNpZGVOb2RlcyA9IFtdOyAvLyDorrDlvZXnu4TlpJboioLngrlcclxuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcclxuICAgICAgICBpZiAodGFyZ2V0Tm9kZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB0YXJnZXROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChGbG93LmlzR3JvdXBOb2RlKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBncm91cE5vZGVzID0gZ3JvdXBOb2Rlcy5jb25jYXQoaXRlbS5jaGlsZHJlbigpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0c2lkZU5vZGVzLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyDmr5TovoPnu4TlhoXlpJboioLngrnvvIzov4fmu6Tnu4TlhoXoioLngrlcclxuICAgICAgICAgICAgb3V0c2lkZU5vZGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFncm91cE5vZGVzLmluY2x1ZGVzKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZXMgPSB0YXJnZXROb2RlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhhdC5qdWRnZUlmUmVhZE1vZGUoaXRlbSkgJiYgdGhhdC5pZlNob3dDb25uZWN0b3JQb2ludChpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB1dGlsLmdldFJlY3QoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5wYXJlbnQgJiYgRmxvdy5pc0dyb3VwTm9kZShpdGVtLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWN0LmJvdW5kaW5nUmVjdC54ICs9IEZsb3cucGFyZW50WChpdGVtLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdC5ib3VuZGluZ1JlY3QueSArPSBGbG93LnBhcmVudFkoaXRlbS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RvclBvaW50ID0gdXRpbC5nZXRDb25uZWN0b3JQb2ludHMocmVjdCwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmNyZWF0ZUNvbm5lY3RvclBvaW50KGNvbm5lY3RvclBvaW50LmxlZnQsIFwibGVmdFwiLCBsaW5lVHlwZSk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmNyZWF0ZUNvbm5lY3RvclBvaW50KGNvbm5lY3RvclBvaW50LnJpZ2h0LCBcInJpZ2h0XCIsIGxpbmVUeXBlKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuY3JlYXRlQ29ubmVjdG9yUG9pbnQoY29ubmVjdG9yUG9pbnQudG9wLCBcInRvcFwiLCBsaW5lVHlwZSk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmNyZWF0ZUNvbm5lY3RvclBvaW50KGNvbm5lY3RvclBvaW50LmJvdHRvbSwgXCJib3R0b21cIiwgbGluZVR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlnKjoioLngrnkuIrmmL7npLrov57mjqXngrlcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbGluZVR5cGUg6L+e57q/55qE57q/5q6157G75Z6LIFtzdHJhaWdodHxqYWdnZWR8Y3VydmVdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIOi/nue6v+eahOe6v+auteWxnuaAp1xyXG4gICAgICpcclxuICAgICAqICAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICAgJCgnLmJ0bi1jb25uZWN0LWphZ2dlZCcpLmNsaWNrKGZ1bmN0aW9uKGUpIHtcclxuICAgICAqICAgICAgICAgICBmaXNoVG9wby5zaG93Q29ubmVjdG9yUG9pbnQoXCJqYWdnZWRcIiwge1xyXG4gICAgICogICAgICAgICAgICAgICBzeW1ib2w6IHtcclxuICAgICAqICAgICAgICAgICAgICAgICAgIC8vIOeureWktOminOiJslxyXG4gICAgICogICAgICAgICAgICAgICAgICAgY29sb3I6IFwiI0JCQkJCQlwiXHJcbiAgICAgKiAgICAgICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAvLyDnur/mnaHpopzoibJcclxuICAgICAqICAgICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjQkJCQkJCXCIsXHJcbiAgICAgKiAgICAgICAgICAgICAgIH1cclxuICAgICAqICAgICAgICAgICB9KTtcclxuICAgICAqICAgICAgIH0pO1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnNob3dDb25uZWN0b3JQb2ludCA9IGZ1bmN0aW9uKGxpbmVUeXBlLCBsaW5lT3B0LCBpZkN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgaWYgKGxpbmVUeXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZVR5cGUgPSBsaW5lVHlwZTsgLy8g57yT5a2Y57q/5q6157G75Z6LXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5saW5lVHlwZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVUeXBlID0gJ2phZ2dlZCc7IC8vIOe6v+autem7mOiupOaKmOe6v+exu+Wei1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGluZU9wdCkge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVPcHQgPSBsaW5lT3B0OyAgLy/nvJPlrZjnur/mrrXnmoTphY3nva7kv6Hmga9cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpZkN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIGlmQ3VycmVudE5vZGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRhcmdldE5vZGVzID0gaWZDdXJyZW50Tm9kZSA/IFt0aGF0LnNlbGVjdGVkTm9kZV0gOiB0aGF0LmFsbE5vZGVzO1xyXG5cclxuICAgICAgICBpZiAoIWlmQ3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgLy8g5omA5pyJ6IqC54K56L+e5o6l54K55bGV56S65YmN77yM6aaW5YWI5riF6Zmk55S75biD5LiK55qE5qGG6YCJZHJhZ1NlbGVjdFxyXG4gICAgICAgICAgICB0aGF0Ll9yZW1vdmVPcGVyYXRpb25Ob2RlKCk7XHJcbiAgICAgICAgICAgIHRoYXQuX3JlbGVhc2VTZWxlY3ROb2RlKCk7XHJcbiAgICAgICAgICAgIHRoYXQuaGlkZUNvbm5lY3RvckNvbnRyb2woKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOiuqeaJgOacieeUu+W4g+S4reeahOiKgueCuS/lvZPliY3oioLngrnmmL7npLrov57mjqXngrlcclxuICAgICAgICB0aGlzLmZpbHRlckNvbm5lY3RQb2ludCh0YXJnZXROb2RlcywgdGhpcy5saW5lVHlwZSk7XHJcblxyXG4gICAgICAgIC8vIOagueaNrui/nue6v+eCueafpeaJvuiKgueCuSjogIPomZHkvJjljJYg5Yib5bu66L+e5o6l54K555qE5pe25YCZIOWwseaKiui/nuaOpeeCueS4jm5vZGXov5vooYznu5HlrprvvIzlsLHkuI3nlKjov5nkuKrlpI3mnYLnmoTorqHnrpfkuoYpXHJcbiAgICAgICAgZnVuY3Rpb24gZmluZENvbm5lY3Rvck5vZGUoeCwgeSwgb2Zmc2V0LCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUsIGVuZFBvcyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoYXQuYWxsTm9kZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHV0aWwuZ2V0UmVjdChpdGVtKTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnBhcmVudCAmJiBGbG93LmlzR3JvdXBOb2RlKGl0ZW0ucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3QuYm91bmRpbmdSZWN0LnggKz0gRmxvdy5wYXJlbnRYKGl0ZW0ucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZWN0LmJvdW5kaW5nUmVjdC55ICs9IEZsb3cucGFyZW50WShpdGVtLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9yUG9pbnQgPSB1dGlsLmdldENvbm5lY3RvclBvaW50cyhyZWN0LCBpdGVtKTtcclxuICAgICAgICAgICAgICAgIGlmIChwb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbcG9zXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W3Bvc10ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImxlZnRcIl0ueCAtIHgpIDw9IG9mZnNldCAmJiBNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImxlZnRcIl0ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInRvcFwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1widG9wXCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJ0b3BcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInJpZ2h0XCJdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbXCJyaWdodFwiXS55IC0geSkgPD0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImJvdHRvbVwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wiYm90dG9tXCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJib3R0b21cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXHJcbiAgICAgICAgICAgICAgICBlbmRQb3M6IGVuZFBvc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdyb3VwLm9uKFwiQ29ubmVjdFBvaW50OmRyYWdzdGFydFwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIC8vIOWmguaenOaYr+W9k+WJjeiKgueCueaYvuekuui/nuaOpeeCue+8jOmcgOimgeWcqOaLluWKqOWJquWktOaXtuiuqeeUu+W4g+S4reeahOWFtuS7luiKgueCueaYvuekuui/nuaOpeeCuVxyXG4gICAgICAgICAgICBpZiAoaWZDdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5maWx0ZXJDb25uZWN0UG9pbnQodGhhdC5hbGxOb2RlcywgdGhhdC5saW5lVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHggPSAoZS5ldmVudC5vZmZzZXRYIC0gdGhhdC5ncm91cC5wb3NpdGlvblswXSkgLyB0aGF0Lm5vd1pvb207XHJcbiAgICAgICAgICAgIHZhciB5ID0gKGUuZXZlbnQub2Zmc2V0WSAtIHRoYXQuZ3JvdXAucG9zaXRpb25bMV0pIC8gdGhhdC5ub3dab29tO1xyXG4gICAgICAgICAgICB2YXIgYXJyb3cgPSBlLmV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgdGhhdC5yZXZlcnNlQ29ubmVjdCA9IGZhbHNlOyAgIC8v5piv5ZCm5Y+N5ZCR6L+e57q/55qE5qCH6K+GXHJcbiAgICAgICAgICAgIHRoYXQuc3RhcnRQb3MgPSBhcnJvdy5wb3M7XHJcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0Q29ubk5vZGUgPSBmaW5kQ29ubmVjdG9yTm9kZShhcnJvdy5zaGFwZS5jeCwgYXJyb3cuc2hhcGUuY3ksIDAsIHRoYXQuc3RhcnRQb3MpLm5vZGU7XHJcbiAgICAgICAgICAgIGFycm93LmhpZGUoKTtcclxuICAgICAgICAgICAgdGhhdC5saW5lT3BlcmF0aW9uTWFuYWdlci5oaWRlQWxsTGluZU9wZXJhdGlvbigpO1xyXG4gICAgICAgICAgICB0aGF0Lm9yaWdpbk5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3IgPSB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLm1hbmFnZVRlbXBDb25uZWN0b3IodGhhdC5zZWxlY3RDb25uTm9kZSwgcG9pbnQsIGFycm93LmxpbmVUeXBlLCB0aGF0LnN0YXJ0UG9zKTtcclxuICAgICAgICAgICAgdGhhdC5ncm91cC5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmdyb3VwLm9uKFwiQ29ubmVjdFBvaW50OmRyYWdcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB2YXIgYXJyb3cgPSBlLmV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgdGhhdC5faGFuZGxlTGluZURyYWcoJ2RyYWcnLCBlLCBhcnJvdy5saW5lVHlwZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5ncm91cC5vbihcIkNvbm5lY3RQb2ludDpkcmFnZW5kXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIGFycm93ID0gZS5ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgIHRoYXQuX2hhbmRsZUxpbmVEcmFnKCdkcmFnZW5kJywgZSwgYXJyb3cubGluZVR5cGUpO1xyXG4gICAgICAgICAgICBhcnJvdy5zaG93KCk7XHJcbiAgICAgICAgICAgIGFycm93LnBvc2l0aW9uID0gWzAsIDBdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZmlzaFRvcG9Qcm90by5jcmVhdGVMaW5lQ29ubmVjdG9yUG9pbnQgPSBmdW5jdGlvbihwb2ludCwgcG9zLCBsaW5lVHlwZSkge1xyXG4gICAgICAgIHZhciBwb2ludEluc3RhbmNlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIGN4OiBwb2ludC54LFxyXG4gICAgICAgICAgICAgICAgY3k6IHBvaW50LnksXHJcbiAgICAgICAgICAgICAgICByOiA0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI0ZGRkYzMycsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6JyMwMDAwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHogOiA0LFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGxpbmVUeXBlOiBsaW5lVHlwZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBvaW50SW5zdGFuY2UudHlwZSA9ICdDb25uZWN0UG9pbnQnO1xyXG4gICAgICAgIHBvaW50SW5zdGFuY2UucG9zID0gcG9zOyAgICAgICAgICAgICAgICAvL+iusOW9leaYr+iKgueCueS4iuWTquS4quS9jee9rueahOi/nuaOpeeCuVxyXG4gICAgICAgIHRoaXMuZ3JvdXAuYWRkKHBvaW50SW5zdGFuY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uZ2V0Um90YXRlZENvcm5lckN1cnNvciA9IGZ1bmN0aW9uKG5vZGUsIHBvcykge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgcm90YXRpb24gPSBub2RlLnJvdGF0aW9uO1xyXG4gICAgICAgIGlmIChwb3MgPT09ICdtdHInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGF0LmN1cnNvck1hcFtwb3NdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTWF0aC5hYnMocm90YXRpb24pID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSAtcm90YXRpb24gLyAoTWF0aC5QSS8xODApO1xyXG4gICAgICAgICAgICB2YXIgbiA9IE1hdGgucm91bmQoKGFuZ2xlICUgMzYwKSAvIDQ1KTtcclxuICAgICAgICAgICAgaWYgKG4gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBuICs9IDg7IC8vIGZ1bGwgY2lyY2xlIGFoZWFkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbiArPSB0aGF0LmN1cnNvck9mZnNldFtwb3NdO1xyXG4gICAgICAgICAgICBuICU9IDg7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGF0LmN1cnNvck1hcHNbbl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGF0LmN1cnNvck1hcFtwb3NdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOagueaNrnBvaW505Yib5bu66IqC54K55LiK55qE5o6n5Yi254K5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnQgeO+8jHnlnZDmoIcgIHt4OngsIHk6eX1cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwb3MgeO+8jHnlnZDmoIcgW3RsfHRjfHRyfGJsfGJyfG10cl0gKHRvcC1sZWZ0LCB0b3AtY2VudGVyLCB0b3AtcmlnaHQsIGJvdHRvbS1sZWZ0LCBib3R0b20tcmlnaHQsIG1pZGRsZS10b3Atcm90YXRlKVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5vZGVJZCDliJvlu7rmjqfliLbngrnml7bkvKDlhaXlvZPliY3oioLngrnnmoRpZO+8jOWujOaIkOiKgueCueS4juaOp+WItueCueeahOe7keWumlxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNyZWF0ZUNvbm5lY3RvckNvbnRyb2wgPSBmdW5jdGlvbihwb2ludCwgcG9zLCBub2RlKSB7XHJcbiAgICAgICAgdmFyIG1lID0gdGhpcztcclxuICAgICAgICB2YXIgcG9zQXJyID0gcG9zLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgaWYgKHBvc0Fyci5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250cm9sQ3Vyc29yID0gbWUuZ2V0Um90YXRlZENvcm5lckN1cnNvcihub2RlLCBwb3MpO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRJbnN0YW5jZSA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6e1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IHBvaW50LnggLSA0LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHBvaW50LnkgLSA0LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA4LFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogOFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTonIzAwMDAwMCdcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB6OiA0LFxyXG4gICAgICAgICAgICAgICAgcm90YXRpb246IG5vZGUucm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICBvcmlnaW46IFtwb2ludC54LCBwb2ludC55XSxcclxuICAgICAgICAgICAgICAgIGN1cnNvcjogY29udHJvbEN1cnNvcixcclxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcG9pbnRJbnN0YW5jZS50eXBlID0gJ0Nvbm5lY3RDb250cm9sJztcclxuICAgICAgICAgICAgcG9pbnRJbnN0YW5jZS5wb3MgPSBwb3M7Ly8g6K6w5b2V5piv6IqC54K55LiK5ZOq5Liq5L2N572u55qE6L+e5o6l54K5XHJcbiAgICAgICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnZHJhZ3N0YXJ0JywgJ2RyYWcnLCAnZHJhZ2VuZCddO1xyXG4gICAgICAgICAgICB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24oZXZlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRJbnN0YW5jZS5vbihldmVOYW1lLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcIkNvbm5lY3RDb250cm9sOlwiICsgZXZlTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMubm9kZUlkID0gbm9kZS5pZDtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY3Vyc29yID0gY29udHJvbEN1cnNvcjtcclxuICAgICAgICAgICAgICAgICAgICBtZS5ncm91cC50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChwb2ludEluc3RhbmNlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDml4vovazngrnkuI7oioLngrnkuYvpl7TpnIDopoHov57nur9cclxuICAgICAgICAgICAgdmFyIGxpbmUgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDE6IHBvaW50LnRvcC54LFxyXG4gICAgICAgICAgICAgICAgICAgIHkxOiBwb2ludC50b3AueSxcclxuICAgICAgICAgICAgICAgICAgICB4MjogcG9pbnQuYm90dG9tLngsXHJcbiAgICAgICAgICAgICAgICAgICAgeTI6IHBvaW50LmJvdHRvbS55XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDFcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB6OiAxLFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsaW5lLnR5cGUgPSAnQ29ubmVjdENvbnRyb2xMaW5lJztcclxuICAgICAgICAgICAgbGluZS5ub2RlSWQgPSBub2RlLmlkO1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChsaW5lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHJldHVybkNvbm5lY3RvckNvbnRyb2xQYXJhbVxyXG4gICAgICog6L+U5Zue5peL6L2s54K55ZKM57yp5pS+54K55o6n5Yi25Y+C5pWwXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IOW9k+WJjeiKgueCueWvueixoVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnJldHVybkNvbm5lY3RvckNvbnRyb2xQYXJhbSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICB2YXIgc2NhbGVGbGFnID0gdHlwZW9mIG5vZGUuc2NhbGVhYmxlID09PSAnYm9vbGVhbicgPyBub2RlLnNjYWxlYWJsZSA6IHRoaXMub3B0aW9ucy5zY2FsZWFibGU7XHJcbiAgICAgICAgdmFyIHJvdGF0ZUZsYWcgPSB0eXBlb2Ygbm9kZS5yb3RhdGFibGUgPT09ICdib29sZWFuJyA/IG5vZGUucm90YXRhYmxlIDogdGhpcy5vcHRpb25zLnJvdGF0YWJsZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzY2FsZWFibGU6IHNjYWxlRmxhZyxcclxuICAgICAgICAgICAgcm90YXRhYmxlOiByb3RhdGVGbGFnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uaWZTaG93Q29ubmVjdG9yUG9pbnQgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgdmFyIGNvbm5lY3RhYmxlID0gbm9kZSAmJiB0eXBlb2Ygbm9kZS5jb25uZWN0YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9kZS5jb25uZWN0YWJsZSA6IHRoaXMub3B0aW9ucy5jb25uZWN0YWJsZTtcclxuICAgICAgICByZXR1cm4gY29ubmVjdGFibGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog6ZqQ6JeP6IqC54K55LiK55qE5o6n5Yi254K5XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uaGlkZUNvbm5lY3RvckNvbnRyb2wgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHR5cGVzID0gWydDb25uZWN0Q29udHJvbCcsICdDb25uZWN0Q29udHJvbExpbmUnXTtcclxuICAgICAgICB0aGlzLmdyb3VwLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXModi50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5ncm91cC5yZW1vdmUodik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMuZ3JvdXAub2ZmKFwiQ29ubmVjdENvbnRyb2w6ZHJhZ3N0YXJ0XCIpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAub2ZmKFwiQ29ubmVjdENvbnRyb2w6ZHJhZ1wiKTtcclxuICAgICAgICB0aGlzLmdyb3VwLm9mZihcIkNvbm5lY3RDb250cm9sOmRyYWdlbmRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlnKjoioLngrnkuIrmmL7npLrmjqfliLbngrlcclxuICAgICAqXHJcbiAgICAgKiAgKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgZmlzaFRvcG8uc2hvd0Nvbm5lY3RvckNvbnRyb2woKTtcclxuICAgICovXHJcbiAgIGZpc2hUb3BvUHJvdG8uc2hvd0Nvbm5lY3RvckNvbnRyb2wgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5qdWRnZUlmUmVhZE1vZGUodGhpcy5zZWxlY3RlZE5vZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvckNvbnRyb2woKTtcclxuICAgICAgICAvLyDorqnlvZPliY3oioLngrnmmL7npLrmjqfliLbngrlcclxuICAgICAgICB2YXIgcmVjdCA9IHV0aWwuZ2V0UmVjdCh0aGlzLnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgdmFyIGNvbm5lY3RvclBvaW50ID0gdXRpbC5nZXRDb25uZWN0b3JDb250cm9scyhyZWN0LCB0aGlzLnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucmV0dXJuQ29ubmVjdG9yQ29udHJvbFBhcmFtKHRoaXMuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICBpZiAocGFyYW1zLnNjYWxlYWJsZSkge1xyXG4gICAgICAgICAgICB0aGF0LmNyZWF0ZUNvbm5lY3RvckNvbnRyb2woY29ubmVjdG9yUG9pbnQudGwsIFwidGxcIiwgdGhpcy5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICB0aGF0LmNyZWF0ZUNvbm5lY3RvckNvbnRyb2woY29ubmVjdG9yUG9pbnQudHIsIFwidHJcIiwgdGhpcy5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICB0aGF0LmNyZWF0ZUNvbm5lY3RvckNvbnRyb2woY29ubmVjdG9yUG9pbnQuYmwsIFwiYmxcIiwgdGhpcy5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICB0aGF0LmNyZWF0ZUNvbm5lY3RvckNvbnRyb2woY29ubmVjdG9yUG9pbnQuYnIsIFwiYnJcIiwgdGhpcy5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyYW1zLnJvdGF0YWJsZSkge1xyXG4gICAgICAgICAgICB0aGF0LmNyZWF0ZUNvbm5lY3RvckNvbnRyb2woY29ubmVjdG9yUG9pbnQubXRyLCBcIm10clwiLCB0aGlzLnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgIHRoYXQuY3JlYXRlQ29ubmVjdG9yQ29udHJvbCh7IHRvcDogY29ubmVjdG9yUG9pbnQubXRyLCBib3R0b206IGNvbm5lY3RvclBvaW50LnRjIH0sIFwibXRyLHRjXCIsIHRoaXMuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGZpbmRDb250cm9sTm9kZSAoaWQpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGF0Lmdyb3VwLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pZCA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZ3JvdXAub24oXCJDb25uZWN0Q29udHJvbDpkcmFnc3RhcnRcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAvLyDpppblhYjmuIXpmaTlhbbku5bmiYDmnInoioLngrnnmoTmjqfliLbngrnlkozov57mjqXngrlcclxuICAgICAgICAgICAgdmFyIGN1cnNvciA9IGUuZXZlbnQudGFyZ2V0LmN1cnNvcjtcclxuICAgICAgICAgICAgdmFyIHBvcyA9IGUuZXZlbnQudGFyZ2V0LnBvcztcclxuICAgICAgICAgICAgdmFyIHBvc01hcCA9IHtcclxuICAgICAgICAgICAgICAgICd0bCc6ICdicicsXHJcbiAgICAgICAgICAgICAgICAndHInOiAnYmwnLFxyXG4gICAgICAgICAgICAgICAgJ2JsJzogJ3RyJyxcclxuICAgICAgICAgICAgICAgICdicic6ICd0bCdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhhdC5zZWxlY3RDb25uTm9kZSA9IGZpbmRDb250cm9sTm9kZShlLm5vZGVJZCk7XHJcbiAgICAgICAgICAgIGlmIChjdXJzb3IgJiYgcG9zICE9PSAnbXRyJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbk5vZGUgPSB6clV0aWwuZmluZCh0aGF0Lmdyb3VwLmNoaWxkcmVuKCksIGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3MgPT09IHBvc01hcFtwb3NdO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSB6clV0aWwuZmluZCh0aGF0Lmdyb3VwLmNoaWxkcmVuKCksIGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zID09PSBwb3M7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGF0LnNlbGVjdENvbm5Ob2RlLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5vcHBvc2l0ZVNoYXBlID0genJVdGlsLmNsb25lKG9yaWdpbk5vZGUuc2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5jdXJyZW50U2hhcGUgPSB6clV0aWwuY2xvbmUoY3VycmVudE5vZGUuc2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB6clV0aWwuY2xvbmUodXRpbC5nZXRSZWN0KHRoYXQuc2VsZWN0Q29ubk5vZGUsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgIHZhciBkaWFnb25hbCA9IE1hdGguc3FydChNYXRoLnBvdyhyZWN0LndpZHRoLCAyKSArIE1hdGgucG93KHJlY3QuaGVpZ2h0LCAyKSk7Ly8g5a+56KeS57q/6ZW/5bqmXHJcbiAgICAgICAgICAgICAgICB0aGF0LmRpYWdvbmFsID0gZGlhZ29uYWw7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm9yaWdpblJlY3QgPSB6clV0aWwuY2xvbmUocmVjdCk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmlmUG9pbnRDZW50ZXIgPSBib3VuZGluZ1JlY3QueCA8IC0xOyAvLyDliKTmlq3kuK3lv4PngrnmmK/lkKblnKjoioLngrnkuK3lv4Mo5Y6f5b2i5Zyo5Lit5b+D77yM55+p5b2i5Zyo5bem5LiK6KeSKVxyXG4gICAgICAgICAgICAgICAgLy8g56e76Zmkbm9kZemrmOS6rlxyXG4gICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RDb25uTm9kZS5zZWxlY3RTdHlsZSAmJiB0aGF0Ll9hcGkuZ2V0WnIoKS5yZW1vdmVIb3Zlcih0aGF0LnNlbGVjdENvbm5Ob2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAub24oXCJDb25uZWN0Q29udHJvbDpkcmFnXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnNvciA9IGUuZXZlbnQudGFyZ2V0LmN1cnNvcjtcclxuICAgICAgICAgICAgdmFyIHRhcmdldFBvcyA9IGUuZXZlbnQudGFyZ2V0LnBvcztcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGhhdC5zZWxlY3RDb25uTm9kZTtcclxuICAgICAgICAgICAgdmFyIHggPSAoZS5ldmVudC5vZmZzZXRYIC0gdGhhdC5ncm91cC5wb3NpdGlvblswXSkgLyB0aGF0Lm5vd1pvb207XHJcbiAgICAgICAgICAgIHZhciB5ID0gKGUuZXZlbnQub2Zmc2V0WSAtIHRoYXQuZ3JvdXAucG9zaXRpb25bMV0pIC8gdGhhdC5ub3dab29tO1xyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IHV0aWwuZ2V0UmVjdChjdXJyZW50Tm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRQb3MgPT09ICdtdHInKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDml4vovaxcclxuICAgICAgICAgICAgICAgIHZhciByX3ggPSB4IC0gY3VycmVudE5vZGUucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgcl95ID0geSAtIGN1cnJlbnROb2RlLnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogcmVjdC54IC0gY3VycmVudE5vZGUucG9zaXRpb25bMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgeTogcmVjdC55IC0gY3VycmVudE5vZGUucG9zaXRpb25bMV1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IE1hdGguYXRhbjIocl95LCByX3gpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RlZE5vZGUuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgJ29yaWdpbic6IFtvcmlnaW5zLngsIG9yaWdpbnMueV0sXHJcbiAgICAgICAgICAgICAgICAgICAgJ3JvdGF0aW9uJzogLXJvdGF0aW9uXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3JQb2ludCA9IHV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKHJlY3QsIHRoYXQuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb250cm9sUG9pbnQgPSB1dGlsLmdldENvbm5lY3RvckNvbnRyb2xzKHJlY3QsIHRoYXQuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICAgICAgIC8vIOiKgueCuei/nue6v+eCue+8jOaOp+WItueCueS9jee9ruabtOaWsFxyXG4gICAgICAgICAgICAgICAgdGhhdC5ncm91cC5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gaXRlbS5wb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ0Nvbm5lY3RDb250cm9sJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09PSAnbXRyJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hdHRyKCdwb3NpdGlvbicsIFswLCAwXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHIoJ3JvdGF0aW9uJywgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRTaGFwZSh7IHg6IGNvbnRyb2xQb2ludFtwb3NdLnggLSA0LCB5OiBjb250cm9sUG9pbnRbcG9zXS55IC0gNCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcmlnaW4nOiBbaXRlbS5zaGFwZS54ICsgNCwgaXRlbS5zaGFwZS55ICsgNF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncm90YXRpb24nOiAtcm90YXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09ICdDb25uZWN0Q29udHJvbExpbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0U2hhcGUoeyB4MTogY29udHJvbFBvaW50Lm10ci54LCB4MjogY29udHJvbFBvaW50LnRjLngsIHkxOiBjb250cm9sUG9pbnQubXRyLnksIHkyOiBjb250cm9sUG9pbnQudGMueSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gJ0Nvbm5lY3RQb2ludCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRTaGFwZSh7IGN4OiBjb25uZWN0b3JQb2ludFtwb3NdLngsIGN5OiBjb25uZWN0b3JQb2ludFtwb3NdLnkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyDnvKnmlL4o57yp5pS+54K56ZyA6KaB57uT5ZCI5peL6L2s6KeS5bqm6K6h566XKVxyXG4gICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gMSxcclxuICAgICAgICAgICAgICAgICAgICBjZW50ZXIgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBjZW50ZXJQb2ludCA9IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoMCwgaGVpZ2h0MDtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJzb3JzWSA9IFsnbi1yZXNpemUnLCAncy1yZXNpemUnXTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbk9yZyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAndGwnOiAnYnInLFxyXG4gICAgICAgICAgICAgICAgICAgICd0cic6ICdibCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJ2JsJzogJ3RyJyxcclxuICAgICAgICAgICAgICAgICAgICAnYnInOiAndGwnXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlTm9kZXMgPSB0aGF0Lmdyb3VwLmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ0Nvbm5lY3RDb250cm9sJyAmJiBub2RlLnBvcyAhPT0gJ210cidcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDb250cm9sTm9kZSA9IHpyVXRpbC5maW5kKHNjYWxlTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zID09PSB0YXJnZXRQb3M7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoeCA8PSA4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IDg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA8PSA4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IDg7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvcnNZLmluY2x1ZGVzKGN1cnNvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDojrflj5Z56L205q+U5L6L5Y2z5Y+vXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IGN1cnJlbnRDb250cm9sTm9kZS5zaGFwZS55ICsgNDtcclxuICAgICAgICAgICAgICAgICAgICByYXRpbyA9IHRoYXQuY3VycmVudFNoYXBlLnkgPj0gdGhhdC5vcHBvc2l0ZVNoYXBlLnkgPyAoKHkgLSB0aGF0Lm9wcG9zaXRlU2hhcGUueSAtIDQpIC8gKHN0YXJ0WSAtIHRoYXQub3Bwb3NpdGVTaGFwZS55KSkgOiAoKHRoYXQub3Bwb3NpdGVTaGFwZS55ICsgNCAtIHkpIC8gKHRoYXQub3Bwb3NpdGVTaGFwZS55IC0gc3RhcnRZKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOiOt+WPlnjovbTmr5TkvovljbPlj69cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRYID0gY3VycmVudENvbnRyb2xOb2RlLnNoYXBlLnggKyA0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJhdGlvID0gdGhhdC5jdXJyZW50U2hhcGUueCA+PSB0aGF0Lm9wcG9zaXRlU2hhcGUueCA/ICgoeCAtIHRoYXQub3Bwb3NpdGVTaGFwZS54IC0gNCkgLyAoc3RhcnRYIC0gdGhhdC5vcHBvc2l0ZVNoYXBlLngpKSA6ICgodGhhdC5vcHBvc2l0ZVNoYXBlLnggKyA0IC0geCkgLyAodGhhdC5vcHBvc2l0ZVNoYXBlLnggLSBzdGFydFgpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCEvXlswLTldKy4/WzAtOV0qLy50ZXN0KHJhdGlvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhdGlvID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnVwZGF0ZVNoYXBlKHJhdGlvKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdFNjYWxlID0gdXRpbC5nZXRSZWN0KGN1cnJlbnROb2RlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGNlbnRlclBvaW50ID0gdGhhdC5pZlBvaW50Q2VudGVyID8geyB4OiB0aGF0Lm9yaWdpblJlY3QueCwgeTogdGhhdC5vcmlnaW5SZWN0LnkgfSA6IHsgeDogdGhhdC5vcmlnaW5SZWN0LmJvdW5kaW5nUmVjdC54LCB5OiB0aGF0Lm9yaWdpblJlY3QuYm91bmRpbmdSZWN0LnkgfTtcclxuICAgICAgICAgICAgICAgIHZhciBkaWFnb25hbE5ldyA9IE1hdGguc3FydChNYXRoLnBvdyhyZWN0U2NhbGUud2lkdGgsIDIpICsgTWF0aC5wb3cocmVjdFNjYWxlLmhlaWdodCwgMikpOy8vIOWvueinkue6v+mVv+W6plxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjdXJzb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDkuIos5bem5LiKXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbi1yZXNpemUnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ253LXJlc2l6ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoMCA9ICh0aGF0Lm9wcG9zaXRlU2hhcGUueCArIDQgLSBjZW50ZXJQb2ludC54KSAqIGRpYWdvbmFsTmV3IC8gdGhhdC5kaWFnb25hbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0MCA9ICh0aGF0Lm9wcG9zaXRlU2hhcGUueSArIDQgLSBjZW50ZXJQb2ludC55KSAqIGRpYWdvbmFsTmV3IC8gdGhhdC5kaWFnb25hbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyLnB1c2godGhhdC5vcHBvc2l0ZVNoYXBlLnggLSB3aWR0aDAgKyA0LCB0aGF0Lm9wcG9zaXRlU2hhcGUueSAtIGhlaWdodDAgKyA0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5Y+zLOWPs+S4ilxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2UtcmVzaXplJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICduZS1yZXNpemUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDAgPSAoY2VudGVyUG9pbnQueCAtIHRoYXQub3Bwb3NpdGVTaGFwZS54IC0gNCkgKiBkaWFnb25hbE5ldyAvIHRoYXQuZGlhZ29uYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDAgPSAodGhhdC5vcHBvc2l0ZVNoYXBlLnkgKyA0IC0gY2VudGVyUG9pbnQueSkgKiBkaWFnb25hbE5ldyAvIHRoYXQuZGlhZ29uYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlci5wdXNoKHRoYXQub3Bwb3NpdGVTaGFwZS54ICsgd2lkdGgwICsgNCwgdGhhdC5vcHBvc2l0ZVNoYXBlLnkgLSBoZWlnaHQwICsgNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOS4i++8jOWPs+S4i1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MtcmVzaXplJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZS1yZXNpemUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDAgPSAoY2VudGVyUG9pbnQueCAtIHRoYXQub3Bwb3NpdGVTaGFwZS54IC0gNCkgKiBkaWFnb25hbE5ldyAvIHRoYXQuZGlhZ29uYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDAgPSAoY2VudGVyUG9pbnQueSAtIHRoYXQub3Bwb3NpdGVTaGFwZS55IC0gNCkgKiBkaWFnb25hbE5ldyAvIHRoYXQuZGlhZ29uYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlci5wdXNoKHRoYXQub3Bwb3NpdGVTaGFwZS54ICsgd2lkdGgwICsgNCwgdGhhdC5vcHBvc2l0ZVNoYXBlLnkgKyBoZWlnaHQwICsgNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOW3pizlt6bkuItcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3LXJlc2l6ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3ctcmVzaXplJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgwID0gKHRoYXQub3Bwb3NpdGVTaGFwZS54ICsgNCAtIGNlbnRlclBvaW50LngpICogZGlhZ29uYWxOZXcgLyB0aGF0LmRpYWdvbmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQwID0gKGNlbnRlclBvaW50LnkgLSB0aGF0Lm9wcG9zaXRlU2hhcGUueSAtIDQpICogZGlhZ29uYWxOZXcgLyB0aGF0LmRpYWdvbmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXIucHVzaCh0aGF0Lm9wcG9zaXRlU2hhcGUueCAtIHdpZHRoMCArIDQsIHRoYXQub3Bwb3NpdGVTaGFwZS55ICsgaGVpZ2h0MCArIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luU2NhbGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogcmVjdFNjYWxlLnggLSBjZW50ZXJbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgeTogcmVjdFNjYWxlLnkgLSBjZW50ZXJbMV1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbic6IGNlbnRlcixcclxuICAgICAgICAgICAgICAgICAgICAnb3JpZ2luJzogW29yaWdpblNjYWxlLngsIG9yaWdpblNjYWxlLnldXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyDmraTml7boioLngrnljIXlm7Tnm5LpnIDopoHph43mlrDorqHnrpdcclxuICAgICAgICAgICAgICAgIHZhciByZWN0Tm93ID0gdXRpbC5nZXRSZWN0KGN1cnJlbnROb2RlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3JQb2ludFNjYWxlID0gdXRpbC5nZXRDb25uZWN0b3JQb2ludHMocmVjdE5vdywgY3VycmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xQb2ludFNjYWxlID0gdXRpbC5nZXRDb25uZWN0b3JDb250cm9scyhyZWN0Tm93LCBjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lmdyb3VwLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IGl0ZW0ucG9zO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT09IHRhcmdldFBvcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHIoJ3Bvc2l0aW9uJywgWzAsIDBdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ0Nvbm5lY3RDb250cm9sJyAmJiBwb3MgIT09IHBvc2l0aW9uT3JnW3RhcmdldFBvc10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRTaGFwZSh7IHg6IGNvbnRyb2xQb2ludFNjYWxlW3Bvc10ueCAtIDQsIHk6IGNvbnRyb2xQb2ludFNjYWxlW3Bvc10ueSAtIDQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYXR0cignb3JpZ2luJywgW2NvbnRyb2xQb2ludFNjYWxlW3Bvc10ueCwgY29udHJvbFBvaW50U2NhbGVbcG9zXS55XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09ICdDb25uZWN0Q29udHJvbExpbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0U2hhcGUoeyB4MTogY29udHJvbFBvaW50U2NhbGUubXRyLngsIHgyOiBjb250cm9sUG9pbnRTY2FsZS50Yy54LCB5MTogY29udHJvbFBvaW50U2NhbGUubXRyLnksIHkyOiBjb250cm9sUG9pbnRTY2FsZS50Yy55IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gJ0Nvbm5lY3RQb2ludCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRTaGFwZSh7IGN4OiBjb25uZWN0b3JQb2ludFNjYWxlW3Bvc10ueCwgY3k6IGNvbm5lY3RvclBvaW50U2NhbGVbcG9zXS55IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoYXQub3BlcmF0aW9uTm9kZS5yZWZyZXNoUG9zdGlvbih0aGF0LnNlbGVjdGVkTm9kZSwgdXRpbC5nZXRSZWN0KHRoYXQuc2VsZWN0ZWROb2RlKSk7XHJcbiAgICAgICAgICAgIC8vIDEuNSDliLfmlrDov57nur9cclxuICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZSh0aGF0LnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgIC8vIDEuNiDlpoLmnpzmmK/nu4TnmoTor50s6ZyA6KaB5oqK57uE5YaF5omA5pyJ57uT5p6c6YO95Yi35paw5LiA5LiL57q/XHJcbiAgICAgICAgICAgIGlmIChGbG93LmlzR3JvdXBOb2RlKHRoYXQuc2VsZWN0ZWROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RlZE5vZGUuZWFjaChmdW5jdGlvbihjaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKGNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmdyb3VwLm9uKFwiQ29ubmVjdENvbnRyb2w6ZHJhZ2VuZFwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIC8vIOabtOaWsOiKgueCuXBvc2l0aW9uXHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhhdC5zZWxlY3RDb25uTm9kZTtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gbm9kZS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IG5vZGUub3JpZ2luO1xyXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBvcmlnaW7lj5bmlbRcclxuICAgICAgICAgICAgdGhhdC5zZWxlY3RDb25uTm9kZS5hdHRyKCdwb3NpdGlvbicsIFtwYXJzZUludChwb3NpdGlvblswXSwgMTApLCBwYXJzZUludChwb3NpdGlvblsxXSwgMTApXSk7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9yaWdpbikpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0Q29ubk5vZGUuYXR0cignb3JpZ2luJywgW3BhcnNlSW50KG9yaWdpblswXSwgMTApLCBwYXJzZUludChvcmlnaW5bMV0sIDEwKV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUudXBkYXRlU2hhcGUoMSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChub2RlLm1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDmm7TmlrBtb2RlbO+8jOaUr+aMgeW6j+WIl+WMli/lj43luo/liJfljJZcclxuICAgICAgICAgICAgICAgIG5vZGUubW9kZWwuc2V0KFwib3B0aW9ucy5yb3RhdGlvblwiLCBub2RlLnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIG5vZGUubW9kZWwuc2V0KFwib3B0aW9ucy5vcmlnaW5cIiwgbm9kZS5vcmlnaW4pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbm9kZS5tb2RlbC5vcHRpb24uZWxlbWVudFR5cGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09ICdJbWFnZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLm1vZGVsLnNldChcIm9wdGlvbnMuc3R5bGVcIiwgbm9kZS5zdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUubW9kZWwuc2V0KFwib3B0aW9ucy5zaGFwZVwiLCBub2RlLnNoYXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAxLjQg6Kem5Y+R54K55Ye7XHJcbiAgICAgICAgICAgIHRoYXQubm9kZUNsaWNrSGFuZGxlcihub2RlKTtcclxuICAgICAgICAgICAgdGhhdC5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgICAgICB0aGF0Lm9wcG9zaXRlU2hhcGUgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGF0LmN1cnJlbnRTaGFwZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoYXQuZGlhZ29uYWwgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGF0Lm9yaWdpblJlY3QgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGF0LmlmUG9pbnRDZW50ZXIgPSBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uaW5pdE9wZXJhdGlvbk5vZGUgPSBmdW5jdGlvbiAobm9kZSwgaWZDdXJyZW50Tm9kZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBpZiAoIWlmQ3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgaWZDdXJyZW50Tm9kZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUgPSBuZXcgT3BlcmF0aW9uTm9kZShub2RlLCB0aGlzLmdyb3VwLCB0aGlzLl9hcGkpO1xyXG4gICAgICAgIC8vIOagueaNrui/nue6v+eCueafpeaJvuiKgueCuSjogIPomZHkvJjljJYg5Yib5bu66L+e5o6l54K555qE5pe25YCZIOWwseaKiui/nuaOpeeCueS4jm5vZGXov5vooYznu5HlrprvvIzlsLHkuI3nlKjov5nkuKrlpI3mnYLnmoTorqHnrpfkuoYpXHJcbiAgICAgICAgZnVuY3Rpb24gZmluZENvbm5lY3Rvck5vZGUoeCwgeSwgb2Zmc2V0LCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUsIGVuZFBvcyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoYXQuYWxsTm9kZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHV0aWwuZ2V0UmVjdChpdGVtKTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnBhcmVudCAmJiBGbG93LmlzR3JvdXBOb2RlKGl0ZW0ucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3QuYm91bmRpbmdSZWN0LnggKz0gRmxvdy5wYXJlbnRYKGl0ZW0ucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZWN0LmJvdW5kaW5nUmVjdC55ICs9IEZsb3cucGFyZW50WShpdGVtLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9yUG9pbnQgPSB1dGlsLmdldENvbm5lY3RvclBvaW50cyhyZWN0LCBpdGVtKTtcclxuICAgICAgICAgICAgICAgIGlmIChwb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbcG9zXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W3Bvc10ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImxlZnRcIl0ueCAtIHgpIDw9IG9mZnNldCAmJiBNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImxlZnRcIl0ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInRvcFwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1widG9wXCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJ0b3BcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInJpZ2h0XCJdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbXCJyaWdodFwiXS55IC0geSkgPD0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImJvdHRvbVwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wiYm90dG9tXCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJib3R0b21cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXHJcbiAgICAgICAgICAgICAgICBlbmRQb3M6IGVuZFBvc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHU1RBUlQsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgICAgIHRoYXQuZmlsdGVyQ29ubmVjdFBvaW50KHRoYXQuYWxsTm9kZXMsIGUuZXZlbnQudGFyZ2V0LmxpbmVUeXBlKTtcclxuICAgICAgICAgICAgdmFyIHggPSAoZS5ldmVudC5vZmZzZXRYIC0gdGhpcy5ncm91cC5wb3NpdGlvblswXSkgLyB0aGlzLm5vd1pvb207XHJcbiAgICAgICAgICAgIHZhciB5ID0gKGUuZXZlbnQub2Zmc2V0WSAtIHRoaXMuZ3JvdXAucG9zaXRpb25bMV0pIC8gdGhpcy5ub3dab29tO1xyXG4gICAgICAgICAgICBpZiAoZS5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVPcHQgPSBlLmRhdGE7ICAvL+e8k+WtmOe6v+auteeahOmFjee9ruS/oeaBr1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8v5ouW5ou95byA5aeL5YWI5oqKIOeureWktOWbvuaghyDnu5npmpDol49cclxuICAgICAgICAgICAgdmFyIGFycm93ID0gZS5ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgIGFycm93LmhpZGUoKTtcclxuICAgICAgICAgICAgdmFyIHJFbmRQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlVGVtcENvbm5lY3Rvcih0aGlzLnNlbGVjdGVkTm9kZSwgckVuZFBvaW50LFxyXG4gICAgICAgICAgICAgICAgYXJyb3cubGluZVR5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgLy8g5L6m5ZCsIOeureWktCDmi5bmi73kuovku7ZcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IChlLmV2ZW50Lm9mZnNldFggLSB0aGlzLmdyb3VwLnBvc2l0aW9uWzBdKSAvIHRoaXMubm93Wm9vbTtcclxuICAgICAgICAgICAgdmFyIHkgPSAoZS5ldmVudC5vZmZzZXRZIC0gdGhpcy5ncm91cC5wb3NpdGlvblsxXSkgLyB0aGlzLm5vd1pvb207XHJcbiAgICAgICAgICAgIHZhciBhcnJvdyA9IGUuZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICB2YXIgckVuZFBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm1hbmFnZVRlbXBDb25uZWN0b3IodGhpcy5zZWxlY3RlZE5vZGUsIHJFbmRQb2ludCwgYXJyb3cubGluZVR5cGUpO1xyXG4gICAgICAgICAgICB0aGF0Lmdyb3VwLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHYudHlwZSA9PT0gJ0Nvbm5lY3RQb2ludCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2LmF0dHIoe3N0eWxlOntmaWxsOiBcIiNGRkZGMzNcIn0sc2NhbGU6WzEsMV0sb3JpZ2luOlt2LnNoYXBlLmN4LHYuc2hhcGUuY3ldfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHYuc2hhcGUuY3ggLSB4KSA8PSAxMCAmJiBNYXRoLmFicyh2LnNoYXBlLmN5IC0geSkgPD0gMTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IGZpbmRDb25uZWN0b3JOb2RlKHgsIHksIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5tYW5hZ2VUZW1wQ29ubmVjdG9yKHRoYXQuc2VsZWN0ZWROb2RlLCByRW5kUG9pbnQsIGFycm93LmxpbmVUeXBlLCAncmlnaHQnLCByZXMuZW5kUG9zLCByZXMubm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYuYXR0cih7c3R5bGU6e2ZpbGw6IFwiI2ZmMDAwMFwifSxzY2FsZTpbMS41LDEuNV0sb3JpZ2luOlt2LnNoYXBlLmN4LHYuc2hhcGUuY3ldLGN1cnNvcjoncG9pbnRlcid9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICAvL+S+puWQrCDnrq3lpLQg5ouW5ou957uT5p2f5LqL5Lu2IOeUu+e6v1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZS5vbihPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUdFTkQsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHggPSAoZS5ldmVudC5vZmZzZXRYIC0gdGhhdC5ncm91cC5wb3NpdGlvblswXSkgLyB0aGF0Lm5vd1pvb207XHJcbiAgICAgICAgICAgIHZhciB5ID0gKGUuZXZlbnQub2Zmc2V0WSAtIHRoYXQuZ3JvdXAucG9zaXRpb25bMV0pIC8gdGhhdC5ub3dab29tO1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gZmluZENvbm5lY3Rvck5vZGUoeCwgeSwgMTApO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHJlcy5ub2RlO1xyXG4gICAgICAgICAgICB2YXIgZW5kUG9zID0gcmVzLmVuZFBvcyB8fCAnbGVmdCc7XHJcbiAgICAgICAgICAgIHZhciBhcnJvdyA9IGUuZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICAvL+aLluaLvee7k+adn+WFiOaKiiDnrq3lpLTlm77moIcg57uZ5pi+56S6XHJcbiAgICAgICAgICAgIGFycm93LnNob3coKTtcclxuICAgICAgICAgICAgLy/liKDpmaTkuLTml7bnur9cclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZW1vdmVUZW1wQ29ubmVjdG9yKHRoaXMuZ3JvdXApO1xyXG5cclxuICAgICAgICAgICAgLy8xLuWmguaenOaYr+WtkOiKgueCuSDlhoUg6IqC54K55ouW5ou9IOWImSDlop7liqDmjpLpmaTlrZDoioLngrnnmoTlj4LmlbBcclxuICAgICAgICAgICAgLy8gdGFyZ2V0Tm9kZSA9IGZpbmRIb3Zlcih0aGlzLmFsbE5vZGVzLCB4LCB5KTtcclxuXHJcbiAgICAgICAgICAgIC8vMi7lpoLmnpzmib7liLDnm67moIfnu5Pngrkg5YiZ55S757q/XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXROb2RlICYmICh0aGlzLnNlbGVjdGVkTm9kZSAhPSB0YXJnZXROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVUeXBlOiBhcnJvdy5saW5lVHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3M6ICdyaWdodCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvczogZW5kUG9zXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGZpbmFsT3B0ID0gdXRpbC5tZXJnZU9wdChjb25uZWN0T3B0aW9ucywgdGhhdC5saW5lT3B0LCB0cnVlLCAncG9zaXRpb24nKTtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHRoYXQuc2VsZWN0ZWROb2RlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHRhcmdldE5vZGU7XHJcbiAgICAgICAgICAgICAgICAvL+WmguaenOacieWOn+Wni+i/nue6v+WtmOWcqO+8jOWImeimgeaatOmcsuWHuuWOu+OAglxyXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQub3JpZ2luTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbi5zdGFydE5vZGUgPSB0aGF0LnNlbGVjdGVkTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4uZW5kTm9kZSA9IHRoYXQub3JpZ2luTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4ub3B0aW9ucyA9IHV0aWwubWVyZ2VPcHQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVR5cGU6IGFycm93LmxpbmVUeXBlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFBvczogdGhhdC5zdGFydFBvcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvczogdGhhdC5vcmlnaW5Qb3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoYXQubGluZU9wdCwgdHJ1ZSwgJ3Bvc2l0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZighdGhpcy5fdHJpZ2dlcignYmVmb3JlQ3JlYXRlJywge3RhcmdldDp0aGlzLnNlbGVjdGVkTm9kZSxlbmROb2RlOnRhcmdldE5vZGUsY29ubmVjdE9wdGlvbnM6Y29ubmVjdE9wdGlvbnMsIG9yaWdpbjoge319KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JCeU5vZGVzKHN0YXJ0LCBlbmQsIGZpbmFsT3B0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0LmhpZGVDb25uZWN0b3JQb2ludCgpO1xyXG4gICAgICAgICAgICAvLyDov57nur/miJDlip8v5aSx6LSl77yM5b2T5YmN6IqC54K55L6d54S25piv6YCJ5Lit54q25oCB77yM6ZyA6KaB6YeN5paw6K6h566X6Jma57q/5ZKM5Zu+5qCH5L2N572uXHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhhdC5zZWxlY3RlZE5vZGU7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZVJlY3QgPSB1dGlsLmdldFJlY3Qobm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIC8vIOaYvuekuuW9k+WJjeiKgueCueeahOi/nuaOpeeCuVxyXG4gICAgICAgICAgICB0aGF0LnNob3dDb25uZWN0b3JQb2ludCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoYXQub3BlcmF0aW9uTm9kZS5yZWZyZXNoUG9zdGlvbihub2RlLCBzaGFwZVJlY3QpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIC8v5Yig6Zmk5oyJ6ZKu54K55Ye75LqL5Lu2XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlLm9uKE9wZXJhdGlvbk5vZGUuREVMRVRFX0NMSUNLLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZSh0aGlzLnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLm9wZXJhdGlvbk5vZGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLnJlbW92ZVNlbGVjdGVkTm9kZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWROb2Rlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQucmVtb3ZlTm9kZShpdGVtLCB7fSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoYXQuc2VsZWN0ZWROb2Rlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3Qub2ZmKFwibW91c2Vkb3duXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZSh0aGlzLmRyYWdTZWxlY3RSZWN0KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoYXQuc2VsZWN0ZWROb2RlKSB7XHJcbiAgICAgICAgICAgIHRoYXQucmVtb3ZlTm9kZSh0aGF0LnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgIC8vIDEuIOmakOiXj+i/nue6v+eCuVxyXG4gICAgICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JQb2ludCgpO1xyXG4gICAgICAgICAgICAvLyAyLiDpmpDol4/mjqfliLbngrlcclxuICAgICAgICAgICAgdGhpcy5oaWRlQ29ubmVjdG9yQ29udHJvbCgpO1xyXG4gICAgICAgICAgICAvLyAzLiDpmpDol4/mk43kvZxub2RlXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZU9wZXJhdGlvbk5vZGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uZmluZE5vZGVDaGlsZElkcyA9IGZ1bmN0aW9uIChub2RlLCBjaGlsZElkcykge1xyXG4gICAgICAgIGNoaWxkSWRzLnB1c2gobm9kZS5pZCk7XHJcbiAgICAgICAgbm9kZS5jaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5hbGxOb2Rlcy5maW5kSW5kZXgoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmlkID09PSB2LmlkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcG9zICE9PSAtMVxyXG4gICAgICAgIH0uYmluZCh0aGlzKSkuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7XHJcbiAgICAgICAgICAgIGlmIChGbG93LmlzR3JvdXBOb2RlKHN1YikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmluZE5vZGVDaGlsZElkcyhzdWIsIGNoaWxkSWRzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkSWRzLnB1c2goc3ViLmlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vpmaTlnLrmma/kuK3nmoTmn5DkuKroioLngrnmiJbogIXnur/mrrUs5ZCMcmVtb3ZlTm9kZVxyXG4gICAgICogQG1ldGhvZCByZW1vdmVcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbm9kZSBvciBsaW5rIOW+heWIoOmZpOeahOiKgueCueaIluiAhee6v+autVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSDlj4LmlbBcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJpZ2dlcj10cnVlXSDmmK/lkKbop6blj5HliKDpmaTkuovku7ZcclxuICAgICAqXHJcbiAgICAgKiAgKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgZmlzaFRvcG8ucmVtb3ZlKHBlb3BsZU5vZGUpO1xyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vpmaTlnLrmma/kuK3nmoTmn5DkuKroioLngrnmiJbogIXnur/mrrUs5ZCMcmVtb3ZlXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZU5vZGVcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbm9kZSBvciBsaW5rIOW+heWIoOmZpOeahOiKgueCueaIluiAhee6v+autVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSDlj4LmlbBcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJpZ2dlcj10cnVlXSDmmK/lkKbop6blj5HliKDpmaTkuovku7ZcclxuICAgICAqXHJcbiAgICAgKiAgKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgZmlzaFRvcG8ucmVtb3ZlTm9kZShwZW9wbGVOb2RlKTtcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5yZW1vdmUgPSBmaXNoVG9wb1Byb3RvLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAoZGVsTm9kZSwgb3B0aW9ucywgaXNOb0NvdW50KSB7XHJcbiAgICAgICAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgaWYob3B0LnRyaWdnZXIgIT09ZmFsc2UgJiYgKCF0aGlzLl90cmlnZ2VyKCdiZWZvcmVEZWxldGUnLCB7dGFyZ2V0OmRlbE5vZGV9KSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFyZW50WnIgPSB0aGlzLl9nZXRQYXJlbnRacihkZWxOb2RlKTtcclxuICAgICAgICBpZiAoZGVsTm9kZSBpbnN0YW5jZW9mIENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAvLyAxLjEg5Yig6Zmk57q/5q615LiK55qE5pON5L2c5Zu+5qCHXHJcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGRlbE5vZGUuaWNvbnMsIGZ1bmN0aW9uKGxpbmVPcGVyYXRpb25JY29uKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRaci5yZW1vdmUobGluZU9wZXJhdGlvbkljb24pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAvLyAxLjIg5Yig6Zmk5b2T5YmN6YCJ5Lit57q/5q61XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZGVsZXRlQnlMaW5lKGRlbE5vZGUscGFyZW50WnIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vMi4xIOWIoOmZpOiKgueCuVxyXG4gICAgICAgICAgICBwYXJlbnRaci5yZW1vdmUoZGVsTm9kZSk7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZElkcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoRmxvdy5pc0dyb3VwTm9kZShkZWxOb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maW5kTm9kZUNoaWxkSWRzKGRlbE5vZGUsIGNoaWxkSWRzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkSWRzLnB1c2goZGVsTm9kZS5pZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8yLuS7jmFsbE5vZGVz5pWw57uE5Lit5Yig6ZmkXHJcbiAgICAgICAgICAgIHRoaXMuYWxsTm9kZXMgPSB0aGlzLmFsbE5vZGVzLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkSWRzLmluZGV4T2Yodi5pZCkgPT09IC0xXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLzIuMyDliKDpmaTlkozoioLngrnnm7jlhbPogZTnmoTnur/mrrVcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5kZWxldGVTZWxlY3RDb24oZGVsTm9kZSwgdGhpcy5ncm91cCk7XHJcbiAgICAgICAgICAgIC8vMi40IOWIoOmZpOiKgueCueaTjeS9nFxyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVPcGVyYXRpb25Ob2RlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDEuIOmakOiXj+i/nue6v+eCuVxyXG4gICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgLy8gMi4g6ZqQ6JeP5o6n5Yi254K5XHJcbiAgICAgICAgdGhpcy5oaWRlQ29ubmVjdG9yQ29udHJvbCgpO1xyXG4gICAgICAgIC8vMy4g5riF56m66L+e5o6l57q/5LiK55qE6LCD5pW05L2N572u5oyJ6ZKuXHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jbGVhclNlbGVjdENvbigpO1xyXG4gICAgICAgIC8vNC4g5riF56m66L+e5o6l57q/5LiK55qE5pON5L2c5oyJ6ZKuXHJcbiAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5oaWRlQWxsTGluZU9wZXJhdGlvbigpO1xyXG4gICAgICAgIGlmIChpc05vQ291bnQgIT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0ZXBDb3VudGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vNC4g5rS+5Y+R5Yig6Zmk5LqL5Lu2XHJcbiAgICAgICAgIHRoaXMuX3RyaWdnZXIoXCJkZWxldGVcIiwge3RhcmdldDpkZWxOb2RlfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6YCJ5Lit5Zy65pmv5Lit55qE5p+Q5Liq6IqC54K5LOW5tuS4lOinpuWPkXNlbGVjdE5vZGXkuovku7ZcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIOW+hemAieS4reeahOiKgueCueWvueixoVxyXG4gICAgICogQHNpbmNlIFYyLjMuMFxyXG4gICAgICogICoq5L2/55So6IyD5L6L77yaKipcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBmaXNoVG9wby5zZWxlY3ROb2RlKG5vZGUpO1xyXG4gICAgICovXHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5zZWxlY3ROb2RlID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZUNsaWNrSGFuZGxlcihub2RlKTtcclxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcihcInNlbGVjdE5vZGVcIiwge3RhcmdldDpub2RlfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruiKgueCueWIm+W7uui/nue6v1xyXG4gICAgICogQG1ldGhvZCBjcmVhdGVDb25uZWN0b3JCeU5vZGVzXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHN0YXJ0Tm9kZSDlvIDlp4voioLngrlcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZW5kTm9kZSAgIOe7k+adn+iKgueCuVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIOe6v+autemAiemhuSDlj4Lop4F7QGxpbmsgZmlzaFRvcG9GbG93LmxpbmsjY29uc3RydWN0b3Ig5p6E6YCg5Ye95pWwb3B0aW9uc+WPguaVsH1cclxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IHRyaWdnZXIg5piv5ZCm6Kem5Y+RY3JlYXRl5LqL5Lu277yM6buY6K6k5piv6Kem5Y+RY3JlYXRl5LqL5Lu277yM6K6+572u5Li6ZmFsc2XliJnkuI3op6blj5FcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5jcmVhdGVDb25uZWN0b3JCeU5vZGVzID0gZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgb3B0aW9ucywgdHJpZ2dlcikge1xyXG4gICAgICAgIHZhciBsaW5rVHlwZSA9IG9wdGlvbnMuc3R5bGUubGluZVR5cGUgfHwgQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQ7XHJcbiAgICAgICAgaWYgKCFmbG93TGlua1tsaW5rVHlwZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBMaW5rID0gZmxvd0xpbmtbbGlua1R5cGVdO1xyXG4gICAgICAgIHZhciBjb25uZWN0b3IgPSBuZXcgTGluayhzdGFydE5vZGUsIGVuZE5vZGUsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuYWRkKGNvbm5lY3Rvcik7XHJcblxyXG4gICAgICAgIGlmIChzdGFydE5vZGUucGFyZW50ICYmIGVuZE5vZGUucGFyZW50ICYmIHN0YXJ0Tm9kZS5wYXJlbnQ9PWVuZE5vZGUucGFyZW50ICkge1xyXG4gICAgICAgICAgICBlbmROb2RlLnBhcmVudC5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvckZvcmJpZEVkaXQoIXRoaXMub3B0aW9ucy5saW5rTW9kaWZ5KTtcclxuICAgICAgICAvLyDlpITnkIbnur/mrrXkuKTnq6/nmoTosIPmlbRkcmFn5LqL5Lu2XHJcbiAgICAgICAgdGhpcy5jcmVhdGVDb25uZWN0b3JEcmFnRXZlbnRzKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgY29ubmVjdG9yLm9uKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNOb2RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIOWPlua2iOiKgueCueeahOmAieS4rVxyXG4gICAgICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JQb2ludCgpO1xyXG4gICAgICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JDb250cm9sKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZU9wZXJhdGlvbk5vZGUoKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5zaG93Q29ubmVjdG9yUG9pbnQoZS50YXJnZXQuc3R5bGUubGluZVR5cGUpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY29ubmVjdG9yLm9uKFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRleHRFZGl0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JFZGl0KHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICBpZiAodHJpZ2dlciAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcihcImNyZWF0ZVwiLCB7IHRhcmdldDogY29ubmVjdG9yIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0ZXBDb3VudGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlpITnkIbov57nur/lkozov57mjqXngrlkcmFn5LqL5Lu2XHJcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVMaW5lRHJhZ1xyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBkcmFnVHlwZSBkcmFn57G75Z6LXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGUgICBldmVudOS6i+S7tuWvueixoVxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBsaW5lVHlwZSDov57nur/nsbvlnotcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5faGFuZGxlTGluZURyYWcgPSBmdW5jdGlvbihkcmFnVHlwZSwgZSwgbGluZVR5cGUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgZnVuY3Rpb24gZmluZENvbm5lY3Rvck5vZGUoeCwgeSwgb2Zmc2V0LCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUsIGVuZFBvcyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoYXQuYWxsTm9kZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHV0aWwuZ2V0UmVjdChpdGVtKTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnBhcmVudCAmJiBGbG93LmlzR3JvdXBOb2RlKGl0ZW0ucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3QuYm91bmRpbmdSZWN0LnggKz0gRmxvdy5wYXJlbnRYKGl0ZW0ucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZWN0LmJvdW5kaW5nUmVjdC55ICs9IEZsb3cucGFyZW50WShpdGVtLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9yUG9pbnQgPSB1dGlsLmdldENvbm5lY3RvclBvaW50cyhyZWN0LCBpdGVtKTtcclxuICAgICAgICAgICAgICAgIGlmIChwb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbcG9zXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W3Bvc10ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImxlZnRcIl0ueCAtIHgpIDw9IG9mZnNldCAmJiBNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImxlZnRcIl0ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInRvcFwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1widG9wXCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJ0b3BcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInJpZ2h0XCJdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbXCJyaWdodFwiXS55IC0geSkgPD0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcImJvdHRvbVwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wiYm90dG9tXCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJib3R0b21cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXHJcbiAgICAgICAgICAgICAgICBlbmRQb3M6IGVuZFBvc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgeCA9IChlLmV2ZW50Lm9mZnNldFggLSB0aGF0Lmdyb3VwLnBvc2l0aW9uWzBdKSAvIHRoYXQubm93Wm9vbTtcclxuICAgICAgICB2YXIgeSA9IChlLmV2ZW50Lm9mZnNldFkgLSB0aGF0Lmdyb3VwLnBvc2l0aW9uWzFdKSAvIHRoYXQubm93Wm9vbTtcclxuICAgICAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XHJcbiAgICAgICAgaWYgKGRyYWdUeXBlID09PSAnZHJhZycpIHtcclxuICAgICAgICAgICAgaWYgKHRoYXQucmV2ZXJzZUNvbm5lY3QpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlUmV2ZXJzZVRlbXBDb25uZWN0b3IocG9pbnQsIHRoYXQuc2VsZWN0Q29ubk5vZGUsIGxpbmVUeXBlLCB0aGF0LmVuZFBvcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLm1hbmFnZVRlbXBDb25uZWN0b3IodGhhdC5zZWxlY3RDb25uTm9kZSwgcG9pbnQsIGxpbmVUeXBlLCB0aGF0LnN0YXJ0UG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0Lmdyb3VwLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHYudHlwZSA9PT0gJ0Nvbm5lY3RQb2ludCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2LmF0dHIoe3N0eWxlOntmaWxsOiBcIiNGRkZGMzNcIn0sc2NhbGU6WzEsMV0sb3JpZ2luOlt2LnNoYXBlLmN4LHYuc2hhcGUuY3ldfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHYuc2hhcGUuY3ggLSB4KSA8PSAxMCAmJiBNYXRoLmFicyh2LnNoYXBlLmN5IC0geSkgPD0gMTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IGZpbmRDb25uZWN0b3JOb2RlKHgsIHksIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQucmV2ZXJzZUNvbm5lY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlUmV2ZXJzZVRlbXBDb25uZWN0b3IocG9pbnQsIHRoYXQuc2VsZWN0Q29ubk5vZGUsIGxpbmVUeXBlLCB0aGF0LmVuZFBvcywgcmVzLmVuZFBvcywgcmVzLm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5tYW5hZ2VUZW1wQ29ubmVjdG9yKHRoYXQuc2VsZWN0Q29ubk5vZGUsIHBvaW50LCBsaW5lVHlwZSwgdGhhdC5zdGFydFBvcywgcmVzLmVuZFBvcywgcmVzLm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYuYXR0cih7c3R5bGU6e2ZpbGw6IFwiI2ZmMDAwMFwifSxzY2FsZTpbMS41LDEuNV0sb3JpZ2luOlt2LnNoYXBlLmN4LHYuc2hhcGUuY3ldLGN1cnNvcjoncG9pbnRlcid9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkcmFnVHlwZSA9PT0gJ2RyYWdlbmQnKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSBmaW5kQ29ubmVjdG9yTm9kZSh4LCB5LCAxMCk7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gcmVzLm5vZGU7XHJcbiAgICAgICAgICAgIHZhciBlbmRQb3MgPSByZXMuZW5kUG9zIHx8ICdsZWZ0JztcclxuICAgICAgICAgICAgLy/liKDpmaTkuLTml7bnur9cclxuICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5yZW1vdmVUZW1wQ29ubmVjdG9yKHRoYXQuZ3JvdXApO1xyXG4gICAgICAgICAgICAvLzIu5aaC5p6c5om+5Yiw55uu5qCH57uT54K5IOWImeeUu+e6v1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSAmJiAodGhhdC5zZWxlY3RDb25uTm9kZS5pZCAhPT0gdGFyZ2V0Tm9kZS5pZCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBjb25uZWN0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lVHlwZTogbGluZVR5cGVcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zOiB0aGF0LnJldmVyc2VDb25uZWN0ID8gZW5kUG9zIDogdGhhdC5zdGFydFBvcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zOiB0aGF0LnJldmVyc2VDb25uZWN0ID8gdGhhdC5lbmRQb3MgOiBlbmRQb3NcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZmluYWxPcHQgPSB1dGlsLm1lcmdlT3B0KGNvbm5lY3RPcHRpb25zLCB0aGF0LmxpbmVPcHQsIHRydWUsICdwb3NpdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhhdC5yZXZlcnNlQ29ubmVjdCA/IHRhcmdldE5vZGUgOiB0aGF0LnNlbGVjdENvbm5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHRoYXQucmV2ZXJzZUNvbm5lY3QgPyB0aGF0LnNlbGVjdENvbm5Ob2RlIDogdGFyZ2V0Tm9kZTtcclxuICAgICAgICAgICAgICAgIC8v5aaC5p6c5pyJ5Y6f5aeL6L+e57q/5a2Y5Zyo77yM5YiZ6KaB5pq06Zyy5Ye65Y6744CCXHJcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5vcmlnaW5Ob2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luLnN0YXJ0Tm9kZSA9IHRoYXQucmV2ZXJzZUNvbm5lY3QgPyB0aGF0Lm9yaWdpbk5vZGUgOiB0aGF0LnNlbGVjdENvbm5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbi5lbmROb2RlID0gdGhhdC5yZXZlcnNlQ29ubmVjdCA/IHRoYXQuc2VsZWN0Q29ubk5vZGUgOiB0aGF0Lm9yaWdpbk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luLm9wdGlvbnMgPSB1dGlsLm1lcmdlT3B0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVUeXBlOiBsaW5lVHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3M6IHRoYXQucmV2ZXJzZUNvbm5lY3QgPyB0aGF0Lm9yaWdpblBvcyA6IHRoYXQuc3RhcnRQb3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3M6IHRoYXQucmV2ZXJzZUNvbm5lY3QgPyB0aGF0LmVuZFBvcyA6IHRoYXQub3JpZ2luUG9zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCB0aGF0LmxpbmVPcHQsIHRydWUsICdwb3NpdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoIXRoYXQuX3RyaWdnZXIoJ2JlZm9yZUNyZWF0ZScsIHt0YXJnZXQ6IHN0YXJ0LCBlbmROb2RlOiBlbmQsIGNvbm5lY3RPcHRpb25zOiBmaW5hbE9wdCwgb3JpZ2luOiBvcmlnaW59KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoYXQuY3JlYXRlQ29ubmVjdG9yQnlOb2RlcyhzdGFydCwgZW5kLCBmaW5hbE9wdCk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmhpZGVDb25uZWN0b3JQb2ludCgpOyAgICAgIC8v6ZqQ6JeP5omA5pyJ6IqC54K55LiK55qE6L+e5o6l54K5XHJcbiAgICAgICAgICAgICAgICAvLyDmgaLlpI3pgInkuK3moLflvI9cclxuICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9wZXJhdGlvbk5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNob3dDb25uZWN0b3JQb2ludCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL+i/mOWOn+aJgOaciei/nuaOpeeCueeahOminOiJslxyXG4gICAgICAgICAgICAgICAgdGhhdC5ncm91cC5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodi50eXBlID09PSAnQ29ubmVjdFBvaW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2LmF0dHIoe3N0eWxlOntmaWxsOiBcIiNGRkZGMzNcIn0sc2NhbGU6WzEsMV0sb3JpZ2luOlt2LnNoYXBlLmN4LHYuc2hhcGUuY3ldLGN1cnNvcjonY3Jvc3NoYWlyJ30pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uY3JlYXRlQ29ubmVjdG9yRHJhZ0V2ZW50cyA9IGZ1bmN0aW9uIChjb25uZWN0b3IpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgY29ubmVjdG9yLm9uKFwiZHJhZ3N0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gKGUuZXZlbnQub2Zmc2V0WCAtIHRoYXQuZ3JvdXAucG9zaXRpb25bMF0pIC8gdGhhdC5ub3dab29tO1xyXG4gICAgICAgICAgICB2YXIgeSA9IChlLmV2ZW50Lm9mZnNldFkgLSB0aGF0Lmdyb3VwLnBvc2l0aW9uWzFdKSAvIHRoYXQubm93Wm9vbTtcclxuICAgICAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0O1xyXG4gICAgICAgICAgICB2YXIgbGluZVR5cGUgPSBvcHQuc3R5bGUubGluZVR5cGU7XHJcbiAgICAgICAgICAgIHZhciBkb2NrZXJzID0gdGhpcy5tb2RlbC5vcHRpb24ub3B0aW9ucy5kb2NrZXJzO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRQb2ludCA9IGRvY2tlcnNbMF07XHJcbiAgICAgICAgICAgIHZhciBlbmRQb2ludCA9IGRvY2tlcnNbZG9ja2Vycy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0RGlmZiA9IE1hdGguYWJzKHggLSBzdGFydFBvaW50LngpICsgTWF0aC5hYnMoeSAtIHN0YXJ0UG9pbnQueSk7XHJcbiAgICAgICAgICAgIHZhciBlbmREaWZmID0gTWF0aC5hYnMoeCAtIGVuZFBvaW50LngpICsgTWF0aC5hYnMoeSAtIGVuZFBvaW50LnkpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnREaWZmID4gMTUgJiYgZW5kRGlmZiA+IDE1KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xyXG4gICAgICAgICAgICB0aGF0LmZpbHRlckNvbm5lY3RQb2ludCh0aGF0LmFsbE5vZGVzLCBsaW5lVHlwZSk7XHJcbiAgICAgICAgICAgIHRoYXQucmV2ZXJzZUNvbm5lY3QgPSBmYWxzZTsgICAvL+aYr+WQpuWPjeWQkei/nue6v+eahOagh+ivhlxyXG4gICAgICAgICAgICB0aGF0LnNlbGVjdENvbm5Ob2RlID0gY29ubmVjdG9yLnN0YXJ0Tm9kZTtcclxuICAgICAgICAgICAgaWYgKGVuZERpZmYgPD0gMTUpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0Q29ubk5vZGUgPSBjb25uZWN0b3Iuc3RhcnROb2RlO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zdGFydFBvcyA9IG9wdC5wb3NpdGlvbi5zdGFydFBvcztcclxuICAgICAgICAgICAgICAgIHRoYXQub3JpZ2luTm9kZSA9IHRoaXMuZW5kTm9kZTtcclxuICAgICAgICAgICAgICAgIHRoYXQub3JpZ2luUG9zID0gb3B0LnBvc2l0aW9uLmVuZFBvcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhcnREaWZmIDw9IDE1KSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnJldmVyc2VDb25uZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0Q29ubk5vZGUgPSBjb25uZWN0b3IuZW5kTm9kZTtcclxuICAgICAgICAgICAgICAgIHRoYXQuZW5kUG9zID0gb3B0LnBvc2l0aW9uLmVuZFBvcztcclxuICAgICAgICAgICAgICAgIHRoYXQub3JpZ2luTm9kZSA9IHRoaXMuc3RhcnROb2RlO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5vcmlnaW5Qb3MgPSBvcHQucG9zaXRpb24uc3RhcnRQb3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5kZWxldGVCeUxpbmUodGhpcywgdGhhdC5ncm91cCk7XHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3JMaW5lO1xyXG4gICAgICAgICAgICBpZiAodGhhdC5yZXZlcnNlQ29ubmVjdCkge1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yTGluZSA9IHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlUmV2ZXJzZVRlbXBDb25uZWN0b3IocG9pbnQsIHRoYXQuc2VsZWN0Q29ubk5vZGUsIGxpbmVUeXBlLCB0aGF0LmVuZFBvcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3JMaW5lID0gdGhhdC5jb25uZWN0aW9uTWFuYWdlci5tYW5hZ2VUZW1wQ29ubmVjdG9yKHRoYXQuc2VsZWN0Q29ubk5vZGUsIHBvaW50LCBsaW5lVHlwZSwgdGhhdC5zdGFydFBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhhdC5ncm91cC5hZGQoY29ubmVjdG9yTGluZSk7XHJcbiAgICAgICAgICAgIGNvbm5lY3RvckxpbmUuc2V0U2VsZWN0ZWRTdHlsZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbm5lY3Rvci5vbihcImRyYWdcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdGhhdC5faGFuZGxlTGluZURyYWcoJ2RyYWcnLCBlLCB0aGlzLm9wdC5zdHlsZS5saW5lVHlwZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29ubmVjdG9yLm9uKFwiZHJhZ2VuZFwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB0aGF0Ll9oYW5kbGVMaW5lRHJhZygnZHJhZ2VuZCcsIGUsIHRoaXMub3B0LnN0eWxlLmxpbmVUeXBlKTtcclxuICAgICAgICAgICAgdGhhdC5oaWRlQ29ubmVjdG9yUG9pbnQoKTtcclxuICAgICAgICAgICAgdGhhdC5oaWRlQ29ubmVjdG9yQ29udHJvbCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOa0vuWPkeWIm+W7uuWujOaIkOS6i+S7tiAg6L+U5ZueZmFsZXPliJnlj5bmtohcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5fdHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUsIGV2ZW50LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5vcHRpb25zW3R5cGVdO1xyXG5cclxuICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSBkYXRhID0ge307XHJcbiAgICAgICAgaWYgKGV2ZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGV2ZW50ID0ge3R5cGU6dHlwZSwgdGFyZ2V0OnRoaXN9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXZlbnQudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50LmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuX2FwaS50cmlnZ2VyKGV2ZW50LnR5cGUsIGV2ZW50KTtcclxuICAgICAgICByZXR1cm4gISh6clV0aWwuaXNGdW5jdGlvbihjYWxsYmFjaykgJiYgY2FsbGJhY2suYXBwbHkodGhpcywgW2V2ZW50XS5jb25jYXQoZGF0YSkpID09PSBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8ubm9kZUNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgLy8g57uE57yp5pS+5oiQ55qE5Zu+54mH6IqC54K55LiN5Y+v5pyJ54K55Ye754q25oCBXHJcbiAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gJ0dST1VQX1JFTEFUSU9OX0lNQUdFJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpZlNob3dQb2ludCA9IG5vZGUudHlwZSAhPT0gJ2RyYWdTZWxlY3QnO1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC50eXBlID09PSBcImRyYWdTZWxlY3RcIikge1xyXG4gICAgICAgICAgICBpZlNob3dQb2ludCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAxLiDpmpDol4/ov57nur/ngrlcclxuICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JQb2ludCgpO1xyXG4gICAgICAgIC8vIDIuIOmakOiXj+aOp+WItueCuVxyXG4gICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvckNvbnRyb2woKTtcclxuICAgICAgICAvLyAzLiDpmpDol4/mk43kvZxub2RlXHJcbiAgICAgICAgdGhpcy5fcmVtb3ZlT3BlcmF0aW9uTm9kZSgpO1xyXG4gICAgICAgIC8vIOm8oOagh+eCueS4iyDlsIbmk43kvZzmoYYg56e75Yiw5a+55bqU55qE6IqC54K55LiKXHJcbiAgICAgICAgaWYgKG5vZGUuc2VsZWN0YWJsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKEZsb3cuaXNJbkdyb3VwKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBub2RlLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChncm91cC5zZWxlY3RhYmxlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGdyb3VwOyAgIC8vIOWmguaenOaciee7hOeahOivne+8jOWwsemSiOWvuee7hOi/m+ihjOWkhOeQhlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGVkTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgdmFyIHNoYXBlUmVjdCA9IHV0aWwuZ2V0UmVjdChub2RlLHRydWUpO1xyXG4gICAgICAgIGlmICghdGhpcy5vcGVyYXRpb25Ob2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdE9wZXJhdGlvbk5vZGUobm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpZlNob3dQb2ludCkge1xyXG4gICAgICAgICAgICAvLyDmmL7npLrlvZPliY3oioLngrnnmoTov57mjqXngrlcclxuICAgICAgICAgICAgdGhpcy5zaG93Q29ubmVjdG9yUG9pbnQodW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5yZXR1cm5Db25uZWN0b3JDb250cm9sUGFyYW0obm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMuc2NhbGVhYmxlIHx8IHBhcmFtcy5yb3RhdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIOaYvuekuuW9k+WJjeiKgueCueeahOaOp+WItueCuVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93Q29ubmVjdG9yQ29udHJvbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOWcqOWtmOWcqOWtkOa1geeoi+eahOaDheWGteS4iyDpnIDopoHmiopub2Rl5Lmf5Lyg6YCS5LiA5LiLXHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlLnJlZnJlc2hQb3N0aW9uKG5vZGUsIHNoYXBlUmVjdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOiKgueCueeahOenu+WKqOaTjeS9nCwg5Li65L2V6KaB6Ieq5bex5a6e546w5ouW5Yqo77yfenJlZG5lciBHcm91cOS4jeaUr+aMgeaLluWKqO+8jOWPquiDveiHquW3seWunueOsFxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmRyYWcgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpczsgLy8genJlbmRlcuS4reeahOS4gOS4qmJ1ZyBldmVudC50YXJnZXTkuI3kvJrluKZncm91cCDlj6rog73nlKh0aGF0IOS4jeiDveeUqGJpbmQodGhpcylcclxuICAgICAgICBub2RlLm9uKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAvL+WmguaenOWKoOS6huWxnuaApyBkcmFnZ2FibGU6ZmFsc2XmiJbogIXmi5bmi73moYbpgInph4wg5YiZ5LiN5Y+v5Lul5ouW5YqoXHJcbiAgICAgICAgICAgIGlmICh0aGF0Lmp1ZGdlSWZSZWFkTW9kZShkcmFnZ2luZ1RhcmdldCkgfHwgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnR5cGUgPT09IFwiZHJhZ1NlbGVjdFwiKSB8fCAobm9kZS5zdHlsZSAmJiBub2RlLnN0eWxlLmZpbGwgPT09ICdub25lJykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0Ll9ub2RlRHJhZ0hhbmRsZXIoZHJhZ2dpbmdUYXJnZXQsIGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xyXG4gICAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiDlkJHkuIrpgJLlvZLoioLngrnorqHnrpdncm91cFJlY3RcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5fcmVjdXJtb2RpZnlHcm91cFJlY3QgPSBmdW5jdGlvbihub2RlLCBncm91cE5vZGUsIG1vdmVPYmopIHtcclxuICAgICAgICBpZiAobm9kZS5uYW1lID09PSAnR1JPVVBfUkVMQVRJT05fSU1BR0UnICYmIGdyb3VwTm9kZSkge1xyXG4gICAgICAgICAgICAvLyDlpoLmnpzoioLngrnmmK9fcmVsYXRpb25JbWFnZeiKgueCue+8jOeUqOWFtuS7luWkhOeQhuaWueW8j1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVPcGVyYXRpb25Ob2RlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlY3VybW9kaWZ5UmVsYXRpb25JbWFnZUdyb3VwUmVjdChub2RlLCBncm91cE5vZGUsIG1vdmVPYmosIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoRmxvdy5pc0luR3JvdXAobm9kZSkpIHtcclxuICAgICAgICAgICAgLy/mlL7lhaVub2Rl546w5pyJ5pWw5YC877yM55So5LqO6YeN57uYZ3JvdXBcclxuICAgICAgICAgICAgdmFyIG5vZGVNZXNzYWdlID0ge1xyXG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBub2RlLnBvc2l0aW9uXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIG5vZGUucGFyZW50Lm1vZGlmeUdyb3VwUmVjdChub2RlTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBGbG93LmlzR3JvdXBOb2RlKG5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdXJtb2RpZnlHcm91cFJlY3Qobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOW9k+WJjeenu+WKqOiKgueCueS4ul9yZWxhdGlvbkltYWdl77yM5L+d6K+BX3JlbGF0aW9uSW1hZ2Xnm7jlhbPnmoRncm91cE5vZGXkuI3lj6/otoXlh7rniLZncm91cE5vZGVcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gaW1hZ2UgX3JlbGF0aW9uSW1hZ2XoioLngrlcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZ3JvdXBOb2RlIOS4jl9yZWxhdGlvbkltYWdl6IqC54K557qn6IGU55qEZ3JvdXBOb2RlXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG1vdmVPYmogX3JlbGF0aW9uSW1hZ2XoioLngrnnmoTnp7vliqjlj4LmlbBcclxuICAgICAqIEBwYXJhbSAge0Jvb2xhZW59IGZsYWcgZ3JvdXBOb2Rl6IqC54K5cG9zaXRpb27mmK/lkKbpnIDopoHliqDkuIrlvZPliY3oioLngrnnmoTnp7vliqjlj4LmlbBcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5fcmVjdXJtb2RpZnlSZWxhdGlvbkltYWdlR3JvdXBSZWN0ID0gZnVuY3Rpb24oaW1hZ2UsIGdyb3VwTm9kZSwgbW92ZU9iaiwgZmxhZykge1xyXG4gICAgICAgIGlmIChGbG93LmlzSW5Hcm91cChncm91cE5vZGUpKSB7XHJcbiAgICAgICAgICAgIC8vIOmHjeaWsOiuoeeul3Bvc2l0aW9uXHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHpyVXRpbC5jbG9uZShncm91cE5vZGUucG9zaXRpb24pO1xyXG4gICAgICAgICAgICBpZiAoZmxhZykge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBbcG9zaXRpb25bMF0gKyBtb3ZlT2JqLm1vdmVYLCBwb3NpdGlvblsxXSArIG1vdmVPYmoubW92ZVldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBub2RlTWVzc2FnZSA9IHtcclxuICAgICAgICAgICAgICAgIG5vZGU6IGdyb3VwTm9kZSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBncm91cE5vZGUucGFyZW50Lm1vZGlmeUdyb3VwUmVjdChub2RlTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGlmIChncm91cE5vZGUucGFyZW50ICYmIEZsb3cuaXNHcm91cE5vZGUoZ3JvdXBOb2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3VybW9kaWZ5UmVsYXRpb25JbWFnZUdyb3VwUmVjdChpbWFnZSwgZ3JvdXBOb2RlLnBhcmVudCwgbW92ZU9iaiwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOe7hOiKgueCueWQkeS4i+mAkuW9kuWIt+aWsOi/nue6v1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLl9yZWN1cmVSZWZyZXNoTGluZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICBpZiAoRmxvdy5pc0dyb3VwTm9kZShub2RlKSAmJiBub2RlLl9yZWxhdGlvbkltYWdlKSB7XHJcbiAgICAgICAgICAgIG5vZGUuZWFjaChmdW5jdGlvbihjaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUoY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChGbG93LmlzR3JvdXBOb2RlKGNoaWxkTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLmlnbm9yZSAmJiBjaGlsZE5vZGUuX3JlbGF0aW9uSW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5pu05paw57uE6IqC54K555qEX3JlbGF0aW9uSW1hZ2XnmoTov57nur9cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZShjaGlsZE5vZGUuX3JlbGF0aW9uSW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWN1cmVSZWZyZXNoTGluZShjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOWIm+W7ul9yZWxhdGlvbkltYWdl55qE6L+e57q/XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlbGF0aW9uSW1hZ2UgICDnu4TnvKnmlL7lm77niYfoioLngrlcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gcmVsYXRpb25Ob2RlICAgIOe7hOiKgueCuVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLl9jcmVhdGVSZWxhdGlvbkltYWdlTGluZSA9IGZ1bmN0aW9uKHJlbGF0aW9uSW1hZ2UsIHJlbGF0aW9uTm9kZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgc3RhcnRzID0gW10sIGVuZHMgPSBbXTtcclxuICAgICAgICAvLyDot6jnu4Tpl7TnmoTov57nur/pg73lrZjlnKjlhajlsYBcclxuICAgICAgICB2YXIgY29ubmVjdG9ycyA9IHRoaXMuZ3JvdXAuX2NoaWxkcmVuLmZpbHRlcihmdW5jdGlvbihjaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZSBpbnN0YW5jZW9mIENvbm5lY3RvciAmJiBjaGlsZE5vZGUubmFtZSAhPT0gJ0dST1VQX1JFTEFUSU9OX0xJTkUnO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBncm91cElubmVyTm9kZXMgPSB0aGlzLmZpbmRHcm91cE5vZGVzKHJlbGF0aW9uTm9kZSk7XHJcbiAgICAgICAgY29ubmVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChncm91cElubmVyTm9kZXMuc29tZShmdW5jdGlvbihjaGlsZE5vZGUpIHsgcmV0dXJuIGNoaWxkTm9kZS5pZCA9PT0gbGluZS5lbmROb2RlLmlkO30pKSB7XHJcbiAgICAgICAgICAgICAgICBpZihncm91cElubmVyTm9kZXMuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7IHJldHVybiBjaGlsZC5pZCA9PT0gbGluZS5zdGFydE5vZGUuaWR9KS5sZW5ndGggPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHpyVXRpbC5jbG9uZShsaW5lLm9wdCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZTogbGluZS5zdGFydE5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE5vZGU6IHJlbGF0aW9uSW1hZ2VcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ3JvdXBJbm5lck5vZGVzLnNvbWUoZnVuY3Rpb24oY2hpbGROb2RlKSB7IHJldHVybiBjaGlsZE5vZGUuaWQgPT09IGxpbmUuc3RhcnROb2RlLmlkO30pKSB7XHJcbiAgICAgICAgICAgICAgICBpZihncm91cElubmVyTm9kZXMuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7IHJldHVybiBjaGlsZC5pZCA9PT0gbGluZS5lbmROb2RlLmlkfSkubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHpyVXRpbC5jbG9uZShsaW5lLm9wdCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZTogcmVsYXRpb25JbWFnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTm9kZTogbGluZS5lbmROb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyDkuKTkuKroioLngrnpl7TlrZjlnKjlpJrmnaHnm7jlkIznmoTov57nur/pnIDopoHljZXni6zlpITnkIbvvIzorqHnrpfov57nur/pl7TnmoTpl7TpmpTvvIzpgb/lhY3ph43lkIhcclxuICAgICAgICB2YXIgZmluZEluZGV4ID0gZnVuY3Rpb24obGluZU9wdEFycmF5LCBsaW5lT3B0KSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVPcHRBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBsaW5lT3B0QXJyYXlbaV1bMF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGFydE5vZGUuaWQgPT09IGxpbmVPcHQuc3RhcnROb2RlLmlkICYmIGl0ZW0uZW5kTm9kZS5pZCA9PT0gbGluZU9wdC5lbmROb2RlLmlkICYmIEpTT04uc3RyaW5naWZ5KGl0ZW0ub3B0aW9ucy5wb3NpdGlvbikgPT09IEpTT04uc3RyaW5naWZ5KGxpbmVPcHQub3B0aW9ucy5wb3NpdGlvbikgJiYgaXRlbS5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09PSBsaW5lT3B0Lm9wdGlvbnMuc3R5bGUubGluZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FsY3VsYXRlID0gIGZ1bmN0aW9uKGxpbmVPcHRBcnJheSkge1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gbGluZU9wdEFycmF5Lmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0genJVdGlsLmNsb25lKGxpbmVPcHRBcnJheVswXS5vcHRpb25zLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IGxpbmVPcHRBcnJheVswXS5zdGFydE5vZGU7XHJcbiAgICAgICAgICAgIHZhciBlbmROb2RlID0gbGluZU9wdEFycmF5WzBdLmVuZE5vZGU7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFJlY3QgPSBzdGFydE5vZGUuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgIHZhciBlbmRSZWN0ID0gZW5kTm9kZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0TGVuZ3RoS2V5ID0gKHBvc2l0aW9uLnN0YXJ0UG9zID09PSAndG9wJyB8fCBwb3NpdGlvbi5zdGFydFBvcyA9PT0gJ2JvdHRvbScpID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xyXG4gICAgICAgICAgICB2YXIgZW5kTGVuZ3RoS2V5ID0gKHBvc2l0aW9uLmVuZFBvcyA9PT0gJ3RvcCcgfHwgcG9zaXRpb24uZW5kUG9zID09PSAnYm90dG9tJykgPyAnd2lkdGgnIDogJ2hlaWdodCc7XHJcbiAgICAgICAgICAgIHZhciBzdGFydExlbiA9IHN0YXJ0UmVjdFtzdGFydExlbmd0aEtleV07XHJcbiAgICAgICAgICAgIHZhciBlbmRMZW4gPSBlbmRSZWN0W2VuZExlbmd0aEtleV07XHJcbiAgICAgICAgICAgIHZhciBzdGFydFNwYWNlID0gcGFyc2VJbnQoc3RhcnRMZW4gLyAobGVuZ3RoICsgMSksIDEwKTtcclxuICAgICAgICAgICAgdmFyIGVuZFNwYWNlID0gcGFyc2VJbnQoZW5kTGVuIC8gKGxlbmd0aCArIDEpLCAxMCk7XHJcbiAgICAgICAgICAgIHZhciBpZk9kZCA9IGxlbmd0aCAlIDIgIT09IDA7XHJcbiAgICAgICAgICAgIHZhciBjZW50ZXJJbmRleCA9IGlmT2RkID8gTWF0aC5jZWlsKGxlbmd0aCAvIDIpIDogbGVuZ3RoIC8gMjtcclxuICAgICAgICAgICAgbGluZU9wdEFycmF5LmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpZk9kZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOWlh+aVsFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoaW5kZXggKyAxKSA8IGNlbnRlckluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3B0aW9ucy5wb3NpdGlvbi5zdGFydFBvcyA9IHBvc2l0aW9uLnN0YXJ0UG9zICsgJy0nICsgKHN0YXJ0U3BhY2UgKiAoY2VudGVySW5kZXggLSBpbmRleCAtIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vcHRpb25zLnBvc2l0aW9uLmVuZFBvcyA9IHBvc2l0aW9uLmVuZFBvcyArICctJyArIChlbmRTcGFjZSAqIChjZW50ZXJJbmRleCAtIGluZGV4IC0gMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGluZGV4ICsgMSkgPiBjZW50ZXJJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm9wdGlvbnMucG9zaXRpb24uc3RhcnRQb3MgPSBwb3NpdGlvbi5zdGFydFBvcyArICcrJyArIChzdGFydFNwYWNlICogKGluZGV4ICsgMSAtIGNlbnRlckluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3B0aW9ucy5wb3NpdGlvbi5lbmRQb3MgPSBwb3NpdGlvbi5lbmRQb3MgKyAnKycgKyAoZW5kU3BhY2UgKiAoaW5kZXggKyAxIC0gY2VudGVySW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOWBtuaVsFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoaW5kZXggKyAxKSA8PSBjZW50ZXJJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm9wdGlvbnMucG9zaXRpb24uc3RhcnRQb3MgPSBwb3NpdGlvbi5zdGFydFBvcyArICctJyArIChzdGFydFNwYWNlICogKGNlbnRlckluZGV4IC0gaW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vcHRpb25zLnBvc2l0aW9uLmVuZFBvcyA9IHBvc2l0aW9uLmVuZFBvcyArICctJyArIChlbmRTcGFjZSAqIChjZW50ZXJJbmRleCAtIGluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vcHRpb25zLnBvc2l0aW9uLnN0YXJ0UG9zID0gcG9zaXRpb24uc3RhcnRQb3MgKyAnKycgKyAoc3RhcnRTcGFjZSAqIChpbmRleCArIDEgLSBjZW50ZXJJbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm9wdGlvbnMucG9zaXRpb24uZW5kUG9zID0gcG9zaXRpb24uZW5kUG9zICsgJysnICsgKGVuZFNwYWNlICogKGluZGV4ICsgMSAtIGNlbnRlckluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGN5Y2xlID0gZnVuY3Rpb24obGluZU9wdEFycmF5KSB7XHJcbiAgICAgICAgICAgIGlmIChsaW5lT3B0QXJyYXkubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbGluZU9wdENodW5rID0gW107XHJcbiAgICAgICAgICAgIGxpbmVPcHRBcnJheS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lT3B0Q2h1bmsucHVzaChbaXRlbV0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVySW5kZXggPSBmaW5kSW5kZXgobGluZU9wdENodW5rLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVySW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT3B0Q2h1bmtbZmlsdGVySW5kZXhdLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU9wdENodW5rLnB1c2goW2l0ZW1dKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxpbmVPcHRDaHVuay5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBpdGVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGluZU9wdEFycmF5LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVOb2RlID0gdGhhdC5jcmVhdGVDb25uZWN0b3JCeU5vZGVzKGl0ZW0uc3RhcnROb2RlLCBpdGVtLmVuZE5vZGUsIGl0ZW0ub3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBsaW5lTm9kZS5uYW1lID0gJ0dST1VQX1JFTEFUSU9OX0xJTkUnO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICBjeWNsZShlbmRzKTtcclxuICAgICAgICBjeWNsZShzdGFydHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOWIoOmZpF9yZWxhdGlvbkltYWdl55qE6L+e57q/XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlbGF0aW9uSW1hZ2UgICDnu4TnvKnmlL7lm77niYfoioLngrlcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5fcmVtb3ZlUmVsYXRpb25JbWFnZUxpbmUgPSBmdW5jdGlvbihyZWxhdGlvbkltYWdlKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb25uZWN0b3JzID0gdGhpcy5ncm91cC5fY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlIGluc3RhbmNlb2YgQ29ubmVjdG9yICYmIGNoaWxkTm9kZS5uYW1lID09PSAnR1JPVVBfUkVMQVRJT05fTElORSc7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGNvbm5lY3RvcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25uZWN0b3JzLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnROb2RlLmlkID09PSByZWxhdGlvbkltYWdlLmlkIHx8IGxpbmUuZW5kTm9kZS5pZCA9PT0gcmVsYXRpb25JbWFnZS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQucmVtb3ZlKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5pu05paw57uE55qEX3JlbGF0aW9uSW1hZ2XkvY3nva5cclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbm9kZSAgIOW9k+WJjee7hOiKgueCuVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zICAg56e75Yqo5Y+C5pWwXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uX3JlZnJlc2hSZWxhdGlvbkltYWdlUG9zaXRpb24gPSBmdW5jdGlvbihub2RlLCBpc01vdmUpIHtcclxuICAgICAgICBpZiAoRmxvdy5pc0dyb3VwTm9kZShub2RlKSAmJiBpc01vdmUgPT09IDEpIHtcclxuICAgICAgICAgICAgbm9kZS5yZWZyZXNoUmVsYXRpb25JbWFnZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLl9ub2RlRHJhZ0hhbmRsZXIgPSBmdW5jdGlvbiAobm9kZSwgeCwgeSkge1xyXG4gICAgICAgIHZhciBpc01vdmUgPSAwO1xyXG4gICAgICAgIHZhciB0cyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG5vd0dyb3VwUG9zaXRpb24gPSBub2RlLnBvc2l0aW9uO1xyXG4gICAgICAgIHZhciBncm91cFBvc2l0aW9uWCA9IG5vZGUucG9zaXRpb25bMF07XHJcbiAgICAgICAgdmFyIGdyb3VwUG9zaXRpb25ZID0gbm9kZS5wb3NpdGlvblsxXTtcclxuICAgICAgICB2YXIgcmVsYXRpb25JbWFnZUdyb3VwTm9kZTsgLy8g6K6w5b2VX3JlbGF0aW9uSW1hZ2XnmoTniLboioLngrlcclxuICAgICAgICBub2RlLl9zdGFydFggPSB4O1xyXG4gICAgICAgIG5vZGUuX3N0YXJ0WSA9IHk7XHJcbiAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gJ0dST1VQX1JFTEFUSU9OX0lNQUdFJykge1xyXG4gICAgICAgICAgICByZWxhdGlvbkltYWdlR3JvdXBOb2RlID0genJVdGlsLmZpbmQodGhpcy5hbGxOb2RlcywgZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZS5pZCA9PT0gbm9kZS5yZWxhdGVkR3JvdXBJZDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiZHJhZ1NlbGVjdFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBhbGxMaW5lcyA9IHRoaXMuZ3JvdXAuY2hpbGRyZW4oKS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2Lm1vZGVsICYmIHYubW9kZWwub3B0aW9uLmVsZW1lbnRUeXBlID09PSBcImNvbm5lY3Rpb25cIjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMuZHJhZ1NlbGVjdFJlY3QuY2hpbGRyZW4oKS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2Lm5hbWUgIT09IFwiR1JPVVBfUkVDVF9OQU1FXCIgJiYgdi5tb2RlbCAmJiB2Lm1vZGVsLm9wdGlvbi5lbGVtZW50VHlwZSAhPT0gXCJjb25uZWN0aW9uXCI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0aGlzLmRyYWdTZWxlY3RSZWN0LmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5uYW1lICE9PSBcIkdST1VQX1JFQ1RfTkFNRVwiICYmIHYubW9kZWwgJiYgdi5tb2RlbC5vcHRpb24uZWxlbWVudFR5cGUgPT09IFwiY29ubmVjdGlvblwiO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYWxsTGluZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IHpyVXRpbC5maW5kKHRoaXMuYWxsTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuaWQgPT09IHYuc3RhcnROb2RlLmlkXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmROb2RlID0genJVdGlsLmZpbmQobm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuaWQgPT09IHYuZW5kTm9kZS5pZFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWZFeGlzdCA9IGxpbmVzLmZpbmRJbmRleChmdW5jdGlvbihsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmUuaWQgPT09IHYuaWRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKChzdGFydE5vZGUgfHwgZW5kTm9kZSkgJiYgaWZFeGlzdCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cy5jb25uZWN0aW9uTWFuYWdlci5yZW1vdmVMaW5lKHYsIHRzLl9nZXRQYXJlbnRacih2KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlLnRyaWdnZXIoXCJkcmFnc3RhcnRcIik7XHJcbiAgICAgICAgLy8gMeOAgeS+puWQrOenu+WKqOS6i+S7tlxyXG5cclxuICAgICAgICB2YXIgbW92ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHNYID0gKGV2ZW50Lm9mZnNldFggLSBub2RlLl9zdGFydFgpIC8gKHRoaXMubm93Wm9vbSk7XHJcbiAgICAgICAgICAgIHZhciBzWSA9IChldmVudC5vZmZzZXRZIC0gbm9kZS5fc3RhcnRZKSAvICh0aGlzLm5vd1pvb20pO1xyXG5cclxuICAgICAgICAgICAgaWYgKChzWCAhPSAwKSB8fCAoc1kgIT0gMCkpIHtcclxuICAgICAgICAgICAgICAgIGlzTW92ZSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZS50cmlnZ2VyKFwiZHJhZ1wiKTtcclxuICAgICAgICAgICAgLy8gMS4x5aSE55CG57uE5YaF55qE5oOF5Ya177yI5aaC5p6c6IqC54K55ouW5Yqo77yM57uE5Lmf6Lef552A5Y+Y77yJXHJcbiAgICAgICAgICAgIHRoaXMuX3JlY3VybW9kaWZ5R3JvdXBSZWN0KG5vZGUsIHJlbGF0aW9uSW1hZ2VHcm91cE5vZGUsIHtcclxuICAgICAgICAgICAgICAgIG1vdmVYOiBzWCxcclxuICAgICAgICAgICAgICAgIG1vdmVZOiBzWSxcclxuICAgICAgICAgICAgICAgIGlzTW92ZTogaXNNb3ZlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBub3dHcm91cFBvc2l0aW9uWzBdID0gZ3JvdXBQb3NpdGlvblggKyBzWDtcclxuICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblsxXSA9IGdyb3VwUG9zaXRpb25ZICsgc1k7XHJcbiAgICAgICAgICAgIG5vZGUuYXR0cihcInBvc2l0aW9uXCIsIG5vd0dyb3VwUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAvLyDnu4TnmoRfcmVsYXRpb25JbWFnZeS9jee9ruabtOaWsFxyXG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoUmVsYXRpb25JbWFnZVBvc2l0aW9uKG5vZGUsIGlzTW92ZSk7XHJcbiAgICAgICAgICAgIC8vIDEuMiDlpITnkIblkYrorabnmoTmg4XlhrUg77yI5ZGK6K2m6ZqP552A6IqC54K556e75Yqo77yJXHJcbiAgICAgICAgICAgIGlmIChub2RlLmFsYXJtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3QWxhcm1Qb3NpdGlvbiA9IFtub3dHcm91cFBvc2l0aW9uWzBdICsgbm9kZS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtIChub2RlLmFsYXJtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtIDYpLCBub3dHcm91cFBvc2l0aW9uWzFdIC0gbm9kZS5hbGFybS5nZXRCb3VuZGluZ1JlY3QoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5oZWlnaHQgLSAzXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5hbGFybS5hdHRyKFwicG9zaXRpb25cIiwgbmV3QWxhcm1Qb3NpdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gMS40IOinpuWPkeeCueWHu1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVDbGlja0hhbmRsZXIobm9kZSk7XHJcbiAgICAgICAgICAgIC8vIDEuNSDliLfmlrDov57nur9cclxuICAgICAgICAgICAgdGhpcy5fcmVjdXJlUmVmcmVzaExpbmUobm9kZSk7XHJcbiAgICAgICAgICAgIGlmICghRmxvdy5pc0luR3JvdXAobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIOe7hOe8qeaUvuS4jei/m+ihjOiDjOaZr+minOiJsuWIh+aNolxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXAuX2NoaWxkcmVuLnNvbWUoZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbS5uYW1lID09PSAnR1JPVVBfUkVMQVRJT05fSU1BR0UnfSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmlzUG9zSW5Hcm91cCh0aGlzLmFsbE5vZGVzLCBub2RlKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5hbGxOb2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoRmxvdy5pc0dyb3VwTm9kZShpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAgJiYgaXRlbS5pZCA9PT0gZ3JvdXAuaWQgJiYgaXRlbS5pZCAhPT0gbm9kZS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jaGlsZHJlbigpLmZpbmQoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5uYW1lID09PSBcIkdST1VQX1JFQ1RfTkFNRVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IFwiI2I2ZTNmNVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v5oGi5aSNZ3JvdXDnmoTog4zmma/oibJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4oKS5maW5kKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYubmFtZSA9PT0gXCJHUk9VUF9SRUNUX05BTUVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBcInJnYmEoMCwwLDAsMClcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fenIub24oJ21vdXNlbW92ZScsIG1vdmVIYW5kbGVyKTtcclxuXHJcblxyXG5cclxuICAgICAgICAvLzIuIOaLluaLvee7k+adn1xyXG4gICAgICAgIHZhciBlbmREcmFnSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUubW9kZWwpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUubW9kZWwuc2V0KFwib3B0aW9ucy5wb3NpdGlvblwiLCBGbG93VXRpbC50cnVuY1Bvc2l0aW9uKG5vZGUucG9zaXRpb24pKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fenIub2ZmKCdtb3VzZW1vdmUnLCBtb3ZlSGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3pyLm9mZignbW91c2V1cCcsIGVuZERyYWdIYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5fenIub2ZmKFwiZ2xvYmFsb3V0XCIsIGVuZERyYWdIYW5kbGVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vMi4xIOe8qeW+ruWbvlxyXG4gICAgICAgICAgICBpZiAoaXNNb3ZlID09IDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXCJkcm9wRHJhZ1wiLCB7dGFyZ2V0Om5vZGV9KTtcclxuICAgICAgICAgICAgICAgIG5vZGUudHJpZ2dlcihcImRyYWdlbmRcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lYWdsZUV5ZSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuRWFnbGVFeWUodGhpcy5lYWdsZUV5ZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFGbG93LmlzSW5Hcm91cChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOe7hOe8qeaUvuS4jei/m+ihjOiDjOaZr+minOiJsuWIh+aNolxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwLl9jaGlsZHJlbi5zb21lKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ubmFtZSA9PT0gJ0dST1VQX1JFTEFUSU9OX0lNQUdFJ30pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5pc1Bvc0luR3JvdXAodGhpcy5hbGxOb2Rlcywgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFsbE5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEZsb3cuaXNHcm91cE5vZGUoaXRlbSkgJiYgaXRlbS5pZCA9PT0gZ3JvdXAuaWQgJiYgaXRlbS5pZCAhPT0gbm9kZS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRaciA9IHRoaXMuX2dldFBhcmVudFpyKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFpyLnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmFkZChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVggPSBGbG93LmlzR3JvdXBOb2RlKG5vZGUpID8gbm9kZS5wb3NpdGlvblswXSArIG5vZGUub3B0aW9ucy5zaGFwZS54IDogbm9kZS5wb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVkgPSBGbG93LmlzR3JvdXBOb2RlKG5vZGUpID8gbm9kZS5wb3NpdGlvblsxXSArIG5vZGUub3B0aW9ucy5zaGFwZS55IDogbm9kZS5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBYID0gdGhpcy5wYXJlbnRYKGdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBZID0gdGhpcy5wYXJlbnRZKGdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmF0dHIoXCJwb3NpdGlvblwiLCBbbm9kZVggLSBncm91cFggKyBpdGVtLm9wdGlvbnMuc2hhcGUueCwgbm9kZVkgLSBncm91cFkgKyBpdGVtLm9wdGlvbnMuc2hhcGUueV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4oKS5maW5kKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2Lm5hbWUgPT09IFwiR1JPVVBfUkVDVF9OQU1FXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBcInJnYmEoMCwwLDAsMClcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3pyLm9uKCdtb3VzZXVwJywgZW5kRHJhZ0hhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuX3pyLm9uKCdnbG9iYWxvdXQnLCBlbmREcmFnSGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBmaXNoVG9wb1Byb3RvLnBhcmVudFggPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBGbG93LmlzR3JvdXBOb2RlKG5vZGUucGFyZW50KSAmJiB0aGlzLmdyb3VwLmlkICE9PSBub2RlLnBhcmVudC5pZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblswXSArIG5vZGUub3B0aW9ucy5zaGFwZS54ICsgdGhpcy5wYXJlbnRYKG5vZGUucGFyZW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblswXSArIG5vZGUub3B0aW9ucy5zaGFwZS54O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLnBhcmVudFkgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBGbG93LmlzR3JvdXBOb2RlKG5vZGUucGFyZW50KSAmJiB0aGlzLmdyb3VwLmlkICE9PSBub2RlLnBhcmVudC5pZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblsxXSArIG5vZGUub3B0aW9ucy5zaGFwZS55ICsgdGhpcy5wYXJlbnRZKG5vZGUucGFyZW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblsxXSArIG5vZGUub3B0aW9ucy5zaGFwZS55O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLmlzUG9zSW5Hcm91cCA9IGZ1bmN0aW9uIChhbGxOb2Rlcywgbm9kZSkge1xyXG4gICAgICAgIGlmIChhbGxOb2Rlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSBudWxsO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBhbGxOb2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChGbG93LmlzR3JvdXBOb2RlKGdyb3VwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cFdpZHRoID0gZ3JvdXAub3B0aW9ucy5zaGFwZS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBIZWlnaHQgPSBncm91cC5vcHRpb25zLnNoYXBlLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBYID0gdGhpcy5wYXJlbnRYKGdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBZID0gdGhpcy5wYXJlbnRZKGdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHV0aWwuZ2V0UmVjdChub2RlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlWCA9IHJlY3QueCAtIG5vZGVXaWR0aC8yO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlWSA9IHJlY3QueSAtIG5vZGVIZWlnaHQvMjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVggPj0gZ3JvdXBYICYmIG5vZGVZID49IGdyb3VwWSAmJiBub2RlWCtub2RlV2lkdGggPD0gZ3JvdXBYK2dyb3VwV2lkdGggJiYgbm9kZVkrbm9kZUhlaWdodCA8PSBncm91cFkrZ3JvdXBIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZ3JvdXAuY2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YiA9IHRoaXMuaXNQb3NJbkdyb3VwKGNoaWxkcmVuLCBub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gc3ViID8gc3ViIDogZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uuiKgueCuVxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVOb2RlXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGUg57G75Z6LIGVnLiAnUmVjdCfjgIEnQ2lyY2xlJ+OAgSdJbWFnZSfjgIEnR3JvdXAn44CBJ1RleHQn562JXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdCDoioLngrnpgInpobkg6K+m6KeBe0BsaW5rIGZpc2hUb3BvRmxvdy5ub2RlIENvbmZpZyBvcHRpb25zfVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVzZXJEYXRhIOeUqOaIt+S8oOmAkueahOS4muWKoeaVsOaNrlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSDliJvlu7rnmoToioLngrnlr7nosaFcclxuICAgICAqXHJcbiAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICB2YXIgcmVjdCA9IHRoaXMuZmlzaFRvcG8uY3JlYXRlTm9kZShcIlJlY3RcIiwgeyAvL+efqeW9olxyXG4gICAgICogICAgICAgICAgc2hhcGU6IHtcclxuICAgICAqICAgICAgICAgICAgICB3aWR0aDogMTAwLFxyXG4gICAgICogICAgICAgICAgICAgIGhlaWdodDogNjAsXHJcbiAgICAgKiAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgc3R5bGU6IHtcclxuICAgICAqICAgICAgICAgICAgICB0ZXh0OiBcIuWfuuacrOefqeW9olwiLFxyXG4gICAgICogICAgICAgICAgICAgIGZpbGw6IFwiIzE2N0NGRlwiLFxyXG4gICAgICogICAgICAgICAgICAgIHN0cm9rZTogXCJyZ2IoMjU1LDI1NSwyNTUpXCIsXHJcbiAgICAgKiAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxNHB4IE1pY3Jvc29mdCBZYUhlaSdcclxuICAgICAqICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICBwb3NpdGlvbjogWzE4MCwgMTAwXSxcclxuICAgICAqICAgICAgICAgIG9wZXJhdGlvbkljb25zOiBbeyBuYW1lOiAnREVMJyB9LFxyXG4gICAgICogICAgICAgICAgICAgIHsgbmFtZTogJ1NUUkFJR0hUJyB9LFxyXG4gICAgICogICAgICAgICAgICAgIHsgbmFtZTogJ0pBR0dFRCcgfSxcclxuICAgICAqICAgICAgICAgICAgICB7IG5hbWU6ICdDVVJWRScgfSxcclxuICAgICAqICAgICAgICAgICAgICB7XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiY3VzdG9tMVwiLFxyXG4gICAgICogICAgICAgICAgICAgICAgICBpY29uUGF0aDogXCJpbWcvaG9zdC5wbmdcIixcclxuICAgICAqICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKGUpIHsgYWxlcnQoZS5kYXRhLm5hbWUgKyBcIiBjbGlja2VkXCIpIH0gIC8vZS5ub2Rl5piv5b2T5YmN55qE6IqC54K5XHJcbiAgICAgKiAgICAgICAgICAgICAgfVxyXG4gICAgICogICAgICAgICAgXVxyXG4gICAgICogICAgICB9KTtcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5jcmVhdGVOb2RlID0gZmlzaFRvcG9Qcm90by5jcmVhdE5vZGUgPSBmdW5jdGlvbiAodHlwZSwgb3B0LCB1c2VyRGF0YSkge1xyXG4gICAgICAgIGlmICghZmxvd05vZGVbdHlwZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBTaGFwZSA9IGZsb3dOb2RlW3R5cGVdO1xyXG4gICAgICAgIHZhciBub2RlID0gbmV3IFNoYXBlKG9wdCk7XHJcblxyXG4gICAgICAgIEZsb3cuc2V0VXNlckRhdGEobm9kZSwgdXNlckRhdGEpO1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNrm5hbWXojrflj5boioLngrlcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSDlnKjliJvlu7roioLngrnkuK0gIG5hbWXlsZ7mgKforr7nva7nmoTlgLxcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICBuYW1l5a+55bqU55qE6IqC54K5XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY2hpbGRPZk5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBhcnJSZXN1bHQgPSBbXTtcclxuICAgICAgICB2YXIgY2hpbGRyZW5Ob2RlID0gdGhpcy5hbGxOb2RlcztcclxuICAgICAgICB2YXIgY2hpbGRyZW5MaW5lID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5Ob2RlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbk5vZGVbaV0ubW9kZWwuZ2V0KFwib3B0aW9ucy5uYW1lXCIpICYmIGNoaWxkcmVuTm9kZVtpXS5tb2RlbC5nZXQoXCJvcHRpb25zLm5hbWVcIikgPT1cclxuICAgICAgICAgICAgICAgIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGFyclJlc3VsdC5wdXNoKGNoaWxkcmVuTm9kZVtpXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ob2RlW2ldLm1vZGVsLmdldChcInVzZXJEYXRhLm5hbWVcIikgPT0gbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgYXJyUmVzdWx0LnB1c2goY2hpbGRyZW5Ob2RlW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkcmVuTGluZS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5MaW5lW2pdLm1vZGVsLmdldChcIm9wdGlvbnMubmFtZVwiKSAmJiBjaGlsZHJlbkxpbmVbal0ubW9kZWwuZ2V0KFwib3B0aW9ucy5uYW1lXCIpID09XHJcbiAgICAgICAgICAgICAgICBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJSZXN1bHQucHVzaChjaGlsZHJlbkxpbmVbal0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuTGluZVtqXS5tb2RlbC5nZXQoXCJ1c2VyRGF0YS5uYW1lXCIpID09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGFyclJlc3VsdC5wdXNoKGNoaWxkcmVuTGluZVtqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFyclJlc3VsdC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJSZXN1bHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyclJlc3VsdFswXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5p+l5om+5Zy65pmv5Lit55qE5a+56LGhICAg5L6L5aaCOiB45Z2Q5qCH5aSn5LqOMTAw55qE6IqC54K5IGZpbmRFbGVtZW50cyhmdW5jdGlvbihub2RlKXsgcmV0dXJuIG5vZGUucG9zaXRpb25bMF0gPiAxMDA7IH0pO1xyXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiICAgICAg5Zue6LCD5Ye95pWwIOWPguaVsOS4uumBjeWOhueahOiKgueCuVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgIGNvbnRleHQg5Zue6LCD5Ye95pWw5omn6KGM55qE5LiK5LiL5paHXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgIOi/lOWbnuafpeaJvuWIsOeahOWvueixoVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmZpbmRFbGVtZW50cyA9IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBjaGlsZHJlbk5vZGUgPSB0aGlzLmFsbE5vZGVzO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbkxpbmUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnM7XHJcbiAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5Ob2RlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuTm9kZVtpXTtcclxuICAgICAgICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpKSB7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZHJlbkxpbmUubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkTCA9IGNoaWxkcmVuTGluZVtqXTtcclxuICAgICAgICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgY2hpbGRMLCBqKSkge1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goY2hpbGRMKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruiKgueCueafpeaJvui/nue6vyAgIOS+i+Wmgjog6buY6K6k5p+l5om+5byA5aeL6IqC54K555qE6L+e57q/IGZpbmRDb25uZWN0b3JzQnlOb2RlKG5vZGUpO1xyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgIG5vZGUgICAg6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgb3B0aW9ucyDmmK/lkKbmn6Xmib7lvIDlp4voioLngrlcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgIOi/lOWbnuafpeaJvuWIsOeahOWvueixoVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmZpbmRDb25uZWN0b3JzQnlOb2RlID0gZnVuY3Rpb24gKG5vZGUsb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgIHpyVXRpbC5kZWZhdWx0cyhvcHRzLCB7XHJcbiAgICAgICAgICAgIHN0YXJ0Tm9kZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbkxpbmUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnM7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZHJlbkxpbmUubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkTCA9IGNoaWxkcmVuTGluZVtqXTtcclxuICAgICAgICAgICAgaWYgKG9wdHMuc3RhcnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZihjaGlsZEwuc3RhcnROb2RlLmlkID09PSBub2RlLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goY2hpbGRMKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmKGNoaWxkTC5lbmROb2RlLmlkID09PSBub2RlLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goY2hpbGRMKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuvue9ruiDjOaZr+iJsiAg5oiWIOiDjOaZr+WbvueJh1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGltYWdlVXJsIOiDjOaZr+iJsiAg5oiWIOiDjOaZr+WbvueJhyBlZy4gJ2ltZy9iZy5qcGcn77yM5Li64oCYZ3JpZExpbmXigJnml7bnvZHmoLzog4zmma9cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpc1JlcGVhdCDmmK/lkKbph43lpI3og4zmma8gIOWmguaenOmHjeWkjeeahOivne+8jOWwhuS9v+eUqGNzc+eahHJlcGVhdCDlm6DkuLpjYW52YXPkuI3mlK/mjIFyZXBlYXRcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5zZXRCYWNrZ3JvdW5kID0gZnVuY3Rpb24gKGltYWdlVXJsLCBpc1JlcGVhdCkge1xyXG4gICAgICAgIGlmIChpbWFnZVVybCAmJiBpbWFnZVVybC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KENvbnN0YW50cy5CQUNLR1JPVU5ELCBpbWFnZVVybCk7XHJcbiAgICAgICAgICAgIGlmIChpbWFnZVVybC5zdWJzdHIoMCwgMSkgPT0gXCIjXCIgfHwgaW1hZ2VVcmwuc3Vic3RyKDAsIDQpID09IFwicmdiYVwiKSB7IC8v5aaC5p6c5piv6aKc6Imy5Yib5bu6cmVjdOS4uuiDjOaZr1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9tLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGltYWdlVXJsO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VTaGFwZSA9IG5ldyB0aGlzLlNoYXBlLlJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuX3pyLmdldFdpZHRoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuX3pyLmdldEhlaWdodCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBpbWFnZVVybFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgejogLTFcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl96ci5hZGQoaW1hZ2VTaGFwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGltYWdlVXJsID09IFwiZ3JpZExpbmVcIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkTGluZUdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZExpbmUoMC4yKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzLmdyaWRMaW5lR3JvdXApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0IHx8IGlzUmVwZWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9tLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IFwidXJsKFwiICsgaW1hZ2VVcmwgKyBcIilcIjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb20uc3R5bGUuYmFja2dyb3VuZFJlcGVhdCA9IFwicmVwZWF0XCI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVNoYXBlMSA9IG5ldyB0aGlzLlNoYXBlLkltYWdlKHsgLy/lpoLmnpzmmK/lm77niYfliJvlu7ppbWFnZeS4uuiDjOaZr1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogWzAsIDBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogWzEsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2VVcmwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5fenIuZ2V0V2lkdGgoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5fenIuZ2V0SGVpZ2h0KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHo6IC0xXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fenIuYWRkKGltYWdlU2hhcGUxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy/og4zmma/nvZHmoLznur9cclxuICAgIGZpc2hUb3BvUHJvdG8uZ3JpZExpbmUgPSBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG4gICAgICAgIHZhciBwaXhlbCA9IDEwO1xyXG4gICAgICAgIHZhciB3aWR0aExlbiA9IHBhcnNlSW50KHRoaXMuZ2V0V2lkdGgoKSAvIHBpeGVsKTtcclxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8PSB3aWR0aExlbjsgeCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBsaW5lWCA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB4MTogeCAqIHBpeGVsLFxyXG4gICAgICAgICAgICAgICAgICAgIHkxOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHgyOiB4ICogcGl4ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgeTI6IHRoaXMuZ2V0SGVpZ2h0KClcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVEYXNoOiBbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHo6IDAsXHJcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JpZExpbmVHcm91cC5hZGQobGluZVgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGhlaWdodExlbiA9IHBhcnNlSW50KHRoaXMuZ2V0SGVpZ2h0KCkgLyBwaXhlbCwgcGl4ZWwpO1xyXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDw9IGhlaWdodExlbjsgeSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBsaW5lWSA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB4MTogMCxcclxuICAgICAgICAgICAgICAgICAgICB5MTogeSAqIHBpeGVsLFxyXG4gICAgICAgICAgICAgICAgICAgIHgyOiB0aGlzLmdldFdpZHRoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgeTI6IHkgKiBwaXhlbFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZURhc2g6IFsxXSxcclxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgejogMCxcclxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjdXJzb3I6ICdkZWZhdWx0J1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5ncmlkTGluZUdyb3VwLmFkZChsaW5lWSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uue6v+autVxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVMaW5rXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHN0YXJ0Tm9kZSDlvIDlp4voioLngrlcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZW5kTm9kZSAgIOe7k+adn+iKgueCuVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIOe6v+autemAiemhuVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN0eWxlXSDoioLngrnnmoTmoLflvI9cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdHlsZS5saW5lV2lkdGg9MV0g57q/5q6155qE5a695bqmXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3R5bGUubGluZVR5cGU9J3N0cmFpZ2h0J10g57q/5q6155qE57G75Z6LIGVnLiAnc3RyYWlnaHQnLCAnamFnZ2VkJywnY3VydmUnXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3R5bGUuc3Ryb2tlPVwiIzAwMDAwMFwiXSDnur/mrrXnmoTpopzoibLlgLwgZWcuICcjMTU3Y2ZmJyAgJ3JnYigxMjIsMTIyLDEyMiknXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMuc3R5bGUubGluZURhc2hdIOiZmue6v+eahOmXtOmalCBlZy4gWzMsM11cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zeW1ib2xdIOe6v+auteeahOeureWktFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN5bWJvbC50eXBlPSdhcnJvdyddIOe6v+auteeahOeureWktOeahOexu+WeiyDlj6/pgInlgLzkuLrvvJogJ2NpcmNsZScsICdyZWN0JywgJ3JvdW5kUmVjdCcsICd0cmlhbmdsZScsICdkaWFtb25kJywgJ3BpbicsICdhcnJvdydcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zeW1ib2wuc2l6ZT0xMF0g57q/5q6155qE566t5aS055qE5bC65a+4XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLmNvbG9yPScjMDAwMDAwJ10g57q/5q6155qE566t5aS055qE6aKc6ImyXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLnpdIFvnrq3lpLTnmoTlsYLnuqfvvIzotorlpKfotorlnKjliY3pnaLmmL7npLpdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudGV4dF0g57q/5q615LiK55qE5paH5a2XXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC50ZXh0XSDnur/mrrXkuIrnmoTmloflrZflhoXlrrlcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LmNvbG9yXSDnur/mrrXkuIrnmoTmloflrZfpopzoibJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRQb3NdIOaWh+Wtl+S9jee9ruWPr+mAieWAvCAnc3RhcnQnLCdjZW50ZXInLCdlbmQnLOm7mOiupOWAvOS4umNlbnRlclxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8QXJyYXl9IFtvcHRpb25zLnRleHQub2Zmc2V0XSDmloflrZfkvY3nva7lgY/np7vph48s5Li6bnVtYmVy5YiZ5piveOWBj+enuyBhcnJheeWImeS4ult4LHldXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zXSDkv53nlZkg6K+35L2/55Sob3B0aW9ucy5wb3NpdGlvbi5kaXJlY3Rpb24g5oyH5a6a57q/5q616LW35aeL5LiO57uI5q2iIOWcqOiKgueCueeahOS7gOS5iOS9jee9riDpu5jorqTlgLzkuLonbGVmdCxyaWdodCcgIOWPr+WPluWAvOWbm+S4quaWueWQkXRvcCxib3R0b20sbGVmdCxyaWdodCDmlrnlkJHlj6/liqDlgY/np7vph4/lpoLlpoIgXCJsZWZ0KzEwLHRvcFwiXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb25dIOaMh+Wumue6v+auteS9jee9rlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLmRpcmVjdGlvbl0g5oyH5a6a57q/5q616LW35aeL5LiO57uI5q2iIOWcqOiKgueCueeahOS7gOS5iOS9jee9riDpu5jorqTlgLzkuLonbGVmdCxyaWdodCcgIOWPr+WPluWAvOWbm+S4quaWueWQkXRvcCxib3R0b20sbGVmdCxyaWdodCDmlrnlkJHlj6/liqDlgY/np7vph4/lpoLlpoIgXCJsZWZ0KzEwLHRvcFwiXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9zaXRpb24uc3RhcnRPZmZzZXRdIOe6v+auteW8gOWni+S9jee9rueahOWBj+enu1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLmVuZE9mZnNldF0g57q/5q6157uT5p2f5L2N572u55qE5YGP56e7XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb24uZXNjYXBlRGlzdGFuY2VdIOaMh+Wumue6v+auteesrOS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOacgOWQjuS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOm7mOiupOWAvOS4ulszMCwgMzBdXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb24ucG9pbnRzXSDkuI3kvb/nlKjoh6rliqjorqHnrpcg5oyH5a6a6L+e57q/55qE5oqY54K55L2N572u5pWw57uE77yM6aaW5bC+5Y+v5Lul5L2/55SobGVmdCxyaWdodCx0b3AsYm90dG9tXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZWZmZWN0XSDnur/kuIrliqjmgIHmlYjmnpxcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5lZmZlY3Quc2hvd10g5piv5ZCm5pi+56S6566t5aS05Yqo5pWIXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZWZmZWN0LnBlcmlvZF0g5Yqo5pWI56e75Yqo6YCf5bqmXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9DaGFuZ2VQb3NpdGlvbl0g6L+e57q/55qE6L+e5o6l54K56ZqPbm9kZeenu+WKqOiHquWKqOWIh+aNouS9jee9ru+8jOm7mOiupOS4umZsYXNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuel0gW+i/nue6v+eahOWxgue6p++8jOi2iuWkp+i2iuWcqOWJjemdouaYvuekul1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyRGF0YSDnlKjmiLfkvKDpgJLnmoTkuJrliqHmlbDmja5cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0g5Yib5bu655qE57q/5q615a+56LGhXHJcbiAgICAgKlxyXG4gICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgdmFyIGxpbmsgPSBtZS5maXNoVG9wby5jcmVhdGVMaW5rKHN0YXJ0Tm9kZSwgZW5kTm9kZSwge1xyXG4gICAgICogICAgICAgICAgICAgIHN5bWJvbDogeyB0eXBlOiAnYXJyb3cnLCBzaXplOiAxMCwgY29sb3I6IFwicmdiKDAsMjAwLDI1NSlcIiB9LCAvL+eureWktCAg5Y+v6YCJ5YC85Li677yaICdjaXJjbGUnLCAncmVjdCcsICdyb3VuZFJlY3QnLCAndHJpYW5nbGUnLCAnZGlhbW9uZCcsICdwaW4nLCAnYXJyb3cnXHJcbiAgICAgKiAgICAgICAgICAgICAgc3R5bGU6IHsgbGluZVdpZHRoOiAzLCBzdHJva2U6IFwicmdiKDAsMjAwLDI1NSlcIiwgbGluZURhc2g6IFszLDNdLCBsaW5lVHlwZTogXCJqYWdnZWRcIiAgfSwgLy/moLflvI9cclxuICAgICAqICAgICAgICAgICAgICB0ZXh0OiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZmZmZicsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIHRleHRQb3M6dGV4dFBvcywvL+aWh+Wtl+S9jee9ruWPr+mAieWAvCAnc3RhcnQnLCdjZW50ZXInLCdlbmQnLOm7mOiupOWAvOS4umNlbnRlclxyXG4gICAgICogICAgICAgICAgICAgICAgICB4T2Zmc2V0OjEwLCAvL+aWh+Wtl+S9jee9rnjlgY/np7vph49cclxuICAgICAqICAgICAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgICAgIHBvczoncmlnaHQsbGVmdCcsXHJcbiAgICAgKiAgICAgICAgICAgICAgZWZmZWN0OiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsLy/mmK/lkKbmmL7npLrnrq3lpLTliqjmlYhcclxuICAgICAqICAgICAgICAgICAgICAgICAgcGVyaW9kOiA2LC8v566t5aS06YCf5bqmXHJcbiAgICAgKiAgICAgICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgICAgICBwb3NpdGlvbjp7XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgZXNjYXBlRGlzdGFuY2U6WzUwLDMwXSwgIC8v56ys5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM5pyA5ZCO5LiA5p2h5oqY57q/55qE6ZW/5bqmXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOltcIngxLHkxXCIsXCJ4Mix5MlwiXSAg5LiN5L2/55So6Ieq5Yqo6K6h566XIOaMh+Wumui/nue6v+eahOS9jee9ruaVsOe7hFxyXG4gICAgICogICAgICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgejogMFxyXG4gICAgICogICAgICAgICAgfSk7XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY3JlYXRlTGluayA9IGZpc2hUb3BvUHJvdG8uY3JlYXRMaW5rID0gZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgb3B0aW9ucywgdXNlckRhdGEpIHtcclxuICAgICAgICB2YXIgbGlua1R5cGUgPSBDb25uZWN0b3IuVFlQRV9TVFJBSUdIVDtcclxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN0eWxlICYmIG9wdGlvbnMuc3R5bGUubGluZVR5cGUpIHtcclxuICAgICAgICAgICAgbGlua1R5cGUgPSBvcHRpb25zLnN0eWxlLmxpbmVUeXBlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWZsb3dMaW5rW2xpbmtUeXBlXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIExpbmsgPSBmbG93TGlua1tsaW5rVHlwZV07XHJcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IG5ldyBMaW5rKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHVzZXJEYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5tb2RlbC5zZXQoQ29uc3RhbnRzLlVTRVJEQVRBLCB6clV0aWwuY2xvbmUodXNlckRhdGEpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2u6IqC54K55Yi35paw6IqC54K55omA6L+e55qE57q/77yI6YeN5paw6K6h566X57q/55qE5L2N572u77yJXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG5vZGUgW+iKgueCuV1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5yZWZyZXNoTGluZUJ5Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZShub2RlKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOe6v+S4iuaWh+Wtl+e8lui+kVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNvbm5lY3RvckVkaXQgPSBmdW5jdGlvbiAodGhpc0Nvbm5lY3Rvcikge1xyXG4gICAgICAgIHZhciBsaW5lVGV4dCA9IHRoaXNDb25uZWN0b3IuY2hpbGRPZk5hbWUoJ2xpbmVUZXh0Jyk7XHJcbiAgICAgICAgaWYgKCFsaW5lVGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0ZXh0U3R5bGUgPSB7fTtcclxuICAgICAgICB2YXIgdGV4dGFyZWEgPSB0aGlzLmNyZWF0ZVRleHRBcmVhKCk7XHJcbiAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KGxpbmVUZXh0LnN0eWxlLnRleHQsIGxpbmVUZXh0LnN0eWxlLnRleHRGb250KTtcclxuICAgICAgICB2YXIgbWF4V2lkdGggPSAxLjIgKiB1dGlsLmdldFJlY3QobGluZVRleHQpLndpZHRoICogdGhpcy5ub3dab29tICsgMTA7XHJcbiAgICAgICAgT2JqZWN0LmtleXMobGluZVRleHQuc3R5bGUpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdob3N0JyAmJiBrZXkgIT09ICd0ZXh0Jykge1xyXG4gICAgICAgICAgICAgICAgdGV4dFN0eWxlW2tleV0gPSBsaW5lVGV4dC5zdHlsZVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSAxLjIgKiB1dGlsLmdldFJlY3QobGluZVRleHQpLndpZHRoICogdGhpcy5ub3dab29tICsgXCJweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9ICgyICogdGV4dFJlY3QuaGVpZ2h0IHx8IDEyKSAqIHRoaXMubm93Wm9vbSArIFwicHhcIjtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5ib3JkZXIgPSBcIjFweCBkYXNoZWQgIzJlMmUyZVwiO1xyXG4gICAgICAgIHRleHRhcmVhLmlubmVySFRNTCA9IGxpbmVUZXh0LnN0eWxlLnRleHQ7XHJcbiAgICAgICAgdGhpc0Nvbm5lY3Rvci5zZXRTdHlsZSh7XHJcbiAgICAgICAgICAgIHRleHQ6IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy5fZG9tLmFwcGVuZENoaWxkKHRleHRhcmVhKTtcclxuICAgICAgICB0aGlzLl9kb20uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUubGluZUhlaWdodCA9ICgxLjIgKiB0ZXh0UmVjdC5saW5lSGVpZ2h0IHx8IDEyKSArIFwicHhcIjtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS50b3AgPSAobGluZVRleHQucG9zaXRpb25bMV0gLSB0ZXh0UmVjdC5oZWlnaHQpICogdGhpcy5ub3dab29tICsgdGhpcy5ncm91cFxyXG4gICAgICAgICAgICAucG9zaXRpb25bMV0gKyBcInB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUubGVmdCA9IChsaW5lVGV4dC5wb3NpdGlvblswXSAtIDAuNTUgKiB0ZXh0UmVjdC53aWR0aCkgKiB0aGlzLm5vd1pvb20gK1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLnBvc2l0aW9uWzBdICsgXCJweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLmZvY3VzKCk7XHJcbiAgICAgICAgdGV4dGFyZWEuc2VsZWN0KCk7XHJcbiAgICAgICAgdGhpcy5fdGV4dGFyZWFSZXNpemUodGV4dFJlY3QsIHRleHRhcmVhLCBtYXhXaWR0aCk7XHJcbiAgICAgICAgdGV4dGFyZWEub25rZXl1cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSB0ZXh0UmVjdC53aWR0aCA8IDYwID8gXCI4MHB4XCIgOiB0ZXh0YXJlYS5zdHlsZS53aWR0aDtcclxuICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gdGV4dGFyZWEuc2Nyb2xsSGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dGFyZWEub25mb2N1c291dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGV4dFN0eWxlLnRleHQgPSB0ZXh0YXJlYS52YWx1ZSB8fCBcIlwiO1xyXG4gICAgICAgICAgICB0aGlzQ29ubmVjdG9yLnNldFN0eWxlKHsgdGV4dDogdGV4dFN0eWxlIH0pO1xyXG4gICAgICAgICAgICAvLyDmm7TmlrDmloflrZfkvY3nva5cclxuICAgICAgICAgICAgdGhpc0Nvbm5lY3Rvci5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIHRleHRhcmVhLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiDoioLngrnkuIrmloflrZfnvJbovpFcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5ub2RlRWRpdCA9IGZ1bmN0aW9uICh0aGlzTm9kZSkge1xyXG4gICAgICAgIHZhciBNQVhXSURUSF9NVUxUSVBMRV9UT1BfQk9UVE9NID0gMy4zOyAvL3RleHTmnIDlpKflrr3luqbkuI7oioLngrnlrr3luqbnmoTns7vmlbDvvIzlnKh0b3AvYm90dG9t5L2N572uXHJcbiAgICAgICAgdmFyIGlzTm90U2V0VGV4dCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciB0ZXh0YXJlYSA9IHRoaXMuY3JlYXRlVGV4dEFyZWEoKTtcclxuICAgICAgICB2YXIgbm9kZVRleHQgPSB6clV0aWwuY2xvbmUodGhpc05vZGUuc3R5bGUudGV4dCk7XHJcbiAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KG5vZGVUZXh0LCB0aGlzTm9kZS5zdHlsZS50ZXh0Rm9udCk7XHJcbiAgICAgICAgdmFyIHRleHRhcmVhV2lkdGggPSB0ZXh0UmVjdC53aWR0aCA8IDI1ID8gKDEuMiAqIHRleHRSZWN0LndpZHRoICogdGhpcy5ub3dab29tICsgMTApIDogMzY7XHJcbiAgICAgICAgdmFyIHRleHRhcmVhSGVpZ2h0ID0gKDIgKiB0ZXh0UmVjdC5oZWlnaHQgfHwgMjQpICogdGhpcy5ub3dab29tO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gdGV4dGFyZWFXaWR0aCArICdweCc7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gdGV4dGFyZWFIZWlnaHQgKyBcInB4XCI7XHJcbiAgICAgICAgdmFyIG5vZGVSZWN0ID0gdXRpbC5nZXRSZWN0KHRoaXNOb2RlKTtcclxuICAgICAgICB2YXIgbWF4V2lkdGggPSAxLjIgKiBub2RlUmVjdC53aWR0aCAqIHRoaXMubm93Wm9vbTtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5saW5lSGVpZ2h0ID0gKDEuMiAqIHRleHRSZWN0LmxpbmVIZWlnaHQgfHwgMTQuNCkgKyBcInB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuYm9yZGVyID0gXCIxcHggZGFzaGVkICMyZTJlMmVcIjtcclxuICAgICAgICB0ZXh0YXJlYS5pbm5lckhUTUwgPSB0aGlzTm9kZS5zdHlsZS50ZXh0O1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGggKyAncHgnO1xyXG4gICAgICAgIHRoaXMuc2V0U3R5bGUodGhpc05vZGUsIHt0ZXh0OiBcIlwifSk7ICAvL+WFiOaKiuiKgueCueaWh+acrOe7mea4heepuu+8jOWQpuWImeWIoOmZpOaWh+acrOahhuS4reaWh+Wtl+eahOaXtuWAme+8jOS8muaYvuekuuWHuuadpVxyXG4gICAgICAgIHRoaXMuX2RvbS5hcHBlbmRDaGlsZCh0ZXh0YXJlYSk7XHJcbiAgICAgICAgdGhpcy5fZG9tLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG4gICAgICAgIHZhciBvZmZlc3RJID0gMTtcclxuICAgICAgICBpZiAodGhpc05vZGUuc3R5bGUudGV4dEFsaWduID09IFwibGVmdFwiKSB7XHJcbiAgICAgICAgICAgIG9mZmVzdEkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpc05vZGUuc3R5bGUudGV4dEFsaWduID09IFwicmlnaHRcIikge1xyXG4gICAgICAgICAgICBvZmZlc3RJID0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9mZmVzdFAgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzTm9kZS5zdHlsZS50ZXh0UG9zaXRpb24gJiYgdGhpc05vZGUuc3R5bGUudGV4dFBvc2l0aW9uID09IFwiYm90dG9tXCIpIHtcclxuICAgICAgICAgICAgb2ZmZXN0UCA9IDE7XHJcbiAgICAgICAgICAgIG1heFdpZHRoID0gTUFYV0lEVEhfTVVMVElQTEVfVE9QX0JPVFRPTSAqIG5vZGVSZWN0LndpZHRoICogdGhpcy5ub3dab29tO1xyXG4gICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoICsgXCJweFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpc05vZGUuc3R5bGUudGV4dFBvc2l0aW9uICYmIHRoaXNOb2RlLnN0eWxlLnRleHRQb3NpdGlvbiA9PSBcInRvcFwiKSB7XHJcbiAgICAgICAgICAgIG9mZmVzdFAgPSAtMTtcclxuICAgICAgICAgICAgbWF4V2lkdGggPSBNQVhXSURUSF9NVUxUSVBMRV9UT1BfQk9UVE9NICogbm9kZVJlY3Qud2lkdGggKiB0aGlzLm5vd1pvb207XHJcbiAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLnRvcCA9IChub2RlUmVjdC55IC0gdGV4dGFyZWFIZWlnaHQgLyAyICsgb2ZmZXN0UCAqIChub2RlUmVjdC5oZWlnaHQgLSB0ZXh0UmVjdC5oZWlnaHQgL1xyXG4gICAgICAgICAgICAyKSkgKiB0aGlzLm5vd1pvb20gKyB0aGlzLmdyb3VwLnBvc2l0aW9uWzFdICsgXCJweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmxlZnQgPSAobm9kZVJlY3QueCAtIG9mZmVzdEkgKiB0ZXh0YXJlYVdpZHRoIC8gMikgKiB0aGlzLm5vd1pvb20gK1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLnBvc2l0aW9uWzBdICsgXCJweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLmZvY3VzKCk7XHJcbiAgICAgICAgdGV4dGFyZWEuc2VsZWN0KCk7XHJcbiAgICAgICAgdGV4dGFyZWEub25rZXl1cCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBrZXlDb2RlLkVTQ0FQRSkge1xyXG4gICAgICAgICAgICAgICAgaXNOb3RTZXRUZXh0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRleHRhcmVhLmJsdXIoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXh0UmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdCh0ZXh0YXJlYS52YWx1ZSwgdGhpc05vZGUuc3R5bGUudGV4dEZvbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dGFyZWFSZXNpemUodGV4dFJlY3QsIHRleHRhcmVhLCBtYXhXaWR0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgICAgIHRleHRhcmVhLm9uYmx1ciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIWlzTm90U2V0VGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmhhbmRsZVdyYXAodGV4dGFyZWEudmFsdWUsIHRleHRhcmVhLnN0eWxlLm1heFdpZHRoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3R5bGUodGhpc05vZGUsIHt0ZXh0OiB0ZXh0fSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0eWxlKHRoaXNOb2RlLCB7dGV4dDogbm9kZVRleHR9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ZXh0YXJlYS5yZW1vdmUoKTtcclxuICAgICAgICB9LmJpbmQodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOWIm+W7uuaWh+acrOWfn1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNyZWF0ZVRleHRBcmVhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0ZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5wYWRkaW5nID0gXCI2cHhcIjtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5yZXNpemUgPSBcIm5vbmVcIjtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS53aGl0ZVNwYWNlID0gXCJwcmVcIjtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5saW5lSGVpZ2h0ID0gXCIxMjUlXCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmJvcmRlciA9IFwiMFwiO1xyXG4gICAgICAgIHRleHRhcmVhLnNwZWxsY2hlY2sgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdGV4dGFyZWE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOWkhOeQhnRleHRhcmVh6Ieq5Yqo5o2i6KGMXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uaGFuZGxlV3JhcCA9IGZ1bmN0aW9uICh2YWx1ZSwgd2lkdGgpIHtcclxuICAgICAgICB2YXIgc3Bhbk5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgICAgICBzcGFuTm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgICBzcGFuTm9kZS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgc3Bhbk5vZGUuc3R5bGUuYm9yZGVyID0gXCIwXCI7XHJcbiAgICAgICAgc3Bhbk5vZGUuc3R5bGUucGFkZGluZyA9IFwiMFwiO1xyXG4gICAgICAgIHNwYW5Ob2RlLnN0eWxlLmxlZnQgPSBcIjBcIjtcclxuICAgICAgICBzcGFuTm9kZS5zdHlsZS50b3AgPSBcIjBcIjtcclxuICAgICAgICB0aGlzLl9kb20uYXBwZW5kQ2hpbGQoc3Bhbk5vZGUpO1xyXG4gICAgICAgIHZhciBjb250ZW50ID0gdmFsdWUuc3BsaXQoXCJcXG5cIik7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XHJcbiAgICAgICAgY29udGVudC5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaSl7XHJcbiAgICAgICAgICAgIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAodmFsTGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vcmVzdWx0ICs9IFwiXFxuXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJlID0gXCJcIixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclZhbCwgdGVtcFdpZHRoLCBjb25XaWR0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlubmVySSA9IDA7IGlubmVySSA8IHZhbExlbmd0aDsgaW5uZXJJKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclZhbCA9IHZhbC5jaGFyQXQoaW5uZXJJKTtcclxuICAgICAgICAgICAgICAgICAgICBzcGFuTm9kZS5pbm5lckhUTUwgPSBzcGFuTm9kZS5pbm5lckhUTUwgKyBpbm5lclZhbDtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wV2lkdGggPSBzcGFuTm9kZS5jbGllbnRXaWR0aDsgLy/ojrflj5bmt7vliqDlrZfnrKblkI7pmpDol4/ln5/nmoTlrr3luqZcclxuICAgICAgICAgICAgICAgICAgICBjb25XaWR0aCA9IE51bWJlcih3aWR0aC5zdWJzdHJpbmcoMCwgd2lkdGgubGVuZ3RoIC0gMikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wV2lkdGggPiBjb25XaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcHJlOyAvL+WmguaenOi/veWKoOWtl+espuWQjumakOiXj+Wfn+WuveW6puWkp+S6jlRleHRBcmVh5a695bqm77yM5YiZ6KGo5piO6K+l5a2X56ym5Li65LiL5LiA6KGM5a2X56ym77yMXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuTm9kZS5pbm5lckhUTUwgPSBpbm5lclZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlID0gaW5uZXJWYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbm5lckkgPT0gdmFsTGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcHJlICsgaW5uZXJWYWw7IC8v5pyA5ZCO5LiA5Liq5a2X56ymXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgY29udGVudC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuTm9kZS5pbm5lckhUTUwgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmUgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZSArPSBpbm5lclZhbDsgLy/kvp3mrKHov73liqDliLBwcmXlj5jph4/kuK1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fZG9tLnJlbW92ZUNoaWxkKHNwYW5Ob2RlKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiDmlofmnKzln5/oh6rpgILlupTpq5jlrr1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5fdGV4dGFyZWFSZXNpemUgPSBmdW5jdGlvbiAodGV4dFJlY3QsIHRleHRhcmVhLCB3aWR0aCkge1xyXG4gICAgICAgIHZhciBtaW5XaWR0aCA9IDA7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSAwO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gKDEuMiAqIHRleHRSZWN0LndpZHRoKSAqIHRoaXMubm93Wm9vbSArIFwicHhcIjtcclxuICAgICAgICBpZiAod2lkdGggPCA2MCkge1xyXG4gICAgICAgICAgICBtaW5XaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1pbldpZHRoID0gODBcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRleHRSZWN0LndpZHRoIDw9IG1pbldpZHRoKSB7XHJcbiAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gbWluV2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9IFwiMHB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gdGV4dGFyZWEuc2Nyb2xsSGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICBpZiAodGV4dGFyZWEuc2Nyb2xsSGVpZ2h0IDw9IDApIHtcclxuICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gXCIxMnB4XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBzZXRTdHlsZVxyXG4gICAgICog6IqC54K55pu05pS5c3R5bGXph4znmoTlsZ7mgKdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIOiKgueCuXN0eWxl6YeM55qE5p+Q5Liq5bGe5oCn5ZCN56ewXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIOiKgueCuXN0eWxl6YeM55qE5p+Q5Liq5bGe5oCn5ZCN56ew5a+55bqU55qE5YC8XHJcbiAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICAgICAgLy/oioLngrnorr7nva7mloflrZdcclxuICAgICAqICAgICAgICAgZmlzaHRvcG8uc2V0U3R5bGUobm9kZSx7dGV4dDpcIuS+i+WtkFwifSk7XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uc2V0U3R5bGUgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xyXG4gICAgICAgIG5vZGUuc2V0U3R5bGUob3B0aW9ucyk7XHJcbiAgICAgICAgenJVdGlsLm1lcmdlKG5vZGUubW9kZWwuZ2V0KFwib3B0aW9ucy5zdHlsZVwiKSwgb3B0aW9ucywgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHNldFNoYXBlXHJcbiAgICAgKiDoioLngrnmm7TmlLlzaGFwZemHjOeahOWxnuaAp1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUg6IqC54K5c2hhcGXph4znmoTmn5DkuKrlsZ7mgKflkI3np7BcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcg6IqC54K5c2hhcGXph4znmoTmn5DkuKrlsZ7mgKflkI3np7Dlr7nlupTnmoTlgLxcclxuICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgICAgICAvL+efqeW9ouiKgueCueiuvue9ruWuvVxyXG4gICAgICogICAgICAgICBmaXNodG9wby5zZXRTaGFwZShub2RlLHt3aWR0aDoxMDB9KTtcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5zZXRTaGFwZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgbm9kZS5zZXRTaGFwZShvcHRpb25zKTtcclxuICAgICAgICBpZiAobm9kZS5tb2RlbCkge1xyXG4gICAgICAgICAgICB6clV0aWwubWVyZ2Uobm9kZS5tb2RlbC5nZXQoXCJvcHRpb25zLnNoYXBlXCIpLCBvcHRpb25zLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7roioLngrnkuIrpnaLnmoTorablkYpcclxuICAgICAqIEBtZXRob2QgY3JlYXRlQWxhcm1cclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbm9kZSDoioLngrlcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0ICDpgInpobnlgLxcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdC50ZXh0XSDorablkYrnmoTmloflrZdcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdC50ZXh0Rm9udF0g6K2m5ZGK55qE5paH5a2X55qE5a2X5L2TXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHQudGV4dEZpbGxdIOitpuWRiueahOaWh+Wtl+eahOminOiJslxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0LnRleHRCYWNrZ3JvdW5kXSDorablkYrnmoTog4zmma/nmoTpopzoibJcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0g6L+U5Zue6IqC54K55LiK55qE6K2m5ZGKXHJcbiAgICAgKlxyXG4gICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgICAgIHRoaXMuZmlzaFRvcG8uY3JlYXRlQWxhcm0oczEse1xyXG4gICAgICogICAgICAgICAgdGV4dDpcIjIgV1wiLFxyXG4gICAgICogICAgICAgICAgdGV4dEZvbnQ6XCI0cHggTWljcm9zb2Z0IFlhSGVpXCIsXHJcbiAgICAgKiAgICAgICAgICB0ZXh0RmlsbDpcIiNGRkZGRkZcIixcclxuICAgICAqICAgICAgICAgIHRleHRCYWNrZ3JvdW5kOlwicmdiYSgyNTUsMCwwLDAuNilcIlxyXG4gICAgICogICAgICB9KTsvL+WIm+W7uuWwj+WbvueJh+WSjOiKgueCuee7keWumlxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNyZWF0ZUFsYXJtID0gZmlzaFRvcG9Qcm90by5jcmVhdEFsYXJtID0gZnVuY3Rpb24gKG5vZGUsIG9wdCkge1xyXG4gICAgICAgIHZhciBncm91cCA9IHRoaXMuY3JlYXRlTm9kZShcIkdyb3VwXCIsIHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICdyZ2JhKDAsMCwwLDApJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJ3JnYmEoMCwwLDAsMCknXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBncm91cC5pc2RyYWdnYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5jcmVhdGVOb2RlKFwiVGV4dFwiLCB7IC8v5paH5a2XXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBvcHQudGV4dCxcclxuICAgICAgICAgICAgICAgIHRleHRGb250OiBvcHQudGV4dEZvbnQsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBvcHQudGV4dEZpbGwsXHJcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IFwidG9wXCIgLy/lnoLnm7Tlr7npvZAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogWzIsIDBdLFxyXG4gICAgICAgICAgICB6OiAyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGV4dC5pc2RyYWdnYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIGdyb3VwLmFkZCh0ZXh0KTtcclxuICAgICAgICBpZiAoRmxvdy5pc0luR3JvdXAobm9kZSkpIHtcclxuICAgICAgICAgICAgbm9kZS5wYXJlbnQuYWRkKGdyb3VwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChncm91cCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBncm91cFdpZHRoID0gZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggKyAyO1xyXG4gICAgICAgIHZhciBncm91cEhlaWdodCA9IGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCArIDY7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtcclxuICAgICAgICAgICAgWzAsIDBdLFxyXG4gICAgICAgICAgICBbZ3JvdXBXaWR0aCwgMF0sXHJcbiAgICAgICAgICAgIFtncm91cFdpZHRoLCBncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgIFtncm91cFdpZHRoIC0gMywgZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICBbZ3JvdXBXaWR0aCAtIDYsIGdyb3VwSGVpZ2h0ICsgM10sXHJcbiAgICAgICAgICAgIFtncm91cFdpZHRoIC0gOSwgZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICBbMCwgZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICBbMCwgMF1cclxuICAgICAgICBdO1xyXG4gICAgICAgIHZhciBQb2x5bGluZSA9IHRoaXMuY3JlYXRlTm9kZShcIlBvbHlsaW5lXCIsIHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBvcHQudGV4dEJhY2tncm91bmQsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IG9wdC50ZXh0QmFja2dyb3VuZFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgejogMVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFBvbHlsaW5lLmlzZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgZ3JvdXAuYWRkKFBvbHlsaW5lKTtcclxuICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvbiA9IFtub2RlLnBvc2l0aW9uWzBdICsgbm9kZS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtIChncm91cC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtXHJcbiAgICAgICAgICAgIDYpLCBub2RlLnBvc2l0aW9uWzFdIC0gZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC0gM107XHJcbiAgICAgICAgZ3JvdXAuYXR0cihcInBvc2l0aW9uXCIsIGdyb3VwUG9zaXRpb24pO1xyXG4gICAgICAgIG5vZGUuYWxhcm0gPSBncm91cDtcclxuICAgICAgICAvL+iuvue9ruaooeWeiyDnu5lqc29u5bqP5YiX5YyW55SoXHJcbiAgICAgICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKHt9KTtcclxuICAgICAgICBtb2RlbC5zZXQoQ29uc3RhbnRzLkVMRU1FTlRfVFlQRSwgQ29uc3RhbnRzLkFMQVJNKTtcclxuICAgICAgICBtb2RlbC5zZXQoQ29uc3RhbnRzLk9QVElPTlMsIHpyVXRpbC5jbG9uZShvcHQpKTtcclxuICAgICAgICBtb2RlbC5zZXQoQ29uc3RhbnRzLlJFTEFUSU9OSUQsIG5vZGUubW9kZWwuZ2V0KENvbnN0YW50cy5JRCkpO1xyXG4gICAgICAgIGdyb3VwLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiDov5Tlm57lvZPliY3nlLvluIPnmoTmlbDmja5cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by50b0RhdGFVUkwgPSBmdW5jdGlvbiAob3B0cykge1xyXG4gICAgICAgIHJldHVybiBGbG93VXRpbC50b0RhdGFVUkwodGhpcy5fenIsIG9wdHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLl9yZWxlYXNlU2VsZWN0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kcmFnU2VsZWN0UmVjdCkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmRyYWdTZWxlY3RSZWN0LmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5uYW1lICE9PSBcIkdST1VQX1JFQ1RfTkFNRVwiO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGdyb3VwTm9kZXNJZHMgPSB0aGlzLmdyb3VwLmNoaWxkcmVuKClcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5uYW1lICE9PSBcIkdST1VQX1JFQ1RfTkFNRVwiO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2LmlkXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IHRoaXMuZHJhZ1NlbGVjdFJlY3QucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgIHZhciBzdGFydFkgPSB0aGlzLmRyYWdTZWxlY3RSZWN0LnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVYID0gRmxvdy5pc0dyb3VwTm9kZShpdGVtKSA/IGl0ZW0ucG9zaXRpb25bMF0gKyBpdGVtLm9wdGlvbnMuc2hhcGUueCA6IGl0ZW0ucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZVkgPSBGbG93LmlzR3JvdXBOb2RlKGl0ZW0pID8gaXRlbS5wb3NpdGlvblsxXSArIGl0ZW0ub3B0aW9ucy5zaGFwZS55IDogaXRlbS5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3QucmVtb3ZlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgLy8gZ3JvdXDlhoXkuI3lrZjlnKhkcmFnU2VsZWN0UmVjdOiKgueCueaWueWPr+a3u+WKoFxyXG4gICAgICAgICAgICAgICAgaWYgKCFncm91cE5vZGVzSWRzLmluY2x1ZGVzKGl0ZW0uaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5tb2RlbC5vcHRpb24uZWxlbWVudFR5cGUgIT09IFwiY29ubmVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hdHRyKFwicG9zaXRpb25cIiwgW25vZGVYK3N0YXJ0WCwgbm9kZVkrc3RhcnRZXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZShpdGVtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3RSZWN0Lm9mZihcIm1vdXNlZG93blwiKTtcclxuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmUodGhpcy5kcmFnU2VsZWN0UmVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uX2RyYWdTZWxlY3QgPSBmdW5jdGlvbiAobm9kZSwgeCwgeSkge1xyXG4gICAgICAgIHZhciBjYW52YXNPZmZzZXRYID0gdGhpcy5ncm91cC5wb3NpdGlvblswXTtcclxuICAgICAgICB2YXIgY2FudmFzT2Zmc2V0WSA9IHRoaXMuZ3JvdXAucG9zaXRpb25bMV07XHJcbiAgICAgICAgdGhpcy5fcmVsZWFzZVNlbGVjdE5vZGUoKTsgIC8v6L+Y5Y6f6YCJ5Lit55qE6IqC54K5XHJcbiAgICAgICAgdGhpcy5kcmFnU2VsZWN0UmVjdCA9IG5ldyBHcm91cE5vZGUoe1xyXG4gICAgICAgICAgICBzaGFwZTp7IHdpZHRoOiAwLCBoZWlnaHQ6IDB9LFxyXG4gICAgICAgICAgICBwb3NpdGlvbjpbKHgtY2FudmFzT2Zmc2V0WCkvdGhpcy5ub3dab29tLCAoeS1jYW52YXNPZmZzZXRZKS90aGlzLm5vd1pvb21dLFxyXG4gICAgICAgICAgICBjaGlsZERyYWdnYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBsaW5lRGFzaDpbMiwyXSxcclxuICAgICAgICAgICAgICAgIGZpbGw6IFwicmdiYSgyMzksMjIyLDIyMSwwLjcpXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjZGRkJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5kcmFnU2VsZWN0UmVjdC50eXBlID0gXCJkcmFnU2VsZWN0XCI7XHJcbiAgICAgICAgdGhpcy5ncm91cC5hZGQodGhpcy5kcmFnU2VsZWN0UmVjdCk7XHJcbiAgICAgICAgdGhpcy5kcmFnKHRoaXMuZHJhZ1NlbGVjdFJlY3QpO1xyXG5cclxuICAgICAgICB2YXIgbW92ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHBvc1ggPSB4IDw9IGV2ZW50Lm9mZnNldFggPyB4IDogZXZlbnQub2Zmc2V0WDtcclxuICAgICAgICAgICAgdmFyIHBvc1kgPSB5IDw9IGV2ZW50Lm9mZnNldFkgPyB5IDogZXZlbnQub2Zmc2V0WTtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5hYnMoZXZlbnQub2Zmc2V0WCAtIHgpO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5hYnMoZXZlbnQub2Zmc2V0WSAtIHkpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3RSZWN0LnNoYXBlID0ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoL3RoaXMubm93Wm9vbSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0L3RoaXMubm93Wm9vbVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3Quc2V0UHJvcGVydGllcyh7c2hhcGU6IHt3aWR0aDp3aWR0aC90aGlzLm5vd1pvb20sIGhlaWdodDogaGVpZ2h0L3RoaXMubm93Wm9vbX0sIHBvc2l0aW9uOiBbKHBvc1gtY2FudmFzT2Zmc2V0WCkvdGhpcy5ub3dab29tLCAocG9zWS1jYW52YXNPZmZzZXRZKS90aGlzLm5vd1pvb21dfSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3pyLm9uKCdtb3VzZW1vdmUnLCBtb3ZlSGFuZGxlcik7XHJcblxyXG4gICAgICAgIHZhciBlbmREcmFnSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl96ci5vZmYoJ21vdXNlbW92ZScsIG1vdmVIYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5fenIub2ZmKCdtb3VzZXVwJywgZW5kRHJhZ0hhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl96ci5vZmYoXCJnbG9iYWxvdXRcIiwgZW5kRHJhZ0hhbmRsZXIpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncm91cC5jaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHYuaWQgIT09IHRzLmRyYWdTZWxlY3RSZWN0LmlkICYmIHYubW9kZWwgJiYgdi5tb2RlbC5vcHRpb24uZWxlbWVudFR5cGUgIT09IFwiY29ubmVjdGlvblwiO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGFsbExpbmVzID0gdGhpcy5ncm91cC5jaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHYubW9kZWwgJiYgdi5tb2RlbC5vcHRpb24uZWxlbWVudFR5cGUgPT09IFwiY29ubmVjdGlvblwiO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IHRoaXMuZHJhZ1NlbGVjdFJlY3QucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgIHZhciBzdGFydFkgPSB0aGlzLmRyYWdTZWxlY3RSZWN0LnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmRyYWdTZWxlY3RSZWN0Lm9wdGlvbnMuc2hhcGUud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmRyYWdTZWxlY3RSZWN0Lm9wdGlvbnMuc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgY250ID0gMDtcclxuICAgICAgICAgICAgYWxsTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB1dGlsLmdldFJlY3QoaXRlbSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZVdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlSGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZVggPSByZWN0LnggLSBub2RlV2lkdGgvMjtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlWSA9IHJlY3QueSAtIG5vZGVIZWlnaHQvMjtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlWCA+PSBzdGFydFggJiYgbm9kZVkgPj0gc3RhcnRZICYmIG5vZGVYK25vZGVXaWR0aCA8PSBzdGFydFgrd2lkdGggJiYgbm9kZVkrbm9kZUhlaWdodCA8PSBzdGFydFkraGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHMuZ3JvdXAucmVtb3ZlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRzLmRyYWdTZWxlY3RSZWN0LmFkZChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB0cy5zZWxlY3RlZE5vZGVzLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hdHRyKFwicG9zaXRpb25cIiwgW2l0ZW0ucG9zaXRpb25bMF0tc3RhcnRYLCBpdGVtLnBvc2l0aW9uWzFdLXN0YXJ0WV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYWxsTGluZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IHRzLmRyYWdTZWxlY3RSZWN0LmNoaWxkcmVuKCkuZmluZChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2LmlkID09PSBpdGVtLnN0YXJ0Tm9kZS5pZDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZE5vZGUgPSB0cy5kcmFnU2VsZWN0UmVjdC5jaGlsZHJlbigpLmZpbmQoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5pZCA9PT0gaXRlbS5lbmROb2RlLmlkO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnROb2RlICYmIGVuZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cy5ncm91cC5yZW1vdmUoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHMuZHJhZ1NlbGVjdFJlY3QuYWRkKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRzLnNlbGVjdGVkTm9kZXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB0cy5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZShpdGVtLnN0YXJ0Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0Tm9kZSB8fCBlbmROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5Yig6Zmk6YCJ5qGG5aSW55qE6IqC54K55LiO5YaF6IqC54K56Ze055qE6L+e57q/XHJcbiAgICAgICAgICAgICAgICAgICAgdHMuZ3JvdXAucmVtb3ZlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFjbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3Qub2ZmKFwibW91c2Vkb3duXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmUodGhpcy5kcmFnU2VsZWN0UmVjdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3RSZWN0LmNoaWxkT2ZOYW1lKFwiR1JPVVBfUkVDVF9OQU1FXCIpLmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogXCJyZ2JhKDAsMCwwLDApXCJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3QubW9kZWwuc2V0KFwib3B0aW9ucy5wb3NpdGlvblwiLCBGbG93VXRpbC50cnVuY1Bvc2l0aW9uKHRoaXMuZHJhZ1NlbGVjdFJlY3QucG9zaXRpb24pKTtcclxuICAgICAgICAgICAgdGhpcy5kcmFnU2VsZWN0UmVjdC5tb2RlbC5zZXQoXCJvcHRpb25zLnNoYXBlXCIsIHRoaXMuZHJhZ1NlbGVjdFJlY3Quc2hhcGUpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLnN0ZXBDb3VudGVyKCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3pyLm9uKCdtb3VzZXVwJywgZW5kRHJhZ0hhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuX3pyLm9uKFwiZ2xvYmFsb3V0XCIsIGVuZERyYWdIYW5kbGVyKTtcclxuICAgIH1cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLl9ncm91cERyYWdIYW5kbGVyID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAvLyBmbG935Lit5pyA5aSW5bGC55qEZ3JvdXDnp7vliqjmk43kvZxcclxuICAgICAgICB2YXIgbm93R3JvdXBQb3NpdGlvbiA9IHRoaXMuZ3JvdXAucG9zaXRpb247XHJcbiAgICAgICAgdmFyIGdyb3VwUG9zaXRpb25YID0gdGhpcy5ncm91cC5wb3NpdGlvblswXTtcclxuICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvblkgPSB0aGlzLmdyb3VwLnBvc2l0aW9uWzFdO1xyXG5cclxuICAgICAgICB2YXIgbW92ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAqIHRoaXMubm93Wm9vbTtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0ICogdGhpcy5ub3dab29tO1xyXG4gICAgICAgICAgICB2YXIgZ3ggPSB0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLnggKiB0aGlzLm5vd1pvb207XHJcbiAgICAgICAgICAgIHZhciBneSA9IHRoaXMuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkueSAqIHRoaXMubm93Wm9vbTtcclxuICAgICAgICAgICAgdmFyIG1pbiA9IFsxMCAtICh3aWR0aCArIGd4KSwgMTAgLSAoaGVpZ2h0ICsgZ3kpXTtcclxuICAgICAgICAgICAgdmFyIG1heCA9IFsodGhpcy5fenIuZ2V0V2lkdGgoKSAtIGd4KSAtIDEwLCAodGhpcy5fenIuZ2V0SGVpZ2h0KCkgLSBneSkgLSAxMF07XHJcbiAgICAgICAgICAgIHZhciBzWCA9IGV2ZW50Lm9mZnNldFggLSB4O1xyXG4gICAgICAgICAgICB2YXIgc1kgPSBldmVudC5vZmZzZXRZIC0geTtcclxuICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblswXSA9IGdyb3VwUG9zaXRpb25YICsgc1g7XHJcbiAgICAgICAgICAgIG5vd0dyb3VwUG9zaXRpb25bMV0gPSBncm91cFBvc2l0aW9uWSArIHNZO1xyXG4gICAgICAgICAgICBpZiAobm93R3JvdXBQb3NpdGlvblswXSA+IG1heFswXSB8fCBub3dHcm91cFBvc2l0aW9uWzFdID4gbWF4WzFdIHx8IG5vd0dyb3VwUG9zaXRpb25bMF0gPFxyXG4gICAgICAgICAgICAgICAgbWluWzBdIHx8IG5vd0dyb3VwUG9zaXRpb25bMV0gPCBtaW5bMV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuYXR0cihcInBvc2l0aW9uXCIsIG5vd0dyb3VwUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZWFnbGVFeWUgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWluaW1hcC51cGRhdGFTZWxlY3Rpb25Qb3NpdGlvbihub3dHcm91cFBvc2l0aW9uLCB0aGlzLm5vd1pvb20pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3pyLm9uKCdtb3VzZW1vdmUnLCBtb3ZlSGFuZGxlcik7XHJcblxyXG4gICAgICAgIHZhciBlbmREcmFnSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fenIub2ZmKCdtb3VzZW1vdmUnLCBtb3ZlSGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3pyLm9mZignbW91c2V1cCcsIGVuZERyYWdIYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5fenIub2ZmKFwiZ2xvYmFsb3V0XCIsIGVuZERyYWdIYW5kbGVyKTtcclxuICAgICAgICB9LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fenIub24oJ21vdXNldXAnLCBlbmREcmFnSGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5fenIub24oXCJnbG9iYWxvdXRcIiwgZW5kRHJhZ0hhbmRsZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLmluaXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZ3JvdXBNYXhXaWR0aCA9IHRoaXMuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGg7XHJcbiAgICAgICAgdmFyIGdyb3VwTWF4SGVpZ2h0ID0gdGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHJhbmdlV2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XHJcbiAgICAgICAgdmFyIHJhbmdlSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcclxuICAgICAgICB2YXIgaW5pdFJhdGlvID0gMSxcclxuICAgICAgICAgICAgcG9zID0gW107XHJcbiAgICAgICAgaWYgKGdyb3VwTWF4V2lkdGggLyBncm91cE1heEhlaWdodCA+IHJhbmdlV2lkdGggLyByYW5nZUhlaWdodCkge1xyXG4gICAgICAgICAgICBpZiAoZ3JvdXBNYXhXaWR0aCA+IHJhbmdlV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGluaXRSYXRpbyA9IHJhbmdlV2lkdGggLyBncm91cE1heFdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGdyb3VwTWF4SGVpZ2h0ID4gcmFuZ2VIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGluaXRSYXRpbyA9IHJhbmdlSGVpZ2h0IC8gZ3JvdXBNYXhIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcG9zWzBdID0gTWF0aC5hYnModGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKS54KSAqIGluaXRSYXRpbztcclxuICAgICAgICBwb3NbMV0gPSBNYXRoLmFicyh0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLnkpICogaW5pdFJhdGlvO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAuYXR0cihcInBvc2l0aW9uXCIsIFtwb3NbMF0sIHBvc1sxXV0pO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAuYXR0cihcInNjYWxlXCIsIFtpbml0UmF0aW8sIGluaXRSYXRpb10pO1xyXG4gICAgICAgIHRoaXMuaW5pdFNjYWxlUmF0aW8gPSBpbml0UmF0aW87XHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gW3Bvc1swXSwgcG9zWzFdLCB0aGlzLmluaXRTY2FsZVJhdGlvLCBncm91cE1heFdpZHRoLCBncm91cE1heEhlaWdodF07XHJcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgfTtcclxuXHJcblx0LyoqXHJcblx0ICog55S75biD5YWD57Sg5Zyo5rC05bmz5pa55ZCR5ZKM5Z6C55u05pa55ZCR5bGF5LitXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGJvdW5kUG9zIOWFtuS4remcgOS8oOWFpeeahOWxnuaAp+WIhuWIq+S4um1pblgsbWluWSxtYXhYLG1heFnljIXlm7TnlLvluIPkuIrmiYDmnInoioLngrnnmoTmnIDlsI/ovrnmoYbnmoTmnIDlsI/nmoR45Z2Q5qCH44CBeeWdkOagh+OAgeacgOWkp+eahHjlnZDmoIfjgIF55Z2Q5qCHXHJcblx0ICovXHJcblx0ZmlzaFRvcG9Qcm90by56ckNlbnRlciA9IGZ1bmN0aW9uIChib3VuZFBvcykge1xyXG4gICAgICAgIHZhciBib3VuZE9iajtcclxuICAgICAgICB2YXIgbm93R3JvdXBQb3NpdGlvbiA9IHRoaXMuZ3JvdXAucG9zaXRpb247XHJcbiAgICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KGJvdW5kUG9zKSkge1xyXG4gICAgICAgICAgICBib3VuZE9iaiA9IHpyVXRpbC5leHRlbmQoe30sIHttaW5YOiBib3VuZFBvc1swXSwgbWluWTogYm91bmRQb3NbMV0sIG1heFg6IGJvdW5kUG9zWzJdLCBtYXhZOiBib3VuZFBvc1szXX0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJvdW5kT2JqID0genJVdGlsLmV4dGVuZCh7fSwgYm91bmRQb3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub3dHcm91cFBvc2l0aW9uWzBdID0gdGhpcy5fenIuZG9tLm9mZnNldFdpZHRoLzIgLSAoYm91bmRPYmoubWluWCArICgoYm91bmRPYmoubWF4WCAtIGJvdW5kT2JqLm1pblgpLzIpKTtcclxuICAgICAgICBub3dHcm91cFBvc2l0aW9uWzFdID0gdGhpcy5fenIuZG9tLm9mZnNldEhlaWdodC8yIC0gKGJvdW5kT2JqLm1pblkgKyAoKGJvdW5kT2JqLm1heFkgLSBib3VuZE9iai5taW5ZKS8yKSk7XHJcbiAgICAgICAgdGhpcy5ncm91cC5hdHRyKFwicG9zaXRpb25cIiwgbm93R3JvdXBQb3NpdGlvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uc3RlcENvdW50ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnN0ZXBKc29uLnNwbGljZSh0aGlzLnN0ZXAsIHRoaXMuc3RlcEpzb24ubGVuZ3RoIC0gKHRoaXMuc3RlcCkpO1xyXG4gICAgICAgIHRoaXMuc3RlcCArPSAxO1xyXG4gICAgICAgIHZhciBqc29uID0gdGhpcy50b0pzb24oKTtcclxuICAgICAgICB0aGlzLnN0ZXBKc29uLnB1c2goSlNPTi5zdHJpbmdpZnkoanNvbikpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOaUvuWkp+aIluiAhee8qeWwj1xyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gdHlwZSDlvZPkuLrlrZfnrKbkuLLml7YgXCJlbmxhcmdlXCLmlL7lpKcgIFwibmFycm93aW5nXCLnvKnlsI8gIOW9k+S4uuaVsOWAvOaXtiDnvKnmlL7nmoTmr5TkvosgIOW7uuiurjAuMy0xLjdcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by56clNjYWxlID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlYWRvbmx5KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIHpvb21EZWx0YSA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09IFwibmFycm93aW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHpvb21EZWx0YSA9IC0wLjA3O1xyXG4gICAgICAgICAgICAgICAgdGhpcy56b29tKHpvb21EZWx0YSwgdGhpcy5fenIuZ2V0V2lkdGgoKSAvIDIsIHRoaXMuX3pyLmdldEhlaWdodCgpIC8gMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJlbmxhcmdlXCIpIHtcclxuICAgICAgICAgICAgICAgIHpvb21EZWx0YSA9IDAuMDc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20oem9vbURlbHRhLCB0aGlzLl96ci5nZXRXaWR0aCgpIC8gMiwgdGhpcy5fenIuZ2V0SGVpZ2h0KCkgLyAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5ncm91cDtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgem9vbVNjYWxlID0gdHlwZSAvIHRhcmdldC5zY2FsZVswXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl96b29tID0gdHlwZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vd1pvb20gPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2NhbGUodGhpcy5fenIuZ2V0V2lkdGgoKSAvIDIsIHRoaXMuX3pyLmdldEhlaWdodCgpIC8gMix6b29tU2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fenIub24oJ21vdXNld2hlZWwnLCB6clV0aWwuYmluZChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRUb29sLnN0b3AoZS5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgem9vbURlbHRhID0gZS53aGVlbERlbHRhID4gMCA/IDAuMDcgOiAtMC4wNztcclxuICAgICAgICAgICAgICAgIHRoaXMuem9vbSh6b29tRGVsdGEsIHRoaXMuX3pyLmdldFdpZHRoKCkgLyAyLCB0aGlzLl96ci5nZXRIZWlnaHQoKSAvIDIpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uem9vbSA9IGZ1bmN0aW9uICh6b29tRGVsdGEsIHpvb21YLCB6b29tWSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhblNjYWxlID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgaWYgKHRhcmdldCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG5ld1pvb20gPSB0aGlzLl96b29tID0gdGhpcy5fem9vbSB8fCAxO1xyXG4gICAgICAgICAgICBuZXdab29tICs9IHpvb21EZWx0YTtcclxuXHJcbiAgICAgICAgICAgIG5ld1pvb20gPSBOdW1iZXIobmV3Wm9vbS50b0ZpeGVkKDIpKTtcclxuICAgICAgICAgICAgdmFyIHpvb21TY2FsZSA9IG5ld1pvb20gLyB0aGlzLl96b29tO1xyXG4gICAgICAgICAgICBpZiAobmV3Wm9vbSA+IHRoaXMub3B0aW9ucy5tYXhTY2FsZSB8fCBuZXdab29tIDwgdGhpcy5vcHRpb25zLm1pblNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fem9vbSA9IG5ld1pvb207XHJcblxyXG4gICAgICAgICAgICB0aGlzLm5vd1pvb20gPSBuZXdab29tO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRTY2FsZSh6b29tWCwgem9vbVksIHpvb21TY2FsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uc2V0U2NhbGUgPSBmdW5jdGlvbiAoem9vbVgsIHpvb21ZLCB6b29tU2NhbGUpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5ncm91cDtcclxuICAgICAgICB2YXIgcG9zID0gdGFyZ2V0LnBvc2l0aW9uO1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHRhcmdldC5zY2FsZTtcclxuICAgICAgICAvLyBLZWVwIHRoZSBtb3VzZSBjZW50ZXIgd2hlbiBzY2FsaW5nXHJcbiAgICAgICAgcG9zWzBdIC09ICh6b29tWCAtIHBvc1swXSkgKiAoem9vbVNjYWxlIC0gMSk7XHJcbiAgICAgICAgcG9zWzFdIC09ICh6b29tWSAtIHBvc1sxXSkgKiAoem9vbVNjYWxlIC0gMSk7XHJcbiAgICAgICAgc2NhbGVbMF0gKj0gem9vbVNjYWxlO1xyXG4gICAgICAgIHNjYWxlWzFdICo9IHpvb21TY2FsZTtcclxuICAgICAgICB0YXJnZXQuYXR0cihcInBvc2l0aW9uXCIsIFtwb3NbMF0sIHBvc1sxXV0pO1xyXG4gICAgICAgIHRhcmdldC5hdHRyKFwic2NhbGVcIiwgW3NjYWxlWzBdLCBzY2FsZVsxXV0pO1xyXG4gICAgICAgIGlmICh0aGlzLmVhZ2xlRXllID09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5taW5pbWFwLnVwZGF0YVNlbGVjdGlvbihwb3NbMF0sIHBvc1sxXSwgem9vbVNjYWxlLCB0aGlzLm5vd1pvb20pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDpubDnnLzlm75cclxuICAgICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlYWdsZUV5ZU5vZGUg5pi+56S66bmw55y85Zu+55qEZGl25YWD57SgXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8ub3BlbkVhZ2xlRXllID0gZnVuY3Rpb24gKGVhZ2xlRXllTm9kZSkge1xyXG4gICAgICAgIHRoaXMuZWFnbGVFeWUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZWFnbGVFeWVOb2RlID0gZWFnbGVFeWVOb2RlO1xyXG4gICAgICAgIHZhciBncm91cFBvc2l0aW9uID0genJVdGlsLmNsb25lKHRoaXMuZ3JvdXAucG9zaXRpb24pO1xyXG4gICAgICAgIHZhciBncm91cFNjYWxlID0genJVdGlsLmNsb25lKHRoaXMuZ3JvdXAuc2NhbGUpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAuYXR0cihcInBvc2l0aW9uXCIsIFswLCAwXSk7XHJcbiAgICAgICAgdGhpcy5ncm91cC5hdHRyKFwic2NhbGVcIiwgWzEsIDFdKTtcclxuICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLmluaXRTY2FsZSgpO1xyXG4gICAgICAgIHZhciBpbWdTcmMgPSB0aGlzLnRvRGF0YVVSTCgpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAuYXR0cihcInBvc2l0aW9uXCIsIGdyb3VwUG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAuYXR0cihcInNjYWxlXCIsIGdyb3VwU2NhbGUpO1xyXG4gICAgICAgIGlmICh0aGlzLm1pbmltYXApIHtcclxuICAgICAgICAgICAgdGhpcy5taW5pbWFwLnVwZGF0YU1hcChpbWdTcmMsIHRoaXMuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWluaW1hcCA9IG5ldyBNaW5pbWFwKHRoaXMsIHRoaXMuZ3JvdXAucG9zaXRpb24sIHRoaXMuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCksXHJcbiAgICAgICAgICAgICAgICBlYWdsZUV5ZU5vZGUsIGRpc3RhbmNlLCBpbWdTcmMpO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHpyVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3BlbkVhZ2xlRXllKHRoaXMuZWFnbGVFeWVOb2RlKVxyXG4gICAgICAgICAgICB9LCB0aGlzKSwgMTApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1pbmltYXAuc2VsZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IGUuY2xpZW50WDtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IGUuY2xpZW50WTtcclxuICAgICAgICAgICAgdmFyIG1pbmltYXBMZWZ0ID0gTnVtYmVyKHRoaXMubWluaW1hcC5zZWxlY3Rpb24uc3R5bGUubGVmdC5zdWJzdHJpbmcoMCwgdGhpcy5taW5pbWFwLnNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgLnN0eWxlLmxlZnQubGVuZ3RoIC0gMikpO1xyXG4gICAgICAgICAgICB2YXIgbWluaW1hcFRvcCA9IE51bWJlcih0aGlzLm1pbmltYXAuc2VsZWN0aW9uLnN0eWxlLnRvcC5zdWJzdHJpbmcoMCwgdGhpcy5taW5pbWFwLnNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgLnN0eWxlLnRvcC5sZW5ndGggLSAyKSk7XHJcbiAgICAgICAgICAgIHZhciBlYWdsZUV5ZU1vdmUgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFggPSBlLmNsaWVudFggLSBzdGFydFg7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WSA9IGUuY2xpZW50WSAtIHN0YXJ0WTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluaW1hcC5zZWxlY3Rpb24uc3R5bGUubGVmdCA9IG1pbmltYXBMZWZ0ICsgb2Zmc2V0WCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluaW1hcC5zZWxlY3Rpb24uc3R5bGUudG9wID0gbWluaW1hcFRvcCArIG9mZnNldFkgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pbmltYXAudXBkYXRhR3JvdXBQb3NpdGlvbih0aGlzLmdyb3VwLCB0aGlzLm5vd1pvb20pO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm1pbmltYXAuc2VsZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgZWFnbGVFeWVNb3ZlKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBlYWdsZUV5ZVVwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taW5pbWFwLnNlbGVjdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGVhZ2xlRXllTW92ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pbmltYXAuc2VsZWN0aW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGVhZ2xlRXllVXApO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMubWluaW1hcC5zZWxlY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgZWFnbGVFeWVVcCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruiKgueCueS9jee9ruWPmOWMluabtOaWsOe7hOi+ueahhueahOWkp+Wwj1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUg6IqC54K5XHJcbiAgICAgKiBAc2luY2UgVjIuMy4wXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8ucmVmcmVzaEdyb3VwQnlOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHsvLyMxODFcclxuICAgICAgICBpZiAoRmxvdy5pc0luR3JvdXAobm9kZSkpIHtcclxuICAgICAgICAgICAgLy/mlL7lhaVub2Rl546w5pyJ5pWw5YC877yM55So5LqO6YeN57uYZ3JvdXBcclxuICAgICAgICAgICAgdGhpcy5fcmVjdXJtb2RpZnlHcm91cFJlY3Qobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUobm9kZSk7XHJcbiAgICAgICAgaWYgKEZsb3cuaXNHcm91cE5vZGUobm9kZSkpIHtcclxuICAgICAgICAgICAgbm9kZS5lYWNoKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUoY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHpyVXRpbC5taXhpbihGaXNoVG9wb0Zsb3csIEV2ZW50ZnVsKTtcclxuXHJcbiAgICAvLyAtLS0tLS0tLS3lr7nlpJbmmrTpnLJmaXNoVG9wb0Zsb3ctLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIHZhciBpZEJhc2UgPSBuZXcgRGF0ZSgpIC0gMDtcclxuICAgIHZhciBpbnN0YW5jZXMgPSB7fTtcclxuICAgIHZhciBET01fQVRUUklCVVRFX0tFWSA9ICdfZmlzaFRvcG9GbG93X2luc3RhbmNlXyc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmaXNoVG9wb0Zsb3flhajlsYDlr7nosaHvvIzlpoLmnpzmmK9hbWTmlrnlvI/liqDovb3vvIzliJnnm7TmjqXov5Tlm55cclxuICAgICAqIEBjbGFzcyBmaXNoVG9wb0Zsb3dcclxuICAgICAqIEBzaW5nbGV0b25cclxuICAgICAqXHJcbiAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAgICAgKi9cclxuICAgIHZhciBmaXNoVG9wb0Zsb3cgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog54mI5pys5Y+3XHJcbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB2ZXJzaW9uOiAnMy4yLjAnLFxyXG4gICAgICAgIGRlcGVuZGVuY2llczoge1xyXG4gICAgICAgICAgICB6cmVuZGVyOiAnMy42LjMnXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIneWni+WMlmRvbeWFg+e0oOS4uiBmbG935a+56LGhXHJcbiAgICAgKiBAbWVtYmVyIGZpc2hUb3BvRmxvd1xyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tICDkuIDkuKpkaXblhYPntKBcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzICDkvKDpgJLnmoTpgInpobnlj4LmlbBcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2Zycgb3IgJ3ZtbCdcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvPTFdIHJldGluYSDlsY/luZXkvJjljJZcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMubGlua01vZGlmeT1mYWxzZV0g5piv5ZCm5YWB6K646LCD5pW057q/5q61XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnRleHRFZGl0YWJsZT1mYWxzZV0g5piv5ZCm5YWB6K645Y+M5Ye76IqC54K557yW6L6R5paH5a2XXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLm1vdXNlTW9kZT0nZGVmYXVsdCddIOiuvue9rum8oOagh+WcqOeUu+W4g+S4iueahOaTjeS9nOaooeW8j++8jOm7mOiupOS4uidkZWZhdWx0J++8muaXoOS7u+S9leaTjeS9nO+8jOiuvuS4uidkcmFnLW1vdmUn77ya5bmz56e75ryr5ri477yM6K6+5Li6J2RyYWctc2VsZWN0J++8muahhumAieiKgueCuVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5yb2FtPXRydWVdIOaYr+WQpuW8gOWQr+m8oOagh+e8qeaUvuOAgum7mOiupOW8gOWQr++8jOiuvuS4umZhbHNl6KGo56S65YWz6Zet57yp5pS+5Yqf6IO944CCXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnJlYWRvbmx5PWZhbHNlXSDmmK/lkKblvIDlkK/lj6ror7vmqKHlvI/vvIzorr7kuLp0cnVl5ZCO55S75biD5Li65Y+q6K+75qih5byPKOeUu+W4g+S4jeWPr+e8qeaUvu+8jOiKgueCueWSjOi/nue6v+aXoOazleaLluaLvSzpgInkuK0s57yW6L6RKVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnRvb2x0aXBdIHRvb2x0aXDphY3nva7poblcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMudG9vbHRpcC5zaG93XSB0b29sdGlw6YWN572u6aG5OuaOp+WItnRvb2x0aXDmmK/lkKbmmL7npLpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaXNBbmltYXRpb25FbmFibGVkPXRydWVdIOaYr+WQpuW8gOWQr+WKqOeUuyzpu5jorqTkuLp0cnVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmNvbm5lY3RhYmxlPXRydWVdIOaYr+WQpuWFgeiuuOi/nuaOpSzpu5jorqTkuLp0cnVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNjYWxlYWJsZT1mYWxzZV0g5piv5ZCm5YWB6K6457yp5pS+LOm7mOiupOS4umZhbHNlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnJvdGF0YWJsZT1mYWxzZV0g5piv5ZCm5YWB6K645peL6L2sLOm7mOiupOS4umZhbHNlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5iZWZvcmVEZWxldGVdIOWIoOmZpOiKgueCueaIlui+uee6vyDkuYvliY3nmoTlm57osIPvvIzlpoLmnpzov5Tlm55mYWxzZeWImeS4jei/m+ihjOWQjue7reeahOWIoOmZpOaTjeS9nFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmJlZm9yZUNyZWF0ZV0g5Yib5bu66IqC54K55oiW6L6557q/IOS5i+WJjeeahOWbnuiwg++8jOWmguaenOi/lOWbnmZhbHNl5YiZ5LiN6L+b6KGM5ZCO57ut55qE5Yig6Zmk5pON5L2cXHJcbiAgICAgKiBAcmV0dXJuIHtmaXNoLnRvcG8uRmlzaFRvcG9GbG93fVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb0Zsb3cuaW5pdCA9IGZ1bmN0aW9uIChkb20sIG9wdHMpIHtcclxuICAgICAgICBpZiAoIWRvbSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luaXRpYWxpemUgZmFpbGVkOiBpbnZhbGlkIGRvbS4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gICAgICAgIC8vIERlZmF1bHQgdmFsdWVcclxuICAgICAgICB6clV0aWwuZGVmYXVsdHMob3B0cywge1xyXG4gICAgICAgICAgICB0eXBlOiBcImZsb3dcIixcclxuICAgICAgICAgICAgbGlua01vZGlmeTogZmFsc2UsXHJcbiAgICAgICAgICAgIHRleHRFZGl0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHJvYW06IHRydWUsXHJcbiAgICAgICAgICAgIG1vdXNlTW9kZTogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICB0b29sdGlwOiB7XHJcbiAgICAgICAgICAgICAgICBzaG93OnRydWVcclxuICAgICAgICAgICAgfSwgIC8v6KaG55uWdG9vbHRpcE1vZGVsXHJcbiAgICAgICAgICAgIGlzQW5pbWF0aW9uRW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICAgICAgcmVhZG9ubHk6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb25uZWN0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgc2NhbGVhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgcm90YXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgYmVmb3JlRGVsZXRlOiBudWxsLCAgLy8g5Yig6Zmk5LmL5YmN55qE5LqL5Lu2XHJcbiAgICAgICAgICAgIGJlZm9yZUNyZWF0ZTpudWxsLCAgIC8v5Yib5bu66IqC54K55oiW6L+e57q/5LmL5YmN55qE5LqL5Lu2XHJcbiAgICAgICAgICAgIG1heFNjYWxlOiAxLjcsICAgICAgIC8v55S75biD5pS+5aSn55qE5pyA5aSn5q+U5L6LXHJcbiAgICAgICAgICAgIG1pblNjYWxlOiAwLjMgICAgICAgIC8v55S75biD57yp5bCP55qE5pyA5bCP5q+U5L6LXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciBmaXNoVG9wb0Zsb3cgPSBuZXcgRmlzaFRvcG9GbG93KGRvbSwgb3B0cyk7XHJcbiAgICAgICAgZmlzaFRvcG9GbG93LmluaXQoKTtcclxuICAgICAgICBmaXNoVG9wb0Zsb3cuRmxvdyA9IEZsb3c7XHJcbiAgICAgICAgZmlzaFRvcG9GbG93LmlkID0gJ2Z0XycgKyBpZEJhc2UrKztcclxuICAgICAgICBpbnN0YW5jZXNbZmlzaFRvcG9GbG93LmlkXSA9IGZpc2hUb3BvRmxvdztcclxuXHJcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZSAmJiBkb20uc2V0QXR0cmlidXRlKERPTV9BVFRSSUJVVEVfS0VZLCBmaXNoVG9wb0Zsb3cuaWQpO1xyXG5cclxuICAgICAgICByZXR1cm4gZmlzaFRvcG9GbG93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIpOaWreW9k+WJjeaYr+WQpuS4uuWPquivu+aooeW8j1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmp1ZGdlSWZSZWFkTW9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICB2YXIgcmVhZG9ubHkgPSB0aGlzLm9wdGlvbnMucmVhZG9ubHk7XHJcbiAgICAgICAgaWYgKHJlYWRvbmx5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXJlYWRvbmx5ICYmIG5vZGUgJiYgbm9kZS5pc2RyYWdnYWJsZSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPliBkb20g5a655Zmo5LiK55qE5a6e5L6L44CCXHJcbiAgICAgKiBAbWVtYmVyIGZpc2hUb3BvRmxvd1xyXG4gICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGRvbSDkuIDkuKpkaXblhYPntKBcclxuICAgICAqIEByZXR1cm4ge2Zpc2gudG9wby5GaXNoVG9wb0Zsb3d9XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvRmxvdy5nZXRJbnN0YW5jZUJ5RG9tID0gZnVuY3Rpb24gKGRvbSkge1xyXG4gICAgICAgIHZhciBrZXkgPSBkb20uZ2V0QXR0cmlidXRlKERPTV9BVFRSSUJVVEVfS0VZKTtcclxuICAgICAgICByZXR1cm4gaW5zdGFuY2VzW2tleV07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6ZSA5q+B5a6e5L6L77yM5a6e5L6L6ZSA5q+B5ZCO5peg5rOV5YaN6KKr5L2/55So44CCXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciBmaXNoVG9wb0Zsb3dcclxuICAgICAqIEBwYXJhbSAge09iamVjdHxzdHJpbmd9IGNoYXJ0IGZpc2hUb3BvQnBtbuWunuS+iyDmiJYgZmlzaFRvcG9CcG1u55qEaWRcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9GbG93LmRpc3Bvc2UgPSBmdW5jdGlvbiAoY2hhcnQpIHtcclxuICAgICAgICB2YXIgdG9wbztcclxuICAgICAgICBpZiAoenJVdGlsLmlzRG9tKGNoYXJ0KSkge1xyXG4gICAgICAgICAgICB0b3BvID0gZmlzaFRvcG9GbG93LmdldEluc3RhbmNlQnlEb20oY2hhcnQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNoYXJ0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0b3BvID0gaW5zdGFuY2VzW2NoYXJ0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh0b3BvIGluc3RhbmNlb2YgZmlzaFRvcG9GbG93KSAmJiAhdG9wby5pc0Rpc3Bvc2VkKCkpIHtcclxuICAgICAgICAgICAgdG9wby5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvL+aatOmcsuWHuuWOu+eahOexu1xyXG4gICAgZmlzaFRvcG9GbG93LmdyYXBoaWMgPSBncmFwaGljO1xyXG4gICAgZmlzaFRvcG9GbG93Lm5vZGUgPSBGbG93VXRpbC5yZWdpc3RlckZsb3dOb2RlKGZsb3dOb2RlKTtcclxuICAgIGZpc2hUb3BvRmxvdy5saW5rID0gZmxvd0xpbms7XHJcblxyXG4gICAgZmlzaFRvcG9GbG93LmxheW91dCA9IGxheW91dDtcclxuICAgIGZpc2hUb3BvRmxvdy5GbG93ID0gRmxvdztcclxuICAgIGZpc2hUb3BvRmxvdy5jb25zdGFudHMgPSBDb25zdGFudHM7XHJcbiAgICBmaXNoVG9wb0Zsb3cudXRpbCA9IHV0aWw7XHJcbiAgICBmaXNoVG9wb0Zsb3cudXRpbFsnaW5pdEltYWdlUG9vbCddID0gSW1hZ2VQb29sLmluaXRJbWFnZVBvb2w7XHJcbiAgICB6clV0aWwuZWFjaChbXHJcbiAgICAgICAgICAgICdtYXAnLCAnZWFjaCcsICdmaWx0ZXInLCAnaW5kZXhPZicsICdpbmhlcml0cycsXHJcbiAgICAgICAgICAgICdyZWR1Y2UnLCAnZmlsdGVyJywgJ2JpbmQnLCAnY3VycnknLCAnaXNBcnJheScsXHJcbiAgICAgICAgICAgICdpc1N0cmluZycsICdpc09iamVjdCcsICdpc0Z1bmN0aW9uJywgJ2V4dGVuZCcsXHJcbiAgICAgICAgICAgICdtZXJnZScsIFwibWVyZ2VBbGxcIlxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgZmlzaFRvcG9GbG93LnV0aWxbbmFtZV0gPSB6clV0aWxbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZpc2hUb3BvRmxvdztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL0Zpc2hUb3BvRmxvdy5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuICAgIC8vcG9seWZpbGwgYmluZFxyXG4gICAgaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xyXG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24ob1RoaXMpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNSBpbnRlcm5hbCBJc0NhbGxhYmxlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcbiAgICAgICAgICAgICAgICBmVG9CaW5kID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGZOT1AgPSBmdW5jdGlvbigpIHt9LFxyXG4gICAgICAgICAgICAgICAgZkJvdW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1AgJiYgb1RoaXMgPyB0aGlzIDogb1RoaXMgfHwgd2luZG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZOT1AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XHJcbiAgICAgICAgICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZCb3VuZDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vcG9seWZpbGwgcmVtb3ZlXHJcbiAgICBpZiAoISgncmVtb3ZlJyBpbiBFbGVtZW50LnByb3RvdHlwZSkpIHtcclxuICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIVN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgpIHtcclxuICAgIFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGggPSBmdW5jdGlvbihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIHN1YmplY3RTdHJpbmcgPSB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicgfHwgIWlzRmluaXRlKHBvc2l0aW9uKSB8fCBNYXRoLmZsb29yKHBvc2l0aW9uKSAhPT0gcG9zaXRpb24gfHwgcG9zaXRpb24gPiBzdWJqZWN0U3RyaW5nLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHN1YmplY3RTdHJpbmcubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb3NpdGlvbiAtPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xyXG4gICAgICAgIHZhciBsYXN0SW5kZXggPSBzdWJqZWN0U3RyaW5nLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBwb3NpdGlvbjtcclxuICAgIH07XHJcbiAgICB9XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvcG9seWZpbGwuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIHZhciBwYXRoVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvcGF0aCcpO1xyXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcclxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoJyk7XHJcbiAgICB2YXIgY29sb3JUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvdG9vbC9jb2xvcicpO1xyXG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4Jyk7XHJcbiAgICB2YXIgdmVjdG9yID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcclxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQnKTtcclxuICAgIHZhciBEcmFnZ2FibGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUnKTtcclxuXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHt9O1xyXG4gICAgZ3JhcGhpYy5VdGlsID0genJVdGlsO1xyXG4gICAgZ3JhcGhpYy5Hcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xyXG5cclxuICAgIGdyYXBoaWMuSW1hZ2UgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5UZXh0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy50ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xyXG5cclxuICAgIGdyYXBoaWMuQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUnKTtcclxuXHJcbiAgICBncmFwaGljLlNlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5SaW5nID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Qb2x5Z29uID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Qb2x5bGluZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUnKTtcclxuXHJcbiAgICBncmFwaGljLlJlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QnKTtcclxuXHJcbiAgICBncmFwaGljLkxpbmUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUnKTtcclxuXHJcbiAgICBncmFwaGljLkJlemllckN1cnZlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZScpO1xyXG5cclxuICAgIGdyYXBoaWMuQXJjID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMnKTtcclxuXHJcbiAgICBncmFwaGljLkxpbmVhckdyYWRpZW50ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudCcpO1xyXG5cclxuICAgIGdyYXBoaWMuUmFkaWFsR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Cb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xyXG4gICAgZ3JhcGhpYy5TdGF0ZXMgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9TdGF0ZXMuanNcIik7XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCBzaGFwZSB3aXRoIHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5leHRlbmRTaGFwZSA9IGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIFBhdGguZXh0ZW5kKG9wdHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCBwYXRoXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuZXh0ZW5kUGF0aCA9IGZ1bmN0aW9uIChwYXRoRGF0YSwgb3B0cykge1xyXG4gICAgICAgIHJldHVybiBwYXRoVG9vbC5leHRlbmRGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBwYXRoIGVsZW1lbnQgZnJvbSBwYXRoIGRhdGEgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aERhdGFcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xheW91dD1jb3Zlcl0gJ2NlbnRlcicgb3IgJ2NvdmVyJ1xyXG4gICAgICovXHJcbiAgICBncmFwaGljLm1ha2VQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBvcHRzLCByZWN0LCBsYXlvdXQpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IHBhdGhUb29sLmNyZWF0ZUZyb21TdHJpbmcocGF0aERhdGEsIG9wdHMpO1xyXG4gICAgICAgIERyYWdnYWJsZS5jYWxsKHBhdGgpO1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIGlmIChyZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhc3BlY3QgPSBib3VuZGluZ1JlY3Qud2lkdGggLyBib3VuZGluZ1JlY3QuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCByZWN0IHRvIGNlbnRlciwga2VlcCB3aWR0aCAvIGhlaWdodCByYXRpby5cclxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3QuaGVpZ2h0ICogYXNwZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodDtcclxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA8PSByZWN0LndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHZhciBjeSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMjtcclxuXHJcbiAgICAgICAgICAgICAgICByZWN0LnggPSBjeCAtIHdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHJlY3QueSA9IGN5IC0gaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIHJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVBhdGgocGF0aCwgcmVjdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB6clV0aWwuaW5oZXJpdHMocGF0aCwgRHJhZ2dhYmxlKTtcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH07XHJcblxyXG4gICAgZ3JhcGhpYy5tZXJnZVBhdGggPSBwYXRoVG9vbC5tZXJnZVBhdGg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemUgYSBwYXRoIHRvIGZpdCB0aGUgcmVjdFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IHBhdGhcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMucmVzaXplUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCByZWN0KSB7XHJcbiAgICAgICAgaWYgKCFwYXRoLmFwcGx5VHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBwYXRoUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcblxyXG4gICAgICAgIHZhciBtID0gcGF0aFJlY3QuY2FsY3VsYXRlVHJhbnNmb3JtKHJlY3QpO1xyXG5cclxuICAgICAgICBwYXRoLmFwcGx5VHJhbnNmb3JtKG0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBsaW5lIGZvciBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc2hhcGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngxXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55MV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueDJdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnkyXVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zdHlsZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc3R5bGUubGluZVdpZHRoXVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBNb2RpZmllZCBwYXJhbVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lID0gZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgdmFyIHN1YlBpeGVsT3B0aW1pemUgPSBncmFwaGljLnN1YlBpeGVsT3B0aW1pemU7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gcGFyYW0uc2hhcGU7XHJcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHBhcmFtLnN0eWxlLmxpbmVXaWR0aDtcclxuXHJcbiAgICAgICAgaWYgKHJvdW5kKHNoYXBlLngxICogMikgPT09IHJvdW5kKHNoYXBlLngyICogMikpIHtcclxuICAgICAgICAgICAgc2hhcGUueDEgPSBzaGFwZS54MiA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueDEsIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb3VuZChzaGFwZS55MSAqIDIpID09PSByb3VuZChzaGFwZS55MiAqIDIpKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnkxID0gc2hhcGUueTIgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLnkxLCBsaW5lV2lkdGgsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyYW07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIHJlY3QgZm9yIGNhbnZhc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zaGFwZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueF1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUud2lkdGhdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLmhlaWdodF1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc3R5bGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnN0eWxlLmxpbmVXaWR0aF1cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdCA9IGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgIHZhciBzdWJQaXhlbE9wdGltaXplID0gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplO1xyXG4gICAgICAgIHZhciBzaGFwZSA9IHBhcmFtLnNoYXBlO1xyXG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XHJcbiAgICAgICAgdmFyIG9yaWdpblggPSBzaGFwZS54O1xyXG4gICAgICAgIHZhciBvcmlnaW5ZID0gc2hhcGUueTtcclxuICAgICAgICB2YXIgb3JpZ2luV2lkdGggPSBzaGFwZS53aWR0aDtcclxuICAgICAgICB2YXIgb3JpZ2luSGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgIHNoYXBlLnggPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLngsIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgc2hhcGUueSA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueSwgbGluZVdpZHRoLCB0cnVlKTtcclxuICAgICAgICBzaGFwZS53aWR0aCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICBzdWJQaXhlbE9wdGltaXplKG9yaWdpblggKyBvcmlnaW5XaWR0aCwgbGluZVdpZHRoLCBmYWxzZSkgLSBzaGFwZS54LFxyXG4gICAgICAgICAgICBvcmlnaW5XaWR0aCA9PT0gMCA/IDAgOiAxXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzaGFwZS5oZWlnaHQgPSBNYXRoLm1heChcclxuICAgICAgICAgICAgc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5ZICsgb3JpZ2luSGVpZ2h0LCBsaW5lV2lkdGgsIGZhbHNlKSAtIHNoYXBlLnksXHJcbiAgICAgICAgICAgIG9yaWdpbkhlaWdodCA9PT0gMCA/IDAgOiAxXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gcGFyYW07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIGZvciBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gQ29vcmRpbmF0ZSwgc3VjaCBhcyB4LCB5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIFNob3VsZCBiZSBub25uZWdhdGl2ZSBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcG9zaXRpdmVPck5lZ2F0aXZlIERlZmF1bHQgZmFsc2UgKG5lZ2F0aXZlKS5cclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gT3B0aW1pemVkIHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemUgPSBmdW5jdGlvbiAocG9zaXRpb24sIGxpbmVXaWR0aCwgcG9zaXRpdmVPck5lZ2F0aXZlKSB7XHJcbiAgICAgICAgLy8gQXNzdXJlIHRoYXQgKHBvc2l0aW9uICsgbGluZVdpZHRoIC8gMikgaXMgbmVhciBpbnRlZ2VyIGVkZ2UsXHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGxpbmUgd2lsbCBiZSBmdXp6eSBpbiBjYW52YXMuXHJcbiAgICAgICAgdmFyIGRvdWJsZWRQb3NpdGlvbiA9IHJvdW5kKHBvc2l0aW9uICogMik7XHJcbiAgICAgICAgcmV0dXJuIChkb3VibGVkUG9zaXRpb24gKyByb3VuZChsaW5lV2lkdGgpKSAlIDIgPT09IDBcclxuICAgICAgICAgICAgPyBkb3VibGVkUG9zaXRpb24gLyAyXHJcbiAgICAgICAgICAgIDogKGRvdWJsZWRQb3NpdGlvbiArIChwb3NpdGl2ZU9yTmVnYXRpdmUgPyAxIDogLTEpKSAvIDI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZG9TaW5nbGVFbnRlckhvdmVyKGVsKSB7XHJcbiAgICAgICAgaWYgKGVsLl9faXNIb3Zlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbC5fX2hvdmVyU3RsRGlydHkpIHtcclxuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IGVsLnN0eWxlLnN0cm9rZTtcclxuICAgICAgICAgICAgdmFyIGZpbGwgPSBlbC5zdHlsZS5maWxsO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGhvdmVyU3R5bGUgb24gbW91c2VvdmVyXHJcbiAgICAgICAgICAgIHZhciBob3ZlclN0eWxlID0gZWwuX19ob3ZlclN0bDtcclxuICAgICAgICAgICAgdmFyIGxpZnQgPSBjb2xvclRvb2wubGlmdDtcclxuICAgICAgICAgICAgaG92ZXJTdHlsZS5maWxsID0gaG92ZXJTdHlsZS5maWxsXHJcbiAgICAgICAgICAgICAgICB8fCAoZmlsbCAmJiAoZmlsbCBpbnN0YW5jZW9mIEdyYWRpZW50ID8gZmlsbCA6IGxpZnQoZmlsbCwgLTAuMSkpKTtcclxuICAgICAgICAgICAgaG92ZXJTdHlsZS5zdHJva2UgPSBob3ZlclN0eWxlLnN0cm9rZVxyXG4gICAgICAgICAgICAgICAgfHwgKHN0cm9rZSAmJiAoc3Ryb2tlIGluc3RhbmNlb2YgR3JhZGllbnQgPyBzdHJva2UgOiBsaWZ0KHN0cm9rZSwgLTAuMSkpKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBub3JtYWxTdHlsZSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGhvdmVyU3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChob3ZlclN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsU3R5bGVbbmFtZV0gPSBlbC5zdHlsZVtuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWwuX19ub3JtYWxTdGwgPSBub3JtYWxTdHlsZTtcclxuXHJcbiAgICAgICAgICAgIGVsLl9faG92ZXJTdGxEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbC5zZXRTdHlsZShlbC5fX2hvdmVyU3RsKTtcclxuICAgICAgICBlbC56MiArPSAxO1xyXG5cclxuICAgICAgICBlbC5fX2lzSG92ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRvU2luZ2xlTGVhdmVIb3ZlcihlbCkge1xyXG4gICAgICAgIGlmICghZWwuX19pc0hvdmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBub3JtYWxTdGwgPSBlbC5fX25vcm1hbFN0bDtcclxuICAgICAgICBub3JtYWxTdGwgJiYgZWwuc2V0U3R5bGUobm9ybWFsU3RsKTtcclxuICAgICAgICBlbC56MiAtPSAxO1xyXG5cclxuICAgICAgICBlbC5fX2lzSG92ZXIgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkb0VudGVySG92ZXIoZWwpIHtcclxuICAgICAgICAoZWwudHlwZSA9PT0gJ2dyb3VwJyB8fCBlbC50eXBlID09PSAnR3JvdXBOb2RlJylcclxuICAgICAgICAgICAgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9TaW5nbGVFbnRlckhvdmVyKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgOiBkb1NpbmdsZUVudGVySG92ZXIoZWwpO1xyXG4gICAgfVxyXG4gICAgZ3JhcGhpYy5kb0VudGVySG92ZXIgPSBkb0VudGVySG92ZXI7XHJcbiAgICBmdW5jdGlvbiBkb0xlYXZlSG92ZXIoZWwpIHtcclxuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXHJcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvU2luZ2xlTGVhdmVIb3ZlcihjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKTtcclxuICAgIH1cclxuICAgIGdyYXBoaWMuZG9MZWF2ZUhvdmVyID0gZG9MZWF2ZUhvdmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0bCkge1xyXG4gICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIHNlcGNpZmllZCBob3ZlclN0eWxlLCB0aGVuIHVzZSBpdCBpbnN0ZWFkIG9mIGdpdmVuIGhvdmVyU3R5bGVcclxuICAgICAgICAvLyBPZnRlbiB1c2VkIHdoZW4gaXRlbSBncm91cCBoYXMgYSBsYWJlbCBlbGVtZW50IGFuZCBpdCdzIGhvdmVyU3R5bGUgaXMgZGlmZmVyZW50XHJcbiAgICAgICAgZWwuX19ob3ZlclN0bCA9IGVsLmhvdmVyU3R5bGUgfHwgaG92ZXJTdGwgfHwge307XHJcbiAgICAgICAgZWwuX19ob3ZlclN0bERpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdyYXBoaWMuc2V0RWxlbWVudEhvdmVyU3RsID0gc2V0RWxlbWVudEhvdmVyU3RsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdmVyKCkge1xyXG4gICAgICAgIC8vIE9ubHkgaWYgZWxlbWVudCBpcyBub3QgaW4gZW1waGFzaXMgc3RhdHVzXHJcbiAgICAgICAgIXRoaXMuX19pc0VtcGhhc2lzICYmIGRvRW50ZXJIb3Zlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbkVsZW1lbnRNb3VzZU91dCgpIHtcclxuICAgICAgICAvLyBPbmx5IGlmIGVsZW1lbnQgaXMgbm90IGluIGVtcGhhc2lzIHN0YXR1c1xyXG4gICAgICAgICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0xlYXZlSG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZW50ZXJFbXBoYXNpcygpIHtcclxuICAgICAgICB0aGlzLl9faXNFbXBoYXNpcyA9IHRydWU7XHJcbiAgICAgICAgZG9FbnRlckhvdmVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGxlYXZlRW1waGFzaXMoKSB7XHJcbiAgICAgICAgdGhpcy5fX2lzRW1waGFzaXMgPSBmYWxzZTtcclxuICAgICAgICBkb0xlYXZlSG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgaG92ZXIgc3R5bGUgb2YgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtob3ZlclN0eWxlXVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnNldEhvdmVyU3R5bGUgPSBmdW5jdGlvbiAoZWwsIGhvdmVyU3R5bGUpIHtcclxuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXHJcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRIb3ZlclN0bChjaGlsZCwgaG92ZXJTdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0eWxlKTtcclxuICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgYm91bmQgaGFuZGxlcnNcclxuICAgICAgICBlbC5vbignbW91c2VvdmVyJywgb25FbGVtZW50TW91c2VPdmVyKVxyXG4gICAgICAgICAgLm9uKCdtb3VzZW91dCcsIG9uRWxlbWVudE1vdXNlT3V0KTtcclxuXHJcbiAgICAgICAgLy8gRW1waGFzaXMsIG5vcm1hbCBjYW4gYmUgdHJpZ2dlcmVkIG1hbnVhbGx5XHJcbiAgICAgICAgZWwub24oJ2VtcGhhc2lzJywgZW50ZXJFbXBoYXNpcylcclxuICAgICAgICAgIC5vbignbm9ybWFsJywgbGVhdmVFbXBoYXNpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChlbC5fX25vcm1hbFN0bCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5fX25vcm1hbFN0bC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLl9fbm9ybWFsU3RsW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGV4dCBvcHRpb24gaW4gdGhlIHN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBsYWJlbE1vZGVsXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHRTdHlsZSwgbGFiZWxNb2RlbCwgY29sb3IpIHtcclxuICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygncG9zaXRpb24nKSB8fCAnaW5zaWRlJztcclxuICAgICAgICB2YXIgbGFiZWxDb2xvciA9IGxhYmVsUG9zaXRpb24uaW5kZXhPZignaW5zaWRlJykgPj0gMCA/ICd3aGl0ZScgOiBjb2xvcjtcclxuICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBsYWJlbE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcclxuICAgICAgICB6clV0aWwuZXh0ZW5kKHRleHRTdHlsZSwge1xyXG4gICAgICAgICAgICB0ZXh0RGlzdGFuY2U6IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnZGlzdGFuY2UnKSB8fCA1LFxyXG4gICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxyXG4gICAgICAgICAgICB0ZXh0UG9zaXRpb246IGxhYmVsUG9zaXRpb24sXHJcbiAgICAgICAgICAgIHRleHRGaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBsYWJlbENvbG9yXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGFuaW1hdGVPclNldFByb3BzKGlzVXBkYXRlLCBlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgY2IpIHtcclxuICAgICAgICB2YXIgcG9zdGZpeCA9IGlzVXBkYXRlID8gJ1VwZGF0ZScgOiAnJztcclxuICAgICAgICB2YXIgZHVyYXRpb24gPSBhbmltYXRhYmxlTW9kZWxcclxuICAgICAgICAgICAgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkR1cmF0aW9uJyArIHBvc3RmaXgpO1xyXG4gICAgICAgIHZhciBhbmltYXRpb25FYXNpbmcgPSBhbmltYXRhYmxlTW9kZWxcclxuICAgICAgICAgICAgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkVhc2luZycgKyBwb3N0Zml4KTtcclxuXHJcbiAgICAgICAgYW5pbWF0YWJsZU1vZGVsICYmIGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb24nKVxyXG4gICAgICAgICAgICA/IGVsLmFuaW1hdGVUbyhwcm9wcywgZHVyYXRpb24sIGFuaW1hdGlvbkVhc2luZywgY2IpXHJcbiAgICAgICAgICAgIDogKGVsLmF0dHIocHJvcHMpLCBjYiAmJiBjYigpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy51cGRhdGVQcm9wcyA9IHpyVXRpbC5jdXJyeShhbmltYXRlT3JTZXRQcm9wcywgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0IGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5pbml0UHJvcHMgPSB6clV0aWwuY3VycnkoYW5pbWF0ZU9yU2V0UHJvcHMsIGZhbHNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0cmFuc2Zvcm0gbWF0cml4IG9mIHRhcmdldCAocGFyYW0gdGFyZ2V0KSxcclxuICAgICAqIGluIGNvb3JkaW5hdGUgb2YgaXRzIGFuY2VzdG9yIChwYXJhbSBhbmNlc3RvcilcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9IHRhcmdldFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSBhbmNlc3RvclxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIGFuY2VzdG9yKSB7XHJcbiAgICAgICAgdmFyIG1hdCA9IG1hdHJpeC5pZGVudGl0eShbXSk7XHJcblxyXG4gICAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBhbmNlc3Rvcikge1xyXG4gICAgICAgICAgICBtYXRyaXgubXVsKG1hdCwgdGFyZ2V0LmdldExvY2FsVHJhbnNmb3JtKCksIG1hdCk7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IHRyYW5zZm9ybSB0byBhbiB2ZXJ0ZXguXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZXJ0ZXggW3gsIHldXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxyXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFt4LCB5XVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKHZlcnRleCwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcclxuICAgICAgICBpZiAoaW52ZXJ0KSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IG1hdHJpeC5pbnZlcnQoW10sIHRyYW5zZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0oW10sIHZlcnRleCwgdHJhbnNmb3JtKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUcmFuc2Zvcm1lZCBkaXJlY3Rpb24uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMudHJhbnNmb3JtRGlyZWN0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcclxuXHJcbiAgICAgICAgLy8gUGljayBhIGJhc2UsIGVuc3VyZSB0aGF0IHRyYW5zZm9ybSByZXN1bHQgd2lsbCBub3QgYmUgKDAsIDApLlxyXG4gICAgICAgIHZhciBoQmFzZSA9ICh0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVswXSA9PT0gMClcclxuICAgICAgICAgICAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVswXSk7XHJcbiAgICAgICAgdmFyIHZCYXNlID0gKHRyYW5zZm9ybVs0XSA9PT0gMCB8fCB0cmFuc2Zvcm1bNV0gPT09IDAgfHwgdHJhbnNmb3JtWzJdID09PSAwKVxyXG4gICAgICAgICAgICA/IDEgOiBNYXRoLmFicygyICogdHJhbnNmb3JtWzRdIC8gdHJhbnNmb3JtWzJdKTtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRleCA9IFtcclxuICAgICAgICAgICAgZGlyZWN0aW9uID09PSAnbGVmdCcgPyAtaEJhc2UgOiBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyBoQmFzZSA6IDAsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3RvcCcgPyAtdkJhc2UgOiBkaXJlY3Rpb24gPT09ICdib3R0b20nID8gdkJhc2UgOiAwXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgdmVydGV4ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSh2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJ0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZlcnRleFswXSkgPiBNYXRoLmFicyh2ZXJ0ZXhbMV0pXHJcbiAgICAgICAgICAgID8gKHZlcnRleFswXSA+IDAgPyAncmlnaHQnIDogJ2xlZnQnKVxyXG4gICAgICAgICAgICA6ICh2ZXJ0ZXhbMV0gPiAwID8gJ2JvdHRvbScgOiAndG9wJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gZ3JhcGhpYztcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvdXRpbFxuICovXG4vLyDnlKjkuo7lpITnkIZtZXJnZeaXtuaXoOazlemBjeWOhkRhdGXnrYnlr7nosaHnmoTpl67pophcbnZhciBCVUlMVElOX09CSkVDVCA9IHtcbiAgJ1tvYmplY3QgRnVuY3Rpb25dJzogMSxcbiAgJ1tvYmplY3QgUmVnRXhwXSc6IDEsXG4gICdbb2JqZWN0IERhdGVdJzogMSxcbiAgJ1tvYmplY3QgRXJyb3JdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nOiAxLFxuICAvLyBGb3Igbm9kZS1jYW52YXNcbiAgJ1tvYmplY3QgSW1hZ2VdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzXSc6IDFcbn07XG52YXIgVFlQRURfQVJSQVkgPSB7XG4gICdbb2JqZWN0IEludDhBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50OEFycmF5XSc6IDEsXG4gICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc6IDEsXG4gICdbb2JqZWN0IEludDE2QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgVWludDE2QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgSW50MzJBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50MzJBcnJheV0nOiAxLFxuICAnW29iamVjdCBGbG9hdDMyQXJyYXldJzogMSxcbiAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc6IDFcbn07XG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgbmF0aXZlRm9yRWFjaCA9IGFycmF5UHJvdG8uZm9yRWFjaDtcbnZhciBuYXRpdmVGaWx0ZXIgPSBhcnJheVByb3RvLmZpbHRlcjtcbnZhciBuYXRpdmVTbGljZSA9IGFycmF5UHJvdG8uc2xpY2U7XG52YXIgbmF0aXZlTWFwID0gYXJyYXlQcm90by5tYXA7XG52YXIgbmF0aXZlUmVkdWNlID0gYXJyYXlQcm90by5yZWR1Y2U7IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cbnZhciBtZXRob2RzID0ge307XG5cbmZ1bmN0aW9uICRvdmVycmlkZShuYW1lLCBmbikge1xuICBtZXRob2RzW25hbWVdID0gZm47XG59XG4vKipcbiAqIFRob3NlIGRhdGEgdHlwZXMgY2FuIGJlIGNsb25lZDpcbiAqICAgICBQbGFpbiBvYmplY3QsIEFycmF5LCBUeXBlZEFycmF5LCBudW1iZXIsIHN0cmluZywgbnVsbCwgdW5kZWZpbmVkLlxuICogVGhvc2UgZGF0YSB0eXBlcyB3aWxsIGJlIGFzc2dpbmVkIHVzaW5nIHRoZSBvcmdpbmFsIGRhdGE6XG4gKiAgICAgQlVJTFRJTl9PQkpFQ1RcbiAqIEluc3RhbmNlIG9mIHVzZXIgZGVmaW5lZCBjbGFzcyB3aWxsIGJlIGNsb25lZCB0byBhIHBsYWluIG9iamVjdCwgd2l0aG91dFxuICogcHJvcGVydGllcyBpbiBwcm90b3R5cGUuXG4gKiBPdGhlciBkYXRhIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQgKG5vdCBzdXJlIHdoYXQgd2lsbCBoYXBwZW4pLlxuICpcbiAqIENhdXRpb246IGRvIG5vdCBzdXBwb3J0IGNsb25lIERhdGUsIGZvciBwZXJmb3JtYW5jZSBjb25zaWRlcmF0aW9uLlxuICogKFRoZXJlIG1pZ2h0IGJlIGEgbGFyZ2UgbnVtYmVyIG9mIGRhdGUgaW4gYHNlcmllcy5kYXRhYCkuXG4gKiBTbyBkYXRlIHNob3VsZCBub3QgYmUgbW9kaWZpZWQgaW4gYW5kIG91dCBvZiBlY2hhcnRzLlxuICpcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAcmV0dXJuIHsqfSBuZXdcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKHNvdXJjZSkge1xuICBpZiAoc291cmNlID09IG51bGwgfHwgdHlwZW9mIHNvdXJjZSAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gc291cmNlO1xuICB2YXIgdHlwZVN0ciA9IG9ialRvU3RyaW5nLmNhbGwoc291cmNlKTtcblxuICBpZiAodHlwZVN0ciA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gY2xvbmUoc291cmNlW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoVFlQRURfQVJSQVlbdHlwZVN0cl0pIHtcbiAgICB2YXIgQ3RvciA9IHNvdXJjZS5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChzb3VyY2UuY29uc3RydWN0b3IuZnJvbSkge1xuICAgICAgcmVzdWx0ID0gQ3Rvci5mcm9tKHNvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBDdG9yKHNvdXJjZS5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IGNsb25lKHNvdXJjZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFCVUlMVElOX09CSkVDVFt0eXBlU3RyXSAmJiAhaXNQcmltaXRpdmUoc291cmNlKSAmJiAhaXNEb20oc291cmNlKSkge1xuICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY2xvbmUoc291cmNlW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQHBhcmFtIHtib29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXVxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkge1xuICAvLyBXZSBzaG91bGQgZXNjYXBzZSB0aGF0IHNvdXJjZSBpcyBzdHJpbmdcbiAgLy8gYW5kIGVudGVyIGZvciAuLi4gaW4gLi4uXG4gIGlmICghaXNPYmplY3Qoc291cmNlKSB8fCAhaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiBvdmVyd3JpdGUgPyBjbG9uZShzb3VyY2UpIDogdGFyZ2V0O1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFyIHRhcmdldFByb3AgPSB0YXJnZXRba2V5XTtcbiAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XG5cbiAgICAgIGlmIChpc09iamVjdChzb3VyY2VQcm9wKSAmJiBpc09iamVjdCh0YXJnZXRQcm9wKSAmJiAhaXNBcnJheShzb3VyY2VQcm9wKSAmJiAhaXNBcnJheSh0YXJnZXRQcm9wKSAmJiAhaXNEb20oc291cmNlUHJvcCkgJiYgIWlzRG9tKHRhcmdldFByb3ApICYmICFpc0J1aWx0SW5PYmplY3Qoc291cmNlUHJvcCkgJiYgIWlzQnVpbHRJbk9iamVjdCh0YXJnZXRQcm9wKSAmJiAhaXNQcmltaXRpdmUoc291cmNlUHJvcCkgJiYgIWlzUHJpbWl0aXZlKHRhcmdldFByb3ApKSB7XG4gICAgICAgIC8vIOWmguaenOmcgOimgemAkuW9kuimhueblu+8jOWwsemAkuW9kuiwg+eUqG1lcmdlXG4gICAgICAgIG1lcmdlKHRhcmdldFByb3AsIHNvdXJjZVByb3AsIG92ZXJ3cml0ZSk7XG4gICAgICB9IGVsc2UgaWYgKG92ZXJ3cml0ZSB8fCAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIC8vIOWQpuWImeWPquWkhOeQhm92ZXJ3cml0ZeS4unRydWXvvIzmiJbogIXlnKjnm67moIflr7nosaHkuK3msqHmnInmraTlsZ7mgKfnmoTmg4XlhrVcbiAgICAgICAgLy8gTk9URe+8jOWcqCB0YXJnZXRba2V5XSDkuI3lrZjlnKjnmoTml7blgJnkuZ/mmK/nm7TmjqXopobnm5ZcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0QW5kU291cmNlcyBUaGUgZmlyc3QgaXRlbSBpcyB0YXJnZXQsIGFuZCB0aGUgcmVzdHMgYXJlIHNvdXJjZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAqIEByZXR1cm4geyp9IHRhcmdldFxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2VBbGwodGFyZ2V0QW5kU291cmNlcywgb3ZlcndyaXRlKSB7XG4gIHZhciByZXN1bHQgPSB0YXJnZXRBbmRTb3VyY2VzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0YXJnZXRBbmRTb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ID0gbWVyZ2UocmVzdWx0LCB0YXJnZXRBbmRTb3VyY2VzW2ldLCBvdmVyd3JpdGUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHBhcmFtIHsqfSB0YXJnZXRcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuLyoqXG4gKiBAcGFyYW0geyp9IHRhcmdldFxuICogQHBhcmFtIHsqfSBzb3VyY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJsYXk9ZmFsc2VdXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuXG5mdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChvdmVybGF5ID8gc291cmNlW2tleV0gIT0gbnVsbCA6IHRhcmdldFtrZXldID09IG51bGwpKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBjcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBtZXRob2RzLmNyZWF0ZUNhbnZhcygpO1xufTtcblxubWV0aG9kcy5jcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbn07IC8vIEZJWE1FXG5cblxudmFyIF9jdHg7XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGlmICghX2N0eCkge1xuICAgIC8vIFVzZSB1dGlsLmNyZWF0ZUNhbnZhcyBpbnN0ZWFkIG9mIGNyZWF0ZUNhbnZhc1xuICAgIC8vIGJlY2F1c2UgY3JlYXRlQ2FudmFzIG1heSBiZSBvdmVyd3JpdHRlbiBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRcbiAgICBfY3R4ID0gY3JlYXRlQ2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgfVxuXG4gIHJldHVybiBfY3R4O1xufVxuLyoqXG4gKiDmn6Xor6LmlbDnu4TkuK3lhYPntKDnmoRpbmRleFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgaWYgKGFycmF5KSB7XG4gICAgaWYgKGFycmF5LmluZGV4T2YpIHtcbiAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiDmnoTpgKDnsbvnu6fmib/lhbPns7tcbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGF6eiDmupDnsbtcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VDbGF6eiDln7rnsbtcbiAqL1xuXG5cbmZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcbiAgdmFyIGNsYXp6UHJvdG90eXBlID0gY2xhenoucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIEYoKSB7fVxuXG4gIEYucHJvdG90eXBlID0gYmFzZUNsYXp6LnByb3RvdHlwZTtcbiAgY2xhenoucHJvdG90eXBlID0gbmV3IEYoKTtcblxuICBmb3IgKHZhciBwcm9wIGluIGNsYXp6UHJvdG90eXBlKSB7XG4gICAgY2xhenoucHJvdG90eXBlW3Byb3BdID0gY2xhenpQcm90b3R5cGVbcHJvcF07XG4gIH1cblxuICBjbGF6ei5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjbGF6ejtcbiAgY2xhenouc3VwZXJDbGFzcyA9IGJhc2VDbGF6ejtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHNvcmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJsYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIG1peGluKHRhcmdldCwgc291cmNlLCBvdmVybGF5KSB7XG4gIHRhcmdldCA9ICdwcm90b3R5cGUnIGluIHRhcmdldCA/IHRhcmdldC5wcm90b3R5cGUgOiB0YXJnZXQ7XG4gIHNvdXJjZSA9ICdwcm90b3R5cGUnIGluIHNvdXJjZSA/IHNvdXJjZS5wcm90b3R5cGUgOiBzb3VyY2U7XG4gIGRlZmF1bHRzKHRhcmdldCwgc291cmNlLCBvdmVybGF5KTtcbn1cbi8qKlxuICogQ29uc2lkZXIgdHlwZWQgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IGRhdGFcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKGRhdGEpIHtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBkYXRhLmxlbmd0aCA9PSAnbnVtYmVyJztcbn1cbi8qKlxuICog5pWw57uE5oiW5a+56LGh6YGN5Y6GXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqL1xuXG5cbmZ1bmN0aW9uIGVhY2gob2JqLCBjYiwgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5mb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgb2JqLmZvckVhY2goY2IsIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIOaVsOe7hOaYoOWwhFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gbWFwKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmoubWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkge1xuICAgIHJldHVybiBvYmoubWFwKGNiLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gW21lbW9dXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiByZWR1Y2Uob2JqLCBjYiwgbWVtbywgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5yZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgcmV0dXJuIG9iai5yZWR1Y2UoY2IsIG1lbW8sIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1lbW8gPSBjYi5jYWxsKGNvbnRleHQsIG1lbW8sIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfVxufVxuLyoqXG4gKiDmlbDnu4Tov4fmu6RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbHRlcihvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLmZpbHRlciAmJiBvYmouZmlsdGVyID09PSBuYXRpdmVGaWx0ZXIpIHtcbiAgICByZXR1cm4gb2JqLmZpbHRlcihjYiwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG9ialtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXG4gKiDmlbDnu4Tpobnmn6Xmib5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cblxuZnVuY3Rpb24gZmluZChvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICByZXR1cm4gb2JqW2ldO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cblxuZnVuY3Rpb24gYmluZChmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9O1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1cnJ5KGZ1bmMpIHtcbiAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncy5jb25jYXQobmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH07XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8ICEhdmFsdWUgJiYgdHlwZSA9PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQnVpbHRJbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gISFCVUlMVElOX09CSkVDVFtvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0RvbSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS5vd25lckRvY3VtZW50ID09PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogV2hldGhlciBpcyBleGFjdGx5IE5hTi4gTm90aWNlIGlzTmFOKCdhJykgcmV0dXJucyB0cnVlLlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGVxTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG4vKipcbiAqIElmIHZhbHVlMSBpcyBub3QgbnVsbCwgdGhlbiByZXR1cm4gdmFsdWUxLCBvdGhlcndpc2UganVkZ2V0IHJlc3Qgb2YgdmFsdWVzLlxuICogTG93IHBlcmZvcm1hbmNlLlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHJldHVybiB7Kn0gRmluYWwgdmFsdWVcbiAqL1xuXG5cbmZ1bmN0aW9uIHJldHJpZXZlKHZhbHVlcykge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyaWV2ZTIodmFsdWUwLCB2YWx1ZTEpIHtcbiAgcmV0dXJuIHZhbHVlMCAhPSBudWxsID8gdmFsdWUwIDogdmFsdWUxO1xufVxuXG5mdW5jdGlvbiByZXRyaWV2ZTModmFsdWUwLCB2YWx1ZTEsIHZhbHVlMikge1xuICByZXR1cm4gdmFsdWUwICE9IG51bGwgPyB2YWx1ZTAgOiB2YWx1ZTEgIT0gbnVsbCA/IHZhbHVlMSA6IHZhbHVlMjtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGVuZEluZGV4XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIHNsaWNlKCkge1xuICByZXR1cm4gRnVuY3Rpb24uY2FsbC5hcHBseShuYXRpdmVTbGljZSwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogTm9ybWFsaXplIGNzcyBsaWtlZCBhcnJheSBjb25maWd1cmF0aW9uXG4gKiBlLmcuXG4gKiAgMyA9PiBbMywgMywgMywgM11cbiAqICBbNCwgMl0gPT4gWzQsIDIsIDQsIDJdXG4gKiAgWzQsIDMsIDJdID0+IFs0LCAzLCAyLCAzXVxuICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHZhbFxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVDc3NBcnJheSh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgdmFyIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIHZlcnRpY2FsIHwgaG9yaXpvbnRhbFxuICAgIHJldHVybiBbdmFsWzBdLCB2YWxbMV0sIHZhbFswXSwgdmFsWzFdXTtcbiAgfSBlbHNlIGlmIChsZW4gPT09IDMpIHtcbiAgICAvLyB0b3AgfCBob3Jpem9udGFsIHwgYm90dG9tXG4gICAgcmV0dXJuIFt2YWxbMF0sIHZhbFsxXSwgdmFsWzJdLCB2YWxbMV1dO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBwcmltaXRpdmVLZXkgPSAnX19lY19wcmltaXRpdmVfXyc7XG4vKipcbiAqIFNldCBhbiBvYmplY3QgYXMgcHJpbWl0aXZlIHRvIGJlIGlnbm9yZWQgdHJhdmVyc2luZyBjaGlsZHJlbiBpbiBjbG9uZSBvciBtZXJnZVxuICovXG5cbmZ1bmN0aW9uIHNldEFzUHJpbWl0aXZlKG9iaikge1xuICBvYmpbcHJpbWl0aXZlS2V5XSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICByZXR1cm4gb2JqW3ByaW1pdGl2ZUtleV07XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPbmx5IGFwcGx5IGBvd25Qcm9wZXJ0eWAuXG4gKi9cblxuXG5mdW5jdGlvbiBIYXNoTWFwKG9iaikge1xuICBvYmogJiYgZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gIH0sIHRoaXMpO1xufSAvLyBBZGQgcHJlZml4IHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZS5cblxuXG52YXIgSEFTSF9NQVBfUFJFRklYID0gJ19lY18nO1xudmFyIEhBU0hfTUFQX1BSRUZJWF9MRU5HVEggPSA0O1xuSGFzaE1hcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBIYXNoTWFwLFxuICAvLyBEbyBub3QgcHJvdmlkZSBgaGFzYCBtZXRob2QgdG8gYXZvaWQgZGVmaW5pbmcgd2hhdCBpcyBgaGFzYC5cbiAgLy8gKFdlIHVzdWFsbHkgdHJlYXQgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcyB0aGUgc2FtZSwgZGlmZmVyZW50XG4gIC8vIGZyb20gRVM2IE1hcCkuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV0gPSB2YWx1ZTsgLy8gQ29tcGFyaW5nIHdpdGggaW52b2NhdGlvbiBjaGFpbmluZywgYHJldHVybiB2YWx1ZWAgaXMgbW9yZSBjb21tb25seVxuICAgIC8vIHVzZWQgaW4gdGhpcyBjYXNlOiBgdmFyIHNvbWVWYWwgPSBtYXAuc2V0KCdhJywgZ2VuVmFsKCkpO2BcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgLy8gQWx0aG91Z2ggdXRpbC5lYWNoIGNhbiBiZSBwZXJmb3JtZWQgb24gdGhpcyBoYXNoTWFwIGRpcmVjdGx5LCB1c2VyXG4gIC8vIHNob3VsZCBub3QgdXNlIHRoZSBleHBvc2VkIGtleXMsIHdobyBhcmUgcHJlZml4ZWQuXG4gIGVhY2g6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGNvbnRleHQgIT09IHZvaWQgMCAmJiAoY2IgPSBiaW5kKGNiLCBjb250ZXh0KSk7XG5cbiAgICBmb3IgKHZhciBwcmVmaXhlZEtleSBpbiB0aGlzKSB7XG4gICAgICB0aGlzLmhhc093blByb3BlcnR5KHByZWZpeGVkS2V5KSAmJiBjYih0aGlzW3ByZWZpeGVkS2V5XSwgcHJlZml4ZWRLZXkuc2xpY2UoSEFTSF9NQVBfUFJFRklYX0xFTkdUSCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBpZiBwZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gIHJlbW92ZUtleTogZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hNYXAob2JqKSB7XG4gIHJldHVybiBuZXcgSGFzaE1hcChvYmopO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0cy4kb3ZlcnJpZGUgPSAkb3ZlcnJpZGU7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG5leHBvcnRzLm1lcmdlQWxsID0gbWVyZ2VBbGw7XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbmV4cG9ydHMuY3JlYXRlQ2FudmFzID0gY3JlYXRlQ2FudmFzO1xuZXhwb3J0cy5nZXRDb250ZXh0ID0gZ2V0Q29udGV4dDtcbmV4cG9ydHMuaW5kZXhPZiA9IGluZGV4T2Y7XG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5leHBvcnRzLm1peGluID0gbWl4aW47XG5leHBvcnRzLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG5leHBvcnRzLmVhY2ggPSBlYWNoO1xuZXhwb3J0cy5tYXAgPSBtYXA7XG5leHBvcnRzLnJlZHVjZSA9IHJlZHVjZTtcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuZXhwb3J0cy5maW5kID0gZmluZDtcbmV4cG9ydHMuYmluZCA9IGJpbmQ7XG5leHBvcnRzLmN1cnJ5ID0gY3Vycnk7XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNCdWlsdEluT2JqZWN0ID0gaXNCdWlsdEluT2JqZWN0O1xuZXhwb3J0cy5pc0RvbSA9IGlzRG9tO1xuZXhwb3J0cy5lcU5hTiA9IGVxTmFOO1xuZXhwb3J0cy5yZXRyaWV2ZSA9IHJldHJpZXZlO1xuZXhwb3J0cy5yZXRyaWV2ZTIgPSByZXRyaWV2ZTI7XG5leHBvcnRzLnJldHJpZXZlMyA9IHJldHJpZXZlMztcbmV4cG9ydHMuc2xpY2UgPSBzbGljZTtcbmV4cG9ydHMubm9ybWFsaXplQ3NzQXJyYXkgPSBub3JtYWxpemVDc3NBcnJheTtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy5zZXRBc1ByaW1pdGl2ZSA9IHNldEFzUHJpbWl0aXZlO1xuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuZXhwb3J0cy5jcmVhdGVIYXNoTWFwID0gY3JlYXRlSGFzaE1hcDtcbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL1BhdGhcIik7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciB0cmFuc2Zvcm1QYXRoID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtUGF0aFwiKTtcblxuLy8gY29tbWFuZCBjaGFyc1xudmFyIGNjID0gWydtJywgJ00nLCAnbCcsICdMJywgJ3YnLCAnVicsICdoJywgJ0gnLCAneicsICdaJywgJ2MnLCAnQycsICdxJywgJ1EnLCAndCcsICdUJywgJ3MnLCAnUycsICdhJywgJ0EnXTtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIFBJID0gTWF0aC5QSTtcblxudmFyIHZNYWcgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xufTtcblxudmFyIHZSYXRpbyA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodk1hZyh1KSAqIHZNYWcodikpO1xufTtcblxudmFyIHZBbmdsZSA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbn07XG5cbmZ1bmN0aW9uIHByb2Nlc3NBcmMoeDEsIHkxLCB4MiwgeTIsIGZhLCBmcywgcngsIHJ5LCBwc2lEZWcsIGNtZCwgcGF0aCkge1xuICB2YXIgcHNpID0gcHNpRGVnICogKFBJIC8gMTgwLjApO1xuICB2YXIgeHAgPSBtYXRoQ29zKHBzaSkgKiAoeDEgLSB4MikgLyAyLjAgKyBtYXRoU2luKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG4gIHZhciB5cCA9IC0xICogbWF0aFNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wICsgbWF0aENvcyhwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICB2YXIgbGFtYmRhID0geHAgKiB4cCAvIChyeCAqIHJ4KSArIHlwICogeXAgLyAocnkgKiByeSk7XG5cbiAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICByeCAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgIHJ5ICo9IG1hdGhTcXJ0KGxhbWJkYSk7XG4gIH1cblxuICB2YXIgZiA9IChmYSA9PT0gZnMgPyAtMSA6IDEpICogbWF0aFNxcnQoKHJ4ICogcnggKiAocnkgKiByeSkgLSByeCAqIHJ4ICogKHlwICogeXApIC0gcnkgKiByeSAqICh4cCAqIHhwKSkgLyAocnggKiByeCAqICh5cCAqIHlwKSArIHJ5ICogcnkgKiAoeHAgKiB4cCkpKSB8fCAwO1xuICB2YXIgY3hwID0gZiAqIHJ4ICogeXAgLyByeTtcbiAgdmFyIGN5cCA9IGYgKiAtcnkgKiB4cCAvIHJ4O1xuICB2YXIgY3ggPSAoeDEgKyB4MikgLyAyLjAgKyBtYXRoQ29zKHBzaSkgKiBjeHAgLSBtYXRoU2luKHBzaSkgKiBjeXA7XG4gIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMCArIG1hdGhTaW4ocHNpKSAqIGN4cCArIG1hdGhDb3MocHNpKSAqIGN5cDtcbiAgdmFyIHRoZXRhID0gdkFuZ2xlKFsxLCAwXSwgWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XSk7XG4gIHZhciB1ID0gWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIHYgPSBbKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIGRUaGV0YSA9IHZBbmdsZSh1LCB2KTtcblxuICBpZiAodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgZFRoZXRhID0gUEk7XG4gIH1cblxuICBpZiAodlJhdGlvKHUsIHYpID49IDEpIHtcbiAgICBkVGhldGEgPSAwO1xuICB9XG5cbiAgaWYgKGZzID09PSAwICYmIGRUaGV0YSA+IDApIHtcbiAgICBkVGhldGEgPSBkVGhldGEgLSAyICogUEk7XG4gIH1cblxuICBpZiAoZnMgPT09IDEgJiYgZFRoZXRhIDwgMCkge1xuICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBQSTtcbiAgfVxuXG4gIHBhdGguYWRkRGF0YShjbWQsIGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhkYXRhKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyBjb21tYW5kIHN0cmluZ1xuXG5cbiAgdmFyIGNzID0gZGF0YS5yZXBsYWNlKC8tL2csICcgLScpLnJlcGxhY2UoLyAgL2csICcgJykucmVwbGFjZSgvIC9nLCAnLCcpLnJlcGxhY2UoLywsL2csICcsJyk7XG4gIHZhciBuOyAvLyBjcmVhdGUgcGlwZXMgc28gdGhhdCB3ZSBjYW4gc3BsaXQgdGhlIGRhdGFcblxuICBmb3IgKG4gPSAwOyBuIDwgY2MubGVuZ3RoOyBuKyspIHtcbiAgICBjcyA9IGNzLnJlcGxhY2UobmV3IFJlZ0V4cChjY1tuXSwgJ2cnKSwgJ3wnICsgY2Nbbl0pO1xuICB9IC8vIGNyZWF0ZSBhcnJheVxuXG5cbiAgdmFyIGFyciA9IGNzLnNwbGl0KCd8Jyk7IC8vIGluaXQgY29udGV4dCBwb2ludFxuXG4gIHZhciBjcHggPSAwO1xuICB2YXIgY3B5ID0gMDtcbiAgdmFyIHBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gIHZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xuICB2YXIgcHJldkNtZDtcblxuICBmb3IgKG4gPSAxOyBuIDwgYXJyLmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIHN0ciA9IGFycltuXTtcbiAgICB2YXIgYyA9IHN0ci5jaGFyQXQoMCk7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIHAgPSBzdHIuc2xpY2UoMSkucmVwbGFjZSgvZSwtL2csICdlLScpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGNtZDtcblxuICAgIGlmIChwLmxlbmd0aCA+IDAgJiYgcFswXSA9PT0gJycpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBbaV0gPSBwYXJzZUZsb2F0KHBbaV0pO1xuICAgIH1cblxuICAgIHdoaWxlIChvZmYgPCBwLmxlbmd0aCAmJiAhaXNOYU4ocFtvZmZdKSkge1xuICAgICAgaWYgKGlzTmFOKHBbMF0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3RsUHR4O1xuICAgICAgdmFyIGN0bFB0eTtcbiAgICAgIHZhciByeDtcbiAgICAgIHZhciByeTtcbiAgICAgIHZhciBwc2k7XG4gICAgICB2YXIgZmE7XG4gICAgICB2YXIgZnM7XG4gICAgICB2YXIgeDEgPSBjcHg7XG4gICAgICB2YXIgeTEgPSBjcHk7IC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuXG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGMgPSAnbCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGMgPSAnTCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSk7XG4gICAgICAgICAgY3B4ID0gcFtvZmYgLSAyXTtcbiAgICAgICAgICBjcHkgPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSwgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5LCBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHkpO1xuICAgICAgICAgIGNweCArPSBwW29mZiAtIDJdO1xuICAgICAgICAgIGNweSArPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcblxuICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHgxID0gY3B4ICsgcFtvZmYrK107XG4gICAgICAgICAgeTEgPSBjcHkgKyBwW29mZisrXTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICB4MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHkxID0gcFtvZmYrK107XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgeDEgPSBwW29mZisrXSArIGNweDtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdICsgY3B5O1xuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG5cbiAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgcnkgPSBwW29mZisrXTtcbiAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGZzID0gcFtvZmYrK107XG4gICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYyA9PT0gJ3onIHx8IGMgPT09ICdaJykge1xuICAgICAgY21kID0gQ01ELlo7XG4gICAgICBwYXRoLmFkZERhdGEoY21kKTtcbiAgICB9XG5cbiAgICBwcmV2Q21kID0gY21kO1xuICB9XG5cbiAgcGF0aC50b1N0YXRpYygpO1xuICByZXR1cm4gcGF0aDtcbn0gLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykge1xuICB2YXIgcGF0aFByb3h5ID0gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhzdHIpO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHBhdGguc2V0RGF0YSkge1xuICAgICAgcGF0aC5zZXREYXRhKHBhdGhQcm94eS5kYXRhKTsgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG5cbiAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdHggPSBwYXRoO1xuICAgICAgcGF0aFByb3h5LnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgfVxuICB9O1xuXG4gIG9wdHMuYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobSkge1xuICAgIHRyYW5zZm9ybVBhdGgocGF0aFByb3h5LCBtKTtcbiAgICB0aGlzLmRpcnR5KHRydWUpO1xuICB9O1xuXG4gIHJldHVybiBvcHRzO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBQYXRoIG9iamVjdCBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRnJvbVN0cmluZyhzdHIsIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBQYXRoKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBQYXRoIGNsYXNzIGZyb20gcGF0aCBzdHJpbmcgZGF0YVxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPdGhlciBvcHRpb25zXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmRGcm9tU3RyaW5nKHN0ciwgb3B0cykge1xuICByZXR1cm4gUGF0aC5leHRlbmQoY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSk7XG59XG4vKipcbiAqIE1lcmdlIG11bHRpcGxlIHBhdGhzXG4gKi9cbi8vIFRPRE8gQXBwbHkgdHJhbnNmb3JtXG4vLyBUT0RPIHN0cm9rZSBkYXNoXG4vLyBUT0RPIE9wdGltaXplIGRvdWJsZSBtZW1vcnkgY29zdCBwcm9ibGVtXG5cblxuZnVuY3Rpb24gbWVyZ2VQYXRoKHBhdGhFbHMsIG9wdHMpIHtcbiAgdmFyIHBhdGhMaXN0ID0gW107XG4gIHZhciBsZW4gPSBwYXRoRWxzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBhdGhFbCA9IHBhdGhFbHNbaV07XG5cbiAgICBpZiAoIXBhdGhFbC5wYXRoKSB7XG4gICAgICBwYXRoRWwuY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGhFbC5fX2RpcnR5UGF0aCkge1xuICAgICAgcGF0aEVsLmJ1aWxkUGF0aChwYXRoRWwucGF0aCwgcGF0aEVsLnNoYXBlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwYXRoTGlzdC5wdXNoKHBhdGhFbC5wYXRoKTtcbiAgfVxuXG4gIHZhciBwYXRoQnVuZGxlID0gbmV3IFBhdGgob3B0cyk7IC8vIE5lZWQgcGF0aCBwcm94eS5cblxuICBwYXRoQnVuZGxlLmNyZWF0ZVBhdGhQcm94eSgpO1xuXG4gIHBhdGhCdW5kbGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBwYXRoLmFwcGVuZFBhdGgocGF0aExpc3QpOyAvLyBTdmcgYW5kIHZtbCByZW5kZXJlciBkb24ndCBoYXZlIGNvbnRleHRcblxuICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHBhdGhCdW5kbGU7XG59XG5cbmV4cG9ydHMuY3JlYXRlRnJvbVN0cmluZyA9IGNyZWF0ZUZyb21TdHJpbmc7XG5leHBvcnRzLmV4dGVuZEZyb21TdHJpbmcgPSBleHRlbmRGcm9tU3RyaW5nO1xuZXhwb3J0cy5tZXJnZVBhdGggPSBtZXJnZVBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBwYXRoQ29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3BhdGhcIik7XG5cbnZhciBQYXR0ZXJuID0gcmVxdWlyZShcIi4vUGF0dGVyblwiKTtcblxudmFyIGdldENhbnZhc1BhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBhdGhQcm94eUZvckRyYXcgPSBuZXcgUGF0aFByb3h5KHRydWUpO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cblxuZnVuY3Rpb24gUGF0aChvcHRzKSB7XG4gIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLnBhdGggPSBudWxsO1xufVxuXG5QYXRoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFBhdGgsXG4gIHR5cGU6ICdwYXRoJyxcbiAgX19kaXJ0eVBhdGg6IHRydWUsXG4gIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IDUsXG4gIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoIHx8IHBhdGhQcm94eUZvckRyYXc7XG4gICAgdmFyIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpO1xuICAgIHZhciBoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpO1xuICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcbiAgICB2YXIgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgIHZhciBoYXNGaWxsR3JhZGllbnQgPSBoYXNGaWxsICYmICEhZmlsbC5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNTdHJva2VHcmFkaWVudCA9IGhhc1N0cm9rZSAmJiAhIXN0cm9rZS5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNGaWxsUGF0dGVybiA9IGhhc0ZpbGwgJiYgISFmaWxsLmltYWdlO1xuICAgIHZhciBoYXNTdHJva2VQYXR0ZXJuID0gaGFzU3Ryb2tlICYmICEhc3Ryb2tlLmltYWdlO1xuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5KSB7XG4gICAgICB2YXIgcmVjdDsgLy8gVXBkYXRlIGdyYWRpZW50IGJlY2F1c2UgYm91bmRpbmcgcmVjdCBtYXkgY2hhbmdlZFxuXG4gICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgZmlsbCwgcmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICByZWN0ID0gcmVjdCB8fCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB0aGlzLl9zdHJva2VHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgc3Ryb2tlLCByZWN0KTtcbiAgICAgIH1cbiAgICB9IC8vIFVzZSB0aGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuXG5cbiAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAvLyBQRU5ESU5HIElmIG1heSBoYXZlIGFmZmVjdCB0aGUgc3RhdGVcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9maWxsR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNGaWxsUGF0dGVybikge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGdldENhbnZhc1BhdHRlcm4uY2FsbChmaWxsLCBjdHgpO1xuICAgIH1cblxuICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNTdHJva2VQYXR0ZXJuKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoc3Ryb2tlLCBjdHgpO1xuICAgIH1cblxuICAgIHZhciBsaW5lRGFzaCA9IHN0eWxlLmxpbmVEYXNoO1xuICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IHN0eWxlLmxpbmVEYXNoT2Zmc2V0O1xuICAgIHZhciBjdHhMaW5lRGFzaCA9ICEhY3R4LnNldExpbmVEYXNoOyAvLyBVcGRhdGUgcGF0aCBzeCwgc3lcblxuICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICBwYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7IC8vIFByb3h5IGNvbnRleHRcbiAgICAvLyBSZWJ1aWxkIHBhdGggaW4gZm9sbG93aW5nIDIgY2FzZXNcbiAgICAvLyAxLiBQYXRoIGlzIGRpcnR5XG4gICAgLy8gMi4gUGF0aCBuZWVkcyBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmVEYXNoIHN0cm9raW5nLlxuICAgIC8vICAgIEluIHRoaXMgY2FzZSwgbGluZURhc2ggaW5mb3JtYXRpb24gd2lsbCBub3QgYmUgc2F2ZWQgaW4gUGF0aFByb3h5XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCB8fCBsaW5lRGFzaCAmJiAhY3R4TGluZURhc2ggJiYgaGFzU3Ryb2tlKSB7XG4gICAgICBwYXRoLmJlZ2luUGF0aChjdHgpOyAvLyBTZXR0aW5nIGxpbmUgZGFzaCBiZWZvcmUgYnVpbGQgcGF0aFxuXG4gICAgICBpZiAobGluZURhc2ggJiYgIWN0eExpbmVEYXNoKSB7XG4gICAgICAgIHBhdGguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICBwYXRoLnNldExpbmVEYXNoT2Zmc2V0KGxpbmVEYXNoT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpOyAvLyBDbGVhciBwYXRoIGRpcnR5IGZsYWdcblxuICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcGxheSBwYXRoIGJ1aWxkaW5nXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLnBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICB9XG5cbiAgICBoYXNGaWxsICYmIHBhdGguZmlsbChjdHgpO1xuXG4gICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgfVxuXG4gICAgaGFzU3Ryb2tlICYmIHBhdGguc3Ryb2tlKGN0eCk7XG5cbiAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgIC8vIFBFTkRJTkdcbiAgICAgIC8vIFJlbW92ZSBsaW5lRGFzaFxuICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTsgLy8gRHJhdyByZWN0IHRleHRcblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgfVxuICB9LFxuICAvLyBXaGVuIGJ1bmRsaW5nIHBhdGgsIHNvbWUgc2hhcGUgbWF5IGRlY2lkZSBpZiB1c2UgbW92ZVRvIHRvIGJlZ2luIGEgbmV3IHN1YnBhdGggb3IgY2xvc2VQYXRoXG4gIC8vIExpa2UgaW4gY2lyY2xlXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGVDZmcsIGluQnVuZGxlKSB7fSxcbiAgY3JlYXRlUGF0aFByb3h5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICB9LFxuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuX3JlY3Q7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgbmVlZHNVcGRhdGVSZWN0ID0gIXJlY3Q7XG5cbiAgICBpZiAobmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcblxuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBwYXRoIG9uIGRlbWFuZC5cbiAgICAgICAgcGF0aCA9IHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWN0ID0gcmVjdDtcblxuICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgLy8gTmVlZHMgdXBkYXRlIHJlY3Qgd2l0aCBzdHJva2UgbGluZVdpZHRoIHdoZW5cbiAgICAgIC8vIDEuIEVsZW1lbnQgY2hhbmdlcyBzY2FsZSBvciBsaW5lV2lkdGhcbiAgICAgIC8vIDIuIFNoYXBlIGlzIGNoYW5nZWRcbiAgICAgIHZhciByZWN0V2l0aFN0cm9rZSA9IHRoaXMuX3JlY3RXaXRoU3Ryb2tlIHx8ICh0aGlzLl9yZWN0V2l0aFN0cm9rZSA9IHJlY3QuY2xvbmUoKSk7XG5cbiAgICAgIGlmICh0aGlzLl9fZGlydHkgfHwgbmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgIHJlY3RXaXRoU3Ryb2tlLmNvcHkocmVjdCk7IC8vIEZJWE1FIE11c3QgYWZ0ZXIgdXBkYXRlVHJhbnNmb3JtXG5cbiAgICAgICAgdmFyIHcgPSBzdHlsZS5saW5lV2lkdGg7IC8vIFBFTkRJTkcsIE1pbiBsaW5lIHdpZHRoIGlzIG5lZWRlZCB3aGVuIGxpbmUgaXMgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbFxuXG4gICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7IC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG5cbiAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICB3ID0gTWF0aC5tYXgodywgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkIHx8IDQpO1xuICAgICAgICB9IC8vIENvbnNpZGVyIGxpbmUgd2lkdGhcbiAgICAgICAgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG5cbiAgICAgICAgaWYgKGxpbmVTY2FsZSA+IDFlLTEwKSB7XG4gICAgICAgICAgcmVjdFdpdGhTdHJva2Uud2lkdGggKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS5oZWlnaHQgKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS54IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnkgLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmV0dXJuIHJlY3Qgd2l0aCBzdHJva2VcblxuXG4gICAgICByZXR1cm4gcmVjdFdpdGhTdHJva2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3Q7XG4gIH0sXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGxvY2FsUG9zID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgeCA9IGxvY2FsUG9zWzBdO1xuICAgIHkgPSBsb2NhbFBvc1sxXTtcblxuICAgIGlmIChyZWN0LmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMucGF0aC5kYXRhO1xuXG4gICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIGxpbmVTY2FsZSA9IHN0eWxlLnN0cm9rZU5vU2NhbGUgPyB0aGlzLmdldExpbmVTY2FsZSgpIDogMTsgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG4gICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgIC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG4gICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IE1hdGgubWF4KGxpbmVXaWR0aCwgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aENvbnRhaW4uY29udGFpblN0cm9rZShwYXRoRGF0YSwgbGluZVdpZHRoIC8gbGluZVNjYWxlLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhDb250YWluLmNvbnRhaW4ocGF0aERhdGEsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZGlydHlQYXRoXG4gICAqL1xuICBkaXJ0eTogZnVuY3Rpb24gKGRpcnR5UGF0aCkge1xuICAgIGlmIChkaXJ0eVBhdGggPT0gbnVsbCkge1xuICAgICAgZGlydHlQYXRoID0gdHJ1ZTtcbiAgICB9IC8vIE9ubHkgbWFyayBkaXJ0eSwgbm90IG1hcmsgY2xlYW5cblxuXG4gICAgaWYgKGRpcnR5UGF0aCkge1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7IC8vIFVzZWQgYXMgYSBjbGlwcGluZyBwYXRoXG5cbiAgICBpZiAodGhpcy5fX2NsaXBUYXJnZXQpIHtcbiAgICAgIHRoaXMuX19jbGlwVGFyZ2V0LmRpcnR5KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc2hhcGUnKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICovXG4gIGFuaW1hdGVTaGFwZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzaGFwZScsIGxvb3ApO1xuICB9LFxuICAvLyBPdmVyd3JpdGUgYXR0cktWXG4gIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAvLyBGSVhNRVxuICAgIGlmIChrZXkgPT09ICdzaGFwZScpIHtcbiAgICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IHRydWU7XG4gICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgRGlzcGxheWFibGUucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0U2hhcGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTsgLy8gUGF0aCBmcm9tIHN0cmluZyBtYXkgbm90IGhhdmUgc2hhcGVcblxuICAgIGlmIChzaGFwZSkge1xuICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChrZXkpKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgc2hhcGVbbmFtZV0gPSBrZXlbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZVtrZXldID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGlydHkodHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGdldExpbmVTY2FsZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07IC8vIEdldCB0aGUgbGluZSBzY2FsZS5cbiAgICAvLyBEZXRlcm1pbmFudCBvZiBgbWAgbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXG4gICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgIC8vIGZvciB3aWR0aC5cblxuICAgIHJldHVybiBtICYmIGFicyhtWzBdIC0gMSkgPiAxZS0xMCAmJiBhYnMobVszXSAtIDEpID4gMWUtMTAgPyBNYXRoLnNxcnQoYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pKSA6IDE7XG4gIH1cbn07XG4vKipcbiAqIOaJqeWxleS4gOS4qiBQYXRoIGVsZW1lbnQsIOavlOWmguaYn+W9ou+8jOWchuetieOAglxuICogRXh0ZW5kIGEgcGF0aCBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy50eXBlIFBhdGggdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuaW5pdCBJbml0aWFsaXplXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5idWlsZFBhdGggT3ZlcndyaXRlIGJ1aWxkUGF0aCBtZXRob2RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc3R5bGVdIEV4dGVuZGVkIGRlZmF1bHQgc3R5bGUgY29uZmlnXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnNoYXBlXSBFeHRlbmRlZCBkZWZhdWx0IHNoYXBlIGNvbmZpZ1xuICovXG5cblBhdGguZXh0ZW5kID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gIHZhciBTdWIgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIFBhdGguY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgIGlmIChkZWZhdWx0cy5zdHlsZSkge1xuICAgICAgLy8gRXh0ZW5kIGRlZmF1bHQgc3R5bGVcbiAgICAgIHRoaXMuc3R5bGUuZXh0ZW5kRnJvbShkZWZhdWx0cy5zdHlsZSwgZmFsc2UpO1xuICAgIH0gLy8gRXh0ZW5kIGRlZmF1bHQgc2hhcGVcblxuXG4gICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xuXG4gICAgaWYgKGRlZmF1bHRTaGFwZSkge1xuICAgICAgdGhpcy5zaGFwZSA9IHRoaXMuc2hhcGUgfHwge307XG4gICAgICB2YXIgdGhpc1NoYXBlID0gdGhpcy5zaGFwZTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0U2hhcGUpIHtcbiAgICAgICAgaWYgKCF0aGlzU2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgZGVmYXVsdFNoYXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdGhpc1NoYXBlW25hbWVdID0gZGVmYXVsdFNoYXBlW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVmYXVsdHMuaW5pdCAmJiBkZWZhdWx0cy5pbml0LmNhbGwodGhpcywgb3B0cyk7XG4gIH07XG5cbiAgenJVdGlsLmluaGVyaXRzKFN1YiwgUGF0aCk7IC8vIEZJWE1FIOS4jeiDvSBleHRlbmQgcG9zaXRpb24sIHJvdGF0aW9uIOetieW8leeUqOWvueixoVxuXG4gIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAvLyBFeHRlbmRpbmcgcHJvdG90eXBlIHZhbHVlcyBhbmQgbWV0aG9kc1xuICAgIGlmIChuYW1lICE9PSAnc3R5bGUnICYmIG5hbWUgIT09ICdzaGFwZScpIHtcbiAgICAgIFN1Yi5wcm90b3R5cGVbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gU3ViO1xufTtcblxuenJVdGlsLmluaGVyaXRzKFBhdGgsIERpc3BsYXlhYmxlKTtcbnZhciBfZGVmYXVsdCA9IFBhdGg7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuL1N0eWxlXCIpO1xuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoXCIuLi9FbGVtZW50XCIpO1xuXG52YXIgUmVjdFRleHQgPSByZXF1aXJlKFwiLi9taXhpbi9SZWN0VGV4dFwiKTtcblxuLyoqXG4gKiDlj6/nu5jliLbnmoTlm77lvaLln7rnsbtcbiAqIEJhc2UgY2xhc3Mgb2YgYWxsIGRpc3BsYXlhYmxlIGdyYXBoaWMgb2JqZWN0c1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqL1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9FbGVtZW50XG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL21peGluL1JlY3RUZXh0XG4gKi9cbmZ1bmN0aW9uIERpc3BsYXlhYmxlKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTsgLy8gRXh0ZW5kIHByb3BlcnRpZXNcblxuICBmb3IgKHZhciBuYW1lIGluIG9wdHMpIHtcbiAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBuYW1lICE9PSAnc3R5bGUnKSB7XG4gICAgICB0aGlzW25hbWVdID0gb3B0c1tuYW1lXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfVxuICAgKi9cblxuXG4gIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob3B0cy5zdHlsZSwgdGhpcyk7XG4gIHRoaXMuX3JlY3QgPSBudWxsOyAvLyBTaGFwZXMgZm9yIGNhc2NhZGUgY2xpcHBpbmcuXG5cbiAgdGhpcy5fX2NsaXBQYXRocyA9IFtdOyAvLyBGSVhNRSBTdGF0ZWZ1bCBtdXN0IGJlIG1peGluZWQgYWZ0ZXIgc3R5bGUgaXMgc2V0dGVkXG4gIC8vIFN0YXRlZnVsLmNhbGwodGhpcywgb3B0cyk7XG59XG5cbkRpc3BsYXlhYmxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERpc3BsYXlhYmxlLFxuICB0eXBlOiAnZGlzcGxheWFibGUnLFxuXG4gIC8qKlxuICAgKiBEaXNwbGF5YWJsZSDmmK/lkKbkuLrohI/vvIxQYWludGVyIOS4reS8muagueaNruivpeagh+iusOWIpOaWreaYr+WQpumcgOimgeaYr+WQpumcgOimgemHjeaWsOe7mOWItlxuICAgKiBEaXJ0eSBmbGFnLiBGcm9tIHdoaWNoIHBhaW50ZXIgd2lsbCBkZXRlcm1pbmUgaWYgdGhpcyBkaXNwbGF5YWJsZSBvYmplY3QgbmVlZHMgYnJ1c2hcbiAgICogQG5hbWUgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNfX2RpcnR5XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgX19kaXJ0eTogdHJ1ZSxcblxuICAvKipcbiAgICog5Zu+5b2i5piv5ZCm5Y+v6KeB77yM5Li6dHJ1ZeaXtuS4jee7mOWItuWbvuW9ou+8jOS9huaYr+S7jeiDveinpuWPkem8oOagh+S6i+S7tlxuICAgKiBJZiBpZ25vcmUgZHJhd2luZyBvZiB0aGUgZGlzcGxheWFibGUgb2JqZWN0LiBNb3VzZSBldmVudCB3aWxsIHN0aWxsIGJlIHRyaWdnZXJlZFxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNpbnZpc2libGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpbnZpc2libGU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHo6IDAsXG5cbiAgLyoqXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgejI6IDAsXG5cbiAgLyoqXG4gICAqIHrlsYJsZXZlbO+8jOWGs+Wumue7mOeUu+WcqOWTquWxgmNhbnZhc+S4rVxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6bGV2ZWxcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgemxldmVsOiAwLFxuXG4gIC8qKlxuICAgKiDmmK/lkKblj6/mi5bmi71cbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJhZ2dhYmxlOiBmYWxzZSxcblxuICAvKipcbiAgICog5piv5ZCm5q2j5Zyo5ouW5ou9XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2RyYWdnYWJsZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRyYWdnaW5nOiBmYWxzZSxcblxuICAvKipcbiAgICog5piv5ZCm55u45bqU6byg5qCH5LqL5Lu2XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3NpbGVudFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIElmIGVuYWJsZSBjdWxsaW5nXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgY3VsbGluZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIE1vdXNlIGN1cnNvciB3aGVuIGhvdmVyZWRcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjY3Vyc29yXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBjdXJzb3I6ICdwb2ludGVyJyxcblxuICAvKipcbiAgICogSWYgaG92ZXIgYXJlYSBpcyBib3VuZGluZyByZWN0XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3JlY3RIb3ZlclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgcmVjdEhvdmVyOiBmYWxzZSxcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBlbGVtZW50IHByb2dyZXNzaXZlbHkgd2hlbiB0aGUgdmFsdWUgPj0gMCxcbiAgICogdXNlZnVsbCBmb3IgbGFyZ2UgZGF0YS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHByb2dyZXNzaXZlOiAtMSxcbiAgYmVmb3JlQnJ1c2g6IGZ1bmN0aW9uIChjdHgpIHt9LFxuICBhZnRlckJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcblxuICAvKipcbiAgICog5Zu+5b2i57uY5Yi25pa55rOVXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICovXG4gIC8vIEludGVyZmFjZVxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7fSxcblxuICAvKipcbiAgICog6I635Y+W5pyA5bCP5YyF5Zu055uSXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgLy8gSW50ZXJmYWNlXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge30sXG5cbiAgLyoqXG4gICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9ouS4ilxuICAgKiBJZiBkaXNwbGF5YWJsZSBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLnJlY3RDb250YWluKHgsIHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICovXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDliKTmlq3lnZDmoIcgeCwgeSDmmK/lkKblnKjlm77lvaLnmoTljIXlm7Tnm5LkuIpcbiAgICogSWYgYm91bmRpbmcgcmVjdCBvZiBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICByZWN0Q29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgY29vcmQgPSB0aGlzLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCh4LCB5KTtcbiAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgcmV0dXJuIHJlY3QuY29udGFpbihjb29yZFswXSwgY29vcmRbMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmoIforrDlm77lvaLlhYPntKDkuLrohI/vvIzlubbkuJTlnKjkuIvkuIDluKfph43nu5hcbiAgICogTWFyayBkaXNwbGF5YWJsZSBlbGVtZW50IGRpcnR5IGFuZCByZWZyZXNoIG5leHQgZnJhbWVcbiAgICovXG4gIGRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICog5Zu+5b2i5piv5ZCm5Lya6Kem5Y+R5LqL5Lu2XG4gICAqIElmIGRpc3BsYXlhYmxlIG9iamVjdCBiaW5kZWQgYW55IGV2ZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICAvLyBUT0RPLCDpgJrov4cgYmluZCDnu5HlrprnmoTkuovku7ZcbiAgLy8gaXNTaWxlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgLy8gICAgIHJldHVybiAhKFxuICAvLyAgICAgICAgIHRoaXMuaG92ZXJhYmxlIHx8IHRoaXMuZHJhZ2dhYmxlXG4gIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlbW92ZSB8fCB0aGlzLm9ubW91c2VvdmVyIHx8IHRoaXMub25tb3VzZW91dFxuICAvLyAgICAgICAgIHx8IHRoaXMub25tb3VzZWRvd24gfHwgdGhpcy5vbm1vdXNldXAgfHwgdGhpcy5vbmNsaWNrXG4gIC8vICAgICAgICAgfHwgdGhpcy5vbmRyYWdlbnRlciB8fCB0aGlzLm9uZHJhZ292ZXIgfHwgdGhpcy5vbmRyYWdsZWF2ZVxuICAvLyAgICAgICAgIHx8IHRoaXMub25kcm9wXG4gIC8vICAgICApO1xuICAvLyB9LFxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc3R5bGUnKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICovXG4gIGFuaW1hdGVTdHlsZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzdHlsZScsIGxvb3ApO1xuICB9LFxuICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSAhPT0gJ3N0eWxlJykge1xuICAgICAgRWxlbWVudC5wcm90b3R5cGUuYXR0cktWLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3R5bGUuc2V0KHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFN0eWxlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuc3R5bGUuc2V0KGtleSwgdmFsdWUpO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVc2UgZ2l2ZW4gc3R5bGUgb2JqZWN0XG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqXG4gICAqL1xuICB1c2VTdHlsZTogZnVuY3Rpb24gKG9iaikge1xuICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob2JqLCB0aGlzKTtcbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnpyVXRpbC5pbmhlcml0cyhEaXNwbGF5YWJsZSwgRWxlbWVudCk7XG56clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFJlY3RUZXh0KTsgLy8genJVdGlsLm1peGluKERpc3BsYXlhYmxlLCBTdGF0ZWZ1bCk7XG5cbnZhciBfZGVmYXVsdCA9IERpc3BsYXlhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU1RZTEVfQ09NTU9OX1BST1BTID0gW1snc2hhZG93Qmx1cicsIDBdLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLCBbJ2xpbmVDYXAnLCAnYnV0dCddLCBbJ2xpbmVKb2luJywgJ21pdGVyJ10sIFsnbWl0ZXJMaW1pdCcsIDEwXV07IC8vIHZhciBTSEFET1dfUFJPUFMgPSBTVFlMRV9DT01NT05fUFJPUFMuc2xpY2UoMCwgNCk7XG4vLyB2YXIgTElORV9QUk9QUyA9IFNUWUxFX0NPTU1PTl9QUk9QUy5zbGljZSg0KTtcblxudmFyIFN0eWxlID0gZnVuY3Rpb24gKG9wdHMsIGhvc3QpIHtcbiAgdGhpcy5leHRlbmRGcm9tKG9wdHMsIGZhbHNlKTtcbiAgdGhpcy5ob3N0ID0gaG9zdDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmVhckdyYWRpZW50KGN0eCwgb2JqLCByZWN0KSB7XG4gIHZhciB4ID0gb2JqLnggPT0gbnVsbCA/IDAgOiBvYmoueDtcbiAgdmFyIHgyID0gb2JqLngyID09IG51bGwgPyAxIDogb2JqLngyO1xuICB2YXIgeSA9IG9iai55ID09IG51bGwgPyAwIDogb2JqLnk7XG4gIHZhciB5MiA9IG9iai55MiA9PSBudWxsID8gMCA6IG9iai55MjtcblxuICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICB4ID0geCAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgeDIgPSB4MiAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgeSA9IHkgKiByZWN0LmhlaWdodCArIHJlY3QueTtcbiAgICB5MiA9IHkyICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gIH1cblxuICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeDIsIHkyKTtcbiAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSYWRpYWxHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIHZhciBtaW4gPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIHggPSBvYmoueCA9PSBudWxsID8gMC41IDogb2JqLng7XG4gIHZhciB5ID0gb2JqLnkgPT0gbnVsbCA/IDAuNSA6IG9iai55O1xuICB2YXIgciA9IG9iai5yID09IG51bGwgPyAwLjUgOiBvYmoucjtcblxuICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICB4ID0geCAqIHdpZHRoICsgcmVjdC54O1xuICAgIHkgPSB5ICogaGVpZ2h0ICsgcmVjdC55O1xuICAgIHIgPSByICogbWluO1xuICB9XG5cbiAgdmFyIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgsIHksIDAsIHgsIHksIHIpO1xuICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG59XG5cblN0eWxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFN0eWxlLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX1cbiAgICovXG4gIGhvc3Q6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmaWxsOiAnIzAwMCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdHJva2U6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBvcGFjaXR5OiAxLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBsaW5lRGFzaDogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGxpbmVEYXNoT2Zmc2V0OiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2hhZG93Qmx1cjogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNoYWRvd09mZnNldFg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzaGFkb3dPZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbGluZVdpZHRoOiAxLFxuXG4gIC8qKlxuICAgKiBJZiBzdHJva2UgaWdub3JlIHNjYWxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc3Ryb2tlTm9TY2FsZTogZmFsc2UsXG4gIC8vIEJvdW5kaW5nIHJlY3QgdGV4dCBjb25maWd1cmF0aW9uXG4gIC8vIE5vdCBhZmZlY3RlZCBieSBlbGVtZW50IHRyYW5zZm9ybVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dDogbnVsbCxcblxuICAvKipcbiAgICogSWYgYGZvbnRTaXplYCBvciBgZm9udEZhbWlseWAgZXhpc3RzLCBgZm9udGAgd2lsbCBiZSByZXNldCBieVxuICAgKiBgZm9udFNpemVgLCBgZm9udFN0eWxlYCwgYGZvbnRXZWlnaHRgLCBgZm9udEZhbWlseWAuXG4gICAqIFNvIGRvIG5vdCB2aXNpdCBpdCBkaXJlY3RseSBpbiB1cHBlciBhcHBsaWNhdGlvbiAobGlrZSBlY2hhcnRzKSxcbiAgICogYnV0IHVzZSBgY29udGFpbi90ZXh0I21ha2VGb250YCBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udDogbnVsbCxcblxuICAvKipcbiAgICogVGhlIHNhbWUgYXMgZm9udC4gVXNlIGZvbnQgcGxlYXNlLlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEZvbnQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEl0IGhlbHBzIG1lcmdpbmcgcmVzcGVjdGl2ZWx5LCByYXRoZXIgdGhhbiBwYXJzaW5nIGFuIGVudGlyZSBmb250IHN0cmluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZvbnRTdHlsZTogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udFdlaWdodDogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBTaG91bGQgYmUgMTIgYnV0IG5vdCAnMTJweCcuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBmb250U2l6ZTogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udEZhbWlseTogbnVsbCxcblxuICAvKipcbiAgICogUmVzZXJ2ZWQgZm9yIHNwZWNpYWwgZnVuY3RpbmFsaXR5LCBsaWtlICdocicuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0VGFnOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEZpbGw6ICcjMDAwJyxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRTdHJva2U6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0V2lkdGg6IG51bGwsXG5cbiAgLyoqXG4gICAqIE9ubHkgZm9yIHRleHRCYWNrZ3JvdW5kLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEhlaWdodDogbnVsbCxcblxuICAvKipcbiAgICogdGV4dFN0cm9rZSBtYXkgYmUgc2V0IGFzIHNvbWUgY29sb3IgYXMgYSBkZWZhdWx0XG4gICAqIHZhbHVlIGluIHVwcGVyIGFwcGxpY2Fpb24sIHdoZXJlIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAqIG9mIHRleHRTdHJva2VXaWR0aCBzaG91bGQgYmUgMCB0byBtYWtlIHN1cmUgdGhhdFxuICAgKiB1c2VyIGNhbiBjaG9vc2UgdG8gZG8gbm90IHVzZSB0ZXh0IHN0cm9rZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTdHJva2VXaWR0aDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRMaW5lSGVpZ2h0OiBudWxsLFxuXG4gIC8qKlxuICAgKiAnaW5zaWRlJywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSdcbiAgICogW3gsIHldXG4gICAqIEJhc2VkIG9uIHgsIHkgb2YgcmVjdC5cbiAgICogQHR5cGUge3N0cmluZ3xBcnJheS48bnVtYmVyPn1cbiAgICogQGRlZmF1bHQgJ2luc2lkZSdcbiAgICovXG4gIHRleHRQb3NpdGlvbjogJ2luc2lkZScsXG5cbiAgLyoqXG4gICAqIElmIG5vdCBzcGVjaWZpZWQsIHVzZSB0aGUgYm91bmRpbmdSZWN0IG9mIGEgYGRpc3BsYXlhYmxlYC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRleHRSZWN0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBbeCwgeV1cbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgdGV4dE9mZnNldDogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRBbGlnbjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRWZXJ0aWNhbEFsaWduOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dERpc3RhbmNlOiA1LFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFNoYWRvd0JsdXI6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0U2hhZG93T2Zmc2V0WDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTaGFkb3dPZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd0JsdXI6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm94U2hhZG93T2Zmc2V0WDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3hTaGFkb3dPZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRyYW5zZm9ybSB0ZXh0LlxuICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdHJhbnNmb3JtVGV4dDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFRleHQgcm90YXRlIGFyb3VuZCBwb3NpdGlvbiBvZiBQYXRoIG9yIEltYWdlXG4gICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnQgYW5kIHRyYW5zZm9ybVRleHQgaXMgZmFsc2UuXG4gICAqL1xuICB0ZXh0Um90YXRpb246IDAsXG5cbiAgLyoqXG4gICAqIFRleHQgb3JpZ2luIG9mIHRleHQgcm90YXRpb24sIGxpa2UgWzEwLCA0MF0uXG4gICAqIEJhc2VkIG9uIHgsIHkgb2YgcmVjdC5cbiAgICogVXNlZnVsIGluIGxhYmVsIHJvdGF0aW9uIG9mIGNpcmN1bGFyIHN5bWJvbC5cbiAgICogQnkgZGVmYXVsdCwgdGhpcyBvcmlnaW4gaXMgdGV4dFBvc2l0aW9uLlxuICAgKiBDYW4gYmUgJ2NlbnRlcicuXG4gICAqIEB0eXBlIHtzdHJpbmd8QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0ZXh0T3JpZ2luOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEJhY2tncm91bmRDb2xvcjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRCb3JkZXJDb2xvcjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3JkZXJXaWR0aDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3JkZXJSYWRpdXM6IDAsXG5cbiAgLyoqXG4gICAqIENhbiBiZSBgMmAgb3IgYFsyLCA0XWAgb3IgYFsyLCAzLCA0LCA1XWBcbiAgICogQHR5cGUge251bWJlcnxBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHRleHRQYWRkaW5nOiBudWxsLFxuXG4gIC8qKlxuICAgKiBUZXh0IHN0eWxlcyBmb3IgcmljaCB0ZXh0LlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcmljaDogbnVsbCxcblxuICAvKipcbiAgICoge291dGVyV2lkdGgsIG91dGVySGVpZ2h0LCBlbGxpcHNpcywgcGxhY2Vob2xkZXJ9XG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0cnVuY2F0ZTogbnVsbCxcblxuICAvKipcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9nbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGJsZW5kOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICBiaW5kOiBmdW5jdGlvbiAoY3R4LCBlbCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcztcbiAgICB2YXIgcHJldlN0eWxlID0gcHJldkVsICYmIHByZXZFbC5zdHlsZTtcbiAgICB2YXIgZmlyc3REcmF3ID0gIXByZXZTdHlsZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IFNUWUxFX0NPTU1PTl9QUk9QU1tpXTtcbiAgICAgIHZhciBzdHlsZU5hbWUgPSBwcm9wWzBdO1xuXG4gICAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlW3N0eWxlTmFtZV0gIT09IHByZXZTdHlsZVtzdHlsZU5hbWVdKSB7XG4gICAgICAgIC8vIEZJWE1FIEludmFsaWQgcHJvcGVydHkgdmFsdWUgd2lsbCBjYXVzZSBzdHlsZSBsZWFrIGZyb20gcHJldmlvdXMgZWxlbWVudC5cbiAgICAgICAgY3R4W3N0eWxlTmFtZV0gPSBzdHlsZVtzdHlsZU5hbWVdIHx8IHByb3BbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZS5maWxsICE9PSBwcmV2U3R5bGUuZmlsbCkge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmZpbGw7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZS5zdHJva2UgIT09IHByZXZTdHlsZS5zdHJva2UpIHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLnN0cm9rZTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlLm9wYWNpdHkgIT09IHByZXZTdHlsZS5vcGFjaXR5KSB7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdHlsZS5vcGFjaXR5ID09IG51bGwgPyAxIDogc3R5bGUub3BhY2l0eTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlLmJsZW5kICE9PSBwcmV2U3R5bGUuYmxlbmQpIHtcbiAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBzdHlsZS5ibGVuZCB8fCAnc291cmNlLW92ZXInO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aCAvICh0aGlzLnN0cm9rZU5vU2NhbGUgJiYgZWwgJiYgZWwuZ2V0TGluZVNjYWxlID8gZWwuZ2V0TGluZVNjYWxlKCkgOiAxKTtcbiAgICB9XG4gIH0sXG4gIGhhc0ZpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmlsbCA9IHRoaXMuZmlsbDtcbiAgICByZXR1cm4gZmlsbCAhPSBudWxsICYmIGZpbGwgIT09ICdub25lJztcbiAgfSxcbiAgaGFzU3Ryb2tlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0cm9rZSA9IHRoaXMuc3Ryb2tlO1xuICAgIHJldHVybiBzdHJva2UgIT0gbnVsbCAmJiBzdHJva2UgIT09ICdub25lJyAmJiB0aGlzLmxpbmVXaWR0aCA+IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dGVuZCBmcm9tIG90aGVyIHN0eWxlXG4gICAqIEBwYXJhbSB7enJlbmRlci9ncmFwaGljL1N0eWxlfSBvdGhlclN0eWxlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcndyaXRlIHRydWU6IG92ZXJ3cmlydGUgYW55IHdheS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2U6IG92ZXJ3cml0ZSBvbmx5IHdoZW4gIXRhcmdldC5oYXNPd25Qcm9wZXJ0eVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlcnM6IG92ZXJ3cml0ZSB3aGVuIHByb3BlcnR5IGlzIG5vdCBudWxsL3VuZGVmaW5lZC5cbiAgICovXG4gIGV4dGVuZEZyb206IGZ1bmN0aW9uIChvdGhlclN0eWxlLCBvdmVyd3JpdGUpIHtcbiAgICBpZiAob3RoZXJTdHlsZSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBvdGhlclN0eWxlKSB7XG4gICAgICAgIGlmIChvdGhlclN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpICYmIChvdmVyd3JpdGUgPT09IHRydWUgfHwgKG92ZXJ3cml0ZSA9PT0gZmFsc2UgPyAhdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA6IG90aGVyU3R5bGVbbmFtZV0gIT0gbnVsbCkpKSB7XG4gICAgICAgICAgdGhpc1tuYW1lXSA9IG90aGVyU3R5bGVbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJhdGNoIHNldHRpbmcgc3R5bGUgd2l0aCBhIGdpdmVuIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IG9ialxuICAgKiBAcGFyYW0geyp9IFtvYmpdXG4gICAqL1xuICBzZXQ6IGZ1bmN0aW9uIChvYmosIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzW29ial0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHRlbmRGcm9tKG9iaiwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZVxuICAgKiBAcmV0dXJuIHt6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld1N0eWxlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICBuZXdTdHlsZS5leHRlbmRGcm9tKHRoaXMsIHRydWUpO1xuICAgIHJldHVybiBuZXdTdHlsZTtcbiAgfSxcbiAgZ2V0R3JhZGllbnQ6IGZ1bmN0aW9uIChjdHgsIG9iaiwgcmVjdCkge1xuICAgIHZhciBtZXRob2QgPSBvYmoudHlwZSA9PT0gJ3JhZGlhbCcgPyBjcmVhdGVSYWRpYWxHcmFkaWVudCA6IGNyZWF0ZUxpbmVhckdyYWRpZW50O1xuICAgIHZhciBjYW52YXNHcmFkaWVudCA9IG1ldGhvZChjdHgsIG9iaiwgcmVjdCk7XG4gICAgdmFyIGNvbG9yU3RvcHMgPSBvYmouY29sb3JTdG9wcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JTdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2FudmFzR3JhZGllbnQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcHNbaV0ub2Zmc2V0LCBjb2xvclN0b3BzW2ldLmNvbG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gIH1cbn07XG52YXIgc3R5bGVQcm90byA9IFN0eWxlLnByb3RvdHlwZTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBTVFlMRV9DT01NT05fUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG5cbiAgaWYgKCEocHJvcFswXSBpbiBzdHlsZVByb3RvKSkge1xuICAgIHN0eWxlUHJvdG9bcHJvcFswXV0gPSBwcm9wWzFdO1xuICB9XG59IC8vIFByb3ZpZGUgZm9yIG90aGVyc1xuXG5cblN0eWxlLmdldEdyYWRpZW50ID0gc3R5bGVQcm90by5nZXRHcmFkaWVudDtcbnZhciBfZGVmYXVsdCA9IFN0eWxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9TdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ3VpZCA9IHJlcXVpcmUoXCIuL2NvcmUvZ3VpZFwiKTtcblxudmFyIEV2ZW50ZnVsID0gcmVxdWlyZShcIi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbnZhciBUcmFuc2Zvcm1hYmxlID0gcmVxdWlyZShcIi4vbWl4aW4vVHJhbnNmb3JtYWJsZVwiKTtcblxudmFyIEFuaW1hdGFibGUgPSByZXF1aXJlKFwiLi9taXhpbi9BbmltYXRhYmxlXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9FbGVtZW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9BbmltYXRhYmxlfVxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9XG4gKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWx9XG4gKi9cbnZhciBFbGVtZW50ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIFRyYW5zZm9ybWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgRXZlbnRmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbiAgQW5pbWF0YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAvKipcbiAgICog55S75biD5YWD57SgSURcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG5cbiAgdGhpcy5pZCA9IG9wdHMuaWQgfHwgZ3VpZCgpO1xufTtcblxuRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiDlhYPntKDnsbvlnotcbiAgICogRWxlbWVudCB0eXBlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0eXBlOiAnZWxlbWVudCcsXG5cbiAgLyoqXG4gICAqIOWFg+e0oOWQjeWtl1xuICAgKiBFbGVtZW50IG5hbWVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIG5hbWU6ICcnLFxuXG4gIC8qKlxuICAgKiBaUmVuZGVyIOWunuS+i+Wvueixoe+8jOS8muWcqCBlbGVtZW50IOa3u+WKoOWIsCB6cmVuZGVyIOWunuS+i+S4reWQjuiHquWKqOi1i+WAvFxuICAgKiBaUmVuZGVyIGluc3RhbmNlIHdpbGwgYmUgYXNzaWduZWQgd2hlbiBlbGVtZW50IGlzIGFzc29jaWF0ZWQgd2l0aCB6cmVuZGVyXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9FbGVtZW50I19fenJcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAqL1xuICBfX3pyOiBudWxsLFxuXG4gIC8qKlxuICAgKiDlm77lvaLmmK/lkKblv73nlaXvvIzkuLp0cnVl5pe25b+955Wl5Zu+5b2i55qE57uY5Yi25Lul5Y+K5LqL5Lu26Kem5Y+RXG4gICAqIElmIGlnbm9yZSBkcmF3aW5nIGFuZCBldmVudHMgb2YgdGhlIGVsZW1lbnQgb2JqZWN0XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9FbGVtZW50I2lnbm9yZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGlnbm9yZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIOeUqOS6juijgeWJqueahOi3r+W+hChzaGFwZSnvvIzmiYDmnIkgR3JvdXAg5YaF55qE6Lev5b6E5Zyo57uY5Yi25pe26YO95Lya6KKr6L+Z5Liq6Lev5b6E6KOB5YmqXG4gICAqIOivpei3r+W+hOS8mue7p+aJv+iiq+ijgeWHj+WvueixoeeahOWPmOaNolxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofVxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC8jY2xpcHBpbmctcmVnaW9uXG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgY2xpcFBhdGg6IG51bGwsXG5cbiAgLyoqXG4gICAqIERyaWZ0IGVsZW1lbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkeCBkeCBvbiB0aGUgZ2xvYmFsIHNwYWNlXG4gICAqIEBwYXJhbSAge251bWJlcn0gZHkgZHkgb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgKi9cbiAgZHJpZnQ6IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgZHkgPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICBkeCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIG0gPSB0aGlzLnRyYW5zZm9ybSA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICB9XG5cbiAgICBtWzRdICs9IGR4O1xuICAgIG1bNV0gKz0gZHk7XG4gICAgdGhpcy5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogSG9vayBiZWZvcmUgdXBkYXRlXG4gICAqL1xuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIC8qKlxuICAgKiBIb29rIGFmdGVyIHVwZGF0ZVxuICAgKi9cbiAgYWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZWFjaCBmcmFtZVxuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAqL1xuICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7fSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicgfHwga2V5ID09PSAnc2NhbGUnIHx8IGtleSA9PT0gJ29yaWdpbicpIHtcbiAgICAgIC8vIENvcHkgdGhlIGFycmF5XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXNba2V5XTtcblxuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgIHRhcmdldCA9IHRoaXNba2V5XSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0WzBdID0gdmFsdWVbMF07XG4gICAgICAgIHRhcmdldFsxXSA9IHZhbHVlWzFdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGVsZW1lbnRcbiAgICovXG4gIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlnbm9yZSA9IHRydWU7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGVsZW1lbnRcbiAgICovXG4gIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlnbm9yZSA9IGZhbHNlO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBhdHRyOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5hdHRyS1Yoa2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHRoaXMuYXR0cktWKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGNsaXBQYXRoXG4gICAqL1xuICBzZXRDbGlwUGF0aDogZnVuY3Rpb24gKGNsaXBQYXRoKSB7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuXG4gICAgaWYgKHpyKSB7XG4gICAgICBjbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgfSAvLyBSZW1vdmUgcHJldmlvdXMgY2xpcCBwYXRoXG5cblxuICAgIGlmICh0aGlzLmNsaXBQYXRoICYmIHRoaXMuY2xpcFBhdGggIT09IGNsaXBQYXRoKSB7XG4gICAgICB0aGlzLnJlbW92ZUNsaXBQYXRoKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGlwUGF0aCA9IGNsaXBQYXRoO1xuICAgIGNsaXBQYXRoLl9fenIgPSB6cjtcbiAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSB0aGlzO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKi9cbiAgcmVtb3ZlQ2xpcFBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoO1xuXG4gICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICBpZiAoY2xpcFBhdGguX196cikge1xuICAgICAgICBjbGlwUGF0aC5yZW1vdmVTZWxmRnJvbVpyKGNsaXBQYXRoLl9fenIpO1xuICAgICAgfVxuXG4gICAgICBjbGlwUGF0aC5fX3pyID0gbnVsbDtcbiAgICAgIGNsaXBQYXRoLl9fY2xpcFRhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLmNsaXBQYXRoID0gbnVsbDtcbiAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkIHNlbGYgZnJvbSB6cmVuZGVyIGluc3RhbmNlLlxuICAgKiBOb3QgcmVjdXJzaXZlbHkgYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgd2hlbiBlbGVtZW50IGFkZGVkIHRvIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICovXG4gIGFkZFNlbGZUb1pyOiBmdW5jdGlvbiAoenIpIHtcbiAgICB0aGlzLl9fenIgPSB6cjsgLy8g5re75Yqg5Yqo55S7XG5cbiAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG5cbiAgICBpZiAoYW5pbWF0b3JzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgdGhpcy5jbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgc2VsZiBmcm9tIHpyZW5kZXIgaW5zdGFuY2UuXG4gICAqIE5vdCByZWN1cnNpdmVseSBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGVsZW1lbnQgYWRkZWQgdG8gc3RvcmFnZS5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgKi9cbiAgcmVtb3ZlU2VsZkZyb21acjogZnVuY3Rpb24gKHpyKSB7XG4gICAgdGhpcy5fX3pyID0gbnVsbDsgLy8g56e76Zmk5Yqo55S7XG5cbiAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG5cbiAgICBpZiAoYW5pbWF0b3JzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB6ci5hbmltYXRpb24ucmVtb3ZlQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgdGhpcy5jbGlwUGF0aC5yZW1vdmVTZWxmRnJvbVpyKHpyKTtcbiAgICB9XG4gIH1cbn07XG56clV0aWwubWl4aW4oRWxlbWVudCwgQW5pbWF0YWJsZSk7XG56clV0aWwubWl4aW4oRWxlbWVudCwgVHJhbnNmb3JtYWJsZSk7XG56clV0aWwubWl4aW4oRWxlbWVudCwgRXZlbnRmdWwpO1xudmFyIF9kZWZhdWx0ID0gRWxlbWVudDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL0VsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogenJlbmRlcjog55Sf5oiQ5ZSv5LiAaWRcbiAqXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cbnZhciBpZFN0YXJ0ID0gMHgwOTA3O1xuXG5mdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIGlkU3RhcnQrKztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9ndWlkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIOS6i+S7tuaJqeWxlVxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgYXJyeVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuLyoqXG4gKiDkuovku7bliIblj5HlmahcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIEV2ZW50ZnVsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl8kaGFuZGxlcnMgPSB7fTtcbn07XG5cbkV2ZW50ZnVsLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEV2ZW50ZnVsLFxuXG4gIC8qKlxuICAgKiDljZXmrKHop6blj5Hnu5HlrprvvIx0cmlnZ2Vy5ZCO6ZSA5q+BXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDlk43lupTlh73mlbBcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICovXG4gIG9uZTogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgIF9oW2V2ZW50XSA9IFtdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2hbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2hbZXZlbnRdLnB1c2goe1xuICAgICAgaDogaGFuZGxlcixcbiAgICAgIG9uZTogdHJ1ZSxcbiAgICAgIGN0eDogY29udGV4dCB8fCB0aGlzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog57uR5a6a5LqL5Lu2XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDkuovku7blpITnkIblh73mlbBcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICAgKi9cbiAgb246IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgY29udGV4dCkge1xuICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgIGlmICghaGFuZGxlciB8fCAhZXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghX2hbZXZlbnRdKSB7XG4gICAgICBfaFtldmVudF0gPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9oW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKF9oW2V2ZW50XVtpXS5oID09PSBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9oW2V2ZW50XS5wdXNoKHtcbiAgICAgIGg6IGhhbmRsZXIsXG4gICAgICBvbmU6IGZhbHNlLFxuICAgICAgY3R4OiBjb250ZXh0IHx8IHRoaXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmmK/lkKbnu5Hlrprkuobkuovku7ZcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgZXZlbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzU2lsZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG4gICAgcmV0dXJuIF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDop6Pnu5Hkuovku7ZcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0g5LqL5Lu25aSE55CG5Ye95pWwXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHRoaXMuXyRoYW5kbGVycyA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGlmIChfaFtldmVudF0pIHtcbiAgICAgICAgdmFyIG5ld0xpc3QgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9oW2V2ZW50XS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldWydoJ10gIT0gaGFuZGxlcikge1xuICAgICAgICAgICAgbmV3TGlzdC5wdXNoKF9oW2V2ZW50XVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2hbZXZlbnRdID0gbmV3TGlzdDtcbiAgICAgIH1cblxuICAgICAgaWYgKF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSBfaFtldmVudF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBfaFtldmVudF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOS6i+S7tuWIhuWPkVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICovXG4gIHRyaWdnZXI6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHRoaXMuXyRoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGlmIChhcmdMZW4gPiAzKSB7XG4gICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgdmFyIGxlbiA9IF9oLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSwgYXJnc1syXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICBfaFtpXVsnaCddLmFwcGx5KF9oW2ldWydjdHgnXSwgYXJncyk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgIF9oLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDluKbmnIljb250ZXh055qE5LqL5Lu25YiG5Y+RLCDmnIDlkI7kuIDkuKrlj4LmlbDmmK/kuovku7blm57osIPnmoRjb250ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgKi9cbiAgdHJpZ2dlcldpdGhDb250ZXh0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0aGlzLl8kaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGFyZ0xlbiA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJnTGVuID4gNCkge1xuICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSwgYXJncy5sZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVyc1t0eXBlXTtcbiAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAvLyBPcHRpbWl6ZSBhZHZpc2UgZnJvbSBiYWNrYm9uZVxuICAgICAgICBzd2l0Y2ggKGFyZ0xlbikge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgpO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgsIGFyZ3NbMV0pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgsIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBoYXZlIG1vcmUgdGhhbiAyIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShjdHgsIGFyZ3MpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfaFtpXVsnb25lJ10pIHtcbiAgICAgICAgICBfaC5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW4tLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTsgLy8g5a+56LGh5Y+v5Lul6YCa6L+HIG9ueHh4eCDnu5Hlrprkuovku7ZcblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25jbGlja1xuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdmVyXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW91dFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vtb3ZlXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXdoZWVsXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZWRvd25cbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNldXBcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdzdGFydFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2VuZFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2VudGVyXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnbGVhdmVcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdvdmVyXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcm9wXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxudmFyIF9kZWZhdWx0ID0gRXZlbnRmdWw7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1hdHJpeCA9IHJlcXVpcmUoXCIuLi9jb3JlL21hdHJpeFwiKTtcblxudmFyIHZlY3RvciA9IHJlcXVpcmUoXCIuLi9jb3JlL3ZlY3RvclwiKTtcblxuLyoqXG4gKiDmj5Dkvpvlj5jmjaLmianlsZVcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xudmFyIG1JZGVudGl0eSA9IG1hdHJpeC5pZGVudGl0eTtcbnZhciBFUFNJTE9OID0gNWUtNTtcblxuZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFRyYW5zZm9ybWFibGUgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTsgLy8gSWYgdGhlcmUgYXJlIG5vIGdpdmVuIHBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGVcblxuICBpZiAoIW9wdHMucG9zaXRpb24pIHtcbiAgICAvKipcbiAgICAgKiDlubPnp7tcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQGRlZmF1bHQgWzAsIDBdXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IFswLCAwXTtcbiAgfVxuXG4gIGlmIChvcHRzLnJvdGF0aW9uID09IG51bGwpIHtcbiAgICAvKipcbiAgICAgKiDml4vovaxcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb24gPSAwO1xuICB9XG5cbiAgaWYgKCFvcHRzLnNjYWxlKSB7XG4gICAgLyoqXG4gICAgICog57yp5pS+XG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBkZWZhdWx0IFsxLCAxXVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGUgPSBbMSwgMV07XG4gIH1cbiAgLyoqXG4gICAqIOaXi+i9rOWSjOe8qeaUvueahOWOn+eCuVxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG5cblxuICB0aGlzLm9yaWdpbiA9IHRoaXMub3JpZ2luIHx8IG51bGw7XG59O1xuXG52YXIgdHJhbnNmb3JtYWJsZVByb3RvID0gVHJhbnNmb3JtYWJsZS5wcm90b3R5cGU7XG50cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtID0gbnVsbDtcbi8qKlxuICog5Yik5pat5piv5ZCm6ZyA6KaB5pyJ5Z2Q5qCH5Y+Y5o2iXG4gKiDlpoLmnpzmnInlnZDmoIflj5jmjaIsIOWImeS7jnBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGXku6Xlj4rniLboioLngrnnmoR0cmFuc2Zvcm3orqHnrpflh7roh6rouqvnmoR0cmFuc2Zvcm3nn6npmLVcbiAqL1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8ubmVlZExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNOb3RBcm91bmRaZXJvKHRoaXMucm90YXRpb24pIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzBdKSB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5wb3NpdGlvblsxXSkgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMuc2NhbGVbMF0gLSAxKSB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVsxXSAtIDEpO1xufTtcblxudHJhbnNmb3JtYWJsZVByb3RvLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICB2YXIgcGFyZW50SGFzVHJhbnNmb3JtID0gcGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm07XG4gIHZhciBuZWVkTG9jYWxUcmFuc2Zvcm0gPSB0aGlzLm5lZWRMb2NhbFRyYW5zZm9ybSgpO1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmICghKG5lZWRMb2NhbFRyYW5zZm9ybSB8fCBwYXJlbnRIYXNUcmFuc2Zvcm0pKSB7XG4gICAgbSAmJiBtSWRlbnRpdHkobSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbSA9IG0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuXG4gIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLmdldExvY2FsVHJhbnNmb3JtKG0pO1xuICB9IGVsc2Uge1xuICAgIG1JZGVudGl0eShtKTtcbiAgfSAvLyDlupTnlKjniLboioLngrnlj5jmjaJcblxuXG4gIGlmIChwYXJlbnRIYXNUcmFuc2Zvcm0pIHtcbiAgICBpZiAobmVlZExvY2FsVHJhbnNmb3JtKSB7XG4gICAgICBtYXRyaXgubXVsKG0sIHBhcmVudC50cmFuc2Zvcm0sIG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRyaXguY29weShtLCBwYXJlbnQudHJhbnNmb3JtKTtcbiAgICB9XG4gIH0gLy8g5L+d5a2Y6L+Z5Liq5Y+Y5o2i55+p6Zi1XG5cblxuICB0aGlzLnRyYW5zZm9ybSA9IG07XG4gIHRoaXMuaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuICBtYXRyaXguaW52ZXJ0KHRoaXMuaW52VHJhbnNmb3JtLCBtKTtcbn07XG5cbnRyYW5zZm9ybWFibGVQcm90by5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7XG4gIHJldHVybiBUcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtKHRoaXMsIG0pO1xufTtcbi8qKlxuICog5bCG6Ieq5bex55qEdHJhbnNmb3Jt5bqU55So5YiwY29udGV4dOS4ilxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcblxuICBpZiAobSkge1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByICogbVswXSwgZHByICogbVsxXSwgZHByICogbVsyXSwgZHByICogbVszXSwgZHByICogbVs0XSwgZHByICogbVs1XSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LnNldFRyYW5zZm9ybShkcHIsIDAsIDAsIGRwciwgMCwgMCk7XG4gIH1cbn07XG5cbnRyYW5zZm9ybWFibGVQcm90by5yZXN0b3JlVHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbn07XG5cbnZhciB0bXBUcmFuc2Zvcm0gPSBbXTtcbi8qKlxuICog5YiG6KejYHRyYW5zZm9ybWDnn6npmLXliLBgcG9zaXRpb25gLCBgcm90YXRpb25gLCBgc2NhbGVgXG4gKi9cblxudHJhbnNmb3JtYWJsZVByb3RvLmRlY29tcG9zZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRyYW5zZm9ybSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICBpZiAocGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm0pIHtcbiAgICAvLyBHZXQgbG9jYWwgdHJhbnNmb3JtIGFuZCBkZWNvbXBvc2UgdGhlbSB0byBwb3NpdGlvbiwgc2NhbGUsIHJvdGF0aW9uXG4gICAgbWF0cml4Lm11bCh0bXBUcmFuc2Zvcm0sIHBhcmVudC5pbnZUcmFuc2Zvcm0sIG0pO1xuICAgIG0gPSB0bXBUcmFuc2Zvcm07XG4gIH1cblxuICB2YXIgc3ggPSBtWzBdICogbVswXSArIG1bMV0gKiBtWzFdO1xuICB2YXIgc3kgPSBtWzJdICogbVsyXSArIG1bM10gKiBtWzNdO1xuICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuXG4gIGlmIChpc05vdEFyb3VuZFplcm8oc3ggLSAxKSkge1xuICAgIHN4ID0gTWF0aC5zcXJ0KHN4KTtcbiAgfVxuXG4gIGlmIChpc05vdEFyb3VuZFplcm8oc3kgLSAxKSkge1xuICAgIHN5ID0gTWF0aC5zcXJ0KHN5KTtcbiAgfVxuXG4gIGlmIChtWzBdIDwgMCkge1xuICAgIHN4ID0gLXN4O1xuICB9XG5cbiAgaWYgKG1bM10gPCAwKSB7XG4gICAgc3kgPSAtc3k7XG4gIH1cblxuICBwb3NpdGlvblswXSA9IG1bNF07XG4gIHBvc2l0aW9uWzFdID0gbVs1XTtcbiAgc2NhbGVbMF0gPSBzeDtcbiAgc2NhbGVbMV0gPSBzeTtcbiAgdGhpcy5yb3RhdGlvbiA9IE1hdGguYXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbn07XG4vKipcbiAqIEdldCBnbG9iYWwgc2NhbGVcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLmdldEdsb2JhbFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmICghbSkge1xuICAgIHJldHVybiBbMSwgMV07XG4gIH1cblxuICB2YXIgc3ggPSBNYXRoLnNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gIHZhciBzeSA9IE1hdGguc3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcblxuICBpZiAobVswXSA8IDApIHtcbiAgICBzeCA9IC1zeDtcbiAgfVxuXG4gIGlmIChtWzNdIDwgMCkge1xuICAgIHN5ID0gLXN5O1xuICB9XG5cbiAgcmV0dXJuIFtzeCwgc3ldO1xufTtcbi8qKlxuICog5Y+Y5o2i5Z2Q5qCH5L2N572u5YiwIHNoYXBlIOeahOWxgOmDqOWdkOagh+epuumXtFxuICogQG1ldGhvZFxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5cbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvTG9jYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICB2YXIgdjIgPSBbeCwgeV07XG4gIHZhciBpbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybTtcblxuICBpZiAoaW52VHJhbnNmb3JtKSB7XG4gICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgaW52VHJhbnNmb3JtKTtcbiAgfVxuXG4gIHJldHVybiB2Mjtcbn07XG4vKipcbiAqIOWPmOaNouWxgOmDqOWdkOagh+S9jee9ruWIsOWFqOWxgOWdkOagh+epuumXtFxuICogQG1ldGhvZFxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5cbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvR2xvYmFsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdmFyIHYyID0gW3gsIHldO1xuICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKHRyYW5zZm9ybSkge1xuICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIHRyYW5zZm9ybSk7XG4gIH1cblxuICByZXR1cm4gdjI7XG59O1xuLyoqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0YXJnZXQub3JpZ2luXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0LnJvdGF0aW9uXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0YXJnZXQucG9zaXRpb25cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFttXVxuICovXG5cblxuVHJhbnNmb3JtYWJsZS5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIG0pIHtcbiAgbSA9IG0gfHwgW107XG4gIG1JZGVudGl0eShtKTtcbiAgdmFyIG9yaWdpbiA9IHRhcmdldC5vcmlnaW47XG4gIHZhciBzY2FsZSA9IHRhcmdldC5zY2FsZSB8fCBbMSwgMV07XG4gIHZhciByb3RhdGlvbiA9IHRhcmdldC5yb3RhdGlvbiB8fCAwO1xuICB2YXIgcG9zaXRpb24gPSB0YXJnZXQucG9zaXRpb24gfHwgWzAsIDBdO1xuXG4gIGlmIChvcmlnaW4pIHtcbiAgICAvLyBUcmFuc2xhdGUgdG8gb3JpZ2luXG4gICAgbVs0XSAtPSBvcmlnaW5bMF07XG4gICAgbVs1XSAtPSBvcmlnaW5bMV07XG4gIH1cblxuICBtYXRyaXguc2NhbGUobSwgbSwgc2NhbGUpO1xuXG4gIGlmIChyb3RhdGlvbikge1xuICAgIG1hdHJpeC5yb3RhdGUobSwgbSwgcm90YXRpb24pO1xuICB9XG5cbiAgaWYgKG9yaWdpbikge1xuICAgIC8vIFRyYW5zbGF0ZSBiYWNrIGZyb20gb3JpZ2luXG4gICAgbVs0XSArPSBvcmlnaW5bMF07XG4gICAgbVs1XSArPSBvcmlnaW5bMV07XG4gIH1cblxuICBtWzRdICs9IHBvc2l0aW9uWzBdO1xuICBtWzVdICs9IHBvc2l0aW9uWzFdO1xuICByZXR1cm4gbTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IFRyYW5zZm9ybWFibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9taXhpbi9UcmFuc2Zvcm1hYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIDN4MuefqemYteaTjeS9nOexu1xuICogQGV4cG9ydHMgenJlbmRlci90b29sL21hdHJpeFxuICovXG52YXIgQXJyYXlDdG9yID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBBcnJheSA6IEZsb2F0MzJBcnJheTtcbi8qKlxuICog5Yib5bu65LiA5Liq5Y2V5L2N55+p6Zi1XG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IEFycmF5Q3Rvcig2KTtcbiAgaWRlbnRpdHkob3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog6K6+572u55+p6Zi15Li65Y2V5L2N55+p6Zi1XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5aSN5Yi255+p6Zi1XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbVxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIG0pIHtcbiAgb3V0WzBdID0gbVswXTtcbiAgb3V0WzFdID0gbVsxXTtcbiAgb3V0WzJdID0gbVsyXTtcbiAgb3V0WzNdID0gbVszXTtcbiAgb3V0WzRdID0gbVs0XTtcbiAgb3V0WzVdID0gbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog55+p6Zi155u45LmYXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTFcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMlxuICovXG5cblxuZnVuY3Rpb24gbXVsKG91dCwgbTEsIG0yKSB7XG4gIC8vIENvbnNpZGVyIG1hdHJpeC5tdWwobSwgbTIsIG0pO1xuICAvLyB3aGVyZSBvdXQgaXMgdGhlIHNhbWUgYXMgbTIuXG4gIC8vIFNvIHVzZSB0ZW1wIHZhcmlhYmxlIHRvIGVzY2FwZSBlcnJvci5cbiAgdmFyIG91dDAgPSBtMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXTtcbiAgdmFyIG91dDEgPSBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXTtcbiAgdmFyIG91dDIgPSBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXTtcbiAgdmFyIG91dDMgPSBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXTtcbiAgdmFyIG91dDQgPSBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdO1xuICB2YXIgb3V0NSA9IG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV07XG4gIG91dFswXSA9IG91dDA7XG4gIG91dFsxXSA9IG91dDE7XG4gIG91dFsyXSA9IG91dDI7XG4gIG91dFszXSA9IG91dDM7XG4gIG91dFs0XSA9IG91dDQ7XG4gIG91dFs1XSA9IG91dDU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOW5s+enu+WPmOaNolxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSB2XG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF0gKyB2WzBdO1xuICBvdXRbNV0gPSBhWzVdICsgdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5peL6L2s5Y+Y5o2iXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZFxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhYSA9IGFbMF07XG4gIHZhciBhYyA9IGFbMl07XG4gIHZhciBhdHggPSBhWzRdO1xuICB2YXIgYWIgPSBhWzFdO1xuICB2YXIgYWQgPSBhWzNdO1xuICB2YXIgYXR5ID0gYVs1XTtcbiAgdmFyIHN0ID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGN0ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYWEgKiBjdCArIGFiICogc3Q7XG4gIG91dFsxXSA9IC1hYSAqIHN0ICsgYWIgKiBjdDtcbiAgb3V0WzJdID0gYWMgKiBjdCArIGFkICogc3Q7XG4gIG91dFszXSA9IC1hYyAqIHN0ICsgY3QgKiBhZDtcbiAgb3V0WzRdID0gY3QgKiBhdHggKyBzdCAqIGF0eTtcbiAgb3V0WzVdID0gY3QgKiBhdHkgLSBzdCAqIGF0eDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog57yp5pS+5Y+Y5o2iXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgdnggPSB2WzBdO1xuICB2YXIgdnkgPSB2WzFdO1xuICBvdXRbMF0gPSBhWzBdICogdng7XG4gIG91dFsxXSA9IGFbMV0gKiB2eTtcbiAgb3V0WzJdID0gYVsyXSAqIHZ4O1xuICBvdXRbM10gPSBhWzNdICogdnk7XG4gIG91dFs0XSA9IGFbNF0gKiB2eDtcbiAgb3V0WzVdID0gYVs1XSAqIHZ5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmsYLpgIbnn6npmLVcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhYSA9IGFbMF07XG4gIHZhciBhYyA9IGFbMl07XG4gIHZhciBhdHggPSBhWzRdO1xuICB2YXIgYWIgPSBhWzFdO1xuICB2YXIgYWQgPSBhWzNdO1xuICB2YXIgYXR5ID0gYVs1XTtcbiAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IGFkICogZGV0O1xuICBvdXRbMV0gPSAtYWIgKiBkZXQ7XG4gIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gIG91dFs0XSA9IChhYyAqIGF0eSAtIGFkICogYXR4KSAqIGRldDtcbiAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuXG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLm11bCA9IG11bDtcbmV4cG9ydHMudHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuZXhwb3J0cy5yb3RhdGUgPSByb3RhdGU7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLmludmVydCA9IGludmVydDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9tYXRyaXguanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IEFycmF5IDogRmxvYXQzMkFycmF5O1xuLyoqXG4gKiDliJvlu7rkuIDkuKrlkJHph49cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gKiBAcmV0dXJuIHtWZWN0b3IyfVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZSh4LCB5KSB7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDIpO1xuXG4gIGlmICh4ID09IG51bGwpIHtcbiAgICB4ID0gMDtcbiAgfVxuXG4gIGlmICh5ID09IG51bGwpIHtcbiAgICB5ID0gMDtcbiAgfVxuXG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWkjeWItuWQkemHj+aVsOaNrlxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHJldHVybiB7VmVjdG9yMn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHkob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWFi+mahuS4gOS4quWQkemHj1xuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtWZWN0b3IyfVxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUodikge1xuICB2YXIgb3V0ID0gbmV3IEFycmF5Q3RvcigyKTtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog6K6+572u5ZCR6YeP55qE5Lik5Liq6aG5XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtWZWN0b3IyfSDnu5PmnpxcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYTtcbiAgb3V0WzFdID0gYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP55u45YqgXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gYWRkKG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdICsgdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdICsgdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+e8qeaUvuWQjuebuOWKoFxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIHYxLCB2MiwgYSkge1xuICBvdXRbMF0gPSB2MVswXSArIHYyWzBdICogYTtcbiAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXSAqIGE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+ebuOWHj1xuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1YihvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSB2MVswXSAtIHYyWzBdO1xuICBvdXRbMV0gPSB2MVsxXSAtIHYyWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/plb/luqZcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gbGVuKHYpIHtcbiAgcmV0dXJuIE1hdGguc3FydChsZW5TcXVhcmUodikpO1xufVxuXG52YXIgbGVuZ3RoID0gbGVuOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuLyoqXG4gKiDlkJHph4/plb/luqblubPmlrlcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIGxlblNxdWFyZSh2KSB7XG4gIHJldHVybiB2WzBdICogdlswXSArIHZbMV0gKiB2WzFdO1xufVxuXG52YXIgbGVuZ3RoU3F1YXJlID0gbGVuU3F1YXJlO1xuLyoqXG4gKiDlkJHph4/kuZjms5VcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKi9cblxuZnVuY3Rpb24gbXVsKG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdICogdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdICogdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+mZpOazlVxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpdihvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSB2MVswXSAvIHYyWzBdO1xuICBvdXRbMV0gPSB2MVsxXSAvIHYyWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/ngrnkuZhcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGRvdCh2MSwgdjIpIHtcbiAgcmV0dXJuIHYxWzBdICogdjJbMF0gKyB2MVsxXSAqIHYyWzFdO1xufVxuLyoqXG4gKiDlkJHph4/nvKnmlL5cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEBwYXJhbSB7bnVtYmVyfSBzXG4gKi9cblxuXG5mdW5jdGlvbiBzY2FsZShvdXQsIHYsIHMpIHtcbiAgb3V0WzBdID0gdlswXSAqIHM7XG4gIG91dFsxXSA9IHZbMV0gKiBzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/lvZLkuIDljJZcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIHYpIHtcbiAgdmFyIGQgPSBsZW4odik7XG5cbiAgaWYgKGQgPT09IDApIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gdlswXSAvIGQ7XG4gICAgb3V0WzFdID0gdlsxXSAvIGQ7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDorqHnrpflkJHph4/pl7Tot53nprtcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGRpc3RhbmNlKHYxLCB2Mikge1xuICByZXR1cm4gTWF0aC5zcXJ0KCh2MVswXSAtIHYyWzBdKSAqICh2MVswXSAtIHYyWzBdKSArICh2MVsxXSAtIHYyWzFdKSAqICh2MVsxXSAtIHYyWzFdKSk7XG59XG5cbnZhciBkaXN0ID0gZGlzdGFuY2U7XG4vKipcbiAqIOWQkemHj+i3neemu+W5s+aWuVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIGRpc3RhbmNlU3F1YXJlKHYxLCB2Mikge1xuICByZXR1cm4gKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pICsgKHYxWzFdIC0gdjJbMV0pICogKHYxWzFdIC0gdjJbMV0pO1xufVxuXG52YXIgZGlzdFNxdWFyZSA9IGRpc3RhbmNlU3F1YXJlO1xuLyoqXG4gKiDmsYLotJ/lkJHph49cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqL1xuXG5mdW5jdGlvbiBuZWdhdGUob3V0LCB2KSB7XG4gIG91dFswXSA9IC12WzBdO1xuICBvdXRbMV0gPSAtdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5o+S5YC85Lik5Liq54K5XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqL1xuXG5cbmZ1bmN0aW9uIGxlcnAob3V0LCB2MSwgdjIsIHQpIHtcbiAgb3V0WzBdID0gdjFbMF0gKyB0ICogKHYyWzBdIC0gdjFbMF0pO1xuICBvdXRbMV0gPSB2MVsxXSArIHQgKiAodjJbMV0gLSB2MVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOefqemYteW3puS5mOWQkemHj1xuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHBhcmFtIHtWZWN0b3IyfSBtXG4gKi9cblxuXG5mdW5jdGlvbiBhcHBseVRyYW5zZm9ybShvdXQsIHYsIG0pIHtcbiAgdmFyIHggPSB2WzBdO1xuICB2YXIgeSA9IHZbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5rGC5Lik5Liq5ZCR6YeP5pyA5bCP5YC8XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gbWluKG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IE1hdGgubWluKHYxWzBdLCB2MlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKHYxWzFdLCB2MlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaxguS4pOS4quWQkemHj+acgOWkp+WAvFxuICogQHBhcmFtICB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtICB7VmVjdG9yMn0gdjJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1heChvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSBNYXRoLm1heCh2MVswXSwgdjJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heCh2MVsxXSwgdjJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuXG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5zY2FsZUFuZEFkZCA9IHNjYWxlQW5kQWRkO1xuZXhwb3J0cy5zdWIgPSBzdWI7XG5leHBvcnRzLmxlbiA9IGxlbjtcbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoO1xuZXhwb3J0cy5sZW5TcXVhcmUgPSBsZW5TcXVhcmU7XG5leHBvcnRzLmxlbmd0aFNxdWFyZSA9IGxlbmd0aFNxdWFyZTtcbmV4cG9ydHMubXVsID0gbXVsO1xuZXhwb3J0cy5kaXYgPSBkaXY7XG5leHBvcnRzLmRvdCA9IGRvdDtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuZXhwb3J0cy5kaXN0ID0gZGlzdDtcbmV4cG9ydHMuZGlzdGFuY2VTcXVhcmUgPSBkaXN0YW5jZVNxdWFyZTtcbmV4cG9ydHMuZGlzdFNxdWFyZSA9IGRpc3RTcXVhcmU7XG5leHBvcnRzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbmV4cG9ydHMubGVycCA9IGxlcnA7XG5leHBvcnRzLmFwcGx5VHJhbnNmb3JtID0gYXBwbHlUcmFuc2Zvcm07XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMubWF4ID0gbWF4O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL3ZlY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEFuaW1hdG9yID0gcmVxdWlyZShcIi4uL2FuaW1hdGlvbi9BbmltYXRvclwiKTtcblxudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9jb3JlL2xvZ1wiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIGlzU3RyaW5nID0gX3V0aWwuaXNTdHJpbmc7XG52YXIgaXNGdW5jdGlvbiA9IF91dGlsLmlzRnVuY3Rpb247XG52YXIgaXNPYmplY3QgPSBfdXRpbC5pc09iamVjdDtcbnZhciBpc0FycmF5TGlrZSA9IF91dGlsLmlzQXJyYXlMaWtlO1xudmFyIGluZGV4T2YgPSBfdXRpbC5pbmRleE9mO1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1ZTp6cmVuZGVyL21peGluL0FuaW1hdGFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQW5pbWF0YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yPn1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICB0aGlzLmFuaW1hdG9ycyA9IFtdO1xufTtcblxuQW5pbWF0YWJsZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBBbmltYXRhYmxlLFxuXG4gIC8qKlxuICAgKiDliqjnlLtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gZmV0Y2ggdmFsdWUgZnJvbSBvYmplY3QsIGxpa2UgJ2EuYi5jJy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbbG9vcF0gV2hldGhlciB0byBsb29wIGFuaW1hdGlvbi5cbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKiBAZXhhbXBsZTpcbiAgICogICAgIGVsLmFuaW1hdGUoJ3N0eWxlJywgZmFsc2UpXG4gICAqICAgICAgICAgLndoZW4oMTAwMCwge3g6IDEwfSApXG4gICAqICAgICAgICAgLmRvbmUoZnVuY3Rpb24oKXsgLy8gQW5pbWF0aW9uIGRvbmUgfSlcbiAgICogICAgICAgICAuc3RhcnQoKVxuICAgKi9cbiAgYW5pbWF0ZTogZnVuY3Rpb24gKHBhdGgsIGxvb3ApIHtcbiAgICB2YXIgdGFyZ2V0O1xuICAgIHZhciBhbmltYXRpbmdTaGFwZSA9IGZhbHNlO1xuICAgIHZhciBlbCA9IHRoaXM7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHZhciBwYXRoU3BsaXR0ZWQgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgcHJvcCA9IGVsOyAvLyBJZiBhbmltYXRpbmcgc2hhcGVcblxuICAgICAgYW5pbWF0aW5nU2hhcGUgPSBwYXRoU3BsaXR0ZWRbMF0gPT09ICdzaGFwZSc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aFNwbGl0dGVkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3AgPSBwcm9wW3BhdGhTcGxpdHRlZFtpXV07XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgIHRhcmdldCA9IHByb3A7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldCA9IGVsO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICBsb2coJ1Byb3BlcnR5IFwiJyArIHBhdGggKyAnXCIgaXMgbm90IGV4aXN0ZWQgaW4gZWxlbWVudCAnICsgZWwuaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmltYXRvcnMgPSBlbC5hbmltYXRvcnM7XG4gICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKHRhcmdldCwgbG9vcCk7XG4gICAgYW5pbWF0b3IuZHVyaW5nKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGVsLmRpcnR5KGFuaW1hdGluZ1NoYXBlKTtcbiAgICB9KS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEZJWE1FIEFuaW1hdG9yIHdpbGwgbm90IGJlIHJlbW92ZWQgaWYgdXNlIGBBbmltYXRvciNzdG9wYCB0byBzdG9wIGFuaW1hdGlvblxuICAgICAgYW5pbWF0b3JzLnNwbGljZShpbmRleE9mKGFuaW1hdG9ycywgYW5pbWF0b3IpLCAxKTtcbiAgICB9KTtcbiAgICBhbmltYXRvcnMucHVzaChhbmltYXRvcik7IC8vIElmIGFuaW1hdGUgYWZ0ZXIgYWRkZWQgdG8gdGhlIHpyZW5kZXJcblxuICAgIGlmICh6cikge1xuICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0b3I7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWBnOatouWKqOeUu1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmRUb0xhc3QgSWYgbW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAqL1xuICBzdG9wQW5pbWF0aW9uOiBmdW5jdGlvbiAoZm9yd2FyZFRvTGFzdCkge1xuICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICB2YXIgbGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFuaW1hdG9yc1tpXS5zdG9wKGZvcndhcmRUb0xhc3QpO1xuICAgIH1cblxuICAgIGFuaW1hdG9ycy5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYXV0aW9uOiB0aGlzIG1ldGhvZCB3aWxsIHN0b3AgcHJldmlvdXMgYW5pbWF0aW9uLlxuICAgKiBTbyBkbyBub3QgdXNlIHRoaXMgbWV0aG9kIHRvIG9uZSBlbGVtZW50IHR3aWNlIGJlZm9yZVxuICAgKiBhbmltYXRpb24gc3RhcnRzLCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT01MDBdIFRpbWUgaW4gbXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtlYXNpbmc9J2xpbmVhciddXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm9yY2VBbmltYXRlXSBQcmV2ZW50IHN0b3AgYW5pbWF0aW9uIGFuZCBjYWxsYmFja1xuICAgKiAgICAgICAgaW1tZWRpZW50bHkgd2hlbiB0YXJnZXQgdmFsdWVzIGFyZSB0aGUgc2FtZSBhcyBjdXJyZW50IHZhbHVlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIC8vIEFuaW1hdGUgcG9zaXRpb25cbiAgICogIGVsLmFuaW1hdGVUbyh7XG4gICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAqICB9LCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICpcbiAgICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtcywgd2l0aCBjdWJpY091dCBlYXNpbmdcbiAgICogIGVsLmFuaW1hdGVUbyh7XG4gICAqICAgICAgc2hhcGU6IHtcbiAgICogICAgICAgICAgd2lkdGg6IDUwMFxuICAgKiAgICAgIH0sXG4gICAqICAgICAgc3R5bGU6IHtcbiAgICogICAgICAgICAgZmlsbDogJ3JlZCdcbiAgICogICAgICB9XG4gICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAqICB9LCAxMDAsIDEwMCwgJ2N1YmljT3V0JywgZnVuY3Rpb24gKCkgeyAvLyBkb25lIH0pXG4gICAqL1xuICAvLyBUT0RPIFJldHVybiBhbmltYXRpb24ga2V5XG4gIGFuaW1hdGVUbzogZnVuY3Rpb24gKHRhcmdldCwgdGltZSwgZGVsYXksIGVhc2luZywgY2FsbGJhY2ssIGZvcmNlQW5pbWF0ZSkge1xuICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGVhc2luZywgY2FsbGJhY2spO1xuICAgIGlmIChpc1N0cmluZyhkZWxheSkpIHtcbiAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgZWFzaW5nID0gZGVsYXk7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfSAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBkZWxheSwgY2FsbGJhY2spO1xuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZWFzaW5nKSkge1xuICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgZWFzaW5nID0gJ2xpbmVhcic7XG4gICAgICAgIGRlbGF5ID0gMDtcbiAgICAgIH0gLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgY2FsbGJhY2spO1xuICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihkZWxheSkpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IGRlbGF5O1xuICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgfSAvLyBhbmltYXRlVG8odGFyZ2V0LCBjYWxsYmFjaylcbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aW1lKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB0aW1lO1xuICAgICAgICAgICAgdGltZSA9IDUwMDtcbiAgICAgICAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQpXG4gICAgICAgICAgZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgICAgdGltZSA9IDUwMDtcbiAgICAgICAgICAgIH0gLy8gU3RvcCBhbGwgcHJldmlvdXMgYW5pbWF0aW9uc1xuXG5cbiAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcblxuICAgIHRoaXMuX2FuaW1hdGVUb1NoYWxsb3coJycsIHRoaXMsIHRhcmdldCwgdGltZSwgZGVsYXkpOyAvLyBBbmltYXRvcnMgbWF5IGJlIHJlbW92ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgc3RhcnRcbiAgICAvLyBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIGFuaW1hdGVcblxuXG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzLnNsaWNlKCk7XG4gICAgdmFyIGNvdW50ID0gYW5pbWF0b3JzLmxlbmd0aDtcblxuICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICBjb3VudC0tO1xuXG4gICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSAvLyBObyBhbmltYXRvcnMuIFRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgYmVmb3JlIGFuaW1hdG9yc1tpXS5zdGFydCgpLFxuICAgIC8vIGJlY2F1c2UgJ2RvbmUnIG1heSBiZSBleGVjdXRlZCBpbW1lZGlhdGVseSBpZiBubyBuZWVkIHRvIGFuaW1hdGUuXG5cblxuICAgIGlmICghY291bnQpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfSAvLyBTdGFydCBhZnRlciBhbGwgYW5pbWF0b3JzIGNyZWF0ZWRcbiAgICAvLyBJbmNhc2UgYW55IGFuaW1hdG9yIGlzIGRvbmUgaW1tZWRpYXRlbHkgd2hlbiBhbGwgYW5pbWF0aW9uIHByb3BlcnRpZXMgYXJlIG5vdCBjaGFuZ2VkXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhbmltYXRvcnNbaV0uZG9uZShkb25lKS5zdGFydChlYXNpbmcsIGZvcmNlQW5pbWF0ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aD0nJ1xuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlPXRoaXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBBbmltYXRlIHBvc2l0aW9uXG4gICAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAqICB9KVxuICAgKlxuICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zXG4gICAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gICAqICAgICAgc2hhcGU6IHtcbiAgICogICAgICAgICAgd2lkdGg6IDUwMFxuICAgKiAgICAgIH0sXG4gICAqICAgICAgc3R5bGU6IHtcbiAgICogICAgICAgICAgZmlsbDogJ3JlZCdcbiAgICogICAgICB9XG4gICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAqICB9LCAxMDAsIDEwMClcbiAgICovXG4gIF9hbmltYXRlVG9TaGFsbG93OiBmdW5jdGlvbiAocGF0aCwgc291cmNlLCB0YXJnZXQsIHRpbWUsIGRlbGF5KSB7XG4gICAgdmFyIG9ialNoYWxsb3cgPSB7fTtcbiAgICB2YXIgcHJvcGVydHlDb3VudCA9IDA7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHRhcmdldCkge1xuICAgICAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VyY2VbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNPYmplY3QodGFyZ2V0W25hbWVdKSAmJiAhaXNBcnJheUxpa2UodGFyZ2V0W25hbWVdKSkge1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGVUb1NoYWxsb3cocGF0aCA/IHBhdGggKyAnLicgKyBuYW1lIDogbmFtZSwgc291cmNlW25hbWVdLCB0YXJnZXRbbmFtZV0sIHRpbWUsIGRlbGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpTaGFsbG93W25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgIHByb3BlcnR5Q291bnQrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXRbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAvLyBBdHRyIGRpcmVjdGx5IGlmIG5vdCBoYXMgcHJvcGVydHlcbiAgICAgICAgLy8gRklYTUUsIGlmIHNvbWUgcHJvcGVydHkgbm90IG5lZWRlZCBmb3IgZWxlbWVudCA/XG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgIHRoaXMuYXR0cihuYW1lLCB0YXJnZXRbbmFtZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNoYXBlIG9yIHN0eWxlXG4gICAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgICAgcHJvcHNbcGF0aF0gPSB7fTtcbiAgICAgICAgICBwcm9wc1twYXRoXVtuYW1lXSA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICB0aGlzLmF0dHIocHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5Q291bnQgPiAwKSB7XG4gICAgICB0aGlzLmFuaW1hdGUocGF0aCwgZmFsc2UpLndoZW4odGltZSA9PSBudWxsID8gNTAwIDogdGltZSwgb2JqU2hhbGxvdykuZGVsYXkoZGVsYXkgfHwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBBbmltYXRhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvbWl4aW4vQW5pbWF0YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIENsaXAgPSByZXF1aXJlKFwiLi9DbGlwXCIpO1xuXG52YXIgY29sb3IgPSByZXF1aXJlKFwiLi4vdG9vbC9jb2xvclwiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIGlzQXJyYXlMaWtlID0gX3V0aWwuaXNBcnJheUxpa2U7XG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2FuaW1hdGlvbi9BbmltYXRvclxuICovXG52YXIgYXJyYXlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gZGVmYXVsdEdldHRlcih0YXJnZXQsIGtleSkge1xuICByZXR1cm4gdGFyZ2V0W2tleV07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXR0ZXIodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gIHRhcmdldFtrZXldID0gdmFsdWU7XG59XG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVOdW1iZXIocDAsIHAxLCBwZXJjZW50KSB7XG4gIHJldHVybiAocDEgLSBwMCkgKiBwZXJjZW50ICsgcDA7XG59XG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30gcDBcbiAqIEBwYXJhbSAge3N0cmluZ30gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVTdHJpbmcocDAsIHAxLCBwZXJjZW50KSB7XG4gIHJldHVybiBwZXJjZW50ID4gMC41ID8gcDEgOiBwMDtcbn1cbi8qKlxuICogQHBhcmFtICB7QXJyYXl9IHAwXG4gKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAqL1xuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwZXJjZW50LCBvdXQsIGFyckRpbSkge1xuICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuXG4gIGlmIChhcnJEaW0gPT0gMSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG91dFtpXSA9IGludGVycG9sYXRlTnVtYmVyKHAwW2ldLCBwMVtpXSwgcGVyY2VudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsZW4yID0gbGVuICYmIHAwWzBdLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgIG91dFtpXVtqXSA9IGludGVycG9sYXRlTnVtYmVyKHAwW2ldW2pdLCBwMVtpXVtqXSwgcGVyY2VudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59IC8vIGFycjAgaXMgc291cmNlIGFycmF5LCBhcnIxIGlzIHRhcmdldCBhcnJheS5cbi8vIERvIHNvbWUgcHJlcHJvY2VzcyB0byBhdm9pZCBlcnJvciBoYXBwZW5lZCB3aGVuIGludGVycG9sYXRpbmcgZnJvbSBhcnIwIHRvIGFycjFcblxuXG5mdW5jdGlvbiBmaWxsQXJyKGFycjAsIGFycjEsIGFyckRpbSkge1xuICB2YXIgYXJyMExlbiA9IGFycjAubGVuZ3RoO1xuICB2YXIgYXJyMUxlbiA9IGFycjEubGVuZ3RoO1xuXG4gIGlmIChhcnIwTGVuICE9PSBhcnIxTGVuKSB7XG4gICAgLy8gRklYTUUgTm90IHdvcmsgZm9yIFR5cGVkQXJyYXlcbiAgICB2YXIgaXNQcmV2aW91c0xhcmdlciA9IGFycjBMZW4gPiBhcnIxTGVuO1xuXG4gICAgaWYgKGlzUHJldmlvdXNMYXJnZXIpIHtcbiAgICAgIC8vIEN1dCB0aGUgcHJldmlvdXNcbiAgICAgIGFycjAubGVuZ3RoID0gYXJyMUxlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmlsbCB0aGUgcHJldmlvdXNcbiAgICAgIGZvciAodmFyIGkgPSBhcnIwTGVuOyBpIDwgYXJyMUxlbjsgaSsrKSB7XG4gICAgICAgIGFycjAucHVzaChhcnJEaW0gPT09IDEgPyBhcnIxW2ldIDogYXJyYXlTbGljZS5jYWxsKGFycjFbaV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gSGFuZGxpbmcgTmFOIHZhbHVlXG5cblxuICB2YXIgbGVuMiA9IGFycjBbMF0gJiYgYXJyMFswXS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIwLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFyckRpbSA9PT0gMSkge1xuICAgICAgaWYgKGlzTmFOKGFycjBbaV0pKSB7XG4gICAgICAgIGFycjBbaV0gPSBhcnIxW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICBpZiAoaXNOYU4oYXJyMFtpXVtqXSkpIHtcbiAgICAgICAgICBhcnIwW2ldW2pdID0gYXJyMVtpXVtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyMFxuICogQHBhcmFtICB7QXJyYXl9IGFycjFcbiAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNBcnJheVNhbWUoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gIGlmIChhcnIwID09PSBhcnIxKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbGVuID0gYXJyMC5sZW5ndGg7XG5cbiAgaWYgKGxlbiAhPT0gYXJyMS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGFycjBbaV0gIT09IGFycjFbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuMiA9IGFycjBbMF0ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgaWYgKGFycjBbaV1bal0gIT09IGFycjFbaV1bal0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQ2F0bXVsbCBSb20gaW50ZXJwb2xhdGUgYXJyYXlcbiAqIEBwYXJhbSAge0FycmF5fSBwMFxuICogQHBhcmFtICB7QXJyYXl9IHAxXG4gKiBAcGFyYW0gIHtBcnJheX0gcDJcbiAqIEBwYXJhbSAge0FycmF5fSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHQyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHQzXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICovXG5cblxuZnVuY3Rpb24gY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mywgb3V0LCBhcnJEaW0pIHtcbiAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcblxuICBpZiAoYXJyRGltID09IDEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvdXRbaV0gPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQsIHQyLCB0Myk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsZW4yID0gcDBbMF0ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgb3V0W2ldW2pdID0gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwW2ldW2pdLCBwMVtpXVtqXSwgcDJbaV1bal0sIHAzW2ldW2pdLCB0LCB0MiwgdDMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBudW1iZXJcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICogQHBhcmFtICB7bnVtYmVyfSB0M1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gIHJldHVybiAoMiAqIChwMSAtIHAyKSArIHYwICsgdjEpICogdDMgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MiArIHYwICogdCArIHAxO1xufVxuXG5mdW5jdGlvbiBjbG9uZVZhbHVlKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlWzBdKSkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJldC5wdXNoKGFycmF5U2xpY2UuY2FsbCh2YWx1ZVtpXSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheVNsaWNlLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiByZ2JhMlN0cmluZyhyZ2JhKSB7XG4gIHJnYmFbMF0gPSBNYXRoLmZsb29yKHJnYmFbMF0pO1xuICByZ2JhWzFdID0gTWF0aC5mbG9vcihyZ2JhWzFdKTtcbiAgcmdiYVsyXSA9IE1hdGguZmxvb3IocmdiYVsyXSk7XG4gIHJldHVybiAncmdiYSgnICsgcmdiYS5qb2luKCcsJykgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5RGltKGtleWZyYW1lcykge1xuICB2YXIgbGFzdFZhbHVlID0ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKGxhc3RWYWx1ZSAmJiBsYXN0VmFsdWVbMF0pID8gMiA6IDE7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYWNrQ2xpcChhbmltYXRvciwgZWFzaW5nLCBvbmVUcmFja0RvbmUsIGtleWZyYW1lcywgcHJvcE5hbWUsIGZvcmNlQW5pbWF0ZSkge1xuICB2YXIgZ2V0dGVyID0gYW5pbWF0b3IuX2dldHRlcjtcbiAgdmFyIHNldHRlciA9IGFuaW1hdG9yLl9zZXR0ZXI7XG4gIHZhciB1c2VTcGxpbmUgPSBlYXNpbmcgPT09ICdzcGxpbmUnO1xuICB2YXIgdHJhY2tMZW4gPSBrZXlmcmFtZXMubGVuZ3RoO1xuXG4gIGlmICghdHJhY2tMZW4pIHtcbiAgICByZXR1cm47XG4gIH0gLy8gR3Vlc3MgZGF0YSB0eXBlXG5cblxuICB2YXIgZmlyc3RWYWwgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gIHZhciBpc1ZhbHVlQXJyYXkgPSBpc0FycmF5TGlrZShmaXJzdFZhbCk7XG4gIHZhciBpc1ZhbHVlQ29sb3IgPSBmYWxzZTtcbiAgdmFyIGlzVmFsdWVTdHJpbmcgPSBmYWxzZTsgLy8gRm9yIHZlcnRpY2VzIG1vcnBoaW5nXG5cbiAgdmFyIGFyckRpbSA9IGlzVmFsdWVBcnJheSA/IGdldEFycmF5RGltKGtleWZyYW1lcykgOiAwO1xuICB2YXIgdHJhY2tNYXhUaW1lOyAvLyBTb3J0IGtleWZyYW1lIGFzIGFzY2VuZGluZ1xuXG4gIGtleWZyYW1lcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEudGltZSAtIGIudGltZTtcbiAgfSk7XG4gIHRyYWNrTWF4VGltZSA9IGtleWZyYW1lc1t0cmFja0xlbiAtIDFdLnRpbWU7IC8vIFBlcmNlbnRzIG9mIGVhY2gga2V5ZnJhbWVcblxuICB2YXIga2ZQZXJjZW50cyA9IFtdOyAvLyBWYWx1ZSBvZiBlYWNoIGtleWZyYW1lXG5cbiAgdmFyIGtmVmFsdWVzID0gW107XG4gIHZhciBwcmV2VmFsdWUgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gIHZhciBpc0FsbFZhbHVlRXF1YWwgPSB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW47IGkrKykge1xuICAgIGtmUGVyY2VudHMucHVzaChrZXlmcmFtZXNbaV0udGltZSAvIHRyYWNrTWF4VGltZSk7IC8vIEFzc3VtZSB2YWx1ZSBpcyBhIGNvbG9yIHdoZW4gaXQgaXMgYSBzdHJpbmdcblxuICAgIHZhciB2YWx1ZSA9IGtleWZyYW1lc1tpXS52YWx1ZTsgLy8gQ2hlY2sgaWYgdmFsdWUgaXMgZXF1YWwsIGRlZXAgY2hlY2sgaWYgdmFsdWUgaXMgYXJyYXlcblxuICAgIGlmICghKGlzVmFsdWVBcnJheSAmJiBpc0FycmF5U2FtZSh2YWx1ZSwgcHJldlZhbHVlLCBhcnJEaW0pIHx8ICFpc1ZhbHVlQXJyYXkgJiYgdmFsdWUgPT09IHByZXZWYWx1ZSkpIHtcbiAgICAgIGlzQWxsVmFsdWVFcXVhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHByZXZWYWx1ZSA9IHZhbHVlOyAvLyBUcnkgY29udmVydGluZyBhIHN0cmluZyB0byBhIGNvbG9yIGFycmF5XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgY29sb3JBcnJheSA9IGNvbG9yLnBhcnNlKHZhbHVlKTtcblxuICAgICAgaWYgKGNvbG9yQXJyYXkpIHtcbiAgICAgICAgdmFsdWUgPSBjb2xvckFycmF5O1xuICAgICAgICBpc1ZhbHVlQ29sb3IgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNWYWx1ZVN0cmluZyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAga2ZWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIWZvcmNlQW5pbWF0ZSAmJiBpc0FsbFZhbHVlRXF1YWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbGFzdFZhbHVlID0ga2ZWYWx1ZXNbdHJhY2tMZW4gLSAxXTsgLy8gUG9seWZpbGwgYXJyYXkgYW5kIE5hTiB2YWx1ZVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW4gLSAxOyBpKyspIHtcbiAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICBmaWxsQXJyKGtmVmFsdWVzW2ldLCBsYXN0VmFsdWUsIGFyckRpbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc05hTihrZlZhbHVlc1tpXSkgJiYgIWlzTmFOKGxhc3RWYWx1ZSkgJiYgIWlzVmFsdWVTdHJpbmcgJiYgIWlzVmFsdWVDb2xvcikge1xuICAgICAgICBrZlZhbHVlc1tpXSA9IGxhc3RWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc1ZhbHVlQXJyYXkgJiYgZmlsbEFycihnZXR0ZXIoYW5pbWF0b3IuX3RhcmdldCwgcHJvcE5hbWUpLCBsYXN0VmFsdWUsIGFyckRpbSk7IC8vIENhY2hlIHRoZSBrZXkgb2YgbGFzdCBmcmFtZSB0byBzcGVlZCB1cCB3aGVuXG4gIC8vIGFuaW1hdGlvbiBwbGF5YmFjayBpcyBzZXF1ZW5jeVxuXG4gIHZhciBsYXN0RnJhbWUgPSAwO1xuICB2YXIgbGFzdEZyYW1lUGVyY2VudCA9IDA7XG4gIHZhciBzdGFydDtcbiAgdmFyIHc7XG4gIHZhciBwMDtcbiAgdmFyIHAxO1xuICB2YXIgcDI7XG4gIHZhciBwMztcblxuICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgdmFyIHJnYmEgPSBbMCwgMCwgMCwgMF07XG4gIH1cblxuICB2YXIgb25mcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAvLyBGaW5kIHRoZSByYW5nZSBrZXlmcmFtZXNcbiAgICAvLyBrZjEtLS0tLWtmMi0tLS0tLS0tLWN1cnJlbnQtLS0tLS0tLWtmM1xuICAgIC8vIGZpbmQga2YyIGFuZCBrZjMgYW5kIGRvIGludGVycG9sYXRpb25cbiAgICB2YXIgZnJhbWU7IC8vIEluIHRoZSBlYXNpbmcgZnVuY3Rpb24gbGlrZSBlbGFzdGljT3V0LCBwZXJjZW50IG1heSBsZXNzIHRoYW4gMFxuXG4gICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICBmcmFtZSA9IDA7XG4gICAgfSBlbHNlIGlmIChwZXJjZW50IDwgbGFzdEZyYW1lUGVyY2VudCkge1xuICAgICAgLy8gU3RhcnQgZnJvbSBuZXh0IGtleVxuICAgICAgLy8gUEVORElORyBzdGFydCBmcm9tIGxhc3RGcmFtZSA/XG4gICAgICBzdGFydCA9IE1hdGgubWluKGxhc3RGcmFtZSArIDEsIHRyYWNrTGVuIC0gMSk7XG5cbiAgICAgIGZvciAoZnJhbWUgPSBzdGFydDsgZnJhbWUgPj0gMDsgZnJhbWUtLSkge1xuICAgICAgICBpZiAoa2ZQZXJjZW50c1tmcmFtZV0gPD0gcGVyY2VudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIFBFTkRJTkcgcmVhbGx5IG5lZWQgdG8gZG8gdGhpcyA/XG5cblxuICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSwgdHJhY2tMZW4gLSAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChmcmFtZSA9IGxhc3RGcmFtZTsgZnJhbWUgPCB0cmFja0xlbjsgZnJhbWUrKykge1xuICAgICAgICBpZiAoa2ZQZXJjZW50c1tmcmFtZV0gPiBwZXJjZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSAtIDEsIHRyYWNrTGVuIC0gMik7XG4gICAgfVxuXG4gICAgbGFzdEZyYW1lID0gZnJhbWU7XG4gICAgbGFzdEZyYW1lUGVyY2VudCA9IHBlcmNlbnQ7XG4gICAgdmFyIHJhbmdlID0ga2ZQZXJjZW50c1tmcmFtZSArIDFdIC0ga2ZQZXJjZW50c1tmcmFtZV07XG5cbiAgICBpZiAocmFuZ2UgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdyA9IChwZXJjZW50IC0ga2ZQZXJjZW50c1tmcmFtZV0pIC8gcmFuZ2U7XG4gICAgfVxuXG4gICAgaWYgKHVzZVNwbGluZSkge1xuICAgICAgcDEgPSBrZlZhbHVlc1tmcmFtZV07XG4gICAgICBwMCA9IGtmVmFsdWVzW2ZyYW1lID09PSAwID8gZnJhbWUgOiBmcmFtZSAtIDFdO1xuICAgICAgcDIgPSBrZlZhbHVlc1tmcmFtZSA+IHRyYWNrTGVuIC0gMiA/IHRyYWNrTGVuIC0gMSA6IGZyYW1lICsgMV07XG4gICAgICBwMyA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAzID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAyXTtcblxuICAgICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgICBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdywgZ2V0dGVyKHRhcmdldCwgcHJvcE5hbWUpLCBhcnJEaW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICB2YWx1ZSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3LCByZ2JhLCAxKTtcbiAgICAgICAgICB2YWx1ZSA9IHJnYmEyU3RyaW5nKHJnYmEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAvLyBTdHJpbmcgaXMgc3RlcCgwLjUpXG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU3RyaW5nKHAxLCBwMiwgdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGVyKHRhcmdldCwgcHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgICBpbnRlcnBvbGF0ZUFycmF5KGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdywgZ2V0dGVyKHRhcmdldCwgcHJvcE5hbWUpLCBhcnJEaW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICBpbnRlcnBvbGF0ZUFycmF5KGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdywgcmdiYSwgMSk7XG4gICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVN0cmluZyhrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gaW50ZXJwb2xhdGVOdW1iZXIoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRlcih0YXJnZXQsIHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBjbGlwID0gbmV3IENsaXAoe1xuICAgIHRhcmdldDogYW5pbWF0b3IuX3RhcmdldCxcbiAgICBsaWZlOiB0cmFja01heFRpbWUsXG4gICAgbG9vcDogYW5pbWF0b3IuX2xvb3AsXG4gICAgZGVsYXk6IGFuaW1hdG9yLl9kZWxheSxcbiAgICBvbmZyYW1lOiBvbmZyYW1lLFxuICAgIG9uZGVzdHJveTogb25lVHJhY2tEb25lXG4gIH0pO1xuXG4gIGlmIChlYXNpbmcgJiYgZWFzaW5nICE9PSAnc3BsaW5lJykge1xuICAgIGNsaXAuZWFzaW5nID0gZWFzaW5nO1xuICB9XG5cbiAgcmV0dXJuIGNsaXA7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3JcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlclxuICovXG5cblxudmFyIEFuaW1hdG9yID0gZnVuY3Rpb24gKHRhcmdldCwgbG9vcCwgZ2V0dGVyLCBzZXR0ZXIpIHtcbiAgdGhpcy5fdHJhY2tzID0ge307XG4gIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgdGhpcy5fbG9vcCA9IGxvb3AgfHwgZmFsc2U7XG4gIHRoaXMuX2dldHRlciA9IGdldHRlciB8fCBkZWZhdWx0R2V0dGVyO1xuICB0aGlzLl9zZXR0ZXIgPSBzZXR0ZXIgfHwgZGVmYXVsdFNldHRlcjtcbiAgdGhpcy5fY2xpcENvdW50ID0gMDtcbiAgdGhpcy5fZGVsYXkgPSAwO1xuICB0aGlzLl9kb25lTGlzdCA9IFtdO1xuICB0aGlzLl9vbmZyYW1lTGlzdCA9IFtdO1xuICB0aGlzLl9jbGlwTGlzdCA9IFtdO1xufTtcblxuQW5pbWF0b3IucHJvdG90eXBlID0ge1xuICAvKipcbiAgICog6K6+572u5Yqo55S75YWz6ZSu5binXG4gICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDlhbPplK7luKfml7bpl7TvvIzljZXkvY3mmK9tc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzIOWFs+mUruW4p+eahOWxnuaAp+WAvO+8jGtleS12YWx1ZeihqOekulxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICB3aGVuOiBmdW5jdGlvbiAodGltZVxuICAvKiBtcyAqL1xuICAsIHByb3BzKSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMuX3RyYWNrcztcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0cmFja3NbcHJvcE5hbWVdKSB7XG4gICAgICAgIHRyYWNrc1twcm9wTmFtZV0gPSBbXTsgLy8gSW52YWxpZCB2YWx1ZVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldHRlcih0aGlzLl90YXJnZXQsIHByb3BOYW1lKTtcblxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHpyTG9nKCdJbnZhbGlkIHByb3BlcnR5ICcgKyBwcm9wTmFtZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gSWYgdGltZSBpcyAwXG4gICAgICAgIC8vICBUaGVuIHByb3BzIGlzIGdpdmVuIGluaXRpYWxpemUgdmFsdWVcbiAgICAgICAgLy8gRWxzZVxuICAgICAgICAvLyAgSW5pdGlhbGl6ZSB2YWx1ZSBmcm9tIGN1cnJlbnQgcHJvcCB2YWx1ZVxuXG5cbiAgICAgICAgaWYgKHRpbWUgIT09IDApIHtcbiAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgIHZhbHVlOiBjbG9uZVZhbHVlKHZhbHVlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyYWNrc1twcm9wTmFtZV0ucHVzaCh7XG4gICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgIHZhbHVlOiBwcm9wc1twcm9wTmFtZV1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDliqjnlLvmr4/kuIDluKfnmoTlm57osIPlh73mlbBcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIGR1cmluZzogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fb25mcmFtZUxpc3QucHVzaChjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9jbGlwTGlzdFtpXS5wYXVzZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gIH0sXG4gIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2NsaXBMaXN0W2ldLnJlc3VtZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICB9LFxuICBpc1BhdXNlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3BhdXNlZDtcbiAgfSxcbiAgX2RvbmVDYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgIC8vIENsZWFyIGFsbCB0cmFja3NcbiAgICB0aGlzLl90cmFja3MgPSB7fTsgLy8gQ2xlYXIgYWxsIGNsaXBzXG5cbiAgICB0aGlzLl9jbGlwTGlzdC5sZW5ndGggPSAwO1xuICAgIHZhciBkb25lTGlzdCA9IHRoaXMuX2RvbmVMaXN0O1xuICAgIHZhciBsZW4gPSBkb25lTGlzdC5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkb25lTGlzdFtpXS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5byA5aeL5omn6KGM5Yqo55S7XG4gICAqIEBwYXJhbSAge3N0cmluZ3xGdW5jdGlvbn0gW2Vhc2luZ11cbiAgICogICAgICAgICDliqjnlLvnvJPliqjlh73mlbDvvIzor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ31cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZm9yY2VBbmltYXRlXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIHN0YXJ0OiBmdW5jdGlvbiAoZWFzaW5nLCBmb3JjZUFuaW1hdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNsaXBDb3VudCA9IDA7XG5cbiAgICB2YXIgb25lVHJhY2tEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2xpcENvdW50LS07XG5cbiAgICAgIGlmICghY2xpcENvdW50KSB7XG4gICAgICAgIHNlbGYuX2RvbmVDYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbGFzdENsaXA7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0aGlzLl90cmFja3MpIHtcbiAgICAgIGlmICghdGhpcy5fdHJhY2tzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsaXAgPSBjcmVhdGVUcmFja0NsaXAodGhpcywgZWFzaW5nLCBvbmVUcmFja0RvbmUsIHRoaXMuX3RyYWNrc1twcm9wTmFtZV0sIHByb3BOYW1lLCBmb3JjZUFuaW1hdGUpO1xuXG4gICAgICBpZiAoY2xpcCkge1xuICAgICAgICB0aGlzLl9jbGlwTGlzdC5wdXNoKGNsaXApO1xuXG4gICAgICAgIGNsaXBDb3VudCsrOyAvLyBJZiBzdGFydCBhZnRlciBhZGRlZCB0byBhbmltYXRpb25cblxuICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGRDbGlwKGNsaXApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdENsaXAgPSBjbGlwO1xuICAgICAgfVxuICAgIH0gLy8gQWRkIGR1cmluZyBjYWxsYmFjayBvbiB0aGUgbGFzdCBjbGlwXG5cblxuICAgIGlmIChsYXN0Q2xpcCkge1xuICAgICAgdmFyIG9sZE9uRnJhbWUgPSBsYXN0Q2xpcC5vbmZyYW1lO1xuXG4gICAgICBsYXN0Q2xpcC5vbmZyYW1lID0gZnVuY3Rpb24gKHRhcmdldCwgcGVyY2VudCkge1xuICAgICAgICBvbGRPbkZyYW1lKHRhcmdldCwgcGVyY2VudCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl9vbmZyYW1lTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNlbGYuX29uZnJhbWVMaXN0W2ldKHRhcmdldCwgcGVyY2VudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSAvLyBUaGlzIG9wdGltaXphdGlvbiB3aWxsIGhlbHAgdGhlIGNhc2UgdGhhdCBpbiB0aGUgdXBwZXIgYXBwbGljYXRpb25cbiAgICAvLyB0aGUgdmlldyBtYXkgYmUgcmVmcmVzaGVkIGZyZXF1ZW50bHksIHdoZXJlIGFuaW1hdGlvbiB3aWxsIGJlXG4gICAgLy8gY2FsbGVkIHJlcGVhdGx5IGJ1dCBub3RoaW5nIGNoYW5nZWQuXG5cblxuICAgIGlmICghY2xpcENvdW50KSB7XG4gICAgICB0aGlzLl9kb25lQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5YGc5q2i5Yqo55S7XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZFRvTGFzdCBJZiBtb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICovXG4gIHN0b3A6IGZ1bmN0aW9uIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgdmFyIGNsaXBMaXN0ID0gdGhpcy5fY2xpcExpc3Q7XG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNsaXAgPSBjbGlwTGlzdFtpXTtcblxuICAgICAgaWYgKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgLy8gTW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICAgIGNsaXAub25mcmFtZSh0aGlzLl90YXJnZXQsIDEpO1xuICAgICAgfVxuXG4gICAgICBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnJlbW92ZUNsaXAoY2xpcCk7XG4gICAgfVxuXG4gICAgY2xpcExpc3QubGVuZ3RoID0gMDtcbiAgfSxcblxuICAvKipcbiAgICog6K6+572u5Yqo55S75bu26L+f5byA5aeL55qE5pe26Ze0XG4gICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDljZXkvY1tc1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICBkZWxheTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICB0aGlzLl9kZWxheSA9IHRpbWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWKqOeUu+e7k+adn+eahOWbnuiwg1xuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgZG9uZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0aGlzLl9kb25lTGlzdC5wdXNoKGNiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwPn1cbiAgICovXG4gIGdldENsaXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaXBMaXN0O1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQW5pbWF0b3I7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBlYXNpbmdGdW5jcyA9IHJlcXVpcmUoXCIuL2Vhc2luZ1wiKTtcblxuLyoqXG4gKiDliqjnlLvkuLvmjqfliLblmahcbiAqIEBjb25maWcgdGFyZ2V0IOWKqOeUu+Wvueixoe+8jOWPr+S7peaYr+aVsOe7hO+8jOWmguaenOaYr+aVsOe7hOeahOivneS8muaJuemHj+WIhuWPkW9uZnJhbWXnrYnkuovku7ZcbiAqIEBjb25maWcgbGlmZSgxMDAwKSDliqjnlLvml7bplb9cbiAqIEBjb25maWcgZGVsYXkoMCkg5Yqo55S75bu26L+f5pe26Ze0XG4gKiBAY29uZmlnIGxvb3AodHJ1ZSlcbiAqIEBjb25maWcgZ2FwKDApIOW+queOr+eahOmXtOmalOaXtumXtFxuICogQGNvbmZpZyBvbmZyYW1lXG4gKiBAY29uZmlnIGVhc2luZyhvcHRpb25hbClcbiAqIEBjb25maWcgb25kZXN0cm95KG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbnJlc3RhcnQob3B0aW9uYWwpXG4gKlxuICogVE9ETyBwYXVzZVxuICovXG5mdW5jdGlvbiBDbGlwKG9wdGlvbnMpIHtcbiAgdGhpcy5fdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7IC8vIOeUn+WRveWRqOacn1xuXG4gIHRoaXMuX2xpZmUgPSBvcHRpb25zLmxpZmUgfHwgMTAwMDsgLy8g5bu25pe2XG5cbiAgdGhpcy5fZGVsYXkgPSBvcHRpb25zLmRlbGF5IHx8IDA7IC8vIOW8gOWni+aXtumXtFxuICAvLyB0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHRoaXMuX2RlbGF5Oy8vIOWNleS9jeavq+enklxuXG4gIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7IC8vIOaYr+WQpuW+queOr1xuXG4gIHRoaXMubG9vcCA9IG9wdGlvbnMubG9vcCA9PSBudWxsID8gZmFsc2UgOiBvcHRpb25zLmxvb3A7XG4gIHRoaXMuZ2FwID0gb3B0aW9ucy5nYXAgfHwgMDtcbiAgdGhpcy5lYXNpbmcgPSBvcHRpb25zLmVhc2luZyB8fCAnTGluZWFyJztcbiAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lO1xuICB0aGlzLm9uZGVzdHJveSA9IG9wdGlvbnMub25kZXN0cm95O1xuICB0aGlzLm9ucmVzdGFydCA9IG9wdGlvbnMub25yZXN0YXJ0O1xuICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcbiAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG59XG5cbkNsaXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQ2xpcCxcbiAgc3RlcDogZnVuY3Rpb24gKGdsb2JhbFRpbWUsIGRlbHRhVGltZSkge1xuICAgIC8vIFNldCBzdGFydFRpbWUgb24gZmlyc3Qgc3RlcCwgb3IgX3N0YXJ0VGltZSBtYXkgaGFzIG1pbGxlc2Vjb25kcyBkaWZmZXJlbnQgYmV0d2VlbiBjbGlwc1xuICAgIC8vIFBFTkRJTkdcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lICsgdGhpcy5fZGVsYXk7XG4gICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSBkZWx0YVRpbWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBlcmNlbnQgPSAoZ2xvYmFsVGltZSAtIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX3BhdXNlZFRpbWUpIC8gdGhpcy5fbGlmZTsgLy8g6L+Y5rKh5byA5aeLXG5cbiAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwZXJjZW50ID0gTWF0aC5taW4ocGVyY2VudCwgMSk7XG4gICAgdmFyIGVhc2luZyA9IHRoaXMuZWFzaW5nO1xuICAgIHZhciBlYXNpbmdGdW5jID0gdHlwZW9mIGVhc2luZyA9PSAnc3RyaW5nJyA/IGVhc2luZ0Z1bmNzW2Vhc2luZ10gOiBlYXNpbmc7XG4gICAgdmFyIHNjaGVkdWxlID0gdHlwZW9mIGVhc2luZ0Z1bmMgPT09ICdmdW5jdGlvbicgPyBlYXNpbmdGdW5jKHBlcmNlbnQpIDogcGVyY2VudDtcbiAgICB0aGlzLmZpcmUoJ2ZyYW1lJywgc2NoZWR1bGUpOyAvLyDnu5PmnZ9cblxuICAgIGlmIChwZXJjZW50ID09IDEpIHtcbiAgICAgIGlmICh0aGlzLmxvb3ApIHtcbiAgICAgICAgdGhpcy5yZXN0YXJ0KGdsb2JhbFRpbWUpOyAvLyDph43mlrDlvIDlp4vlkajmnJ9cbiAgICAgICAgLy8g5oqb5Ye66ICM5LiN5piv55u05o6l6LCD55So5LqL5Lu255u05YiwIHN0YWdlLnVwZGF0ZSDlkI7lho3nu5/kuIDosIPnlKjov5nkupvkuovku7ZcblxuICAgICAgICByZXR1cm4gJ3Jlc3RhcnQnO1xuICAgICAgfSAvLyDliqjnlLvlrozmiJDlsIbov5nkuKrmjqfliLblmajmoIfor4bkuLrlvoXliKDpmaRcbiAgICAgIC8vIOWcqEFuaW1hdGlvbi51cGRhdGXkuK3ov5vooYzmibnph4/liKDpmaRcblxuXG4gICAgICB0aGlzLl9uZWVkc1JlbW92ZSA9IHRydWU7XG4gICAgICByZXR1cm4gJ2Rlc3Ryb3knO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICByZXN0YXJ0OiBmdW5jdGlvbiAoZ2xvYmFsVGltZSkge1xuICAgIHZhciByZW1haW5kZXIgPSAoZ2xvYmFsVGltZSAtIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX3BhdXNlZFRpbWUpICUgdGhpcy5fbGlmZTtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lIC0gcmVtYWluZGVyICsgdGhpcy5nYXA7XG4gICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG4gICAgdGhpcy5fbmVlZHNSZW1vdmUgPSBmYWxzZTtcbiAgfSxcbiAgZmlyZTogZnVuY3Rpb24gKGV2ZW50VHlwZSwgYXJnKSB7XG4gICAgZXZlbnRUeXBlID0gJ29uJyArIGV2ZW50VHlwZTtcblxuICAgIGlmICh0aGlzW2V2ZW50VHlwZV0pIHtcbiAgICAgIHRoaXNbZXZlbnRUeXBlXSh0aGlzLl90YXJnZXQsIGFyZyk7XG4gICAgfVxuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gIH0sXG4gIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQ2xpcDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9DbGlwLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIOe8k+WKqOS7o+eggeadpeiHqiBodHRwczovL2dpdGh1Yi5jb20vc29sZS90d2Vlbi5qcy9ibG9iL21hc3Rlci9zcmMvVHdlZW4uanNcbiAqIEBzZWUgaHR0cDovL3NvbGUuZ2l0aHViLmlvL3R3ZWVuLmpzL2V4YW1wbGVzLzAzX2dyYXBocy5odG1sXG4gKiBAZXhwb3J0cyB6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmdcbiAqL1xudmFyIGVhc2luZyA9IHtcbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGxpbmVhcjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhZHJhdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFkcmF0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiAoMiAtIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFkcmF0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0wLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuICB9LFxuICAvLyDkuInmrKHmlrnnmoTnvJPliqjvvIh0XjPvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY3ViaWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjdWJpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjdWJpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICsgMik7XG4gIH0sXG4gIC8vIOWbm+asoeaWueeahOe8k+WKqO+8iHReNO+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFydGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiBrICogayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YXJ0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDEgLSAtLWsgKiBrICogayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YXJ0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcbiAgICB9XG5cbiAgICByZXR1cm4gLTAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAtIDIpO1xuICB9LFxuICAvLyDkupTmrKHmlrnnmoTnvJPliqjvvIh0XjXvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVpbnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogayAqIGsgKiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVpbnRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gLS1rICogayAqIGsgKiBrICogayArIDE7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1aW50aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAqIGsgKyAyKTtcbiAgfSxcbiAgLy8g5q2j5bym5puy57q/55qE57yT5Yqo77yIc2luKHQp77yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHNpbnVzb2lkYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMSAtIE1hdGguY29zKGsgKiBNYXRoLlBJIC8gMik7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHNpbnVzb2lkYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIE1hdGguc2luKGsgKiBNYXRoLlBJIC8gMik7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHNpbnVzb2lkYWxJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICB9LFxuICAvLyDmjIfmlbDmm7Lnur/nmoTnvJPliqjvvIgyXnTvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZXhwb25lbnRpYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayA9PT0gMCA/IDAgOiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGV4cG9uZW50aWFsT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZXhwb25lbnRpYWxJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGsgLSAxKSkgKyAyKTtcbiAgfSxcbiAgLy8g5ZyG5b2i5puy57q/55qE57yT5Yqo77yIc3FydCgxLXReMinvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY2lyY3VsYXJJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gayAqIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjaXJjdWxhck91dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLWsgKiBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY2lyY3VsYXJJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoayAtPSAyKSAqIGspICsgMSk7XG4gIH0sXG4gIC8vIOWIm+W7uuexu+S8vOS6juW8ueewp+WcqOWBnOatouWJjeadpeWbnuaMr+iNoeeahOWKqOeUu1xuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBlbGFzdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGEgPSAwLjE7XG4gICAgdmFyIHAgPSAwLjQ7XG5cbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgYSA9IDE7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0oYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGVsYXN0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGEgPSAwLjE7XG4gICAgdmFyIHAgPSAwLjQ7XG5cbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgYSA9IDE7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiBrKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBlbGFzdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGEgPSAwLjE7XG4gICAgdmFyIHAgPSAwLjQ7XG5cbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgYSA9IDE7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICogMC41ICsgMTtcbiAgfSxcbiAgLy8g5Zyo5p+Q5LiA5Yqo55S75byA5aeL5rK/5oyH56S655qE6Lev5b6E6L+b6KGM5Yqo55S75aSE55CG5YmN56iN56iN5pS25Zue6K+l5Yqo55S755qE56e75YqoXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJhY2tJbjogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJhY2tPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBiYWNrSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG5cbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAyKTtcbiAgfSxcbiAgLy8g5Yib5bu65by56Lez5pWI5p6cXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJvdW5jZUluOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAxIC0gZWFzaW5nLmJvdW5jZU91dCgxIC0gayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJvdW5jZU91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoayA8IDEgLyAyLjc1KSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogayAqIGs7XG4gICAgfSBlbHNlIGlmIChrIDwgMiAvIDIuNzUpIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAxLjUgLyAyLjc1KSAqIGsgKyAwLjc1O1xuICAgIH0gZWxzZSBpZiAoayA8IDIuNSAvIDIuNzUpIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAyLjI1IC8gMi43NSkgKiBrICsgMC45Mzc1O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gMi42MjUgLyAyLjc1KSAqIGsgKyAwLjk4NDM3NTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJvdW5jZUluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmIChrIDwgMC41KSB7XG4gICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZUluKGsgKiAyKSAqIDAuNTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWFzaW5nLmJvdW5jZU91dChrICogMiAtIDEpICogMC41ICsgMC41O1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gZWFzaW5nO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvYW5pbWF0aW9uL2Vhc2luZy5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExSVSA9IHJlcXVpcmUoXCIuLi9jb3JlL0xSVVwiKTtcblxudmFyIGtDU1NDb2xvclRhYmxlID0ge1xuICAndHJhbnNwYXJlbnQnOiBbMCwgMCwgMCwgMF0sXG4gICdhbGljZWJsdWUnOiBbMjQwLCAyNDgsIDI1NSwgMV0sXG4gICdhbnRpcXVld2hpdGUnOiBbMjUwLCAyMzUsIDIxNSwgMV0sXG4gICdhcXVhJzogWzAsIDI1NSwgMjU1LCAxXSxcbiAgJ2FxdWFtYXJpbmUnOiBbMTI3LCAyNTUsIDIxMiwgMV0sXG4gICdhenVyZSc6IFsyNDAsIDI1NSwgMjU1LCAxXSxcbiAgJ2JlaWdlJzogWzI0NSwgMjQ1LCAyMjAsIDFdLFxuICAnYmlzcXVlJzogWzI1NSwgMjI4LCAxOTYsIDFdLFxuICAnYmxhY2snOiBbMCwgMCwgMCwgMV0sXG4gICdibGFuY2hlZGFsbW9uZCc6IFsyNTUsIDIzNSwgMjA1LCAxXSxcbiAgJ2JsdWUnOiBbMCwgMCwgMjU1LCAxXSxcbiAgJ2JsdWV2aW9sZXQnOiBbMTM4LCA0MywgMjI2LCAxXSxcbiAgJ2Jyb3duJzogWzE2NSwgNDIsIDQyLCAxXSxcbiAgJ2J1cmx5d29vZCc6IFsyMjIsIDE4NCwgMTM1LCAxXSxcbiAgJ2NhZGV0Ymx1ZSc6IFs5NSwgMTU4LCAxNjAsIDFdLFxuICAnY2hhcnRyZXVzZSc6IFsxMjcsIDI1NSwgMCwgMV0sXG4gICdjaG9jb2xhdGUnOiBbMjEwLCAxMDUsIDMwLCAxXSxcbiAgJ2NvcmFsJzogWzI1NSwgMTI3LCA4MCwgMV0sXG4gICdjb3JuZmxvd2VyYmx1ZSc6IFsxMDAsIDE0OSwgMjM3LCAxXSxcbiAgJ2Nvcm5zaWxrJzogWzI1NSwgMjQ4LCAyMjAsIDFdLFxuICAnY3JpbXNvbic6IFsyMjAsIDIwLCA2MCwgMV0sXG4gICdjeWFuJzogWzAsIDI1NSwgMjU1LCAxXSxcbiAgJ2RhcmtibHVlJzogWzAsIDAsIDEzOSwgMV0sXG4gICdkYXJrY3lhbic6IFswLCAxMzksIDEzOSwgMV0sXG4gICdkYXJrZ29sZGVucm9kJzogWzE4NCwgMTM0LCAxMSwgMV0sXG4gICdkYXJrZ3JheSc6IFsxNjksIDE2OSwgMTY5LCAxXSxcbiAgJ2RhcmtncmVlbic6IFswLCAxMDAsIDAsIDFdLFxuICAnZGFya2dyZXknOiBbMTY5LCAxNjksIDE2OSwgMV0sXG4gICdkYXJra2hha2knOiBbMTg5LCAxODMsIDEwNywgMV0sXG4gICdkYXJrbWFnZW50YSc6IFsxMzksIDAsIDEzOSwgMV0sXG4gICdkYXJrb2xpdmVncmVlbic6IFs4NSwgMTA3LCA0NywgMV0sXG4gICdkYXJrb3JhbmdlJzogWzI1NSwgMTQwLCAwLCAxXSxcbiAgJ2RhcmtvcmNoaWQnOiBbMTUzLCA1MCwgMjA0LCAxXSxcbiAgJ2RhcmtyZWQnOiBbMTM5LCAwLCAwLCAxXSxcbiAgJ2RhcmtzYWxtb24nOiBbMjMzLCAxNTAsIDEyMiwgMV0sXG4gICdkYXJrc2VhZ3JlZW4nOiBbMTQzLCAxODgsIDE0MywgMV0sXG4gICdkYXJrc2xhdGVibHVlJzogWzcyLCA2MSwgMTM5LCAxXSxcbiAgJ2RhcmtzbGF0ZWdyYXknOiBbNDcsIDc5LCA3OSwgMV0sXG4gICdkYXJrc2xhdGVncmV5JzogWzQ3LCA3OSwgNzksIDFdLFxuICAnZGFya3R1cnF1b2lzZSc6IFswLCAyMDYsIDIwOSwgMV0sXG4gICdkYXJrdmlvbGV0JzogWzE0OCwgMCwgMjExLCAxXSxcbiAgJ2RlZXBwaW5rJzogWzI1NSwgMjAsIDE0NywgMV0sXG4gICdkZWVwc2t5Ymx1ZSc6IFswLCAxOTEsIDI1NSwgMV0sXG4gICdkaW1ncmF5JzogWzEwNSwgMTA1LCAxMDUsIDFdLFxuICAnZGltZ3JleSc6IFsxMDUsIDEwNSwgMTA1LCAxXSxcbiAgJ2RvZGdlcmJsdWUnOiBbMzAsIDE0NCwgMjU1LCAxXSxcbiAgJ2ZpcmVicmljayc6IFsxNzgsIDM0LCAzNCwgMV0sXG4gICdmbG9yYWx3aGl0ZSc6IFsyNTUsIDI1MCwgMjQwLCAxXSxcbiAgJ2ZvcmVzdGdyZWVuJzogWzM0LCAxMzksIDM0LCAxXSxcbiAgJ2Z1Y2hzaWEnOiBbMjU1LCAwLCAyNTUsIDFdLFxuICAnZ2FpbnNib3JvJzogWzIyMCwgMjIwLCAyMjAsIDFdLFxuICAnZ2hvc3R3aGl0ZSc6IFsyNDgsIDI0OCwgMjU1LCAxXSxcbiAgJ2dvbGQnOiBbMjU1LCAyMTUsIDAsIDFdLFxuICAnZ29sZGVucm9kJzogWzIxOCwgMTY1LCAzMiwgMV0sXG4gICdncmF5JzogWzEyOCwgMTI4LCAxMjgsIDFdLFxuICAnZ3JlZW4nOiBbMCwgMTI4LCAwLCAxXSxcbiAgJ2dyZWVueWVsbG93JzogWzE3MywgMjU1LCA0NywgMV0sXG4gICdncmV5JzogWzEyOCwgMTI4LCAxMjgsIDFdLFxuICAnaG9uZXlkZXcnOiBbMjQwLCAyNTUsIDI0MCwgMV0sXG4gICdob3RwaW5rJzogWzI1NSwgMTA1LCAxODAsIDFdLFxuICAnaW5kaWFucmVkJzogWzIwNSwgOTIsIDkyLCAxXSxcbiAgJ2luZGlnbyc6IFs3NSwgMCwgMTMwLCAxXSxcbiAgJ2l2b3J5JzogWzI1NSwgMjU1LCAyNDAsIDFdLFxuICAna2hha2knOiBbMjQwLCAyMzAsIDE0MCwgMV0sXG4gICdsYXZlbmRlcic6IFsyMzAsIDIzMCwgMjUwLCAxXSxcbiAgJ2xhdmVuZGVyYmx1c2gnOiBbMjU1LCAyNDAsIDI0NSwgMV0sXG4gICdsYXduZ3JlZW4nOiBbMTI0LCAyNTIsIDAsIDFdLFxuICAnbGVtb25jaGlmZm9uJzogWzI1NSwgMjUwLCAyMDUsIDFdLFxuICAnbGlnaHRibHVlJzogWzE3MywgMjE2LCAyMzAsIDFdLFxuICAnbGlnaHRjb3JhbCc6IFsyNDAsIDEyOCwgMTI4LCAxXSxcbiAgJ2xpZ2h0Y3lhbic6IFsyMjQsIDI1NSwgMjU1LCAxXSxcbiAgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogWzI1MCwgMjUwLCAyMTAsIDFdLFxuICAnbGlnaHRncmF5JzogWzIxMSwgMjExLCAyMTEsIDFdLFxuICAnbGlnaHRncmVlbic6IFsxNDQsIDIzOCwgMTQ0LCAxXSxcbiAgJ2xpZ2h0Z3JleSc6IFsyMTEsIDIxMSwgMjExLCAxXSxcbiAgJ2xpZ2h0cGluayc6IFsyNTUsIDE4MiwgMTkzLCAxXSxcbiAgJ2xpZ2h0c2FsbW9uJzogWzI1NSwgMTYwLCAxMjIsIDFdLFxuICAnbGlnaHRzZWFncmVlbic6IFszMiwgMTc4LCAxNzAsIDFdLFxuICAnbGlnaHRza3libHVlJzogWzEzNSwgMjA2LCAyNTAsIDFdLFxuICAnbGlnaHRzbGF0ZWdyYXknOiBbMTE5LCAxMzYsIDE1MywgMV0sXG4gICdsaWdodHNsYXRlZ3JleSc6IFsxMTksIDEzNiwgMTUzLCAxXSxcbiAgJ2xpZ2h0c3RlZWxibHVlJzogWzE3NiwgMTk2LCAyMjIsIDFdLFxuICAnbGlnaHR5ZWxsb3cnOiBbMjU1LCAyNTUsIDIyNCwgMV0sXG4gICdsaW1lJzogWzAsIDI1NSwgMCwgMV0sXG4gICdsaW1lZ3JlZW4nOiBbNTAsIDIwNSwgNTAsIDFdLFxuICAnbGluZW4nOiBbMjUwLCAyNDAsIDIzMCwgMV0sXG4gICdtYWdlbnRhJzogWzI1NSwgMCwgMjU1LCAxXSxcbiAgJ21hcm9vbic6IFsxMjgsIDAsIDAsIDFdLFxuICAnbWVkaXVtYXF1YW1hcmluZSc6IFsxMDIsIDIwNSwgMTcwLCAxXSxcbiAgJ21lZGl1bWJsdWUnOiBbMCwgMCwgMjA1LCAxXSxcbiAgJ21lZGl1bW9yY2hpZCc6IFsxODYsIDg1LCAyMTEsIDFdLFxuICAnbWVkaXVtcHVycGxlJzogWzE0NywgMTEyLCAyMTksIDFdLFxuICAnbWVkaXVtc2VhZ3JlZW4nOiBbNjAsIDE3OSwgMTEzLCAxXSxcbiAgJ21lZGl1bXNsYXRlYmx1ZSc6IFsxMjMsIDEwNCwgMjM4LCAxXSxcbiAgJ21lZGl1bXNwcmluZ2dyZWVuJzogWzAsIDI1MCwgMTU0LCAxXSxcbiAgJ21lZGl1bXR1cnF1b2lzZSc6IFs3MiwgMjA5LCAyMDQsIDFdLFxuICAnbWVkaXVtdmlvbGV0cmVkJzogWzE5OSwgMjEsIDEzMywgMV0sXG4gICdtaWRuaWdodGJsdWUnOiBbMjUsIDI1LCAxMTIsIDFdLFxuICAnbWludGNyZWFtJzogWzI0NSwgMjU1LCAyNTAsIDFdLFxuICAnbWlzdHlyb3NlJzogWzI1NSwgMjI4LCAyMjUsIDFdLFxuICAnbW9jY2FzaW4nOiBbMjU1LCAyMjgsIDE4MSwgMV0sXG4gICduYXZham93aGl0ZSc6IFsyNTUsIDIyMiwgMTczLCAxXSxcbiAgJ25hdnknOiBbMCwgMCwgMTI4LCAxXSxcbiAgJ29sZGxhY2UnOiBbMjUzLCAyNDUsIDIzMCwgMV0sXG4gICdvbGl2ZSc6IFsxMjgsIDEyOCwgMCwgMV0sXG4gICdvbGl2ZWRyYWInOiBbMTA3LCAxNDIsIDM1LCAxXSxcbiAgJ29yYW5nZSc6IFsyNTUsIDE2NSwgMCwgMV0sXG4gICdvcmFuZ2VyZWQnOiBbMjU1LCA2OSwgMCwgMV0sXG4gICdvcmNoaWQnOiBbMjE4LCAxMTIsIDIxNCwgMV0sXG4gICdwYWxlZ29sZGVucm9kJzogWzIzOCwgMjMyLCAxNzAsIDFdLFxuICAncGFsZWdyZWVuJzogWzE1MiwgMjUxLCAxNTIsIDFdLFxuICAncGFsZXR1cnF1b2lzZSc6IFsxNzUsIDIzOCwgMjM4LCAxXSxcbiAgJ3BhbGV2aW9sZXRyZWQnOiBbMjE5LCAxMTIsIDE0NywgMV0sXG4gICdwYXBheWF3aGlwJzogWzI1NSwgMjM5LCAyMTMsIDFdLFxuICAncGVhY2hwdWZmJzogWzI1NSwgMjE4LCAxODUsIDFdLFxuICAncGVydSc6IFsyMDUsIDEzMywgNjMsIDFdLFxuICAncGluayc6IFsyNTUsIDE5MiwgMjAzLCAxXSxcbiAgJ3BsdW0nOiBbMjIxLCAxNjAsIDIyMSwgMV0sXG4gICdwb3dkZXJibHVlJzogWzE3NiwgMjI0LCAyMzAsIDFdLFxuICAncHVycGxlJzogWzEyOCwgMCwgMTI4LCAxXSxcbiAgJ3JlZCc6IFsyNTUsIDAsIDAsIDFdLFxuICAncm9zeWJyb3duJzogWzE4OCwgMTQzLCAxNDMsIDFdLFxuICAncm95YWxibHVlJzogWzY1LCAxMDUsIDIyNSwgMV0sXG4gICdzYWRkbGVicm93bic6IFsxMzksIDY5LCAxOSwgMV0sXG4gICdzYWxtb24nOiBbMjUwLCAxMjgsIDExNCwgMV0sXG4gICdzYW5keWJyb3duJzogWzI0NCwgMTY0LCA5NiwgMV0sXG4gICdzZWFncmVlbic6IFs0NiwgMTM5LCA4NywgMV0sXG4gICdzZWFzaGVsbCc6IFsyNTUsIDI0NSwgMjM4LCAxXSxcbiAgJ3NpZW5uYSc6IFsxNjAsIDgyLCA0NSwgMV0sXG4gICdzaWx2ZXInOiBbMTkyLCAxOTIsIDE5MiwgMV0sXG4gICdza3libHVlJzogWzEzNSwgMjA2LCAyMzUsIDFdLFxuICAnc2xhdGVibHVlJzogWzEwNiwgOTAsIDIwNSwgMV0sXG4gICdzbGF0ZWdyYXknOiBbMTEyLCAxMjgsIDE0NCwgMV0sXG4gICdzbGF0ZWdyZXknOiBbMTEyLCAxMjgsIDE0NCwgMV0sXG4gICdzbm93JzogWzI1NSwgMjUwLCAyNTAsIDFdLFxuICAnc3ByaW5nZ3JlZW4nOiBbMCwgMjU1LCAxMjcsIDFdLFxuICAnc3RlZWxibHVlJzogWzcwLCAxMzAsIDE4MCwgMV0sXG4gICd0YW4nOiBbMjEwLCAxODAsIDE0MCwgMV0sXG4gICd0ZWFsJzogWzAsIDEyOCwgMTI4LCAxXSxcbiAgJ3RoaXN0bGUnOiBbMjE2LCAxOTEsIDIxNiwgMV0sXG4gICd0b21hdG8nOiBbMjU1LCA5OSwgNzEsIDFdLFxuICAndHVycXVvaXNlJzogWzY0LCAyMjQsIDIwOCwgMV0sXG4gICd2aW9sZXQnOiBbMjM4LCAxMzAsIDIzOCwgMV0sXG4gICd3aGVhdCc6IFsyNDUsIDIyMiwgMTc5LCAxXSxcbiAgJ3doaXRlJzogWzI1NSwgMjU1LCAyNTUsIDFdLFxuICAnd2hpdGVzbW9rZSc6IFsyNDUsIDI0NSwgMjQ1LCAxXSxcbiAgJ3llbGxvdyc6IFsyNTUsIDI1NSwgMCwgMV0sXG4gICd5ZWxsb3dncmVlbic6IFsxNTQsIDIwNSwgNTAsIDFdXG59O1xuXG5mdW5jdGlvbiBjbGFtcENzc0J5dGUoaSkge1xuICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMjU1LlxuICBpID0gTWF0aC5yb3VuZChpKTsgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG5cbiAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAyNTUgPyAyNTUgOiBpO1xufVxuXG5mdW5jdGlvbiBjbGFtcENzc0FuZ2xlKGkpIHtcbiAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDM2MC5cbiAgaSA9IE1hdGgucm91bmQoaSk7IC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuXG4gIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMzYwID8gMzYwIDogaTtcbn1cblxuZnVuY3Rpb24gY2xhbXBDc3NGbG9hdChmKSB7XG4gIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gIHJldHVybiBmIDwgMCA/IDAgOiBmID4gMSA/IDEgOiBmO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNzc0ludChzdHIpIHtcbiAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICByZXR1cm4gY2xhbXBDc3NCeXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7XG4gIH1cblxuICByZXR1cm4gY2xhbXBDc3NCeXRlKHBhcnNlSW50KHN0ciwgMTApKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDc3NGbG9hdChzdHIpIHtcbiAgLy8gZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgIHJldHVybiBjbGFtcENzc0Zsb2F0KHBhcnNlRmxvYXQoc3RyKSAvIDEwMCk7XG4gIH1cblxuICByZXR1cm4gY2xhbXBDc3NGbG9hdChwYXJzZUZsb2F0KHN0cikpO1xufVxuXG5mdW5jdGlvbiBjc3NIdWVUb1JnYihtMSwgbTIsIGgpIHtcbiAgaWYgKGggPCAwKSB7XG4gICAgaCArPSAxO1xuICB9IGVsc2UgaWYgKGggPiAxKSB7XG4gICAgaCAtPSAxO1xuICB9XG5cbiAgaWYgKGggKiA2IDwgMSkge1xuICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2O1xuICB9XG5cbiAgaWYgKGggKiAyIDwgMSkge1xuICAgIHJldHVybiBtMjtcbiAgfVxuXG4gIGlmIChoICogMyA8IDIpIHtcbiAgICByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMiAvIDMgLSBoKSAqIDY7XG4gIH1cblxuICByZXR1cm4gbTE7XG59XG5cbmZ1bmN0aW9uIGxlcnBOdW1iZXIoYSwgYiwgcCkge1xuICByZXR1cm4gYSArIChiIC0gYSkgKiBwO1xufVxuXG5mdW5jdGlvbiBzZXRSZ2JhKG91dCwgciwgZywgYiwgYSkge1xuICBvdXRbMF0gPSByO1xuICBvdXRbMV0gPSBnO1xuICBvdXRbMl0gPSBiO1xuICBvdXRbM10gPSBhO1xuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBjb3B5UmdiYShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxudmFyIGNvbG9yQ2FjaGUgPSBuZXcgTFJVKDIwKTtcbnZhciBsYXN0UmVtb3ZlZEFyciA9IG51bGw7XG5cbmZ1bmN0aW9uIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpIHtcbiAgLy8gUmV1c2UgcmVtb3ZlZCBhcnJheVxuICBpZiAobGFzdFJlbW92ZWRBcnIpIHtcbiAgICBjb3B5UmdiYShsYXN0UmVtb3ZlZEFyciwgcmdiYUFycik7XG4gIH1cblxuICBsYXN0UmVtb3ZlZEFyciA9IGNvbG9yQ2FjaGUucHV0KGNvbG9yU3RyLCBsYXN0UmVtb3ZlZEFyciB8fCByZ2JhQXJyLnNsaWNlKCkpO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JTdHJcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG91dFxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cblxuZnVuY3Rpb24gcGFyc2UoY29sb3JTdHIsIHJnYmFBcnIpIHtcbiAgaWYgKCFjb2xvclN0cikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJnYmFBcnIgPSByZ2JhQXJyIHx8IFtdO1xuICB2YXIgY2FjaGVkID0gY29sb3JDYWNoZS5nZXQoY29sb3JTdHIpO1xuXG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY29weVJnYmEocmdiYUFyciwgY2FjaGVkKTtcbiAgfSAvLyBjb2xvclN0ciBtYXkgYmUgbm90IHN0cmluZ1xuXG5cbiAgY29sb3JTdHIgPSBjb2xvclN0ciArICcnOyAvLyBSZW1vdmUgYWxsIHdoaXRlc3BhY2UsIG5vdCBjb21wbGlhbnQsIGJ1dCBzaG91bGQganVzdCBiZSBtb3JlIGFjY2VwdGluZy5cblxuICB2YXIgc3RyID0gY29sb3JTdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTsgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLlxuXG4gIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHtcbiAgICBjb3B5UmdiYShyZ2JhQXJyLCBrQ1NTQ29sb3JUYWJsZVtzdHJdKTtcbiAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICByZXR1cm4gcmdiYUFycjtcbiAgfSAvLyAjYWJjIGFuZCAjYWJjMTIzIHN5bnRheC5cblxuXG4gIGlmIChzdHIuY2hhckF0KDApID09PSAnIycpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cblxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZikpIHtcbiAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuOyAvLyBDb3ZlcnMgTmFOLlxuICAgICAgfVxuXG4gICAgICBzZXRSZ2JhKHJnYmFBcnIsIChpdiAmIDB4ZjAwKSA+PiA0IHwgKGl2ICYgMHhmMDApID4+IDgsIGl2ICYgMHhmMCB8IChpdiAmIDB4ZjApID4+IDQsIGl2ICYgMHhmIHwgKGl2ICYgMHhmKSA8PCA0LCAxKTtcbiAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7IC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmZmZmKSkge1xuICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICByZXR1cm47IC8vIENvdmVycyBOYU4uXG4gICAgICB9XG5cbiAgICAgIHNldFJnYmEocmdiYUFyciwgKGl2ICYgMHhmZjAwMDApID4+IDE2LCAoaXYgJiAweGZmMDApID4+IDgsIGl2ICYgMHhmZiwgMSk7XG4gICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBvcCA9IHN0ci5pbmRleE9mKCcoJyksXG4gICAgICBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG5cbiAgaWYgKG9wICE9PSAtMSAmJiBlcCArIDEgPT09IHN0ci5sZW5ndGgpIHtcbiAgICB2YXIgZm5hbWUgPSBzdHIuc3Vic3RyKDAsIG9wKTtcbiAgICB2YXIgcGFyYW1zID0gc3RyLnN1YnN0cihvcCArIDEsIGVwIC0gKG9wICsgMSkpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGFscGhhID0gMTsgLy8gVG8gYWxsb3cgY2FzZSBmYWxsdGhyb3VnaC5cblxuICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYWxwaGEgPSBwYXJzZUNzc0Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgIC8vIEZhbGwgdGhyb3VnaC5cblxuICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFJnYmEocmdiYUFyciwgcGFyc2VDc3NJbnQocGFyYW1zWzBdKSwgcGFyc2VDc3NJbnQocGFyYW1zWzFdKSwgcGFyc2VDc3NJbnQocGFyYW1zWzJdKSwgYWxwaGEpO1xuICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG5cbiAgICAgIGNhc2UgJ2hzbGEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zWzNdID0gcGFyc2VDc3NGbG9hdChwYXJhbXNbM10pO1xuICAgICAgICBoc2xhMnJnYmEocGFyYW1zLCByZ2JhQXJyKTtcbiAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgIHJldHVybiByZ2JhQXJyO1xuXG4gICAgICBjYXNlICdoc2wnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaHNsYTJyZ2JhKHBhcmFtcywgcmdiYUFycik7XG4gICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICByZXR1cm4gcmdiYUFycjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gIHJldHVybjtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaHNsYVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAqL1xuXG5cbmZ1bmN0aW9uIGhzbGEycmdiYShoc2xhLCByZ2JhKSB7XG4gIHZhciBoID0gKHBhcnNlRmxvYXQoaHNsYVswXSkgJSAzNjAgKyAzNjApICUgMzYwIC8gMzYwOyAvLyAwIC4uIDFcbiAgLy8gTk9URShkZWFubSk6IEFjY29yZGluZyB0byB0aGUgQ1NTIHNwZWMgcy9sIHNob3VsZCBvbmx5IGJlXG4gIC8vIHBlcmNlbnRhZ2VzLCBidXQgd2UgZG9uJ3QgYm90aGVyIGFuZCBsZXQgZmxvYXQgb3IgcGVyY2VudGFnZS5cblxuICB2YXIgcyA9IHBhcnNlQ3NzRmxvYXQoaHNsYVsxXSk7XG4gIHZhciBsID0gcGFyc2VDc3NGbG9hdChoc2xhWzJdKTtcbiAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gIHZhciBtMSA9IGwgKiAyIC0gbTI7XG4gIHJnYmEgPSByZ2JhIHx8IFtdO1xuICBzZXRSZ2JhKHJnYmEsIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGggKyAxIC8gMykgKiAyNTUpLCBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoKSAqIDI1NSksIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGggLSAxIC8gMykgKiAyNTUpLCAxKTtcblxuICBpZiAoaHNsYS5sZW5ndGggPT09IDQpIHtcbiAgICByZ2JhWzNdID0gaHNsYVszXTtcbiAgfVxuXG4gIHJldHVybiByZ2JhO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gaHNsYVxuICovXG5cblxuZnVuY3Rpb24gcmdiYTJoc2xhKHJnYmEpIHtcbiAgaWYgKCFyZ2JhKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFJHQiBmcm9tIDAgdG8gMjU1XG5cblxuICB2YXIgUiA9IHJnYmFbMF0gLyAyNTU7XG4gIHZhciBHID0gcmdiYVsxXSAvIDI1NTtcbiAgdmFyIEIgPSByZ2JhWzJdIC8gMjU1O1xuICB2YXIgdk1pbiA9IE1hdGgubWluKFIsIEcsIEIpOyAvLyBNaW4uIHZhbHVlIG9mIFJHQlxuXG4gIHZhciB2TWF4ID0gTWF0aC5tYXgoUiwgRywgQik7IC8vIE1heC4gdmFsdWUgb2YgUkdCXG5cbiAgdmFyIGRlbHRhID0gdk1heCAtIHZNaW47IC8vIERlbHRhIFJHQiB2YWx1ZVxuXG4gIHZhciBMID0gKHZNYXggKyB2TWluKSAvIDI7XG4gIHZhciBIO1xuICB2YXIgUzsgLy8gSFNMIHJlc3VsdHMgZnJvbSAwIHRvIDFcblxuICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICBIID0gMDtcbiAgICBTID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoTCA8IDAuNSkge1xuICAgICAgUyA9IGRlbHRhIC8gKHZNYXggKyB2TWluKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUyA9IGRlbHRhIC8gKDIgLSB2TWF4IC0gdk1pbik7XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhUiA9ICgodk1heCAtIFIpIC8gNiArIGRlbHRhIC8gMikgLyBkZWx0YTtcbiAgICB2YXIgZGVsdGFHID0gKCh2TWF4IC0gRykgLyA2ICsgZGVsdGEgLyAyKSAvIGRlbHRhO1xuICAgIHZhciBkZWx0YUIgPSAoKHZNYXggLSBCKSAvIDYgKyBkZWx0YSAvIDIpIC8gZGVsdGE7XG5cbiAgICBpZiAoUiA9PT0gdk1heCkge1xuICAgICAgSCA9IGRlbHRhQiAtIGRlbHRhRztcbiAgICB9IGVsc2UgaWYgKEcgPT09IHZNYXgpIHtcbiAgICAgIEggPSAxIC8gMyArIGRlbHRhUiAtIGRlbHRhQjtcbiAgICB9IGVsc2UgaWYgKEIgPT09IHZNYXgpIHtcbiAgICAgIEggPSAyIC8gMyArIGRlbHRhRyAtIGRlbHRhUjtcbiAgICB9XG5cbiAgICBpZiAoSCA8IDApIHtcbiAgICAgIEggKz0gMTtcbiAgICB9XG5cbiAgICBpZiAoSCA+IDEpIHtcbiAgICAgIEggLT0gMTtcbiAgICB9XG4gIH1cblxuICB2YXIgaHNsYSA9IFtIICogMzYwLCBTLCBMXTtcblxuICBpZiAocmdiYVszXSAhPSBudWxsKSB7XG4gICAgaHNsYS5wdXNoKHJnYmFbM10pO1xuICB9XG5cbiAgcmV0dXJuIGhzbGE7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cblxuZnVuY3Rpb24gbGlmdChjb2xvciwgbGV2ZWwpIHtcbiAgdmFyIGNvbG9yQXJyID0gcGFyc2UoY29sb3IpO1xuXG4gIGlmIChjb2xvckFycikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICAgIGNvbG9yQXJyW2ldID0gY29sb3JBcnJbaV0gKiAoMSAtIGxldmVsKSB8IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xvckFycltpXSA9ICgyNTUgLSBjb2xvckFycltpXSkgKiBsZXZlbCArIGNvbG9yQXJyW2ldIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5KGNvbG9yQXJyLCBjb2xvckFyci5sZW5ndGggPT09IDQgPyAncmdiYScgOiAncmdiJyk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cblxuZnVuY3Rpb24gdG9IZXgoY29sb3IpIHtcbiAgdmFyIGNvbG9yQXJyID0gcGFyc2UoY29sb3IpO1xuXG4gIGlmIChjb2xvckFycikge1xuICAgIHJldHVybiAoKDEgPDwgMjQpICsgKGNvbG9yQXJyWzBdIDw8IDE2KSArIChjb2xvckFyclsxXSA8PCA4KSArICtjb2xvckFyclsyXSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICB9XG59XG4vKipcbiAqIE1hcCB2YWx1ZSB0byBjb2xvci4gRmFzdGVyIHRoYW4gbGVycCBtZXRob2RzIGJlY2F1c2UgY29sb3IgaXMgcmVwcmVzZW50ZWQgYnkgcmdiYSBhcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBub3JtYWxpemVkVmFsdWUgQSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGNvbG9ycyBMaXN0IG9mIHJnYmEgY29sb3IgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIE1hcHBlZCBnYmEgY29sb3IgYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSB3aWxsIGJlIG51bGwvdW5kZWZpbmVkIGlmIGlucHV0IGlsbGVnYWwuXG4gKi9cblxuXG5mdW5jdGlvbiBmYXN0TGVycChub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgb3V0KSB7XG4gIGlmICghKGNvbG9ycyAmJiBjb2xvcnMubGVuZ3RoKSB8fCAhKG5vcm1hbGl6ZWRWYWx1ZSA+PSAwICYmIG5vcm1hbGl6ZWRWYWx1ZSA8PSAxKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG91dCA9IG91dCB8fCBbXTtcbiAgdmFyIHZhbHVlID0gbm9ybWFsaXplZFZhbHVlICogKGNvbG9ycy5sZW5ndGggLSAxKTtcbiAgdmFyIGxlZnRJbmRleCA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gIHZhciBsZWZ0Q29sb3IgPSBjb2xvcnNbbGVmdEluZGV4XTtcbiAgdmFyIHJpZ2h0Q29sb3IgPSBjb2xvcnNbcmlnaHRJbmRleF07XG4gIHZhciBkdiA9IHZhbHVlIC0gbGVmdEluZGV4O1xuICBvdXRbMF0gPSBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMF0sIHJpZ2h0Q29sb3JbMF0sIGR2KSk7XG4gIG91dFsxXSA9IGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKTtcbiAgb3V0WzJdID0gY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpO1xuICBvdXRbM10gPSBjbGFtcENzc0Zsb2F0KGxlcnBOdW1iZXIobGVmdENvbG9yWzNdLCByaWdodENvbG9yWzNdLCBkdikpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblxudmFyIGZhc3RNYXBUb0NvbG9yID0gZmFzdExlcnA7XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBub3JtYWxpemVkVmFsdWUgQSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjb2xvcnMgQ29sb3IgbGlzdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGZ1bGxPdXRwdXQgRGVmYXVsdCBmYWxzZS5cbiAqIEByZXR1cm4geyhzdHJpbmd8T2JqZWN0KX0gUmVzdWx0IGNvbG9yLiBJZiBmdWxsT3V0cHV0LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbG9yOiAuLi4sIGxlZnRJbmRleDogLi4uLCByaWdodEluZGV4OiAuLi4sIHZhbHVlOiAuLi59LFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5mdW5jdGlvbiBsZXJwKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBmdWxsT3V0cHV0KSB7XG4gIGlmICghKGNvbG9ycyAmJiBjb2xvcnMubGVuZ3RoKSB8fCAhKG5vcm1hbGl6ZWRWYWx1ZSA+PSAwICYmIG5vcm1hbGl6ZWRWYWx1ZSA8PSAxKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIChjb2xvcnMubGVuZ3RoIC0gMSk7XG4gIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgdmFyIHJpZ2h0SW5kZXggPSBNYXRoLmNlaWwodmFsdWUpO1xuICB2YXIgbGVmdENvbG9yID0gcGFyc2UoY29sb3JzW2xlZnRJbmRleF0pO1xuICB2YXIgcmlnaHRDb2xvciA9IHBhcnNlKGNvbG9yc1tyaWdodEluZGV4XSk7XG4gIHZhciBkdiA9IHZhbHVlIC0gbGVmdEluZGV4O1xuICB2YXIgY29sb3IgPSBzdHJpbmdpZnkoW2NsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclswXSwgcmlnaHRDb2xvclswXSwgZHYpKSwgY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzFdLCByaWdodENvbG9yWzFdLCBkdikpLCBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSksIGNsYW1wQ3NzRmxvYXQobGVycE51bWJlcihsZWZ0Q29sb3JbM10sIHJpZ2h0Q29sb3JbM10sIGR2KSldLCAncmdiYScpO1xuICByZXR1cm4gZnVsbE91dHB1dCA/IHtcbiAgICBjb2xvcjogY29sb3IsXG4gICAgbGVmdEluZGV4OiBsZWZ0SW5kZXgsXG4gICAgcmlnaHRJbmRleDogcmlnaHRJbmRleCxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSA6IGNvbG9yO1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblxudmFyIG1hcFRvQ29sb3IgPSBsZXJwO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7bnVtYmVyPX0gaCAwIH4gMzYwLCBpZ25vcmUgd2hlbiBudWxsLlxuICogQHBhcmFtIHtudW1iZXI9fSBzIDAgfiAxLCBpZ25vcmUgd2hlbiBudWxsLlxuICogQHBhcmFtIHtudW1iZXI9fSBsIDAgfiAxLCBpZ25vcmUgd2hlbiBudWxsLlxuICogQHJldHVybiB7c3RyaW5nfSBDb2xvciBzdHJpbmcgaW4gcmdiYSBmb3JtYXQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cbmZ1bmN0aW9uIG1vZGlmeUhTTChjb2xvciwgaCwgcywgbCkge1xuICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3IpIHtcbiAgICBjb2xvciA9IHJnYmEyaHNsYShjb2xvcik7XG4gICAgaCAhPSBudWxsICYmIChjb2xvclswXSA9IGNsYW1wQ3NzQW5nbGUoaCkpO1xuICAgIHMgIT0gbnVsbCAmJiAoY29sb3JbMV0gPSBwYXJzZUNzc0Zsb2F0KHMpKTtcbiAgICBsICE9IG51bGwgJiYgKGNvbG9yWzJdID0gcGFyc2VDc3NGbG9hdChsKSk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShoc2xhMnJnYmEoY29sb3IpLCAncmdiYScpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHBhcmFtIHtudW1iZXI9fSBhbHBoYSAwIH4gMVxuICogQHJldHVybiB7c3RyaW5nfSBDb2xvciBzdHJpbmcgaW4gcmdiYSBmb3JtYXQuXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cblxuZnVuY3Rpb24gbW9kaWZ5QWxwaGEoY29sb3IsIGFscGhhKSB7XG4gIGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXG4gIGlmIChjb2xvciAmJiBhbHBoYSAhPSBudWxsKSB7XG4gICAgY29sb3JbM10gPSBjbGFtcENzc0Zsb2F0KGFscGhhKTtcbiAgICByZXR1cm4gc3RyaW5naWZ5KGNvbG9yLCAncmdiYScpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyckNvbG9yIGxpa2UgWzEyLDMzLDQ0LDAuNF1cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICdyZ2JhJywgJ2hzdmEnLCAuLi5cbiAqIEByZXR1cm4ge3N0cmluZ30gUmVzdWx0IGNvbG9yLiAoSWYgaW5wdXQgaWxsZWdhbCwgcmV0dXJuIHVuZGVmaW5lZCkuXG4gKi9cblxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyQ29sb3IsIHR5cGUpIHtcbiAgaWYgKCFhcnJDb2xvciB8fCAhYXJyQ29sb3IubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbG9yU3RyID0gYXJyQ29sb3JbMF0gKyAnLCcgKyBhcnJDb2xvclsxXSArICcsJyArIGFyckNvbG9yWzJdO1xuXG4gIGlmICh0eXBlID09PSAncmdiYScgfHwgdHlwZSA9PT0gJ2hzdmEnIHx8IHR5cGUgPT09ICdoc2xhJykge1xuICAgIGNvbG9yU3RyICs9ICcsJyArIGFyckNvbG9yWzNdO1xuICB9XG5cbiAgcmV0dXJuIHR5cGUgKyAnKCcgKyBjb2xvclN0ciArICcpJztcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5saWZ0ID0gbGlmdDtcbmV4cG9ydHMudG9IZXggPSB0b0hleDtcbmV4cG9ydHMuZmFzdExlcnAgPSBmYXN0TGVycDtcbmV4cG9ydHMuZmFzdE1hcFRvQ29sb3IgPSBmYXN0TWFwVG9Db2xvcjtcbmV4cG9ydHMubGVycCA9IGxlcnA7XG5leHBvcnRzLm1hcFRvQ29sb3IgPSBtYXBUb0NvbG9yO1xuZXhwb3J0cy5tb2RpZnlIU0wgPSBtb2RpZnlIU0w7XG5leHBvcnRzLm1vZGlmeUFscGhhID0gbW9kaWZ5QWxwaGE7XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvdG9vbC9jb2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gU2ltcGxlIExSVSBjYWNoZSB1c2UgZG91Ymx5IGxpbmtlZCBsaXN0XG4vLyBAbW9kdWxlIHpyZW5kZXIvY29yZS9MUlVcblxuLyoqXG4gKiBTaW1wbGUgZG91YmxlIGxpbmtlZCBsaXN0LiBDb21wYXJlZCB3aXRoIGFycmF5LCBpdCBoYXMgTygxKSByZW1vdmUgb3BlcmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cbiAgdGhpcy5oZWFkID0gbnVsbDtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICovXG5cbiAgdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5fbGVuID0gMDtcbn07XG5cbnZhciBsaW5rZWRMaXN0UHJvdG8gPSBMaW5rZWRMaXN0LnByb3RvdHlwZTtcbi8qKlxuICogSW5zZXJ0IGEgbmV3IHZhbHVlIGF0IHRoZSB0YWlsXG4gKiBAcGFyYW0gIHt9IHZhbFxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gKi9cblxubGlua2VkTGlzdFByb3RvLmluc2VydCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgdmFyIGVudHJ5ID0gbmV3IEVudHJ5KHZhbCk7XG4gIHRoaXMuaW5zZXJ0RW50cnkoZW50cnkpO1xuICByZXR1cm4gZW50cnk7XG59O1xuLyoqXG4gKiBJbnNlcnQgYW4gZW50cnkgYXQgdGhlIHRhaWxcbiAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fSBlbnRyeVxuICovXG5cblxubGlua2VkTGlzdFByb3RvLmluc2VydEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gZW50cnk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtcbiAgICBlbnRyeS5wcmV2ID0gdGhpcy50YWlsO1xuICAgIGVudHJ5Lm5leHQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICB9XG5cbiAgdGhpcy5fbGVuKys7XG59O1xuLyoqXG4gKiBSZW1vdmUgZW50cnkuXG4gKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgdmFyIHByZXYgPSBlbnRyeS5wcmV2O1xuICB2YXIgbmV4dCA9IGVudHJ5Lm5leHQ7XG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICB9IGVsc2Uge1xuICAgIC8vIElzIGhlYWRcbiAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2O1xuICB9IGVsc2Uge1xuICAgIC8vIElzIHRhaWxcbiAgICB0aGlzLnRhaWwgPSBwcmV2O1xuICB9XG5cbiAgZW50cnkubmV4dCA9IGVudHJ5LnByZXYgPSBudWxsO1xuICB0aGlzLl9sZW4tLTtcbn07XG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5sZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9sZW47XG59O1xuLyoqXG4gKiBDbGVhciBsaXN0XG4gKi9cblxuXG5saW5rZWRMaXN0UHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMuX2xlbiA9IDA7XG59O1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7fSB2YWxcbiAqL1xuXG5cbnZhciBFbnRyeSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHt9XG4gICAqL1xuICB0aGlzLnZhbHVlID0gdmFsO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cblxuICB0aGlzLm5leHQ7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAqL1xuXG4gIHRoaXMucHJldjtcbn07XG4vKipcbiAqIExSVSBDYWNoZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9MUlVcbiAqL1xuXG5cbnZhciBMUlUgPSBmdW5jdGlvbiAobWF4U2l6ZSkge1xuICB0aGlzLl9saXN0ID0gbmV3IExpbmtlZExpc3QoKTtcbiAgdGhpcy5fbWFwID0ge307XG4gIHRoaXMuX21heFNpemUgPSBtYXhTaXplIHx8IDEwO1xuICB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5ID0gbnVsbDtcbn07XG5cbnZhciBMUlVQcm90byA9IExSVS5wcm90b3R5cGU7XG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0gIHt9IHZhbHVlXG4gKiBAcmV0dXJuIHt9IFJlbW92ZWQgdmFsdWVcbiAqL1xuXG5MUlVQcm90by5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gIHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gIHZhciByZW1vdmVkID0gbnVsbDtcblxuICBpZiAobWFwW2tleV0gPT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBsaXN0LmxlbigpOyAvLyBSZXVzZSBsYXN0IHJlbW92ZWQgZW50cnlcblxuICAgIHZhciBlbnRyeSA9IHRoaXMuX2xhc3RSZW1vdmVkRW50cnk7XG5cbiAgICBpZiAobGVuID49IHRoaXMuX21heFNpemUgJiYgbGVuID4gMCkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkXG4gICAgICB2YXIgbGVhc3RVc2VkRW50cnkgPSBsaXN0LmhlYWQ7XG4gICAgICBsaXN0LnJlbW92ZShsZWFzdFVzZWRFbnRyeSk7XG4gICAgICBkZWxldGUgbWFwW2xlYXN0VXNlZEVudHJ5LmtleV07XG4gICAgICByZW1vdmVkID0gbGVhc3RVc2VkRW50cnkudmFsdWU7XG4gICAgICB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5ID0gbGVhc3RVc2VkRW50cnk7XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS52YWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyeSA9IG5ldyBFbnRyeSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZW50cnkua2V5ID0ga2V5O1xuICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgIG1hcFtrZXldID0gZW50cnk7XG4gIH1cblxuICByZXR1cm4gcmVtb3ZlZDtcbn07XG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHt9XG4gKi9cblxuXG5MUlVQcm90by5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciBlbnRyeSA9IHRoaXMuX21hcFtrZXldO1xuICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG5cbiAgaWYgKGVudHJ5ICE9IG51bGwpIHtcbiAgICAvLyBQdXQgdGhlIGxhdGVzdCB1c2VkIGVudHJ5IGluIHRoZSB0YWlsXG4gICAgaWYgKGVudHJ5ICE9PSBsaXN0LnRhaWwpIHtcbiAgICAgIGxpc3QucmVtb3ZlKGVudHJ5KTtcbiAgICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgIH1cblxuICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgfVxufTtcbi8qKlxuICogQ2xlYXIgdGhlIGNhY2hlXG4gKi9cblxuXG5MUlVQcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fbGlzdC5jbGVhcigpO1xuXG4gIHRoaXMuX21hcCA9IHt9O1xufTtcblxudmFyIF9kZWZhdWx0ID0gTFJVO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9MUlUuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcblxudmFyIGRlYnVnTW9kZSA9IF9jb25maWcuZGVidWdNb2RlO1xuXG52YXIgbG9nID0gZnVuY3Rpb24gKCkge307XG5cbmlmIChkZWJ1Z01vZGUgPT09IDEpIHtcbiAgbG9nID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYXJndW1lbnRzW2tdKTtcbiAgICB9XG4gIH07XG59IGVsc2UgaWYgKGRlYnVnTW9kZSA+IDEpIHtcbiAgbG9nID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzKSB7XG4gICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHNba10pO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIF9kZWZhdWx0ID0gbG9nO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9sb2cuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkcHIgPSAxOyAvLyBJZiBpbiBicm93c2VyIGVudmlyb25tZW50XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBkcHIgPSBNYXRoLm1heCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLCAxKTtcbn1cbi8qKlxuICogY29uZmln6buY6K6k6YWN572u6aG5XG4gKiBAZXhwb3J0cyB6cmVuZGVyL2NvbmZpZ1xuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiBkZWJ1Z+aXpeW/l+mAiemhue+8mmNhdGNoQnJ1c2hFeGNlcHRpb27kuLp0cnVl5LiL5pyJ5pWIXG4gKiAwIDog5LiN55Sf5oiQZGVidWfmlbDmja7vvIzlj5HluIPnlKhcbiAqIDEgOiDlvILluLjmipvlh7rvvIzosIPor5XnlKhcbiAqIDIgOiDmjqfliLblj7DovpPlh7rvvIzosIPor5XnlKhcbiAqL1xuXG5cbnZhciBkZWJ1Z01vZGUgPSAwOyAvLyByZXRpbmEg5bGP5bmV5LyY5YyWXG5cbnZhciBkZXZpY2VQaXhlbFJhdGlvID0gZHByO1xuZXhwb3J0cy5kZWJ1Z01vZGUgPSBkZWJ1Z01vZGU7XG5leHBvcnRzLmRldmljZVBpeGVsUmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0ZXh0SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci90ZXh0XCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG4vKipcbiAqIE1peGluIGZvciBkcmF3aW5nIHRleHQgaW4gYSBlbGVtZW50IGJvdW5kaW5nIHJlY3RcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9SZWN0VGV4dFxuICovXG52YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoKTtcblxudmFyIFJlY3RUZXh0ID0gZnVuY3Rpb24gKCkge307XG5cblJlY3RUZXh0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFJlY3RUZXh0LFxuXG4gIC8qKlxuICAgKiBEcmF3IHRleHQgaW4gYSByZWN0IHdpdGggc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlY3QgRGlzcGxheWFibGUgcmVjdFxuICAgKi9cbiAgZHJhd1JlY3RUZXh0OiBmdW5jdGlvbiAoY3R4LCByZWN0KSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICByZWN0ID0gc3R5bGUudGV4dFJlY3QgfHwgcmVjdDsgLy8gT3B0aW1pemUsIGF2b2lkIG5vcm1hbGl6ZSBldmVyeSB0aW1lLlxuXG4gICAgdGhpcy5fX2RpcnR5ICYmIHRleHRIZWxwZXIubm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlLCB0cnVlKTtcbiAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7IC8vIENvbnZlcnQgdG8gc3RyaW5nXG5cbiAgICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuXG4gICAgaWYgKCF0ZXh0SGVscGVyLm5lZWREcmF3VGV4dCh0ZXh0LCBzdHlsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZJWE1FXG5cblxuICAgIGN0eC5zYXZlKCk7IC8vIFRyYW5zZm9ybSByZWN0IHRvIHZpZXcgc3BhY2VcblxuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICAgIGlmICghc3R5bGUudHJhbnNmb3JtVGV4dCkge1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0bXBSZWN0LmNvcHkocmVjdCk7XG4gICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgcmVjdCA9IHRtcFJlY3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgfSAvLyB0cmFuc2Zvcm1UZXh0IGFuZCB0ZXh0Um90YXRpb24gY2FuIG5vdCBiZSB1c2VkIGF0IHRoZSBzYW1lIHRpbWUuXG5cblxuICAgIHRleHRIZWxwZXIucmVuZGVyVGV4dCh0aGlzLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gUmVjdFRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL21peGluL1JlY3RUZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vY29yZS91dGlsXCIpO1xuXG52YXIgcmV0cmlldmUyID0gX3V0aWwucmV0cmlldmUyO1xudmFyIHJldHJpZXZlMyA9IF91dGlsLnJldHJpZXZlMztcbnZhciBlYWNoID0gX3V0aWwuZWFjaDtcbnZhciBub3JtYWxpemVDc3NBcnJheSA9IF91dGlsLm5vcm1hbGl6ZUNzc0FycmF5O1xudmFyIGlzU3RyaW5nID0gX3V0aWwuaXNTdHJpbmc7XG52YXIgaXNPYmplY3QgPSBfdXRpbC5pc09iamVjdDtcblxudmFyIHRleHRDb250YWluID0gcmVxdWlyZShcIi4uLy4uL2NvbnRhaW4vdGV4dFwiKTtcblxudmFyIHJvdW5kUmVjdEhlbHBlciA9IHJlcXVpcmUoXCIuL3JvdW5kUmVjdFwiKTtcblxudmFyIGltYWdlSGVscGVyID0gcmVxdWlyZShcIi4vaW1hZ2VcIik7XG5cbi8vIFRPRE86IEhhdmUgbm90IHN1cHBvcnQgJ3N0YXJ0JywgJ2VuZCcgeWV0LlxudmFyIFZBTElEX1RFWFRfQUxJR04gPSB7XG4gIGxlZnQ6IDEsXG4gIHJpZ2h0OiAxLFxuICBjZW50ZXI6IDFcbn07XG52YXIgVkFMSURfVEVYVF9WRVJUSUNBTF9BTElHTiA9IHtcbiAgdG9wOiAxLFxuICBib3R0b206IDEsXG4gIG1pZGRsZTogMVxufTtcbi8qKlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBzdHlsZVxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gVGhlIGlucHV0IHN0eWxlLlxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSkge1xuICBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gIGVhY2goc3R5bGUucmljaCwgbm9ybWFsaXplU3R5bGUpO1xuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHN0eWxlKSB7XG4gIGlmIChzdHlsZSkge1xuICAgIHN0eWxlLmZvbnQgPSB0ZXh0Q29udGFpbi5tYWtlRm9udChzdHlsZSk7XG4gICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgICB0ZXh0QWxpZ24gPT09ICdtaWRkbGUnICYmICh0ZXh0QWxpZ24gPSAnY2VudGVyJyk7XG4gICAgc3R5bGUudGV4dEFsaWduID0gdGV4dEFsaWduID09IG51bGwgfHwgVkFMSURfVEVYVF9BTElHTlt0ZXh0QWxpZ25dID8gdGV4dEFsaWduIDogJ2xlZnQnOyAvLyBDb21wYXRpYmxlIHdpdGggdGV4dEJhc2VsaW5lLlxuXG4gICAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gfHwgc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgIHRleHRWZXJ0aWNhbEFsaWduID09PSAnY2VudGVyJyAmJiAodGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJyk7XG4gICAgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gPSB0ZXh0VmVydGljYWxBbGlnbiA9PSBudWxsIHx8IFZBTElEX1RFWFRfVkVSVElDQUxfQUxJR05bdGV4dFZlcnRpY2FsQWxpZ25dID8gdGV4dFZlcnRpY2FsQWxpZ24gOiAndG9wJztcbiAgICB2YXIgdGV4dFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcblxuICAgIGlmICh0ZXh0UGFkZGluZykge1xuICAgICAgc3R5bGUudGV4dFBhZGRpbmcgPSBub3JtYWxpemVDc3NBcnJheShzdHlsZS50ZXh0UGFkZGluZyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IHN0eWxlXG4gKiBAcGFyYW0ge09iamVjdHxib29sZWFufSBbcmVjdF0ge3gsIHksIHdpZHRoLCBoZWlnaHR9XG4gKiAgICAgICAgICAgICAgICAgIElmIHNldCBmYWxzZSwgcmVjdCB0ZXh0IGlzIG5vdCB1c2VkLlxuICovXG5cblxuZnVuY3Rpb24gcmVuZGVyVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpIHtcbiAgc3R5bGUucmljaCA/IHJlbmRlclJpY2hUZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCkgOiByZW5kZXJQbGFpblRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUGxhaW5UZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCkge1xuICB2YXIgZm9udCA9IHNldEN0eChjdHgsICdmb250Jywgc3R5bGUuZm9udCB8fCB0ZXh0Q29udGFpbi5ERUZBVUxUX0ZPTlQpO1xuICB2YXIgdGV4dFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcbiAgdmFyIGNvbnRlbnRCbG9jayA9IGhvc3RFbC5fX3RleHRDb3RlbnRCbG9jaztcblxuICBpZiAoIWNvbnRlbnRCbG9jayB8fCBob3N0RWwuX19kaXJ0eSkge1xuICAgIGNvbnRlbnRCbG9jayA9IGhvc3RFbC5fX3RleHRDb3RlbnRCbG9jayA9IHRleHRDb250YWluLnBhcnNlUGxhaW5UZXh0KHRleHQsIGZvbnQsIHRleHRQYWRkaW5nLCBzdHlsZS50cnVuY2F0ZSk7XG4gIH1cblxuICB2YXIgb3V0ZXJIZWlnaHQgPSBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQ7XG4gIHZhciB0ZXh0TGluZXMgPSBjb250ZW50QmxvY2subGluZXM7XG4gIHZhciBsaW5lSGVpZ2h0ID0gY29udGVudEJsb2NrLmxpbmVIZWlnaHQ7XG4gIHZhciBib3hQb3MgPSBnZXRCb3hQb3NpdGlvbihvdXRlckhlaWdodCwgc3R5bGUsIHJlY3QpO1xuICB2YXIgYmFzZVggPSBib3hQb3MuYmFzZVg7XG4gIHZhciBiYXNlWSA9IGJveFBvcy5iYXNlWTtcbiAgdmFyIHRleHRBbGlnbiA9IGJveFBvcy50ZXh0QWxpZ247XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IGJveFBvcy50ZXh0VmVydGljYWxBbGlnbjsgLy8gT3JpZ2luIG9mIHRleHRSb3RhdGlvbiBzaG91bGQgYmUgdGhlIGJhc2UgcG9pbnQgb2YgdGV4dCBkcmF3aW5nLlxuXG4gIGFwcGx5VGV4dFJvdGF0aW9uKGN0eCwgc3R5bGUsIHJlY3QsIGJhc2VYLCBiYXNlWSk7XG4gIHZhciBib3hZID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFkoYmFzZVksIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHZhciB0ZXh0WCA9IGJhc2VYO1xuICB2YXIgdGV4dFkgPSBib3hZO1xuICB2YXIgbmVlZERyYXdCZyA9IG5lZWREcmF3QmFja2dyb3VuZChzdHlsZSk7XG5cbiAgaWYgKG5lZWREcmF3QmcgfHwgdGV4dFBhZGRpbmcpIHtcbiAgICAvLyBDb25zaWRlciBwZXJmb3JtYW5jZSwgZG8gbm90IGNhbGwgZ2V0VGV4dFdpZHRoIHV0aWwgbmVjZXNzYXJ5LlxuICAgIHZhciB0ZXh0V2lkdGggPSB0ZXh0Q29udGFpbi5nZXRXaWR0aCh0ZXh0LCBmb250KTtcbiAgICB2YXIgb3V0ZXJXaWR0aCA9IHRleHRXaWR0aDtcbiAgICB0ZXh0UGFkZGluZyAmJiAob3V0ZXJXaWR0aCArPSB0ZXh0UGFkZGluZ1sxXSArIHRleHRQYWRkaW5nWzNdKTtcbiAgICB2YXIgYm94WCA9IHRleHRDb250YWluLmFkanVzdFRleHRYKGJhc2VYLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICAgIG5lZWREcmF3QmcgJiYgZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHN0eWxlLCBib3hYLCBib3hZLCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG5cbiAgICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICAgIHRleHRYID0gZ2V0VGV4dFhGb3JQYWRkaW5nKGJhc2VYLCB0ZXh0QWxpZ24sIHRleHRQYWRkaW5nKTtcbiAgICAgIHRleHRZICs9IHRleHRQYWRkaW5nWzBdO1xuICAgIH1cbiAgfVxuXG4gIHNldEN0eChjdHgsICd0ZXh0QWxpZ24nLCB0ZXh0QWxpZ24gfHwgJ2xlZnQnKTsgLy8gRm9yY2UgYmFzZWxpbmUgdG8gYmUgXCJtaWRkbGVcIi4gT3RoZXJ3aXNlLCBpZiB1c2luZyBcInRvcFwiLCB0aGVcbiAgLy8gdGV4dCB3aWxsIG9mZnNldCBkb3dud2FyZCBhIGxpdHRsZSBiaXQgaW4gZm9udCBcIk1pY3Jvc29mdCBZYUhlaVwiLlxuXG4gIHNldEN0eChjdHgsICd0ZXh0QmFzZWxpbmUnLCAnbWlkZGxlJyk7IC8vIEFsd2F5cyBzZXQgc2hhZG93Qmx1ciBhbmQgc2hhZG93T2Zmc2V0IHRvIGF2b2lkIGxlYWsgZnJvbSBkaXNwbGF5YWJsZS5cblxuICBzZXRDdHgoY3R4LCAnc2hhZG93Qmx1cicsIHN0eWxlLnRleHRTaGFkb3dCbHVyIHx8IDApO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93Q29sb3InLCBzdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgJ3RyYW5zcGFyZW50Jyk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRYJywgc3R5bGUudGV4dFNoYWRvd09mZnNldFggfHwgMCk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRZJywgc3R5bGUudGV4dFNoYWRvd09mZnNldFkgfHwgMCk7IC8vIGB0ZXh0QmFzZWxpbmVgIGlzIHNldCBhcyAnbWlkZGxlJy5cblxuICB0ZXh0WSArPSBsaW5lSGVpZ2h0IC8gMjtcbiAgdmFyIHRleHRTdHJva2VXaWR0aCA9IHN0eWxlLnRleHRTdHJva2VXaWR0aDtcbiAgdmFyIHRleHRTdHJva2UgPSBnZXRTdHJva2Uoc3R5bGUudGV4dFN0cm9rZSwgdGV4dFN0cm9rZVdpZHRoKTtcbiAgdmFyIHRleHRGaWxsID0gZ2V0RmlsbChzdHlsZS50ZXh0RmlsbCk7XG5cbiAgaWYgKHRleHRTdHJva2UpIHtcbiAgICBzZXRDdHgoY3R4LCAnbGluZVdpZHRoJywgdGV4dFN0cm9rZVdpZHRoKTtcbiAgICBzZXRDdHgoY3R4LCAnc3Ryb2tlU3R5bGUnLCB0ZXh0U3Ryb2tlKTtcbiAgfVxuXG4gIGlmICh0ZXh0RmlsbCkge1xuICAgIHNldEN0eChjdHgsICdmaWxsU3R5bGUnLCB0ZXh0RmlsbCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIEZpbGwgYWZ0ZXIgc3Ryb2tlIHNvIHRoZSBvdXRsaW5lIHdpbGwgbm90IGNvdmVyIHRoZSBtYWluIHBhcnQuXG4gICAgdGV4dFN0cm9rZSAmJiBjdHguc3Ryb2tlVGV4dCh0ZXh0TGluZXNbaV0sIHRleHRYLCB0ZXh0WSk7XG4gICAgdGV4dEZpbGwgJiYgY3R4LmZpbGxUZXh0KHRleHRMaW5lc1tpXSwgdGV4dFgsIHRleHRZKTtcbiAgICB0ZXh0WSArPSBsaW5lSGVpZ2h0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJpY2hUZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCkge1xuICB2YXIgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrO1xuXG4gIGlmICghY29udGVudEJsb2NrIHx8IGhvc3RFbC5fX2RpcnR5KSB7XG4gICAgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrID0gdGV4dENvbnRhaW4ucGFyc2VSaWNoVGV4dCh0ZXh0LCBzdHlsZSk7XG4gIH1cblxuICBkcmF3UmljaFRleHQoaG9zdEVsLCBjdHgsIGNvbnRlbnRCbG9jaywgc3R5bGUsIHJlY3QpO1xufVxuXG5mdW5jdGlvbiBkcmF3UmljaFRleHQoaG9zdEVsLCBjdHgsIGNvbnRlbnRCbG9jaywgc3R5bGUsIHJlY3QpIHtcbiAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRlbnRCbG9jay53aWR0aDtcbiAgdmFyIG91dGVyV2lkdGggPSBjb250ZW50QmxvY2sub3V0ZXJXaWR0aDtcbiAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICB2YXIgdGV4dFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcbiAgdmFyIGJveFBvcyA9IGdldEJveFBvc2l0aW9uKG91dGVySGVpZ2h0LCBzdHlsZSwgcmVjdCk7XG4gIHZhciBiYXNlWCA9IGJveFBvcy5iYXNlWDtcbiAgdmFyIGJhc2VZID0gYm94UG9zLmJhc2VZO1xuICB2YXIgdGV4dEFsaWduID0gYm94UG9zLnRleHRBbGlnbjtcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gYm94UG9zLnRleHRWZXJ0aWNhbEFsaWduOyAvLyBPcmlnaW4gb2YgdGV4dFJvdGF0aW9uIHNob3VsZCBiZSB0aGUgYmFzZSBwb2ludCBvZiB0ZXh0IGRyYXdpbmcuXG5cbiAgYXBwbHlUZXh0Um90YXRpb24oY3R4LCBzdHlsZSwgcmVjdCwgYmFzZVgsIGJhc2VZKTtcbiAgdmFyIGJveFggPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WChiYXNlWCwgb3V0ZXJXaWR0aCwgdGV4dEFsaWduKTtcbiAgdmFyIGJveFkgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WShiYXNlWSwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgdmFyIHhMZWZ0ID0gYm94WDtcbiAgdmFyIGxpbmVUb3AgPSBib3hZO1xuXG4gIGlmICh0ZXh0UGFkZGluZykge1xuICAgIHhMZWZ0ICs9IHRleHRQYWRkaW5nWzNdO1xuICAgIGxpbmVUb3AgKz0gdGV4dFBhZGRpbmdbMF07XG4gIH1cblxuICB2YXIgeFJpZ2h0ID0geExlZnQgKyBjb250ZW50V2lkdGg7XG4gIG5lZWREcmF3QmFja2dyb3VuZChzdHlsZSkgJiYgZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHN0eWxlLCBib3hYLCBib3hZLCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QmxvY2subGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGNvbnRlbnRCbG9jay5saW5lc1tpXTtcbiAgICB2YXIgdG9rZW5zID0gbGluZS50b2tlbnM7XG4gICAgdmFyIHRva2VuQ291bnQgPSB0b2tlbnMubGVuZ3RoO1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gbGluZS5saW5lSGVpZ2h0O1xuICAgIHZhciB1c2VkV2lkdGggPSBsaW5lLndpZHRoO1xuICAgIHZhciBsZWZ0SW5kZXggPSAwO1xuICAgIHZhciBsaW5lWExlZnQgPSB4TGVmdDtcbiAgICB2YXIgbGluZVhSaWdodCA9IHhSaWdodDtcbiAgICB2YXIgcmlnaHRJbmRleCA9IHRva2VuQ291bnQgLSAxO1xuICAgIHZhciB0b2tlbjtcblxuICAgIHdoaWxlIChsZWZ0SW5kZXggPCB0b2tlbkNvdW50ICYmICh0b2tlbiA9IHRva2Vuc1tsZWZ0SW5kZXhdLCAhdG9rZW4udGV4dEFsaWduIHx8IHRva2VuLnRleHRBbGlnbiA9PT0gJ2xlZnQnKSkge1xuICAgICAgcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCBsaW5lWExlZnQsICdsZWZ0Jyk7XG4gICAgICB1c2VkV2lkdGggLT0gdG9rZW4ud2lkdGg7XG4gICAgICBsaW5lWExlZnQgKz0gdG9rZW4ud2lkdGg7XG4gICAgICBsZWZ0SW5kZXgrKztcbiAgICB9XG5cbiAgICB3aGlsZSAocmlnaHRJbmRleCA+PSAwICYmICh0b2tlbiA9IHRva2Vuc1tyaWdodEluZGV4XSwgdG9rZW4udGV4dEFsaWduID09PSAncmlnaHQnKSkge1xuICAgICAgcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCBsaW5lWFJpZ2h0LCAncmlnaHQnKTtcbiAgICAgIHVzZWRXaWR0aCAtPSB0b2tlbi53aWR0aDtcbiAgICAgIGxpbmVYUmlnaHQgLT0gdG9rZW4ud2lkdGg7XG4gICAgICByaWdodEluZGV4LS07XG4gICAgfSAvLyBUaGUgb3RoZXIgdG9rZW5zIGFyZSBwbGFjZWQgYXMgdGV4dEFsaWduICdjZW50ZXInIGlmIHRoZXJlIGlzIGVub3VnaCBzcGFjZS5cblxuXG4gICAgbGluZVhMZWZ0ICs9IChjb250ZW50V2lkdGggLSAobGluZVhMZWZ0IC0geExlZnQpIC0gKHhSaWdodCAtIGxpbmVYUmlnaHQpIC0gdXNlZFdpZHRoKSAvIDI7XG5cbiAgICB3aGlsZSAobGVmdEluZGV4IDw9IHJpZ2h0SW5kZXgpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2xlZnRJbmRleF07IC8vIENvbnNpZGVyIHdpZHRoIHNwZWNpZmllZCBieSB1c2VyLCB1c2UgJ2NlbnRlcicgcmF0aGVyIHRoYW4gJ2xlZnQnLlxuXG4gICAgICBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIGxpbmVYTGVmdCArIHRva2VuLndpZHRoIC8gMiwgJ2NlbnRlcicpO1xuICAgICAgbGluZVhMZWZ0ICs9IHRva2VuLndpZHRoO1xuICAgICAgbGVmdEluZGV4Kys7XG4gICAgfVxuXG4gICAgbGluZVRvcCArPSBsaW5lSGVpZ2h0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VGV4dFJvdGF0aW9uKGN0eCwgc3R5bGUsIHJlY3QsIHgsIHkpIHtcbiAgLy8gdGV4dFJvdGF0aW9uIG9ubHkgYXBwbHkgaW4gUmVjdFRleHQuXG4gIGlmIChyZWN0ICYmIHN0eWxlLnRleHRSb3RhdGlvbikge1xuICAgIHZhciBvcmlnaW4gPSBzdHlsZS50ZXh0T3JpZ2luO1xuXG4gICAgaWYgKG9yaWdpbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHggPSByZWN0LndpZHRoIC8gMiArIHJlY3QueDtcbiAgICAgIHkgPSByZWN0LmhlaWdodCAvIDIgKyByZWN0Lnk7XG4gICAgfSBlbHNlIGlmIChvcmlnaW4pIHtcbiAgICAgIHggPSBvcmlnaW5bMF0gKyByZWN0Lng7XG4gICAgICB5ID0gb3JpZ2luWzFdICsgcmVjdC55O1xuICAgIH1cblxuICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7IC8vIFBvc2l0aXZlOiBhbnRpY2xvY2t3aXNlXG5cbiAgICBjdHgucm90YXRlKC1zdHlsZS50ZXh0Um90YXRpb24pO1xuICAgIGN0eC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIHgsIHRleHRBbGlnbikge1xuICB2YXIgdG9rZW5TdHlsZSA9IHN0eWxlLnJpY2hbdG9rZW4uc3R5bGVOYW1lXSB8fCB7fTsgLy8gJ2N0eC50ZXh0QmFzZWxpbmUnIGlzIGFsd2F5cyBzZXQgYXMgJ21pZGRsZScsIGZvciBzYWtlIG9mXG4gIC8vIHRoZSBiaWFzIG9mIFwiTWljcm9zb2Z0IFlhSGVpXCIuXG5cbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gdG9rZW4udGV4dFZlcnRpY2FsQWxpZ247XG4gIHZhciB5ID0gbGluZVRvcCArIGxpbmVIZWlnaHQgLyAyO1xuXG4gIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICB5ID0gbGluZVRvcCArIHRva2VuLmhlaWdodCAvIDI7XG4gIH0gZWxzZSBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSA9IGxpbmVUb3AgKyBsaW5lSGVpZ2h0IC0gdG9rZW4uaGVpZ2h0IC8gMjtcbiAgfVxuXG4gICF0b2tlbi5pc0xpbmVIb2xkZXIgJiYgbmVlZERyYXdCYWNrZ3JvdW5kKHRva2VuU3R5bGUpICYmIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCB0b2tlblN0eWxlLCB0ZXh0QWxpZ24gPT09ICdyaWdodCcgPyB4IC0gdG9rZW4ud2lkdGggOiB0ZXh0QWxpZ24gPT09ICdjZW50ZXInID8geCAtIHRva2VuLndpZHRoIC8gMiA6IHgsIHkgLSB0b2tlbi5oZWlnaHQgLyAyLCB0b2tlbi53aWR0aCwgdG9rZW4uaGVpZ2h0KTtcbiAgdmFyIHRleHRQYWRkaW5nID0gdG9rZW4udGV4dFBhZGRpbmc7XG5cbiAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgeCA9IGdldFRleHRYRm9yUGFkZGluZyh4LCB0ZXh0QWxpZ24sIHRleHRQYWRkaW5nKTtcbiAgICB5IC09IHRva2VuLmhlaWdodCAvIDIgLSB0ZXh0UGFkZGluZ1syXSAtIHRva2VuLnRleHRIZWlnaHQgLyAyO1xuICB9XG5cbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0JsdXInLCByZXRyaWV2ZTModG9rZW5TdHlsZS50ZXh0U2hhZG93Qmx1ciwgc3R5bGUudGV4dFNoYWRvd0JsdXIsIDApKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0NvbG9yJywgdG9rZW5TdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgc3R5bGUudGV4dFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCcpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WCcsIHJldHJpZXZlMyh0b2tlblN0eWxlLnRleHRTaGFkb3dPZmZzZXRYLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WCwgMCkpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WScsIHJldHJpZXZlMyh0b2tlblN0eWxlLnRleHRTaGFkb3dPZmZzZXRZLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSwgMCkpO1xuICBzZXRDdHgoY3R4LCAndGV4dEFsaWduJywgdGV4dEFsaWduKTsgLy8gRm9yY2UgYmFzZWxpbmUgdG8gYmUgXCJtaWRkbGVcIi4gT3RoZXJ3aXNlLCBpZiB1c2luZyBcInRvcFwiLCB0aGVcbiAgLy8gdGV4dCB3aWxsIG9mZnNldCBkb3dud2FyZCBhIGxpdHRsZSBiaXQgaW4gZm9udCBcIk1pY3Jvc29mdCBZYUhlaVwiLlxuXG4gIHNldEN0eChjdHgsICd0ZXh0QmFzZWxpbmUnLCAnbWlkZGxlJyk7XG4gIHNldEN0eChjdHgsICdmb250JywgdG9rZW4uZm9udCB8fCB0ZXh0Q29udGFpbi5ERUZBVUxUX0ZPTlQpO1xuICB2YXIgdGV4dFN0cm9rZSA9IGdldFN0cm9rZSh0b2tlblN0eWxlLnRleHRTdHJva2UgfHwgc3R5bGUudGV4dFN0cm9rZSwgdGV4dFN0cm9rZVdpZHRoKTtcbiAgdmFyIHRleHRGaWxsID0gZ2V0RmlsbCh0b2tlblN0eWxlLnRleHRGaWxsIHx8IHN0eWxlLnRleHRGaWxsKTtcbiAgdmFyIHRleHRTdHJva2VXaWR0aCA9IHJldHJpZXZlMih0b2tlblN0eWxlLnRleHRTdHJva2VXaWR0aCwgc3R5bGUudGV4dFN0cm9rZVdpZHRoKTsgLy8gRmlsbCBhZnRlciBzdHJva2Ugc28gdGhlIG91dGxpbmUgd2lsbCBub3QgY292ZXIgdGhlIG1haW4gcGFydC5cblxuICBpZiAodGV4dFN0cm9rZSkge1xuICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRTdHJva2UpO1xuICAgIGN0eC5zdHJva2VUZXh0KHRva2VuLnRleHQsIHgsIHkpO1xuICB9XG5cbiAgaWYgKHRleHRGaWxsKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2ZpbGxTdHlsZScsIHRleHRGaWxsKTtcbiAgICBjdHguZmlsbFRleHQodG9rZW4udGV4dCwgeCwgeSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmVlZERyYXdCYWNrZ3JvdW5kKHN0eWxlKSB7XG4gIHJldHVybiBzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yIHx8IHN0eWxlLnRleHRCb3JkZXJXaWR0aCAmJiBzdHlsZS50ZXh0Qm9yZGVyQ29sb3I7XG59IC8vIHN0eWxlOiB7dGV4dEJhY2tncm91bmRDb2xvciwgdGV4dEJvcmRlcldpZHRoLCB0ZXh0Qm9yZGVyQ29sb3IsIHRleHRCb3JkZXJSYWRpdXN9XG4vLyBzaGFwZToge3gsIHksIHdpZHRoLCBoZWlnaHR9XG5cblxuZnVuY3Rpb24gZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHN0eWxlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciB0ZXh0QmFja2dyb3VuZENvbG9yID0gc3R5bGUudGV4dEJhY2tncm91bmRDb2xvcjtcbiAgdmFyIHRleHRCb3JkZXJXaWR0aCA9IHN0eWxlLnRleHRCb3JkZXJXaWR0aDtcbiAgdmFyIHRleHRCb3JkZXJDb2xvciA9IHN0eWxlLnRleHRCb3JkZXJDb2xvcjtcbiAgdmFyIGlzUGxhaW5CZyA9IGlzU3RyaW5nKHRleHRCYWNrZ3JvdW5kQ29sb3IpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93Qmx1cicsIHN0eWxlLnRleHRCb3hTaGFkb3dCbHVyIHx8IDApO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93Q29sb3InLCBzdHlsZS50ZXh0Qm94U2hhZG93Q29sb3IgfHwgJ3RyYW5zcGFyZW50Jyk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRYJywgc3R5bGUudGV4dEJveFNoYWRvd09mZnNldFggfHwgMCk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRZJywgc3R5bGUudGV4dEJveFNoYWRvd09mZnNldFkgfHwgMCk7XG5cbiAgaWYgKGlzUGxhaW5CZyB8fCB0ZXh0Qm9yZGVyV2lkdGggJiYgdGV4dEJvcmRlckNvbG9yKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIHZhciB0ZXh0Qm9yZGVyUmFkaXVzID0gc3R5bGUudGV4dEJvcmRlclJhZGl1cztcblxuICAgIGlmICghdGV4dEJvcmRlclJhZGl1cykge1xuICAgICAgY3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdW5kUmVjdEhlbHBlci5idWlsZFBhdGgoY3R4LCB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHI6IHRleHRCb3JkZXJSYWRpdXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxuXG4gIGlmIChpc1BsYWluQmcpIHtcbiAgICBzZXRDdHgoY3R4LCAnZmlsbFN0eWxlJywgdGV4dEJhY2tncm91bmRDb2xvcik7XG4gICAgY3R4LmZpbGwoKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh0ZXh0QmFja2dyb3VuZENvbG9yKSkge1xuICAgIHZhciBpbWFnZSA9IHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2U7XG4gICAgaW1hZ2UgPSBpbWFnZUhlbHBlci5jcmVhdGVPclVwZGF0ZUltYWdlKGltYWdlLCBudWxsLCBob3N0RWwsIG9uQmdJbWFnZUxvYWRlZCwgdGV4dEJhY2tncm91bmRDb2xvcik7XG5cbiAgICBpZiAoaW1hZ2UgJiYgaW1hZ2VIZWxwZXIuaXNJbWFnZVJlYWR5KGltYWdlKSkge1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRleHRCb3JkZXJXaWR0aCAmJiB0ZXh0Qm9yZGVyQ29sb3IpIHtcbiAgICBzZXRDdHgoY3R4LCAnbGluZVdpZHRoJywgdGV4dEJvcmRlcldpZHRoKTtcbiAgICBzZXRDdHgoY3R4LCAnc3Ryb2tlU3R5bGUnLCB0ZXh0Qm9yZGVyQ29sb3IpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkJnSW1hZ2VMb2FkZWQoaW1hZ2UsIHRleHRCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgLy8gUmVwbGFjZSBpbWFnZSwgc28gdGhhdCBgY29udGFpbi90ZXh0LmpzI3BhcnNlUmljaFRleHRgXG4gIC8vIHdpbGwgZ2V0IGNvcnJlY3QgcmVzdWx0IGluIG5leHQgdGljay5cbiAgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZSA9IGltYWdlO1xufVxuXG5mdW5jdGlvbiBnZXRCb3hQb3NpdGlvbihibG9ja0hlaWh0LCBzdHlsZSwgcmVjdCkge1xuICB2YXIgYmFzZVggPSBzdHlsZS54IHx8IDA7XG4gIHZhciBiYXNlWSA9IHN0eWxlLnkgfHwgMDtcbiAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ247IC8vIFRleHQgcG9zaXRpb24gcmVwcmVzZW50ZWQgYnkgY29vcmRcblxuICBpZiAocmVjdCkge1xuICAgIHZhciB0ZXh0UG9zaXRpb24gPSBzdHlsZS50ZXh0UG9zaXRpb247XG5cbiAgICBpZiAodGV4dFBvc2l0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIC8vIFBlcmNlbnRcbiAgICAgIGJhc2VYID0gcmVjdC54ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblswXSwgcmVjdC53aWR0aCk7XG4gICAgICBiYXNlWSA9IHJlY3QueSArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMV0sIHJlY3QuaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlcyA9IHRleHRDb250YWluLmFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIHN0eWxlLnRleHREaXN0YW5jZSk7XG4gICAgICBiYXNlWCA9IHJlcy54O1xuICAgICAgYmFzZVkgPSByZXMueTsgLy8gRGVmYXVsdCBhbGlnbiBhbmQgYmFzZWxpbmUgd2hlbiBoYXMgdGV4dFBvc2l0aW9uXG5cbiAgICAgIHRleHRBbGlnbiA9IHRleHRBbGlnbiB8fCByZXMudGV4dEFsaWduO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSB0ZXh0VmVydGljYWxBbGlnbiB8fCByZXMudGV4dFZlcnRpY2FsQWxpZ247XG4gICAgfSAvLyB0ZXh0T2Zmc2V0IGlzIG9ubHkgc3VwcG9ydCBpbiBSZWN0VGV4dCwgb3RoZXJ3aXNlXG4gICAgLy8gd2UgaGF2ZSB0byBhZGp1c3QgYm91bmRpbmdSZWN0IGZvciB0ZXh0T2Zmc2V0LlxuXG5cbiAgICB2YXIgdGV4dE9mZnNldCA9IHN0eWxlLnRleHRPZmZzZXQ7XG5cbiAgICBpZiAodGV4dE9mZnNldCkge1xuICAgICAgYmFzZVggKz0gdGV4dE9mZnNldFswXTtcbiAgICAgIGJhc2VZICs9IHRleHRPZmZzZXRbMV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiYXNlWDogYmFzZVgsXG4gICAgYmFzZVk6IGJhc2VZLFxuICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgIHRleHRWZXJ0aWNhbEFsaWduOiB0ZXh0VmVydGljYWxBbGlnblxuICB9O1xufVxuXG5mdW5jdGlvbiBzZXRDdHgoY3R4LCBwcm9wLCB2YWx1ZSkge1xuICAvLyBGSVhNRSA/Pz8gcGVyZm9ybWFuY2UgdHJ5XG4gIC8vIGlmIChjdHguX19jdXJyZW50VmFsdWVzW3Byb3BdICE9PSB2YWx1ZSkge1xuICAvLyBjdHhbcHJvcF0gPSBjdHguX19jdXJyZW50VmFsdWVzW3Byb3BdID0gdmFsdWU7XG4gIGN0eFtwcm9wXSA9IHZhbHVlOyAvLyB9XG5cbiAgcmV0dXJuIGN0eFtwcm9wXTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJva2VdIElmIHNwZWNpZmllZCwgZG8gbm90IGNoZWNrIHN0eWxlLnRleHRTdHJva2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xpbmVXaWR0aF0gSWYgc3BlY2lmaWVkLCBkbyBub3QgY2hlY2sgc3R5bGUudGV4dFN0cm9rZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHlsZVxuICovXG5cblxuZnVuY3Rpb24gZ2V0U3Ryb2tlKHN0cm9rZSwgbGluZVdpZHRoKSB7XG4gIHJldHVybiBzdHJva2UgPT0gbnVsbCB8fCBsaW5lV2lkdGggPD0gMCB8fCBzdHJva2UgPT09ICd0cmFuc3BhcmVudCcgfHwgc3Ryb2tlID09PSAnbm9uZScgPyBudWxsIC8vIFRPRE8gcGF0dGVybiBhbmQgZ3JhZGllbnQ/XG4gIDogc3Ryb2tlLmltYWdlIHx8IHN0cm9rZS5jb2xvclN0b3BzID8gJyMwMDAnIDogc3Ryb2tlO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxsKGZpbGwpIHtcbiAgcmV0dXJuIGZpbGwgPT0gbnVsbCB8fCBmaWxsID09PSAnbm9uZScgPyBudWxsIC8vIFRPRE8gcGF0dGVybiBhbmQgZ3JhZGllbnQ/XG4gIDogZmlsbC5pbWFnZSB8fCBmaWxsLmNvbG9yU3RvcHMgPyAnIzAwMCcgOiBmaWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBlcmNlbnQodmFsdWUsIG1heFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbHVlLmxhc3RJbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogbWF4VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0WEZvclBhZGRpbmcoeCwgdGV4dEFsaWduLCB0ZXh0UGFkZGluZykge1xuICByZXR1cm4gdGV4dEFsaWduID09PSAncmlnaHQnID8geCAtIHRleHRQYWRkaW5nWzFdIDogdGV4dEFsaWduID09PSAnY2VudGVyJyA/IHggKyB0ZXh0UGFkZGluZ1szXSAvIDIgLSB0ZXh0UGFkZGluZ1sxXSAvIDIgOiB4ICsgdGV4dFBhZGRpbmdbM107XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0eWxlfSBzdHlsZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIG5lZWREcmF3VGV4dCh0ZXh0LCBzdHlsZSkge1xuICByZXR1cm4gdGV4dCAhPSBudWxsICYmICh0ZXh0IHx8IHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHwgc3R5bGUudGV4dEJvcmRlcldpZHRoICYmIHN0eWxlLnRleHRCb3JkZXJDb2xvciB8fCBzdHlsZS50ZXh0UGFkZGluZyk7XG59XG5cbmV4cG9ydHMubm9ybWFsaXplVGV4dFN0eWxlID0gbm9ybWFsaXplVGV4dFN0eWxlO1xuZXhwb3J0cy5yZW5kZXJUZXh0ID0gcmVuZGVyVGV4dDtcbmV4cG9ydHMuZ2V0U3Ryb2tlID0gZ2V0U3Ryb2tlO1xuZXhwb3J0cy5nZXRGaWxsID0gZ2V0RmlsbDtcbmV4cG9ydHMubmVlZERyYXdUZXh0ID0gbmVlZERyYXdUZXh0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci90ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9oZWxwZXIvaW1hZ2VcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBnZXRDb250ZXh0ID0gX3V0aWwuZ2V0Q29udGV4dDtcbnZhciBleHRlbmQgPSBfdXRpbC5leHRlbmQ7XG52YXIgcmV0cmlldmUyID0gX3V0aWwucmV0cmlldmUyO1xudmFyIHJldHJpZXZlMyA9IF91dGlsLnJldHJpZXZlMztcbnZhciB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xudmFyIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG52YXIgVEVYVF9DQUNIRV9NQVggPSA1MDAwO1xudmFyIFNUWUxFX1JFRyA9IC9cXHsoW2EtekEtWjAtOV9dKylcXHwoW159XSopXFx9L2c7XG52YXIgREVGQVVMVF9GT05UID0gJzEycHggc2Fucy1zZXJpZic7IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cbnZhciBtZXRob2RzID0ge307XG5cbmZ1bmN0aW9uICRvdmVycmlkZShuYW1lLCBmbikge1xuICBtZXRob2RzW25hbWVdID0gZm47XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7bnVtYmVyfSB3aWR0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0V2lkdGgodGV4dCwgZm9udCkge1xuICBmb250ID0gZm9udCB8fCBERUZBVUxUX0ZPTlQ7XG4gIHZhciBrZXkgPSB0ZXh0ICsgJzonICsgZm9udDtcblxuICBpZiAodGV4dFdpZHRoQ2FjaGVba2V5XSkge1xuICAgIHJldHVybiB0ZXh0V2lkdGhDYWNoZVtrZXldO1xuICB9XG5cbiAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIHdpZHRoID0gMDtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyB0ZXh0Q29udGFpbi5tZWFzdXJlVGV4dCBtYXkgYmUgb3ZlcnJpZGVkIGluIFNWRyBvciBWTUxcbiAgICB3aWR0aCA9IE1hdGgubWF4KG1lYXN1cmVUZXh0KHRleHRMaW5lc1tpXSwgZm9udCkud2lkdGgsIHdpZHRoKTtcbiAgfVxuXG4gIGlmICh0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPiBURVhUX0NBQ0hFX01BWCkge1xuICAgIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG4gICAgdGV4dFdpZHRoQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIHRleHRXaWR0aENhY2hlQ291bnRlcisrO1xuICB0ZXh0V2lkdGhDYWNoZVtrZXldID0gd2lkdGg7XG4gIHJldHVybiB3aWR0aDtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRBbGlnbj0nbGVmdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRWZXJ0aWNhbEFsaWduPSd0b3AnXVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW3RleHRQYWRkaW5nXVxuICogQHBhcmFtIHtPYmplY3R9IFtyaWNoXVxuICogQHBhcmFtIHtPYmplY3R9IFt0cnVuY2F0ZV1cbiAqIEByZXR1cm4ge09iamVjdH0ge3gsIHksIHdpZHRoLCBoZWlnaHQsIGxpbmVIZWlnaHR9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHJpY2gsIHRydW5jYXRlKSB7XG4gIHJldHVybiByaWNoID8gZ2V0UmljaFRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCByaWNoLCB0cnVuY2F0ZSkgOiBnZXRQbGFpblRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCB0cnVuY2F0ZSk7XG59XG5cbmZ1bmN0aW9uIGdldFBsYWluVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHRydW5jYXRlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSBwYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCB0ZXh0UGFkZGluZywgdHJ1bmNhdGUpO1xuICB2YXIgb3V0ZXJXaWR0aCA9IGdldFdpZHRoKHRleHQsIGZvbnQpO1xuXG4gIGlmICh0ZXh0UGFkZGluZykge1xuICAgIG91dGVyV2lkdGggKz0gdGV4dFBhZGRpbmdbMV0gKyB0ZXh0UGFkZGluZ1szXTtcbiAgfVxuXG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHggPSBhZGp1c3RUZXh0WCgwLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICB2YXIgeSA9IGFkanVzdFRleHRZKDAsIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHZhciByZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCh4LCB5LCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG4gIHJlY3QubGluZUhlaWdodCA9IGNvbnRlbnRCbG9jay5saW5lSGVpZ2h0O1xuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0UmljaFRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCByaWNoLCB0cnVuY2F0ZSkge1xuICB2YXIgY29udGVudEJsb2NrID0gcGFyc2VSaWNoVGV4dCh0ZXh0LCB7XG4gICAgcmljaDogcmljaCxcbiAgICB0cnVuY2F0ZTogdHJ1bmNhdGUsXG4gICAgZm9udDogZm9udCxcbiAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICB0ZXh0UGFkZGluZzogdGV4dFBhZGRpbmdcbiAgfSk7XG4gIHZhciBvdXRlcldpZHRoID0gY29udGVudEJsb2NrLm91dGVyV2lkdGg7XG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHggPSBhZGp1c3RUZXh0WCgwLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICB2YXIgeSA9IGFkanVzdFRleHRZKDAsIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHgsIHksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0QWxpZ249J2xlZnQnXVxuICogQHJldHVybiB7bnVtYmVyfSBBZGp1c3RlZCB4LlxuICovXG5cblxuZnVuY3Rpb24gYWRqdXN0VGV4dFgoeCwgd2lkdGgsIHRleHRBbGlnbikge1xuICAvLyBGSVhNRSBSaWdodCB0byBsZWZ0IGxhbmd1YWdlXG4gIGlmICh0ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09IHdpZHRoIC8gMjtcbiAgfVxuXG4gIHJldHVybiB4O1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0VmVydGljYWxBbGlnbj0ndG9wJ11cbiAqIEByZXR1cm4ge251bWJlcn0gQWRqdXN0ZWQgeS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRleHRZKHksIGhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pIHtcbiAgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnbWlkZGxlJykge1xuICAgIHkgLT0gaGVpZ2h0IC8gMjtcbiAgfSBlbHNlIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5IC09IGhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB5O1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0aXJuZ30gdGV4dFBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICogQHJldHVybiB7T2JqZWN0fSB7eCwgeSwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIGRpc3RhbmNlKSB7XG4gIHZhciB4ID0gcmVjdC54O1xuICB2YXIgeSA9IHJlY3QueTtcbiAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9ICd0b3AnO1xuXG4gIHN3aXRjaCAodGV4dFBvc2l0aW9uKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICB4IC09IGRpc3RhbmNlO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHggKz0gZGlzdGFuY2UgKyB3aWR0aDtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgLT0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgKz0gaGVpZ2h0ICsgZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVMZWZ0JzpcbiAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVSaWdodCc6XG4gICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlVG9wJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVCb3R0b20nOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5ICs9IGhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVUb3BMZWZ0JzpcbiAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVUb3BSaWdodCc6XG4gICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlQm90dG9tTGVmdCc6XG4gICAgICB4ICs9IGRpc3RhbmNlO1xuICAgICAgeSArPSBoZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZUJvdHRvbVJpZ2h0JzpcbiAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gIH07XG59XG4vKipcbiAqIFNob3cgZWxsaXBzaXMgaWYgb3ZlcmZsb3cuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRhaW5lcldpZHRoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gW2VsbGlwc2lzPScuLi4nXVxuICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMubWF4SXRlcmF0aW9ucz0zXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5taW5DaGFyPTBdIElmIHRydW5jYXRlIHJlc3VsdCBhcmUgbGVzc1xuICogICAgICAgICAgICAgICAgICB0aGVuIG1pbkNoYXIsIGVsbGlwc2lzIHdpbGwgbm90IHNob3csIHdoaWNoIGlzXG4gKiAgICAgICAgICAgICAgICAgIGJldHRlciBmb3IgdXNlciBoaW50IGluIHNvbWUgY2FzZXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLnBsYWNlaG9sZGVyPScnXSBXaGVuIGFsbCB0cnVuY2F0ZWQsIHVzZSB0aGUgcGxhY2Vob2xkZXIuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiB0cnVuY2F0ZVRleHQodGV4dCwgY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuICBvcHRpb25zID0gcHJlcGFyZVRydW5jYXRlT3B0aW9ucyhjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpOyAvLyBGSVhNRVxuICAvLyBJdCBpcyBub3QgYXBwcm9wcmlhdGUgdGhhdCBldmVyeSBsaW5lIGhhcyAnLi4uJyB3aGVuIHRydW5jYXRlIG11bHRpcGxlIGxpbmVzLlxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0ZXh0TGluZXNbaV0gPSB0cnVuY2F0ZVNpbmdsZUxpbmUodGV4dExpbmVzW2ldLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB0ZXh0TGluZXMuam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUcnVuY2F0ZU9wdGlvbnMoY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICBvcHRpb25zLmZvbnQgPSBmb250O1xuICB2YXIgZWxsaXBzaXMgPSByZXRyaWV2ZTIoZWxsaXBzaXMsICcuLi4nKTtcbiAgb3B0aW9ucy5tYXhJdGVyYXRpb25zID0gcmV0cmlldmUyKG9wdGlvbnMubWF4SXRlcmF0aW9ucywgMik7XG4gIHZhciBtaW5DaGFyID0gb3B0aW9ucy5taW5DaGFyID0gcmV0cmlldmUyKG9wdGlvbnMubWluQ2hhciwgMCk7IC8vIEZJWE1FXG4gIC8vIE90aGVyIGxhbmd1YWdlcz9cblxuICBvcHRpb25zLmNuQ2hhcldpZHRoID0gZ2V0V2lkdGgoJ+WbvScsIGZvbnQpOyAvLyBGSVhNRVxuICAvLyBDb25zaWRlciBwcm9wb3J0aW9uYWwgZm9udD9cblxuICB2YXIgYXNjQ2hhcldpZHRoID0gb3B0aW9ucy5hc2NDaGFyV2lkdGggPSBnZXRXaWR0aCgnYScsIGZvbnQpO1xuICBvcHRpb25zLnBsYWNlaG9sZGVyID0gcmV0cmlldmUyKG9wdGlvbnMucGxhY2Vob2xkZXIsICcnKTsgLy8gRXhhbXBsZSAxOiBtaW5DaGFyOiAzLCB0ZXh0OiAnYXNkZnp4Y3YnLCB0cnVuY2F0ZSByZXN1bHQ6ICdhc2RmJywgYnV0IG5vdDogJ2EuLi4nLlxuICAvLyBFeGFtcGxlIDI6IG1pbkNoYXI6IDMsIHRleHQ6ICfnu7TluqYnLCB0cnVuY2F0ZSByZXN1bHQ6ICfnu7QnLCBidXQgbm90OiAnLi4uJy5cblxuICB2YXIgY29udGVudFdpZHRoID0gY29udGFpbmVyV2lkdGggPSBNYXRoLm1heCgwLCBjb250YWluZXJXaWR0aCAtIDEpOyAvLyBSZXNlcnZlIHNvbWUgZ2FwLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluQ2hhciAmJiBjb250ZW50V2lkdGggPj0gYXNjQ2hhcldpZHRoOyBpKyspIHtcbiAgICBjb250ZW50V2lkdGggLT0gYXNjQ2hhcldpZHRoO1xuICB9XG5cbiAgdmFyIGVsbGlwc2lzV2lkdGggPSBnZXRXaWR0aChlbGxpcHNpcyk7XG5cbiAgaWYgKGVsbGlwc2lzV2lkdGggPiBjb250ZW50V2lkdGgpIHtcbiAgICBlbGxpcHNpcyA9ICcnO1xuICAgIGVsbGlwc2lzV2lkdGggPSAwO1xuICB9XG5cbiAgY29udGVudFdpZHRoID0gY29udGFpbmVyV2lkdGggLSBlbGxpcHNpc1dpZHRoO1xuICBvcHRpb25zLmVsbGlwc2lzID0gZWxsaXBzaXM7XG4gIG9wdGlvbnMuZWxsaXBzaXNXaWR0aCA9IGVsbGlwc2lzV2lkdGg7XG4gIG9wdGlvbnMuY29udGVudFdpZHRoID0gY29udGVudFdpZHRoO1xuICBvcHRpb25zLmNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyV2lkdGg7XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZVNpbmdsZUxpbmUodGV4dExpbmUsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbnRhaW5lcldpZHRoID0gb3B0aW9ucy5jb250YWluZXJXaWR0aDtcbiAgdmFyIGZvbnQgPSBvcHRpb25zLmZvbnQ7XG4gIHZhciBjb250ZW50V2lkdGggPSBvcHRpb25zLmNvbnRlbnRXaWR0aDtcblxuICBpZiAoIWNvbnRhaW5lcldpZHRoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGxpbmVXaWR0aCA9IGdldFdpZHRoKHRleHRMaW5lLCBmb250KTtcblxuICBpZiAobGluZVdpZHRoIDw9IGNvbnRhaW5lcldpZHRoKSB7XG4gICAgcmV0dXJuIHRleHRMaW5lO1xuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7OyBqKyspIHtcbiAgICBpZiAobGluZVdpZHRoIDw9IGNvbnRlbnRXaWR0aCB8fCBqID49IG9wdGlvbnMubWF4SXRlcmF0aW9ucykge1xuICAgICAgdGV4dExpbmUgKz0gb3B0aW9ucy5lbGxpcHNpcztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBzdWJMZW5ndGggPSBqID09PSAwID8gZXN0aW1hdGVMZW5ndGgodGV4dExpbmUsIGNvbnRlbnRXaWR0aCwgb3B0aW9ucy5hc2NDaGFyV2lkdGgsIG9wdGlvbnMuY25DaGFyV2lkdGgpIDogbGluZVdpZHRoID4gMCA/IE1hdGguZmxvb3IodGV4dExpbmUubGVuZ3RoICogY29udGVudFdpZHRoIC8gbGluZVdpZHRoKSA6IDA7XG4gICAgdGV4dExpbmUgPSB0ZXh0TGluZS5zdWJzdHIoMCwgc3ViTGVuZ3RoKTtcbiAgICBsaW5lV2lkdGggPSBnZXRXaWR0aCh0ZXh0TGluZSwgZm9udCk7XG4gIH1cblxuICBpZiAodGV4dExpbmUgPT09ICcnKSB7XG4gICAgdGV4dExpbmUgPSBvcHRpb25zLnBsYWNlaG9sZGVyO1xuICB9XG5cbiAgcmV0dXJuIHRleHRMaW5lO1xufVxuXG5mdW5jdGlvbiBlc3RpbWF0ZUxlbmd0aCh0ZXh0LCBjb250ZW50V2lkdGgsIGFzY0NoYXJXaWR0aCwgY25DaGFyV2lkdGgpIHtcbiAgdmFyIHdpZHRoID0gMDtcbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAodmFyIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuICYmIHdpZHRoIDwgY29udGVudFdpZHRoOyBpKyspIHtcbiAgICB2YXIgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgd2lkdGggKz0gMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAxMjcgPyBhc2NDaGFyV2lkdGggOiBjbkNoYXJXaWR0aDtcbiAgfVxuXG4gIHJldHVybiBpO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7bnVtYmVyfSBsaW5lIGhlaWdodFxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGluZUhlaWdodChmb250KSB7XG4gIC8vIEZJWE1FIEEgcm91Z2ggYXBwcm9hY2guXG4gIHJldHVybiBnZXRXaWR0aCgn5Zu9JywgZm9udCk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHJldHVybiB7T2JqZWN0fSB3aWR0aFxuICovXG5cblxuZnVuY3Rpb24gbWVhc3VyZVRleHQodGV4dCwgZm9udCkge1xuICByZXR1cm4gbWV0aG9kcy5tZWFzdXJlVGV4dCh0ZXh0LCBmb250KTtcbn0gLy8gQXZvaWQgYXNzaWduIHRvIGFuIGV4cG9ydGVkIHZhcmlhYmxlLCBmb3IgdHJhbnNmb3JtaW5nIHRvIGNqcy5cblxuXG5tZXRob2RzLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGZvbnQpIHtcbiAgdmFyIGN0eCA9IGdldENvbnRleHQoKTtcbiAgY3R4LmZvbnQgPSBmb250IHx8IERFRkFVTFRfRk9OVDtcbiAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbn07XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICogQHBhcmFtIHtPYmplY3R9IFt0cnVuY2F0ZV1cbiAqIEByZXR1cm4ge09iamVjdH0gYmxvY2s6IHtsaW5lSGVpZ2h0LCBsaW5lcywgaGVpZ2h0LCBvdXRlckhlaWdodH1cbiAqICBOb3RpY2U6IGZvciBwZXJmb3JtYW5jZSwgZG8gbm90IGNhbGN1bGF0ZSBvdXRlcldpZHRoIHV0aWwgbmVlZGVkLlxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VQbGFpblRleHQodGV4dCwgZm9udCwgcGFkZGluZywgdHJ1bmNhdGUpIHtcbiAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcbiAgdmFyIGxpbmVIZWlnaHQgPSBnZXRMaW5lSGVpZ2h0KGZvbnQpO1xuICB2YXIgbGluZXMgPSB0ZXh0ID8gdGV4dC5zcGxpdCgnXFxuJykgOiBbXTtcbiAgdmFyIGhlaWdodCA9IGxpbmVzLmxlbmd0aCAqIGxpbmVIZWlnaHQ7XG4gIHZhciBvdXRlckhlaWdodCA9IGhlaWdodDtcblxuICBpZiAocGFkZGluZykge1xuICAgIG91dGVySGVpZ2h0ICs9IHBhZGRpbmdbMF0gKyBwYWRkaW5nWzJdO1xuICB9XG5cbiAgaWYgKHRleHQgJiYgdHJ1bmNhdGUpIHtcbiAgICB2YXIgdHJ1bmNPdXRlckhlaWdodCA9IHRydW5jYXRlLm91dGVySGVpZ2h0O1xuICAgIHZhciB0cnVuY091dGVyV2lkdGggPSB0cnVuY2F0ZS5vdXRlcldpZHRoO1xuXG4gICAgaWYgKHRydW5jT3V0ZXJIZWlnaHQgIT0gbnVsbCAmJiBvdXRlckhlaWdodCA+IHRydW5jT3V0ZXJIZWlnaHQpIHtcbiAgICAgIHRleHQgPSAnJztcbiAgICAgIGxpbmVzID0gW107XG4gICAgfSBlbHNlIGlmICh0cnVuY091dGVyV2lkdGggIT0gbnVsbCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBwcmVwYXJlVHJ1bmNhdGVPcHRpb25zKHRydW5jT3V0ZXJXaWR0aCAtIChwYWRkaW5nID8gcGFkZGluZ1sxXSArIHBhZGRpbmdbM10gOiAwKSwgZm9udCwgdHJ1bmNhdGUuZWxsaXBzaXMsIHtcbiAgICAgICAgbWluQ2hhcjogdHJ1bmNhdGUubWluQ2hhcixcbiAgICAgICAgcGxhY2Vob2xkZXI6IHRydW5jYXRlLnBsYWNlaG9sZGVyXG4gICAgICB9KTsgLy8gRklYTUVcbiAgICAgIC8vIEl0IGlzIG5vdCBhcHByb3ByaWF0ZSB0aGF0IGV2ZXJ5IGxpbmUgaGFzICcuLi4nIHdoZW4gdHJ1bmNhdGUgbXVsdGlwbGUgbGluZXMuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsaW5lc1tpXSA9IHRydW5jYXRlU2luZ2xlTGluZShsaW5lc1tpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lczogbGluZXMsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgb3V0ZXJIZWlnaHQ6IG91dGVySGVpZ2h0LFxuICAgIGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHRcbiAgfTtcbn1cbi8qKlxuICogRm9yIGV4YW1wbGU6ICdzb21lIHRleHQge2F8c29tZSB0ZXh0fW90aGVyIHRleHR7Ynxzb21lIHRleHR9eHh4e2N8fXh4eCdcbiAqIEFsc28gY29uc2lkZXIgJ2JiYmJ7YXx4eHhcXG56enp9eHh4eFxcbmFhYWEnLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEByZXR1cm4ge09iamVjdH0gYmxvY2tcbiAqIHtcbiAqICAgICAgd2lkdGgsXG4gKiAgICAgIGhlaWdodCxcbiAqICAgICAgbGluZXM6IFt7XG4gKiAgICAgICAgICBsaW5lSGVpZ2h0LFxuICogICAgICAgICAgd2lkdGgsXG4gKiAgICAgICAgICB0b2tlbnM6IFtbe1xuICogICAgICAgICAgICAgIHN0eWxlTmFtZSxcbiAqICAgICAgICAgICAgICB0ZXh0LFxuICogICAgICAgICAgICAgIHdpZHRoLCAgICAgIC8vIGluY2x1ZGUgdGV4dFBhZGRpbmdcbiAqICAgICAgICAgICAgICBoZWlnaHQsICAgICAvLyBpbmNsdWRlIHRleHRQYWRkaW5nXG4gKiAgICAgICAgICAgICAgdGV4dFdpZHRoLCAvLyBwdXJlIHRleHQgd2lkdGhcbiAqICAgICAgICAgICAgICB0ZXh0SGVpZ2h0LCAvLyBwdXJlIHRleHQgaGVpZ2h0XG4gKiAgICAgICAgICAgICAgbGluZUhlaWhndCxcbiAqICAgICAgICAgICAgICBmb250LFxuICogICAgICAgICAgICAgIHRleHRBbGlnbixcbiAqICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnblxuICogICAgICAgICAgfV0sIFsuLi5dLCAuLi5dXG4gKiAgICAgIH0sIC4uLl1cbiAqIH1cbiAqIElmIHN0eWxlTmFtZSBpcyB1bmRlZmluZWQsIGl0IGlzIHBsYWluIHRleHQuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVJpY2hUZXh0KHRleHQsIHN0eWxlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSB7XG4gICAgbGluZXM6IFtdLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9O1xuICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuXG4gIGlmICghdGV4dCkge1xuICAgIHJldHVybiBjb250ZW50QmxvY2s7XG4gIH1cblxuICB2YXIgbGFzdEluZGV4ID0gU1RZTEVfUkVHLmxhc3RJbmRleCA9IDA7XG4gIHZhciByZXN1bHQ7XG5cbiAgd2hpbGUgKChyZXN1bHQgPSBTVFlMRV9SRUcuZXhlYyh0ZXh0KSkgIT0gbnVsbCkge1xuICAgIHZhciBtYXRjaGVkSW5kZXggPSByZXN1bHQuaW5kZXg7XG5cbiAgICBpZiAobWF0Y2hlZEluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4LCBtYXRjaGVkSW5kZXgpKTtcbiAgICB9XG5cbiAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgcmVzdWx0WzJdLCByZXN1bHRbMV0pO1xuICAgIGxhc3RJbmRleCA9IFNUWUxFX1JFRy5sYXN0SW5kZXg7XG4gIH1cblxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4LCB0ZXh0Lmxlbmd0aCkpO1xuICB9XG5cbiAgdmFyIGxpbmVzID0gY29udGVudEJsb2NrLmxpbmVzO1xuICB2YXIgY29udGVudEhlaWdodCA9IDA7XG4gIHZhciBjb250ZW50V2lkdGggPSAwOyAvLyBGb3IgYHRleHRXaWR0aDogMTAwJWBcblxuICB2YXIgcGVuZGluZ0xpc3QgPSBbXTtcbiAgdmFyIHN0bFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcbiAgdmFyIHRydW5jYXRlID0gc3R5bGUudHJ1bmNhdGU7XG4gIHZhciB0cnVuY2F0ZVdpZHRoID0gdHJ1bmNhdGUgJiYgdHJ1bmNhdGUub3V0ZXJXaWR0aDtcbiAgdmFyIHRydW5jYXRlSGVpZ2h0ID0gdHJ1bmNhdGUgJiYgdHJ1bmNhdGUub3V0ZXJIZWlnaHQ7XG5cbiAgaWYgKHN0bFBhZGRpbmcpIHtcbiAgICB0cnVuY2F0ZVdpZHRoICE9IG51bGwgJiYgKHRydW5jYXRlV2lkdGggLT0gc3RsUGFkZGluZ1sxXSArIHN0bFBhZGRpbmdbM10pO1xuICAgIHRydW5jYXRlSGVpZ2h0ICE9IG51bGwgJiYgKHRydW5jYXRlSGVpZ2h0IC09IHN0bFBhZGRpbmdbMF0gKyBzdGxQYWRkaW5nWzJdKTtcbiAgfSAvLyBDYWxjdWxhdGUgbGF5b3V0IGluZm8gb2YgdG9rZW5zLlxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgdmFyIGxpbmVIZWlnaHQgPSAwO1xuICAgIHZhciBsaW5lV2lkdGggPSAwO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lLnRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHRva2VuID0gbGluZS50b2tlbnNbal07XG4gICAgICB2YXIgdG9rZW5TdHlsZSA9IHRva2VuLnN0eWxlTmFtZSAmJiBzdHlsZS5yaWNoW3Rva2VuLnN0eWxlTmFtZV0gfHwge307IC8vIHRleHRQYWRkaW5nIHNob3VsZCBub3QgaW5oZXJpdCBmcm9tIHN0eWxlLlxuXG4gICAgICB2YXIgdGV4dFBhZGRpbmcgPSB0b2tlbi50ZXh0UGFkZGluZyA9IHRva2VuU3R5bGUudGV4dFBhZGRpbmc7IC8vIHRleHRGb250IGhhcyBiZWVuIGFzaWduZWQgdG8gZm9udCBieSBgbm9ybWFsaXplU3R5bGVgLlxuXG4gICAgICB2YXIgZm9udCA9IHRva2VuLmZvbnQgPSB0b2tlblN0eWxlLmZvbnQgfHwgc3R5bGUuZm9udDsgLy8gdGV4dEhlaWdodCBjYW4gYmUgdXNlZCB3aGVuIHRleHRWZXJ0aWNhbEFsaWduIGlzIHNwZWNpZmllZCBpbiB0b2tlbi5cblxuICAgICAgdmFyIHRva2VuSGVpZ2h0ID0gdG9rZW4udGV4dEhlaWdodCA9IHJldHJpZXZlMiggLy8gdGV4dEhlaWdodCBzaG91bGQgbm90IGJlIGluaGVyaXRlZCwgY29uc2lkZXIgaXQgY2FuIGJlIHNwZWNpZmllZFxuICAgICAgLy8gYXMgYm94IGhlaWdodCBvZiB0aGUgYmxvY2suXG4gICAgICB0b2tlblN0eWxlLnRleHRIZWlnaHQsIGdldExpbmVIZWlnaHQoZm9udCkpO1xuICAgICAgdGV4dFBhZGRpbmcgJiYgKHRva2VuSGVpZ2h0ICs9IHRleHRQYWRkaW5nWzBdICsgdGV4dFBhZGRpbmdbMl0pO1xuICAgICAgdG9rZW4uaGVpZ2h0ID0gdG9rZW5IZWlnaHQ7XG4gICAgICB0b2tlbi5saW5lSGVpZ2h0ID0gcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dExpbmVIZWlnaHQsIHN0eWxlLnRleHRMaW5lSGVpZ2h0LCB0b2tlbkhlaWdodCk7XG4gICAgICB0b2tlbi50ZXh0QWxpZ24gPSB0b2tlblN0eWxlICYmIHRva2VuU3R5bGUudGV4dEFsaWduIHx8IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgIHRva2VuLnRleHRWZXJ0aWNhbEFsaWduID0gdG9rZW5TdHlsZSAmJiB0b2tlblN0eWxlLnRleHRWZXJ0aWNhbEFsaWduIHx8ICdtaWRkbGUnO1xuXG4gICAgICBpZiAodHJ1bmNhdGVIZWlnaHQgIT0gbnVsbCAmJiBjb250ZW50SGVpZ2h0ICsgdG9rZW4ubGluZUhlaWdodCA+IHRydW5jYXRlSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0b2tlbi50ZXh0V2lkdGggPSBnZXRXaWR0aCh0b2tlbi50ZXh0LCBmb250KTtcbiAgICAgIHZhciB0b2tlbldpZHRoID0gdG9rZW5TdHlsZS50ZXh0V2lkdGg7XG4gICAgICB2YXIgdG9rZW5XaWR0aE5vdFNwZWNpZmllZCA9IHRva2VuV2lkdGggPT0gbnVsbCB8fCB0b2tlbldpZHRoID09PSAnYXV0byc7IC8vIFBlcmNlbnQgd2lkdGgsIGNhbiBiZSBgMTAwJWAsIGNhbiBiZSB1c2VkIGluIGRyYXdpbmcgc2VwYXJhdGVcbiAgICAgIC8vIGxpbmUgd2hlbiBib3ggd2lkdGggaXMgbmVlZGVkIHRvIGJlIGF1dG8uXG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW5XaWR0aCA9PT0gJ3N0cmluZycgJiYgdG9rZW5XaWR0aC5jaGFyQXQodG9rZW5XaWR0aC5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICAgIHRva2VuLnBlcmNlbnRXaWR0aCA9IHRva2VuV2lkdGg7XG4gICAgICAgIHBlbmRpbmdMaXN0LnB1c2godG9rZW4pO1xuICAgICAgICB0b2tlbldpZHRoID0gMDsgLy8gRG8gbm90IHRydW5jYXRlIGluIHRoaXMgY2FzZSwgYmVjYXVzZSB0aGVyZSBpcyBubyB1c2VyIGNhc2VcbiAgICAgICAgLy8gYW5kIGl0IGlzIHRvbyBjb21wbGljYXRlZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0b2tlbldpZHRoTm90U3BlY2lmaWVkKSB7XG4gICAgICAgICAgdG9rZW5XaWR0aCA9IHRva2VuLnRleHRXaWR0aDsgLy8gRklYTUU6IElmIGltYWdlIGlzIG5vdCBsb2FkZWQgYW5kIHRleHRXaWR0aCBpcyBub3Qgc3BlY2lmaWVkLCBjYWxsaW5nXG4gICAgICAgICAgLy8gYGdldEJvdW5kaW5nUmVjdCgpYCB3aWxsIG5vdCBnZXQgY29ycmVjdCByZXN1bHQuXG5cbiAgICAgICAgICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IHRva2VuU3R5bGUudGV4dEJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICB2YXIgYmdJbWcgPSB0ZXh0QmFja2dyb3VuZENvbG9yICYmIHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2U7IC8vIFVzZSBjYXNlczpcbiAgICAgICAgICAvLyAoMSkgSWYgaW1hZ2UgaXMgbm90IGxvYWRlZCwgaXQgd2lsbCBiZSBsb2FkZWQgYXQgcmVuZGVyIHBoYXNlIGFuZCBjYWxsXG4gICAgICAgICAgLy8gYGRpcnR5KClgIGFuZCBgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZWAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBsb2FkZWRcbiAgICAgICAgICAvLyBpbWFnZSwgYW5kIHRoZW4gdGhlIHJpZ2h0IHNpemUgd2lsbCBiZSBjYWxjdWxhdGVkIGhlcmUgYXQgdGhlIG5leHQgdGljay5cbiAgICAgICAgICAvLyBTZWUgYGdyYXBoaWMvaGVscGVyL3RleHQuanNgLlxuICAgICAgICAgIC8vICgyKSBJZiBpbWFnZSBsb2FkZWQsIGFuZCBgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZWAgaXMgaW1hZ2Ugc3JjIHN0cmluZyxcbiAgICAgICAgICAvLyB1c2UgYGltYWdlSGVscGVyLmZpbmRFeGlzdEltYWdlYCB0byBmaW5kIGNhY2hlZCBpbWFnZS5cbiAgICAgICAgICAvLyBgaW1hZ2VIZWxwZXIuZmluZEV4aXN0SW1hZ2VgIHdpbGwgYWx3YXlzIGJlIGNhbGxlZCBoZXJlIGJlZm9yZVxuICAgICAgICAgIC8vIGBpbWFnZUhlbHBlci5jcmVhdGVPclVwZGF0ZUltYWdlYCBpbiBgZ3JhcGhpYy9oZWxwZXIvdGV4dC5qcyNyZW5kZXJSaWNoVGV4dGBcbiAgICAgICAgICAvLyB3aGljaCBlbnN1cmVzIHRoYXQgaW1hZ2Ugd2lsbCBub3QgYmUgcmVuZGVyZWQgYmVmb3JlIGNvcnJlY3Qgc2l6ZSBjYWxjdWFsdGVkLlxuXG4gICAgICAgICAgaWYgKGJnSW1nKSB7XG4gICAgICAgICAgICBiZ0ltZyA9IGltYWdlSGVscGVyLmZpbmRFeGlzdEltYWdlKGJnSW1nKTtcblxuICAgICAgICAgICAgaWYgKGltYWdlSGVscGVyLmlzSW1hZ2VSZWFkeShiZ0ltZykpIHtcbiAgICAgICAgICAgICAgdG9rZW5XaWR0aCA9IE1hdGgubWF4KHRva2VuV2lkdGgsIGJnSW1nLndpZHRoICogdG9rZW5IZWlnaHQgLyBiZ0ltZy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYWRkaW5nVyA9IHRleHRQYWRkaW5nID8gdGV4dFBhZGRpbmdbMV0gKyB0ZXh0UGFkZGluZ1szXSA6IDA7XG4gICAgICAgIHRva2VuV2lkdGggKz0gcGFkZGluZ1c7XG4gICAgICAgIHZhciByZW1pYW5UcnVuY1dpZHRoID0gdHJ1bmNhdGVXaWR0aCAhPSBudWxsID8gdHJ1bmNhdGVXaWR0aCAtIGxpbmVXaWR0aCA6IG51bGw7XG5cbiAgICAgICAgaWYgKHJlbWlhblRydW5jV2lkdGggIT0gbnVsbCAmJiByZW1pYW5UcnVuY1dpZHRoIDwgdG9rZW5XaWR0aCkge1xuICAgICAgICAgIGlmICghdG9rZW5XaWR0aE5vdFNwZWNpZmllZCB8fCByZW1pYW5UcnVuY1dpZHRoIDwgcGFkZGluZ1cpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSAnJztcbiAgICAgICAgICAgIHRva2VuLnRleHRXaWR0aCA9IHRva2VuV2lkdGggPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gdHJ1bmNhdGVUZXh0KHRva2VuLnRleHQsIHJlbWlhblRydW5jV2lkdGggLSBwYWRkaW5nVywgZm9udCwgdHJ1bmNhdGUuZWxsaXBzaXMsIHtcbiAgICAgICAgICAgICAgbWluQ2hhcjogdHJ1bmNhdGUubWluQ2hhclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b2tlbi50ZXh0V2lkdGggPSBnZXRXaWR0aCh0b2tlbi50ZXh0LCBmb250KTtcbiAgICAgICAgICAgIHRva2VuV2lkdGggPSB0b2tlbi50ZXh0V2lkdGggKyBwYWRkaW5nVztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGluZVdpZHRoICs9IHRva2VuLndpZHRoID0gdG9rZW5XaWR0aDtcbiAgICAgIHRva2VuU3R5bGUgJiYgKGxpbmVIZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCB0b2tlbi5saW5lSGVpZ2h0KSk7XG4gICAgfVxuXG4gICAgbGluZS53aWR0aCA9IGxpbmVXaWR0aDtcbiAgICBsaW5lLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgIGNvbnRlbnRIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICBjb250ZW50V2lkdGggPSBNYXRoLm1heChjb250ZW50V2lkdGgsIGxpbmVXaWR0aCk7XG4gIH1cblxuICBjb250ZW50QmxvY2sub3V0ZXJXaWR0aCA9IGNvbnRlbnRCbG9jay53aWR0aCA9IHJldHJpZXZlMihzdHlsZS50ZXh0V2lkdGgsIGNvbnRlbnRXaWR0aCk7XG4gIGNvbnRlbnRCbG9jay5vdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5oZWlnaHQgPSByZXRyaWV2ZTIoc3R5bGUudGV4dEhlaWdodCwgY29udGVudEhlaWdodCk7XG5cbiAgaWYgKHN0bFBhZGRpbmcpIHtcbiAgICBjb250ZW50QmxvY2sub3V0ZXJXaWR0aCArPSBzdGxQYWRkaW5nWzFdICsgc3RsUGFkZGluZ1szXTtcbiAgICBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQgKz0gc3RsUGFkZGluZ1swXSArIHN0bFBhZGRpbmdbMl07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBlbmRpbmdMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gcGVuZGluZ0xpc3RbaV07XG4gICAgdmFyIHBlcmNlbnRXaWR0aCA9IHRva2VuLnBlcmNlbnRXaWR0aDsgLy8gU2hvdWxkIG5vdCBiYXNlIG9uIG91dGVyV2lkdGgsIGJlY2F1c2UgdG9rZW4gY2FuIG5vdCBiZSBwbGFjZWQgb3V0IG9mIHBhZGRpbmcuXG5cbiAgICB0b2tlbi53aWR0aCA9IHBhcnNlSW50KHBlcmNlbnRXaWR0aCwgMTApIC8gMTAwICogY29udGVudFdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnRCbG9jaztcbn1cblxuZnVuY3Rpb24gcHVzaFRva2VucyhibG9jaywgc3RyLCBzdHlsZU5hbWUpIHtcbiAgdmFyIGlzRW1wdHlTdHIgPSBzdHIgPT09ICcnO1xuICB2YXIgc3RycyA9IHN0ci5zcGxpdCgnXFxuJyk7XG4gIHZhciBsaW5lcyA9IGJsb2NrLmxpbmVzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Rycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0ZXh0ID0gc3Ryc1tpXTtcbiAgICB2YXIgdG9rZW4gPSB7XG4gICAgICBzdHlsZU5hbWU6IHN0eWxlTmFtZSxcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBpc0xpbmVIb2xkZXI6ICF0ZXh0ICYmICFpc0VtcHR5U3RyXG4gICAgfTsgLy8gVGhlIGZpcnN0IHRva2VuIHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgbGFzdCBsaW5lLlxuXG4gICAgaWYgKCFpKSB7XG4gICAgICB2YXIgdG9rZW5zID0gKGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdIHx8IChsaW5lc1swXSA9IHtcbiAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgfSkpLnRva2VuczsgLy8gQ29uc2lkZXIgY2FzZXM6XG4gICAgICAvLyAoMSkgJycuc3BsaXQoJ1xcbicpID0+IFsnJywgJ1xcbicsICcnXSwgdGhlICcnIGF0IHRoZSBmaXJzdCBpdGVtXG4gICAgICAvLyAod2hpY2ggaXMgYSBwbGFjZWhvbGRlcikgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IG5ldyB0b2tlbi5cbiAgICAgIC8vICgyKSBBIGltYWdlIGJhY2thZ2UsIHdoZXJlIHRva2VuIGxpa2VzIHthfH0uXG4gICAgICAvLyAoMykgQSByZWR1bmRhbnQgJycgd2lsbCBhZmZlY3QgdGV4dEFsaWduIGluIGxpbmUuXG4gICAgICAvLyAoNCkgdG9rZW5zIHdpdGggdGhlIHNhbWUgdHBsTmFtZSBzaG91bGQgbm90IGJlIG1lcmdlZCwgYmVjYXVzZVxuICAgICAgLy8gdGhleSBzaG91bGQgYmUgZGlzcGxheWVkIGluIGRpZmZlcmVudCBib3ggKHdpdGggYm9yZGVyIGFuZCBwYWRkaW5nKS5cblxuICAgICAgdmFyIHRva2Vuc0xlbiA9IHRva2Vucy5sZW5ndGg7XG4gICAgICB0b2tlbnNMZW4gPT09IDEgJiYgdG9rZW5zWzBdLmlzTGluZUhvbGRlciA/IHRva2Vuc1swXSA9IHRva2VuIDogLy8gQ29uc2lkZXIgdGV4dCBpcyAnJywgb25seSBpbnNlcnQgd2hlbiBpdCBpcyB0aGUgXCJsaW5lSG9sZGVyXCIgb3JcbiAgICAgIC8vIFwiZW1wdHlTdHJcIi4gT3RoZXJ3aXNlIGEgcmVkdW5kYW50ICcnIHdpbGwgYWZmZWN0IHRleHRBbGlnbiBpbiBsaW5lLlxuICAgICAgKHRleHQgfHwgIXRva2Vuc0xlbiB8fCBpc0VtcHR5U3RyKSAmJiB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgfSAvLyBPdGhlciB0b2tlbnMgYWx3YXlzIHN0YXJ0IGEgbmV3IGxpbmUuXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzICcnLCBpbnNlcnQgaXQgYXMgYSBwbGFjZWhvbGRlci5cbiAgICAgICAgbGluZXMucHVzaCh7XG4gICAgICAgICAgdG9rZW5zOiBbdG9rZW5dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VGb250KHN0eWxlKSB7XG4gIC8vIEZJWE1FIGluIG5vZGUtY2FudmFzIGZvbnRXZWlnaHQgaXMgYmVmb3JlIGZvbnRTdHlsZVxuICAvLyBVc2UgYGZvbnRTaXplYCBgZm9udEZhbWlseWAgdG8gY2hlY2sgd2hldGhlciBmb250IHByb3BlcnRpZXMgYXJlIGRlZmluZWQuXG4gIHJldHVybiAoc3R5bGUuZm9udFNpemUgfHwgc3R5bGUuZm9udEZhbWlseSkgJiYgW3N0eWxlLmZvbnRTdHlsZSwgc3R5bGUuZm9udFdlaWdodCwgKHN0eWxlLmZvbnRTaXplIHx8IDEyKSArICdweCcsIC8vIElmIGZvbnQgcHJvcGVydGllcyBhcmUgZGVmaW5lZCwgYGZvbnRGYW1pbHlgIHNob3VsZCBub3QgYmUgaWdub3JlZC5cbiAgc3R5bGUuZm9udEZhbWlseSB8fCAnc2Fucy1zZXJpZiddLmpvaW4oJyAnKSB8fCBzdHlsZS50ZXh0Rm9udCB8fCBzdHlsZS5mb250O1xufVxuXG5leHBvcnRzLkRFRkFVTFRfRk9OVCA9IERFRkFVTFRfRk9OVDtcbmV4cG9ydHMuJG92ZXJyaWRlID0gJG92ZXJyaWRlO1xuZXhwb3J0cy5nZXRXaWR0aCA9IGdldFdpZHRoO1xuZXhwb3J0cy5nZXRCb3VuZGluZ1JlY3QgPSBnZXRCb3VuZGluZ1JlY3Q7XG5leHBvcnRzLmFkanVzdFRleHRYID0gYWRqdXN0VGV4dFg7XG5leHBvcnRzLmFkanVzdFRleHRZID0gYWRqdXN0VGV4dFk7XG5leHBvcnRzLmFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCA9IGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdDtcbmV4cG9ydHMudHJ1bmNhdGVUZXh0ID0gdHJ1bmNhdGVUZXh0O1xuZXhwb3J0cy5nZXRMaW5lSGVpZ2h0ID0gZ2V0TGluZUhlaWdodDtcbmV4cG9ydHMubWVhc3VyZVRleHQgPSBtZWFzdXJlVGV4dDtcbmV4cG9ydHMucGFyc2VQbGFpblRleHQgPSBwYXJzZVBsYWluVGV4dDtcbmV4cG9ydHMucGFyc2VSaWNoVGV4dCA9IHBhcnNlUmljaFRleHQ7XG5leHBvcnRzLm1ha2VGb250ID0gbWFrZUZvbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHZlYzIgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciBtYXRyaXggPSByZXF1aXJlKFwiLi9tYXRyaXhcIik7XG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0XG4gKi9cbnZhciB2MkFwcGx5VHJhbnNmb3JtID0gdmVjMi5hcHBseVRyYW5zZm9ybTtcbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAqL1xuXG5mdW5jdGlvbiBCb3VuZGluZ1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAod2lkdGggPCAwKSB7XG4gICAgeCA9IHggKyB3aWR0aDtcbiAgICB3aWR0aCA9IC13aWR0aDtcbiAgfVxuXG4gIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cblxuICB0aGlzLnggPSB4O1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy55ID0geTtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xufVxuXG5Cb3VuZGluZ1JlY3QucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQm91bmRpbmdSZWN0LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fSBvdGhlclxuICAgKi9cbiAgdW5pb246IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHZhciB4ID0gbWF0aE1pbihvdGhlci54LCB0aGlzLngpO1xuICAgIHZhciB5ID0gbWF0aE1pbihvdGhlci55LCB0aGlzLnkpO1xuICAgIHRoaXMud2lkdGggPSBtYXRoTWF4KG90aGVyLnggKyBvdGhlci53aWR0aCwgdGhpcy54ICsgdGhpcy53aWR0aCkgLSB4O1xuICAgIHRoaXMuaGVpZ2h0ID0gbWF0aE1heChvdGhlci55ICsgb3RoZXIuaGVpZ2h0LCB0aGlzLnkgKyB0aGlzLmhlaWdodCkgLSB5O1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbVxuICAgKiBAbWV0aG9kc1xuICAgKi9cbiAgYXBwbHlUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbHQgPSBbXTtcbiAgICB2YXIgcmIgPSBbXTtcbiAgICB2YXIgbGIgPSBbXTtcbiAgICB2YXIgcnQgPSBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG0pIHtcbiAgICAgIC8vIEluIGNhc2UgdXNhZ2UgbGlrZSB0aGlzXG4gICAgICAvLyBlbC5nZXRCb3VuZGluZ1JlY3QoKS5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pXG4gICAgICAvLyBBbmQgZWxlbWVudCBoYXMgbm8gdHJhbnNmb3JtXG4gICAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsdFswXSA9IGxiWzBdID0gdGhpcy54O1xuICAgICAgbHRbMV0gPSBydFsxXSA9IHRoaXMueTtcbiAgICAgIHJiWzBdID0gcnRbMF0gPSB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgICAgcmJbMV0gPSBsYlsxXSA9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShsdCwgbHQsIG0pO1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShyYiwgcmIsIG0pO1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShsYiwgbGIsIG0pO1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShydCwgcnQsIG0pO1xuICAgICAgdGhpcy54ID0gbWF0aE1pbihsdFswXSwgcmJbMF0sIGxiWzBdLCBydFswXSk7XG4gICAgICB0aGlzLnkgPSBtYXRoTWluKGx0WzFdLCByYlsxXSwgbGJbMV0sIHJ0WzFdKTtcbiAgICAgIHZhciBtYXhYID0gbWF0aE1heChsdFswXSwgcmJbMF0sIGxiWzBdLCBydFswXSk7XG4gICAgICB2YXIgbWF4WSA9IG1hdGhNYXgobHRbMV0sIHJiWzFdLCBsYlsxXSwgcnRbMV0pO1xuICAgICAgdGhpcy53aWR0aCA9IG1heFggLSB0aGlzLng7XG4gICAgICB0aGlzLmhlaWdodCA9IG1heFkgLSB0aGlzLnk7XG4gICAgfTtcbiAgfSgpLFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgbWF0cml4IG9mIHRyYW5zZm9ybWluZyBmcm9tIHNlbGYgdG8gdGFyZ2V0IHJlY3RcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IGJcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBjYWxjdWxhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChiKSB7XG4gICAgdmFyIGEgPSB0aGlzO1xuICAgIHZhciBzeCA9IGIud2lkdGggLyBhLndpZHRoO1xuICAgIHZhciBzeSA9IGIuaGVpZ2h0IC8gYS5oZWlnaHQ7XG4gICAgdmFyIG0gPSBtYXRyaXguY3JlYXRlKCk7IC8vIOefqemYteWPs+S5mFxuXG4gICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbLWEueCwgLWEueV0pO1xuICAgIG1hdHJpeC5zY2FsZShtLCBtLCBbc3gsIHN5XSk7XG4gICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbYi54LCBiLnldKTtcbiAgICByZXR1cm4gbTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHsobW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R8T2JqZWN0KX0gYlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaW50ZXJzZWN0OiBmdW5jdGlvbiAoYikge1xuICAgIGlmICghYikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghKGIgaW5zdGFuY2VvZiBCb3VuZGluZ1JlY3QpKSB7XG4gICAgICAvLyBOb3JtYWxpemUgbmVnYXRpdmUgd2lkdGgvaGVpZ2h0LlxuICAgICAgYiA9IEJvdW5kaW5nUmVjdC5jcmVhdGUoYik7XG4gICAgfVxuXG4gICAgdmFyIGEgPSB0aGlzO1xuICAgIHZhciBheDAgPSBhLng7XG4gICAgdmFyIGF4MSA9IGEueCArIGEud2lkdGg7XG4gICAgdmFyIGF5MCA9IGEueTtcbiAgICB2YXIgYXkxID0gYS55ICsgYS5oZWlnaHQ7XG4gICAgdmFyIGJ4MCA9IGIueDtcbiAgICB2YXIgYngxID0gYi54ICsgYi53aWR0aDtcbiAgICB2YXIgYnkwID0gYi55O1xuICAgIHZhciBieTEgPSBiLnkgKyBiLmhlaWdodDtcbiAgICByZXR1cm4gIShheDEgPCBieDAgfHwgYngxIDwgYXgwIHx8IGF5MSA8IGJ5MCB8fCBieTEgPCBheTApO1xuICB9LFxuICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciByZWN0ID0gdGhpcztcbiAgICByZXR1cm4geCA+PSByZWN0LnggJiYgeCA8PSByZWN0LnggKyByZWN0LndpZHRoICYmIHkgPj0gcmVjdC55ICYmIHkgPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb3B5IGZyb20gYW5vdGhlciByZWN0XG4gICAqL1xuICBjb3B5OiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB0aGlzLnggPSBvdGhlci54O1xuICAgIHRoaXMueSA9IG90aGVyLnk7XG4gICAgdGhpcy53aWR0aCA9IG90aGVyLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gb3RoZXIuaGVpZ2h0O1xuICB9LFxuICBwbGFpbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnksXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICB9XG59O1xuLyoqXG4gKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gcmVjdFxuICogQHBhcmFtIHtudW1iZXJ9IHJlY3QueFxuICogQHBhcmFtIHtudW1iZXJ9IHJlY3QueVxuICogQHBhcmFtIHtudW1iZXJ9IHJlY3Qud2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LmhlaWdodFxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gKi9cblxuQm91bmRpbmdSZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChyZWN0KSB7XG4gIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBCb3VuZGluZ1JlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExSVSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL0xSVVwiKTtcblxudmFyIGdsb2JhbEltYWdlQ2FjaGUgPSBuZXcgTFJVKDUwKTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IG5ld0ltYWdlT3JTcmNcbiAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZVxuICovXG5cbmZ1bmN0aW9uIGZpbmRFeGlzdEltYWdlKG5ld0ltYWdlT3JTcmMpIHtcbiAgaWYgKHR5cGVvZiBuZXdJbWFnZU9yU3JjID09PSAnc3RyaW5nJykge1xuICAgIHZhciBjYWNoZWRJbWdPYmogPSBnbG9iYWxJbWFnZUNhY2hlLmdldChuZXdJbWFnZU9yU3JjKTtcbiAgICByZXR1cm4gY2FjaGVkSW1nT2JqICYmIGNhY2hlZEltZ09iai5pbWFnZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3SW1hZ2VPclNyYztcbiAgfVxufVxuLyoqXG4gKiBDYXV0aW9uOiBVc2VyIHNob3VsZCBjYWNoZSBsb2FkZWQgaW1hZ2VzLCBidXQgbm90IGp1c3QgY291bnQgb24gTFJVLlxuICogQ29uc2lkZXIgaWYgcmVxdWlyZWQgaW1hZ2VzIG1vcmUgdGhhbiBMUlUgc2l6ZSwgd2lsbCBkZWFkIGxvb3Agb2NjdXI/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IG5ld0ltYWdlT3JTcmNcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IGltYWdlIEV4aXN0ZW50IGltYWdlLlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBbaG9zdEVsXSBGb3IgY2FsbGluZyBgZGlydHlgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBwYXJhbXM6IChpbWFnZSwgY2JQYXlsb2FkKVxuICogQHBhcmFtIHtPYmplY3R9IFtjYlBheWxvYWRdIFBheWxvYWQgb24gY2IgY2FsbGluZy5cbiAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVJbWFnZShuZXdJbWFnZU9yU3JjLCBpbWFnZSwgaG9zdEVsLCBjYiwgY2JQYXlsb2FkKSB7XG4gIGlmICghbmV3SW1hZ2VPclNyYykge1xuICAgIHJldHVybiBpbWFnZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbmV3SW1hZ2VPclNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJbWFnZSBzaG91bGQgbm90IGJlIGxvYWRlZCByZXBlYXRseS5cbiAgICBpZiAoaW1hZ2UgJiYgaW1hZ2UuX196ckltYWdlU3JjID09PSBuZXdJbWFnZU9yU3JjIHx8ICFob3N0RWwpIHtcbiAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9IC8vIE9ubHkgd2hlbiB0aGVyZSBpcyBubyBleGlzdGVudCBpbWFnZSBvciBleGlzdGVudCBpbWFnZSBzcmNcbiAgICAvLyBpcyBkaWZmZXJlbnQsIHRoaXMgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkLlxuXG5cbiAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQobmV3SW1hZ2VPclNyYyk7XG4gICAgdmFyIHBlbmRpbmdXcmFwID0ge1xuICAgICAgaG9zdEVsOiBob3N0RWwsXG4gICAgICBjYjogY2IsXG4gICAgICBjYlBheWxvYWQ6IGNiUGF5bG9hZFxuICAgIH07XG5cbiAgICBpZiAoY2FjaGVkSW1nT2JqKSB7XG4gICAgICBpbWFnZSA9IGNhY2hlZEltZ09iai5pbWFnZTtcbiAgICAgICFpc0ltYWdlUmVhZHkoaW1hZ2UpICYmIGNhY2hlZEltZ09iai5wZW5kaW5nLnB1c2gocGVuZGluZ1dyYXApO1xuICAgIH0gZWxzZSB7XG4gICAgICAhaW1hZ2UgJiYgKGltYWdlID0gbmV3IEltYWdlKCkpO1xuICAgICAgaW1hZ2Uub25sb2FkID0gaW1hZ2VPbkxvYWQ7XG4gICAgICBnbG9iYWxJbWFnZUNhY2hlLnB1dChuZXdJbWFnZU9yU3JjLCBpbWFnZS5fX2NhY2hlZEltZ09iaiA9IHtcbiAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICBwZW5kaW5nOiBbcGVuZGluZ1dyYXBdXG4gICAgICB9KTtcbiAgICAgIGltYWdlLnNyYyA9IGltYWdlLl9fenJJbWFnZVNyYyA9IG5ld0ltYWdlT3JTcmM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGltYWdlO1xuICB9IC8vIG5ld0ltYWdlT3JTcmMgaXMgYW4gSFRNTEltYWdlRWxlbWVudCBvciBIVE1MQ2FudmFzRWxlbWVudCBvciBDYW52YXNcbiAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3SW1hZ2VPclNyYztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGltYWdlT25Mb2FkKCkge1xuICB2YXIgY2FjaGVkSW1nT2JqID0gdGhpcy5fX2NhY2hlZEltZ09iajtcbiAgdGhpcy5vbmxvYWQgPSB0aGlzLl9fY2FjaGVkSW1nT2JqID0gbnVsbDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlZEltZ09iai5wZW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBlbmRpbmdXcmFwID0gY2FjaGVkSW1nT2JqLnBlbmRpbmdbaV07XG4gICAgdmFyIGNiID0gcGVuZGluZ1dyYXAuY2I7XG4gICAgY2IgJiYgY2IodGhpcywgcGVuZGluZ1dyYXAuY2JQYXlsb2FkKTtcbiAgICBwZW5kaW5nV3JhcC5ob3N0RWwuZGlydHkoKTtcbiAgfVxuXG4gIGNhY2hlZEltZ09iai5wZW5kaW5nLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIGlzSW1hZ2VSZWFkeShpbWFnZSkge1xuICByZXR1cm4gaW1hZ2UgJiYgaW1hZ2Uud2lkdGggJiYgaW1hZ2UuaGVpZ2h0O1xufVxuXG5leHBvcnRzLmZpbmRFeGlzdEltYWdlID0gZmluZEV4aXN0SW1hZ2U7XG5leHBvcnRzLmNyZWF0ZU9yVXBkYXRlSW1hZ2UgPSBjcmVhdGVPclVwZGF0ZUltYWdlO1xuZXhwb3J0cy5pc0ltYWdlUmVhZHkgPSBpc0ltYWdlUmVhZHk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBidWlsZFBhdGgoY3R4LCBzaGFwZSkge1xuICB2YXIgeCA9IHNoYXBlLng7XG4gIHZhciB5ID0gc2hhcGUueTtcbiAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gIHZhciByID0gc2hhcGUucjtcbiAgdmFyIHIxO1xuICB2YXIgcjI7XG4gIHZhciByMztcbiAgdmFyIHI0OyAvLyBDb252ZXJ0IHdpZHRoIGFuZCBoZWlnaHQgdG8gcG9zaXRpdmUgZm9yIGJldHRlciBib3JkZXJSYWRpdXNcblxuICBpZiAod2lkdGggPCAwKSB7XG4gICAgeCA9IHggKyB3aWR0aDtcbiAgICB3aWR0aCA9IC13aWR0aDtcbiAgfVxuXG4gIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgciA9PT0gJ251bWJlcicpIHtcbiAgICByMSA9IHIyID0gcjMgPSByNCA9IHI7XG4gIH0gZWxzZSBpZiAociBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgaWYgKHIubGVuZ3RoID09PSAxKSB7XG4gICAgICByMSA9IHIyID0gcjMgPSByNCA9IHJbMF07XG4gICAgfSBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMikge1xuICAgICAgcjEgPSByMyA9IHJbMF07XG4gICAgICByMiA9IHI0ID0gclsxXTtcbiAgICB9IGVsc2UgaWYgKHIubGVuZ3RoID09PSAzKSB7XG4gICAgICByMSA9IHJbMF07XG4gICAgICByMiA9IHI0ID0gclsxXTtcbiAgICAgIHIzID0gclsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcjEgPSByWzBdO1xuICAgICAgcjIgPSByWzFdO1xuICAgICAgcjMgPSByWzJdO1xuICAgICAgcjQgPSByWzNdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByMSA9IHIyID0gcjMgPSByNCA9IDA7XG4gIH1cblxuICB2YXIgdG90YWw7XG5cbiAgaWYgKHIxICsgcjIgPiB3aWR0aCkge1xuICAgIHRvdGFsID0gcjEgKyByMjtcbiAgICByMSAqPSB3aWR0aCAvIHRvdGFsO1xuICAgIHIyICo9IHdpZHRoIC8gdG90YWw7XG4gIH1cblxuICBpZiAocjMgKyByNCA+IHdpZHRoKSB7XG4gICAgdG90YWwgPSByMyArIHI0O1xuICAgIHIzICo9IHdpZHRoIC8gdG90YWw7XG4gICAgcjQgKj0gd2lkdGggLyB0b3RhbDtcbiAgfVxuXG4gIGlmIChyMiArIHIzID4gaGVpZ2h0KSB7XG4gICAgdG90YWwgPSByMiArIHIzO1xuICAgIHIyICo9IGhlaWdodCAvIHRvdGFsO1xuICAgIHIzICo9IGhlaWdodCAvIHRvdGFsO1xuICB9XG5cbiAgaWYgKHIxICsgcjQgPiBoZWlnaHQpIHtcbiAgICB0b3RhbCA9IHIxICsgcjQ7XG4gICAgcjEgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgcjQgKj0gaGVpZ2h0IC8gdG90YWw7XG4gIH1cblxuICBjdHgubW92ZVRvKHggKyByMSwgeSk7XG4gIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcjIsIHkpO1xuICByMiAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHIyKTtcbiAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByMyk7XG4gIHIzICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcjMsIHkgKyBoZWlnaHQpO1xuICBjdHgubGluZVRvKHggKyByNCwgeSArIGhlaWdodCk7XG4gIHI0ICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByNCk7XG4gIGN0eC5saW5lVG8oeCwgeSArIHIxKTtcbiAgcjEgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHIxLCB5KTtcbn1cblxuZXhwb3J0cy5idWlsZFBhdGggPSBidWlsZFBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN1cnZlID0gcmVxdWlyZShcIi4vY3VydmVcIik7XG5cbnZhciB2ZWMyID0gcmVxdWlyZShcIi4vdmVjdG9yXCIpO1xuXG52YXIgYmJveCA9IHJlcXVpcmUoXCIuL2Jib3hcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcblxudmFyIGRwciA9IF9jb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcblxuLyoqXG4gKiBQYXRoIOS7o+eQhu+8jOWPr+S7peWcqGBidWlsZFBhdGhg5Lit55So5LqO5pu/5LujYGN0eGAsIOS8muS/neWtmOavj+S4qnBhdGjmk43kvZznmoTlkb3ku6TliLBwYXRoQ29tbWFuZHPlsZ7mgKfkuK1cbiAqIOWPr+S7peeUqOS6jiBpc0luc2lkZVBhdGgg5Yik5pat5Lul5Y+K6I635Y+WYm91bmRpbmdSZWN0XG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvUGF0aFByb3h5XG4gKiBAYXV0aG9yIFlpIFNoZW4gKGh0dHA6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBUT0RPIGdldFRvdGFsTGVuZ3RoLCBnZXRQb2ludEF0TGVuZ3RoXG52YXIgQ01EID0ge1xuICBNOiAxLFxuICBMOiAyLFxuICBDOiAzLFxuICBROiA0LFxuICBBOiA1LFxuICBaOiA2LFxuICAvLyBSZWN0XG4gIFI6IDdcbn07IC8vIHZhciBDTURfTUVNX1NJWkUgPSB7XG4vLyAgICAgTTogMyxcbi8vICAgICBMOiAzLFxuLy8gICAgIEM6IDcsXG4vLyAgICAgUTogNSxcbi8vICAgICBBOiA5LFxuLy8gICAgIFI6IDUsXG4vLyAgICAgWjogMVxuLy8gfTtcblxudmFyIG1pbiA9IFtdO1xudmFyIG1heCA9IFtdO1xudmFyIG1pbjIgPSBbXTtcbnZhciBtYXgyID0gW107XG52YXIgbWF0aE1pbiA9IE1hdGgubWluO1xudmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbnZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG52YXIgbWF0aFNpbiA9IE1hdGguc2luO1xudmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIG1hdGhBYnMgPSBNYXRoLmFicztcbnZhciBoYXNUeXBlZEFycmF5ID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPSAndW5kZWZpbmVkJztcbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgUGF0aFByb3h5ID0gZnVuY3Rpb24gKG5vdFNhdmVEYXRhKSB7XG4gIHRoaXMuX3NhdmVEYXRhID0gIShub3RTYXZlRGF0YSB8fCBmYWxzZSk7XG5cbiAgaWYgKHRoaXMuX3NhdmVEYXRhKSB7XG4gICAgLyoqXG4gICAgICogUGF0aCBkYXRhLiBTdG9yZWQgYXMgZmxhdCBhcnJheVxuICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgfVxuXG4gIHRoaXMuX2N0eCA9IG51bGw7XG59O1xuLyoqXG4gKiDlv6vpgJ/orqHnrpdQYXRo5YyF5Zu055uS77yI5bm25LiN5piv5pyA5bCP5YyF5Zu055uS77yJXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuXG5QYXRoUHJveHkucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGF0aFByb3h5LFxuICBfeGk6IDAsXG4gIF95aTogMCxcbiAgX3gwOiAwLFxuICBfeTA6IDAsXG4gIC8vIFVuaXQgeCwgVW5pdCB5LiBQcm92aWRlIGZvciBhdm9pZGluZyBkcmF3aW5nIHRoYXQgdG9vIHNob3J0IGxpbmUgc2VnbWVudFxuICBfdXg6IDAsXG4gIF91eTogMCxcbiAgX2xlbjogMCxcbiAgX2xpbmVEYXNoOiBudWxsLFxuICBfZGFzaE9mZnNldDogMCxcbiAgX2Rhc2hJZHg6IDAsXG4gIF9kYXNoU3VtOiAwLFxuXG4gIC8qKlxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIHNldFNjYWxlOiBmdW5jdGlvbiAoc3gsIHN5KSB7XG4gICAgdGhpcy5fdXggPSBtYXRoQWJzKDEgLyBkcHIgLyBzeCkgfHwgMDtcbiAgICB0aGlzLl91eSA9IG1hdGhBYnMoMSAvIGRwciAvIHN5KSB8fCAwO1xuICB9LFxuICBnZXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N0eDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBiZWdpblBhdGg6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgY3R4ICYmIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHggJiYgKHRoaXMuZHByID0gY3R4LmRwcik7IC8vIFJlc2V0XG5cbiAgICBpZiAodGhpcy5fc2F2ZURhdGEpIHtcbiAgICAgIHRoaXMuX2xlbiA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xpbmVEYXNoKSB7XG4gICAgICB0aGlzLl9saW5lRGFzaCA9IG51bGw7XG4gICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIG1vdmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELk0sIHgsIHkpO1xuICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHgubW92ZVRvKHgsIHkpOyAvLyB4MCwgeTAsIHhpLCB5aSDmmK/orrDlvZXlnKggX2Rhc2hlZFhYWFhUbyDmlrnms5XkuK3kvb/nlKhcbiAgICAvLyB4aSwgeWkg6K6w5b2V5b2T5YmN54K5LCB4MCwgeTAg5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnlm57liLDotbflp4vngrnjgIJcbiAgICAvLyDmnInlj6/og73lnKggYmVnaW5QYXRoIOS5i+WQjuebtOaOpeiwg+eUqCBsaW5lVG/vvIzov5nml7blgJkgeDAsIHkwIOmcgOimgVxuICAgIC8vIOWcqCBsaW5lVG8g5pa55rOV5Lit6K6w5b2V77yM6L+Z6YeM5YWI5LiN6ICD6JmR6L+Z56eN5oOF5Ya177yMZGFzaGVkIGxpbmUg5Lmf5Y+q5ZyoIElFMTAtIOS4reS4jeaUr+aMgVxuXG4gICAgdGhpcy5feDAgPSB4O1xuICAgIHRoaXMuX3kwID0geTtcbiAgICB0aGlzLl94aSA9IHg7XG4gICAgdGhpcy5feWkgPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgbGluZVRvOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHZhciBleGNlZWRVbml0ID0gbWF0aEFicyh4IC0gdGhpcy5feGkpID4gdGhpcy5fdXggfHwgbWF0aEFicyh5IC0gdGhpcy5feWkpID4gdGhpcy5fdXkgLy8gRm9yY2UgZHJhdyB0aGUgZmlyc3Qgc2VnbWVudFxuICAgIHx8IHRoaXMuX2xlbiA8IDU7XG4gICAgdGhpcy5hZGREYXRhKENNRC5MLCB4LCB5KTtcblxuICAgIGlmICh0aGlzLl9jdHggJiYgZXhjZWVkVW5pdCkge1xuICAgICAgdGhpcy5fbmVlZHNEYXNoKCkgPyB0aGlzLl9kYXNoZWRMaW5lVG8oeCwgeSkgOiB0aGlzLl9jdHgubGluZVRvKHgsIHkpO1xuICAgIH1cblxuICAgIGlmIChleGNlZWRVbml0KSB7XG4gICAgICB0aGlzLl94aSA9IHg7XG4gICAgICB0aGlzLl95aSA9IHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyXG4gICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4M1xuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkzXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELkMsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuXG4gICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgdGhpcy5fbmVlZHNEYXNoKCkgPyB0aGlzLl9kYXNoZWRCZXppZXJUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSA6IHRoaXMuX2N0eC5iZXppZXJDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgIH1cblxuICAgIHRoaXMuX3hpID0geDM7XG4gICAgdGhpcy5feWkgPSB5MztcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxXG4gICAqIEBwYXJhbSAge251bWJlcn0geDJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuUSwgeDEsIHkxLCB4MiwgeTIpO1xuXG4gICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgdGhpcy5fbmVlZHNEYXNoKCkgPyB0aGlzLl9kYXNoZWRRdWFkcmF0aWNUbyh4MSwgeTEsIHgyLCB5MikgOiB0aGlzLl9jdHgucXVhZHJhdGljQ3VydmVUbyh4MSwgeTEsIHgyLCB5Mik7XG4gICAgfVxuXG4gICAgdGhpcy5feGkgPSB4MjtcbiAgICB0aGlzLl95aSA9IHkyO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN4XG4gICAqIEBwYXJhbSAge251bWJlcn0gY3lcbiAgICogQHBhcmFtICB7bnVtYmVyfSByXG4gICAqIEBwYXJhbSAge251bWJlcn0gc3RhcnRBbmdsZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVuZEFuZ2xlXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGFudGljbG9ja3dpc2VcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBhcmM6IGZ1bmN0aW9uIChjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5BLCBjeCwgY3ksIHIsIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSwgMCwgYW50aWNsb2Nrd2lzZSA/IDAgOiAxKTtcbiAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4LmFyYyhjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKTtcbiAgICB0aGlzLl94aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogciArIGN4O1xuICAgIHRoaXMuX3lpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByICsgY3g7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIFRPRE9cbiAgYXJjVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSB7XG4gICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgdGhpcy5fY3R4LmFyY1RvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBUT0RPXG4gIHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgIHRoaXMuYWRkRGF0YShDTUQuUiwgeCwgeSwgdywgaCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgY2xvc2VQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5aKTtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHZhciB4MCA9IHRoaXMuX3gwO1xuICAgIHZhciB5MCA9IHRoaXMuX3kwO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgdGhpcy5fbmVlZHNEYXNoKCkgJiYgdGhpcy5fZGFzaGVkTGluZVRvKHgwLCB5MCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuXG4gICAgdGhpcy5feGkgPSB4MDtcbiAgICB0aGlzLl95aSA9IHkwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb250ZXh0IOS7juWklumDqOS8oOWFpe+8jOWboOS4uuacieWPr+iDveaYryByZWJ1aWxkUGF0aCDlrozkuYvlkI7lho0gZmlsbOOAglxuICAgKiBzdHJva2Ug5ZCM5qC3XG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBmaWxsOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgY3R4ICYmIGN0eC5maWxsKCk7XG4gICAgdGhpcy50b1N0YXRpYygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgc3Ryb2tlOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgY3R4ICYmIGN0eC5zdHJva2UoKTtcbiAgICB0aGlzLnRvU3RhdGljKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOW/hemhu+WcqOWFtuWug+e7mOWItuWRveS7pOWJjeiwg+eUqFxuICAgKiBNdXN0IGJlIGludm9rZWQgYmVmb3JlIGFsbCBvdGhlciBwYXRoIGRyYXdpbmcgbWV0aG9kc1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIHNldExpbmVEYXNoOiBmdW5jdGlvbiAobGluZURhc2gpIHtcbiAgICBpZiAobGluZURhc2ggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdGhpcy5fbGluZURhc2ggPSBsaW5lRGFzaDtcbiAgICAgIHRoaXMuX2Rhc2hJZHggPSAwO1xuICAgICAgdmFyIGxpbmVEYXNoU3VtID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lRGFzaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaW5lRGFzaFN1bSArPSBsaW5lRGFzaFtpXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZGFzaFN1bSA9IGxpbmVEYXNoU3VtO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBzZXRMaW5lRGFzaE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBsZW46IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuO1xuICB9LFxuXG4gIC8qKlxuICAgKiDnm7TmjqXorr7nva4gUGF0aCDmlbDmja5cbiAgICovXG4gIHNldERhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgaWYgKCEodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5sZW5ndGggPT0gbGVuKSAmJiBoYXNUeXBlZEFycmF5KSB7XG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGxlbik7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5kYXRhW2ldID0gZGF0YVtpXTtcbiAgICB9XG5cbiAgICB0aGlzLl9sZW4gPSBsZW47XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWtkOi3r+W+hFxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fEFycmF5Ljxtb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eT59IHBhdGhcbiAgICovXG4gIGFwcGVuZFBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgcGF0aCA9IFtwYXRoXTtcbiAgICB9XG5cbiAgICB2YXIgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgdmFyIGFwcGVuZFNpemUgPSAwO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9sZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcHBlbmRTaXplICs9IHBhdGhbaV0ubGVuKCk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1R5cGVkQXJyYXkgJiYgdGhpcy5kYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KG9mZnNldCArIGFwcGVuZFNpemUpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBhcHBlbmRQYXRoRGF0YSA9IHBhdGhbaV0uZGF0YTtcblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcHBlbmRQYXRoRGF0YS5sZW5ndGg7IGsrKykge1xuICAgICAgICB0aGlzLmRhdGFbb2Zmc2V0KytdID0gYXBwZW5kUGF0aERhdGFba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbGVuID0gb2Zmc2V0O1xuICB9LFxuXG4gIC8qKlxuICAgKiDloavlhYUgUGF0aCDmlbDmja7jgIJcbiAgICog5bC96YeP5aSN55So6ICM5LiN55Sz5piO5paw55qE5pWw57uE44CC5aSn6YOo5YiG5Zu+5b2i6YeN57uY55qE5oyH5Luk5pWw5o2u6ZW/5bqm6YO95piv5LiN5Y+Y55qE44CCXG4gICAqL1xuICBhZGREYXRhOiBmdW5jdGlvbiAoY21kKSB7XG4gICAgaWYgKCF0aGlzLl9zYXZlRGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgaWYgKHRoaXMuX2xlbiArIGFyZ3VtZW50cy5sZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgLy8g5Zug5Li65LmL5YmN55qE5pWw57uE5bey57uP6L2s5o2i5oiQ6Z2Z5oCB55qEIEZsb2F0MzJBcnJheVxuICAgICAgLy8g5omA5Lul5LiN5aSf55So5pe26ZyA6KaB5omp5bGV5LiA5Liq5paw55qE5Yqo5oCB5pWw57uEXG4gICAgICB0aGlzLl9leHBhbmREYXRhKCk7XG5cbiAgICAgIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFbdGhpcy5fbGVuKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIHRoaXMuX3ByZXZDbWQgPSBjbWQ7XG4gIH0sXG4gIF9leHBhbmREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gT25seSBpZiBkYXRhIGlzIEZsb2F0MzJBcnJheVxuICAgIGlmICghKHRoaXMuZGF0YSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgdmFyIG5ld0RhdGEgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sZW47IGkrKykge1xuICAgICAgICBuZXdEYXRhW2ldID0gdGhpcy5kYXRhW2ldO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRhdGEgPSBuZXdEYXRhO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSWYgbmVlZHMganMgaW1wbGVtZW50ZWQgZGFzaGVkIGxpbmVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9uZWVkc0Rhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGluZURhc2g7XG4gIH0sXG4gIF9kYXNoZWRMaW5lVG86IGZ1bmN0aW9uICh4MSwgeTEpIHtcbiAgICB2YXIgZGFzaFN1bSA9IHRoaXMuX2Rhc2hTdW07XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXQ7XG4gICAgdmFyIGxpbmVEYXNoID0gdGhpcy5fbGluZURhc2g7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICB2YXIgeDAgPSB0aGlzLl94aTtcbiAgICB2YXIgeTAgPSB0aGlzLl95aTtcbiAgICB2YXIgZHggPSB4MSAtIHgwO1xuICAgIHZhciBkeSA9IHkxIC0geTA7XG4gICAgdmFyIGRpc3QgPSBtYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgdmFyIHggPSB4MDtcbiAgICB2YXIgeSA9IHkwO1xuICAgIHZhciBkYXNoO1xuICAgIHZhciBuRGFzaCA9IGxpbmVEYXNoLmxlbmd0aDtcbiAgICB2YXIgaWR4O1xuICAgIGR4IC89IGRpc3Q7XG4gICAgZHkgLz0gZGlzdDtcblxuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAvLyBDb252ZXJ0IHRvIHBvc2l0aXZlIG9mZnNldFxuICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICB9XG5cbiAgICBvZmZzZXQgJT0gZGFzaFN1bTtcbiAgICB4IC09IG9mZnNldCAqIGR4O1xuICAgIHkgLT0gb2Zmc2V0ICogZHk7XG5cbiAgICB3aGlsZSAoZHggPiAwICYmIHggPD0geDEgfHwgZHggPCAwICYmIHggPj0geDEgfHwgZHggPT0gMCAmJiAoZHkgPiAwICYmIHkgPD0geTEgfHwgZHkgPCAwICYmIHkgPj0geTEpKSB7XG4gICAgICBpZHggPSB0aGlzLl9kYXNoSWR4O1xuICAgICAgZGFzaCA9IGxpbmVEYXNoW2lkeF07XG4gICAgICB4ICs9IGR4ICogZGFzaDtcbiAgICAgIHkgKz0gZHkgKiBkYXNoO1xuICAgICAgdGhpcy5fZGFzaElkeCA9IChpZHggKyAxKSAlIG5EYXNoOyAvLyBTa2lwIHBvc2l0aXZlIG9mZnNldFxuXG4gICAgICBpZiAoZHggPiAwICYmIHggPCB4MCB8fCBkeCA8IDAgJiYgeCA+IHgwIHx8IGR5ID4gMCAmJiB5IDwgeTAgfHwgZHkgPCAwICYmIHkgPiB5MCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY3R4W2lkeCAlIDIgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShkeCA+PSAwID8gbWF0aE1pbih4LCB4MSkgOiBtYXRoTWF4KHgsIHgxKSwgZHkgPj0gMCA/IG1hdGhNaW4oeSwgeTEpIDogbWF0aE1heCh5LCB5MSkpO1xuICAgIH0gLy8gT2Zmc2V0IGZvciBuZXh0IGxpbmVUb1xuXG5cbiAgICBkeCA9IHggLSB4MTtcbiAgICBkeSA9IHkgLSB5MTtcbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gLW1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgfSxcbiAgLy8gTm90IGFjY3VyYXRlIGRhc2hlZCBsaW5lIHRvXG4gIF9kYXNoZWRCZXppZXJUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICB2YXIgZGFzaFN1bSA9IHRoaXMuX2Rhc2hTdW07XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXQ7XG4gICAgdmFyIGxpbmVEYXNoID0gdGhpcy5fbGluZURhc2g7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICB2YXIgeDAgPSB0aGlzLl94aTtcbiAgICB2YXIgeTAgPSB0aGlzLl95aTtcbiAgICB2YXIgdDtcbiAgICB2YXIgZHg7XG4gICAgdmFyIGR5O1xuICAgIHZhciBjdWJpY0F0ID0gY3VydmUuY3ViaWNBdDtcbiAgICB2YXIgYmV6aWVyTGVuID0gMDtcbiAgICB2YXIgaWR4ID0gdGhpcy5fZGFzaElkeDtcbiAgICB2YXIgbkRhc2ggPSBsaW5lRGFzaC5sZW5ndGg7XG4gICAgdmFyIHg7XG4gICAgdmFyIHk7XG4gICAgdmFyIHRtcExlbiA9IDA7XG5cbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgLy8gQ29udmVydCB0byBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgIG9mZnNldCA9IGRhc2hTdW0gKyBvZmZzZXQ7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICU9IGRhc2hTdW07IC8vIEJlemllciBhcHByb3ggbGVuZ3RoXG5cbiAgICBmb3IgKHQgPSAwOyB0IDwgMTsgdCArPSAwLjEpIHtcbiAgICAgIGR4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCArIDAuMSkgLSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgIGR5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCArIDAuMSkgLSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgIGJlemllckxlbiArPSBtYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfSAvLyBGaW5kIGlkeCBhZnRlciBhZGQgb2Zmc2V0XG5cblxuICAgIGZvciAoOyBpZHggPCBuRGFzaDsgaWR4KyspIHtcbiAgICAgIHRtcExlbiArPSBsaW5lRGFzaFtpZHhdO1xuXG4gICAgICBpZiAodG1wTGVuID4gb2Zmc2V0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHQgPSAodG1wTGVuIC0gb2Zmc2V0KSAvIGJlemllckxlbjtcblxuICAgIHdoaWxlICh0IDw9IDEpIHtcbiAgICAgIHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgIHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTsgLy8gVXNlIGxpbmUgdG8gYXBwcm94aW1hdGUgZGFzaGVkIGJlemllclxuICAgICAgLy8gQmFkIHJlc3VsdCBpZiBkYXNoIGlzIGxvbmdcblxuICAgICAgaWR4ICUgMiA/IGN0eC5tb3ZlVG8oeCwgeSkgOiBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgdCArPSBsaW5lRGFzaFtpZHhdIC8gYmV6aWVyTGVuO1xuICAgICAgaWR4ID0gKGlkeCArIDEpICUgbkRhc2g7XG4gICAgfSAvLyBGaW5pc2ggdGhlIGxhc3Qgc2VnbWVudCBhbmQgY2FsY3VsYXRlIHRoZSBuZXcgb2Zmc2V0XG5cblxuICAgIGlkeCAlIDIgIT09IDAgJiYgY3R4LmxpbmVUbyh4MywgeTMpO1xuICAgIGR4ID0geDMgLSB4O1xuICAgIGR5ID0geTMgLSB5O1xuICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAtbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB9LFxuICBfZGFzaGVkUXVhZHJhdGljVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgIC8vIENvbnZlcnQgcXVhZHJhdGljIHRvIGN1YmljIHVzaW5nIGRlZ3JlZSBlbGV2YXRpb25cbiAgICB2YXIgeDMgPSB4MjtcbiAgICB2YXIgeTMgPSB5MjtcbiAgICB4MiA9ICh4MiArIDIgKiB4MSkgLyAzO1xuICAgIHkyID0gKHkyICsgMiAqIHkxKSAvIDM7XG4gICAgeDEgPSAodGhpcy5feGkgKyAyICogeDEpIC8gMztcbiAgICB5MSA9ICh0aGlzLl95aSArIDIgKiB5MSkgLyAzO1xuXG4gICAgdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOi9rOaIkOmdmeaAgeeahCBGbG9hdDMyQXJyYXkg5YeP5bCR5aCG5YaF5a2Y5Y2g55SoXG4gICAqIENvbnZlcnQgZHluYW1pYyBhcnJheSB0byBzdGF0aWMgRmxvYXQzMkFycmF5XG4gICAqL1xuICB0b1N0YXRpYzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZGF0YS5sZW5ndGggPSB0aGlzLl9sZW47XG5cbiAgICAgIGlmIChoYXNUeXBlZEFycmF5KSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICovXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIG1pblswXSA9IG1pblsxXSA9IG1pbjJbMF0gPSBtaW4yWzFdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBtYXhbMF0gPSBtYXhbMV0gPSBtYXgyWzBdID0gbWF4MlsxXSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciB4aSA9IDA7XG4gICAgdmFyIHlpID0gMDtcbiAgICB2YXIgeDAgPSAwO1xuICAgIHZhciB5MCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgdmFyIGNtZCA9IGRhdGFbaSsrXTtcblxuICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgIC8vXG4gICAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgeTAgPSB5aTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAgIC8vIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5L2/55SoXG4gICAgICAgICAgeDAgPSBkYXRhW2krK107XG4gICAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgIG1pbjJbMF0gPSB4MDtcbiAgICAgICAgICBtaW4yWzFdID0geTA7XG4gICAgICAgICAgbWF4MlswXSA9IHgwO1xuICAgICAgICAgIG1heDJbMV0gPSB5MDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgIGJib3guZnJvbUxpbmUoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICBiYm94LmZyb21DdWJpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgICAgYmJveC5mcm9tUXVhZHJhdGljKHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5BOlxuICAgICAgICAgIC8vIFRPRE8gQXJjIOWIpOaWreeahOW8gOmUgOavlOi+g+Wkp1xuICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBkYXRhW2krK10gKyBzdGFydEFuZ2xlOyAvLyBUT0RPIEFyYyDml4vovaxcblxuICAgICAgICAgIHZhciBwc2kgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgLy8g55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgICAgeDAgPSBtYXRoQ29zKHN0YXJ0QW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICAgIHkwID0gbWF0aFNpbihzdGFydEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmJveC5mcm9tQXJjKGN4LCBjeSwgcngsIHJ5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgeGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgeWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICB4MCA9IHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHkwID0geWkgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHdpZHRoID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2krK107IC8vIFVzZSBmcm9tTGluZVxuXG4gICAgICAgICAgYmJveC5mcm9tTGluZSh4MCwgeTAsIHgwICsgd2lkdGgsIHkwICsgaGVpZ2h0LCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gVW5pb25cblxuXG4gICAgICB2ZWMyLm1pbihtaW4sIG1pbiwgbWluMik7XG4gICAgICB2ZWMyLm1heChtYXgsIG1heCwgbWF4Mik7XG4gICAgfSAvLyBObyBkYXRhXG5cblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBtaW5bMF0gPSBtaW5bMV0gPSBtYXhbMF0gPSBtYXhbMV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYnVpbGQgcGF0aCBmcm9tIGN1cnJlbnQgZGF0YVxuICAgKiBSZWJ1aWxkIHBhdGggd2lsbCBub3QgY29uc2lkZXIgamF2YXNjcmlwdCBpbXBsZW1lbnRlZCBsaW5lIGRhc2guXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICovXG4gIHJlYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdmFyIGQgPSB0aGlzLmRhdGE7XG4gICAgdmFyIHgwLCB5MDtcbiAgICB2YXIgeGksIHlpO1xuICAgIHZhciB4LCB5O1xuICAgIHZhciB1eCA9IHRoaXMuX3V4O1xuICAgIHZhciB1eSA9IHRoaXMuX3V5O1xuICAgIHZhciBsZW4gPSB0aGlzLl9sZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgIHZhciBjbWQgPSBkW2krK107XG5cbiAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAvL1xuICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICB4aSA9IGRbaV07XG4gICAgICAgIHlpID0gZFtpICsgMV07XG4gICAgICAgIHgwID0geGk7XG4gICAgICAgIHkwID0geWk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgeDAgPSB4aSA9IGRbaSsrXTtcbiAgICAgICAgICB5MCA9IHlpID0gZFtpKytdO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeGksIHlpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgIHggPSBkW2krK107XG4gICAgICAgICAgeSA9IGRbaSsrXTsgLy8gTm90IGRyYXcgdG9vIHNtYWxsIHNlZyBiZXR3ZWVuXG5cbiAgICAgICAgICBpZiAobWF0aEFicyh4IC0geGkpID4gdXggfHwgbWF0aEFicyh5IC0geWkpID4gdXkgfHwgaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIHhpID0geDtcbiAgICAgICAgICAgIHlpID0geTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10pO1xuICAgICAgICAgIHhpID0gZFtpIC0gMl07XG4gICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgeGkgPSBkW2kgLSAyXTtcbiAgICAgICAgICB5aSA9IGRbaSAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgdmFyIGN4ID0gZFtpKytdO1xuICAgICAgICAgIHZhciBjeSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgcnggPSBkW2krK107XG4gICAgICAgICAgdmFyIHJ5ID0gZFtpKytdO1xuICAgICAgICAgIHZhciB0aGV0YSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgZFRoZXRhID0gZFtpKytdO1xuICAgICAgICAgIHZhciBwc2kgPSBkW2krK107XG4gICAgICAgICAgdmFyIGZzID0gZFtpKytdO1xuICAgICAgICAgIHZhciByID0gcnggPiByeSA/IHJ4IDogcnk7XG4gICAgICAgICAgdmFyIHNjYWxlWCA9IHJ4ID4gcnkgPyAxIDogcnggLyByeTtcbiAgICAgICAgICB2YXIgc2NhbGVZID0gcnggPiByeSA/IHJ5IC8gcnggOiAxO1xuICAgICAgICAgIHZhciBpc0VsbGlwc2UgPSBNYXRoLmFicyhyeCAtIHJ5KSA+IDFlLTM7XG4gICAgICAgICAgdmFyIGVuZEFuZ2xlID0gdGhldGEgKyBkVGhldGE7XG5cbiAgICAgICAgICBpZiAoaXNFbGxpcHNlKSB7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKHBzaSk7XG4gICAgICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByLCB0aGV0YSwgZW5kQW5nbGUsIDEgLSBmcyk7XG4gICAgICAgICAgICBjdHguc2NhbGUoMSAvIHNjYWxlWCwgMSAvIHNjYWxlWSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKC1wc2kpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5hcmMoY3gsIGN5LCByLCB0aGV0YSwgZW5kQW5nbGUsIDEgLSBmcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgLy8g55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgICAgeDAgPSBtYXRoQ29zKHRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICB5MCA9IG1hdGhTaW4odGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICB5aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgIHgwID0geGkgPSBkW2ldO1xuICAgICAgICAgIHkwID0geWkgPSBkW2kgKyAxXTtcbiAgICAgICAgICBjdHgucmVjdChkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgeWkgPSB5MDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5QYXRoUHJveHkuQ01EID0gQ01EO1xudmFyIF9kZWZhdWx0ID0gUGF0aFByb3h5O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9QYXRoUHJveHkuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4vdmVjdG9yXCIpO1xuXG52YXIgdjJDcmVhdGUgPSBfdmVjdG9yLmNyZWF0ZTtcbnZhciB2MkRpc3RTcXVhcmUgPSBfdmVjdG9yLmRpc3RTcXVhcmU7XG5cbi8qKlxuICog5puy57q/6L6F5Yqp5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xudmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBFUFNJTE9OID0gMWUtODtcbnZhciBFUFNJTE9OX05VTUVSSUMgPSAxZS00O1xudmFyIFRIUkVFX1NRUlQgPSBtYXRoU3FydCgzKTtcbnZhciBPTkVfVEhJUkQgPSAxIC8gMzsgLy8g5Li05pe25Y+Y6YePXG5cbnZhciBfdjAgPSB2MkNyZWF0ZSgpO1xuXG52YXIgX3YxID0gdjJDcmVhdGUoKTtcblxudmFyIF92MiA9IHYyQ3JlYXRlKCk7XG5cbmZ1bmN0aW9uIGlzQXJvdW5kWmVybyh2YWwpIHtcbiAgcmV0dXJuIHZhbCA+IC1FUFNJTE9OICYmIHZhbCA8IEVQU0lMT047XG59XG5cbmZ1bmN0aW9uIGlzTm90QXJvdW5kWmVybyh2YWwpIHtcbiAgcmV0dXJuIHZhbCA+IEVQU0lMT04gfHwgdmFsIDwgLUVQU0lMT047XG59XG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOWAvFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNBdChwMCwgcDEsIHAyLCBwMywgdCkge1xuICB2YXIgb25ldCA9IDEgLSB0O1xuICByZXR1cm4gb25ldCAqIG9uZXQgKiAob25ldCAqIHAwICsgMyAqIHQgKiBwMSkgKyB0ICogdCAqICh0ICogcDMgKyAzICogb25ldCAqIHAyKTtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5a+85pWw5YC8XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCBwMywgdCkge1xuICB2YXIgb25ldCA9IDEgLSB0O1xuICByZXR1cm4gMyAqICgoKHAxIC0gcDApICogb25ldCArIDIgKiAocDIgLSBwMSkgKiB0KSAqIG9uZXQgKyAocDMgLSBwMikgKiB0ICogdCk7XG59XG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+ague+8jOS9v+eUqOebm+mHkeWFrOW8j1xuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsXG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5qC55pWw55uuXG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY1Jvb3RBdChwMCwgcDEsIHAyLCBwMywgdmFsLCByb290cykge1xuICAvLyBFdmFsdWF0ZSByb290cyBvZiBjdWJpYyBmdW5jdGlvbnNcbiAgdmFyIGEgPSBwMyArIDMgKiAocDEgLSBwMikgLSBwMDtcbiAgdmFyIGIgPSAzICogKHAyIC0gcDEgKiAyICsgcDApO1xuICB2YXIgYyA9IDMgKiAocDEgLSBwMCk7XG4gIHZhciBkID0gcDAgLSB2YWw7XG4gIHZhciBBID0gYiAqIGIgLSAzICogYSAqIGM7XG4gIHZhciBCID0gYiAqIGMgLSA5ICogYSAqIGQ7XG4gIHZhciBDID0gYyAqIGMgLSAzICogYiAqIGQ7XG4gIHZhciBuID0gMDtcblxuICBpZiAoaXNBcm91bmRaZXJvKEEpICYmIGlzQXJvdW5kWmVybyhCKSkge1xuICAgIGlmIChpc0Fyb3VuZFplcm8oYikpIHtcbiAgICAgIHJvb3RzWzBdID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHQxID0gLWMgLyBiOyAvL3QxLCB0MiwgdDMsIGIgaXMgbm90IHplcm9cblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkaXNjID0gQiAqIEIgLSA0ICogQSAqIEM7XG5cbiAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICB2YXIgSyA9IEIgLyBBO1xuICAgICAgdmFyIHQxID0gLWIgLyBhICsgSzsgLy8gdDEsIGEgaXMgbm90IHplcm9cblxuICAgICAgdmFyIHQyID0gLUsgLyAyOyAvLyB0MiwgdDNcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgdmFyIFkxID0gQSAqIGIgKyAxLjUgKiBhICogKC1CICsgZGlzY1NxcnQpO1xuICAgICAgdmFyIFkyID0gQSAqIGIgKyAxLjUgKiBhICogKC1CIC0gZGlzY1NxcnQpO1xuXG4gICAgICBpZiAoWTEgPCAwKSB7XG4gICAgICAgIFkxID0gLW1hdGhQb3coLVkxLCBPTkVfVEhJUkQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWTEgPSBtYXRoUG93KFkxLCBPTkVfVEhJUkQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoWTIgPCAwKSB7XG4gICAgICAgIFkyID0gLW1hdGhQb3coLVkyLCBPTkVfVEhJUkQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWTIgPSBtYXRoUG93KFkyLCBPTkVfVEhJUkQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdDEgPSAoLWIgLSAoWTEgKyBZMikpIC8gKDMgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBUID0gKDIgKiBBICogYiAtIDMgKiBhICogQikgLyAoMiAqIG1hdGhTcXJ0KEEgKiBBICogQSkpO1xuICAgICAgdmFyIHRoZXRhID0gTWF0aC5hY29zKFQpIC8gMztcbiAgICAgIHZhciBBU3FydCA9IG1hdGhTcXJ0KEEpO1xuICAgICAgdmFyIHRtcCA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHZhciB0MSA9ICgtYiAtIDIgKiBBU3FydCAqIHRtcCkgLyAoMyAqIGEpO1xuICAgICAgdmFyIHQyID0gKC1iICsgQVNxcnQgKiAodG1wICsgVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcbiAgICAgIHZhciB0MyA9ICgtYiArIEFTcXJ0ICogKHRtcCAtIFRIUkVFX1NRUlQgKiBNYXRoLnNpbih0aGV0YSkpKSAvICgzICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgIH1cblxuICAgICAgaWYgKHQzID49IDAgJiYgdDMgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+aegemZkOWAvOeahOS9jee9rlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBleHRyZW1hXG4gKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOaVsOebrlxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNFeHRyZW1hKHAwLCBwMSwgcDIsIHAzLCBleHRyZW1hKSB7XG4gIHZhciBiID0gNiAqIHAyIC0gMTIgKiBwMSArIDYgKiBwMDtcbiAgdmFyIGEgPSA5ICogcDEgKyAzICogcDMgLSAzICogcDAgLSA5ICogcDI7XG4gIHZhciBjID0gMyAqIHAxIC0gMyAqIHAwO1xuICB2YXIgbiA9IDA7XG5cbiAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgIGlmIChpc05vdEFyb3VuZFplcm8oYikpIHtcbiAgICAgIHZhciB0MSA9IC1jIC8gYjtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcblxuICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgIGV4dHJlbWFbMF0gPSAtYiAvICgyICogYSk7XG4gICAgfSBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICBleHRyZW1hW24rK10gPSB0MjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cbi8qKlxuICog57uG5YiG5LiJ5qyh6LSd5aGe5bCU5puy57q/XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY1N1YmRpdmlkZShwMCwgcDEsIHAyLCBwMywgdCwgb3V0KSB7XG4gIHZhciBwMDEgPSAocDEgLSBwMCkgKiB0ICsgcDA7XG4gIHZhciBwMTIgPSAocDIgLSBwMSkgKiB0ICsgcDE7XG4gIHZhciBwMjMgPSAocDMgLSBwMikgKiB0ICsgcDI7XG4gIHZhciBwMDEyID0gKHAxMiAtIHAwMSkgKiB0ICsgcDAxO1xuICB2YXIgcDEyMyA9IChwMjMgLSBwMTIpICogdCArIHAxMjtcbiAgdmFyIHAwMTIzID0gKHAxMjMgLSBwMDEyKSAqIHQgKyBwMDEyOyAvLyBTZWcwXG5cbiAgb3V0WzBdID0gcDA7XG4gIG91dFsxXSA9IHAwMTtcbiAgb3V0WzJdID0gcDAxMjtcbiAgb3V0WzNdID0gcDAxMjM7IC8vIFNlZzFcblxuICBvdXRbNF0gPSBwMDEyMztcbiAgb3V0WzVdID0gcDEyMztcbiAgb3V0WzZdID0gcDIzO1xuICBvdXRbN10gPSBwMztcbn1cbi8qKlxuICog5oqV5bCE54K55Yiw5LiJ5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gKiDmipXlsITngrnmnInlj6/og73kvJrmnInkuIDkuKrmiJbogIXlpJrkuKrvvIzov5nph4zlj6rov5Tlm57lhbbkuK3ot53nprvmnIDnn63nmoTkuIDkuKrjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIOaKleWwhOeCuVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5LCBvdXQpIHtcbiAgLy8gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNwcm9qZWN0aW9uc1xuICB2YXIgdDtcbiAgdmFyIGludGVydmFsID0gMC4wMDU7XG4gIHZhciBkID0gSW5maW5pdHk7XG4gIHZhciBwcmV2O1xuICB2YXIgbmV4dDtcbiAgdmFyIGQxO1xuICB2YXIgZDI7XG4gIF92MFswXSA9IHg7XG4gIF92MFsxXSA9IHk7IC8vIOWFiOeyl+eVpeS8sOiuoeS4gOS4i+WPr+iDveeahOacgOWwj+i3neemu+eahCB0IOWAvFxuICAvLyBQRU5ESU5HXG5cbiAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICBfdjFbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBfdCk7XG4gICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgX3QpO1xuICAgIGQxID0gdjJEaXN0U3F1YXJlKF92MCwgX3YxKTtcblxuICAgIGlmIChkMSA8IGQpIHtcbiAgICAgIHQgPSBfdDtcbiAgICAgIGQgPSBkMTtcbiAgICB9XG4gIH1cblxuICBkID0gSW5maW5pdHk7IC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgIG5leHQgPSB0ICsgaW50ZXJ2YWw7IC8vIHQgLSBpbnRlcnZhbFxuXG4gICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgcHJldik7XG4gICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgcHJldik7XG4gICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgaWYgKHByZXYgPj0gMCAmJiBkMSA8IGQpIHtcbiAgICAgIHQgPSBwcmV2O1xuICAgICAgZCA9IGQxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ICsgaW50ZXJ2YWxcbiAgICAgIF92MlswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIG5leHQpO1xuICAgICAgX3YyWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgbmV4dCk7XG4gICAgICBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG5cbiAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgIHQgPSBuZXh0O1xuICAgICAgICBkID0gZDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHRcblxuXG4gIGlmIChvdXQpIHtcbiAgICBvdXRbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICBvdXRbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgfSAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG5cblxuICByZXR1cm4gbWF0aFNxcnQoZCk7XG59XG4vKipcbiAqIOiuoeeul+S6jOasoeaWuei0neWhnuWwlOWAvFxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNBdChwMCwgcDEsIHAyLCB0KSB7XG4gIHZhciBvbmV0ID0gMSAtIHQ7XG4gIHJldHVybiBvbmV0ICogKG9uZXQgKiBwMCArIDIgKiB0ICogcDEpICsgdCAqIHQgKiBwMjtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5a+85pWw5YC8XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCB0KSB7XG4gIHJldHVybiAyICogKCgxIC0gdCkgKiAocDEgLSBwMCkgKyB0ICogKHAyIC0gcDEpKTtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5pa556iL5qC5XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmoLnmlbDnm65cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY1Jvb3RBdChwMCwgcDEsIHAyLCB2YWwsIHJvb3RzKSB7XG4gIHZhciBhID0gcDAgLSAyICogcDEgKyBwMjtcbiAgdmFyIGIgPSAyICogKHAxIC0gcDApO1xuICB2YXIgYyA9IHAwIC0gdmFsO1xuICB2YXIgbiA9IDA7XG5cbiAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgIGlmIChpc05vdEFyb3VuZFplcm8oYikpIHtcbiAgICAgIHZhciB0MSA9IC1jIC8gYjtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkaXNjID0gYiAqIGIgLSA0ICogYSAqIGM7XG5cbiAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICB2YXIgdDEgPSAtYiAvICgyICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgdmFyIHQxID0gKC1iICsgZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgIHZhciB0MiA9ICgtYiAtIGRpc2NTcXJ0KSAvICgyICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh6LSd5aGe5bCU5pa556iL5p6B6ZmQ5YC8XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljRXh0cmVtdW0ocDAsIHAxLCBwMikge1xuICB2YXIgZGl2aWRlciA9IHAwICsgcDIgLSAyICogcDE7XG5cbiAgaWYgKGRpdmlkZXIgPT09IDApIHtcbiAgICAvLyBwMSBpcyBjZW50ZXIgb2YgcDAgYW5kIHAyXG4gICAgcmV0dXJuIDAuNTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHAwIC0gcDEpIC8gZGl2aWRlcjtcbiAgfVxufVxuLyoqXG4gKiDnu4bliIbkuozmrKHotJ3loZ7lsJTmm7Lnur9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY1N1YmRpdmlkZShwMCwgcDEsIHAyLCB0LCBvdXQpIHtcbiAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgdmFyIHAxMiA9IChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgdmFyIHAwMTIgPSAocDEyIC0gcDAxKSAqIHQgKyBwMDE7IC8vIFNlZzBcblxuICBvdXRbMF0gPSBwMDtcbiAgb3V0WzFdID0gcDAxO1xuICBvdXRbMl0gPSBwMDEyOyAvLyBTZWcxXG5cbiAgb3V0WzNdID0gcDAxMjtcbiAgb3V0WzRdID0gcDEyO1xuICBvdXRbNV0gPSBwMjtcbn1cbi8qKlxuICog5oqV5bCE54K55Yiw5LqM5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gKiDmipXlsITngrnmnInlj6/og73kvJrmnInkuIDkuKrmiJbogIXlpJrkuKrvvIzov5nph4zlj6rov5Tlm57lhbbkuK3ot53nprvmnIDnn63nmoTkuIDkuKrjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0IOaKleWwhOeCuVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljUHJvamVjdFBvaW50KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHksIG91dCkge1xuICAvLyBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI3Byb2plY3Rpb25zXG4gIHZhciB0O1xuICB2YXIgaW50ZXJ2YWwgPSAwLjAwNTtcbiAgdmFyIGQgPSBJbmZpbml0eTtcbiAgX3YwWzBdID0geDtcbiAgX3YwWzFdID0geTsgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gIC8vIFBFTkRJTkdcblxuICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIF90KTtcbiAgICBfdjFbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBfdCk7XG4gICAgdmFyIGQxID0gdjJEaXN0U3F1YXJlKF92MCwgX3YxKTtcblxuICAgIGlmIChkMSA8IGQpIHtcbiAgICAgIHQgPSBfdDtcbiAgICAgIGQgPSBkMTtcbiAgICB9XG4gIH1cblxuICBkID0gSW5maW5pdHk7IC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICB2YXIgbmV4dCA9IHQgKyBpbnRlcnZhbDsgLy8gdCAtIGludGVydmFsXG5cbiAgICBfdjFbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBwcmV2KTtcbiAgICBfdjFbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBwcmV2KTtcbiAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgaWYgKHByZXYgPj0gMCAmJiBkMSA8IGQpIHtcbiAgICAgIHQgPSBwcmV2O1xuICAgICAgZCA9IGQxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ICsgaW50ZXJ2YWxcbiAgICAgIF92MlswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIG5leHQpO1xuICAgICAgX3YyWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgbmV4dCk7XG4gICAgICB2YXIgZDIgPSB2MkRpc3RTcXVhcmUoX3YyLCBfdjApO1xuXG4gICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgZCA9IGQyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyB0XG5cblxuICBpZiAob3V0KSB7XG4gICAgb3V0WzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgdCk7XG4gICAgb3V0WzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG4gIH0gLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuXG5cbiAgcmV0dXJuIG1hdGhTcXJ0KGQpO1xufVxuXG5leHBvcnRzLmN1YmljQXQgPSBjdWJpY0F0O1xuZXhwb3J0cy5jdWJpY0Rlcml2YXRpdmVBdCA9IGN1YmljRGVyaXZhdGl2ZUF0O1xuZXhwb3J0cy5jdWJpY1Jvb3RBdCA9IGN1YmljUm9vdEF0O1xuZXhwb3J0cy5jdWJpY0V4dHJlbWEgPSBjdWJpY0V4dHJlbWE7XG5leHBvcnRzLmN1YmljU3ViZGl2aWRlID0gY3ViaWNTdWJkaXZpZGU7XG5leHBvcnRzLmN1YmljUHJvamVjdFBvaW50ID0gY3ViaWNQcm9qZWN0UG9pbnQ7XG5leHBvcnRzLnF1YWRyYXRpY0F0ID0gcXVhZHJhdGljQXQ7XG5leHBvcnRzLnF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IHF1YWRyYXRpY0Rlcml2YXRpdmVBdDtcbmV4cG9ydHMucXVhZHJhdGljUm9vdEF0ID0gcXVhZHJhdGljUm9vdEF0O1xuZXhwb3J0cy5xdWFkcmF0aWNFeHRyZW11bSA9IHF1YWRyYXRpY0V4dHJlbXVtO1xuZXhwb3J0cy5xdWFkcmF0aWNTdWJkaXZpZGUgPSBxdWFkcmF0aWNTdWJkaXZpZGU7XG5leHBvcnRzLnF1YWRyYXRpY1Byb2plY3RQb2ludCA9IHF1YWRyYXRpY1Byb2plY3RQb2ludDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9jdXJ2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHZlYzIgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoXCIuL2N1cnZlXCIpO1xuXG4vKipcbiAqIEBhdXRob3IgWWkgU2hlbihodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aFNpbiA9IE1hdGguc2luO1xudmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbnZhciBzdGFydCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgZW5kID0gdmVjMi5jcmVhdGUoKTtcbnZhciBleHRyZW1pdHkgPSB2ZWMyLmNyZWF0ZSgpO1xuLyoqXG4gKiDku47pobbngrnmlbDnu4TkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvaW50cyDpobbngrnmlbDnu4RcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqL1xuXG5mdW5jdGlvbiBmcm9tUG9pbnRzKHBvaW50cywgbWluLCBtYXgpIHtcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcCA9IHBvaW50c1swXTtcbiAgdmFyIGxlZnQgPSBwWzBdO1xuICB2YXIgcmlnaHQgPSBwWzBdO1xuICB2YXIgdG9wID0gcFsxXTtcbiAgdmFyIGJvdHRvbSA9IHBbMV07XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBwID0gcG9pbnRzW2ldO1xuICAgIGxlZnQgPSBtYXRoTWluKGxlZnQsIHBbMF0pO1xuICAgIHJpZ2h0ID0gbWF0aE1heChyaWdodCwgcFswXSk7XG4gICAgdG9wID0gbWF0aE1pbih0b3AsIHBbMV0pO1xuICAgIGJvdHRvbSA9IG1hdGhNYXgoYm90dG9tLCBwWzFdKTtcbiAgfVxuXG4gIG1pblswXSA9IGxlZnQ7XG4gIG1pblsxXSA9IHRvcDtcbiAgbWF4WzBdID0gcmlnaHQ7XG4gIG1heFsxXSA9IGJvdHRvbTtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cblxuZnVuY3Rpb24gZnJvbUxpbmUoeDAsIHkwLCB4MSwgeTEsIG1pbiwgbWF4KSB7XG4gIG1pblswXSA9IG1hdGhNaW4oeDAsIHgxKTtcbiAgbWluWzFdID0gbWF0aE1pbih5MCwgeTEpO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MSk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkxKTtcbn1cblxudmFyIHhEaW0gPSBbXTtcbnZhciB5RGltID0gW107XG4vKipcbiAqIOS7juS4iemYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyLCBwMynkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gKiBAcGFyYW0ge251bWJlcn0geDNcbiAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuXG5mdW5jdGlvbiBmcm9tQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW4sIG1heCkge1xuICB2YXIgY3ViaWNFeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hO1xuICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gIHZhciBpO1xuICB2YXIgbiA9IGN1YmljRXh0cmVtYSh4MCwgeDEsIHgyLCB4MywgeERpbSk7XG4gIG1pblswXSA9IEluZmluaXR5O1xuICBtaW5bMV0gPSBJbmZpbml0eTtcbiAgbWF4WzBdID0gLUluZmluaXR5O1xuICBtYXhbMV0gPSAtSW5maW5pdHk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgeERpbVtpXSk7XG4gICAgbWluWzBdID0gbWF0aE1pbih4LCBtaW5bMF0pO1xuICAgIG1heFswXSA9IG1hdGhNYXgoeCwgbWF4WzBdKTtcbiAgfVxuXG4gIG4gPSBjdWJpY0V4dHJlbWEoeTAsIHkxLCB5MiwgeTMsIHlEaW0pO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHlEaW1baV0pO1xuICAgIG1pblsxXSA9IG1hdGhNaW4oeSwgbWluWzFdKTtcbiAgICBtYXhbMV0gPSBtYXRoTWF4KHksIG1heFsxXSk7XG4gIH1cblxuICBtaW5bMF0gPSBtYXRoTWluKHgwLCBtaW5bMF0pO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgwLCBtYXhbMF0pO1xuICBtaW5bMF0gPSBtYXRoTWluKHgzLCBtaW5bMF0pO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgzLCBtYXhbMF0pO1xuICBtaW5bMV0gPSBtYXRoTWluKHkwLCBtaW5bMV0pO1xuICBtYXhbMV0gPSBtYXRoTWF4KHkwLCBtYXhbMV0pO1xuICBtaW5bMV0gPSBtYXRoTWluKHkzLCBtaW5bMV0pO1xuICBtYXhbMV0gPSBtYXRoTWF4KHkzLCBtYXhbMV0pO1xufVxuLyoqXG4gKiDku47kuozpmLbotJ3loZ7lsJTmm7Lnur8ocDAsIHAxLCBwMinkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cblxuZnVuY3Rpb24gZnJvbVF1YWRyYXRpYyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBtaW4sIG1heCkge1xuICB2YXIgcXVhZHJhdGljRXh0cmVtdW0gPSBjdXJ2ZS5xdWFkcmF0aWNFeHRyZW11bTtcbiAgdmFyIHF1YWRyYXRpY0F0ID0gY3VydmUucXVhZHJhdGljQXQ7IC8vIEZpbmQgZXh0cmVtaXRpZXMsIHdoZXJlIGRlcml2YXRpdmUgaW4geCBkaW0gb3IgeSBkaW0gaXMgemVyb1xuXG4gIHZhciB0eCA9IG1hdGhNYXgobWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh4MCwgeDEsIHgyKSwgMSksIDApO1xuICB2YXIgdHkgPSBtYXRoTWF4KG1hdGhNaW4ocXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5MiksIDEpLCAwKTtcbiAgdmFyIHggPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0eCk7XG4gIHZhciB5ID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdHkpO1xuICBtaW5bMF0gPSBtYXRoTWluKHgwLCB4MiwgeCk7XG4gIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkyLCB5KTtcbiAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDIsIHgpO1xuICBtYXhbMV0gPSBtYXRoTWF4KHkwLCB5MiwgeSk7XG59XG4vKipcbiAqIOS7juWchuW8p+S4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IHJ4XG4gKiBAcGFyYW0ge251bWJlcn0gcnlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kQW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbnRpY2xvY2t3aXNlXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cblxuZnVuY3Rpb24gZnJvbUFyYyh4LCB5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBtaW4sIG1heCkge1xuICB2YXIgdmVjMk1pbiA9IHZlYzIubWluO1xuICB2YXIgdmVjMk1heCA9IHZlYzIubWF4O1xuICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG5cbiAgaWYgKGRpZmYgJSBQSTIgPCAxZS00ICYmIGRpZmYgPiAxZS00KSB7XG4gICAgLy8gSXMgYSBjaXJjbGVcbiAgICBtaW5bMF0gPSB4IC0gcng7XG4gICAgbWluWzFdID0geSAtIHJ5O1xuICAgIG1heFswXSA9IHggKyByeDtcbiAgICBtYXhbMV0gPSB5ICsgcnk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhcnRbMF0gPSBtYXRoQ29zKHN0YXJ0QW5nbGUpICogcnggKyB4O1xuICBzdGFydFsxXSA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIHk7XG4gIGVuZFswXSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyB4O1xuICBlbmRbMV0gPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgeTtcbiAgdmVjMk1pbihtaW4sIHN0YXJ0LCBlbmQpO1xuICB2ZWMyTWF4KG1heCwgc3RhcnQsIGVuZCk7IC8vIFRocmVzaCB0byBbMCwgTWF0aC5QSSAqIDJdXG5cbiAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgJSBQSTI7XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPCAwKSB7XG4gICAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBQSTI7XG4gIH1cblxuICBlbmRBbmdsZSA9IGVuZEFuZ2xlICUgUEkyO1xuXG4gIGlmIChlbmRBbmdsZSA8IDApIHtcbiAgICBlbmRBbmdsZSA9IGVuZEFuZ2xlICsgUEkyO1xuICB9XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSAmJiAhYW50aWNsb2Nrd2lzZSkge1xuICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgfSBlbHNlIGlmIChzdGFydEFuZ2xlIDwgZW5kQW5nbGUgJiYgYW50aWNsb2Nrd2lzZSkge1xuICAgIHN0YXJ0QW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgdG1wID0gZW5kQW5nbGU7XG4gICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgIHN0YXJ0QW5nbGUgPSB0bXA7XG4gIH0gLy8gdmFyIG51bWJlciA9IDA7XG4gIC8vIHZhciBzdGVwID0gKGFudGljbG9ja3dpc2UgPyAtTWF0aC5QSSA6IE1hdGguUEkpIC8gMjtcblxuXG4gIGZvciAodmFyIGFuZ2xlID0gMDsgYW5nbGUgPCBlbmRBbmdsZTsgYW5nbGUgKz0gTWF0aC5QSSAvIDIpIHtcbiAgICBpZiAoYW5nbGUgPiBzdGFydEFuZ2xlKSB7XG4gICAgICBleHRyZW1pdHlbMF0gPSBtYXRoQ29zKGFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgIGV4dHJlbWl0eVsxXSA9IG1hdGhTaW4oYW5nbGUpICogcnkgKyB5O1xuICAgICAgdmVjMk1pbihtaW4sIGV4dHJlbWl0eSwgbWluKTtcbiAgICAgIHZlYzJNYXgobWF4LCBleHRyZW1pdHksIG1heCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuZnJvbVBvaW50cyA9IGZyb21Qb2ludHM7XG5leHBvcnRzLmZyb21MaW5lID0gZnJvbUxpbmU7XG5leHBvcnRzLmZyb21DdWJpYyA9IGZyb21DdWJpYztcbmV4cG9ydHMuZnJvbVF1YWRyYXRpYyA9IGZyb21RdWFkcmF0aWM7XG5leHBvcnRzLmZyb21BcmMgPSBmcm9tQXJjO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL2Jib3guanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBsaW5lID0gcmVxdWlyZShcIi4vbGluZVwiKTtcblxudmFyIGN1YmljID0gcmVxdWlyZShcIi4vY3ViaWNcIik7XG5cbnZhciBxdWFkcmF0aWMgPSByZXF1aXJlKFwiLi9xdWFkcmF0aWNcIik7XG5cbnZhciBhcmMgPSByZXF1aXJlKFwiLi9hcmNcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBub3JtYWxpemVSYWRpYW4gPSBfdXRpbC5ub3JtYWxpemVSYWRpYW47XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoXCIuLi9jb3JlL2N1cnZlXCIpO1xuXG52YXIgd2luZGluZ0xpbmUgPSByZXF1aXJlKFwiLi93aW5kaW5nTGluZVwiKTtcblxudmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG52YXIgRVBTSUxPTiA9IDFlLTQ7XG5cbmZ1bmN0aW9uIGlzQXJvdW5kRXF1YWwoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgRVBTSUxPTjtcbn0gLy8g5Li05pe25pWw57uEXG5cblxudmFyIHJvb3RzID0gWy0xLCAtMSwgLTFdO1xudmFyIGV4dHJlbWEgPSBbLTEsIC0xXTtcblxuZnVuY3Rpb24gc3dhcEV4dHJlbWEoKSB7XG4gIHZhciB0bXAgPSBleHRyZW1hWzBdO1xuICBleHRyZW1hWzBdID0gZXh0cmVtYVsxXTtcbiAgZXh0cmVtYVsxXSA9IHRtcDtcbn1cblxuZnVuY3Rpb24gd2luZGluZ0N1YmljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSkge1xuICAvLyBRdWljayByZWplY3RcbiAgaWYgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyICYmIHkgPiB5MyB8fCB5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5MiAmJiB5IDwgeTMpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBuUm9vdHMgPSBjdXJ2ZS5jdWJpY1Jvb3RBdCh5MCwgeTEsIHkyLCB5MywgeSwgcm9vdHMpO1xuXG4gIGlmIChuUm9vdHMgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdyA9IDA7XG4gICAgdmFyIG5FeHRyZW1hID0gLTE7XG4gICAgdmFyIHkwXywgeTFfO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUm9vdHM7IGkrKykge1xuICAgICAgdmFyIHQgPSByb290c1tpXTsgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG5cbiAgICAgIHZhciB1bml0ID0gdCA9PT0gMCB8fCB0ID09PSAxID8gMC41IDogMTtcbiAgICAgIHZhciB4XyA9IGN1cnZlLmN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuXG4gICAgICBpZiAoeF8gPCB4KSB7XG4gICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5FeHRyZW1hIDwgMCkge1xuICAgICAgICBuRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYSk7XG5cbiAgICAgICAgaWYgKGV4dHJlbWFbMV0gPCBleHRyZW1hWzBdICYmIG5FeHRyZW1hID4gMSkge1xuICAgICAgICAgIHN3YXBFeHRyZW1hKCk7XG4gICAgICAgIH1cblxuICAgICAgICB5MF8gPSBjdXJ2ZS5jdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hWzBdKTtcblxuICAgICAgICBpZiAobkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgeTFfID0gY3VydmUuY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5FeHRyZW1hID09IDIpIHtcbiAgICAgICAgLy8g5YiG5oiQ5LiJ5q615Y2V6LCD5Ye95pWwXG4gICAgICAgIGlmICh0IDwgZXh0cmVtYVswXSkge1xuICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH0gZWxzZSBpZiAodCA8IGV4dHJlbWFbMV0pIHtcbiAgICAgICAgICB3ICs9IHkxXyA8IHkwXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHkzIDwgeTFfID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyDliIbmiJDkuKTmrrXljZXosIPlh73mlbBcbiAgICAgICAgaWYgKHQgPCBleHRyZW1hWzBdKSB7XG4gICAgICAgICAgdyArPSB5MF8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHkzIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2luZGluZ1F1YWRyYXRpYyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gIC8vIFF1aWNrIHJlamVjdFxuICBpZiAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIgfHwgeSA8IHkwICYmIHkgPCB5MSAmJiB5IDwgeTIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBuUm9vdHMgPSBjdXJ2ZS5xdWFkcmF0aWNSb290QXQoeTAsIHkxLCB5MiwgeSwgcm9vdHMpO1xuXG4gIGlmIChuUm9vdHMgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdCA9IGN1cnZlLnF1YWRyYXRpY0V4dHJlbXVtKHkwLCB5MSwgeTIpO1xuXG4gICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgIHZhciB3ID0gMDtcbiAgICAgIHZhciB5XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICAgIC8vIFJlbW92ZSBvbmUgZW5kcG9pbnQuXG4gICAgICAgIHZhciB1bml0ID0gcm9vdHNbaV0gPT09IDAgfHwgcm9vdHNbaV0gPT09IDEgPyAwLjUgOiAxO1xuICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCByb290c1tpXSk7XG5cbiAgICAgICAgaWYgKHhfIDwgeCkge1xuICAgICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvb3RzW2ldIDwgdCkge1xuICAgICAgICAgIHcgKz0geV8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHkyIDwgeV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSBvbmUgZW5kcG9pbnQuXG4gICAgICB2YXIgdW5pdCA9IHJvb3RzWzBdID09PSAwIHx8IHJvb3RzWzBdID09PSAxID8gMC41IDogMTtcbiAgICAgIHZhciB4XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHJvb3RzWzBdKTtcblxuICAgICAgaWYgKHhfIDwgeCkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB5MiA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgIH1cbiAgfVxufSAvLyBUT0RPXG4vLyBBcmMg5peL6L2sXG5cblxuZnVuY3Rpb24gd2luZGluZ0FyYyhjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCB4LCB5KSB7XG4gIHkgLT0gY3k7XG5cbiAgaWYgKHkgPiByIHx8IHkgPCAtcikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHRtcCA9IE1hdGguc3FydChyICogciAtIHkgKiB5KTtcbiAgcm9vdHNbMF0gPSAtdG1wO1xuICByb290c1sxXSA9IHRtcDtcbiAgdmFyIGRpZmYgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuXG4gIGlmIChkaWZmIDwgMWUtNCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGRpZmYgJSBQSTIgPCAxZS00KSB7XG4gICAgLy8gSXMgYSBjaXJjbGVcbiAgICBzdGFydEFuZ2xlID0gMDtcbiAgICBlbmRBbmdsZSA9IFBJMjtcbiAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcblxuICAgIGlmICh4ID49IHJvb3RzWzBdICsgY3ggJiYgeCA8PSByb290c1sxXSArIGN4KSB7XG4gICAgICByZXR1cm4gZGlyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHRtcCk7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihzdGFydEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gIH1cblxuICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlKSB7XG4gICAgZW5kQW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgdmFyIHcgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgdmFyIHhfID0gcm9vdHNbaV07XG5cbiAgICBpZiAoeF8gKyBjeCA+IHgpIHtcbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeF8pO1xuICAgICAgdmFyIGRpciA9IGFudGljbG9ja3dpc2UgPyAxIDogLTE7XG5cbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgYW5nbGUgPSBQSTIgKyBhbmdsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUgfHwgYW5nbGUgKyBQSTIgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSArIFBJMiA8PSBlbmRBbmdsZSkge1xuICAgICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJIC8gMiAmJiBhbmdsZSA8IE1hdGguUEkgKiAxLjUpIHtcbiAgICAgICAgICBkaXIgPSAtZGlyO1xuICAgICAgICB9XG5cbiAgICAgICAgdyArPSBkaXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHc7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5QYXRoKGRhdGEsIGxpbmVXaWR0aCwgaXNTdHJva2UsIHgsIHkpIHtcbiAgdmFyIHcgPSAwO1xuICB2YXIgeGkgPSAwO1xuICB2YXIgeWkgPSAwO1xuICB2YXIgeDAgPSAwO1xuICB2YXIgeTAgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgdmFyIGNtZCA9IGRhdGFbaSsrXTsgLy8gQmVnaW4gYSBuZXcgc3VicGF0aFxuXG4gICAgaWYgKGNtZCA9PT0gQ01ELk0gJiYgaSA+IDEpIHtcbiAgICAgIC8vIENsb3NlIHByZXZpb3VzIHN1YnBhdGhcbiAgICAgIGlmICghaXNTdHJva2UpIHtcbiAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSk7XG4gICAgICB9IC8vIOWmguaenOiiq+S7u+S9leS4gOS4qiBzdWJwYXRoIOWMheWQq1xuICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIH1cblxuICAgIH1cblxuICAgIGlmIChpID09IDEpIHtcbiAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAvL1xuICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgIHlpID0gZGF0YVtpICsgMV07XG4gICAgICB4MCA9IHhpO1xuICAgICAgeTAgPSB5aTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgLy8gbW92ZVRvIOWRveS7pOmHjeaWsOWIm+W7uuS4gOS4quaWsOeahCBzdWJwYXRoLCDlubbkuJTmm7TmlrDmlrDnmoTotbfngrlcbiAgICAgICAgLy8g5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnkvb/nlKhcbiAgICAgICAgeDAgPSBkYXRhW2krK107XG4gICAgICAgIHkwID0gZGF0YVtpKytdO1xuICAgICAgICB4aSA9IHgwO1xuICAgICAgICB5aSA9IHkwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKGxpbmUuY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTk9URSDlnKjnrKzkuIDkuKrlkb3ku6TkuLogTCwgQywgUSDnmoTml7blgJnkvJrorqHnrpflh7ogTmFOXG4gICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCB4LCB5KSB8fCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKGN1YmljLmNvbnRhaW5TdHJva2UoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB3aW5kaW5nQ3ViaWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCB4LCB5KSB8fCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKHF1YWRyYXRpYy5jb250YWluU3Ryb2tlKHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB3aW5kaW5nUXVhZHJhdGljKHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCB4LCB5KSB8fCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgZFRoZXRhID0gZGF0YVtpKytdOyAvLyBUT0RPIEFyYyDml4vovaxcblxuICAgICAgICB2YXIgcHNpID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgYW50aWNsb2Nrd2lzZSA9IDEgLSBkYXRhW2krK107XG4gICAgICAgIHZhciB4MSA9IE1hdGguY29zKHRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgIHZhciB5MSA9IE1hdGguc2luKHRoZXRhKSAqIHJ5ICsgY3k7IC8vIOS4jeaYr+ebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG5cbiAgICAgICAgaWYgKGkgPiAxKSB7XG4gICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgxLCB5MSwgeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgICB5MCA9IHkxO1xuICAgICAgICB9IC8vIHpyIOS9v+eUqHNjYWxl5p2l5qih5ouf5qSt5ZyGLCDov5nph4zkuZ/lr7l45YGa5LiA5a6a55qE57yp5pS+XG5cblxuICAgICAgICB2YXIgX3ggPSAoeCAtIGN4KSAqIHJ5IC8gcnggKyBjeDtcblxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAoYXJjLmNvbnRhaW5TdHJva2UoY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLCBsaW5lV2lkdGgsIF94LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0gd2luZGluZ0FyYyhjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsIF94LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhpID0gTWF0aC5jb3ModGhldGEgKyBkVGhldGEpICogcnggKyBjeDtcbiAgICAgICAgeWkgPSBNYXRoLnNpbih0aGV0YSArIGRUaGV0YSkgKiByeSArIGN5O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgeDAgPSB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeTAgPSB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHdpZHRoID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgeDEgPSB4MCArIHdpZHRoO1xuICAgICAgICB2YXIgeTEgPSB5MCArIGhlaWdodDtcblxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAobGluZS5jb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkwLCBsaW5lV2lkdGgsIHgsIHkpIHx8IGxpbmUuY29udGFpblN0cm9rZSh4MSwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KSB8fCBsaW5lLmNvbnRhaW5TdHJva2UoeDEsIHkxLCB4MCwgeTEsIGxpbmVXaWR0aCwgeCwgeSkgfHwgbGluZS5jb250YWluU3Ryb2tlKHgwLCB5MSwgeDAsIHkwLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRklYTUUgQ2xvY2t3aXNlID9cbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHgxLCB5MCwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHgwLCB5MSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5aOlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAobGluZS5jb250YWluU3Ryb2tlKHhpLCB5aSwgeDAsIHkwLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2xvc2UgYSBzdWJwYXRoXG4gICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSk7IC8vIOWmguaenOiiq+S7u+S9leS4gOS4qiBzdWJwYXRoIOWMheWQq1xuICAgICAgICAgIC8vIEZJWE1FIHN1YnBhdGhzIG1heSBvdmVybGFwXG4gICAgICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgLy8gfVxuICAgICAgICB9XG5cbiAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc1N0cm9rZSAmJiAhaXNBcm91bmRFcXVhbCh5aSwgeTApKSB7XG4gICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSkgfHwgMDtcbiAgfVxuXG4gIHJldHVybiB3ICE9PSAwO1xufVxuXG5mdW5jdGlvbiBjb250YWluKHBhdGhEYXRhLCB4LCB5KSB7XG4gIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgMCwgZmFsc2UsIHgsIHkpO1xufVxuXG5mdW5jdGlvbiBjb250YWluU3Ryb2tlKHBhdGhEYXRhLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCBsaW5lV2lkdGgsIHRydWUsIHgsIHkpO1xufVxuXG5leHBvcnRzLmNvbnRhaW4gPSBjb250YWluO1xuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi9wYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIOe6v+auteWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gIHZhciBfYSA9IDA7XG4gIHZhciBfYiA9IHgwOyAvLyBRdWljayByZWplY3RcblxuICBpZiAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgfHwgeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgfHwgeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgfHwgeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoeDAgIT09IHgxKSB7XG4gICAgX2EgPSAoeTAgLSB5MSkgLyAoeDAgLSB4MSk7XG4gICAgX2IgPSAoeDAgKiB5MSAtIHgxICogeTApIC8gKHgwIC0geDEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBNYXRoLmFicyh4IC0geDApIDw9IF9sIC8gMjtcbiAgfVxuXG4gIHZhciB0bXAgPSBfYSAqIHggLSB5ICsgX2I7XG5cbiAgdmFyIF9zID0gdG1wICogdG1wIC8gKF9hICogX2EgKyAxKTtcblxuICByZXR1cm4gX3MgPD0gX2wgLyAyICogX2wgLyAyO1xufVxuXG5leHBvcnRzLmNvbnRhaW5TdHJva2UgPSBjb250YWluU3Ryb2tlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluL2xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjdXJ2ZSA9IHJlcXVpcmUoXCIuLi9jb3JlL2N1cnZlXCIpO1xuXG4vKipcbiAqIOS4ieasoei0neWhnuWwlOabsue6v+aPj+i+ueWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAqIEBwYXJhbSAge251bWJlcn0gIHgyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MlxuICogQHBhcmFtICB7bnVtYmVyfSAgeDNcbiAqIEBwYXJhbSAge251bWJlcn0gIHkzXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbCA9IGxpbmVXaWR0aDsgLy8gUXVpY2sgcmVqZWN0XG5cbiAgaWYgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sICYmIHkgPiB5MyArIF9sIHx8IHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sICYmIHkgPCB5MyAtIF9sIHx8IHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sICYmIHggPiB4MiArIF9sICYmIHggPiB4MyArIF9sIHx8IHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sICYmIHggPCB4MyAtIF9sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGQgPSBjdXJ2ZS5jdWJpY1Byb2plY3RQb2ludCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHgsIHksIG51bGwpO1xuICByZXR1cm4gZCA8PSBfbCAvIDI7XG59XG5cbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfY3VydmUgPSByZXF1aXJlKFwiLi4vY29yZS9jdXJ2ZVwiKTtcblxudmFyIHF1YWRyYXRpY1Byb2plY3RQb2ludCA9IF9jdXJ2ZS5xdWFkcmF0aWNQcm9qZWN0UG9pbnQ7XG5cbi8qKlxuICog5LqM5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7IC8vIFF1aWNrIHJlamVjdFxuXG4gIGlmICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCAmJiB5ID4geTIgKyBfbCB8fCB5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCAmJiB5IDwgeTIgLSBfbCB8fCB4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCAmJiB4ID4geDIgKyBfbCB8fCB4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCAmJiB4IDwgeDIgLSBfbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBkID0gcXVhZHJhdGljUHJvamVjdFBvaW50KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHksIG51bGwpO1xuICByZXR1cm4gZCA8PSBfbCAvIDI7XG59XG5cbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX3V0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgbm9ybWFsaXplUmFkaWFuID0gX3V0aWwubm9ybWFsaXplUmFkaWFuO1xudmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuLyoqXG4gKiDlnIblvKfmj4/ovrnljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIGN4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBjeVxuICogQHBhcmFtICB7bnVtYmVyfSAgclxuICogQHBhcmFtICB7bnVtYmVyfSAgc3RhcnRBbmdsZVxuICogQHBhcmFtICB7bnVtYmVyfSAgZW5kQW5nbGVcbiAqIEBwYXJhbSAge2Jvb2xlYW59ICBhbnRpY2xvY2t3aXNlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBjb250YWluU3Ryb2tlKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIGxpbmVXaWR0aCwgeCwgeSkge1xuICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIF9sID0gbGluZVdpZHRoO1xuICB4IC09IGN4O1xuICB5IC09IGN5O1xuICB2YXIgZCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblxuICBpZiAoZCAtIF9sID4gciB8fCBkICsgX2wgPCByKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSkgJSBQSTIgPCAxZS00KSB7XG4gICAgLy8gSXMgYSBjaXJjbGVcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4odG1wKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHN0YXJ0QW5nbGUpO1xuICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgfVxuXG4gIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICBlbmRBbmdsZSArPSBQSTI7XG4gIH1cblxuICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHksIHgpO1xuXG4gIGlmIChhbmdsZSA8IDApIHtcbiAgICBhbmdsZSArPSBQSTI7XG4gIH1cblxuICByZXR1cm4gYW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSA8PSBlbmRBbmdsZSB8fCBhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlO1xufVxuXG5leHBvcnRzLmNvbnRhaW5TdHJva2UgPSBjb250YWluU3Ryb2tlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluL2FyYy5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuXG5mdW5jdGlvbiBub3JtYWxpemVSYWRpYW4oYW5nbGUpIHtcbiAgYW5nbGUgJT0gUEkyO1xuXG4gIGlmIChhbmdsZSA8IDApIHtcbiAgICBhbmdsZSArPSBQSTI7XG4gIH1cblxuICByZXR1cm4gYW5nbGU7XG59XG5cbmV4cG9ydHMubm9ybWFsaXplUmFkaWFuID0gbm9ybWFsaXplUmFkaWFuO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIHdpbmRpbmdMaW5lKHgwLCB5MCwgeDEsIHkxLCB4LCB5KSB7XG4gIGlmICh5ID4geTAgJiYgeSA+IHkxIHx8IHkgPCB5MCAmJiB5IDwgeTEpIHtcbiAgICByZXR1cm4gMDtcbiAgfSAvLyBJZ25vcmUgaG9yaXpvbnRhbCBsaW5lXG5cblxuICBpZiAoeTEgPT09IHkwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgZGlyID0geTEgPCB5MCA/IDEgOiAtMTtcbiAgdmFyIHQgPSAoeSAtIHkwKSAvICh5MSAtIHkwKTsgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG5cbiAgaWYgKHQgPT09IDEgfHwgdCA9PT0gMCkge1xuICAgIGRpciA9IHkxIDwgeTAgPyAwLjUgOiAtMC41O1xuICB9XG5cbiAgdmFyIHhfID0gdCAqICh4MSAtIHgwKSArIHgwO1xuICByZXR1cm4geF8gPiB4ID8gZGlyIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aW5kaW5nTGluZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi93aW5kaW5nTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdHRlcm4gPSBmdW5jdGlvbiAoaW1hZ2UsIHJlcGVhdCkge1xuICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7aW1hZ2U6IC4uLn1gLCB3aGVyZSB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICB0aGlzLnJlcGVhdCA9IHJlcGVhdDsgLy8gQ2FuIGJlIGNsb25lZFxuXG4gIHRoaXMudHlwZSA9ICdwYXR0ZXJuJztcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm4gPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0aGlzLmltYWdlLCB0aGlzLnJlcGVhdCB8fCAncmVwZWF0Jyk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBQYXR0ZXJuO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9QYXR0ZXJuLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSBfdmVjdG9yLmFwcGx5VHJhbnNmb3JtO1xudmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG52YXIgcG9pbnRzID0gW1tdLCBbXSwgW11dO1xudmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIG1hdGhBdGFuMiA9IE1hdGguYXRhbjI7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KHBhdGgsIG0pIHtcbiAgdmFyIGRhdGEgPSBwYXRoLmRhdGE7XG4gIHZhciBjbWQ7XG4gIHZhciBuUG9pbnQ7XG4gIHZhciBpO1xuICB2YXIgajtcbiAgdmFyIGs7XG4gIHZhciBwO1xuICB2YXIgTSA9IENNRC5NO1xuICB2YXIgQyA9IENNRC5DO1xuICB2YXIgTCA9IENNRC5MO1xuICB2YXIgUiA9IENNRC5SO1xuICB2YXIgQSA9IENNRC5BO1xuICB2YXIgUSA9IENNRC5RO1xuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgY21kID0gZGF0YVtpKytdO1xuICAgIGogPSBpO1xuICAgIG5Qb2ludCA9IDA7XG5cbiAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgY2FzZSBNOlxuICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMOlxuICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDOlxuICAgICAgICBuUG9pbnQgPSAzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBROlxuICAgICAgICBuUG9pbnQgPSAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBBOlxuICAgICAgICB2YXIgeCA9IG1bNF07XG4gICAgICAgIHZhciB5ID0gbVs1XTtcbiAgICAgICAgdmFyIHN4ID0gbWF0aFNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgIHZhciBzeSA9IG1hdGhTcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICB2YXIgYW5nbGUgPSBtYXRoQXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTsgLy8gY3hcblxuICAgICAgICBkYXRhW2ldICo9IHN4O1xuICAgICAgICBkYXRhW2krK10gKz0geDsgLy8gY3lcblxuICAgICAgICBkYXRhW2ldICo9IHN5O1xuICAgICAgICBkYXRhW2krK10gKz0geTsgLy8gU2NhbGUgcnggYW5kIHJ5XG4gICAgICAgIC8vIEZJWE1FIEFzc3VtZSBwc2kgaXMgMCBoZXJlXG5cbiAgICAgICAgZGF0YVtpKytdICo9IHN4O1xuICAgICAgICBkYXRhW2krK10gKj0gc3k7IC8vIFN0YXJ0IGFuZ2xlXG5cbiAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlOyAvLyBlbmQgYW5nbGVcblxuICAgICAgICBkYXRhW2krK10gKz0gYW5nbGU7IC8vIEZJWE1FIHBzaVxuXG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFI6XG4gICAgICAgIC8vIHgwLCB5MFxuICAgICAgICBwWzBdID0gZGF0YVtpKytdO1xuICAgICAgICBwWzFdID0gZGF0YVtpKytdO1xuICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICBkYXRhW2orK10gPSBwWzFdOyAvLyB4MSwgeTFcblxuICAgICAgICBwWzBdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgcFsxXSArPSBkYXRhW2krK107XG4gICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgfVxuXG4gICAgZm9yIChrID0gMDsgayA8IG5Qb2ludDsgaysrKSB7XG4gICAgICB2YXIgcCA9IHBvaW50c1trXTtcbiAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICBwWzFdID0gZGF0YVtpKytdO1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTsgLy8gV3JpdGUgYmFja1xuXG4gICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAqL1xudmFyIEdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yU3RvcHMpIHtcbiAgdGhpcy5jb2xvclN0b3BzID0gY29sb3JTdG9wcyB8fCBbXTtcbn07XG5cbkdyYWRpZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdyYWRpZW50LFxuICBhZGRDb2xvclN0b3A6IGZ1bmN0aW9uIChvZmZzZXQsIGNvbG9yKSB7XG4gICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBjb2xvcjogY29sb3JcbiAgICB9KTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEdyYWRpZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVE9ETyBEcmFnZ2FibGUgZm9yIGdyb3VwXG4vLyBGSVhNRSBEcmFnZ2FibGUgb24gZWxlbWVudCB3aGljaCBoYXMgcGFyZW50IHJvdGF0aW9uIG9yIHNjYWxlXG5mdW5jdGlvbiBEcmFnZ2FibGUoKSB7XG4gIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMuX2RyYWdTdGFydCwgdGhpcyk7XG4gIHRoaXMub24oJ21vdXNlbW92ZScsIHRoaXMuX2RyYWcsIHRoaXMpO1xuICB0aGlzLm9uKCdtb3VzZXVwJywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7XG4gIHRoaXMub24oJ2dsb2JhbG91dCcsIHRoaXMuX2RyYWdFbmQsIHRoaXMpOyAvLyB0aGlzLl9kcm9wVGFyZ2V0ID0gbnVsbDtcbiAgLy8gdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBudWxsO1xuICAvLyB0aGlzLl94ID0gMDtcbiAgLy8gdGhpcy5feSA9IDA7XG59XG5cbkRyYWdnYWJsZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEcmFnZ2FibGUsXG4gIF9kcmFnU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gZS50YXJnZXQ7XG5cbiAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgJiYgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dhYmxlKSB7XG4gICAgICB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IGRyYWdnaW5nVGFyZ2V0O1xuICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5feCA9IGUub2Zmc2V0WDtcbiAgICAgIHRoaXMuX3kgPSBlLm9mZnNldFk7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWdzdGFydCcsIGUuZXZlbnQpO1xuICAgIH1cbiAgfSxcbiAgX2RyYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gdGhpcy5fZHJhZ2dpbmdUYXJnZXQ7XG5cbiAgICBpZiAoZHJhZ2dpbmdUYXJnZXQpIHtcbiAgICAgIHZhciB4ID0gZS5vZmZzZXRYO1xuICAgICAgdmFyIHkgPSBlLm9mZnNldFk7XG4gICAgICB2YXIgZHggPSB4IC0gdGhpcy5feDtcbiAgICAgIHZhciBkeSA9IHkgLSB0aGlzLl95O1xuICAgICAgdGhpcy5feCA9IHg7XG4gICAgICB0aGlzLl95ID0geTtcbiAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyaWZ0KGR4LCBkeSwgZSk7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWcnLCBlLmV2ZW50KTtcbiAgICAgIHZhciBkcm9wVGFyZ2V0ID0gdGhpcy5maW5kSG92ZXIoeCwgeSwgZHJhZ2dpbmdUYXJnZXQpLnRhcmdldDtcbiAgICAgIHZhciBsYXN0RHJvcFRhcmdldCA9IHRoaXMuX2Ryb3BUYXJnZXQ7XG4gICAgICB0aGlzLl9kcm9wVGFyZ2V0ID0gZHJvcFRhcmdldDtcblxuICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICE9PSBkcm9wVGFyZ2V0KSB7XG4gICAgICAgIGlmIChsYXN0RHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0obGFzdERyb3BUYXJnZXQsIGUpLCAnZHJhZ2xlYXZlJywgZS5ldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJvcFRhcmdldCwgZSksICdkcmFnZW50ZXInLCBlLmV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2RyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gdGhpcy5fZHJhZ2dpbmdUYXJnZXQ7XG5cbiAgICBpZiAoZHJhZ2dpbmdUYXJnZXQpIHtcbiAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyYWdnaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcmFnZ2luZ1RhcmdldCwgZSksICdkcmFnZW5kJywgZS5ldmVudCk7XG5cbiAgICBpZiAodGhpcy5fZHJvcFRhcmdldCkge1xuICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbSh0aGlzLl9kcm9wVGFyZ2V0LCBlKSwgJ2Ryb3AnLCBlLmV2ZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG4gICAgdGhpcy5fZHJvcFRhcmdldCA9IG51bGw7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBhcmFtKHRhcmdldCwgZSkge1xuICByZXR1cm4ge1xuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIHRvcFRhcmdldDogZSAmJiBlLnRvcFRhcmdldFxuICB9O1xufVxuXG52YXIgX2RlZmF1bHQgPSBEcmFnZ2FibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoXCIuLi9FbGVtZW50XCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG4vKipcbiAqIEdyb3Vw5piv5LiA5Liq5a655Zmo77yM5Y+v5Lul5o+S5YWl5a2Q6IqC54K577yMR3JvdXDnmoTlj5jmjaLkuZ/kvJrooqvlupTnlKjliLDlrZDoioLngrnkuIpcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0dyb3VwXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvY29udGFpbmVyL0dyb3VwJyk7XG4gKiAgICAgdmFyIENpcmNsZSA9IHJlcXVpcmUoJ3pyZW5kZXIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUnKTtcbiAqICAgICB2YXIgZyA9IG5ldyBHcm91cCgpO1xuICogICAgIGcucG9zaXRpb25bMF0gPSAxMDA7XG4gKiAgICAgZy5wb3NpdGlvblsxXSA9IDEwMDtcbiAqICAgICBnLmFkZChuZXcgQ2lyY2xlKHtcbiAqICAgICAgICAgc3R5bGU6IHtcbiAqICAgICAgICAgICAgIHg6IDEwMCxcbiAqICAgICAgICAgICAgIHk6IDEwMCxcbiAqICAgICAgICAgICAgIHI6IDIwLFxuICogICAgICAgICB9XG4gKiAgICAgfSkpO1xuICogICAgIHpyLmFkZChnKTtcbiAqL1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKi9cbnZhciBHcm91cCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBFbGVtZW50LmNhbGwodGhpcywgb3B0cyk7XG5cbiAgZm9yICh2YXIga2V5IGluIG9wdHMpIHtcbiAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB0aGlzW2tleV0gPSBvcHRzW2tleV07XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5fX3N0b3JhZ2UgPSBudWxsO1xuICB0aGlzLl9fZGlydHkgPSB0cnVlO1xufTtcblxuR3JvdXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogR3JvdXAsXG4gIGlzR3JvdXA6IHRydWUsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0eXBlOiAnZ3JvdXAnLFxuXG4gIC8qKlxuICAgKiDmiYDmnInlrZDlrZnlhYPntKDmmK/lkKblk43lupTpvKDmoIfkuovku7ZcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2NvbnRhaW5lci9Hcm91cCNzaWxlbnRcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvRWxlbWVudD59XG4gICAqL1xuICBjaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5zbGljZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmjIflrpogaW5kZXgg55qE5YS/5a2Q6IqC54K5XG4gICAqIEBwYXJhbSAge251bWJlcn0gaWR4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAqL1xuICBjaGlsZEF0OiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW2lkeF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPluaMh+WumuWQjeWtl+eahOWEv+WtkOiKgueCuVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICovXG4gIGNoaWxkT2ZOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNoaWxkcmVuW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgY2hpbGRDb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWtkOiKgueCueWIsOacgOWQjlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gICAgICB0aGlzLl9kb0FkZChjaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWtkOiKgueCueWcqCBuZXh0U2libGluZyDkuYvliY1cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IG5leHRTaWJsaW5nXG4gICAqL1xuICBhZGRCZWZvcmU6IGZ1bmN0aW9uIChjaGlsZCwgbmV4dFNpYmxpbmcpIHtcbiAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IHRoaXMgJiYgY2hpbGQucGFyZW50ICE9PSB0aGlzICYmIG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICB2YXIgaWR4ID0gY2hpbGRyZW4uaW5kZXhPZihuZXh0U2libGluZyk7XG5cbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAwLCBjaGlsZCk7XG5cbiAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfZG9BZGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuICAgIH1cblxuICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICB2YXIgenIgPSB0aGlzLl9fenI7XG5cbiAgICBpZiAoc3RvcmFnZSAmJiBzdG9yYWdlICE9PSBjaGlsZC5fX3N0b3JhZ2UpIHtcbiAgICAgIHN0b3JhZ2UuYWRkVG9TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgenIgJiYgenIucmVmcmVzaCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDnp7vpmaTlrZDoioLngrlcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICB2YXIgaWR4ID0genJVdGlsLmluZGV4T2YoY2hpbGRyZW4sIGNoaWxkKTtcblxuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcbiAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuXG4gICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHpyICYmIHpyLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog56e76Zmk5omA5pyJ5a2Q6IqC54K5XG4gICAqL1xuICByZW1vdmVBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgIHZhciBjaGlsZDtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog6YGN5Y6G5omA5pyJ5a2Q6IqC54K5XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgKi9cbiAgZWFjaENoaWxkOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY2IuY2FsbChjb250ZXh0LCBjaGlsZCwgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3seW6puS8mOWFiOmBjeWOhuaJgOacieWtkOWtmeiKgueCuVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICovXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICBjaGlsZC50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZENoaWxkcmVuVG9TdG9yYWdlOiBmdW5jdGlvbiAoc3RvcmFnZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBjaGlsZC5hZGRDaGlsZHJlblRvU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlbENoaWxkcmVuRnJvbVN0b3JhZ2U6IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uIChpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICAvLyBUT0RPIENhY2hpbmdcbiAgICB2YXIgcmVjdCA9IG51bGw7XG4gICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgIHZhciBjaGlsZHJlbiA9IGluY2x1ZGVDaGlsZHJlbiB8fCB0aGlzLl9jaGlsZHJlbjtcbiAgICB2YXIgdG1wTWF0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGNoaWxkLmlnbm9yZSB8fCBjaGlsZC5pbnZpc2libGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZFJlY3QgPSBjaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBjaGlsZC5nZXRMb2NhbFRyYW5zZm9ybSh0bXBNYXQpOyAvLyBUT0RPXG4gICAgICAvLyBUaGUgYm91bmRpbmdSZWN0IGNhY2x1YXRlZCBieSB0cmFuc2Zvcm1pbmcgb3JpZ2luYWxcbiAgICAgIC8vIHJlY3QgbWF5IGJlIGJpZ2dlciB0aGFuIHRoZSBhY3R1YWwgYnVuZGluZ1JlY3Qgd2hlbiByb3RhdGlvblxuICAgICAgLy8gaXMgdXNlZC4gKENvbnNpZGVyIGEgY2lyY2xlIHJvdGF0ZWQgYWdpbnN0IGl0cyBjZW50ZXIsIHdoZXJlXG4gICAgICAvLyB0aGUgYWN0dWFsIGJvdW5kaW5nUmVjdCBzaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhhdCBub3QgYmVcbiAgICAgIC8vIHJvdGF0ZWQuKSBCdXQgd2UgY2FuIG5vdCBmaW5kIGJldHRlciBhcHByb2FjaCB0byBjYWxjdWxhdGVcbiAgICAgIC8vIGFjdHVhbCBib3VuZGluZ1JlY3QgeWV0LCBjb25zaWRlcmluZyBwZXJmb3JtYW5jZS5cblxuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0bXBSZWN0LmNvcHkoY2hpbGRSZWN0KTtcbiAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICByZWN0ID0gcmVjdCB8fCB0bXBSZWN0LmNsb25lKCk7XG4gICAgICAgIHJlY3QudW5pb24odG1wUmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWN0ID0gcmVjdCB8fCBjaGlsZFJlY3QuY2xvbmUoKTtcbiAgICAgICAgcmVjdC51bmlvbihjaGlsZFJlY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZWN0IHx8IHRtcFJlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoR3JvdXAsIEVsZW1lbnQpO1xudmFyIF9kZWZhdWx0ID0gR3JvdXA7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlhYmxlXCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIGltYWdlSGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyL2ltYWdlXCIpO1xuXG4vKipcbiAqIEBhbGlhcyB6cmVuZGVyL2dyYXBoaWMvSW1hZ2VcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuZnVuY3Rpb24gWkltYWdlKG9wdHMpIHtcbiAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuWkltYWdlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFpJbWFnZSxcbiAgdHlwZTogJ2ltYWdlJyxcbiAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIHNyYyA9IHN0eWxlLmltYWdlOyAvLyBNdXN0IGJpbmQgZWFjaCB0aW1lXG5cbiAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcbiAgICB2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSA9IGltYWdlSGVscGVyLmNyZWF0ZU9yVXBkYXRlSW1hZ2Uoc3JjLCB0aGlzLl9pbWFnZSwgdGhpcywgdGhpcy5vbmxvYWQpO1xuXG4gICAgaWYgKCFpbWFnZSB8fCAhaW1hZ2VIZWxwZXIuaXNJbWFnZVJlYWR5KGltYWdlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8g5Zu+54mH5bey57uP5Yqg6L295a6M5oiQXG4gICAgLy8gaWYgKGltYWdlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gJ0lNRycpIHtcbiAgICAvLyAgICAgaWYgKCFpbWFnZS5jb21wbGV0ZSkge1xuICAgIC8vICAgICAgICAgcmV0dXJuO1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuICAgIC8vIEVsc2UgaXMgY2FudmFzXG5cblxuICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xuICAgIHZhciB5ID0gc3R5bGUueSB8fCAwO1xuICAgIHZhciB3aWR0aCA9IHN0eWxlLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBzdHlsZS5oZWlnaHQ7XG4gICAgdmFyIGFzcGVjdCA9IGltYWdlLndpZHRoIC8gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgIC8vIEtlZXAgaW1hZ2UvaGVpZ2h0IHJhdGlvXG4gICAgICB3aWR0aCA9IGhlaWdodCAqIGFzcGVjdDtcbiAgICB9IGVsc2UgaWYgKGhlaWdodCA9PSBudWxsICYmIHdpZHRoICE9IG51bGwpIHtcbiAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0O1xuICAgIH0gZWxzZSBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgPT0gbnVsbCkge1xuICAgICAgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgIGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICB9IC8vIOiuvue9rnRyYW5zZm9ybVxuXG5cbiAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG4gICAgaWYgKHN0eWxlLnNXaWR0aCAmJiBzdHlsZS5zSGVpZ2h0KSB7XG4gICAgICB2YXIgc3ggPSBzdHlsZS5zeCB8fCAwO1xuICAgICAgdmFyIHN5ID0gc3R5bGUuc3kgfHwgMDtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHN4LCBzeSwgc3R5bGUuc1dpZHRoLCBzdHlsZS5zSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKHN0eWxlLnN4ICYmIHN0eWxlLnN5KSB7XG4gICAgICB2YXIgc3ggPSBzdHlsZS5zeDtcbiAgICAgIHZhciBzeSA9IHN0eWxlLnN5O1xuICAgICAgdmFyIHNXaWR0aCA9IHdpZHRoIC0gc3g7XG4gICAgICB2YXIgc0hlaWdodCA9IGhlaWdodCAtIHN5O1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgc3gsIHN5LCBzV2lkdGgsIHNIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTsgLy8gRHJhdyByZWN0IHRleHRcblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgfVxuICB9LFxuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuXG4gICAgaWYgKCF0aGlzLl9yZWN0KSB7XG4gICAgICB0aGlzLl9yZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChzdHlsZS54IHx8IDAsIHN0eWxlLnkgfHwgMCwgc3R5bGUud2lkdGggfHwgMCwgc3R5bGUuaGVpZ2h0IHx8IDApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICB9XG59O1xuenJVdGlsLmluaGVyaXRzKFpJbWFnZSwgRGlzcGxheWFibGUpO1xudmFyIF9kZWZhdWx0ID0gWkltYWdlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZShcIi4vRGlzcGxheWFibGVcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwiLi4vY29udGFpbi90ZXh0XCIpO1xuXG52YXIgdGV4dEhlbHBlciA9IHJlcXVpcmUoXCIuL2hlbHBlci90ZXh0XCIpO1xuXG4vKipcbiAqIEBhbGlhcyB6cmVuZGVyL2dyYXBoaWMvVGV4dFxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG52YXIgVGV4dCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xufTtcblxuVGV4dC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUZXh0LFxuICB0eXBlOiAndGV4dCcsXG4gIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlOyAvLyBPcHRpbWl6ZSwgYXZvaWQgbm9ybWFsaXplIGV2ZXJ5IHRpbWUuXG5cbiAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpOyAvLyBVc2UgcHJvcHMgd2l0aCBwcmVmaXggJ3RleHQnLlxuXG4gICAgc3R5bGUuZmlsbCA9IHN0eWxlLnN0cm9rZSA9IHN0eWxlLnNoYWRvd0JsdXIgPSBzdHlsZS5zaGFkb3dDb2xvciA9IHN0eWxlLnNoYWRvd09mZnNldFggPSBzdHlsZS5zaGFkb3dPZmZzZXRZID0gbnVsbDtcbiAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7IC8vIENvbnZlcnQgdG8gc3RyaW5nXG5cbiAgICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpOyAvLyBBbHdheXMgYmluZCBzdHlsZVxuXG4gICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG5cbiAgICBpZiAoIXRleHRIZWxwZXIubmVlZERyYXdUZXh0KHRleHQsIHN0eWxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgdGV4dEhlbHBlci5yZW5kZXJUZXh0KHRoaXMsIGN0eCwgdGV4dCwgc3R5bGUpO1xuICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICB9LFxuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlOyAvLyBPcHRpbWl6ZSwgYXZvaWQgbm9ybWFsaXplIGV2ZXJ5IHRpbWUuXG5cbiAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpO1xuXG4gICAgaWYgKCF0aGlzLl9yZWN0KSB7XG4gICAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7XG4gICAgICB0ZXh0ICE9IG51bGwgPyB0ZXh0ICs9ICcnIDogdGV4dCA9ICcnO1xuICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3Qoc3R5bGUudGV4dCArICcnLCBzdHlsZS5mb250LCBzdHlsZS50ZXh0QWxpZ24sIHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduLCBzdHlsZS50ZXh0UGFkZGluZywgc3R5bGUucmljaCk7XG4gICAgICByZWN0LnggKz0gc3R5bGUueCB8fCAwO1xuICAgICAgcmVjdC55ICs9IHN0eWxlLnkgfHwgMDtcblxuICAgICAgaWYgKHRleHRIZWxwZXIuZ2V0U3Ryb2tlKHN0eWxlLnRleHRTdHJva2UsIHN0eWxlLnRleHRTdHJva2VXaWR0aCkpIHtcbiAgICAgICAgdmFyIHcgPSBzdHlsZS50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICAgIHJlY3QueCAtPSB3IC8gMjtcbiAgICAgICAgcmVjdC55IC09IHcgLyAyO1xuICAgICAgICByZWN0LndpZHRoICs9IHc7XG4gICAgICAgIHJlY3QuaGVpZ2h0ICs9IHc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICB9XG59O1xuenJVdGlsLmluaGVyaXRzKFRleHQsIERpc3BsYXlhYmxlKTtcbnZhciBfZGVmYXVsdCA9IFRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5ZyG5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQ2lyY2xlXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2NpcmNsZScsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBpbkJ1bmRsZSkge1xuICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgIC8vIEFsd2F5cyBkbyBpdCBtYXkgaGF2ZSBwZXJmb3JtZW5jZSBpc3N1ZSAoIGZpbGwgbWF5IGJlIDJ4IG1vcmUgY29zdClcbiAgICBpZiAoaW5CdW5kbGUpIHtcbiAgICAgIGN0eC5tb3ZlVG8oc2hhcGUuY3ggKyBzaGFwZS5yLCBzaGFwZS5jeSk7XG4gICAgfSAvLyBlbHNlIHtcbiAgICAvLyAgICAgaWYgKGN0eC5hbGxvY2F0ZSAmJiAhY3R4LmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gICAgICAgICBjdHguYWxsb2NhdGUoY3R4LkNNRF9NRU1fU0laRS5BKTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cbiAgICAvLyBCZXR0ZXIgc3Ryb2tpbmcgaW4gU2hhcGVCdW5kbGVcbiAgICAvLyBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuXG5cbiAgICBjdHguYXJjKHNoYXBlLmN4LCBzaGFwZS5jeSwgc2hhcGUuciwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciBmaXhDbGlwV2l0aFNoYWRvdyA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvZml4Q2xpcFdpdGhTaGFkb3dcIik7XG5cbi8qKlxuICog5omH5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9TZWN0b3JcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnc2VjdG9yJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByMDogMCxcbiAgICByOiAwLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICB9LFxuICBicnVzaDogZml4Q2xpcFdpdGhTaGFkb3coUGF0aC5wcm90b3R5cGUuYnJ1c2gpLFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgIHZhciByMCA9IE1hdGgubWF4KHNoYXBlLnIwIHx8IDAsIDApO1xuICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xuICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG4gICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIwICsgeCwgdW5pdFkgKiByMCArIHkpO1xuICAgIGN0eC5saW5lVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gICAgY3R4LmxpbmVUbyhNYXRoLmNvcyhlbmRBbmdsZSkgKiByMCArIHgsIE1hdGguc2luKGVuZEFuZ2xlKSAqIHIwICsgeSk7XG5cbiAgICBpZiAocjAgIT09IDApIHtcbiAgICAgIGN0eC5hcmMoeCwgeSwgcjAsIGVuZEFuZ2xlLCBzdGFydEFuZ2xlLCBjbG9ja3dpc2UpO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZW52ID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZW52XCIpO1xuXG4vLyBGaXggd2VpcmQgYnVnIGluIHNvbWUgdmVyc2lvbiBvZiBJRTExIChsaWtlIDExLjAuOTYwMC4xNzgqKiksXG4vLyB3aGVyZSBleGNlcHRpb24gXCJ1bmV4cGVjdGVkIGNhbGwgdG8gbWV0aG9kIG9yIHByb3BlcnR5IGFjY2Vzc1wiXG4vLyBtaWdodCBiZSB0aHJvd24gd2hlbiBjYWxsaW5nIGN0eC5maWxsIG9yIGN0eC5zdHJva2UgYWZ0ZXIgYSBwYXRoXG4vLyB3aG9zZSBhcmVhIHNpemUgaXMgemVybyBpcyBkcmF3biBhbmQgY3R4LmNsaXAoKSBpcyBjYWxsZWQgYW5kXG4vLyBzaGFkb3dCbHVyIGlzIHNldC4gU2VlICM0NTcyLCAjMzExMiwgIzU3NzcuXG4vLyAoZS5nLixcbi8vICBjdHgubW92ZVRvKDEwLCAxMCk7XG4vLyAgY3R4LmxpbmVUbygyMCwgMTApO1xuLy8gIGN0eC5jbG9zZVBhdGgoKTtcbi8vICBjdHguY2xpcCgpO1xuLy8gIGN0eC5zaGFkb3dCbHVyID0gMTA7XG4vLyAgLi4uXG4vLyAgY3R4LmZpbGwoKTtcbi8vIClcbnZhciBzaGFkb3dUZW1wID0gW1snc2hhZG93Qmx1cicsIDBdLCBbJ3NoYWRvd0NvbG9yJywgJyMwMDAnXSwgWydzaGFkb3dPZmZzZXRYJywgMF0sIFsnc2hhZG93T2Zmc2V0WScsIDBdXTtcblxuZnVuY3Rpb24gX2RlZmF1bHQob3JpZ25hbEJydXNoKSB7XG4gIC8vIHZlcnNpb24gc3RyaW5nIGNhbiBiZTogJzExLjAnXG4gIHJldHVybiBlbnYuYnJvd3Nlci5pZSAmJiBlbnYuYnJvd3Nlci52ZXJzaW9uID49IDExID8gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGlwUGF0aHMgPSB0aGlzLl9fY2xpcFBhdGhzO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIG1vZGlmaWVkO1xuXG4gICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzW2ldO1xuICAgICAgICB2YXIgc2hhcGUgPSBjbGlwUGF0aCAmJiBjbGlwUGF0aC5zaGFwZTtcbiAgICAgICAgdmFyIHR5cGUgPSBjbGlwUGF0aCAmJiBjbGlwUGF0aC50eXBlO1xuXG4gICAgICAgIGlmIChzaGFwZSAmJiAodHlwZSA9PT0gJ3NlY3RvcicgJiYgc2hhcGUuc3RhcnRBbmdsZSA9PT0gc2hhcGUuZW5kQW5nbGUgfHwgdHlwZSA9PT0gJ3JlY3QnICYmICghc2hhcGUud2lkdGggfHwgIXNoYXBlLmhlaWdodCkpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaGFkb3dUZW1wLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAvLyBJdCBpcyBzYXZlIHRvIHB1dCBzaGFkb3dUZW1wIHN0YXRpYywgYmVjYXVzZSBzaGFkb3dUZW1wXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGFsbCBtb2RpZmllZCBlYWNoIGl0ZW0gYnJ1c2ggY2FsbGVkLlxuICAgICAgICAgICAgc2hhZG93VGVtcFtqXVsyXSA9IHN0eWxlW3NoYWRvd1RlbXBbal1bMF1dO1xuICAgICAgICAgICAgc3R5bGVbc2hhZG93VGVtcFtqXVswXV0gPSBzaGFkb3dUZW1wW2pdWzFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG9yaWduYWxCcnVzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc3R5bGVbc2hhZG93VGVtcFtqXVswXV0gPSBzaGFkb3dUZW1wW2pdWzJdO1xuICAgICAgfVxuICAgIH1cbiAgfSA6IG9yaWduYWxCcnVzaDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvZml4Q2xpcFdpdGhTaGFkb3cuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogZWNoYXJ0c+iuvuWkh+eOr+Wig+ivhuWIq1xuICpcbiAqIEBkZXNjIGVjaGFydHPln7rkuo5DYW52YXPvvIznuq9KYXZhc2NyaXB05Zu+6KGo5bqT77yM5o+Q5L6b55u06KeC77yM55Sf5Yqo77yM5Y+v5Lqk5LqS77yM5Y+v5Liq5oCn5YyW5a6a5Yi255qE5pWw5o2u57uf6K6h5Zu+6KGo44CCXG4gKiBAYXV0aG9yIGZpcmVkZVtmaXJlZGVAZmlyZWRlLnVzXVxuICogQGRlc2MgdGhhbmtzIHplcHRvLlxuICovXG52YXIgZW52ID0ge307XG5cbmlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAvLyBJbiBub2RlXG4gIGVudiA9IHtcbiAgICBicm93c2VyOiB7fSxcbiAgICBvczoge30sXG4gICAgbm9kZTogdHJ1ZSxcbiAgICAvLyBBc3N1bWUgY2FudmFzIGlzIHN1cHBvcnRlZFxuICAgIGNhbnZhc1N1cHBvcnRlZDogdHJ1ZSxcbiAgICBzdmdTdXBwb3J0ZWQ6IHRydWVcbiAgfTtcbn0gZWxzZSB7XG4gIGVudiA9IGRldGVjdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gZW52OyAvLyBaZXB0by5qc1xuLy8gKGMpIDIwMTAtMjAxMyBUaG9tYXMgRnVjaHNcbi8vIFplcHRvLmpzIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG5mdW5jdGlvbiBkZXRlY3QodWEpIHtcbiAgdmFyIG9zID0ge307XG4gIHZhciBicm93c2VyID0ge307IC8vIHZhciB3ZWJraXQgPSB1YS5tYXRjaCgvV2ViW2tLXWl0W1xcL117MCwxfShbXFxkLl0rKS8pO1xuICAvLyB2YXIgYW5kcm9pZCA9IHVhLm1hdGNoKC8oQW5kcm9pZCk7P1tcXHNcXC9dKyhbXFxkLl0rKT8vKTtcbiAgLy8gdmFyIGlwYWQgPSB1YS5tYXRjaCgvKGlQYWQpLipPU1xccyhbXFxkX10rKS8pO1xuICAvLyB2YXIgaXBvZCA9IHVhLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/Lyk7XG4gIC8vIHZhciBpcGhvbmUgPSAhaXBhZCAmJiB1YS5tYXRjaCgvKGlQaG9uZVxcc09TKVxccyhbXFxkX10rKS8pO1xuICAvLyB2YXIgd2Vib3MgPSB1YS5tYXRjaCgvKHdlYk9TfGhwd09TKVtcXHNcXC9dKFtcXGQuXSspLyk7XG4gIC8vIHZhciB0b3VjaHBhZCA9IHdlYm9zICYmIHVhLm1hdGNoKC9Ub3VjaFBhZC8pO1xuICAvLyB2YXIga2luZGxlID0gdWEubWF0Y2goL0tpbmRsZVxcLyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgc2lsayA9IHVhLm1hdGNoKC9TaWxrXFwvKFtcXGQuX10rKS8pO1xuICAvLyB2YXIgYmxhY2tiZXJyeSA9IHVhLm1hdGNoKC8oQmxhY2tCZXJyeSkuKlZlcnNpb25cXC8oW1xcZC5dKykvKTtcbiAgLy8gdmFyIGJiMTAgPSB1YS5tYXRjaCgvKEJCMTApLipWZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gIC8vIHZhciByaW10YWJsZXRvcyA9IHVhLm1hdGNoKC8oUklNXFxzVGFibGV0XFxzT1MpXFxzKFtcXGQuXSspLyk7XG4gIC8vIHZhciBwbGF5Ym9vayA9IHVhLm1hdGNoKC9QbGF5Qm9vay8pO1xuICAvLyB2YXIgY2hyb21lID0gdWEubWF0Y2goL0Nocm9tZVxcLyhbXFxkLl0rKS8pIHx8IHVhLm1hdGNoKC9DcmlPU1xcLyhbXFxkLl0rKS8pO1xuXG4gIHZhciBmaXJlZm94ID0gdWEubWF0Y2goL0ZpcmVmb3hcXC8oW1xcZC5dKykvKTsgLy8gdmFyIHNhZmFyaSA9IHdlYmtpdCAmJiB1YS5tYXRjaCgvTW9iaWxlXFwvLykgJiYgIWNocm9tZTtcbiAgLy8gdmFyIHdlYnZpZXcgPSB1YS5tYXRjaCgvKGlQaG9uZXxpUG9kfGlQYWQpLipBcHBsZVdlYktpdCg/IS4qU2FmYXJpKS8pICYmICFjaHJvbWU7XG5cbiAgdmFyIGllID0gdWEubWF0Y2goL01TSUVcXHMoW1xcZC5dKykvKSAvLyBJRSAxMSBUcmlkZW50LzcuMDsgcnY6MTEuMFxuICB8fCB1YS5tYXRjaCgvVHJpZGVudFxcLy4rP3J2OigoW1xcZC5dKykpLyk7XG4gIHZhciBlZGdlID0gdWEubWF0Y2goL0VkZ2VcXC8oW1xcZC5dKykvKTsgLy8gSUUgMTIgYW5kIDEyK1xuXG4gIHZhciB3ZUNoYXQgPSAvbWljcm9tZXNzZW5nZXIvaS50ZXN0KHVhKTsgLy8gVG9kbzogY2xlYW4gdGhpcyB1cCB3aXRoIGEgYmV0dGVyIE9TL2Jyb3dzZXIgc2VwZXJhdGlvbjpcbiAgLy8gLSBkaXNjZXJuIChtb3JlKSBiZXR3ZWVuIG11bHRpcGxlIGJyb3dzZXJzIG9uIGFuZHJvaWRcbiAgLy8gLSBkZWNpZGUgaWYga2luZGxlIGZpcmUgaW4gc2lsayBtb2RlIGlzIGFuZHJvaWQgb3Igbm90XG4gIC8vIC0gRmlyZWZveCBvbiBBbmRyb2lkIGRvZXNuJ3Qgc3BlY2lmeSB0aGUgQW5kcm9pZCB2ZXJzaW9uXG4gIC8vIC0gcG9zc2libHkgZGV2aWRlIGluIG9zLCBkZXZpY2UgYW5kIGJyb3dzZXIgaGFzaGVzXG4gIC8vIGlmIChicm93c2VyLndlYmtpdCA9ICEhd2Via2l0KSBicm93c2VyLnZlcnNpb24gPSB3ZWJraXRbMV07XG4gIC8vIGlmIChhbmRyb2lkKSBvcy5hbmRyb2lkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGFuZHJvaWRbMl07XG4gIC8vIGlmIChpcGhvbmUgJiYgIWlwb2QpIG9zLmlvcyA9IG9zLmlwaG9uZSA9IHRydWUsIG9zLnZlcnNpb24gPSBpcGhvbmVbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAvLyBpZiAoaXBhZCkgb3MuaW9zID0gb3MuaXBhZCA9IHRydWUsIG9zLnZlcnNpb24gPSBpcGFkWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgLy8gaWYgKGlwb2QpIG9zLmlvcyA9IG9zLmlwb2QgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBvZFszXSA/IGlwb2RbM10ucmVwbGFjZSgvXy9nLCAnLicpIDogbnVsbDtcbiAgLy8gaWYgKHdlYm9zKSBvcy53ZWJvcyA9IHRydWUsIG9zLnZlcnNpb24gPSB3ZWJvc1syXTtcbiAgLy8gaWYgKHRvdWNocGFkKSBvcy50b3VjaHBhZCA9IHRydWU7XG4gIC8vIGlmIChibGFja2JlcnJ5KSBvcy5ibGFja2JlcnJ5ID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGJsYWNrYmVycnlbMl07XG4gIC8vIGlmIChiYjEwKSBvcy5iYjEwID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGJiMTBbMl07XG4gIC8vIGlmIChyaW10YWJsZXRvcykgb3MucmltdGFibGV0b3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gcmltdGFibGV0b3NbMl07XG4gIC8vIGlmIChwbGF5Ym9vaykgYnJvd3Nlci5wbGF5Ym9vayA9IHRydWU7XG4gIC8vIGlmIChraW5kbGUpIG9zLmtpbmRsZSA9IHRydWUsIG9zLnZlcnNpb24gPSBraW5kbGVbMV07XG4gIC8vIGlmIChzaWxrKSBicm93c2VyLnNpbGsgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBzaWxrWzFdO1xuICAvLyBpZiAoIXNpbGsgJiYgb3MuYW5kcm9pZCAmJiB1YS5tYXRjaCgvS2luZGxlIEZpcmUvKSkgYnJvd3Nlci5zaWxrID0gdHJ1ZTtcbiAgLy8gaWYgKGNocm9tZSkgYnJvd3Nlci5jaHJvbWUgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBjaHJvbWVbMV07XG5cbiAgaWYgKGZpcmVmb3gpIHtcbiAgICBicm93c2VyLmZpcmVmb3ggPSB0cnVlO1xuICAgIGJyb3dzZXIudmVyc2lvbiA9IGZpcmVmb3hbMV07XG4gIH0gLy8gaWYgKHNhZmFyaSAmJiAodWEubWF0Y2goL1NhZmFyaS8pIHx8ICEhb3MuaW9zKSkgYnJvd3Nlci5zYWZhcmkgPSB0cnVlO1xuICAvLyBpZiAod2VidmlldykgYnJvd3Nlci53ZWJ2aWV3ID0gdHJ1ZTtcblxuXG4gIGlmIChpZSkge1xuICAgIGJyb3dzZXIuaWUgPSB0cnVlO1xuICAgIGJyb3dzZXIudmVyc2lvbiA9IGllWzFdO1xuICB9XG5cbiAgaWYgKGVkZ2UpIHtcbiAgICBicm93c2VyLmVkZ2UgPSB0cnVlO1xuICAgIGJyb3dzZXIudmVyc2lvbiA9IGVkZ2VbMV07XG4gIH0gLy8gSXQgaXMgZGlmZmljdWx0IHRvIGRldGVjdCBXZUNoYXQgaW4gV2luIFBob25lIHByZWNpc2VseSwgYmVjYXVzZSB1YSBjYW5cbiAgLy8gbm90IGJlIHNldCBvbiB3aW4gcGhvbmUuIFNvIHdlIGRvIG5vdCBjb25zaWRlciBXaW4gUGhvbmUuXG5cblxuICBpZiAod2VDaGF0KSB7XG4gICAgYnJvd3Nlci53ZUNoYXQgPSB0cnVlO1xuICB9IC8vIG9zLnRhYmxldCA9ICEhKGlwYWQgfHwgcGxheWJvb2sgfHwgKGFuZHJvaWQgJiYgIXVhLm1hdGNoKC9Nb2JpbGUvKSkgfHxcbiAgLy8gICAgIChmaXJlZm94ICYmIHVhLm1hdGNoKC9UYWJsZXQvKSkgfHwgKGllICYmICF1YS5tYXRjaCgvUGhvbmUvKSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpO1xuICAvLyBvcy5waG9uZSAgPSAhISghb3MudGFibGV0ICYmICFvcy5pcG9kICYmIChhbmRyb2lkIHx8IGlwaG9uZSB8fCB3ZWJvcyB8fFxuICAvLyAgICAgKGNocm9tZSAmJiB1YS5tYXRjaCgvQW5kcm9pZC8pKSB8fCAoY2hyb21lICYmIHVhLm1hdGNoKC9DcmlPU1xcLyhbXFxkLl0rKS8pKSB8fFxuICAvLyAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL01vYmlsZS8pKSB8fCAoaWUgJiYgdWEubWF0Y2goL1RvdWNoLykpKSk7XG5cblxuICByZXR1cm4ge1xuICAgIGJyb3dzZXI6IGJyb3dzZXIsXG4gICAgb3M6IG9zLFxuICAgIG5vZGU6IGZhbHNlLFxuICAgIC8vIOWOn+eUn2NhbnZhc+aUr+aMge+8jOaUueaegeerr+eCueS6hlxuICAgIC8vIGNhbnZhc1N1cHBvcnRlZCA6ICEoYnJvd3Nlci5pZSAmJiBwYXJzZUZsb2F0KGJyb3dzZXIudmVyc2lvbikgPCA5KVxuICAgIGNhbnZhc1N1cHBvcnRlZDogISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0LFxuICAgIHN2Z1N1cHBvcnRlZDogdHlwZW9mIFNWR1JlY3QgIT09ICd1bmRlZmluZWQnLFxuICAgIC8vIEBzZWUgPGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDgxNzAyOS93aGF0cy10aGUtYmVzdC13YXktdG8tZGV0ZWN0LWEtdG91Y2gtc2NyZWVuLWRldmljZS11c2luZy1qYXZhc2NyaXB0PlxuICAgIC8vIHdvcmtzIG9uIG1vc3QgYnJvd3NlcnNcbiAgICAvLyBJRTEwLzExIGRvZXMgbm90IHN1cHBvcnQgdG91Y2ggZXZlbnQsIGFuZCBNUyBFZGdlIHN1cHBvcnRzIHRoZW0gYnV0IG5vdCBieVxuICAgIC8vIGRlZmF1bHQsIHNvIHdlIGRvbnQgY2hlY2sgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIGZvciB0aGVtIGhlcmUuXG4gICAgdG91Y2hFdmVudHNTdXBwb3J0ZWQ6ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiAhYnJvd3Nlci5pZSAmJiAhYnJvd3Nlci5lZGdlLFxuICAgIC8vIDxodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1wb2ludGVyJTIwZXZlbnQ+LlxuICAgIHBvaW50ZXJFdmVudHNTdXBwb3J0ZWQ6ICdvbnBvaW50ZXJkb3duJyBpbiB3aW5kb3cgLy8gRmlyZWZveCBzdXBwb3J0cyBwb2ludGVyIGJ1dCBub3QgYnkgZGVmYXVsdCwgb25seSBNUyBicm93c2VycyBhcmUgcmVsaWFibGUgb24gcG9pbnRlclxuICAgIC8vIGV2ZW50cyBjdXJyZW50bHkuIFNvIHdlIGRvbnQgdXNlIHRoYXQgb24gb3RoZXIgYnJvd3NlcnMgdW5sZXNzIHRlc3RlZCBzdWZmaWNpZW50bHkuXG4gICAgLy8gQWx0aG91Z2ggSUUgMTAgc3VwcG9ydHMgcG9pbnRlciBldmVudCwgaXQgdXNlIG9sZCBzdHlsZSBhbmQgaXMgZGlmZmVyZW50IGZyb20gdGhlXG4gICAgLy8gc3RhbmRhcmQuIFNvIHdlIGV4Y2x1ZGUgdGhhdC4gKElFIDEwIGlzIGhhcmRseSB1c2VkIG9uIHRvdWNoIGRldmljZSlcbiAgICAmJiAoYnJvd3Nlci5lZGdlIHx8IGJyb3dzZXIuaWUgJiYgYnJvd3Nlci52ZXJzaW9uID49IDExKVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL2Vudi5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxuLyoqXG4gKiDlnIbnjq9cbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1JpbmdcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAncmluZycsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjogMCxcbiAgICByMDogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICBjdHgubW92ZVRvKHggKyBzaGFwZS5yLCB5KTtcbiAgICBjdHguYXJjKHgsIHksIHNoYXBlLnIsIDAsIFBJMiwgZmFsc2UpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHNoYXBlLnIwLCB5KTtcbiAgICBjdHguYXJjKHgsIHksIHNoYXBlLnIwLCAwLCBQSTIsIHRydWUpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvcG9seVwiKTtcblxuLyoqXG4gKiDlpJrovrnlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9Qb2x5Z29uXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3BvbHlnb24nLFxuICBzaGFwZToge1xuICAgIHBvaW50czogbnVsbCxcbiAgICBzbW9vdGg6IGZhbHNlLFxuICAgIHNtb290aENvbnN0cmFpbnQ6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHBvbHlIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUsIHRydWUpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc21vb3RoU3BsaW5lID0gcmVxdWlyZShcIi4vc21vb3RoU3BsaW5lXCIpO1xuXG52YXIgc21vb3RoQmV6aWVyID0gcmVxdWlyZShcIi4vc21vb3RoQmV6aWVyXCIpO1xuXG5mdW5jdGlvbiBidWlsZFBhdGgoY3R4LCBzaGFwZSwgY2xvc2VQYXRoKSB7XG4gIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gIHZhciBzbW9vdGggPSBzaGFwZS5zbW9vdGg7XG5cbiAgaWYgKHBvaW50cyAmJiBwb2ludHMubGVuZ3RoID49IDIpIHtcbiAgICBpZiAoc21vb3RoICYmIHNtb290aCAhPT0gJ3NwbGluZScpIHtcbiAgICAgIHZhciBjb250cm9sUG9pbnRzID0gc21vb3RoQmV6aWVyKHBvaW50cywgc21vb3RoLCBjbG9zZVBhdGgsIHNoYXBlLnNtb290aENvbnN0cmFpbnQpO1xuICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7XG4gICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoY2xvc2VQYXRoID8gbGVuIDogbGVuIC0gMSk7IGkrKykge1xuICAgICAgICB2YXIgY3AxID0gY29udHJvbFBvaW50c1tpICogMl07XG4gICAgICAgIHZhciBjcDIgPSBjb250cm9sUG9pbnRzW2kgKiAyICsgMV07XG4gICAgICAgIHZhciBwID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjcDFbMF0sIGNwMVsxXSwgY3AyWzBdLCBjcDJbMV0sIHBbMF0sIHBbMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc21vb3RoID09PSAnc3BsaW5lJykge1xuICAgICAgICBwb2ludHMgPSBzbW9vdGhTcGxpbmUocG9pbnRzLCBjbG9zZVBhdGgpO1xuICAgICAgfVxuXG4gICAgICBjdHgubW92ZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsb3NlUGF0aCAmJiBjdHguY2xvc2VQYXRoKCk7XG4gIH1cbn1cblxuZXhwb3J0cy5idWlsZFBhdGggPSBidWlsZFBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3BvbHkuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgdjJEaXN0YW5jZSA9IF92ZWN0b3IuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2F0bXVsbC1Sb20gc3BsaW5lIOaPkuWAvOaKmOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqICAgICAgICAgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gIHJldHVybiAoMiAqIChwMSAtIHAyKSArIHYwICsgdjEpICogdDMgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MiArIHYwICogdCArIHAxO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhTcGxpbmVcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyDnur/mrrXpobbngrnmlbDnu4RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb29wXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIF9kZWZhdWx0KHBvaW50cywgaXNMb29wKSB7XG4gIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICB2YXIgcmV0ID0gW107XG4gIHZhciBkaXN0YW5jZSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgIGRpc3RhbmNlICs9IHYyRGlzdGFuY2UocG9pbnRzW2kgLSAxXSwgcG9pbnRzW2ldKTtcbiAgfVxuXG4gIHZhciBzZWdzID0gZGlzdGFuY2UgLyAyO1xuICBzZWdzID0gc2VncyA8IGxlbiA/IGxlbiA6IHNlZ3M7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzOyBpKyspIHtcbiAgICB2YXIgcG9zID0gaSAvIChzZWdzIC0gMSkgKiAoaXNMb29wID8gbGVuIDogbGVuIC0gMSk7XG4gICAgdmFyIGlkeCA9IE1hdGguZmxvb3IocG9zKTtcbiAgICB2YXIgdyA9IHBvcyAtIGlkeDtcbiAgICB2YXIgcDA7XG4gICAgdmFyIHAxID0gcG9pbnRzW2lkeCAlIGxlbl07XG4gICAgdmFyIHAyO1xuICAgIHZhciBwMztcblxuICAgIGlmICghaXNMb29wKSB7XG4gICAgICBwMCA9IHBvaW50c1tpZHggPT09IDAgPyBpZHggOiBpZHggLSAxXTtcbiAgICAgIHAyID0gcG9pbnRzW2lkeCA+IGxlbiAtIDIgPyBsZW4gLSAxIDogaWR4ICsgMV07XG4gICAgICBwMyA9IHBvaW50c1tpZHggPiBsZW4gLSAzID8gbGVuIC0gMSA6IGlkeCArIDJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwMCA9IHBvaW50c1soaWR4IC0gMSArIGxlbikgJSBsZW5dO1xuICAgICAgcDIgPSBwb2ludHNbKGlkeCArIDEpICUgbGVuXTtcbiAgICAgIHAzID0gcG9pbnRzWyhpZHggKyAyKSAlIGxlbl07XG4gICAgfVxuXG4gICAgdmFyIHcyID0gdyAqIHc7XG4gICAgdmFyIHczID0gdyAqIHcyO1xuICAgIHJldC5wdXNoKFtpbnRlcnBvbGF0ZShwMFswXSwgcDFbMF0sIHAyWzBdLCBwM1swXSwgdywgdzIsIHczKSwgaW50ZXJwb2xhdGUocDBbMV0sIHAxWzFdLCBwMlsxXSwgcDNbMV0sIHcsIHcyLCB3MyldKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aFNwbGluZS5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciB2Mk1pbiA9IF92ZWN0b3IubWluO1xudmFyIHYyTWF4ID0gX3ZlY3Rvci5tYXg7XG52YXIgdjJTY2FsZSA9IF92ZWN0b3Iuc2NhbGU7XG52YXIgdjJEaXN0YW5jZSA9IF92ZWN0b3IuZGlzdGFuY2U7XG52YXIgdjJBZGQgPSBfdmVjdG9yLmFkZDtcbnZhciB2MkNsb25lID0gX3ZlY3Rvci5jbG9uZTtcbnZhciB2MlN1YiA9IF92ZWN0b3Iuc3ViO1xuXG4vKipcbiAqIOi0neWhnuWwlOW5s+a7keabsue6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoQmV6aWVyXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqICAgICAgICAgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICog6LSd5aGe5bCU5bmz5ruR5puy57q/XG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhCZXppZXJcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyDnur/mrrXpobbngrnmlbDnu4RcbiAqIEBwYXJhbSB7bnVtYmVyfSBzbW9vdGgg5bmz5ruR562J57qnLCAwLTFcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb29wXG4gKiBAcGFyYW0ge0FycmF5fSBjb25zdHJhaW50IOWwhuiuoeeul+WHuuadpeeahOaOp+WItueCuee6puadn+WcqOS4gOS4quWMheWbtOebkuWGhVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICDmr5TlpoIgW1swLCAwXSwgWzEwMCwgMTAwXV0sIOi/meS4quWMheWbtOebkuS8muS4jlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICDmlbTkuKrmipjnur/nmoTljIXlm7Tnm5LlgZrkuIDkuKrlubbpm4bnlKjmnaXnuqbmnZ/mjqfliLbngrnjgIJcbiAqIEBwYXJhbSB7QXJyYXl9IOiuoeeul+WHuuadpeeahOaOp+WItueCueaVsOe7hFxuICovXG5mdW5jdGlvbiBfZGVmYXVsdChwb2ludHMsIHNtb290aCwgaXNMb29wLCBjb25zdHJhaW50KSB7XG4gIHZhciBjcHMgPSBbXTtcbiAgdmFyIHYgPSBbXTtcbiAgdmFyIHYxID0gW107XG4gIHZhciB2MiA9IFtdO1xuICB2YXIgcHJldlBvaW50O1xuICB2YXIgbmV4dFBvaW50O1xuICB2YXIgbWluLCBtYXg7XG5cbiAgaWYgKGNvbnN0cmFpbnQpIHtcbiAgICBtaW4gPSBbSW5maW5pdHksIEluZmluaXR5XTtcbiAgICBtYXggPSBbLUluZmluaXR5LCAtSW5maW5pdHldO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdjJNaW4obWluLCBtaW4sIHBvaW50c1tpXSk7XG4gICAgICB2Mk1heChtYXgsIG1heCwgcG9pbnRzW2ldKTtcbiAgICB9IC8vIOS4juaMh+WumueahOWMheWbtOebkuWBmuW5tumbhlxuXG5cbiAgICB2Mk1pbihtaW4sIG1pbiwgY29uc3RyYWludFswXSk7XG4gICAgdjJNYXgobWF4LCBtYXgsIGNvbnN0cmFpbnRbMV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcblxuICAgIGlmIChpc0xvb3ApIHtcbiAgICAgIHByZXZQb2ludCA9IHBvaW50c1tpID8gaSAtIDEgOiBsZW4gLSAxXTtcbiAgICAgIG5leHRQb2ludCA9IHBvaW50c1soaSArIDEpICUgbGVuXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICBjcHMucHVzaCh2MkNsb25lKHBvaW50c1tpXSkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZQb2ludCA9IHBvaW50c1tpIC0gMV07XG4gICAgICAgIG5leHRQb2ludCA9IHBvaW50c1tpICsgMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdjJTdWIodiwgbmV4dFBvaW50LCBwcmV2UG9pbnQpOyAvLyB1c2UgZGVncmVlIHRvIHNjYWxlIHRoZSBoYW5kbGUgbGVuZ3RoXG5cbiAgICB2MlNjYWxlKHYsIHYsIHNtb290aCk7XG4gICAgdmFyIGQwID0gdjJEaXN0YW5jZShwb2ludCwgcHJldlBvaW50KTtcbiAgICB2YXIgZDEgPSB2MkRpc3RhbmNlKHBvaW50LCBuZXh0UG9pbnQpO1xuICAgIHZhciBzdW0gPSBkMCArIGQxO1xuXG4gICAgaWYgKHN1bSAhPT0gMCkge1xuICAgICAgZDAgLz0gc3VtO1xuICAgICAgZDEgLz0gc3VtO1xuICAgIH1cblxuICAgIHYyU2NhbGUodjEsIHYsIC1kMCk7XG4gICAgdjJTY2FsZSh2MiwgdiwgZDEpO1xuICAgIHZhciBjcDAgPSB2MkFkZChbXSwgcG9pbnQsIHYxKTtcbiAgICB2YXIgY3AxID0gdjJBZGQoW10sIHBvaW50LCB2Mik7XG5cbiAgICBpZiAoY29uc3RyYWludCkge1xuICAgICAgdjJNYXgoY3AwLCBjcDAsIG1pbik7XG4gICAgICB2Mk1pbihjcDAsIGNwMCwgbWF4KTtcbiAgICAgIHYyTWF4KGNwMSwgY3AxLCBtaW4pO1xuICAgICAgdjJNaW4oY3AxLCBjcDEsIG1heCk7XG4gICAgfVxuXG4gICAgY3BzLnB1c2goY3AwKTtcbiAgICBjcHMucHVzaChjcDEpO1xuICB9XG5cbiAgaWYgKGlzTG9vcCkge1xuICAgIGNwcy5wdXNoKGNwcy5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBjcHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aEJlemllci5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL3BvbHlcIik7XG5cbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUG9seWxpbmVcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAncG9seWxpbmUnLFxuICBzaGFwZToge1xuICAgIHBvaW50czogbnVsbCxcbiAgICBzbW9vdGg6IGZhbHNlLFxuICAgIHNtb290aENvbnN0cmFpbnQ6IG51bGxcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICBwb2x5SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlLCBmYWxzZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci9yb3VuZFJlY3RcIik7XG5cbi8qKlxuICog55+p5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9SZWN0XG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3JlY3QnLFxuICBzaGFwZToge1xuICAgIC8vIOW3puS4iuOAgeWPs+S4iuOAgeWPs+S4i+OAgeW3puS4i+inkueahOWNiuW+hOS+neasoeS4unIx44CBcjLjgIFyM+OAgXI0XG4gICAgLy8gcue8qeWGmeS4ujEgICAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXG4gICAgLy8gcue8qeWGmeS4ulsxXSAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXG4gICAgLy8gcue8qeWGmeS4ulsxLCAyXSAgICDnm7jlvZPkuo4gWzEsIDIsIDEsIDJdXG4gICAgLy8gcue8qeWGmeS4ulsxLCAyLCAzXSDnm7jlvZPkuo4gWzEsIDIsIDMsIDJdXG4gICAgcjogMCxcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgdmFyIHkgPSBzaGFwZS55O1xuICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG5cbiAgICBpZiAoIXNoYXBlLnIpIHtcbiAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3VuZFJlY3RIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUpO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm47XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog55u057q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9MaW5lXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2xpbmUnLFxuICBzaGFwZToge1xuICAgIC8vIFN0YXJ0IHBvaW50XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgLy8gRW5kIHBvaW50XG4gICAgeDI6IDAsXG4gICAgeTI6IDAsXG4gICAgcGVyY2VudDogMVxuICB9LFxuICBzdHlsZToge1xuICAgIHN0cm9rZTogJyMwMDAnLFxuICAgIGZpbGw6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4MSA9IHNoYXBlLngxO1xuICAgIHZhciB5MSA9IHNoYXBlLnkxO1xuICAgIHZhciB4MiA9IHNoYXBlLngyO1xuICAgIHZhciB5MiA9IHNoYXBlLnkyO1xuICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcblxuICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICB4MiA9IHgxICogKDEgLSBwZXJjZW50KSArIHgyICogcGVyY2VudDtcbiAgICAgIHkyID0geTEgKiAoMSAtIHBlcmNlbnQpICsgeTIgKiBwZXJjZW50O1xuICAgIH1cblxuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgcG9pbnRBdDogZnVuY3Rpb24gKHApIHtcbiAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgIHJldHVybiBbc2hhcGUueDEgKiAoMSAtIHApICsgc2hhcGUueDIgKiBwLCBzaGFwZS55MSAqICgxIC0gcCkgKyBzaGFwZS55MiAqIHBdO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgdmVjMiA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIF9jdXJ2ZSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2N1cnZlXCIpO1xuXG52YXIgcXVhZHJhdGljU3ViZGl2aWRlID0gX2N1cnZlLnF1YWRyYXRpY1N1YmRpdmlkZTtcbnZhciBjdWJpY1N1YmRpdmlkZSA9IF9jdXJ2ZS5jdWJpY1N1YmRpdmlkZTtcbnZhciBxdWFkcmF0aWNBdCA9IF9jdXJ2ZS5xdWFkcmF0aWNBdDtcbnZhciBjdWJpY0F0ID0gX2N1cnZlLmN1YmljQXQ7XG52YXIgcXVhZHJhdGljRGVyaXZhdGl2ZUF0ID0gX2N1cnZlLnF1YWRyYXRpY0Rlcml2YXRpdmVBdDtcbnZhciBjdWJpY0Rlcml2YXRpdmVBdCA9IF9jdXJ2ZS5jdWJpY0Rlcml2YXRpdmVBdDtcblxuLyoqXG4gKiDotJ3loZ7lsJTmm7Lnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9CZXppZXJDdXJ2ZVxuICovXG52YXIgb3V0ID0gW107XG5cbmZ1bmN0aW9uIHNvbWVWZWN0b3JBdChzaGFwZSwgdCwgaXNUYW5nZW50KSB7XG4gIHZhciBjcHgyID0gc2hhcGUuY3B4MjtcbiAgdmFyIGNweTIgPSBzaGFwZS5jcHkyO1xuXG4gIGlmIChjcHgyID09PSBudWxsIHx8IGNweTIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gWyhpc1RhbmdlbnQgPyBjdWJpY0Rlcml2YXRpdmVBdCA6IGN1YmljQXQpKHNoYXBlLngxLCBzaGFwZS5jcHgxLCBzaGFwZS5jcHgyLCBzaGFwZS54MiwgdCksIChpc1RhbmdlbnQgPyBjdWJpY0Rlcml2YXRpdmVBdCA6IGN1YmljQXQpKHNoYXBlLnkxLCBzaGFwZS5jcHkxLCBzaGFwZS5jcHkyLCBzaGFwZS55MiwgdCldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbKGlzVGFuZ2VudCA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA6IHF1YWRyYXRpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUueDIsIHQpLCAoaXNUYW5nZW50ID8gcXVhZHJhdGljRGVyaXZhdGl2ZUF0IDogcXVhZHJhdGljQXQpKHNoYXBlLnkxLCBzaGFwZS5jcHkxLCBzaGFwZS55MiwgdCldO1xuICB9XG59XG5cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2Jlemllci1jdXJ2ZScsXG4gIHNoYXBlOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgeDI6IDAsXG4gICAgeTI6IDAsXG4gICAgY3B4MTogMCxcbiAgICBjcHkxOiAwLFxuICAgIC8vIGNweDI6IDAsXG4gICAgLy8gY3B5MjogMFxuICAgIC8vIEN1cnZlIHNob3cgcGVyY2VudCwgZm9yIGFuaW1hdGluZ1xuICAgIHBlcmNlbnQ6IDFcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeDEgPSBzaGFwZS54MTtcbiAgICB2YXIgeTEgPSBzaGFwZS55MTtcbiAgICB2YXIgeDIgPSBzaGFwZS54MjtcbiAgICB2YXIgeTIgPSBzaGFwZS55MjtcbiAgICB2YXIgY3B4MSA9IHNoYXBlLmNweDE7XG4gICAgdmFyIGNweTEgPSBzaGFwZS5jcHkxO1xuICAgIHZhciBjcHgyID0gc2hhcGUuY3B4MjtcbiAgICB2YXIgY3B5MiA9IHNoYXBlLmNweTI7XG4gICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xuXG4gICAgaWYgKHBlcmNlbnQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG5cbiAgICBpZiAoY3B4MiA9PSBudWxsIHx8IGNweTIgPT0gbnVsbCkge1xuICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZSh4MSwgY3B4MSwgeDIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgIHgyID0gb3V0WzJdO1xuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoeTEsIGNweTEsIHkyLCBwZXJjZW50LCBvdXQpO1xuICAgICAgICBjcHkxID0gb3V0WzFdO1xuICAgICAgICB5MiA9IG91dFsyXTtcbiAgICAgIH1cblxuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY3B4MSwgY3B5MSwgeDIsIHkyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgIGN1YmljU3ViZGl2aWRlKHgxLCBjcHgxLCBjcHgyLCB4MiwgcGVyY2VudCwgb3V0KTtcbiAgICAgICAgY3B4MSA9IG91dFsxXTtcbiAgICAgICAgY3B4MiA9IG91dFsyXTtcbiAgICAgICAgeDIgPSBvdXRbM107XG4gICAgICAgIGN1YmljU3ViZGl2aWRlKHkxLCBjcHkxLCBjcHkyLCB5MiwgcGVyY2VudCwgb3V0KTtcbiAgICAgICAgY3B5MSA9IG91dFsxXTtcbiAgICAgICAgY3B5MiA9IG91dFsyXTtcbiAgICAgICAgeTIgPSBvdXRbM107XG4gICAgICB9XG5cbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNweDEsIGNweTEsIGNweDIsIGNweTIsIHgyLCB5Mik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBwb2ludEF0OiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGFuZ2VudCBhdCBwZXJjZW50XG4gICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHRhbmdlbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgcCA9IHNvbWVWZWN0b3JBdCh0aGlzLnNoYXBlLCB0LCB0cnVlKTtcbiAgICByZXR1cm4gdmVjMi5ub3JtYWxpemUocCwgcCk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOWchuW8p1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvQXJjXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2FyYycsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjogMCxcbiAgICBzdGFydEFuZ2xlOiAwLFxuICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcbiAgICBjbG9ja3dpc2U6IHRydWVcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgdmFyIGVuZEFuZ2xlID0gc2hhcGUuZW5kQW5nbGU7XG4gICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcbiAgICB2YXIgdW5pdFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICBjdHgubW92ZVRvKHVuaXRYICogciArIHgsIHVuaXRZICogciArIHkpO1xuICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgR3JhZGllbnQgPSByZXF1aXJlKFwiLi9HcmFkaWVudFwiKTtcblxuLyoqXG4gKiB4LCB5LCB4MiwgeTIgYXJlIGFsbCBwZXJjZW50IGZyb20gMCB0byAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFt4Mj0xXVxuICogQHBhcmFtIHtudW1iZXJ9IFt5Mj0wXVxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gY29sb3JTdG9wc1xuICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsQ29vcmQ9ZmFsc2VdXG4gKi9cbnZhciBMaW5lYXJHcmFkaWVudCA9IGZ1bmN0aW9uICh4LCB5LCB4MiwgeTIsIGNvbG9yU3RvcHMsIGdsb2JhbENvb3JkKSB7XG4gIC8vIFNob3VsZCBkbyBub3RoaW5nIG1vcmUgaW4gdGhpcyBjb25zdHJ1Y3Rvci4gQmVjYXVzZSBncmFkaWVudCBjYW4gYmVcbiAgLy8gZGVjbGFyZCBieSBgY29sb3I6IHt0eXBlOiAnbGluZWFyJywgY29sb3JTdG9wczogLi4ufWAsIHdoZXJlXG4gIC8vIHRoaXMgY29uc3RydWN0b3Igd2lsbCBub3QgYmUgY2FsbGVkLlxuICB0aGlzLnggPSB4ID09IG51bGwgPyAwIDogeDtcbiAgdGhpcy55ID0geSA9PSBudWxsID8gMCA6IHk7XG4gIHRoaXMueDIgPSB4MiA9PSBudWxsID8gMSA6IHgyO1xuICB0aGlzLnkyID0geTIgPT0gbnVsbCA/IDAgOiB5MjsgLy8gQ2FuIGJlIGNsb25lZFxuXG4gIHRoaXMudHlwZSA9ICdsaW5lYXInOyAvLyBJZiB1c2UgZ2xvYmFsIGNvb3JkXG5cbiAgdGhpcy5nbG9iYWwgPSBnbG9iYWxDb29yZCB8fCBmYWxzZTtcbiAgR3JhZGllbnQuY2FsbCh0aGlzLCBjb2xvclN0b3BzKTtcbn07XG5cbkxpbmVhckdyYWRpZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IExpbmVhckdyYWRpZW50XG59O1xuenJVdGlsLmluaGVyaXRzKExpbmVhckdyYWRpZW50LCBHcmFkaWVudCk7XG52YXIgX2RlZmF1bHQgPSBMaW5lYXJHcmFkaWVudDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgR3JhZGllbnQgPSByZXF1aXJlKFwiLi9HcmFkaWVudFwiKTtcblxuLyoqXG4gKiB4LCB5LCByIGFyZSBhbGwgcGVyY2VudCBmcm9tIDAgdG8gMVxuICogQHBhcmFtIHtudW1iZXJ9IFt4PTAuNV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wLjVdXG4gKiBAcGFyYW0ge251bWJlcn0gW3I9MC41XVxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW2NvbG9yU3RvcHNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxDb29yZD1mYWxzZV1cbiAqL1xudmFyIFJhZGlhbEdyYWRpZW50ID0gZnVuY3Rpb24gKHgsIHksIHIsIGNvbG9yU3RvcHMsIGdsb2JhbENvb3JkKSB7XG4gIC8vIFNob3VsZCBkbyBub3RoaW5nIG1vcmUgaW4gdGhpcyBjb25zdHJ1Y3Rvci4gQmVjYXVzZSBncmFkaWVudCBjYW4gYmVcbiAgLy8gZGVjbGFyZCBieSBgY29sb3I6IHt0eXBlOiAncmFkaWFsJywgY29sb3JTdG9wczogLi4ufWAsIHdoZXJlXG4gIC8vIHRoaXMgY29uc3RydWN0b3Igd2lsbCBub3QgYmUgY2FsbGVkLlxuICB0aGlzLnggPSB4ID09IG51bGwgPyAwLjUgOiB4O1xuICB0aGlzLnkgPSB5ID09IG51bGwgPyAwLjUgOiB5O1xuICB0aGlzLnIgPSByID09IG51bGwgPyAwLjUgOiByOyAvLyBDYW4gYmUgY2xvbmVkXG5cbiAgdGhpcy50eXBlID0gJ3JhZGlhbCc7IC8vIElmIHVzZSBnbG9iYWwgY29vcmRcblxuICB0aGlzLmdsb2JhbCA9IGdsb2JhbENvb3JkIHx8IGZhbHNlO1xuICBHcmFkaWVudC5jYWxsKHRoaXMsIGNvbG9yU3RvcHMpO1xufTtcblxuUmFkaWFsR3JhZGllbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUmFkaWFsR3JhZGllbnRcbn07XG56clV0aWwuaW5oZXJpdHMoUmFkaWFsR3JhZGllbnQsIEdyYWRpZW50KTtcbnZhciBfZGVmYXVsdCA9IFJhZGlhbEdyYWRpZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuL1N0eWxlXCIpO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHZlYzJDb3B5ID0gX3ZlY3Rvci5jb3B5O1xuXG4vKipcbiAqIFN0YXRlcyBtYWNoaW5lIGZvciBtYW5hZ2luZyBncmFwaGljIHN0YXRlc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSUdyYXBoaWNTdGF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6bGV2ZWxdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pdXG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSB7cG9zaXRpb259XG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bWJlcn0ge3JvdGF0aW9ufVxuICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPn0ge3NjYWxlfVxuICogQHByb3BlcnR5IHtPYmplY3R9IHN0eWxlXG4gKlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb25lbnRlclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb25sZWF2ZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb250cmFuc2l0aW9uXG4gKiBAcHJvcGVydHkge0FycmF5LjxJR3JhcGhpY1N0YXRlVHJhbnNpdGlvbnxzdHJpbmc+fSB0cmFuc2l0aW9uXG4gKiAgICAgICAgICAgVHJhbnNpdGlvbiBvYmplY3Qgb3IgYSBzdHJpbmcgZGVzY3JpcHRvciBsaWtlICcqIDMwIDAgTGluZWFyJ1xuICovXG52YXIgdHJhbnNpdGlvblByb3BlcnRpZXMgPSBbJ3Bvc2l0aW9uJywgJ3JvdGF0aW9uJywgJ3NjYWxlJywgJ3N0eWxlJywgJ3NoYXBlJ107XG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL1N0YXRlc35UcmFuc2l0aW9uT2JqZWN0XG4gKi9cblxudmFyIFRyYW5zaXRpb25PYmplY3QgPSBmdW5jdGlvbiAob3B0cykge1xuICBpZiAodHlwZW9mIG9wdHMgPT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLl9mcm9tU3RyKG9wdHMpO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICBvcHRzLnByb3BlcnR5ICYmICh0aGlzLnByb3BlcnR5ID0gb3B0cy5wcm9wZXJ0eSk7XG4gICAgb3B0cy5kdXJhdGlvbiAhPSBudWxsICYmICh0aGlzLmR1cmF0aW9uID0gb3B0cy5kdXJhdGlvbik7XG4gICAgb3B0cy5lYXNpbmcgJiYgKHRoaXMuZWFzaW5nID0gb3B0cy5lYXNpbmcpO1xuICAgIG9wdHMuZGVsYXkgJiYgKHRoaXMuZGVsYXkgPSBvcHRzLmRlbGF5KTtcbiAgfVxuXG4gIGlmICh0aGlzLnByb3BlcnR5ICE9PSAnKicpIHtcbiAgICB0aGlzLnByb3BlcnR5ID0gdGhpcy5wcm9wZXJ0eS5zcGxpdCgnLCcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucHJvcGVydHkgPSB0cmFuc2l0aW9uUHJvcGVydGllcztcbiAgfVxufTtcblxuVHJhbnNpdGlvbk9iamVjdC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2l0aW9uT2JqZWN0LFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFsbCB0cmFuc2l0aW9uIHByb3BlcnRpZXMuIFNwbGl0dGVkIGJ5IGNvbW1hLiBNdXN0IG5vdCBoYXZlIHNwYWNlcyBpbiB0aGUgc3RyaW5nLlxuICAgKiBlLmcuICdwb3NpdGlvbixzdHlsZS5jb2xvcicuICcqJyB3aWxsIG1hdGNoIGFsbCB0aGUgdmFsaWQgcHJvcGVydGllcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgKlxuICAgKi9cbiAgcHJvcGVydHk6ICcqJyxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ0xpbmVhcidcbiAgICovXG4gIGVhc2luZzogJ0xpbmVhcicsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0ICdudW1iZXInXG4gICAqL1xuICBkdXJhdGlvbjogNTAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZGVsYXk6IDAsXG4gIF9mcm9tU3RyOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIGFyciA9IHN0ci5zcGxpdCgvXFxzKy9nKTtcbiAgICB0aGlzLnByb3BlcnR5ID0gYXJyWzBdO1xuICAgIHRoaXMuZHVyYXRpb24gPSArYXJyWzFdO1xuICAgIHRoaXMuZGVsYXkgPSArYXJyWzJdO1xuICAgIHRoaXMuZWFzaW5nID0gYXJyWzNdO1xuICB9XG59O1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdGF0ZXNcbiAqL1xuXG52YXIgR3JhcGhpY1N0YXRlcyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLl9zdGF0ZXMgPSB7fTtcbiAgLyoqXG4gICAqIFRhcmdldCBlbGVtZW50XG4gICAqIEB0eXBlIHt6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGV8enJlbmRlci9jb250YWluZXIvR3JvdXB9XG4gICAqL1xuXG4gIHRoaXMuX2VsID0gb3B0cy5lbDtcbiAgdGhpcy5fc3ViU3RhdGVzID0gW107XG4gIHRoaXMuX3RyYW5zaXRpb25BbmltYXRvcnMgPSBbXTtcblxuICBpZiAob3B0cy5pbml0aWFsU3RhdGUpIHtcbiAgICB0aGlzLl9pbml0aWFsU3RhdGUgPSBvcHRzLmluaXRpYWxTdGF0ZTtcbiAgfVxuXG4gIHZhciBvcHRzU3RhdGVzID0gb3B0cy5zdGF0ZXM7XG5cbiAgaWYgKG9wdHNTdGF0ZXMpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG9wdHNTdGF0ZXMpIHtcbiAgICAgIGlmIChvcHRzU3RhdGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IG9wdHNTdGF0ZXNbbmFtZV07XG5cbiAgICAgICAgdGhpcy5fYWRkU3RhdGUobmFtZSwgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuc2V0U3RhdGUodGhpcy5faW5pdGlhbFN0YXRlKTtcbn07XG5cbkdyYXBoaWNTdGF0ZXMucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogR3JhcGhpY1N0YXRlcyxcblxuICAvKipcbiAgICogQWxsIG90aGVyIHN0YXRlIHdpbGwgYmUgZXh0ZW5kZWQgZnJvbSBpbml0aWFsIHN0YXRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdGlhbFN0YXRlOiAnbm9ybWFsJyxcblxuICAvKipcbiAgICogQ3VycmVudCBzdGF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2N1cnJlbnRTdGF0ZTogJycsXG4gIGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsO1xuICB9LFxuICBfYWRkU3RhdGU6IGZ1bmN0aW9uIChuYW1lLCBzdGF0ZSkge1xuICAgIHRoaXMuX3N0YXRlc1tuYW1lXSA9IHN0YXRlO1xuXG4gICAgaWYgKHN0YXRlLnRyYW5zaXRpb24pIHtcbiAgICAgIHN0YXRlLnRyYW5zaXRpb24gPSBuZXcgVHJhbnNpdGlvbk9iamVjdChzdGF0ZS50cmFuc2l0aW9uKTtcbiAgICB9IC8vIEV4dGVuZCBmcm9tIGluaXRpYWwgc3RhdGVcblxuXG4gICAgaWYgKG5hbWUgIT09IHRoaXMuX2luaXRpYWxTdGF0ZSkge1xuICAgICAgdGhpcy5fZXh0ZW5kRnJvbUluaXRpYWwoc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLl9lbDsgLy8gc2V0U3RhdGUg55qE5pe25YCZ6Ieq5bim55qEIHN0eWxlIOWSjCBzaGFwZSDpg73kvJrooqvnm7TmjqXopobnm5ZcbiAgICAgIC8vIOaJgOS7pei/mei+ueWFiOaKiuiHquW4pueahCBzdHlsZSDlkowgc2hhcGUg5omp5bGV5Yiw5Yid5aeL54q25oCB5LitXG5cbiAgICAgIHpyVXRpbC5tZXJnZShzdGF0ZS5zdHlsZSwgZWwuc3R5bGUsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAgIGlmIChzdGF0ZS5zaGFwZSkge1xuICAgICAgICB6clV0aWwubWVyZ2Uoc3RhdGUuc2hhcGUsIGVsLnNoYXBlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5zaGFwZSA9IHpyVXRpbC5jbG9uZShlbC5zaGFwZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5fc3RhdGVzKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB0aGlzLl9leHRlbmRGcm9tSW5pdGlhbCh0aGlzLl9zdGF0ZXNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfZXh0ZW5kRnJvbUluaXRpYWw6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLl9zdGF0ZXNbdGhpcy5faW5pdGlhbFN0YXRlXTtcblxuICAgIGlmIChpbml0aWFsU3RhdGUgJiYgc3RhdGUgIT09IGluaXRpYWxTdGF0ZSkge1xuICAgICAgenJVdGlsLm1lcmdlKHN0YXRlLCBpbml0aWFsU3RhdGUsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gIH0sXG4gIHNldFN0YXRlOiBmdW5jdGlvbiAobmFtZSwgc2lsZW50KSB7XG4gICAgaWYgKG5hbWUgPT09IHRoaXMuX2N1cnJlbnRTdGF0ZSAmJiAhdGhpcy50cmFuc2l0aW5nKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZXNbbmFtZV07XG5cbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHRoaXMuX3N0b3BUcmFuc2l0aW9uKCk7XG5cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHZhciBwcmV2U3RhdGUgPSB0aGlzLl9zdGF0ZXNbdGhpcy5fY3VycmVudFN0YXRlXTtcblxuICAgICAgICBpZiAocHJldlN0YXRlKSB7XG4gICAgICAgICAgcHJldlN0YXRlLm9ubGVhdmUgJiYgcHJldlN0YXRlLm9ubGVhdmUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLm9uZW50ZXIgJiYgc3RhdGUub25lbnRlci5jYWxsKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jdXJyZW50U3RhdGUgPSBuYW1lO1xuXG4gICAgICBpZiAodGhpcy5fZWwpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5fZWw7IC8vIFNldHRpbmcgYXR0cmlidXRlc1xuXG4gICAgICAgIGlmIChzdGF0ZS56bGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICAgIGVsLnpsZXZlbCA9IHN0YXRlLnpsZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZS56ICE9IG51bGwpIHtcbiAgICAgICAgICBlbC56ID0gc3RhdGUuejtcbiAgICAgICAgfSAvLyBTUlRcblxuXG4gICAgICAgIHN0YXRlLnBvc2l0aW9uICYmIHZlYzJDb3B5KGVsLnBvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIHN0YXRlLnNjYWxlICYmIHZlYzJDb3B5KGVsLnNjYWxlLCBzdGF0ZS5zY2FsZSk7XG5cbiAgICAgICAgaWYgKHN0YXRlLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICBlbC5yb3RhdGlvbiA9IHN0YXRlLnJvdGF0aW9uO1xuICAgICAgICB9IC8vIFN0eWxlXG5cblxuICAgICAgICBpZiAoc3RhdGUuc3R5bGUpIHtcbiAgICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5fc3RhdGVzW3RoaXMuX2luaXRpYWxTdGF0ZV07XG4gICAgICAgICAgZWwuc3R5bGUgPSBuZXcgU3R5bGUoKTtcblxuICAgICAgICAgIGlmIChpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmV4dGVuZEZyb20oaW5pdGlhbFN0YXRlLnN0eWxlLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCAvLyBOb3QgaW5pdGlhbCBzdGF0ZVxuICAgICAgICAgIG5hbWUgIT0gdGhpcy5faW5pdGlhbFN0YXRlIC8vIE5vdCBjb3BpZWQgZnJvbSBpbml0aWFsIHN0YXRlIGluIF9leHRlbmRGcm9tSW5pdGlhbCBtZXRob2RcbiAgICAgICAgICAmJiBpbml0aWFsU3RhdGUuc3R5bGUgIT09IHN0YXRlLnN0eWxlKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5leHRlbmRGcm9tKHN0YXRlLnN0eWxlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUuc2hhcGUpIHtcbiAgICAgICAgICBlbC5zaGFwZSA9IHpyVXRpbC5jbG9uZShzdGF0ZS5zaGFwZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbC5kaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc3ViU3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9zdWJTdGF0ZXMuc2V0U3RhdGUobmFtZSk7XG4gICAgfVxuICB9LFxuICBnZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGU7XG4gIH0sXG4gIHRyYW5zaXRpb25TdGF0ZTogZnVuY3Rpb24gKHRhcmdldCwgZG9uZSkge1xuICAgIGlmICh0YXJnZXQgPT09IHRoaXMuX2N1cnJlbnRTdGF0ZSAmJiAhdGhpcy50cmFuc2l0aW5nKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZXNbdGFyZ2V0XTtcbiAgICB2YXIgc3R5bGVTaGFwZVJlZyA9IC8kW3N0eWxlfHNoYXBlXVxcLi87XG4gICAgdmFyIHNlbGYgPSB0aGlzOyAvLyBBbmltYXRpb24g5Y676YeNXG5cbiAgICB2YXIgcHJvcFBhdGhNYXAgPSB7fTtcblxuICAgIGlmIChzdGF0ZSkge1xuICAgICAgc2VsZi5fc3RvcFRyYW5zaXRpb24oKTtcblxuICAgICAgdmFyIGVsID0gc2VsZi5fZWw7XG5cbiAgICAgIGlmIChzdGF0ZS50cmFuc2l0aW9uICYmIGVsICYmIGVsLl9fenIpIHtcbiAgICAgICAgLy8gRWwgY2FuIGJlIGFuaW1hdGVkXG4gICAgICAgIHZhciB0cmFuc2l0aW9uQ2ZnID0gc3RhdGUudHJhbnNpdGlvbjtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gdHJhbnNpdGlvbkNmZy5wcm9wZXJ0eTtcbiAgICAgICAgdmFyIGFuaW1hdGluZ0NvdW50ID0gMDtcblxuICAgICAgICB2YXIgYW5pbWF0aW9uRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhbmltYXRpbmdDb3VudC0tO1xuXG4gICAgICAgICAgaWYgKGFuaW1hdGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBzZWxmLnNldFN0YXRlKHRhcmdldCk7XG4gICAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0eS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5W2ldOyAvLyBBbmltYXRpbmcgYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHN0eWxlIG9yIHNoYXBlXG5cbiAgICAgICAgICBpZiAocHJvcE5hbWUgPT09ICdzdHlsZScgfHwgcHJvcE5hbWUgPT09ICdzaGFwZScpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZVtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHN0YXRlW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGVbcHJvcE5hbWVdLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gcHJvcE5hbWUgKyAnLicgKyBrZXk7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcFBhdGhNYXBbcGF0aF0pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByb3BQYXRoTWFwW3BhdGhdID0gMTtcbiAgICAgICAgICAgICAgICBhbmltYXRpbmdDb3VudCArPSBzZWxmLl9hbmltUHJvcChzdGF0ZSwgcHJvcE5hbWUsIGtleSwgdHJhbnNpdGlvbkNmZywgYW5pbWF0aW9uRG9uZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByb3BQYXRoTWFwW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcFBhdGhNYXBbcHJvcE5hbWVdID0gMTsgLy8gQW5pbWF0aW5nIHBhcnRpY3VsYXIgcHJvcGVydHkgaW4gc3R5bGUgb3Igc3R5bGVcblxuICAgICAgICAgICAgaWYgKHByb3BOYW1lLm1hdGNoKHN0eWxlU2hhcGVSZWcpKSB7XG4gICAgICAgICAgICAgIC8vIHJlbW92ZSAnc3R5bGUuJywgJ3NoYXBlLicgcHJlZml4XG4gICAgICAgICAgICAgIHZhciBzdWJQcm9wID0gcHJvcE5hbWUuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgICAgIHByb3BOYW1lID0gcHJvcE5hbWUuc2xpY2UoNik7XG4gICAgICAgICAgICAgIGFuaW1hdGluZ0NvdW50ICs9IHNlbGYuX2FuaW1Qcm9wKHN0YXRlLCBzdWJQcm9wLCBwcm9wTmFtZSwgdHJhbnNpdGlvbkNmZywgYW5pbWF0aW9uRG9uZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbmltYXRpbmdDb3VudCArPSBzZWxmLl9hbmltUHJvcChzdGF0ZSwgJycsIHByb3BOYW1lLCB0cmFuc2l0aW9uQ2ZnLCBhbmltYXRpb25Eb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gTm8gdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG5cblxuICAgICAgICBpZiAoYW5pbWF0aW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgICBzZWxmLnNldFN0YXRlKHRhcmdldCk7XG4gICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc2V0U3RhdGUodGFyZ2V0KTtcbiAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN1YlN0YXRlcyA9IHNlbGYuX3N1YlN0YXRlcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ViU3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdWJTdGF0ZXMudHJhbnNpdGlvblN0YXRlKHRhcmdldCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEbyB0cmFuc2l0aW9uIGFuaW1hdGlvbiBvZiBwYXJ0aWN1bGFyIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViUHJvcEtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2l0aW9uQ2ZnXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hbmltUHJvcDogZnVuY3Rpb24gKHN0YXRlLCBzdWJQcm9wS2V5LCBrZXksIHRyYW5zaXRpb25DZmcsIGRvbmUpIHtcbiAgICB2YXIgZWwgPSB0aGlzLl9lbDtcbiAgICB2YXIgc3RhdGVPYmogPSBzdWJQcm9wS2V5ID8gc3RhdGVbc3ViUHJvcEtleV0gOiBzdGF0ZTtcbiAgICB2YXIgZWxPYmogPSBzdWJQcm9wS2V5ID8gZWxbc3ViUHJvcEtleV0gOiBlbDtcbiAgICB2YXIgYXZhaWxhYmxlUHJvcCA9IHN0YXRlT2JqICYmIGtleSBpbiBzdGF0ZU9iaiAmJiBlbE9iaiAmJiBrZXkgaW4gZWxPYmo7XG4gICAgdmFyIHRyYW5zaXRpb25BbmltYXRvcnMgPSB0aGlzLl90cmFuc2l0aW9uQW5pbWF0b3JzO1xuXG4gICAgaWYgKGF2YWlsYWJsZVByb3ApIHtcbiAgICAgIHZhciBvYmogPSB7fTtcblxuICAgICAgaWYgKHN0YXRlT2JqW2tleV0gPT09IGVsT2JqW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIG9ialtrZXldID0gc3RhdGVPYmpba2V5XTtcbiAgICAgIHZhciBhbmltYXRvciA9IGVsLmFuaW1hdGUoc3ViUHJvcEtleSkud2hlbih0cmFuc2l0aW9uQ2ZnLmR1cmF0aW9uLCBvYmopLmRlbGF5KHRyYW5zaXRpb25DZmcuZGVhbHkpLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWR4ID0genJVdGlsLmluZGV4T2YodHJhbnNpdGlvbkFuaW1hdG9ycywgMSk7XG5cbiAgICAgICAgaWYgKGlkeCA+IDApIHtcbiAgICAgICAgICB0cmFuc2l0aW9uQW5pbWF0b3JzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSkuc3RhcnQodHJhbnNpdGlvbkNmZy5lYXNpbmcpO1xuICAgICAgdHJhbnNpdGlvbkFuaW1hdG9ycy5wdXNoKGFuaW1hdG9yKTtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuICBfc3RvcFRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHJhbnNpdGlvbkFuaW1hdG9ycyA9IHRoaXMuX3RyYW5zaXRpb25BbmltYXRvcnM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zaXRpb25BbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyYW5zaXRpb25BbmltYXRvcnNbaV0uc3RvcCgpO1xuICAgIH1cblxuICAgIHRyYW5zaXRpb25BbmltYXRvcnMubGVuZ3RoID0gMDtcbiAgfSxcbiAgdHJhbnNpdGluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uQW5pbWF0b3JzLmxlbmd0aCA+IDA7XG4gIH0sXG4gIGFkZFN1YlN0YXRlczogZnVuY3Rpb24gKHN0YXRlcykge1xuICAgIHRoaXMuX3N1YlN0YXRlcy5wdXNoKHN0YXRlcyk7XG4gIH0sXG4gIHJlbW92ZVN1YlN0YXRlczogZnVuY3Rpb24gKHN0YXRlcykge1xuICAgIHZhciBpZHggPSB6clV0aWwuaW5kZXhPZih0aGlzLl9zdWJTdGF0ZXMsIHN0YXRlcyk7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuX3N1YlN0YXRlcy5zcGxpY2Uoc3RhdGVzLCAxKTtcbiAgICB9XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBHcmFwaGljU3RhdGVzO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9TdGF0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcbiAgICBmdW5jdGlvbiBNaW5pbWFwKGJpZ0NhbnZhcyxncm91cFBvc2l0aW9uLCBncm91cCxlYWdsZUV5ZU5vZGUsZGlzdGFuY2UsaW1nU3JjKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYmlnQ2FudmFzID0gYmlnQ2FudmFzO1xyXG4gICAgICAgIHRoaXMuZWFnbGVFeWVOb2RlID0gZWFnbGVFeWVOb2RlO1xyXG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICB0aGlzLmltZ1NyYyA9IGltZ1NyYztcclxuICAgICAgICB0aGlzLnJhdGlvO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBSYXRpbztcclxuICAgICAgICB0aGlzLmdyb3VwID0gZ3JvdXA7XHJcbiAgICAgICAgdGhpcy5pbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdGhpcy5ncm91cFBvc2l0aW9uID0genJVdGlsLmNsb25lKGdyb3VwUG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0UG9zaXRpb24gPSBbMCwwXTtcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIE1pbmltYXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGF0LnJhdGlvID0gMC4xMjtcclxuICAgICAgICB2YXIgZWFnbGVFeWVOb2RlV2lkdGggPSB0aGF0Lmdyb3VwLndpZHRoICAqIHRoYXQucmF0aW87XHJcbiAgICAgICAgdmFyIGVhZ2xlRXllTm9kZUhlaWdodCA9IHRoYXQuZ3JvdXAuaGVpZ2h0ICAqIHRoYXQucmF0aW87XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUud2lkdGggPSBlYWdsZUV5ZU5vZGVXaWR0aCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUuaGVpZ2h0ID0gZWFnbGVFeWVOb2RlSGVpZ2h0K1wicHhcIjtcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5zdHlsZS5tYXJnaW5Ub3AgPSAtZWFnbGVFeWVOb2RlSGVpZ2h0K1wicHhcIjtcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gdGhhdC5iaWdDYW52YXMuZ2V0V2lkdGgoKS1lYWdsZUV5ZU5vZGVXaWR0aCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwiO1xyXG4gICAgICAgIHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLmJhY2tncm91bmQgPSBcInVybChcIit0aGF0LmltZ1NyYytcIikgbm8tcmVwZWF0XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUuYmFja2dyb3VuZFNpemUgPSBlYWdsZUV5ZU5vZGVXaWR0aC8odGhhdC5ncm91cC53aWR0aCp0aGF0LmRpc3RhbmNlWzJdL3RoYXQuYmlnQ2FudmFzLmdldFdpZHRoKCkpK1wicHhcIjtcclxuICAgICAgICB0aGF0LmJhY2tncm91bmRTaXplID0genJVdGlsLmNsb25lKHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLmJhY2tncm91bmRTaXplKTtcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5pbm5lckhUTUwgPSBcIlwiO1xyXG4gICAgICAgIHRoYXQuc2VsZWN0aW9uLnN0eWxlLmJvcmRlciA9IFwiMXB4IHNvbGlkICNmZjAwMDBcIjtcclxuICAgICAgICB0aGF0LnNlbGVjdGlvbi5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcclxuICAgICAgICB0aGF0LnNlbGVjdGlvbi5zdHlsZS53aWR0aCA9IHRoYXQuYmlnQ2FudmFzLmdldFdpZHRoKCkvdGhhdC5ncm91cC53aWR0aCplYWdsZUV5ZU5vZGVXaWR0aCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5zZWxlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gdGhhdC5iaWdDYW52YXMuZ2V0SGVpZ2h0KCkvdGhhdC5ncm91cC5oZWlnaHQqZWFnbGVFeWVOb2RlSGVpZ2h0K1wicHhcIjtcclxuICAgICAgICB0aGF0LnNlbGVjdFdpZHRoID0gdGhhdC5zZWxlY3Rpb24uc3R5bGUud2lkdGg7XHJcbiAgICAgICAgdGhhdC5zZWxlY3RIZWlnaHQgPSB0aGF0LnNlbGVjdGlvbi5zdHlsZS5oZWlnaHQ7XHJcbiAgICAgICAgdGhhdC5zZWxlY3Rpb24uc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiO1xyXG4gICAgICAgIHRoYXQuc2VsZWN0aW9uLnN0eWxlLnRvcCA9IDArXCJweFwiO1xyXG4gICAgICAgIHRoYXQuc2VsZWN0aW9uLnN0eWxlLmxlZnQgPSAwK1wicHhcIjtcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdGlvbik7XHJcbiAgICB9O1xyXG4gICAgTWluaW1hcC5wcm90b3R5cGUudXBkYXRhU2VsZWN0aW9uID0gZnVuY3Rpb24ob2ZmZWN0TGVmdCxvZmZlY3RUb3Asem9vbVNjYWxlLG5vd1pvb20pe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGF0Lnpvb21TY2FsZSA9IHpvb21TY2FsZTtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zdHlsZS53aWR0aCA9IHRoaXMuc2VsZWN0aW9uLnN0eWxlLndpZHRoLnJlcGxhY2UoXCJweFwiLFwiXCIpL3pvb21TY2FsZStcInB4XCI7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gdGhpcy5zZWxlY3Rpb24uc3R5bGUuaGVpZ2h0LnJlcGxhY2UoXCJweFwiLFwiXCIpL3pvb21TY2FsZStcInB4XCI7XHJcbiAgICAgICAgdGhhdC5zZWxlY3RQb3NpdGlvblswXSA9IHpyVXRpbC5jbG9uZShvZmZlY3RMZWZ0KSp0aGF0LnJhdGlvL25vd1pvb207XHJcbiAgICAgICAgdGhhdC5zZWxlY3RQb3NpdGlvblsxXSA9IHpyVXRpbC5jbG9uZShvZmZlY3RUb3ApKnRoYXQucmF0aW8vbm93Wm9vbTtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zdHlsZS5sZWZ0ID0gLXRoYXQuc2VsZWN0UG9zaXRpb25bMF0rXCJweFwiO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnN0eWxlLnRvcCA9IC10aGF0LnNlbGVjdFBvc2l0aW9uWzFdK1wicHhcIjtcclxuICAgIH07XHJcbiAgICBNaW5pbWFwLnByb3RvdHlwZS51cGRhdGFNYXAgPSBmdW5jdGlvbihpbWdTcmMsbmV3R3JvdXApe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBcInVybChcIitpbWdTcmMrXCIpXCI7XHJcbiAgICAgICAgdmFyIGVhZ2xlRXllTm9kZVdpZHRoID0gbmV3R3JvdXAud2lkdGggICogdGhhdC5yYXRpbztcclxuICAgICAgICB2YXIgZWFnbGVFeWVOb2RlSGVpZ2h0ID0gbmV3R3JvdXAuaGVpZ2h0ICAqIHRoYXQucmF0aW87XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUud2lkdGggPSBlYWdsZUV5ZU5vZGVXaWR0aCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUuaGVpZ2h0ID0gZWFnbGVFeWVOb2RlSGVpZ2h0K1wicHhcIjtcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5zdHlsZS5tYXJnaW5Ub3AgPSAtZWFnbGVFeWVOb2RlSGVpZ2h0K1wicHhcIjtcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gdGhhdC5iaWdDYW52YXMuZ2V0V2lkdGgoKS1lYWdsZUV5ZU5vZGVXaWR0aCtcInB4XCI7XHJcbiAgICB9O1xyXG4gICAgTWluaW1hcC5wcm90b3R5cGUudXBkYXRhU2VsZWN0aW9uUG9zaXRpb24gPSBmdW5jdGlvbihub3dHcm91cFBvc2l0aW9uLG5vd1pvb20pe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGF0LnNlbGVjdFBvc2l0aW9uWzBdID0genJVdGlsLmNsb25lKG5vd0dyb3VwUG9zaXRpb25bMF0pKnRoYXQucmF0aW8vbm93Wm9vbTtcclxuICAgICAgICB0aGF0LnNlbGVjdFBvc2l0aW9uWzFdID0genJVdGlsLmNsb25lKG5vd0dyb3VwUG9zaXRpb25bMV0pKnRoYXQucmF0aW8vbm93Wm9vbTtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zdHlsZS5sZWZ0ID0gLXRoYXQuc2VsZWN0UG9zaXRpb25bMF0rXCJweFwiO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnN0eWxlLnRvcCA9IC10aGF0LnNlbGVjdFBvc2l0aW9uWzFdK1wicHhcIjtcclxuICAgIH07XHJcbiAgICBNaW5pbWFwLnByb3RvdHlwZS51cGRhdGFHcm91cFBvc2l0aW9uID0gZnVuY3Rpb24oZ3JvdXAsbm93Wm9vbSl7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwb3NpdGlvblggPSAtTnVtYmVyKHRoYXQuc2VsZWN0aW9uLnN0eWxlLmxlZnQuc3Vic3RyaW5nKDAsdGhhdC5zZWxlY3Rpb24uc3R5bGUubGVmdC5sZW5ndGgtMikpL3RoYXQucmF0aW8qbm93Wm9vbTtcclxuICAgICAgICB2YXIgcG9zaXRpb25ZID0gLU51bWJlcih0aGF0LnNlbGVjdGlvbi5zdHlsZS50b3Auc3Vic3RyaW5nKDAsdGhhdC5zZWxlY3Rpb24uc3R5bGUudG9wLmxlbmd0aC0yKSkvdGhhdC5yYXRpbypub3dab29tO1xyXG4gICAgICAgIGdyb3VwLmF0dHIoXCJwb3NpdGlvblwiLFtwb3NpdGlvblgscG9zaXRpb25ZXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gTWluaW1hcDtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9taW5pbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5bel5YW35pa55rOV57G7XHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4vUG9pbnQuanNcIik7XHJcbiAgICB2YXIgTGluZSA9IHJlcXVpcmUoXCIuL0xpbmVTdHJ1Y3QuanNcIik7XHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIC8qKlxyXG4gICAgICog5p6E6YCg57G757un5om/5YWz57O7XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xhenog5rqQ57G7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlQ2xhenog5Z+657G7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcclxuICAgICAgICB2YXIgY2xhenpQcm90b3R5cGUgPSBjbGF6ei5wcm90b3R5cGU7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxyXG4gICAgICAgIEYucHJvdG90eXBlID0gYmFzZUNsYXp6LnByb3RvdHlwZTtcclxuICAgICAgICBjbGF6ei5wcm90b3R5cGUgPSBuZXcgRigpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGNsYXp6UHJvdG90eXBlKSB7XHJcbiAgICAgICAgICAgIGNsYXp6LnByb3RvdHlwZVtwcm9wXSA9IGNsYXp6UHJvdG90eXBlW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGF6ei5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjbGF6ejtcclxuICAgICAgICBjbGF6ei5zdXBlckNsYXNzID0gYmFzZUNsYXp6O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFVVSUQoKSB7XHJcbiAgICAgICAgdmFyIGNoYXJzID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Jy5zcGxpdCgnJyksXHJcbiAgICAgICAgICAgIHV1aWQgPSBuZXcgQXJyYXkoMzYpLFxyXG4gICAgICAgICAgICBybmQgPSAwLFxyXG4gICAgICAgICAgICByO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzY7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA9PSA4IHx8IGkgPT0gMTMgfHwgaSA9PSAxOCB8fCBpID09IDIzKSB7XHJcbiAgICAgICAgICAgICAgICB1dWlkW2ldID0gJy0nO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT0gMTQpIHtcclxuICAgICAgICAgICAgICAgIHV1aWRbaV0gPSAnNCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocm5kIDw9IDB4MDIpIHJuZCA9IDB4MjAwMDAwMCArIChNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwKSB8IDA7XHJcbiAgICAgICAgICAgICAgICByID0gcm5kICYgMHhmO1xyXG4gICAgICAgICAgICAgICAgcm5kID0gcm5kID4+IDQ7XHJcbiAgICAgICAgICAgICAgICB1dWlkW2ldID0gY2hhcnNbKGkgPT0gMTkpID8gKHIgJiAweDMpIHwgMHg4IDogcl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwic2lkLVwiICsgdXVpZC5qb2luKCcnKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorqHnrpfkuKTngrnkuYvpl7TnmoTot53nprtcclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDEgLSBmaXJzdCB7UG9pbnR9XHJcbiAgICAgKkBwYXJhbSB7UG9pbnR9IHAyIC0gc2Vjb25kIHtQb2ludH1cclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRob3NlIDIgcG9pbnRzLiBJdCBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBkaXN0YW5jZShwMSwgcDIpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHAxLnggLSBwMi54LCAyKSArIE1hdGgucG93KHAxLnkgLSBwMi55LCAyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDov5Tlm57kuIDmnaHmipjnur8g5pyA6ZW/55qE5Lik5Liq54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHBvaW50cyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldE1heExpbmVMZW5ndGgocG9pbnRzKSB7XHJcbiAgICAgICAgdmFyIG0gPSBkaXN0YW5jZShwb2ludHNbMF0sIHBvaW50c1sxXSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtwb2ludHNbMF0sIHBvaW50c1sxXV07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAobSA8IGRpc3RhbmNlKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSkpIHtcclxuICAgICAgICAgICAgICAgIG0gPSBkaXN0YW5jZShwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbcG9pbnRzW2ldLCBwb2ludHNbaSArIDFdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipSZXR1cm5zIHRoZSBsZW5ndGggb2YgYSBQb2x5bGluZSB0aGF0IHdvdWxkIGJlIGNyZWF0ZWQgd2l0aCBhIHNldCBvZiBwb2ludHNcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIGFuIHtBcnJheX0gb2Yge1BvaW50c31cclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIGEgcG9zaXRpdmUgbnVtYmVyIGVxdWFsIHdpdGggdG90YWwgbGVuZ3RoKi9cclxuICAgIGZ1bmN0aW9uIGdldFBvbHlsaW5lTGVuZ3RoKHYpIHtcclxuICAgICAgICB2YXIgbCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBsICs9IGRpc3RhbmNlKHZbaV0sIHZbaSArIDFdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBsO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipSZXR1cm5zIHRoZSBtYXggb2YgYSB2ZWN0b3JcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIHZlY3RvciBvZiB7TnVtYmVyfXNcclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIHRoZSBtYXhpbXVtIG51bWJlciBmcm9tIHRoZSB2ZWN0b3Igb3IgTmFOIGlmIHZlY3RvciBpcyBlbXB0eVxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gbWF4KHYpIHtcclxuICAgICAgICBpZiAodi5sZW5naHQgPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBtID0gdlswXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobSA8IHZbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gdltpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipSZXR1cm5zIHRoZSBtaW4gb2YgYSB2ZWN0b3JcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIHZlY3RvciBvZiB7TnVtYmVyfXNcclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIHRoZSBtaW5pbXVtIG51bWJlciBmcm9tIHRoZSB2ZWN0b3Igb3IgTmFOIGlmIHZlY3RvciBpcyBlbXB0eVxyXG4gICAgICpAYXV0aG9yIGFsZXhAc2NyaXB0b2lkLmNvbVxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gbWluKHYpIHtcclxuICAgICAgICBpZiAodi5sZW5naHQgPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBtID0gdlswXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobSA+IHZbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gdltpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yik5patIOeCueaVsOe7hCDmmK/lkKbmraPkuqTnm7Tnur/ot6/lvoRcclxuICAgICAqVGVzdHMgaWYgYSB2ZWN0b3Igb2YgcG9pbnRzIGlzIGFuIG9ydGhvZ29uYWwgcGF0aCAobW92aW5nIGluIG11bHRpcGxlcyBvZiA5MCBkZWdyZWVzKVxyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gYW4ge0FycmF5fSBvZiB7UG9pbnR9c1xyXG4gICAgICpAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgcGF0aCBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBvcnRob2dvbmFsUGF0aCh2KSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh2W2ldLnggIT0gdltpICsgMV0ueCAmJiB2W2ldLnkgIT0gdltpICsgMV0ueSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlRlc3QgdG8gc2VlIGlmIDIge0xpbmV9cyBpbnRlcnNlY3RzLiBUaGV5IGFyZSBjb25zaWRlcmVkIGZpbml0ZSBzZWdtZW50c1xyXG4gICAgICphbmQgbm90IHRoZSBpbmZpbml0ZSBsaW5lcyBmcm9tIGdlb21ldHJ5XHJcbiAgICAgKkBwYXJhbSB7TGluZX0gbDEgLSBmaXN0IGxpbmUvc2VnbWVudFxyXG4gICAgICpAcGFyYW0ge0xpbmV9IGwyIC0gbGFzdCBsaW5lL3NlZ21lbnRcclxuICAgICAqQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSAtIGlmIHRoZSBsaW5lcyBpbnRlcnNlY3Qgb3IgZmFsc2UgaWYgbm90XHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBsaW5lSW50ZXJzZWN0c0xpbmUobDEsIGwyKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIHR3byB2ZXJ0aWNhbCBsaW5lc1xyXG4gICAgICAgIGlmIChsMS5zdGFydFBvaW50LnggPT0gbDEuZW5kUG9pbnQueCAmJiBsMi5zdGFydFBvaW50LnggPT0gbDIuZW5kUG9pbnQueCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbDEuc3RhcnRQb2ludC54ID09IGwyLnN0YXJ0UG9pbnQueCA/IC8vIGlmICdpbmZpbml0ZSAnbGluZXMgZG8gY29pbmNpZGUsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGNoZWNrIHNlZ21lbnQgYm91bmRzIGZvciBvdmVybGFwcGluZ1xyXG4gICAgICAgICAgICAgICAgbDEuY29udGFpbnMobDIuc3RhcnRQb2ludC54LCBsMi5zdGFydFBvaW50LnkpIHx8XHJcbiAgICAgICAgICAgICAgICBsMS5jb250YWlucyhsMi5lbmRQb2ludC54LCBsMi5lbmRQb2ludC55KSA6XHJcbiAgICAgICAgICAgICAgICAvLyBsaW5lcyBhcmUgcGFyYWxlbFxyXG4gICAgICAgICAgICAgICAgZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIG9uZSBsaW5lIGlzIHZlcnRpY2FsLCBhbmQgYW5vdGhlciBsaW5lIGlzIG5vdCB2ZXJ0aWNhbFxyXG4gICAgICAgIGVsc2UgaWYgKGwxLnN0YXJ0UG9pbnQueCA9PSBsMS5lbmRQb2ludC54IHx8IGwyLnN0YXJ0UG9pbnQueCA9PSBsMi5lbmRQb2ludC54KSB7XHJcbiAgICAgICAgICAgIC8vIGxldCBhc3N1bWUgbDIgaXMgdmVydGljYWwsIG90aGVyd2lzZSBleGNoYW5nZSB0aGVtXHJcbiAgICAgICAgICAgIGlmIChsMS5zdGFydFBvaW50LnggPT0gbDEuZW5kUG9pbnQueCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGwgPSBsMTtcclxuICAgICAgICAgICAgICAgIGwxID0gbDI7XHJcbiAgICAgICAgICAgICAgICBsMiA9IGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZmluZGluZyBpbnRlcnNlY3Rpb24gb2YgJ2luZmluaXRlJyBsaW5lc1xyXG4gICAgICAgICAgICAvLyBlcXVhdGlvbiBvZiB0aGUgZmlyc3QgbGluZSBpcyB5ID0gYXggKyBiLCBzZWNvbmQ6IHggPSBjXHJcbiAgICAgICAgICAgIHZhciBhID0gKGwxLmVuZFBvaW50LnkgLSBsMS5zdGFydFBvaW50LnkpIC8gKGwxLmVuZFBvaW50LnggLSBsMS5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgYiA9IGwxLnN0YXJ0UG9pbnQueSAtIGEgKiBsMS5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgIHZhciB4MCA9IGwyLnN0YXJ0UG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIHkwID0gYSAqIHgwICsgYjtcclxuICAgICAgICAgICAgcmV0dXJuIGwxLmNvbnRhaW5zKHgwLCB5MCkgJiYgbDIuY29udGFpbnMoeDAsIHkwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIG5vcm1hbCBjYXNlIC0gYm90aCBsaW5lcyBhcmUgbm90IHZlcnRpY2FsXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vbGluZSBlcXVhdGlvbiBpcyA6IHkgPSBhKnggKyBiLCBiID0geSAtIGEgKiB4XHJcbiAgICAgICAgICAgIHZhciBhMSA9IChsMS5lbmRQb2ludC55IC0gbDEuc3RhcnRQb2ludC55KSAvIChsMS5lbmRQb2ludC54IC0gbDEuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgdmFyIGIxID0gbDEuc3RhcnRQb2ludC55IC0gYTEgKiBsMS5zdGFydFBvaW50Lng7XHJcblxyXG4gICAgICAgICAgICB2YXIgYTIgPSAobDIuZW5kUG9pbnQueSAtIGwyLnN0YXJ0UG9pbnQueSkgLyAobDIuZW5kUG9pbnQueCAtIGwyLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciBiMiA9IGwyLnN0YXJ0UG9pbnQueSAtIGEyICogbDIuc3RhcnRQb2ludC54O1xyXG5cclxuICAgICAgICAgICAgaWYgKGExID09IGEyKSB7IC8vcGFyYWxlbCBsaW5lc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIxID09IGIyID9cclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgY29pbmNpZGUgbGluZXMsIGNoZWNrIGZvciBzZWdtZW50IGJvdW5kcyBvdmVybGFwcGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGwxLmNvbnRhaW5zKGwyLnN0YXJ0UG9pbnQueCwgbDIuc3RhcnRQb2ludC55KSB8fCBsMS5jb250YWlucyhsMi5lbmRQb2ludC54LCBsMi5lbmRQb2ludC55KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGNvaW5jaWRlIHBhcmFsZWwgbGluZXMgaGF2ZSBubyBjaGFuY2UgdG8gaW50ZXJzZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vdXN1YWwgY2FzZSAtIG5vbiBwYXJhbGVsLCB0aGUgJ2luZmluaXRlJyBsaW5lcyBpbnRlcnNlY3RzLi4ud2Ugb25seSBuZWVkIHRvIGtub3cgaWYgaW5zaWRlIHRoZSBzZWdtZW50XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIGlmIG9uZSBvZiB0aGUgbGluZXMgYXJlIHZlcnRpY2FsLCB0aGVuIHgwIGlzIGVxdWFsIHRvIHRoZWlyIHgsXHJcbiAgICAgICAgICAgICAgICAgKiBvdGhlcndpc2U6XHJcbiAgICAgICAgICAgICAgICAgKiB5MSA9IGExICogeCArIGIxXHJcbiAgICAgICAgICAgICAgICAgKiB5MiA9IGEyICogeCArIGIyXHJcbiAgICAgICAgICAgICAgICAgKiA9PiB4MCA9IChiMiAtIGIxKSAvIChhMSAtIGEyKVxyXG4gICAgICAgICAgICAgICAgICogPT4geTAgPSBhMSAqIHgwICsgYjFcclxuICAgICAgICAgICAgICAgICAqKi9cclxuICAgICAgICAgICAgICAgIHgwID0gKGIyIC0gYjEpIC8gKGExIC0gYTIpO1xyXG4gICAgICAgICAgICAgICAgeTAgPSBhMSAqIHgwICsgYjE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbDEuY29udGFpbnMoeDAsIHkwKSAmJiBsMi5jb250YWlucyh4MCwgeTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqVGVzdHMgaWYgYSBhIHBvbHlsaW5lIGRlZmluZWQgYnkgYSBzZXQgb2YgcG9pbnRzIGludGVyc2VjdHMgYSByZWN0YW5nbGVcclxuICAgICAqQHBhcmFtIHtBcnJheX0gcG9pbnRzIC0gYW5kIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqQHBhcmFtIHtBcnJheX0gYm91bmRzIC0gdGhlIGJvdW5kcyBvZiB0aGUgcmVjdGFuZ2xlIGRlZmluZWQgYnkgKHgxLCB5MSwgeDIsIHkyKVxyXG4gICAgICpAcGFyYW0ge0Jvb2xlYW59IGNsb3NlZFBvbHlsaW5lIC0gaW5jYXNlIHBvbHlsaW5lIGlzIGNsb3NlZCBmaWd1cmUgdGhlbiB0cnVlLCBlbHNlIGZhbHNlXHJcbiAgICAgKlxyXG4gICAgICpAcmV0dXJuIHRydWUgLSBpZiBsaW5lIGludGVyc2VjdHMgdGhlIHJlY3RhbmdsZSwgZmFsc2UgLSBpZiBub3RcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIHBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZShwb2ludHMsIGJvdW5kcywgY2xvc2VkUG9seWxpbmUpIHtcclxuXHJcblxyXG4gICAgICAgIC8vZ2V0IHRoZSA0IGxpbmVzL3NlZ21lbnRzIHJlcHJlc2VudGVkIGJ5IHRoZSBib3VuZHNcclxuICAgICAgICB2YXIgbGluZXMgPSBbXTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1sxXSksIG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1sxXSkpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1sxXSksIG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1szXSkpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1szXSksIG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1szXSkpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1szXSksIG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1sxXSkpKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBwb2ludHMubGVuZ3RoIC0gMTsgaysrKSB7XHJcbiAgICAgICAgICAgIC8vY3JlYXRlIGEgbGluZSBvdXQgb2YgZWFjaCAyIGNvbnNlY3V0aXZlIHBvaW50c1xyXG4gICAgICAgICAgICB2YXIgdGVtcExpbmUgPSBuZXcgTGluZShwb2ludHNba10sIHBvaW50c1trICsgMV0pO1xyXG5cclxuICAgICAgICAgICAgLy9zZWUgaWYgdGhhdCBsaW5lIGludGVyc2VjdCBhbnkgb2YgdGhlIGxpbmUgb24gYm91bmRzIGJvcmRlclxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZUludGVyc2VjdHNMaW5lKHRlbXBMaW5lLCBsaW5lc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jaGVjayB0aGUgY2xvc2VkIGZpZ3VyZSAtIHRoYXQgaXMgbGFzdCBwb2ludCBjb25uZWN0ZWQgdG8gdGhlIGZpcnN0XHJcbiAgICAgICAgaWYgKGNsb3NlZFBvbHlsaW5lKSB7XHJcbiAgICAgICAgICAgIC8vY3JlYXRlIGEgbGluZSBvdXQgb2YgZWFjaCAyIGNvbnNlY3V0aXZlIHBvaW50c1xyXG4gICAgICAgICAgICB2YXIgdGVtcExpbmUxID0gbmV3IExpbmUocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSwgcG9pbnRzWzBdKTtcclxuXHJcbiAgICAgICAgICAgIC8vc2VlIGlmIHRoYXQgbGluZSBpbnRlcnNlY3QgYW55IG9mIHRoZSBsaW5lIG9uIGJvdW5kcyBib3JkZXJcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVJbnRlcnNlY3RzTGluZSh0ZW1wTGluZTEsIGxpbmVzW2pdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorqHnrpfot6/lvoTnmoTliIbmlbBcclxuICAgICAqIFNjb3JlIGEgb3J0b2dvbmFsIHBhdGggbWFkZSBvdXQgb2YgUG9pbnRzXHJcbiAgICAgKkl0ZXJhdGVzIG92ZXIgYSBzZXQgb2YgcG9pbnRzIChtaW5pbXVtIDMpXHJcbiAgICAgKkZvciBlYWNoIDMgcG9pbnRzIChpLCBpKzEsIGkrMikgOlxyXG4gICAgICogIC0gaWYgdGhlIDNyZCBvbmUgaXMgYWZ0ZXIgdGhlIDJuZCBvbiB0aGUgc2FtZSBsaW5lIHdlIGFkZCArMVxyXG4gICAgICogIC0gaWYgdGhlIDNyZCBpcyB1cCBvciBkb3duIHJlbGF0ZWQgdG8gdGhlIDJuZCB3ZSBkbyBub3QgZG8gYW55dGhpbmcgKzBcclxuICAgICAqICAtIGlmIHRoZSAzcmQgZ29lcyBiYWNrIHdlIGltZWRpYXRlbGx5IHJldHVybiAtMVxyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gYW4gYXJyYXkgb2Yge1BvaW50fXNcclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIC0xIGlmIHRoZSBwYXRoIGlzIHdyb25nIChnb2VzIGJhY2spIG9yIHNvbWV0aGluZyA+PSAwIGlmIGlzIGZpbmVcclxuICAgICAqICBUaGUgYmlnZ2VyIHRoZSBudW1iZXIgdGhlIHNtb290aCB0aGUgcGF0aCBpc1xyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gc2NvcmVQYXRoKHYpIHtcclxuICAgICAgICBpZiAodi5sZW5ndGggPD0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2NvcmUgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdi5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHZbaSAtIDFdLnggPT0gdltpXS54ICYmIHZbaV0ueCA9PSB2W2kgKyAxXS54KSB7IC8vb24gdGhlIHNhbWUgdmVydGljYWxcclxuICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueSAtIHZbaV0ueSkgPT0gc2lnbnVtKHZbaV0ueSAtIHZbaSAtIDFdLnkpKSB7IC8vc2FtZSBkaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBzY29yZSsrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9nb2luZyBiYWNrIC0gbm8gZ29vZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2W2kgLSAxXS55ID09IHZbaV0ueSAmJiB2W2ldLnkgPT0gdltpICsgMV0ueSkgeyAvL29uIHRoZSBzYW1lIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueCAtIHZbaV0ueCkgPT0gc2lnbnVtKHZbaV0ueCAtIHZbaSAtIDFdLngpKSB7IC8vc2FtZSBkaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBzY29yZSsrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9nb2luZyBiYWNrIC0gbm8gZ29vZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHsgLy9ub3Qgb24gc2FtZSB2ZXJ0aWNhbCBub3IgaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgc2NvcmUtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNjb3JlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6L+U5Zue5pWw5a2X56ym5Y+377yIKyAtKVxyXG4gICAgICogUmV0dXJucyB0aGUgc2lnbiBvZiBhIG51bWJlclxyXG4gICAgICpAcGFyYW0ge051bWJlcn0geCAtIHRoZSBudW1iZXJcclxuICAgICAqQHJldHVybnMge051bWJlcn1cclxuICAgICAqQHNlZSA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaWduX2Z1bmN0aW9uXCI+aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaWduX2Z1bmN0aW9uPC9hPlxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gc2lnbnVtKHgpIHtcclxuICAgICAgICBpZiAoeCA+IDApXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIGVsc2UgaWYgKHggPCAwKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIpOaWrSDngrnmlbDnu4Qg5piv5LiN5piv5pyJ5pWI6Lev5b6E77yI5rKh5pyJ5Zue6Lev77yJXHJcbiAgICAgKlRlc3RzIGlmIGEgdmVjdG9yIG9mIHBvaW50cyBpcyBhIHZhbGlkIHBhdGggKG5vdCBnb2luZyBiYWNrKVxyXG4gICAgICpUaGVyZSBhcmUgYSBmZXcgcHJvYmxlbXMgaGVyZS4gSWYgeW91IGhhdmUgcDEsIHAyLCBwMyBhbmQgcDQgYW5kIHAyID0gcDMgeW91IG5lZWQgdG8gaWdub3JlIHRoYXRcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIGFuIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIHBhdGggaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gZm9yd2FyZFBhdGgodikge1xyXG4gICAgICAgIGlmICh2Lmxlbmd0aCA8PSAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aCAtIDI7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodltpXS54ID09IHZbaSArIDFdLnggJiYgdltpICsgMV0ueCA9PSB2W2kgKyAyXS54KSB7IC8vb24gdGhlIHNhbWUgdmVydGljYWxcclxuICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueSAtIHZbaV0ueSkgIT0gMCkgeyAvL3Rlc3Qgb25seSB3ZSBoYXZlIGEgcHJvZ3Jlc3NpbmcgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueSAtIHZbaV0ueSkgPT0gLTEgKiBzaWdudW0odltpICsgMl0ueSAtIHZbaSArIDFdLnkpKSB7IC8vZ29pbmcgYmFjayAoaWdub3JlIHplcm8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodltpXS55ID09IHZbaSArIDFdLnkgJiYgdltpICsgMV0ueSA9PSB2W2kgKyAyXS55KSB7IC8vb24gdGhlIHNhbWUgaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS54IC0gdltpXS54KSAhPSAwKSB7IC8vdGVzdCBvbmx5IHdlIGhhdmUgYSBwcm9ncmVzc2luZyBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS54IC0gdltpXS54KSA9PSAtMSAqIHNpZ251bSh2W2kgKyAyXS54IC0gdltpICsgMV0ueCkpIHsgLy9nb2luZyBiYWNrIChpZ25vcmUgemVybylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlsIZbeDowLHk6MF3ovazljJbkuLpbMCwgMF0gIOe7mXpyZW5kZXLkvb/nlKhcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcG9pbnRzIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gaXNSZXZlcnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0cmFzbGF0ZVBvaW50cyhwb2ludHMsIGlzUmV2ZXJ0KSB7XHJcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IFtdO1xyXG4gICAgICAgIGlmIChpc1JldmVydCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2gobmV3IFBvaW50KHBvaW50WzBdLCBwb2ludFsxXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdQb2ludHM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2ludDEgPSBwb2ludHNbal07XHJcbiAgICAgICAgICAgICAgICBuZXdQb2ludHMucHVzaChbcG9pbnQxLngsIHBvaW50MS55XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ld1BvaW50cztcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByb3RhdGlvbk1hdHJpeChhbmdsZSkge1xyXG4gICAgICAgIHZhciBtUmV0dXJuID0gW1xyXG4gICAgICAgICAgICBbTWF0aC5jb3MoYW5nbGUpLCAtTWF0aC5zaW4oYW5nbGUpLCAwXSxcclxuICAgICAgICAgICAgW01hdGguc2luKGFuZ2xlKSwgTWF0aC5jb3MoYW5nbGUpLCAwXSxcclxuICAgICAgICAgICAgWzAsIDAsIDFdXHJcbiAgICAgICAgXTtcclxuICAgICAgICByZXR1cm4gbVJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0cmFuc2xhdGlvbk1hdHJpeChkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbMSwgMCwgZHhdLFxyXG4gICAgICAgICAgICBbMCwgMSwgZHldLFxyXG4gICAgICAgICAgICBbMCwgMCwgMV1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNjYWxlTWF0cml4KHN4LCBzeSkge1xyXG4gICAgICAgIGlmIChzeSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN5ID0gc3g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFtzeCwgMCwgMF0sXHJcbiAgICAgICAgICAgIFswLCBzeSwgMF0sXHJcbiAgICAgICAgICAgIFswLCAwLCAxXVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEl0IHdpbGwgcmV0dXJuIHRoZSBlbmQgcG9pbnQgb2YgYSBsaW5lIG9uIGEgZ2l2ZW4gYW5nbGUgKGNsb2Nrd2lzZSkuXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBzdGFydFBvaW50IC0gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gdGhlIGxlbmd0aCBvZiB0aGUgbGluZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIC0gdGhlIGFuZ2xlIG9mIHRoZSBsaW5lIGluIHJhZGlhbnNcclxuICAgICAqIEByZXR1cm4ge1BvaW50fSAtIHRoZSBlbmRQb2ludCBvZiB0aGUgbGluZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRFbmRQb2ludChzdGFydFBvaW50LCBsZW5ndGgsIGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIGVuZFBvaW50ID0gc3RhcnRQb2ludC5jbG9uZSgpO1xyXG4gICAgICAgIGVuZFBvaW50LnRyYW5zZm9ybSh0cmFuc2xhdGlvbk1hdHJpeCgtc3RhcnRQb2ludC54LCAtc3RhcnRQb2ludC55KSk7XHJcbiAgICAgICAgZW5kUG9pbnQueSAtPSBsZW5ndGg7XHJcbiAgICAgICAgZW5kUG9pbnQudHJhbnNmb3JtKHJvdGF0aW9uTWF0cml4KGFuZ2xlKSk7XHJcbiAgICAgICAgZW5kUG9pbnQudHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KHN0YXJ0UG9pbnQueCwgc3RhcnRQb2ludC55KSk7XHJcbiAgICAgICAgcmV0dXJuIGVuZFBvaW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W6I635Y+W5Lik5Liq5Zu+5b2i55qE5aSW6Z2i5Zub5Liq6L+e5o6l54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHJlY3QgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldENvbm5lY3RvclBvaW50cyhyZWN0LCBub2RlKSB7XHJcbiAgICAgICAgbm9kZSA9IG5vZGUgfHwge307XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHpyVXRpbC5jbG9uZShyZWN0LmJvdW5kaW5nUmVjdCB8fCByZWN0KTtcclxuICAgICAgICB2YXIgcm90YXRpb24gPSBub2RlLnJvdGF0aW9uO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSB7XHJcbiAgICAgICAgICAgIGxlZnQ6IG5ldyBQb2ludChib3VuZGluZ1JlY3QueCwgYm91bmRpbmdSZWN0LnkgKyBib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMiksIC8v55+p5b2iIOW3puS4reeahOS9jee9rlxyXG4gICAgICAgICAgICB0b3A6IG5ldyBQb2ludChib3VuZGluZ1JlY3QueCArIGJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC55KSwgLy/nn6nlvaIg5LiK5Lit55qE5L2N572uXHJcbiAgICAgICAgICAgIHJpZ2h0OiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC55ICsgYm91bmRpbmdSZWN0LmhlaWdodCAvIDIpLCAvL+efqeW9oiDlj7PkuK3nmoTkvY3nva5cclxuICAgICAgICAgICAgYm90dG9tOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGggLyAyLCBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQpLCAvL+efqeW9oiDkuIvkuK3nmoTkvY3nva5cclxuICAgICAgICAgICAgY2VudGVyOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGggLyAyLCBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyKSAvL+S4remXtOS9jee9rlxyXG5cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhub2RlKS5sZW5ndGggPiAwICYmIE1hdGguYWJzKHJvdGF0aW9uKSA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHJlY3ROZXcgPSByZWN0LmJvdW5kaW5nUmVjdCA/IHJlY3QgOiBnZXRSZWN0KG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0geyB4OiByZWN0TmV3LngsIHk6IHJlY3ROZXcueSB9OyAvLyDkuK3lv4PngrlcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMocG9pbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcG9pbnRzW2tleV07XHJcbiAgICAgICAgICAgICAgICB2YXIgeDAgPSBjZW50ZXIueCAtIHZhbHVlLng7XHJcbiAgICAgICAgICAgICAgICB2YXIgeTAgPSBjZW50ZXIueSAtIHZhbHVlLnk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oLXJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcygtcm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uX25feCA9IGNlbnRlci54IC0gKHgwICogY29zIC0geTAgKiBzaW4pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uX25feSA9IGNlbnRlci55IC0gKHgwICogc2luICsgeTAgKiBjb3MpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzW2tleV0ueCA9IHBvc2l0aW9uX25feDtcclxuICAgICAgICAgICAgICAgIHBvaW50c1trZXldLnkgPSBwb3NpdGlvbl9uX3k7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W6IqC54K55aSW6Z2i5Zub5Liq5o6n5Yi254K55ZKM5peL6L2s54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0Q29ubmVjdG9yQ29udHJvbHMocmVjdCwgbm9kZSkge1xyXG4gICAgICAgIG5vZGUgPSBub2RlIHx8IHt9O1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB6clV0aWwuY2xvbmUocmVjdC5ib3VuZGluZ1JlY3QpO1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IG5vZGUucm90YXRpb247XHJcbiAgICAgICAgdmFyIGNvbnRyb2xzID0ge1xyXG4gICAgICAgICAgICB0bDogbmV3IFBvaW50KGJvdW5kaW5nUmVjdC54LCBib3VuZGluZ1JlY3QueSksIC8v55+p5b2iIOW3puS4iuinkuS9jee9rlxyXG4gICAgICAgICAgICB0YzogbmV3IFBvaW50KGJvdW5kaW5nUmVjdC54ICsgYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LnkgLSA0KSwgLy/nn6nlvaIg5LiK5Lit5L2N572uXHJcbiAgICAgICAgICAgIHRyOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC55KSwgLy/nn6nlvaIg5Y+z5LiK6KeS5L2N572uXHJcbiAgICAgICAgICAgIGJsOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LngsIGJvdW5kaW5nUmVjdC55ICsgYm91bmRpbmdSZWN0LmhlaWdodCksIC8v55+p5b2iIOW3puS4i+inklxyXG4gICAgICAgICAgICBicjogbmV3IFBvaW50KGJvdW5kaW5nUmVjdC54ICsgYm91bmRpbmdSZWN0LndpZHRoLCBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQpLCAvL+efqeW9oiDlj7PkuIvop5LkvY3nva5cclxuICAgICAgICAgICAgbXRyOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGggLyAyLCBib3VuZGluZ1JlY3QueSAtIDIwKSAvLyDml4vovazngrnkvY3nva5cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhub2RlKS5sZW5ndGggPiAwICYmIE1hdGguYWJzKHJvdGF0aW9uKSA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHJlY3ROZXcgPSByZWN0O1xyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0geyB4OiByZWN0TmV3LngsIHk6IHJlY3ROZXcueSB9OyAvLyDkuK3lv4PngrlcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udHJvbHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjb250cm9sc1trZXldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHgwID0gY2VudGVyLnggLSB2YWx1ZS54O1xyXG4gICAgICAgICAgICAgICAgdmFyIHkwID0gY2VudGVyLnkgLSB2YWx1ZS55O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKC1yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoLXJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbl9uX3ggPSBjZW50ZXIueCAtICh4MCAqIGNvcyAtIHkwICogc2luKTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbl9uX3kgPSBjZW50ZXIueSAtICh4MCAqIHNpbiArIHkwICogY29zKTtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xzW2tleV0ueCA9IHBvc2l0aW9uX25feDtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xzW2tleV0ueSA9IHBvc2l0aW9uX25feTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250cm9scztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruS4reW/g+eCueWSjOaXi+i9rOW8p+W6pu+8jOiuoeeul+aXi+i9rOWQjueahOeCueWdkOagh1xyXG4gICAgICogQHBhcmFtICB7W29iamVjdHxhcnJheV19IHBvaW50cyBb5Y6f5Z2Q5qCHXVxyXG4gICAgICogQHBhcmFtICB7W29iamVjdF19ICAgICAgIGNlbnRlciBb5Lit5b+D54K5XVxyXG4gICAgICogQHBhcmFtICB7W251bWJlcl19ICAgICAgIHJvdGF0aW9uIFvml4vovazlvKfluqZdXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVQb2ludHMocG9pbnRzLCBjZW50ZXIsIHJvdGF0aW9uKSB7XHJcbiAgICAgICAgdmFyIHggPSBBcnJheS5pc0FycmF5KHBvaW50cykgPyBwb2ludHNbMF0gOiBwb2ludHMueDtcclxuICAgICAgICB2YXIgeSA9IEFycmF5LmlzQXJyYXkocG9pbnRzKSA/IHBvaW50c1sxXSA6IHBvaW50cy55O1xyXG4gICAgICAgIHZhciB4MCA9IGNlbnRlci54IC0geDtcclxuICAgICAgICB2YXIgeTAgPSBjZW50ZXIueSAtIHk7XHJcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKC1yb3RhdGlvbik7XHJcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKC1yb3RhdGlvbik7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uX25feCA9IGNlbnRlci54IC0gKHgwICogY29zIC0geTAgKiBzaW4pO1xyXG4gICAgICAgIHZhciBwb3NpdGlvbl9uX3kgPSBjZW50ZXIueSAtICh4MCAqIHNpbiArIHkwICogY29zKTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2ludHMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbcG9zaXRpb25fbl94LCBwb3NpdGlvbl9uX3ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBwb3NpdGlvbl9uX3gsXHJcbiAgICAgICAgICAgIHk6IHBvc2l0aW9uX25feVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluiOt+WPluS4pOS4quWbvuW9oueahOWklumdouWbm+S4qui/nuaOpeeCuVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFNvbHRQb2ludHMobm9kZSkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIC8vdG9wXHJcbiAgICAgICAgICAgIFtNYXRoLnJvdW5kKG5vZGUuZ2V0UmVjdCgpLndpZHRoIC8gMyAvMTApKjEwLCAwIF0sXHJcbiAgICAgICAgICAgIFtNYXRoLnJvdW5kKDIqbm9kZS5nZXRSZWN0KCkud2lkdGggLyAzIC8xMCkqMTAsIDAgXSxcclxuICAgICAgICAgICAgLy9yaWdodFxyXG4gICAgICAgICAgICBbbm9kZS5nZXRSZWN0KCkud2lkdGgsIE1hdGgucm91bmQobm9kZS5nZXRSZWN0KCkuaGVpZ2h0IC8gMyAvMTApKjEwIF0sXHJcbiAgICAgICAgICAgIFtub2RlLmdldFJlY3QoKS53aWR0aCwgTWF0aC5yb3VuZCgyKm5vZGUuZ2V0UmVjdCgpLmhlaWdodCAvIDMgLzEwKSoxMCBdLFxyXG4gICAgICAgICAgICAvL2JvdHRvbVxyXG4gICAgICAgICAgICBbTWF0aC5yb3VuZChub2RlLmdldFJlY3QoKS53aWR0aCAvIDMgLzEwKSoxMCwgbm9kZS5nZXRSZWN0KCkuaGVpZ2h0IF0sXHJcbiAgICAgICAgICAgIFtNYXRoLnJvdW5kKDIqbm9kZS5nZXRSZWN0KCkud2lkdGggLyAzIC8xMCkqMTAsIG5vZGUuZ2V0UmVjdCgpLmhlaWdodCBdLFxyXG4gICAgICAgICAgICAvL2xlZnRcclxuICAgICAgICAgICAgWzAsIE1hdGgucm91bmQobm9kZS5nZXRSZWN0KCkuaGVpZ2h0IC8gMyAvMTApKjEwIF0sXHJcbiAgICAgICAgICAgIFswLCBNYXRoLnJvdW5kKDIqbm9kZS5nZXRSZWN0KCkuaGVpZ2h0IC8gMyAvMTApKjEwIF1cclxuXHJcbiAgICAgICAgXVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6h566XIHAxIHAy5Lik54K55omA6L+e5o6l55qE55u057q/55qE6KeS5bqmXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHAxIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcDIgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRhbmdlbnRSb3RhdGlvbihwMSwgcDIpIHtcclxuICAgICAgICByZXR1cm4gLU1hdGguUEkgLyAyIC0gTWF0aC5hdGFuMihcclxuICAgICAgICAgICAgcDIueSAtIHAxLnksIHAyLnggLSBwMS54XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIpOaWrTPngrnmmK/lkKblnKjkuIDmnaHnm7Tnur/kuIpcclxuICAgICAqIFRlc3RzIGlmIDMgcG9pbnRzIGFyZSBjb2xpbmlhciB3aXRoIG1hdHJpeCBkZXRlcm1pbmFudHMuXHJcbiAgICAgKiBJZiB0aGUgZGV0ZXJtaW5hdCBvZiBtYXRyaXhcclxuICAgICAqIC8gICAgICAgICBcXFxyXG4gICAgICogfCB4MSB5MSAxIHxcclxuICAgICAqIHwgeDIgeTIgMSB8XHJcbiAgICAgKiB8IHgzIHkzIDEgfFxyXG4gICAgICogXFwgICAgICAgICAvXHJcbiAgICAgKiBpcyB6ZXJvIGl0IG1lYW5zIHRoYXQgdGhlIHBvaW50cyBhcmUgY29saW5lYXJcclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDEgLSBmaXJzdCBwb2ludFxyXG4gICAgICpAcGFyYW0ge1BvaW50fSBwMiAtIHNlY29uZCBwb2ludFxyXG4gICAgICpAcGFyYW0ge1BvaW50fSBwMyAtIHRoaXJkIHBvaW50XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzc2lvblxyXG4gICAgICpAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgY29saW5pYXIgYW5kIGZhbHNlIGlmIG5vdFxyXG4gICAgICpAYXV0aG9yIEFsZXhcclxuICAgICAqQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RldGVybWluYW50XHJcbiAgICAgKkBzZWUgaHR0cHM6Ly9wZW9wbGUucmljaGxhbmQuZWR1L2phbWVzL2xlY3R1cmUvbTExNi9tYXRyaWNlcy9hcHBsaWNhdGlvbnMuaHRtbFxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gY29sbGluZWFyaXR5KHAxLCBwMiwgcDMsIHByZWNpc3Npb24pIHtcclxuICAgICAgICB2YXIgZGV0ZXJtaW5hbnQgPSAocDEueCAqIHAyLnkgKyBwMS55ICogcDMueCArIHAyLnggKiBwMy55KSAtIChwMi55ICogcDMueCArIHAxLnkgKiBwMi54ICsgcDEueCAqIHAzLnkpO1xyXG5cclxuICAgICAgICBpZiAocHJlY2lzc2lvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoZGV0ZXJtaW5hbnQpIDw9IHByZWNpc3Npb247XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRldGVybWluYW50ID09PSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlm5voiI3kupTlhaUg5L+d5a2YZGVjaW1hbHPnmoTlsI/mlbBcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGVuaGFuY2VkUm91bmQobnVtYmVyLCBkZWNpbWFscykge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIE1hdGgucG93KDEwLCBkZWNpbWFscykpIC8gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluS4pOeCueS5i+mXtOeahOmVv+W6plxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gZ2V0TGVuZ3RoKHN0YXJ0UG9pbnQsIGVuZFBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhzdGFydFBvaW50LnggLSBlbmRQb2ludC54LCAyKSArIE1hdGgucG93KHN0YXJ0UG9pbnQueSAtIGVuZFBvaW50LnksIDIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluinkuW6plxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBjZW50ZXJQb2ludCAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBvdXRzaWRlUG9pbnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSByb3VuZCAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRBbmdsZShjZW50ZXJQb2ludCwgb3V0c2lkZVBvaW50LCByb3VuZCkge1xyXG4gICAgICAgIGNlbnRlclBvaW50LnggPSBlbmhhbmNlZFJvdW5kKGNlbnRlclBvaW50LngsIDUpO1xyXG4gICAgICAgIGNlbnRlclBvaW50LnkgPSBlbmhhbmNlZFJvdW5kKGNlbnRlclBvaW50LnksIDUpO1xyXG4gICAgICAgIG91dHNpZGVQb2ludC54ID0gZW5oYW5jZWRSb3VuZChvdXRzaWRlUG9pbnQueCwgNSk7XHJcbiAgICAgICAgb3V0c2lkZVBvaW50LnkgPSBlbmhhbmNlZFJvdW5kKG91dHNpZGVQb2ludC55LCA1KTtcclxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4oKG91dHNpZGVQb2ludC54IC0gY2VudGVyUG9pbnQueCkgLyAob3V0c2lkZVBvaW50LnkgLSBjZW50ZXJQb2ludC55KSk7XHJcbiAgICAgICAgYW5nbGUgPSAtYW5nbGU7XHJcblxyXG4gICAgICAgIC8vZW5kQW5nbGUrPTkwO1xyXG4gICAgICAgIGlmIChvdXRzaWRlUG9pbnQueCA+PSBjZW50ZXJQb2ludC54ICYmIG91dHNpZGVQb2ludC55ID49IGNlbnRlclBvaW50LnkpIHtcclxuICAgICAgICAgICAgYW5nbGUgKz0gTWF0aC5QSTtcclxuICAgICAgICB9IGVsc2UgaWYgKG91dHNpZGVQb2ludC54IDw9IGNlbnRlclBvaW50LnggJiYgb3V0c2lkZVBvaW50LnkgPj0gY2VudGVyUG9pbnQueSkge1xyXG4gICAgICAgICAgICBhbmdsZSArPSBNYXRoLlBJO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3V0c2lkZVBvaW50LnggPD0gY2VudGVyUG9pbnQueCAmJiBvdXRzaWRlUG9pbnQueSA8PSBjZW50ZXJQb2ludC55KSB7XHJcbiAgICAgICAgICAgIGFuZ2xlICs9IE1hdGguUEkgKiAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoYW5nbGUgPj0gTWF0aC5QSSAqIDIpIHtcclxuICAgICAgICAgICAgYW5nbGUgLT0gTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc05hTihhbmdsZSkpIHsgLy9OYW5cclxuICAgICAgICAgICAgYW5nbGUgPSAwOyAvL3dlIGFyZSBhdCBjZW50ZXIgcG9pbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb3VuZCkge1xyXG4gICAgICAgICAgICBhbmdsZSA9IE1hdGgucm91bmQoYW5nbGUgLyByb3VuZCkgKiByb3VuZFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYW5nbGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bniLboioLngrnnmoRwb3NpdGlvblswXVxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBub2RlICBb6IqC54K5XVxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwYXJlbnRLZXkgW+WIpOaWreaYr+WQpuacieaMh+WumueItuiKgueCueeahGtleSzlr7nkuo5ncm91cOaYr3R5cGXvvJvlr7nkuo5zdWJwcm9jZXNz5pivbm9kZVR5cGVdXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBhcmVudFZhbHVlICBb5Yik5pat5piv5ZCm5pyJ5oyH5a6a54i26IqC54K555qEdmFsdWUs5a+55LqOZ3JvdXDmmK9Hcm91cE5vZGXvvJvlr7nkuo5zdWJwcm9jZXNz5pivU3ViUHJvY2Vzc11cclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgIOeItuiKgueCueeahHBvc2l0aW9uWzBdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFBhcmVudFgobm9kZSwgcGFyZW50S2V5LCBwYXJlbnRWYWx1ZSkge1xyXG4gICAgICAgIGlmICghcGFyZW50S2V5KSB7XHJcbiAgICAgICAgICAgIHBhcmVudEtleSA9ICd0eXBlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwYXJlbnRWYWx1ZSkge1xyXG4gICAgICAgICAgICBwYXJlbnRWYWx1ZSA9ICdHcm91cE5vZGUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnRbcGFyZW50S2V5XSA9PT0gcGFyZW50VmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zaXRpb25bMF0gKyBnZXRQYXJlbnRYKG5vZGUucGFyZW50KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzBdXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W54i26IqC54K555qEcG9zaXRpb25bMV1cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gbm9kZSAgW+iKgueCuV1cclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gcGFyZW50S2V5IFvliKTmlq3mmK/lkKbmnInmjIflrprniLboioLngrnnmoRrZXks5a+55LqOZ3JvdXDmmK90eXBl77yb5a+55LqOc3VicHJvY2Vzc+aYr25vZGVUeXBlXVxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwYXJlbnRWYWx1ZSAgW+WIpOaWreaYr+WQpuacieaMh+WumueItuiKgueCueeahHZhbHVlLOWvueS6jmdyb3Vw5pivR3JvdXBOb2Rl77yb5a+55LqOc3VicHJvY2Vzc+aYr1N1YlByb2Nlc3NdXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICAgICDniLboioLngrnnmoRwb3NpdGlvblsxXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRQYXJlbnRZKG5vZGUsIHBhcmVudEtleSwgcGFyZW50VmFsdWUpIHtcclxuICAgICAgICBpZiAoIXBhcmVudEtleSkge1xyXG4gICAgICAgICAgICBwYXJlbnRLZXkgPSAndHlwZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcGFyZW50VmFsdWUpIHtcclxuICAgICAgICAgICAgcGFyZW50VmFsdWUgPSAnR3JvdXBOb2RlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50W3BhcmVudEtleV0gPT09IHBhcmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzFdICsgZ2V0UGFyZW50WShub2RlLnBhcmVudClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblsxXVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRSZWN0KG5vZGUsIGlzQ2FsY1BhcmVudCkge1xyXG4gICAgICAgIHZhciBjbGlwUGF0aCA9IG5vZGUuY2xpcFBhdGg7XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgLy8g6IqC54K56KOB5Ymq5ZCO77yM5Lul6KOB5Ymq6IqC54K55YyF5Zu055uS5Li65YeGXHJcbiAgICAgICAgaWYgKGNsaXBQYXRoKSB7XHJcbiAgICAgICAgICAgIGJvdW5kaW5nUmVjdCA9IGNsaXBQYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+WIm+W7uuacgOWwj+WMheWbtOebkuiZmue6v1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICBwb2ludHNbMF0gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgcG9pbnRzWzFdID0gW2JvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgcG9pbnRzWzJdID0gW2JvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbM10gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbNF0gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcblxyXG4gICAgICAgIHZhciBwb3NpdGlvblggPSBub2RlLnBvc2l0aW9uWzBdO1xyXG4gICAgICAgIHZhciBwb3NpdGlvblkgPSBub2RlLnBvc2l0aW9uWzFdO1xyXG4gICAgICAgIC8v6L+Z6YeM6KaB5b6q546v5Yik5pat5LiA5oqKIOacieayoeacieeItuiKgueCuSDlubbkuJTniLboioLngrnkuI3mmK/moLnoioLngrkg54S25ZCO6L+b6KGM55u45YqgXHJcbiAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIGlzQ2FsY1BhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gJ0dyb3VwTm9kZScgfHwgbm9kZS5wYXJlbnQubm9kZVR5cGUgPT09ICdTdWJQcm9jZXNzJykge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25YICs9IGdldFBhcmVudFgobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25ZICs9IGdldFBhcmVudFkobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYm91bmRSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChcclxuICAgICAgICAgICAgICAgIE51bWJlcihwb3NpdGlvblggKyBib3VuZGluZ1JlY3QueCksICAgLy/ms6g6IOWboOS6i+S7tuS4uuWchuW9oiAg5omA5LulIHggeSDkuLrlnIblv4PnmoTkvY3nva4gIOWMheWbtOefqeW9ouimgeWHj+WOu+WuveW6puS4gOWNilxyXG4gICAgICAgICAgICAgICAgTnVtYmVyKHBvc2l0aW9uWSArIGJvdW5kaW5nUmVjdC55KSxcclxuICAgICAgICAgICAgICAgIE51bWJlcihib3VuZGluZ1JlY3Qud2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyKGJvdW5kaW5nUmVjdC5oZWlnaHQpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgLy/kuK3lv4PngrlcclxuICAgICAgICB2YXIgY3ggPSBOdW1iZXIocG9zaXRpb25YKSArIE51bWJlcihib3VuZGluZ1JlY3Qud2lkdGgpIC8gMiArIE51bWJlcihib3VuZGluZ1JlY3QueCk7XHJcbiAgICAgICAgdmFyIGN5ID0gTnVtYmVyKHBvc2l0aW9uWSkgKyBOdW1iZXIoYm91bmRpbmdSZWN0LmhlaWdodCkgLyAyICsgTnVtYmVyKGJvdW5kaW5nUmVjdC55KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBOdW1iZXIoY3gpLFxyXG4gICAgICAgICAgICB5OiBOdW1iZXIoY3kpLFxyXG4gICAgICAgICAgICB3aWR0aDogTnVtYmVyKGJvdW5kaW5nUmVjdC53aWR0aCksXHJcbiAgICAgICAgICAgIGhlaWdodDogTnVtYmVyKGJvdW5kaW5nUmVjdC5oZWlnaHQpLFxyXG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICAgICAgYm91bmRpbmdSZWN0OiBib3VuZFJlY3RcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBTdGFja2VkTWFwID0ge1xyXG4gICAgICAgIGNyZWF0ZU5ldzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFjayA9IFtdO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJLZXkgPSB0aGlzLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFycktleS5wdXNoKHZhbHVlKVxyXG5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyDojrflj5botbflp4vngrnmnIlvZmZzZXTpl7TpmpTnmoRhcnJLZXlcclxuICAgICAgICAgICAgICAgIGdldHNpbWlsYXI6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlBcnIgPSBrZXkuc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1LZXlBcnIgPSBpdGVtLmtleS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbUtleUFyclswXS5pbmRleE9mKGtleUFyclswXSkgPiAtMSAmJiBpdGVtS2V5QXJyWzFdLmluZGV4T2Yoa2V5QXJyWzFdKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNvbmNhdChpdGVtLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTsgIFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gc3RhY2tbaV0ua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tbaV0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy/lpoLmnpzmsqHmnInmib7liLDnmoTor53vvIzliJnliJvlu7rkuIDkuKrmlrDnmoTmlbDnu4RcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAga2V5czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChzdGFja1tpXS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0b3A6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gc3RhY2tbaV0ua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNwbGljZShpZHgsIDEpWzBdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uKGtleSwgaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJLZXkgPSB0aGlzLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHpyVXRpbC5pbmRleE9mKGFycktleSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyS2V5LnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZVRvcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSAxLCAxKVswXTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFjay5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnNwbGljZSgwLCBzdGFjay5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcmFuZG9tQ29sb3IoKSB7XHJcbiAgICAgICAgdmFyIGFyckhleCA9IFtcIjBcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIl0sXHJcbiAgICAgICAgICAgIHN0ckhleCA9IFwiI1wiLFxyXG4gICAgICAgICAgICBpbmRleDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xyXG4gICAgICAgICAgICBpbmRleCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDE1KTtcclxuICAgICAgICAgICAgc3RySGV4ICs9IGFyckhleFtpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHJIZXg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbGxpbmVhclJlZHVjdGlvbiAodikge1xyXG4gICAgICAgIHZhciByID0gW107XHJcblxyXG4gICAgICAgIGlmKHYubGVuZ3RoIDwgMyl7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5jbG9uZUFycmF5KHYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgci5wdXNoKCB2WzBdLmNsb25lKCkgKTtcclxuICAgICAgICBmb3IodmFyIGk9MTsgaSA8IHYubGVuZ3RoLTE7IGkrKyl7XHJcbiAgICAgICAgICAgIGlmKCAodltpLTFdLnggPT0gdltpXS54ICYmIHZbaV0ueCA9PSB2W2krMV0ueCkgIHx8ICAodltpLTFdLnkgPT0gdltpXS55ICYmIHZbaV0ueSA9PSB2W2krMV0ueSkgKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgci5wdXNoKCB2W2ldLmNsb25lKCkgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByLnB1c2goIHZbdi5sZW5ndGgtMV0uY2xvbmUoKSApO1xyXG5cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcclxuICAgIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cclxuICAgIHZhciB0ZW1wbGF0ZVNldHRpbmdzID0ge1xyXG4gICAgICAgIGV2YWx1YXRlOiAvPCUoW1xcc1xcU10rPyklPi9nLFxyXG4gICAgICAgIGludGVycG9sYXRlOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcclxuICAgICAgICBlc2NhcGU6IC88JS0oW1xcc1xcU10rPyklPi9nXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cclxuICAgIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcclxuICAgIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxyXG4gICAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XHJcblxyXG4gICAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcclxuICAgIC8vIHN0cmluZyBsaXRlcmFsLlxyXG4gICAgdmFyIGVzY2FwZXMgPSB7XHJcbiAgICAgICAgXCInXCI6IFwiJ1wiLFxyXG4gICAgICAgICdcXFxcJzogJ1xcXFwnLFxyXG4gICAgICAgICdcXHInOiAncicsXHJcbiAgICAgICAgJ1xcbic6ICduJyxcclxuICAgICAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXHJcbiAgICAgICAgJ1xcdTIwMjknOiAndTIwMjknXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xyXG5cclxuICAgIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXHJcbiAgICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXHJcbiAgICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cclxuICAgIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cclxuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xyXG4gICAgICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XHJcbiAgICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcclxuICAgICAgICBzZXR0aW5ncyA9IHpyVXRpbC5kZWZhdWx0cyhzZXR0aW5ncywgdGVtcGxhdGVTZXR0aW5ncywgdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxyXG4gICAgICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcclxuICAgICAgICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXHJcbiAgICAgICAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXHJcbiAgICAgICAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcclxuICAgICAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XHJcblxyXG4gICAgICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcclxuICAgICAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVyLCBlc2NhcGVDaGFyKTtcclxuICAgICAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBpZiAoZXNjYXBlKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcclxuXHJcbiAgICAgICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cclxuICAgICAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xyXG5cclxuICAgICAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXHJcbiAgICAgICAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXHJcbiAgICAgICAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsIHNvdXJjZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cclxuICAgICAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcclxuICAgICAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XHJcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXlMaWtlKG9iaikgJiYgKHpyVXRpbC5pc0FycmF5KG9iaikgfHwgenJVdGlsLmlzU3RyaW5nKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lcmdlT3B0KHRhcmdldCwgc291cmNlLCBvdmVyd3JpdGUsIGV4Y2x1ZGUpIHtcclxuICAgICAgICAvLyBXZSBzaG91bGQgZXNjYXBzZSB0aGF0IHNvdXJjZSBpcyBzdHJpbmdcclxuICAgICAgICAvLyBhbmQgZW50ZXIgZm9yIC4uLiBpbiAuLi5cclxuICAgICAgICBpZiAoIXpyVXRpbC5pc09iamVjdChzb3VyY2UpIHx8ICF6clV0aWwuaXNPYmplY3QodGFyZ2V0KSkge1xyXG4gICAgICAgICAgcmV0dXJuIG92ZXJ3cml0ZSA/IHpyVXRpbC5jbG9uZShzb3VyY2UpIDogdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xyXG4gICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRQcm9wID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XHJcblxyXG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KHNvdXJjZVByb3ApICYmIHpyVXRpbC5pc09iamVjdCh0YXJnZXRQcm9wKSAmJiAhenJVdGlsLmlzQXJyYXkoc291cmNlUHJvcCkgJiYgIXpyVXRpbC5pc0FycmF5KHRhcmdldFByb3ApICYmICF6clV0aWwuaXNEb20oc291cmNlUHJvcCkgJiYgIXpyVXRpbC5pc0RvbSh0YXJnZXRQcm9wKSAmJiAhenJVdGlsLmlzQnVpbHRJbk9iamVjdChzb3VyY2VQcm9wKSAmJiAhenJVdGlsLmlzQnVpbHRJbk9iamVjdCh0YXJnZXRQcm9wKSAmJiAhenJVdGlsLmlzUHJpbWl0aXZlKHNvdXJjZVByb3ApICYmICF6clV0aWwuaXNQcmltaXRpdmUodGFyZ2V0UHJvcCkpIHtcclxuICAgICAgICAgICAgICAvLyDlpoLmnpzpnIDopoHpgJLlvZLopobnm5bvvIzlsLHpgJLlvZLosIPnlKhtZXJnZVxyXG4gICAgICAgICAgICAgIG1lcmdlT3B0KHRhcmdldFByb3AsIHNvdXJjZVByb3AsIG92ZXJ3cml0ZSwgZXhjbHVkZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3ZlcndyaXRlIHx8ICEoa2V5IGluIHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAvLyDlkKbliJnlj6rlpITnkIZvdmVyd3JpdGXkuLp0cnVl77yM5oiW6ICF5Zyo55uu5qCH5a+56LGh5Lit5rKh5pyJ5q2k5bGe5oCn55qE5oOF5Ya1XHJcbiAgICAgICAgICAgICAgLy8gTk9URe+8jOWcqCB0YXJnZXRba2V5XSDkuI3lrZjlnKjnmoTml7blgJnkuZ/mmK/nm7TmjqXopobnm5ZcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IGV4Y2x1ZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHpyVXRpbC5jbG9uZShzb3VyY2Vba2V5XSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIENsYXNzKCkge31cclxuICAgIENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uKHByb3RvKSB7XHJcbiAgICAgICAgdmFyIGJhc2UgPSBmdW5jdGlvbigpIHt9LFxyXG4gICAgICAgICAgICBtZW1iZXIsXHJcbiAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgICAgICBzdWJjbGFzcyA9IHByb3RvICYmIHByb3RvLmluaXQgPyBwcm90by5pbml0IDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmbjtcclxuXHJcbiAgICAgICAgYmFzZS5wcm90b3R5cGUgPSB0aGF0LnByb3RvdHlwZTtcclxuICAgICAgICBmbiA9IHN1YmNsYXNzLmZuID0gc3ViY2xhc3MucHJvdG90eXBlID0gbmV3IGJhc2UoKTtcclxuXHJcbiAgICAgICAgZm9yIChtZW1iZXIgaW4gcHJvdG8pIHtcclxuICAgICAgICAgICAgaWYgKHByb3RvW21lbWJlcl0gIT0gbnVsbCAmJiBwcm90b1ttZW1iZXJdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1lcmdlIG9iamVjdCBtZW1iZXJzXHJcbiAgICAgICAgICAgICAgICBmblttZW1iZXJdID0genJVdGlsLm1lcmdlQWxsKFt7fSwgYmFzZS5wcm90b3R5cGVbbWVtYmVyXSwgcHJvdG9bbWVtYmVyXV0sdHJ1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmblttZW1iZXJdID0gcHJvdG9bbWVtYmVyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm4uY29uc3RydWN0b3IgPSBzdWJjbGFzcztcclxuICAgICAgICBzdWJjbGFzcy5leHRlbmQgPSB0aGF0LmV4dGVuZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN1YmNsYXNzO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBpbmhlcml0czogaW5oZXJpdHMsXHJcbiAgICAgICAgZ2V0VVVJRDogZ2V0VVVJRCxcclxuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXHJcbiAgICAgICAgZ2V0UG9seWxpbmVMZW5ndGg6IGdldFBvbHlsaW5lTGVuZ3RoLFxyXG4gICAgICAgIG1heDogbWF4LFxyXG4gICAgICAgIG1pbjogbWluLFxyXG4gICAgICAgIGlzRW1wdHk6IGlzRW1wdHksXHJcbiAgICAgICAgbWVyZ2VPcHQ6IG1lcmdlT3B0LFxyXG4gICAgICAgIG9ydGhvZ29uYWxQYXRoOiBvcnRob2dvbmFsUGF0aCxcclxuICAgICAgICBwb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGU6IHBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZSxcclxuICAgICAgICBzY29yZVBhdGg6IHNjb3JlUGF0aCxcclxuICAgICAgICBmb3J3YXJkUGF0aDogZm9yd2FyZFBhdGgsXHJcbiAgICAgICAgdHJhc2xhdGVQb2ludHM6IHRyYXNsYXRlUG9pbnRzLFxyXG4gICAgICAgIGdldEVuZFBvaW50OiBnZXRFbmRQb2ludCxcclxuICAgICAgICBnZXRDb25uZWN0b3JQb2ludHM6IGdldENvbm5lY3RvclBvaW50cyxcclxuICAgICAgICBnZXRDb25uZWN0b3JDb250cm9sczogZ2V0Q29ubmVjdG9yQ29udHJvbHMsXHJcbiAgICAgICAgY2FsY3VsYXRlUG9pbnRzOiBjYWxjdWxhdGVQb2ludHMsXHJcbiAgICAgICAgdGFuZ2VudFJvdGF0aW9uOiB0YW5nZW50Um90YXRpb24sXHJcbiAgICAgICAgY29sbGluZWFyaXR5OiBjb2xsaW5lYXJpdHksXHJcbiAgICAgICAgdHJhbnNsYXRpb25NYXRyaXg6IHRyYW5zbGF0aW9uTWF0cml4LFxyXG4gICAgICAgIHNjYWxlTWF0cml4OiBzY2FsZU1hdHJpeCxcclxuICAgICAgICByb3VuZDogZW5oYW5jZWRSb3VuZCxcclxuICAgICAgICBnZXRMZW5ndGg6IGdldExlbmd0aCxcclxuICAgICAgICBnZXRBbmdsZTogZ2V0QW5nbGUsXHJcbiAgICAgICAgZ2V0UGFyZW50WDogZ2V0UGFyZW50WCxcclxuICAgICAgICBnZXRQYXJlbnRZOiBnZXRQYXJlbnRZLFxyXG4gICAgICAgIGdldFJlY3Q6IGdldFJlY3QsXHJcbiAgICAgICAgU3RhY2tlZE1hcDogU3RhY2tlZE1hcCxcclxuICAgICAgICBnZXRNYXhMaW5lTGVuZ3RoOiBnZXRNYXhMaW5lTGVuZ3RoLFxyXG4gICAgICAgIHJhbmRvbUNvbG9yOiByYW5kb21Db2xvcixcclxuICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICAgICAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxyXG4gICAgICAgIGdldFNvbHRQb2ludHM6Z2V0U29sdFBvaW50cyxcclxuICAgICAgICBjb2xsaW5lYXJSZWR1Y3Rpb246IGNvbGxpbmVhclJlZHVjdGlvbixcclxuICAgICAgICBDbGFzczpDbGFzc1xyXG4gICAgfTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHJcbiAgICAvKipcclxuICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFBvaW50XHJcbiAgICAgICpcclxuICAgICAgKlxyXG4gICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAqIEB0aGlzIHtQb2ludH1cclxuICAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIG9mIHBvaW50LlxyXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgb2YgcG9pbnQuXHJcbiAgICAgICogTm90ZTogRXZlbiBpZiBpdCBpcyBuYW1lZCBQb2ludCB0aGlzIGNsYXNzIHNob3VsZCBiZSBuYW1lZCBEb3QgYXMgRG90IGlzIGNsb3NlclxyXG4gICAgICAqIHRoZW4gUG9pbnQgZnJvbSBtYXRoIHBlcnNwZWN0aXZlLlxyXG4gICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIFBvaW50KHgsIHkpe1xyXG4gICAgICAgIC8qKlRoZSB4IGNvb3JkaW5hdGUgb2YgcG9pbnQqL1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgICAgIC8qKlRoZSB5IGNvb3JkaW5hdGUgb2YgcG9pbnQqL1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipDcmVhdGVzIGEge1BvaW50fSBvdXQgb2YgSlNPTiBwYXJzZWQgb2JqZWN0XHJcbiAgICAgKkBwYXJhbSB7SlNPTk9iamVjdH0gbyAtIHRoZSBKU09OIHBhcnNlZCBvYmplY3RcclxuICAgICAqQHJldHVybiB7UG9pbnR9IGEgbmV3bHkgY29uc3RydWN0ZWQgUG9pbnRcclxuICAgICAqKi9cclxuICAgIFBvaW50LmxvYWQgPSBmdW5jdGlvbihvKXtcclxuICAgICAgICB2YXIgbmV3UG9pbnQgPSBuZXcgUG9pbnQoTnVtYmVyKG8ueCksIE51bWJlcihvLnkpKTtcclxuICAgICAgICByZXR1cm4gbmV3UG9pbnQ7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipDcmVhdGVzIGFuIGFycmF5IG9mIHBvaW50cyBmcm9tIGFuIGFycmF5IG9mIHtKU09OT2JqZWN0fXNcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIHRoZSBhcnJheSBvZiBKU09OT2JqZWN0c1xyXG4gICAgICpAcmV0dXJuIGFuIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqKi9cclxuICAgIFBvaW50LmxvYWRBcnJheSA9IGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIHZhciBuZXdQb2ludHMgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTwgdi5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKFBvaW50LmxvYWQodltpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3UG9pbnRzO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqQ2xvbmVzIGFuIGFycmF5IG9mIHBvaW50c1xyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gdGhlIGFycmF5IG9mIHtQb2ludH1zXHJcbiAgICAgKkByZXR1cm4gYW4ge0FycmF5fSBvZiB7UG9pbnR9c1xyXG4gICAgICoqL1xyXG4gICAgUG9pbnQuY2xvbmVBcnJheSA9IGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIHZhciBuZXdQb2ludHMgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTwgdi5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKHZbaV0uY2xvbmUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdQb2ludHM7XHJcbiAgICB9O1xyXG5cclxuICAgIFBvaW50LnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvciA6IFBvaW50LFxyXG5cclxuICAgICAgICB0cmFuc2Zvcm06ZnVuY3Rpb24obWF0cml4KXtcclxuICAgICAgICAgICAgdmFyIG9sZFggPSB0aGlzLng7XHJcbiAgICAgICAgICAgIHZhciBvbGRZID0gdGhpcy55O1xyXG4gICAgICAgICAgICB0aGlzLnggPSBtYXRyaXhbMF1bMF0gKiBvbGRYICsgbWF0cml4WzBdWzFdICogb2xkWSArIG1hdHJpeFswXVsyXTtcclxuICAgICAgICAgICAgdGhpcy55ID0gbWF0cml4WzFdWzBdICogb2xkWCArIG1hdHJpeFsxXVsxXSAqIG9sZFkgKyBtYXRyaXhbMV1bMl07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqVGVzdHMgaWYgdGhpcyBwb2ludCBpcyBzaW1pbGFyIHRvIG90aGVyIHBvaW50XHJcbiAgICAgICAgICpAcGFyYW0ge1BvaW50fSBhbm90aGVyUG9pbnQgLSB0aGUgb3RoZXIgcG9pbnRcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZXF1YWxzOmZ1bmN0aW9uKGFub3RoZXJQb2ludCl7XHJcbiAgICAgICAgICAgIGlmKCEgKGFub3RoZXJQb2ludCBpbnN0YW5jZW9mIFBvaW50KSApe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy54ID09IGFub3RoZXJQb2ludC54KVxyXG4gICAgICAgICAgICAmJiAodGhpcy55ID09IGFub3RoZXJQb2ludC55KVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKkNsb25lIGN1cnJlbnQgUG9pbnRcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHZhciBuZXdQb2ludCA9IG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdQb2ludDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhZGQ6IGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMueCArIHBvaW50Lng7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSArIHBvaW50Lnk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlRlc3RzIHRvIHNlZSBpZiBhIHBvaW50ICh4LCB5KSBpcyB3aXRoaW4gYSByYW5nZSBvZiBjdXJyZW50IFBvaW50XHJcbiAgICAgICAgICpAcGFyYW0ge051bWVyaWN9IHggLSB0aGUgeCBjb29yZGluYXRlIG9mIHRlc3RlZCBwb2ludFxyXG4gICAgICAgICAqQHBhcmFtIHtOdW1lcmljfSB5IC0gdGhlIHggY29vcmRpbmF0ZSBvZiB0ZXN0ZWQgcG9pbnRcclxuICAgICAgICAgKkBwYXJhbSB7TnVtZXJpY30gcmFkaXVzIC0gdGhlIHJhZGl1cyBvZiB0aGUgdmljaW5pdHlcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgbmVhcjpmdW5jdGlvbih4LCB5LCByYWRpdXMpe1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy54IC0geCwgMikgKyBNYXRoLnBvdyh0aGlzLnkgLSB5LCAyKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKGRpc3RhbmNlIDw9IHJhZGl1cyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uKHgseSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggPT0geCAmJiB0aGlzLnkgPT0geTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0b1N0cmluZzpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gJ1snICsgdGhpcy54ICsgJywnICsgdGhpcy55ICsgJ10nO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldFBvaW50czpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gW3RoaXNdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBMaW5lLiBBIExpbmUgaXMgYWN0dWFsbHkgYSBzZWdtZW50IGFuZCBub3QgYSBwdXJlXHJcbiAgICAgICogZ2VvbWV0cmljYWwgTGluZVxyXG4gICAgICAqXHJcbiAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICogQHRoaXMge0xpbmV9XHJcbiAgICAgICogQHBhcmFtIHtQb2ludH0gc3RhcnRQb2ludCAtIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBsaW5lXHJcbiAgICAgICogQHBhcmFtIHtQb2ludH0gZW5kUG9pbnQgLSB0aGUgZW5kaW5nIHBvaW50IG9mIHRoZSBsaW5lXHJcbiAgICAgICoqL1xyXG4gICAgZnVuY3Rpb24gTGluZShzdGFydFBvaW50LCBlbmRQb2ludCl7XHJcbiAgICAgICAgLyoqU3RhcnRpbmcge0BsaW5rIFBvaW50fSBvZiB0aGUgbGluZSovXHJcbiAgICAgICAgdGhpcy5zdGFydFBvaW50ID0gc3RhcnRQb2ludDtcclxuXHJcbiAgICAgICAgLyoqRW5kaW5nIHtAbGluayBQb2ludH0gb2YgdGhlIGxpbmUqL1xyXG4gICAgICAgIHRoaXMuZW5kUG9pbnQgPSBlbmRQb2ludDtcclxuXHJcbiAgICAgICAgLyoqU2VyaWFsaXphdGlvbiB0eXBlKi9cclxuICAgICAgICB0aGlzLm9UeXBlID0gJ0xpbmUnOyAvL29iamVjdCB0eXBlIHVzZWQgZm9yIEpTT04gZGVzZXJpYWxpemF0aW9uXHJcbiAgICB9XHJcblxyXG4gICAgLyoqQ3JlYXRlcyBhIHtMaW5lfSBvdXQgb2YgSlNPTiBwYXJzZWQgb2JqZWN0XHJcbiAgICAgKkBwYXJhbSB7SlNPTk9iamVjdH0gbyAtIHRoZSBKU09OIHBhcnNlZCBvYmplY3RcclxuICAgICAqQHJldHVybiB7TGluZX0gYSBuZXdseSBjb25zdHJ1Y3RlZCBMaW5lXHJcbiAgICAgKiovXHJcbiAgICBMaW5lLmxvYWQgPSBmdW5jdGlvbihvKXtcclxuICAgICAgICB2YXIgbmV3TGluZSA9IG5ldyBMaW5lKFxyXG4gICAgICAgICAgICBQb2ludC5sb2FkKG8uc3RhcnRQb2ludCksXHJcbiAgICAgICAgICAgIFBvaW50LmxvYWQoby5lbmRQb2ludClcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3TGluZTtcclxuICAgIH07XHJcblxyXG4gICAgTGluZS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29udHJ1Y3RvcjogTGluZSxcclxuXHJcblxyXG5cclxuICAgICAgICBjbG9uZTpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IExpbmUodGhpcy5zdGFydFBvaW50LmNsb25lKCksIHRoaXMuZW5kUG9pbnQuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZXF1YWxzOmZ1bmN0aW9uKGFub3RoZXJMaW5lKXtcclxuICAgICAgICAgICAgaWYoIWFub3RoZXJMaW5lIGluc3RhbmNlb2YgTGluZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQb2ludC5lcXVhbHMoYW5vdGhlckxpbmUuc3RhcnRQb2ludClcclxuICAgICAgICAgICAgJiYgdGhpcy5lbmRQb2ludC5lcXVhbHMoYW5vdGhlckxpbmUuZW5kUG9pbnQpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqIFRlc3RzIHRvIHNlZSBpZiBhIHBvaW50IGJlbG9uZ3MgdG8gdGhpcyBsaW5lIChub3QgYXMgaW5maW5pdGUgbGluZSBidXQgbW9yZSBsaWtlIGEgc2VnbWVudClcclxuICAgICAgICAgKiBBbGdvcml0aG06IENvbXB1dGUgbGluZSdzIGVxdWF0aW9uIGFuZCBzZWUgaWYgKHgsIHkpIHZlcmlmaWVzIGl0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gdGhlIFggY29vcmRpbmF0ZXNcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geSAtIHRoZSBZIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGNvbnRhaW5zOiBmdW5jdGlvbih4LCB5KXtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIHBvaW50IGlzIGluc2lkZSByZWN0YW5nbGUgYm91bmRzIG9mIHRoZSBzZWdtZW50XHJcbiAgICAgICAgICAgIGlmIChNYXRoLm1pbih0aGlzLnN0YXJ0UG9pbnQueCwgdGhpcy5lbmRQb2ludC54KSA8PSB4XHJcbiAgICAgICAgICAgICAgICAmJiB4IDw9IE1hdGgubWF4KHRoaXMuc3RhcnRQb2ludC54LCB0aGlzLmVuZFBvaW50LngpXHJcbiAgICAgICAgICAgICAgICAmJiBNYXRoLm1pbih0aGlzLnN0YXJ0UG9pbnQueSwgdGhpcy5lbmRQb2ludC55KSA8PSB5XHJcbiAgICAgICAgICAgICAgICAmJiB5IDw9IE1hdGgubWF4KHRoaXMuc3RhcnRQb2ludC55LCB0aGlzLmVuZFBvaW50LnkpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHZlcnRpY2FsIGxpbmVcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0UG9pbnQueCA9PSB0aGlzLmVuZFBvaW50LngpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCA9PSB0aGlzLnN0YXJ0UG9pbnQueDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVzdWFsIChub3QgdmVydGljYWwpIGxpbmUgY2FuIGJlIHJlcHJlc2VudGVkIGFzIHkgPSBhICogeCArIGJcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9ICh0aGlzLmVuZFBvaW50LnkgLSB0aGlzLnN0YXJ0UG9pbnQueSkgLyAodGhpcy5lbmRQb2ludC54IC0gdGhpcy5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5zdGFydFBvaW50LnkgLSBhICogdGhpcy5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkgPT0gYSAqIHggKyBiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKlNlZSBpZiB3ZSBhcmUgbmVhciBhIHtMaW5lfSBieSBhIGNlcnRhaW4gcmFkaXVzIChhbHNvIGluY2x1ZGVzIHRoZSBleHRyZW1pdGllcyBpbnRvIGNvbXB1dGF0aW9uKVxyXG4gICAgICAgICAqQHBhcmFtIHtOdW1iZXJ9IHggLSB0aGUgeCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqQHBhcmFtIHtOdW1iZXJ9IHkgLSB0aGUgeSBjb29yZGluYXRlc1xyXG4gICAgICAgICAqQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyAtIHRoZSByYWRpdXMgdG8gc2VhcmNoIGZvclxyXG4gICAgICAgICAqQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RhbmNlX2Zyb21fYV9wb2ludF90b19hX2xpbmVcclxuICAgICAgICAgKkBzZWUgXCJNYXRoZW1hdGljcyBmb3IgQ29tcHV0ZXIgR3JhcGhpY3MsIDJuZCBFZC4sIGJ5IEpvaG4gVmljZSwgcGFnZSAyMjdcIlxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBuZWFyOmZ1bmN0aW9uKHgseSxyYWRpdXMpe1xyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5lbmRQb2ludC54ID09PSB0aGlzLnN0YXJ0UG9pbnQueCl7IC8vVmVydGljYWwgbGluZSwgc28gdGhlIHZpY2luaXR5IGFyZWEgaXMgYSByZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgIHJldHVybiAoICh0aGlzLnN0YXJ0UG9pbnQueS1yYWRpdXM8PXkgJiYgdGhpcy5lbmRQb2ludC55K3JhZGl1cz49eSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHRoaXMuZW5kUG9pbnQueS1yYWRpdXM8PXkgJiYgdGhpcy5zdGFydFBvaW50LnkrcmFkaXVzPj15KSlcclxuICAgICAgICAgICAgICAgICYmIHggPiB0aGlzLnN0YXJ0UG9pbnQueCAtIHJhZGl1cyAmJiB4IDwgdGhpcy5zdGFydFBvaW50LnggKyByYWRpdXMgO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLnN0YXJ0UG9pbnQueSA9PT0gdGhpcy5lbmRQb2ludC55KXsgLy9Ib3Jpem9udGFsIGxpbmUsIHNvIHRoZSB2aWNpbml0eSBhcmVhIGlzIGEgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCAodGhpcy5zdGFydFBvaW50LnggLSByYWRpdXM8PXggJiYgdGhpcy5lbmRQb2ludC54K3JhZGl1cz49eClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHRoaXMuZW5kUG9pbnQueC1yYWRpdXM8PXggJiYgdGhpcy5zdGFydFBvaW50LngrcmFkaXVzPj14KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgeT50aGlzLnN0YXJ0UG9pbnQueS1yYWRpdXMgJiYgeTx0aGlzLnN0YXJ0UG9pbnQueStyYWRpdXMgO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IE1hdGgubWluKHRoaXMuZW5kUG9pbnQueCx0aGlzLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFkgPSBNYXRoLm1pbih0aGlzLmVuZFBvaW50LnksdGhpcy5zdGFydFBvaW50LnkpO1xyXG4gICAgICAgICAgICB2YXIgZW5kWCA9IE1hdGgubWF4KHRoaXMuZW5kUG9pbnQueCx0aGlzLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciBlbmRZID0gTWF0aC5tYXgodGhpcy5lbmRQb2ludC55LHRoaXMuc3RhcnRQb2ludC55KTtcclxuXHJcbiAgICAgICAgICAgIC8qV2Ugd2lsbCBjb21wdXRlIHRoZSBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIHRoZSBsaW5lXHJcbiAgICAgICAgICAgICAqIGJ5IHVzaW5nIHRoZSBhbGdvcml0aG0gZnJvbVxyXG4gICAgICAgICAgICAgKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RhbmNlX2Zyb21fYV9wb2ludF90b19hX2xpbmVcclxuICAgICAgICAgICAgICogKi9cclxuXHJcbiAgICAgICAgICAgIC8vRmlyc3Qgd2UgbmVlZCB0byBmaW5kIGEsYixjIG9mIHRoZSBsaW5lIGVxdWF0aW9uIGF4ICsgYnkgKyBjID0gMFxyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuZW5kUG9pbnQueSAtIHRoaXMuc3RhcnRQb2ludC55O1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuc3RhcnRQb2ludC54IC0gdGhpcy5lbmRQb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgYyA9IC0odGhpcy5zdGFydFBvaW50LnggKiB0aGlzLmVuZFBvaW50LnkgLSB0aGlzLmVuZFBvaW50LnggKiB0aGlzLnN0YXJ0UG9pbnQueSk7XHJcblxyXG4gICAgICAgICAgICAvL1NlY29uZGx5IHdlIGdldCB0aGUgZGlzdGFuY2UgXCJNYXRoZW1hdGljcyBmb3IgQ29tcHV0ZXIgR3JhcGhpY3MsIDJuZCBFZC4sIGJ5IEpvaG4gVmljZSwgcGFnZSAyMjdcIlxyXG4gICAgICAgICAgICB2YXIgZCA9IE1hdGguYWJzKCAoYSp4ICsgYip5ICsgYykgLyBNYXRoLnNxcnQoTWF0aC5wb3coYSwyKSArIE1hdGgucG93KGIsMikpICk7XHJcblxyXG4gICAgICAgICAgICAvL1RoaXJkbHkgd2UgZ2V0IGNvb3JkaW5hdGVzIG9mIGNsb3Nlc3QgbGluZSdzIHBvaW50IHRvIHRhcmdldCBwb2ludFxyXG4gICAgICAgICAgICAvL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfZnJvbV9hX3BvaW50X3RvX2FfbGluZSNDYXJ0ZXNpYW5fY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgdmFyIGNsb3Nlc3RYID0gKGIgKiAoYip4IC0gYSp5KSAtIGEqYykgLyAoIE1hdGgucG93KGEsMikgKyBNYXRoLnBvdyhiLDIpICk7XHJcbiAgICAgICAgICAgIHZhciBjbG9zZXN0WSA9IChhICogKC1iKnggKyBhKnkpIC0gYipjKSAvICggTWF0aC5wb3coYSwyKSArIE1hdGgucG93KGIsMikgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByID0gKCBkIDw9IHJhZGl1cyAmJiBlbmRYPj1jbG9zZXN0WCAmJiBjbG9zZXN0WD49c3RhcnRYICYmIGVuZFk+PWNsb3Nlc3RZICYmIGNsb3Nlc3RZPj1zdGFydFkgKSAvL3RoZSBwcm9qZWN0aW9uIG9mIHRoZSBwb2ludCBmYWxscyBJTlNJREUgb2YgdGhlIHNlZ21lbnRcclxuICAgICAgICAgICAgICAgIHx8IHRoaXMuc3RhcnRQb2ludC5uZWFyKHgseSxyYWRpdXMpIHx8IHRoaXMuZW5kUG9pbnQubmVhcih4LHkscmFkaXVzKTsgLy90aGUgcHJvamVjdGlvbiBvZiB0aGUgcG9pbnQgZmFsbHMgT1VUU0lERSBvZiB0aGUgc2VnbWVudFxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICByO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKip3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBhcnJheSBlYWNoIHRpbWUsIG9yIHdlIHdpbGwgYWZmZWN0IHRoZSBhY3R1YWwgc2hhcGUqL1xyXG4gICAgICAgIGdldFBvaW50czpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHRoaXMuc3RhcnRQb2ludCk7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHRoaXMuZW5kUG9pbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlJldHVybiB0aGUge1BvaW50fSBjb3JyZXNwb25kaW5nIHRoZSB0IGNlcnRhaW4gdCB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0IHRoZSB2YWx1ZSBvZiBwYXJhbWV0ZXIgdCwgd2hlcmUgdCBpbiBbMCwxXSwgdCBpcyBsaWtlIGEgcGVyY2VudCovXHJcbiAgICAgICAgZ2V0UG9pbnQ6IGZ1bmN0aW9uKHQpe1xyXG4gICAgICAgICAgICB2YXIgWHAgPSB0ICogKHRoaXMuZW5kUG9pbnQueCAtIHRoaXMuc3RhcnRQb2ludC54KSArIHRoaXMuc3RhcnRQb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgWXAgPSB0ICogKHRoaXMuZW5kUG9pbnQueSAtIHRoaXMuc3RhcnRQb2ludC55KSArIHRoaXMuc3RhcnRQb2ludC55O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYcCwgWXApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIC8qKlxyXG4gICAgICAgIC8vICAqIFJldHVybnMgdGhlIG1pZGRsZSBvZiB0aGUgbGluZVxyXG4gICAgICAgIC8vICAqIEByZXR1cm4ge1BvaW50fSB0aGUgbWlkZGxlIHBvaW50XHJcbiAgICAgICAgLy8gICogKi9cclxuICAgICAgICAvLyBnZXRNaWRkbGUgOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gVXRpbC5nZXRNaWRkbGUodGhpcy5zdGFydFBvaW50LCB0aGlzLmVuZFBvaW50KTtcclxuICAgICAgICAvLyB9LFxyXG5cclxuXHJcbiAgICAgICAgLy8gZ2V0TGVuZ3RoIDogZnVuY3Rpb24oKXtcclxuICAgICAgICAvLyAgICAgcmV0dXJuIFV0aWwuZ2V0TGVuZ3RoKHRoaXMuc3RhcnRQb2ludCwgdGhpcy5lbmRQb2ludCk7XHJcbiAgICAgICAgLy8gfSxcclxuXHJcbiAgICAgICAgLy8gLyoqXHJcbiAgICAgICAgLy8gICpHZXQgYm91bmRzIGZvciB0aGlzIGxpbmVcclxuICAgICAgICAvLyAgKkBhdXRob3IgQWxleCBHaGVvcmdoaXUgPGFsZXhAc2NyaXB0b2lkLmNvbT5cclxuICAgICAgICAvLyAgKiovXHJcbiAgICAgICAgLy8gZ2V0Qm91bmRzOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgLy8gICAgIHJldHVybiBVdGlsLmdldEJvdW5kcyh0aGlzLmdldFBvaW50cygpKTtcclxuICAgICAgICAvLyB9LFxyXG5cclxuICAgICAgICAvKipTdHJpbmcgcmVwcmVzZW50YXRpb24qL1xyXG4gICAgICAgIHRvU3RyaW5nOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiAnbGluZSgnICsgdGhpcy5zdGFydFBvaW50ICsgJywnICsgdGhpcy5lbmRQb2ludCArICcpJztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xyXG5cclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9MaW5lU3RydWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblxyXG4gICAgdmFyIGFwaUxpc3QgPSBbXHJcbiAgICAgICAgJ2dldERvbScsICdnZXRacicsICdnZXRXaWR0aCcsICdnZXRIZWlnaHQnLCAnZGlzcGF0Y2hBY3Rpb24nLFxyXG4gICAgICAgICdvbicsICdvZmYnLCAndHJpZ2dlcicsICdnZXREYXRhVVJMJywgJ2dldENvbm5lY3RlZERhdGFVUkwnLCAnZ2V0TW9kZWwnLCAnZ2V0T3B0aW9uJyxcclxuICAgICAgICBcInJlbW92ZVwiLCBcIl9nZXRQYXJlbnRaclwiLCBcImNoYW5nZVNlbGVjdENvbm5lY3RvclR5cGVcIixcIl9hZGRHcm91cE5vZGVcIlxyXG4gICAgXTtcclxuXHJcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25BUEkoaW5zdGFuY2UpIHtcclxuICAgICAgICB6clV0aWwuZWFjaChhcGlMaXN0LCBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzW25hbWVdID0genJVdGlsLmJpbmQoaW5zdGFuY2VbbmFtZV0sIGluc3RhbmNlKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV4dGVuc2lvbkFQSTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9FeHRlbnNpb25BcGkuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBndWlkID0gcmVxdWlyZShcIi4vY29yZS9ndWlkXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4vY29yZS9lbnZcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBIYW5kbGVyID0gcmVxdWlyZShcIi4vSGFuZGxlclwiKTtcblxudmFyIFN0b3JhZ2UgPSByZXF1aXJlKFwiLi9TdG9yYWdlXCIpO1xuXG52YXIgUGFpbnRlciA9IHJlcXVpcmUoXCIuL1BhaW50ZXJcIik7XG5cbnZhciBBbmltYXRpb24gPSByZXF1aXJlKFwiLi9hbmltYXRpb24vQW5pbWF0aW9uXCIpO1xuXG52YXIgSGFuZGxlclByb3h5ID0gcmVxdWlyZShcIi4vZG9tL0hhbmRsZXJQcm94eVwiKTtcblxuLyohXG4qIFpSZW5kZXIsIGEgaGlnaCBwZXJmb3JtYW5jZSAyZCBkcmF3aW5nIGxpYnJhcnkuXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMywgQmFpZHUgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBMSUNFTlNFXG4qIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvenJlbmRlci9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuKi9cbnZhciB1c2VWTUwgPSAhZW52LmNhbnZhc1N1cHBvcnRlZDtcbnZhciBwYWludGVyQ3RvcnMgPSB7XG4gIGNhbnZhczogUGFpbnRlclxufTtcbnZhciBpbnN0YW5jZXMgPSB7fTsgLy8gWlJlbmRlcuWunuS+i21hcOe0ouW8lVxuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblxudmFyIHZlcnNpb24gPSAnMy43LjQnO1xuLyoqXG4gKiBJbml0aWFsaXppbmcgYSB6cmVuZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpb11cbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMud2lkdGhdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAqL1xuXG5mdW5jdGlvbiBpbml0KGRvbSwgb3B0cykge1xuICB2YXIgenIgPSBuZXcgWlJlbmRlcihndWlkKCksIGRvbSwgb3B0cyk7XG4gIGluc3RhbmNlc1t6ci5pZF0gPSB6cjtcbiAgcmV0dXJuIHpyO1xufVxuLyoqXG4gKiBEaXNwb3NlIHpyZW5kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAqL1xuXG5cbmZ1bmN0aW9uIGRpc3Bvc2UoenIpIHtcbiAgaWYgKHpyKSB7XG4gICAgenIuZGlzcG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBpbnN0YW5jZXMpIHtcbiAgICAgIGlmIChpbnN0YW5jZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpbnN0YW5jZXNba2V5XS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdGFuY2VzID0ge307XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbi8qKlxuICogR2V0IHpyZW5kZXIgaW5zdGFuY2UgYnkgaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCB6cmVuZGVyIGluc3RhbmNlIGlkXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0SW5zdGFuY2UoaWQpIHtcbiAgcmV0dXJuIGluc3RhbmNlc1tpZF07XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUGFpbnRlcihuYW1lLCBDdG9yKSB7XG4gIHBhaW50ZXJDdG9yc1tuYW1lXSA9IEN0b3I7XG59XG5cbmZ1bmN0aW9uIGRlbEluc3RhbmNlKGlkKSB7XG4gIGRlbGV0ZSBpbnN0YW5jZXNbaWRdO1xufVxuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvWlJlbmRlclxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvWlJlbmRlclxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpb11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqL1xuXG5cbnZhciBaUmVuZGVyID0gZnVuY3Rpb24gKGlkLCBkb20sIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIC8qKlxuICAgKiBAdHlwZSB7SFRNTERvbUVsZW1lbnR9XG4gICAqL1xuXG4gIHRoaXMuZG9tID0gZG9tO1xuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG5cbiAgdGhpcy5pZCA9IGlkO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdG9yYWdlID0gbmV3IFN0b3JhZ2UoKTtcbiAgdmFyIHJlbmRlcmVyVHlwZSA9IG9wdHMucmVuZGVyZXI7IC8vIFRPRE8gV2ViR0xcblxuICBpZiAodXNlVk1MKSB7XG4gICAgaWYgKCFwYWludGVyQ3RvcnMudm1sKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHJlcXVpcmUgXFwnenJlbmRlci92bWwvdm1sXFwnIHRvIHN1cHBvcnQgSUU4Jyk7XG4gICAgfVxuXG4gICAgcmVuZGVyZXJUeXBlID0gJ3ZtbCc7XG4gIH0gZWxzZSBpZiAoIXJlbmRlcmVyVHlwZSB8fCAhcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0pIHtcbiAgICByZW5kZXJlclR5cGUgPSAnY2FudmFzJztcbiAgfVxuXG4gIHZhciBwYWludGVyID0gbmV3IHBhaW50ZXJDdG9yc1tyZW5kZXJlclR5cGVdKGRvbSwgc3RvcmFnZSwgb3B0cyk7XG4gIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG4gIHZhciBoYW5kZXJQcm94eSA9ICFlbnYubm9kZSA/IG5ldyBIYW5kbGVyUHJveHkocGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkgOiBudWxsO1xuICB0aGlzLmhhbmRsZXIgPSBuZXcgSGFuZGxlcihzdG9yYWdlLCBwYWludGVyLCBoYW5kZXJQcm94eSwgcGFpbnRlci5yb290KTtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufVxuICAgKi9cblxuICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oe1xuICAgIHN0YWdlOiB7XG4gICAgICB1cGRhdGU6IHpyVXRpbC5iaW5kKHRoaXMuZmx1c2gsIHRoaXMpXG4gICAgfVxuICB9KTtcbiAgdGhpcy5hbmltYXRpb24uc3RhcnQoKTtcbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9uZWVkc1JlZnJlc2g7IC8vIOS/ruaUuSBzdG9yYWdlLmRlbEZyb21TdG9yYWdlLCDmr4/mrKHliKDpmaTlhYPntKDkuYvliY3liKDpmaTliqjnlLtcbiAgLy8gRklYTUUg5pyJ54K5dWdseVxuXG4gIHZhciBvbGREZWxGcm9tU3RvcmFnZSA9IHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2U7XG4gIHZhciBvbGRBZGRUb1N0b3JhZ2UgPSBzdG9yYWdlLmFkZFRvU3RvcmFnZTtcblxuICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgb2xkRGVsRnJvbVN0b3JhZ2UuY2FsbChzdG9yYWdlLCBlbCk7XG4gICAgZWwgJiYgZWwucmVtb3ZlU2VsZkZyb21acihzZWxmKTtcbiAgfTtcblxuICBzdG9yYWdlLmFkZFRvU3RvcmFnZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIG9sZEFkZFRvU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgICBlbC5hZGRTZWxmVG9acihzZWxmKTtcbiAgfTtcbn07XG5cblpSZW5kZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogWlJlbmRlcixcblxuICAvKipcbiAgICog6I635Y+W5a6e5L6L5ZSv5LiA5qCH6K+GXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldElkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWFg+e0oFxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiAoZWwpIHtcbiAgICB0aGlzLnN0b3JhZ2UuYWRkUm9vdChlbCk7XG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5YWD57SgXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChlbCkge1xuICAgIHRoaXMuc3RvcmFnZS5kZWxSb290KGVsKTtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgY29uZmlndXJhdGlvbiBvZiBsYXllclxuICAgKiBAcGFyYW0ge3N0cmluZ30gekxldmVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSBDbGVhciBjb2xvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5tb3Rpb25CbHVyPWZhbHNlXSBJZiBlbmFibGUgbW90aW9uIGJsdXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubGFzdEZyYW1lQWxwaGE9MC43XSBNb3Rpb24gYmx1ciBmYWN0b3IuIExhcmdlciB2YWx1ZSBjYXVzZSBsb25nZXIgdHJhaWxlclxuICAqL1xuICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpMZXZlbCwgY29uZmlnKSB7XG4gICAgdGhpcy5wYWludGVyLmNvbmZpZ0xheWVyKHpMZXZlbCwgY29uZmlnKTtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoZSBjYW52YXMgaW1tZWRpYXRlbHlcbiAgICovXG4gIHJlZnJlc2hJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgIC8vIHZhciBzdGFydCA9IG5ldyBEYXRlKCk7XG4gICAgLy8gQ2xlYXIgbmVlZHNSZWZyZXNoIGFoZWFkIHRvIGF2b2lkIHNvbWV0aGluZyB3cm9uZyBoYXBwZW5zIGluIHJlZnJlc2hcbiAgICAvLyBPciBpdCB3aWxsIGNhdXNlIHpyZW5kZXIgcmVmcmVzaGVzIGFnYWluIGFuZCBhZ2Fpbi5cbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSBmYWxzZTtcbiAgICB0aGlzLnBhaW50ZXIucmVmcmVzaCgpO1xuICAgIC8qKlxuICAgICAqIEF2b2lkIHRyaWdnZXIgenIucmVmcmVzaCBpbiBFbGVtZW50I2JlZm9yZVVwZGF0ZSBob29rXG4gICAgICovXG5cbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSBmYWxzZTsgLy8gdmFyIGVuZCA9IG5ldyBEYXRlKCk7XG4gICAgLy8gdmFyIGxvZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2cnKTtcbiAgICAvLyBpZiAobG9nKSB7XG4gICAgLy8gICAgIGxvZy5pbm5lckhUTUwgPSBsb2cuaW5uZXJIVE1MICsgJzxicj4nICsgKGVuZCAtIHN0YXJ0KTtcbiAgICAvLyB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1hcmsgYW5kIHJlcGFpbnQgdGhlIGNhbnZhcyBpbiB0aGUgbmV4dCBmcmFtZSBvZiBicm93c2VyXG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybSBhbGwgcmVmcmVzaFxuICAgKi9cbiAgZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fbmVlZHNSZWZyZXNoKSB7XG4gICAgICB0aGlzLnJlZnJlc2hJbW1lZGlhdGVseSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2hIb3Zlcikge1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXJJbW1lZGlhdGVseSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkIGVsZW1lbnQgdG8gaG92ZXIgbGF5ZXJcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAqL1xuICBhZGRIb3ZlcjogZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xuICAgIGlmICh0aGlzLnBhaW50ZXIuYWRkSG92ZXIpIHtcbiAgICAgIHRoaXMucGFpbnRlci5hZGRIb3ZlcihlbCwgc3R5bGUpO1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBlbGVtZW50IGZyb20gaG92ZXIgbGF5ZXJcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAodGhpcy5wYWludGVyLnJlbW92ZUhvdmVyKSB7XG4gICAgICB0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIoZWwpO1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBob3ZlciBlbGVtZW50cyBpbiBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgY2xlYXJIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBhaW50ZXIuY2xlYXJIb3Zlcikge1xuICAgICAgdGhpcy5wYWludGVyLmNsZWFySG92ZXIoKTtcbiAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGhvdmVyIGluIG5leHQgZnJhbWVcbiAgICovXG4gIHJlZnJlc2hIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaCBob3ZlciBpbW1lZGlhdGVseVxuICAgKi9cbiAgcmVmcmVzaEhvdmVySW1tZWRpYXRlbHk6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IGZhbHNlO1xuICAgIHRoaXMucGFpbnRlci5yZWZyZXNoSG92ZXIgJiYgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIGNhbnZhcy5cbiAgICogU2hvdWxkIGJlIGludm9rZWQgd2hlbiBjb250YWluZXIgc2l6ZSBpcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB0aGlzLnBhaW50ZXIucmVzaXplKG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgICB0aGlzLmhhbmRsZXIucmVzaXplKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3AgYW5kIGNsZWFyIGFsbCBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICovXG4gIGNsZWFyQW5pbWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hbmltYXRpb24uY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNvbnRhaW5lciB3aWR0aFxuICAgKi9cbiAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFdpZHRoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjb250YWluZXIgaGVpZ2h0XG4gICAqL1xuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldEhlaWdodCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHBvcnQgdGhlIGNhbnZhcyBhcyBCYXNlNjQgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFja2dyb3VuZENvbG9yPScjZmZmJ11cbiAgICogQHJldHVybiB7c3RyaW5nfSBCYXNlNjQgVVJMXG4gICAqL1xuICAvLyB0b0RhdGFVUkw6IGZ1bmN0aW9uKHR5cGUsIGJhY2tncm91bmRDb2xvcikge1xuICAvLyAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRSZW5kZXJlZENhbnZhcyh7XG4gIC8vICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgLy8gICAgIH0pLnRvRGF0YVVSTCh0eXBlKTtcbiAgLy8gfSxcblxuICAvKipcbiAgICogQ29udmVydGluZyBhIHBhdGggdG8gaW1hZ2UuXG4gICAqIEl0IGhhcyBtdWNoIGJldHRlciBwZXJmb3JtYW5jZSBvZiBkcmF3aW5nIGltYWdlIHJhdGhlciB0aGFuIGRyYXdpbmcgYSB2ZWN0b3IgcGF0aC5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHBhdGhUb0ltYWdlOiBmdW5jdGlvbiAoZSwgZHByKSB7XG4gICAgcmV0dXJuIHRoaXMucGFpbnRlci5wYXRoVG9JbWFnZShlLCBkcHIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgZGVmYXVsdCBjdXJzb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JTdHlsZT0nZGVmYXVsdCddIOS+i+WmgiBjcm9zc2hhaXJcbiAgICovXG4gIHNldEN1cnNvclN0eWxlOiBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICB0aGlzLmhhbmRsZXIuc2V0Q3Vyc29yU3R5bGUoY3Vyc29yU3R5bGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kIGhvdmVyZWQgZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHt0YXJnZXQsIHRvcFRhcmdldH1cbiAgICovXG4gIGZpbmRIb3ZlcjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmZpbmRIb3Zlcih4LCB5KTtcbiAgfSxcblxuICAvKipcbiAgICogQmluZCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRIYW5kbGVyIEhhbmRsZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0IG9iamVjdFxuICAgKi9cbiAgb246IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgY29udGV4dCkge1xuICAgIHRoaXMuaGFuZGxlci5vbihldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVuYmluZCBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2V2ZW50SGFuZGxlcl0gSGFuZGxlciBmdW5jdGlvblxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICB0aGlzLmhhbmRsZXIub2ZmKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJpZ2dlciBldmVudCBtYW51YWxseVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtldmVudD19IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICB0aGlzLmhhbmRsZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIG9iamVjdHMgYW5kIHRoZSBjYW52YXMuXG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RvcmFnZS5kZWxSb290KCk7XG4gICAgdGhpcy5wYWludGVyLmNsZWFyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3Bvc2Ugc2VsZi5cbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbi5zdG9wKCk7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuc3RvcmFnZS5kaXNwb3NlKCk7XG4gICAgdGhpcy5wYWludGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuYW5pbWF0aW9uID0gdGhpcy5zdG9yYWdlID0gdGhpcy5wYWludGVyID0gdGhpcy5oYW5kbGVyID0gbnVsbDtcbiAgICBkZWxJbnN0YW5jZSh0aGlzLmlkKTtcbiAgfVxufTtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5kaXNwb3NlID0gZGlzcG9zZTtcbmV4cG9ydHMuZ2V0SW5zdGFuY2UgPSBnZXRJbnN0YW5jZTtcbmV4cG9ydHMucmVnaXN0ZXJQYWludGVyID0gcmVnaXN0ZXJQYWludGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi96cmVuZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIERyYWdnYWJsZSA9IHJlcXVpcmUoXCIuL21peGluL0RyYWdnYWJsZVwiKTtcblxudmFyIEV2ZW50ZnVsID0gcmVxdWlyZShcIi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbi8qKlxuICogSGFuZGxlclxuICogQG1vZHVsZSB6cmVuZGVyL0hhbmRsZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChzaGVueWkuOTE0QGdtYWlsLmNvbSlcbiAqL1xudmFyIFNJTEVOVCA9ICdzaWxlbnQnO1xuXG5mdW5jdGlvbiBtYWtlRXZlbnRQYWNrZXQoZXZlVHlwZSwgdGFyZ2V0SW5mbywgZXZlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBldmVUeXBlLFxuICAgIGV2ZW50OiBldmVudCxcbiAgICAvLyB0YXJnZXQgY2FuIG9ubHkgYmUgYW4gZWxlbWVudCB0aGF0IGlzIG5vdCBzaWxlbnQuXG4gICAgdGFyZ2V0OiB0YXJnZXRJbmZvLnRhcmdldCxcbiAgICAvLyB0b3BUYXJnZXQgY2FuIGJlIGEgc2lsZW50IGVsZW1lbnQuXG4gICAgdG9wVGFyZ2V0OiB0YXJnZXRJbmZvLnRvcFRhcmdldCxcbiAgICBjYW5jZWxCdWJibGU6IGZhbHNlLFxuICAgIG9mZnNldFg6IGV2ZW50LnpyWCxcbiAgICBvZmZzZXRZOiBldmVudC56clksXG4gICAgZ2VzdHVyZUV2ZW50OiBldmVudC5nZXN0dXJlRXZlbnQsXG4gICAgcGluY2hYOiBldmVudC5waW5jaFgsXG4gICAgcGluY2hZOiBldmVudC5waW5jaFksXG4gICAgcGluY2hTY2FsZTogZXZlbnQucGluY2hTY2FsZSxcbiAgICB3aGVlbERlbHRhOiBldmVudC56ckRlbHRhLFxuICAgIHpyQnlUb3VjaDogZXZlbnQuenJCeVRvdWNoLFxuICAgIHdoaWNoOiBldmVudC53aGljaFxuICB9O1xufVxuXG5mdW5jdGlvbiBFbXB0eVByb3h5KCkge31cblxuRW1wdHlQcm94eS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgaGFuZGxlck5hbWVzID0gWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JywgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdjb250ZXh0bWVudSddO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvSGFuZGxlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfSBzdG9yYWdlIFN0b3JhZ2UgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXIgUGFpbnRlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZG9tL0hhbmRsZXJQcm94eX0gcHJveHkgSGFuZGxlclByb3h5IGluc3RhbmNlLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFpbnRlclJvb3QgcGFpbnRlci5yb290IChub3QgcGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkuXG4gKi9cblxudmFyIEhhbmRsZXIgPSBmdW5jdGlvbiAoc3RvcmFnZSwgcGFpbnRlciwgcHJveHksIHBhaW50ZXJSb290KSB7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG4gIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG4gIHRoaXMucGFpbnRlclJvb3QgPSBwYWludGVyUm9vdDtcbiAgcHJveHkgPSBwcm94eSB8fCBuZXcgRW1wdHlQcm94eSgpO1xuICAvKipcbiAgICogUHJveHkgb2YgZXZlbnQuIGNhbiBiZSBEb20sIFdlYkdMU3VyZmFjZSwgZXRjLlxuICAgKi9cblxuICB0aGlzLnByb3h5ID0gcHJveHk7IC8vIEF0dGFjaCBoYW5kbGVyXG5cbiAgcHJveHkuaGFuZGxlciA9IHRoaXM7XG4gIC8qKlxuICAgKiB7dGFyZ2V0LCB0b3BUYXJnZXQsIHgsIHl9XG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIHRoaXMuX2hvdmVyZWQgPSB7fTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtEYXRlfVxuICAgKi9cblxuICB0aGlzLl9sYXN0VG91Y2hNb21lbnQ7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLl9sYXN0WDtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuX2xhc3RZO1xuICBEcmFnZ2FibGUuY2FsbCh0aGlzKTtcbiAgdXRpbC5lYWNoKGhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBwcm94eS5vbiAmJiBwcm94eS5vbihuYW1lLCB0aGlzW25hbWVdLCB0aGlzKTtcbiAgfSwgdGhpcyk7XG59O1xuXG5IYW5kbGVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEhhbmRsZXIsXG4gIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHggPSBldmVudC56clg7XG4gICAgdmFyIHkgPSBldmVudC56clk7XG4gICAgdmFyIGxhc3RIb3ZlcmVkID0gdGhpcy5faG92ZXJlZDtcbiAgICB2YXIgbGFzdEhvdmVyZWRUYXJnZXQgPSBsYXN0SG92ZXJlZC50YXJnZXQ7IC8vIElmIGxhc3RIb3ZlcmVkVGFyZ2V0IGlzIHJlbW92ZWQgZnJvbSB6ciAoZGV0ZWN0ZWQgYnkgJ19fenInKSBieSBzb21lIEFQSSBjYWxsXG4gICAgLy8gKGxpa2UgJ3NldE9wdGlvbicgb3IgJ2Rpc3BhdGNoQWN0aW9uJykgaW4gZXZlbnQgaGFuZGxlcnMsIHdlIHNob3VsZCBmaW5kXG4gICAgLy8gbGFzdEhvdmVyZWQgYWdhaW4gaGVyZS4gT3RoZXJ3aXNlICdtb3VzZW91dCcgY2FuIG5vdCBiZSB0cmlnZ2VyZWQgbm9ybWFsbHkuXG4gICAgLy8gU2VlICM2MTk4LlxuXG4gICAgaWYgKGxhc3RIb3ZlcmVkVGFyZ2V0ICYmICFsYXN0SG92ZXJlZFRhcmdldC5fX3pyKSB7XG4gICAgICBsYXN0SG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKGxhc3RIb3ZlcmVkLngsIGxhc3RIb3ZlcmVkLnkpO1xuICAgICAgbGFzdEhvdmVyZWRUYXJnZXQgPSBsYXN0SG92ZXJlZC50YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGhvdmVyZWQgPSB0aGlzLl9ob3ZlcmVkID0gdGhpcy5maW5kSG92ZXIoeCwgeSk7XG4gICAgdmFyIGhvdmVyZWRUYXJnZXQgPSBob3ZlcmVkLnRhcmdldDtcbiAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgIHByb3h5LnNldEN1cnNvciAmJiBwcm94eS5zZXRDdXJzb3IoaG92ZXJlZFRhcmdldCA/IGhvdmVyZWRUYXJnZXQuY3Vyc29yIDogJ2RlZmF1bHQnKTsgLy8gTW91c2Ugb3V0IG9uIHByZXZpb3VzIGhvdmVyZWQgZWxlbWVudFxuXG4gICAgaWYgKGxhc3RIb3ZlcmVkVGFyZ2V0ICYmIGhvdmVyZWRUYXJnZXQgIT09IGxhc3RIb3ZlcmVkVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGxhc3RIb3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG4gICAgfSAvLyBNb3VzZSBtb3Zpbmcgb24gb25lIGVsZW1lbnRcblxuXG4gICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCAnbW91c2Vtb3ZlJywgZXZlbnQpOyAvLyBNb3VzZSBvdmVyIG9uIGEgbmV3IGVsZW1lbnRcblxuICAgIGlmIChob3ZlcmVkVGFyZ2V0ICYmIGhvdmVyZWRUYXJnZXQgIT09IGxhc3RIb3ZlcmVkVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW92ZXInLCBldmVudCk7XG4gICAgfVxuICB9LFxuICBtb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudCh0aGlzLl9ob3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7IC8vIFRoZXJlIG1pZ2h0IGJlIHNvbWUgZG9tcyBjcmVhdGVkIGJ5IHVwcGVyIGxheWVyIGFwcGxpY2F0aW9uXG4gICAgLy8gYXQgdGhlIHNhbWUgbGV2ZWwgb2YgcGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSAoZS5nLiwgdG9vbHRpcFxuICAgIC8vIGRvbSBjcmVhdGVkIGJ5IGVjaGFydHMpLCB3aGVyZSAnZ2xvYmFsb3V0JyBldmVudCBzaG91bGQgbm90XG4gICAgLy8gYmUgdHJpZ2dlcmVkIHdoZW4gbW91c2UgZW50ZXJzIHRoZXNlIGRvbXMuIChCdXQgJ21vdXNlb3V0J1xuICAgIC8vIHNob3VsZCBiZSB0cmlnZ2VyZWQgYXQgdGhlIG9yaWdpbmFsIGhvdmVyZWQgZWxlbWVudCBhcyB1c3VhbCkuXG5cbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIHZhciBpbm5lckRvbTtcblxuICAgIGRvIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB9IHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgIT0gOSAmJiAhKGlubmVyRG9tID0gZWxlbWVudCA9PT0gdGhpcy5wYWludGVyUm9vdCkpO1xuXG4gICAgIWlubmVyRG9tICYmIHRoaXMudHJpZ2dlcignZ2xvYmFsb3V0Jywge1xuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2l6ZVxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLl9ob3ZlcmVkID0ge307XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3BhdGNoIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtldmVudD19IGV2ZW50QXJnc1xuICAgKi9cbiAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJncykge1xuICAgIHZhciBoYW5kbGVyID0gdGhpc1tldmVudE5hbWVdO1xuICAgIGhhbmRsZXIgJiYgaGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50QXJncyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3Bvc2VcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnByb3h5LmRpc3Bvc2UoKTtcbiAgICB0aGlzLnN0b3JhZ2UgPSB0aGlzLnByb3h5ID0gdGhpcy5wYWludGVyID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICog6K6+572u6buY6K6k55qEY3Vyc29yIHN0eWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3R5bGU9J2RlZmF1bHQnXSDkvovlpoIgY3Jvc3NoYWlyXG4gICAqL1xuICBzZXRDdXJzb3JTdHlsZTogZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgdmFyIHByb3h5ID0gdGhpcy5wcm94eTtcbiAgICBwcm94eS5zZXRDdXJzb3IgJiYgcHJveHkuc2V0Q3Vyc29yKGN1cnNvclN0eWxlKTtcbiAgfSxcblxuICAvKipcbiAgICog5LqL5Lu25YiG5Y+R5Luj55CGXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRJbmZvIHt0YXJnZXQsIHRvcFRhcmdldH0g55uu5qCH5Zu+5b2i5YWD57SgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUg5LqL5Lu25ZCN56ewXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7blr7nosaFcbiAgICovXG4gIGRpc3BhdGNoVG9FbGVtZW50OiBmdW5jdGlvbiAodGFyZ2V0SW5mbywgZXZlbnROYW1lLCBldmVudCkge1xuICAgIHRhcmdldEluZm8gPSB0YXJnZXRJbmZvIHx8IHt9O1xuICAgIHZhciBlbCA9IHRhcmdldEluZm8udGFyZ2V0O1xuXG4gICAgaWYgKGVsICYmIGVsLnNpbGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBldmVudEhhbmRsZXIgPSAnb24nICsgZXZlbnROYW1lO1xuICAgIHZhciBldmVudFBhY2tldCA9IG1ha2VFdmVudFBhY2tldChldmVudE5hbWUsIHRhcmdldEluZm8sIGV2ZW50KTtcblxuICAgIHdoaWxlIChlbCkge1xuICAgICAgZWxbZXZlbnRIYW5kbGVyXSAmJiAoZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlID0gZWxbZXZlbnRIYW5kbGVyXS5jYWxsKGVsLCBldmVudFBhY2tldCkpO1xuICAgICAgZWwudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgIGVsID0gZWwucGFyZW50O1xuXG4gICAgICBpZiAoZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAvLyDlhpLms6HliLDpobbnuqcgenJlbmRlciDlr7nosaFcbiAgICAgIHRoaXMudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTsgLy8g5YiG5Y+R5LqL5Lu25Yiw55So5oi36Ieq5a6a5LmJ5bGCXG4gICAgICAvLyDnlKjmiLfmnInlj6/og73lnKjlhajlsYAgY2xpY2sg5LqL5Lu25LitIGRpc3Bvc2XvvIzmiYDku6XpnIDopoHliKTmlq3kuIsgcGFpbnRlciDmmK/lkKblrZjlnKhcblxuICAgICAgdGhpcy5wYWludGVyICYmIHRoaXMucGFpbnRlci5lYWNoT3RoZXJMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsYXllcltldmVudEhhbmRsZXJdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBsYXllcltldmVudEhhbmRsZXJdLmNhbGwobGF5ZXIsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXllci50cmlnZ2VyKSB7XG4gICAgICAgICAgbGF5ZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGV9IGV4Y2x1ZGVcbiAgICogQHJldHVybiB7bW9kZWw6enJlbmRlci9FbGVtZW50fVxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBmaW5kSG92ZXI6IGZ1bmN0aW9uICh4LCB5LCBleGNsdWRlKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTtcbiAgICB2YXIgb3V0ID0ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBob3ZlckNoZWNrUmVzdWx0O1xuXG4gICAgICBpZiAobGlzdFtpXSAhPT0gZXhjbHVkZSAvLyBnZXREaXNwbGF5TGlzdCBtYXkgaW5jbHVkZSBpZ25vcmVkIGl0ZW0gaW4gVk1MIG1vZGVcbiAgICAgICYmICFsaXN0W2ldLmlnbm9yZSAmJiAoaG92ZXJDaGVja1Jlc3VsdCA9IGlzSG92ZXIobGlzdFtpXSwgeCwgeSkpKSB7XG4gICAgICAgICFvdXQudG9wVGFyZ2V0ICYmIChvdXQudG9wVGFyZ2V0ID0gbGlzdFtpXSk7XG5cbiAgICAgICAgaWYgKGhvdmVyQ2hlY2tSZXN1bHQgIT09IFNJTEVOVCkge1xuICAgICAgICAgIG91dC50YXJnZXQgPSBsaXN0W2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxufTsgLy8gQ29tbW9uIGhhbmRsZXJzXG5cbnV0aWwuZWFjaChbJ2NsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNld2hlZWwnLCAnZGJsY2xpY2snLCAnY29udGV4dG1lbnUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgSGFuZGxlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBGaW5kIGhvdmVyIGFnYWluIHRvIGF2b2lkIGNsaWNrIGV2ZW50IGlzIGRpc3BhdGNoZWQgbWFudWFsbHkuIE9yIGNsaWNrIGlzIHRyaWdnZXJlZCB3aXRob3V0IG1vdXNlb3ZlclxuICAgIHZhciBob3ZlcmVkID0gdGhpcy5maW5kSG92ZXIoZXZlbnQuenJYLCBldmVudC56clkpO1xuICAgIHZhciBob3ZlcmVkVGFyZ2V0ID0gaG92ZXJlZC50YXJnZXQ7XG5cbiAgICBpZiAobmFtZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgIHRoaXMuX2Rvd25FbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgICB0aGlzLl9kb3duUG9pbnQgPSBbZXZlbnQuenJYLCBldmVudC56clldOyAvLyBJbiBjYXNlIGNsaWNrIHRyaWdnZXJlZCBiZWZvcmUgbW91c2V1cFxuXG4gICAgICB0aGlzLl91cEVsID0gaG92ZXJlZFRhcmdldDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdtb3N1ZXVwJykge1xuICAgICAgdGhpcy5fdXBFbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBpZiAodGhpcy5fZG93bkVsICE9PSB0aGlzLl91cEVsIC8vIE9yaWdpbmFsIGNsaWNrIGV2ZW50IGlzIHRyaWdnZXJlZCBvbiB0aGUgd2hvbGUgY2FudmFzIGVsZW1lbnQsXG4gICAgICAvLyBpbmNsdWRpbmcgdGhlIGNhc2UgdGhhdCBgbW91c2Vkb3duYCAtIGBtb3VzZW1vdmVgIC0gYG1vdXNldXBgLFxuICAgICAgLy8gd2hpY2ggc2hvdWxkIGJlIGZpbHRlcmVkLCBvdGhlcndpc2UgaXQgd2lsbCBicmluZyB0cm91YmxlIHRvXG4gICAgICAvLyBwYW4gYW5kIHpvb20uXG4gICAgICB8fCAhdGhpcy5fZG93blBvaW50IC8vIEFyYml0cmFyeSB2YWx1ZVxuICAgICAgfHwgdmVjMi5kaXN0KHRoaXMuX2Rvd25Qb2ludCwgW2V2ZW50LnpyWCwgZXZlbnQuenJZXSkgPiA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZG93blBvaW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsIG5hbWUsIGV2ZW50KTtcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBpc0hvdmVyKGRpc3BsYXlhYmxlLCB4LCB5KSB7XG4gIGlmIChkaXNwbGF5YWJsZVtkaXNwbGF5YWJsZS5yZWN0SG92ZXIgPyAncmVjdENvbnRhaW4nIDogJ2NvbnRhaW4nXSh4LCB5KSkge1xuICAgIHZhciBlbCA9IGRpc3BsYXlhYmxlO1xuICAgIHZhciBpc1NpbGVudDtcblxuICAgIHdoaWxlIChlbCkge1xuICAgICAgLy8gSWYgY2xpcHBlZCBieSBhbmNlc3Rvci5cbiAgICAgIC8vIEZJWE1FOiBJZiBjbGlwUGF0aCBoYXMgbmVpdGhlciBzdHJva2Ugbm9yIGZpbGwsXG4gICAgICAvLyBlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZS5cbiAgICAgIGlmIChlbC5jbGlwUGF0aCAmJiAhZWwuY2xpcFBhdGguY29udGFpbih4LCB5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbC5zaWxlbnQpIHtcbiAgICAgICAgaXNTaWxlbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNTaWxlbnQgPyBTSUxFTlQgOiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG51dGlsLm1peGluKEhhbmRsZXIsIEV2ZW50ZnVsKTtcbnV0aWwubWl4aW4oSGFuZGxlciwgRHJhZ2dhYmxlKTtcbnZhciBfZGVmYXVsdCA9IEhhbmRsZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9IYW5kbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIGVudiA9IHJlcXVpcmUoXCIuL2NvcmUvZW52XCIpO1xuXG52YXIgR3JvdXAgPSByZXF1aXJlKFwiLi9jb250YWluZXIvR3JvdXBcIik7XG5cbnZhciB0aW1zb3J0ID0gcmVxdWlyZShcIi4vY29yZS90aW1zb3J0XCIpO1xuXG4vKipcbiAqIFN0b3JhZ2XlhoXlrrnku5PlupPmqKHlnZdcbiAqIEBtb2R1bGUgenJlbmRlci9TdG9yYWdlXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqIEBhdXRob3IgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly9naXRodWIuY29tL3Bpc3NhbmcvKVxuICovXG4vLyBVc2UgdGltc29ydCBiZWNhdXNlIGluIG1vc3QgY2FzZSBlbGVtZW50cyBhcmUgcGFydGlhbGx5IHNvcnRlZFxuLy8gaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvcGlzc2FuZy9qcjR4N21kbS84L1xuZnVuY3Rpb24gc2hhcGVDb21wYXJlRnVuYyhhLCBiKSB7XG4gIGlmIChhLnpsZXZlbCA9PT0gYi56bGV2ZWwpIHtcbiAgICBpZiAoYS56ID09PSBiLnopIHtcbiAgICAgIC8vIGlmIChhLnoyID09PSBiLnoyKSB7XG4gICAgICAvLyAgICAgLy8gRklYTUUgU2xvdyBoYXMgcmVuZGVyaWR4IGNvbXBhcmVcbiAgICAgIC8vICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwODgzNDIxL3NvcnRpbmctaW4tamF2YXNjcmlwdC1zaG91bGQtZXZlcnktY29tcGFyZS1mdW5jdGlvbi1oYXZlLWEtcmV0dXJuLTAtc3RhdGVtZW50XG4gICAgICAvLyAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Y4L3Y4L2Jsb2IvNDdjY2U1NDRhMzFlZDU1NzdmZmUyOTYzZjY3YWNiNDE0NGVlMDIzMi9zcmMvanMvYXJyYXkuanMjTDEwMTJcbiAgICAgIC8vICAgICByZXR1cm4gYS5fX3JlbmRlcmlkeCAtIGIuX19yZW5kZXJpZHg7XG4gICAgICAvLyB9XG4gICAgICByZXR1cm4gYS56MiAtIGIuejI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEueiAtIGIuejtcbiAgfVxuXG4gIHJldHVybiBhLnpsZXZlbCAtIGIuemxldmVsO1xufVxuLyoqXG4gKiDlhoXlrrnku5PlupMgKE0pXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvU3RvcmFnZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIHRoaXMuX3Jvb3RzID0gW107XG4gIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG4gIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbn07XG5cblN0b3JhZ2UucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU3RvcmFnZSxcblxuICAvKipcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqXG4gICAqL1xuICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fcm9vdHNbaV0udHJhdmVyc2UoY2IsIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6L+U5Zue5omA5pyJ5Zu+5b2i55qE57uY5Yi26Zif5YiXXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZT1mYWxzZV0g5piv5ZCm5Zyo6L+U5Zue5YmN5pu05paw6K+l5pWw57uEXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uELCDlnKggdXBkYXRlIOS4uiB0cnVlIOeahOaXtuWAmeacieaViFxuICAgKlxuICAgKiDor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5wcm90b3R5cGUudXBkYXRlRGlzcGxheUxpc3R9XG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlPn1cbiAgICovXG4gIGdldERpc3BsYXlMaXN0OiBmdW5jdGlvbiAodXBkYXRlLCBpbmNsdWRlSWdub3JlKSB7XG4gICAgaW5jbHVkZUlnbm9yZSA9IGluY2x1ZGVJZ25vcmUgfHwgZmFsc2U7XG5cbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZURpc3BsYXlMaXN0KGluY2x1ZGVJZ25vcmUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9kaXNwbGF5TGlzdDtcbiAgfSxcblxuICAvKipcbiAgICog5pu05paw5Zu+5b2i55qE57uY5Yi26Zif5YiX44CCXG4gICAqIOavj+asoee7mOWItuWJjemDveS8muiwg+eUqO+8jOivpeaWueazleS8muWFiOa3seW6puS8mOWFiOmBjeWOhuaVtOS4quagke+8jOabtOaWsOaJgOaciUdyb3Vw5ZKMU2hhcGXnmoTlj5jmjaLlubbkuJTmiormiYDmnInlj6/op4HnmoRTaGFwZeS/neWtmOWIsOaVsOe7hOS4re+8jFxuICAgKiDmnIDlkI7moLnmja7nu5jliLbnmoTkvJjlhYjnuqfvvIh6bGV2ZWwgPiB6ID4g5o+S5YWl6aG65bqP77yJ5o6S5bqP5b6X5Yiw57uY5Yi26Zif5YiXXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uEXG4gICAqL1xuICB1cGRhdGVEaXNwbGF5TGlzdDogZnVuY3Rpb24gKGluY2x1ZGVJZ25vcmUpIHtcbiAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgdmFyIHJvb3RzID0gdGhpcy5fcm9vdHM7XG4gICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5fZGlzcGxheUxpc3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm9vdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlKHJvb3RzW2ldLCBudWxsLCBpbmNsdWRlSWdub3JlKTtcbiAgICB9XG5cbiAgICBkaXNwbGF5TGlzdC5sZW5ndGggPSB0aGlzLl9kaXNwbGF5TGlzdExlbjsgLy8gZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gICAgIGRpc3BsYXlMaXN0W2ldLl9fcmVuZGVyaWR4ID0gaTtcbiAgICAvLyB9XG4gICAgLy8gZGlzcGxheUxpc3Quc29ydChzaGFwZUNvbXBhcmVGdW5jKTtcblxuICAgIGVudi5jYW52YXNTdXBwb3J0ZWQgJiYgdGltc29ydChkaXNwbGF5TGlzdCwgc2hhcGVDb21wYXJlRnVuYyk7XG4gIH0sXG4gIF91cGRhdGVBbmRBZGREaXNwbGF5YWJsZTogZnVuY3Rpb24gKGVsLCBjbGlwUGF0aHMsIGluY2x1ZGVJZ25vcmUpIHtcbiAgICBpZiAoZWwuaWdub3JlICYmICFpbmNsdWRlSWdub3JlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWwuYmVmb3JlVXBkYXRlKCk7XG5cbiAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgZWwudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZWwuYWZ0ZXJVcGRhdGUoKTtcbiAgICB2YXIgdXNlclNldENsaXBQYXRoID0gZWwuY2xpcFBhdGg7XG5cbiAgICBpZiAodXNlclNldENsaXBQYXRoKSB7XG4gICAgICAvLyBGSVhNRSDmlYjnjoflvbHlk41cbiAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgY2xpcFBhdGhzID0gY2xpcFBhdGhzLnNsaWNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGlwUGF0aHMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRDbGlwUGF0aCA9IHVzZXJTZXRDbGlwUGF0aDtcbiAgICAgIHZhciBwYXJlbnRDbGlwUGF0aCA9IGVsOyAvLyBSZWN1cnNpdmVseSBhZGQgY2xpcCBwYXRoXG5cbiAgICAgIHdoaWxlIChjdXJyZW50Q2xpcFBhdGgpIHtcbiAgICAgICAgLy8gY2xpcFBhdGgg55qE5Y+Y5o2i5piv5Z+65LqO5L2/55So6L+Z5LiqIGNsaXBQYXRoIOeahOWFg+e0oFxuICAgICAgICBjdXJyZW50Q2xpcFBhdGgucGFyZW50ID0gcGFyZW50Q2xpcFBhdGg7XG4gICAgICAgIGN1cnJlbnRDbGlwUGF0aC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgY2xpcFBhdGhzLnB1c2goY3VycmVudENsaXBQYXRoKTtcbiAgICAgICAgcGFyZW50Q2xpcFBhdGggPSBjdXJyZW50Q2xpcFBhdGg7XG4gICAgICAgIGN1cnJlbnRDbGlwUGF0aCA9IGN1cnJlbnRDbGlwUGF0aC5jbGlwUGF0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWwuaXNHcm91cCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuX2NoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldOyAvLyBGb3JjZSB0byBtYXJrIGFzIGRpcnR5IGlmIGdyb3VwIGlzIGRpcnR5XG4gICAgICAgIC8vIEZJWE1FIF9fZGlydHlQYXRoID9cblxuICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgICAgIGNoaWxkLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlQW5kQWRkRGlzcGxheWFibGUoY2hpbGQsIGNsaXBQYXRocywgaW5jbHVkZUlnbm9yZSk7XG4gICAgICB9IC8vIE1hcmsgZ3JvdXAgY2xlYW4gaGVyZVxuXG5cbiAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuX19jbGlwUGF0aHMgPSBjbGlwUGF0aHM7XG4gICAgICB0aGlzLl9kaXNwbGF5TGlzdFt0aGlzLl9kaXNwbGF5TGlzdExlbisrXSA9IGVsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5Zu+5b2iKFNoYXBlKeaIluiAhee7hChHcm91cCnliLDmoLnoioLngrlcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgYWRkUm9vdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsLl9fc3RvcmFnZSA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICBlbC5hZGRDaGlsZHJlblRvU3RvcmFnZSh0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZFRvU3RvcmFnZShlbCk7XG5cbiAgICB0aGlzLl9yb290cy5wdXNoKGVsKTtcbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5oyH5a6a55qE5Zu+5b2iKFNoYXBlKeaIluiAhee7hChHcm91cClcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtlbF0g5aaC5p6c5Li656m65riF56m65pW05LiqU3RvcmFnZVxuICAgKi9cbiAgZGVsUm9vdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsID09IG51bGwpIHtcbiAgICAgIC8vIOS4jeaMh+WummVs5riF56m6XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdHNbaV07XG5cbiAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgIHJvb3QuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9yb290cyA9IFtdO1xuICAgICAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcbiAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5kZWxSb290KGVsW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fcm9vdHMsIGVsKTtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgdGhpcy5kZWxGcm9tU3RvcmFnZShlbCk7XG5cbiAgICAgIHRoaXMuX3Jvb3RzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBlbC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYWRkVG9TdG9yYWdlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICBlbC5fX3N0b3JhZ2UgPSB0aGlzO1xuICAgIGVsLmRpcnR5KGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGVsRnJvbVN0b3JhZ2U6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuX19zdG9yYWdlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5riF56m65bm25LiU6YeK5pS+U3RvcmFnZVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3JlbmRlckxpc3QgPSB0aGlzLl9yb290cyA9IG51bGw7XG4gIH0sXG4gIGRpc3BsYXlhYmxlU29ydEZ1bmM6IHNoYXBlQ29tcGFyZUZ1bmNcbn07XG52YXIgX2RlZmF1bHQgPSBTdG9yYWdlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvU3RvcmFnZS5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL216aWNjYXJkL25vZGUtdGltc29ydFxudmFyIERFRkFVTFRfTUlOX01FUkdFID0gMzI7XG52YXIgREVGQVVMVF9NSU5fR0FMTE9QSU5HID0gNztcbnZhciBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCA9IDI1NjtcblxuZnVuY3Rpb24gbWluUnVuTGVuZ3RoKG4pIHtcbiAgdmFyIHIgPSAwO1xuXG4gIHdoaWxlIChuID49IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgciB8PSBuICYgMTtcbiAgICBuID4+PSAxO1xuICB9XG5cbiAgcmV0dXJuIG4gKyByO1xufVxuXG5mdW5jdGlvbiBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpIHtcbiAgdmFyIHJ1bkhpID0gbG8gKyAxO1xuXG4gIGlmIChydW5IaSA9PT0gaGkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGlmIChjb21wYXJlKGFycmF5W3J1bkhpKytdLCBhcnJheVtsb10pIDwgMCkge1xuICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA8IDApIHtcbiAgICAgIHJ1bkhpKys7XG4gICAgfVxuXG4gICAgcmV2ZXJzZVJ1bihhcnJheSwgbG8sIHJ1bkhpKTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPj0gMCkge1xuICAgICAgcnVuSGkrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnVuSGkgLSBsbztcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVJ1bihhcnJheSwgbG8sIGhpKSB7XG4gIGhpLS07XG5cbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICB2YXIgdCA9IGFycmF5W2xvXTtcbiAgICBhcnJheVtsbysrXSA9IGFycmF5W2hpXTtcbiAgICBhcnJheVtoaS0tXSA9IHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBzdGFydCwgY29tcGFyZSkge1xuICBpZiAoc3RhcnQgPT09IGxvKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuXG4gIGZvciAoOyBzdGFydCA8IGhpOyBzdGFydCsrKSB7XG4gICAgdmFyIHBpdm90ID0gYXJyYXlbc3RhcnRdO1xuICAgIHZhciBsZWZ0ID0gbG87XG4gICAgdmFyIHJpZ2h0ID0gc3RhcnQ7XG4gICAgdmFyIG1pZDtcblxuICAgIHdoaWxlIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgIG1pZCA9IGxlZnQgKyByaWdodCA+Pj4gMTtcblxuICAgICAgaWYgKGNvbXBhcmUocGl2b3QsIGFycmF5W21pZF0pIDwgMCkge1xuICAgICAgICByaWdodCA9IG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuID0gc3RhcnQgLSBsZWZ0O1xuXG4gICAgc3dpdGNoIChuKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGFycmF5W2xlZnQgKyAzXSA9IGFycmF5W2xlZnQgKyAyXTtcblxuICAgICAgY2FzZSAyOlxuICAgICAgICBhcnJheVtsZWZ0ICsgMl0gPSBhcnJheVtsZWZ0ICsgMV07XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgYXJyYXlbbGVmdCArIDFdID0gYXJyYXlbbGVmdF07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgICBhcnJheVtsZWZ0ICsgbl0gPSBhcnJheVtsZWZ0ICsgbiAtIDFdO1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgYXJyYXlbbGVmdF0gPSBwaXZvdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnYWxsb3BMZWZ0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gIHZhciBtYXhPZmZzZXQgPSAwO1xuICB2YXIgb2Zmc2V0ID0gMTtcblxuICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPiAwKSB7XG4gICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPiAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICBvZmZzZXQgKz0gaGludDtcbiAgfSBlbHNlIHtcbiAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPD0gMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICBsYXN0T2Zmc2V0ID0gaGludCAtIG9mZnNldDtcbiAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICB9XG5cbiAgbGFzdE9mZnNldCsrO1xuXG4gIHdoaWxlIChsYXN0T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pID4gMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSBtO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGdhbGxvcFJpZ2h0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gIHZhciBtYXhPZmZzZXQgPSAwO1xuICB2YXIgb2Zmc2V0ID0gMTtcblxuICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPCAwKSB7XG4gICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCAtIG9mZnNldF0pIDwgMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICBsYXN0T2Zmc2V0ID0gaGludCAtIG9mZnNldDtcbiAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICB9IGVsc2Uge1xuICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCArIG9mZnNldF0pID49IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgfVxuXG4gICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgIG9mZnNldCArPSBoaW50O1xuICB9XG5cbiAgbGFzdE9mZnNldCsrO1xuXG4gIHdoaWxlIChsYXN0T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pIDwgMCkge1xuICAgICAgb2Zmc2V0ID0gbTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpIHtcbiAgdmFyIG1pbkdhbGxvcCA9IERFRkFVTFRfTUlOX0dBTExPUElORztcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciB0bXBTdG9yYWdlTGVuZ3RoID0gREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEg7XG4gIHZhciBzdGFja0xlbmd0aCA9IDA7XG4gIHZhciBydW5TdGFydDtcbiAgdmFyIHJ1bkxlbmd0aDtcbiAgdmFyIHN0YWNrU2l6ZSA9IDA7XG4gIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgMiAqIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIKSB7XG4gICAgdG1wU3RvcmFnZUxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcbiAgfVxuXG4gIHZhciB0bXAgPSBbXTtcbiAgc3RhY2tMZW5ndGggPSBsZW5ndGggPCAxMjAgPyA1IDogbGVuZ3RoIDwgMTU0MiA/IDEwIDogbGVuZ3RoIDwgMTE5MTUxID8gMTkgOiA0MDtcbiAgcnVuU3RhcnQgPSBbXTtcbiAgcnVuTGVuZ3RoID0gW107XG5cbiAgZnVuY3Rpb24gcHVzaFJ1bihfcnVuU3RhcnQsIF9ydW5MZW5ndGgpIHtcbiAgICBydW5TdGFydFtzdGFja1NpemVdID0gX3J1blN0YXJ0O1xuICAgIHJ1bkxlbmd0aFtzdGFja1NpemVdID0gX3J1bkxlbmd0aDtcbiAgICBzdGFja1NpemUgKz0gMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlUnVucygpIHtcbiAgICB3aGlsZSAoc3RhY2tTaXplID4gMSkge1xuICAgICAgdmFyIG4gPSBzdGFja1NpemUgLSAyO1xuXG4gICAgICBpZiAobiA+PSAxICYmIHJ1bkxlbmd0aFtuIC0gMV0gPD0gcnVuTGVuZ3RoW25dICsgcnVuTGVuZ3RoW24gKyAxXSB8fCBuID49IDIgJiYgcnVuTGVuZ3RoW24gLSAyXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiAtIDFdKSB7XG4gICAgICAgIGlmIChydW5MZW5ndGhbbiAtIDFdIDwgcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChydW5MZW5ndGhbbl0gPiBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBtZXJnZUF0KG4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcmNlTWVyZ2VSdW5zKCkge1xuICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgIGlmIChuID4gMCAmJiBydW5MZW5ndGhbbiAtIDFdIDwgcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICBuLS07XG4gICAgICB9XG5cbiAgICAgIG1lcmdlQXQobik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VBdChpKSB7XG4gICAgdmFyIHN0YXJ0MSA9IHJ1blN0YXJ0W2ldO1xuICAgIHZhciBsZW5ndGgxID0gcnVuTGVuZ3RoW2ldO1xuICAgIHZhciBzdGFydDIgPSBydW5TdGFydFtpICsgMV07XG4gICAgdmFyIGxlbmd0aDIgPSBydW5MZW5ndGhbaSArIDFdO1xuICAgIHJ1bkxlbmd0aFtpXSA9IGxlbmd0aDEgKyBsZW5ndGgyO1xuXG4gICAgaWYgKGkgPT09IHN0YWNrU2l6ZSAtIDMpIHtcbiAgICAgIHJ1blN0YXJ0W2kgKyAxXSA9IHJ1blN0YXJ0W2kgKyAyXTtcbiAgICAgIHJ1bkxlbmd0aFtpICsgMV0gPSBydW5MZW5ndGhbaSArIDJdO1xuICAgIH1cblxuICAgIHN0YWNrU2l6ZS0tO1xuICAgIHZhciBrID0gZ2FsbG9wUmlnaHQoYXJyYXlbc3RhcnQyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG4gICAgc3RhcnQxICs9IGs7XG4gICAgbGVuZ3RoMSAtPSBrO1xuXG4gICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZW5ndGgyID0gZ2FsbG9wTGVmdChhcnJheVtzdGFydDEgKyBsZW5ndGgxIC0gMV0sIGFycmF5LCBzdGFydDIsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aDEgPD0gbGVuZ3RoMikge1xuICAgICAgbWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZUhpZ2goc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQxICsgaV07XG4gICAgfVxuXG4gICAgdmFyIGN1cnNvcjEgPSAwO1xuICAgIHZhciBjdXJzb3IyID0gc3RhcnQyO1xuICAgIHZhciBkZXN0ID0gc3RhcnQxO1xuICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgfVxuXG4gICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG4gICAgdmFyIGNvdW50MSwgY291bnQyLCBleGl0O1xuXG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIGNvdW50MSA9IDA7XG4gICAgICBjb3VudDIgPSAwO1xuICAgICAgZXhpdCA9IGZhbHNlO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjb21wYXJlKGFycmF5W2N1cnNvcjJdLCB0bXBbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgIGNvdW50MSA9IDA7XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJheVtkZXN0KytdID0gdG1wW2N1cnNvcjErK107XG4gICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgY291bnQyID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IF9taW5HYWxsb3ApO1xuXG4gICAgICBpZiAoZXhpdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZG8ge1xuICAgICAgICBjb3VudDEgPSBnYWxsb3BSaWdodChhcnJheVtjdXJzb3IyXSwgdG1wLCBjdXJzb3IxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MTsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc3QgKz0gY291bnQxO1xuICAgICAgICAgIGN1cnNvcjEgKz0gY291bnQxO1xuICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aDEgPD0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb3VudDIgPSBnYWxsb3BMZWZ0KHRtcFtjdXJzb3IxXSwgYXJyYXksIGN1cnNvcjIsIGxlbmd0aDIsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQyOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXN0ICs9IGNvdW50MjtcbiAgICAgICAgICBjdXJzb3IyICs9IGNvdW50MjtcbiAgICAgICAgICBsZW5ndGgyIC09IGNvdW50MjtcblxuICAgICAgICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBfbWluR2FsbG9wLS07XG4gICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICBpZiAoZXhpdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKF9taW5HYWxsb3AgPCAwKSB7XG4gICAgICAgIF9taW5HYWxsb3AgPSAwO1xuICAgICAgfVxuXG4gICAgICBfbWluR2FsbG9wICs9IDI7XG4gICAgfVxuXG4gICAgbWluR2FsbG9wID0gX21pbkdhbGxvcDtcbiAgICBtaW5HYWxsb3AgPCAxICYmIChtaW5HYWxsb3AgPSAxKTtcblxuICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7IC8vIHRocm93IG5ldyBFcnJvcignbWVyZ2VMb3cgcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgIHRtcFtpXSA9IGFycmF5W3N0YXJ0MiArIGldO1xuICAgIH1cblxuICAgIHZhciBjdXJzb3IxID0gc3RhcnQxICsgbGVuZ3RoMSAtIDE7XG4gICAgdmFyIGN1cnNvcjIgPSBsZW5ndGgyIC0gMTtcbiAgICB2YXIgZGVzdCA9IHN0YXJ0MiArIGxlbmd0aDIgLSAxO1xuICAgIHZhciBjdXN0b21DdXJzb3IgPSAwO1xuICAgIHZhciBjdXN0b21EZXN0ID0gMDtcbiAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgIGRlc3QgLT0gbGVuZ3RoMTtcbiAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICB9XG5cbiAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciBjb3VudDEgPSAwO1xuICAgICAgdmFyIGNvdW50MiA9IDA7XG4gICAgICB2YXIgZXhpdCA9IGZhbHNlO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjb21wYXJlKHRtcFtjdXJzb3IyXSwgYXJyYXlbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgIGNvdW50MiA9IDA7XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG4gICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgY291bnQxID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IF9taW5HYWxsb3ApO1xuXG4gICAgICBpZiAoZXhpdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZG8ge1xuICAgICAgICBjb3VudDEgPSBsZW5ndGgxIC0gZ2FsbG9wUmlnaHQodG1wW2N1cnNvcjJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCBsZW5ndGgxIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgIGRlc3QgLT0gY291bnQxO1xuICAgICAgICAgIGN1cnNvcjEgLT0gY291bnQxO1xuICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgIGZvciAoaSA9IGNvdW50MSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY291bnQyID0gbGVuZ3RoMiAtIGdhbGxvcExlZnQoYXJyYXlbY3Vyc29yMV0sIHRtcCwgMCwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICBkZXN0IC09IGNvdW50MjtcbiAgICAgICAgICBjdXJzb3IyIC09IGNvdW50MjtcbiAgICAgICAgICBsZW5ndGgyIC09IGNvdW50MjtcbiAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMiArIDE7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQyOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IHRtcFtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGVuZ3RoMiA8PSAxKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIF9taW5HYWxsb3AtLTtcbiAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICB9XG5cbiAgICAgIF9taW5HYWxsb3AgKz0gMjtcbiAgICB9XG5cbiAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuXG4gICAgaWYgKG1pbkdhbGxvcCA8IDEpIHtcbiAgICAgIG1pbkdhbGxvcCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgIGRlc3QgLT0gbGVuZ3RoMTtcbiAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICB9XG5cbiAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7IC8vIHRocm93IG5ldyBFcnJvcignbWVyZ2VIaWdoIHByZWNvbmRpdGlvbnMgd2VyZSBub3QgcmVzcGVjdGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMubWVyZ2VSdW5zID0gbWVyZ2VSdW5zO1xuICB0aGlzLmZvcmNlTWVyZ2VSdW5zID0gZm9yY2VNZXJnZVJ1bnM7XG4gIHRoaXMucHVzaFJ1biA9IHB1c2hSdW47XG59XG5cbmZ1bmN0aW9uIHNvcnQoYXJyYXksIGNvbXBhcmUsIGxvLCBoaSkge1xuICBpZiAoIWxvKSB7XG4gICAgbG8gPSAwO1xuICB9XG5cbiAgaWYgKCFoaSkge1xuICAgIGhpID0gYXJyYXkubGVuZ3RoO1xuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IGhpIC0gbG87XG5cbiAgaWYgKHJlbWFpbmluZyA8IDIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcnVuTGVuZ3RoID0gMDtcblxuICBpZiAocmVtYWluaW5nIDwgREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0cyA9IG5ldyBUaW1Tb3J0KGFycmF5LCBjb21wYXJlKTtcbiAgdmFyIG1pblJ1biA9IG1pblJ1bkxlbmd0aChyZW1haW5pbmcpO1xuXG4gIGRvIHtcbiAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuXG4gICAgaWYgKHJ1bkxlbmd0aCA8IG1pblJ1bikge1xuICAgICAgdmFyIGZvcmNlID0gcmVtYWluaW5nO1xuXG4gICAgICBpZiAoZm9yY2UgPiBtaW5SdW4pIHtcbiAgICAgICAgZm9yY2UgPSBtaW5SdW47XG4gICAgICB9XG5cbiAgICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBsbyArIGZvcmNlLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgICBydW5MZW5ndGggPSBmb3JjZTtcbiAgICB9XG5cbiAgICB0cy5wdXNoUnVuKGxvLCBydW5MZW5ndGgpO1xuICAgIHRzLm1lcmdlUnVucygpO1xuICAgIHJlbWFpbmluZyAtPSBydW5MZW5ndGg7XG4gICAgbG8gKz0gcnVuTGVuZ3RoO1xuICB9IHdoaWxlIChyZW1haW5pbmcgIT09IDApO1xuXG4gIHRzLmZvcmNlTWVyZ2VSdW5zKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc29ydDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS90aW1zb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcblxudmFyIGRldmljZVBpeGVsUmF0aW8gPSBfY29uZmlnLmRldmljZVBpeGVsUmF0aW87XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG52YXIgbG9nID0gcmVxdWlyZShcIi4vY29yZS9sb2dcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxudmFyIHRpbXNvcnQgPSByZXF1aXJlKFwiLi9jb3JlL3RpbXNvcnRcIik7XG5cbnZhciBMYXllciA9IHJlcXVpcmUoXCIuL0xheWVyXCIpO1xuXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZShcIi4vYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZVwiKTtcblxudmFyIEltYWdlID0gcmVxdWlyZShcIi4vZ3JhcGhpYy9JbWFnZVwiKTtcblxuLyoqXG4gKiBEZWZhdWx0IGNhbnZhcyBwYWludGVyXG4gKiBAbW9kdWxlIHpyZW5kZXIvUGFpbnRlclxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiAgICAgICAgIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gUEVORElHTlxuLy8gTGF5ZXIgZXhjZWVkcyBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIG1heSBoYXZlIHNvbWUgcHJvYmxlbSB3aGVuIGZsdXNoIGRpcmVjdGx5IHNlY29uZCB0aW1lLlxuLy9cbi8vIE1heGltdW0gcHJvZ3Jlc3NpdmUgbGF5ZXIuIFdoZW4gZXhjZWVkaW5nIHRoaXMgbnVtYmVyLiBBbGwgZWxlbWVudHMgd2lsbCBiZSBkcmF3ZWQgaW4gdGhlIGxhc3QgbGF5ZXIuXG52YXIgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiA9IDU7XG5cbmZ1bmN0aW9uIHBhcnNlSW50MTAodmFsKSB7XG4gIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNMYXllclZhbGlkKGxheWVyKSB7XG4gIGlmICghbGF5ZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobGF5ZXIuX19idWlsdGluX18pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbGF5ZXIucmVzaXplICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBsYXllci5yZWZyZXNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHByZVByb2Nlc3NMYXllcihsYXllcikge1xuICBsYXllci5fX3VudXNlZENvdW50Kys7XG59XG5cbmZ1bmN0aW9uIHBvc3RQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgaWYgKGxheWVyLl9fdW51c2VkQ291bnQgPT0gMSkge1xuICAgIGxheWVyLmNsZWFyKCk7XG4gIH1cbn1cblxudmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xudmFyIHZpZXdSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcblxuZnVuY3Rpb24gaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgd2lkdGgsIGhlaWdodCkge1xuICB0bXBSZWN0LmNvcHkoZWwuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuXG4gIGlmIChlbC50cmFuc2Zvcm0pIHtcbiAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSk7XG4gIH1cblxuICB2aWV3UmVjdC53aWR0aCA9IHdpZHRoO1xuICB2aWV3UmVjdC5oZWlnaHQgPSBoZWlnaHQ7XG4gIHJldHVybiAhdG1wUmVjdC5pbnRlcnNlY3Qodmlld1JlY3QpO1xufVxuXG5mdW5jdGlvbiBpc0NsaXBQYXRoQ2hhbmdlZChjbGlwUGF0aHMsIHByZXZDbGlwUGF0aHMpIHtcbiAgaWYgKGNsaXBQYXRocyA9PSBwcmV2Q2xpcFBhdGhzKSB7XG4gICAgLy8gQ2FuIGJvdGggYmUgbnVsbCBvciB1bmRlZmluZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWNsaXBQYXRocyB8fCAhcHJldkNsaXBQYXRocyB8fCBjbGlwUGF0aHMubGVuZ3RoICE9PSBwcmV2Q2xpcFBhdGhzLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY2xpcFBhdGhzW2ldICE9PSBwcmV2Q2xpcFBhdGhzW2ldKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZG9DbGlwKGNsaXBQYXRocywgY3R4KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzW2ldO1xuICAgIGNsaXBQYXRoLnNldFRyYW5zZm9ybShjdHgpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjbGlwUGF0aC5idWlsZFBhdGgoY3R4LCBjbGlwUGF0aC5zaGFwZSk7XG4gICAgY3R4LmNsaXAoKTsgLy8gVHJhbnNmb3JtIGJhY2tcblxuICAgIGNsaXBQYXRoLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSb290KHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIGRvbVJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsgLy8gZG9tUm9vdC5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuXG4gIGRvbVJvb3Quc3R5bGUuY3NzVGV4dCA9IFsncG9zaXRpb246cmVsYXRpdmUnLCAnb3ZlcmZsb3c6aGlkZGVuJywgJ3dpZHRoOicgKyB3aWR0aCArICdweCcsICdoZWlnaHQ6JyArIGhlaWdodCArICdweCcsICdwYWRkaW5nOjAnLCAnbWFyZ2luOjAnLCAnYm9yZGVyLXdpZHRoOjAnXS5qb2luKCc7JykgKyAnOyc7XG4gIHJldHVybiBkb21Sb290O1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvUGFpbnRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290IOe7mOWbvuWuueWZqFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfSBzdG9yYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5cblxudmFyIFBhaW50ZXIgPSBmdW5jdGlvbiAocm9vdCwgc3RvcmFnZSwgb3B0cykge1xuICB0aGlzLnR5cGUgPSAnY2FudmFzJzsgLy8gSW4gbm9kZSBlbnZpcm9ubWVudCB1c2luZyBub2RlLWNhbnZhc1xuXG4gIHZhciBzaW5nbGVDYW52YXMgPSAhcm9vdC5ub2RlTmFtZSAvLyBJbiBub2RlID9cbiAgfHwgcm9vdC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQ0FOVkFTJztcbiAgdGhpcy5fb3B0cyA9IG9wdHMgPSB1dGlsLmV4dGVuZCh7fSwgb3B0cyB8fCB7fSk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLmRwciA9IG9wdHMuZGV2aWNlUGl4ZWxSYXRpbyB8fCBkZXZpY2VQaXhlbFJhdGlvO1xuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX3NpbmdsZUNhbnZhcyA9IHNpbmdsZUNhbnZhcztcbiAgLyoqXG4gICAqIOe7mOWbvuWuueWZqFxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqL1xuXG4gIHRoaXMucm9vdCA9IHJvb3Q7XG4gIHZhciByb290U3R5bGUgPSByb290LnN0eWxlO1xuXG4gIGlmIChyb290U3R5bGUpIHtcbiAgICByb290U3R5bGVbJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvciddID0gJ3RyYW5zcGFyZW50JztcbiAgICByb290U3R5bGVbJy13ZWJraXQtdXNlci1zZWxlY3QnXSA9IHJvb3RTdHlsZVsndXNlci1zZWxlY3QnXSA9IHJvb3RTdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSAnbm9uZSc7XG4gICAgcm9vdC5pbm5lckhUTUwgPSAnJztcbiAgfVxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9XG4gICAqL1xuXG5cbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0ID0gW107XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp6cmVuZGVyL0xheWVyPn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycyA9IHt9O1xuICAvKipcbiAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBPYmplY3Q+fVxuICAgKiBAdHlwZSB7cHJpdmF0ZX1cbiAgICovXG5cbiAgdGhpcy5fbGF5ZXJDb25maWcgPSB7fTtcblxuICBpZiAoIXNpbmdsZUNhbnZhcykge1xuICAgIHRoaXMuX3dpZHRoID0gdGhpcy5fZ2V0U2l6ZSgwKTtcbiAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLl9nZXRTaXplKDEpO1xuICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdCA9IGNyZWF0ZVJvb3QodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChkb21Sb290KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob3B0cy53aWR0aCAhPSBudWxsKSB7XG4gICAgICByb290LndpZHRoID0gb3B0cy53aWR0aDtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgcm9vdC5oZWlnaHQgPSBvcHRzLmhlaWdodDtcbiAgICB9IC8vIFVzZSBjYW52YXMgd2lkdGggYW5kIGhlaWdodCBkaXJlY3RseVxuXG5cbiAgICB2YXIgd2lkdGggPSByb290LndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSByb290LmhlaWdodDtcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDsgLy8gQ3JlYXRlIGxheWVyIGlmIG9ubHkgb25lIGdpdmVuIGNhbnZhc1xuICAgIC8vIERldmljZSBwaXhlbCByYXRpbyBpcyBmaXhlZCB0byAxIGJlY2F1c2UgZ2l2ZW4gY2FudmFzIGhhcyBpdHMgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHRcblxuICAgIHZhciBtYWluTGF5ZXIgPSBuZXcgTGF5ZXIocm9vdCwgdGhpcywgMSk7XG4gICAgbWFpbkxheWVyLmluaXRDb250ZXh0KCk7IC8vIEZJWE1FIFVzZSBjYW52YXMgd2lkdGggYW5kIGhlaWdodFxuICAgIC8vIG1haW5MYXllci5yZXNpemUod2lkdGgsIGhlaWdodCk7XG5cbiAgICBsYXllcnNbMF0gPSBtYWluTGF5ZXI7XG4gICAgemxldmVsTGlzdC5wdXNoKDApO1xuICAgIHRoaXMuX2RvbVJvb3QgPSByb290O1xuICB9IC8vIExheWVycyBmb3IgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nXG5cblxuICB0aGlzLl9wcm9ncmVzc2l2ZUxheWVycyA9IFtdO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL0xheWVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9ob3ZlcmxheWVyO1xuICB0aGlzLl9ob3ZlckVsZW1lbnRzID0gW107XG59O1xuXG5QYWludGVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFBhaW50ZXIsXG4gIGdldFR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ2NhbnZhcyc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIHBhaW50ZXIgdXNlIGEgc2luZ2xlIGNhbnZhc1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNTaW5nbGVDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2luZ2xlQ2FudmFzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRGl2RWxlbWVudH1cbiAgICovXG4gIGdldFZpZXdwb3J0Um9vdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9kb21Sb290O1xuICB9LFxuICBnZXRWaWV3cG9ydFJvb3RPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmlld3BvcnRSb290ID0gdGhpcy5nZXRWaWV3cG9ydFJvb3QoKTtcblxuICAgIGlmICh2aWV3cG9ydFJvb3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9mZnNldExlZnQ6IHZpZXdwb3J0Um9vdC5vZmZzZXRMZWZ0IHx8IDAsXG4gICAgICAgIG9mZnNldFRvcDogdmlld3BvcnRSb290Lm9mZnNldFRvcCB8fCAwXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yi35pawXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhaW50QWxsPWZhbHNlXSDlvLrliLbnu5jliLbmiYDmnIlkaXNwbGF5YWJsZVxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gKHBhaW50QWxsKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSk7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuXG4gICAgdGhpcy5fcGFpbnRMaXN0KGxpc3QsIHBhaW50QWxsKTsgLy8gUGFpbnQgY3VzdHVtIGxheWVyc1xuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcblxuICAgICAgaWYgKCFsYXllci5fX2J1aWx0aW5fXyAmJiBsYXllci5yZWZyZXNoKSB7XG4gICAgICAgIGxheWVyLnJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuXG4gICAgaWYgKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fc3RhcnRQcm9nZXNzaXZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIGhvdmVyU3R5bGUpIHtcbiAgICBpZiAoZWwuX19ob3Zlck1pcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbE1pcnJvciA9IG5ldyBlbC5jb25zdHJ1Y3Rvcih7XG4gICAgICBzdHlsZTogZWwuc3R5bGUsXG4gICAgICBzaGFwZTogZWwuc2hhcGVcbiAgICB9KTtcbiAgICBlbE1pcnJvci5fX2Zyb20gPSBlbDtcbiAgICBlbC5fX2hvdmVyTWlyID0gZWxNaXJyb3I7XG4gICAgZWxNaXJyb3Iuc2V0U3R5bGUoaG92ZXJTdHlsZSk7XG5cbiAgICB0aGlzLl9ob3ZlckVsZW1lbnRzLnB1c2goZWxNaXJyb3IpO1xuICB9LFxuICByZW1vdmVIb3ZlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgdmFyIGVsTWlycm9yID0gZWwuX19ob3Zlck1pcjtcbiAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZihob3ZlckVsZW1lbnRzLCBlbE1pcnJvcik7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGhvdmVyRWxlbWVudHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuXG4gICAgZWwuX19ob3Zlck1pciA9IG51bGw7XG4gIH0sXG4gIGNsZWFySG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG92ZXJFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZyb20gPSBob3ZlckVsZW1lbnRzW2ldLl9fZnJvbTtcblxuICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgZnJvbS5fX2hvdmVyTWlyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBob3ZlckVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gIH0sXG4gIHJlZnJlc2hIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICB2YXIgbGVuID0gaG92ZXJFbGVtZW50cy5sZW5ndGg7XG4gICAgdmFyIGhvdmVyTGF5ZXIgPSB0aGlzLl9ob3ZlcmxheWVyO1xuICAgIGhvdmVyTGF5ZXIgJiYgaG92ZXJMYXllci5jbGVhcigpO1xuXG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1zb3J0KGhvdmVyRWxlbWVudHMsIHRoaXMuc3RvcmFnZS5kaXNwbGF5YWJsZVNvcnRGdW5jKTsgLy8gVXNlIGEgZXh0cmVhbSBsYXJnZSB6bGV2ZWxcbiAgICAvLyBGSVhNRT9cblxuICAgIGlmICghaG92ZXJMYXllcikge1xuICAgICAgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXIgPSB0aGlzLmdldExheWVyKDFlNSk7XG4gICAgfVxuXG4gICAgdmFyIHNjb3BlID0ge307XG4gICAgaG92ZXJMYXllci5jdHguc2F2ZSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICB2YXIgZWwgPSBob3ZlckVsZW1lbnRzW2ldO1xuICAgICAgdmFyIG9yaWdpbmFsRWwgPSBlbC5fX2Zyb207IC8vIE9yaWdpbmFsIGVsIGlzIHJlbW92ZWRcbiAgICAgIC8vIFBFTkRJTkdcblxuICAgICAgaWYgKCEob3JpZ2luYWxFbCAmJiBvcmlnaW5hbEVsLl9fenIpKSB7XG4gICAgICAgIGhvdmVyRWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICBvcmlnaW5hbEVsLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICBsZW4tLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGkrKzsgLy8gVXNlIHRyYW5zZm9ybVxuICAgICAgLy8gRklYTUUgc3R5bGUgYW5kIHNoYXBlID9cblxuICAgICAgaWYgKCFvcmlnaW5hbEVsLmludmlzaWJsZSkge1xuICAgICAgICBlbC50cmFuc2Zvcm0gPSBvcmlnaW5hbEVsLnRyYW5zZm9ybTtcbiAgICAgICAgZWwuaW52VHJhbnNmb3JtID0gb3JpZ2luYWxFbC5pbnZUcmFuc2Zvcm07XG4gICAgICAgIGVsLl9fY2xpcFBhdGhzID0gb3JpZ2luYWxFbC5fX2NsaXBQYXRoczsgLy8gZWwuXG5cbiAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBob3ZlckxheWVyLCB0cnVlLCBzY29wZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaG92ZXJMYXllci5jdHgucmVzdG9yZSgpO1xuICB9LFxuICBfc3RhcnRQcm9nZXNzaXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCFzZWxmLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFVzZSBhIHRva2VuIHRvIHN0b3AgcHJvZ3Jlc3Mgc3RlcHMgdHJpZ2dlcmVkIGJ5XG4gICAgLy8gcHJldmlvdXMgenIucmVmcmVzaCBjYWxsaW5nLlxuXG5cbiAgICB2YXIgdG9rZW4gPSBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuID0gK25ldyBEYXRlKCk7XG4gICAgc2VsZi5fcHJvZ3Jlc3MrKztcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG5cbiAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgLy8gSW4gY2FzZSByZWZyZXNoZWQgb3IgZGlzcG9zZWRcbiAgICAgIGlmICh0b2tlbiA9PT0gc2VsZi5fcHJvZ3Jlc3NpdmVUb2tlbiAmJiBzZWxmLnN0b3JhZ2UpIHtcbiAgICAgICAgc2VsZi5fZG9QYWludExpc3Qoc2VsZi5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCkpO1xuXG4gICAgICAgIGlmIChzZWxmLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUpIHtcbiAgICAgICAgICBzZWxmLl9wcm9ncmVzcysrO1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIF9jbGVhclByb2dyZXNzaXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVUb2tlbiA9IC0xO1xuICAgIHRoaXMuX3Byb2dyZXNzID0gMDtcbiAgICB1dGlsLmVhY2godGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgbGF5ZXIuX19kaXJ0eSAmJiBsYXllci5jbGVhcigpO1xuICAgIH0pO1xuICB9LFxuICBfcGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCwgcGFpbnRBbGwpIHtcbiAgICBpZiAocGFpbnRBbGwgPT0gbnVsbCkge1xuICAgICAgcGFpbnRBbGwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVMYXllclN0YXR1cyhsaXN0KTtcblxuICAgIHRoaXMuX2NsZWFyUHJvZ3Jlc3NpdmUoKTtcblxuICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcihwcmVQcm9jZXNzTGF5ZXIpO1xuXG4gICAgdGhpcy5fZG9QYWludExpc3QobGlzdCwgcGFpbnRBbGwpO1xuXG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHBvc3RQcm9jZXNzTGF5ZXIpO1xuICB9LFxuICBfZG9QYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBwYWludEFsbCkge1xuICAgIHZhciBjdXJyZW50TGF5ZXI7XG4gICAgdmFyIGN1cnJlbnRaTGV2ZWw7XG4gICAgdmFyIGN0eDsgLy8gdmFyIGludlRyYW5zZm9ybSA9IFtdO1xuXG4gICAgdmFyIHNjb3BlO1xuICAgIHZhciBwcm9ncmVzc2l2ZUxheWVySWR4ID0gMDtcbiAgICB2YXIgY3VycmVudFByb2dyZXNzaXZlTGF5ZXI7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICB2YXIgbGF5ZXJQcm9ncmVzcztcbiAgICB2YXIgZnJhbWUgPSB0aGlzLl9wcm9ncmVzcztcblxuICAgIGZ1bmN0aW9uIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihsYXllcikge1xuICAgICAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwOyAvLyBBdm9pZCBsYXllciBkb24ndCBjbGVhciBpbiBuZXh0IHByb2dyZXNzaXZlIGZyYW1lXG5cbiAgICAgIGN1cnJlbnRMYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICBjdHguZHJhd0ltYWdlKGxheWVyLmRvbSwgMCwgMCwgd2lkdGggKiBkcHIsIGhlaWdodCAqIGRwcik7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBlbCA9IGxpc3RbaV07XG4gICAgICB2YXIgZWxaTGV2ZWwgPSB0aGlzLl9zaW5nbGVDYW52YXMgPyAwIDogZWwuemxldmVsO1xuICAgICAgdmFyIGVsRnJhbWUgPSBlbC5fX2ZyYW1lOyAvLyBGbHVzaCBhdCBjdXJyZW50IGNvbnRleHRcbiAgICAgIC8vIFBFTkRJTkdcblxuICAgICAgaWYgKGVsRnJhbWUgPCAwICYmIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgIH0gLy8gQ2hhbmdlIGRyYXcgbGF5ZXJcblxuXG4gICAgICBpZiAoY3VycmVudFpMZXZlbCAhPT0gZWxaTGV2ZWwpIHtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH0gLy8gUmVzZXQgc2NvcGVcblxuXG4gICAgICAgIHNjb3BlID0ge307IC8vIE9ubHkgMCB6bGV2ZWwgaWYgb25seSBoYXMgb25lIGNhbnZhc1xuXG4gICAgICAgIGN1cnJlbnRaTGV2ZWwgPSBlbFpMZXZlbDtcbiAgICAgICAgY3VycmVudExheWVyID0gdGhpcy5nZXRMYXllcihjdXJyZW50WkxldmVsKTtcblxuICAgICAgICBpZiAoIWN1cnJlbnRMYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICAgIGxvZygnWkxldmVsICcgKyBjdXJyZW50WkxldmVsICsgJyBoYXMgYmVlbiB1c2VkIGJ5IHVua293biBsYXllciAnICsgY3VycmVudExheWVyLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eCA9IGN1cnJlbnRMYXllci5jdHg7XG4gICAgICAgIGN0eC5zYXZlKCk7IC8vIFJlc2V0IHRoZSBjb3VudFxuXG4gICAgICAgIGN1cnJlbnRMYXllci5fX3VudXNlZENvdW50ID0gMDtcblxuICAgICAgICBpZiAoY3VycmVudExheWVyLl9fZGlydHkgfHwgcGFpbnRBbGwpIHtcbiAgICAgICAgICBjdXJyZW50TGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIShjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBwYWludEFsbCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbEZyYW1lID49IDApIHtcbiAgICAgICAgLy8gUHJvZ3Jlc3NpdmUgbGF5ZXIgY2hhbmdlZFxuICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSB0aGlzLl9wcm9ncmVzc2l2ZUxheWVyc1tNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVySWR4KyssIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgLSAxKV07XG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuY3R4LnNhdmUoKTtcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5yZW5kZXJTY29wZSA9IHt9O1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyICYmIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPiBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzKSB7XG4gICAgICAgICAgICAvLyBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgICAgICAgICAgLy8gUXVpY2sganVtcCBhbGwgcHJvZ3Jlc3NpdmUgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIEFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50IGFyZSBub3QgZGlydHksIGp1bXAgb3ZlciBhbmQgZmx1c2ggZGlyZWN0bHlcbiAgICAgICAgICAgIGkgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nIC0gMTsgLy8gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsYXllclByb2dyZXNzID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcztcblxuICAgICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSkge1xuICAgICAgICAgICAgLy8gS2VlcCByZW5kZXJpbmdcbiAgICAgICAgICAgIGZyYW1lID0gbGF5ZXJQcm9ncmVzcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzID0gZnJhbWUgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsRnJhbWUgPT09IGZyYW1lKSB7XG4gICAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciwgdHJ1ZSwgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIucmVuZGVyU2NvcGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGN1cnJlbnRMYXllciwgcGFpbnRBbGwsIHNjb3BlKTtcbiAgICAgIH1cblxuICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICB9IC8vIFJlc3RvcmUgdGhlIGxhc3RMYXllciBjdHhcblxuXG4gICAgY3R4ICYmIGN0eC5yZXN0b3JlKCk7IC8vIElmIHN0aWxsIGhhcyBjbGlwcGluZyBzdGF0ZVxuICAgIC8vIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAvLyAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAvLyB9XG5cbiAgICB0aGlzLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUgPSBmYWxzZTtcbiAgICB1dGlsLmVhY2godGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgaWYgKGxheWVyLl9fbWF4UHJvZ3Jlc3MgPj0gbGF5ZXIuX19wcm9ncmVzcykge1xuICAgICAgICB0aGlzLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9LFxuICBfZG9QYWludEVsOiBmdW5jdGlvbiAoZWwsIGN1cnJlbnRMYXllciwgZm9yY2VQYWludCwgc2NvcGUpIHtcbiAgICB2YXIgY3R4ID0gY3VycmVudExheWVyLmN0eDtcbiAgICB2YXIgbSA9IGVsLnRyYW5zZm9ybTtcblxuICAgIGlmICgoY3VycmVudExheWVyLl9fZGlydHkgfHwgZm9yY2VQYWludCkgJiYgLy8gSWdub3JlIGludmlzaWJsZSBlbGVtZW50XG4gICAgIWVsLmludmlzaWJsZSAvLyBJZ25vcmUgdHJhbnNwYXJlbnQgZWxlbWVudFxuICAgICYmIGVsLnN0eWxlLm9wYWNpdHkgIT09IDAgLy8gSWdub3JlIHNjYWxlIDAgZWxlbWVudCwgaW4gc29tZSBlbnZpcm9ubWVudCBsaWtlIG5vZGUtY2FudmFzXG4gICAgLy8gRHJhdyBhIHNjYWxlIDAgZWxlbWVudCBjYW4gY2F1c2UgYWxsIGZvbGxvd2luZyBkcmF3IHdyb25nXG4gICAgLy8gQW5kIHNldFRyYW5zZm9ybSB3aXRoIHNjYWxlIDAgd2lsbCBjYXVzZSBzZXQgYmFjayB0cmFuc2Zvcm0gZmFpbGVkLlxuICAgICYmICEobSAmJiAhbVswXSAmJiAhbVszXSkgLy8gSWdub3JlIGN1bGxlZCBlbGVtZW50XG4gICAgJiYgIShlbC5jdWxsaW5nICYmIGlzRGlzcGxheWFibGVDdWxsZWQoZWwsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpKSkge1xuICAgICAgdmFyIGNsaXBQYXRocyA9IGVsLl9fY2xpcFBhdGhzOyAvLyBPcHRpbWl6ZSB3aGVuIGNsaXBwaW5nIG9uIGdyb3VwIHdpdGggc2V2ZXJhbCBlbGVtZW50c1xuXG4gICAgICBpZiAoc2NvcGUucHJldkNsaXBMYXllciAhPT0gY3VycmVudExheWVyIHx8IGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgc2NvcGUucHJldkVsQ2xpcFBhdGhzKSkge1xuICAgICAgICAvLyBJZiBoYXMgcHJldmlvdXMgY2xpcHBpbmcgc3RhdGUsIHJlc3RvcmUgZnJvbSBpdFxuICAgICAgICBpZiAoc2NvcGUucHJldkVsQ2xpcFBhdGhzKSB7XG4gICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgICAgIHNjb3BlLnByZXZDbGlwTGF5ZXIgPSBzY29wZS5wcmV2RWxDbGlwUGF0aHMgPSBudWxsOyAvLyBSZXNldCBwcmV2RWwgc2luY2UgY29udGV4dCBoYXMgYmVlbiByZXN0b3JlZFxuXG4gICAgICAgICAgc2NvcGUucHJldkVsID0gbnVsbDtcbiAgICAgICAgfSAvLyBOZXcgY2xpcHBpbmcgc3RhdGVcblxuXG4gICAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCk7XG4gICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IGN1cnJlbnRMYXllcjtcbiAgICAgICAgICBzY29wZS5wcmV2RWxDbGlwUGF0aHMgPSBjbGlwUGF0aHM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWwuYmVmb3JlQnJ1c2ggJiYgZWwuYmVmb3JlQnJ1c2goY3R4KTtcbiAgICAgIGVsLmJydXNoKGN0eCwgc2NvcGUucHJldkVsIHx8IG51bGwpO1xuICAgICAgc2NvcGUucHJldkVsID0gZWw7XG4gICAgICBlbC5hZnRlckJydXNoICYmIGVsLmFmdGVyQnJ1c2goY3R4KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPliB6bGV2ZWwg5omA5Zyo5bGC77yM5aaC5p6c5LiN5a2Y5Zyo5YiZ5Lya5Yib5bu65LiA5Liq5paw55qE5bGCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAqL1xuICBnZXRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgIGlmICh0aGlzLl9zaW5nbGVDYW52YXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbMF07XG4gICAgfVxuXG4gICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG5cbiAgICBpZiAoIWxheWVyKSB7XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgbGF5ZXJcbiAgICAgIGxheWVyID0gbmV3IExheWVyKCd6cl8nICsgemxldmVsLCB0aGlzLCB0aGlzLmRwcik7XG4gICAgICBsYXllci5fX2J1aWx0aW5fXyA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLl9sYXllckNvbmZpZ1t6bGV2ZWxdKSB7XG4gICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluc2VydExheWVyKHpsZXZlbCwgbGF5ZXIpOyAvLyBDb250ZXh0IGlzIGNyZWF0ZWQgYWZ0ZXIgZG9tIGluc2VydGVkIHRvIGRvY3VtZW50XG4gICAgICAvLyBPciBleGNhbnZhcyB3aWxsIGdldCAwcHggY2xpZW50V2lkdGggYW5kIGNsaWVudEhlaWdodFxuXG4gICAgICBsYXllci5pbml0Q29udGV4dCgpO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllcjtcbiAgfSxcbiAgaW5zZXJ0TGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwsIGxheWVyKSB7XG4gICAgdmFyIGxheWVyc01hcCA9IHRoaXMuX2xheWVycztcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdmFyIGxlbiA9IHpsZXZlbExpc3QubGVuZ3RoO1xuICAgIHZhciBwcmV2TGF5ZXIgPSBudWxsO1xuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290O1xuXG4gICAgaWYgKGxheWVyc01hcFt6bGV2ZWxdKSB7XG4gICAgICBsb2coJ1pMZXZlbCAnICsgemxldmVsICsgJyBoYXMgYmVlbiB1c2VkIGFscmVhZHknKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENoZWNrIGlmIGlzIGEgdmFsaWQgbGF5ZXJcblxuXG4gICAgaWYgKCFpc0xheWVyVmFsaWQobGF5ZXIpKSB7XG4gICAgICBsb2coJ0xheWVyIG9mIHpsZXZlbCAnICsgemxldmVsICsgJyBpcyBub3QgdmFsaWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuID4gMCAmJiB6bGV2ZWwgPiB6bGV2ZWxMaXN0WzBdKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmICh6bGV2ZWxMaXN0W2ldIDwgemxldmVsICYmIHpsZXZlbExpc3RbaSArIDFdID4gemxldmVsKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldkxheWVyID0gbGF5ZXJzTWFwW3psZXZlbExpc3RbaV1dO1xuICAgIH1cblxuICAgIHpsZXZlbExpc3Quc3BsaWNlKGkgKyAxLCAwLCB6bGV2ZWwpO1xuICAgIGxheWVyc01hcFt6bGV2ZWxdID0gbGF5ZXI7IC8vIFZpdHVhbCBsYXllciB3aWxsIG5vdCBkaXJlY3RseSBzaG93IG9uIHRoZSBzY3JlZW4uXG4gICAgLy8gKEl0IGNhbiBiZSBhIFdlYkdMIGxheWVyIGFuZCBhc3NpZ25lZCB0byBhIFpJbWFnZSBlbGVtZW50KVxuICAgIC8vIEJ1dCBpdCBzdGlsbCB1bmRlciBtYW5hZ2VtZW50IG9mIHpyZW5kZXIuXG5cbiAgICBpZiAoIWxheWVyLnZpcnR1YWwpIHtcbiAgICAgIGlmIChwcmV2TGF5ZXIpIHtcbiAgICAgICAgdmFyIHByZXZEb20gPSBwcmV2TGF5ZXIuZG9tO1xuXG4gICAgICAgIGlmIChwcmV2RG9tLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUobGF5ZXIuZG9tLCBwcmV2RG9tLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkb21Sb290LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBkb21Sb290Lmluc2VydEJlZm9yZShsYXllci5kb20sIGRvbVJvb3QuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tUm9vdC5hcHBlbmRDaGlsZChsYXllci5kb20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyBJdGVyYXRlIGVhY2ggbGF5ZXJcbiAgZWFjaExheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdmFyIHo7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1t6XSwgeik7XG4gICAgfVxuICB9LFxuICAvLyBJdGVyYXRlIGVhY2ggYnVpbGRpbiBsYXllclxuICBlYWNoQnVpbHRpbkxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdmFyIGxheWVyO1xuICAgIHZhciB6O1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG5cbiAgICAgIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGxheWVyLCB6KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBvdGhlciBsYXllciBleGNlcHQgYnVpbGRpbiBsYXllclxuICBlYWNoT3RoZXJMYXllcjogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHZhciBsYXllcjtcbiAgICB2YXIgejtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuXG4gICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgbGF5ZXIsIHopO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W5omA5pyJ5bey5Yib5bu655qE5bGCXG4gICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0xheWVyPn0gW3ByZXZMYXllcl1cbiAgICovXG4gIGdldExheWVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9sYXllcnM7XG4gIH0sXG4gIF91cGRhdGVMYXllclN0YXR1czogZnVuY3Rpb24gKGxpc3QpIHtcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgIHZhciBwcm9ncmVzc2l2ZUxheWVycyA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzO1xuICAgIHZhciBlbENvdW50c0xhc3RGcmFtZSA9IHt9O1xuICAgIHZhciBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lID0ge307XG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKGZ1bmN0aW9uIChsYXllciwgeikge1xuICAgICAgZWxDb3VudHNMYXN0RnJhbWVbel0gPSBsYXllci5lbENvdW50O1xuICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICBsYXllci5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfSk7XG4gICAgdXRpbC5lYWNoKHByb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIsIGlkeCkge1xuICAgICAgcHJvZ3Jlc3NpdmVFbENvdW50c0xhc3RGcmFtZVtpZHhdID0gbGF5ZXIuZWxDb3VudDtcbiAgICAgIGxheWVyLmVsQ291bnQgPSAwO1xuICAgICAgbGF5ZXIuX19kaXJ0eSA9IGZhbHNlO1xuICAgIH0pO1xuICAgIHZhciBwcm9ncmVzc2l2ZUxheWVyQ291bnQgPSAwO1xuICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcbiAgICB2YXIgbGFzdFByb2dyZXNzaXZlS2V5O1xuICAgIHZhciBmcmFtZUNvdW50ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBlbCA9IGxpc3RbaV07XG4gICAgICB2YXIgemxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuICAgICAgdmFyIGVsUHJvZ3Jlc3MgPSBlbC5wcm9ncmVzc2l2ZTtcblxuICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgIGxheWVyLmVsQ291bnQrKztcbiAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IGxheWVyLl9fZGlydHkgfHwgZWwuX19kaXJ0eTtcbiAgICAgIH0gLy8vLy8vLyBVcGRhdGUgcHJvZ3Jlc3NpdmVcblxuXG4gICAgICBpZiAoZWxQcm9ncmVzcyA+PSAwKSB7XG4gICAgICAgIC8vIEZpeCB3cm9uZyBwcm9ncmVzc2l2ZSBzZXF1ZW5jZSBwcm9ibGVtLlxuICAgICAgICBpZiAobGFzdFByb2dyZXNzaXZlS2V5ICE9PSBlbFByb2dyZXNzKSB7XG4gICAgICAgICAgbGFzdFByb2dyZXNzaXZlS2V5ID0gZWxQcm9ncmVzcztcbiAgICAgICAgICBmcmFtZUNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxGcmFtZSA9IGVsLl9fZnJhbWUgPSBmcmFtZUNvdW50IC0gMTtcblxuICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgdmFyIGlkeCA9IE1hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJDb3VudCwgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiAtIDEpO1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gcHJvZ3Jlc3NpdmVMYXllcnNbaWR4XTtcblxuICAgICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gcHJvZ3Jlc3NpdmVMYXllcnNbaWR4XSA9IG5ldyBMYXllcigncHJvZ3Jlc3NpdmUnLCB0aGlzLCB0aGlzLmRwcik7XG4gICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5pbml0Q29udGV4dCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fZGlydHkgfHwgZWwuX19kaXJ0eTtcbiAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuZWxDb3VudCsrO1xuICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzID0gTWF0aC5tYXgoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcywgZWxGcmFtZSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPj0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcykge1xuICAgICAgICAgIC8vIFNob3VsZCBrZWVwIHJlbmRlcmluZyB0aGlzICBsYXllciBiZWNhdXNlIHByb2dyZXNzaXZlIHJlbmRlcmluZyBpcyBub3QgZmluaXNoZWQgeWV0XG4gICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLl9fZnJhbWUgPSAtMTtcblxuICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVyQ291bnQrKztcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19uZXh0SWR4Tm90UHJvZyA9IGk7XG4gICAgfSAvLyDlsYLkuK3nmoTlhYPntKDmlbDph4/mnInlj5HnlJ/lj5jljJZcblxuXG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKGZ1bmN0aW9uIChsYXllciwgeikge1xuICAgICAgaWYgKGVsQ291bnRzTGFzdEZyYW1lW3pdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHByb2dyZXNzaXZlTGF5ZXJzLmxlbmd0aCA9IE1hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJDb3VudCwgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUik7XG4gICAgdXRpbC5lYWNoKHByb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIsIGlkeCkge1xuICAgICAgaWYgKHByb2dyZXNzaXZlRWxDb3VudHNMYXN0RnJhbWVbaWR4XSAhPT0gbGF5ZXIuZWxDb3VudCkge1xuICAgICAgICBlbC5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxheWVyLl9fZGlydHkpIHtcbiAgICAgICAgbGF5ZXIuX19wcm9ncmVzcyA9IDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4hemZpGhvdmVy5bGC5aSW5omA5pyJ5YaF5a65XG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcih0aGlzLl9jbGVhckxheWVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2NsZWFyTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICAgIGxheWVyLmNsZWFyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOS/ruaUueaMh+WumnpsZXZlbOeahOe7mOWItuWPguaVsFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gemxldmVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcg6YWN572u5a+56LGhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0g5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIOaYr+WQpuW8gOWQr+WKqOaAgeaooeezilxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddXG4gICAqICAgICAgICAgICAgICAgICDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgKi9cbiAgY29uZmlnTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwsIGNvbmZpZykge1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIHZhciBsYXllckNvbmZpZyA9IHRoaXMuX2xheWVyQ29uZmlnO1xuXG4gICAgICBpZiAoIWxheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgbGF5ZXJDb25maWdbemxldmVsXSA9IGNvbmZpZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwubWVyZ2UobGF5ZXJDb25maWdbemxldmVsXSwgY29uZmlnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG5cbiAgICAgIGlmIChsYXllcikge1xuICAgICAgICB1dGlsLm1lcmdlKGxheWVyLCBsYXllckNvbmZpZ1t6bGV2ZWxdLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIoOmZpOaMh+WumuWxglxuICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsIOWxguaJgOWcqOeahHpsZXZlbFxuICAgKi9cbiAgZGVsTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwpIHtcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGF5ZXIgPSBsYXllcnNbemxldmVsXTtcblxuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsYXllci5kb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsYXllci5kb20pO1xuICAgIGRlbGV0ZSBsYXllcnNbemxldmVsXTtcbiAgICB6bGV2ZWxMaXN0LnNwbGljZSh1dGlsLmluZGV4T2YoemxldmVsTGlzdCwgemxldmVsKSwgMSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWMuuWfn+Wkp+Wwj+WPmOWMluWQjumHjee7mFxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdDsgLy8gRklYTUUgV2h5ID9cblxuICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gU2F2ZSBpbnB1dCB3L2hcblxuICAgIHZhciBvcHRzID0gdGhpcy5fb3B0cztcbiAgICB3aWR0aCAhPSBudWxsICYmIChvcHRzLndpZHRoID0gd2lkdGgpO1xuICAgIGhlaWdodCAhPSBudWxsICYmIChvcHRzLmhlaWdodCA9IGhlaWdodCk7XG4gICAgd2lkdGggPSB0aGlzLl9nZXRTaXplKDApO1xuICAgIGhlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG4gICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJyc7IC8vIOS8mOWMluayoeacieWunumZheaUueWPmOeahHJlc2l6ZVxuXG4gICAgaWYgKHRoaXMuX3dpZHRoICE9IHdpZHRoIHx8IGhlaWdodCAhPSB0aGlzLl9oZWlnaHQpIHtcbiAgICAgIGRvbVJvb3Quc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICBkb21Sb290LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICAgICAgICBpZiAodGhpcy5fbGF5ZXJzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIHRoaXMuX2xheWVyc1tpZF0ucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGxheWVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZWZyZXNoKHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmuIXpmaTljZXni6znmoTkuIDkuKrlsYJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgKi9cbiAgY2xlYXJMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuXG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBsYXllci5jbGVhcigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6YeK5pS+XG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yb290LmlubmVySFRNTCA9ICcnO1xuICAgIHRoaXMucm9vdCA9IHRoaXMuc3RvcmFnZSA9IHRoaXMuX2RvbVJvb3QgPSB0aGlzLl9sYXllcnMgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY2FudmFzIHdoaWNoIGhhcyBhbGwgdGhpbmcgcmVuZGVyZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnBpeGVsUmF0aW9dXG4gICAqL1xuICBnZXRSZW5kZXJlZENhbnZhczogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIGlmICh0aGlzLl9zaW5nbGVDYW52YXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbMF0uZG9tO1xuICAgIH1cblxuICAgIHZhciBpbWFnZUxheWVyID0gbmV3IExheWVyKCdpbWFnZScsIHRoaXMsIG9wdHMucGl4ZWxSYXRpbyB8fCB0aGlzLmRwcik7XG4gICAgaW1hZ2VMYXllci5pbml0Q29udGV4dCgpO1xuICAgIGltYWdlTGF5ZXIuY2xlYXJDb2xvciA9IG9wdHMuYmFja2dyb3VuZENvbG9yO1xuICAgIGltYWdlTGF5ZXIuY2xlYXIoKTtcbiAgICB2YXIgZGlzcGxheUxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSk7XG4gICAgdmFyIHNjb3BlID0ge307XG4gICAgdmFyIHpsZXZlbDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBmaW5kQW5kRHJhd090aGVyTGF5ZXIoc21hbGxlciwgbGFyZ2VyKSB7XG4gICAgICB2YXIgemxldmVsTGlzdCA9IHNlbGYuX3psZXZlbExpc3Q7XG5cbiAgICAgIGlmIChzbWFsbGVyID09IG51bGwpIHtcbiAgICAgICAgc21hbGxlciA9IC1JbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgdmFyIGludGVybWVkaWF0ZUxheWVyO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICB2YXIgbGF5ZXIgPSBzZWxmLl9sYXllcnNbel07XG5cbiAgICAgICAgaWYgKCFsYXllci5fX2J1aWx0aW5fXyAmJiB6ID4gc21hbGxlciAmJiB6IDwgbGFyZ2VyKSB7XG4gICAgICAgICAgaW50ZXJtZWRpYXRlTGF5ZXIgPSBsYXllcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW50ZXJtZWRpYXRlTGF5ZXIgJiYgaW50ZXJtZWRpYXRlTGF5ZXIucmVuZGVyVG9DYW52YXMpIHtcbiAgICAgICAgaW1hZ2VMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICBpbnRlcm1lZGlhdGVMYXllci5yZW5kZXJUb0NhbnZhcyhpbWFnZUxheWVyLmN0eCk7XG4gICAgICAgIGltYWdlTGF5ZXIuY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWwgPSBkaXNwbGF5TGlzdFtpXTtcblxuICAgICAgaWYgKGVsLnpsZXZlbCAhPT0gemxldmVsKSB7XG4gICAgICAgIGZpbmRBbmREcmF3T3RoZXJMYXllcih6bGV2ZWwsIGVsLnpsZXZlbCk7XG4gICAgICAgIHpsZXZlbCA9IGVsLnpsZXZlbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBpbWFnZUxheWVyLCB0cnVlLCBzY29wZSk7XG4gICAgfVxuXG4gICAgZmluZEFuZERyYXdPdGhlckxheWVyKHpsZXZlbCwgSW5maW5pdHkpO1xuICAgIHJldHVybiBpbWFnZUxheWVyLmRvbTtcbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W57uY5Zu+5Yy65Z+f5a695bqmXG4gICAqL1xuICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W57uY5Zu+5Yy65Z+f6auY5bqmXG4gICAqL1xuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICB9LFxuICBfZ2V0U2l6ZTogZnVuY3Rpb24gKHdoSWR4KSB7XG4gICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgIHZhciB3aCA9IFsnd2lkdGgnLCAnaGVpZ2h0J11bd2hJZHhdO1xuICAgIHZhciBjd2ggPSBbJ2NsaWVudFdpZHRoJywgJ2NsaWVudEhlaWdodCddW3doSWR4XTtcbiAgICB2YXIgcGx0ID0gWydwYWRkaW5nTGVmdCcsICdwYWRkaW5nVG9wJ11bd2hJZHhdO1xuICAgIHZhciBwcmIgPSBbJ3BhZGRpbmdSaWdodCcsICdwYWRkaW5nQm90dG9tJ11bd2hJZHhdO1xuXG4gICAgaWYgKG9wdHNbd2hdICE9IG51bGwgJiYgb3B0c1t3aF0gIT09ICdhdXRvJykge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQob3B0c1t3aF0pO1xuICAgIH1cblxuICAgIHZhciByb290ID0gdGhpcy5yb290OyAvLyBJRTggZG9lcyBub3Qgc3VwcG9ydCBnZXRDb21wdXRlZFN0eWxlLCBidXQgaXQgdXNlIFZNTC5cblxuICAgIHZhciBzdGwgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHJvb3QpO1xuICAgIHJldHVybiAocm9vdFtjd2hdIHx8IHBhcnNlSW50MTAoc3RsW3doXSkgfHwgcGFyc2VJbnQxMChyb290LnN0eWxlW3doXSkpIC0gKHBhcnNlSW50MTAoc3RsW3BsdF0pIHx8IDApIC0gKHBhcnNlSW50MTAoc3RsW3ByYl0pIHx8IDApIHwgMDtcbiAgfSxcbiAgcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uIChwYXRoLCBkcHIpIHtcbiAgICBkcHIgPSBkcHIgfHwgdGhpcy5kcHI7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgcmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIHN0eWxlID0gcGF0aC5zdHlsZTtcbiAgICB2YXIgc2hhZG93Qmx1clNpemUgPSBzdHlsZS5zaGFkb3dCbHVyO1xuICAgIHZhciBzaGFkb3dPZmZzZXRYID0gc3R5bGUuc2hhZG93T2Zmc2V0WDtcbiAgICB2YXIgc2hhZG93T2Zmc2V0WSA9IHN0eWxlLnNoYWRvd09mZnNldFk7XG4gICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmhhc1N0cm9rZSgpID8gc3R5bGUubGluZVdpZHRoIDogMDtcbiAgICB2YXIgbGVmdE1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIC1zaGFkb3dPZmZzZXRYICsgc2hhZG93Qmx1clNpemUpO1xuICAgIHZhciByaWdodE1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIHNoYWRvd09mZnNldFggKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHRvcE1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIC1zaGFkb3dPZmZzZXRZICsgc2hhZG93Qmx1clNpemUpO1xuICAgIHZhciBib3R0b21NYXJnaW4gPSBNYXRoLm1heChsaW5lV2lkdGggLyAyLCBzaGFkb3dPZmZzZXRZICsgc2hhZG93Qmx1clNpemUpO1xuICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGggKyBsZWZ0TWFyZ2luICsgcmlnaHRNYXJnaW47XG4gICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0ICsgdG9wTWFyZ2luICsgYm90dG9tTWFyZ2luO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZHByO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG4gICAgY3R4LnNjYWxlKGRwciwgZHByKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGN0eC5kcHIgPSBkcHI7XG4gICAgdmFyIHBhdGhUcmFuc2Zvcm0gPSB7XG4gICAgICBwb3NpdGlvbjogcGF0aC5wb3NpdGlvbixcbiAgICAgIHJvdGF0aW9uOiBwYXRoLnJvdGF0aW9uLFxuICAgICAgc2NhbGU6IHBhdGguc2NhbGVcbiAgICB9O1xuICAgIHBhdGgucG9zaXRpb24gPSBbbGVmdE1hcmdpbiAtIHJlY3QueCwgdG9wTWFyZ2luIC0gcmVjdC55XTtcbiAgICBwYXRoLnJvdGF0aW9uID0gMDtcbiAgICBwYXRoLnNjYWxlID0gWzEsIDFdO1xuICAgIHBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICBpZiAocGF0aCkge1xuICAgICAgcGF0aC5icnVzaChjdHgpO1xuICAgIH1cblxuICAgIHZhciBJbWFnZVNoYXBlID0gSW1hZ2U7XG4gICAgdmFyIGltZ1NoYXBlID0gbmV3IEltYWdlU2hhcGUoe1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgaW1hZ2U6IGNhbnZhc1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHBhdGhUcmFuc2Zvcm0ucG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgaW1nU2hhcGUucG9zaXRpb24gPSBwYXRoLnBvc2l0aW9uID0gcGF0aFRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICB9XG5cbiAgICBpZiAocGF0aFRyYW5zZm9ybS5yb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICBpbWdTaGFwZS5yb3RhdGlvbiA9IHBhdGgucm90YXRpb24gPSBwYXRoVHJhbnNmb3JtLnJvdGF0aW9uO1xuICAgIH1cblxuICAgIGlmIChwYXRoVHJhbnNmb3JtLnNjYWxlICE9IG51bGwpIHtcbiAgICAgIGltZ1NoYXBlLnNjYWxlID0gcGF0aC5zY2FsZSA9IHBhdGhUcmFuc2Zvcm0uc2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGltZ1NoYXBlO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gUGFpbnRlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL1BhaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB1dGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcblxudmFyIGRldmljZVBpeGVsUmF0aW8gPSBfY29uZmlnLmRldmljZVBpeGVsUmF0aW87XG5cbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuL2dyYXBoaWMvU3R5bGVcIik7XG5cbnZhciBQYXR0ZXJuID0gcmVxdWlyZShcIi4vZ3JhcGhpYy9QYXR0ZXJuXCIpO1xuXG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9MYXllclxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICog5Yib5bu6ZG9tXG4gKlxuICogQGlubmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgZG9tIGlkIOW+heeUqFxuICogQHBhcmFtIHtQYWludGVyfSBwYWludGVyIHBhaW50ZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZURvbShpZCwgcGFpbnRlciwgZHByKSB7XG4gIHZhciBuZXdEb20gPSB1dGlsLmNyZWF0ZUNhbnZhcygpO1xuICB2YXIgd2lkdGggPSBwYWludGVyLmdldFdpZHRoKCk7XG4gIHZhciBoZWlnaHQgPSBwYWludGVyLmdldEhlaWdodCgpO1xuICB2YXIgbmV3RG9tU3R5bGUgPSBuZXdEb20uc3R5bGU7IC8vIOayoWFwcGVuZOWRou+8jOivt+WOn+iwheaIkei/meagt+WGme+8jOa4heaZsH5cblxuICBuZXdEb21TdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIG5ld0RvbVN0eWxlLmxlZnQgPSAwO1xuICBuZXdEb21TdHlsZS50b3AgPSAwO1xuICBuZXdEb21TdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgbmV3RG9tU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgbmV3RG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gIG5ld0RvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7IC8vIGlk5LiN5L2c5Li657Si5byV55So77yM6YG/5YWN5Y+v6IO96YCg5oiQ55qE6YeN5ZCN77yM5a6a5LmJ5Li656eB5pyJ5bGe5oCnXG5cbiAgbmV3RG9tLnNldEF0dHJpYnV0ZSgnZGF0YS16ci1kb20taWQnLCBpZCk7XG4gIHJldHVybiBuZXdEb207XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9MYXllclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvUGFpbnRlcn0gcGFpbnRlclxuICogQHBhcmFtIHtudW1iZXJ9IFtkcHJdXG4gKi9cblxuXG52YXIgTGF5ZXIgPSBmdW5jdGlvbiAoaWQsIHBhaW50ZXIsIGRwcikge1xuICB2YXIgZG9tO1xuICBkcHIgPSBkcHIgfHwgZGV2aWNlUGl4ZWxSYXRpbztcblxuICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuICAgIGRvbSA9IGNyZWF0ZURvbShpZCwgcGFpbnRlciwgZHByKTtcbiAgfSAvLyBOb3QgdXNpbmcgaXNEb20gYmVjYXVzZSBpbiBub2RlIGl0IHdpbGwgcmV0dXJuIGZhbHNlXG4gIGVsc2UgaWYgKHV0aWwuaXNPYmplY3QoaWQpKSB7XG4gICAgICBkb20gPSBpZDtcbiAgICAgIGlkID0gZG9tLmlkO1xuICAgIH1cblxuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuZG9tID0gZG9tO1xuICB2YXIgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG5cbiAgaWYgKGRvbVN0eWxlKSB7XG4gICAgLy8gTm90IGluIG5vZGVcbiAgICBkb20ub25zZWxlY3RzdGFydCA9IHJldHVybkZhbHNlOyAvLyDpgb/lhY3pobXpnaLpgInkuK3nmoTlsLTlsKxcblxuICAgIGRvbVN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgZG9tU3R5bGVbJ3VzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgZG9tU3R5bGVbJy13ZWJraXQtdG91Y2gtY2FsbG91dCddID0gJ25vbmUnO1xuICAgIGRvbVN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICBkb21TdHlsZVsncGFkZGluZyddID0gMDtcbiAgICBkb21TdHlsZVsnbWFyZ2luJ10gPSAwO1xuICAgIGRvbVN0eWxlWydib3JkZXItd2lkdGgnXSA9IDA7XG4gIH1cblxuICB0aGlzLmRvbUJhY2sgPSBudWxsO1xuICB0aGlzLmN0eEJhY2sgPSBudWxsO1xuICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuICB0aGlzLmNvbmZpZyA9IG51bGw7IC8vIENvbmZpZ3NcblxuICAvKipcbiAgICog5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG5cbiAgdGhpcy5jbGVhckNvbG9yID0gMDtcbiAgLyoqXG4gICAqIOaYr+WQpuW8gOWQr+WKqOaAgeaooeezilxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG5cbiAgdGhpcy5tb3Rpb25CbHVyID0gZmFsc2U7XG4gIC8qKlxuICAgKiDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwLjdcbiAgICovXG5cbiAgdGhpcy5sYXN0RnJhbWVBbHBoYSA9IDAuNztcbiAgLyoqXG4gICAqIExheWVyIGRwclxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLmRwciA9IGRwcjtcbn07XG5cbkxheWVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IExheWVyLFxuICBlbENvdW50OiAwLFxuICBfX2RpcnR5OiB0cnVlLFxuICBpbml0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY3R4ID0gdGhpcy5kb20uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmN0eC5fX2N1cnJlbnRWYWx1ZXMgPSB7fTtcbiAgICB0aGlzLmN0eC5kcHIgPSB0aGlzLmRwcjtcbiAgfSxcbiAgY3JlYXRlQmFja0J1ZmZlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcbiAgICB0aGlzLmRvbUJhY2sgPSBjcmVhdGVEb20oJ2JhY2stJyArIHRoaXMuaWQsIHRoaXMucGFpbnRlciwgZHByKTtcbiAgICB0aGlzLmN0eEJhY2sgPSB0aGlzLmRvbUJhY2suZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmN0eEJhY2suX19jdXJyZW50VmFsdWVzID0ge307XG5cbiAgICBpZiAoZHByICE9IDEpIHtcbiAgICAgIHRoaXMuY3R4QmFjay5zY2FsZShkcHIsIGRwcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHdpZHRoXG4gICAqIEBwYXJhbSAge251bWJlcn0gaGVpZ2h0XG4gICAqL1xuICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGRwciA9IHRoaXMuZHByO1xuICAgIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgICB2YXIgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG4gICAgdmFyIGRvbUJhY2sgPSB0aGlzLmRvbUJhY2s7XG4gICAgZG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgZG9tU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICBkb20ud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICBkb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgaWYgKGRvbUJhY2spIHtcbiAgICAgIGRvbUJhY2sud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgIGRvbUJhY2suaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICBpZiAoZHByICE9IDEpIHtcbiAgICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4heepuuivpeWxgueUu+W4g1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyQWxsIENsZWFyIGFsbCB3aXRoIG91dCBtb3Rpb24gYmx1clxuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uIChjbGVhckFsbCkge1xuICAgIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgdmFyIHdpZHRoID0gZG9tLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBkb20uaGVpZ2h0O1xuICAgIHZhciBjbGVhckNvbG9yID0gdGhpcy5jbGVhckNvbG9yO1xuICAgIHZhciBoYXZlTW90aW9uQkx1ciA9IHRoaXMubW90aW9uQmx1ciAmJiAhY2xlYXJBbGw7XG4gICAgdmFyIGxhc3RGcmFtZUFscGhhID0gdGhpcy5sYXN0RnJhbWVBbHBoYTtcbiAgICB2YXIgZHByID0gdGhpcy5kcHI7XG5cbiAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgIGlmICghdGhpcy5kb21CYWNrKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlQmFja0J1ZmZlcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eEJhY2suZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgdGhpcy5jdHhCYWNrLmRyYXdJbWFnZShkb20sIDAsIDAsIHdpZHRoIC8gZHByLCBoZWlnaHQgLyBkcHIpO1xuICAgIH1cblxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBpZiAoY2xlYXJDb2xvcikge1xuICAgICAgdmFyIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjsgLy8gR3JhZGllbnRcblxuICAgICAgaWYgKGNsZWFyQ29sb3IuY29sb3JTdG9wcykge1xuICAgICAgICAvLyBDYWNoZSBjYW52YXMgZ3JhZGllbnRcbiAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gY2xlYXJDb2xvci5fX2NhbnZhc0dyYWRpZW50IHx8IFN0eWxlLmdldEdyYWRpZW50KGN0eCwgY2xlYXJDb2xvciwge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjtcbiAgICAgIH0gLy8gUGF0dGVyblxuICAgICAgZWxzZSBpZiAoY2xlYXJDb2xvci5pbWFnZSkge1xuICAgICAgICAgIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiA9IFBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm4uY2FsbChjbGVhckNvbG9yLCBjdHgpO1xuICAgICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuIHx8IGNsZWFyQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlmIChoYXZlTW90aW9uQkx1cikge1xuICAgICAgdmFyIGRvbUJhY2sgPSB0aGlzLmRvbUJhY2s7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gbGFzdEZyYW1lQWxwaGE7XG4gICAgICBjdHguZHJhd0ltYWdlKGRvbUJhY2ssIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBMYXllcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL0xheWVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2RlZmF1bHQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL3pyZW5kZXIvaXNzdWVzLzE4OSNpc3N1ZWNvbW1lbnQtMjI0OTE5ODA5XG53aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHx8IGZ1bmN0aW9uIChmdW5jKSB7XG4gIHNldFRpbWVvdXQoZnVuYywgMTYpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgX2V2ZW50ID0gcmVxdWlyZShcIi4uL2NvcmUvZXZlbnRcIik7XG5cbnZhciBEaXNwYXRjaGVyID0gX2V2ZW50LkRpc3BhdGNoZXI7XG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKFwiLi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIik7XG5cbnZhciBBbmltYXRvciA9IHJlcXVpcmUoXCIuL0FuaW1hdG9yXCIpO1xuXG4vKipcbiAqIOWKqOeUu+S4u+exuywg6LCD5bqm5ZKM566h55CG5omA5pyJ5Yqo55S75o6n5Yi25ZmoXG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gVE9ETyBBZGRpdGl2ZSBhbmltYXRpb25cbi8vIGh0dHA6Ly9pb3NvdGVyaWMuY29tL2FkZGl0aXZlLWFuaW1hdGlvbnMtYW5pbWF0ZXdpdGhkdXJhdGlvbi1pbi1pb3MtOC9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS92aWRlb3Mvd3dkYzIwMTQvIzIzNlxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IElaUmVuZGVyU3RhZ2VcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVwZGF0ZVxuICovXG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25mcmFtZV1cbiAqIEBwYXJhbSB7SVpSZW5kZXJTdGFnZX0gW29wdGlvbnMuc3RhZ2VdXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKCk7XG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgeDogMTAwLFxuICogICAgICAgICB5OiAxMDBcbiAqICAgICB9O1xuICogICAgIGFuaW1hdGlvbi5hbmltYXRlKG5vZGUucG9zaXRpb24pXG4gKiAgICAgICAgIC53aGVuKDEwMDAsIHtcbiAqICAgICAgICAgICAgIHg6IDUwMCxcbiAqICAgICAgICAgICAgIHk6IDUwMFxuICogICAgICAgICB9KVxuICogICAgICAgICAud2hlbigyMDAwLCB7XG4gKiAgICAgICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgICAgICB5OiAxMDBcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgLnN0YXJ0KCdzcGxpbmUnKTtcbiAqL1xudmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnN0YWdlID0gb3B0aW9ucy5zdGFnZSB8fCB7fTtcblxuICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWUgfHwgZnVuY3Rpb24gKCkge307IC8vIHByaXZhdGUgcHJvcGVydGllc1xuXG5cbiAgdGhpcy5fY2xpcHMgPSBbXTtcbiAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICB0aGlzLl90aW1lO1xuICB0aGlzLl9wYXVzZWRUaW1lO1xuICB0aGlzLl9wYXVzZVN0YXJ0O1xuICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgRGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xufTtcblxuQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEFuaW1hdGlvbixcblxuICAvKipcbiAgICog5re75YqgIGNsaXBcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgKi9cbiAgYWRkQ2xpcDogZnVuY3Rpb24gKGNsaXApIHtcbiAgICB0aGlzLl9jbGlwcy5wdXNoKGNsaXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqAgYW5pbWF0b3JcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9IGFuaW1hdG9yXG4gICAqL1xuICBhZGRBbmltYXRvcjogZnVuY3Rpb24gKGFuaW1hdG9yKSB7XG4gICAgYW5pbWF0b3IuYW5pbWF0aW9uID0gdGhpcztcbiAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hZGRDbGlwKGNsaXBzW2ldKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIoOmZpOWKqOeUu+eJh+autVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAqL1xuICByZW1vdmVDbGlwOiBmdW5jdGlvbiAoY2xpcCkge1xuICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fY2xpcHMsIGNsaXApO1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICB0aGlzLl9jbGlwcy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIoOmZpOWKqOeUu+eJh+autVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICovXG4gIHJlbW92ZUFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZW1vdmVDbGlwKGNsaXBzW2ldKTtcbiAgICB9XG5cbiAgICBhbmltYXRvci5hbmltYXRpb24gPSBudWxsO1xuICB9LFxuICBfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3BhdXNlZFRpbWU7XG5cbiAgICB2YXIgZGVsdGEgPSB0aW1lIC0gdGhpcy5fdGltZTtcbiAgICB2YXIgY2xpcHMgPSB0aGlzLl9jbGlwcztcbiAgICB2YXIgbGVuID0gY2xpcHMubGVuZ3RoO1xuICAgIHZhciBkZWZlcnJlZEV2ZW50cyA9IFtdO1xuICAgIHZhciBkZWZlcnJlZENsaXBzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgY2xpcCA9IGNsaXBzW2ldO1xuICAgICAgdmFyIGUgPSBjbGlwLnN0ZXAodGltZSwgZGVsdGEpOyAvLyBUaHJvdyBvdXQgdGhlIGV2ZW50cyBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlclxuICAgICAgLy8gc3RhZ2UudXBkYXRlLCBsaWtlIGRlc3Ryb3lcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgZGVmZXJyZWRFdmVudHMucHVzaChlKTtcbiAgICAgICAgZGVmZXJyZWRDbGlwcy5wdXNoKGNsaXApO1xuICAgICAgfVxuICAgIH0gLy8gUmVtb3ZlIHRoZSBmaW5pc2hlZCBjbGlwXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgaWYgKGNsaXBzW2ldLl9uZWVkc1JlbW92ZSkge1xuICAgICAgICBjbGlwc1tpXSA9IGNsaXBzW2xlbiAtIDFdO1xuICAgICAgICBjbGlwcy5wb3AoKTtcbiAgICAgICAgbGVuLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGVuID0gZGVmZXJyZWRFdmVudHMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVmZXJyZWRDbGlwc1tpXS5maXJlKGRlZmVycmVkRXZlbnRzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICB0aGlzLm9uZnJhbWUoZGVsdGEpO1xuICAgIHRoaXMudHJpZ2dlcignZnJhbWUnLCBkZWx0YSk7XG5cbiAgICBpZiAodGhpcy5zdGFnZS51cGRhdGUpIHtcbiAgICAgIHRoaXMuc3RhZ2UudXBkYXRlKCk7XG4gICAgfVxuICB9LFxuICBfc3RhcnRMb29wOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIGlmIChzZWxmLl9ydW5uaW5nKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgIXNlbGYuX3BhdXNlZCAmJiBzZWxmLl91cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOW8gOWni+i/kOihjOWKqOeUu1xuICAgKi9cbiAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl90aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG5cbiAgICB0aGlzLl9zdGFydExvb3AoKTtcbiAgfSxcblxuICAvKipcbiAgICog5YGc5q2i6L+Q6KGM5Yqo55S7XG4gICAqL1xuICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYXVzZVxuICAgKi9cbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc3VtZVxuICAgKi9cbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3BhdXNlU3RhcnQ7XG4gICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4hemZpOaJgOacieWKqOeUu+eJh+autVxuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jbGlwcyA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlr7nkuIDkuKrnm67moIfliJvlu7rkuIDkuKphbmltYXRvcuWvueixoe+8jOWPr+S7peaMh+Wumuebruagh+S4reeahOWxnuaAp+S9v+eUqOWKqOeUu1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMubG9vcD1mYWxzZV0g5piv5ZCm5b6q546v5pKt5pS+5Yqo55S7XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZXR0ZXI9bnVsbF1cbiAgICogICAgICAgICDlpoLmnpzmjIflrppnZXR0ZXLlh73mlbDvvIzkvJrpgJrov4dnZXR0ZXLlh73mlbDlj5blsZ7mgKflgLxcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLnNldHRlcj1udWxsXVxuICAgKiAgICAgICAgIOWmguaenOaMh+WumnNldHRlcuWHveaVsO+8jOS8mumAmui/h3NldHRlcuWHveaVsOiuvue9ruWxnuaAp+WAvFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufkFuaW1hdG9yfVxuICAgKi9cbiAgLy8gVE9ETyBHYXBcbiAgYW5pbWF0ZTogZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcih0YXJnZXQsIG9wdGlvbnMubG9vcCwgb3B0aW9ucy5nZXR0ZXIsIG9wdGlvbnMuc2V0dGVyKTtcbiAgICB0aGlzLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcbiAgICByZXR1cm4gYW5pbWF0b3I7XG4gIH1cbn07XG51dGlsLm1peGluKEFuaW1hdGlvbiwgRGlzcGF0Y2hlcik7XG52YXIgX2RlZmF1bHQgPSBBbmltYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwiLi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbmV4cG9ydHMuRGlzcGF0Y2hlciA9IEV2ZW50ZnVsO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4vZW52XCIpO1xuXG4vKipcbiAqIOS6i+S7tui+heWKqeexu1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvZXZlbnRcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICovXG52YXIgaXNEb21MZXZlbDIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyO1xudmFyIE1PVVNFX0VWRU5UX1JFRyA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLztcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gIC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSkgZG9uJ3QgaGF2ZSBnZXRCb3VuZGluZ1JlY3RcbiAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwXG4gIH07XG59IC8vIGBjYWxjdWxhdGVgIGlzIG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlXG5cblxuZnVuY3Rpb24gY2xpZW50VG9Mb2NhbChlbCwgZSwgb3V0LCBjYWxjdWxhdGUpIHtcbiAgb3V0ID0gb3V0IHx8IHt9OyAvLyBBY2NvcmRpbmcgdG8gdGhlIFczQyBXb3JraW5nIERyYWZ0LCBvZmZzZXRYIGFuZCBvZmZzZXRZIHNob3VsZCBiZSByZWxhdGl2ZVxuICAvLyB0byB0aGUgcGFkZGluZyBlZGdlIG9mIHRoZSB0YXJnZXQgZWxlbWVudC4gVGhlIG9ubHkgYnJvd3NlciB1c2luZyB0aGlzIGNvbnZlbnRpb25cbiAgLy8gaXMgSUUuIFdlYmtpdCB1c2VzIHRoZSBib3JkZXIgZWRnZSwgT3BlcmEgdXNlcyB0aGUgY29udGVudCBlZGdlLCBhbmQgRmlyZUZveCBkb2VzXG4gIC8vIG5vdCBzdXBwb3J0IHRoZSBwcm9wZXJ0aWVzLlxuICAvLyAoc2VlIGh0dHA6Ly93d3cuamFja2xtb29yZS5jb20vbm90ZXMvbW91c2UtcG9zaXRpb24vKVxuICAvLyBJbiB6ciBwYWludGVyLmRvbSwgcGFkZGluZyBlZGdlIGVxdWFscyB0byBib3JkZXIgZWRnZS5cbiAgLy8gRklYTUVcbiAgLy8gV2hlbiBtb3VzZW1vdmUgZXZlbnQgdHJpZ2dlcmVkIG9uIGVjIHRvb2x0aXAsIHRhcmdldCBpcyBub3QgenIgcGFpbnRlci5kb20sIGFuZFxuICAvLyBvZmZzZXRYL1kgaXMgcmVsYXRpdmUgdG8gZS50YXJnZXQsIHdoZXJlIHRoZSBjYWxjdWxhdGlvbiBvZiB6clgvWSB2aWEgb2Zmc2V0WC9ZXG4gIC8vIGlzIHRvbyBjb21wbGV4LiBTbyBjc3MtdHJhbnNmcm9tIGRvbnQgc3VwcG9ydCBpbiB0aGlzIGNhc2UgdGVtcG9yYXJpbHkuXG5cbiAgaWYgKGNhbGN1bGF0ZSB8fCAhZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpO1xuICB9IC8vIENhdXRpb246IEluIEZpcmVGb3gsIGxheWVyWC9sYXllclkgTW91c2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGNsb3Nlc3QgcG9zaXRpb25lZFxuICAvLyBhbmNlc3RvciBlbGVtZW50LCBzbyB3ZSBzaG91bGQgbWFrZSBzdXJlIGVsIGlzIHBvc2l0aW9uZWQgKGUuZy4sIG5vdCBwb3NpdGlvbjpzdGF0aWMpLlxuICAvLyBCVFcxLCBXZWJraXQgZG9uJ3QgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdHMgYXMgRkYgaW4gbm9uLXNpbXBsZSBjYXNlcyAobGlrZSBhZGRcbiAgLy8gem9vbS1mYWN0b3IsIG92ZXJmbG93IC8gb3BhY2l0eSBsYXllcnMsIHRyYW5zZm9ybXMgLi4uKVxuICAvLyBCVFcyLCAoZXYub2Zmc2V0WSB8fCBldi5wYWdlWSAtICQoZXYudGFyZ2V0KS5vZmZzZXQoKS50b3ApIGlzIG5vdCBjb3JyZWN0IGluIHByZXNlcnZlLTNkLlxuICAvLyA8aHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzg1MjMjY29tbWVudDoxND5cbiAgLy8gQlRXMywgSW4gZmYsIG9mZnNldFgvb2Zmc2V0WSBpcyBhbHdheXMgMC5cbiAgZWxzZSBpZiAoZW52LmJyb3dzZXIuZmlyZWZveCAmJiBlLmxheWVyWCAhPSBudWxsICYmIGUubGF5ZXJYICE9PSBlLm9mZnNldFgpIHtcbiAgICAgIG91dC56clggPSBlLmxheWVyWDtcbiAgICAgIG91dC56clkgPSBlLmxheWVyWTtcbiAgICB9IC8vIEZvciBJRTYrLCBjaHJvbWUsIHNhZmFyaSwgb3BlcmEuIChXaGVuIHdpbGwgZmYgc3VwcG9ydCBvZmZzZXRYPylcbiAgICBlbHNlIGlmIChlLm9mZnNldFggIT0gbnVsbCkge1xuICAgICAgICBvdXQuenJYID0gZS5vZmZzZXRYO1xuICAgICAgICBvdXQuenJZID0gZS5vZmZzZXRZO1xuICAgICAgfSAvLyBGb3Igc29tZSBvdGhlciBkZXZpY2UsIGUuZy4sIElPUyBzYWZhcmkuXG4gICAgICBlbHNlIHtcbiAgICAgICAgICBkZWZhdWx0R2V0WnJYWShlbCwgZSwgb3V0KTtcbiAgICAgICAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpIHtcbiAgLy8gVGhpcyB3ZWxsLWtub3duIG1ldGhvZCBiZWxvdyBkb2VzIG5vdCBzdXBwb3J0IGNzcyB0cmFuc2Zvcm0uXG4gIHZhciBib3ggPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpO1xuICBvdXQuenJYID0gZS5jbGllbnRYIC0gYm94LmxlZnQ7XG4gIG91dC56clkgPSBlLmNsaWVudFkgLSBib3gudG9wO1xufVxuLyoqXG4gKiDlpoLmnpzlrZjlnKjnrKzkuInmlrnltYzlhaXnmoTkuIDkuptkb23op6blj5HnmoTkuovku7bvvIzmiJZ0b3VjaOS6i+S7tu+8jOmcgOimgei9rOaNouS4gOS4i+S6i+S7tuWdkOaghy5cbiAqIGBjYWxjdWxhdGVgIGlzIG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlLlxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnQoZWwsIGUsIGNhbGN1bGF0ZSkge1xuICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgaWYgKGUuenJYICE9IG51bGwpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHZhciBldmVudFR5cGUgPSBlLnR5cGU7XG4gIHZhciBpc1RvdWNoID0gZXZlbnRUeXBlICYmIGV2ZW50VHlwZS5pbmRleE9mKCd0b3VjaCcpID49IDA7XG5cbiAgaWYgKCFpc1RvdWNoKSB7XG4gICAgY2xpZW50VG9Mb2NhbChlbCwgZSwgZSwgY2FsY3VsYXRlKTtcbiAgICBlLnpyRGVsdGEgPSBlLndoZWVsRGVsdGEgPyBlLndoZWVsRGVsdGEgLyAxMjAgOiAtKGUuZGV0YWlsIHx8IDApIC8gMztcbiAgfSBlbHNlIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudFR5cGUgIT0gJ3RvdWNoZW5kJyA/IGUudGFyZ2V0VG91Y2hlc1swXSA6IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgdG91Y2ggJiYgY2xpZW50VG9Mb2NhbChlbCwgdG91Y2gsIGUsIGNhbGN1bGF0ZSk7XG4gIH0gLy8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodDsgb3RoZXJ3aXNlOiAwO1xuICAvLyBTZWUgalF1ZXJ5OiBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9zcmMvZXZlbnQuanNcbiAgLy8gSWYgZS53aGljaCBoYXMgYmVlbiBkZWZpbmVkLCBpZiBtYXkgYmUgcmVhZG9ubHksXG4gIC8vIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvd2hpY2hcblxuXG4gIHZhciBidXR0b24gPSBlLmJ1dHRvbjtcblxuICBpZiAoZS53aGljaCA9PSBudWxsICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIE1PVVNFX0VWRU5UX1JFRy50ZXN0KGUudHlwZSkpIHtcbiAgICBlLndoaWNoID0gYnV0dG9uICYgMSA/IDEgOiBidXR0b24gJiAyID8gMyA6IGJ1dHRvbiAmIDQgPyAyIDogMDtcbiAgfVxuXG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBoYW5kbGVyKSB7XG4gIGlmIChpc0RvbUxldmVsMikge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gIH0gZWxzZSB7XG4gICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgbmFtZSwgaGFuZGxlcik7XG4gIH1cbn1cbi8qKlxuICogcHJldmVudERlZmF1bHQgYW5kIHN0b3BQcm9wYWdhdGlvbi5cbiAqIE5vdGljZTogZG8gbm90IGRvIHRoYXQgaW4genJlbmRlci4gVXBwZXIgYXBwbGljYXRpb25cbiAqIGRvIHRoYXQgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2V2ZW50XG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge0V2ZW50fSBlIDogZXZlbnTlr7nosaFcbiAqL1xuXG5cbnZhciBzdG9wID0gaXNEb21MZXZlbDIgPyBmdW5jdGlvbiAoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbn0gOiBmdW5jdGlvbiAoZSkge1xuICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIG5vdExlZnRNb3VzZShlKSB7XG4gIC8vIElmIGUud2hpY2ggaXMgdW5kZWZpbmVkLCBjb25zaWRlcmVkIGFzIGxlZnQgbW91c2UgZXZlbnQuXG4gIHJldHVybiBlLndoaWNoID4gMTtcbn0gLy8g5YGa5ZCR5LiK5YW85a65XG5cblxuZXhwb3J0cy5jbGllbnRUb0xvY2FsID0gY2xpZW50VG9Mb2NhbDtcbmV4cG9ydHMubm9ybWFsaXplRXZlbnQgPSBub3JtYWxpemVFdmVudDtcbmV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5zdG9wID0gc3RvcDtcbmV4cG9ydHMubm90TGVmdE1vdXNlID0gbm90TGVmdE1vdXNlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL2V2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2V2ZW50ID0gcmVxdWlyZShcIi4uL2NvcmUvZXZlbnRcIik7XG5cbnZhciBhZGRFdmVudExpc3RlbmVyID0gX2V2ZW50LmFkZEV2ZW50TGlzdGVuZXI7XG52YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IF9ldmVudC5yZW1vdmVFdmVudExpc3RlbmVyO1xudmFyIG5vcm1hbGl6ZUV2ZW50ID0gX2V2ZW50Lm5vcm1hbGl6ZUV2ZW50O1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIEV2ZW50ZnVsID0gcmVxdWlyZShcIi4uL21peGluL0V2ZW50ZnVsXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4uL2NvcmUvZW52XCIpO1xuXG52YXIgR2VzdHVyZU1nciA9IHJlcXVpcmUoXCIuLi9jb3JlL0dlc3R1cmVNZ3JcIik7XG5cbnZhciBUT1VDSF9DTElDS19ERUxBWSA9IDMwMDtcbnZhciBtb3VzZUhhbmRsZXJOYW1lcyA9IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V3aGVlbCcsICdtb3VzZW91dCcsICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnY29udGV4dG1lbnUnXTtcbnZhciB0b3VjaEhhbmRsZXJOYW1lcyA9IFsndG91Y2hzdGFydCcsICd0b3VjaGVuZCcsICd0b3VjaG1vdmUnXTtcbnZhciBwb2ludGVyRXZlbnROYW1lcyA9IHtcbiAgcG9pbnRlcmRvd246IDEsXG4gIHBvaW50ZXJ1cDogMSxcbiAgcG9pbnRlcm1vdmU6IDEsXG4gIHBvaW50ZXJvdXQ6IDFcbn07XG52YXIgcG9pbnRlckhhbmRsZXJOYW1lcyA9IHpyVXRpbC5tYXAobW91c2VIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBubSA9IG5hbWUucmVwbGFjZSgnbW91c2UnLCAncG9pbnRlcicpO1xuICByZXR1cm4gcG9pbnRlckV2ZW50TmFtZXNbbm1dID8gbm0gOiBuYW1lO1xufSk7XG5cbmZ1bmN0aW9uIGV2ZW50TmFtZUZpeChuYW1lKSB7XG4gIHJldHVybiBuYW1lID09PSAnbW91c2V3aGVlbCcgJiYgZW52LmJyb3dzZXIuZmlyZWZveCA/ICdET01Nb3VzZVNjcm9sbCcgOiBuYW1lO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzR2VzdHVyZShwcm94eSwgZXZlbnQsIHN0YWdlKSB7XG4gIHZhciBnZXN0dXJlTWdyID0gcHJveHkuX2dlc3R1cmVNZ3I7XG4gIHN0YWdlID09PSAnc3RhcnQnICYmIGdlc3R1cmVNZ3IuY2xlYXIoKTtcbiAgdmFyIGdlc3R1cmVJbmZvID0gZ2VzdHVyZU1nci5yZWNvZ25pemUoZXZlbnQsIHByb3h5LmhhbmRsZXIuZmluZEhvdmVyKGV2ZW50LnpyWCwgZXZlbnQuenJZLCBudWxsKS50YXJnZXQsIHByb3h5LmRvbSk7XG4gIHN0YWdlID09PSAnZW5kJyAmJiBnZXN0dXJlTWdyLmNsZWFyKCk7IC8vIERvIG5vdCBkbyBhbnkgcHJldmVudERlZmF1bHQgaGVyZS4gVXBwZXIgYXBwbGljYXRpb24gZG8gdGhhdCBpZiBuZWNlc3NhcnkuXG5cbiAgaWYgKGdlc3R1cmVJbmZvKSB7XG4gICAgdmFyIHR5cGUgPSBnZXN0dXJlSW5mby50eXBlO1xuICAgIGV2ZW50Lmdlc3R1cmVFdmVudCA9IHR5cGU7XG4gICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudCh7XG4gICAgICB0YXJnZXQ6IGdlc3R1cmVJbmZvLnRhcmdldFxuICAgIH0sIHR5cGUsIGdlc3R1cmVJbmZvLmV2ZW50KTtcbiAgfVxufSAvLyBmdW5jdGlvbiBvbk1TR2VzdHVyZUNoYW5nZShwcm94eSwgZXZlbnQpIHtcbi8vICAgICBpZiAoZXZlbnQudHJhbnNsYXRpb25YIHx8IGV2ZW50LnRyYW5zbGF0aW9uWSkge1xuLy8gICAgICAgICAvLyBtb3VzZW1vdmUgaXMgY2FycmllZCBieSBNU0dlc3R1cmUgdG8gcmVkdWNlIHRoZSBzZW5zaXRpdml0eS5cbi8vICAgICAgICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudChldmVudC50YXJnZXQsICdtb3VzZW1vdmUnLCBldmVudCk7XG4vLyAgICAgfVxuLy8gICAgIGlmIChldmVudC5zY2FsZSAhPT0gMSkge1xuLy8gICAgICAgICBldmVudC5waW5jaFggPSBldmVudC5vZmZzZXRYO1xuLy8gICAgICAgICBldmVudC5waW5jaFkgPSBldmVudC5vZmZzZXRZO1xuLy8gICAgICAgICBldmVudC5waW5jaFNjYWxlID0gZXZlbnQuc2NhbGU7XG4vLyAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoZXZlbnQudGFyZ2V0LCAncGluY2gnLCBldmVudCk7XG4vLyAgICAgfVxuLy8gfVxuXG4vKipcbiAqIFByZXZlbnQgbW91c2UgZXZlbnQgZnJvbSBiZWluZyBkaXNwYXRjaGVkIGFmdGVyIFRvdWNoIEV2ZW50cyBhY3Rpb25cbiAqIEBzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9kZWx0YWtvc2gvaGFuZGpzL2Jsb2IvbWFzdGVyL3NyYy9oYW5kLmJhc2UuanM+XG4gKiAxLiBNb2JpbGUgYnJvd3NlcnMgZGlzcGF0Y2ggbW91c2UgZXZlbnRzIDMwMG1zIGFmdGVyIHRvdWNoZW5kLlxuICogMi4gQ2hyb21lIGZvciBBbmRyb2lkIGRpc3BhdGNoIG1vdXNlZG93biBmb3IgbG9uZy10b3VjaCBhYm91dCA2NTBtc1xuICogUmVzdWx0OiBCbG9ja2luZyBNb3VzZSBFdmVudHMgZm9yIDcwMG1zLlxuICovXG5cblxuZnVuY3Rpb24gc2V0VG91Y2hUaW1lcihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5fdG91Y2hpbmcgPSB0cnVlO1xuICBjbGVhclRpbWVvdXQoaW5zdGFuY2UuX3RvdWNoVGltZXIpO1xuICBpbnN0YW5jZS5fdG91Y2hUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGluc3RhbmNlLl90b3VjaGluZyA9IGZhbHNlO1xuICB9LCA3MDApO1xufVxuXG52YXIgZG9tSGFuZGxlcnMgPSB7XG4gIC8qKlxuICAgKiBNb3VzZSBtb3ZlIGhhbmRsZXJcbiAgICogQGlubmVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICB0aGlzLnRyaWdnZXIoJ21vdXNlbW92ZScsIGV2ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogTW91c2Ugb3V0IGhhbmRsZXJcbiAgICogQGlubmVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICBtb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuICAgIHZhciBlbGVtZW50ID0gZXZlbnQudG9FbGVtZW50IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICBpZiAoZWxlbWVudCAhPSB0aGlzLmRvbSkge1xuICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPSA5KSB7XG4gICAgICAgIC8vIOW/veeVpeWMheWQq+WcqHJvb3TkuK3nmoRkb23lvJXotbfnmoRtb3VzZU91dFxuICAgICAgICBpZiAoZWxlbWVudCA9PT0gdGhpcy5kb20pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlcignbW91c2VvdXQnLCBldmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvdWNo5byA5aeL5ZON5bqU5Ye95pWwXG4gICAqIEBpbm5lclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgdG91Y2hzdGFydDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gRGVmYXVsdCBtb3VzZSBiZWhhdmlvdXIgc2hvdWxkIG5vdCBiZSBkaXNhYmxlZCBoZXJlLlxuICAgIC8vIEZvciBleGFtcGxlLCBwYWdlIG1heSBuZWVkcyB0byBiZSBzbGlkZWQuXG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpOyAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG5cbiAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuICAgIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA9IG5ldyBEYXRlKCk7XG4gICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdzdGFydCcpOyAvLyBJbiB0b3VjaCBkZXZpY2UsIHRyaWdnZXIgYG1vdXNlbW92ZWAoYG1vdXNlb3ZlcmApIHNob3VsZFxuICAgIC8vIGJlIHRyaWdnZXJlZCwgYW5kIG11c3QgYmVmb3JlIGBtb3VzZWRvd25gIHRyaWdnZXJlZC5cblxuICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBkb21IYW5kbGVycy5tb3VzZWRvd24uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogVG91Y2jnp7vliqjlk43lupTlh73mlbBcbiAgICogQGlubmVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICB0b3VjaG1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTsgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgIC8vIG1vdXNlIGV2ZW50IGluIHVwcGVyIGFwcGxpY2F0b2luLlxuXG4gICAgZXZlbnQuenJCeVRvdWNoID0gdHJ1ZTtcbiAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ2NoYW5nZScpOyAvLyBNb3VzZSBtb3ZlIHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgLy8gdGhlcmUgaXMgZ2VzdHJ1ZSBldmVudCwgYmVjYXVzZSBtb3VzZSBtb3ZlIGFuZCBwaW5jaCBtYXlcbiAgICAvLyBiZSB1c2VkIGF0IHRoZSBzYW1lIHRpbWUuXG5cbiAgICBkb21IYW5kbGVycy5tb3VzZW1vdmUuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogVG91Y2jnu5PmnZ/lk43lupTlh73mlbBcbiAgICogQGlubmVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICB0b3VjaGVuZDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpOyAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG5cbiAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnZW5kJyk7XG4gICAgZG9tSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTsgLy8gRG8gbm90IHRyaWdnZXIgYG1vdXNlb3V0YCBoZXJlLCBpbiBzcGl0ZSBvZiBgbW91c2Vtb3ZlYChgbW91c2VvdmVyYCkgaXNcbiAgICAvLyB0cmlnZ2VyZWQgaW4gYHRvdWNoc3RhcnRgLiBUaGlzIHNlZW1zIHRvIGJlIGlsbG9naWNhbCwgYnV0IGJ5IHRoaXMgbWVjaGFuaXNtLFxuICAgIC8vIHdlIGNhbiBjb252ZW5pZW50bHkgaW1wbGVtZW50IFwiaG92ZXIgc3R5bGVcIiBpbiBib3RoIFBDIGFuZCB0b3VjaCBkZXZpY2UganVzdFxuICAgIC8vIGJ5IGxpc3RlbmluZyB0byBgbW91c2VvdmVyYCB0byBhZGQgXCJob3ZlciBzdHlsZVwiIGFuZCBsaXN0ZW5pbmcgdG8gYG1vdXNlb3V0YFxuICAgIC8vIHRvIHJlbW92ZSBcImhvdmVyIHN0eWxlXCIgb24gYW4gZWxlbWVudCwgd2l0aG91dCBhbnkgYWRkaXRpb25hbCBjb2RlIGZvclxuICAgIC8vIGNvbXBhdGliaWxpdHkuIChgbW91c2VvdXRgIHdpbGwgbm90IGJlIHRyaWdnZXJlZCBpbiBgdG91Y2hlbmRgLCBzbyBcImhvdmVyXG4gICAgLy8gc3R5bGVcIiB3aWxsIHJlbWFpbiBmb3IgdXNlciB2aWV3KVxuICAgIC8vIGNsaWNrIGV2ZW50IHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgLy8gdGhlcmUgaXMgZ2VzdHJ1ZSBldmVudC4gU3lzdGVtIGNsaWNrIGNhbiBub3QgYmUgcHJldmVudGVkLlxuXG4gICAgaWYgKCtuZXcgRGF0ZSgpIC0gdGhpcy5fbGFzdFRvdWNoTW9tZW50IDwgVE9VQ0hfQ0xJQ0tfREVMQVkpIHtcbiAgICAgIGRvbUhhbmRsZXJzLmNsaWNrLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cblxuICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gIH0sXG4gIHBvaW50ZXJkb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBkb21IYW5kbGVycy5tb3VzZWRvd24uY2FsbCh0aGlzLCBldmVudCk7IC8vIGlmICh1c2VNU0d1ZXN0dXJlKHRoaXMsIGV2ZW50KSkge1xuICAgIC8vICAgICB0aGlzLl9tc0dlc3R1cmUuYWRkUG9pbnRlcihldmVudC5wb2ludGVySWQpO1xuICAgIC8vIH1cbiAgfSxcbiAgcG9pbnRlcm1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIEZJWE1FXG4gICAgLy8gcG9pbnRlcm1vdmUgaXMgc28gc2Vuc2l0aXZlIHRoYXQgaXQgYWx3YXlzIHRyaWdnZXJlZCB3aGVuXG4gICAgLy8gdGFwKGNsaWNrKSBvbiB0b3VjaCBzY3JlZW4sIHdoaWNoIGFmZmVjdCBzb21lIGp1ZGdlbWVudCBpblxuICAgIC8vIHVwcGVyIGFwcGxpY2F0aW9uLiBTbywgd2UgZG9udCBzdXBwb3J0IG1vdXNlbW92ZSBvbiBNUyB0b3VjaFxuICAgIC8vIGRldmljZSB5ZXQuXG4gICAgaWYgKCFpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpKSB7XG4gICAgICBkb21IYW5kbGVycy5tb3VzZW1vdmUuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9LFxuICBwb2ludGVydXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGRvbUhhbmRsZXJzLm1vdXNldXAuY2FsbCh0aGlzLCBldmVudCk7XG4gIH0sXG4gIHBvaW50ZXJvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIHBvaW50ZXJvdXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0YXAgb24gdG91Y2ggc2NyZWVuXG4gICAgLy8gKElFMTErL0VkZ2Ugb24gTVMgU3VyZmFjZSkgYWZ0ZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcmVkLFxuICAgIC8vIHdoaWNoIGlzIGluY29uc2lzdGVudCB3aXRoIHRoZSBtb3Vzb3V0IGJlaGF2aW9yIHdlIGRlZmluZWRcbiAgICAvLyBpbiB0b3VjaGVuZC4gU28gd2UgdW5pZnkgdGhlbS5cbiAgICAvLyAoY2hlY2sgZG9tSGFuZGxlcnMudG91Y2hlbmQgZm9yIGRldGFpbGVkIGV4cGxhbmF0aW9uKVxuICAgIGlmICghaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSkge1xuICAgICAgZG9tSGFuZGxlcnMubW91c2VvdXQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpIHtcbiAgdmFyIHBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gIHJldHVybiBwb2ludGVyVHlwZSA9PT0gJ3BlbicgfHwgcG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG59IC8vIGZ1bmN0aW9uIHVzZU1TR3Vlc3R1cmUoaGFuZGxlclByb3h5LCBldmVudCkge1xuLy8gICAgIHJldHVybiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpICYmICEhaGFuZGxlclByb3h5Ll9tc0dlc3R1cmU7XG4vLyB9XG4vLyBDb21tb24gaGFuZGxlcnNcblxuXG56clV0aWwuZWFjaChbJ2NsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNld2hlZWwnLCAnZGJsY2xpY2snLCAnY29udGV4dG1lbnUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZG9tSGFuZGxlcnNbbmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgdGhpcy50cmlnZ2VyKG5hbWUsIGV2ZW50KTtcbiAgfTtcbn0pO1xuLyoqXG4gKiDkuLrmjqfliLbnsbvlrp7kvovliJ3lp4vljJZkb20g5LqL5Lu25aSE55CG5Ye95pWwXG4gKlxuICogQGlubmVyXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0hhbmRsZXJ9IGluc3RhbmNlIOaOp+WItuexu+WunuS+i1xuICovXG5cbmZ1bmN0aW9uIGluaXREb21IYW5kbGVyKGluc3RhbmNlKSB7XG4gIHpyVXRpbC5lYWNoKHRvdWNoSGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IHpyVXRpbC5iaW5kKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gIH0pO1xuICB6clV0aWwuZWFjaChwb2ludGVySGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IHpyVXRpbC5iaW5kKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gIH0pO1xuICB6clV0aWwuZWFjaChtb3VzZUhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSBtYWtlTW91c2VIYW5kbGVyKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIG1ha2VNb3VzZUhhbmRsZXIoZm4sIGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5fdG91Y2hpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4uYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBIYW5kbGVyRG9tUHJveHkoZG9tKSB7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG4gIHRoaXMuZG9tID0gZG9tO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuXG4gIHRoaXMuX3RvdWNoaW5nID0gZmFsc2U7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLl90b3VjaFRpbWVyO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvR2VzdHVyZU1ncn1cbiAgICovXG5cbiAgdGhpcy5fZ2VzdHVyZU1nciA9IG5ldyBHZXN0dXJlTWdyKCk7XG4gIHRoaXMuX2hhbmRsZXJzID0ge307XG4gIGluaXREb21IYW5kbGVyKHRoaXMpO1xuXG4gIGlmIChlbnYucG9pbnRlckV2ZW50c1N1cHBvcnRlZCkge1xuICAgIC8vIE9ubHkgSUUxMSsvRWRnZVxuICAgIC8vIDEuIE9uIGRldmljZXMgdGhhdCBib3RoIGVuYWJsZSB0b3VjaCBhbmQgbW91c2UgKGUuZy4sIE1TIFN1cmZhY2UgYW5kIGxlbm92byBYMjQwKSxcbiAgICAvLyBJRTExKy9FZGdlIGRvIG5vdCB0cmlnZ2VyIHRvdWNoIGV2ZW50LCBidXQgdHJpZ2dlciBwb2ludGVyIGV2ZW50IGFuZCBtb3VzZSBldmVudFxuICAgIC8vIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgLy8gMi4gT24gTVMgU3VyZmFjZSwgaXQgcHJvYmFibGVseSBvbmx5IHRyaWdnZXIgbW91c2Vkb3duIGJ1dCBubyBtb3VzZXVwIHdoZW4gdGFwIG9uXG4gICAgLy8gc2NyZWVuLCB3aGljaCBkbyBub3Qgb2NjdXJzIGluIHBvaW50ZXIgZXZlbnQuXG4gICAgLy8gU28gd2UgdXNlIHBvaW50ZXIgZXZlbnQgdG8gYm90aCBkZXRlY3QgdG91Y2ggZ2VzdHVyZSBhbmQgbW91c2UgYmVoYXZpb3IuXG4gICAgbW91bnRIYW5kbGVycyhwb2ludGVySGFuZGxlck5hbWVzLCB0aGlzKTsgLy8gRklYTUVcbiAgICAvLyBOb3RlOiBNUyBHZXN0dXJlIHJlcXVpcmUgQ1NTIHRvdWNoLWFjdGlvbiBzZXQuIEJ1dCB0b3VjaC1hY3Rpb24gaXMgbm90IHJlbGlhYmxlLFxuICAgIC8vIHdoaWNoIGRvZXMgbm90IHByZXZlbnQgZGVmdWF1bHQgYmVoYXZpb3Igb2NjYXNpb25hbGx5ICh3aGljaCBtYXkgY2F1c2UgdmlldyBwb3J0XG4gICAgLy8gem9vbWVkIGluIGJ1dCB1c2UgY2FuIG5vdCB6b29tIGl0IGJhY2spLiBBbmQgZXZlbnQucHJldmVudERlZmF1bHQoKSBkb2VzIG5vdCB3b3JrLlxuICAgIC8vIFNvIHdlIGhhdmUgdG8gbm90IHRvIHVzZSBNU0dlc3R1cmUgYW5kIG5vdCB0byBzdXBwb3J0IHRvdWNobW92ZSBhbmQgcGluY2ggb24gTVNcbiAgICAvLyB0b3VjaCBzY3JlZW4uIEFuZCB3ZSBvbmx5IHN1cHBvcnQgY2xpY2sgYmVoYXZpb3Igb24gTVMgdG91Y2ggc2NyZWVuIG5vdy5cbiAgICAvLyBNUyBHZXN0dXJlIEV2ZW50IGlzIG9ubHkgc3VwcG9ydGVkIG9uIElFMTErL0VkZ2UgYW5kIG9uIFdpbmRvd3MgOCsuXG4gICAgLy8gV2UgZG9udCBzdXBwb3J0IHRvdWNoIG9uIElFIG9uIHdpbjcuXG4gICAgLy8gU2VlIDxodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RuNDMzMjQzKHY9dnMuODUpLmFzcHg+XG4gICAgLy8gaWYgKHR5cGVvZiBNU0dlc3R1cmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAgICAgKHRoaXMuX21zR2VzdHVyZSA9IG5ldyBNU0dlc3R1cmUoKSkudGFyZ2V0ID0gZG9tOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAvLyAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ01TR2VzdHVyZUNoYW5nZScsIG9uTVNHZXN0dXJlQ2hhbmdlKTtcbiAgICAvLyB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVudi50b3VjaEV2ZW50c1N1cHBvcnRlZCkge1xuICAgICAgbW91bnRIYW5kbGVycyh0b3VjaEhhbmRsZXJOYW1lcywgdGhpcyk7IC8vIEhhbmRsZXIgb2YgJ21vdXNlb3V0JyBldmVudCBpcyBuZWVkZWQgaW4gdG91Y2ggbW9kZSwgd2hpY2ggd2lsbCBiZSBtb3VudGVkIGJlbG93LlxuICAgICAgLy8gYWRkRXZlbnRMaXN0ZW5lcihyb290LCAnbW91c2VvdXQnLCB0aGlzLl9tb3VzZW91dEhhbmRsZXIpO1xuICAgIH0gLy8gMS4gQ29uc2lkZXJpbmcgc29tZSBkZXZpY2VzIHRoYXQgYm90aCBlbmFibGUgdG91Y2ggYW5kIG1vdXNlIGV2ZW50IChsaWtlIG9uIE1TIFN1cmZhY2VcbiAgICAvLyBhbmQgbGVub3ZvIFgyNDAsIEBzZWUgIzIzNTApLCB3ZSBtYWtlIG1vdXNlIGV2ZW50IGJlIGFsd2F5cyBsaXN0ZW5lZCwgb3RoZXJ3aXNlXG4gICAgLy8gbW91c2UgZXZlbnQgY2FuIG5vdCBiZSBoYW5kbGUgaW4gdGhvc2UgZGV2aWNlcy5cbiAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBDaHJvbWUgd2lsbCB0cmlnZ2VyIGJvdGggdG91Y2ggZXZlbnQgYW5kIG1vdXNlIGV2ZW50LiBIb3cgdG8gcHJldmVudFxuICAgIC8vIG1vdXNlZXZlbnQgYWZ0ZXIgdG91Y2ggZXZlbnQgdHJpZ2dlcmVkLCBzZWUgYHNldFRvdWNoVGltZXJgLlxuXG5cbiAgICBtb3VudEhhbmRsZXJzKG1vdXNlSGFuZGxlck5hbWVzLCB0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdW50SGFuZGxlcnMoaGFuZGxlck5hbWVzLCBpbnN0YW5jZSkge1xuICAgIHpyVXRpbC5lYWNoKGhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZG9tLCBldmVudE5hbWVGaXgobmFtZSksIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSk7XG4gICAgfSwgaW5zdGFuY2UpO1xuICB9XG59XG5cbnZhciBoYW5kbGVyRG9tUHJveHlQcm90byA9IEhhbmRsZXJEb21Qcm94eS5wcm90b3R5cGU7XG5cbmhhbmRsZXJEb21Qcm94eVByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoYW5kbGVyTmFtZXMgPSBtb3VzZUhhbmRsZXJOYW1lcy5jb25jYXQodG91Y2hIYW5kbGVyTmFtZXMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBoYW5kbGVyTmFtZXNbaV07XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmRvbSwgZXZlbnROYW1lRml4KG5hbWUpLCB0aGlzLl9oYW5kbGVyc1tuYW1lXSk7XG4gIH1cbn07XG5cbmhhbmRsZXJEb21Qcm94eVByb3RvLnNldEN1cnNvciA9IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICB0aGlzLmRvbS5zdHlsZS5jdXJzb3IgPSBjdXJzb3JTdHlsZSB8fCAnZGVmYXVsdCc7XG59O1xuXG56clV0aWwubWl4aW4oSGFuZGxlckRvbVByb3h5LCBFdmVudGZ1bCk7XG52YXIgX2RlZmF1bHQgPSBIYW5kbGVyRG9tUHJveHk7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9kb20vSGFuZGxlclByb3h5LmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZXZlbnRVdGlsID0gcmVxdWlyZShcIi4vZXZlbnRcIik7XG5cbi8qKlxuICogT25seSBpbXBsZW1lbnRzIG5lZWRlZCBnZXN0dXJlcyBmb3IgbW9iaWxlLlxuICovXG52YXIgR2VzdHVyZU1nciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICovXG4gIHRoaXMuX3RyYWNrID0gW107XG59O1xuXG5HZXN0dXJlTWdyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdlc3R1cmVNZ3IsXG4gIHJlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICB0aGlzLl9kb1RyYWNrKGV2ZW50LCB0YXJnZXQsIHJvb3QpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlY29nbml6ZShldmVudCk7XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdHJhY2subGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2RvVHJhY2s6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0LCByb290KSB7XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuXG4gICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrSXRlbSA9IHtcbiAgICAgIHBvaW50czogW10sXG4gICAgICB0b3VjaGVzOiBbXSxcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b3VjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdG91Y2ggPSB0b3VjaGVzW2ldO1xuICAgICAgdmFyIHBvcyA9IGV2ZW50VXRpbC5jbGllbnRUb0xvY2FsKHJvb3QsIHRvdWNoLCB7fSk7XG4gICAgICB0cmFja0l0ZW0ucG9pbnRzLnB1c2goW3Bvcy56clgsIHBvcy56clldKTtcbiAgICAgIHRyYWNrSXRlbS50b3VjaGVzLnB1c2godG91Y2gpO1xuICAgIH1cblxuICAgIHRoaXMuX3RyYWNrLnB1c2godHJhY2tJdGVtKTtcbiAgfSxcbiAgX3JlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHJlY29nbml6ZXJzKSB7XG4gICAgICBpZiAocmVjb2duaXplcnMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICB2YXIgZ2VzdHVyZUluZm8gPSByZWNvZ25pemVyc1tldmVudE5hbWVdKHRoaXMuX3RyYWNrLCBldmVudCk7XG5cbiAgICAgICAgaWYgKGdlc3R1cmVJbmZvKSB7XG4gICAgICAgICAgcmV0dXJuIGdlc3R1cmVJbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBkaXN0KHBvaW50UGFpcikge1xuICB2YXIgZHggPSBwb2ludFBhaXJbMV1bMF0gLSBwb2ludFBhaXJbMF1bMF07XG4gIHZhciBkeSA9IHBvaW50UGFpclsxXVsxXSAtIHBvaW50UGFpclswXVsxXTtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRlcihwb2ludFBhaXIpIHtcbiAgcmV0dXJuIFsocG9pbnRQYWlyWzBdWzBdICsgcG9pbnRQYWlyWzFdWzBdKSAvIDIsIChwb2ludFBhaXJbMF1bMV0gKyBwb2ludFBhaXJbMV1bMV0pIC8gMl07XG59XG5cbnZhciByZWNvZ25pemVycyA9IHtcbiAgcGluY2g6IGZ1bmN0aW9uICh0cmFjaywgZXZlbnQpIHtcbiAgICB2YXIgdHJhY2tMZW4gPSB0cmFjay5sZW5ndGg7XG5cbiAgICBpZiAoIXRyYWNrTGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBpbmNoRW5kID0gKHRyYWNrW3RyYWNrTGVuIC0gMV0gfHwge30pLnBvaW50cztcbiAgICB2YXIgcGluY2hQcmUgPSAodHJhY2tbdHJhY2tMZW4gLSAyXSB8fCB7fSkucG9pbnRzIHx8IHBpbmNoRW5kO1xuXG4gICAgaWYgKHBpbmNoUHJlICYmIHBpbmNoUHJlLmxlbmd0aCA+IDEgJiYgcGluY2hFbmQgJiYgcGluY2hFbmQubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIHBpbmNoU2NhbGUgPSBkaXN0KHBpbmNoRW5kKSAvIGRpc3QocGluY2hQcmUpO1xuICAgICAgIWlzRmluaXRlKHBpbmNoU2NhbGUpICYmIChwaW5jaFNjYWxlID0gMSk7XG4gICAgICBldmVudC5waW5jaFNjYWxlID0gcGluY2hTY2FsZTtcbiAgICAgIHZhciBwaW5jaENlbnRlciA9IGNlbnRlcihwaW5jaEVuZCk7XG4gICAgICBldmVudC5waW5jaFggPSBwaW5jaENlbnRlclswXTtcbiAgICAgIGV2ZW50LnBpbmNoWSA9IHBpbmNoQ2VudGVyWzFdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3BpbmNoJyxcbiAgICAgICAgdGFyZ2V0OiB0cmFja1swXS50YXJnZXQsXG4gICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gT25seSBwaW5jaCBjdXJyZW50bHkuXG5cbn07XG52YXIgX2RlZmF1bHQgPSBHZXN0dXJlTWdyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29yZS9HZXN0dXJlTWdyLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog6YCJ5Lit6IqC54K55ZCO77yM5Ye6546w55qE5pON5L2c5qGG5Y+K5oyJ6ZKuXHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIE5vZGUgPSByZXF1aXJlKFwiLi4vTm9kZVwiKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XHJcbiAgICB2YXIgaWNvbiA9IHJlcXVpcmUoJy4vSWNvbk9wZXJhdGlvbicpO1xyXG4gICAgdmFyIHN5bWJvbFV0aWwgPSByZXF1aXJlKCcuLi9zaGFwZXMvU3ltYm9sJyk7XHJcbiAgICBmdW5jdGlvbiBPcGVyYXRpb25Ob2RlKG5vZGUsIHpyLCBhcGksZm9yYmlkRWRpdCkge1xyXG4gICAgICAgIE5vZGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMuenIgPSB6cjtcclxuICAgICAgICB0aGlzLmZvcmJpZEVkaXQgPSBmb3JiaWRFZGl0O1xyXG4gICAgICAgIHRoaXMuX2FwaSA9IGFwaTtcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8v5LqL5Lu2XHJcbiAgICBPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUdFTkQgPSBcIk9wZXJhdGlvbk5vZGU6ZHJhZ2VuZEFycm93XCI7XHJcbiAgICBPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUcgPSBcIk9wZXJhdGlvbk5vZGU6ZHJhZ0Fycm93XCI7XHJcbiAgICBPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUdTVEFSVCA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnc3RhcnRBcnJvd1wiO1xyXG4gICAgT3BlcmF0aW9uTm9kZS5ERUxFVEVfQ0xJQ0sgPSBcIk9wZXJhdGlvbk5vZGU6ZGVsZXRlQ2xpY2tcIjtcclxuICAgIE9wZXJhdGlvbk5vZGUuREVMID0gXCJERUxcIjtcclxuICAgIE9wZXJhdGlvbk5vZGUuQ09NTUVOVF9DTElDSyA9IFwiT3BlcmF0aW9uTm9kZTpjb21tZW50Q2xpY2tcIjtcclxuICAgIE9wZXJhdGlvbk5vZGUuQ09NTUVOVCA9IFwiQ09NTUVOVFwiO1xyXG4gICAgICAgIC8v5YaF572u5pON5L2c5Zu+5qCH55qE5Zu+5YOPXHJcbiAgICBPcGVyYXRpb25Ob2RlLm9waWNvbnMgPSB7XHJcbiAgICAgICAgU1RSQUlHSFQ6IGljb24uU1RSQUlHSFRfU1ZHLFxyXG4gICAgICAgIEpBR0dFRDogaWNvbi5KQUdHRURfU1ZHLFxyXG4gICAgICAgIENVUlZFOiBpY29uLkNVUlZFX1NWRyxcclxuICAgICAgICBERUw6IGljb24uREVMX1NWRyxcclxuICAgICAgICBDT01NRU5UOiBpY29uLkNPTU1FTlRfU1ZHXHJcbiAgICB9O1xyXG5cclxuICAgIE9wZXJhdGlvbk5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyQmFzZSgpO1xyXG4gICAgICAgIGlmICghdGhpcy5mb3JiaWRFZGl0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyT3RoZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZXJhdGlvbk5vZGUucHJvdG90eXBlLnJlbmRlckJhc2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZU9wZXJhdGlvbigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5jcmVhdGVPcGVyYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xyXG4gICAgICAgIHZhciBpZlNob3dOb2RlT3BlcmF0aW9uSWNvbnMgPSB0aGlzLm5vZGUub3BlcmF0aW9uSWNvbnM7XHJcbiAgICAgICAgaWYgKHRoaXMubm9kZS5wYXJlbnQgJiYgdGhpcy5ub2RlLnBhcmVudC50eXBlID09PSAnZHJhZ1NlbGVjdCcpIHtcclxuICAgICAgICAgICAgaWZTaG93Tm9kZU9wZXJhdGlvbkljb25zID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5ub2RlLnNlbGVjdFN0eWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbFJlY3QgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSh7IHN0eWxlOiB7IGxpbmVEYXNoOiBbMl0gfSB9KTtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsUmVjdC5pc1NlbGZDb21wdXRlUG9zID0gdHJ1ZTsgIC8vIOiHquW3seiuoeeul+S9jee9rlxyXG4gICAgICAgICAgICB0aGlzLmFkZCh0aGlzLnZpcnR1YWxSZWN0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgaWYgKHRoaXMubm9kZS50eXBlID09PSAnWlBhdGgnKSB7ICAvL2FkZEhvdmVy6ZyA6KaB5LuO5a6D6Ieq6Lqr55qE5p6E6YCg5Ye95pWw5Lit5Yib5bu644CCMS5QYWludGVy5LitYWRkSG92ZXLmupDnoIHmmK/moLnmja5zaGFwZeS4jnN0eWxl5Yib5bu6IDIucGF0aOS4reeahOaehOmAoOWHveaVsOaYr+i/lOWbnuWPpuS4gOS4quWFg+e0oFxyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLl96Q2xvbmVTdHlsZSA9IHRoaXMubm9kZS5zdHlsZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgIHRoaXMubm9kZS5zZXRTdHlsZSh0aGlzLm5vZGUuc2VsZWN0U3R5bGUpO1xyXG4gICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMubm9kZS5zZXRPckNhbmNlbFNlbGVjdFN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUuc2V0T3JDYW5jZWxTZWxlY3RTdHlsZSh0cnVlKTtcclxuICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcGkuZ2V0WnIoKS5hZGRIb3Zlcih0aGlzLm5vZGUsIHRoaXMubm9kZS5zZWxlY3RTdHlsZSk7XHJcbiAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlmU2hvd05vZGVPcGVyYXRpb25JY29ucykge1xyXG4gICAgICAgICAgICB6clV0aWwuZWFjaCh0aGlzLm5vZGUub3BlcmF0aW9uSWNvbnMsIGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIC8v5qOA5p+l5piv5ZCm5piv5YaF572u5Zu+5qCHXHJcbiAgICAgICAgICAgICAgICB2YXIgb3BJY29uSW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbkljb24gPSBPcGVyYXRpb25Ob2RlLm9waWNvbnNbaXRlbS5uYW1lLnRvVXBwZXJDYXNlKCkgKyBcIlwiXVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbkljb24pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZm9yYmlkRWRpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmhpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLm5hbWUgPT0gT3BlcmF0aW9uTm9kZS5ERUwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy/lnoPlnL7mobZcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2UgPSBncmFwaGljLm1ha2VQYXRoKG9wZXJhdGlvbkljb24sIHsgc3R5bGU6IHsgZmlsbDogJyNhYWFhYWMnIH0sejptZS5ub2RlLnorMSxyZWN0SG92ZXI6IHRydWUgfSwgeyB4OiAwLCB5OiAwLCB3aWR0aDogMTAsIGhlaWdodDogMTUgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpdGVtLmNhbGxiYWNrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5ub2RlID0gbWUubm9kZTsgIC8vIOWwhuaJgOmZhOeahOiKgueCueS5n+S8oOmAkuWHuuWOu1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY2FsbGJhY2soZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBPcGVyYXRpb25Ob2RlLkRFTEVURV9DTElDSztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0ubmFtZSA9PSBPcGVyYXRpb25Ob2RlLkNPTU1FTlQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZSA9IGdyYXBoaWMubWFrZVBhdGgob3BlcmF0aW9uSWNvbiwgeyBzdHlsZTogeyBmaWxsOiAnI2FhYWFhYycgfSwgejptZS5ub2RlLnorMiwgcmVjdEhvdmVyOiB0cnVlIH0sIHJlY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gT3BlcmF0aW9uTm9kZS5DT01NRU5UX0NMSUNLO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3RPdGhlciA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDE1LCBoZWlnaHQ6IDE1IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlID0gZ3JhcGhpYy5tYWtlUGF0aChvcGVyYXRpb25JY29uLCB7IHN0eWxlOiB7IGZpbGw6ICcjYWFhYWFjJyB9LGRyYWdnYWJsZTp0cnVlLHo6bWUubm9kZS56KzIsbGluZVR5cGU6IENvbm5lY3RvcltcIlRZUEVfXCIgKyBpdGVtLm5hbWUudG9VcHBlckNhc2UoKV0scmVjdEhvdmVyOiB0cnVlIH0sIHJlY3RPdGhlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnZHJhZ3N0YXJ0JywgJ2RyYWcnLCAnZHJhZ2VuZCddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24oZXZlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2Uub24oZXZlTmFtZSwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5kYXRhID0gaXRlbS5vcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcIk9wZXJhdGlvbk5vZGU6XCIgKyBldmVOYW1lICsgXCJBcnJvd1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2UgPSBzeW1ib2xVdGlsLmNyZWF0ZVN5bWJvbChpdGVtLmljb25QYXRoLCAwLCAwLCBpdGVtLndpZHRoIHx8IDE1LCBpdGVtLmhlaWdodCB8fCAxNSwgbWUubm9kZS56KzEsIGl0ZW0uY29sb3J8fCcjMDAwJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubm9kZSA9IG1lLm5vZGU7ICAvLyDlsIbmiYDpmYTnmoToioLngrnkuZ/kvKDpgJLlh7rljrtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY2FsbGJhY2soZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtID0ge2V2ZW50OmUsIHR5cGU6XCJPcGVyYXRpb25Ob2RlOlwiICsgaXRlbS5uYW1lICsgXCJDbGlja1wifTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWUuX2FwaS50cmlnZ2VyKHBhcmFtLnR5cGUsIHBhcmFtKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlLm5hbWUgPSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBtZS5hZGQob3BJY29uSW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZXJhdGlvbk5vZGUucHJvdG90eXBlLnJlZnJlc2hQb3N0aW9uID0gZnVuY3Rpb24obm9kZSwgbm9kZVJlY3QpIHtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgdmFyIHJiUG9pbnQgPSB6clV0aWwuY2xvbmUobm9kZVJlY3QucG9pbnRzWzJdKTsgLy/lj5blj7PkuIvop5LlnZDmoIdcclxuICAgICAgICB2YXIgcm90YXRpb24gPSBub2RlLnJvdGF0aW9uO1xyXG4gICAgICAgIHZhciBhbmdsZSA9IHJvdGF0aW9uIC8gKE1hdGguUEkvMTgwKTtcclxuICAgICAgICBpZiAoTWF0aC5hYnMocm90YXRpb24pID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgY29ubmVjdG9yQ29udHJvbHMgPSBVdGlsLmdldENvbm5lY3RvckNvbnRyb2xzKG5vZGVSZWN0LCBub2RlKTtcclxuICAgICAgICAgICAgdmFyIGJyQ29udHJvbCA9IGNvbm5lY3RvckNvbnRyb2xzLmJyO1xyXG4gICAgICAgICAgICByYlBvaW50ID0gW2JyQ29udHJvbC54IC0gbm9kZVJlY3QueCwgIGJyQ29udHJvbC55IC0gbm9kZVJlY3QueV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vMS7lrprkvY3omZrmoYZcclxuICAgICAgICBpZiAodGhpcy52aXJ0dWFsUmVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxSZWN0LnNldFNoYXBlKHsgcG9pbnRzOiBub2RlUmVjdC5wb2ludHMgfSk7XHJcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC5jaGlsZERyYWdnYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aXJ0dWFsUmVjdC5hdHRyKCd6Jywgbm9kZS5wYXJlbnQueiArIDEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsUmVjdC5hdHRyKCdyb3RhdGlvbicsIHJvdGF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8yLuWumuS9jeavj+S4quWwj+Wbvuagh1xyXG4gICAgICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uKG5vZGVJdGVtKSB7XHJcbiAgICAgICAgICAgIGlmICghbm9kZUl0ZW0uaXNTZWxmQ29tcHV0ZVBvcykge1xyXG4gICAgICAgICAgICAgICAgLy8gOHB45piv56ys5LiA5Liq5pON5L2c5oyJ6ZKu5Zu+5qCH55qE6Led56a7IOmdoOWkqui/keS4jeWlveeciyAgICAyMHB45piv5q+P5Liq5Zu+5qCH55qE6Ze06ZqUICAxMHB45piv5Zu+5qCH5ZCR5YGP55qE6Led56a7XHJcbiAgICAgICAgICAgICAgICBub2RlSXRlbS5hdHRyKFwicG9zaXRpb25cIiwgW2FuZ2xlID49IDAgPyByYlBvaW50WzBdICsgOCArIChpKysgKiAyMCkgOiByYlBvaW50WzBdIC0gMjAgLSAoaSsrICogMjApLCByYlBvaW50WzFdIC0gMTBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbk90aGVyKG5vZGUsbm9kZVJlY3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5yZW5kZXJPdGhlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8v55WZ57uZ5omp5bGV5L2/55SoXHJcbiAgICB9O1xyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVmcmVzaFBvc2l0aW9uT3RoZXIgPSBmdW5jdGlvbihub2RlLG5vZGVSZWN0KSB7XHJcbiAgICAgICAgLy/nlZnnu5nmianlsZXkvb/nlKhcclxuICAgICAgICAvLzMu5a6a5L2N5pW05Liqb3BlcmF0aW9uTm9kZVxyXG4gICAgICAgIGlmICgobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQuaXNCZyAmJiBub2RlLnBhcmVudC5pc0JnID09IHRydWUpIHx8IChub2RlLnBhcmVudC50eXBlID09PSBcIkdyb3VwTm9kZVwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLmF0dHIoXCJwb3NpdGlvblwiLCBbbm9kZVJlY3QueCwgbm9kZVJlY3QueV0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG5vZGVTaGFwZVggPSBub2RlLnNoYXBlPyBub2RlLnNoYXBlLng6MDtcclxuICAgICAgICAgICAgdmFyIG5vZGVTYWhwZVkgPSBub2RlLnNoYXBlPyBub2RlLnNoYXBlLnk6MDtcclxuICAgICAgICAgICAgdGhpcy5hdHRyKFwicG9zaXRpb25cIiwgW25vZGVSZWN0LnggKyBub2RlLnBhcmVudC5wb3NpdGlvblswXStub2RlU2hhcGVYLCBub2RlUmVjdC55ICsgbm9kZS5wYXJlbnQucG9zaXRpb25bMV0rbm9kZVNhaHBlWV0pXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYodGhpcy5ub2RlLnNlbGVjdFN0eWxlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGUudHlwZSA9PT0gJ1pQYXRoJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLnNldFN0eWxlKHRoaXMubm9kZS5fekNsb25lU3R5bGUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5ub2RlLnNldE9yQ2FuY2VsU2VsZWN0U3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5zZXRPckNhbmNlbFNlbGVjdFN0eWxlKGZhbHNlKTtcclxuICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcGkuZ2V0WnIoKS5yZW1vdmVIb3Zlcih0aGlzLm5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKE9wZXJhdGlvbk5vZGUsIE5vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBPcGVyYXRpb25Ob2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvT3BlcmF0aW9uTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4vZ3JhcGhpYycpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpXHJcbiAgICAvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZSAg5YyF5ousZnJvbUpTT04gdG9KU09OXHJcbiAgICBmdW5jdGlvbiBOb2RlKCkge1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VJZCA9IHV0aWwuZ2V0VVVJRCgpOyAvLyDnlJ/miJDoioLngrlJRFxyXG4gICAgICAgIGdyYXBoaWMuR3JvdXAuY2FsbCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUseeItuexu+WunueOsFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlLHniLbnsbvlrp7njrBcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0ganNvbiBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24oanNvbikge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkcmF3VGV4dFxyXG4gICAgICogQGRlc2NyaXB0aW9uIOeUu+S4gOS4quaWh+acrFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS5kcmF3VGV4dCA9IGZ1bmN0aW9uKG5hbWUsIGNvbG9yLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciB0ZXh0TmFtZSA9IHRoaXMuYnBtbkluZm8ubmFtZSwgeCwgeTtcclxuICAgICAgICBpZihuYW1lICE9IG51bGwpe1xyXG4gICAgICAgICAgICB0ZXh0TmFtZSA9IG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0TmFtZSxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvciA/IGNvbG9yIDogdGhpcy5vcHRpb25zLnRleHQuY29sb3IsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzEycHggTWljcm9zb2Z0IFlhSGVpJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6bGV2ZWw6IDIwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy/mloflrZfnu5jliLbnmoTkvY3nva4gXHJcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA/IHBvc2l0aW9uIDogJ2luaXQnO1xyXG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcclxuICAgICAgICAgICAgLy/oioLngrnkuIvmlrnlsYXkuK3kvY3nva5cclxuICAgICAgICAgICAgY2FzZSAnaW5pdCc6IFxyXG4gICAgICAgICAgICAgICAgLy94ID0g5Lit5b+D54K5LnggLSDotbflp4vkvY3nva4ueCAtIOaWh+Wtl+WuveW6pueahOS4gOWNilxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0UmVjdCgpLnggLSB0aGlzLnBvc2l0aW9uWzBdIC0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAvL3kgPSDkuK3lv4PngrkueSAtIOi1t+Wni+S9jee9ri55ICsg5YGP56e75YC877yINu+8iVxyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2V0UmVjdCgpLnkgLSB0aGlzLnBvc2l0aW9uWzFdICsgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyICsgNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvL+iKgueCueWGhemDqOWxheS4reS9jee9rlxyXG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0UmVjdCgpLnggLSB0aGlzLnBvc2l0aW9uWzBdIC0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRSZWN0KCkueSAtIHRoaXMucG9zaXRpb25bMV0gLSA2O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIC8v6IqC54K55YaF6YOo5bGF5bem5L2N572uXHJcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOiBcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLmdldFJlY3QoKS54IC0gdGhpcy5wb3NpdGlvblswXSAtIHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggKyA2O1xyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2V0UmVjdCgpLnkgLSB0aGlzLnBvc2l0aW9uWzFdIC0gNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OiBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dC5hdHRyKFwic3R5bGVcIiwgeyB4OiB4LCB5OiB5IH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgICAgIHJlY3Q6IHRleHQuZ2V0Qm91bmRpbmdSZWN0KClcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogcmVmcmVzaFRleHRcclxuICAgICAqIEBkZXNjcmlwdGlvbiDliLfmlrDmlofmnKxcclxuICAgICAqL1xyXG4gICAgTm9kZS5wcm90b3R5cGUucmVmcmVzaFRleHQgPSBmdW5jdGlvbihwb3MpIHtcclxuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJUaXRsZVwiKSwgeCwgeTtcclxuICAgICAgICBwb3MgPSBwb3MgPyBwb3MgOiAnaW5pdCc7XHJcbiAgICAgICAgc3dpdGNoIChwb3MpIHtcclxuICAgICAgICAgICAgY2FzZSAnaW5pdCc6IFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0UmVjdCgpLnggLSB0aGlzLnBvc2l0aW9uWzBdIC0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRSZWN0KCkueSAtIHRoaXMucG9zaXRpb25bMV0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAvIDIgKyA2O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5nZXRSZWN0KCkueCAtIHRoaXMucG9zaXRpb25bMF0gLSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLmdldFJlY3QoKS55IC0gdGhpcy5wb3NpdGlvblsxXSAtIDY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICB4ID0gMjtcclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLmdldFJlY3QoKS55IC0gdGhpcy5wb3NpdGlvblsxXSAtIDY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDogYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHQuYXR0cihcInN0eWxlXCIsIHsgeDogeCwgeTogeSB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOeUseeItuexu+WunueOsFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgZ3JhcGhpYy5VdGlsLmluaGVyaXRzKE5vZGUsIGdyYXBoaWMuR3JvdXApO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDov57mjqXnur9cclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOb2RlID0gcmVxdWlyZShcIi4uL05vZGUuanNcIik7XHJcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoXCIuL1N5bWJvbC5qc1wiKTtcclxuICAgIHZhciBIYW5kbGUgPSByZXF1aXJlKFwiLi9IYW5kbGUuanNcIik7XHJcbiAgICB2YXIgRWZmZWN0TGluZSA9IHJlcXVpcmUoXCIuL0VmZmVjdExpbmUuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdGlvblBvaW50ID0gcmVxdWlyZShcIi4vQ29ubmVjdGlvblBvaW50LmpzXCIpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZShcIi4uL21vZGVsLmpzXCIpO1xyXG5cclxuICAgIENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUID0gJ3N0cmFpZ2h0JztcclxuICAgIENvbm5lY3Rvci5UWVBFX0pBR0dFRCA9ICdqYWdnZWQnO1xyXG4gICAgQ29ubmVjdG9yLlRZUEVfQ1VSVkUgPSAnY3VydmUnO1xyXG4gICAgQ29ubmVjdG9yLlRZUEVfQ0hBSU4gPSAnY2hhaW4nO1xyXG4gICAgQ29ubmVjdG9yLlJBRElVUyA9IDM7XHJcbiAgICBDb25uZWN0b3IuU1RBUlRfTk9ERSA9IFwic3RhcnROb2RlXCI7XHJcbiAgICBDb25uZWN0b3IuRU5EX05PREUgPSBcImVuZE5vZGVcIjtcclxuICAgIENvbm5lY3Rvci5MRUZUID0gXCJsZWZ0XCI7XHJcbiAgICBDb25uZWN0b3IuUklHSFQgPSBcInJpZ2h0XCI7XHJcbiAgICBDb25uZWN0b3IuVE9QID0gXCJ0b3BcIjtcclxuICAgIENvbm5lY3Rvci5CT1RUT00gPSBcImJvdHRvbVwiO1xyXG4gICAgQ29ubmVjdG9yLkJPVFRPTSA9IFwiYm90dG9tXCI7XHJcbiAgICBDb25uZWN0b3IuU0VQRVJBVE9SID0gXCItXCI7XHJcbiAgICBDb25uZWN0b3IuTk9STUFMX0NPTE9SID0gXCIjMDAwXCI7XHJcbiAgICBDb25uZWN0b3IuU0VMRUNURURfQ09MT1IgPSAnIzc0QjdFMCc7XHJcbiAgICBDb25uZWN0b3IuQ0hJTERfTkFNRSA9IFsnbGluZVRleHQnLCAnbGluZUltYWdlJ107XHJcbiAgICAvKipcclxuICAgICAqIOaehOmAoOWHveaVsFxyXG4gICAgICogQHBhcmFtIHtbdHlwZV19IG9wdGlvbnMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDb25uZWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIE5vZGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9wdCA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgaWYgKHRoaXMub3B0Lm1vZGVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VJZCA9IHRoaXMub3B0Lm1vZGVsLmdldChcInJlc291cmNlSWRcIik7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSB0aGlzLm9wdC5tb2RlbDtcclxuICAgICAgICAgICAgdGhpcy5vcHQgPSB0aGlzLm9wdC5tb2RlbC5vcHRpb247XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZUlkID0gVXRpbC5nZXRVVUlEKCk7IC8vIOeUn+aIkOiKgueCuUlEXHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBuZXcgTW9kZWwoe30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHN5bWJvbDogeyB0eXBlOiBcImFycm93XCIsIHNpemU6IDEwLCBjb2xvcjogQ29ubmVjdG9yLk5PUk1BTF9DT0xPUiwgYm90aDpmYWxzZSwgb2Zmc2V0OjAgfSwgLy/nrq3lpLQgIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICAgICAgICBzdHlsZTogeyBsaW5lV2lkdGg6IDEsIHN0cm9rZTogQ29ubmVjdG9yLk5PUk1BTF9DT0xPUiwgbGluZVR5cGU6IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUIH0sIC8v5qC35byPXHJcbiAgICAgICAgICAgIGhvdmVyU3R5bGU6IHsgbGluZVdpZHRoOiAyLCBzdHJva2U6IENvbm5lY3Rvci5TRUxFQ1RFRF9DT0xPUiB9LCAvL+enu+S4iuWOu+eahOagt+W8j1xyXG4gICAgICAgICAgICBhcnJvd0hvdmVyU3R5bGU6IHsgZmlsbDogQ29ubmVjdG9yLlNFTEVDVEVEX0NPTE9SfSxcclxuICAgICAgICAgICAgc2hhcGU6IHsgcG9pbnRzOiBudWxsLCBzbW9vdGg6IGZhbHNlLCBzbW9vdGhDb25zdHJhaW50OiBudWxsIH0sIC8v5b2i54q2XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHN0YXJ0UG9zOm51bGwsIGVuZFBvczpudWxsLCAgLy/mjIflrprnur/mrrXotbflp4vkuI7nu4jmraIg5Zyo6IqC54K555qE5LuA5LmI5L2N572uIOm7mOiupOWAvOS4uidsZWZ0LHJpZ2h0JyAg5Y+v5Y+W5YC85Zub5Liq5pa55ZCRdG9wLGJvdHRvbSxsZWZ0LHJpZ2h0IOaWueWQkeWPr+WKoOWBj+enu+mHj+WmguWmgiBcImxlZnQrMTAsdG9wXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6WzAsMF0sICAvLyDotbflp4vnur/mrrXnprvoioLngrnnmoTlgY/np7tcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kT2Zmc2V0OlswLDBdLCAgICAvLyDnu4jmraLnur/mrrXnprvoioLngrnnmoTlgY/np7tcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlRGlzdGFuY2U6WzMwLDMwXSwgLy8g56ys5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM5pyA5ZCO5LiA5p2h5oqY57q/55qE6ZW/5bqmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czpudWxsICAgIC8v5LiN5L2/55So6Ieq5Yqo6K6h566XIOaMh+Wumui/nue6v+eahOaKmOeCueS9jee9ruaVsOe7hO+8jOmmluWwvuWPr+S7peS9v+eUqGxlZnQscmlnaHQsdG9wLGJvdHRvbVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF1dG9DaGFuZ2VQb3NpdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIHRleHRDb250ZXh0TWVudTogbnVsbCxcclxuICAgICAgICAgICAgaXNFZGl0OiB0cnVlLCAvL+aYr+WQpuWPr+e8lui+kVxyXG4gICAgICAgICAgICB0ZXh0OiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgdGV4dEZpbGw6ICcjMDAwMDAwJywgLy8g5paH5pys6aKc6ImyXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzEycHggTWljcm9zb2Z0IFlhSGVpJyxcclxuICAgICAgICAgICAgICAgIHRleHRQb3M6ICdjZW50ZXInLFxyXG4gICAgICAgICAgICAgICAgdGV4dFJvdGF0ZWFibGU6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW1hZ2U6IHtcclxuICAgICAgICAgICAgICAgIGltYWdlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDUwLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1MCxcclxuICAgICAgICAgICAgICAgIC8vIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gaW1hZ2U6IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFEd0FBQUF5Q0FZQUFBQUE5cmdDQUFBRVprbEVRVlJvUSsyYVhZZ2JWUlRIei84bXV3U0pXUHg0c0Znb2FCVXJXb3JVTDhTSzlVR2hGQ3QyVVJSaFFhaTZ1TERaeVIwRGhUYUladS9OWlBkTnJZTDRoYUtsZmxEd29TZ1VWS3JZSWhSYVA3QjkySWJ0ZzFKZklxelpuUnk1eTBSbXgyUjNNcWxKWnBONW5Ebm4zdi92bm52bm52c0JhdkJvcmE4SGNGdXRWdHZTNkhzdnZ4TkNuQWR3aXBuUFpMUFp2NEphRVh5aHRTNFNrZFhMVUNHMXpRb2g5bG1XOVo3ZmZobXcxbnFXaURhRUxEQVdac3ljdDIzN1FGM3N2OEJhNisrSTZNNVlVTFF1OGo0cDVkZkdiUWxZS1hVQXdQN1d5NG1OeHk4QWJqZGp1Zzc4SVlESGZmTEx6UHlTYmR0dnhBYkpFK280em1iWGRVZUNBUlJDM0dGWjFnOTFZTk1DTi9yZ0Rra3BSK0lHVzllcnRkNUpSRWNDK2tlbGxHOHZBV3V0MmY4eE9ORGpDTjZNYVFCc29qbUljQXo3OUtCTGV3bklZQXozMGhndUZvdTdtWGtUZ04rRkVMT1RrNU5maFIxZHNldlNXdXVQaVdoUEFQQlRLZVdqWWFCakJheVVPbUZTd1NaZ3owc3BYMXNOT2piQVRiS2taWHpKWlBLcVRDWnpjU1hvMkFBcnBTWUJPQ3ZCQUxncm04MSt2eWFBaThYaUtETy90UktNRU9KbXk3SitYaFBBcFZKcGgrdTZYemFEQWZCcnBWTFprcy9uNXpzT1BETXpzMjVoWVdFak0vOWgyM1o1dFI5SjJPOWE2MCtJYUhjaiswUWk4V0NZNmVtU2pPRkNvWEMvRUdJUGdIdUlhQ01ScmZPSk9rMUVSNG5vT0RNZmI3Y0J0TmJQRWRHcnZ2TG52RFg2NjJFYXJpMWdwVlFXZ0prVHQ0V3B6RXRlQ3VsMCtwV3hzYkZLV0orZzNmVDA5Sld1NjI1aTVvdXBWR3AyZkh6ODc3QmxSUWJXV2hlSTZNV3dGZm50QVB3STRDbkxzczVFOFcvSHB4M2daWnNERVVTY0ZrS01kQnI2a2dFejgyOEFQZ2R3ZUhGeDhjTDgvUHhjT3AzZVdxdlZIZ2J3VUpPZHo4TlN5c2NpTkZaa2w4akEzbzdtZHEvbW9wVHlpMVdtQTJrMlFvTTJBSjdOWnJNSEl4TzA2QmdadU1WNmxzeTExazhUMFRzQjMzSXltZHlleVdUT1JTbXpWWitPQW52UUpzb20ydjduQXlubGs2MktqMkxmY1dESGNhNnUxV3JmRU5GTmZzSE0vTEp0Mi91aVFMVGkwM0ZnTDhyUEVOR2JRYUhNdkNGTVlsSW9GTFlKSWN3eThWWUFtd0Y4UzBRbm1mbVVsUExzS3YrU2hsdlAvL3NXajliYTVNVTdHb2k3VjBwcEFQN3pURTFObVpPREp3QThzZ0xVUjh6czJMWjlvcEZOVnlKc2hDaWxkcGxwcklsd2s0WWVOV2U2cnV1V2hSQVBNUE1vZ0d0Q2R0OHFFVG11NnpxNVhPNVB2MC9YZ0wydWJmTGZ2U0Vob3BqOVJFVDdwWlNINnM1ZEJmYWdUWlIzUmFDWk13c1NBT2VZMlN4WTdpYWk2eHFWTXpRMHRINWlZdUtDVjE5M3huQ2dtelg4aVRWcGhMUE0vUDd3OFBEQk9vUXZlaTh3OHppQUcveSs5UlBDbmdFMlFuekhtU2JWdktVQjdHY0EzcTFVS2tmeStmeGlzeDdocmFRTXVKbnJMeU9pWXdCMjF1OTFkTDFMTnhLdWxMbzhtVXhlVzYxVzF5Y1NpZk9wVktyY3loTFFsRmtxbGJaV3E5VXJjcm5jc1o3NWFVVVl0MjI3OUdTRTI2WmFvWUFCOE9Bd3pkYzkxdnlCdUZLcXZ5NjFLS1g2N3RwU2YxMU04MUt4L3JsNjZNdFIrK2R5cVErNmY2NFArNkRYN0FYeGZ3QU52ZkZnV2NDeWpBQUFBQUJKUlU1RXJrSmdnZz09XCIsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gd2lkdGg6NTAsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gaGVpZ2h0OjUwXHJcbiAgICAgICAgICAgICAgICAvLyB9LFxyXG4gICAgICAgICAgICAgICAgaW1hZ2VQb3M6ICdjZW50ZXInLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2VSb3RhdGVhYmxlOiB0cnVlIC8vIOWbvueJh+aYr+WQpui3n+maj+e6v+auteaXi+i9rFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OiAwXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBVdGlsLm1lcmdlT3B0KGRlZmF1bHRPcHRpb25zLCB0aGlzLm9wdCwgdHJ1ZSwgJ3RleHRDb250ZXh0TWVudScpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29uUG9pbnRzR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgIHRoaXMuc3RhcnROb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVuZE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGluZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ncm91cEN1cnZlID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICB0aGlzLmljb25zID0gW107IC8vIOeUqOS6juWtmOWCqOe6v+auteS4iumdoueahOaTjeS9nOWbvuagh1xyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e57q/6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbT2JqZWN0XX0gb3B0aW9ucyBb6IqC54K55Y+C5pWwXVxyXG4gICAgICogQHBhcmFtICB7W1N0cmluZ119IHR5cGUgW+iKgueCueexu+Wei10gJ3RleHQnICdpbWFnZSdcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVMaW5lTm9kZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIHR5cGUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHRleHQgPSBudWxsO1xyXG4gICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICB0eXBlID0gJ3RleHQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbm9kZU5hbWUgPSB6clV0aWwuZmluZChDb25uZWN0b3IuQ0hJTERfTkFNRSwgZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpLmluZGV4T2YodHlwZSkgPiAtMTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXkob3B0aW9uc1t0eXBlXSkgJiYgdGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NIQUlOKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnNbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGF0LmRyYXdUZXh0KG5vZGVOYW1lK1wiLVwiK2ksIHYsIDAsIDAsIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHpyVXRpbC5pc1N0cmluZyh2KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBvYmpbdHlwZV0gPSB2O1xyXG4gICAgICAgICAgICAgICAgICAgIG9ialt0eXBlKydJZCddID0gY29udGVudC50ZXh0LmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQub3B0aW9uc1t0eXBlXVt0eXBlXVtpXSA9IG9iajtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5vcHRpb25zW3R5cGVdW3R5cGVdW2ldLnRleHRJZCA9IGNvbnRlbnQudGV4dC5pZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoYXQuYWRkKGNvbnRlbnQudGV4dCk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmNyZWF0ZU5vZGVDb250ZXh0TWVudShjb250ZW50LnRleHQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0ZXh0ID0gdGhpcy5kcmF3VGV4dChub2RlTmFtZSwgb3B0aW9ucywgMCwgMCwgdHlwZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRleHQudGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoYXQuY3JlYXRlTm9kZUNvbnRleHRNZW51KHRleHQudGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuaWZMaW5lTm9kZVJvdGF0ZWFibGUgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSAndGV4dCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQpIHtcclxuICAgICAgICAgICAgaWYgKCh0eXBlID09PSAndGV4dCcgJiYgdGhpcy5vcHRpb25zLnRleHQudGV4dFJvdGF0ZWFibGUpIHx8ICh0eXBlID09PSAnaW1hZ2UnICYmIHRoaXMub3B0aW9ucy5pbWFnZS5pbWFnZVJvdGF0ZWFibGUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5pu05paw6L+e57q/55qE5paH5a2XL+WbvueJh+iKgueCuVxyXG4gICAgICogQHBhcmFtICB7W09iamVjdF19IGxpbmVOb2RlIFvoioLngrldXHJcbiAgICAgKiBAcGFyYW0gIHtbT2JqZWN0XX0gb3B0aW9ucyBb6IqC54K55Y+C5pWwXVxyXG4gICAgICogQHBhcmFtICB7W1N0cmluZ119IHR5cGUgW+iKgueCueexu+Wei10gJ3RleHQnICdpbWFnZSdcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZWZyZXNoTGluZU5vZGUgPSBmdW5jdGlvbihsaW5lTm9kZSwgb3B0aW9ucywgdHlwZSkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgbGluZU5vZGVBcnIgPSBbXSwgbm9kZU5hbWUgPSBDb25uZWN0b3IuQ0hJTERfTkFNRVswXTtcclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgdHlwZSA9ICd0ZXh0JztcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZU5hbWUgPSB6clV0aWwuZmluZChDb25uZWN0b3IuQ0hJTERfTkFNRSwgZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpLmluZGV4T2YodHlwZSkgPiAtMTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NIQUlOICYmIHpyVXRpbC5pc0FycmF5KG9wdGlvbnNbdHlwZV0pKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnNbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICAgICAgbGluZU5vZGVBcnIucHVzaChzZWxmLmNoaWxkT2ZOYW1lKG5vZGVOYW1lKyctJytpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWxpbmVOb2RlICYmIG9wdGlvbnNbdHlwZV0pIHtcclxuICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmRyYXdUZXh0KG5vZGVOYW1lLCBvcHRpb25zLCAwLCAwLCB0eXBlKTtcclxuICAgICAgICAgICAgdGhpcy5hZGQodGV4dC50ZXh0KTtcclxuICAgICAgICAgICAgbGluZU5vZGUgPSB0aGlzLmNoaWxkT2ZOYW1lKG5vZGVOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpbmVOb2RlQXJyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGNudCA9IGxpbmVOb2RlQXJyLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gdGhpcy50dXJuaW5nUG9pbnRzWzFdLnggLSB0aGlzLnR1cm5pbmdQb2ludHNbMF0ueCxcclxuICAgICAgICAgICAgICAgIGdhcCA9IHBhcnNlSW50KGRpc3RhbmNlL2NudCksXHJcbiAgICAgICAgICAgICAgICBwb3MgPSAtKGdhcCkgKiBwYXJzZUludChjbnQvMik7XHJcblxyXG4gICAgICAgICAgICAgICAgbGluZU5vZGVBcnIuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleHRQb2ludCA9IHNlbGYuZ2V0VGV4dFBvc3Rpb24ob3B0aW9ucywgdiksIHdheSA9ICcnO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciByYXRlID0gc2VsZi5nZXRUZXh0Um90YXRpb24odGV4dFBvaW50LCB2KTtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhyYXRlKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXkgPSByYXRlID4gMCA/ICdwbHVzJyA6ICdtaW51cyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByYXRlID0gTWF0aC5hYnMocmF0ZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVnID0gKDE4MCpyYXRlKS9NYXRoLlBJO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gbnVsbCwgbGVuZ3RoID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2LnNldFN0eWxlKFwidGV4dFwiLCB6clV0aWwuaXNTdHJpbmcob3B0aW9uc1t0eXBlXVtpXSkgPyBvcHRpb25zW3R5cGVdW2ldIDogb3B0aW9uc1t0eXBlXVtpXS50ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmm7TmlrDmloflrZfnn6nlvaLljIXlm7Tnm5JcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dEJvdW5kaW5nUmVjdCA9IHNlbGYuZ2V0VGV4dEJvdW5kaW5nUmVjdCh2LnN0eWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB2LnNldFNoYXBlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRleHRCb3VuZGluZ1JlY3Qud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGV4dEJvdW5kaW5nUmVjdC5oZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAod2F5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm90YXRpb24gPSBkZWcgPiA5MCA/ICgoZGVnLTQ1KSpNYXRoLlBJKS8xODAgOiAoKDQ1K2RlZykqTWF0aC5QSSkvMTgwO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gd2F5ID09PSAnbWludXMnID8gLShyb3RhdGlvbikgOiByb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm90YXRpb24gPSAoNDUqTWF0aC5QSSkvMTgwXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2LmF0dHIoJ3JvdGF0aW9uJywgcm90YXRpb24pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkZWcgPT09IDkwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dFBvaW50WzFdIC09IHBvcztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dFBvaW50WzBdICs9IHBvcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmF0ZSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBNYXRoLnRhbihkZWcqTWF0aC5QSS8xODApKnBvcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb2ludFsxXSAtPSB3YXkgPT09ICdwbHVzJyA/IGxlbmd0aCA6IC0obGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb2ludFsxXSArPSB3YXkgPT09ICdwbHVzJyA/IC0obGVuZ3RoKSA6IChsZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHYuYXR0cihcInBvc2l0aW9uXCIsIHRleHRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICBwb3MgKz0gZ2FwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpbmVOb2RlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVOb2RlLnNldFN0eWxlKFwidGV4dFwiLCBvcHRpb25zW3R5cGVdKTtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXh0UmVjdCA9IHRoaXMuZ2V0VGV4dEJvdW5kaW5nUmVjdChvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGxpbmVOb2RlLnNldFNoYXBlKHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGV4dFJlY3Qud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0ZXh0UmVjdC5oZWlnaHRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ZXh0UG9pbnQgPSB0aGlzLmdldFRleHRQb3N0aW9uKG9wdGlvbnMsIGxpbmVOb2RlKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaWZMaW5lTm9kZVJvdGF0ZWFibGUodHlwZSkpIHsgLy8jMTg3XHJcbiAgICAgICAgICAgICAgICBsaW5lTm9kZS5hdHRyKCdyb3RhdGlvbicsIHRoaXMuZ2V0VGV4dFJvdGF0aW9uKHRleHRQb2ludCwgbGluZU5vZGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaW5lTm9kZS5hdHRyKFwicG9zaXRpb25cIiwgdGV4dFBvaW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6YeN5paw55S757q/77yM5aaC5p6c5Lyg56m65YiZ5qC55o2udHVybmluZ1BvaW50cyDph43mlrDnlLvnur9cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcG9pbnRzIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oYXJyUG9pbnRzKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIGlmIChhcnJQb2ludHMpIHtcclxuICAgICAgICAgICAgdGhpcy50dXJuaW5nUG9pbnRzID0gYXJyUG9pbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+Wwhlt4OjAseTowXei9rOWMluS4ulswLCAwXSAg57uZenJlbmRlcuS9v+eUqFxyXG4gICAgICAgIHZhciBwb2ludHMgPSBVdGlsLnRyYXNsYXRlUG9pbnRzKHRoaXMudHVybmluZ1BvaW50cyk7XHJcblxyXG4gICAgICAgIGlmICgodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSAmJiAocG9pbnRzLmxlbmd0aCA+IDIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q3VydmUodGhpcy50dXJuaW5nUG9pbnRzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmUuYXR0cignc2hhcGUnLCB7IHBvaW50czogcG9pbnRzIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5pu05paw57q/5q615paH5a2XL+WbvueJh+iKgueCuVxyXG4gICAgICAgIENvbm5lY3Rvci5DSElMRF9OQU1FLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgbGluZU5vZGUgPSB0aGF0LmNoaWxkT2ZOYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IG5hbWUgPT09IENvbm5lY3Rvci5DSElMRF9OQU1FWzBdID8gJ3RleHQnIDogJ2ltYWdlJztcclxuICAgICAgICAgICAgdGhhdC5yZWZyZXNoTGluZU5vZGUobGluZU5vZGUsIHRoYXQub3B0aW9uc1t0eXBlXSwgdHlwZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMucmVmcmVzaEZyb21Ub1N5bWJvbChwb2ludHMpO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaEhhbmRsZXMoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uue6v+S4iuiKgueCueeahOWPs+WHu+ebkeWQrFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY3JlYXRlTm9kZUNvbnRleHRNZW51ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICBpZiAobm9kZSAmJiB0aGlzLm9wdC50ZXh0Q29udGV4dE1lbnUpIHtcclxuICAgICAgICAgICAgdmFyIHRleHRDb250ZXh0TWVudSA9IHRoaXMub3B0LnRleHRDb250ZXh0TWVudTtcclxuICAgICAgICAgICAgbm9kZS5vbihcImNvbnRleHRtZW51XCIsZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgZS5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgZS5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIHRleHRDb250ZXh0TWVudS5idWlsZE1lbnUoZS5ldmVudCx0aGlzKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOa4suafk1xyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIC8vMS7liJvlu7rnrq3lpLRcclxuICAgICAgICB0aGlzLnJlbmRlckZyb21Ub1N5bWJvbCgpO1xyXG5cclxuICAgICAgICAvLzIu5Yib5bu657q/XHJcbiAgICAgICAgdGhpcy5jdXJ2ZUxpbmUgPSBuZXcgZ3JhcGhpYy5CZXppZXJDdXJ2ZSh7XHJcbiAgICAgICAgICAgIC8vcG9zaXRpb246IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcclxuICAgICAgICAgICAgc3R5bGU6IHRoaXMub3B0aW9ucy5zdHlsZSxcclxuICAgICAgICAgICAgejogdGhpcy5vcHRpb25zLnpcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmdyb3VwQ3VydmUuYWRkKHRoaXMuY3VydmVMaW5lKTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLmdyb3VwQ3VydmUpO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMuY29uUG9pbnRzR3JvdXApO1xyXG4gICAgICAgIHRoaXMucG9seUxpbmUgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSh7XHJcbiAgICAgICAgICAgIC8vcG9zaXRpb246IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcclxuICAgICAgICAgICAgc2hhcGU6IHRoaXMub3B0aW9ucy5zaGFwZSxcclxuICAgICAgICAgICAgc3R5bGU6IHRoaXMub3B0aW9ucy5zdHlsZSxcclxuICAgICAgICAgICAgejogdGhpcy5vcHRpb25zLnpcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLnBvbHlMaW5lKTtcclxuXHJcbiAgICAgICAgaWYgKCh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZSA9IHRoaXMuZ3JvdXBDdXJ2ZTtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVIb3ZlclN0eWxlKHRoaXMuY3VydmVMaW5lKTtcclxuICAgICAgICAgICAgdGhpcy5wb2x5TGluZS5oaWRlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lID0gdGhpcy5wb2x5TGluZTtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVIb3ZlclN0eWxlKHRoaXMucG9seUxpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnZlTGluZS5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLzMu5L6m5ZCs57q/5LqL5Lu2XHJcbiAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydkYmxjbGljaycsICdjbGljayddOyAvLydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnXHJcbiAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lLm9uKGV2ZU5hbWUsIHpyVXRpbC5iaW5kKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiQ29ubmVjdG9yOlwiICsgZXZlTmFtZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGF0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pc0VkaXQgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IH1cclxuICAgICAgICAgICAgICAgIHRoYXQuc2V0U2VsZWN0ZWRTdHlsZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhbmRsZXMubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcGVTZXRIYW5kbGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgLy80LuWIm+W7uue6v+S4iuaWh+acrFxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dC50ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlTGluZU5vZGUodGhpcy5vcHRpb25zLnRleHQsICd0ZXh0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIC8vIDUu5Yib5bu657q/5LiK5Zu+54mH6IqC54K5XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbWFnZS5pbWFnZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUxpbmVOb2RlKHRoaXMub3B0aW9ucy5pbWFnZSwgJ2ltYWdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnJlbmRlckZyb21Ub1N5bWJvbCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgc3ltYm9sVG8gPSB0aGlzLmNyZWF0ZVN5bWJvbCgndG9TeW1ib2wnLCB0aGlzLm9wdGlvbnMpOyAvL2Fycm93LHRyaWFuZ2xlXHJcbiAgICAgICAgaWYgKHN5bWJvbFRvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHN5bWJvbFRvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/lpoLmnpzlj4zlkJHnrq3lpLQg5YiZ5YaN5Yib5bu66aaW566t5aS0XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zeW1ib2wuYm90aCkge1xyXG4gICAgICAgICAgICB2YXIgc3ltYm9sRnJvbSA9IHRoaXMuY3JlYXRlU3ltYm9sKCdmcm9tU3ltYm9sJywgdGhpcy5vcHRpb25zKTsgLy9hcnJvdyx0cmlhbmdsZVxyXG4gICAgICAgICAgICBpZiAoc3ltYm9sRnJvbSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoc3ltYm9sRnJvbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZWZyZXNoRnJvbVRvU3ltYm9sID0gZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICB2YXIgc3ltYm9sRnJvbSA9IHRoaXMuY2hpbGRPZk5hbWUoJ2Zyb21TeW1ib2wnKTtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBbXSwgb2Zmc2V0ID0gdGhpcy5vcHRpb25zLnN5bWJvbC5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHN5bWJvbFRvKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWZmZWN0ICYmIHRoaXMub3B0aW9ucy5lZmZlY3Quc2hvdykge1xyXG4gICAgICAgICAgICAgICAgbmV3IEVmZmVjdExpbmUoc3ltYm9sVG8sIHRoaXMub3B0aW9ucywgdGhpcy5ncm91cEN1cnZlLCB0aGlzLnBvbHlMaW5lKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgIT09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gdmVjMi5kaXN0YW5jZShwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IGRpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdmVjMi5sZXJwKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW10sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgLyBkaXN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN5bWJvbFRvLmF0dHIoJ3Bvc2l0aW9uJywgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sVG8uYXR0cigncm90YXRpb24nLCBVdGlsLnRhbmdlbnRSb3RhdGlvbih0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCAtIDJdLCB0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCAtIDFdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzeW1ib2xGcm9tKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uID0gcG9pbnRzWzBdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlICE9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlRnJvbSA9IHZlYzIuZGlzdGFuY2UocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSBkaXN0YW5jZUZyb20pIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHZlYzIubGVycChcclxuICAgICAgICAgICAgICAgICAgICAgICAgW10sIHBvaW50c1swXSwgcG9pbnRzWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgLyBkaXN0YW5jZUZyb20pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvaW50c1swXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzeW1ib2xGcm9tLmF0dHIoJ3Bvc2l0aW9uJywgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICBzeW1ib2xGcm9tLmF0dHIoJ3JvdGF0aW9uJywgVXRpbC50YW5nZW50Um90YXRpb24odGhpcy50dXJuaW5nUG9pbnRzWzFdLCB0aGlzLnR1cm5pbmdQb2ludHNbMF0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOiuvue9rnN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyDmoLflvI/lr7nosaFcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbm90U2F2ZU1vZGVsIOiuvue9ruagt+W8j+aYr+WQpuS/neWtmOWIsOaooeWei+S4rSzpu5jorqTmmK9mYWxzZVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24ob3B0aW9ucyxub3RTYXZlTW9kZWwpIHtcclxuICAgICAgICB2YXIgbGluZU9wdCA9IHt9O1xyXG4gICAgICAgIHZhciBzeW1ib2xUbyA9IG51bGw7XHJcbiAgICAgICAgdmFyIG5vdExpbmVLZXlzID0gWyd0ZXh0JywgJ2ltYWdlJywgJ3N5bWJvbCddO1xyXG4gICAgICAgIC8vIGlmIChvcHRpb25zLmNvbG9yKSB7XHJcbiAgICAgICAgLy8gICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpIHtcclxuICAgICAgICAvLyAgICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZS5lYWNoQ2hpbGQoZnVuY3Rpb24oY3VydmUpIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICBjdXJ2ZS5hdHRyKFwic3R5bGVcIiwgeyBzdHJva2U6IG9wdGlvbnMuY29sb3IgfSk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgZ3JhcGhpYy5zZXROb3JtYWxTdHlsZShjdXJ2ZSwgeyBzdHJva2U6IG9wdGlvbnMuY29sb3IgfSk7XHJcbiAgICAgICAgLy8gICAgICAgICB9KTtcclxuICAgICAgICAvLyAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgICAgIHRoaXMucG9seUxpbmUuYXR0cihcInN0eWxlXCIsIHsgc3Ryb2tlOiBvcHRpb25zLmNvbG9yIH0pO1xyXG4gICAgICAgIC8vICAgICAgICAgZ3JhcGhpYy5zZXROb3JtYWxTdHlsZSh0aGlzLnBvbHlMaW5lLCB7IHN0cm9rZTogb3B0aW9ucy5jb2xvciB9KTtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vICAgICBzeW1ib2xUbyA9IHRoaXMuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XHJcbiAgICAgICAgLy8gICAgIGlmIChzeW1ib2xUbykge1xyXG4gICAgICAgIC8vICAgICAgICAgc3ltYm9sVG8uYXR0cihcInN0eWxlXCIsIHsgZmlsbDogb3B0aW9ucy5jb2xvciB9KTtcclxuICAgICAgICAvLyAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUoc3ltYm9sVG8sIHsgZmlsbDogb3B0aW9ucy5jb2xvciB9KTtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vICAgICBpZighbm90U2F2ZU1vZGVsKSB7XHJcbiAgICAgICAgLy8gICAgICAgICB0aGlzLm9wdGlvbnMuc3R5bGUuc3Ryb2tlID0gb3B0aW9ucy5jb2xvcjtcclxuICAgICAgICAvLyAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zdHlsZS5zdHJva2VcIiwgb3B0aW9ucy5jb2xvcik7XHJcbiAgICAgICAgLy8gICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuc3ltYm9sLmNvbG9yXCIsIG9wdGlvbnMuY29sb3IpO1xyXG4gICAgICAgIC8vICAgICAgICAgdGhpcy5vcHRpb25zLnN5bWJvbC5jb2xvciA9IG9wdGlvbnMuY29sb3I7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZShDb25uZWN0b3IuQ0hJTERfTkFNRVswXSk7XHJcbiAgICAgICAgICAgIC8v5byA5aeL5rKh5pyJ5Yib5bu65paH5pys77yM5ZCO5p2l5Lyg6L+b5p2ldGV4dOS6hu+8jOmcgOimgeWFiOWIm+W7uuaWh+acrFxyXG4gICAgICAgICAgICBpZiAoIWxpbmVUZXh0ICYmIG9wdGlvbnMudGV4dC50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZHJhd1RleHQoQ29ubmVjdG9yLkNISUxEX05BTUVbMF0sIG9wdGlvbnMudGV4dCwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZCh0ZXh0LnRleHQpO1xyXG4gICAgICAgICAgICAgICAgbGluZVRleHQgPSB0aGlzLmNoaWxkT2ZOYW1lKENvbm5lY3Rvci5DSElMRF9OQU1FWzBdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGV4dC50ZXh0IHx8IG9wdGlvbnMudGV4dC50ZXh0ID09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVUZXh0LnNldFN0eWxlKFwidGV4dFwiLCBvcHRpb25zLnRleHQudGV4dCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC50ZXh0ID0gb3B0aW9ucy50ZXh0LnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRleHRQb2ludCA9IHRoaXMuZ2V0VGV4dFBvc3Rpb24ob3B0aW9ucy50ZXh0KTtcclxuICAgICAgICAgICAgbGluZVRleHQuYXR0cihcInBvc2l0aW9uXCIsIHRleHRQb2ludCk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRleHQudGV4dFBvcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRleHQudGV4dFBvcyA9IG9wdGlvbnMudGV4dC50ZXh0UG9zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRleHQub2Zmc2V0KSB7IC8vIzE4N1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRleHQub2Zmc2V0ID0gb3B0aW9ucy50ZXh0Lm9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGV4dC5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgbGluZVRleHQuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0RmlsbDogb3B0aW9ucy50ZXh0LmNvbG9yXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0LnRleHRGaWxsID0gb3B0aW9ucy50ZXh0LmNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50ZXh0LnRleHRGb250KSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lVGV4dC5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRGb250Om9wdGlvbnMudGV4dC50ZXh0Rm9udFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC50ZXh0Rm9udCA9IG9wdGlvbnMudGV4dC50ZXh0Rm9udDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGV4dC50ZXh0RmlsbCkge1xyXG4gICAgICAgICAgICAgICAgbGluZVRleHQuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0RmlsbDogb3B0aW9ucy50ZXh0LnRleHRGaWxsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0LnRleHRGaWxsID0gb3B0aW9ucy50ZXh0LnRleHRGaWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy50ZXh0XCIsIG9wdGlvbnMudGV4dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5pbWFnZSkge1xyXG4gICAgICAgICAgICB2YXIgbGluZUltYWdlID0gdGhpcy5jaGlsZE9mTmFtZShDb25uZWN0b3IuQ0hJTERfTkFNRVsxXSk7XHJcbiAgICAgICAgICAgIC8v5byA5aeL5rKh5pyJ5Yib5bu65Zu+54mH77yM5ZCO5p2l5Lyg6L+b5p2laW1hZ2XkuobvvIzpnIDopoHlhYjliJvlu7rlm77niYdcclxuICAgICAgICAgICAgaWYgKCFsaW5lSW1hZ2UgJiYgb3B0aW9ucy5pbWFnZS5pbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlID0gdGhpcy5kcmF3VGV4dChDb25uZWN0b3IuQ0hJTERfTkFNRVsxXSwgb3B0aW9ucy5pbWFnZSwgMCwgMCwgJ2ltYWdlJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChpbWFnZS50ZXh0KTtcclxuICAgICAgICAgICAgICAgIGxpbmVJbWFnZSA9IHRoaXMuY2hpbGRPZk5hbWUoQ29ubmVjdG9yLkNISUxEX05BTUVbMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbWFnZVBvaW50ID0gdGhpcy5nZXRUZXh0UG9zdGlvbihvcHRpb25zLmltYWdlLCBsaW5lSW1hZ2UpO1xyXG4gICAgICAgICAgICBsaW5lSW1hZ2UuYXR0cihcInBvc2l0aW9uXCIsIGltYWdlUG9pbnQpO1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmltYWdlW2tleV0gPSBvcHRpb25zW2tleV07XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmltYWdlLm9mZnNldCkgeyAvLyMxODdcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5pbWFnZS5vZmZzZXQgPSBvcHRpb25zLmltYWdlLm9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuaW1hZ2VcIiwgb3B0aW9ucy5pbWFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zeW1ib2wpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3ltYm9sLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zeW1ib2wudHlwZSA9IG9wdGlvbnMuc3ltYm9sLnR5cGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuc3ltYm9sLnR5cGVcIiwgb3B0aW9ucy5zeW1ib2wudHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3ltYm9sLnNpemUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zeW1ib2wuc2l6ZSA9IG9wdGlvbnMuc3ltYm9sLnNpemU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuc3ltYm9sLnNpemVcIiwgb3B0aW9ucy5zeW1ib2wuc2l6ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3ltYm9sLmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3ltYm9sLmNvbG9yID0gb3B0aW9ucy5zeW1ib2wuY29sb3I7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuc3ltYm9sLmNvbG9yXCIsIG9wdGlvbnMuc3ltYm9sLmNvbG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zeW1ib2wueikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN5bWJvbC56ID0gb3B0aW9ucy5zeW1ib2wuejtcclxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zeW1ib2wuelwiLCBvcHRpb25zLnN5bWJvbC56KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3ltYm9sVG8gPSB0aGlzLmNoaWxkT2ZOYW1lKCd0b1N5bWJvbCcpO1xyXG4gICAgICAgICAgICBpZiAoc3ltYm9sVG8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHN5bWJvbFRvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3ltYm9sID0gdGhpcy5jcmVhdGVTeW1ib2woXCJ0b1N5bWJvbFwiLCB0aGlzLm1vZGVsLmdldChcIm9wdGlvbnNcIikpXHJcbiAgICAgICAgICAgIGlmIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHN5bWJvbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgaWYgKG5vdExpbmVLZXlzLmluZGV4T2Yoa2V5KSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGxpbmVPcHRba2V5XSA9IG9wdGlvbnNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShsaW5lT3B0KSAhPT0gJ3t9Jykge1xyXG4gICAgICAgICAgICBpZiAobGluZU9wdC5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgbGluZU9wdC5zdHJva2UgPSBsaW5lT3B0LmNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsaW5lT3B0LnN0cm9rZSkge1xyXG4gICAgICAgICAgICAgICAgbGluZU9wdC5jb2xvciA9IGxpbmVPcHQuc3Ryb2tlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZS5lYWNoQ2hpbGQoZnVuY3Rpb24oY3VydmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJ2ZS5hdHRyKFwic3R5bGVcIiwgbGluZU9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5zZXROb3JtYWxTdHlsZShjdXJ2ZSwgbGluZU9wdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9seUxpbmUuYXR0cihcInN0eWxlXCIsIGxpbmVPcHQpO1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpYy5zZXROb3JtYWxTdHlsZSh0aGlzLnBvbHlMaW5lLCBsaW5lT3B0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzeW1ib2xUbyA9IHRoaXMuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XHJcbiAgICAgICAgICAgIGlmIChzeW1ib2xUbyAmJiBsaW5lT3B0LmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKFwic3R5bGVcIiwgeyBmaWxsOiBsaW5lT3B0LmNvbG9yIH0pO1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpYy5zZXROb3JtYWxTdHlsZShzeW1ib2xUbywgeyBmaWxsOiBsaW5lT3B0LmNvbG9yIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCFub3RTYXZlTW9kZWwpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGxpbmVPcHQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN0eWxlW2tleV0gPSBsaW5lT3B0W2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLnN0eWxlXCIrIGtleSwgbGluZU9wdFtrZXldKTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZU9wdC5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zeW1ib2wuY29sb3IgPSBsaW5lT3B0LmNvbG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuvue9rumAieS4rXN0eWxlXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuc2V0U2VsZWN0ZWRTdHlsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIOmAieS4reeahOi/nue6v+Wxgue6p+aYr+acgOmrmOeahFxyXG4gICAgICAgIHZhciBzeW1ib2xUbztcclxuICAgICAgICB0aGlzLnNldFN0eWxlKHRoaXMub3B0aW9ucy5ob3ZlclN0eWxlLCB0cnVlKTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZS5lYWNoQ2hpbGQoZnVuY3Rpb24oY3VydmUpIHtcclxuICAgICAgICAgICAgICAgIGN1cnZlLmF0dHIoXCJ6XCIsIHRoaXMub3B0aW9ucy56ICsgMik7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wb2x5TGluZS5hdHRyKCd6JywgdGhpcy5vcHRpb25zLnogKyAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3ltYm9sVG8gPSB0aGlzLmNoaWxkT2ZOYW1lKCd0b1N5bWJvbCcpO1xyXG4gICAgICAgIGlmIChzeW1ib2xUbykge1xyXG4gICAgICAgICAgICBzeW1ib2xUby5hdHRyKFwielwiLCB0aGlzLm9wdGlvbnMueiArIDIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7lj5bmtojpgInkuK1zdHlsZVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnJlbW92ZVNlbGVjdGVkU3R5bGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc3ltYm9sVG87XHJcbiAgICAgICAgdGhpcy5zZXRTdHlsZSh7Y29sb3I6dGhpcy5vcHRpb25zLnN0eWxlLnN0cm9rZSxsaW5lV2lkdGg6dGhpcy5vcHRpb25zLnN0eWxlLmxpbmVXaWR0aH0sdHJ1ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGN1cnZlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJ2ZS5hdHRyKFwielwiLCB0aGlzLm9wdGlvbnMueik7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wb2x5TGluZS5hdHRyKCd6JywgdGhpcy5vcHRpb25zLnopO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzeW1ib2xUbyA9IHRoaXMuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XHJcbiAgICAgICAgaWYgKHN5bWJvbFRvKSB7XHJcbiAgICAgICAgICAgIHN5bWJvbFRvLmF0dHIoXCJ6XCIsIHRoaXMub3B0aW9ucy56KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W57q/5q616IqC54K555qE5L2N572uXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHRleHQge3RleHQ6JycsIGNvbG9yOicnLCB0ZXh0UG9zOicnfVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgIHt4LHl9XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0VGV4dFBvc3Rpb24gPSBmdW5jdGlvbih0ZXh0LCBub2RlKSB7XHJcbiAgICAgICAgdmFyIHRleHRQb3N0aW9uID0gW107XHJcbiAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dC5pbWFnZSAmJiBub2RlID8gbm9kZS5nZXRCb3VuZGluZ1JlY3QoKSA6IHRoaXMuZ2V0VGV4dEJvdW5kaW5nUmVjdCh0ZXh0KTtcclxuICAgICAgICB2YXIgdGV4dFdpZHRoID0gdGV4dFJlY3Qud2lkdGg7XHJcbiAgICAgICAgdmFyIHRleHRIZWlnaHQgPSB0ZXh0UmVjdC5oZWlnaHQgfHwgMTI7XHJcbiAgICAgICAgdmFyIHBvcztcclxuICAgICAgICBpZiAodGV4dCAmJiAodGV4dC50ZXh0UG9zIHx8IHRleHQuaW1hZ2VQb3MpKSB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0ZXh0Lm9mZnNldCB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgYXJyT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICBwb3MgPSB0ZXh0LnRleHRQb3MgfHwgdGV4dC5pbWFnZVBvcztcclxuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShvZmZzZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJPZmZzZXQgPSBbb2Zmc2V0LCAwXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcG9pbnRzT3JpZ2luID0gVXRpbC5nZXRNYXhMaW5lTGVuZ3RoKFt0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCAtIDJdLCB0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCAtIDFdXSk7XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXSwgYmVpemllclBvaW50cyA9W107XHJcbiAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gVXRpbC5nZXRBbmdsZShwb2ludHNPcmlnaW5bMF0sIHBvaW50c09yaWdpblsxXSk7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGgsIG5ld1BvaW50O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgICAgICBiZWl6aWVyUG9pbnRzID0gdGhpcy5nZXRQb2ludHNGcm9tQ3VydmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb2ludHNPcmlnaW4uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUNvcHkgPSBuZXcgUG9pbnQoaXRlbS54LCBwb2ludHNPcmlnaW5bMV0ueCA+PSBwb2ludHNPcmlnaW5bMF0ueCA/IGl0ZW0ueSAtIHRleHRIZWlnaHQgLyAyIDogaXRlbS55ICsgdGV4dEhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goaXRlbUNvcHkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc3dpdGNoKHBvcykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhcnQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT09IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGFyck9mZnNldFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UG9pbnQgPSBVdGlsLmdldEVuZFBvaW50KHBvaW50c1swXSwgbGVuZ3RoLCBhbmdsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW25ld1BvaW50LngsIG5ld1BvaW50LnkgKyBhcnJPZmZzZXRbMV1dO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW3RoaXMudHVybmluZ1BvaW50c1swXS54IC0gdGV4dFdpZHRoIC8gMiArIGFyck9mZnNldFswXSwgdGhpcy50dXJuaW5nUG9pbnRzWzBdLnkgKyBhcnJPZmZzZXRbMV0gLSB0ZXh0SGVpZ2h0IC8gMl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09PSBDb25uZWN0b3IuVFlQRV9TVFJBSUdIVCAmJiAhdGhpcy5vcHRpb25zLnRleHQudGV4dFJvdGF0ZWFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gVXRpbC5kaXN0YW5jZShwb2ludHNbMF0sIHBvaW50c1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BvaW50ID0gVXRpbC5nZXRFbmRQb2ludChwb2ludHNbMF0sIGxlbmd0aCwgYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFtuZXdQb2ludC54ICAtIHRleHRXaWR0aCArIGFyck9mZnNldFswXSwgbmV3UG9pbnQueSArIGFyck9mZnNldFsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gVXRpbC5kaXN0YW5jZShwb2ludHNbMF0sIHBvaW50c1sxXSkgLSB0ZXh0V2lkdGggKyBhcnJPZmZzZXRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BvaW50ID0gVXRpbC5nZXRFbmRQb2ludChwb2ludHNbMF0sIGxlbmd0aCwgYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFtuZXdQb2ludC54LCBuZXdQb2ludC55ICsgYXJyT2Zmc2V0WzFdXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaWRQb2ludCA9IHRoaXMubWlkZGxlKHRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlmTGluZU5vZGVSb3RhdGVhYmxlKHRleHQuaW1hZ2UgPyAnaW1hZ2UnIDogJ3RleHQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGUgPSB0aGlzLmdldFRleHRSb3RhdGlvbih0ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25CZWZvcmUgPSBbbWlkUG9pbnRbMF0gLSB0ZXh0V2lkdGggLyAyLCBtaWRQb2ludFsxXSAtIHRleHRIZWlnaHQgLyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFV0aWwuY2FsY3VsYXRlUG9pbnRzKHBvc2l0aW9uQmVmb3JlLCB7eDogbWlkUG9pbnRbMF0sIHk6IG1pZFBvaW50WzFdfSwgcm90YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDmm7Lnur/nmoTmloflrZdwb3NpdGlvbuWNleeLrOiuoeeul1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlaXppZXJQb2ludHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIgPSBhcnIuY29uY2F0KGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5yb3VuZChhcnIubGVuZ3RoIC8gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW2FycltpbmRleF0ueCAtIHRleHRXaWR0aCAvIDIsIGFycltpbmRleF0ueSAtdGV4dEhlaWdodCAvIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW21pZFBvaW50WzBdICsgYXJyT2Zmc2V0WzBdLCBtaWRQb2ludFsxXSArIGFyck9mZnNldFsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgIT09IENvbm5lY3Rvci5UWVBFX0NIQUlOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFt0ZXh0UG9zdGlvblswXSAtIHRleHRXaWR0aCAvIDIsIHRleHRQb3N0aW9uWzFdIC0gdGV4dEhlaWdodCAvIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5taWRkbGUodGV4dCk7XHJcbiAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW3Bvc2l0aW9uWzBdIC0gdGV4dFdpZHRoIC8gMiwgcG9zaXRpb25bMV1dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHRQb3N0aW9uO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPlue6v+auteeahOaXi+i9rOinkuW6plxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSB0ZXh0UG9zdGlvbiB7eCx5fVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICDop5LluqblgLxcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5nZXRUZXh0Um90YXRpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgLy/orqHnrpflh7rmnoHlnZDmoIfnmoTop5LluqZcclxuICAgICAgICB2YXIgcG9pbnRzID0gVXRpbC5nZXRNYXhMaW5lTGVuZ3RoKHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgdmFyIG1pZFBvaW50ID0gdGhpcy5taWRkbGUob3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gLU1hdGguYXRhbjIocG9pbnRzWzFdLnkgLSBtaWRQb2ludFsxXSwgcG9pbnRzWzFdLnggLSBtaWRQb2ludFswXSk7IC8vLE1hdGguUEkvMlxyXG4gICAgICAgIHJldHVybiBhbmdsZTtcclxuICAgIH07XHJcblxyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVIb3ZlclN0eWxlID0gZnVuY3Rpb24oZWwpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhvdmVyU3R5bGUgJiYgdGhpcy5vcHRpb25zLmlzRWRpdCkge1xyXG4gICAgICAgICAgICBncmFwaGljLnNldEVsZW1lbnRIb3ZlclN0bChlbCwgdGhpcy5vcHRpb25zLmhvdmVyU3R5bGUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICAgICAgaWYgKHN5bWJvbFRvKSB7IGdyYXBoaWMuc2V0RWxlbWVudEhvdmVyU3RsKHN5bWJvbFRvLCB0aGlzLm9wdGlvbnMuYXJyb3dIb3ZlclN0eWxlKTsgfVxyXG5cclxuICAgICAgICAgICAgZWwub24oJ21vdXNlb3ZlcicsIHpyVXRpbC5iaW5kKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpYy5kb0VudGVySG92ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbFRvKSB7IGdyYXBoaWMuZG9FbnRlckhvdmVyKHN5bWJvbFRvKTsgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZS5lYWNoQ2hpbGQoZnVuY3Rpb24obGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuZG9FbnRlckhvdmVyKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIHpyVXRpbC5iaW5kKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydFBvaW50ID0gdGhpcy50dXJuaW5nUG9pbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZFBvaW50ID0gdGhpcy50dXJuaW5nUG9pbnRzW3RoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydERpZmYgPSBNYXRoLmFicyhlLmV2ZW50Lm9mZnNldFggLSBzdGFydFBvaW50LngpICsgTWF0aC5hYnMoZS5ldmVudC5vZmZzZXRZIC0gc3RhcnRQb2ludC55KTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmREaWZmID0gTWF0aC5hYnMoZS5ldmVudC5vZmZzZXRYIC0gZW5kUG9pbnQueCkgKyBNYXRoLmFicyhlLmV2ZW50Lm9mZnNldFkgLSBlbmRQb2ludC55KTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydERpZmYgPD0gMTUgfHwgZW5kRGlmZiA8PSAxNSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLmN1cnNvciA9ICdtb3ZlJztcclxuICAgICAgICAgICAgICAgICAgICBlbC5kcmFnZ2FibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5jdXJzb3IgPSAncG9pbnRlcic7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMpKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgenJVdGlsLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljLmRvTGVhdmVIb3ZlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sVG8pIHsgZ3JhcGhpYy5kb0xlYXZlSG92ZXIoc3ltYm9sVG8pOyB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaGljLmRvTGVhdmVIb3ZlcihsaW5lKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCB0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu6Tm9kZeeahOi/nuaOpeeCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVBbGxjb25uZWN0aW9uUG9pbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLCB0aGlzLnR1cm5pbmdQb2ludHNbMF0uY2xvbmUoKSwgQ29ubmVjdGlvblBvaW50LlRZUEVfQ09OTkVDVE9SKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLCB0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCAtIDFdLmNsb25lKCksIENvbm5lY3Rpb25Qb2ludC5UWVBFX0NPTk5FQ1RPUik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e5o6l54K5XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzaGFwZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHBvaW50IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gdHlwZSAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY29ubmVjdGlvblBvaW50Q3JlYXRlID0gZnVuY3Rpb24oc2hhcGUsIHBvaW50LCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIGNvblBvaW50ID0gbmV3IENvbm5lY3Rpb25Qb2ludCh0aGlzLCBwb2ludCwgdHlwZSwgdGhpcy5vcHRpb25zKTtcclxuICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwLmFkZChjb25Qb2ludC5zaGFwZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5riF56m65o6n5Yi254K5XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jbGVhckhhbmRsZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGFuZGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aGlzLmhhbmRsZXNbaV0uaGFuZGxlU2hhcGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhhbmRsZXMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5jb25Qb2ludHNHcm91cCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+aBouWkjeWOn+adpeeahOminOiJslxyXG4gICAgICAgIHRoaXMucmVtb3ZlU2VsZWN0ZWRTdHlsZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOabtOaWsOaOp+WItueCuVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUucmVmcmVzaEhhbmRsZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy50dXJuaW5nUG9pbnRzO1xyXG4gICAgICAgIHZhciBiZWl6aWVyUG9pbnRzID0gW107XHJcbiAgICAgICAgdmFyIHgsIHksIHR5cGU7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpIHtcclxuICAgICAgICAgICAgICAgIC8vIOiOt+WPluabsue6v+eahOi3r+W+hOeCuembhuWQiFxyXG4gICAgICAgICAgICAgICAgYmVpemllclBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzRnJvbUN1cnZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuaGFuZGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFzc29jaWF0ZWRQb2ludCA9IHRoaXMuaGFuZGxlc1tpXS5hc3NvY2lhdGVkUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gdGhpcy5oYW5kbGVzW2ldLnR5cGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwb2ludHMuZmluZEluZGV4KGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS54ID09IGFzc29jaWF0ZWRQb2ludC54ICYmIGl0ZW0ueSA9PSBhc3NvY2lhdGVkUG9pbnQueTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09ICdoJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gcG9pbnRzW2luZGV4IC0gMV0ueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IChwb2ludHNbaW5kZXggLSAxXS55ICsgcG9pbnRzW2luZGV4XS55KSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICd2Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gKHBvaW50c1tpbmRleCAtIDFdLnggKyBwb2ludHNbaW5kZXhdLngpIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHBvaW50c1tpbmRleCAtIDFdLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUgJiYgYmVpemllclBvaW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZWl6aWVyUG9pbnQgPSB6clV0aWwuZmluZChiZWl6aWVyUG9pbnRzW2luZGV4IC0gMl0sIGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdoJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRWYWx1ZSA9IE1hdGguYWJzKHBvaW50LnkgLSB5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3YnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZFZhbHVlID0gTWF0aC5hYnMocG9pbnQueCAtIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRWYWx1ZSA8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmVpemllclBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYmVpemllclBvaW50Lng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYmVpemllclBvaW50Lnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVzW2ldLnVwZGF0ZSh4LCB5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uuaLhue6vyDnur/mlq3nmoTmjqfliLbngrlcclxuICAgICAqIOabsue6v+aOp+WItueCueS9jee9ruiuoeeul+eyvuehrlxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuc2hhcGVTZXRIYW5kbGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy50dXJuaW5nUG9pbnRzO1xyXG4gICAgICAgIC8vIOiOt+WPluabsue6v+eahOi3r+W+hOeCuembhuWQiFxyXG4gICAgICAgIHZhciBiZWl6aWVyUG9pbnRzID0gdGhpcy5nZXRQb2ludHNGcm9tQ3VydmUoKTtcclxuICAgICAgICB2YXIgdHlwZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGggLSAyOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGg7XHJcbiAgICAgICAgICAgIHZhciB4LCB5O1xyXG4gICAgICAgICAgICAvL+aYr+WQpuWcqOS4gOadoee6v+S4ilxyXG4gICAgICAgICAgICB2YXIgaXNDb2xsaW5lYWl0eUZpcnN0ID0gVXRpbC5jb2xsaW5lYXJpdHkocG9pbnRzW2kgLSAxXSwgcG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKTtcclxuICAgICAgICAgICAgdmFyIGlzQ29sbGluZWFpdHlTZWNvbmQgPSBVdGlsLmNvbGxpbmVhcml0eShwb2ludHNbaV0sIHBvaW50c1tpICsgMV0sIHBvaW50c1tpICsgMl0pO1xyXG4gICAgICAgICAgICBpZiAoKCFpc0NvbGxpbmVhaXR5Rmlyc3QgJiYgKCFpc0NvbGxpbmVhaXR5U2Vjb25kIHx8IHBvaW50c1tpICsgMV0uZXF1YWxzKHBvaW50c1tpICsgMl0pKSkgfHwgKCghaXNDb2xsaW5lYWl0eUZpcnN0IHx8IHBvaW50c1tpIC0gMV0uZXF1YWxzKHBvaW50c1tpXSkpICYmICFpc0NvbGxpbmVhaXR5U2Vjb25kKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwb2ludHNbaV0ueCA9PT0gcG9pbnRzW2kgKyAxXS54KSB7IC8vc2FtZSB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgICAgIHggPSBwb2ludHNbaV0ueDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gKHBvaW50c1tpXS55ICsgcG9pbnRzW2kgKyAxXS55KSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdoJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRzW2ldLnkgPT09IHBvaW50c1tpICsgMV0ueSkgeyAvLyBzYW1lIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgICAgICB4ID0gKHBvaW50c1tpXS54ICsgcG9pbnRzW2kgKyAxXS54KSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHBvaW50c1tpXS55O1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAndic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoeCAmJiB5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSAmJiBiZWl6aWVyUG9pbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJlaXppZXJQb2ludCA9IHpyVXRpbC5maW5kKGJlaXppZXJQb2ludHNbaSAtIDFdLCBmdW5jdGlvbihwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnaCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkVmFsdWUgPSBNYXRoLmFicyhwb2ludC55IC0geSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRWYWx1ZSA9IE1hdGguYWJzKHBvaW50LnggLSB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkVmFsdWUgPCAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlaXppZXJQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGJlaXppZXJQb2ludC54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGJlaXppZXJQb2ludC55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGggPSBuZXcgSGFuZGxlKHR5cGUsIHgsIHksIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGguYXNzb2NpYXRlZFBvaW50ID0gcG9pbnRzW2kgKyAxXTsgLy8g6L+e57q/5o6n5Yi254K55LiOdGhpcy50dXJuaW5nUG9pbnRz5YWz6IGUXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKGguaGFuZGxlU2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcy5wdXNoKGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu6566t5aS0XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5hbWUgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBvcHRpb25zIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY3JlYXRlU3ltYm9sID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBzeW1ib2xUeXBlID0gb3B0aW9ucy5zeW1ib2wudHlwZTtcclxuICAgICAgICB2YXIgc3ltYm9sU2l6ZSA9IG9wdGlvbnMuc3ltYm9sLnNpemU7XHJcbiAgICAgICAgaWYgKHN5bWJvbFR5cGUgPT09ICdub25lJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHN5bWJvbFNpemUpKSB7XHJcbiAgICAgICAgICAgIHN5bWJvbFNpemUgPSBbc3ltYm9sU2l6ZSwgc3ltYm9sU2l6ZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc3ltYm9sWkluZGV4ID0gb3B0aW9ucy56O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zeW1ib2wueikgeyBzeW1ib2xaSW5kZXggPSBvcHRpb25zLnN5bWJvbC56IH1cclxuXHJcbiAgICAgICAgdmFyIHN5bWJvbFBhdGggPSBzeW1ib2xVdGlsLmNyZWF0ZVN5bWJvbChcclxuICAgICAgICAgICAgc3ltYm9sVHlwZSwgLXN5bWJvbFNpemVbMF0gLyAyLCAtc3ltYm9sU2l6ZVsxXSAvIDIsXHJcbiAgICAgICAgICAgIHN5bWJvbFNpemVbMF0sIHN5bWJvbFNpemVbMV0sIHN5bWJvbFpJbmRleCwgb3B0aW9ucy5zeW1ib2wuY29sb3JcclxuICAgICAgICApO1xyXG4gICAgICAgIHN5bWJvbFBhdGgubmFtZSA9IG5hbWU7XHJcblxyXG4gICAgICAgIHJldHVybiBzeW1ib2xQYXRoO1xyXG4gICAgfTtcclxuXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihuYW1lLCBjb250ZW50KSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog57uY5Yi257q/5q615LiK55qE5paH5pysXHJcbiAgICAgKiDnlKjnn6nlvaLku6Pmm7/mlofmnKxcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gY29udGVudCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5hbWUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSB4ICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0geSAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNvbG9yICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5kcmF3VGV4dCA9IGZ1bmN0aW9uKG5hbWUsIGNvbnRlbnQsIHgsIHksIHR5cGUpIHtcclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgdHlwZSA9ICd0ZXh0JztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9wdCA9IHpyVXRpbC5pc1N0cmluZyhjb250ZW50KSA/ICh0eXBlID09PSAndGV4dCcgPyB7dGV4dDpjb250ZW50LCB4OngsIHk6eX0gOiB7aW1hZ2U6Y29udGVudCwgeDp4LCB5Onl9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB6clV0aWwuZGVmYXVsdHMoe3g6eCwgeTp5fSwgY29udGVudCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHZhciB0ZXh0U3R5bGUgPSB6clV0aWwuZGVmYXVsdHMoenJVdGlsLmNsb25lKHRoaXMub3B0aW9ucy50ZXh0KSwgb3B0LCB0cnVlKTtcclxuICAgICAgICB2YXIgbm9kZTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0Qm91bmRpbmdSZWN0ID0gdGhpcy5nZXRUZXh0Qm91bmRpbmdSZWN0KHRleHRTdHlsZSk7XHJcbiAgICAgICAgICAgIHRleHRTdHlsZSA9IHpyVXRpbC5kZWZhdWx0cyh0ZXh0U3R5bGUsIHsgZmlsbDogJyNGOUY5RjknLCB0cmFuc2Zvcm1UZXh0OiB0cnVlIH0sIHRydWUpO1xyXG4gICAgICAgICAgICBub2RlID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgICAgICBzaGFwZTogeyB3aWR0aDogdGV4dEJvdW5kaW5nUmVjdC53aWR0aCwgaGVpZ2h0OiB0ZXh0Qm91bmRpbmdSZWN0LmhlaWdodCB9LFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHRleHRTdHlsZSxcclxuICAgICAgICAgICAgICAgIHpsZXZlbDogMjAsXHJcbiAgICAgICAgICAgICAgICBuYW1lIDogbmFtZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0xpbmtJbWFnZScsXHJcbiAgICAgICAgICAgICAgICBzdHlsZTogdGV4dFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgemxldmVsOiAyMCxcclxuICAgICAgICAgICAgICAgIG5hbWUgOiBuYW1lXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0ZXh0OiBub2RlLFxyXG4gICAgICAgICAgICByZWN0OiBub2RlLmdldEJvdW5kaW5nUmVjdCgpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAgLyoqXHJcbiAgICAgKiDojrflj5bnur/mrrXmlofmnKzljIXlm7Tnm5JcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gY29udGVudCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmdldFRleHRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgICAgdmFyIHRleHRSZWN0ID0gZ3JhcGhpYy50ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dC50ZXh0LCB0ZXh0LnRleHRGb250KTtcclxuICAgICAgICB2YXIgdGV4dFdpZHRoID0gZ3JhcGhpYy50ZXh0Q29udGFpbi5nZXRXaWR0aCh0ZXh0LnRleHQsIHRleHQudGV4dEZvbnQpO1xyXG4gICAgICAgIHZhciB0ZXh0SGVpZ2h0ID0gdGV4dFJlY3QuaGVpZ2h0IHx8IDEyO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0ZXh0V2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGV4dEhlaWdodFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bnur/mrrXnmoTkuK3pl7TlgLxcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gdGV4dFxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLm1pZGRsZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUIHx8IHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DSEFJTikge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gVXRpbC5nZXRNYXhMaW5lTGVuZ3RoKHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgICAgIC8v5aaC5p6c5piv5rGC57q/5q615LiK55qE5paH5a2X55qE5Lit6Ze05YC8XHJcbiAgICAgICAgICAgIC8vIGlmKHRleHQpIHtcclxuICAgICAgICAgICAgLy8gICAgIC8v5Y+W5Ye65a2X55qE6ZW/5bqm77yM6K6h566X6KeS5bqm77yMXHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgdGV4dFdpZHRoID0gZ3JhcGhpYy50ZXh0Q29udGFpbi5nZXRXaWR0aCh0ZXh0LnRleHQsIHRleHQudGV4dEZvbnQpO1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIGFuZ2xlID0gVXRpbC5nZXRBbmdsZShwb2ludHNbMF0scG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBsZW5ndGggPSAgVXRpbC5kaXN0YW5jZShwb2ludHNbMF0scG9pbnRzWzFdKS8yIC0gdGV4dFdpZHRoLzI7XHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgbmV3UG9pbnQgPSBVdGlsLmdldEVuZFBvaW50KHBvaW50c1swXSwgbGVuZ3RoLCBhbmdsZSk7XHJcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gW25ld1BvaW50LngsIG5ld1BvaW50LnldO1xyXG4gICAgICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIG1pZGRsZVggPSAocG9pbnRzWzBdLnggKyBwb2ludHNbMV0ueCkvMjtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBtaWRkbGVZID0gKHBvaW50c1swXS55ICsgcG9pbnRzWzFdLnkpIC8yO1xyXG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuIFttaWRkbGVYLCBtaWRkbGVZXTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICB2YXIgbWlkZGxlWCA9IChwb2ludHNbMF0ueCArIHBvaW50c1sxXS54KSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVZID0gKHBvaW50c1swXS55ICsgcG9pbnRzWzFdLnkpIC8gMjtcclxuICAgICAgICAgICAgcmV0dXJuIFttaWRkbGVYLCBtaWRkbGVZXTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9KQUdHRUQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vZmluZCB0b3RhbCBkaXN0YW5jZVxyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLmdldExlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgLy9maW5kIGJldHdlZW4gd2hhdCB0dXJuaW5nIHBvaW50cyB0aGUgaGFsZiBkaXN0YW5jZSBpc1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcclxuICAgICAgICAgICAgdmFyIGVsbGFwc2VkRGlzdGFuY2UgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gVXRpbC5nZXRMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzW2ldLCB0aGlzLnR1cm5pbmdQb2ludHNbaSArIDFdKTtcclxuICAgICAgICAgICAgICAgIGlmIChlbGxhcHNlZERpc3RhbmNlICsgc2VnbWVudCA8IGRpc3RhbmNlIC8gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsbGFwc2VkRGlzdGFuY2UgKz0gc2VnbWVudDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vd2UgaGF2ZSB0aGUgbWlkZGxlIGRpc3RhbmNlIHNvbWV3aGVyZSBiZXR3ZWVuIGkobmRleCkgYW5kIGkobmRleCkrMVxyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtaXNzaW5nRGlzdGFuY2UgPSBkaXN0YW5jZSAvIDIgLSBlbGxhcHNlZERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKFV0aWwucm91bmQodGhpcy50dXJuaW5nUG9pbnRzW2luZGV4XS54LCAzKSA9PSBVdGlsLnJvdW5kKHRoaXMudHVybmluZ1BvaW50c1tpbmRleCArIDFdLngsIDMpKSB7IC8vdmVydGljYWwgc2VnbWVudCAoc2FtZSB4KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4XS54LCBNYXRoLm1pbih0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLnksIHRoaXMudHVybmluZ1BvaW50c1tpbmRleCArIDFdLnkpICsgbWlzc2luZ0Rpc3RhbmNlXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbC5yb3VuZCh0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLnksIDMpID09IFV0aWwucm91bmQodGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueSwgMykpIHsgLy9ob3Jpem9udGFsIHNlZ21lbnQgKHNhbWUgeSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW01hdGgubWluKHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueCwgdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueCkgKyBtaXNzaW5nRGlzdGFuY2UsIHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb25uZWN0b3I6bWlkZGxlKCkgLSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4gXCIgKyB0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdICsgXCIgXCIgKyB0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXggKyAxXSArIFwiIG5yIG9mIHBvaW50cyBcIiArIHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gMC41O1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgd2Fsa2VkID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2Fsa2VkICsgVXRpbC5kaXN0YW5jZSh0aGlzLnR1cm5pbmdQb2ludHNbal0sIHRoaXMudHVybmluZ1BvaW50c1tqICsgMV0pID4gbCAqIHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB3YWxrZWQgKz0gVXRpbC5kaXN0YW5jZSh0aGlzLnR1cm5pbmdQb2ludHNbal0sIHRoaXMudHVybmluZ1BvaW50c1tqICsgMV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdCA9IGwgKiB0IC0gd2Fsa2VkO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFNlZ21lbnRMZW5ndGggPSBVdGlsLmRpc3RhbmNlKHRoaXMudHVybmluZ1BvaW50c1tqXSwgdGhpcy50dXJuaW5nUG9pbnRzW2ogKyAxXSk7XHJcblxyXG4gICAgICAgICAgICAvL2ZpbmQgdGhlIHBvc2l0aW9uL3JhdGlvbiBvZiB0aGUgbWlkZGxlIG9mIFBvbHlsaW5lIG9uIGN1cnJlbnQgc2VnbWVudFxyXG4gICAgICAgICAgICB2YXIgc2VnbWVudFBlcmNlbnQgPSByZXN0IC8gY3VycmVudFNlZ21lbnRMZW5ndGg7XHJcblxyXG4gICAgICAgICAgICB2YXIgWHAgPSBzZWdtZW50UGVyY2VudCAqICh0aGlzLnR1cm5pbmdQb2ludHNbaiArIDFdLnggLSB0aGlzLnR1cm5pbmdQb2ludHNbal0ueCkgKyB0aGlzLnR1cm5pbmdQb2ludHNbal0ueDtcclxuICAgICAgICAgICAgdmFyIFlwID0gc2VnbWVudFBlcmNlbnQgKiAodGhpcy50dXJuaW5nUG9pbnRzW2ogKyAxXS55IC0gdGhpcy50dXJuaW5nUG9pbnRzW2pdLnkpICsgdGhpcy50dXJuaW5nUG9pbnRzW2pdLnk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW1hwLCBZcF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZmluZCB0b3RhbCBkaXN0YW5jZVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9maW5kIHRvdGFsIGRpc3RhbmNlXHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gVXRpbC5nZXRMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzW2ldLCB0aGlzLnR1cm5pbmdQb2ludHNbaSArIDFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOi9rEpTT07lr7nosaEgYnBtbuS9v+eUqFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwicmVzb3VyY2VJZFwiLCB0aGlzLnJlc291cmNlSWQpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwicHJvcGVydGllcy50eXBlXCIsIDE0KTtcclxuXHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiwgdGhpcy5wb3NpdGlvblswXSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIiwgdGhpcy5wb3NpdGlvblsxXSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC54XCIsIHBhcnNlSW50KHRoaXMucG9zaXRpb25bMF0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoKSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC55XCIsIHBhcnNlSW50KHRoaXMucG9zaXRpb25bMV0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCkpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwic3R5bGUuc1Bvc1wiLCB0aGlzLm9wdGlvbnMucG9zaXRpb24uc3RhcnRQb3MpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwic3R5bGUuZVBvc1wiLCB0aGlzLm9wdGlvbnMucG9zaXRpb24uZW5kUG9zKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0eWxlLmxpbmVEYXNoXCIsIHRoaXMub3B0aW9ucy5zdHlsZS5saW5lRGFzaCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJzdHlsZS5zdHJva2VcIiwgdGhpcy5vcHRpb25zLnN0eWxlLnN0cm9rZSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJzeW1ib2wudHlwZVwiLCB0aGlzLm9wdGlvbnMuc3ltYm9sLnR5cGUpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiZG9ja2Vyc1wiLCB0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm9wdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZWZyZXNoTW9kZWwgIGZsb3flvZPluo/liJfljJbnmoTml7blgJnosIPnlKgg5pu05paw57q/5q6155qE5L2N572uIOWPiue6v+S4iueahGljb25zXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZWZyZXNoTW9kZWwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnNcIiwgenJVdGlsLmNsb25lKHRoaXMub3B0aW9ucykpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5kb2NrZXJzXCIsIHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgdmFyIGljb25zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmljb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpY29uTm9kZSA9IHRoaXMuaWNvbnNbaV07XHJcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBbaWNvbk5vZGUua2V5LCB7XHJcbiAgICAgICAgICAgICAgICBpY29uOiBpY29uTm9kZS5zdHlsZS5pbWFnZSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBpY29uTm9kZS5zdHlsZS53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaWNvbk5vZGUuc3R5bGUuaGVpZ2h0XHJcbiAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBpY29ucy5wdXNoKG9wdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiaWNvbnNcIiwgaWNvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiwg+aVtOabsue6v+eahOW9oueKtlxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9IHBvaW50cyDngrnmlbDnu4RcclxuICAgICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUubW9kaWZ5Q3VydmUgPSBmdW5jdGlvbihwb2ludHMpIHtcclxuICAgICAgICB2YXIgc29sID0gdGhpcy5nZXRDdXJ2ZVBvaW50KHBvaW50cyk7XHJcblxyXG4gICAgICAgIC8vIDEuIOWmguaenOabsue6v+eahOaVsOmHjyDmr5TmlbDph4/nmoTkuK3mlbDph4/opoHlsJEg5YiZ5Yig6Zmk5aSa5L2Z55qE57q/5q61XHJcbiAgICAgICAgdmFyIHdpbGxEZWxDdXJ2ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBqID0gc29sLmxlbmd0aCwgY250Q3VydmUgPSB0aGlzLmdyb3VwQ3VydmUuY2hpbGRDb3VudCgpOyBqIDwgY250Q3VydmU7IGorKykge1xyXG4gICAgICAgICAgICB3aWxsRGVsQ3VydmVzLnB1c2godGhpcy5ncm91cEN1cnZlLmNoaWxkQXQoaikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB6clV0aWwuZWFjaCh3aWxsRGVsQ3VydmVzLCBmdW5jdGlvbihjdXJ2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUucmVtb3ZlKGN1cnZlKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAvLyAyLiDpgY3ljobmm7Lnur8gICDlpoLmnpzlrZjlnKjliJnnm7TmjqXorr7nva7lvaLnirbvvIzlkKbliJnliJvlu7pcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvbC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMuZ3JvdXBDdXJ2ZS5jaGlsZEF0KGkpO1xyXG4gICAgICAgICAgICBpZiAobGluZSkge1xyXG4gICAgICAgICAgICAgICAgbGluZS5hdHRyKCdzaGFwZScsIHNvbFtpXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VyZSA9IG5ldyBncmFwaGljLkJlemllckN1cnZlKHtcclxuICAgICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uOiB0aGlzLm9wdGlvbnMucG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHRoaXMub3B0aW9ucy5zdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZTogc29sW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgIHo6IHRoaXMub3B0aW9ucy56XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZS5hZGQoY3VyZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUhvdmVyU3R5bGUoY3VyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2Mg6I635Y+W54K577yM6L+Z6YeM5Y+v5Lul6K6+572u54K555qE5Liq5pWwXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtIOeCueS4quaVsFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcDEg54K55Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwMiDngrnlnZDmoIdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHAzIOeCueWdkOagh1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcDQg54K55Z2Q5qCHXHJcbiAgICAgKiDlpoLmnpzlj4LmlbDmmK8gbnVtLCBwMSwgcDIg5Li65LiA6Zi26LSd5aGe5bCUXHJcbiAgICAgKiDlpoLmnpzlj4LmlbDmmK8gbnVtLCBwMSwgYzEsIHAyIOS4uuS6jOmYtui0neWhnuWwlFxyXG4gICAgICog5aaC5p6c5Y+C5pWw5pivIG51bSwgcDEsIGMxLCBjMiwgcDIg5Li65LiJ6Zi26LSd5aGe5bCUXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0QmV6aWVyUG9pbnRzID0gZnVuY3Rpb24ocG9pbnQsIG51bSkge1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICB2YXIgZnVuYyA9IG51bGw7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9pbnQuc3RhcnQ7XHJcbiAgICAgICAgdmFyIGNwMSA9IHBvaW50LmNwMTtcclxuICAgICAgICB2YXIgY3AyID0gcG9pbnQuY3AyO1xyXG4gICAgICAgIHZhciBlbmQgPSBwb2ludC5lbmQ7XHJcbiAgICAgICAgaWYgKCFudW0gfHwgbnVtIDw9IDUwKSB7XHJcbiAgICAgICAgICAgIG51bSA9IDUwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWNwMSAmJiAhY3AyKSB7XHJcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLm9uZUJlemllcjtcclxuICAgICAgICB9IGVsc2UgaWYgKGNwMSAmJiAhY3AyKSB7XHJcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnR3b0JlemllcjtcclxuICAgICAgICB9IGVsc2UgaWYgKGNwMSAmJiBjcDIpIHtcclxuICAgICAgICAgICAgZnVuYyA9IHRoaXMudGhyZWVCZXppZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goZnVuYyhpIC8gbnVtLCBzdGFydCwgY3AxLCBjcDIsIGVuZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb2ludHMucHVzaChlbmQpO1xyXG4gICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2Mg5LiA6Zi26LSd5aGe5bCUXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCDlvZPliY3nmb7liIbmr5RcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IOi1t+eCueWdkOagh1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZW5kIOe7iOeCueWdkOagh1xyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLm9uZUJlemllciA9IGZ1bmN0aW9uKHQsIHN0YXJ0LCBjcDEsIGNwMiwgZW5kKSB7XHJcbiAgICAgICAgdmFyIHgxID0gc3RhcnQueDE7XHJcbiAgICAgICAgdmFyIHkxID0gc3RhcnQueTE7XHJcbiAgICAgICAgdmFyIHgyID0gZW5kLngyO1xyXG4gICAgICAgIHZhciB5MiA9IGVuZC55MjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB4MSArICh4MiAtIHgxKSAqIHQsXHJcbiAgICAgICAgICAgIHk6IHkxICsgKHkyIC0geTEpICogdFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzYyDkuozpmLbotJ3loZ7lsJRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IOW9k+WJjeeZvuWIhuavlFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQg6LW354K55Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbmQg57uI54K55Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjcDEg5o6n5Yi254K5XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUudHdvQmV6aWVyID0gZnVuY3Rpb24odCwgc3RhcnQsIGNwMSwgY3AyLCBlbmQpIHtcclxuICAgICAgICB2YXIgeDEgPSBzdGFydC54MTtcclxuICAgICAgICB2YXIgeTEgPSBzdGFydC55MTtcclxuICAgICAgICB2YXIgeDIgPSBlbmQueDI7XHJcbiAgICAgICAgdmFyIHkyID0gZW5kLnkyO1xyXG4gICAgICAgIHZhciBjcHgxID0gY3AxLmNweDE7XHJcbiAgICAgICAgdmFyIGNweTEgPSBjcDEuY3B5MTtcclxuICAgICAgICB2YXIgeCA9ICgxIC0gdCkgKiAoMSAtIHQpICogeDEgKyAyICogdCAqICgxIC0gdCkgKiBjcHgxICsgdCAqIHQgKiB4MjtcclxuICAgICAgICB2YXIgeSA9ICgxIC0gdCkgKiAoMSAtIHQpICogeTEgKyAyICogdCAqICgxIC0gdCkgKiBjcHkxICsgdCAqIHQgKiB5MjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICB5OiB5XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjIOS4iemYtui0neWhnuWwlFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQg5b2T5YmN55m+5YiG5q+UXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCDotbfngrnlnZDmoIdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVuZCDnu4jngrnlnZDmoIdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNwMSDmjqfliLbngrlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNwMiDmjqfliLbngrlcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS50aHJlZUJlemllciA9IGZ1bmN0aW9uKHQsIHN0YXJ0LCBjcDEsIGNwMiwgZW5kKSB7XHJcbiAgICAgICAgdmFyIHgxID0gc3RhcnQueDE7XHJcbiAgICAgICAgdmFyIHkxID0gc3RhcnQueTE7XHJcbiAgICAgICAgdmFyIHgyID0gZW5kLngyO1xyXG4gICAgICAgIHZhciB5MiA9IGVuZC55MjtcclxuICAgICAgICB2YXIgY3B4MSA9IGNwMS5jcHgxO1xyXG4gICAgICAgIHZhciBjcHkxID0gY3AxLmNweTE7XHJcbiAgICAgICAgdmFyIGNweDIgPSBjcDIuY3B4MjtcclxuICAgICAgICB2YXIgY3B5MiA9IGNwMi5jcHkyO1xyXG4gICAgICAgIHZhciB4ID1cclxuICAgICAgICAgICAgeDEgKiAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCkgK1xyXG4gICAgICAgICAgICAzICogY3B4MSAqIHQgKiAoMSAtIHQpICogKDEgLSB0KSArXHJcbiAgICAgICAgICAgIDMgKiBjcHgyICogdCAqIHQgKiAoMSAtIHQpICtcclxuICAgICAgICAgICAgeDIgKiB0ICogdCAqIHQ7XHJcbiAgICAgICAgdmFyIHkgPVxyXG4gICAgICAgICAgICB5MSAqICgxIC0gdCkgKiAoMSAtIHQpICogKDEgLSB0KSArXHJcbiAgICAgICAgICAgIDMgKiBjcHkxICogdCAqICgxIC0gdCkgKiAoMSAtIHQpICtcclxuICAgICAgICAgICAgMyAqIGNweTIgKiB0ICogdCAqICgxIC0gdCkgK1xyXG4gICAgICAgICAgICB5MiAqIHQgKiB0ICogdDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICB5OiB5XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluabsue6v+S4iueahOeCuei9qOi/uVxyXG4gICAgICogQHJldHVybiB7YXJyYXl9XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0UG9pbnRzRnJvbUN1cnZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwZXJjZW50ID0gMDtcclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy50dXJuaW5nUG9pbnRzO1xyXG4gICAgICAgIHZhciBtYXhNaW5Qb2ludHMgPSBVdGlsLmdldE1heExpbmVMZW5ndGgocG9pbnRzKTtcclxuICAgICAgICB2YXIgYmVpemllclBvaW50cyA9IFtdO1xyXG4gICAgICAgIHBlcmNlbnQgPSBwYXJzZUludChtYXhNaW5Qb2ludHNbMF0ueCAtIG1heE1pblBvaW50c1sxXS54KTtcclxuICAgICAgICBpZiAoKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkgJiYgKHBvaW50cy5sZW5ndGggPiAyKSkge1xyXG4gICAgICAgICAgICB2YXIgc29scyA9IHRoaXMudHJhbnNmb3JtQ3VydmVQb2ludCh0aGlzLmdldEN1cnZlUG9pbnQocG9pbnRzKSk7XHJcbiAgICAgICAgICAgIGlmIChzb2xzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHNvbHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVpemllclBvaW50cy5wdXNoKHRoYXQuZ2V0QmV6aWVyUG9pbnRzKGl0ZW0sIHBlcmNlbnQpKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJlaXppZXJQb2ludHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7kvKDlhaXnmoTngrnmlbDnu4TovazmjaLmiJDpnIDopoHnmoTnsbvlnotcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBzb2wg54K55pWw57uEXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUudHJhbnNmb3JtQ3VydmVQb2ludCA9IGZ1bmN0aW9uKHNvbCkge1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICBzb2wuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRQYXJhbSA9IHt9O1xyXG4gICAgICAgICAgICBpZiAocG9pbnQueDEgJiYgcG9pbnQueTEpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50UGFyYW0uc3RhcnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDE6IHBvaW50LngxLFxyXG4gICAgICAgICAgICAgICAgICAgIHkxOiBwb2ludC55MVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2ludC5jcHgxICYmIHBvaW50LmNweTEpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50UGFyYW0uY3AxID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNweDE6IHBvaW50LmNweDEsXHJcbiAgICAgICAgICAgICAgICAgICAgY3B5MTogcG9pbnQuY3B5MVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2ludC5jcHgyICYmIHBvaW50LmNweTIpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50UGFyYW0uY3AyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNweDI6IHBvaW50LmNweDIsXHJcbiAgICAgICAgICAgICAgICAgICAgY3B5MjogcG9pbnQuY3B5MlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2ludC54MiAmJiBwb2ludC55Mikge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRQYXJhbS5lbmQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDI6IHBvaW50LngyLFxyXG4gICAgICAgICAgICAgICAgICAgIHkyOiBwb2ludC55MlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50UGFyYW0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7kvKDlhaXnmoTngrnmlbDnu4TorqHnrpfmm7Lnur/nmoTngrlcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBQIOeCueaVsOe7hFxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAg5puy57q/55qE54K55pWw57uEXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0Q3VydmVQb2ludCA9IGZ1bmN0aW9uKFApIHtcclxuICAgICAgICB2YXIgbiA9IFAubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzb2wgPSBbXTtcclxuICAgICAgICBpZiAobiA9PT0gMykge1xyXG4gICAgICAgICAgICBzb2wucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB4MTogUFswXS54LFxyXG4gICAgICAgICAgICAgICAgeTE6IFBbMF0ueSxcclxuICAgICAgICAgICAgICAgIGNweDE6IFBbMV0ueCxcclxuICAgICAgICAgICAgICAgIGNweTE6IFBbMV0ueSxcclxuICAgICAgICAgICAgICAgIHgyOiBQWzJdLngsXHJcbiAgICAgICAgICAgICAgICB5MjogUFsyXS55XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc29sO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobiA9PT0gNCkge1xyXG4gICAgICAgICAgICBzb2wucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB4MTogUFswXS54LFxyXG4gICAgICAgICAgICAgICAgeTE6IFBbMF0ueSxcclxuICAgICAgICAgICAgICAgIGNweDE6IFBbMV0ueCxcclxuICAgICAgICAgICAgICAgIGNweTE6IFBbMV0ueSxcclxuICAgICAgICAgICAgICAgIGNweDI6IFBbMl0ueCxcclxuICAgICAgICAgICAgICAgIGNweTI6IFBbMl0ueSxcclxuICAgICAgICAgICAgICAgIHgyOiBQWzNdLngsXHJcbiAgICAgICAgICAgICAgICB5MjogUFszXS55XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc29sO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKkNvbXB1dGVzIHRoZSBzdW0gYmV0d2VlbiB0d28gcG9pbnRcclxuICAgICAgICAgKkBwYXJhbSBwMSAtIHtQb2ludH1cclxuICAgICAgICAgKkBwYXJhbSBwMiAtIHtQb2ludH1cclxuICAgICAgICAgKkByZXR1cm4ge1BvaW50fSB0aGUgc3VtIG9mIGluaXRpYWwgcG9pbnRzXHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHN1bShwMSwgcDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwMS54ICsgcDIueCwgcDEueSArIHAyLnkpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKkNvbXB1dGVzIHRoZSBkaXZpc2lvbiBvZiBhIHtQb2ludH0gYnkgYSBudW1iZXJcclxuICAgICAgICAgKkBwYXJhbSBwIC0ge1BvaW50fVxyXG4gICAgICAgICAqQHBhcmFtIG5yIC0ge051bWJlcn1cclxuICAgICAgICAgKkByZXR1cm4ge1BvaW50fVxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBmdW5jdGlvbiBkaXZpZGUocCwgbnIpIHtcclxuICAgICAgICAgICAgaWYgKG5yID09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiRGl2aXNpb24gYnkgemVybyBub3QgYWxsb3dlZCAoeWV0IDopIFwiICsgdGhpcy5jYWxsZWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwLnggLyBuciwgcC55IC8gbnIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqQ29tcHV0ZXMgdGhlIG11bHRpcGxpY2F0aW9uIG9mIGEge1BvaW50fSBieSBhIG51bWJlclxyXG4gICAgICAgICAqQHBhcmFtIHAgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcGFyYW0gbnIgLSB7TnVtYmVyfVxyXG4gICAgICAgICAqQHJldHVybiB7UG9pbnR9XHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGZ1bmN0aW9uIG11bHRpcGx5KHAsIG5yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocC54ICogbnIsIHAueSAqIG5yKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICpJIGRvIG5vdCBnZXQgd2h5IGZpcnN0IDQgbXVzdCBiZSAwIGFuZCBsYXN0IDMgb2Ygc2FtZSB2YWx1ZS4uLi4uXHJcbiAgICAgICAgICpidXQgb3RoZXJ3aXNlIHdlIHdpbGwgZ2V0IGRpdmlzaW9uIGJ5IHplcm9cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgayA9IFswLCAwLCAwXTtcclxuXHJcbiAgICAgICAgdmFyIGo7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8PSBuIC0gMzsgaisrKSB7XHJcbiAgICAgICAgICAgIGsucHVzaChqKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGsucHVzaChuIC0gMywgbiAtIDMpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG4gLSAzOyBpKyspIHtcclxuICAgICAgICAgICAgLy9xMSAtIGNvbXB1dGUgc3RhcnQgcG9pbnRcclxuICAgICAgICAgICAgdmFyIHExID0gZGl2aWRlKHN1bShtdWx0aXBseShQW2ldLCBrW2kgKyA0XSAtIGtbaSArIDJdKSwgbXVsdGlwbHkoUFtpICsgMV0sIGtbaSArIDJdIC0ga1tpICsgMV0pKSwga1tpICsgNF0gLSBrW2kgKyAxXSk7XHJcblxyXG4gICAgICAgICAgICAvL3EwIC0gY29tcHV0ZSAxc3QgY29udHJvbGwgcG9pbnRcclxuICAgICAgICAgICAgdmFyIHFfMDEgPSAoa1tpICsgM10gLSBrW2kgKyAyXSkgLyAoa1tpICsgM10gLSBrW2kgKyAxXSk7XHJcbiAgICAgICAgICAgIHZhciBxXzAyID0gZGl2aWRlKHN1bShtdWx0aXBseShQW2kgLSAxXSwga1tpICsgM10gLSBrW2kgKyAyXSksIG11bHRpcGx5KFBbaV0sIGtbaSArIDJdIC0ga1tpXSkpLCBrW2kgKyAzXSAtIGtbaV0pO1xyXG4gICAgICAgICAgICB2YXIgcV8wMyA9IG11bHRpcGx5KHExLCAoa1tpICsgMl0gLSBrW2kgKyAxXSkgLyAoa1tpICsgM10gLSBrW2kgKyAxXSkpO1xyXG4gICAgICAgICAgICB2YXIgcTAgPSBzdW0obXVsdGlwbHkocV8wMiwgcV8wMSksIHFfMDMpO1xyXG5cclxuICAgICAgICAgICAgLy9xMiAtIGNvbXB1dGUgMm5kIGNvbnRyb2xsIHBvaW50XHJcbiAgICAgICAgICAgIHZhciBxMiA9IGRpdmlkZShzdW0obXVsdGlwbHkoUFtpXSwga1tpICsgNF0gLSBrW2kgKyAzXSksIG11bHRpcGx5KFBbaSArIDFdLCBrW2kgKyAzXSAtIGtbaSArIDFdKSksIGtbaSArIDRdIC0ga1tpICsgMV0pO1xyXG5cclxuICAgICAgICAgICAgLy9xMyAtIGNvbXB1dGUgZW5kIHBvaW50XHJcbiAgICAgICAgICAgIHZhciBxXzMxID0gKGtbaSArIDNdIC0ga1tpICsgMl0pIC8gKGtbaSArIDRdIC0ga1tpICsgMl0pO1xyXG4gICAgICAgICAgICB2YXIgcV8zMiA9IGRpdmlkZShzdW0obXVsdGlwbHkoUFtpICsgMV0sIGtbaSArIDVdIC0ga1tpICsgM10pLCBtdWx0aXBseShQW2kgKyAyXSwga1tpICsgM10gLSBrW2kgKyAyXSkpLCBrW2kgKyA1XSAtIGtbaSArIDJdKTtcclxuICAgICAgICAgICAgdmFyIHFfMzMgPSBtdWx0aXBseShxMiwgKGtbaSArIDRdIC0ga1tpICsgM10pIC8gKGtbaSArIDRdIC0ga1tpICsgMl0pKTtcclxuICAgICAgICAgICAgdmFyIHEzID0gc3VtKG11bHRpcGx5KHFfMzIsIHFfMzEpLCBxXzMzKTtcclxuXHJcbiAgICAgICAgICAgIC8vc3RvcmUgc29sdXRpb25cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgc29sLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgeDE6IHEwLngsXHJcbiAgICAgICAgICAgICAgICB5MTogcTAueSxcclxuICAgICAgICAgICAgICAgIGNweDE6IHExLngsXHJcbiAgICAgICAgICAgICAgICBjcHkxOiBxMS55LFxyXG4gICAgICAgICAgICAgICAgY3B4MjogcTIueCxcclxuICAgICAgICAgICAgICAgIGNweTI6IHEyLnksXHJcbiAgICAgICAgICAgICAgICB4MjogcTMueCxcclxuICAgICAgICAgICAgICAgIHkyOiBxMy55XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNvbDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFV0aWwuaW5oZXJpdHMoQ29ubmVjdG9yLCBOb2RlKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbm5lY3RvcjtcclxuXHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gU3ltYm9sIGZhY3RvcnlcclxuXHJcblxyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi9ncmFwaGljJyk7XHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcclxuICAgIC8qKlxyXG4gICAgICogVHJpYW5nbGUgc2hhcGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVHJpYW5nbGUgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcclxuICAgICAgICB0eXBlOiAndHJpYW5nbGUnLFxyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIGN4ID0gc2hhcGUuY3g7XHJcbiAgICAgICAgICAgIHZhciBjeSA9IHNoYXBlLmN5O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBwYXRoLm1vdmVUbyhjeCwgY3kgLSBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCArIHdpZHRoLCBjeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4IC0gd2lkdGgsIGN5ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRGlhbW9uZCBzaGFwZVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBEaWFtb25kID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcbiAgICAgICAgdHlwZTogJ2RpYW1vbmQnLFxyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIGN4ID0gc2hhcGUuY3g7XHJcbiAgICAgICAgICAgIHZhciBjeSA9IHNoYXBlLmN5O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBwYXRoLm1vdmVUbyhjeCwgY3kgLSBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCArIHdpZHRoLCBjeSk7XHJcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4LCBjeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4IC0gd2lkdGgsIGN5KTtcclxuICAgICAgICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpbiBzaGFwZVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBQaW4gPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcclxuICAgICAgICB0eXBlOiAncGluJyxcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAvLyB4LCB5IG9uIHRoZSBjdXNwXHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XHJcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcclxuICAgICAgICAgICAgdmFyIHcgPSBzaGFwZS53aWR0aCAvIDUgKiAzO1xyXG4gICAgICAgICAgICAvLyBIZWlnaHQgbXVzdCBiZSBsYXJnZXIgdGhhbiB3aWR0aFxyXG4gICAgICAgICAgICB2YXIgaCA9IE1hdGgubWF4KHcsIHNoYXBlLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHZhciByID0gdyAvIDI7XHJcblxyXG4gICAgICAgICAgICAvLyBEaXN0IG9uIHkgd2l0aCB0YW5nZW50IHBvaW50IGFuZCBjaXJjbGUgY2VudGVyXHJcbiAgICAgICAgICAgIHZhciBkeSA9IHIgKiByIC8gKGggLSByKTtcclxuICAgICAgICAgICAgdmFyIGN5ID0geSAtIGggKyByICsgZHk7XHJcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXNpbihkeSAvIHIpO1xyXG4gICAgICAgICAgICAvLyBEaXN0IG9uIHggd2l0aCB0YW5nZW50IHBvaW50IGFuZCBjaXJjbGUgY2VudGVyXHJcbiAgICAgICAgICAgIHZhciBkeCA9IE1hdGguY29zKGFuZ2xlKSAqIHI7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGFuWCA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICAgICAgdmFyIHRhblkgPSBNYXRoLmNvcyhhbmdsZSk7XHJcblxyXG4gICAgICAgICAgICBwYXRoLmFyYyhcclxuICAgICAgICAgICAgICAgIHgsIGN5LCByLFxyXG4gICAgICAgICAgICAgICAgTWF0aC5QSSAtIGFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgTWF0aC5QSSAqIDIgKyBhbmdsZVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNwTGVuID0gciAqIDAuNjtcclxuICAgICAgICAgICAgdmFyIGNwTGVuMiA9IHIgKiAwLjc7XHJcbiAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgIHggKyBkeCAtIHRhblggKiBjcExlbiwgY3kgKyBkeSArIHRhblkgKiBjcExlbixcclxuICAgICAgICAgICAgICAgIHgsIHkgLSBjcExlbjIsXHJcbiAgICAgICAgICAgICAgICB4LCB5XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgIHgsIHkgLSBjcExlbjIsXHJcbiAgICAgICAgICAgICAgICB4IC0gZHggKyB0YW5YICogY3BMZW4sIGN5ICsgZHkgKyB0YW5ZICogY3BMZW4sXHJcbiAgICAgICAgICAgICAgICB4IC0gZHgsIGN5ICsgZHlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycm93IHNoYXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIEFycm93ID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdhcnJvdycsXHJcblxyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XHJcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcclxuICAgICAgICAgICAgdmFyIGR4ID0gd2lkdGggLyAzICogMjtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgZHgsIHkgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyBoZWlnaHQgLyA0ICogMyk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCAtIGR4LCB5ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIG9mIHBhdGggY29udHJ1Y3RvcnNcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoPn1cclxuICAgICAqL1xyXG4gICAgdmFyIHN5bWJvbEN0b3JzID0ge1xyXG4gICAgICAgIGxpbmU6IGdyYXBoaWMuTGluZSxcclxuXHJcbiAgICAgICAgcmVjdDogZ3JhcGhpYy5SZWN0LFxyXG5cclxuICAgICAgICByb3VuZFJlY3Q6IGdyYXBoaWMuUmVjdCxcclxuXHJcbiAgICAgICAgc3F1YXJlOiBncmFwaGljLlJlY3QsXHJcblxyXG4gICAgICAgIGNpcmNsZTogZ3JhcGhpYy5DaXJjbGUsXHJcblxyXG4gICAgICAgIGRpYW1vbmQ6IERpYW1vbmQsXHJcblxyXG4gICAgICAgIHBpbjogUGluLFxyXG5cclxuICAgICAgICBhcnJvdzogQXJyb3csXHJcblxyXG4gICAgICAgIHRyaWFuZ2xlOiBUcmlhbmdsZVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgc3ltYm9sU2hhcGVNYWtlcnMgPSB7XHJcblxyXG4gICAgICAgIGxpbmU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICAvLyBGSVhNRVxyXG4gICAgICAgICAgICBzaGFwZS54MSA9IHg7XHJcbiAgICAgICAgICAgIHNoYXBlLnkxID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS54MiA9IHggKyB3O1xyXG4gICAgICAgICAgICBzaGFwZS55MiA9IHkgKyBoIC8gMjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgc2hhcGUueCA9IHg7XHJcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5O1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcm91bmRSZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgc2hhcGUueCA9IHg7XHJcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5O1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgICAgIHNoYXBlLnIgPSBNYXRoLm1pbih3LCBoKSAvIDQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3F1YXJlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbih3LCBoKTtcclxuICAgICAgICAgICAgc2hhcGUueCA9IHg7XHJcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5O1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHNpemU7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IHNpemU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2lyY2xlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgLy8gUHV0IGNpcmNsZSBpbiB0aGUgY2VudGVyIG9mIHNxdWFyZVxyXG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLnIgPSBNYXRoLm1pbih3LCBoKSAvIDI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGlhbW9uZDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLmN4ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHBpbjogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4ICsgdyAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhcnJvdzogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4ICsgdyAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0cmlhbmdsZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLmN4ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHN5bWJvbEJ1aWxkUHJveGllcyA9IHt9O1xyXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzeW1ib2xDdG9ycykge1xyXG4gICAgICAgIHN5bWJvbEJ1aWxkUHJveGllc1tuYW1lXSA9IG5ldyBzeW1ib2xDdG9yc1tuYW1lXSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBTeW1ib2wgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ3N5bWJvbCcsXHJcblxyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIHN5bWJvbFR5cGU6ICcnLFxyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYmVmb3JlQnJ1c2g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgLy8gRklYTUVcclxuICAgICAgICAgICAgaWYgKHNoYXBlLnN5bWJvbFR5cGUgPT09ICdwaW4nICYmIHN0eWxlLnRleHRQb3NpdGlvbiA9PT0gJ2luc2lkZScpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnRleHRQb3NpdGlvbiA9IFsnNTAlJywgJzQwJSddO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgc3ltYm9sVHlwZSA9IHNoYXBlLnN5bWJvbFR5cGU7XHJcbiAgICAgICAgICAgIHZhciBwcm94eVN5bWJvbCA9IHN5bWJvbEJ1aWxkUHJveGllc1tzeW1ib2xUeXBlXTtcclxuICAgICAgICAgICAgaWYgKHNoYXBlLnN5bWJvbFR5cGUgIT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwcm94eVN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgcmVjdFxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFR5cGUgPSAncmVjdCc7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJveHlTeW1ib2wgPSBzeW1ib2xCdWlsZFByb3hpZXNbc3ltYm9sVHlwZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xTaGFwZU1ha2Vyc1tzeW1ib2xUeXBlXShcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZS54LCBzaGFwZS55LCBzaGFwZS53aWR0aCwgc2hhcGUuaGVpZ2h0LCBwcm94eVN5bWJvbC5zaGFwZVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHByb3h5U3ltYm9sLmJ1aWxkUGF0aChjdHgsIHByb3h5U3ltYm9sLnNoYXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFByb3ZpZGUgc2V0Q29sb3IgaGVscGVyIG1ldGhvZCB0byBhdm9pZCBkZXRlcm1pbmUgaWYgc2V0IHRoZSBmaWxsIG9yIHN0cm9rZSBvdXRzaWRlXHJcbiAgICB2YXIgc3ltYm9sUGF0aFNldENvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ2ltYWdlJykge1xyXG4gICAgICAgICAgICB2YXIgc3ltYm9sU3R5bGUgPSB0aGlzLnN0eWxlO1xyXG4gICAgICAgICAgICB2YXIgc3ltYm9sU2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICBpZiAoc3ltYm9sU2hhcGUgJiYgc3ltYm9sU2hhcGUuc3ltYm9sVHlwZSA9PT0gJ2xpbmUnKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5zdHJva2UgPSBjb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9faXNFbXB0eUJydXNoKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5zdHJva2UgPSBjb2xvcjtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLmZpbGwgPSAnI2ZmZic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSDliKTmlq3lm77lvaLpu5jorqTmmK/loavlhYXov5jmmK/mj4/ovrnvvIzkvb/nlKggb25seVN0cm9rZSA/XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5maWxsICYmIChzeW1ib2xTdHlsZS5maWxsID0gY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlICYmIChzeW1ib2xTdHlsZS5zdHJva2UgPSBjb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHN5bWJvbFV0aWwgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlIGEgc3ltYm9sIGVsZW1lbnQgd2l0aCBnaXZlbiBzeW1ib2wgY29uZmlndXJhdGlvbjogc2hhcGUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbFR5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaFxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlU3ltYm9sOiBmdW5jdGlvbiAoc3ltYm9sVHlwZSwgeCwgeSwgdywgaCwgeiwgY29sb3IpIHtcclxuICAgICAgICAgICAgdmFyIGlzRW1wdHkgPSBzeW1ib2xUeXBlLmluZGV4T2YoJ2VtcHR5JykgPT09IDA7XHJcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUeXBlID0gc3ltYm9sVHlwZS5zdWJzdHIoNSwgMSkudG9Mb3dlckNhc2UoKSArIHN5bWJvbFR5cGUuc3Vic3RyKDYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzeW1ib2xQYXRoO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN5bWJvbFR5cGUuaW5kZXhPZignaW1hZ2U6Ly8nKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sUGF0aCA9IG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogc3ltYm9sVHlwZS5zbGljZSg4KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgejogelxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc3ltYm9sVHlwZS5pbmRleE9mKCdwYXRoOi8vJykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFBhdGggPSBncmFwaGljLm1ha2VQYXRoKHN5bWJvbFR5cGUuc2xpY2UoNyksIHt6OiB6LCByZWN0SG92ZXI6IHRydWV9LCBuZXcgQm91bmRpbmdSZWN0KHgsIHksIHcsIGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFBhdGggPSBuZXcgU3ltYm9sKHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xUeXBlOiBzeW1ib2xUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB6OiB6XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3ltYm9sUGF0aC5fX2lzRW1wdHlCcnVzaCA9IGlzRW1wdHk7XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xQYXRoLnNldENvbG9yID0gc3ltYm9sUGF0aFNldENvbG9yO1xyXG5cclxuICAgICAgICAgICAgc3ltYm9sUGF0aC5zZXRDb2xvcihjb2xvcik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sUGF0aDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gc3ltYm9sVXRpbDtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvU3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog55S75Y+l5p+EXHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XHJcbiAgICBmdW5jdGlvbiBIYW5kbGUodHlwZSwgeCwgeSwgY29ubmVjdG9yKXtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG5cclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcclxuXHJcbiAgICAgICAgdGhpcy5oYW5kbGVTaGFwZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogeCxcclxuICAgICAgICAgICAgICAgIGN5OiB5LFxyXG4gICAgICAgICAgICAgICAgcjogSGFuZGxlLlJBRElVU1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IFwicmdiKDAsMjU1LDApXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6XCJyZ2IoMCwwLDApXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgemxldmVsIDogY29ubmVjdG9yLm9wdGlvbnMueiArIDIsICAvL+iKgueCuVrkuLoxIOe6v+auteS4ujA7XHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTp0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGlzLmhhbmRsZVNoYXBlLm9uKFwiZHJhZ1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHRoYXQuYWN0aW9uQ29ubmVjdG9yKGUub2Zmc2V0WCxlLm9mZnNldFkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgLy8gcmV0dXJuIHRoaXMuY2lyY2xlO1xyXG4gICAgfVxyXG5cclxuICAgIEhhbmRsZS5SQURJVVMgPSA0O1xyXG5cclxuICAgIEhhbmRsZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yIDogSGFuZGxlLFxyXG5cclxuICAgICAgICBlcXVhbHMgOiBmdW5jdGlvbihhbm90aGVySGFuZGxlKXtcclxuICAgICAgICAgICAgaWYoIWFub3RoZXJIYW5kbGUgaW5zdGFuY2VvZiBIYW5kbGUpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IGFub3RoZXJIYW5kbGUudHlwZVxyXG4gICAgICAgICAgICAmJiB0aGlzLnggPT0gYW5vdGhlckhhbmRsZS54XHJcbiAgICAgICAgICAgICYmIHRoaXMueSA9PSBhbm90aGVySGFuZGxlLnlcclxuICAgICAgICAgICAgJiYgdGhpcy52aXNpYmxlID09IGFub3RoZXJIYW5kbGUudmlzaWJsZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTaGFwZS5hdHRyKCdwb3NpdGlvbicsIFswLCAwXSk7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2hhcGUuc2V0U2hhcGUoe1xyXG4gICAgICAgICAgICAgICAgY3g6IHgsXHJcbiAgICAgICAgICAgICAgICBjeTogeVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDnp7vliqjlj6Xmn4RcclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5ld1ggW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbmV3WSBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKi9cclxuICAgICAgICBhY3Rpb25Db25uZWN0b3I6IGZ1bmN0aW9uKG5ld1gsIG5ld1kpe1xyXG4gICAgICAgICAgICBzd2l0Y2godGhpcy50eXBlKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmib7lh7rkuKTkuKrovazmipjngrnvvIjlj6/np7vliqjlj6Xmn4TlnKjov5nkuKTkuKrovazmipjngrnkuK3pl7TvvIlcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50cy5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXNzb2NpYXRlZFBvaW50ICYmIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueCA9PSB0aGlzLmFzc29jaWF0ZWRQb2ludC54ICYmIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueSA9PSB0aGlzLmFzc29jaWF0ZWRQb2ludC55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueSA9PSB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueSA9PSB0aGlzLnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGgubWluKHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueCwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLngpIDw9IHRoaXMueFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5tYXgodGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54LCB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueCkgPj0gdGhpcy54KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhWSA9IG5ld1kgLSB0aGlzLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uTWF0cml4ID0gVXRpbC50cmFuc2xhdGlvbk1hdHJpeCgwLCBkZWx0YVkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2luZGV4LTFdLnRyYW5zZm9ybSh0cmFuc2xhdGlvbk1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpbmRleF0udHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5yZWZyZXNoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmib7lh7rkuKTkuKrovazmipjngrnvvIjlj6/np7vliqjlj6Xmn4TlnKjov5nkuKTkuKrovazmipjngrnkuK3pl7TvvIlcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50cy5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXNzb2NpYXRlZFBvaW50ICYmIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueCA9PSB0aGlzLmFzc29jaWF0ZWRQb2ludC54ICYmIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueSA9PSB0aGlzLmFzc29jaWF0ZWRQb2ludC55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueCA9PSB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueCA9PSB0aGlzLnhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGgubWluKHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueSwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLnkpIDw9IHRoaXMueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5tYXgodGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS55LCB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueSkgPj0gdGhpcy55KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YVggPSBuZXdYLXRoaXMueDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRpb25NYXRyaXggPSBVdGlsLnRyYW5zbGF0aW9uTWF0cml4KGRlbHRhWCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpbmRleC0xXS50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaW5kZXhdLnRyYW5zZm9ybSh0cmFuc2xhdGlvbk1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IucmVmcmVzaCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIC8vLiB0aGlzLnNoYXBlLnVwZGF0ZU1pZGRsZVRleHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW5kbGU7XHJcblxyXG5cclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvSGFuZGxlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog6L+e57q/5Yqo5oCB5pWI5p6cXHJcbiAqIEBhdXRob3IgbWlhby5jdW56aGlcclxuICovXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xyXG4gICAgdmFyIGN1cnZlVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvY3VydmUnKTtcclxuICAgIHZhciBzeW1ib2xVdGlsID0gcmVxdWlyZSgnLi9TeW1ib2wuanMnKTtcclxuXHJcbiAgICBmdW5jdGlvbiBFZmZlY3RMaW5lKHN5bWJvbCwgb3B0aW9ucywgZ3JvdXBDdXJ2ZSwgcG9seUxpbmUpIHtcclxuICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZVBlcmNlbnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZSA9IGdyb3VwQ3VydmU7XHJcbiAgICAgICAgdGhpcy5pbml0U3ltYm9sKG9wdGlvbnMsIHBvbHlMaW5lKTtcclxuICAgIH1cclxuICAgIHZhciBFZmZlY3RMaW5lUHJvdG8gPSBFZmZlY3RMaW5lLnByb3RvdHlwZTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8uaW5pdFN5bWJvbCA9IGZ1bmN0aW9uKG9wdGlvbnMsIHBvbHlMaW5lKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLnoyID0gMTAwO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLmN1bGxpbmcgPSB0cnVlO1xyXG4gICAgICAgIHZhciBwZXJpb2QgPSBvcHRpb25zLmVmZmVjdC5wZXJpb2QgKiAxMDAwO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fdCA9IDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuc3RvcEFuaW1hdGlvbigpO1xyXG4gICAgICAgIGlmICgob3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBcImN1cnZlXCIpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwQ3VydmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgIHBlcmlvZCA9IHBlcmlvZCAvIHRoaXMuZ3JvdXBDdXJ2ZS5fY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlQW5pbWF0ZSh0aGlzLmdyb3VwQ3VydmUuX2NoaWxkcmVuWzBdLCBpLCBwZXJpb2QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sLmFuaW1hdGUoJycsIHRydWUpXHJcbiAgICAgICAgICAgICAgICAud2hlbihwZXJpb2QsIHtcclxuICAgICAgICAgICAgICAgICAgICBfX3Q6IDFcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuZGVsYXkoMClcclxuICAgICAgICAgICAgICAgIC5kdXJpbmcoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51cGRhdGVTeW1ib2xQb3NpdGlvblBvbHlsaW5lKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QW5pbWF0aW9uUG9pbnRzUG9seWxpbmUocG9seUxpbmUuc2hhcGUucG9pbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8uZ3JvdXBDdXJ2ZUFuaW1hdGUgPSBmdW5jdGlvbihjdXJ2ZUxpbmUsIGksIHBlcmlvZCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBpZiAoY3VydmVMaW5lID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjdXJ2ZUxpbmUgPSB0aGlzLmdyb3VwQ3VydmUuX2NoaWxkcmVuWzBdO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBvaW50cztcclxuICAgICAgICB2YXIgcG9zID0gY3VydmVMaW5lLnNoYXBlO1xyXG4gICAgICAgIHBvaW50cyA9IFtcclxuICAgICAgICAgICAgW3Bvcy54MSwgcG9zLnkxXSxcclxuICAgICAgICAgICAgW3Bvcy54MiwgcG9zLnkyXSxcclxuICAgICAgICAgICAgW3Bvcy5jcHgxLCBwb3MuY3B5MV0sXHJcbiAgICAgICAgICAgIFtwb3MuY3B4MiwgcG9zLmNweTJdXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLnNldEFuaW1hdGlvblBvaW50c0JlemllckN1cnZlKHBvaW50cyk7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuYW5pbWF0ZSgnJylcclxuICAgICAgICAgICAgLndoZW4ocGVyaW9kLCB7XHJcbiAgICAgICAgICAgICAgICBfX3Q6IDFcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmRlbGF5KDApXHJcbiAgICAgICAgICAgIC5kdXJpbmcoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVN5bWJvbFBvc2l0aW9uQmV6aWVyQ3VydmUoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnN5bWJvbC5fX3QgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5ncm91cEN1cnZlQW5pbWF0ZSh0aGF0Lmdyb3VwQ3VydmUuX2NoaWxkcmVuW2kgKyAxXSwgaSArIDEsIHBlcmlvZCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdGFydCgpO1xyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by5zZXRBbmltYXRpb25Qb2ludHNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fcDEgPSBwb2ludHNbMF07XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX19wMiA9IHBvaW50c1sxXTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX2NwMSA9IHBvaW50c1syXSB8fCBbXHJcbiAgICAgICAgICAgIChwb2ludHNbMF1bMF0gKyBwb2ludHNbMV1bMF0pIC8gMixcclxuICAgICAgICAgICAgKHBvaW50c1swXVsxXSArIHBvaW50c1sxXVsxXSkgLyAyXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX2NwMiA9IHBvaW50c1szXTtcclxuICAgIH07XHJcblxyXG4gICAgRWZmZWN0TGluZVByb3RvLnVwZGF0ZVN5bWJvbFBvc2l0aW9uQmV6aWVyQ3VydmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcDEgPSB0aGlzLnN5bWJvbC5fX3AxO1xyXG4gICAgICAgIHZhciBwMiA9IHRoaXMuc3ltYm9sLl9fcDI7XHJcbiAgICAgICAgdmFyIGNwMSA9IHRoaXMuc3ltYm9sLl9fY3AxO1xyXG4gICAgICAgIHZhciBjcDIgPSB0aGlzLnN5bWJvbC5fX2NwMjtcclxuICAgICAgICB2YXIgdCA9IHRoaXMuc3ltYm9sLl9fdDtcclxuICAgICAgICB2YXIgcG9zID0gdGhpcy5zeW1ib2wucG9zaXRpb247XHJcbiAgICAgICAgdmFyIHR4LCB0eTtcclxuICAgICAgICBpZiAoY3AyWzBdICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YXIgY3ViaWNBdCA9IGN1cnZlVXRpbC5jdWJpY0F0O1xyXG4gICAgICAgICAgICB2YXIgY3ViaWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVV0aWwuY3ViaWNEZXJpdmF0aXZlQXQ7XHJcbiAgICAgICAgICAgIHBvc1swXSA9IGN1YmljQXQocDFbMF0sIGNwMVswXSwgY3AyWzBdLCBwMlswXSwgdCk7XHJcbiAgICAgICAgICAgIHBvc1sxXSA9IGN1YmljQXQocDFbMV0sIGNwMVsxXSwgY3AyWzFdLCBwMlsxXSwgdCk7XHJcbiAgICAgICAgICAgIC8vIFRhbmdlbnRcclxuICAgICAgICAgICAgdHggPSBjdWJpY0Rlcml2YXRpdmVBdChwMVswXSwgY3AxWzBdLCBjcDJbMF0sIHAyWzBdLCB0KTtcclxuICAgICAgICAgICAgdHkgPSBjdWJpY0Rlcml2YXRpdmVBdChwMVsxXSwgY3AxWzFdLCBjcDJbMV0sIHAyWzFdLCB0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZVV0aWwucXVhZHJhdGljQXQ7XHJcbiAgICAgICAgICAgIHZhciBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVV0aWwucXVhZHJhdGljRGVyaXZhdGl2ZUF0O1xyXG4gICAgICAgICAgICBwb3NbMF0gPSBxdWFkcmF0aWNBdChwMVswXSwgY3AxWzBdLCBwMlswXSwgdCk7XHJcbiAgICAgICAgICAgIHBvc1sxXSA9IHF1YWRyYXRpY0F0KHAxWzFdLCBjcDFbMV0sIHAyWzFdLCB0KTtcclxuICAgICAgICAgICAgLy8gVGFuZ2VudFxyXG4gICAgICAgICAgICB0eCA9IHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMVswXSwgY3AxWzBdLCBwMlswXSwgdCk7XHJcbiAgICAgICAgICAgIHR5ID0gcXVhZHJhdGljRGVyaXZhdGl2ZUF0KHAxWzFdLCBjcDFbMV0sIHAyWzFdLCB0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zeW1ib2wucm90YXRpb24gPSAtTWF0aC5hdGFuMih0eSwgdHgpIC0gTWF0aC5QSSAvIDI7XHJcblxyXG4gICAgICAgIHRoaXMuc3ltYm9sLmlnbm9yZSA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8uc2V0QW5pbWF0aW9uUG9pbnRzUG9seWxpbmUgPSBmdW5jdGlvbihwb2ludHMpIHtcclxuICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgdmFyIGFjY0xlbkFyciA9IFswXTtcclxuICAgICAgICB2YXIgbGVuID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcDEgPSBwb2ludHNbaSAtIDFdO1xyXG4gICAgICAgICAgICB2YXIgcDIgPSBwb2ludHNbaV07XHJcbiAgICAgICAgICAgIGxlbiArPSB2ZWMyLmRpc3QocDEsIHAyKTtcclxuICAgICAgICAgICAgYWNjTGVuQXJyLnB1c2gobGVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFjY0xlbkFyci5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBhY2NMZW5BcnJbal0gLz0gbGVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9vZmZzZXRzID0gYWNjTGVuQXJyO1xyXG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbjtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fbGFzdEZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX2xhc3RGcmFtZVBlcmNlbnQgPSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8udXBkYXRlU3ltYm9sUG9zaXRpb25Qb2x5bGluZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0ID0gdGhpcy5zeW1ib2wuX190O1xyXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLl9wb2ludHM7XHJcbiAgICAgICAgdmFyIG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xyXG4gICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoIW9mZnNldHMpIHtcclxuICAgICAgICAgICAgLy8gSGFzIGxlbmd0aCAwXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsYXN0RnJhbWUgPSB0aGlzLl9sYXN0RnJhbWU7XHJcbiAgICAgICAgdmFyIGZyYW1lO1xyXG5cclxuICAgICAgICBpZiAodCA8IHRoaXMuX2xhc3RGcmFtZVBlcmNlbnQpIHtcclxuICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSB0aGUgbmV4dCBmcmFtZVxyXG4gICAgICAgICAgICAvLyBQRU5ESU5HIHN0YXJ0IGZyb20gbGFzdEZyYW1lID9cclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5taW4obGFzdEZyYW1lICsgMSwgbGVuIC0gMSk7XHJcbiAgICAgICAgICAgIGZvciAoZnJhbWUgPSBzdGFydDsgZnJhbWUgPj0gMDsgZnJhbWUtLSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldHNbZnJhbWVdIDw9IHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQRU5ESU5HIHJlYWxseSBuZWVkIHRvIGRvIHRoaXMgP1xyXG4gICAgICAgICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lLCBsZW4gLSAyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBmcmFtZSA9IGxhc3RGcmFtZTsgZnJhbWUgPCBsZW47IGZyYW1lKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRzW2ZyYW1lXSA+IHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lIC0gMSwgbGVuIC0gMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZlYzIubGVycChcclxuICAgICAgICAgICAgdGhpcy5zeW1ib2wucG9zaXRpb24sIHBvaW50c1tmcmFtZV0sIHBvaW50c1tmcmFtZSArIDFdLFxyXG4gICAgICAgICAgICAodCAtIG9mZnNldHNbZnJhbWVdKSAvIChvZmZzZXRzW2ZyYW1lICsgMV0gLSBvZmZzZXRzW2ZyYW1lXSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSBmcmFtZTtcclxuICAgICAgICB0aGlzLl9sYXN0RnJhbWVQZXJjZW50ID0gdDtcclxuICAgICAgICB2YXIgYW5nbGUgPSAtTWF0aC5hdGFuMihwb2ludHNbZnJhbWUgKyAxXVsxXSAtIHBvaW50c1tmcmFtZV1bMV0sIHBvaW50c1tmcmFtZSArIDFdWzBdIC0gcG9pbnRzW2ZyYW1lXVswXSk7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wucm90YXRpb24gPSBhbmdsZSAtIE1hdGguUEkgLyAyO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLmlnbm9yZSA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gRWZmZWN0TGluZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvRWZmZWN0TGluZS5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOaOp+WItueCuVxyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uL2dyYXBoaWMuanNcIik7XHJcbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uUG9pbnQoY29ubmVjdG9yLCBwb2ludCwgdHlwZSwgb3B0aW9ucyl7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBjb25uZWN0b3I7XHJcblxyXG4gICAgICAgIHRoaXMucG9pbnQgPSBwb2ludC5jbG9uZSgpO1xyXG5cclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbG9yID0gQ29ubmVjdGlvblBvaW50Lk5PUk1BTF9DT0xPUjtcclxuXHJcbiAgICAgICAgdGhpcy5vVHlwZSA9ICdDb25uZWN0aW9uUG9pbnQnO1xyXG5cclxuICAgICAgICB0aGlzLnNoYXBlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIGN4OiB0aGlzLnBvaW50LngsXHJcbiAgICAgICAgICAgICAgICBjeTogdGhpcy5wb2ludC55LFxyXG4gICAgICAgICAgICAgICAgcjogQ29ubmVjdGlvblBvaW50LlJBRElVU1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IHRoaXMuY29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6JyMwMDAwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHogOiBvcHRpb25zLnogKyAyICAvL+iKgueCuVrkuLoxIOe6v+auteS4ujA7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zaGFwZS50eXBlID0gIHRoaXMudHlwZTtcclxuXHJcbiAgICAgICAgdGhpcy5zaGFwZS5jb25uZWN0b3IgPSBjb25uZWN0b3I7XHJcbiAgICAgICAgLy9yZXR1cm4gdGhpcy5jaXJjbGU7XHJcbiAgICB9XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50Lk5PUk1BTF9DT0xPUiA9IFwiI0ZGRkYzM1wiOyAvL3llbGxvdy5cclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQuT1ZFUl9DT0xPUiA9IFwiI0ZGOTkwMFwiOyAvL29yYW5nZVxyXG5cclxuICAgIENvbm5lY3Rpb25Qb2ludC5DT05ORUNURURfQ09MT1IgPSBcIiNmZjAwMDBcIjsgLy9yZWRcclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQuUkFESVVTID0gNDtcclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQuVFlQRV9GSUdVUkUgPSAnZmlndXJlJztcclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQuVFlQRV9DT05ORUNUT1IgPSAnY29ubmVjdG9yJztcclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvciA6IENvbm5lY3Rpb25Qb2ludCxcclxuXHJcbiAgICAgICAgZXF1YWxzIDogZnVuY3Rpb24oYW5vdGhlckNvbm5lY3Rpb25Qb2ludCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvaW50LmVxdWFscyhhbm90aGVyQ29ubmVjdGlvblBvaW50LnBvaW50KVxyXG4gICAgICAgICAgICAmJiB0aGlzLmNvbm5lY3RvciA9PSBhbm90aGVyQ29ubmVjdGlvblBvaW50LmNvbm5lY3RvclxyXG4gICAgICAgICAgICAmJiB0aGlzLnR5cGUgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC50eXBlXHJcbiAgICAgICAgICAgICYmIHRoaXMuY29sb3IgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5jb2xvclxyXG4gICAgICAgICAgICAmJiB0aGlzLnJhZGl1cyA9PSBhbm90aGVyQ29ubmVjdGlvblBvaW50LnJhZGl1cztcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25Qb2ludDtcclxuXHJcblxyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0aW9uUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDoioLngrnnrYnnmoTmqKHlnotcclxuICog6YeM6Z2i5a2Y55qE5pWw5o2u55So5p2l5aSE55CG5bqP5YiX5YyW5ZKM5Y+N5bqP5YiX5YyWXHJcbiAqIEBjbGFzcyBmaXNoLnRvcG8ubW9kZWxcclxuICovXHJcblxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBjbGF6elV0aWwgPSByZXF1aXJlKCcuL2NsYXp6Jyk7XHJcblxyXG4gICAgZnVuY3Rpb24gTW9kZWwob3B0aW9uLCBwYXJlbnRNb2RlbCwgIGV4dHJhT3B0KSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRNb2RlbCA9IHBhcmVudE1vZGVsO1xyXG4gICAgICAgIHRoaXMub3B0aW9uID0gb3B0aW9uO1xyXG5cclxuICAgICAgICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXHJcbiAgICAgICAgaWYgKHRoaXMuaW5pdCkge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQob3B0aW9uLCBwYXJlbnRNb2RlbCwgIGV4dHJhT3B0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIE1vZGVsLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3I6IE1vZGVsLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNb2RlbCDnmoTliJ3lp4vljJblh73mlbBcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXREZWZhdWx0T3B0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnX19kZWZhdWx0T3B0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcHRMaXN0ID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKENsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdCA9IENsYXNzLnByb3RvdHlwZS5kZWZhdWx0T3B0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdCAmJiBvcHRMaXN0LnB1c2gob3B0KTtcclxuICAgICAgICAgICAgICAgICAgICBDbGFzcyA9IENsYXNzLnN1cGVyQ2xhc3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRPcHRpb24gPSB7fTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBvcHRMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbiA9IHpyVXRpbC5tZXJnZShkZWZhdWx0T3B0aW9uLCBvcHRMaXN0W2ldLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19kZWZhdWx0T3B0aW9uID0gZGVmYXVsdE9wdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RlZmF1bHRPcHRpb247XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICB6clV0aWwubWVyZ2UodGhpcy5vcHRpb24sIG9wdGlvbiwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+WbW9kZWznmoTmn5DkuKrlsZ7mgKfnmoTlgLxcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBtb2RlbOS4reeahOWxnuaAp1xyXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgICAgICBub2RlLm1vZGVsLmdldChcIm9wdGlvbnMudGV4dFwiKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChwYXRoLCBpZ25vcmVQYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb247XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLm9wdGlvbjtcclxuICAgICAgICAgICAgdmFyIHBhcmVudE1vZGVsID0gdGhpcy5wYXJlbnRNb2RlbDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvYmogY291bGQgYmUgbnVtYmVyL3N0cmluZy8uLi4gKGxpa2UgMClcclxuICAgICAgICAgICAgICAgIG9iaiA9IChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpID8gb2JqW3BhdGhbaV1dIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCAmJiBwYXJlbnRNb2RlbCAmJiAhaWdub3JlUGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBvYmogPSBwYXJlbnRNb2RlbC5nZXQocGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDorr7nva5tb2RlbOeahOafkOS4quWxnuaAp+eahOWAvFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIG1vZGVs5Lit55qE5bGe5oCnXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIOaJgOmcgOimgeiuvue9rueahOWAvFxyXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgICAgICBub2RlLm1vZGVsLnNldChcIm9wdGlvbnMudGV4dFwiLFwi5L6L5a2QXCIpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHBhdGgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLm9wdGlvbjtcclxuXHJcbiAgICAgICAgICAgIGlmIChwYXRoLmluZGV4T2YoXCIuXCIpID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBvYmpbcGF0aF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaWVsZEFycmF5ICA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgIHZhciBuID0gZmllbGRBcnJheS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFJlZiA9IG9iajtcclxuICAgICAgICAgICAgICAgIHZhciBmaWVsZE5hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lID0gZmllbGRBcnJheVtpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50UmVmW2ZpZWxkTmFtZV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVmW2ZpZWxkTmFtZV0gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlZiA9IGN1cnJlbnRSZWZbZmllbGROYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkQXJyYXlbbi0xXTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSZWZbZmllbGROYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRTaGFsbG93OiBmdW5jdGlvbiAoa2V5LCBpZ25vcmVQYXJlbnQpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gb3B0aW9uICYmIG9wdGlvbltrZXldO1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50TW9kZWwgPSB0aGlzLnBhcmVudE1vZGVsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09IG51bGwgJiYgcGFyZW50TW9kZWwgJiYgIWlnbm9yZVBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gcGFyZW50TW9kZWwuZ2V0U2hhbGxvdyhrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRNb2RlbDogZnVuY3Rpb24gKHBhdGgsIHBhcmVudE1vZGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmogPSB0aGlzLmdldChwYXRoLCB0cnVlKTtcclxuICAgICAgICAgICAgdmFyIHRoaXNQYXJlbnRNb2RlbCA9IHRoaXMucGFyZW50TW9kZWw7XHJcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbChcclxuICAgICAgICAgICAgICAgIG9iaiwgcGFyZW50TW9kZWwgfHwgKHRoaXNQYXJlbnRNb2RlbCAmJiB0aGlzUGFyZW50TW9kZWwuZ2V0TW9kZWwocGF0aCkpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKua4heepum1vZGVs55qEb3B0aW9uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbiA9PSBudWxsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7fSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgQ3RvciA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcih6clV0aWwuY2xvbmUodGhpcy5vcHRpb24pKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEVuYWJsZSBNb2RlbC5leHRlbmQuXHJcbiAgICBjbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoTW9kZWwpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gTW9kZWw7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHJcbiAgICB2YXIgY2xhenogPSB7fTtcclxuXHJcbiAgICB2YXIgVFlQRV9ERUxJTUlURVIgPSAnLic7XHJcbiAgICB2YXIgSVNfQ09OVEFJTkVSID0gJ19fX0ZUX19DT01QT05FTlRfX0NPTlRBSU5FUl9fXyc7XHJcbiAgICAvKipcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgdmFyIHBhcnNlQ2xhc3NUeXBlID0gY2xhenoucGFyc2VDbGFzc1R5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgIHZhciByZXQgPSB7bWFpbjogJycsIHN1YjogJyd9O1xyXG4gICAgICAgIGlmIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBjb21wb25lbnRUeXBlLnNwbGl0KFRZUEVfREVMSU1JVEVSKTtcclxuICAgICAgICAgICAgcmV0Lm1haW4gPSBjb21wb25lbnRUeXBlWzBdIHx8ICcnO1xyXG4gICAgICAgICAgICByZXQuc3ViID0gY29tcG9uZW50VHlwZVsxXSB8fCAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwdWJsaWMgIOebuOavlCDnm7TmjqXnlKh6clV0aWwuaW5oZXJpdHMg5aW95aSE5pivICDlj6/ku6Xnm7TmjqXosIPnlKjniLbnsbvnmoTmnoTpgKDlh73mlbBcclxuICAgICAqL1xyXG4gICAgY2xhenouZW5hYmxlQ2xhc3NFeHRlbmQgPSBmdW5jdGlvbiAoUm9vdENsYXNzLCBwcmVDb25zdHJ1Y3QpIHtcclxuICAgICAgICBSb290Q2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3RvKSB7XHJcbiAgICAgICAgICAgIHZhciBFeHRlbmRlZENsYXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcHJlQ29uc3RydWN0ICYmIHByZUNvbnN0cnVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgUm9vdENsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB6clV0aWwuZXh0ZW5kKEV4dGVuZGVkQ2xhc3MucHJvdG90eXBlLCBwcm90byk7XHJcblxyXG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLmV4dGVuZCA9IHRoaXMuZXh0ZW5kO1xyXG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLnN1cGVyQ2FsbCA9IHN1cGVyQ2FsbDtcclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckFwcGx5ID0gc3VwZXJBcHBseTtcclxuICAgICAgICAgICAgenJVdGlsLmluaGVyaXRzKEV4dGVuZGVkQ2xhc3MsIHRoaXMpO1xyXG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLnN1cGVyQ2xhc3MgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIEV4dGVuZGVkQ2xhc3M7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gc3VwZXJDYWxsIHNob3VsZCBoYXZlIGNsYXNzIGluZm8sIHdoaWNoIGNhbiBub3QgYmUgZmV0Y2ggZnJvbSAndGhpcycuXHJcbiAgICAvLyBDb25zaWRlciB0aGlzIGNhc2U6XHJcbiAgICAvLyBjbGFzcyBBIGhhcyBtZXRob2QgZixcclxuICAgIC8vIGNsYXNzIEIgaW5oZXJpdHMgY2xhc3MgQSwgb3ZlcnJpZGVzIG1ldGhvZCBmLCBmIGNhbGwgc3VwZXJBcHBseSgnZicpLFxyXG4gICAgLy8gY2xhc3MgQyBpbmhlcml0cyBjbGFzcyBCLCBkbyBub3Qgb3ZlcnJpZGVzIG1ldGhvZCBmLFxyXG4gICAgLy8gdGhlbiB3aGVuIG1ldGhvZCBvZiBjbGFzcyBDIGlzIGNhbGxlZCwgZGVhZCBsb29wIG9jY3VyZWQuXHJcbiAgICBmdW5jdGlvbiBzdXBlckNhbGwoY29udGV4dCwgbWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHZhciBhcmdzID0genJVdGlsLnNsaWNlKGFyZ3VtZW50cywgMik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3VwZXJBcHBseShjb250ZXh0LCBtZXRob2ROYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW50aXR5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWdpc3RlcldoZW5FeHRlbmRdXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGNsYXp6LmVuYWJsZUNsYXNzTWFuYWdlbWVudCA9IGZ1bmN0aW9uIChlbnRpdHksIG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29tcG9uZW50IG1vZGVsIGNsYXNzZXNcclxuICAgICAgICAgKiBrZXk6IGNvbXBvbmVudFR5cGUsXHJcbiAgICAgICAgICogdmFsdWU6XHJcbiAgICAgICAgICogICAgIGNvbXBvbmVudENsYXNzLCB3aGVuIGNvbXBvbmVudFR5cGUgaXMgJ3h4eCdcclxuICAgICAgICAgKiAgICAgb3IgT2JqZWN0LjxzdWJLZXksIGNvbXBvbmVudENsYXNzPiwgd2hlbiBjb21wb25lbnRUeXBlIGlzICd4eHgueXknXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgc3RvcmFnZSA9IHt9O1xyXG5cclxuICAgICAgICBlbnRpdHkucmVnaXN0ZXJDbGFzcyA9IGZ1bmN0aW9uIChDbGF6eiwgY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50VHlwZS5zdWIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5bey57uP5rOo5YaM6L+H5LqG77yM55u05o6l6L+U5ZueXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dID0gQ2xheno7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnRUeXBlLnN1YiAhPT0gSVNfQ09OVEFJTkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG1ha2VDb250YWluZXIoY29tcG9uZW50VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyW2NvbXBvbmVudFR5cGUuc3ViXSA9IENsYXp6O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBDbGF6ejtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZU1haW4sIHN1YlR5cGUsIHRocm93V2hlbk5vdEZvdW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBDbGF6eiA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZU1haW5dO1xyXG5cclxuICAgICAgICAgICAgaWYgKENsYXp6ICYmIENsYXp6W0lTX0NPTlRBSU5FUl0pIHtcclxuICAgICAgICAgICAgICAgIENsYXp6ID0gc3ViVHlwZSA/IENsYXp6W3N1YlR5cGVdIDogbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRocm93V2hlbk5vdEZvdW5kICYmICFDbGF6eikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICdDb21wb25lbnQgJyArIGNvbXBvbmVudFR5cGVNYWluICsgJy4nICsgKHN1YlR5cGUgfHwgJycpICsgJyBub3QgZXhpc3RzLiBMb2FkIGl0IGZpcnN0LidcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBDbGF6ejtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkuZ2V0Q2xhc3Nlc0J5TWFpblR5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgIHZhciBvYmogPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XHJcblxyXG4gICAgICAgICAgICBpZiAob2JqICYmIG9ialtJU19DT05UQUlORVJdKSB7XHJcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChvYmosIGZ1bmN0aW9uIChvLCB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gSVNfQ09OVEFJTkVSICYmIHJlc3VsdC5wdXNoKG8pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmopO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGVudGl0eS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIC8vIEp1c3QgY29uc2lkZXIgY29tcG9uZW50VHlwZS5tYWluLlxyXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybiAhIXN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gTGlrZSBbJ2FhJywgJ2JiJ10sIGJ1dCBjYW4gbm90IGJlIFsnYWEueHgnXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVudGl0eS5nZXRBbGxDbGFzc01haW5UeXBlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGVzID0gW107XHJcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHN0b3JhZ2UsIGZ1bmN0aW9uIChvYmosIHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2godHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgYSBtYWluIHR5cGUgaXMgY29udGFpbmVyIGFuZCBoYXMgc3ViIHR5cGVzXHJcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSAgY29tcG9uZW50VHlwZVxyXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW50aXR5Lmhhc1N1YlR5cGVzID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIG9ialtJU19DT05UQUlORVJdO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGVudGl0eS5wYXJzZUNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBtYWtlQ29udGFpbmVyKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcclxuICAgICAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lcltJU19DT05UQUlORVJdKSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl0gPSB7fTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcltJU19DT05UQUlORVJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMucmVnaXN0ZXJXaGVuRXh0ZW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEV4dGVuZCA9IGVudGl0eS5leHRlbmQ7XHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEV4dGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBFeHRlbmRlZENsYXNzID0gb3JpZ2luYWxFeHRlbmQuY2FsbCh0aGlzLCBwcm90byk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudGl0eS5yZWdpc3RlckNsYXNzKEV4dGVuZGVkQ2xhc3MsIHByb3RvLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjbGF6ejtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9jbGF6ei5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOaTjeS9nOWbvuagh+exu1xyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgSWNvbk9wZXJhdGlvbiA9IHtcclxuICAgICAgICBTVFJBSUdIVF9TVkc6ICdNOTM3LjM1Mzg0NiA3MjQuNjc2OTIzQzg4Mi4yMTUzODUgNjY5LjUzODQ2MiA3OTUuNTY5MjMxIDY2MS42NjE1MzggNzMyLjU1Mzg0NiA3MDEuMDQ2MTU0TDM2Mi4zMzg0NjIgMzMwLjgzMDc2OUM0MDEuNzIzMDc3IDI2Ny44MTUzODUgMzkzLjg0NjE1NCAxODEuMTY5MjMxIDMzOC43MDc2OTIgMTI2LjAzMDc2OSAyNjcuODE1Mzg1IDU1LjEzODQ2MiAxNjUuNDE1Mzg1IDU1LjEzODQ2MiA5NC41MjMwNzcgMTI2LjAzMDc2OSAyMy42MzA3NjkgMTk2LjkyMzA3NyAyMy42MzA3NjkgMjk5LjMyMzA3NyA5NC41MjMwNzcgMzcwLjIxNTM4NSAxNDkuNjYxNTM4IDQyNS4zNTM4NDYgMjM2LjMwNzY5MiA0MzMuMjMwNzY5IDI5OS4zMjMwNzcgMzkzLjg0NjE1NEw2NjkuNTM4NDYyIDc2NC4wNjE1MzhDNjMwLjE1Mzg0NiA4MjcuMDc2OTIzIDYzOC4wMzA3NjkgOTEzLjcyMzA3NyA2OTMuMTY5MjMxIDk2OC44NjE1MzggNzY0LjA2MTUzOCAxMDM5Ljc1Mzg0NiA4NjYuNDYxNTM4IDEwMzkuNzUzODQ2IDkzNy4zNTM4NDYgOTY4Ljg2MTUzOCAxMDAwLjM2OTIzMSA4OTcuOTY5MjMxIDEwMDAuMzY5MjMxIDc5NS41NjkyMzEgOTM3LjM1Mzg0NiA3MjQuNjc2OTIzTDkzNy4zNTM4NDYgNzI0LjY3NjkyM1pNMjc1LjY5MjMwOCAzMDcuMkMyNDQuMTg0NjE1IDMzOC43MDc2OTIgMTg5LjA0NjE1NCAzMzguNzA3NjkyIDE1Ny41Mzg0NjIgMzA3LjIgMTI2LjAzMDc2OSAyNzUuNjkyMzA4IDEyNi4wMzA3NjkgMjIwLjU1Mzg0NiAxNTcuNTM4NDYyIDE4OS4wNDYxNTQgMTg5LjA0NjE1NCAxNTcuNTM4NDYyIDI0NC4xODQ2MTUgMTU3LjUzODQ2MiAyNzUuNjkyMzA4IDE4OS4wNDYxNTQgMzA3LjIgMjIwLjU1Mzg0NiAzMDcuMiAyNjcuODE1Mzg1IDI3NS42OTIzMDggMzA3LjJMMjc1LjY5MjMwOCAzMDcuMlpNODc0LjMzODQ2MiA5MTMuNzIzMDc3Qzg0Mi44MzA3NjkgOTQ1LjIzMDc2OSA3ODcuNjkyMzA4IDk0NS4yMzA3NjkgNzU2LjE4NDYxNSA5MTMuNzIzMDc3IDcyNC42NzY5MjMgODgyLjIxNTM4NSA3MjQuNjc2OTIzIDgyNy4wNzY5MjMgNzU2LjE4NDYxNSA3OTUuNTY5MjMxIDc4Ny42OTIzMDggNzY0LjA2MTUzOCA4NDIuODMwNzY5IDc2NC4wNjE1MzggODc0LjMzODQ2MiA3OTUuNTY5MjMxIDkwNS44NDYxNTQgODI3LjA3NjkyMyA5MDUuODQ2MTU0IDg3NC4zMzg0NjIgODc0LjMzODQ2MiA5MTMuNzIzMDc3TDg3NC4zMzg0NjIgOTEzLjcyMzA3N1onLFxyXG4gICAgICAgIEpBR0dFRF9TVkc6ICdNMjA0LjggODE5LjJsLTUxLjItMTAyLjQgMjA0LjgtMzA3LjIgNTEuMiAxMDIuNC0yMDQuOCAzMDcuMnpNNDA5LjYgNTEybDUxLjItMTAyLjQgMTUzLjYgMjA0LjgtNTEuMiAxMDIuNC0xNTMuNi0yMDQuOHpNODE5LjIgMjA0LjhsNTEuMiAxMDIuNC0yMDQuOCA0MDkuNi01MS4yLTEwMi40IDIwNC44LTQwOS42eiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE0xNTMuNiA3MTYuOGMtODcuMDQgMC0xNTMuNiA2Ni41Ni0xNTMuNiAxNTMuNnM2Ni41NiAxNTMuNiAxNTMuNiAxNTMuNiAxNTMuNi02Ni41NiAxNTMuNi0xNTMuNi02Ni41Ni0xNTMuNi0xNTMuNi0xNTMuNnogbTUxLjIgMjA0LjhIMTAyLjR2LTEwMi40aDEwMi40djEwMi40ek00MDkuNiAyMDQuOEMzMjIuNTYgMjA0LjggMjU2IDI3MS4zNiAyNTYgMzU4LjRzNjYuNTYgMTUzLjYgMTUzLjYgMTUzLjYgMTUzLjYtNjYuNTYgMTUzLjYtMTUzLjYtNjYuNTYtMTUzLjYtMTUzLjYtMTUzLjZ6IG01MS4yIDIwNC44SDM1OC40VjMwNy4yaDEwMi40djEwMi40ek02MTQuNCA2MTQuNGMtODcuMDQgMC0xNTMuNiA2Ni41Ni0xNTMuNiAxNTMuNnM2Ni41NiAxNTMuNiAxNTMuNiAxNTMuNiAxNTMuNi02Ni41NiAxNTMuNi0xNTMuNi02Ni41Ni0xNTMuNi0xNTMuNi0xNTMuNnogbTUxLjIgMjA0LjhoLTEwMi40di0xMDIuNGgxMDIuNHYxMDIuNHpNODcwLjQgMGMtODcuMDQgMC0xNTMuNiA2Ni41Ni0xNTMuNiAxNTMuNnM2Ni41NiAxNTMuNiAxNTMuNiAxNTMuNiAxNTMuNi02Ni41NiAxNTMuNi0xNTMuNi02Ni41Ni0xNTMuNi0xNTMuNi0xNTMuNnogbTUxLjIgMjA0LjhoLTEwMi40VjEwMi40aDEwMi40djEwMi40eicsXHJcbiAgICAgICAgQ1VSVkVfU1ZHOiAnTTEwMTQuMjg1MDM5IDgyNC4wMjQyMzRsLTE0NS4xNjg0MjgtMTQ0LjM3MjA1Yy0xMi45Njk1OTMtMTIuODU1ODI1LTM3LjU0MzU1OS0xNC41MDU0NjYtNDQuNTk3MTk3IDIuMzMyMjUyLTEuODc3MTc4IDQuNTUwNzM0LTIuMjc1MzY3IDE3LjE3OTAyMi0yLjI3NTM2OCAxNy4xNzkwMjJ2OTcuNTU2MzY5SDMzMC45MzUzODNhMTE4LjMxOTA5NSAxMTguMzE5MDk1IDAgMCAxLTExOC41NDY2MzItMTE3LjkyMDkwNUExMTguMzE5MDk1IDExOC4zMTkwOTUgMCAwIDEgMzMwLjk5MjI2NyA1NjAuODc4MDE2aDQ0NS41MTY4OTljMTIxLjU2MTQ5MyAwIDIyMC40MjYxOTgtOTguMzUyNzQ3IDIyMC40MjYxOTgtMjE5LjIzMTYzcy05OC44NjQ3MDUtMjE5LjE3NDc0Ni0yMjAuNDI2MTk4LTIxOS4xNzQ3NDZIMzQwLjQ5MTkyNUExNzQuMjM2MjQ0IDE3NC4yMzYyNDQgMCAwIDAgMTc0LjEwNTY5OCAwIDE3My43ODExNyAxNzMuNzgxMTcgMCAwIDAgMC4wNDAxMDcgMTczLjA5ODU2YTE3My43ODExNyAxNzMuNzgxMTcgMCAwIDAgMTc0LjA2NTU5MSAxNzMuMDk4NTYgMTc0LjIzNjI0NCAxNzQuMjM2MjQ0IDAgMCAwIDE2Ni4zODYyMjctMTIyLjQ3MTYzOWg0MzYuMDE3MjQxYzY1LjQxNjgwNyAwIDExOC42MDM1MTYgNTIuOTAyMjg4IDExOC42MDM1MTUgMTE3LjkyMDkwNUExMTguMzE5MDk1IDExOC4zMTkwOTUgMCAwIDEgNzc2LjUwOTE2NiA0NTkuNjI0MTc2SDMzMC45OTIyNjdjLTEyMS41MDQ2MDkgMC0yMjAuMzY5MzE0IDk4LjM1Mjc0Ny0yMjAuMzY5MzE0IDIxOS4yMzE2M3M5OC44NjQ3MDUgMjE5LjE3NDc0NiAyMjAuMzY5MzE0IDIxOS4xNzQ3NDZoNDkxLjE5NDg5NXY5Mi41NTA1NjFzMCAxNC4yMjEwNDUgMi4zMzIyNTIgMTkuNzk1Njk1YzcuMDUzNjM4IDE2Ljg5NDYwMiAzMS42Mjc2MDQgMTcuNTc3MjEyIDQ0LjU5NzE5NyA0LjY2NDUwMmwxNDUuMTExNTQzLTE0NC4zMTUxNjVhMzIuODc5MDU2IDMyLjg3OTA1NiAwIDAgMCAwLTQ2LjY0NTAyN3pNMTc0LjEwNTY5OCAyNDQuOTQzMjhjLTM5LjgxODkyNiAwLTcyLjI0MjkwOS0zMi4yNTMzMy03Mi4yNDI5MDktNzEuODQ0NzJzMzIuNDIzOTgzLTcxLjc4NzgzNSA3Mi4yNDI5MDktNzEuNzg3ODM1YzM5LjgxODkyNiAwIDcyLjE4NjAyNSAzMi4xOTY0NDYgNzIuMTg2MDI1IDcxLjc4NzgzNSAwIDM5LjU5MTM4OS0zMi40MjM5ODMgNzEuNzg3ODM1LTcyLjI0MjkwOSA3MS43ODc4MzZ6JyxcclxuICAgICAgICBERUxfU1ZHOiAnTTk4MC45OTIgMjU2aC04NC45OTJ2NjgzLjAwOGMwIDQ3LjEwNC0zNy44ODggODQuOTkyLTg0Ljk5MiA4NC45OTJIMjEyLjk5MmMtNDcuMTA0IDAtODQuOTkyLTM3Ljg4OC04NC45OTItODQuOTkyVjI1Nkg0My4wMDhDMTkuNDU2IDI1NiAwIDIzNi41NDQgMCAyMTIuOTkyYzAtMjMuNTUyIDE5LjQ1Ni00My4wMDggNDMuMDA4LTQzLjAwOEgyNTZWODQuOTkyQzI1NiAzNy44ODggMjkzLjg4OCAwIDM0MC45OTIgMGgzNDAuOTkyQzczMC4xMTIgMCA3NjggMzcuODg4IDc2OCA4NC45OTJ2ODQuOTkyaDIxNC4wMTZjMjMuNTUyIDAgNDMuMDA4IDE5LjQ1NiA0My4wMDggNDMuMDA4LTEuMDI0IDIzLjU1Mi0yMC40OCA0My4wMDgtNDQuMDMyIDQzLjAwOHpNNjgzLjAwOCA4NC45OTJIMzQwLjk5MnY4NC45OTJoMzQwLjk5MlY4NC45OTJ6TTIxMi45OTIgOTM5LjAwOGg1OTYuOTkyVjI1NkgyMTIuOTkydjY4My4wMDh6IG0xNzEuMDA4LTQ3MC4wMTZ2MjU2YzAgMjMuNTUyLTE5LjQ1NiA0My4wMDgtNDMuMDA4IDQzLjAwOC0yMy41NTIgMC00My4wMDgtMTkuNDU2LTQzLjAwOC00My4wMDh2LTI1NmMwLTIzLjU1MiAxOS40NTYtNDMuMDA4IDQzLjAwOC00My4wMDggMjMuNTUyIDEuMDI0IDQzLjAwOCAxOS40NTYgNDMuMDA4IDQzLjAwOHpNNTEyIDQyNy4wMDhjMjMuNTUyIDAgNDMuMDA4IDE5LjQ1NiA0My4wMDggNDMuMDA4djI1NmMwIDIzLjU1Mi0xOS40NTYgNDMuMDA4LTQzLjAwOCA0My4wMDgtMjMuNTUyIDAtNDMuMDA4LTE5LjQ1Ni00My4wMDgtNDMuMDA4di0yNTZjMC0yNC41NzYgMTkuNDU2LTQzLjAwOCA0My4wMDgtNDMuMDA4eiBtMTcxLjAwOCAwYzIzLjU1MiAwIDQzLjAwOCAxOS40NTYgNDMuMDA4IDQzLjAwOHYyNTZjMCAyMy41NTItMTkuNDU2IDQzLjAwOC00My4wMDggNDMuMDA4LTIzLjU1MiAwLTQzLjAwOC0xOS40NTYtNDMuMDA4LTQzLjAwOHYtMjU2YzAtMjQuNTc2IDE5LjQ1Ni00My4wMDggNDMuMDA4LTQzLjAwOHonLFxyXG4gICAgICAgIENPTU1FTlRfU1ZHOiAnTTIwOS45MiAxNTIuMDY0bDU3Mi40MTYgMS41MzZjMTIuOCAwIDIzLjA0IDEwLjI0IDIzLjA0IDIzLjA0djIzNy41NjhjMCAxMi44IDEwLjI0IDIzLjA0IDIzLjA0IDIzLjA0czIzLjA0LTEwLjI0IDIzLjA0LTIzLjA0VjEyNS40NGMwLTEyLjgtMTAuMjQtMjMuMDQtMjMuMDQtMjMuMDRIMTU4LjcyYy0xMi44IDAtMjMuMDQgMTAuMjQtMjMuMDQgMjMuMDR2NzczLjEyYzAgMTIuOCAxMC4yNCAyMy4wNCAyMy4wNCAyMy4wNGgyMzYuMDMyYzEyLjggMCAyMy4wNC0xMC4yNCAyMy4wNC0yMy4wNHMtMTAuMjQtMjIuNTI4LTIyLjUyOC0yMy4wNGwtMTg1Ljg1Ni0xLjUzNmMtMTIuOCAwLTIyLjUyOC0xMC4yNC0yMi41MjgtMjMuMDRWMTc0LjU5MmMwLTEyLjI4OCAxMC4yNC0yMi41MjggMjMuMDQtMjIuNTI4eiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTTI2OC44IDU3MC4zNjhoMTU5LjIzMmMxMy4zMTIgMCAyNC4wNjQgMTAuNzUyIDI0LjU3NiAyNC4wNjR2Mi41NmMwIDEzLjMxMi0xMC43NTIgMjQuNTc2LTI0LjU3NiAyNC41NzZIMjY4LjhjLTEzLjMxMiAwLTI0LjA2NC0xMC43NTItMjQuNTc2LTI0LjA2NHYtMi41NmMwLjUxMi0xMy4zMTIgMTEuMjY0LTI0LjU3NiAyNC41NzYtMjQuNTc2eiBtMC0zMTIuMzJoNDQxLjM0NGMxMy4zMTIgMCAyNC41NzYgMTAuNzUyIDI0LjU3NiAyNC41NzZ2Mi41NmMwIDEzLjMxMi0xMC43NTIgMjQuNTc2LTI0LjU3NiAyNC41NzZIMjY4LjhjLTEzLjMxMiAwLTI0LjU3Ni0xMC43NTItMjQuNTc2LTI0LjU3NnYtMi41NmMwLjUxMi0xMy4zMTIgMTEuMjY0LTI0LjU3NiAyNC41NzYtMjQuNTc2eiBtMC41MTIgMTU1LjY0OGgyNjkuMzEyYzEzLjMxMiAwIDI0LjU3NiAxMC43NTIgMjQuNTc2IDI0LjA2NHYyLjU2YzAgMTMuMzEyLTEwLjc1MiAyNC41NzYtMjQuNTc2IDI0LjU3NkgyNjkuMzEyYy0xMy4zMTIgMC0yNC41NzYtMTAuNzUyLTI0LjU3Ni0yNC4wNjR2LTIuNTZjMC0xMy44MjQgMTAuNzUyLTI0LjU3NiAyNC41NzYtMjQuNTc2eiBtNDcxLjA0IDEzLjMxMmwtMjQ2Ljc4NCAzMzkuNDU2Yy0xLjUzNiAyLjU2LTIuNTYgNS42MzItMi41NiA4LjcwNGwtMS41MzYgMTMyLjA5NmMwIDkuNzI4IDkuNzI4IDE2Ljg5NiAxOC45NDQgMTQuMzM2bDEyMi44OC0zNy44ODhjMy4wNzItMS4wMjQgNS42MzItMy4wNzIgNy42OC01LjYzMmwyNDYuNzg0LTMzOC45NDRjNC42MDgtNi4xNDQgMy41ODQtMTUuMzYtMi41Ni0xOS45NjhsLTEyMS4zNDQtOTQuNzJjLTcuMTY4LTUuNjMyLTE2Ljg5Ni00LjA5Ni0yMS41MDQgMi41NnogbTIzLjA0IDY3LjU4NGw1MS4yIDM5LjkzNmMyLjA0OCAxLjUzNiAyLjU2IDUuMTIgMS4wMjQgNy4xNjhsLTI2LjExMiAzNS44NGMtMS41MzYgMi41Ni01LjEyIDMuMDcyLTcuNjggMS4wMjRsLTUxLjcxMi0zOC45MTJjLTIuMDQ4LTEuNTM2LTIuNTYtNC42MDgtMS4wMjQtNy4xNjhsMjYuNjI0LTM3LjM3NmMyLjA0OC0xLjUzNiA1LjYzMi0yLjA0OCA3LjY4LTAuNTEyeiBtLTE2NS44ODggMzQxLjUwNGwtMzUuMzI4IDEwLjc1MmMtOS4yMTYgMy4wNzItMTguOTQ0LTQuMDk2LTE4Ljk0NC0xMy44MjRsMC41MTItNDAuOTZjMC0zLjA3MiAxLjAyNC02LjE0NCAyLjU2LTguNzA0bDEzNy4yMTYtMTg3LjkwNGMxLjUzNi0yLjU2IDUuMTItMi41NiA3LjE2OC0xLjAyNGw1MS4yIDM4LjRjMi41NiAyLjA0OCAzLjA3MiA1LjEyIDEuMDI0IDcuNjhsLTEzNy43MjggMTg5Ljk1MmMtMi4wNDggMi41Ni00LjYwOCA0LjYwOC03LjY4IDUuNjMyeicsXHJcbiAgICAgICAgQ0hBTkdFX0xJTkVfVFlQRV9TVkc6ICdNMTAwOCAzMzUuMiAxMDA4IDMzNS4ybC0xNjAgMTQ0IDAgMGMtOC44IDgtMjAgMTIuOC0zMiAxMi44LTI2LjQgMC00OC0yMS42LTQ4LTQ4IDAtMTQuNCA2LjQtMjYuNCAxNi0zNS4ybDAgMCA2Ny4yLTYwTDU2MCAzNDguOGMwIDAgMCAwIDAgMEw0NjQgMzQ4LjhsMCAwTDM1MiAzNDguOCA0OCAzNDguOGMtMjYuNCAwLTQ4LTIxLjYtNDgtNDggMC0yNi40IDIxLjYtNDggNDgtNDhsMTI0LjggMCAwIDBMNDE2IDI1Mi44bDAgMCAyMDggMCAwIDAgMjI3LjIgMEw3ODQgMTkybDAgMGMtOS42LTguOC0xNi0yMS42LTE2LTM1LjIgMC0yNi40IDIxLjYtNDggNDgtNDggMTIgMCAyMy4yIDQuOCAzMiAxMi44bDAgMCAxNjAgMTQ0IDAgMGM5LjYgOC44IDE2IDIxLjYgMTYgMzUuMkMxMDI0IDMxNC40IDEwMTcuNiAzMjYuNCAxMDA4IDMzNS4yek0xNiA2ODAuOCAxNiA2ODAuOGwxNjAtMTQ0IDAgMGM4LjgtOCAyMC0xMi44IDMyLTEyLjggMjYuNCAwIDQ4IDIxLjYgNDggNDggMCAxNC40LTYuNCAyNi40LTE2IDM1LjJsMCAwLTY3LjIgNjBMNDAwIDY2Ny4ybDAgMCAyMDggMCAwIDAgMjQzLjIgMCAwIDBMOTc2IDY2Ny4yYzI2LjQgMCA0OCAyMS42IDQ4IDQ4IDAgMjYuNC0yMS42IDQ4LTQ4IDQ4TDY3MiA3NjMuMiA1NjAgNzYzLjJjMCAwIDAgMCAwIDBMNDY0IDc2My4ybDAgMEwxNzIuOCA3NjMuMiAyNDAgODI0bDAgMGM5LjYgOC44IDE2IDIxLjYgMTYgMzUuMiAwIDI2LjQtMjEuNiA0OC00OCA0OC0xMiAwLTIzLjItNC44LTMyLTEyLjhsMCAwTDE2IDc1MmwwIDBjLTkuNi04LjgtMTYtMjEuNi0xNi0zNS4yQzAgNzAxLjYgNi40IDY4OS42IDE2IDY4MC44eidcclxuICAgIH1cclxuICAgIG1vZHVsZS5leHBvcnRzID0gSWNvbk9wZXJhdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvSWNvbk9wZXJhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIGZsb3fov57nur/nrqHnkIbnsbtcclxuICogQGF1dGhvciBtaWFvLmN1bnpoaVxyXG4gKi9cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvQ29ubmVjdGlvbk1hbmFnZXIuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbCcpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9Qb2ludC5qc1wiKTtcclxuICAgIHZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi4vdXRpbC9GbG93Q29uc3RhbnRzLmpzXCIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEZsb3dDb25uZWN0aW9uTWFuYWdlcihhcGkpIHtcclxuICAgICAgICBDb25uZWN0aW9uTWFuYWdlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYnVuZGxlT2Zmc2V0ID0gMzA7IC8v5aSa57q/5q6155qE5YGP56e7XHJcbiAgICAgICAgdGhpcy5idW5kbGVHYXAgPSAyMDsgLy8g5aSa57q/5q6155qE6Ze06ZqUXHJcbiAgICAgICAgdGhpcy5jb25uZWN0b3JNYXAgPSBVdGlsLlN0YWNrZWRNYXAuY3JlYXRlTmV3KCk7IC8v5a2Y5pS+5aSa57q/5q61XHJcbiAgICAgICAgdGhpcy5fYXBpID0gYXBpO1xyXG4gICAgfVxyXG5cclxuICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0b3JzLnB1c2goY29ubmVjdG9yKTtcclxuICAgICAgICAvLzEu5aSE55CG5LqL5Lu2XHJcbiAgICAgICAgdGhpcy5oYW5kbGVDb25uZWN0b3JFdmVudChjb25uZWN0b3IpO1xyXG4gICAgICAgIC8vMi7liKTmlq3mmK/lkKbkuKToioLngrnnm7jogZRcclxuICAgICAgICBpZihjb25uZWN0b3Iuc3RhcnROb2RlICYmIGNvbm5lY3Rvci5lbmROb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmdldFR3b05vZGVJZChjb25uZWN0b3Iuc3RhcnROb2RlLCBjb25uZWN0b3IuZW5kTm9kZSwgY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvck1hcC5hZGQoa2V5LCBjb25uZWN0b3IpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVDb25uZWN0b3JTaHJpbmsoY29ubmVjdG9yKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYnVuZGxlT2Zmc2V0ID0gY29ubmVjdG9yLm9wdGlvbnMuYnVuZGxlT2Zmc2V0IHx8IHRoaXMuYnVuZGxlT2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLmJ1bmRsZUdhcCA9IGNvbm5lY3Rvci5vcHRpb25zLmJ1bmRsZUdhcCB8fCB0aGlzLmJ1bmRsZUdhcDtcclxuICAgICAgICAgICAgLy8yLiDojrflj5bov5nkuKprZXnlr7nlupTnmoTnur/mrrXmlbDnu4RcclxuICAgICAgICAgICAgdmFyIGFyckNvbnMgPSB0aGlzLmNvbm5lY3Rvck1hcC5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGFyckNvbnMubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgICAgIC8v5Lik5Liq6IqC54K55Y+q5pyJ5LiA5Liq6L+e57q/55qE5oOF5Ya1XHJcbiAgICAgICAgICAgICAgICAvL+WIpOaWreS4gOS4iyBtb2RlbOmHjOacieayoeaciWRvY2tlcnPvvIzlpoLmnpzmnInliJnosIPnlKjmnoTpgKBwb2ludOaVsOe7hCAg5oiW6ICF6LCD55SocmVmcmVzaENvbm5lY3Rvcuiuoeeul+WmguS9leeUu+e6v1xyXG4gICAgICAgICAgICAgICAgdmFyIGRvY2tlcnMgPSBjb25uZWN0b3Iub3B0aW9ucy5kb2NrZXJzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvY2tlcnMgJiYgZG9ja2Vycy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IFBvaW50LmxvYWRBcnJheShkb2NrZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3IucmVmcmVzaChwb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24ucG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJTdGFydEVuZFBvaW50ID0gdGhpcy5nZXRTdGFydEVuZFBvaW50KGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uLnBvaW50cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnVuc2hpZnQoYXJyU3RhcnRFbmRQb2ludFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGFyclN0YXJ0RW5kUG9pbnRbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3IucmVmcmVzaChwb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbm5lY3RvcihhcnJDb25zWzBdLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyQ29ucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAvL+S4pOS4quiKgueCueacieWkmuS4qui/nue6v+eahOaDheWGtVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ucyhhcnJDb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8v5aSE55CG5rKh5pyJIOi1t+Wni+iKgueCueS4jue7iOatouiKgueCueaXtueahOi/nue6v1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNvbm5lY3RvclBvaW50cyhjb25uZWN0b3IpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLzMu6K6+572u5qih5Z6LXHJcbiAgICAgICAgdGhpcy5oYW5kbGVDb25uZWN0b3JNb2RlbChjb25uZWN0b3IpO1xyXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5oYW5kbGVDb25uZWN0b3JFdmVudCA9IGZ1bmN0aW9uKGNvbm5lY3Rvcikge1xyXG4gICAgICAgIGlmIChjb25uZWN0b3IuY29uUG9pbnRzR3JvdXApIHtcclxuICAgICAgICAgICAgY29ubmVjdG9yLmNvblBvaW50c0dyb3VwLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyclNwbGl0ID0gZS50YXJnZXQudHlwZS5zcGxpdChDb25uZWN0b3IuU0VQRVJBVE9SKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3IgPSBlLnRhcmdldC5jb25uZWN0b3I7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJyU3BsaXRbMF0gPT09IENvbm5lY3Rvci5TVEFSVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24uc3RhcnRQb3MgPSBhcnJTcGxpdFsxXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyU3BsaXRbMF0gPT09IENvbm5lY3Rvci5FTkRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uLmVuZFBvcyA9IGFyclNwbGl0WzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ubmVjdG9yKGNvbm5lY3RvciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcImNvblBvaW50c0dyb3VwOmNsaWNrXCI7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMubGluZU5vZGUgPSB0aGlzLnNlbENvbm5lY3RvcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnY2xpY2snLCAnZGJsY2xpY2snXTtcclxuICAgICAgICB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24oZXZlTmFtZSkge1xyXG4gICAgICAgICAgICBjb25uZWN0b3Iub24oXCJDb25uZWN0b3I6XCIgKyBldmVOYW1lLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBlLnRhcmdldDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbENvbm5lY3RvciAhPT0gc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbENvbm5lY3RvciAmJiB0aGlzLnJlZnJlc2hDb25uZWN0b3IodGhpcy5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsQ29ubmVjdG9yID0gc2VsZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBldmVOYW1lO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRoaXMuc2VsQ29ubmVjdG9yO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBpLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbiAgICBGbG93Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmhhbmRsZUNvbm5lY3Rvck1vZGVsID0gZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgY29ubmVjdG9yLm1vZGVsLnNldChDb25zdGFudHMuRUxFTUVOVF9UWVBFLCBDb25zdGFudHMuQ09OTkVDVElPTik7XHJcbiAgICAgICAgaWYoY29ubmVjdG9yLnN0YXJ0Tm9kZSAmJiBjb25uZWN0b3IuZW5kTm9kZSkge1xyXG4gICAgICAgICAgICBjb25uZWN0b3IubW9kZWwuc2V0KENvbnN0YW50cy5TVEFSVF9JRCwgY29ubmVjdG9yLnN0YXJ0Tm9kZS5pZCk7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5tb2RlbC5zZXQoQ29uc3RhbnRzLkVORF9JRCwgY29ubmVjdG9yLmVuZE5vZGUuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25uZWN0b3IubW9kZWwuc2V0KENvbnN0YW50cy5PUFRJT05TLCB6clV0aWwuY2xvbmUoY29ubmVjdG9yLm9wdGlvbnMpKTtcclxuICAgIH1cclxuXHJcbiAgICBGbG93Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmhhbmRsZUNvbm5lY3RvclNocmluayA9IGZ1bmN0aW9uKGNvbm5lY3Rvcikge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAvL+WPjOWHu+aUtue0p+S4uuS4gOadoee6v1xyXG4gICAgICAgIC8vIOe8qeeVpeWbvuWkmue6v+auteWPjOWHu+WQiOaIkOWNlee6v+autVxyXG4gICAgICAgIGNvbm5lY3Rvci5saW5lLm9uKFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmIChjb25uZWN0b3Iub3B0aW9ucy5pc1NocmluayA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb24gPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IGNvbi5zdGFydE5vZGU7XHJcbiAgICAgICAgICAgIHZhciBlbmROb2RlID0gY29uLmVuZE5vZGU7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHpyVXRpbC5jbG9uZShjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXRTaWduO1xyXG4gICAgICAgICAgICBpZiAocG9zaXRpb24uc3RhcnRQb3MuaW5kZXhPZignLScpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldFNpZ24gPSAnLSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uLnN0YXJ0UG9zLmluZGV4T2YoJysnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRTaWduID0gJysnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0UG9zID0gcG9zaXRpb24uc3RhcnRQb3Muc3BsaXQob2Zmc2V0U2lnbilbMF07XHJcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbi5lbmRQb3MuaW5kZXhPZignLScpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldFNpZ24gPSAnLSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uLmVuZFBvcy5pbmRleE9mKCcrJykgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0U2lnbiA9ICcrJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb3NpdGlvbi5lbmRQb3MgPSBwb3NpdGlvbi5lbmRQb3Muc3BsaXQob2Zmc2V0U2lnbilbMF07XHJcbiAgICAgICAgICAgIC8vMS7ojrflj5bmiYDmnInnmoTnur/mrrVcclxuICAgICAgICAgICAgdmFyIGtleSA9IHRoYXQuZ2V0VHdvTm9kZUlkKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2YXIgY29ucyA9IHRoYXQuY29ubmVjdG9yTWFwLmdldHNpbWlsYXIoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGNvbnMubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vMi7liKTmlq3nur/mmK/lkKblpITkuo7pmpDol4/nirbmgIFcclxuICAgICAgICAgICAgLy8yLuWwhumZpOS4remXtOeahOS4gOadoee6v+i/m+ihjOmakOiXj1xyXG4gICAgICAgICAgICB2YXIgaGFsZiA9IHBhcnNlSW50KGNvbnMubGVuZ3RoIC8gMik7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gKGhhbGYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNbaV0uaWdub3JlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNbaV0uc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNbaV0uaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy/lpITnkIbmsqHmnIkg6LW35aeL6IqC54K55LiO57uI5q2i6IqC54K55pe255qE6L+e57q/XHJcbiAgICBGbG93Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmhhbmRsZUNvbm5lY3RvclBvaW50cyA9IGZ1bmN0aW9uKGNvbm5lY3Rvcikge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gY29ubmVjdG9yLm9wdGlvbnM7XHJcbiAgICAgICAgdmFyIGRvY2tlcnMgPSBjb25uZWN0b3Iub3B0aW9ucy5kb2NrZXJzO1xyXG4gICAgICAgIGlmIChkb2NrZXJzICYmIGRvY2tlcnMubGVuZ3RoID49IDIpIHtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFBvaW50LmxvYWRBcnJheShkb2NrZXJzKTtcclxuICAgICAgICAgICAgY29ubmVjdG9yLnJlZnJlc2gocG9pbnRzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiAmJiBvcHRpb25zLnBvc2l0aW9uLnBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9Qb2ludHMgPSBvcHRpb25zLnBvc2l0aW9uLnBvaW50cztcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5yZWZyZXNoKG9Qb2ludHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VHdvTm9kZUlkID0gZnVuY3Rpb24oc3RhcnROb2RlLCBlbmROb2RlLCBwb3MpIHtcclxuICAgICAgICByZXR1cm4gc3RhcnROb2RlLmlkICsgJy0nICsgcG9zLnN0YXJ0UG9zICsgXCIsXCIgKyBlbmROb2RlLmlkICsgJy0nICsgcG9zLmVuZFBvcztcclxuICAgIH1cclxuICAgIC8v5aSE55CG5aSa5p2h57q/5q61XHJcbiAgICBGbG93Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlZnJlc2hDb25zID0gZnVuY3Rpb24oYXJyQ29ucykge1xyXG4gICAgICAgIC8v5aaC5p6c5piv5oqY57q/55qE6K+dXHJcbiAgICAgICAgaWYgKGFyckNvbnNbMF0ub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9KQUdHRUQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJDb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25uZWN0b3IoYXJyQ29uc1tpXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25zU3RyYWlnaHQoYXJyQ29ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8v5aSE55CG5aSa5p2h57q/5q61KOebtOe6vylcclxuICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVmcmVzaENvbnNTdHJhaWdodCA9IGZ1bmN0aW9uKGFyckNvbnMpIHtcclxuICAgICAgICB2YXIgaGFsZiA9IHBhcnNlSW50KGFyckNvbnMubGVuZ3RoIC8gMik7XHJcbiAgICAgICAgdmFyIGFyckNvbm5lY3RSZXN1bHQgPSBbXVxyXG5cclxuICAgICAgICB2YXIgc3RhcnROb2RlID0gYXJyQ29uc1swXS5zdGFydE5vZGU7XHJcbiAgICAgICAgdmFyIGVuZE5vZGUgPSBhcnJDb25zWzBdLmVuZE5vZGU7XHJcbiAgICAgICAgLy8g5L+u5aSN6IqC54K55Zyo57uE5YaF5YyF5Zu055uS6ZyA5Yqg5LiK57uE55qEcG9zaXRpb25cclxuICAgICAgICB2YXIgc1JlY3QgPSBVdGlsLmdldFJlY3Qoc3RhcnROb2RlLCB0cnVlKTtcclxuICAgICAgICB2YXIgZVJlY3QgPSBVdGlsLmdldFJlY3QoZW5kTm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIHNDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKHNSZWN0LCBzdGFydE5vZGUpO1xyXG4gICAgICAgIHZhciBlQ29ubmVjdG9yUG9pbnQgPSBVdGlsLmdldENvbm5lY3RvclBvaW50cyhlUmVjdCwgZW5kTm9kZSk7XHJcbiAgICAgICAgLy/liKTmlq3lpoLmnpzmsqHmnInmjIflrprkvY3nva7nmoTor50sIOWIpOaWreW8gOWni+iKgueCueWcqOe7k+adn+e7k+aenOW3pui+ueWImemHh+eUqCByaWdodC1sZWZ0IOWQpuWImemHh+eUqGxlZnQtcmlnaHRcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBhcnJDb25zWzBdLm9wdGlvbnMucG9zaXRpb247XHJcbiAgICAgICAgaWYgKCFwb3NpdGlvbi5zdGFydFBvcyB8fCAhcG9zaXRpb24uZW5kUG9zKSB7XHJcbiAgICAgICAgICAgIGlmIChzUmVjdC54IDwgZVJlY3QueCkge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc3RhcnRQb3MgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5lbmRQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0UG9zID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5lbmRQb3MgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzdGFydFBvaW50ID0gc0Nvbm5lY3RvclBvaW50W3Bvc2l0aW9uLnN0YXJ0UG9zXTtcclxuICAgICAgICB2YXIgZW5kUG9pbnQgPSBlQ29ubmVjdG9yUG9pbnRbcG9zaXRpb24uZW5kUG9zXTtcclxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGVuZFBvaW50LnkgLSBzdGFydFBvaW50LnksIGVuZFBvaW50LnggLSBzdGFydFBvaW50LngpO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gaGFsZjsgaSA+PSAxOyBpLS0pIHtcclxuICAgICAgICAgICAgcG9pbnRzID0gW107IC8vdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaChzdGFydFBvaW50KTsgLy9cclxuICAgICAgICAgICAgLy8gcG9pbnRzLnB1c2gobmV3IFBvaW50KHN0YXJ0UG9pbnQueCArIGJ1bmRsZU9mZnNldCAsIHN0YXJ0UG9pbnQueSArIGkgKiBidW5kbGVHYXApKTtcclxuICAgICAgICAgICAgLy8gcG9pbnRzLnB1c2gobmV3IFBvaW50KGVuZFBvaW50LnggLSBidW5kbGVPZmZzZXQgLCBzdGFydFBvaW50LnkgKyBpICogYnVuZGxlR2FwKSk7IC8vc3RhcnRQb2ludC54ICsgYnVuZGxlT2Zmc2V0XHJcbiAgICAgICAgICAgIHZhciBzZWNvbmRQb2ludCA9IHN0YXJ0UG9pbnQuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vc2Vjb25kUG9pbnQueCA9ICBzZWNvbmRQb2ludC54ICsgdGhpcy5idW5kbGVPZmZzZXQ7XHJcbiAgICAgICAgICAgIHNlY29uZFBvaW50LnRyYW5zZm9ybShVdGlsLnRyYW5zbGF0aW9uTWF0cml4KDAsIHRoaXMuYnVuZGxlR2FwICogaSkpO1xyXG4gICAgICAgICAgICAvL3NlY29uZFBvaW50ID0gdGhpcy5ib3VuZE9mZnNldFhZKHNlY29uZFBvaW50LCB0cnVlKTtcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy/nm7Top5LlnZDmoIcgeCwg5ZKMIHksIOiuoeeul+WHuuaegeWdkOagh1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8v5LuO5p6B5Z2Q5qCH6K6h566X5Ye655u06KeS5Z2Q5qCHXHJcbiAgICAgICAgICAgIHNlY29uZFBvaW50LnggPSBzZWNvbmRQb2ludC54ICsgdGhpcy5idW5kbGVPZmZzZXQgKiBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgICAgIHNlY29uZFBvaW50LnkgPSBzZWNvbmRQb2ludC55ICsgdGhpcy5idW5kbGVPZmZzZXQgKiBNYXRoLnNpbihhbmdsZSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vc2Vjb25kUG9pbnQudHJhbnNmb3JtKFV0aWwuc2NhbGVNYXRyaXgoMC41KSk7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHNlY29uZFBvaW50KTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0aGlyZFBvaW50ID0gZW5kUG9pbnQuY2xvbmUoKTtcclxuICAgICAgICAgICAgLy90aGlyZFBvaW50LnggPSAgdGhpcmRQb2ludC54IC0gdGhpcy5idW5kbGVPZmZzZXQ7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIHRoaXJkUG9pbnQudHJhbnNmb3JtKFV0aWwudHJhbnNsYXRpb25NYXRyaXgoMCwgdGhpcy5idW5kbGVHYXAgKiBpKSk7XHJcbiAgICAgICAgICAgIC8vdGhpcmRQb2ludCA9IHRoaXMuYm91bmRPZmZzZXRYWSh0aGlyZFBvaW50LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIC8vc2Vjb25kUG9pbnQudHJhbnNmb3JtKFV0aWwuc2NhbGVNYXRyaXgoMC41KSk7XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8v55u06KeS5Z2Q5qCHIHgsIOWSjCB5LCDorqHnrpflh7rmnoHlnZDmoIdcclxuXHJcbiAgICAgICAgICAgIC8v5LuO5p6B5Z2Q5qCH6K6h566X5Ye655u06KeS5Z2Q5qCHXHJcbiAgICAgICAgICAgIHRoaXJkUG9pbnQueCA9IHRoaXJkUG9pbnQueCAtIHRoaXMuYnVuZGxlT2Zmc2V0ICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgICAgICB0aGlyZFBvaW50LnkgPSB0aGlyZFBvaW50LnkgLSB0aGlzLmJ1bmRsZU9mZnNldCAqIE1hdGguc2luKGFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHRoaXJkUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goZW5kUG9pbnQpO1xyXG4gICAgICAgICAgICBhcnJDb25uZWN0UmVzdWx0LnB1c2gocG9pbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFyckNvbm5lY3RSZXN1bHQucHVzaChbc3RhcnRQb2ludCwgZW5kUG9pbnRdKTtcclxuXHJcbiAgICAgICAgdmFyIHVwSGFsZiA9IE1hdGguY2VpbChhcnJDb25zLmxlbmd0aCAvIDIpO1xyXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCB1cEhhbGY7IGkrKykge1xyXG4gICAgICAgICAgICBwb2ludHMgPSBbXTsgLy92YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHN0YXJ0UG9pbnQpO1xyXG4gICAgICAgICAgICB2YXIgc2VjUG9pbnQgPSBzdGFydFBvaW50LmNsb25lKCk7XHJcbiAgICAgICAgICAgIC8vc2VjUG9pbnQueCA9ICBzZWNQb2ludC54ICsgdGhpcy5idW5kbGVPZmZzZXQ7XHJcbiAgICAgICAgICAgIHNlY1BvaW50LnRyYW5zZm9ybShVdGlsLnRyYW5zbGF0aW9uTWF0cml4KDAsIC10aGlzLmJ1bmRsZUdhcCAqIGkpKTtcclxuICAgICAgICAgICAgc2VjUG9pbnQueCA9IHNlY1BvaW50LnggKyB0aGlzLmJ1bmRsZU9mZnNldCAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICAgICAgc2VjUG9pbnQueSA9IHNlY1BvaW50LnkgKyB0aGlzLmJ1bmRsZU9mZnNldCAqIE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goc2VjUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRoZFBvaW50ID0gZW5kUG9pbnQuY2xvbmUoKTtcclxuICAgICAgICAgICAgLy90aGRQb2ludC54ID0gIHRoZFBvaW50LnggLSB0aGlzLmJ1bmRsZU9mZnNldDtcclxuICAgICAgICAgICAgdGhkUG9pbnQudHJhbnNmb3JtKFV0aWwudHJhbnNsYXRpb25NYXRyaXgoMCwgLXRoaXMuYnVuZGxlR2FwICogaSkpO1xyXG4gICAgICAgICAgICAvL+S7juaegeWdkOagh+iuoeeul+WHuuebtOinkuWdkOagh1xyXG4gICAgICAgICAgICB0aGRQb2ludC54ID0gdGhkUG9pbnQueCAtIHRoaXMuYnVuZGxlT2Zmc2V0ICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgICAgICB0aGRQb2ludC55ID0gdGhkUG9pbnQueSAtIHRoaXMuYnVuZGxlT2Zmc2V0ICogTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgICAgICAvL3NlY29uZFBvaW50LnRyYW5zZm9ybShVdGlsLnNjYWxlTWF0cml4KDAuNSkpO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh0aGRQb2ludCk7XHJcblxyXG4gICAgICAgICAgICBwb2ludHMucHVzaChlbmRQb2ludCk7XHJcbiAgICAgICAgICAgIGFyckNvbm5lY3RSZXN1bHQucHVzaChwb2ludHMpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnJDb25uZWN0UmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFyckNvbnNbaV0ucmVmcmVzaChhcnJDb25uZWN0UmVzdWx0W2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYm91bmRPZmZzZXRYWSA9IGZ1bmN0aW9uKHBvaW50LCBpc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdFBvaW50ID0gcG9pbnQuY2xvbmUoKTtcclxuICAgICAgICAvL+ebtOinkuWdkOaghyB4LCDlkowgeSwg6K6h566X5Ye65p6B5Z2Q5qCHXHJcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihyZXN1bHRQb2ludC55LCByZXN1bHRQb2ludC54KTtcclxuICAgICAgICB2YXIgciA9IE1hdGguc3FydChNYXRoLnBvdyhyZXN1bHRQb2ludC54LCAyKSArIE1hdGgucG93KHJlc3VsdFBvaW50LnksIDIpKTtcclxuICAgICAgICBpZiAoaXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICByID0gciArIHRoaXMuYnVuZGxlT2Zmc2V0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHIgPSByIC0gdGhpcy5idW5kbGVPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy/ku47mnoHlnZDmoIforqHnrpflh7rnm7Top5LlnZDmoIdcclxuICAgICAgICByZXN1bHRQb2ludC54ID0gciAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICByZXN1bHRQb2ludC55ID0gciAqIE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0UG9pbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7nur/mrrXnmoTmqKHlnovmlbDmja4gICjnsbvlnosg5paH5a2XKVxyXG4gICAgICogQHBhcmFtIHtbdHlwZV19IGNvbm5lY3RvciBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0ge1t0eXBlXX0gb3B0aW9uICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRNb2RlbCA9IGZ1bmN0aW9uKGNvbm5lY3Rvciwgb3B0aW9uKSB7XHJcbiAgICAgICAgdmFyIG9yaWdpbkxpbmVUeXBlID0gY29ubmVjdG9yLm1vZGVsLmdldChcInN0eWxlLmxpbmVUeXBlXCIpO1xyXG4gICAgICAgIGNvbm5lY3Rvci5tb2RlbC5tZXJnZU9wdGlvbihvcHRpb24pO1xyXG4gICAgICAgIHpyVXRpbC5tZXJnZShjb25uZWN0b3IubW9kZWwuZ2V0KFwib3B0aW9uc1wiKSwgb3B0aW9uLCB0cnVlKTtcclxuICAgICAgICBpZiAob3JpZ2luTGluZVR5cGUgIT09IG9wdGlvbi5zdHlsZS5saW5lVHlwZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25uZWN0b3IoY29ubmVjdG9yLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKDpmaTmjIflrprnmoTnur9cclxuICAgICAqIEBwYXJhbSBjb25uZWN0b3Ig5qyy5Yig6Zmk55qE6L+e57q/XHJcbiAgICAgKiBAcGFyYW0gX3pyIHpyXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVCeUxpbmUgPSBmdW5jdGlvbiAoY29ubmVjdG9yLF96cikge1xyXG4gICAgICAgIC8vMS7lsIbnur8g5omA6IGU55qEc3RhcnROb2Rl55qEb3V0Z29pbmfmlbDmja7liKDpmaRcclxuICAgICAgICBpZihjb25uZWN0b3Iuc3RhcnROb2RlKXtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZU91dGdvaW5nID0gY29ubmVjdG9yLnN0YXJ0Tm9kZS5tb2RlbC5nZXQoXCJvdXRnb2luZ1wiKTtcclxuICAgICAgICAgICAgaW5kZXggPSB6clV0aWwuaW5kZXhPZihzdGFydE5vZGVPdXRnb2luZywgY29ubmVjdG9yLnJlc291cmNlSWQpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZU91dGdvaW5nLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rvck1hcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0VHdvTm9kZUlkKGNvbm5lY3Rvci5zdGFydE5vZGUsIGNvbm5lY3Rvci5lbmROb2RlLCBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvck1hcC5yZW1vdmVJdGVtKGtleSwgY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vMi7ku45fenLkuIrliKDpmaRcclxuICAgICAgICBfenIucmVtb3ZlKGNvbm5lY3Rvcik7XHJcblxyXG5cclxuICAgICAgICAvLzMu5LuO57q/5pWw5o2u5Lit5Yig6ZmkXHJcbiAgICAgICAgdmFyIGluZGV4ID0genJVdGlsLmluZGV4T2YodGhpcy5jb25uZWN0b3JzLCBjb25uZWN0b3IpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsQ29ubmVjdG9yID09PSBjb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxDb25uZWN0b3IgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5Yi35paw6L+e5o6l57q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZWZyZXNoTGluZUJ5Tm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAvLyDliKTmlq3ov5nkuKroioLngrnmmK/lkKbmnInlpJrmnaHnur/mrrVcclxuICAgICAgICB2YXIga2V5cyA9IHRoaXMuY29ubmVjdG9yTWFwLmtleXMoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihub2RlLmlkKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyckNvbnMgPSB0aGlzLmNvbm5lY3Rvck1hcC5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnRMaW5lUG9zKGFyckNvbnMpXHJcbiAgICAgICAgICAgICAgICBpZiAoYXJyQ29ucy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8v5Lik5Liq6IqC54K55Y+q5pyJ5LiA5Liq6L+e57q/55qE5oOF5Ya1XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ubmVjdG9yKGFyckNvbnNbMF0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcnJDb25zLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL+S4pOS4quiKgueCueacieWkmuS4qui/nue6v+eahOaDheWGtVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbnMoYXJyQ29ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliLfmlrDov57mjqXnur9cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbm9kZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBGbG93Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnRvZ2dsZUxpbmVCeU5vZGUgPSBmdW5jdGlvbihub2RlLCBpc1Nob3cpIHtcclxuICAgICAgICAvLyDliKTmlq3ov5nkuKroioLngrnmmK/lkKbmnInlpJrmnaHnur/mrrVcclxuICAgICAgICB2YXIga2V5cyA9IHRoaXMuY29ubmVjdG9yTWFwLmtleXMoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihub2RlLmlkKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyckNvbnMgPSB0aGlzLmNvbm5lY3Rvck1hcC5nZXQoa2V5KTtcclxuXHJcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChhcnJDb25zLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNTaG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOmHjeaWsOiwg+aVtOe6v+eahOS9jee9rlxyXG4gICAgICovXHJcbiAgICBGbG93Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvdW50TGluZVBvcyA9IGZ1bmN0aW9uKGFyckNvbnMpIHtcclxuICAgICAgICB6clV0aWwuZWFjaChhcnJDb25zLCBmdW5jdGlvbihjb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBjb25uZWN0b3Iub3B0aW9ucztcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0NoYW5nZVBvc2l0aW9uID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzUmVjdCA9IFV0aWwuZ2V0UmVjdChjb25uZWN0b3Iuc3RhcnROb2RlKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgZVJlY3QgPSBVdGlsLmdldFJlY3QoY29ubmVjdG9yLmVuZE5vZGUpLmJvdW5kaW5nUmVjdDtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydFBvcyA9IG9wdGlvbnMucG9zaXRpb24uc3RhcnRQb3M7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kUG9zID0gb3B0aW9ucy5wb3NpdGlvbi5lbmRQb3M7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRQb3NOb3cgPSB0aGlzLnBvc0lzQ2hhbmdlKHN0YXJ0UG9zLCBzUmVjdCwgZVJlY3QsIFwic3RhcnROb2RlXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZFBvc05vdyA9IHRoaXMucG9zSXNDaGFuZ2UoZW5kUG9zLCBzUmVjdCwgZVJlY3QsIFwiZW5kTm9kZVwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydFBvcyAhPSBzdGFydFBvc05vdyB8fCBlbmRQb3MgIT0gZW5kUG9zTm93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbi5zdGFydFBvcyA9IHN0YXJ0UG9zTm93O1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24uZW5kUG9zID0gZW5kUG9zTm93O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSx0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBGbG93Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnBvc0lzQ2hhbmdlID0gZnVuY3Rpb24ocG9zLCBzUmVjdCwgZVJlY3QsIG5vZGVUeXBlKSB7XHJcbiAgICAgICAgdmFyIG5ld1Bvc1xyXG4gICAgICAgIGlmIChwb3MuaW5kZXhPZihcInRvcFwiKSAhPSAtMSB8fCBwb3MuaW5kZXhPZihcImJvdHRvbVwiKSAhPSAtMSkge1xyXG4gICAgICAgICAgICBpZiAoc1JlY3QueSArIHNSZWN0LmhlaWdodCA8IGVSZWN0LnkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PSBcInN0YXJ0Tm9kZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zLnJlcGxhY2UoLyh0b3B8Ym90dG9tKS9nLCBcImJvdHRvbVwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zLnJlcGxhY2UoLyh0b3B8Ym90dG9tKS9nLCBcInRvcFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlUmVjdC55ICsgZVJlY3QuaGVpZ2h0IDwgc1JlY3QueSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09IFwiZW5kTm9kZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zLnJlcGxhY2UoLyh0b3B8Ym90dG9tKS9nLCBcImJvdHRvbVwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zLnJlcGxhY2UoLyh0b3B8Ym90dG9tKS9nLCBcInRvcFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzUmVjdC54ICsgc1JlY3Qud2lkdGggPCBlUmVjdC54KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT0gXCJzdGFydE5vZGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8odG9wfGJvdHRvbSkvZywgXCJyaWdodFwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zLnJlcGxhY2UoLyh0b3B8Ym90dG9tKS9nLCBcImxlZnRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZVJlY3QueCArIGVSZWN0LndpZHRoIDwgc1JlY3QueCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09IFwiZW5kTm9kZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zLnJlcGxhY2UoLyh0b3B8Ym90dG9tKS9nLCBcInJpZ2h0XCIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQb3MgPSBwb3MucmVwbGFjZSgvKHRvcHxib3R0b20pL2csIFwibGVmdFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChwb3MuaW5kZXhPZihcImxlZnRcIikgIT0gLTEgfHwgcG9zLmluZGV4T2YoXCJyaWdodFwiKSAhPSAtMSkge1xyXG4gICAgICAgICAgICBpZiAoc1JlY3QueCArIHNSZWN0LndpZHRoIDwgZVJlY3QueCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09IFwic3RhcnROb2RlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQb3MgPSBwb3MucmVwbGFjZSgvKHJpZ2h0fGxlZnQpL2csIFwicmlnaHRcIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8ocmlnaHR8bGVmdCkvZywgXCJsZWZ0XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVSZWN0LnggKyBlUmVjdC53aWR0aCA8IHNSZWN0LngpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PSBcImVuZE5vZGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8ocmlnaHR8bGVmdCkvZywgXCJyaWdodFwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zLnJlcGxhY2UoLyhyaWdodHxsZWZ0KS9nLCBcImxlZnRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc1JlY3QueSArIHNSZWN0LmhlaWdodCA8IGVSZWN0LnkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PSBcInN0YXJ0Tm9kZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zLnJlcGxhY2UoLyhyaWdodHxsZWZ0KS9nLCBcImJvdHRvbVwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zLnJlcGxhY2UoLyhyaWdodHxsZWZ0KS9nLCBcInRvcFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlUmVjdC55ICsgZVJlY3QuaGVpZ2h0IDwgc1JlY3QueSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09IFwiZW5kTm9kZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zLnJlcGxhY2UoLyhyaWdodHxsZWZ0KS9nLCBcImJvdHRvbVwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zLnJlcGxhY2UoLyhyaWdodHxsZWZ0KS9nLCBcInRvcFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1BvcyA9IHBvcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1BvcztcclxuICAgIH1cclxuXHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKEZsb3dDb25uZWN0aW9uTWFuYWdlciwgQ29ubmVjdGlvbk1hbmFnZXIpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBGbG93Q29ubmVjdGlvbk1hbmFnZXI7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbWFuYWdlci9GbG93Q29ubmVjdGlvbk1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDov57nur/nrqHnkIbnsbtcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcclxuICAgIHZhciBQb2ludCA9IHJlcXVpcmUoXCIuLi9Qb2ludC5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgIHZhciBMb2cgPSByZXF1aXJlKFwiLi4vTG9nLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25NYW5hZ2VyKCkge1xyXG4gICAgICAgIHRoaXMuY29ubmVjdG9ycyA9IFtdOyAvL+W9k+WJjeeUu+W4g+aJgOacieeahOe6v+autVxyXG4gICAgICAgIHRoaXMuc2VsQ29ubmVjdG9yID0gbnVsbDsgLy/lvZPliY3pgInkuK3nmoTnur/mrrVcclxuICAgICAgICB0aGlzLnRlbXBDb25uZWN0b3IgPSBudWxsOyAvL+S4tOaXtue6v+autVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u57q/55qE5LiN5Y+v57yW6L6RXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGZvcmJpZEVkaXQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3RvckZvcmJpZEVkaXQgPSBmdW5jdGlvbiAoZm9yYmlkRWRpdCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25uZWN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yc1tpXS5vcHRpb25zLmlzRWRpdCA9ICFmb3JiaWRFZGl0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm9yYmlkRWRpdCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNvbm5lY3RvckV2ZW50TGlzdGVuZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vpmaTnur/mnaHnm5HlkKzkuovku7ZcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUNvbm5lY3RvckV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9ycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGNvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLnBvbHlMaW5lLm9mZignbW91c2VvdmVyJyk7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IucG9seUxpbmUub2ZmKCdtb3VzZW1vdmUnKTtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5wb2x5TGluZS5vZmYoJ21vdXNlb3V0Jyk7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IuY3VydmVMaW5lLm9mZignbW91c2VvdmVyJyk7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IuY3VydmVMaW5lLm9mZignbW91c2Vtb3ZlJyk7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IuY3VydmVMaW5lLm9mZignbW91c2VvdXQnKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOa4heepuui/nuaOpee6v+S4iueahOiwg+aVtOS9jee9ruaMiemSrlxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhclNlbGVjdENvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxDb25uZWN0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25uZWN0b3IodGhpcy5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5Yig6Zmk5ZKM6IqC54K555u45YWz6IGU55qE6L+e5o6l57q/XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZVNlbGVjdENvbiA9IGZ1bmN0aW9uIChub2RlLCBfenIpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29ubmVjdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0b3JzW2ldLnN0YXJ0Tm9kZSA9PSBub2RlIHx8IHRoaXMuY29ubmVjdG9yc1tpXS5lbmROb2RlID09IG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIC8vMS7lsIbnur8g5omA6IGU55qEc3RhcnROb2Rl55qEb3V0Z29pbmfmlbDmja7liKDpmaRcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydE5vZGVPdXRnb2luZyA9IHRoaXMuY29ubmVjdG9yc1tpXS5zdGFydE5vZGUubW9kZWwuZ2V0KFwib3V0Z29pbmdcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB6clV0aWwuaW5kZXhPZihzdGFydE5vZGVPdXRnb2luZywgdGhpcy5jb25uZWN0b3JzW2ldLnJlc291cmNlSWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnROb2RlT3V0Z29pbmcuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vMi7ku45fenLkuIrliKDpmaRcclxuICAgICAgICAgICAgICAgIF96ci5yZW1vdmUodGhpcy5jb25uZWN0b3JzW2ldKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9ycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbENvbm5lY3RvciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlTGluZSA9IGZ1bmN0aW9uIChsaW5lLCB6cikge1xyXG4gICAgICAgIHRoaXMuc2VsQ29ubmVjdG9yID0gbGluZTtcclxuICAgICAgICB0aGlzLmRlbGV0ZUxpbmUoenIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDliKDpmaTpgInlrprnmoTnur9cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlTGluZSA9IGZ1bmN0aW9uIChfenIpIHtcclxuICAgICAgICAvLzEu5bCG57q/IOaJgOiBlOeahHN0YXJ0Tm9kZeeahG91dGdvaW5n5pWw5o2u5Yig6ZmkXHJcbiAgICAgICAgaWYodGhpcy5zZWxDb25uZWN0b3Iuc3RhcnROb2RlKXtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZU91dGdvaW5nID0gdGhpcy5zZWxDb25uZWN0b3Iuc3RhcnROb2RlLm1vZGVsLmdldChcIm91dGdvaW5nXCIpO1xyXG4gICAgICAgICAgICBpbmRleCA9IHpyVXRpbC5pbmRleE9mKHN0YXJ0Tm9kZU91dGdvaW5nLCB0aGlzLnNlbENvbm5lY3Rvci5yZXNvdXJjZUlkKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE5vZGVPdXRnb2luZy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0b3JNYXApIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmdldFR3b05vZGVJZCh0aGlzLnNlbENvbm5lY3Rvci5zdGFydE5vZGUsIHRoaXMuc2VsQ29ubmVjdG9yLmVuZE5vZGUsIHRoaXMuc2VsQ29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JNYXAucmVtb3ZlSXRlbShrZXksIHRoaXMuc2VsQ29ubmVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vMi7ku45fenLkuIrliKDpmaRcclxuICAgICAgICBfenIucmVtb3ZlKHRoaXMuc2VsQ29ubmVjdG9yKTtcclxuXHJcblxyXG4gICAgICAgIC8vMy7ku47nur/mlbDmja7kuK3liKDpmaRcclxuICAgICAgICB2YXIgaW5kZXggPSB6clV0aWwuaW5kZXhPZih0aGlzLmNvbm5lY3RvcnMsIHRoaXMuc2VsQ29ubmVjdG9yKTtcclxuICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsQ29ubmVjdG9yID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmHjeaWsOeUu+e6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBjb25uZWN0b3IgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBmb3JjZVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVmcmVzaENvbm5lY3RvciA9IGZ1bmN0aW9uIChjb25uZWN0b3IsIGZvcmNlKSB7XHJcbiAgICAgICAgLy8g5Y+q5pyJ6ZyA6KaB5by65Yi25Yi35pawICDmiJbogIUg6L+e57q/5Li656m677yIPDIp5pe2IOaJjei/m+ihjOmHjeaWsOiuoeeul+mHjee7mFxyXG4gICAgICAgIGlmIChmb3JjZSB8fCAoIWNvbm5lY3Rvci50dXJuaW5nUG9pbnRzKSB8fCAoY29ubmVjdG9yLnR1cm5pbmdQb2ludHMubGVuZ3RoIDwgMikpIHtcclxuICAgICAgICAgICAgaWYgKGNvbm5lY3Rvci5tb2RlbCAmJiBjb25uZWN0b3IubW9kZWwuZ2V0KFwic3R5bGUubGluZVR5cGVcIikpIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID0gY29ubmVjdG9yLm1vZGVsLmdldChcInN0eWxlLmxpbmVUeXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhcnJTdGFydEVuZFBvaW50ID0gdGhpcy5nZXRTdGFydEVuZFBvaW50KGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgIHZhciBlc2NhcGVEaXN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbiAmJiBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbi5lc2NhcGVEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgZXNjYXBlRGlzdGFuY2UgPSBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbi5lc2NhcGVEaXN0YW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc29sdXRpb25zID0gdGhpcy5jb25uZWN0b3IyUG9pbnRzKGNvbm5lY3Rvci5vcHRpb25zLnN0eWxlLmxpbmVUeXBlLCBhcnJTdGFydEVuZFBvaW50WzBdLFxyXG4gICAgICAgICAgICAgICAgYXJyU3RhcnRFbmRQb2ludFsxXSxcclxuICAgICAgICAgICAgICAgIGFyclN0YXJ0RW5kUG9pbnRbMl0sIGFyclN0YXJ0RW5kUG9pbnRbM10sIGVzY2FwZURpc3RhbmNlKTsgLy8gVFlQRV9TVFJBSUdIVCBUWVBFX0pBR0dFRFxyXG5cclxuICAgICAgICAgICAgY29ubmVjdG9yLnJlZnJlc2goc29sdXRpb25zWzBdWzJdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbm5lY3Rvci5jbGVhckhhbmRsZXMoKTsgLy/muIXnqbpoYW5kbGVcclxuICAgIH1cclxuXHJcblxyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFN0YXJ0RW5kUG9pbnQgPSBmdW5jdGlvbiAoY29ubmVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IGNvbm5lY3Rvci5zdGFydE5vZGU7XHJcbiAgICAgICAgdmFyIGVuZE5vZGUgPSBjb25uZWN0b3IuZW5kTm9kZTtcclxuICAgICAgICB2YXIgaXNOb3RJblNhbWVHcm91cCA9IHRydWU7XHJcbiAgICAgICAgaXNOb3RJblNhbWVHcm91cCA9IHN0YXJ0Tm9kZS5wYXJlbnQgIT09IGVuZE5vZGUucGFyZW50O1xyXG5cclxuICAgICAgICB2YXIgc1JlY3QgPSBVdGlsLmdldFJlY3Qoc3RhcnROb2RlLCBpc05vdEluU2FtZUdyb3VwKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgdmFyIHNCb3VuZHMgPSBbTnVtYmVyKHNSZWN0LngpLCBOdW1iZXIoc1JlY3QueSksIE51bWJlcihzUmVjdC54KSArIE51bWJlcihzUmVjdC53aWR0aCksIE51bWJlcihcclxuICAgICAgICAgICAgc1JlY3QueSkgKyBOdW1iZXIoc1JlY3QuaGVpZ2h0KV07XHJcblxyXG4gICAgICAgIHZhciBlUmVjdCA9IFV0aWwuZ2V0UmVjdChlbmROb2RlLCBpc05vdEluU2FtZUdyb3VwKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgdmFyIGVCb3VuZHMgPSBbTnVtYmVyKGVSZWN0LngpLCBOdW1iZXIoZVJlY3QueSksIE51bWJlcihlUmVjdC54KSArIE51bWJlcihlUmVjdC53aWR0aCksIE51bWJlcihcclxuICAgICAgICAgICAgZVJlY3QueSkgKyBOdW1iZXIoZVJlY3QuaGVpZ2h0KV07XHJcblxyXG5cclxuICAgICAgICB2YXIgc0Nvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoc1JlY3QsIHN0YXJ0Tm9kZSk7XHJcbiAgICAgICAgdmFyIGVDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKGVSZWN0LCBlbmROb2RlKTtcclxuXHJcbiAgICAgICAgLy/liKTmlq3lpoLmnpzmsqHmnInmjIflrprkvY3nva7nmoTor50sIOWIpOaWreW8gOWni+iKgueCueWcqOe7k+adn+e7k+aenOW3pui+ueWImemHh+eUqCByaWdodC1sZWZ0IOWQpuWImemHh+eUqGxlZnQtcmlnaHRcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbjtcclxuICAgICAgICBpZiAocG9zaXRpb24uZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3NBcnIgPSBwb3NpdGlvbi5kaXJlY3Rpb24uc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgcG9zaXRpb24uc3RhcnRQb3MgPSBwb3NBcnJbMF07XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZFBvcyA9IHBvc0FyclsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwb3NpdGlvbi5zdGFydFBvcyB8fCAhcG9zaXRpb24uZW5kUG9zKSB7XHJcbiAgICAgICAgICAgIGlmIChzUmVjdC54IDwgZVJlY3QueCkge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc3RhcnRQb3MgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5lbmRQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0UG9zID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5lbmRQb3MgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSB0aGlzLmNhbGNQb2ludEV4cHJlc3Npb24ocG9zaXRpb24uc3RhcnRQb3MsIHNDb25uZWN0b3JQb2ludCk7XHJcbiAgICAgICAgdmFyIGVuZFBvaW50ID0gdGhpcy5jYWxjUG9pbnRFeHByZXNzaW9uKHBvc2l0aW9uLmVuZFBvcywgZUNvbm5lY3RvclBvaW50KTtcclxuICAgICAgICBzdGFydFBvaW50LmFkZChuZXcgUG9pbnQocG9zaXRpb24uc3RhcnRPZmZzZXRbMF0sIHBvc2l0aW9uLnN0YXJ0T2Zmc2V0WzFdKSk7XHJcbiAgICAgICAgZW5kUG9pbnQuYWRkKG5ldyBQb2ludChwb3NpdGlvbi5lbmRPZmZzZXRbMF0sIHBvc2l0aW9uLmVuZE9mZnNldFsxXSkpO1xyXG4gICAgICAgIHJldHVybiBbc3RhcnRQb2ludCwgZW5kUG9pbnQsIHNCb3VuZHMsIGVCb3VuZHNdO1xyXG4gICAgfVxyXG5cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jYWxjUG9pbnRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHBvcywgcG9pbnQpIHtcclxuICAgICAgICB2YXIgdmFyaWFibGUgPSB7XHJcbiAgICAgICAgICAgIHRvcDogcG9pbnQudG9wLngsXHJcbiAgICAgICAgICAgIGxlZnQ6IHBvaW50LmxlZnQueSxcclxuICAgICAgICAgICAgcmlnaHQ6IHBvaW50LnJpZ2h0LnksXHJcbiAgICAgICAgICAgIGJvdHRvbTogcG9pbnQuYm90dG9tLngsXHJcbiAgICAgICAgICAgIGNlbnRlcjogcG9pbnQuY2VudGVyLnhcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IFwiPCUgcHJpbnQoXCIgKyBwb3MgKyBcIikgJT5cIjtcclxuICAgICAgICB2YXIgdmFsID0gcGFyc2VJbnQoVXRpbC50ZW1wbGF0ZShleHByZXNzaW9uKSh2YXJpYWJsZSkpO1xyXG4gICAgICAgIGlmIChwb3MuaW5kZXhPZihcInRvcFwiKSAhPSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHZhbCwgcG9pbnQudG9wLnkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocG9zLmluZGV4T2YoXCJsZWZ0XCIpICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocG9pbnQubGVmdC54LCB2YWwpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocG9zLmluZGV4T2YoXCJyaWdodFwiKSAhPSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHBvaW50LnJpZ2h0LngsIHZhbCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwb3MuaW5kZXhPZihcImJvdHRvbVwiKSAhPSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHZhbCwgcG9pbnQuYm90dG9tLnkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocG9zLmluZGV4T2YoXCJjZW50ZXJcIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh2YWwsIHBvaW50LmJvdHRvbS55KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb3Plj4LmlbDplJnor69cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu65oiW5L+u5pS55Li05pe257q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHN0YXJ0Tm9kZSAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHJFbmRQb2ludCAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGxpbmVUeXBlICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHN0YXJ0UG9zICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5tYW5hZ2VUZW1wQ29ubmVjdG9yID0gZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgckVuZFBvaW50LCBsaW5lVHlwZSwgc3RhcnRQb3MsIGVuZFBvcywgZW5kTm9kZSkge1xyXG4gICAgICAgIHZhciBlUmVjdCA9IG51bGw7XHJcbiAgICAgICAgdmFyIGVCb3VuZHMgPSBudWxsO1xyXG4gICAgICAgIHZhciBzUmVjdCA9IFV0aWwuZ2V0UmVjdChzdGFydE5vZGUsIHRydWUpLmJvdW5kaW5nUmVjdDtcclxuICAgICAgICB2YXIgc0JvdW5kcyA9IFtOdW1iZXIoc1JlY3QueCksIE51bWJlcihzUmVjdC55KSwgTnVtYmVyKHNSZWN0LngpICsgTnVtYmVyKHNSZWN0LndpZHRoKSwgTnVtYmVyKFxyXG4gICAgICAgICAgICBzUmVjdC55KSArIE51bWJlcihzUmVjdC5oZWlnaHQpXTtcclxuXHJcbiAgICAgICAgdmFyIHNDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKHNSZWN0LCBzdGFydE5vZGUpO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMudGVtcENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBDb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKHtcclxuICAgICAgICAgICAgICAgIGlzRWRpdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVUeXBlOiBsaW5lVHlwZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjb25uZWN0b3IgPSB0aGlzLnRlbXBDb25uZWN0b3I7XHJcbiAgICAgICAgLy/liKTmlq3lpoLmnpzmsqHmnInmjIflrprkvY3nva7nmoTor50sIOWIpOaWreW8gOWni+iKgueCueWcqOe7k+adn+e7k+aenOW3pui+ueWImemHh+eUqCByaWdodC1sZWZ0IOWQpuWImemHh+eUqGxlZnQtcmlnaHRcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbjtcclxuICAgICAgICBwb3NpdGlvbi5zdGFydFBvcyA9IHN0YXJ0UG9zID8gc3RhcnRQb3MgOiAoc1JlY3QueCA8IHJFbmRQb2ludC54ID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpO1xyXG4gICAgICAgIHBvc2l0aW9uLmVuZFBvcyA9IGVuZFBvcyA/IGVuZFBvcyA6IChzUmVjdC54IDwgckVuZFBvaW50LnggPyBcImxlZnRcIiA6IFwicmlnaHRcIik7XHJcblxyXG4gICAgICAgIGNvbm5lY3Rvci5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID0gbGluZVR5cGU7XHJcbiAgICAgICAgaWYgKGVuZE5vZGUpIHtcclxuICAgICAgICAgICAgZVJlY3QgPSBVdGlsLmdldFJlY3QoZW5kTm9kZSwgdHJ1ZSkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgICAgICBlQm91bmRzID0gW051bWJlcihlUmVjdC54KSwgTnVtYmVyKGVSZWN0LnkpLCBOdW1iZXIoZVJlY3QueCkgKyBOdW1iZXIoZVJlY3Qud2lkdGgpLCBOdW1iZXIoXHJcbiAgICAgICAgICAgICAgICBlUmVjdC55KSArIE51bWJlcihlUmVjdC5oZWlnaHQpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNvbHV0aW9ucyA9IHRoaXMuY29ubmVjdG9yMlBvaW50cyhsaW5lVHlwZSwgc0Nvbm5lY3RvclBvaW50W3Bvc2l0aW9uLnN0YXJ0UG9zXSwgckVuZFBvaW50LFxyXG4gICAgICAgICAgICBzQm91bmRzLCBlQm91bmRzKTsgLy8gVFlQRV9TVFJBSUdIVCBUWVBFX0pBR0dFRFxyXG5cclxuICAgICAgICBjb25uZWN0b3IucmVmcmVzaChzb2x1dGlvbnNbMF1bMl0pO1xyXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rmiJbkv67mlLnkuLTml7blj43ovaznur9cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhcnRQb2ludCAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBlbmROb2RlICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGxpbmVUeXBlICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZW5kUG9zICAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5tYW5hZ2VSZXZlcnNlVGVtcENvbm5lY3RvciA9IGZ1bmN0aW9uIChzdGFydFBvaW50LCBlbmROb2RlLCBsaW5lVHlwZSwgZW5kUG9zLCBzdGFydFBvcywgc3RhcnROb2RlKSB7XHJcbiAgICAgICAgdmFyIHNSZWN0ID0gbnVsbDtcclxuICAgICAgICB2YXIgc0JvdW5kcyA9IG51bGw7XHJcbiAgICAgICAgdmFyIGVSZWN0ID0gVXRpbC5nZXRSZWN0KGVuZE5vZGUsIHRydWUpLmJvdW5kaW5nUmVjdDtcclxuICAgICAgICB2YXIgZUJvdW5kcyA9IFtOdW1iZXIoZVJlY3QueCksIE51bWJlcihlUmVjdC55KSwgTnVtYmVyKGVSZWN0LngpICsgTnVtYmVyKGVSZWN0LndpZHRoKSwgTnVtYmVyKGVSZWN0LnkpICsgTnVtYmVyKGVSZWN0LmhlaWdodCldO1xyXG4gICAgICAgIHZhciBlQ29ubmVjdG9yUG9pbnQgPSBVdGlsLmdldENvbm5lY3RvclBvaW50cyhlUmVjdCwgZW5kTm9kZSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRlbXBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy50ZW1wQ29ubmVjdG9yID0gbmV3IENvbm5lY3Rvcih7XHJcbiAgICAgICAgICAgICAgICBpc0VkaXQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lVHlwZTogbGluZVR5cGVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb25uZWN0b3IgPSB0aGlzLnRlbXBDb25uZWN0b3I7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb247XHJcbiAgICAgICAgcG9zaXRpb24uZW5kUG9zID0gZW5kUG9zID8gZW5kUG9zIDogKGVSZWN0LnggPCBzdGFydFBvaW50LnggPyBcInJpZ2h0XCIgOiBcImxlZnRcIik7XHJcbiAgICAgICAgcG9zaXRpb24uc3RhcnRQb3MgPSBzdGFydFBvcyA/IHN0YXJ0UG9zIDogKGVSZWN0LnggPCBzdGFydFBvaW50LnggPyBcImxlZnRcIiA6IFwicmlnaHRcIik7XHJcblxyXG4gICAgICAgIGNvbm5lY3Rvci5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID0gbGluZVR5cGU7XHJcbiAgICAgICAgaWYgKHN0YXJ0Tm9kZSkge1xyXG4gICAgICAgICAgICBzUmVjdCA9IFV0aWwuZ2V0UmVjdChzdGFydE5vZGUsIHRydWUpLmJvdW5kaW5nUmVjdDtcclxuICAgICAgICAgICAgc0JvdW5kcyA9IFtOdW1iZXIoc1JlY3QueCksIE51bWJlcihzUmVjdC55KSwgTnVtYmVyKHNSZWN0LngpICsgTnVtYmVyKHNSZWN0LndpZHRoKSwgTnVtYmVyKFxyXG4gICAgICAgICAgICBzUmVjdC55KSArIE51bWJlcihzUmVjdC5oZWlnaHQpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNvbHV0aW9ucyA9IHRoaXMuY29ubmVjdG9yMlBvaW50cyhsaW5lVHlwZSwgc3RhcnRQb2ludCwgZUNvbm5lY3RvclBvaW50W3Bvc2l0aW9uLmVuZFBvc10sXHJcbiAgICAgICAgICAgIHNCb3VuZHMsIGVCb3VuZHMpOyAvLyBUWVBFX1NUUkFJR0hUIFRZUEVfSkFHR0VEXHJcblxyXG4gICAgICAgIGNvbm5lY3Rvci5yZWZyZXNoKHNvbHV0aW9uc1swXVsyXSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIoOmZpOS4tOaXtue6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSB6ciAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVUZW1wQ29ubmVjdG9yID0gZnVuY3Rpb24gKHpyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGVtcENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICB6ci5yZW1vdmUodGhpcy50ZW1wQ29ubmVjdG9yKTtcclxuICAgICAgICAgICAgdGhpcy50ZW1wQ29ubmVjdG9yID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog566X5Ye6IOS4pOS4quiKgueCuSDmjIflrprkuKTkuKrngrnlpoLkvZXogZTnur9cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gdHlwZSAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHN0YXJ0UG9pbnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBlbmRQb2ludCAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc0JvdW5kcyAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGVCb3VuZHMgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3RvcjJQb2ludHMgPSBmdW5jdGlvbiAodHlwZSwgc3RhcnRQb2ludCwgZW5kUG9pbnQsIHNCb3VuZHMsIGVCb3VuZHMsXHJcbiAgICAgICAgZXNjYXBlRGlzdGFuY2UpIHtcclxuICAgICAgICB2YXIgZmlndXJlRXNjYXBlRGlzdGFuY2UgPSBbMzAsIDMwXTtcclxuICAgICAgICBpZiAoZXNjYXBlRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShlc2NhcGVEaXN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgIGZpZ3VyZUVzY2FwZURpc3RhbmNlID0gW2VzY2FwZURpc3RhbmNlLCBlc2NhcGVEaXN0YW5jZV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmaWd1cmVFc2NhcGVEaXN0YW5jZSA9IGVzY2FwZURpc3RhbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBMb2cuZ3JvdXAoXCJjb25uZWN0aW9uTWFuYWdlcjogY29ubmVjdG9yMlBvaW50c1wiKTtcclxuXHJcblxyXG4gICAgICAgIExvZy5pbmZvKFwiQ29ubmVjdGlvbk1hbmFnZXI6IGNvbm5lY3RvcjJQb2ludHMgKFwiICsgdHlwZSArIFwiLCBcIiArIHN0YXJ0UG9pbnQgKyBcIiwgXCIgKyBlbmRQb2ludCArXHJcbiAgICAgICAgICAgIFwiLCBcIiArIHNCb3VuZHMgKyBcIiwgXCIgKyBlQm91bmRzICsgJyknKTtcclxuICAgICAgICB2YXIgc29sdXRpb25zID0gW107XHJcblxyXG5cclxuXHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgQ29ubmVjdG9yLlRZUEVfQ0hBSU46XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUOiAvL+ebtOe6v1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtzdGFydFBvaW50LmNsb25lKCksIGVuZFBvaW50LmNsb25lKCldO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzdHJhaWdodCcsICdzdHJhaWdodCcsIHBvaW50c10pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbm5lY3Rvci5UWVBFX0NVUlZFOiAvL+absue6v1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb25uZWN0b3IuVFlQRV9KQUdHRUQ6IC8v5oqY57q/XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRFeGl0UG9pbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZEV4aXRQb2ludCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9maW5kIHN0YXJ0IGV4aXQgcG9pbnQgIOWvu+aJvuW8gOWni+WHuuWPo1xyXG4gICAgICAgICAgICAgICAgaWYgKHNCb3VuZHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3RlbnRpYWxFeGl0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChzdGFydFBvaW50LngsIHNCb3VuZHNbMV0gLSBmaWd1cmVFc2NhcGVEaXN0YW5jZVswXSkpOyAvL25vcnRoIOWMl1xyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KHNCb3VuZHNbMl0gKyBmaWd1cmVFc2NhcGVEaXN0YW5jZVswXSwgc3RhcnRQb2ludC55KSk7IC8vZWFzdCAg5LicXHJcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoc3RhcnRQb2ludC54LCBzQm91bmRzWzNdICsgZmlndXJlRXNjYXBlRGlzdGFuY2VbMF0pKTsgLy9zb3V0aCAg5Y2XXHJcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoc0JvdW5kc1swXSAtIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzBdLCBzdGFydFBvaW50LnkpKTsgLy93ZXN0ICDopb9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9waWNrIGNsb3Nlc3QgZXhpdCBwb2ludCAg5a+75om+5LiOIHN0YXJ0UG9pbnQg5pyA6Z2g6L+R55qE5Ye65Y+j54K5XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFeGl0UG9pbnQgPSBwb3RlbnRpYWxFeGl0c1swXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvdGVudGlhbEV4aXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChVdGlsLmRpc3RhbmNlKHN0YXJ0UG9pbnQsIHBvdGVudGlhbEV4aXRzW2ldKSA8IFV0aWwuZGlzdGFuY2Uoc3RhcnRQb2ludCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEV4aXRQb2ludCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RXhpdFBvaW50ID0gcG90ZW50aWFsRXhpdHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vZmluZCBlbmQgZXhpdCBwb2ludCAg5a+75om+57uT5p2f5Ye65Y+jXHJcbiAgICAgICAgICAgICAgICBpZiAoZUJvdW5kcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvdGVudGlhbEV4aXRzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KGVuZFBvaW50LngsIGVCb3VuZHNbMV0gLSBmaWd1cmVFc2NhcGVEaXN0YW5jZVsxXSkpOyAvL25vcnRoXHJcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoZUJvdW5kc1syXSArIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzFdLCBlbmRQb2ludC55KSk7IC8vZWFzdFxyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KGVuZFBvaW50LngsIGVCb3VuZHNbM10gKyBmaWd1cmVFc2NhcGVEaXN0YW5jZVsxXSkpOyAvL3NvdXRoXHJcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoZUJvdW5kc1swXSAtIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzFdLCBlbmRQb2ludC55KSk7IC8vd2VzdFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3BpY2sgY2xvc2VzdCBleGl0IHBvaW50ICDlr7vmib7kuI4gZW5kUG9pbnQg5pyA6Z2g6L+R55qE5Ye65Y+j54K5XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kRXhpdFBvaW50ID0gcG90ZW50aWFsRXhpdHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb3RlbnRpYWxFeGl0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5kaXN0YW5jZShlbmRQb2ludCwgcG90ZW50aWFsRXhpdHNbaV0pIDwgVXRpbC5kaXN0YW5jZShlbmRQb2ludCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRFeGl0UG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRFeGl0UG9pbnQgPSBwb3RlbnRpYWxFeGl0c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL0Jhc2ljIHNvbHV0aW9uIOacgOWfuuacrOeahOino+WGs+aWueahiCAgIOS4uuWFtuS7luino+WGs+aWueahiOWBmuWHhuWkh1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBbc3RhcnRQb2ludF07XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2FwSW5kZXggPSAwOyAvL3RoZSBpbmRleCBvZiB0aGUgZ2FwICh3aGVyZSBkbyB3ZSBuZWVkIHRvIGluc2VydCBuZXcgcG9pbnRzKSBETyBOT1QgQ0hBTkdFIElUXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRFeGl0UG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzLnB1c2goc3RhcnRFeGl0UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdhcEluZGV4ID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlbmRFeGl0UG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzLnB1c2goZW5kRXhpdFBvaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHMucHVzaChlbmRQb2ludCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1NPIC0gbm8gYWRkaXRpb25hbCBwb2ludHMgICAgIFMwIOino+WGs+aWueahiCDkuI3mt7vliqDku7vkvZXngrkgIOWfuuacrOS4jeS8muiiq+mHh+eUqFxyXG4gICAgICAgICAgICAgICAgdmFyIHMwID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczAnLCAnczAnLCBzMF0pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9TMSAgIFMxIOino+WGs+aWueahiCAg5Y+q5pyJ5LiA5Liq5oqY54K5XHJcbiAgICAgICAgICAgICAgICB2YXIgczEgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZmlyc3QgdmFyaWFudCAgIOesrOS4gOS4quWPmOS9kyBzMSBzMV8x5pa55qGIICDmipjnur/ngrnlnKggc3RhcnRFeGl0UG9pbnTnmoRYIOS4jiBlbmRFeGl0UG9pbnTnmoQgWeS9jee9rlxyXG4gICAgICAgICAgICAgICAgdmFyIHMxXzEgPSBQb2ludC5jbG9uZUFycmF5KHMxKTtcclxuICAgICAgICAgICAgICAgIHMxXzEuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgbmV3IFBvaW50KHMxXzFbZ2FwSW5kZXhdLngsIHMxXzFbZ2FwSW5kZXggKyAxXS55KSk7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MxJywgJ3MxXzEnLCBzMV8xXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9zZWNvbmQgdmFyaWFudCAg56ys5LqM5Y+Y5L2TIHMxIHMxLTLmlrnmoYggIOaKmOe6v+eCueWcqCBlbmRFeGl0UG9pbnTnmoRYIOS4jiAgc3RhcnRFeGl0UG9pbnTnmoRZ5L2N572uXHJcbiAgICAgICAgICAgICAgICB2YXIgczFfMiA9IFBvaW50LmNsb25lQXJyYXkoczEpO1xyXG4gICAgICAgICAgICAgICAgczFfMi5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBuZXcgUG9pbnQoczFfMltnYXBJbmRleCArIDFdLngsIHMxXzJbZ2FwSW5kZXhdLnkpKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczEnLCAnczFfMicsIHMxXzJdKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9TMiAgUzIg6Kej5Yaz5pa55qGIICDmt7vliqDkuKTkuKrmipjngrlcclxuXHJcbiAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgSSAgIHMyXzHmlrnmoYhcclxuICAgICAgICAgICAgICAgIHZhciBzMl8xID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl8xXzEgPSBuZXcgUG9pbnQoKHMyXzFbZ2FwSW5kZXhdLnggKyBzMl8xW2dhcEluZGV4ICsgMV0ueCkgLyAyLCBzMl8xW2dhcEluZGV4XS55KTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl8xXzIgPSBuZXcgUG9pbnQoKHMyXzFbZ2FwSW5kZXhdLnggKyBzMl8xW2dhcEluZGV4ICsgMV0ueCkgLyAyLCBzMl8xW2dhcEluZGV4ICsgMV0ueSk7XHJcbiAgICAgICAgICAgICAgICBzMl8xLnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzFfMSwgczJfMV8yKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfMScsIHMyXzFdKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9WYXJpYW50IElJICBzMl8x5pa55qGIICAx5oqY57q/54K5IHg6IHN0YXJ0RXhpdFBvaW5055qEWCDkvY3nva4geTogc3RhcnRFeGl0UG9pbnTnmoR5K2VuZEV4aXRQb2ludOeahHkvMlxyXG4gICAgICAgICAgICAgICAgLy8x5oqY57q/54K5IHg6ZW5kRXhpdFBvaW5055qEeCAgeTpzdGFydEV4aXRQb2ludOeahHkrZW5kRXhpdFBvaW5055qEeS8yXHJcbiAgICAgICAgICAgICAgICB2YXIgczJfMiA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfMl8xID0gbmV3IFBvaW50KHMyXzJbZ2FwSW5kZXhdLngsIChzMl8yW2dhcEluZGV4XS55ICsgczJfMltnYXBJbmRleCArIDFdLnkpIC8gMik7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfMl8yID0gbmV3IFBvaW50KHMyXzJbZ2FwSW5kZXggKyAxXS54LCAoczJfMltnYXBJbmRleF0ueSArIHMyXzJbZ2FwSW5kZXggKyAxXS55KSAvIDIpO1xyXG4gICAgICAgICAgICAgICAgczJfMi5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBzMl8yXzEsIHMyXzJfMik7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MyJywgJ3MyXzInLCBzMl8yXSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vVmFyaWFudCBJSUlcclxuICAgICAgICAgICAgICAgIHZhciBzMl8zID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICAgICAgICAgIC8vZmluZCB0aGUgYW1vdW50IChzdG9yZWQgaW4gZGVsdGEpIG9mIHBpeGVscyB3ZSBuZWVkIHRvIG1vdmUgcmlnaHQgc28gbm8gaW50ZXJzZWN0aW9uIHdpdGggYSBmaWd1cmUgd2lsbCBiZSBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAvLyFTZWU6ICAvZG9jdW1lbnRzL3NwZWNzL2Nvbm5lY3RlZF9maWd1cmVzX2RlbHRhcy5qcGcgZmlsZVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBlYXN0RXhpdHMgPSBbczJfM1tnYXBJbmRleF0ueCArIDIwLCBzMl8zW2dhcEluZGV4ICsgMV0ueCArIDIwXTsgLy9hZGQgcG9pbnRzIFggY29vcmRpbmF0ZXMgdG8gYmUgYWJsZSB0byBnZW5lcmF0ZSBWYXJpYW50IElJSSBldmVuIGluIHRoZSBhYnNlbmNlIG9mIGZpZ3VyZXMgOnBcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVhc3RFeGl0cy5wdXNoKHNCb3VuZHNbMl0gKyAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBlYXN0RXhpdHMucHVzaChlQm91bmRzWzJdICsgMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBlYXN0RXhpdCA9IFV0aWwubWF4KGVhc3RFeGl0cyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfM18xID0gbmV3IFBvaW50KGVhc3RFeGl0LCBzMl8zW2dhcEluZGV4XS55KTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl8zXzIgPSBuZXcgUG9pbnQoZWFzdEV4aXQsIHMyXzNbZ2FwSW5kZXggKyAxXS55KTtcclxuICAgICAgICAgICAgICAgIHMyXzMuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfM18xLCBzMl8zXzIpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl8zJywgczJfM10pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgSVYgIHMyXzTmlrnmoYhcclxuICAgICAgICAgICAgICAgIHZhciBzMl80ID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICAgICAgICAgIC8vZmluZCB0aGUgYW1vdW50IChzdG9yZWQgaW4gZGVsdGEpIG9mIHBpeGVscyB3ZSBuZWVkIHRvIG1vdmUgdXAgc28gbm8gaW50ZXJzZWN0aW9uIHdpdGggYSBmaWd1cmUgd2lsbCBiZSBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAvLyFTZWU6ICAvZG9jdW1lbnRzL3NwZWNzL2Nvbm5lY3RlZF9maWd1cmVzX2RlbHRhcy5qcGcgZmlsZVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBub3J0aEV4aXRzID0gW3MyXzRbZ2FwSW5kZXhdLnkgLSAyMCwgczJfNFtnYXBJbmRleCArIDFdLnkgLSAyMF07IC8vYWRkIHBvaW50cyB5IGNvb3JkaW5hdGVzIHRvIGJlIGFibGUgdG8gZ2VuZXJhdGUgVmFyaWFudCBJSUkgZXZlbiBpbiB0aGUgYWJzZW5jZSBvZiBmaWd1cmVzIDpwXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBub3J0aEV4aXRzLnB1c2goc0JvdW5kc1sxXSAtIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZUJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcnRoRXhpdHMucHVzaChlQm91bmRzWzFdIC0gMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBub3J0aEV4aXQgPSBVdGlsLm1pbihub3J0aEV4aXRzKTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl80XzEgPSBuZXcgUG9pbnQoczJfNFtnYXBJbmRleF0ueCwgbm9ydGhFeGl0KTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl80XzIgPSBuZXcgUG9pbnQoczJfNFtnYXBJbmRleCArIDFdLngsIG5vcnRoRXhpdCk7XHJcbiAgICAgICAgICAgICAgICBzMl80LnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzRfMSwgczJfNF8yKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfNCcsIHMyXzRdKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9WYXJpYW50IFZcclxuICAgICAgICAgICAgICAgIHZhciBzMl81ID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICAgICAgICAgIC8vZmluZCB0aGUgYW1vdW50IChzdG9yZWQgaW4gZGVsdGEpIG9mIHBpeGVscyB3ZSBuZWVkIHRvIG1vdmUgbGVmdCBzbyBubyBpbnRlcnNlY3Rpb24gd2l0aCBhIGZpZ3VyZSB3aWxsIGJlIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIC8vIVNlZTogIC9kb2N1bWVudHMvc3BlY3MvY29ubmVjdGVkX2ZpZ3VyZXNfZGVsdGFzLmpwZyBmaWxlXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHdlc3RFeGl0cyA9IFtzMl81W2dhcEluZGV4XS54IC0gMjAsIHMyXzVbZ2FwSW5kZXggKyAxXS54IC0gMjBdOyAvL2FkZCBwb2ludHMgeCBjb29yZGluYXRlcyB0byBiZSBhYmxlIHRvIGdlbmVyYXRlIFZhcmlhbnQgSUlJIGV2ZW4gaW4gdGhlIGFic2VuY2Ugb2YgZmlndXJlcyA6cFxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2VzdEV4aXRzLnB1c2goc0JvdW5kc1swXSAtIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZUJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdlc3RFeGl0cy5wdXNoKGVCb3VuZHNbMF0gLSAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHdlc3RFeGl0ID0gVXRpbC5taW4od2VzdEV4aXRzKTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl81XzEgPSBuZXcgUG9pbnQod2VzdEV4aXQsIHMyXzVbZ2FwSW5kZXhdLnkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzVfMiA9IG5ldyBQb2ludCh3ZXN0RXhpdCwgczJfNVtnYXBJbmRleCArIDFdLnkpO1xyXG4gICAgICAgICAgICAgICAgczJfNS5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBzMl81XzEsIHMyXzVfMik7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MyJywgJ3MyXzUnLCBzMl81XSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vVmFyaWFudCBWSVxyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzYgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgLy9maW5kIHRoZSBhbW91bnQgKHN0b3JlZCBpbiBkZWx0YSkgb2YgcGl4ZWxzIHdlIG5lZWQgdG8gbW92ZSBkb3duIHNvIG5vIGludGVyc2VjdGlvbiB3aXRoIGEgZmlndXJlIHdpbGwgYmUgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgLy8hU2VlOiAgL2RvY3VtZW50cy9zcGVjcy9jb25uZWN0ZWRfZmlndXJlc19kZWx0YXMuanBnIGZpbGVcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc291dGhFeGl0cyA9IFtzMl82W2dhcEluZGV4XS55ICsgMjAsIHMyXzZbZ2FwSW5kZXggKyAxXS55ICsgMjBdOyAvL2FkZCBwb2ludHMgeSBjb29yZGluYXRlcyB0byBiZSBhYmxlIHRvIGdlbmVyYXRlIFZhcmlhbnQgSUlJIGV2ZW4gaW4gdGhlIGFic2VuY2Ugb2YgZmlndXJlcyA6cFxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc291dGhFeGl0cy5wdXNoKHNCb3VuZHNbM10gKyAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3V0aEV4aXRzLnB1c2goZUJvdW5kc1szXSArIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc291dGhFeGl0ID0gVXRpbC5tYXgoc291dGhFeGl0cyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNl8xID0gbmV3IFBvaW50KHMyXzZbZ2FwSW5kZXhdLngsIHNvdXRoRXhpdCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNl8yID0gbmV3IFBvaW50KHMyXzZbZ2FwSW5kZXggKyAxXS54LCBzb3V0aEV4aXQpO1xyXG4gICAgICAgICAgICAgICAgczJfNi5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBzMl82XzEsIHMyXzZfMik7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MyJywgJ3MyXzYnLCBzMl82XSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL0ZJTFRFUiBzb2x1dGlvbnNcclxuXHJcbiAgICAgICAgICAgICAgICAvKkFsZ29yaXRobVxyXG4gICAgICAgICAgICAgICAgICogMC4gc29sdXRpb25zIGFyZSBvcmRlcmVkIGZyb20gbWluaW1tdW4gbnIgb2YgcG9pbnRzIHRvIG1heGltdW0gPjopXHJcbiAgICAgICAgICAgICAgICAgKiAxLiByZW1vdmUgYWxsIHNvbHV0aW9ucyB0aGF0IGFyZSBub3Qgb3J0aG9nb25hbCAobWFpbmx5IHMwIHNvbHV0aW9uKVxyXG4gICAgICAgICAgICAgICAgICogMi4gcmVtb3ZlIGFsbCBzb2x1dGlvbnMgdGhhdCBnbyBiYWNrd2FyZCAod2Ugd2lsbCBub3QgbmVlZCB0aGVtIGV2ZXIpXHJcbiAgICAgICAgICAgICAgICAgKiAzLiByZW1vdmUgYWxsIHNvbHV0aW9ucyB3aXRoIGludGVyc2VjdGlvbnNcclxuICAgICAgICAgICAgICAgICAqIDQuIHBpY2sgZmlyc3QgY2xhc3Mgb2Ygc29sdXRpb25zIHdpdGggc2FtZSBuciBvZiBwb2ludHMgKGV4OiAyKVxyXG4gICAgICAgICAgICAgICAgICogNS4gcGljayB0aGUgZmlyc3Qgc29sdXRpb24gd2l0aCA5MCBkZWdyZWUgYW5nbGVzIChsZXNzIHR1cm5hcm91bmRzKVxyXG4gICAgICAgICAgICAgICAgICogKG5vdCBpbnRlcmVzdGV0ZWQpIHNvcnQgYnkgbGVuZ3RoIDpwXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICAvLzEuIGZpbHRlciBub24gb3J0b2dvbmFsIHNvbHV0aW9ucyDliKDpmaTkuI3mmK/mraPkuqTnm7Tnur/nmoTmlrnmoYhcclxuICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiRmlsdGVyIG9ydGhvZ29uYWwgc29sdXRpb25zLiBJbml0aWFsIG51bWJlciBvZiBzb2x1dGlvbnMgPSBcIiArIHNvbHV0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9ydGhvZ29uYWxTb2x1dGlvbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBzb2x1dGlvbnMubGVuZ3RoOyBsKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc29sdXRpb24gPSBzb2x1dGlvbnNbbF1bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWwub3J0aG9nb25hbFBhdGgoc29sdXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ydGhvZ29uYWxTb2x1dGlvbi5wdXNoKHNvbHV0aW9uc1tsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zID0gb3J0aG9nb25hbFNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgTG9nLmluZm8oXCJcXG5cXHRPcnRob2dvbmFsU29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLzIuIGZpbHRlciBiYWNrd2FyZCBzb2x1dGlvbnMgIOi/h+a7pCDlgJLpgIDnmoTmlrnmoYhcclxuICAgICAgICAgICAgICAgIC8vZG8gbm90IGFsbG93IHN0YXJ0IGFuZCBlbmQgcG9pbnRzIHRvIGNvaW5jaWRlIC0gaWdub3JlIHRoZW1cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydFBvaW50LmVxdWFscyhlbmRQb2ludCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJTdGFydCBhbmQgZW5kIHBvaW50IGNvaW5jaWRlLi4uc2tpcCBiYWNrd2FyZCBzb2x1dGlvbi4gSSB0aGluayB3ZSB3aWxsIGp1c3QgZmFsbCBvbiBzMCA6KVwiXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJGaWx0ZXIgYmFja3dhcmQgc29sdXRpb25zLiBJbml0aWFsIG51bWJlciBvZiBzb2x1dGlvbnMgPSBcIiArIHNvbHV0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3J3YXJkU29sdXRpb25zID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHNvbHV0aW9ucy5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sdXRpb24gPSBzb2x1dGlvbnNbbF1bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChVdGlsLmZvcndhcmRQYXRoKHNvbHV0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZFNvbHV0aW9ucy5wdXNoKHNvbHV0aW9uc1tsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gdGVtcCArIFwiXFxuXFx0XCIgKyBzb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBmb3J3YXJkU29sdXRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiXFxuXFx0IEZvcndhcmRTb2x1dGlvbnMgPSBcIiArIHNvbHV0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb2x1dGlvbnMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJEaXNjYXJkZWQgc29sdXRpb25zOiBcIiArIHRlbXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8zLiBGaWx0ZXIgbm9uIGludGVyc2VjdGluZyBzb2x1dGlvbnMgIOWOu+mZpOayoeacieS6pOmbhigp55qE5pa55qGIXHJcbiAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIkZpbHRlciBub24gaW50ZXJzZWN0aW5nIHNvbHV0aW9ucy4gSW5pdGlhbCBudW1iZXIgb2Ygc29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHZhciBub25JbnRlcnNlY3Rpb25Tb2x1dGlvbnMgPSBbXVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBzb2x1dGlvbnMubGVuZ3RoOyBsKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc29sdXRpb24gPSBzb2x1dGlvbnNbbF1bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Mb2cuaW5mbyhcIlNvbHV0aW9uIGlkPSBcIiArIHNvbHV0aW9uc1tsXVsxXSArICcgbnIgcG9pbnRzID0gJyArIHNvbHV0aW9uLmxlbmd0aCArIFwiLCBwb2ludHMgPSBcIiArIHNvbHV0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbm5lckxpbmVzID0gc29sdXRpb24uc2xpY2UoKTsgLy9qdXN0IGEgc2hhbGxvdyBjb3B5XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qSWYgYW55IGJvdW5kcyBqdXN0IHRyaW0gdGhlIHNvbHV0aW9uLiBTbyB3ZSBhdm9pZCB0aGUgc3RyYW5nZSBjYXNlIHdoZW4gYSBjb25uZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICpzdGFydGVzIGZyb20gYSBwb2ludCBvbiBhIGZpZ3VyZSBhbmQgZW5kcyBpbnNpZGUgb2YgdGhlIHNhbWUgZmlndXJlLCBidXQgbm90IG9uIGEgY29ubmVjdGlvbiBwb2ludCovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVCb3VuZHMgfHwgc0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2kwbm5lckxpbmVzID0gaW5uZXJMaW5lcy5zbGljZSgwLCBpbm5lckxpbmVzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lckxpbmVzID0gaW5uZXJMaW5lcy5zbGljZSgxLCBpbm5lckxpbmVzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0xvZy5pbmZvKFwiXFx0IGVCb3VuZHMgcHJlc2VudCxpbm5lckxpbmVzIG5yLiBwb2ludHMgPSBcIiArIGlubmVyTGluZXMubGVuZ3RoICsgXCIsIHBvaW50cyA9IFwiICsgaW5uZXJMaW5lcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vbm93IHRlc3QgZm9yIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdCA9IGludGVyc2VjdCB8fCBVdGlsLnBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZShpbm5lckxpbmVzLCBzQm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0ID0gaW50ZXJzZWN0IHx8IFV0aWwucG9seWxpbmVJbnRlcnNlY3RzUmVjdGFuZ2xlKGlubmVyTGluZXMsIGVCb3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnRlcnNlY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9uSW50ZXJzZWN0aW9uU29sdXRpb25zLnB1c2goc29sdXRpb25zW2xdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9JZiBhbGwgc29sdXRpb25zIGludGVyc2VjdCB0aGFuIHRoaXMgaXMgZGVzdGlueSAgOikgYW5kIGp1c3QgaWdub3JlIHRoZSBpbnRlcnNlY3Rpb24gZmlsdGVyXHJcbiAgICAgICAgICAgICAgICBpZiAobm9uSW50ZXJzZWN0aW9uU29sdXRpb25zLmxlbmd0aCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZWFzaWduIHRvIHNvbHV0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IG5vbkludGVyc2VjdGlvblNvbHV0aW9ucztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIlxcblxcdCBub25JbnRlcnNlY3Rpb25Tb2x1dGlvbnMgPSBcIiArIHNvbHV0aW9ucy5sZW5ndGgpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLzQuIGdldCBmaXJzdCBjbGFzcyBvZiBzb2x1dGlvbnMgd2l0aCBzYW1lIG5yIG9mIHBvaW50cyDpgInmi6nkuI7nrKzkuIDkuKrmlrnmoYjngrnmlbDkuIDmoLflpJrnmoTmlrnmoYjvvIjlm6DkuLrnrKzkuIDkuKrmlrnmoYjngrnmlbDmnIDlsJHvvIlcclxuICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiR2V0IGZpcnN0IGNsYXNzIG9mIHNvbHV0aW9ucyB3aXRoIHNhbWUgbnIgb2YgcG9pbnRzXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvbHV0aW9ucy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiVGhpcyBpcyBub3QgcG9zc2libGVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0U29sdXRpb24gPSBzb2x1dGlvbnNbMF1bMl07IC8vcGljayBmaXJzdCBzb2x1dGlvblxyXG4gICAgICAgICAgICAgICAgdmFyIG5yT2ZQb2ludHMgPSBmaXJzdFNvbHV0aW9uLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciBzYW1lTnJQb2ludHNTb2x1dGlvbiA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgc29sdXRpb25zLmxlbmd0aDsgbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gc29sdXRpb25zW2xdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb2x1dGlvbi5sZW5ndGggPT0gbnJPZlBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1lTnJQb2ludHNTb2x1dGlvbi5wdXNoKHNvbHV0aW9uc1tsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IHNhbWVOclBvaW50c1NvbHV0aW9uO1xyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8qNS4gIOiuoeeul+i3r+W+hOWIhuaVsCDvvIzlj5bmnIDliIbmlbDpq5jnmoRcclxuICAgICAgICAgICAgICAgICBQaWNrIHRoZSBmaXJzdCBzb2x1dGlvbiB3aXRoIDkwIGRlZ3JlZSBhbmdsZXMgKGxlc3MgdHVybmFyb3VuZHMpXHJcbiAgICAgICAgICAgICAgICAgKmluIGNhc2Ugd2UgaGF2ZSBtb3JlIHRoYW4gb25lIHNvbHV0aW9uIGluIG91ciBjbGFzc1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBMb2cuaW5mbyhcInBpY2sgdGhlIGZpcnN0IHNvbHV0aW9uIHdpdGggOTAgZGVncmVlIGFuZ2xlcyAobGVzcyB0dXJuYXJvdW5kcylcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgc29sSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBzb2x1dGlvbnMubGVuZ3RoOyBsKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc29sdXRpb24gPSBzb2x1dGlvbnNbbF1bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWwuc2NvcmVQYXRoKHNvbHV0aW9uc1tzb2xJbmRleF1bMl0pIDwgVXRpbC5zY29yZVBhdGgoc29sdXRpb25zW2xdWzJdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2xJbmRleCA9IGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zID0gW3NvbHV0aW9uc1tzb2xJbmRleF1dO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vU01PT1RISU5HIGN1cnZlXHJcbiAgICAgICAgaWYgKHR5cGUgPT09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc21vb3RoQ3VydmUoc29sdXRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9FTkQgU01PT1RISU5HIGN1cnZlXHJcblxyXG4gICAgICAgIExvZy5ncm91cEVuZCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gc29sdXRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zbW9vdGhDdXJ2ZSA9IGZ1bmN0aW9uIChzb2x1dGlvbnMpIHtcclxuICAgICAgICB2YXIgb3B0aW9uID0gMztcclxuXHJcbiAgICAgICAgc3dpdGNoIChvcHRpb24pIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgLy9kbyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMTogLy9hZGQgaW50ZXJtZWRpYXRlIHBvaW50c1xyXG4gICAgICAgICAgICAgICAgLy9BZGQgdGhlIG1pZGRsZSBwb2ludCBmb3Igc3RhcnQgYW5kIGVuZCBzZWdtZW50IHNvIHRoYXQgd2UgXCJmb3JjZVwiIHRoZVxyXG4gICAgICAgICAgICAgICAgLy9jdXJ2ZSB0byBib3RoIGNvbWUgXCJwZXJwZW5kaWN1bGFyXCIgb24gYm91bmRzIGFuZCBhbHNvIG1ha2UgdGhlIGN1cnZlXHJcbiAgICAgICAgICAgICAgICAvL1wiZmxlZVwiIG1vcmUgZnJvbSBib3VuZHMgKG9uIGV4aXQpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHNvbHV0aW9ucy5sZW5ndGg7IHMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2xUdXJuaW5nUG9pbnRzID0gc29sdXRpb25zW3NdWzJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2ZpcnN0IHNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYTEgPSBzb2xUdXJuaW5nUG9pbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhMiA9IHNvbFR1cm5pbmdQb2ludHNbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0TWlkZGxlUG9pbnQgPSBVdGlsLmdldE1pZGRsZShhMSwgYTIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNvbFR1cm5pbmdQb2ludHMuc3BsaWNlKDEsIDAsIHN0YXJ0TWlkZGxlUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2xhc3Qgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhMyA9IHNvbFR1cm5pbmdQb2ludHNbc29sVHVybmluZ1BvaW50cy5sZW5ndGggLSAyXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYTQgPSBzb2xUdXJuaW5nUG9pbnRzW3NvbFR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZE1pZGRsZVBvaW50ID0gVXRpbC5nZXRNaWRkbGUoYTMsIGE0KTtcclxuICAgICAgICAgICAgICAgICAgICBzb2xUdXJuaW5nUG9pbnRzLnNwbGljZShzb2xUdXJuaW5nUG9pbnRzLmxlbmd0aCAtIDEsIDAsIGVuZE1pZGRsZVBvaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAyOiAvL3JlbW92ZSBwb2ludHNcclxuXHJcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChzb2x1dGlvbnMsIGZ1bmN0aW9uKHNvbHV0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbFR5cGUgPSBzb2x1dGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc29sVHlwZSA9PSAnczEnIHx8IHNvbFR5cGUgPT0gJ3MyJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sVHVybmluZ1BvaW50cyA9IHNvbHV0aW9uWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2xUdXJuaW5nUG9pbnRzLnNwbGljZSgxLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29sVHVybmluZ1BvaW50cy5zcGxpY2Uoc29sVHVybmluZ1BvaW50cy5sZW5ndGggLSAyLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgLypyZW1vdmUgY29saW5lYXIgcG9pbnQgZm9yIHMxIGFzIGl0IHNlZW1zIHRoYXQgbW9yZSBjb2xpbmVhciBwb2ludHMgZG8gbm90IGxvb2sgZ29vZFxyXG4gICAgICAgICAgICAgICAgICogb24gb3JnYW5pYyBzb2x1dGlvbnMgPjpEKi9cclxuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKHNvbHV0aW9ucywgZnVuY3Rpb24oc29sdXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc29sVHlwZSA9IHNvbHV0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb2xUeXBlID09ICdzMScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbFR1cm5pbmdQb2ludHMgPSBzb2x1dGlvblsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZHVjZWRTb2x1dGlvbiA9IFV0aWwuY29sbGluZWFyUmVkdWN0aW9uKHNvbFR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2x1dGlvblsyXSA9IHJlZHVjZWRTb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gLy9lbmQgc3dpdGNoXHJcblxyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0Nvbm5lY3Rpb25NYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5pel5b+X57G7XHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG5cclxuICAgIHZhciBMb2cgID0ge1xyXG4gICAgICAgIExPR19MRVZFTF9OT05FICA6IDAsXHJcblxyXG4gICAgICAgIExPR19MRVZFTF9ERUJVRyA6IDEsXHJcblxyXG4gICAgICAgIExPR19MRVZFTF9JTkZPIDogMixcclxuXHJcbiAgICAgICAgTE9HX0xFVkVMX0VSUk9SIDogMyxcclxuXHJcbiAgICAgICAgbGV2ZWwgOiB0aGlzLkxPR19MRVZFTF9FUlJPUixcclxuICAgICAgICBcclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRoZSBsZXNzIGltcG9ydGFudCBvZiBhbGwgbWVzc2FnZXNcclxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIC0gdGhlIG1lc3NhZ2UgdG8gYmUgbG9nZ2VkXHJcbiAgICAgICAgKiovXHJcbiAgICAgICAgZGVidWc6IGZ1bmN0aW9uIChtZXNzYWdlKXtcclxuICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMubGV2ZWwgPD0gdGhpcy5MT0dfTEVWRUxfREVCVUcpe1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vaW4gRkYgaXMgZGVidWdcclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZS5kZWJ1ZyA9PSAnZnVuY3Rpb24nKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZXsvL1RPRE86IGluIElFIGlzIGxvZ1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBUaGUgY29tbW9ubHkgdXNlZCBsb2cgbWVzc2FnZVxyXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgLSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWRcclxuICAgICAgICAqKi9cclxuICAgICAgICBpbmZvIDogZnVuY3Rpb24gKG1lc3NhZ2Upe1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5sZXZlbCA8PSB0aGlzLkxPR19MRVZFTF9JTkZPKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8obWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRoZSB3b3JzZSBraW5kIG9mIG1lc3NhZ2UuIFVzdWFsbHkgYSBjcmFzaFxyXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgLSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWRcclxuICAgICAgICAqKi9cclxuICAgICAgICBlcnJvciA6IGZ1bmN0aW9uIChtZXNzYWdlKXtcclxuICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMubGV2ZWwgPD0gdGhpcy5MT0dfTEVWRUxfRVJST1Ipe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKlN0YXJ0IGdyb3VwaW5nIHRoZSBsb2cgbWVzc2FnZXNcclxuICAgICAgICAgKkBwYXJhbSB7U3RyaW5nfSB0aXRsZSAtIHRoZSB0aXRsZSBvZiB0aGUgZ3JvdXBcclxuICAgICAgICAgKkBzZWUgPGEgaHJlZj1cImh0dHA6Ly9nZXRmaXJlYnVnLmNvbS9sb2dnaW5nXCI+aHR0cDovL2dldGZpcmVidWcuY29tL2xvZ2dpbmc8L2E+XHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGdyb3VwIDogZnVuY3Rpb24odGl0bGUpe1xyXG4gICAgICAgICAgICBpZih0aGlzLmxldmVsIDw9IHRoaXMuTE9HX0xFVkVMX0lORk8peyAvL2lnbm9yZSBncm91cCBpZiBsZXZlbCBub3QgZGVidWcgb3IgaW5mb1xyXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKXsgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8qKklmIHdlIGRvIG5vdCB0ZXN0IGZvciBncm91cCgpIGZ1bmN0aW9uIHlvdSB3aWxsIGdldCBhbiBlcnJvciBpbiBPcGVyYVxyXG4gICAgICAgICAgICAgICAgICAgICAqYXMgT3BlcmEgaGFzIGl0J3Mgb3duIGNvbnNvbGUuLi53aGljaCBkb2VzIG5vdCBoYXZlIGEgZ3JvdXAoKSBmdW5jdGlvbiovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUuZ3JvdXAgPT09ICdmdW5jdGlvbicpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwKHRpdGxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipFbmRzIGN1cnJlbnQgbWVzc2FnZSBncm91cGluZyovXHJcbiAgICAgICAgZ3JvdXBFbmQgOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBpZih0aGlzLmxldmVsIDw9IHRoaXMuTE9HX0xFVkVMX0lORk8peyAvL2lnbm9yZSBncm91cCBpZiBsZXZlbCBub3QgZGVidWcgb3IgaW5mb1xyXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKXtcclxuICAgICAgICAgICAgICAgICAgICAvKipJZiB3ZSBkbyBub3QgdGVzdCBmb3IgZ3JvdXBFbmQoKSBmdW5jdGlvbiB5b3Ugd2lsbCBnZXQgYW4gZXJyb3IgaW4gT3BlcmFcclxuICAgICAgICAgICAgICAgICAgICAgKmFzIE9wZXJhIGhhcyBpdCdzIG93biBjb25zb2xlLi4ud2hpY2ggZG9lcyBub3QgaGF2ZSBhIGdyb3VwKCkgZnVuY3Rpb24qL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlLmdyb3VwRW5kID09PSAnZnVuY3Rpb24nKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vTG9nLmxldmVsID0gTG9nLkxPR19MRVZFTF9ERUJVRzsgXHJcbiAgICBMb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX0VSUk9SOyBcclxuICAgIC8vTG9nLmxldmVsID0gTG9nLkxPR19MRVZFTF9FUlJPUjtcclxuICAgIC8vTG9nLmxldmVsID0gTG9nLkxPR19MRVZFTF9OT05FO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMb2c7XHJcbiAgICBcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL0xvZy5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOW4uOmHj+WumuS5iVxyXG4gKi9cclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBcdHtcclxuXHRcdEVMRU1FTlRfVFlQRTogXCJlbGVtZW50VHlwZVwiLFxyXG5cdFx0TU9ERTogXCJtb2RlXCIsXHJcblx0XHRCQUNLR1JPVU5EOiBcImJhY2tncm91ZFwiLFxyXG5cdFx0T1BUSU9OUzogXCJvcHRpb25zXCIsXHJcblx0XHRVU0VSREFUQTogXCJ1c2VyRGF0YVwiLFxyXG5cdFx0SUQ6IFwiaWRcIixcclxuXHRcdFNUQVJUX0lEOiBcInN0YXJ0Tm9kZUlkXCIsXHJcblx0XHRFTkRfSUQ6IFwiZW5kTm9kZUlkXCIsXHJcblx0XHRBTEFSTTogXCJBbGFybVwiLFxyXG5cdFx0UkVMQVRJT05JRDpcInJlbGF0aW9uSWRcIixcclxuXHRcdFJFTEFUSU9OX0lNQUdFOlwicmVsYXRpb25JbWFnZVwiLFxyXG5cdFx0R1JPVVA6IFwiR3JvdXBcIixcclxuXHRcdEdST1VQX05PREU6XCJHcm91cE5vZGVcIixcclxuXHRcdENPTk5FQ1RJT046IFwiY29ubmVjdGlvblwiLFxyXG5cdFx0Q0hJTERTOiBcImNoaWxkc1wiLFxyXG5cdFx0VFJFRV9ST09UOiBcInRyZWVSb290XCIsXHJcblx0XHRET0NLRVJTOlwib3B0aW9ucy5kb2NrZXJzXCIsXHJcblx0XHRTVFlMRV9MSU5FVFlQRTpcInN0eWxlLmxpbmVUeXBlXCIsXHJcblx0XHRMSU5FT1BFUkFUSU9OSUNPTjpcIkxpbmVPcGVyYXRpb25JY29uXCIsXHJcblx0XHRERUw6XCJERUxcIixcclxuXHRcdExJTks6XCJzdHJhaWdodFwiLFxyXG5cdFx0Rk9MRDpcImphZ2dlZFwiLFxyXG5cdFx0Q1VSVkU6XCJjdXJ2ZVwiXHJcblx0fTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi91dGlsL0Zsb3dDb25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBGbG935bel5YW357G7XHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHU5XHJcbiAqL1xyXG5cclxuICAgIHZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi9GbG93Q29uc3RhbnRzLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEdyb3VwTm9kZSA9IHJlcXVpcmUoXCIuLi9ub2RlL0dyb3VwTm9kZS5qc1wiKTtcclxuICAgIHZhciBSZWN0ID0gcmVxdWlyZShcIi4uL25vZGUvUmVjdC5qc1wiKTtcclxuICAgIHZhciBDaXJjbGUgPSByZXF1aXJlKFwiLi4vbm9kZS9DaXJjbGUuanNcIik7XHJcbiAgICB2YXIgSW1hZ2UgPSByZXF1aXJlKFwiLi4vbm9kZS9JbWFnZS5qc1wiKTtcclxuICAgIHZhciBUZXh0ID0gcmVxdWlyZShcIi4uL25vZGUvVGV4dC5qc1wiKTtcclxuICAgIHZhciBTZWN0b3IgPSByZXF1aXJlKFwiLi4vbm9kZS9TZWN0b3IuanNcIik7XHJcbiAgICB2YXIgUmluZyA9IHJlcXVpcmUoXCIuLi9ub2RlL1JpbmcuanNcIik7XHJcbiAgICB2YXIgRWxsaXBzZSA9IHJlcXVpcmUoXCIuLi9ub2RlL0VsbGlwc2UuanNcIik7XHJcbiAgICB2YXIgSGVhcnQgPSByZXF1aXJlKFwiLi4vbm9kZS9IZWFydC5qc1wiKTtcclxuICAgIHZhciBEcm9wbGV0ID0gcmVxdWlyZShcIi4uL25vZGUvRHJvcGxldC5qc1wiKTtcclxuICAgIHZhciBSb3NlID0gcmVxdWlyZShcIi4uL25vZGUvUm9zZS5qc1wiKTtcclxuICAgIHZhciBJc29nb24gPSByZXF1aXJlKFwiLi4vbm9kZS9Jc29nb24uanNcIik7XHJcbiAgICB2YXIgUG9seWdvbiA9IHJlcXVpcmUoXCIuLi9ub2RlL1BvbHlnb24uanNcIik7XHJcbiAgICB2YXIgTGluZSA9IHJlcXVpcmUoXCIuLi9ub2RlL0xpbmUuanNcIik7XHJcbiAgICB2YXIgUG9seWxpbmUgPSByZXF1aXJlKFwiLi4vbm9kZS9Qb2x5bGluZS5qc1wiKTtcclxuICAgIHZhciBCZXppZXJDdXJ2ZSA9IHJlcXVpcmUoXCIuLi9ub2RlL0JlemllckN1cnZlLmpzXCIpO1xyXG4gICAgdmFyIEFyYyA9IHJlcXVpcmUoXCIuLi9ub2RlL0FyYy5qc1wiKTtcclxuICAgIHZhciBTdGFyID0gcmVxdWlyZShcIi4uL25vZGUvU3Rhci5qc1wiKTtcclxuICAgIHZhciBUcm9jaG9pZCA9IHJlcXVpcmUoXCIuLi9ub2RlL1Ryb2Nob2lkLmpzXCIpO1xyXG4gICAgdmFyIFBhdGggPSByZXF1aXJlKFwiLi4vbm9kZS9QYXRoLmpzXCIpO1xyXG4gICAgdmFyIEljb25CdXR0b24gPSByZXF1aXJlKFwiLi4vbm9kZS9JY29uQnV0dG9uXCIpO1xyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgIHZhciBmbG93TGluayA9IHJlcXVpcmUoXCIuLi9saW5rL2Zsb3dMaW5rXCIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7nu5PngrnmlbDnu4Qg5a+85Ye6SlNPTuagvOW8j+eahOaVsOaNrlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1vZGVsIOaAu+eahOaooeWei1xyXG4gICAgICogQHJldHVybiB7SlNPTn0gSlNPTuagvOW8j+eahOaVsOaNrlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0pzb24obW9kZWwsIGdyb3VwKSB7XHJcbiAgICAgICAgdmFyIGpzb25BcnIgPSBbXTtcclxuICAgICAgICBncm91cC5lYWNoQ2hpbGQoZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUubW9kZWwpIHtcclxuICAgICAgICAgICAgICAgIC8v5aaC5p6c5piv57uE55qE6K+dXHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEdyb3VwTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZEFyciA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5tb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSBpbnN0YW5jZW9mIENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5yZWZyZXNoTW9kZWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLm1vZGVsLnNldChcIm9wdGlvbnMucG9zaXRpb25cIiwgY2hpbGROb2RlLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkQXJyLnB1c2goY2hpbGROb2RlLm1vZGVsLm9wdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLm1vZGVsLnNldChDb25zdGFudHMuQ0hJTERTLCBjaGlsZEFycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVmcmVzaE1vZGVsKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2gobm9kZS5tb2RlbC5vcHRpb24pO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9KVxyXG4gICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuQ0hJTERTLCBqc29uQXJyKTtcclxuICAgICAgICAvLyDlm77niYdaSW1hZ2XoioLngrnnmoRtb2RlbOWIoOmZpGhvc3ToioLngrksSlNPTi5zdHJpbmdpZnkoKeaKpeWvueixoeW+queOr+W8leeUqOmUmeivr1xyXG4gICAgICAgIHZhciBvcHRpb24gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RlbC5vcHRpb24pO1xyXG4gICAgICAgIG9wdGlvbi5jaGlsZHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtLm9wdGlvbnMgJiYgaXRlbS5vcHRpb25zLnN0eWxlICYmIGl0ZW0ub3B0aW9ucy5zdHlsZS5ob3N0KSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS5vcHRpb25zLnN0eWxlLmhvc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gb3B0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2uIEpTT04g55Sf5oiQ6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGZpc2hUb3BvZmxvdyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGpzb24gICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzTm9Db3VudCDmmK/lkKbpnIDopoFzdGVw6K6h5pWw77yM6buY6K6k5piv6ZyA6KaB6K6h5pWwXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21Kc29uKGZpc2hUb3BvZmxvdywgZ3JvdXAsIGNoaWxkU2hhcGVzLCBpc0NoaWxkLCBsYXlvdXRSb290Tm9kZSwgaXNOb0NvdW50KSB7XHJcbiAgICAgICAgdmFyIGNvbm5lY3RvcnMgPSBbXTtcclxuICAgICAgICAvLyAxLuWFiOWIm+W7uuiKgueCuSAg6YGN5Y6G5b2i54q2IOiOt+WPluaooeWei1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRTaGFwZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gY2hpbGRTaGFwZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChzaGFwZS5lbGVtZW50VHlwZSA9PT0gQ29uc3RhbnRzLkNPTk5FQ1RJT04pIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3RvcnMucHVzaChzaGFwZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUuZWxlbWVudFR5cGUgPT09IENvbnN0YW50cy5BTEFSTSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbGF0aW9uTm9kZSA9IGZpbmROb2RlQnlJZChmaXNoVG9wb2Zsb3cuYWxsTm9kZXMsIHNoYXBlLnJlbGF0aW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgZmlzaFRvcG9mbG93LmNyZWF0ZUFsYXJtKHJlbGF0aW9uTm9kZSwgc2hhcGUub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHNoYXBlLmVsZW1lbnRUeXBlID09PSBDb25zdGFudHMuR1JPVVBfTk9ERSkgfHwgKHNoYXBlLmVsZW1lbnRUeXBlID09PSBDb25zdGFudHMuR1JPVVApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDop6PlhrPlj43luo/liJfnu4TvvIznu4Tov57nur/ml6Dms5XljLnphY3nu4Tpl67pophcclxuICAgICAgICAgICAgICAgIC8vIHNoYXBlLm9wdGlvbnMuaWQgPSBzaGFwZS5pZDtcclxuICAgICAgICAgICAgICAgIHZhciBjcmVhdGVkR3JvdXAgPSBmaXNoVG9wb2Zsb3cuY3JlYXRlTm9kZShDb25zdGFudHMuR1JPVVAsIHNoYXBlLm9wdGlvbnMsIHNoYXBlLnVzZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZS5jaGlsZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmcm9tSnNvbihmaXNoVG9wb2Zsb3csIGNyZWF0ZWRHcm91cCwgc2hhcGUuY2hpbGRzLCB0cnVlLCBsYXlvdXRSb290Tm9kZSwgaXNOb0NvdW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyDliKTmlq3nu4ToioLngrnmmK/lkKbmnInniLboioLngrlcclxuICAgICAgICAgICAgICAgIGlmIChpc0NoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKGNyZWF0ZWRHcm91cCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpc2hUb3BvZmxvdy5hZGROb2RlKGNyZWF0ZWRHcm91cCwge30sIGlzTm9Db3VudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIOagueaNrm9wdGlvbnPliJvlu7roioLngrlcclxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9mbG93LmNyZWF0ZU5vZGUoc2hhcGUuZWxlbWVudFR5cGUsIHNoYXBlLm9wdGlvbnMsIHNoYXBlLnVzZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0NoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXNoVG9wb2Zsb3cuYWRkTm9kZShub2RlLCB7fSwgaXNOb0NvdW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUub3B0aW9ucy5sYXlvdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGUub3B0aW9ucy5sYXlvdXQubGF5b3V0ID09PSBDb25zdGFudHMuVFJFRV9ST09UKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlRm9yTGF5b3V0ID0gZmluZE5vZGVCeUlkKGZpc2hUb3BvZmxvdy5hbGxOb2Rlcywgc2hhcGUuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dFJvb3ROb2RlLnB1c2gobm9kZUZvckxheW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBmaXNoVG9wby5sYXlvdXROb2RlKFwidHJlZVwiLHtcIm5vZGVcIjpub2RlfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMi4g5YaN5Yib5bu657q/XHJcbiAgICAgICAgenJVdGlsLmVhY2goY29ubmVjdG9ycywgZnVuY3Rpb24gKGxpbmUpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IGZpbmROb2RlQnlJZChmaXNoVG9wb2Zsb3cuYWxsTm9kZXMsIGxpbmUuc3RhcnROb2RlSWQpO1xyXG4gICAgICAgICAgICB2YXIgZW5kTm9kZSA9IGZpbmROb2RlQnlJZChmaXNoVG9wb2Zsb3cuYWxsTm9kZXMsIGxpbmUuZW5kTm9kZUlkKTtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0Tm9kZSAmJiBlbmROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGluayA9IGZpc2hUb3BvZmxvdy5jcmVhdGVMaW5rKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgbGluZS5vcHRpb25zLCBsaW5lLnVzZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0NoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKGxpbmspO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXNoVG9wb2Zsb3cuYWRkTm9kZShsaW5rLCB7fSwgaXNOb0NvdW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGhpc0xpbmsgPSBmbG93TGluay5MaW5rLmNyZWF0ZUJ5UG9pbnQobGluZS5vcHRpb25zLGxpbmUudXNlckRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBncm91cC5hZGQodGhpc0xpbmspO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXNoVG9wb2Zsb3cuYWRkTm9kZSh0aGlzTGluaywge30sIGlzTm9Db3VudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2uaWTlnKhncm91cOS4reafpeaJviwgIOWboOe7hOWGheWtkOiKgueCueS5i+mXtOeahOi/nue6vyzlnKhncm91cOS4reafpeaJvuS4jeWIsCzmiYDku6XopoHlnKhhbGxOb2Rlc+mHjOmdouWPllxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBncm91cCAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlSWQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmaW5kTm9kZUJ5SWQoYWxsTm9kZXMsIG5vZGVJZCkge1xyXG4gICAgICAgIHZhciByZXROb2RlID0gbnVsbDtcclxuICAgICAgICBhbGxOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmlkID09PSBub2RlSWQpIHtcclxuICAgICAgICAgICAgICAgIHJldE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJldE5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgY2FudmFzIHdoaWNoIGhhcyBhbGwgdGhpbmcgcmVuZGVyZWRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRSZW5kZXJlZENhbnZhcyh6ciwgb3B0cykge1xyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gICAgICAgIG9wdHMucGl4ZWxSYXRpbyA9IG9wdHMucGl4ZWxSYXRpbyB8fCAxO1xyXG4gICAgICAgIG9wdHMuYmFja2dyb3VuZENvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3IgfHxcclxuICAgICAgICAgICAgXCIjRkZGRkZGXCI7XHJcbiAgICAgICAgdmFyIGxpc3QgPSB6ci5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCk7XHJcbiAgICAgICAgLy8gU3RvcCBhbmltYXRpb25zXHJcbiAgICAgICAgenJVdGlsLmVhY2gobGlzdCwgZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSBlbC5hbmltYXRvcnM7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRvcnNbaV0uc3RvcChmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4genIucGFpbnRlci5nZXRSZW5kZXJlZENhbnZhcyhvcHRzKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b0RhdGFVUkwoenIsIG9wdHMpIHtcclxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcclxuICAgICAgICB2YXIgdXJsID0gZ2V0UmVuZGVyZWRDYW52YXMoenIsIG9wdHMpLnRvRGF0YVVSTChcclxuICAgICAgICAgICAgJ2ltYWdlLycgKyAob3B0cyAmJiBvcHRzLnR5cGUgfHwgJ3BuZycpXHJcbiAgICAgICAgKTtcclxuICAgICAgICB2YXIgbGlzdCA9IHpyLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTtcclxuICAgICAgICAvLyBTdGFydCBhbmltYXRpb25zXHJcbiAgICAgICAgenJVdGlsLmVhY2gobGlzdCwgZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSBlbC5hbmltYXRvcnM7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRvcnNbaV0uc3RhcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB1cmw7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdHJ1bmNQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciB4ID0gcGFyc2VJbnQocG9zaXRpb25bMF0sIDEwKTtcclxuICAgICAgICB2YXIgeSA9IHBhcnNlSW50KHBvc2l0aW9uWzFdLCAxMCk7XHJcbiAgICAgICAgaWYgKHggPCAwKSB7XHJcbiAgICAgICAgICAgIHggPSAwXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5IDwgMCkge1xyXG4gICAgICAgICAgICB5ID0gMFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRmxvd05vZGUoZmxvd05vZGUpIHtcclxuICAgICAgICB2YXIgbm9kZUN0b3JzID0ge1xyXG4gICAgICAgICAgICBSZWN0OiBSZWN0LFxyXG4gICAgICAgICAgICBDaXJjbGU6IENpcmNsZSxcclxuICAgICAgICAgICAgSW1hZ2U6IEltYWdlLFxyXG4gICAgICAgICAgICBUZXh0OiBUZXh0LFxyXG4gICAgICAgICAgICBTZWN0b3I6IFNlY3RvcixcclxuICAgICAgICAgICAgUmluZzogUmluZyxcclxuICAgICAgICAgICAgRWxsaXBzZTogRWxsaXBzZSxcclxuICAgICAgICAgICAgSGVhcnQ6IEhlYXJ0LFxyXG4gICAgICAgICAgICBEcm9wbGV0OiBEcm9wbGV0LFxyXG4gICAgICAgICAgICBSb3NlOiBSb3NlLFxyXG4gICAgICAgICAgICBJc29nb246IElzb2dvbixcclxuICAgICAgICAgICAgUG9seWdvbjogUG9seWdvbixcclxuICAgICAgICAgICAgTGluZTogTGluZSxcclxuICAgICAgICAgICAgUG9seWxpbmU6IFBvbHlsaW5lLFxyXG4gICAgICAgICAgICBCZXppZXJDdXJ2ZTogQmV6aWVyQ3VydmUsXHJcbiAgICAgICAgICAgIEFyYzogQXJjLFxyXG4gICAgICAgICAgICBTdGFyOiBTdGFyLFxyXG4gICAgICAgICAgICBUcm9jaG9pZDogVHJvY2hvaWQsXHJcbiAgICAgICAgICAgIFBhdGg6IFBhdGgsXHJcbiAgICAgICAgICAgIEdyb3VwOiBHcm91cE5vZGUsXHJcbiAgICAgICAgICAgIEljb25CdXR0b246IEljb25CdXR0b25cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBub2RlQ3RvcnMpIHtcclxuICAgICAgICAgICAgZmxvd05vZGVbbmFtZV0gPSBub2RlQ3RvcnNbbmFtZV1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZsb3dOb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9ybWFsaXplIGNzcyBsaWtlZCBhcnJheSBjb25maWd1cmF0aW9uXHJcbiAgICAgKiBlLmcuXHJcbiAgICAgKiAgMyA9PiBbMywgMywgMywgM11cclxuICAgICAqICBbNCwgMl0gPT4gWzQsIDIsIDQsIDJdXHJcbiAgICAgKiAgWzQsIDMsIDJdID0+IFs0LCAzLCAyLCAzXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHZhbFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpemVDc3NBcnJheSh2YWwpIHtcclxuICAgICAgICB2YXIgbGVuID0gdmFsLmxlbmd0aDtcclxuICAgICAgICBpZiAodHlwZW9mICh2YWwpID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWwsIHZhbF07XHJcbiAgICAgICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcclxuICAgICAgICAgICAgLy8gdmVydGljYWwgfCBob3Jpem9udGFsXHJcbiAgICAgICAgICAgIHJldHVybiBbdmFsWzBdLCB2YWxbMV0sIHZhbFswXSwgdmFsWzFdXTtcclxuICAgICAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMykge1xyXG4gICAgICAgICAgICAvLyB0b3AgfCBob3Jpem9udGFsIHwgYm90dG9tXHJcbiAgICAgICAgICAgIHJldHVybiBbdmFsWzBdLCB2YWxbMV0sIHZhbFsyXSwgdmFsWzFdXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfdHJpbShzdHIpIHtcclxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xccyskLywgJycpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlUGVyY2VudChwZXJjZW50LCBhbGwpIHtcclxuICAgICAgICBzd2l0Y2ggKHBlcmNlbnQpIHtcclxuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcclxuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcclxuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAnNTAlJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAnMCUnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAnMTAwJSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwZXJjZW50ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAoX3RyaW0ocGVyY2VudCkubWF0Y2goLyUkLykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBlcmNlbnQpIC8gMTAwICogYWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChwZXJjZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwZXJjZW50ID09IG51bGwgPyBOYU4gOiArcGVyY2VudDtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXBwZXJDYXNlRmlyc3Q9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0NhbWVsQ2FzZShzdHIsIHVwcGVyQ2FzZUZpcnN0KSB7XHJcbiAgICAgICAgc3RyID0gKHN0ciB8fCAnJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uIChtYXRjaCwgZ3JvdXAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBncm91cDEudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKHVwcGVyQ2FzZUZpcnN0ICYmIHN0cikge1xyXG4gICAgICAgICAgICBzdHIgPSBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgcHJvcGVydHkgc3RvcmFnZSB0byBhbnkgaG9zdCBvYmplY3QuXHJcbiAgICAgKiBOb3RpY2U6IFNlcmlhbGl6YXRpb24gaXMgbm90IHN1cHBvcnRlZC5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgZXhhbXBsZTpcclxuICAgICAqIHZhciBnZXQgPSBtb2RlbFVpdGwubWFrZUdldHRlcigpO1xyXG4gICAgICpcclxuICAgICAqIGZ1bmN0aW9uIHNvbWUoaG9zdE9iaikge1xyXG4gICAgICogICAgICBnZXQoaG9zdE9iaikuX3NvbWVQcm9wZXJ0eSA9IDEyMTI7XHJcbiAgICAgKiAgICAgIC4uLlxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxyXG4gICAgICovXHJcbiAgICB2YXIgbWFrZUdldHRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gJ1xcMF9fdG9wb19wcm9wX2dldHRlcl8nICsgaW5kZXgrKztcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChob3N0T2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaG9zdE9ialtrZXldIHx8IChob3N0T2JqW2tleV0gPSB7fSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgIH0pKCk7XHJcbiAgICB2YXIgZW5jb2RlSFRNTCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKHNvdXJjZSlcclxuICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcclxuICAgICAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcclxuICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgJyYjMzk7Jyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBUUExfVkFSX0FMSUFTID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJ107XHJcblxyXG4gICAgdmFyIHdyYXBWYXIgPSBmdW5jdGlvbiAodmFyTmFtZSwgc2VyaWVzSWR4KSB7XHJcbiAgICAgICAgcmV0dXJuICd7JyArIHZhck5hbWUgKyAoc2VyaWVzSWR4ID09IG51bGwgPyAnJyA6IHNlcmllc0lkeCkgKyAnfSc7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUZW1wbGF0ZSBmb3JtYXR0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cGxcclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD58T2JqZWN0fSBwYXJhbXNMaXN0XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmNvZGU9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvcm1hdFRwbCh0cGwsIHBhcmFtc0xpc3QsIGVuY29kZSkge1xyXG4gICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkocGFyYW1zTGlzdCkpIHtcclxuICAgICAgICAgICAgcGFyYW1zTGlzdCA9IFtwYXJhbXNMaXN0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNlcmllc0xlbiA9IHBhcmFtc0xpc3QubGVuZ3RoO1xyXG4gICAgICAgIGlmICghc2VyaWVzTGVuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciAkdmFycyA9IHBhcmFtc0xpc3RbMF0uJHZhcnMgfHwgW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAkdmFycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYWxpYXMgPSBUUExfVkFSX0FMSUFTW2ldO1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gd3JhcFZhcihhbGlhcywgMCk7XHJcbiAgICAgICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKHdyYXBWYXIoYWxpYXMpLCBlbmNvZGUgPyBlbmNvZGVIVE1MKHZhbCkgOiB2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBzZXJpZXNJZHggPSAwOyBzZXJpZXNJZHggPCBzZXJpZXNMZW47IHNlcmllc0lkeCsrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgJHZhcnMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXQgPSBwYXJhbXNMaXN0W3Nlcmllc0lkeF1bJHZhcnNba11dO1xyXG4gICAgICAgICAgICAgICAgdHBsID0gdHBsLnJlcGxhY2UoXHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcFZhcihUUExfVkFSX0FMSUFTW2tdLCBzZXJpZXNJZHgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZSA/IGVuY29kZUhUTUwocmV0KSA6IHJldFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRwbDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgdG9Kc29uOiB0b0pzb24sXHJcbiAgICAgICAgZnJvbUpzb246IGZyb21Kc29uLFxyXG4gICAgICAgIHRvRGF0YVVSTDogdG9EYXRhVVJMLFxyXG4gICAgICAgIHRydW5jUG9zaXRpb246IHRydW5jUG9zaXRpb24sXHJcbiAgICAgICAgcmVnaXN0ZXJGbG93Tm9kZTogcmVnaXN0ZXJGbG93Tm9kZSxcclxuICAgICAgICBub3JtYWxpemVDc3NBcnJheTogbm9ybWFsaXplQ3NzQXJyYXksXHJcbiAgICAgICAgcGFyc2VQZXJjZW50OiBwYXJzZVBlcmNlbnQsXHJcbiAgICAgICAgdG9DYW1lbENhc2U6IHRvQ2FtZWxDYXNlLFxyXG4gICAgICAgIG1ha2VHZXR0ZXI6IG1ha2VHZXR0ZXIsXHJcbiAgICAgICAgZm9ybWF0VHBsOiBmb3JtYXRUcGwsXHJcbiAgICAgICAgZmluZE5vZGVCeUlkOiBmaW5kTm9kZUJ5SWRcclxuICAgIH07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi91dGlsL0Zsb3dVdGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog57uE77yMIOe7hOS4reWFg+e0oOeahOWdkOagh+mDveaYr+ebuOWvueS6jui/meS4que7hOeahDxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLkdyb3VwTm9kZVxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgZ3JvdXAxID0gbmV3IG5vZGUuR3JvdXAoe1xyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzYwLDUwXVxyXG4gKiAgICAgICB9KTtcclxuICpcclxuICogICAgICAgdmFyIHJlY3QxID0gbmV3IG5vZGUuUmVjdCh7XHJcbiAqICAgICAgICAgICBzaGFwZTp7d2lkdGg6MTIwLGhlaWdodDozMH0sXHJcbiAqICAgICAgICAgICBzdHlsZTp7dGV4dDpcIuagh+mimFwiLCBmaWxsOlwiI0ZGQjkwRlwiLHN0cm9rZTpcIiNiYmJiYmJcIn0sXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbMCwwXSxcclxuICogICAgICAgICAgIHNlbGVjdGFibGU6ZmFsc2VcclxuICogICAgICAgfSk7XHJcbiAqXHJcbiAqICAgICAgIHZhciByZWN0MiA9IG5ldyBub2RlLlJlY3Qoe1xyXG4gKiAgICAgICAgICAgc2hhcGU6e3dpZHRoOjEyMCxoZWlnaHQ6NjB9LFxyXG4gKiAgICAgICAgICAgc3R5bGU6e3RleHQ6XCLlhoXlrrlcIiwgZmlsbDpcIiNGRkZGRkZcIixzdHJva2U6XCIjYmJiYmJiXCJ9LFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzAsMzBdLFxyXG4gKiAgICAgICAgICAgc2VsZWN0YWJsZTpmYWxzZVxyXG4gKiAgICAgICB9KTtcclxuICpcclxuICogICAgICAgZ3JvdXAxLmFkZChyZWN0MSk7XHJcbiAqICAgICAgIGdyb3VwMS5hZGQocmVjdDIpO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQoZ3JvdXAxKTtcclxuICovXHJcblxyXG5cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIGZsb3dOb2RlID1yZXF1aXJlKCcuL2Zsb3dOb2RlJyk7XHJcblxyXG4gICAgZnVuY3Rpb24gR3JvdXBOb2RlKG9wdHMpIHtcclxuICAgICAgICB0aGlzLm1vZGVsID0gZmxvd05vZGUuZ2VuTW9kZWwoXCJHcm91cE5vZGVcIiwgb3B0cyk7XHJcbiAgICAgICAgZ3JhcGhpYy5Hcm91cC5jYWxsKHRoaXMsIG9wdHMpO1xyXG5cclxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogNSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogNSxcclxuICAgICAgICAgICAgICAgIHI6IDVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICdyZ2JhKDAsMCwwLDApJywvLycjZjlmOWY5JyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJ3JnYmEoMCwwLDAsMCknLy8nI2JiYmJiYidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcG9zaXRpb246IFswLCAwXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0genJVdGlsLm1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRzLCB0cnVlKTtcclxuICAgICAgICAvL+WHveaVsOaXoOazlWNsb25lIOWOn+Wei2Nsb25l5LiN5LiKXHJcbiAgICAgICAgdGhpcy5vcHRpb25zLmxheW91dCA9IG9wdHMubGF5b3V0O1xyXG4gICAgICAgIHRoaXMubWF4ID0gWzEwMjQsIDk2MF07XHJcbiAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5vcHRpb25zKTtcclxuICAgIH1cclxuICAgIEdyb3VwTm9kZS5SRUNUX05BTUUgPSBcIkdST1VQX1JFQ1RfTkFNRVwiO1xyXG4gICAgR3JvdXBOb2RlLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogR3JvdXBOb2RlLFxyXG4gICAgICAgIHR5cGU6IFwiR3JvdXBOb2RlXCIsXHJcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAobW9kZWwpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiBtb2RlbC5zaGFwZSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiBtb2RlbC5zdHlsZSxcclxuICAgICAgICAgICAgICAgIC8vc2lsZW50OnRydWUsIC8v5Yqg5LiK5ZCOIOaLluWKqCDnu4TkuK3msqHmnInlrZDlhYPntKDnmoTlnLDmlrkg5peg5rOV5omL5Yqo5LqGXHJcbiAgICAgICAgICAgICAgICB6OiAxXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZWN0Lm5hbWUgPSBHcm91cE5vZGUuUkVDVF9OQU1FO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChyZWN0KTtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG1vZGVsLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLm1lcmdlZEltYWdlID0gbW9kZWwubWVyZ2VkSW1hZ2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWN0Q29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSB1dGlsLmdldFJlY3QodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZWN0LmJvdW5kaW5nUmVjdC5jb250YWluKHgsIHkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFkZDogZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kb0FkZChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYXBpICYmIHRoaXMuX2FwaS5fYWRkR3JvdXBOb2RlKHRoaXMsY2hpbGQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6YGN5Y6G57uE5Lit5q+P5LiA5Liq5a2Q6IqC54K5XHJcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiIOWbnuiwg+WHveaVsGNiXHJcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBjb250ZXh0ICAg5LiK5LiL5paHY29udGV4dFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubmFtZSAhPSBHcm91cE5vZGUuUkVDVF9OQU1FKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBjaGlsZCwgaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyDorr7nva4gZ3JvdXDkuK3moYblvaLlpKflsI/kuLogZ3JvdXDnmoTljIXlm7TlkoxcclxuICAgICAgICB3aWxsUmVuZGVyOmZ1bmN0aW9uIChhcGkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXlvdXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGF5b3V0KHRoaXMub3B0aW9ucy5sYXlvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJvcGVydGllcyh7XHJcbiAgICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwaSA9IGFwaTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXRMYXlvdXQ6IGZ1bmN0aW9uKExheW91dCkge1xyXG4gICAgICAgICAgICBMYXlvdXQucnVuKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldFJlY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgIHZhciBjbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGg7XHJcbiAgICAgICAgICAgIC8vIOiKgueCueijgeWJquWQju+8jOS7peijgeWJquiKgueCueWMheWbtOebkuS4uuWHhlxyXG4gICAgICAgICAgICBpZiAoY2xpcFBhdGgpIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kaW5nUmVjdCA9IGNsaXBQYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8v5Yib5bu65pyA5bCP5YyF5Zu055uS6Jma57q/XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgcG9pbnRzWzBdID0gWy1ib3VuZGluZ1JlY3Qud2lkdGggLyAyLCAtYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG4gICAgICAgICAgICBwb2ludHNbMV0gPSBbYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgLWJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICAgICAgcG9pbnRzWzJdID0gW2JvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICAgICAgcG9pbnRzWzNdID0gWy1ib3VuZGluZ1JlY3Qud2lkdGggLyAyLCBib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgICAgIHBvaW50c1s0XSA9IFstYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgLWJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBib3VuZFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHRoaXMucG9zaXRpb25bMF0sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdLFxyXG4gICAgICAgICAgICAgICAgYm91bmRpbmdSZWN0LndpZHRoLCBib3VuZGluZ1JlY3QuaGVpZ2h0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IHRoaXMucG9zaXRpb25bMF0gKyBib3VuZGluZ1JlY3Qud2lkdGggLyAyLFxyXG4gICAgICAgICAgICAgICAgeTogdGhpcy5wb3NpdGlvblsxXSArIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogYm91bmRpbmdSZWN0LmhlaWdodCxcclxuICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxyXG4gICAgICAgICAgICAgICAgYm91bmRpbmdSZWN0OiBib3VuZFJlY3RcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOaLluaLvee7hOWGheiKgueCueeahOaXtuWAme+8jOWKqOaAgeabtOaUueiDjOaZr3JlY3TnmoTlpKflsI9cclxuICAgICAgICAgKiBAcGFyYW0gbm9kZU1lc3NhZ2Ug5ouW5ou955qE57uE5YaF6IqC54K555qE5L+h5oGvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbW9kaWZ5R3JvdXBSZWN0OiBmdW5jdGlvbiAobm9kZU1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgLy8xLumHjee9ruiDjOaZr3JlY3Qg55qE6ZW/5a69XHJcbiAgICAgICAgICAgIHZhciBtaW5MZW5ndGggPSB0aGlzLm9wdGlvbnMuc2hhcGUucjtcclxuICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG1pbkxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG1pbkxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICByOiBtaW5MZW5ndGhcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHpyVXRpbC5jbG9uZShub2RlTWVzc2FnZS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBib3VuZGluZ1JlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBib3VuZGluZ1JlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgcmVjdFNoYXBlID0ge1xyXG4gICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgIHk6IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKG5vZGVNZXNzYWdlLm5vZGUgaW5zdGFuY2VvZiBHcm91cE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJlY3RTaGFwZSA9IG5vZGVNZXNzYWdlLm5vZGUuY2hpbGRPZk5hbWUoR3JvdXBOb2RlLlJFQ1RfTkFNRSkuc2hhcGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9zaXRpb24gPSBbcG9zaXRpb25bMF0gKyByZWN0U2hhcGUueCwgcG9zaXRpb25bMV0gKyByZWN0U2hhcGUueV07XHJcbiAgICAgICAgICAgIHZhciBtaW5YID0gcG9zaXRpb25bMF0sXHJcbiAgICAgICAgICAgICAgICBtaW5ZID0gcG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgIHZhciBtYXhYID0gcG9zaXRpb25bMF0sXHJcbiAgICAgICAgICAgICAgICBtYXhZID0gcG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgIHZhciBtYXhYTm9kZSA9IG5vZGVNZXNzYWdlLm5vZGUsIG1heFlOb2RlID0gbm9kZU1lc3NhZ2Uubm9kZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuW2ldIGluc3RhbmNlb2YgQ29ubmVjdG9yIHx8IHRoaXMuX2NoaWxkcmVuW2ldLmlzSWNvbiA9PSB0cnVlIHx8IHRoaXMuX2NoaWxkcmVuW2ldLm5hbWUgPT09IEdyb3VwTm9kZS5SRUNUX05BTUUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkUG9zaXRpb24gPSB6clV0aWwuY2xvbmUodGhpcy5fY2hpbGRyZW5baV0ucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbltpXSBpbnN0YW5jZW9mIEdyb3VwTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSB6clV0aWwuY2xvbmUodGhpcy5fY2hpbGRyZW5baV0uY2hpbGRPZk5hbWUoR3JvdXBOb2RlLlJFQ1RfTkFNRSkuc2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFBvc2l0aW9uID0gW2NoaWxkUG9zaXRpb25bMF0gKyBzaGFwZS54LCBjaGlsZFBvc2l0aW9uWzFdICsgc2hhcGUueV1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pblggPiB0aGlzLl9jaGlsZHJlbltpXS5wb3NpdGlvblswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5YID0gdGhpcy5fY2hpbGRyZW5baV0ucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhYIDwgdGhpcy5fY2hpbGRyZW5baV0ucG9zaXRpb25bMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHRoaXMuX2NoaWxkcmVuW2ldLnBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhYTm9kZSA9IHRoaXMuX2NoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWluWSA+IHRoaXMuX2NoaWxkcmVuW2ldLnBvc2l0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblkgPSB0aGlzLl9jaGlsZHJlbltpXS5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heFkgPCB0aGlzLl9jaGlsZHJlbltpXS5wb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhZID0gdGhpcy5fY2hpbGRyZW5baV0ucG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFlOb2RlID0gdGhpcy5fY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOWmguaenOe7hOiKgueCueiHquWumuS5ieS6hnNoYXBl5a696auY77yM5oyJ54Wn6Ieq5a6a5LmJ6YWN572u6K6h566XXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNoYXBlICYmIHRoaXMuc2hhcGUud2lkdGggJiYgdGhpcy5zaGFwZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlUmVjdCA9IG5vZGVNZXNzYWdlLm5vZGUuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHRoaXMuc2hhcGUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLnNoYXBlLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIGlmIChtaW5YIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoICs9IE1hdGguYWJzKG1pblgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWzBdID0gbWluWDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdE1heFggPSBtYXhYTm9kZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF4WCArIHJlY3RNYXhYLndpZHRoICsgTWF0aC5hYnMobWluWCkgPiB3aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSAobWF4WCArIHJlY3RNYXhYLndpZHRoICsgTWF0aC5hYnMobWluWCkgLSB3aWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1pblkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICs9IE1hdGguYWJzKG1pblkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWzFdID0gbWluWTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdE1heFkgPSBtYXhZTm9kZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF4WSArIHJlY3RNYXhZLmhlaWdodCArIE1hdGguYWJzKG1pblkpID4gaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCArPSAobWF4WSArIHJlY3RNYXhZLmhlaWdodCArIE1hdGguYWJzKG1pblkpIC0gaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4WCA+IHdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBtYXhYICsgbWF4WE5vZGUuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4WSA+IGhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IG1heFkgKyBtYXhZTm9kZS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZVJlY3Qud2lkdGggKyBwb3NpdGlvblswXSA+IHdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBub2RlUmVjdC53aWR0aCArIHBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVSZWN0LmhlaWdodCArIHBvc2l0aW9uWzFdID4gaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gbm9kZVJlY3QuaGVpZ2h0ICsgcG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5vZGVNZXNzYWdlLm5vZGUuYWxhcm0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdBbGFybVBvc2l0aW9uID0gW3Bvc2l0aW9uWzBdICsgbm9kZU1lc3NhZ2Uubm9kZS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtIChub2RlTWVzc2FnZS5ub2RlLmFsYXJtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtIDYpLCBwb3NpdGlvblsxXSAtIG5vZGVNZXNzYWdlLm5vZGUuYWxhcm0uZ2V0Qm91bmRpbmdSZWN0KClcclxuICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0IC0gM1xyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIG5vZGVNZXNzYWdlLm5vZGUuYWxhcm0uYXR0cihcInBvc2l0aW9uXCIsIG5ld0FsYXJtUG9zaXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8v5pS55Y+Y6IOM5pmvcmVjdOeahOmVv+WuveWSjOS9jee9rlxyXG4gICAgICAgICAgICB0aGlzLnNldFByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgeDogcG9zaXRpb25bMF0gPCAwID8gcG9zaXRpb25bMF0gOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHBvc2l0aW9uWzFdIDwgMCA/IHBvc2l0aW9uWzFdIDogMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFByb3BlcnRpZXM6IGZ1bmN0aW9uIChvcHQpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNoaWxkT2ZOYW1lKEdyb3VwTm9kZS5SRUNUX05BTUUpO1xyXG4gICAgICAgICAgICByZWN0LnNldFNoYXBlKG9wdC5zaGFwZSk7XHJcbiAgICAgICAgICAgLy8gcmVjdC5hdHRyKFwic3R5bGVcIiwgb3B0LnN0eWxlKTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyKCdwb3NpdGlvbicsIG9wdC5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgLy8gdGhpcy5hdHRyKFwic2hhcGVcIiwgb3B0LnNoYXBlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRwYXJlbnRJZ25vcmU6IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQuaWdub3JlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOe7p+e7reWQkeS4iumBjeWOhlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldHBhcmVudElnbm9yZShub2RlLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaG93Q2hpbGRyZW5SZWxhdGlvbkltYWdlOiBmdW5jdGlvbihncm91cE5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICBncm91cE5vZGUuX2NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuX3JlbGF0aW9uSW1hZ2UgJiYgbm9kZS5pZ25vcmUgPT09IHRydWUgJiYgIXRoYXQuZ2V0cGFyZW50SWdub3JlKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fcmVsYXRpb25JbWFnZS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEdyb3VwTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2hvd0NoaWxkcmVuUmVsYXRpb25JbWFnZShub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoaWRlQ2hpbGRyZW5SZWxhdGlvbkltYWdlOiBmdW5jdGlvbihncm91cE5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICBncm91cE5vZGUuX2NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuX3JlbGF0aW9uSW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLl9yZWxhdGlvbkltYWdlLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgR3JvdXBOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5oaWRlQ2hpbGRyZW5SZWxhdGlvbkltYWdlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNhbGN1bGF0ZVJlbGF0aW9uSW1hZ2U6IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSBub2RlLl9yZWxhdGlvbkltYWdlLmdldFJlY3QgPyBub2RlLl9yZWxhdGlvbkltYWdlLmdldEJvdW5kaW5nUmVjdCgpIDogdXRpbC5nZXRSZWN0KG5vZGUuX3JlbGF0aW9uSW1hZ2UpO1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoIHx8IDMwO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgfHwgMzA7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHpyVXRpbC5jbG9uZShub2RlLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0genJVdGlsLmNsb25lKG5vZGUuY2hpbGRPZk5hbWUoR3JvdXBOb2RlLlJFQ1RfTkFNRSkuc2hhcGUpO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQgaW5zdGFuY2VvZiBHcm91cE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uWzBdICs9IHV0aWwuZ2V0UGFyZW50WChub2RlLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvblsxXSArPSB1dGlsLmdldFBhcmVudFkobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8v6K6h566X5ZCI5bm25ZCO55qE5bCP5Zu+54mH55qEcG9zaXRpb25cclxuICAgICAgICAgICAgdmFyIHJlbGF0aW9uSW1hZ2VQb3NpdGlvbiA9IFtwb3NpdGlvblswXSArIHNoYXBlLnggKyAoc2hhcGUud2lkdGggLyAyIC0gd2lkdGggLyAyKSwgcG9zaXRpb25bMV0gKyBzaGFwZS55ICsgKHNoYXBlLmhlaWdodCAvIDIgLSBoZWlnaHQgLyAyKV07XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGlvbkltYWdlUG9zaXRpb25cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNhbGN1bGF0ZUdyb3VwTm9kZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZVBvc2l0aW9uID0genJVdGlsLmNsb25lKHRoaXMuX3JlbGF0aW9uSW1hZ2UucG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VSZWN0ID0gdGhpcy5fcmVsYXRpb25JbWFnZS5nZXRSZWN0ID8gdGhpcy5fcmVsYXRpb25JbWFnZS5nZXRCb3VuZGluZ1JlY3QoKSA6IHV0aWwuZ2V0UmVjdCh0aGlzLl9yZWxhdGlvbkltYWdlKTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0genJVdGlsLmNsb25lKHRoaXMuY2hpbGRPZk5hbWUoR3JvdXBOb2RlLlJFQ1RfTkFNRSkuc2hhcGUpO1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBpbWFnZVJlY3Qud2lkdGggfHwgMzA7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBpbWFnZVJlY3QuaGVpZ2h0IHx8IDMwO1xyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBbXTtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSBbaW1hZ2VQb3NpdGlvblswXSAtIHNoYXBlLnggLSAoc2hhcGUud2lkdGggLyAyIC0gd2lkdGggLyAyKSwgaW1hZ2VQb3NpdGlvblsxXSAtIHNoYXBlLnkgLSAoc2hhcGUuaGVpZ2h0IC8gMiAtIGhlaWdodCAvIDIpXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50IGluc3RhbmNlb2YgR3JvdXBOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvblswXSAtPSB1dGlsLmdldFBhcmVudFgodGhpcy5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25bMV0gLT0gdXRpbC5nZXRQYXJlbnRZKHRoaXMucGFyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWZyZXNoUmVsYXRpb25JbWFnZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHJlZnJlc2ggPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEdyb3VwTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUgaW5zdGFuY2VvZiBHcm91cE5vZGUgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLmlnbm9yZSAmJiBjaGlsZE5vZGUuX3JlbGF0aW9uSW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHRoYXQuY2FsY3VsYXRlUmVsYXRpb25JbWFnZShjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5fcmVsYXRpb25JbWFnZS5hdHRyKFwicG9zaXRpb25cIiwgcmVjdC5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoKGNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlZnJlc2godGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtZXJnZWQ6IGZ1bmN0aW9uIChmbG93KSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgLy/nu5nlsI/lm77niYforr7nva7lsZ7mgKfvvIzpmpDol49ncm91cFxyXG4gICAgICAgICAgICB2YXIgcmVsYXRpb25JbWFnZVJlY3QgPSB0aGlzLmNhbGN1bGF0ZVJlbGF0aW9uSW1hZ2UodGhpcyk7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlbGF0aW9uSW1hZ2VSZWN0LndpZHRoO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcmVsYXRpb25JbWFnZVJlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpb25JbWFnZVBvc2l0aW9uID0gcmVsYXRpb25JbWFnZVJlY3QucG9zaXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbGF0aW9uSW1hZ2UuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgIGltYWdlOiB0aGlzLm1lcmdlZEltYWdlLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbGF0aW9uSW1hZ2UuYXR0cihcInBvc2l0aW9uXCIsIHJlbGF0aW9uSW1hZ2VQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVDaGlsZHJlblJlbGF0aW9uSW1hZ2UodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWxhdGlvbkltYWdlLnNob3coKTtcclxuICAgICAgICAgICAgICAgIGlmIChmbG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvdy5fY3JlYXRlUmVsYXRpb25JbWFnZUxpbmUodGhpcy5fcmVsYXRpb25JbWFnZSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8v5Y+M5Ye75Zu+54mH5pS+5Ye657uEXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbGF0aW9uSW1hZ2Uub24oXCJkYmxjbGlja1wiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvL+iuvue9rue7hOeahOS9jee9ruagueaNruWwj+WbvueJh+eahOWBj+enu+mHj+adpeiuoeeul1xyXG4gICAgICAgICAgICAgICAgdGhhdC5hdHRyKCdwb3NpdGlvbicsIHRoYXQuY2FsY3VsYXRlR3JvdXBOb2RlKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnNob3coKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuc2hvd0NoaWxkcmVuUmVsYXRpb25JbWFnZSh0aGF0KTtcclxuICAgICAgICAgICAgICAgIC8vIOe7hOiKgueCueebuOWFs+i/nuaOpeeCueWxleekulxyXG4gICAgICAgICAgICAgICAgaWYgKGZsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDliKDpmaTlm77niYfoioLngrnnmoTov57nur9cclxuICAgICAgICAgICAgICAgICAgICBmbG93Ll9yZW1vdmVSZWxhdGlvbkltYWdlTGluZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDlsZXnpLrov57nur9cclxuICAgICAgICAgICAgICAgICAgICBmbG93LnRvZ2dsZUFsbENvbk5vZGVMaW5lKHRoYXQsICdzaG93Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5Yi35paw6L+e57q/XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvdy5fcmVjdXJlUmVmcmVzaExpbmUodGhhdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVsYXRpb25JbWFnZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLm9wdGlvbnMuc2hhcGU7XHJcbiAgICAgICAgICAgIHZhciBuZXdXID0gTnVtYmVyKHNoYXBlLndpZHRoICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBuZXdIID0gTnVtYmVyKG5ld1cgKiBzaGFwZS5oZWlnaHQgLyBzaGFwZS53aWR0aCk7XHJcbiAgICAgICAgICAgIGlmIChpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdXID0gcGFyc2VJbnQobmV3VywgMTApO1xyXG4gICAgICAgICAgICAgICAgbmV3SCA9IHBhcnNlSW50KG5ld0gsIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDmjInmr5TkvovnvKnmlL5cclxuICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG5ld1csXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdIXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyDmm7TmlrDnu4TlhoXoioLngrlcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdi5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmICh2Lm5hbWUgIT09IEdyb3VwTm9kZS5SRUNUX05BTUUgJiYgISh2IGluc3RhbmNlb2YgQ29ubmVjdG9yKSAmJiB2LnR5cGUgIT09ICdaUGF0aCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmr4/kuKroioLngrnnmoRwb3NpdGlvbuabtOaWsFxyXG4gICAgICAgICAgICAgICAgICAgIHYudXBkYXRlU2hhcGUocmF0aW8sIGlmUGFyc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYuYXR0cigncG9zaXRpb24nLCBbcG9zaXRpb25bMF0gKiBzY2FsZVJhdGlvLCBwb3NpdGlvblsxXSAqIHNjYWxlUmF0aW9dKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodi50eXBlID09PSAnWlBhdGgnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB2LnJlY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdC5oZWlnaHQgPSByZWN0LmhlaWdodCAqIHNjYWxlUmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdC53aWR0aCA9IHJlY3Qud2lkdGggKiBzY2FsZVJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgIHYuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbcG9zaXRpb25bMF0gKiBzY2FsZVJhdGlvLCBwb3NpdGlvblsxXSAqIHNjYWxlUmF0aW9dLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0OiByZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoR3JvdXBOb2RlLCBncmFwaGljLkdyb3VwKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JvdXBOb2RlO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgYWRkXHJcbiAqIOWwhuiKgueCueWKoOWFpeWIsOi/meS4que7hOS4reacgOWQjlxyXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSDmrLLmt7vliqDliLDnu4TnmoToioLngrlcclxuICovXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHJlbW92ZUFsbFxyXG4gKiDnp7vpmaTmiYDmnInlrZDoioLngrlcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCByZW1vdmVcclxuICog56e76Zmk5omA5pyJ5a2Q6IqC54K5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGlsZCDlrZDoioLngrlcclxuICovXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGNoaWxkT2ZOYW1lXHJcbiAqIOiOt+WPluaMh+WumuWQjeWtl+eahOWEv+WtkOiKgueCuVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IOiKgueCuVxyXG4gKi9cclxuLyoqXHJcbiAqIEBtZXRob2QgdHJhdmVyc2VcclxuICog5rex5bqm5LyY5YWI6YGN5Y6G5omA5pyJ5a2Q5a2Z6IqC54K577yIZWFjaOWPqumBjeWOhuWtkOiKgueCue+8iVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IOiKgueCuVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtTdHJpbmd9IG1lcmdlZEltYWdlPScnICDmjqfliLblvZPlj4zlh7vml7Yg57uE5Y+v5Lul57yp5bCP5Li65oyH5a6a55qE5Zu+5b2i44CCXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjZmcge0Jvb2xlYW59IGNoaWxkRHJhZ2dhYmxlPWZhbHNlICDmjqfliLbnu4TlhoXmiJDlkZjmmK/lkKblj6/ku6Xmi5bliqhcclxuICovXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9Hcm91cE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxyXG4gKiBmaXNoVG9wb0Zsb3fnmoRub2Rl5a+56LGh77yM5qGG5p625o+Q5L6b55qE6IqC54K56YO95pS+5Zyo6L+Z5Liq5a+56LGh5LiL44CC6YCa6L+HZXh0ZW5k5pa55rOV5Yib5bu66Ieq5a6a5LmJ6IqC54K5PGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGVcclxuICogQGFic3RyYWN0XHJcbiAqXHJcbiAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICpcclxuICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gICAgKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAgICAqICAgICAgdmFyIERpYW1vbmQgPSBub2RlLmV4dGVuZCh7XHJcbiAgICAqICAgICAgICAgIHR5cGU6ICdEaWFtb25kJyxcclxuICAgICogICAgICAgICAgc2hhcGU6IHtcclxuICAgICogICAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgKiAgICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAqICAgICAgICAgIH0sXHJcbiAgICAqICAgICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XHJcbiAgICAqICAgICAgICAgICAgICB2YXIgY3ggPSAwO1xyXG4gICAgKiAgICAgICAgICAgICAgdmFyIGN5ID0gMDtcclxuICAgICogICAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoIC8gMjtcclxuICAgICogICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQgLyAyO1xyXG4gICAgKiAgICAgICAgICAgICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcclxuICAgICogICAgICAgICAgICAgIHBhdGgubGluZVRvKGN4ICsgd2lkdGgsIGN5KTtcclxuICAgICogICAgICAgICAgICAgIHBhdGgubGluZVRvKGN4LCBjeSArIGhlaWdodCk7XHJcbiAgICAqICAgICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSk7XHJcbiAgICAqICAgICAgICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xyXG4gICAgKiAgICAgICAgICB9XHJcbiAgICAqICAgICAgfSk7XHJcbiAgICAqICAgICAgICB2YXIgZGlhbW9kID0gbmV3IERpYW1vbmQoe1xyXG4gICAgKiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAqICAgICAgICAgICAgICAgIHdpZHRoOjUwLFxyXG4gICAgKiAgICAgICAgICAgICAgICBoZWlnaHQ6NTBcclxuICAgICogICAgICAgICAgICB9LFxyXG4gICAgKiAgICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF1cclxuICAgICogICAgICAgIH0pXHJcbiAgICAqICAgICAgICBmaXNoVG9wby5hZGQoZGlhbW9kKTtcclxuICovXHJcblxyXG4gICAgdmFyIFBhdGggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1BhdGgnKTtcclxuICAgIHZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi4vdXRpbC9GbG93Q29uc3RhbnRzLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21vZGVsLmpzXCIpO1xyXG4gICAgdmFyIGZsb3dOb2RlID0ge307XHJcbiAgICAvKipcclxuICAgICAqIOaehOmAoOaooeWei1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZmxvd05vZGUuZ2VuTW9kZWwgPSBmdW5jdGlvbiAodHlwZSwgb3B0cykge1xyXG4gICAgICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbCh7fSk7XHJcbiAgICAgICAgLy8g5rKh5pyJaWTnmoTml7blgJnvvIznvLrlsJHnu5nkuIDkuKpVVUlE44CC5Yib5bu66IqC54K55oiW6ICF5Y+N5bqP5YiX5YyW55qE5pe25YCZIOiKgueCueeahElE5Y+W55qE5pivb3B0cy5pZFxyXG5cdFx0aWYgKCFvcHRzLmlkKSB7XHJcblx0XHRcdG9wdHMuaWQgPSB1dGlsLmdldFVVSUQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdHMuc3R5bGUgJiYgb3B0cy5zdHlsZS50ZXh0TGluZUhlaWdodCAhPT0gMCAmJiAhb3B0cy5zdHlsZS5yaWNoKSB7IC8vIzE3MFxyXG4gICAgICAgICAgICBvcHRzLnN0eWxlLnJpY2ggPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbW9kZWwuc2V0KENvbnN0YW50cy5FTEVNRU5UX1RZUEUsIHR5cGUpO1xyXG4gICAgICAgIC8vIOmYsuatoiBuZXcgZWwuY29uc3RydWN0b3IoeyBzdHlsZTogZWwuc3R5bGUsc2hhcGU6IGVsLnNoYXBlIH0pOyB6clV0aWwuY2xvbmXmiqXplJlcclxuICAgICAgICBpZiAob3B0cy5zdHlsZSAmJiBvcHRzLnN0eWxlLmhvc3QpIHtcclxuICAgICAgICAgICAgZGVsZXRlIG9wdHMuc3R5bGUuaG9zdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbW9kZWwuc2V0KENvbnN0YW50cy5PUFRJT05TLCB6clV0aWwuY2xvbmUob3B0cykpO1xyXG4gICAgICAgIGlmIChcImRyYWdnYWJsZVwiIGluIG9wdHMpIHtcclxuICAgICAgICAgICAgb3B0cy5pc2RyYWdnYWJsZSA9IG9wdHMuZHJhZ2dhYmxlO1xyXG4gICAgICAgICAgICBkZWxldGUgb3B0cy5kcmFnZ2FibGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb3B0cy56KSB7XHJcbiAgICAgICAgICAgIG9wdHMueiA9IDE7IC8v6IqC54K56buY6K6k5Li6Me+8jOe6v+autTA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChvcHRzLmhvdmVyQW5pbWF0aW9uKSkge1xyXG4gICAgICAgICAgICBvcHRzLmhvdmVyQW5pbWF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChvcHRzLnNlbGVjdGFibGUpKSB7XHJcbiAgICAgICAgICAgIG9wdHMuc2VsZWN0YWJsZSA9IHRydWU7ICAvL+m7mOiupOWPr+S7pemAieS4rVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbW9kZWw7XHJcbiAgICB9XHJcblxyXG4gICAgZmxvd05vZGUuYWRkSG92ZXJBbmltYXRpb24gPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgdmFyIHNjYWxlID0genJVdGlsLmNsb25lKG5vZGUuc2NhbGUpIHx8IFsxLDFdO1xyXG4gICAgICAgIHZhciBvbkVtcGhhc2lzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVRvKHtcclxuICAgICAgICAgICAgICAgIHNjYWxlOiBbc2NhbGVbMF0gKiAxLjEsIHNjYWxlWzFdICogMS4xXVxyXG4gICAgICAgICAgICB9LCA0MDAsICdlbGFzdGljT3V0Jyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgb25Ob3JtYWwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRlVG8oe1xyXG4gICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlXHJcbiAgICAgICAgICAgIH0sIDQwMCwgJ2VsYXN0aWNPdXQnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIG5vZGUub24oJ21vdXNlb3ZlcicsIG9uRW1waGFzaXMpXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBvbk5vcm1hbClcclxuICAgICAgICAgICAgLm9uKCdlbXBoYXNpcycsIG9uRW1waGFzaXMpXHJcbiAgICAgICAgICAgIC5vbignbm9ybWFsJywgb25Ob3JtYWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBleHRlbmRcclxuICAgICAqIOaJqeWxleS4gOS4qiDoh6rlrprkuYnoioLngrksIOavlOWmgumSu+efs+W9ouetieOAglxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMudHlwZSDoh6rlrprkuYnnu5PoioLnmoTlkI3np7AgUGF0aCB0eXBlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMuaW5pdF0g5Yid5aeL5YyWIEluaXRpYWxpemVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3BzLmJ1aWxkUGF0aCDov5vooYzmnoTlu7roioLngrkgT3ZlcndyaXRlIGJ1aWxkUGF0aCBtZXRob2RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc3R5bGVdIOe8uuecgeagt+W8jyBFeHRlbmRlZCBkZWZhdWx0IHN0eWxlIGNvbmZpZ1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zaGFwZV0g57y655yB6IqC54K55Y+C5pWwIEV4dGVuZGVkIGRlZmF1bHQgc2hhcGUgY29uZmlnXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBmbG93Tm9kZS5leHRlbmQgPSBmdW5jdGlvbiAoZGVmYXVsdHMpIHtcclxuICAgICAgICB2YXIgU3ViID0gZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IGZsb3dOb2RlLmdlbk1vZGVsKGRlZmF1bHRzLnR5cGUsIG9wdHMpO1xyXG4gICAgICAgICAgICBQYXRoLmNhbGwodGhpcywgb3B0cyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVmYXVsdHMuc3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4dGVuZCBkZWZhdWx0IHN0eWxlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLmV4dGVuZEZyb20oZGVmYXVsdHMuc3R5bGUsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRXh0ZW5kIGRlZmF1bHQgc2hhcGVcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xyXG4gICAgICAgICAgICBpZiAoZGVmYXVsdFNoYXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gdGhpcy5zaGFwZSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHZhciB0aGlzU2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0U2hhcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXNTaGFwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGRlZmF1bHRTaGFwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzU2hhcGVbbmFtZV0gPSBkZWZhdWx0U2hhcGVbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0cy5pbml0ICYmIGRlZmF1bHRzLmluaXQuY2FsbCh0aGlzLCBvcHRzKTtcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgenJVdGlsLmluaGVyaXRzKFN1YiwgUGF0aCk7XHJcblxyXG4gICAgICAgIC8vIEZJWE1FIOS4jeiDvSBleHRlbmQgcG9zaXRpb24sIHJvdGF0aW9uIOetieW8leeUqOWvueixoVxyXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcclxuICAgICAgICAgICAgLy8gRXh0ZW5kaW5nIHByb3RvdHlwZSB2YWx1ZXMgYW5kIG1ldGhvZHNcclxuICAgICAgICAgICAgaWYgKG5hbWUgIT09ICdzdHlsZScgJiYgbmFtZSAhPT0gJ3NoYXBlJykge1xyXG4gICAgICAgICAgICAgICAgU3ViLnByb3RvdHlwZVtuYW1lXSA9IGRlZmF1bHRzW25hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOmHjeWGmXNldFN0eWxlXHJcbiAgICAgICAgU3ViLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBrZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdHlsZS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xyXG4gICAgICAgICAgICB6clV0aWwubWVyZ2UodGhpcy5tb2RlbC5nZXQoXCJvcHRpb25zLnN0eWxlXCIpLCBvcHRpb25zLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gU3ViO1xyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmxvd05vZGU7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBjZmcge0FycmF5fSBwb3NpdGlvbiDoioLngrnnmoTkvY3nva4s57uf5LiA5L2/55SocG9zaXRpb27ov5vooYzlrprkvY1beCx5XSBlZy4gWzEwMCwxMDBdXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjZmcge09iamVjdH0gc3R5bGUg5qC35byP5Y+C5pWwXHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUuZmlsbD0jMDAwIOWhq+WFheiJsiBlZy4jNUM5QUQzIHwgcmdiKDAsMjAwLDI1NSkgfCByZ2JhKDAsMjAwLDI1NSwwLjYpIHwgcmVkIHwgZ3JhZGllbnQg5rOo77ya5Y2V54us5paH5a2X5L2/55SodGV4dEZpbGxcclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS5zdHJva2U9bnVsbCDnrJTnlLvpopzoibIgZWcuIzVDOUFEMyB8IHJnYigwLDIwMCwyNTUpIHwgcmdiYSgwLDIwMCwyNTUsMC42KSB8IHJlZCB8IGdyYWRpZW50IOazqO+8muWNleeLrOaWh+Wtl+S9v+eUqHRleHRTdG9rZVxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLmxpbmVXaWR0aD0xIOeslOeUu+WuveW6plxyXG4gKiBAY2ZnIHtBcnJheX0gc3R5bGUubGluZURhc2g9bnVsbCDnrJTnlLvnmoTomZrnur/pl7TpmpTvvIzlj4LmlbDkuLrkuqTmm7/nu5jliLbnur/mrrXlkozpl7Tot53plb/luqbnmoTmlbDlrZcg5Y+C6KeBW2xpbmVEYXNoT2Zmc2V0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoKSBlZy4gbGluZURhc2g6WzYsMTBdXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUubGluZURhc2hPZmZzZXQ9MCAg56yU55S755qE6Jma57q/5YGP56e76YePIOWPguingVtsaW5lRGFzaE9mZnNldF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9saW5lRGFzaE9mZnNldClcclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS50ZXh0PVwiXCIg6IqC54K55LiK5pi+56S655qE5paH5pysLOWPr+S7peS9v+eUqCBcXG4g5p2l5o2i6KGMXHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUudGV4dEZvbnQ9JzEycHggc2Fucy1zZXJpZicg5a2X5L2T5aSn5bCP44CB5a2X5L2T57G75Z6L44CB57KX57uG44CB5a2X5L2T5qC35byP44CC5qC85byP5Y+C6KeBW2NzcyBmb250XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udCkgZWcudGV4dEZvbnQ6ICdpdGFsaWMgYm9sZGVyIDE0cHggTWljcm9zb2Z0IFlhSGVpJ1xyXG4gKiBAY2ZnIHtzdHJpbmd9IHN0eWxlLmZvbnRTdHlsZT1udWxsIOWtl+S9k+agt+W8j1xyXG4gKiBAY2ZnIHtzdHJpbmd9IHN0eWxlLmZvbnRXZWlnaHQ9IzAwMCDlrZfkvZPnspfnu4ZcclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS5mb250U2l6ZT1udWxsIOWtl+S9k+Wkp+Wwj1xyXG4gKiBAY2ZnIHtzdHJpbmd9IHN0eWxlLmZvbnRGYW1pbHk9bnVsbCDlrZfkvZPnsbvlnotcclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS50ZXh0RmlsbD0jMDAwIOiKgueCueS4iuaWh+acrOeahOWhq+WFheiJsiBlZy4jNUM5QUQzIHwgcmdiKDAsMjAwLDI1NSkgfCByZ2JhKDAsMjAwLDI1NSwwLjYpIHwgcmVkXHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUudGV4dFN0b2tlPW51bGwg6IqC54K55LiK5paH5pys55qE5o+P6L656ImyIGVnLiM1QzlBRDMgfCByZ2IoMCwyMDAsMjU1KSB8IHJnYmEoMCwyMDAsMjU1LDAuNikgfCByZWRcclxuICogQGNmZyB7c3RyaW5nfEFycmF5fSBzdHlsZS50ZXh0UG9zaXRpb249XCJcIiDmlofmnKzlnKjoioLngrnkuK3nmoTkvY3nva5sZWZ0fHJpZ2h0fHRvcHxib3R0b218aW5zaWRlfGluc2lkZUxlZnR8aW5zaWRlUmlnaHR8aW5zaWRlVG9wfGluc2lkZUJvdHRvbXxpbnNpZGVUb3BMZWZ0fGluc2lkZVRvcFJpZ2h0fGluc2lkZUJvdHRvbUxlZnR8aW5zaWRlQm90dG9tUmlnaHR8W3gseV18WyUsJV1cclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS50ZXh0QmFzZWxpbmU9XCJhbHBoYWJldGljXCIg5b2T5YmN5paH5pys5Z+657q/55qE5bGe5oCnIFwidG9wXCIgfHwgXCJoYW5naW5nXCIgfHwgXCJtaWRkbGVcIiB8fCBcImFscGhhYmV0aWNcIiB8fCBcImlkZW9ncmFwaGljXCIgfHwgXCJib3R0b21cIiDlj4Lop4FbY3NzIGZvbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvdGV4dEJhc2VsaW5lKVxyXG4gKiBAY2ZnIHtBcnJheX0gc3R5bGUudGV4dE9mZnNldD1udWxsIOaWh+acrOWcqOiKgueCueeahOWBj+enu+WAvFt4LHldIGVnLiBbMTAsMTBdXHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUudGV4dEFsaWduPVwiXCIg5paH5pys5Zyo6IqC54K55Lit55qE5a+56b2Q5pa55byPIGxlZnQgfCBjZW50ZXIgfCByaWdodFxyXG4gKiBAY2ZnIHtzdHJpbmd9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduPW51bGwg5paH5pys5Zyo6IqC54K55Lit55qE5Z6C55u05a+56b2Q5pa55byPIHRvcCB8IG1pZGRsZSB8IGJvdHRvbVxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLnRleHREaXN0YW5jZT01IOaWh+Wtl+eahOebuOWvuXRleHRQb3PnmoTlgY/np7vph48gZWcuIHRleHRQb3NpdGlvbj0nbGVmdCcgdGV4dERpc3RhbmNlPTUg5YiZ5paH5a2X55qEeOWdkOagh+eahOWAvOS4uiAobGVmdOeahOWdkOagh3jlgLwpIC01XHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUudGV4dFNoYWRvd0NvbG9yPSd0cmFuc3BhcmVudCcg5paH5a2X6Zi05b2x6aKc6ImyXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUudGV4dFNoYWRvd0JsdXI9MCDmlofmnKzpmLTlvbHlrr3luqYg5Y+C6KeBW3NoYWRvd0JsdXJdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2hhZG93Qmx1cilcclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WD0wIOaWh+acrOmYtOW9sSBYIOaWueWQkeWBj+enuyDlj4Lop4FzaGFkb3dPZmZzZXRYW2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2hhZG93T2Zmc2V0WF1cclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WT0wIOaWh+acrOmYtOW9sSBZIOaWueWQkeWBj+enuyDlj4Lop4FzaGFkb3dPZmZzZXRZW2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2hhZG93T2Zmc2V0WV1cclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS50ZXh0Um90YXRpb249MCDmlofmnKzml4vovaznmoTop5LluqZcclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS50ZXh0Qm9yZGVyV2lkdGg9MCDmloflrZfmj4/ovrnlrr3luqZcclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS50ZXh0Qm9yZGVyQ29sb3I9bnVsbCDmloflrZfmj4/ovrnpopzoibJcclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS50ZXh0Qm9yZGVyUmFkaXVzPTAg5paH5a2X5o+P6L655Y2K5b6EXHJcbiAqIEBjZmcge3N0cmluZ3xPYmplY3R9IHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3I9bnVsbCDmloflrZfog4zmma8o6aKc6Imy5oiW5Zu+54mHKSBlZy4gJyMzMzMnIHwge2ltYWdlOicuL2Fzc2V0L2ltZy9jbHVuZC5wbmcnfVxyXG4gKiBAY2ZnIHtudW1iZXJ8QXJyYXl9IHN0eWxlLnRleHRQYWRkaW5nPW51bGwg5paH5a2XcGFkZGluZyAgZWcuIGAyYCBvciBgWzIsIDRdYCBvciBgWzIsIDMsIDQsIDVdYFxyXG4gKiBAY2ZnIHtPYmplY3R9IHN0eWxlLnJpY2g9bnVsbCDlr4zmlofmnKzmoLflvI/lsZ7mgKdcclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS50ZXh0TGluZUhlaWdodD0wIOaWh+Wtl+eahOihjOmrmFxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLm9wYWNpdHk9MSDlm77lvaLpgI/mmI7luqbjgILmlK/mjIHku44gMCDliLAgMSDnmoTmlbDlrZfvvIzkuLogMCDml7bkuI3nu5jliLbor6Xlm77lvaLjgIJcclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS5zaGFkb3dCbHVyPTAg6Zi05b2x5a695bqmIOWPguingVtzaGFkb3dCbHVyXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NoYWRvd0JsdXIpXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUuc2hhZG93T2Zmc2V0WD0wIOmYtOW9sSBYIOaWueWQkeWBj+enuyDlj4Lop4FzaGFkb3dPZmZzZXRYW2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2hhZG93T2Zmc2V0WF1cclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS5zaGFkb3dPZmZzZXRZPTAg6Zi05b2xIFkg5pa55ZCR5YGP56e7IOWPguingXNoYWRvd09mZnNldFlbaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zaGFkb3dPZmZzZXRZXVxyXG4gKiBAY2ZnIHtzdHJpbmd9IHN0eWxlLnNoYWRvd0NvbG9yPScjMDAwJyDpmLTlvbHpopzoibIgZWcuIzVDOUFEMyB8IHJnYigwLDIwMCwyNTUpIHwgcmdiYSgwLDIwMCwyNTUsMC42KSB8IHJlZCDlj4Lop4Fbc2hhZG93Q29sb3JdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2hhZG93Q29sb3IpXHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUuaW1hZ2U9XCJcIiDlm77niYfnmoTot6/lvoQg55So5LqOSW1hZ2VcclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS53aWR0aCDlm77niYfnmoTlrr3luqYg55So5LqOSW1hZ2VcclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS5oZWlnaHQg5Zu+54mH55qE6auY5bqmIOeUqOS6jkltYWdlXHJcbiAqL1xyXG5cclxuIC8qKlxyXG4gKiBAY2ZnIHtPYmplY3R9IGhvdmVyU3R5bGUgaG92ZXLmoLflvI8sIOWPguaVsOingXN0eWxlXHJcbiAgKi9cclxuIC8qKlxyXG4gKiBAY2ZnIHtPYmplY3R9IHNlbGVjdFN0eWxlIOmAieS4reiKgueCueeahOagt+W8jywg5Y+C5pWw6KeBc3R5bGU7ICDpu5jorqTmmK/kuIDkuKromZrnmoTovrnmoYY7ICDorr7kuLrnqbrlr7nosaHliJnkuI3mmL7npLrpgInkuK3ovrnmoYY7XHJcbiovXHJcbi8qKlxyXG4gKiBAY2ZnIHtCb29sZWFufSBkcmFnZ2FibGU9dHJ1ZSDmmK/lkKblj6/ku6Xooqvmi5bmi73jgIJcclxuICovXHJcblxyXG4vKipcclxuICogQGNmZyB7Qm9vbGVhbn0gaWdub3JlPWZhbHNlIOaYr+WQpumakOiXj+eKtuaAge+8iOWPquivu++8ie+8jGZhc2xlOumakOiXjyx0cnVlOuS4jemakOiXj1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtCb29sZWFufSBzZWxlY3RhYmxlPXRydWUg6IqC54K55piv5ZCm5Y+v6YCJ5Lit77yM6buY6K6k5pivdHJ1ZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtTdHJpbmd9IGlkIOS4uuS6humBv+WFjemHjeWkje+8jOebruWJjeeUseezu+e7n+iHquWKqOeUn+aIkO+8jOWmguaenOS4jemcgOimgeeUqOWPr+S7peW/veeVpeOAguW7uuiuruS9v+eUqG5tYWVcclxuICovXHJcblxyXG4vKipcclxuICogIEBjZmcge0Jvb2xlYW59IGhvdmVyQW5pbWF0aW9uPWZhbHNlIOaYr+WQpuW8gOWQryBob3ZlciDlnKjoioLngrnkuIrnmoTmj5DnpLrliqjnlLvmlYjmnpzjgILvvIzpu5jorqTmmK9mYWxzZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtTdHJpbmd9IG5hbWUg5oyH5a6a6IqC54K555qEbmFtZSwg5Y+v5Lul5L2/55SoY2hpbGRPZk5hbWXnrYnlh73mlbDmoLnmja5uYW1l5p+l5om+6IqC54K5XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjZmcge1N0cmluZ30gdG9vbHRpcCDoioLngrnnmoR0b29sdGlwIOWGheWuueWPr+S7peWMheaLrEhUTUzmoIfnrb5cclxuICovXHJcblxyXG4vKipcclxuICogQGNmZyB7T2JqZWN0fSByZWxhdGl2ZSByZWxhdGl2ZeaPj+i/sOaAjuS5iOagueaNrueItuWFg+e0oOi/m+ihjOWumuS9je+8jOiuvue9ruS6hnJlbGF0aXZl5bGe5oCnIOWwseS4jemcgOimgeiuvue9rnBvc2l0aW9u44CC5pSv5oyB77yabGVmdOOAgXJpZ2h044CBdG9w44CBYm90dG9tXHJcbiAqIEBjZmcge051bWJlcnxTdHJpbmd9IHJlbGF0aXZlLmxlZnQgIOi3neemu+eItuWFg+e0oOW3pui+ueeahOS9jee9ruOAguWAvOeahOexu+Wei+WPr+S7peaYr++8mjEubnVtYmVy77ya6KGo56S65YOP57Sg5YC877ybMi7nmb7liIbmr5TlgLzvvJrlpoIgJzMzJSfvvIznlKjniLblhYPntKDnmoTpq5jlkozmraTnmb7liIbmr5TorqHnrpflh7rmnIDnu4jlgLzjgIIzLidjZW50ZXIn77ya6KGo56S66Ieq5Yqo5bGF5Lit44CCNC5sZWZ0IOWSjCByaWdodCDlj6rmnInkuIDkuKrlj6/ku6XnlJ/mlYjjgIJcclxuICogQGNmZyB7TnVtYmVyfFN0cmluZ30gcmVsYXRpdmUucmlnaHQgIOi3neemu+eItuWFg+e0oOWPs+i+ueeahOS9jee9ruOAguWAvOeahOexu+Wei+WPr+S7peaYr++8mjEubnVtYmVy77ya6KGo56S65YOP57Sg5YC877ybMi7nmb7liIbmr5TlgLzvvJrlpoIgJzMzJSfvvIznlKjniLblhYPntKDnmoTpq5jlkozmraTnmb7liIbmr5TorqHnrpflh7rmnIDnu4jlgLzjgIIzLidjZW50ZXIn77ya6KGo56S66Ieq5Yqo5bGF5Lit44CCNC5sZWZ0IOWSjCByaWdodCDlj6rmnInkuIDkuKrlj6/ku6XnlJ/mlYjjgIJcclxuICogQGNmZyB7TnVtYmVyfFN0cmluZ30gcmVsYXRpdmUudG9wICDot53nprvniLblhYPntKDpobbpg6jnmoTkvY3nva7jgILlgLznmoTnsbvlnovlj6/ku6XmmK/vvJoxLm51bWJlcu+8muihqOekuuWDj+e0oOWAvO+8mzIu55m+5YiG5q+U5YC877ya5aaCICczMyUn77yM55So54i25YWD57Sg55qE6auY5ZKM5q2k55m+5YiG5q+U6K6h566X5Ye65pyA57uI5YC844CCMy4nY2VudGVyJ++8muihqOekuuiHquWKqOWxheS4reOAgjQudG9wIOWSjCBib3R0b20g5Y+q5pyJ5LiA5Liq5Y+v5Lul55Sf5pWI44CCXHJcbiAqIEBjZmcge051bWJlcnxTdHJpbmd9IHJlbGF0aXZlLmJvdHRvbSAg6Led56a754i25YWD57Sg5bqV6YOo55qE5L2N572u44CC5YC855qE57G75Z6L5Y+v5Lul5piv77yaMS5udW1iZXLvvJrooajnpLrlg4/ntKDlgLzvvJsyLueZvuWIhuavlOWAvO+8muWmgiAnMzMlJ++8jOeUqOeItuWFg+e0oOeahOmrmOWSjOatpOeZvuWIhuavlOiuoeeul+WHuuacgOe7iOWAvOOAgjMuJ2NlbnRlcifvvJrooajnpLroh6rliqjlsYXkuK3jgII0LnRvcCDlkowgYm90dG9tIOWPquacieS4gOS4quWPr+S7peeUn+aViOOAglxyXG4gKiBAY2ZnIHtTdHJpbmd9IFtib3VuZGluZz0nYWxsJ10g5Yaz5a6a5q2k5Zu+5b2i5YWD57Sg5Zyo5a6a5L2N5pe277yM5a+56Ieq6Lqr55qE5YyF5Zu055uS6K6h566X5pa55byP44CCIDEuJ2FsbCfvvJrvvIjpu5jorqTvvIkg6KGo56S655So6Ieq6Lqr5Lul5Y+K5a2Q6IqC54K55pW05L2T55qE57uP6L+HIHRyYW5zZm9ybSDlkI7nmoTljIXlm7Tnm5Lov5vooYzlrprkvY3jgIIg6L+Z56eN5pa55byP5piT5LqO5L2/5pW05L2T6YO96ZmQ5Yi25Zyo54i25YWD57Sg6IyD5Zu05Lit44CCMi4ncmF3J++8miDooajnpLrku4Xku4XnlKjoh6rouqvvvIjkuI3ljIXmi6zlrZDoioLngrnvvInnmoTmsqHnu4/ov4cgdHJhbmZvcm0g55qE5YyF5Zu055uS6L+b6KGM5a6a5L2N44CCIOi/meenjeaWueW8j+aYk+S6juWGheWuuei2heWHuueItuWFg+e0oOiMg+WbtOeahOWumuS9jeaWueW8j+OAglxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtBcnJheX0gc2NhbGUg6IqC54K555qE57yp5pS+5Zug5a2QLCBbeCx5XSDmsLTlubPkuI7lnoLnm7TmlrnlkJHnmoQgZWcuIFsxLDFdXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjZmcge251bWJlcn0gcm90YXRpb24g6IqC54K555qE5peL6L2s5Zug5a2QLCDljZXkvY3mmK/op5LluqYgZWcuIDAuNSogTWF0aC5QSVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtBcnJheX0gb3JpZ2luIOaXi+i9rOWSjOe8qeaUvueahOWOn+eCuSwgW3gseV0gZWcuIFs3NSw3NV1cclxuICovXHJcblxyXG4vKipcclxuICogQGNmZyB7bnVtYmVyfSB6PTAgIHrmlrnlkJHnmoTpq5jluqbvvIzlhrPlrprlsYLlj6DlhbPns7vjgILnsbvkvLxjc3MgekluZGV4XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjZmcge251bWJlcn0gemxldmVsPTAgIOWGs+WumuatpOWFg+e0oOe7mOWItuWcqOWTquS4qiBjYW52YXMg5bGC5Lit44CC5rOo5oSP77yM6LaK5aSaIGNhbnZhcyDlsYLkvJrljaDnlKjotorlpJrotYTmupDjgIJcclxuICovXHJcblxyXG4vKipcclxuICogQGNmZyB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlICDmmK/lkKbkuI3lk43lupTpvKDmoIfku6Xlj4rop6bmkbjkuovku7bjgIJcclxuICovXHJcbi8qKlxyXG4gKiBAY2ZnIHtCb29sZWFufSBpbnZpc2libGU9ZmFsc2UgIOiKgueCueaYr+WQpuWPr+ingeOAglxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtPYmplY3R9IHBhcmVudCAg6IqC54K555qE54i25YWD57SgXHJcbiAqL1xyXG4vKipcclxuICogQGNmZyB7T2JqZWN0fSBvcGVyYXRpb25JY29ucyAg6IqC54K55pON5L2c5Li66YCJ5Lit55qE6IqC54K577yM5o+Q5L6b6buY6K6k5pON5L2c5oiW55So5oi36Ieq5a6a5LmJ5pON5L2c44CCXHJcbiAqIEBjZmcge1N0cmluZ30gb3BlcmF0aW9uSWNvbnMubmFtZSDorr7nva7oioLngrnlkI3np7DvvIzlj6/pgInlgLzmnIljb25zdGFudHMuREVMKOWIoOmZpCnvvIxjb25zdGFudHMuTElOS++8iOebtOe6v++8ie+8jGNvbnN0YW50cy5GT0xE77yI5oqY57q/77yJ77yMY29uc3RhbnRzLkNVUlZFKOabsue6vynvvIzku6Xlj4roh6rlrprkuYnlkI3np7BcclxuICogQGNmZyB7U3RyaW5nfSBvcGVyYXRpb25JY29ucy5pY29uUGF0aCDorr7nva7oh6rlrprkuYnoioLngrnlm77moIfot6/lvoRcclxuICogQGNmZyB7RnVuY3Rpb259IG9wZXJhdGlvbkljb25zLmNhbGxiYWNrIOiuvue9ruiKgueCueiiq+eCueWHu++8iGNsaWNr77yJ55qE5Zue6LCD5Ye95pWwXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgaW1hZ2UxID0gbmV3IG5vZGUuSW1hZ2Uoe1xyXG4gKiAgICAgICAgICAgc3R5bGU6IHtcclxuICogICAgICAgICAgICAgICBpbWFnZTogXCJpbWcvaW1nLWNpYy9pY29uLXNlbmQtc21zLnN2Z1wiLFxyXG4gKiAgICAgICAgICAgICAgIHdpZHRoOjEyMCxcclxuICogICAgICAgICAgICAgICBoZWlnaHQ6NzAsXHJcbiAqICAgICAgICAgICAgICAgdGV4dDpcIuaTjeS9nDrnur/mrrVcIixcclxuICogICAgICAgICAgICAgICB0ZXh0UG9zaXRpb246XCJpbnNpZGVCb3R0b21cIlxyXG4gKiAgICAgICAgICAgfSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF0sXHJcbiAqICAgICAgICAgICBvcGVyYXRpb25JY29uczogW1xyXG4gKiAgICAgICAgICAgICAgIHsgbmFtZTogY29uc3RhbnRzLkxJTkt9ICxcclxuICogICAgICAgICAgICAgICB7IG5hbWU6IGNvbnN0YW50cy5GT0xEIH0sXHJcbiAqICAgICAgICAgICAgICAgeyBuYW1lOiBjb25zdGFudHMuQ1VSVkUgfVxyXG4gKiAgICAgICAgICAgXVxyXG4gKiAgICAgICB9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQHByb3BlcnR5IHtPYmplY3R9IHN0YXRlc1xyXG4gKiDnlKjkuo7orr7nva7oioLngrnnmoTnirbmgIFcclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtb2RlbFxyXG4gKiDoioLngrnnmoTmqKHlnovvvIznlKjkuo7lrZjlgqjluo/liJfljJbmlbDmja4g5Lul5Y+K55So5oi36Ieq5a6a5LmJ5pWw5o2uXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgYXR0clxyXG4gKiDorr7nva7oioLngrnlsZ7mgKdcclxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBrZXkg6K6+572u55qE5bGe5oCn44CC5Y+v5Lul5pivIHN0cmluZyDnsbvlnovnmoTlsZ7mgKflkI3np7DvvIzmiJbogIUgT2JqZWN0IOexu+Wei+eahOWxnuaAp+WPiuWFtuWAvFxyXG4gKiBAcGFyYW0geyp9IOWxnuaAp+WAvFxyXG4gKiAqKuS9v+eUqOiMg+S+iyoqXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIG5vZGUuYXR0cigncG9zaXRpb24nLCBbMTAwLCAyMDBdKTtcclxuICogbm9kZS5hdHRyKHtcclxuICogICAgIHN0eWxlOiB7XHJcbiAqICAgICAgICAgZmlsbDogJ3JlZCdcclxuICogICAgIH0sXHJcbiAqICAgICBzaGFwZToge1xyXG4gKiAgICAgICAgIHg6IDEwMFxyXG4gKiAgICAgfVxyXG4gKiB9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzZXRTdHlsZVxyXG4gKiDliJvlu7roioLngrnlkI7vvIzorr7nva7oioLngrnnmoTmoLflvI/vvIhzdHlsZeWxnuaAp++8iVxyXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IOmUruWQjVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIOmUruWAvFxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IOi/lOWbnuiKgueCueWvueixoeiHqui6q1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHNldFNoYXBlXHJcbiAqIOWIm+W7uuiKgueCueWQju+8jOiuvue9ruiKgueCueeahOW9oueKtu+8iHNoYXBl5bGe5oCn77yJXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkg6ZSu5ZCNXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUg6ZSu5YC8XHJcbiAqIEByZXR1cm4ge09iamVjdH0g6L+U5Zue6IqC54K55a+56LGh6Ieq6LqrXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaGlkZVxyXG4gKiDpmpDol4/oioLngrlcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzaG93XHJcbiAqIOaYvuekuuiKgueCuVxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBvblxyXG4gKiDnu5Hlrprkuovku7ZcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIOS4iuS4i+aWh1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIG9mZlxyXG4gKiDop6Pnu5Hkuovku7ZcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIG9uZVxyXG4gKiDljZXmrKHop6blj5Hnu5HlrposdHJpZ2dlcuWQjumUgOavgVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5LqL5Lu25aSE55CG5Ye95pWwXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0g5LiK5LiL5paHXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgdHJpZ2dlclxyXG4gKiDkuovku7bliIblj5FcclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaXNTaWxlbnRcclxuICog5piv5ZCm57uR5a6a5LqG5LqL5Lu2XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCDkuovku7blkI1cclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBhbmltYXRlXHJcbiAqIOWKqOeUu1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCDpnIDopoHmt7vliqDliqjnlLvnmoTlsZ7mgKfojrflj5bot6/lvoTvvIzlj6/ku6XpgJrov4dhLmIuY+adpeiOt+WPlua3seWxgueahOWxnuaAp1xyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtsb29wXSDliqjnlLvmmK/lkKblvqrnjq9cclxuICogQHJldHVybiB7T2JqZWN0fSDov5Tlm55BbmltYXRvcuWvueixoVxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICBlbC5hbmltYXRlKCdzdHlsZScsIGZhbHNlKVxyXG4gKiAgICAgICAgIC53aGVuKDEwMDAsIHt4OiAxMH0gKVxyXG4gKiAgICAgICAgIC5kb25lKGZ1bmN0aW9uKCl7IC8vIEFuaW1hdGlvbiBkb25lIH0pXHJcbiAqICAgICAgICAgLnN0YXJ0KClcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzdG9wQW5pbWF0aW9uXHJcbiAqIOWBnOatouWKqOeUu1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmRUb0xhc3Qg5piv5ZCm5Zyo5YGc5q2i5YmN56e75Yqo5Yiw5pyA5ZCO5LiA5binXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgYW5pbWF0ZVRvXHJcbiAqIOS7juS4gOWKqOWxnuaAp+i/h+a4oeWIsOWPpuS4gOenjeWxnuaAp+eahOWKqOeUu1xyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IOebruWJjeWxnuaAp1xyXG4gKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXSDliqjnlLvml7bpl7Qg5Y2V5L2NbXNcclxuICogQHBhcmFtIHtzdHJpbmd9IFtlYXNpbmc9J2xpbmVhciddIOWKqOeUu+WHveaVsCDlj4Lop4Fb57yT5Yqo56S65L6LXShodHRwOi8vZWNoYXJ0cy5iYWlkdS5jb20vZ2FsbGVyeS9lZGl0b3IuaHRtbD9jPWxpbmUtZWFzaW5nKVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdIOW7tuaXtuaXtumXtFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIOWKqOeUu+e7k+adn+Wbnuiwg1xyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgICAgLy8gQW5pbWF0ZSBwb3NpdGlvblxyXG4gKiAgICAgICAgICBlbC5hbmltYXRlVG8oe1xyXG4gKiAgICAgICAgICAgICAgcG9zaXRpb246IFsxMCwgMTBdXHJcbiAqICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxyXG4gKlxyXG4gKiAgICAgICAgICAvLyBBbmltYXRlIHNoYXBlLCBzdHlsZSBhbmQgcG9zaXRpb24gaW4gMTAwbXMsIGRlbGF5ZWQgMTAwbXMsIHdpdGggY3ViaWNPdXQgZWFzaW5nXHJcbiAqICAgICAgICAgIGVsLmFuaW1hdGVUbyh7XHJcbiAqICAgICAgICAgICAgICBzaGFwZToge1xyXG4gKiAgICAgICAgICAgICAgICAgIHdpZHRoOiA1MDBcclxuICogICAgICAgICAgICAgIH0sXHJcbiAqICAgICAgICAgICAgICBzdHlsZToge1xyXG4gKiAgICAgICAgICAgICAgICAgIGZpbGw6ICdyZWQnXHJcbiAqICAgICAgICAgICAgICB9XHJcbiAqICAgICAgICAgICAgICBwb3NpdGlvbjogWzEwLCAxMF1cclxuICogICAgICAgICAgfSwgMTAwLCAxMDAsICdjdWJpY091dCcsIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgY2xpY2tcclxuICog5Y2V5Ye75LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhcmdldCDnm67moIflr7nosaFcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmV2ZW50IOWunumZheeahOa1j+iniOWZqOS6i+S7tuWvueixoVxyXG4gKiA8cHJlPlxyXG4gKiBub2RlLm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAqICAgLy9kbyBzb21ldGhpbmdcclxuICogfSlcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBkYmxjbGlja1xyXG4gKiDlvZPlj4zlh7vlhYPntKDml7bvvIzkvJrlj5HnlJ8gZGJsY2xpY2sg5LqL5Lu244CCXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhcmdldCDnm67moIflr7nosaFcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmV2ZW50IOWunumZheeahOa1j+iniOWZqOS6i+S7tuWvueixoVxyXG4gKiA8cHJlPlxyXG4gKiBub2RlLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAqICAgLy9kbyBzb21ldGhpbmdcclxuICogfSlcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBtb3VzZW92ZXJcclxuICog5b2T6byg5qCH5oyH6ZKI5L2N5LqO5YWD57Sg5LiK5pa55pe277yM5Lya5Y+R55SfIG1vdXNlb3ZlciDkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudGFyZ2V0IOebruagh+WvueixoVxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZXZlbnQg5a6e6ZmF55qE5rWP6KeI5Zmo5LqL5Lu25a+56LGhXHJcbiAqIDxwcmU+XHJcbiAqIG5vZGUub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAqICAgLy9kbyBzb21ldGhpbmdcclxuICogfSlcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBtb3VzZW91dFxyXG4gKiDlvZPpvKDmoIfmjIfpkojku47lhYPntKDkuIrnp7vlvIDml7bvvIzlj5HnlJ8gbW91c2VvdXQg5LqL5Lu244CCXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhcmdldCDnm67moIflr7nosaFcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmV2ZW50IOWunumZheeahOa1j+iniOWZqOS6i+S7tuWvueixoVxyXG4gKiA8cHJlPlxyXG4gKiBub2RlLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAqICAgLy9kbyBzb21ldGhpbmdcclxuICogfSlcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgbW91c2Vtb3ZlXHJcbiAqIOW9k+m8oOagh+aMh+mSiOWcqOaMh+WumueahOWFg+e0oOS4reenu+WKqOaXtu+8jOWwseS8muWPkeeUnyBtb3VzZW1vdmUg5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhcmdldCDnm67moIflr7nosaFcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmV2ZW50IOWunumZheeahOa1j+iniOWZqOS6i+S7tuWvueixoVxyXG4gKiA8cHJlPlxyXG4gKiBub2RlLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQGV2ZW50IG1vdXNld2hlZWxcclxuICog5b2T55So5oi35Zyo5oyH5a6a55qE5YWD57Sg5pe25rua5Yqo6byg5qCH5ruR6L2u5pe2LOWwseS8muWPkeeUnyBtb3VzZXdoZWVs5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhcmdldCDnm67moIflr7nosaFcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmV2ZW50IOWunumZheeahOa1j+iniOWZqOS6i+S7tuWvueixoVxyXG4gKiA8cHJlPlxyXG4gKiBub2RlLm9uKCdtb3VzZXdoZWVsJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICogICAvL2RvIHNvbWV0aGluZ1xyXG4gKiB9KVxyXG4gKiA8L3ByZT5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBldmVudCBtb3VzZWRvd25cclxuICog5b2T6byg5qCH5oyH6ZKI56e75Yqo5Yiw5YWD57Sg5LiK5pa577yM5bm25oyJ5LiL6byg5qCH5oyJ6ZSu5pe277yM5Lya5Y+R55SfIG1vdXNlZG93biDkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudGFyZ2V0IOebruagh+WvueixoVxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZXZlbnQg5a6e6ZmF55qE5rWP6KeI5Zmo5LqL5Lu25a+56LGhXHJcbiAqIDxwcmU+XHJcbiAqIG5vZGUub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAqICAgLy9kbyBzb21ldGhpbmdcclxuICogfSlcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgbW91c2V1cFxyXG4gKiDlvZPlnKjlhYPntKDkuIrmlL7mnb7pvKDmoIfmjInpkq7ml7bvvIzkvJrlj5HnlJ8gbW91c2V1cCDkuovku7bjgIJcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudGFyZ2V0IOebruagh+WvueixoVxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZXZlbnQg5a6e6ZmF55qE5rWP6KeI5Zmo5LqL5Lu25a+56LGhXHJcbiAqIDxwcmU+XHJcbiAqIG5vZGUub24oJ21vdXNldXAnLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgY29udGV4dG1lbnVcclxuICog5b2T5Zyo5YWD57Sg5LiK54K55Ye76byg5qCH5Y+z6ZSu5pe277yM5Lya5Y+R55SfIGNvbnRleHRtZW51IOS6i+S7tuOAglxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YXJnZXQg55uu5qCH5a+56LGhXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5ldmVudCDlrp7pmYXnmoTmtY/op4jlmajkuovku7blr7nosaHvvIzlpoLmnpzmg7PpmLvmraLpu5jorqTnmoTmtY/op4jlmajlj7PplK7oj5zljZXor7fkvb/nlKggZXZlbnQuZXZlbnQucHJldmVudERlZmF1bHQoKTsgZXZlbnQuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gKiA8cHJlPlxyXG4gKiBub2RlLm9uKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAqICAgLy9kbyBzb21ldGhpbmdcclxuICogfSlcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBkcmFnc3RhcnRcclxuICog5b2T5byA5aeL5ouW5Yqo6IqC54K555qE5pe25YCZ77yM5Lya5Y+R55SfIGRyYWdzdGFydCDkuovku7bjgIJcclxuICpcclxuICogPHByZT5cclxuICogbm9kZS5vbignZHJhZ3N0YXJ0JywgZnVuY3Rpb24oZSkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQGV2ZW50IGRyYWdcclxuICog5b2T5ouW5Yqo6IqC54K555qE5pe25YCZ77yM5Lya5Y+R55SfIGRyYWcg5LqL5Lu244CCXHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqIG5vZGUub24oJ2RyYWcnLCBmdW5jdGlvbihlKSB7XHJcbiAqICAgLy9kbyBzb21ldGhpbmdcclxuICogfSlcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBkcmFnZW5kXHJcbiAqIOW9k+aLluWKqOiKgueCuee7k+adn+eahOaXtuWAme+8jOS8muWPkeeUnyBkcmFnZW5kIOS6i+S7tuOAglxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiBub2RlLm9uKCdkcmFnZW5kJywgZnVuY3Rpb24oZSkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvZmxvd05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDnn6nlvaI8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5SZWN0XHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciByZWN0ID0gbmV3IG5vZGUuUmVjdCh7XHJcbiAqICAgICAgICAgICBzaGFwZTp7d2lkdGg6MTAwLGhlaWdodDo2MH0sXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbMjAsMjBdXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQocmVjdCk7XHJcbiAqL1xyXG5cclxuICAgIHZhciByb3VuZFJlY3RIZWxwZXIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QnKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnUmVjdCcsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtBcnJheX0gc2hhcGUucG9pbnRzPW51bGwg5ouG57q/54K555qE5Z2Q5qCHIOWPr+S7peS7jkFJ5Lit6I635Y+W44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfFN0cmluZ3xCb29sZWFufSBbc2hhcGUuc21vb3RoPWZhbHNlXSDmmK/lkKblubPmu5Hmm7Lnur/mmL7npLrjgILlpoLmnpzkuLogbnVtYmVy77ya6KGo56S66LSd5aGe5bCUIChiZXppZXIpIOW3ruWAvOW5s+a7ke+8jHNtb290aCDmjIflrprkuoblubPmu5HnrYnnuqfvvIzojIPlm7QgWzAsIDFdO+WmguaenOS4uiAnc3BsaW5lJ++8muihqOekuiBDYXRtdWxsLVJvbSBzcGxpbmUg5beu5YC85bmz5ruRXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5zbW9vdGhDb25zdHJhaW50PW51bGwg5piv5ZCm5bCG5bmz5ruR5puy57q/57qm5p2f5Zyo5YyF5Zu055uS5Lit44CCc21vb3RoIOS4uiBudW1iZXLvvIhiZXppZXLvvInml7bnlJ/mlYhcclxuICAgICAgICAgKi9cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAvLyDlt6bkuIrjgIHlj7PkuIrjgIHlj7PkuIvjgIHlt6bkuIvop5LnmoTljYrlvoTkvp3mrKHkuLpyMeOAgXIy44CBcjPjgIFyNFxyXG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6MSAgICAgICAgIOebuOW9k+S6jiBbMSwgMSwgMSwgMV1cclxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ulsxXSAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXHJcbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLpbMSwgMl0gICAg55u45b2T5LqOIFsxLCAyLCAxLCAyXVxyXG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6WzEsIDIsIDNdIOebuOW9k+S6jiBbMSwgMiwgMywgMl1cclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgcjogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDUwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDUwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IDA7XHJcbiAgICAgICAgICAgIHZhciB5ID0gMDtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmICghc2hhcGUucikge1xyXG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb3VuZFJlY3RIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICB2YXIgbmV3VyA9IE51bWJlcihzaGFwZS53aWR0aCAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgbmV3SCA9IE51bWJlcihuZXdXICogc2hhcGUuaGVpZ2h0IC8gc2hhcGUud2lkdGgpO1xyXG4gICAgICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3VyA9IHBhcnNlSW50KG5ld1csIDEwKTtcclxuICAgICAgICAgICAgICAgIG5ld0ggPSBwYXJzZUludChuZXdILCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5oyJ5q+U5L6L57yp5pS+XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2hhcGUoe1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG5ld1csXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG5ld0hcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBleHRlbmRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXHJcbiAqIOWchuW9ojxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLkNpcmNsZVxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgY2lyY2xlID0gbmV3IG5vZGUuQ2lyY2xlKHtcclxuICogICAgICAgICAgIHNoYXBlOntyOjI0fSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChjaXJjbGUpO1xyXG4gKi9cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnQ2lyY2xlJyxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IHNoYXBlIOW9oueKtuWPguaVsFxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUucj0yMCDljYrlvoTjgIJcclxuICAgICAgICAgKi9cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICByOiAyMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aCA6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBpbkJ1bmRsZSkge1xyXG4gICAgICAgICAgICAvLyBCZXR0ZXIgc3Ryb2tpbmcgaW4gU2hhcGVCdW5kbGVcclxuICAgICAgICAgICAgLy8gQWx3YXlzIGRvIGl0IG1heSBoYXZlIHBlcmZvcm1lbmNlIGlzc3VlICggZmlsbCBtYXkgYmUgMnggbW9yZSBjb3N0KVxyXG4gICAgICAgICAgICBpZiAoaW5CdW5kbGUpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc2hhcGUuciwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXHJcbiAgICAgICAgICAgIC8vIGN0eC5tb3ZlVG8oc2hhcGUuY3ggKyBzaGFwZS5yLCBzaGFwZS5jeSk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgc2hhcGUuciwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlU2hhcGU6IGZ1bmN0aW9uIChyYXRpbywgaWZQYXJzZSkge1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIHZhciBuZXdSID0gTnVtYmVyKHNoYXBlLnIgKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIG5ld1IgPSBwYXJzZUludChuZXdSLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5oyJ5q+U5L6L57yp5pS+XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2hhcGUoe1xyXG4gICAgICAgICAgICAgICAgcjogbmV3UlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDlm77niYfoioLngrk8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5JbWFnZVxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgaW1hZ2UgPSBuZXcgbm9kZS5JbWFnZSh7XHJcbiAqICAgICAgICAgICBzdHlsZToge1xyXG4gKiAgICAgICAgICAgICAgIGltYWdlOiBcIi4uLy4uL2V4YW1wbGVzL2Zsb3cvaW1nL2ltZy1jaWMvc3RhcnQuc3ZnXCIsXHJcbiAqICAgICAgICAgICAgICAgd2lkdGg6MTIwLFxyXG4gKiAgICAgICAgICAgICAgIGhlaWdodDo3MCxcclxuICogICAgICAgICAgICAgICB0ZXh0OlwiRXZlbnQgTmFtZVwiXHJcbiAqICAgICAgICAgICB9LFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzYwLDYwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKGltYWdlKTtcclxuICovXHJcblxyXG5cclxuICAgIHZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUnKTtcclxuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGZsb3dOb2RlID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpO1xyXG4gICAgdmFyIExSVSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvTFJVJyk7XHJcbiAgICB2YXIgZ2xvYmFsSW1hZ2VDYWNoZSA9IG5ldyBMUlUoNTApO1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBaSW1hZ2Uob3B0cykge1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBmbG93Tm9kZS5nZW5Nb2RlbChcIkltYWdlXCIsIG9wdHMpO1xyXG4gICAgICAgIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XHJcblxyXG4gICAgICAgIGlmICh3aW5kb3cualF1ZXJ5KSB7ICAgLy/liKTmlq1qUXVlcnnmmK/lkKblrZjlnKhcclxuICAgICAgICAgICAgdGhpcy5yZXN1bHREZWZlcnJkID0galF1ZXJ5LkRlZmVycmVkKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5yZXN1bHREZWZlcnJkLnByb21pc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgWkltYWdlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3I6IFpJbWFnZSxcclxuXHJcbiAgICAgICAgdHlwZTogJ0ltYWdlJyxcclxuXHJcbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xyXG4gICAgICAgICAgICB2YXIgc3JjID0gc3R5bGUuaW1hZ2U7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZTtcclxuXHJcbiAgICAgICAgICAgIC8vIE11c3QgYmluZCBlYWNoIHRpbWVcclxuICAgICAgICAgICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XHJcbiAgICAgICAgICAgIC8vIHN0eWxlLmltYWdlIGlzIGEgdXJsIHN0cmluZ1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGltYWdlID0gdGhpcy5faW1hZ2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2UgJiYgaW1hZ2Uuc3JjICE9PSBzcmMpIHsgLy8jMTcxXHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHN0eWxlLmltYWdlIGlzIGFuIEhUTUxJbWFnZUVsZW1lbnQgb3IgSFRNTENhbnZhc0VsZW1lbnQgb3IgQ2FudmFzXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBzcmM7XHJcbiAgICAgICAgICAgICAgICBpbWFnZS5pc0xvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRklYTUUgQ2FzZSBjcmVhdGUgbWFueSBpbWFnZXMgd2l0aCBzcmNcclxuICAgICAgICAgICAgaWYgKCFpbWFnZSAmJiBzcmMpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRyeSBnZXQgZnJvbSBnbG9iYWwgaW1hZ2UgY2FjaGVcclxuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRJbWdPYmogPSBnbG9iYWxJbWFnZUNhY2hlLmdldChzcmMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZWRJbWdPYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgaW1hZ2VcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlLmlzTG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5pc0xvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FjaGVkSW1nT2JqLnBlbmRpbmcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZEltZ09iai5wZW5kaW5nW2ldLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZEltZ09iaiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nOiBbdGhpc11cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IHNyYztcclxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxJbWFnZUNhY2hlLnB1dChzcmMsIGNhY2hlZEltZ09iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IGNhY2hlZEltZ09iai5pbWFnZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZSA9IGltYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEltYWdlIGlzIG5vdCBjb21wbGV0ZSBmaW5pc2gsIGFkZCB0byBwZW5kaW5nIGxpc3QgIOWmguaenOS9v+eUqOeahHN2Z+WbvueJhywgSUUxMeS4i+Wwseeul+WKoOi9veaIkOWKn2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHTkuZ/pg73mmK/kuLowXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghaW1hZ2Uud2lkdGggfHwgIWltYWdlLmhlaWdodCkgJiYgKCFpbWFnZS5zcmMuZW5kc1dpdGgoXCJzdmdcIikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZEltZ09iai5wZW5kaW5nLnB1c2godGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgLy8g5Zu+54mH5bey57uP5Yqg6L295a6M5oiQXHJcbiAgICAgICAgICAgICAgICAvLyBpZiAoaW1hZ2Uubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnSU1HJykge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIGlmICghaW1hZ2UuY29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIC8vIEVsc2UgaXMgY2FudmFzXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcclxuICAgICAgICAgICAgICAgIC8vIOWmguaenOS9v+eUqOeahHN2Z+WbvueJhywgSUUxMeS4i+Wwseeul+WKoOi9veaIkOWKn2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHTkuZ/pg73mmK/kuLowXHJcbiAgICAgICAgICAgICAgICAvL+atpOWkhOWmguS4jeazqOmHiiwg5Lya5a+86Ie0SUUxMeS4i3N2Z+WbvueJh+aXoOazleS9v+eUqFxyXG4gICAgICAgICAgICAgICAgLy8g5Zu+54mH5Yqg6L295aSx6LSlXHJcbiAgICAgICAgICAgICAgICAvLyBpZiAoIWltYWdlLndpZHRoIHx8ICFpbWFnZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWltYWdlLmlzTG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5qUXVlcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHREZWZlcnJkLnJlamVjdChpbWFnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBzdHlsZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzdHlsZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXNwZWN0ID0gaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgaW1hZ2UvaGVpZ2h0IHJhdGlvXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoZWlnaHQgPT0gbnVsbCAmJiB3aWR0aCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3aWR0aCA9PSBudWxsICYmIGhlaWdodCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBpbWFnZS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8g6K6+572udHJhbnNmb3JtXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zV2lkdGggJiYgc3R5bGUuc0hlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IHN0eWxlLnN4IHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gc3R5bGUuc3kgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIHdpZHRoLCBoZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGUuc3ggJiYgc3R5bGUuc3kpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3gyID0gc3R5bGUuc3g7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5MiA9IHN0eWxlLnN5O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzV2lkdGggPSB3aWR0aCAtIHN4MjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc0hlaWdodCA9IGhlaWdodCAtIHN5MjtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3gyLCBzeTIsIHNXaWR0aCwgc0hlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCwgeSwgd2lkdGgsIGhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIOWmguaenOayoeiuvue9ruWuveWSjOmrmOeahOivneiHquWKqOagueaNruWbvueJh+WuvemrmOiuvue9rlxyXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLndpZHRoID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmhlaWdodCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERyYXcgcmVjdCB0ZXh0XHJcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cualF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHREZWZlcnJkLnJlc29sdmUoaW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XHJcbiAgICAgICAgICAgIGlmICghIHRoaXMuX3JlY3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnggfHwgMCwgc3R5bGUueSB8fCAwLCBzdHlsZS53aWR0aCB8fCAwLCBzdHlsZS5oZWlnaHQgfHwgMFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xyXG4gICAgICAgICAgICB2YXIgbmV3VyA9IE51bWJlcihzdHlsZS53aWR0aCAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgbmV3SCA9IE51bWJlcihuZXdXICogc3R5bGUuaGVpZ2h0IC8gc3R5bGUud2lkdGgpO1xyXG4gICAgICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3VyA9IHBhcnNlSW50KG5ld1csIDEwKTtcclxuICAgICAgICAgICAgICAgIG5ld0ggPSBwYXJzZUludChuZXdILCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5oyJ5q+U5L6L57yp5pS+XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG5ld1csXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG5ld0hcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBpbWFnZeS4jee7p+aJv2Zsb3dOb2Rl77yM6ZyA5Y2V54us5a6a5LmJc2V0U3R5bGXmlrnms5VcclxuICAgICAgICBzZXRTdHlsZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBrZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdHlsZS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xyXG4gICAgICAgICAgICB6clV0aWwubWVyZ2UodGhpcy5tb2RlbC5nZXQoXCJvcHRpb25zLnN0eWxlXCIpLCBvcHRpb25zLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBaSW1hZ2U7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBleHRlbmRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvSW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDmlofmnKw8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5UZXh0XHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIikpO1xyXG4gKiAgICAgICB2YXIgdGV4dCA9IG5ldyBub2RlLlRleHQoe1xyXG4gKiAgICAgICAgICAgc3R5bGU6e3RleHQ6XCLmlofmnKzkuZ/lj6/ku6XkvZzkuLrni6znq4vnmoToioLngrnov5vooYzmi5bmi71cIixmaWxsOlwiI2ZmMDAwMFwiLCB0ZXh0Rm9udDpcIjE2cHggTWljcm9zb2Z0IFlhSGVpXCJ9LFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzYwLDYwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKHRleHQpO1xyXG4gKi9cclxuXHJcbiAgICB2YXIgVGV4dCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dCcpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGZsb3dOb2RlID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpO1xyXG4gICAgZnVuY3Rpb24gWlRleHQob3B0cykge1xyXG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgc3R5bGU6e3RleHRCYXNlbGluZTpcInRvcFwifSAgIC8vIOm7mOiupOWAvCAg6L+Z5qC36YCJ5Lit5pe255qE5qGG5omN5q2j56GuXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHpyVXRpbC5tZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0cywgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IGZsb3dOb2RlLmdlbk1vZGVsKFwiVGV4dFwiLCBvcHRpb25zKTtcclxuICAgICAgICBUZXh0LmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgWlRleHQucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBaVGV4dCxcclxuXHJcbiAgICAgICAgdHlwZTogJ1RleHQnLFxyXG5cclxuICAgICAgICB1cGRhdGVTaGFwZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB6clV0aWwuaW5oZXJpdHMoWlRleHQsIFRleHQpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBaVGV4dDtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9UZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOaJh+W9ojxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLlNlY3RvclxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpKTtcclxuICogICAgICAgdmFyIHNlY3RvciA9IG5ldyBub2RlLlNlY3Rvcih7XHJcbiAqICAgICAgICAgICBzaGFwZToge3I6MzAsIHN0YXJ0QW5nbGU6MCwgZW5kQW5nbGU6TWF0aC5QSSAqIDAuNX0sIC8vIHN0YXJ0QW5nbGVcXGVuZEFuZ2xl5piv5byn5bqm5Y2V5L2NXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNjBdXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQoc2VjdG9yKTtcclxuICovXHJcblxyXG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XHJcbiAgICB2YXIgUGF0aCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aCcpO1xyXG5cclxuICAgIHZhciBzaGFkb3dUZW1wID0gW1xyXG4gICAgICAgIFsnc2hhZG93Qmx1cicsIDBdLFxyXG4gICAgICAgIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLFxyXG4gICAgICAgIFsnc2hhZG93T2Zmc2V0WCcsIDBdLFxyXG4gICAgICAgIFsnc2hhZG93T2Zmc2V0WScsIDBdXHJcbiAgICBdO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ1NlY3RvcicsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnI9MCDlpJbljYrlvoTjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnIwPTAg5YaF5Y2K5b6E44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5zdGFydEFuZ2xlPTAg5byA5aeL5byn5bqm44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5lbmRBbmdsZT1NYXRoLlBJICogMiAg57uT5p2f5byn5bqm44CCXHJcbiAgICAgICAgICogQGNmZyB7Qm9vbGVhbn0gc2hhcGUuY2xvY2t3aXNlPXRydWUg5piv5ZCm6aG65pe26ZKI44CCXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgY3g6IDAsXHJcblxyXG4gICAgICAgICAgICBjeTogMCxcclxuXHJcbiAgICAgICAgICAgIHIwOiAwLFxyXG5cclxuICAgICAgICAgICAgcjogMCxcclxuXHJcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IDAsXHJcblxyXG4gICAgICAgICAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXHJcblxyXG4gICAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBicnVzaDogKGVudi5icm93c2VyLmllICYmIGVudi5icm93c2VyLnZlcnNpb24gPj0gMTEpIC8vIHZlcnNpb246ICcxMS4wJ1xyXG4gICAgICAgICAgICAvLyBGaXggd2VpcmQgYnVnIGluIHNvbWUgdmVyc2lvbiBvZiBJRTExIChsaWtlIDExLjAuOTYwMC4xNzgwMSksXHJcbiAgICAgICAgICAgIC8vIHdoZXJlIGV4Y2VwdGlvbiBcInVuZXhwZWN0ZWQgY2FsbCB0byBtZXRob2Qgb3IgcHJvcGVydHkgYWNjZXNzXCJcclxuICAgICAgICAgICAgLy8gbWlnaHQgYmUgdGhyb3duIHdoZW4gY2FsbGluZyBjdHguZmlsbCBhZnRlciBhIHBhdGggd2hvc2UgYXJlYSBzaXplXHJcbiAgICAgICAgICAgIC8vIGlzIHplcm8gaXMgZHJhd24gYW5kIGN0eC5jbGlwKCkgaXMgY2FsbGVkIGFuZCBzaGFkb3dCbHVyIGlzIHNldC5cclxuICAgICAgICAgICAgLy8gKGUuZy4sXHJcbiAgICAgICAgICAgIC8vICBjdHgubW92ZVRvKDEwLCAxMCk7XHJcbiAgICAgICAgICAgIC8vICBjdHgubGluZVRvKDIwLCAxMCk7XHJcbiAgICAgICAgICAgIC8vICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIC8vICBjdHguY2xpcCgpO1xyXG4gICAgICAgICAgICAvLyAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcclxuICAgICAgICAgICAgLy8gIC4uLlxyXG4gICAgICAgICAgICAvLyAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgLy8gKVxyXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjbGlwUGF0aHMgPSB0aGlzLl9fY2xpcFBhdGhzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcclxuICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gY2xpcFBhdGhzW2ldICYmIGNsaXBQYXRoc1tpXS5zaGFwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLnN0YXJ0QW5nbGUgPT09IHNoYXBlLmVuZEFuZ2xlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dUZW1wW2pdWzJdID0gc3R5bGVbc2hhZG93VGVtcFtqXVswXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbc2hhZG93VGVtcFtqXVswXV0gPSBzaGFkb3dUZW1wW2pdWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgUGF0aC5wcm90b3R5cGUuYnJ1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNoYWRvd1RlbXAubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbc2hhZG93VGVtcFtrXVswXV0gPSBzaGFkb3dUZW1wW2tdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IFBhdGgucHJvdG90eXBlLmJydXNoLFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xyXG4gICAgICAgICAgICB2YXIgcjAgPSBNYXRoLm1heChzaGFwZS5yMCB8fCAwLCAwKTtcclxuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xyXG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcclxuICAgICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcclxuXHJcbiAgICAgICAgICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odW5pdFggKiByMCArIHgsIHVuaXRZICogcjAgKyB5KTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XHJcblxyXG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oXHJcbiAgICAgICAgICAgICAgICBNYXRoLmNvcyhlbmRBbmdsZSkgKiByMCArIHgsXHJcbiAgICAgICAgICAgICAgICBNYXRoLnNpbihlbmRBbmdsZSkgKiByMCArIHlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByMCwgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIGNsb2Nrd2lzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICB2YXIgbmV3UiA9IE51bWJlcihzaGFwZS5yICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBuZXdSMCA9IE51bWJlcihzaGFwZS5yMCAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3UiA9IHBhcnNlSW50KG5ld1IsIDEwKTtcclxuICAgICAgICAgICAgICAgIG5ld1IwID0gcGFyc2VJbnQobmV3UjAsIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDmjInmr5TkvovnvKnmlL5cclxuICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgICAgICByOiBuZXdSLFxyXG4gICAgICAgICAgICAgICAgcjA6IG5ld1IwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1NlY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDnjq/lvaI8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5SaW5nXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIikpO1xyXG4gKiAgICAgICB2YXIgcmluZyA9IG5ldyBub2RlLlJpbmcoe1xyXG4gKiAgICAgICAgICAgc2hhcGU6IHtyOjMwLCAgcjA6MTB9LCAgLy8gcjAg5YaF5Y2K5b6EXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNjBdXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQocmluZyk7XHJcbiAqL1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpLmV4dGVuZCh7XHJcblxyXG4gICAgICAgICB0eXBlOiAnUmluZycsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnI9MCDlpJbljYrlvoTjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnIwPTAg5YaF5Y2K5b6E44CCXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICByOiAwLFxyXG4gICAgICAgICAgICByMDogMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBzaGFwZS5yLCB5KTtcclxuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yLCAwLCBQSTIsIGZhbHNlKTtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUucjAsIHkpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHNoYXBlLnIwLCAwLCBQSTIsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlU2hhcGU6IGZ1bmN0aW9uIChyYXRpbywgaWZQYXJzZSkge1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIHZhciBuZXdSID0gTnVtYmVyKHNoYXBlLnIgKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIG5ld1IwID0gTnVtYmVyKHNoYXBlLnIwICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgIGlmIChpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdSID0gcGFyc2VJbnQobmV3UiwgMTApO1xyXG4gICAgICAgICAgICAgICAgbmV3UjAgPSBwYXJzZUludChuZXdSMCwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOaMieavlOS+i+e8qeaUvlxyXG4gICAgICAgICAgICB0aGlzLnNldFNoYXBlKHtcclxuICAgICAgICAgICAgICAgIHI6IG5ld1IsXHJcbiAgICAgICAgICAgICAgICByMDogbmV3UjBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBleHRlbmRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvUmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxyXG4gKiDmpK3lnIY8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5Ecm9wbGV0XHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBlbGxpcHNlID0gbmV3IG5vZGUuRWxsaXBzZSh7XHJcbiAqICAgICAgICAgICBzaGFwZToge3J4OjcwLCAgcnk6MzB9LCAgLy8gcng65qSt5ZyG5qiq5Y2K6L206ZW/IHJ5OuakreWchue6teWNiui9tOmVv1xyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzYwLDYwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKGVsbGlwc2UpO1xyXG4gKi9cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnRWxsaXBzZScsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnJ4PTAg5qSt5ZyG5qiq5Y2K6L206ZW/XHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5yeT0wIOakreWchue6teWNiui9tOmVv1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIHJ4OiAwLCByeTogMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIGsgPSAwLjU1MjI4NDg7XHJcbiAgICAgICAgICAgIHZhciB4ID0gMDtcclxuICAgICAgICAgICAgdmFyIHkgPSAwO1xyXG4gICAgICAgICAgICB2YXIgYSA9IHNoYXBlLnJ4O1xyXG4gICAgICAgICAgICB2YXIgYiA9IHNoYXBlLnJ5O1xyXG4gICAgICAgICAgICB2YXIgb3ggPSBhICogazsgLy8g5rC05bmz5o6n5Yi254K55YGP56e76YePXHJcbiAgICAgICAgICAgIHZhciBveSA9IGIgKiBrOyAvLyDlnoLnm7TmjqfliLbngrnlgY/np7vph49cclxuICAgICAgICAgICAgLy8g5LuO5qSt5ZyG55qE5bem56uv54K55byA5aeL6aG65pe26ZKI57uY5Yi25Zub5p2h5LiJ5qyh6LSd5aGe5bCU5puy57q/XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCAtIGEsIHkpO1xyXG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4IC0gYSwgeSAtIG95LCB4IC0gb3gsIHkgLSBiLCB4LCB5IC0gYik7XHJcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyBveCwgeSAtIGIsIHggKyBhLCB5IC0gb3ksIHggKyBhLCB5KTtcclxuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCArIGEsIHkgKyBveSwgeCArIG94LCB5ICsgYiwgeCwgeSArIGIpO1xyXG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4IC0gb3gsIHkgKyBiLCB4IC0gYSwgeSArIG95LCB4IC0gYSwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICB2YXIgbmV3UnggPSBOdW1iZXIoc2hhcGUucnggKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIG5ld1J5ID0gTnVtYmVyKG5ld1J4ICogc2hhcGUucnkgLyBzaGFwZS5yeCk7XHJcbiAgICAgICAgICAgIGlmIChpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdSeCA9IHBhcnNlSW50KG5ld1J4LCAxMCk7XHJcbiAgICAgICAgICAgICAgICBuZXdSeSA9IHBhcnNlSW50KG5ld1J5LCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5oyJ5q+U5L6L57yp5pS+XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2hhcGUoe1xyXG4gICAgICAgICAgICAgICAgcng6IG5ld1J4LFxyXG4gICAgICAgICAgICAgICAgcnk6IG5ld1J5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0VsbGlwc2UuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5b+D5b2iPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuSGVhcnRcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgdmFyIGhlYXJ0ICA9IG5ldyBub2RlLkhlYXJ0KHtcclxuICogICAgICAgICAgIHNoYXBlOiB7d2lkdGg6NDAsICBoZWlnaHQ6NTB9LFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzYwLDYwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKGhlYXJ0ICk7XHJcbiAqL1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdIZWFydCcsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLmN4PTAg5Lit5b+D5Zyo54i26IqC54K55Z2Q5qCH57O777yI5Lul54i26IqC54K55bem5LiK6KeS5Li65Y6f54K577yJ5Lit55qE5qiq5Z2Q5qCH5YC844CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5jeT0wIOS4reW/g+WcqOeItuiKgueCueWdkOagh+ezu++8iOS7peeItuiKgueCueW3puS4iuinkuS4uuWOn+eCue+8ieS4reeahOe6teWdkOagh+WAvOOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUud2lkdGg9MCDlrr3luqbjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLmhlaWdodD0wIOmrmOW6puOAglxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIGEgPSBzaGFwZS53aWR0aDtcclxuICAgICAgICAgICAgdmFyIGIgPSBzaGFwZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxyXG4gICAgICAgICAgICAgICAgeCArIGEgLyAyLCB5IC0gYiAqIDIgLyAzLFxyXG4gICAgICAgICAgICAgICAgeCArIGEgKiAyLCB5ICsgYiAvIDMsXHJcbiAgICAgICAgICAgICAgICB4LCB5ICsgYlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgIHggLSBhICogIDIsIHkgKyBiIC8gMyxcclxuICAgICAgICAgICAgICAgIHggLSBhIC8gMiwgeSAtIGIgKiAyIC8gMyxcclxuICAgICAgICAgICAgICAgIHgsIHlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBOdW1iZXIoc2hhcGUud2lkdGggKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIG5ld0hlaWdodCA9IE51bWJlcihuZXdXaWR0aCAqIHNoYXBlLmhlaWdodCAvIHNoYXBlLndpZHRoKTtcclxuICAgICAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIG5ld1dpZHRoID0gcGFyc2VJbnQobmV3V2lkdGgsIDEwKTtcclxuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IHBhcnNlSW50KG5ld0hlaWdodCwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOaMieavlOS+i+e8qeaUvlxyXG4gICAgICAgICAgICB0aGlzLnNldFNoYXBlKHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBuZXdXaWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogbmV3SGVpZ2h0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0hlYXJ0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXHJcbiAqIOawtOa7tOW9ojxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLkRyb3BsZXRcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgdmFyIGRyb3BsZXQgPSBuZXcgbm9kZS5Ecm9wbGV0KHtcclxuICogICAgICAgICAgIHNoYXBlOiB7d2lkdGg6MTAsICBoZWlnaHQ6MzB9LFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzYwLDYwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKGRyb3BsZXQpO1xyXG4gKi9cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnRHJvcGxldCcsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLndpZHRoPTAg5a695bqm44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5oZWlnaHQ9MCDpq5jluqbjgIJcclxuICAgICAgICAgKi9cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBjeDogMCwgY3k6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLCBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGggOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xyXG4gICAgICAgICAgICB2YXIgYSA9IHNoYXBlLndpZHRoO1xyXG4gICAgICAgICAgICB2YXIgYiA9IHNoYXBlLmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSArIGEpO1xyXG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgIHggKyBhLFxyXG4gICAgICAgICAgICAgICAgeSArIGEsXHJcbiAgICAgICAgICAgICAgICB4ICsgYSAqIDMgLyAyLFxyXG4gICAgICAgICAgICAgICAgeSAtIGEgLyAzLFxyXG4gICAgICAgICAgICAgICAgeCxcclxuICAgICAgICAgICAgICAgIHkgLSBiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxyXG4gICAgICAgICAgICAgICAgeCAtIGEgKiAzIC8gMixcclxuICAgICAgICAgICAgICAgIHkgLSBhIC8gMyxcclxuICAgICAgICAgICAgICAgIHggLSBhLFxyXG4gICAgICAgICAgICAgICAgeSArIGEsXHJcbiAgICAgICAgICAgICAgICB4LFxyXG4gICAgICAgICAgICAgICAgeSArIGFcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlU2hhcGU6IGZ1bmN0aW9uIChyYXRpbywgaWZQYXJzZSkge1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIHZhciBuZXdXaWR0aCA9IE51bWJlcihzaGFwZS53aWR0aCAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gTnVtYmVyKG5ld1dpZHRoICogc2hhcGUuaGVpZ2h0IC8gc2hhcGUud2lkdGgpO1xyXG4gICAgICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3V2lkdGggPSBwYXJzZUludChuZXdXaWR0aCwgMTApO1xyXG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gcGFyc2VJbnQobmV3SGVpZ2h0LCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5oyJ5q+U5L6L57yp5pS+XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2hhcGUoe1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG5ld1dpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdIZWlnaHRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBleHRlbmRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvRHJvcGxldC5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDnjqvnkbDlvaI8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5Sb3NlXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIikpO1xyXG4gKiAgICAgICB2YXIgcm9zZSA9IG5ldyBub2RlLlJvc2Uoe1xyXG4gKiAgICAgICAgICAgc2hhcGU6IHtyOlszNV0sIGs6Nywgbjo0fSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChyb3NlKTtcclxuICovXHJcblxyXG4gICAgdmFyIHNpbiA9IE1hdGguc2luO1xyXG4gICAgdmFyIGNvcyA9IE1hdGguY29zO1xyXG4gICAgdmFyIHJhZGlhbiA9IE1hdGguUEkgLyAxODA7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnUm9zZScsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtBcnJheX0gc2hhcGUucj1bXVxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuaz0wXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5uPTFcclxuICAgICAgICAgKi9cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgIHI6IFtdLFxyXG4gICAgICAgICAgICBrOiAwLFxyXG4gICAgICAgICAgICBuOiAxXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXHJcbiAgICAgICAgICAgIGZpbGw6IG51bGwsXHJcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMlxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHg7XHJcbiAgICAgICAgICAgIHZhciB5O1xyXG4gICAgICAgICAgICB2YXIgUiA9IHNoYXBlLnI7XHJcbiAgICAgICAgICAgIHZhciByO1xyXG4gICAgICAgICAgICB2YXIgayA9IHNoYXBlLms7XHJcbiAgICAgICAgICAgIHZhciBuID0gc2hhcGUubjtcclxuXHJcbiAgICAgICAgICAgIHZhciB4MCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgeTAgPSBzaGFwZS5jeTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDAsIHkwKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBSLmxlbmd0aDsgaSA8IGxlbiA7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgciA9IFJbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMzYwICogbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogc2luKGsgLyBuICogaiAlIDM2MCAqIHJhZGlhbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogY29zKGogKiByYWRpYW4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICArIHgwO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSByXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpbihrIC8gbiAqIGogJSAzNjAgKiByYWRpYW4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpbihqICogcmFkaWFuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKyB5MDtcclxuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVTaGFwZTogZnVuY3Rpb24gKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZVJhdGlvID0gTnVtYmVyKHJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgdmFyIG5ld1IgPSBbXTtcclxuICAgICAgICAgICAgc2hhcGUuci5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICBuZXdSLnB1c2goTnVtYmVyKHYgKiBzY2FsZVJhdGlvKSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdSLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICB2ID0gcGFyc2VJbnQodiwgMTApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5oyJ5q+U5L6L57yp5pS+XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2hhcGUoe1xyXG4gICAgICAgICAgICAgICAgcjogbmV3UlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9Sb3NlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOato+Wkmui+ueW9ojxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLklzb2dvblxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgaXNvZ29uID0gbmV3IG5vZGUuSXNvZ29uKHtcclxuICogICAgICAgICAgIHNoYXBlOiB7cjo0MCwgIG46OX0sICAvLyBy5Y2K5b6EIG7lh6DkuKrovrlcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw1MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChpc29nb24pO1xyXG4gKi9cclxuXHJcbiAgICB2YXIgUEkgPSBNYXRoLlBJO1xyXG4gICAgdmFyIHNpbiA9IE1hdGguc2luO1xyXG4gICAgdmFyIGNvcyA9IE1hdGguY29zO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ0lzb2dvbicsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnI9MCDljYrlvoRcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLm49MCDlh6DkuKrovrlcclxuICAgICAgICAgKi9cclxuICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIHg6IDAsIHk6IDAsXHJcbiAgICAgICAgICAgIHI6IDAsIG46IDBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gc2hhcGUubjtcclxuICAgICAgICAgICAgaWYgKCFuIHx8IG4gPCAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55O1xyXG4gICAgICAgICAgICB2YXIgciA9IHNoYXBlLnI7XHJcblxyXG4gICAgICAgICAgICB2YXIgZFN0ZXAgPSAyICogUEkgLyBuO1xyXG4gICAgICAgICAgICB2YXIgZGVnID0gLVBJIC8gMjtcclxuXHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHIgKiBjb3MoZGVnKSwgeSArIHIgKiBzaW4oZGVnKSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlbmQgPSBuIC0gMTsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBkZWcgKz0gZFN0ZXA7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyByICogY29zKGRlZyksIHkgKyByICogc2luKGRlZykpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVTaGFwZTogZnVuY3Rpb24gKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZVJhdGlvID0gTnVtYmVyKHJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgdmFyIG5ld1IgPSBOdW1iZXIoc2hhcGUuciAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3UiA9IHBhcnNlSW50KG5ld1IsIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDmjInmr5TkvovnvKnmlL5cclxuICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgICAgICByOiBuZXdSXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0lzb2dvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDlpJrovrnlvaI8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5Qb2x5Z29uXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBwb2x5Z29uID0gbmV3IG5vZGUuUG9seWdvbih7XHJcbiAqICAgICAgICAgICBzaGFwZToge3BvaW50czpbWzg1LjI3NSwwXSwgWzEwMCwyNS40MV0sIFs4NS4yNzUsNTAuODIxXSwgWzE0LjEzOCw1MC44MjFdLCBbMCwyNS40MV0sIFsxNC4xMzgsMF1dfSwgIC8vIHLljYrlvoQgbuWHoOS4qui+uVxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzYwLDYwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKHBvbHlnb24pO1xyXG4gKi9cclxuXHJcbiAgICB2YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3BvbHknKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgIHR5cGU6ICdQb2x5Z29uJyxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IHNoYXBlIOW9oueKtuWPguaVsFxyXG4gICAgICAgICAqIEBjZmcge0FycmF5fSBzaGFwZS5wb2ludHM9bnVsbCDlpJrovrnlvaLngrnnmoTlnZDmoIcg5Y+v5Lul5LuOQUnkuK3ojrflj5bjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ8U3RyaW5nfEJvb2xlYW59IFtzaGFwZS5zbW9vdGg9ZmFsc2VdIOaYr+WQpuW5s+a7keabsue6v+aYvuekuuOAguWmguaenOS4uiBudW1iZXLvvJrooajnpLrotJ3loZ7lsJQgKGJlemllcikg5beu5YC85bmz5ruR77yMc21vb3RoIOaMh+WumuS6huW5s+a7keetiee6p++8jOiMg+WbtCBbMCwgMV075aaC5p6c5Li6ICdzcGxpbmUn77ya6KGo56S6IENhdG11bGwtUm9tIHNwbGluZSDlt67lgLzlubPmu5FcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnNtb290aENvbnN0cmFpbnQ9bnVsbCDmmK/lkKblsIblubPmu5Hmm7Lnur/nuqbmnZ/lnKjljIXlm7Tnm5LkuK3jgIJzbW9vdGgg5Li6IG51bWJlcu+8iGJlemllcu+8ieaXtueUn+aViFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIHBvaW50czogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIHNtb290aDogZmFsc2UsXHJcblxyXG4gICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICBwb2x5SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzTmV3ID0gW107XHJcbiAgICAgICAgICAgIHNoYXBlLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHBvaW50c05ldy5wdXNoKFtOdW1iZXIoaXRlbVswXSAqIHNjYWxlUmF0aW8pLCBOdW1iZXIoaXRlbVsxXSAqIHNjYWxlUmF0aW8pXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzTmV3LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bMF0gPSBwYXJzZUludChpdGVtWzBdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsxXSA9IHBhcnNlSW50KGl0ZW1bMV0sIDEwKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOaMieavlOS+i+e8qeaUvlxyXG4gICAgICAgICAgICB0aGlzLnNldFNoYXBlKHtcclxuICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzTmV3XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1BvbHlnb24uanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog55u057q/PGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuTGluZVxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgbGluZSA9IG5ldyBub2RlLkxpbmUoe1xyXG4gKiAgICAgICAgICAgc2hhcGU6IHt4MTo2MCwgIHkxOjYwLCB4MjoxMDAsIHkyOjEwMH0sICAvLyB4IOi1t+eCuSB557uI54K5XHJcbiAqICAgICAgICAgICBzdHlsZToge2xpbmVXaWR0aDozfVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKGxpbmUpO1xyXG4gKi9cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnTGluZScsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLngxPTAg6LW35aeL54K555qE5qiq5Z2Q5qCH5YC844CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS55MT0wIOi1t+Wni+eCueeahOe6teWdkOagh+WAvOOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUueDI9MCDnu4jmraLngrnnmoTmqKrlnZDmoIflgLzjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnkyPTAg57uI5q2i54K555qE57q15Z2Q5qCH5YC844CCXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgLy8gU3RhcnQgcG9pbnRcclxuICAgICAgICAgICAgeDE6IDAsXHJcbiAgICAgICAgICAgIHkxOiAwLFxyXG4gICAgICAgICAgICAvLyBFbmQgcG9pbnRcclxuICAgICAgICAgICAgeDI6IDAsXHJcbiAgICAgICAgICAgIHkyOiAwLFxyXG5cclxuICAgICAgICAgICAgcGVyY2VudDogMVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxyXG4gICAgICAgICAgICBmaWxsOiBudWxsXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgeDEgPSBzaGFwZS54MTtcclxuICAgICAgICAgICAgdmFyIHkxID0gc2hhcGUueTE7XHJcbiAgICAgICAgICAgIHZhciB4MiA9IHNoYXBlLngyO1xyXG4gICAgICAgICAgICB2YXIgeTIgPSBzaGFwZS55MjtcclxuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICB4MiA9IHgxICogKDEgLSBwZXJjZW50KSArIHgyICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgIHkyID0geTEgKiAoMSAtIHBlcmNlbnQpICsgeTIgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxyXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBvaW50QXQ6IGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBzaGFwZS54MSAqICgxIC0gcCkgKyBzaGFwZS54MiAqIHAsXHJcbiAgICAgICAgICAgICAgICBzaGFwZS55MSAqICgxIC0gcCkgKyBzaGFwZS55MiAqIHBcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICB2YXIgbmV3WDEgPSBOdW1iZXIoc2hhcGUueDEgKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIG5ld1gyID0gTnVtYmVyKHNoYXBlLngyICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBuZXdZMSA9IE51bWJlcihzaGFwZS55MSAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgbmV3WTIgPSBOdW1iZXIoc2hhcGUueTIgKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIG5ld1gxID0gcGFyc2VJbnQobmV3WDEsIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDmjInmr5TkvovnvKnmlL5cclxuICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgICAgICB4MTogbmV3WDEsXHJcbiAgICAgICAgICAgICAgICB5MTogbmV3WTEsXHJcbiAgICAgICAgICAgICAgICB4MjogbmV3WDIsXHJcbiAgICAgICAgICAgICAgICB5MjogbmV3WTJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBleHRlbmRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxyXG4gKiDmi4bnur88YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5Qb2x5bGluZVxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgcG9seWxpbmUgPSBuZXcgbm9kZS5Qb2x5bGluZSh7XHJcbiAqICAgICAgICAgICBzaGFwZToge3BvaW50czpbWzU3LDEzOF0sWzk1LDE4NF0sWzExNSwxNjZdLFsxNTEsMTg0XSBdfVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKHBvbHlsaW5lKTtcclxuICovXHJcblxyXG4gICAgdmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9wb2x5Jyk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnUG9seWxpbmUnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7QXJyYXl9IHNoYXBlLnBvaW50cz1udWxsIOaLhue6v+eCueeahOWdkOaghyDlj6/ku6Xku45BSeS4reiOt+WPluOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcnxTdHJpbmd8Qm9vbGVhbn0gW3NoYXBlLnNtb290aD1mYWxzZV0g5piv5ZCm5bmz5ruR5puy57q/5pi+56S644CC5aaC5p6c5Li6IG51bWJlcu+8muihqOekuui0neWhnuWwlCAoYmV6aWVyKSDlt67lgLzlubPmu5HvvIxzbW9vdGgg5oyH5a6a5LqG5bmz5ruR562J57qn77yM6IyD5Zu0IFswLCAxXTvlpoLmnpzkuLogJ3NwbGluZSfvvJrooajnpLogQ2F0bXVsbC1Sb20gc3BsaW5lIOW3ruWAvOW5s+a7kVxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuc21vb3RoQ29uc3RyYWludD1udWxsIOaYr+WQpuWwhuW5s+a7keabsue6v+e6puadn+WcqOWMheWbtOebkuS4reOAgnNtb290aCDkuLogbnVtYmVy77yIYmV6aWVy77yJ5pe255Sf5pWIXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgcG9pbnRzOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgc21vb3RoOiBmYWxzZSxcclxuXHJcbiAgICAgICAgICAgIHNtb290aENvbnN0cmFpbnQ6IG51bGxcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcclxuXHJcbiAgICAgICAgICAgIGZpbGw6IG51bGxcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHBvbHlIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUsIGZhbHNlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzTmV3ID0gW107XHJcbiAgICAgICAgICAgIHNoYXBlLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHBvaW50c05ldy5wdXNoKFtOdW1iZXIoaXRlbVswXSAqIHNjYWxlUmF0aW8pLCBOdW1iZXIoaXRlbVsxXSAqIHNjYWxlUmF0aW8pXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzTmV3LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bMF0gPSBwYXJzZUludChpdGVtWzBdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsxXSA9IHBhcnNlSW50KGl0ZW1bMV0sIDEwKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOaMieavlOS+i+e8qeaUvlxyXG4gICAgICAgICAgICB0aGlzLnNldFNoYXBlKHtcclxuICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzTmV3XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1BvbHlsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXHJcbiAqIOi0neWhnuWwlOabsue6vzxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLkJlemllckN1cnZlXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBiZXppZXJDdXJ2ZSA9IG5ldyBub2RlLkJlemllckN1cnZlKHtcclxuICogICAgICAgICAgIHNoYXBlOiB7eDE6MCwgeTE6MTAwLCBjcHgxOjAsIGNweTE6MCwgY3B4MjowLCBjcHkyOjAsIHgyOjEwMCwgeTI6MH0sXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjogWzYwLCA2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChiZXppZXJDdXJ2ZSk7XHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgY3VydmVUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9jdXJ2ZScpO1xyXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xyXG4gICAgdmFyIHF1YWRyYXRpY1N1YmRpdmlkZSA9IGN1cnZlVG9vbC5xdWFkcmF0aWNTdWJkaXZpZGU7XHJcbiAgICB2YXIgY3ViaWNTdWJkaXZpZGUgPSBjdXJ2ZVRvb2wuY3ViaWNTdWJkaXZpZGU7XHJcbiAgICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZVRvb2wucXVhZHJhdGljQXQ7XHJcbiAgICB2YXIgY3ViaWNBdCA9IGN1cnZlVG9vbC5jdWJpY0F0O1xyXG4gICAgdmFyIHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVG9vbC5xdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XHJcbiAgICB2YXIgY3ViaWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVRvb2wuY3ViaWNEZXJpdmF0aXZlQXQ7XHJcblxyXG4gICAgdmFyIG91dCA9IFtdO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNvbWVWZWN0b3JBdChzaGFwZSwgdCwgaXNUYW5nZW50KSB7XHJcbiAgICAgICAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xyXG4gICAgICAgIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcclxuICAgICAgICBpZiAoY3B4MiA9PT0gbnVsbCB8fCBjcHkyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUuY3B4Miwgc2hhcGUueDIsIHQpLFxyXG4gICAgICAgICAgICAgICAgKGlzVGFuZ2VudCA/IGN1YmljRGVyaXZhdGl2ZUF0IDogY3ViaWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLmNweTIsIHNoYXBlLnkyLCB0KVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLngyLCB0KSxcclxuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLnkyLCB0KVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdCZXppZXJDdXJ2ZScsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLngxPTAg6LW35aeL54K555qE5qiq5Z2Q5qCH5YC844CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS55MT0wIOi1t+Wni+eCueeahOe6teWdkOagh+WAvOOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUueDI9MCDnu4jmraLngrnnmoTmqKrlnZDmoIflgLzjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnkyPTAg57uI5q2i54K555qE57q15Z2Q5qCH5YC844CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5jcHgxPTAg5o6n5Yi254K555qE5qiq5Z2Q5qCH5YC844CCXHJcbiAgICAgICAgICogQGNmZyB7Qm9vbGVhbn0gc2hhcGUuY3B4Mj0wIOaOp+WItueCueeahOe6teWdkOagh+WAvOOAglxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIHgxOiAwLFxyXG4gICAgICAgICAgICB5MTogMCxcclxuICAgICAgICAgICAgeDI6IDAsXHJcbiAgICAgICAgICAgIHkyOiAwLFxyXG4gICAgICAgICAgICBjcHgxOiAwLFxyXG4gICAgICAgICAgICBjcHkxOiAwLFxyXG5cclxuICAgICAgICAgICAgLy8gQ3VydmUgc2hvdyBwZXJjZW50LCBmb3IgYW5pbWF0aW5nXHJcbiAgICAgICAgICAgIHBlcmNlbnQ6IDFcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcclxuICAgICAgICAgICAgZmlsbDogbnVsbFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHgxID0gc2hhcGUueDE7XHJcbiAgICAgICAgICAgIHZhciB5MSA9IHNoYXBlLnkxO1xyXG4gICAgICAgICAgICB2YXIgeDIgPSBzaGFwZS54MjtcclxuICAgICAgICAgICAgdmFyIHkyID0gc2hhcGUueTI7XHJcbiAgICAgICAgICAgIHZhciBjcHgxID0gc2hhcGUuY3B4MTtcclxuICAgICAgICAgICAgdmFyIGNweTEgPSBzaGFwZS5jcHkxO1xyXG4gICAgICAgICAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XHJcbiAgICAgICAgICAgIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcclxuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xyXG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY3B4MiA9PSBudWxsIHx8IGNweTIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSwgY3B4MSwgeDIsIHBlcmNlbnQsIG91dFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3B4MSA9IG91dFsxXTtcclxuICAgICAgICAgICAgICAgICAgICB4MiA9IG91dFsyXTtcclxuICAgICAgICAgICAgICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxLCBjcHkxLCB5MiwgcGVyY2VudCwgb3V0XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBjcHkxID0gb3V0WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHkyID0gb3V0WzJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxyXG4gICAgICAgICAgICAgICAgICAgIGNweDEsIGNweTEsXHJcbiAgICAgICAgICAgICAgICAgICAgeDIsIHkyXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3ViaWNTdWJkaXZpZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxLCBjcHgxLCBjcHgyLCB4MiwgcGVyY2VudCwgb3V0XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBjcHgxID0gb3V0WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNweDIgPSBvdXRbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBvdXRbM107XHJcbiAgICAgICAgICAgICAgICAgICAgY3ViaWNTdWJkaXZpZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxLCBjcHkxLCBjcHkyLCB5MiwgcGVyY2VudCwgb3V0XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBjcHkxID0gb3V0WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNweTIgPSBvdXRbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBvdXRbM107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgICAgICBjcHgxLCBjcHkxLFxyXG4gICAgICAgICAgICAgICAgICAgIGNweDIsIGNweTIsXHJcbiAgICAgICAgICAgICAgICAgICAgeDIsIHkyXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcclxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBwb2ludEF0OiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIGZhbHNlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGFuZ2VudCBhdCBwZXJjZW50XHJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0XHJcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGFuZ2VudEF0OiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICB2YXIgcCA9IHNvbWVWZWN0b3JBdCh0aGlzLnNoYXBlLCB0LCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZlYzIubm9ybWFsaXplKHAsIHApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlU2hhcGU6IGZ1bmN0aW9uIChyYXRpbywgaWZQYXJzZSkge1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIHZhciBwb2ludHNOZXcgPSB7fTtcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2hhcGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2hhcGVba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdwZXJjZW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50c05ld1trZXldID0gTnVtYmVyKHZhbHVlICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50c05ld1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocG9pbnRzTmV3KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50c05ld1trZXldID0gcGFyc2VJbnQocG9pbnRzTmV3W2tleV0sIDEwKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOaMieavlOS+i+e8qeaUvlxyXG4gICAgICAgICAgICB0aGlzLnNldFNoYXBlKHBvaW50c05ldyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBleHRlbmRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvQmV6aWVyQ3VydmUuanNcbi8vIG1vZHVsZSBpZCA9IDExMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcclxuICog5ZyG5bynPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuQXJjXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBhcmMgPSBuZXcgbm9kZS5BcmMoe1xyXG4gKiAgICAgICAgICAgc2hhcGU6IHtyOjUwLCBzdGFydEFuZ2xlOjAsIGVuZEFuZ2xlOjEuMipNYXRoLlBJfSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOiBbNjAsIDYwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKGFyYyk7XHJcbiAqL1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdBcmMnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5yPTAg5Y2K5b6E44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5zdGFydEFuZ2xlPTAg5byA5aeL5byn5bqm44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5lbmRBbmdsZT1NYXRoLlBJICogMiAg57uT5p2f5byn5bqm44CCXHJcbiAgICAgICAgICogQGNmZyB7Qm9vbGVhbn0gc2hhcGUuY2xvY2t3aXNlPXRydWUg5piv5ZCm6aG65pe26ZKI44CCXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICByOiAwLFxyXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiAwLFxyXG4gICAgICAgICAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXHJcbiAgICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN0eWxlOiB7XHJcblxyXG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcclxuXHJcbiAgICAgICAgICAgIGZpbGw6IG51bGxcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xyXG4gICAgICAgICAgICB2YXIgciA9IE1hdGgubWF4KHNoYXBlLnIsIDApO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XHJcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xyXG4gICAgICAgICAgICB2YXIgY2xvY2t3aXNlID0gc2hhcGUuY2xvY2t3aXNlO1xyXG5cclxuICAgICAgICAgICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XHJcbiAgICAgICAgICAgIHZhciB1bml0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xyXG5cclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIgKyB4LCB1bml0WSAqIHIgKyB5KTtcclxuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVTaGFwZTogZnVuY3Rpb24gKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZVJhdGlvID0gTnVtYmVyKHJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgdmFyIG5ld1IgPSBOdW1iZXIoc2hhcGUuciAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3UiA9IHBhcnNlSW50KG5ld1IsIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDmjInmr5TkvovnvKnmlL5cclxuICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgICAgICByOiBuZXdSXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0FyYy5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxyXG4gKiDmmJ/lvaI8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5TdGFyXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIikpO1xyXG4gKiAgICAgICB2YXIgc3RhciA9IG5ldyBub2RlLlN0YXIoe1xyXG4gKiAgICAgICAgICAgc2hhcGU6IHtuOjcsIHI6MzB9LCAgLy9y5Y2K5b6EIG7lh6DkuKrop5JcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChzdGFyKTtcclxuICovXHJcblxyXG4gICAgdmFyIFBJID0gTWF0aC5QSTtcclxuXHJcbiAgICB2YXIgY29zID0gTWF0aC5jb3M7XHJcbiAgICB2YXIgc2luID0gTWF0aC5zaW47XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnU3RhcicsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLm49MyDlh6DkuKrop5LjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnI9MCDlpJbljYrlvoTjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnIwPTAg5YaF5Y2K5b6E44CCXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICBuOiAzLFxyXG4gICAgICAgICAgICByMDogbnVsbCxcclxuICAgICAgICAgICAgcjogMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBuID0gc2hhcGUubjtcclxuICAgICAgICAgICAgaWYgKCFuIHx8IG4gPCAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XHJcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUuY3k7XHJcbiAgICAgICAgICAgIHZhciByID0gc2hhcGUucjtcclxuICAgICAgICAgICAgdmFyIHIwID0gc2hhcGUucjA7XHJcblxyXG4gICAgICAgICAgICAvLyDlpoLmnpzmnKrmjIflrprlhoXpg6jpobbngrnlpJbmjqXlnIbljYrlvoTvvIzliJnoh6rliqjorqHnrpdcclxuICAgICAgICAgICAgaWYgKHIwID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHIwID0gbiA+IDRcclxuICAgICAgICAgICAgICAgICAgICAvLyDnm7jpmpTnmoTlpJbpg6jpobbngrnnmoTov57nur/nmoTkuqTngrnvvIxcclxuICAgICAgICAgICAgICAgICAgICAvLyDooqvlj5bkuLrlhoXpg6jkuqTngrnvvIzku6XmraTorqHnrpdyMFxyXG4gICAgICAgICAgICAgICAgICAgID8gciAqIGNvcygyICogUEkgLyBuKSAvIGNvcyhQSSAvIG4pXHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5LqM5LiJ5Zub6KeS5pif55qE54m55q6K5aSE55CGXHJcbiAgICAgICAgICAgICAgICAgICAgOiByIC8gMztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRTdGVwID0gUEkgLyBuO1xyXG4gICAgICAgICAgICB2YXIgZGVnID0gLVBJIC8gMjtcclxuICAgICAgICAgICAgdmFyIHhTdGFydCA9IHggKyByICogY29zKGRlZyk7XHJcbiAgICAgICAgICAgIHZhciB5U3RhcnQgPSB5ICsgciAqIHNpbihkZWcpO1xyXG4gICAgICAgICAgICBkZWcgKz0gZFN0ZXA7XHJcblxyXG4gICAgICAgICAgICAvLyDorrDlvZXovrnnlYzngrnvvIznlKjkuo7liKTmlq1pbnNpZGVcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4U3RhcnQsIHlTdGFydCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlbmQgPSBuICogMiAtIDEsIHJpOyBpIDwgZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJpID0gaSAlIDIgPT09IDAgPyByMCA6IHI7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyByaSAqIGNvcyhkZWcpLCB5ICsgcmkgKiBzaW4oZGVnKSk7XHJcbiAgICAgICAgICAgICAgICBkZWcgKz0gZFN0ZXA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVNoYXBlOiBmdW5jdGlvbiAocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICB2YXIgbmV3UiA9IE51bWJlcihzaGFwZS5yICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgIGlmIChpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdSID0gcGFyc2VJbnQobmV3UiwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOaMieavlOS+i+e8qeaUvlxyXG4gICAgICAgICAgICB0aGlzLnNldFNoYXBlKHtcclxuICAgICAgICAgICAgICAgIHI6IG5ld1JcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBleHRlbmRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvU3Rhci5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxyXG4gKiDml4vova7mm7Lnur88YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5Ucm9jaG9pZFxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpKTtcclxuICogICAgICAgdmFyIHRyb2Nob2lkID0gbmV3IG5vZGUuVHJvY2hvaWQoe1xyXG4gKiAgICAgICAgICAgc2hhcGU6IHtyOjUwLCByMDozNSwgZDozMCwgbG9jYXRpb246bnVsbH0sICAvL3LljYrlvoQgbuWHoOS4quinklxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzYwLDYwXSxcclxuICogICAgICAgICAgIHRvb2x0aXA6IFwi5peL6L2u5puy57q/XCJcclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZCh0cm9jaG9pZCk7XHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgY29zID0gTWF0aC5jb3M7XHJcbiAgICB2YXIgc2luID0gTWF0aC5zaW47XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnVHJvY2hvaWQnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5yPTAg5aSW5Y2K5b6E44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5yMD0wIOWGheWNiuW+hOOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuZD0wXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5sb2NhdGlvbj0nb3V0J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgcjogMCxcclxuICAgICAgICAgICAgcjA6IDAsXHJcbiAgICAgICAgICAgIGQ6IDAsXHJcbiAgICAgICAgICAgIGxvY2F0aW9uOiAnb3V0J1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxyXG5cclxuICAgICAgICAgICAgZmlsbDogbnVsbFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHgxO1xyXG4gICAgICAgICAgICB2YXIgeTE7XHJcbiAgICAgICAgICAgIHZhciB4MjtcclxuICAgICAgICAgICAgdmFyIHkyO1xyXG4gICAgICAgICAgICB2YXIgUiA9IHNoYXBlLnI7XHJcbiAgICAgICAgICAgIHZhciByID0gc2hhcGUucjA7XHJcbiAgICAgICAgICAgIHZhciBkID0gc2hhcGUuZDtcclxuICAgICAgICAgICAgdmFyIG9mZnNldFggPSBzaGFwZS5jeDtcclxuICAgICAgICAgICAgdmFyIG9mZnNldFkgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIGRlbHRhID0gc2hhcGUubG9jYXRpb24gPT0gJ291dCcgPyAxIDogLTE7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2hhcGUubG9jYXRpb24gJiYgUiA8PSByKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBudW0gPSAwO1xyXG4gICAgICAgICAgICB2YXIgaSA9IDE7XHJcbiAgICAgICAgICAgIHZhciB0aGV0YTtcclxuXHJcbiAgICAgICAgICAgIHgxID0gKFIgKyBkZWx0YSAqIHIpICogY29zKDApXHJcbiAgICAgICAgICAgICAgICAtIGRlbHRhICogZCAqIGNvcygwKSArIG9mZnNldFg7XHJcbiAgICAgICAgICAgIHkxID0gKFIgKyBkZWx0YSAqIHIpICogc2luKDApXHJcbiAgICAgICAgICAgICAgICAtIGQgKiBzaW4oMCkgKyBvZmZzZXRZO1xyXG5cclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xyXG5cclxuICAgICAgICAgICAgLy8g6K6h566X57uT5p2f5pe255qEaVxyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBudW0rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoKHIgKiBudW0pICUgKFIgKyBkZWx0YSAqIHIpICE9PSAwKTtcclxuXHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIHRoZXRhID0gTWF0aC5QSSAvIDE4MCAqIGk7XHJcbiAgICAgICAgICAgICAgICB4MiA9IChSICsgZGVsdGEgKiByKSAqIGNvcyh0aGV0YSlcclxuICAgICAgICAgICAgICAgICAgICAgLSBkZWx0YSAqIGQgKiBjb3MoKFIgLyByICsgIGRlbHRhKSAqIHRoZXRhKVxyXG4gICAgICAgICAgICAgICAgICAgICArIG9mZnNldFg7XHJcbiAgICAgICAgICAgICAgICB5MiA9IChSICsgZGVsdGEgKiByKSAqIHNpbih0aGV0YSlcclxuICAgICAgICAgICAgICAgICAgICAgLSBkICogc2luKChSIC8gciArIGRlbHRhKSAqIHRoZXRhKVxyXG4gICAgICAgICAgICAgICAgICAgICArIG9mZnNldFk7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgyLCB5Mik7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKGkgPD0gKHIgKiBudW0pIC8gKFIgKyBkZWx0YSAqIHIpICogMzYwKTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGVTaGFwZTogZnVuY3Rpb24gKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZVJhdGlvID0gTnVtYmVyKHJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgdmFyIG5ld1IgPSBOdW1iZXIoc2hhcGUuciAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgICAgICB2YXIgbmV3UjAgPSBOdW1iZXIoc2hhcGUucjAgKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIG5ld0QgPSBOdW1iZXIoc2hhcGUuZCAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgICAgICBuZXdSID0gcGFyc2VJbnQobmV3UiwgMTApO1xyXG4gICAgICAgICAgICBuZXdSMCA9IHBhcnNlSW50KG5ld1IwLCAxMCk7XHJcbiAgICAgICAgICAgIG5ld0QgPSBwYXJzZUludChuZXdELCAxMCk7XHJcbiAgICAgICAgICAgIC8vIOaMieavlOS+i+e8qeaUvlxyXG4gICAgICAgICAgICB0aGlzLnNldFNoYXBlKHtcclxuICAgICAgICAgICAgICAgIHI6IG5ld1IsXHJcbiAgICAgICAgICAgICAgICByMDogbmV3UjAsXHJcbiAgICAgICAgICAgICAgICBkOiBuZXdEXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1Ryb2Nob2lkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOi3r+W+hDxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLlBhdGhcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgdmFyIHBhdGggPSBuZXcgbm9kZS5QYXRoKHtcclxuICogICAgICAgICAgIHBhdGhEYXRhOiAnTTkgMGw4IDgtMTcgMTcgNyA3IDE3LTE3IDggOHYtMjNoLTIzeicsXHJcbiAqICAgICAgICAgICByZWN0OiB7eDowLHk6MCx3aWR0aDozMCxoZWlnaHQ6MzB9LFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246IFs2MCw2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChwYXRoKTtcclxuICovXHJcblxyXG4gICAgdmFyIHBhdGhUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvdG9vbC9wYXRoJyk7XHJcbiAgICB2YXIgRHJhZ2dhYmxlID0gcmVxdWlyZSgnenJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlJyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZmxvd05vZGUgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJyk7XHJcblxyXG4gICAgZnVuY3Rpb24gWlBhdGgob3B0cykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gb3B0aW9ucyDlj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtTdHJpbmd9IG9wdGlvbnMucGF0aERhdGEgcGF0aOaVsOaNruOAglxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gb3B0aW9ucy5yZWN0IOWbvuW9oueahOWkp+Wwj+OAglxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gb3B0aW9ucy5yZWN0LndpZHRoIOWbvuW9oueahOWuveW6puOAglxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gb3B0aW9ucy5yZWN0LmhlaWdodCDlm77lvaLnmoTpq5jluqbjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IFtvcHRpb25zLmxheW91dD1udWxsXSDpu5jorqTkuLpudWxsICDku4XmlK/mjIFcImNlbnRlclwiXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHN0eWxlOnsgZmlsbDogJ25vbmUnLHN0cm9rZTogJyMyYzJjMmMnfSxcclxuICAgICAgICAgICAgcmVjdDp7eDowLHk6MCx3aWR0aDowLGhlaWdodDowfSxcclxuICAgICAgICAgICAgcmVjdEhvdmVyOiB0cnVlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcGF0aERhdGEgPSBvcHRzLnBhdGhEYXRhO1xyXG4gICAgICAgIHZhciBtb2RlbCA9IGZsb3dOb2RlLmdlbk1vZGVsKFwiUGF0aFwiLCBvcHRzKTtcclxuICAgICAgICBkZWxldGUgb3B0cy5wYXRoRGF0YTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdHMsIHRydWUpO1xyXG4gICAgICAgIHZhciBwYXRoID0gcGF0aFRvb2wuY3JlYXRlRnJvbVN0cmluZyhwYXRoRGF0YSwgdGhpcy5vcHRpb25zKTtcclxuICAgICAgICBwYXRoLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgRHJhZ2dhYmxlLmNhbGwocGF0aCk7XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLm9wdGlvbnMucmVjdDtcclxuICAgICAgICB2YXIgbGF5b3V0ID0gb3B0cy5sYXlvdXQ7XHJcbiAgICAgICAgaWYgKHJlY3QpIHtcclxuICAgICAgICAgICAgdmFyIGFzcGVjdCA9IGJvdW5kaW5nUmVjdC53aWR0aCAvIGJvdW5kaW5nUmVjdC5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAobGF5b3V0ID09PSAnY2VudGVyJykge1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IHJlY3QgdG8gY2VudGVyLCBrZWVwIHdpZHRoIC8gaGVpZ2h0IHJhdGlvLlxyXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVjdC5oZWlnaHQgKiBhc3BlY3Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoIDw9IHJlY3Qud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjeCA9IHJlY3QueCArIHJlY3Qud2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN5ID0gcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlY3QueCA9IGN4IC0gd2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgcmVjdC55ID0gY3kgLSBoZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICAgICAgcmVjdC53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgcmVjdC5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplUGF0aChwYXRoLCByZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGF0aC50eXBlID0gJ1pQYXRoJztcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH1cclxuXHJcbiAgICBaUGF0aC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBaUGF0aCxcclxuXHJcbiAgICAgICAgdHlwZTogJ1pQYXRoJyxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNpemUgYSBwYXRoIHRvIGZpdCB0aGUgcmVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlc2l6ZVBhdGg6IGZ1bmN0aW9uIChwYXRoLCByZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGguYXBwbHlUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHBhdGhSZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHBhdGhSZWN0LmNhbGN1bGF0ZVRyYW5zZm9ybShyZWN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBwYXRoLmFwcGx5VHJhbnNmb3JtKG0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlU2hhcGU6IGZ1bmN0aW9uIChyYXRpbywgaWZQYXJzZSkge1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5yZWN0O1xyXG4gICAgICAgICAgICB2YXIgbmV3VyA9IE51bWJlcihyZWN0LndpZHRoICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBuZXdIID0gTnVtYmVyKG5ld1cgKiByZWN0LmhlaWdodCAvIHJlY3Qud2lkdGgpO1xyXG4gICAgICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3VyA9IHBhcnNlSW50KG5ld1csIDEwKTtcclxuICAgICAgICAgICAgICAgIG5ld0ggPSBwYXJzZUludChuZXdILCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVjdC53aWR0aCA9IG5ld1c7XHJcbiAgICAgICAgICAgIHJlY3QuaGVpZ2h0ID0gbmV3SDtcclxuICAgICAgICAgICAgLy8g5oyJ5q+U5L6L57yp5pS+XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cigncmVjdCcsIHJlY3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHpyVXRpbC5pbmhlcml0cyhaUGF0aCwgRHJhZ2dhYmxlKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gWlBhdGg7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5Zu+5b2i5oyJ6ZKuPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuSWNvbkJ1dHRvblxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgaWNvbkJ1dHRvbiAgID0gbmV3IG5vZGUuSWNvbkJ1dHRvbih7XHJcbiAqICAgICAgICAgIHRpdGxlOidJY29uQnV0dG9uJyxcclxuICogICAgICAgICAgaWNvbjoncGF0aDovL000MzIuNDUsNTk1LjQ0NGMwLDIuMTc3LTQuNjYxLDYuODItMTEuMzA1LDYuODJjLTYuNDc1LDAtMTEuMzA2LTQuNTY3LTExLjMwNi02LjgyczQuODUyLTYuODEyLDExLjMwNi02LjgxMkM0MjcuODQxLDU4OC42MzIsNDMyLjQ1Miw1OTMuMTkxLDQzMi40NSw1OTUuNDQ0TDQzMi40NSw1OTUuNDQ0eiBNNDIxLjE1NSw1ODkuODc2Yy0zLjAwOSwwLTUuNDQ4LDIuNDk1LTUuNDQ4LDUuNTcyczIuNDM5LDUuNTcyLDUuNDQ4LDUuNTcyYzMuMDEsMCw1LjQ0OS0yLjQ5NSw1LjQ0OS01LjU3MkM0MjYuNjA0LDU5Mi4zNzEsNDI0LjE2NSw1ODkuODc2LDQyMS4xNTUsNTg5Ljg3Nkw0MjEuMTU1LDU4OS44NzZ6IE00MjEuMTQ2LDU5MS44OTFjLTEuOTE2LDAtMy40NywxLjU4OS0zLjQ3LDMuNTQ5YzAsMS45NTksMS41NTQsMy41NDgsMy40NywzLjU0OHMzLjQ2OS0xLjU4OSwzLjQ2OS0zLjU0OEM0MjQuNjE0LDU5My40NzksNDIzLjA2Miw1OTEuODkxLDQyMS4xNDYsNTkxLjg5MUw0MjEuMTQ2LDU5MS44OTF6TTQyMS4xNDYsNTkxLjg5MScsXHJcbiAqICAgICAgICAgIGl0ZW1TaXplOjUwLFxyXG4gKiAgICAgICAgICBwb3NpdGlvbjpbNjAsNjBdXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQoaWNvbkJ1dHRvbik7XHJcbiAqL1xyXG5cclxuXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgZmxvd05vZGUgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJyk7XHJcblxyXG4gICAgZnVuY3Rpb24gSWNvbkJ1dHRvbihvcHRzKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gb3B0aW9ucyDmnoTpgKDlj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtTdHJpbmd9IG9wdGlvbnMudGl0bGU9XCJcIiDpvKDmoIfnp7vkuIrljrvmmL7npLrnmoTmloflrZdcclxuICAgICAgICAgKiBAY2ZnIHtTdHJpbmd9IG9wdGlvbnMuaWNvbj1cIlwiIEljb24g55qEIHBhdGgg5a2X56ym5Liy77yM5pSv5oyB5L2/55So6Ieq5a6a5LmJ55qEIHN2ZyBwYXRoIOS9nOS4uiBpY29u77yM5qC85byP5Y+C6KeBIFtTVkcgUGF0aERhdGFdKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YSnjgILlj6/ku6Xku44gQWRvYmUgSWxsdXN0cmF0b3Ig562J5bel5YW357yW6L6R5a+85Ye644CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBvcHRpb25zLml0ZW1TaXplPTE1ICBpY29uIOeahOWkp+Wwj1xyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gb3B0aW9ucy5pY29uU3R5bGUgIOWbvuagh+agt+W8j1xyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gb3B0aW9ucy5pY29uU3R5bGUubm9ybWFsIOato+W4uOeahOagt+W8j1xyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gb3B0aW9ucy5pY29uU3R5bGUubm9ybWFsLnN0cm9rZT0nIzY2Nicg5q2j5bi455qE5qC35byP77yI5o+P6L656Imy77yJXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBvcHRpb25zLmljb25TdHlsZS5ub3JtYWwuZmlsbD0nbm9uZScg5q2j5bi455qE5qC35byP77yI5aGr5YWF6Imy77yJXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBvcHRpb25zLmljb25TdHlsZS5lbXBoYXNpcyDpq5jkuq7nirbmgIHkuIvnmoTmoLflvI9cclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IG9wdGlvbnMuaWNvblN0eWxlLmVtcGhhc2lzLnN0cm9rZT0nIzY2Nicg6auY5Lqu54q25oCB5LiL55qE5qC35byP77yI5o+P6L656Imy77yJXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBvcHRpb25zLmljb25TdHlsZS5lbXBoYXNpcy5maWxsPSdub25lJyDpq5jkuq7nirbmgIHkuIvnmoTmoLflvI/vvIjloavlhYXoibLvvIlcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjY2NjJyxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOmZhbHNlLFxyXG4gICAgICAgICAgICBzZWxlY3RhYmxlOmZhbHNlLFxyXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMCxcclxuICAgICAgICAgICAgaXRlbVNpemU6IDE1LFxyXG4gICAgICAgICAgICBzaG93VGl0bGU6IHRydWUsXHJcbiAgICAgICAgICAgIGljb246XCJcIiwgIC8vSWNvbiDnmoQgcGF0aCDlrZfnrKbkuLLvvIzmlK/mjIHkvb/nlKjoh6rlrprkuYnnmoQgc3ZnIHBhdGgg5L2c5Li6IGljb27vvIzmoLzlvI/lj4Lop4EgU1ZHIFBhdGhEYXRh44CC5Y+v5Lul5LuOIEFkb2JlIElsbHVzdHJhdG9yIOetieW3peWFt+e8lui+keWvvOWHuuOAglxyXG4gICAgICAgICAgICBpY29uU3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG5vcm1hbDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJyM2NjYnLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICdub25lJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVtcGhhc2lzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzNFOThjNSdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0genJVdGlsLm1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRzLCB0cnVlKTtcclxuXHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IGZsb3dOb2RlLmdlbk1vZGVsKFwiSWNvbkJ1dHRvblwiLCB0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIGdyYXBoaWMuR3JvdXAuY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9XHJcbiAgICBJY29uQnV0dG9uLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogSWNvbkJ1dHRvbixcclxuICAgICAgICB0eXBlOiBcIkljb25CdXR0b25cIixcclxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5vcm1hbFN0eWxlID0gdGhpcy5vcHRpb25zLmljb25TdHlsZS5ub3JtYWw7XHJcbiAgICAgICAgICAgIHZhciBob3ZlclN0eWxlID0gdGhpcy5vcHRpb25zLmljb25TdHlsZS5lbXBoYXNpcztcclxuICAgICAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5vcHRpb25zLml0ZW1TaXplO1xyXG4gICAgICAgICAgICB2YXIgaWNvbiA9IHRoaXMub3B0aW9ucy5pY29uO1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiAtaXRlbVNpemUgLyAyLFxyXG4gICAgICAgICAgICAgICAgeTogLWl0ZW1TaXplIC8gMixcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBpdGVtU2l6ZSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaXRlbVNpemVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIHBhdGggPSBpY29uLmluZGV4T2YoJ2ltYWdlOi8vJykgPT09IDAgP1xyXG4gICAgICAgICAgICAgICAgKFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmltYWdlID0gaWNvbi5zbGljZSg4KSxcclxuICAgICAgICAgICAgICAgICAgICBuZXcgZ3JhcGhpYy5JbWFnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICApIDpcclxuICAgICAgICAgICAgICAgIGdyYXBoaWMubWFrZVBhdGgoXHJcbiAgICAgICAgICAgICAgICAgICAgaWNvbi5yZXBsYWNlKCdwYXRoOi8vJywgJycpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBub3JtYWxTdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJTdHlsZTogaG92ZXJTdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdEhvdmVyOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICAnY2VudGVyJ1xyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZShwYXRoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd1RpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoLl9fdGl0bGUgPSB0aGlzLm9wdGlvbnMudGl0bGU7XHJcbiAgICAgICAgICAgICAgICBwYXRoLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBub3QgcmV1c2UgYWJvdmUgaG92ZXJTdHlsZSwgd2hpY2ggbWlnaHQgYmUgbW9kaWZpZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguc2V0U3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5vcHRpb25zLnRpdGxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uOiBob3ZlclN0eWxlLnRleHRQb3NpdGlvbiB8fCAnYm90dG9tJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRGaWxsOiBob3ZlclN0eWxlLmZpbGwgfHwgaG92ZXJTdHlsZS5zdHJva2UgfHwgJyMwMDAnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiBob3ZlclN0eWxlLnRleHRBbGlnbiB8fCAnY2VudGVyJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRTdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0RmlsbDogbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcGF0aC50cmlnZ2VyKCdub3JtYWwnKTtcclxuICAgICAgICAgICAgdGhpcy5hZGQocGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhJY29uQnV0dG9uLCBncmFwaGljLkdyb3VwKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gSWNvbkJ1dHRvbjtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9JY29uQnV0dG9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXHJcbiAqIGZpc2hUb3BvRmxvd+eahGxpbmvlr7nosaHvvIzmoYbmnrbmj5DkvpvnmoTov57nur/pg73mlL7lnKjov5nkuKrlr7nosaHkuIvjgIJcclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5saW5rXHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxuXHJcbiAgICB2YXIgTGluayA9IHJlcXVpcmUoJy4vTGluaycpO1xyXG4gICAgdmFyIEZvbGQgPSByZXF1aXJlKCcuL0ZvbGQnKTtcclxuICAgIHZhciBDdXJ2ZSA9IHJlcXVpcmUoJy4vQ3VydmUnKTtcclxuICAgIHZhciBDaGFpbiA9IHJlcXVpcmUoJy4vQ2hhaW4nKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgZmxvd0xpbmsgPSB7fTtcclxuICAgIGZsb3dMaW5rLkxpbmsgPSBmbG93TGlua1tDb25uZWN0b3IuVFlQRV9TVFJBSUdIVF0gPSBMaW5rO1xyXG4gICAgZmxvd0xpbmsuRm9sZCA9IGZsb3dMaW5rW0Nvbm5lY3Rvci5UWVBFX0pBR0dFRF0gPSBGb2xkO1xyXG4gICAgZmxvd0xpbmsuQ3VydmUgPSBmbG93TGlua1tDb25uZWN0b3IuVFlQRV9DVVJWRV0gPSBDdXJ2ZTtcclxuICAgIGZsb3dMaW5rLkNoYWluID0gZmxvd0xpbmtbQ29ubmVjdG9yLlRZUEVfQ0hBSU5dID0gQ2hhaW47XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZsb3dMaW5rO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGNvbnN0cnVjdG9yXHJcbiAqIOi/nue6v+eahOaehOmAoOWHveaVsFxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IHN0YXJ0Tm9kZSDlvIDlp4voioLngrlcclxuICogQHBhcmFtICB7T2JqZWN0fSBlbmROb2RlICAg57uT5p2f6IqC54K5XHJcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyDnur/mrrXpgInpoblcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN0eWxlXSDoioLngrnnmoTmoLflvI9cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0eWxlLmxpbmVXaWR0aD0xXSDnur/mrrXnmoTlrr3luqZcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN0eWxlLmxpbmVUeXBlPSdzdHJhaWdodCddIOe6v+auteeahOexu+WeiyBlZy4gJ3N0cmFpZ2h0JywgJ2phZ2dlZCcsJ2N1cnZlJ1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3R5bGUuc3Ryb2tlPVwiIzAwMDAwMFwiXSDnur/mrrXnmoTpopzoibLlgLwgZWcuICcjMTU3Y2ZmJyAgJ3JnYigxMjIsMTIyLDEyMiknXHJcbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5zdHlsZS5saW5lRGFzaF0g6Jma57q/55qE6Ze06ZqUIGVnLiBbMywzXVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc3ltYm9sXSDnur/mrrXnmoTnrq3lpLRcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN5bWJvbC50eXBlPSdhcnJvdyddIOe6v+auteeahOeureWktOeahOexu+WeiyDlj6/pgInlgLzkuLrvvJogJ2NpcmNsZScsICdyZWN0JywgJ3JvdW5kUmVjdCcsICd0cmlhbmdsZScsICdkaWFtb25kJywgJ3BpbicsICdhcnJvdydcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN5bWJvbC5zaXplPTEwXSDnur/mrrXnmoTnrq3lpLTnmoTlsLrlr7hcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN5bWJvbC5jb2xvcj0nIzAwMDAwMCddIOe6v+auteeahOeureWktOeahOminOiJslxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLnpdIFvnrq3lpLTnmoTlsYLnuqfvvIzotorlpKfotorlnKjliY3pnaLmmL7npLpdXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3ltYm9sLmJvdGhdIFvmjIflrprmmK/lkKblnKjov57nur/nmoTpppbkuI7lsL7pg73nlLvnrq3lpLQg6buY6K6k5pivZmFsc2VdXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zeW1ib2wub2Zmc2V0XSDorr7nva7nrq3lpLTlnKjov57nur/kuIrnmoTlgY/np7vph4/vvIzpu5jorqTmmK8w77yb5q2k5bGe5oCn5Y+q6ZKI5a+555u057q/5ZKM5oqY57q/57G75Z6L5pyJ5pWI77yM5aaC5p6c5piv5oqY57q/77yMb2Zmc2V05pyA5aSn5YC85LiN6IO96LaF6L+Hb3B0aW9ucy5idW5kbGVPZmZzZXQo6buY6K6k5pivMzAp6K6+572u55qE5YC8IHNpbmNlIFYyLjMuMFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudGV4dF0g57q/5q615LiK55qE5paH5a2XXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRdIOe6v+auteS4iueahOaWh+Wtl+WGheWuuVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC5jb2xvcl0g57q/5q615LiK55qE5paH5a2X6aKc6ImyXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRQb3NdIOaWh+Wtl+S9jee9ruWPr+mAieWAvCAnc3RhcnQnLCdjZW50ZXInLCdlbmQnLOm7mOiupOWAvOS4umNlbnRlclxyXG4gKiBAcGFyYW0ge051bWJlcnxBcnJheX0gW29wdGlvbnMudGV4dC5vZmZzZXRdIOaWh+Wtl+S9jee9ruWBj+enu+mHjyzkuLpudW1iZXLliJnmmK945YGP56e7IGFycmF55YiZ5Li6W3gseV1cclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50ZXh0LnRleHRSb3RhdGVhYmxlXSDmloflrZfpmo/nur/mrrXml4vovawsIOm7mOiupOWAvOS4unRydWVcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltYWdlXSDnur/mrrXkuIrnmoTlm77niYfoioLngrlcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmltYWdlLmltYWdlXSDnur/mrrXkuIrnmoTlm77niYfoioLngrnnmoTot6/lvoRcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmltYWdlLmltYWdlUG9zXSDnur/mrrXkuIrnmoTlm77niYfoioLngrnkvY3nva7lj6/pgInlgLwgJ3N0YXJ0JywnY2VudGVyJywnZW5kJyzpu5jorqTlgLzkuLpjZW50ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ8QXJyYXl9IFtvcHRpb25zLmltYWdlLm9mZnNldF0g57q/5q615LiK55qE5Zu+54mH5L2N572u5YGP56e76YePLOS4um51bWJlcuWImeaYr3jlgY/np7sgYXJyYXnliJnkuLpbeCx5XVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmltYWdlLmltYWdlUm90YXRlYWJsZV0g5Zu+54mH6ZqP57q/5q615peL6L2sLCDpu5jorqTlgLzkuLp0cnVlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NdIOS/neeVmSDor7fkvb/nlKhvcHRpb25zLnBvc2l0aW9uLmRpcmVjdGlvbiDmjIflrprnur/mrrXotbflp4vkuI7nu4jmraIg5Zyo6IqC54K555qE5LuA5LmI5L2N572uIOm7mOiupOWAvOS4uidsZWZ0LHJpZ2h0JyAg5Y+v5Y+W5YC85Zub5Liq5pa55ZCRdG9wLGJvdHRvbSxsZWZ0LHJpZ2h0IOaWueWQkeWPr+WKoOWBj+enu+mHj+WmguWmgiBcImxlZnQrMTAsdG9wXCJcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uXSDmjIflrprnur/mrrXkvY3nva5cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLmRpcmVjdGlvbl0g5oyH5a6a57q/5q616LW35aeL5LiO57uI5q2iIOWcqOiKgueCueeahOS7gOS5iOS9jee9riDpu5jorqTlgLzkuLonbGVmdCxyaWdodCcgIOWPr+WPluWAvOWbm+S4quaWueWQkXRvcCxib3R0b20sbGVmdCxyaWdodCDmlrnlkJHlj6/liqDlgY/np7vph4/lpoLlpoIgXCJsZWZ0KzEwLHRvcFwiXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5zdGFydE9mZnNldF0g57q/5q615byA5aeL5L2N572u55qE5YGP56e7XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5lbmRPZmZzZXRdIOe6v+autee7k+adn+S9jee9rueahOWBj+enu1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb24uZXNjYXBlRGlzdGFuY2VdIOaMh+Wumue6v+auteesrOS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOacgOWQjuS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOm7mOiupOWAvOS4ulszMCwgMzBdXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbi5wb2ludHNdIOS4jeS9v+eUqOiHquWKqOiuoeeulyDmjIflrprov57nur/nmoTmipjngrnkvY3nva7mlbDnu4TvvIzpppblsL7lj6/ku6Xkvb/nlKhsZWZ0LHJpZ2h0LHRvcCxib3R0b21cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmVmZmVjdF0g57q/5LiK5Yqo5oCB5pWI5p6cXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5lZmZlY3Quc2hvd10g5piv5ZCm5pi+56S6566t5aS05Yqo5pWIXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lZmZlY3QucGVyaW9kXSDliqjmlYjnp7vliqjpgJ/luqZcclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvQ2hhbmdlUG9zaXRpb25dIOi/nue6v+eahOi/nuaOpeeCuemaj25vZGXnp7vliqjoh6rliqjliIfmjaLkvY3nva7vvIzpu5jorqTkuLpmbGFzZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuel0g6L+e57q/55qE5bGC57qn77yM6LaK5aSn6LaK5Zyo5YmN6Z2i5pi+56S6XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5idW5kbGVPZmZzZXQ9MzBdIOaLhue6v+aLkOinkuWkhOeahOmVv+W6pijnlKjkuo7ov57nur/nu4QpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5idW5kbGVHYXA9MjBdIOWkmue6v+auteeahOmXtOmalCjnlKjkuo7ov57nur/nu4QpXHJcbiAqIEByZXR1cm4ge09iamVjdH0g6L+U5Zue5Yib5bu65oiQ5Yqf55qE6L+e57q/5a+56LGhXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHNldFN0eWxlXHJcbiAqIOWIm+W7uui/nue6v+WQju+8jOiuvue9rui/nue6v+eahOagt+W8j1xyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyDlr7nlupTliJvlu7roioLngrnvvIzkvKDpgJLnmoRvcHRpb25z5Y+C5pWwXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50ZXh0XSDov57nur/mloflrZfnmoTmoLflvI9cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN5bWJvbF0g6L+e57q/566t5aS055qE5qC35byPXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb2xvcl0g6L+e57q/55qE6aKc6ImyXHJcbiAqL1xyXG4vKipcclxuICogQG1ldGhvZCBvblxyXG4gKiDnu5Hlrprkuovku7ZcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIOS4iuS4i+aWh1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIG9mZlxyXG4gKiDop6Pnu5Hkuovku7ZcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIG9uZVxyXG4gKiDljZXmrKHop6blj5Hnu5HlrposdHJpZ2dlcuWQjumUgOavgVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5LqL5Lu25aSE55CG5Ye95pWwXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0g5LiK5LiL5paHXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgdHJpZ2dlclxyXG4gKiDkuovku7bliIblj5FcclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXHJcbiAqL1xyXG4vKipcclxuICogQGV2ZW50IGNsaWNrXHJcbiAqIOWNleWHu+S6i+S7tlxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiBmbGluay5vbignQ29ubmVjdG9yOmNsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgZGJsY2xpY2tcclxuICog5b2T5Y+M5Ye75YWD57Sg5pe277yM5Lya5Y+R55SfIGRibGNsaWNrIOS6i+S7tuOAglxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiBmbGluay5vbignQ29ubmVjdG9yOmRibGNsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xpbmsvZmxvd0xpbmsuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog55u057q/PGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93LmxpbmsuTGlua1xyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubGlua1xyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGxpbmsgPSBmaXNoVG9wb0Zsb3cubGluaztcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICAvL+iKgueCuVxyXG4gKiAgICAgICBmdW5jdGlvbiBuZXdOb2RlKHgsIHksIHcsIGgpIHtcclxuICogICAgICAgICAgIHZhciByZWN0ID0gbmV3IG5vZGUuUmVjdCh7XHJcbiAqICAgICAgICAgICAgICAgc2hhcGU6IHt3aWR0aDogdyxoZWlnaHQ6IGh9LFxyXG4gKiAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbeCwgeV0sXHJcbiAqICAgICAgICAgICAgICAgc3R5bGU6IHtmaWxsOiBcIiMxNjdDRkZcIn1cclxuICogICAgICAgICAgIH0pO1xyXG4gKiAgICAgICAgICAgZmlzaFRvcG8uYWRkKHJlY3QpO1xyXG4gKiAgICAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAqICAgICAgIH1cclxuICogICAgICAgLy/nroDljZXov57nur9cclxuICogICAgICAgZnVuY3Rpb24gbmV3TGluayhzdGFydE5vZGUsIGVuZE5vZGUsIHRleHQsIGRhc2hlZFBhdHRlcm4pIHtcclxuICogICAgICAgICAgIHZhciBzbGluayA9IG5ldyBsaW5rLkxpbmsoc3RhcnROb2RlLCBlbmROb2RlLCB7XHJcbiAqICAgICAgICAgICAgICAgc3R5bGU6IHtsaW5lRGFzaDogW2Rhc2hlZFBhdHRlcm5dfSxcclxuICogICAgICAgICAgICAgICB0ZXh0OiB7dGV4dDogdGV4dH1cclxuICogICAgICAgICAgIH0pXHJcbiAqICAgICAgICAgICBmaXNoVG9wby5hZGQoc2xpbmspO1xyXG4gKiAgICAgICAgICAgcmV0dXJuIHNsaW5rO1xyXG4gKiAgICAgICB9XHJcbiAqICAgICAgIHZhciBmcm9tID0gbmV3Tm9kZSgxMDAsIDYwLCAzMCwgMzApO1xyXG4gKiAgICAgICB2YXIgdG8gPSBuZXdOb2RlKDMwMCwgNjAsIDMwLCAzMCk7XHJcbiAqICAgICAgIG5ld0xpbmsoZnJvbSwgdG8sICfomZrnur/luKbnrq3lpLQnLCA1KTtcclxuICovXHJcblxyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgIHZhciBGbG93ID0gcmVxdWlyZShcIi4uL0Zsb3dcIik7XHJcblxyXG4gICAgZnVuY3Rpb24gTGluayhzdGFydE5vZGUsZW5kTm9kZSxvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdCA9IEZsb3cudHJhbnNsYXRlTGlua09wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgLy/pu5jorqTlsLHmmK/nm7Tnur9cclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gbmV3IENvbm5lY3RvcihvcHQpO1xyXG4gICAgICAgIGNvbm5lY3Rvci5zdGFydE5vZGUgPSBzdGFydE5vZGU7XHJcbiAgICAgICAgY29ubmVjdG9yLmVuZE5vZGUgPSBlbmROb2RlO1xyXG5cclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUJ5UG9pbnRcclxuICAgICAqIOeUqOaIt+aMh+Wumui/nue6v+eahOeCue+8jOadpei/m+ihjOeUu+e6v1xyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIOe6v+autemAiemhuVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN0eWxlXSDoioLngrnnmoTmoLflvI9cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdHlsZS5saW5lV2lkdGg9MV0g57q/5q6155qE5a695bqmXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3R5bGUubGluZVR5cGU9J3N0cmFpZ2h0J10g57q/5q6155qE57G75Z6LIGVnLiAnc3RyYWlnaHQnLCAnamFnZ2VkJywnY3VydmUnXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3R5bGUuc3Ryb2tlPVwiIzAwMDAwMFwiXSDnur/mrrXnmoTpopzoibLlgLwgZWcuICcjMTU3Y2ZmJyAgJ3JnYigxMjIsMTIyLDEyMiknXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMuc3R5bGUubGluZURhc2hdIOiZmue6v+eahOmXtOmalCBlZy4gWzMsM11cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zeW1ib2xdIOe6v+auteeahOeureWktFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN5bWJvbC50eXBlPSdhcnJvdyddIOe6v+auteeahOeureWktOeahOexu+WeiyDlj6/pgInlgLzkuLrvvJogJ2NpcmNsZScsICdyZWN0JywgJ3JvdW5kUmVjdCcsICd0cmlhbmdsZScsICdkaWFtb25kJywgJ3BpbicsICdhcnJvdydcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zeW1ib2wuc2l6ZT0xMF0g57q/5q6155qE566t5aS055qE5bC65a+4XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLmNvbG9yPScjMDAwMDAwJ10g57q/5q6155qE566t5aS055qE6aKc6ImyXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLnpdIFvnrq3lpLTnmoTlsYLnuqfvvIzotorlpKfotorlnKjliY3pnaLmmL7npLpdXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN5bWJvbC5ib3RoXSBb5oyH5a6a5piv5ZCm5Zyo6L+e57q/55qE6aaW5LiO5bC+6YO955S7566t5aS0IOm7mOiupOaYr2ZhbHNlXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN5bWJvbC5vZmZzZXRdIOiuvue9rueureWktOWcqOi/nue6v+S4iueahOWBj+enu+mHj++8jOm7mOiupOaYrzAgc2luY2UgVjIuMy4wXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudGV4dF0g57q/5q615LiK55qE5paH5a2XXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC50ZXh0XSDnur/mrrXkuIrnmoTmloflrZflhoXlrrlcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRGaWxsXSDnur/mrrXkuIrnmoTmloflrZfpopzoibJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRQb3NdIOaWh+Wtl+S9jee9ruWPr+mAieWAvCAnc3RhcnQnLCdjZW50ZXInLCdlbmQnLOm7mOiupOWAvOS4umNlbnRlclxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8QXJyYXl9IFtvcHRpb25zLnRleHQub2Zmc2V0XSDmloflrZfkvY3nva7lgY/np7vph48s5Li6bnVtYmVy5YiZ5piveOWBj+enuyBhcnJheeWImeS4ult4LHldXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRleHQudGV4dFJvdGF0ZWFibGVdIOaWh+Wtl+maj+e6v+auteaXi+i9rCwg6buY6K6k5YC85Li6dHJ1ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltYWdlXSDnur/mrrXkuIrnmoTlm77niYfoioLngrlcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pbWFnZS5pbWFnZV0g57q/5q615LiK55qE5Zu+54mH6IqC54K555qE6Lev5b6EXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaW1hZ2UuaW1hZ2VQb3NdIOe6v+auteS4iueahOWbvueJh+iKgueCueS9jee9ruWPr+mAieWAvCAnc3RhcnQnLCdjZW50ZXInLCdlbmQnLOm7mOiupOWAvOS4umNlbnRlclxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8QXJyYXl9IFtvcHRpb25zLmltYWdlLm9mZnNldF0g57q/5q615LiK55qE5Zu+54mH5L2N572u5YGP56e76YePLOS4um51bWJlcuWImeaYr3jlgY/np7sgYXJyYXnliJnkuLpbeCx5XVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbWFnZS5pbWFnZVJvdGF0ZWFibGVdIOWbvueJh+maj+e6v+auteaXi+i9rCwg6buY6K6k5YC85Li6dHJ1ZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc10g5L+d55WZIOivt+S9v+eUqG9wdGlvbnMucG9zaXRpb24uZGlyZWN0aW9uIOaMh+Wumue6v+autei1t+Wni+S4jue7iOatoiDlnKjoioLngrnnmoTku4DkuYjkvY3nva4g6buY6K6k5YC85Li6J2xlZnQscmlnaHQnICDlj6/lj5blgLzlm5vkuKrmlrnlkJF0b3AsYm90dG9tLGxlZnQscmlnaHQg5pa55ZCR5Y+v5Yqg5YGP56e76YeP5aaC5aaCIFwibGVmdCsxMCx0b3BcIlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uXSDmjIflrprnur/mrrXkvY3nva5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5kaXJlY3Rpb25dIOaMh+Wumue6v+autei1t+Wni+S4jue7iOatoiDlnKjoioLngrnnmoTku4DkuYjkvY3nva4g6buY6K6k5YC85Li6J2xlZnQscmlnaHQnICDlj6/lj5blgLzlm5vkuKrmlrnlkJF0b3AsYm90dG9tLGxlZnQscmlnaHQg5pa55ZCR5Y+v5Yqg5YGP56e76YeP5aaC5aaCIFwibGVmdCsxMCx0b3BcIlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLnN0YXJ0T2Zmc2V0XSDnur/mrrXlvIDlp4vkvY3nva7nmoTlgY/np7tbeCx5XSAgIGVnLiBzdGFydE9mZnNldDpbMCwxMF0g5ZyoeOS4iuWBj+enuzAgeeS4iuWBj+enuzEwXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9zaXRpb24uZW5kT2Zmc2V0XSDnur/mrrXnu5PmnZ/kvY3nva7nmoTlgY/np7tbeCx5XSAgIGVnLiBzdGFydE9mZnNldDpbMCwxMF0g5ZyoeOS4iuWBj+enuzAgeeS4iuWBj+enuzEwXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb24uZXNjYXBlRGlzdGFuY2VdIOaMh+Wumue6v+auteesrOS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOacgOWQjuS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOm7mOiupOWAvOS4ulszMCwgMzBdXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb24ucG9pbnRzXSDkuI3kvb/nlKjoh6rliqjorqHnrpcg5oyH5a6a6L+e57q/55qE5oqY54K55L2N572u5pWw57uE77yM6aaW5bC+5Y+v5Lul5L2/55SobGVmdCxyaWdodCx0b3AsYm90dG9tXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZWZmZWN0XSDnur/kuIrliqjmgIHmlYjmnpxcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5lZmZlY3Quc2hvd10g5piv5ZCm5pi+56S6566t5aS05Yqo5pWIXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZWZmZWN0LnBlcmlvZF0g5Yqo5pWI56e75Yqo6YCf5bqmXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9DaGFuZ2VQb3NpdGlvbl0g6L+e57q/55qE6L+e5o6l54K56ZqPbm9kZeenu+WKqOiHquWKqOWIh+aNouS9jee9ru+8jOm7mOiupOS4umZsYXNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuel0g6L+e57q/55qE5bGC57qn77yM6LaK5aSn6LaK5Zyo5YmN6Z2i5pi+56S6XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnVuZGxlT2Zmc2V0PTMwXSDmi4bnur/mi5Dop5LlpITnmoTplb/luqYo55So5LqO6L+e57q/57uEKVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1bmRsZUdhcD0yMF0g5aSa57q/5q6155qE6Ze06ZqUKOeUqOS6jui/nue6v+e7hClcclxuICAgICAqL1xyXG4gICAgTGluay5jcmVhdGVCeVBvaW50ID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHQgPSBGbG93LnRyYW5zbGF0ZUxpbmtPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgIC8v6buY6K6k5bCx5piv55u057q/XHJcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Iob3B0KTtcclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gTGluaztcclxuXHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGluay9MaW5rLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEZsb3fpnZnmgIHmlrnms5XnsbtcclxuICogQGNsYXNzIGZpc2gudG9wby5GaXNoVG9wb0Zsb3cuRmxvd1xyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL3V0aWwvRmxvd0NvbnN0YW50cy5qc1wiKTtcclxuICAgIHZhciBHcm91cE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL0dyb3VwTm9kZS5qc1wiKTtcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIEZsb3cgPSB7XHJcbiAgICAgICAgRkxPV19UWVBFOiBcImVsZW1lbnRUeXBlXCIsXHJcbiAgICAgICAgTElOSzogXCJjb25uZWN0aW9uXCIsXHJcbiAgICAgICAgUkVDVDogXCJSZWN0XCIsXHJcbiAgICAgICAgR3JvdXA6ICdHcm91cCcsXHJcbiAgICAgICAgSU1BR0U6ICdJbWFnZScsXHJcbiAgICAgICAgVEVYVDogJ1RleHQnLFxyXG4gICAgICAgIENJUkNMRTogJ0NpcmNsZScsXHJcbiAgICAgICAgU0VDVE9SOiAnU2VjdG9yJyxcclxuICAgICAgICBSSU5HOiAnUmluZycsXHJcbiAgICAgICAgUE9MWUdPTjogJ1BvbHlnb24nLFxyXG4gICAgICAgIFBPTFlMSU5FOiAnUG9seWxpbmUnLFxyXG4gICAgICAgIExJTkU6ICdMaW5lJyxcclxuICAgICAgICBCRVpJRVJDVVJWRTogJ0JlemllcmN1cnZlJyxcclxuICAgICAgICBBUkM6ICdBcmMnLFxyXG4gICAgICAgIFNDRU5FOidzY2VuZScsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZXRob2Qgc2V0VXNlckRhdGFcclxuICAgICAgICAgKiDorr7nva7nlKjmiLfmlbDmja5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSDpnIDopoHorr7nva7mlbDmja7nmoToioLngrlcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIOaVsOaNrlxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgIC8v6K6+572u6Ieq5a6a5LmJ5pWw5o2uXHJcbiAgICAgICAgICogICAgICB0aGlzLmZpc2hUb3BvLkZsb3cuc2V0VXNlckRhdGEocmVjdCwgeyBjdXN0b21PYmo6IFwicmVjdFwiIH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldFVzZXJEYXRhOiBmdW5jdGlvbihub2RlLCBvYmopIHtcclxuICAgICAgICAgICAgbm9kZS5tb2RlbC5zZXQoQ29uc3RhbnRzLlVTRVJEQVRBLCBvYmopO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W6K6+572u55qE55So5oi35pWw5o2uXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUg6ZyA6KaB6I635Y+W5pWw5o2u55qE6IqC54K5XHJcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgIOaVsOaNrlxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgIC8v6I635Y+W6Ieq5a6a5LmJ5pWw5o2uXHJcbiAgICAgICAgICogICAgICB0aGlzLmZpc2hUb3BvLkZsb3cuZ2V0VXNlckRhdGEocmVjdCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0VXNlckRhdGE6IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIHVzZXJEYXRhID0gbm9kZS5tb2RlbC5nZXQoQ29uc3RhbnRzLlVTRVJEQVRBKTtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQodXNlckRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICB1c2VyRGF0YSA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyRGF0YTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIpOaWreaYr+WQpuaYr+i/nue6v1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCDlr7nosaHnmoRtb2RlbFxyXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgIC8v5Yik5pat5piv5ZCm5piv6L+e57q/XHJcbiAgICAgICAgICogICAgICB2YXIgbm9kZU1vZGVsID0gZS50YXJnZXQubW9kZWw7XHJcbiAgICAgICAgICogICAgICBpZiAodGhpcy5maXNoVG9wby5GbG93LmlzTGluayhub2RlTW9kZWwpKSB7IHJldHVybiB0cnVlO31cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc0xpbms6IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IG1vZGVsLmdldChGbG93LkZMT1dfVFlQRSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50VHlwZSA9PSBGbG93LkxJTks7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDliKTmlq3mmK/lkKbmmK/oioLngrlcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwg5a+56LGh55qEbW9kZWxcclxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAvL+WIpOaWreaYr+WQpuaYr+iKgueCuVxyXG4gICAgICAgICAqICAgICAgdmFyIG5vZGVNb2RlbCA9IGUudGFyZ2V0Lm1vZGVsO1xyXG4gICAgICAgICAqICAgICAgaWYgKHRoaXMuZmlzaFRvcG8uRmxvdy5pc05vZGUobm9kZU1vZGVsKSkgeyByZXR1cm4gdHJ1ZTt9XHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIGlzTm9kZTogZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbW9kZWwuZ2V0KEZsb3cuRkxPV19UWVBFKTtcclxuICAgICAgICAgICAgdmFyIGlzTm9kZTtcclxuICAgICAgICAgICAgaWYoZWxlbWVudFR5cGUgIT0gIEZsb3cuTElOSyAmJiBlbGVtZW50VHlwZSAhPSAgRmxvdy5TQ0VORSl7XHJcbiAgICAgICAgICAgICAgICBpc05vZGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGlzTm9kZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpc05vZGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNJbkdyb3VwOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudCBpbnN0YW5jZW9mIEdyb3VwTm9kZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc0dyb3VwTm9kZTogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEdyb3VwTm9kZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcmVudFg6IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIEZsb3cuaXNHcm91cE5vZGUobm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblswXSArIEZsb3cucGFyZW50WChub2RlLnBhcmVudClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzBdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcmVudFk6IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIEZsb3cuaXNHcm91cE5vZGUobm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblsxXSArIEZsb3cucGFyZW50WShub2RlLnBhcmVudClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzFdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDliKTmlq3oioLngrnmmK/lkKbmmK/nn6nlvaLoioLngrlcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwg6IqC54K555qEbW9kZWxcclxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAvL+WIpOaWreaYr+WQpuaYr+efqeW9ouiKgueCuVxyXG4gICAgICAgICAqICAgICAgdmFyIG5vZGVNb2RlbCA9IGUudGFyZ2V0Lm1vZGVsO1xyXG4gICAgICAgICAqICAgICAgaWYgKHRoaXMuZmlzaFRvcG8uRmxvdy5pc1JlY3Qobm9kZU1vZGVsKSkgeyByZXR1cm4gdHJ1ZTt9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNSZWN0OiBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBtb2RlbC5nZXQoRmxvdy5GTE9XX1RZUEUpO1xyXG4gICAgICAgICAgICByZXR1cm4gIGVsZW1lbnRUeXBlID09IEZsb3cuUkVDVDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIpOaWreiKgueCueaYr+WQpuaYr+WbvueJh+iKgueCuVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCDoioLngrnnmoRtb2RlbFxyXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgIC8v5Yik5pat5piv5ZCm5piv5Zu+54mH6IqC54K5XHJcbiAgICAgICAgICogICAgICB2YXIgbm9kZU1vZGVsID0gZS50YXJnZXQubW9kZWw7XHJcbiAgICAgICAgICogICAgICBpZiAodGhpcy5maXNoVG9wby5GbG93LmlzSW1hZ2Uobm9kZU1vZGVsKSkgeyByZXR1cm4gdHJ1ZTt9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNJbWFnZTogZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbW9kZWwuZ2V0KEZsb3cuRkxPV19UWVBFKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRUeXBlID09IEZsb3cuSU1BR0U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDliKTmlq3oioLngrnmmK/lkKbmmK/mloflrZfoioLngrlcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwg6IqC54K555qEbW9kZWxcclxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAvL+WIpOaWreaYr+WQpuaYr+aWh+Wtl+iKgueCuVxyXG4gICAgICAgICAqICAgICAgdmFyIG5vZGVNb2RlbCA9IGUudGFyZ2V0Lm1vZGVsO1xyXG4gICAgICAgICAqICAgICAgaWYgKHRoaXMuZmlzaFRvcG8uRmxvdy5pc1RleHQobm9kZU1vZGVsKSkgeyByZXR1cm4gdHJ1ZTt9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNUZXh0OiBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBtb2RlbC5nZXQoRmxvdy5GTE9XX1RZUEUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudFR5cGUgPT0gRmxvdy5URVhUO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yik5pat6IqC54K55piv5ZCm5piv5ZyG5b2i6IqC54K5XHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIOiKgueCueeahG1vZGVsXHJcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcbiAgICAgICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAgLy/liKTmlq3mmK/lkKbmmK/lnIblvaLoioLngrlcclxuICAgICAgICAgKiAgICAgIHZhciBub2RlTW9kZWwgPSBlLnRhcmdldC5tb2RlbDtcclxuICAgICAgICAgKiAgICAgIGlmICh0aGlzLmZpc2hUb3BvLkZsb3cuaXNDaXJjbGUobm9kZU1vZGVsKSkgeyByZXR1cm4gdHJ1ZTt9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNDaXJjbGU6IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IG1vZGVsLmdldChGbG93LkZMT1dfVFlQRSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50VHlwZSA9PSBGbG93LkNJUkNMRTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPluiKgueCueeahOexu+Wei1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCDoioLngrnnmoRtb2RlbFxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgIC8v6I635Y+W6IqC54K557G75Z6LXHJcbiAgICAgICAgICogICAgICB2YXIgbm9kZU1vZGVsID0gZS50YXJnZXQubW9kZWw7XHJcbiAgICAgICAgICogICAgICByZXR1cm4gdGhpcy5maXNoVG9wby5GbG93LmdldFR5cGUobm9kZU1vZGVsKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRUeXBlOiBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBtb2RlbC5nZXQoRmxvdy5GTE9XX1RZUEUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudFR5cGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmFuc2xhdGVMaW5rT3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucG9zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyclBvcyA9IG9wdGlvbnMucG9zLnNwbGl0KFwiLFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyUG9zLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24uc3RhcnRQb3MgPSBhcnJQb3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24uZW5kUG9zID0gYXJyUG9zWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRleHQgJiYgb3B0aW9ucy50ZXh0LmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50ZXh0LnRleHRGaWxsID0gb3B0aW9ucy50ZXh0LmNvbG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBGbG93O1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL0Zsb3cuanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5oqY57q/PGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93LmxpbmsuRm9sZFxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubGlua1xyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGxpbmsgPSBmaXNoVG9wb0Zsb3cubGluaztcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICAvL+iKgueCuVxyXG4gKiAgICAgICBmdW5jdGlvbiBuZXdOb2RlKHgsIHksIHcsIGgpIHtcclxuICogICAgICAgICAgIHZhciByZWN0ID0gbmV3IG5vZGUuUmVjdCh7XHJcbiAqICAgICAgICAgICAgICAgc2hhcGU6IHt3aWR0aDogdyxoZWlnaHQ6IGh9LFxyXG4gKiAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbeCwgeV0sXHJcbiAqICAgICAgICAgICAgICAgc3R5bGU6IHtmaWxsOiBcIiMxNjdDRkZcIn1cclxuICogICAgICAgICAgIH0pO1xyXG4gKiAgICAgICAgICAgZmlzaFRvcG8uYWRkKHJlY3QpO1xyXG4gKiAgICAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAqICAgICAgIH1cclxuICogICAgICAgLy/mipjnur9cclxuICogICAgICAgZnVuY3Rpb24gbmV3Rm9sZExpbmsoc3RhcnROb2RlLCBlbmROb2RlLCB0ZXh0LCBkaXJlY3Rpb24sIGRhc2hlZFBhdHRlcm4pIHtcclxuICogICAgICAgICAgIHZhciBmbGluayA9IG5ldyBsaW5rLkZvbGQoc3RhcnROb2RlLCBlbmROb2RlLCB7XHJcbiAqICAgICAgICAgICAgICAgc3R5bGU6IHtsaW5lRGFzaDogW2Rhc2hlZFBhdHRlcm5dfSxcclxuICogICAgICAgICAgICAgICB0ZXh0OiB7dGV4dDogdGV4dH0sXHJcbiAqICAgICAgICAgICAgICAgcG9zOiBkaXJlY3Rpb25cclxuICogICAgICAgICAgIH0pXHJcbiAqICAgICAgICAgICBmaXNoVG9wby5hZGQoZmxpbmspO1xyXG4gKiAgICAgICAgICAgcmV0dXJuIGZsaW5rO1xyXG4gKiAgICAgICB9XHJcbiAqICAgICAgIHZhciBmcm9tID0gbmV3Tm9kZSgxMDAsIDQwLCAzMCwgMzApO1xyXG4gKiAgICAgICB2YXIgdG8gPSBuZXdOb2RlKDMwMCwgODAsIDMwLCAzMCk7XHJcbiAqICAgICAgIG5ld0ZvbGRMaW5rKGZyb20sIHRvLCAn5oqY57q/Jyk7XHJcbiAqL1xyXG5cclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgRmxvdyA9IHJlcXVpcmUoXCIuLi9GbG93XCIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEZvbGQoc3RhcnROb2RlLGVuZE5vZGUsb3B0aW9ucykge1xyXG4gICAgICAgIC8v5oqY57q/XHJcbiAgICAgICAgdmFyIG9wdCA9IHpyVXRpbC5tZXJnZSh7c3R5bGU6e2xpbmVUeXBlOiBDb25uZWN0b3IuVFlQRV9KQUdHRUR9fSwgb3B0aW9ucywgdHJ1ZSk7XHJcbiAgICAgICAgb3B0ID0gRmxvdy50cmFuc2xhdGVMaW5rT3B0aW9ucyhvcHQpO1xyXG4gICAgICAgIHZhciBjb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKG9wdCk7XHJcbiAgICAgICAgY29ubmVjdG9yLnN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZTtcclxuICAgICAgICBjb25uZWN0b3IuZW5kTm9kZSA9IGVuZE5vZGU7XHJcblxyXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUJ5UG9pbnRcclxuICAgICAqIOeUqOaIt+aMh+Wumui/nue6v+eahOeCue+8jOadpei/m+ihjOeUu+e6v1xyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIOe6v+autemAiemhuVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN0eWxlXSDoioLngrnnmoTmoLflvI9cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdHlsZS5saW5lV2lkdGg9MV0g57q/5q6155qE5a695bqmXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3R5bGUubGluZVR5cGU9J3N0cmFpZ2h0J10g57q/5q6155qE57G75Z6LIGVnLiAnc3RyYWlnaHQnLCAnamFnZ2VkJywnY3VydmUnXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3R5bGUuc3Ryb2tlPVwiIzAwMDAwMFwiXSDnur/mrrXnmoTpopzoibLlgLwgZWcuICcjMTU3Y2ZmJyAgJ3JnYigxMjIsMTIyLDEyMiknXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMuc3R5bGUubGluZURhc2hdIOiZmue6v+eahOmXtOmalCBlZy4gWzMsM11cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zeW1ib2xdIOe6v+auteeahOeureWktFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN5bWJvbC50eXBlPSdhcnJvdyddIOe6v+auteeahOeureWktOeahOexu+WeiyDlj6/pgInlgLzkuLrvvJogJ2NpcmNsZScsICdyZWN0JywgJ3JvdW5kUmVjdCcsICd0cmlhbmdsZScsICdkaWFtb25kJywgJ3BpbicsICdhcnJvdydcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zeW1ib2wuc2l6ZT0xMF0g57q/5q6155qE566t5aS055qE5bC65a+4XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLmNvbG9yPScjMDAwMDAwJ10g57q/5q6155qE566t5aS055qE6aKc6ImyXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLnpdIFvnrq3lpLTnmoTlsYLnuqfvvIzotorlpKfotorlnKjliY3pnaLmmL7npLpdXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN5bWJvbC5ib3RoXSBb5oyH5a6a5piv5ZCm5Zyo6L+e57q/55qE6aaW5LiO5bC+6YO955S7566t5aS0IOm7mOiupOaYr2ZhbHNlXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN5bWJvbC5vZmZzZXRdIOiuvue9rueureWktOWcqOi/nue6v+S4iueahOWBj+enu+mHj++8jOm7mOiupOaYrzDvvJtvZmZzZXTmnIDlpKflgLzkuI3og73otoXov4dvcHRpb25zLmJ1bmRsZU9mZnNldCjpu5jorqQzMCkg6K6+572u55qE5YC8IHNpbmNlIFYyLjMuMFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRleHRdIOe6v+auteS4iueahOaWh+Wtl1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHQudGV4dF0g57q/5q615LiK55qE5paH5a2X5YaF5a65XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC5jb2xvcl0g57q/5q615LiK55qE5paH5a2X6aKc6ImyXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC50ZXh0UG9zXSDmloflrZfkvY3nva7lj6/pgInlgLwgJ3N0YXJ0JywnY2VudGVyJywnZW5kJyzpu5jorqTlgLzkuLpjZW50ZXJcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfEFycmF5fSBbb3B0aW9ucy50ZXh0Lm9mZnNldF0g5paH5a2X5L2N572u5YGP56e76YePLOS4um51bWJlcuWImeaYr3jlgY/np7sgYXJyYXnliJnkuLpbeCx5XVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc10g5L+d55WZIOivt+S9v+eUqG9wdGlvbnMucG9zaXRpb24uZGlyZWN0aW9uIOaMh+Wumue6v+autei1t+Wni+S4jue7iOatoiDlnKjoioLngrnnmoTku4DkuYjkvY3nva4g6buY6K6k5YC85Li6J2xlZnQscmlnaHQnICDlj6/lj5blgLzlm5vkuKrmlrnlkJF0b3AsYm90dG9tLGxlZnQscmlnaHQg5pa55ZCR5Y+v5Yqg5YGP56e76YeP5aaC5aaCIFwibGVmdCsxMCx0b3BcIlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uXSDmjIflrprnur/mrrXkvY3nva5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5kaXJlY3Rpb25dIOaMh+Wumue6v+autei1t+Wni+S4jue7iOatoiDlnKjoioLngrnnmoTku4DkuYjkvY3nva4g6buY6K6k5YC85Li6J2xlZnQscmlnaHQnICDlj6/lj5blgLzlm5vkuKrmlrnlkJF0b3AsYm90dG9tLGxlZnQscmlnaHQg5pa55ZCR5Y+v5Yqg5YGP56e76YeP5aaC5aaCIFwibGVmdCsxMCx0b3BcIlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLnN0YXJ0T2Zmc2V0XSDnur/mrrXlvIDlp4vkvY3nva7nmoTlgY/np7tcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5lbmRPZmZzZXRdIOe6v+autee7k+adn+S9jee9rueahOWBj+enu1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uLmVzY2FwZURpc3RhbmNlXSDmjIflrprnur/mrrXnrKzkuIDmnaHmipjnur/nmoTplb/luqbvvIzmnIDlkI7kuIDmnaHmipjnur/nmoTplb/luqbvvIzpu5jorqTlgLzkuLpbMzAsIDMwXVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uLnBvaW50c10g5LiN5L2/55So6Ieq5Yqo6K6h566XIOaMh+Wumui/nue6v+eahOaKmOeCueS9jee9ruaVsOe7hO+8jOmmluWwvuWPr+S7peS9v+eUqGxlZnQscmlnaHQsdG9wLGJvdHRvbVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmVmZmVjdF0g57q/5LiK5Yqo5oCB5pWI5p6cXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZWZmZWN0LnNob3ddIOaYr+WQpuaYvuekuueureWktOWKqOaViFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVmZmVjdC5wZXJpb2RdIOWKqOaViOenu+WKqOmAn+W6plxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvQ2hhbmdlUG9zaXRpb25dIOi/nue6v+eahOi/nuaOpeeCuemaj25vZGXnp7vliqjoh6rliqjliIfmjaLkvY3nva7vvIzpu5jorqTkuLpmbGFzZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnpdIOi/nue6v+eahOWxgue6p++8jOi2iuWkp+i2iuWcqOWJjemdouaYvuekulxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1bmRsZU9mZnNldD0zMF0g5ouG57q/5ouQ6KeS5aSE55qE6ZW/5bqmKOeUqOS6jui/nue6v+e7hClcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5idW5kbGVHYXA9MjBdIOWkmue6v+auteeahOmXtOmalCjnlKjkuo7ov57nur/nu4QpXHJcbiAgICAgKi9cclxuICAgIEZvbGQuY3JlYXRlQnlQb2ludCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgb3B0ID0genJVdGlsLm1lcmdlKHtzdHlsZTp7bGluZVR5cGU6IENvbm5lY3Rvci5UWVBFX0pBR0dFRH19LCBvcHRpb25zLCB0cnVlKTtcclxuICAgICAgICBvcHQgPSBGbG93LnRyYW5zbGF0ZUxpbmtPcHRpb25zKG9wdCk7XHJcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Iob3B0KTtcclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBGb2xkO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGluay9Gb2xkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOabsue6vzxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5saW5rLkN1cnZlXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5saW5rXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgbGluayA9IGZpc2hUb3BvRmxvdy5saW5rO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIC8v6IqC54K5XHJcbiAqICAgICAgIGZ1bmN0aW9uIG5ld05vZGUoeCwgeSwgdywgaCkge1xyXG4gKiAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgbm9kZS5SZWN0KHtcclxuICogICAgICAgICAgICAgICBzaGFwZToge3dpZHRoOiB3LGhlaWdodDogaH0sXHJcbiAqICAgICAgICAgICAgICAgcG9zaXRpb246IFt4LCB5XSxcclxuICogICAgICAgICAgICAgICBzdHlsZToge2ZpbGw6IFwiIzE2N0NGRlwifVxyXG4gKiAgICAgICAgICAgfSk7XHJcbiAqICAgICAgICAgICBmaXNoVG9wby5hZGQocmVjdCk7XHJcbiAqICAgICAgICAgICByZXR1cm4gcmVjdDtcclxuICogICAgICAgfVxyXG4gKiAgICAgICAvL+absue6v1xyXG4gKiAgICAgICBmdW5jdGlvbiBuZXdDdXJ2ZUxpbmsoc3RhcnROb2RlLCBlbmROb2RlLCB0ZXh0LCBkaXJlY3Rpb24sIGRhc2hlZFBhdHRlcm4pIHtcclxuICogICAgICAgICAgIHZhciBjbGluayA9IG5ldyBsaW5rLkN1cnZlKHN0YXJ0Tm9kZSwgZW5kTm9kZSwge1xyXG4gKiAgICAgICAgICAgICAgIHN0eWxlOiB7bGluZURhc2g6IFtkYXNoZWRQYXR0ZXJuXX0sXHJcbiAqICAgICAgICAgICAgICAgdGV4dDoge3RleHQ6IHRleHR9LFxyXG4gKiAgICAgICAgICAgICAgIHBvczogZGlyZWN0aW9uXHJcbiAqICAgICAgICAgICB9KVxyXG4gKiAgICAgICAgICAgZmlzaFRvcG8uYWRkKGNsaW5rKTtcclxuICogICAgICAgICAgIHJldHVybiBjbGluaztcclxuICogICAgICAgfVxyXG4gKiAgICAgICB2YXIgZnJvbSA9IG5ld05vZGUoMTAwLCA0MCwgMzAsIDMwKTtcclxuICogICAgICAgdmFyIHRvID0gbmV3Tm9kZSgzMDAsIDgwLCAzMCwgMzApO1xyXG4gKiAgICAgICBuZXdDdXJ2ZUxpbmsoZnJvbSwgdG8sICfmm7Lnur8nKTtcclxuICovXHJcblxyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBGbG93ID0gcmVxdWlyZShcIi4uL0Zsb3dcIik7XHJcbiAgICBmdW5jdGlvbiBDdXJ2ZShzdGFydE5vZGUsZW5kTm9kZSxvcHRpb25zKSB7XHJcbiAgICAgICAgLy/mm7Lnur9cclxuICAgICAgICB2YXIgb3B0ID0genJVdGlsLm1lcmdlKHtzdHlsZTp7bGluZVR5cGU6IENvbm5lY3Rvci5UWVBFX0NVUlZFfX0sIG9wdGlvbnMsIHRydWUpO1xyXG4gICAgICAgIG9wdCA9IEZsb3cudHJhbnNsYXRlTGlua09wdGlvbnMob3B0KTtcclxuXHJcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Iob3B0KTtcclxuICAgICAgICBjb25uZWN0b3Iuc3RhcnROb2RlID0gc3RhcnROb2RlO1xyXG4gICAgICAgIGNvbm5lY3Rvci5lbmROb2RlID0gZW5kTm9kZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVCeVBvaW50XHJcbiAgICAgKiDnlKjmiLfmjIflrprov57nur/nmoTngrnvvIzmnaXov5vooYznlLvnur9cclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyDnur/mrrXpgInpoblcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zdHlsZV0g6IqC54K555qE5qC35byPXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3R5bGUubGluZVdpZHRoPTFdIOe6v+auteeahOWuveW6plxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN0eWxlLmxpbmVUeXBlPSdzdHJhaWdodCddIOe6v+auteeahOexu+WeiyBlZy4gJ3N0cmFpZ2h0JywgJ2phZ2dlZCcsJ2N1cnZlJ1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN0eWxlLnN0cm9rZT1cIiMwMDAwMDBcIl0g57q/5q6155qE6aKc6Imy5YC8IGVnLiAnIzE1N2NmZicgICdyZ2IoMTIyLDEyMiwxMjIpJ1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLnN0eWxlLmxpbmVEYXNoXSDomZrnur/nmoTpl7TpmpQgZWcuIFszLDNdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc3ltYm9sXSDnur/mrrXnmoTnrq3lpLRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wudHlwZT0nYXJyb3cnXSDnur/mrrXnmoTnrq3lpLTnmoTnsbvlnosg5Y+v6YCJ5YC85Li677yaICdjaXJjbGUnLCAncmVjdCcsICdyb3VuZFJlY3QnLCAndHJpYW5nbGUnLCAnZGlhbW9uZCcsICdwaW4nLCAnYXJyb3cnXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3ltYm9sLnNpemU9MTBdIOe6v+auteeahOeureWktOeahOWwuuWvuFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN5bWJvbC5jb2xvcj0nIzAwMDAwMCddIOe6v+auteeahOeureWktOeahOminOiJslxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN5bWJvbC56XSBb566t5aS055qE5bGC57qn77yM6LaK5aSn6LaK5Zyo5YmN6Z2i5pi+56S6XVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zeW1ib2wuYm90aF0gW+aMh+WumuaYr+WQpuWcqOi/nue6v+eahOmmluS4juWwvumDveeUu+eureWktCDpu5jorqTmmK9mYWxzZV1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50ZXh0XSDnur/mrrXkuIrnmoTmloflrZdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRdIOe6v+auteS4iueahOaWh+Wtl+WGheWuuVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHQuY29sb3JdIOe6v+auteS4iueahOaWh+Wtl+minOiJslxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHQudGV4dFBvc10g5paH5a2X5L2N572u5Y+v6YCJ5YC8ICdzdGFydCcsJ2NlbnRlcicsJ2VuZCcs6buY6K6k5YC85Li6Y2VudGVyXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcnxBcnJheX0gW29wdGlvbnMudGV4dC5vZmZzZXRdIOaWh+Wtl+S9jee9ruWBj+enu+mHjyzkuLpudW1iZXLliJnmmK945YGP56e7IGFycmF55YiZ5Li6W3gseV1cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NdIOS/neeVmSDor7fkvb/nlKhvcHRpb25zLnBvc2l0aW9uLmRpcmVjdGlvbiDmjIflrprnur/mrrXotbflp4vkuI7nu4jmraIg5Zyo6IqC54K555qE5LuA5LmI5L2N572uIOm7mOiupOWAvOS4uidsZWZ0LHJpZ2h0JyAg5Y+v5Y+W5YC85Zub5Liq5pa55ZCRdG9wLGJvdHRvbSxsZWZ0LHJpZ2h0IOaWueWQkeWPr+WKoOWBj+enu+mHj+WmguWmgiBcImxlZnQrMTAsdG9wXCJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbl0g5oyH5a6a57q/5q615L2N572uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9zaXRpb24uZGlyZWN0aW9uXSDmjIflrprnur/mrrXotbflp4vkuI7nu4jmraIg5Zyo6IqC54K555qE5LuA5LmI5L2N572uIOm7mOiupOWAvOS4uidsZWZ0LHJpZ2h0JyAg5Y+v5Y+W5YC85Zub5Liq5pa55ZCRdG9wLGJvdHRvbSxsZWZ0LHJpZ2h0IOaWueWQkeWPr+WKoOWBj+enu+mHj+WmguWmgiBcImxlZnQrMTAsdG9wXCJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5zdGFydE9mZnNldF0g57q/5q615byA5aeL5L2N572u55qE5YGP56e7XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9zaXRpb24uZW5kT2Zmc2V0XSDnur/mrrXnu5PmnZ/kvY3nva7nmoTlgY/np7tcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbi5lc2NhcGVEaXN0YW5jZV0g5oyH5a6a57q/5q6156ys5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM5pyA5ZCO5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM6buY6K6k5YC85Li6WzMwLCAzMF1cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbi5wb2ludHNdIOS4jeS9v+eUqOiHquWKqOiuoeeulyDmjIflrprov57nur/nmoTmipjngrnkvY3nva7mlbDnu4TvvIzpppblsL7lj6/ku6Xkvb/nlKhsZWZ0LHJpZ2h0LHRvcCxib3R0b21cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5lZmZlY3RdIOe6v+S4iuWKqOaAgeaViOaenFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmVmZmVjdC5zaG93XSDmmK/lkKbmmL7npLrnrq3lpLTliqjmlYhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lZmZlY3QucGVyaW9kXSDliqjmlYjnp7vliqjpgJ/luqZcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b0NoYW5nZVBvc2l0aW9uXSDov57nur/nmoTov57mjqXngrnpmo9ub2Rl56e75Yqo6Ieq5Yqo5YiH5o2i5L2N572u77yM6buY6K6k5Li6Zmxhc2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy56XSDov57nur/nmoTlsYLnuqfvvIzotorlpKfotorlnKjliY3pnaLmmL7npLpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5idW5kbGVPZmZzZXQ9MzBdIOaLhue6v+aLkOinkuWkhOeahOmVv+W6pijnlKjkuo7ov57nur/nu4QpXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnVuZGxlR2FwPTIwXSDlpJrnur/mrrXnmoTpl7TpmpQo55So5LqO6L+e57q/57uEKVxyXG4gICAgICovXHJcbiAgICBDdXJ2ZS5jcmVhdGVCeVBvaW50ID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHQgPSB6clV0aWwubWVyZ2Uoe3N0eWxlOntsaW5lVHlwZTogQ29ubmVjdG9yLlRZUEVfQ1VSVkV9fSwgb3B0aW9ucywgdHJ1ZSk7XHJcbiAgICAgICAgb3B0ID0gRmxvdy50cmFuc2xhdGVMaW5rT3B0aW9ucyhvcHQpO1xyXG4gICAgICAgIHZhciBjb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKG9wdCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgIH1cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ3VydmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9saW5rL0N1cnZlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOmTvui3ryDmlK/mjIHnur/kuIrlpJrmlofmnKzlsZXnpLrvvIwg5pyA5aSn55qE5LiN5ZCM5pivdGV4dC50ZXh05a+56LGh5Li65pWw57uE57G75Z6L77yM6KGo56S65aSa5Liq5paH5pys55qE5pWw5o2u44CC5pWw57uE5YWD57Sg5Y+v5Lul5Li65a2X56ym5Liy77yM6KGo56S65q+P5Liq5paH5pys55qE5ZCN5a2X77yb5Lmf5Y+v5Lul5piv5Liq5a+56LGh77yM5a+56LGh5Lit5b+F6aG75oyH5a6adGV4dOWxnuaAp++8jOWFtuWAvOS4uuaWh+acrOeahOWQjeWtl++8jOWFtuS9meWxnuaAp+WImeS4uuS4muWKoeS+p+iHquWumuS5ieeahDxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5saW5rLkNoYWluXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5saW5rXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgbGluayA9IGZpc2hUb3BvRmxvdy5saW5rO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIC8v6IqC54K5XHJcbiAqICAgICAgIGZ1bmN0aW9uIG5ld05vZGUoeCwgeSwgdywgaCkge1xyXG4gKiAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgbm9kZS5SZWN0KHtcclxuICogICAgICAgICAgICAgICBzaGFwZToge3dpZHRoOiB3LGhlaWdodDogaH0sXHJcbiAqICAgICAgICAgICAgICAgcG9zaXRpb246IFt4LCB5XSxcclxuICogICAgICAgICAgICAgICBzdHlsZToge2ZpbGw6IFwiIzE2N0NGRlwifVxyXG4gKiAgICAgICAgICAgfSk7XHJcbiAqICAgICAgICAgICBmaXNoVG9wby5hZGQocmVjdCk7XHJcbiAqICAgICAgICAgICByZXR1cm4gcmVjdDtcclxuICogICAgICAgfVxyXG4gKiAgICAgICAvL+iKgueCuemXtOmTvui3r1xyXG4gKiAgICAgICBmdW5jdGlvbiBuZXdDaGFpbihzdGFydE5vZGUsIGVuZE5vZGUsIHRleHQsIGRhc2hlZFBhdHRlcm4pIHtcclxuICogICAgICAgICAgIHZhciBzbGluayA9IG5ldyBsaW5rLkNoYWluKHN0YXJ0Tm9kZSwgZW5kTm9kZSwge1xyXG4gKiAgICAgICAgICAgICAgIHN0eWxlOiB7bGluZURhc2g6IFtkYXNoZWRQYXR0ZXJuXX0sXHJcbiAqICAgICAgICAgICAgICAgdGV4dDoge3RleHQ6IHRleHR9XHJcbiAqICAgICAgICAgICB9KVxyXG4gKiAgICAgICAgICAgZmlzaFRvcG8uYWRkKHNsaW5rKTtcclxuICogICAgICAgICAgIHJldHVybiBzbGluaztcclxuICogICAgICAgfVxyXG4gKiAgICAgICB2YXIgZnJvbSA9IG5ld05vZGUoMTAwLCA2MCwgMzAsIDMwKTtcclxuICogICAgICAgdmFyIHRvID0gbmV3Tm9kZSgzMDAsIDYwLCAzMCwgMzApO1xyXG4gKiAgICAgICBuZXdDaGFpbihmcm9tLCB0bywgW3t0ZXh0OiAn5YC+5pac5paH5pysMScsIGxpbmtJZDogMTAwfSwge3RleHQ6ICflgL7mlpzmlofmnKwyJywgbGlua0lkOiAxMTF9LCB7dGV4dDogJ+WAvuaWnOaWh+acrDMnLCBsaW5rSWQ6IDExMn1dLCA1KTtcclxuICovXHJcblxyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgIHZhciBGbG93ID0gcmVxdWlyZShcIi4uL0Zsb3dcIik7XHJcblxyXG4gICAgZnVuY3Rpb24gQ2hhaW4oc3RhcnROb2RlLGVuZE5vZGUsb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMuc3R5bGUubGluZVR5cGUgPSBDb25uZWN0b3IuVFlQRV9DSEFJTlxyXG4gICAgICAgIHZhciBvcHQgPSBGbG93LnRyYW5zbGF0ZUxpbmtPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgIHZhciBjb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKG9wdCk7XHJcbiAgICAgICAgY29ubmVjdG9yLnN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZTtcclxuICAgICAgICBjb25uZWN0b3IuZW5kTm9kZSA9IGVuZE5vZGU7XHJcblxyXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgY3JlYXRlQnlQb2ludFxyXG4gICAgICog55So5oi35oyH5a6a6L+e57q/55qE54K577yM5p2l6L+b6KGM55S757q/XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMg57q/5q616YCJ6aG5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc3R5bGVdIOiKgueCueeahOagt+W8j1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0eWxlLmxpbmVXaWR0aD0xXSDnur/mrrXnmoTlrr3luqZcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5saW5lVHlwZT0nc3RyYWlnaHQnXSDnur/mrrXnmoTnsbvlnosgZWcuICdzdHJhaWdodCcsICdqYWdnZWQnLCdjdXJ2ZSdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5zdHJva2U9XCIjMDAwMDAwXCJdIOe6v+auteeahOminOiJsuWAvCBlZy4gJyMxNTdjZmYnICAncmdiKDEyMiwxMjIsMTIyKSdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5zdHlsZS5saW5lRGFzaF0g6Jma57q/55qE6Ze06ZqUIGVnLiBbMywzXVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN5bWJvbF0g57q/5q6155qE566t5aS0XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLnR5cGU9J2Fycm93J10g57q/5q6155qE566t5aS055qE57G75Z6LIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN5bWJvbC5zaXplPTEwXSDnur/mrrXnmoTnrq3lpLTnmoTlsLrlr7hcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wuY29sb3I9JyMwMDAwMDAnXSDnur/mrrXnmoTnrq3lpLTnmoTpopzoibJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wuel0gW+eureWktOeahOWxgue6p++8jOi2iuWkp+i2iuWcqOWJjemdouaYvuekul1cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3ltYm9sLmJvdGhdIFvmjIflrprmmK/lkKblnKjov57nur/nmoTpppbkuI7lsL7pg73nlLvnrq3lpLQg6buY6K6k5pivZmFsc2VdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3ltYm9sLm9mZnNldF0g6K6+572u566t5aS05Zyo6L+e57q/5LiK55qE5YGP56e76YeP77yM6buY6K6k5pivMCBzaW5jZSBWMi4zLjBcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50ZXh0XSDnur/mrrXkuIrnmoTmloflrZdcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50ZXh0LnRleHRdIOS4uuaVsOe7hOexu+Wei++8jOihqOekuuWkmuS4quaWh+acrOeahOaVsOaNruOAguaVsOe7hOWFg+e0oOWPr+S7peS4uuWtl+espuS4su+8jOihqOekuuavj+S4quaWh+acrOeahOWQjeWtl++8m+S5n+WPr+S7peaYr+S4quWvueixoe+8jOWvueixoeS4reW/hemhu+aMh+WumnRleHTlsZ7mgKfvvIzlhbblgLzkuLrmlofmnKznmoTlkI3lrZfvvIzlhbbkvZnlsZ7mgKfliJnkuLrkuJrliqHkvqfoh6rlrprkuYnnmoRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LmNvbG9yXSDnur/mrrXkuIrnmoTmloflrZfpopzoibJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRQb3NdIOaWh+Wtl+S9jee9ruWPr+mAieWAvCAnc3RhcnQnLCdjZW50ZXInLCdlbmQnLOm7mOiupOWAvOS4umNlbnRlclxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8QXJyYXl9IFtvcHRpb25zLnRleHQub2Zmc2V0XSDmloflrZfkvY3nva7lgY/np7vph48s5Li6bnVtYmVy5YiZ5piveOWBj+enuyBhcnJheeWImeS4ult4LHldXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zXSDkv53nlZkg6K+35L2/55Sob3B0aW9ucy5wb3NpdGlvbi5kaXJlY3Rpb24g5oyH5a6a57q/5q616LW35aeL5LiO57uI5q2iIOWcqOiKgueCueeahOS7gOS5iOS9jee9riDpu5jorqTlgLzkuLonbGVmdCxyaWdodCcgIOWPr+WPluWAvOWbm+S4quaWueWQkXRvcCxib3R0b20sbGVmdCxyaWdodCDmlrnlkJHlj6/liqDlgY/np7vph4/lpoLlpoIgXCJsZWZ0KzEwLHRvcFwiXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb25dIOaMh+Wumue6v+auteS9jee9rlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLmRpcmVjdGlvbl0g5oyH5a6a57q/5q616LW35aeL5LiO57uI5q2iIOWcqOiKgueCueeahOS7gOS5iOS9jee9riDpu5jorqTlgLzkuLonbGVmdCxyaWdodCcgIOWPr+WPluWAvOWbm+S4quaWueWQkXRvcCxib3R0b20sbGVmdCxyaWdodCDmlrnlkJHlj6/liqDlgY/np7vph4/lpoLlpoIgXCJsZWZ0KzEwLHRvcFwiXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9zaXRpb24uc3RhcnRPZmZzZXRdIOe6v+auteW8gOWni+S9jee9rueahOWBj+enu1t4LHldICAgZWcuIHN0YXJ0T2Zmc2V0OlswLDEwXSDlnKh45LiK5YGP56e7MCB55LiK5YGP56e7MTBcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5lbmRPZmZzZXRdIOe6v+autee7k+adn+S9jee9rueahOWBj+enu1t4LHldICAgZWcuIHN0YXJ0T2Zmc2V0OlswLDEwXSDlnKh45LiK5YGP56e7MCB55LiK5YGP56e7MTBcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbi5lc2NhcGVEaXN0YW5jZV0g5oyH5a6a57q/5q6156ys5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM5pyA5ZCO5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM6buY6K6k5YC85Li6WzMwLCAzMF1cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbi5wb2ludHNdIOS4jeS9v+eUqOiHquWKqOiuoeeulyDmjIflrprov57nur/nmoTmipjngrnkvY3nva7mlbDnu4TvvIzpppblsL7lj6/ku6Xkvb/nlKhsZWZ0LHJpZ2h0LHRvcCxib3R0b21cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5lZmZlY3RdIOe6v+S4iuWKqOaAgeaViOaenFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmVmZmVjdC5zaG93XSDmmK/lkKbmmL7npLrnrq3lpLTliqjmlYhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lZmZlY3QucGVyaW9kXSDliqjmlYjnp7vliqjpgJ/luqZcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b0NoYW5nZVBvc2l0aW9uXSDov57nur/nmoTov57mjqXngrnpmo9ub2Rl56e75Yqo6Ieq5Yqo5YiH5o2i5L2N572u77yM6buY6K6k5Li6Zmxhc2VcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy56XSDov57nur/nmoTlsYLnuqfvvIzotorlpKfotorlnKjliY3pnaLmmL7npLpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5idW5kbGVPZmZzZXQ9MzBdIOaLhue6v+aLkOinkuWkhOeahOmVv+W6pijnlKjkuo7ov57nur/nu4QpXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnVuZGxlR2FwPTIwXSDlpJrnur/mrrXnmoTpl7TpmpQo55So5LqO6L+e57q/57uEKVxyXG4gICAgICovXHJcbiAgICBDaGFpbi5jcmVhdGVCeVBvaW50ID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHQgPSBGbG93LnRyYW5zbGF0ZUxpbmtPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgIHZhciBjb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKG9wdCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENoYWluO1xyXG5cclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9saW5rL0NoYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOi/nue6v+aTjeS9nOexu1xyXG4gKiBAYXV0aG9yIG1pYW8uY3VuemhpXHJcbiAqL1xyXG5cclxuICAgIHZhciBzeW1ib2xVdGlsID0gcmVxdWlyZSgnLi4vc2hhcGVzL1N5bWJvbCcpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGljb24gPSByZXF1aXJlKCcuL0ljb25PcGVyYXRpb24nKTtcclxuICAgIGZ1bmN0aW9uIExpbmVPcGVyYXRpb25NYW5hZ2VyKGNvbm5lY3Rpb25NYW5hZ2VyLCBhcGkpIHtcclxuICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25zID0gW10sXHJcbiAgICAgICAgdGhpcy5pc0VkaXQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBjb25uZWN0aW9uTWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9hcGkgPSBhcGk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5hZGRJY29uKGtleSwgb3B0aW9ucyk7XHJcbiAgICAgKi9cclxuICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLnByb3RvdHlwZS5hZGRJY29uID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgLy/liKTmlq3mmK/lsI/lm77moIflkKblrZjlnKgg77yM5a2Y5Zyo5YiZ55u05o6l6L+U5ZueXHJcbiAgICAgICAgdmFyIGxpbmVPcGVyYXRpb25JY29uID0genJVdGlsLmZpbmQob3B0aW9ucy5saW5lTm9kZS5pY29ucywgZnVuY3Rpb24oaWNvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gaWNvbi5rZXkgPT09IGtleTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGxpbmVPcGVyYXRpb25JY29uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmluZE9wZXJhdGlvbihvcHRpb25zLmxpbmVOb2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgdmFyIGxpbmVPcGVyYXRpb24gPSB0aGlzLmNyZWF0T3BlcmF0aW9uKGtleSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwaS5fZ2V0UGFyZW50WnIoKS5hZGQobGluZU9wZXJhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuYmluZE9wZXJhdGlvbihvcHRpb25zLmxpbmVOb2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGxpbmVPcGVyYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5wcm90b3R5cGUuY3JlYXRPcGVyYXRpb24gPSBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgbGluZU9wZXJhdGlvbiA9IHN5bWJvbFV0aWwuY3JlYXRlU3ltYm9sKG9wdGlvbnMuaWNvblBhdGgsIDAsIDAsIG9wdGlvbnMud2lkdGggfHwgMTUsIG9wdGlvbnMuaGVpZ2h0IHx8IDE1LCAwLCBvcHRpb25zLmNvbG9yfHwnI2FhYWFhYycpO1xyXG4gICAgICAgIGxpbmVPcGVyYXRpb24ua2V5ID0ga2V5O1xyXG4gICAgICAgIGxpbmVPcGVyYXRpb24uX3dpZHRoID0gIG9wdGlvbnMud2lkdGggfHwgMTU7ICAvLyBwYXRo5oOF5Ya15LiL5peg5rOV6K6h566XXHJcbiAgICAgICAgbGluZU9wZXJhdGlvbi5faXNMaW5lT3BlcmF0aW9uSWNvbiA9IHRydWU7XHJcbiAgICAgICAgbGluZU9wZXJhdGlvbi5oaWRlKCk7XHJcbiAgICAgICAgb3B0aW9ucy5saW5lTm9kZS5pY29ucy5wdXNoKGxpbmVPcGVyYXRpb24pO1xyXG4gICAgICAgIHRoaXMubGluZU9wZXJhdGlvbnMucHVzaChsaW5lT3BlcmF0aW9uKTtcclxuXHJcbiAgICAgICAgLy/lsI/lm77moIcg54K55Ye75LqL5Lu2ICDlpoLmnpzmnInlm57osIPliJnosIPnlKjlm57osIPvvIzlkKbliJnmtL7lj5Hkuovku7ZcclxuICAgICAgICBsaW5lT3BlcmF0aW9uLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEgPSBvcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQubGluZU5vZGUgPSBvcHRpb25zLmxpbmVOb2RlO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhldmVudCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBldmVudDtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJjbGlja1wiO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmVsZW1lbnRUeXBlID0gXCJMaW5lT3BlcmF0aW9uSWNvblwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBpLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIHJldHVybiBsaW5lT3BlcmF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6h566X5bCP5Zu+5qCH55qE5L2N572u77yM5bm25pi+56S6XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNvbm5lY3RvciBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLnByb3RvdHlwZS5iaW5kT3BlcmF0aW9uID0gZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gcGFyZW50WChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC5ub2RlVHlwZSA9PSBcIlN1YlByb2Nlc3NcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zaXRpb25bMF0gKyBwYXJlbnRYKG5vZGUucGFyZW50KVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zaXRpb25bMF1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudFkobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQubm9kZVR5cGUgPT0gXCJTdWJQcm9jZXNzXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzFdICsgcGFyZW50WShub2RlLnBhcmVudClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzFdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzRWRpdCA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwb2ludFBvc2l0aW9uID0gY29ubmVjdG9yLm1pZGRsZSgpLCBwb3NYLCBwb3NZO1xyXG4gICAgICAgIGlmIChjb25uZWN0b3IucGFyZW50ICYmIGNvbm5lY3Rvci5wYXJlbnQubm9kZVR5cGUgPT0gXCJTdWJQcm9jZXNzXCIpIHtcclxuICAgICAgICAgICAgcG9zWCA9IHBvaW50UG9zaXRpb25bMF0gKyBwYXJlbnRYKGNvbm5lY3Rvci5wYXJlbnQpO1xyXG4gICAgICAgICAgICBwb3NZID0gcG9pbnRQb3NpdGlvblsxXSArIHBhcmVudFkoY29ubmVjdG9yLnBhcmVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcG9zWCA9IHBvaW50UG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgIHBvc1kgPSBwb2ludFBvc2l0aW9uWzFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGFyckxlbmd0aCA9IHpyVXRpbC5tYXAoY29ubmVjdG9yLmljb25zLCBmdW5jdGlvbihpY29uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpY29uLl93aWR0aDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIHRvdGFsTGVuZ3RoID0genJVdGlsLnJlZHVjZShhcnJMZW5ndGgsIGZ1bmN0aW9uKHByZXZpb3VzVmFsdWUsY3VycmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlICsgY3VycmVudFZhbHVlICsgMTA7XHJcbiAgICAgICAgfSwgMCApO1xyXG5cclxuICAgICAgICB6clV0aWwuZWFjaChjb25uZWN0b3IuaWNvbnMsIGZ1bmN0aW9uKGljb24sIGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3JQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaW5kZXg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yUG9zaXRpb24gKz0gYXJyTGVuZ3RoW2tdICsgMTA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWNvbi5hdHRyKFwicG9zaXRpb25cIiwgW3Bvc1ggKyBjb25uZWN0b3JQb3NpdGlvbiAtIHRvdGFsTGVuZ3RoIC8gMiwgcG9zWSArIDVdKTtcclxuICAgICAgICAgICAgaWNvbi5zaG93KCk7XHJcbiAgICAgICAgICAgIGljb24uYXR0YWNoTGluZSA9IGNvbm5lY3RvcjtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLnByb3RvdHlwZS5oaWRlQWxsTGluZU9wZXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHpyVXRpbC5lYWNoKHRoaXMubGluZU9wZXJhdGlvbnMsIGZ1bmN0aW9uKGxpbmVPcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgbGluZU9wZXJhdGlvbi5oaWRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgTGluZU9wZXJhdGlvbk1hbmFnZXIucHJvdG90eXBlLmFkZERlbGV0ZUljb24gPSBmdW5jdGlvbihsaW5lTm9kZSxvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB6clV0aWwuZGVmYXVsdHMoe1xyXG4gICAgICAgICAgICBpY29uUGF0aDogJ3BhdGg6Ly8nICsgaWNvbi5ERUxfU1ZHLFxyXG4gICAgICAgICAgICB3aWR0aDogMTIsXHJcbiAgICAgICAgICAgIGhlaWdodDogMTQsXHJcbiAgICAgICAgICAgIGxpbmVOb2RlOiBsaW5lTm9kZSxcclxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaS5yZW1vdmUoZS50YXJnZXQuYXR0YWNoTGluZSk7Ly90aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnNlbENvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgIH0sIG9wdGlvbnMsdHJ1ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkSWNvbihcImRlbGV0ZVwiLCBvcHRzKTtcclxuICAgIH1cclxuXHJcbiAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5wcm90b3R5cGUuYWRkQ2hhbmdlTGluZVR5cGVJY29uID0gZnVuY3Rpb24obGluZU5vZGUsb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHRzID0genJVdGlsLmRlZmF1bHRzKHtcclxuICAgICAgICAgICAgaWNvblBhdGg6ICdwYXRoOi8vJyArIGljb24uQ0hBTkdFX0xJTkVfVFlQRV9TVkcsXHJcbiAgICAgICAgICAgIHdpZHRoOiAxNSxcclxuICAgICAgICAgICAgaGVpZ2h0OiAxNSxcclxuICAgICAgICAgICAgbGluZU5vZGU6IGxpbmVOb2RlLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBpLmNoYW5nZVNlbGVjdENvbm5lY3RvclR5cGUoKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICAgICAgfSwgb3B0aW9ucyx0cnVlKTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRJY29uKFwiY2hhbmdlXCIsIG9wdHMpXHJcbiAgICB9XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaW5lT3BlcmF0aW9uTWFuYWdlcjtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0xpbmVPcGVyYXRpb25NYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXHJcbiAqIGZpc2hUb3BvRmxvd+eahGxheW91dOWvueixoe+8jOahhuaetuaPkOS+m+eahOW4g+WxgOmDveaUvuWcqOi/meS4quWvueixoeS4i+OAgumAmui/h2FkZEN1c3RvbUxheW91dOaWueazlea3u+WKoOiHquWumuS5ieW4g+WxgFxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93LmxheW91dFxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcblxyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZmxvd1V0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9GbG93VXRpbFwiKTtcclxuICAgIHZhciBITGF5b3V0ID0gcmVxdWlyZSgnLi9ITGF5b3V0Jyk7XHJcbiAgICB2YXIgVkxheW91dCA9IHJlcXVpcmUoJy4vVkxheW91dCcpO1xyXG4gICAgdmFyIFRyZWVMYXlvdXQgPSByZXF1aXJlKCcuL1RyZWVMYXlvdXQnKTtcclxuICAgIHZhciBGb3JjZUxheW91dCA9IHJlcXVpcmUoJy4vRm9yY2VMYXlvdXQnKTtcclxuICAgIHZhciBwYXJzZVBlcmNlbnQgPSBmbG93VXRpbC5wYXJzZVBlcmNlbnQ7XHJcbiAgICB2YXIgVHJlZSA9IHJlcXVpcmUoJy4uL2RhdGEvVHJlZScpO1xyXG4gICAgdmFyIGxheW91dCA9IHt9O1xyXG4gICAgbGF5b3V0LkhMYXlvdXQgPSBITGF5b3V0O1xyXG4gICAgbGF5b3V0LlZMYXlvdXQgPSBWTGF5b3V0O1xyXG4gICAgbGF5b3V0LlRyZWVMYXlvdXQgPSBUcmVlTGF5b3V0O1xyXG4gICAgbGF5b3V0LkZvcmNlTGF5b3V0ID0gRm9yY2VMYXlvdXQ7XHJcbiAgICBsYXlvdXQuVHJlZSA9IFRyZWVcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgYWRkQ3VzdG9tTGF5b3V0XHJcbiAgICAgKiDmt7vliqDoh6rlrprkuYnluIPlsYDnsbtcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21MYXlvdXQg6Ieq5a6a5LmJ5biD5bGA55qE57G7XHJcbiAgICAgKi9cclxuICAgIGxheW91dC5hZGRDdXN0b21MYXlvdXQgPSBmdW5jdGlvbihjdXN0b21MYXlvdXQpIHtcclxuICAgICAgICBsYXlvdXQuY3VzdG9tTGF5b3V0ID0gY3VzdG9tTGF5b3V0O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBsYXlvdXQuZ2V0TGF5b3V0UmVjdCA9IGZ1bmN0aW9uIChwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpbikge1xyXG4gICAgICAgIG1hcmdpbiA9IGZsb3dVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KG1hcmdpbiB8fCAwKTtcclxuXHJcbiAgICAgICAgdmFyIGNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyUmVjdC53aWR0aDtcclxuICAgICAgICB2YXIgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyUmVjdC5oZWlnaHQ7XHJcblxyXG4gICAgICAgIHZhciBsZWZ0ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby5sZWZ0LCBjb250YWluZXJXaWR0aCk7XHJcbiAgICAgICAgdmFyIHRvcCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8udG9wLCBjb250YWluZXJIZWlnaHQpO1xyXG4gICAgICAgIHZhciByaWdodCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ucmlnaHQsIGNvbnRhaW5lcldpZHRoKTtcclxuICAgICAgICB2YXIgYm90dG9tID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby5ib3R0b20sIGNvbnRhaW5lckhlaWdodCk7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby53aWR0aCwgY29udGFpbmVyV2lkdGgpO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmhlaWdodCwgY29udGFpbmVySGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRpY2FsTWFyZ2luID0gbWFyZ2luWzJdICsgbWFyZ2luWzBdO1xyXG4gICAgICAgIHZhciBob3Jpem9udGFsTWFyZ2luID0gbWFyZ2luWzFdICsgbWFyZ2luWzNdO1xyXG4gICAgICAgIHZhciBhc3BlY3QgPSBwb3NpdGlvbkluZm8uYXNwZWN0O1xyXG5cclxuICAgICAgICAvLyBJZiB3aWR0aCBpcyBub3Qgc3BlY2lmaWVkLCBjYWxjdWxhdGUgd2lkdGggZnJvbSBsZWZ0IGFuZCByaWdodFxyXG4gICAgICAgIGlmIChpc05hTih3aWR0aCkpIHtcclxuICAgICAgICAgICAgd2lkdGggPSBjb250YWluZXJXaWR0aCAtIHJpZ2h0IC0gaG9yaXpvbnRhbE1hcmdpbiAtIGxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc05hTihoZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbnRhaW5lckhlaWdodCAtIGJvdHRvbSAtIHZlcnRpY2FsTWFyZ2luIC0gdG9wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgd2lkdGggYW5kIGhlaWdodCBhcmUgbm90IGdpdmVuXHJcbiAgICAgICAgLy8gMS4gR3JhcGggc2hvdWxkIG5vdCBleGNlZWRzIHRoZSBjb250YWluZXJcclxuICAgICAgICAvLyAyLiBBc3BlY3QgbXVzdCBiZSBrZWVwZWRcclxuICAgICAgICAvLyAzLiBHcmFwaCBzaG91bGQgdGFrZSB0aGUgc3BhY2UgYXMgbW9yZSBhcyBwb3NzaWJsZVxyXG4gICAgICAgIGlmIChpc05hTih3aWR0aCkgJiYgaXNOYU4oaGVpZ2h0KSkge1xyXG4gICAgICAgICAgICBpZiAoYXNwZWN0ID4gY29udGFpbmVyV2lkdGggLyBjb250YWluZXJIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoID0gY29udGFpbmVyV2lkdGggKiAwLjg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgKiAwLjg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhc3BlY3QgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgd2lkdGggb3IgaGVpZ2h0IHdpdGggZ2l2ZW4gYXNwZWN0XHJcbiAgICAgICAgICAgIGlmIChpc05hTih3aWR0aCkpIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoID0gYXNwZWN0ICogaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc05hTihoZWlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgbGVmdCBpcyBub3Qgc3BlY2lmaWVkLCBjYWxjdWxhdGUgbGVmdCBmcm9tIHJpZ2h0IGFuZCB3aWR0aFxyXG4gICAgICAgIGlmIChpc05hTihsZWZ0KSkge1xyXG4gICAgICAgICAgICBsZWZ0ID0gY29udGFpbmVyV2lkdGggLSByaWdodCAtIHdpZHRoIC0gaG9yaXpvbnRhbE1hcmdpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTmFOKHRvcCkpIHtcclxuICAgICAgICAgICAgdG9wID0gY29udGFpbmVySGVpZ2h0IC0gYm90dG9tIC0gaGVpZ2h0IC0gdmVydGljYWxNYXJnaW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBbGlnbiBsZWZ0IGFuZCB0b3BcclxuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uSW5mby5sZWZ0IHx8IHBvc2l0aW9uSW5mby5yaWdodCkge1xyXG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgICAgICAgICAgbGVmdCA9IGNvbnRhaW5lcldpZHRoIC8gMiAtIHdpZHRoIC8gMiAtIG1hcmdpblszXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gY29udGFpbmVyV2lkdGggLSB3aWR0aCAtIGhvcml6b250YWxNYXJnaW47XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoIChwb3NpdGlvbkluZm8udG9wIHx8IHBvc2l0aW9uSW5mby5ib3R0b20pIHtcclxuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcclxuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcclxuICAgICAgICAgICAgICAgIHRvcCA9IGNvbnRhaW5lckhlaWdodCAvIDIgLSBoZWlnaHQgLyAyIC0gbWFyZ2luWzBdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLSBoZWlnaHQgLSB2ZXJ0aWNhbE1hcmdpbjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBzb21ldGhpbmcgaXMgd3JvbmcgYW5kIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCBhcmUgY2FsY3VsYXRlZCBhcyBOYU5cclxuICAgICAgICBsZWZ0ID0gbGVmdCB8fCAwO1xyXG4gICAgICAgIHRvcCA9IHRvcCB8fCAwO1xyXG4gICAgICAgIGlmIChpc05hTih3aWR0aCkpIHtcclxuICAgICAgICAgICAgLy8gV2lkdGggbWF5IGJlIE5hTiBpZiBvbmx5IG9uZSB2YWx1ZSBpcyBnaXZlbiBleGNlcHQgd2lkdGhcclxuICAgICAgICAgICAgd2lkdGggPSBjb250YWluZXJXaWR0aCAtIGxlZnQgLSAocmlnaHQgfHwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc05hTihoZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIC8vIEhlaWdodCBtYXkgYmUgTmFOIGlmIG9ubHkgb25lIHZhbHVlIGlzIGdpdmVuIGV4Y2VwdCBoZWlnaHRcclxuICAgICAgICAgICAgaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0IC0gdG9wIC0gKGJvdHRvbSB8fCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChsZWZ0ICsgbWFyZ2luWzNdLCB0b3AgKyBtYXJnaW5bMF0sIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHJlY3QubWFyZ2luID0gbWFyZ2luO1xyXG4gICAgICAgIHJldHVybiByZWN0O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgbGF5b3V0LnBvc2l0aW9uRWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgcG9zaXRpb25JbmZvLCBjb250YWluZXJSZWN0LCBtYXJnaW4sIG9wdCkge1xyXG4gICAgICAgIHZhciBoID0gIW9wdCB8fCAhb3B0Lmh2IHx8IG9wdC5odlswXTtcclxuICAgICAgICB2YXIgdiA9ICFvcHQgfHwgIW9wdC5odiB8fCBvcHQuaHZbMV07XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nTW9kZSA9IG9wdCAmJiBvcHQuYm91bmRpbmdNb2RlIHx8ICdhbGwnO1xyXG5cclxuICAgICAgICBpZiAoIWggJiYgIXYpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlY3Q7XHJcbiAgICAgICAgaWYgKGJvdW5kaW5nTW9kZSA9PT0gJ3JhdycpIHtcclxuICAgICAgICAgICAgcmVjdCA9IChlbC50eXBlID09PSAnZ3JvdXAnIHx8IGVsLnR5cGUgPT09ICdHcm91cE5vZGUnKVxyXG4gICAgICAgICAgICAgICAgPyBuZXcgQm91bmRpbmdSZWN0KDAsIDAsICtwb3NpdGlvbkluZm8ud2lkdGggfHwgMCwgK3Bvc2l0aW9uSW5mby5oZWlnaHQgfHwgMClcclxuICAgICAgICAgICAgICAgIDogZWwuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWN0ID0gZWwuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgIGlmIChlbC5uZWVkTG9jYWxUcmFuc2Zvcm0oKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGVsLmdldExvY2FsVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3RpY2U6IHJhdyByZWN0IG1heSBiZSBpbm5lciBvYmplY3Qgb2YgZWwsXHJcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBzaG91bGQgbm90IGJlIG1vZGlmaWVkLlxyXG4gICAgICAgICAgICAgICAgcmVjdCA9IHJlY3QuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIHJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcG9zaXRpb25JbmZvID0gbGF5b3V0LmdldExheW91dFJlY3QoXHJcbiAgICAgICAgICAgIHpyVXRpbC5kZWZhdWx0cyhcclxuICAgICAgICAgICAgICAgIHt3aWR0aDogcmVjdC53aWR0aCwgaGVpZ2h0OiByZWN0LmhlaWdodH0sXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkluZm9cclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgY29udGFpbmVyUmVjdCxcclxuICAgICAgICAgICAgbWFyZ2luXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gQmVjYXVzZSAndHJhbmxhdGUnIGlzIHRoZSBsYXN0IHN0ZXAgaW4gdHJhbnNmb3JtXHJcbiAgICAgICAgLy8gKHNlZSB6cmVuZGVyL2NvcmUvVHJhbnNmb3JtYWJsZSNnZXRMb2NhbFRyYW5zZnJvbSksXHJcbiAgICAgICAgLy8gd2UgY2FuIGp1c3Qgb25seSBtb2RpZnkgZWwucG9zaXRpb24gdG8gZ2V0IGZpbmFsIHJlc3VsdC5cclxuICAgICAgICB2YXIgZWxQb3MgPSBlbC5wb3NpdGlvbjtcclxuICAgICAgICB2YXIgZHggPSBoID8gcG9zaXRpb25JbmZvLnggLSByZWN0LnggOiAwO1xyXG4gICAgICAgIHZhciBkeSA9IHYgPyBwb3NpdGlvbkluZm8ueSAtIHJlY3QueSA6IDA7XHJcblxyXG4gICAgICAgIGVsLmF0dHIoJ3Bvc2l0aW9uJywgYm91bmRpbmdNb2RlID09PSAncmF3JyA/IFtkeCwgZHldIDogW2VsUG9zWzBdICsgZHgsIGVsUG9zWzFdICsgZHldKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gbGF5b3V0O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L2xheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDmsLTlubPluIPlsYA8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubGF5b3V0LkhMYXlvdXRcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93LmxheW91dFxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGxheW91dCA9IGZpc2hUb3BvRmxvdy5sYXlvdXQ7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgZnVuY3Rpb24gbmV3Tm9kZShncm91cCx0ZXh0KSB7XHJcbiAqICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBub2RlLlJlY3Qoe1xyXG4gKiAgICAgICAgICAgICAgICAgICBzaGFwZTp7d2lkdGg6MjUsaGVpZ2h0OjI1fSxcclxuICogICAgICAgICAgICAgICAgICAgc3R5bGU6IHt0ZXh0OnRleHQsZmlsbDogXCIjMTY3Q0ZGXCJ9XHJcbiAqICAgICAgICAgICAgICAgfSk7XHJcbiAqICAgICAgICAgICBncm91cC5hZGQocmVjdCk7XHJcbiAqICAgICAgICAgICByZXR1cm4gcmVjdDtcclxuICogICAgICAgfVxyXG4gKiAgICAgICB2YXIgaEdyb3VwID0gIG5ldyBub2RlLkdyb3VwKHtcclxuICogICAgICAgICAgIHN0eWxlOiB7XHJcbiAqICAgICAgICAgICAgICAgdGV4dDogXCLmsLTlubPluIPlsYBcIixcclxuICogICAgICAgICAgICAgICB0ZXh0UG9zaXRpb246XCJib3R0b21cIlxyXG4gKiAgICAgICAgICAgfSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOls1MCw1MF0sXHJcbiAqICAgICAgICAgICBsYXlvdXQgOiBuZXcgbGF5b3V0LkhMYXlvdXQoe2dhcDoxMH0pXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBuZXdOb2RlKGhHcm91cCwgXCJBXzFcIilcclxuICogICAgICAgbmV3Tm9kZShoR3JvdXAsIFwiQV8yXCIpO1xyXG4gKiAgICAgICBuZXdOb2RlKGhHcm91cCwgXCJBXzNcIik7XHJcbiAqICAgICAgIG5ld05vZGUoaEdyb3VwLCBcIkFfNFwiKTtcclxuICogICAgICAgbmV3Tm9kZShoR3JvdXAsIFwiQV81XCIpO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQoaEdyb3VwKTtcclxuICovXHJcblxyXG4gICAgICAgICAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICAgICAgICAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBITGF5b3V0KG9wdHMpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQGNmZyB7TnVtYmVyfSBnYXAg6IqC54K55LmL6Ze055qE6Ze06ZqUXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQGNmZyB7TnVtYmVyfSBtYXhIZWlnaHQ9SW5maW5pdHkg57uE5pyA5aSn55qE5a695bqm77yM5aaC5p6c6LaF6L+H5Lya5o2i6KGMXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBnYXA6IDUsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0genJVdGlsLm1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRzLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG1ldGhvZCBydW5cclxuICAgICAgICAgICAgICog6L+b6KGM5Z6C55u05biD5bGA77yM5LiA6Iis5LiN6ZyA6KaB6LCD55So77yM55u05o6l5bCG5biD5bGA57G7IOi1i+WAvOe7mee7hGxheW91dCDlsZ7mgKfljbPlj69cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGdyb3VwIOmcgOimgei/m+ihjOWeguebtOW4g+WxgOeahOe7hFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oZ3JvdXApICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudExpbmVNYXhTaXplID0gMDtcclxuICAgICAgICAgICAgICAgIGdyb3VwLmVhY2goZnVuY3Rpb24gKGNoaWxkLCBpZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gY2hpbGQucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBjaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENoaWxkID0gZ3JvdXAuY2hpbGRBdChpZHggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENoaWxkUmVjdCA9IG5leHRDaGlsZCAmJiBuZXh0Q2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRYO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW92ZVggPSByZWN0LndpZHRoICsgKG5leHRDaGlsZFJlY3QgPyAoLW5leHRDaGlsZFJlY3QueCArIHJlY3QueCkgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0WCA9IHggKyBtb3ZlWDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXcmFwIHdoZW4gd2lkdGggZXhjZWVkcyBtYXhXaWR0aCBvciBtZWV0IGEgYG5ld2xpbmVgIGdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRYID4gdGhpcy5vcHRpb25zLm1heFdpZHRoIHx8IGNoaWxkLm5ld2xpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRYID0gbW92ZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gY3VycmVudExpbmVNYXhTaXplICsgcGFyc2VJbnQodGhpcy5vcHRpb25zLmdhcCwxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRMaW5lTWF4U2l6ZSwgcmVjdC5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5ld2xpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25bMF0gPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWzFdID0geTtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gbmV4dFggKyB0aGlzLm9wdGlvbnMuZ2FwO1xyXG4gICAgICAgICAgICAgICAgfSx0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSExheW91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gSExheW91dDtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGFkZEN1c3RvbUxheW91dFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L0hMYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5Z6C55u05biD5bGAPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93LmxheW91dC5WTGF5b3V0XHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5sYXlvdXRcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBsYXlvdXQgPSBmaXNoVG9wb0Zsb3cubGF5b3V0O1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIGZ1bmN0aW9uIG5ld05vZGUoZ3JvdXAsdGV4dCkge1xyXG4gKiAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgbm9kZS5SZWN0KHtcclxuICogICAgICAgICAgICAgICAgICAgc2hhcGU6e3dpZHRoOjI1LGhlaWdodDoyNX0sXHJcbiAqICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7dGV4dDp0ZXh0LGZpbGw6IFwiIzE2N0NGRlwifVxyXG4gKiAgICAgICAgICAgICAgIH0pO1xyXG4gKiAgICAgICAgICAgZ3JvdXAuYWRkKHJlY3QpO1xyXG4gKiAgICAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAqICAgICAgIH1cclxuICogICAgICAgdmFyIHZHcm91cCA9ICBuZXcgbm9kZS5Hcm91cCh7XHJcbiAqICAgICAgICAgICBzdHlsZToge1xyXG4gKiAgICAgICAgICAgICAgIHRleHQ6IFwi5Z6C55u05biD5bGAXCIsXHJcbiAqICAgICAgICAgICAgICAgdGV4dFBvc2l0aW9uOlwiYm90dG9tXCJcclxuICogICAgICAgICAgIH0sXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNjBdLFxyXG4gKiAgICAgICAgICAgbGF5b3V0IDogbmV3IGxheW91dC5WTGF5b3V0KHtnYXA6MTB9KVxyXG4gKiAgICAgICB9KTtcclxuKlxyXG4gKiAgICAgICBuZXdOb2RlKHZHcm91cCwgXCJBXzFcIilcclxuICogICAgICAgbmV3Tm9kZSh2R3JvdXAsIFwiQV8yXCIpO1xyXG4gKiAgICAgICBuZXdOb2RlKHZHcm91cCwgXCJBXzNcIik7XHJcbiAqICAgICAgIG5ld05vZGUodkdyb3VwLCBcIkFfNFwiKTtcclxuICogICAgICAgbmV3Tm9kZSh2R3JvdXAsIFwiQV81XCIpO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQodkdyb3VwKTtcclxuICovXHJcblxyXG4gICAgICAgICAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICAgICAgICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFZMYXlvdXQob3B0cykge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IGdhcCDoioLngrnkuYvpl7TnmoTpl7TpmpRcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IG1heEhlaWdodD1JbmZpbml0eSDnu4TmnIDlpKfnmoTpq5jluqbvvIzlpoLmnpzotoXov4fkvJrmjaLooYxcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGdhcDogNSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0genJVdGlsLm1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRzLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBtZXRob2QgcnVuXHJcbiAgICAgICAgICAgICAqIOi/m+ihjOWeguebtOW4g+WxgO+8jOS4gOiIrOS4jemcgOimgeiwg+eUqO+8jOebtOaOpeWwhuW4g+WxgOexuyDotYvlgLznu5nnu4RsYXlvdXQg5bGe5oCn5Y2z5Y+vXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncm91cCDpnIDopoHov5vooYzlnoLnm7TluIPlsYDnmoTnu4RcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFZMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKGdyb3VwKSAge1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBncm91cC5lYWNoKGZ1bmN0aW9uIChjaGlsZCwgaWR4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGNoaWxkLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDaGlsZCA9IGdyb3VwLmNoaWxkQXQoaWR4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDaGlsZFJlY3QgPSBuZXh0Q2hpbGQgJiYgbmV4dENoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0WTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdmVZID0gcmVjdC5oZWlnaHQgKyAobmV4dENoaWxkUmVjdCA/ICgtbmV4dENoaWxkUmVjdC55ICsgcmVjdC55KSA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRZID0geSArIG1vdmVZO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdyYXAgd2hlbiB3aWR0aCBleGNlZWRzIG1heEhlaWdodCBvciBtZWV0IGEgYG5ld2xpbmVgIGdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRZID4gdGhpcy5vcHRpb25zLm1heEhlaWdodCB8fCBjaGlsZC5uZXdsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gY3VycmVudExpbmVNYXhTaXplICsgcGFyc2VJbnQodGhpcy5vcHRpb25zLmdhcCwxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0WSA9IG1vdmVZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZU1heFNpemUgPSByZWN0LndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gTWF0aC5tYXgoY3VycmVudExpbmVNYXhTaXplLCByZWN0LndpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5uZXdsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWzBdID0geDtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblsxXSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IG5leHRZICsgdGhpcy5vcHRpb25zLmdhcDtcclxuICAgICAgICAgICAgICAgIH0sdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFZMYXlvdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFZMYXlvdXQ7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgYWRkQ3VzdG9tTGF5b3V0XHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvVkxheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDmoJHluIPlsYA8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubGF5b3V0LlRyZWVMYXlvdXRcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93LmxheW91dFxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGxheW91dCA9IGZpc2hUb3BvRmxvdy5sYXlvdXQ7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSk7XHJcbiAqICAgICAgIGZ1bmN0aW9uIG5ld05vZGUoZGF0YSkge1xyXG4gKiAgICAgICAgICAgdmFyIGNpcmNsZSA9IG5ldyBub2RlLkNpcmNsZSh7XHJcbiAqICAgICAgICAgICAgICAgc2hhcGU6IHsgcjogMTUgfSxcclxuICogICAgICAgICAgICAgICBzdHlsZTogeyBmaWxsOiBcIiM0ODgzYjRcIiB9LFxyXG4gKiAgICAgICAgICAgICAgIG5hbWU6IGRhdGEubmFtZVxyXG4gKiAgICAgICAgICAgfSk7XHJcbiAqICAgICAgICAgICByZXR1cm4gY2lyY2xlO1xyXG4gKiAgICAgICB9XHJcbiAqICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gKiAgICAgICAgICAgY3JlYXRlTm9kZUZ1bmN0aW9uOiBuZXdOb2RlLFxyXG4gKiAgICAgICAgICAgZGF0YTpbe1xyXG4gKiAgICAgICAgICAgICAgIG5hbWU6ICfmoLnoioLngrknLFxyXG4gKiAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXHJcbiAqICAgICAgICAgICAgICAgICAgIHsgICBuYW1lOiAn6IqC54K5MScsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn5Y+25a2Q6IqC54K5MSd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn5Y+25a2Q6IqC54K5Mid9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn5Y+25a2Q6IqC54K5Myd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn5Y+25a2Q6IqC54K5NCd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn5Y+25a2Q6IqC54K5NSd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn5Y+25a2Q6IqC54K5Nid9XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAqICAgICAgICAgICAgICAgICAgIH0sXHJcbiAqICAgICAgICAgICAgICAgICAgIHsgICBuYW1lOiAn6IqC54K5MicsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn5Y+25a2Q6IqC54K5Nyd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn5Y+25a2Q6IqC54K5OCd9XVxyXG4gKiAgICAgICAgICAgICAgICAgICB9LFxyXG4gKiAgICAgICAgICAgICAgICAgICB7ICAgbmFtZTogJ+iKgueCuTMnLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ+WPtuWtkOiKgueCuTknfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ+WPtuWtkOiKgueCuTEwJ30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrkxMSd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn5Y+25a2Q6IqC54K5MTInfVxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gKiAgICAgICAgICAgICAgICAgICB9XHJcbiAqICAgICAgICAgICAgICAgXVxyXG4gKiAgICAgICAgICAgfV1cclxuICogICAgICAgfVxyXG4qXHJcbiAqICAgICAgIHZhciB0cmVlTGF5b3V0ID0gbmV3IGxheW91dC5UcmVlTGF5b3V0KHtcclxuICogICAgICAgICAgIGZpc2hUb3BvOmZpc2hUb3BvLFxyXG4gKiAgICAgICAgICAgcm9vdExvY2F0aW9uOnt4OidjZW50ZXInLCB5OjUwfSxcclxuICogICAgICAgICAgIG5vZGVQYWRkaW5nOjFcclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIHRyZWVMYXlvdXQuZG9MYXlvdXQob3B0aW9ucyk7XHJcbiAqL1xyXG5cclxuICAgICAgICAgICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgICAgICAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcclxuICAgICAgICAgICAgdmFyIGZsb3dVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9GbG93VXRpbCcpO1xyXG4gICAgICAgICAgICB2YXIgcGFyc2VQZXJjZW50ID0gZmxvd1V0aWwucGFyc2VQZXJjZW50O1xyXG4gICAgICAgICAgICB2YXIgVHJlZURhdGEgPSByZXF1aXJlKCcuLi9kYXRhL1RyZWUnKTsgIC8vIOaVsOaNruS+nei1llxyXG4gICAgICAgICAgICB2YXIgVHJlZUhlbHBlciA9IHJlcXVpcmUoXCIuL3RyZWVIZWxwZXJcIik7IC8vIOW4g+WxgOS+nei1llxyXG4gICAgICAgICAgICBmdW5jdGlvbiBUcmVlTGF5b3V0KG9wdHMpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQGNmZyB7T2JqZWN0fSBmaXNoVG9wbyBmaXNoVG9wb+WunuS+i1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEBjZmcge09iamVjdH0gcm9vdExvY2F0aW9uIOagueiKgueCueWdkOagh++8jOaUr+aMgee7neWvueWAvO+8iHB477yJ44CB5a2X56ym5ZKM55m+5YiG5q+UICdjZW50ZXInIHwgJ2xlZnQnIHwgJ3JpZ2h0JyB8ICd4JScgfCBudW1iZXJcclxuICAgICAgICAgICAgICAgICAqIEBjZmcge051bWJlcnxTdHJpbmd9IHJvb3RMb2NhdGlvbi54ICDmoLnoioLngrnmqKrlnZDmoIfvvIzmlK/mjIHnu53lr7nlgLzvvIhweO+8ieOAgeWtl+espuWSjOeZvuWIhuavlCAnY2VudGVyJyB8ICdsZWZ0JyB8ICdyaWdodCcgfCAneCUnIHwgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ8U3RyaW5nfSByb290TG9jYXRpb24ueSAg5qC56IqC54K557q15Z2Q5qCH77yM5pSv5oyB57ud5a+55YC877yIcHjvvInjgIHlrZfnrKblkoznmb7liIbmr5QgJ2NlbnRlcicgfCAnbGVmdCcgfCAncmlnaHQnIHwgJ3glJyB8IG51bWJlclxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEBjZmcge051bWJlcn0gbGF5ZXJQYWRkaW5nPTEwMCDlsYLpl7Tot50s6buY6K6kOjEwMFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEBjZmcge051bWJlcn0gbm9kZVBhZGRpbmc9MzAg6IqC54K56Ze06LedLOm7mOiupDozMFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqQGNmZyB7U3RyaW5nfSBkaXJlY3Rpb24g5qCR55qE5pa55ZCR5Y+v6YCJ77yaJ3ZlcnRpY2FsJyB8ICdob3Jpem9udGFsJyAs6buY6K6kOnZlcnRpY2FsXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQGNmZyB7T2JqZWN0fSBsaW5lU3R5bGUg6L+e57q/55qE5qC35byPICDlj4Lop4F7QGxpbmsgZmlzaFRvcG9GbG93LmxpbmsjY29uc3RydWN0b3Ig5p6E6YCg5Ye95pWwb3B0aW9uc+WPguaVsH1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWVudDondmVydGljYWwnLCAgLy8gdmVydGljYWwsaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVQYWRkaW5nOjMwLCAvL+iKgueCuemXtOi3nVxyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyUGFkZGluZzoxMDAsICAvL+WxgumXtOi3nVxyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RMb2NhdGlvbjoge3g6MTAwLCB5OjIzMH0sIC8vIOagueiKgueCueWdkOagh++8jOaUr+aMgee7neWvueWAvO+8iHB477yJ44CB5a2X56ym5ZKM55m+5YiG5q+UXHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZVRpbWUgOiA1MDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZVN0eWxlOiB7cG9zOidib3R0b20sdG9wJywgc3ltYm9sOnt0eXBlOidub25lJ319XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdHMub3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9ucy5saW5lU3R5bGUucG9zID0gJ3JpZ2h0LGxlZnQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHpyVXRpbC5kZWZhdWx0cyhkZWZhdWx0T3B0aW9ucywgb3B0cywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVQYWRkaW5nID0gdGhpcy5vcHRpb25zLm5vZGVQYWRkaW5nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXllclBhZGRpbmcgPSB0aGlzLm9wdGlvbnMubGF5ZXJQYWRkaW5nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maXNoVG9wbyA9IHRoaXMub3B0aW9ucy5maXNoVG9wbztcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyT2Zmc2V0cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWRlTm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBtZXRob2QgbGF5b3V0QnlSb290Tm9kZVxyXG4gICAgICAgICAgICAgKiDmoLnmja7moLnoioLngrnlj4rov57nur/nmoTlhbPns7sg77yM55Sf5oiQ5qCRXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByb290Tm9kZSDmoJHnmoTmoLnoioLngrlcclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBib3VuZGluZ2JveCDljIXlm7TlkoxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRyZWVMYXlvdXQucHJvdG90eXBlLmxheW91dEJ5Um9vdE5vZGUgPSBmdW5jdGlvbihyb290Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RvcnMgPSB0aGlzLmZpc2hUb3BvLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnM7ICAvL+aJgOaciee6v+auteeahOaVsOe7hFxyXG4gICAgICAgICAgICAgICAgLy/pgJLlvZLnlJ/miJDmoJHlnovmlbDmja7nu5PmnoRcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRyYXZlcnNlTm9kZShwYXJlbnROb2RlLCB0cmVlRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbkRhdGEgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW5Ob2RlID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgLy8xLuagueaNrui/nue6v++8jOaJvuWHuui1t+Wni+iKgueCueeahOaJgOacieWtkOiKgueCuVxyXG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKGNvbm5lY3RvcnMsIGZ1bmN0aW9uKGNvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjb25uZWN0b3Iuc3RhcnROb2RlID09PSBwYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighY29ubmVjdG9yLmVuZE5vZGUuZXhjbHVkZSkgeyAgIC8v5aaC5p6c5piv5o6S5pal55qE6IqC54K55YiZ5LiN5Yqg5YWlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5Ob2RlLnB1c2goY29ubmVjdG9yLmVuZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuTm9kZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vMi7pgY3ljoblrZDoioLngrlcclxuICAgICAgICAgICAgICAgICAgICAgICAgenJVdGlsLmVhY2goY2hpbGRyZW5Ob2RlLCBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVEYXRhID0ge25hbWU6IG5vZGUuaWQsIG5vZGU6bm9kZX07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5EYXRhLnB1c2gobm9kZURhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlTm9kZShub2RlLCBub2RlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vMy7lsIblrZDoioLngrnmlL7lhaVjaGlsZHJlbuS4rVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbkRhdGEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlRGF0YS5jaGlsZHJlbiA9IGNoaWxkcmVuRGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcm9vdFRyZWVEYXRhID0ge25hbWU6IHJvb3ROb2RlLmlkLCBub2RlOnJvb3ROb2RlfTtcclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlTm9kZShyb290Tm9kZSxyb290VHJlZURhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9MYXlvdXQoe2RhdGE6W3Jvb3RUcmVlRGF0YV19LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBtZXRob2QgZG9MYXlvdXRcclxuICAgICAgICAgICAgICog5qC55o2u5Lyg6L+H5p2l5qCR5Z6L57uT5p6E5pWw5o2u6L+b6KGM5qCR5biD5bGAXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmVlRGF0YSDmoJHlvaLmlbDmja5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJlZURhdGEuY3JlYXRlTm9kZUZ1bmN0aW9uPW51bGwg5Yib5bu66IqC54K555qE5Ye95pWwIOS8muaKimRhdGHkuK3nmoTmlbDmja4g5Lyg6YCS6L+H5Y67ICDlpoLmnpzmsqHmnInpu5jorqTlsLHmmK/liJvlu7rlnIblvaJcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRyZWVEYXRhLmRhdGEg5Yib5bu65qCR5biD5bGA5pWw5o2u77yI5b+F6aG75YyF5ousbmFtZeWxnuaAp++8iVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTm90QnVpbGRMaW5rPXRydWUg6buY6K6k5piv6Ieq5Yqo5Yib5bu66L+e57q/77yM5LygdHJ1ZeWImeS4jeS8muiHquWKqOWIm+W7uui/nue6v1xyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGJvdW5kaW5nYm94IOWMheWbtOWSjFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUuZG9MYXlvdXQgPSBmdW5jdGlvbih0cmVlRGF0YSwgaXNOb3RCdWlsZExpbmspICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm9vdERhdGEgPSB0cmVlRGF0YS5kYXRhWzBdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlRGF0YSA9IHRyZWVEYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZSA9IFRyZWVEYXRhLmZyb21PcHRpb25EYXRhKHJvb3REYXRhLm5hbWUsIHJvb3REYXRhLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZS5yb290LmRhdGEgPSByb290RGF0YTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYnVpbGROb2RlKHRyZWVEYXRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL+agueaNrnJvb3TlnZDmoIcg5pa55ZCRIOWvueavj+S4quiKgueCueeahOWdkOagh+i/m+ihjOaYoOWwhFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VHJlZVNoYXBlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1aWxkQWxsTGluayhpc05vdEJ1aWxkTGluayk7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICogQG1ldGhvZCBfYnVpbGRBbGxMaW5rXHJcbiAgICAgICAgICAgICAqIOmAkuW9kueUu+WHuui/nuaOpee6vyDkuI7orr7nva7oioLngrnlnZDmoIdcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5fYnVpbGRBbGxMaW5rID0gZnVuY3Rpb24gKGlzTm90QnVpbGRMaW5rKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWUudHJhdmVyc2UoZnVuY3Rpb24odHJlZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL+eUu+i/nuaOpee6v1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmVlTm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwICYmICFpc05vdEJ1aWxkTGluaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWlsZExpbmtCeVBhcmVudCh0cmVlTm9kZSwgdGhpcy50cmVlRGF0YS5jcmVhdGVMaW5rRnVuY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXNoVG9wby5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZSh0cmVlTm9kZS5kYXRhLm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sdGhpcylcclxuICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRCb3VuZGluZ1JlY3RcclxuICAgICAgICAgICAgICog6K6h566X5Ye65qCR55qE5YyF5Zu05ZKMXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gYm91bmRpbmdib3gg5YyF5Zu05ZKMXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5nZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZS50cmF2ZXJzZShmdW5jdGlvbih0cmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZFJlY3QgPSBCb3VuZGluZ1JlY3QuY3JlYXRlKHt4OnRyZWVOb2RlLmxheW91dC5wb3NpdGlvblswXSwgeTp0cmVlTm9kZS5sYXlvdXQucG9zaXRpb25bMV0sIHdpZHRoOnRyZWVOb2RlLmxheW91dC53aWR0aCwgaGVpZ2h0OiB0cmVlTm9kZS5sYXlvdXQuaGVpZ2h0fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWN0KSByZWN0ID0gY2hpbGRSZWN0LmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdC51bmlvbihjaGlsZFJlY3QpO1xyXG4gICAgICAgICAgICAgICAgfSx0aGlzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUuX3NldFRyZWVTaGFwZSA9IGZ1bmN0aW9uKGRvbmVDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGVDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJlZUhlbHBlciA9IG5ldyBUcmVlSGVscGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVBhZGRpbmc6IHRoaXMubm9kZVBhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyUGFkZGluZzogdGhpcy5sYXllclBhZGRpbmdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWUudHJhdmVyc2UoZnVuY3Rpb24odHJlZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih6clV0aWwuaW5kZXhPZih0aGlzLl9oaWRlTm9kZXMsIHRyZWVOb2RlKSA9PSAtMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0cmVlTm9kZS5kYXRhLm5vZGUuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmxheW91dCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0cmVlTm9kZS5kYXRhLm5vZGUuX3dpZHRoIHx8IGJvdW5kaW5nUmVjdC53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdHJlZU5vZGUuZGF0YS5ub2RlLl9oZWlnaHQgfHwgYm91bmRpbmdSZWN0LmhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0sdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0cmVlSGVscGVyLl9oaWRlTm9kZXMgPSB0aGlzLl9oaWRlTm9kZXM7XHJcbiAgICAgICAgICAgICAgICB0cmVlSGVscGVyLnJ1bih0aGlzLnRyZWUpO1xyXG4gICAgICAgICAgICAgICAgLy8g5qCR55qE5pa55ZCRXHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZW50ID0gdGhpcy5vcHRpb25zLm9yaWVudDtcclxuICAgICAgICAgICAgICAgIHZhciByb290WCA9IHRoaXMub3B0aW9ucy5yb290TG9jYXRpb24ueDtcclxuICAgICAgICAgICAgICAgIHZhciByb290WSA9IHRoaXMub3B0aW9ucy5yb290TG9jYXRpb24ueTtcclxuICAgICAgICAgICAgICAgIHZhciB6cldpZHRoID0gdGhpcy5maXNoVG9wby5nZXRXaWR0aCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHpySGVpZ2h0ID0gdGhpcy5maXNoVG9wby5nZXRIZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChyb290WCA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICByb290WCA9IHpyV2lkdGggKiAwLjU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByb290WCA9IHBhcnNlUGVyY2VudChyb290WCwgenJXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocm9vdFkgPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdFkgPSB6ckhlaWdodCAqIDAuNTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RZID0gcGFyc2VQZXJjZW50KHJvb3RZLCB6ckhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByb290WSA9IHBhcnNlUGVyY2VudChyb290WSwgenJIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgLy8g5rC05bmz5qCRXHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICByb290WCA9IGlzTmFOKHJvb3RYKSA/IDEwIDogcm9vdFg7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdFkgPSBpc05hTihyb290WSkgPyB6ckhlaWdodCAqIDAuNSA6IHJvb3RZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8g57q15ZCR5qCRXHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByb290WCA9IGlzTmFOKHJvb3RYKSA/IHpyV2lkdGggKiAwLjUgOiByb290WDtcclxuICAgICAgICAgICAgICAgICAgICByb290WSA9IGlzTmFOKHJvb3RZKSA/IDEwIDogcm9vdFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB0cmVlIGxheW91dOiHquWKqOeul+WHuuadpeeahHJvb3TnmoTlnZDmoIdcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5Sb290WCA9IHRoaXMudHJlZS5yb290LmxheW91dC5wb3NpdGlvblswXTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdHJlZU5vZGVDb3VudCA9IHRyZWVIZWxwZXIuY291bnQodGhpcy50cmVlKSAtIHRoaXMuX2hpZGVOb2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWluWSA9IEluZmluaXR5O1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZS50cmF2ZXJzZShcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodHJlZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih6clV0aWwuaW5kZXhPZih0aGlzLl9oaWRlTm9kZXMsIHRyZWVOb2RlKSA9PSAtMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZW50ID09PSAndmVydGljYWwnICYmIHRoaXMub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdpbnZlcnNlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSB0cmVlTm9kZS5sYXlvdXQucG9zaXRpb25bMF0gLSBvcmlnaW5Sb290WCArIHJvb3RYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSByb290WSAtIHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9yaWVudCA9PT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSB0cmVlTm9kZS5sYXlvdXQucG9zaXRpb25bMF0gLSBvcmlnaW5Sb290WCArIHJvb3RYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB0cmVlTm9kZS5sYXlvdXQucG9zaXRpb25bMV0gKyByb290WTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9yaWVudCA9PT0gJ2hvcml6b250YWwnICYmIHRoaXMub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdpbnZlcnNlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB0cmVlTm9kZS5sYXlvdXQucG9zaXRpb25bMF0gLSBvcmlnaW5Sb290WCArIHJvb3RZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSByb290WCAtIHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9yaWVudCA9PT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblswXSAtIG9yaWdpblJvb3RYICsgcm9vdFk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblsxXSArIHJvb3RYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUubGF5b3V0Ll9feCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5sYXlvdXQuX195ID0geTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5IDwgbWluWSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblkgPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZS50cmF2ZXJzZShmdW5jdGlvbiAodHJlZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih6clV0aWwuaW5kZXhPZih0aGlzLl9oaWRlTm9kZXMsIHRyZWVOb2RlKSA9PSAtMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW5ZID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzBdID0gdHJlZU5vZGUubGF5b3V0Ll9feDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblsxXSA9IHRyZWVOb2RlLmxheW91dC5fX3k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzBdID0gdHJlZU5vZGUubGF5b3V0Ll9feDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblsxXSA9IHRyZWVOb2RlLmxheW91dC5fX3kgLSBtaW5ZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5kYXRhLm5vZGUuYW5pbWF0ZVRvKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbdHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzBdLCB0cmVlTm9kZS5sYXlvdXQucG9zaXRpb25bMV1dXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy5hbmltYXRlVGltZSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKythbmltYXRlQ291bnQgPT09IHRyZWVOb2RlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy/oioLngrnmnInlranlrZDmiY3mmL7npLog5pS257yp5oyJ6ZKuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuX2hpZGVOb2Rlcy5sZW5ndGggPT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJlZU5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiB0cmVlTm9kZS5kYXRhLm5vZGUuX3RvZ2dsZVNocmluaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmRhdGEubm9kZS5fdG9nZ2xlU2hyaW5rKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0sdGhpcylcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUuX2J1aWxkTm9kZSA9IGZ1bmN0aW9uKHRyZWVEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZighdHJlZURhdGEuY3JlYXRlTm9kZUZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJlZURhdGEuY3JlYXRlTm9kZUZ1bmN0aW9uID0gdGhpcy5fZGVmYXVsdENyZWF0ZU5vZGVGdW5jdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8v5Yik5pat5LiA5LiL5piv5ZCm5pyJbm9kZSDlpoLmnpzmsqHmnInliJnoh6rlt7HliJvlu7pcclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZS50cmF2ZXJzZShmdW5jdGlvbih0cmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCF0cmVlTm9kZS5kYXRhLm5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNyZWF0ZU5vZGVGdW5jdGlvbiA9IHRyZWVOb2RlLmRhdGEuY3JlYXRlTm9kZUZ1bmN0aW9uIHx8IHRyZWVEYXRhLmNyZWF0ZU5vZGVGdW5jdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVOb2RlRnVuY3Rpb24odHJlZU5vZGUuZGF0YSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuX2NoaWxkU2hvdyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlzaFRvcG8uYWRkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5kYXRhLm5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFRyZWVMYXlvdXQucHJvdG90eXBlLl9kZWZhdWx0Q3JlYXRlTm9kZUZ1bmN0aW9uID0gZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNpcmNsZSA9IHRoaXMuZmlzaFRvcG8uY3JlYXRlTm9kZShcIkNpcmNsZVwiLHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZTogeyByOiAxNSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7IGZpbGw6IFwiIzQ4ODNiNFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogaXRlbS5sYWJsZSB8fCBpdGVtLm5hbWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNpcmNsZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUuX2J1aWxkTGlua0J5UGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudFRyZWVOb2RlLCBjcmVhdGVMaW5rRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBjaGlsZExlbmd0aCA9IHBhcmVudFRyZWVOb2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGNoaWxkTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWlsZExpbmsocGFyZW50VHJlZU5vZGUsIHBhcmVudFRyZWVOb2RlLmNoaWxkcmVuW2ldLCBjcmVhdGVMaW5rRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgIFRyZWVMYXlvdXQucHJvdG90eXBlLl9idWlsZExpbmsgPSBmdW5jdGlvbiAoc3RhcnRUcmVlTm9kZSwgZW5kVHJlZU5vZGUsIGNyZWF0ZUxpbmtGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydE5vZGUgPSBzdGFydFRyZWVOb2RlLmRhdGEubm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kTm9kZSA9IGVuZFRyZWVOb2RlLmRhdGEubm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBpZihjcmVhdGVMaW5rRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtT2JqID0gIGVuZFRyZWVOb2RlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtT2JqLnN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1PYmouZW5kTm9kZSA9IGVuZE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvciA9IGNyZWF0ZUxpbmtGdW5jdGlvbihwYXJhbU9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmtTdHlsZSA9IHRoaXMub3B0aW9ucy5saW5lU3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRUcmVlTm9kZS5kYXRhLmxpbmVTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua1N0eWxlID0genJVdGlsLm1lcmdlKHpyVXRpbC5jbG9uZShsaW5rU3R5bGUpLCBlbmRUcmVlTm9kZS5kYXRhLmxpbmVTdHlsZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yID0gdGhpcy5maXNoVG9wby5jcmVhdGVMaW5rKHN0YXJ0Tm9kZSxlbmROb2RlLGxpbmtTdHlsZSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXNoVG9wby5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGFkZENoaWxkXHJcbiAgICAgICAgICAgICAqIOWcqOaMh+WumnRvcG/oioLngrnkuIvmlrDlop7kuIDkuKrlrZDoioLngrlcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRyZWVOb2RlIOimgeWinuWKoOWtkOiKgueCueeahHRvcG/oioLngrlcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEg5paw5aKe5a2Q6IqC54K555qE5pWw5o2uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIOWinuWKoOWujOWtkOiKgueCueS5i+WQjuinpuWPkeeahOWbnuiwg+WHveaVsFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IOaWsOWinuWKoOeahOWtkOiKgueCuVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAodHJlZU5vZGUsIGRhdGEsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3VHJlZU5vZGUgPSAobmV3IFRyZWVEYXRhKGRhdGEubmFtZSkpLnJvb3Q7XHJcbiAgICAgICAgICAgICAgICBuZXdUcmVlTm9kZS5kYXRhID0gZGF0YTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMudHJlZURhdGEuY3JlYXRlTm9kZUZ1bmN0aW9uKG5ld1RyZWVOb2RlLmRhdGEsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5fY2hpbGRTaG93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0cmVlTm9kZS5jaGlsZHJlbi5sZW5ndGggPj0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cigncG9zaXRpb24nLCB6clV0aWwuY2xvbmUodHJlZU5vZGUuY2hpbGRyZW5bdHJlZU5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubGF5b3V0LnBvc2l0aW9uKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cigncG9zaXRpb24nLCB6clV0aWwuY2xvbmUodHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5maXNoVG9wby5hZGQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBuZXdUcmVlTm9kZS5kYXRhLm5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVpbGRMaW5rKHRyZWVOb2RlLCBuZXdUcmVlTm9kZSwgdGhpcy50cmVlRGF0YS5jcmVhdGVMaW5rRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLm9wdGlvbnMuYW5pbWF0ZVRpbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRyZWVOb2RlLmFkZChuZXdUcmVlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbkFuZExpbmUoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG1ldGhvZCB0b2dnbGVDaGlsZFxyXG4gICAgICAgICAgICAgKiDlsZXnpLrmiJbogIXpmpDol4/pgInkuK10b3Bv6IqC54K55LiL55qE5a2Q6IqC54K55Lul5Y+K5LiO5a2Q6IqC54K55LmL6Ze055qE6L+e57q/XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIOagkeiKgueCuVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUudG9nZ2xlQ2hpbGQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvZ2dsZVRyZWVOb2RlID0gdGhpcy5maW5kVHJlZU5vZGVCeU5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5fY2hpbGRTaG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlVHJlZU5vZGUudHJhdmVyc2UoZnVuY3Rpb24gKHRyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmVlTm9kZS5kYXRhLm5vZGUgIT09IG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmRhdGEubm9kZS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih6clV0aWwuaW5kZXhPZih0aGlzLl9oaWRlTm9kZXMsIHRyZWVOb2RlKSA9PSAtMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZU5vZGVzLnB1c2godHJlZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXNoVG9wby5jb25uZWN0aW9uTWFuYWdlci50b2dnbGVMaW5lQnlOb2RlKHRyZWVOb2RlLmRhdGEubm9kZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVOb2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5kYXRhLm5vZGUuX2NoaWxkU2hvdyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmRhdGEubm9kZS5fdG9nZ2xlU2hyaW5rICYmIHRyZWVOb2RlLmRhdGEubm9kZS5fdG9nZ2xlU2hyaW5rKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fY2hpbGRTaG93ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fdG9nZ2xlU2hyaW5rICYmIG5vZGUuX3RvZ2dsZVNocmluayhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoUG9zaXRpb25BbmRMaW5lKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZVRyZWVOb2RlLnRyYXZlcnNlKGZ1bmN0aW9uICh0cmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJlZU5vZGUuZGF0YS5ub2RlICE9PSBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5kYXRhLm5vZGUuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZU5vZGVzLnNwbGljZSh6clV0aWwuaW5kZXhPZih0aGlzLl9oaWRlTm9kZXMsIHRyZWVOb2RlKSwxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlzaFRvcG8uY29ubmVjdGlvbk1hbmFnZXIudG9nZ2xlTGluZUJ5Tm9kZSh0cmVlTm9kZS5kYXRhLm5vZGUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVOb2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5kYXRhLm5vZGUuX2NoaWxkU2hvdyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUuZGF0YS5ub2RlLl90b2dnbGVTaHJpbmsgJiYgdHJlZU5vZGUuZGF0YS5ub2RlLl90b2dnbGVTaHJpbmsodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2NoaWxkU2hvdyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fdG9nZ2xlU2hyaW5rICYmIG5vZGUuX3RvZ2dsZVNocmluayh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbkFuZExpbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGZpbmRUcmVlTm9kZUJ5Tm9kZVxyXG4gICAgICAgICAgICAgKiDmoLnmja50b3Bv6IqC54K55om+5Yiw5qCR55qE6IqC54K5XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRvcG/oioLngrlcclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRyZWVMYXlvdXQucHJvdG90eXBlLmZpbmRUcmVlTm9kZUJ5Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVHJlZU5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLnRyYXZlcnNlKGZ1bmN0aW9uICh0cmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmVlTm9kZS5kYXRhLm5vZGUgPT09IG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHJlZU5vZGUgPSB0cmVlTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5UcmVlTm9kZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZU5vZGVcclxuICAgICAgICAgICAgICog5Yig6Zmk6YCJ5LitdG9wb+iKgueCuVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0b3Bv6IqC54K5XHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IOWIoOmZpOaYr+WQpuaIkOWKn1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJlZU5vZGUgPSB0aGlzLmZpbmRUcmVlTm9kZUJ5Tm9kZShub2RlKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRUcmVlTm9kZSA9IHRyZWVOb2RlLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50VHJlZU5vZGUpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8v6YGN5Y6GIHRvcG/kuK3liKDpmaToh6rlt7Hlj4rlranlrZDoioLngrlcclxuICAgICAgICAgICAgICAgIHRyZWVOb2RlLnRyYXZlcnNlKGZ1bmN0aW9uIChlYWNoVHJlZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpc2hUb3BvLnJlbW92ZShlYWNoVHJlZU5vZGUuZGF0YS5ub2RlKTsgLy/liKDpmaToioLngrlcclxuICAgICAgICAgICAgICAgIH0sdGhpcylcclxuXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRUcmVlTm9kZS5yZW1vdmUodHJlZU5vZGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8v5Yik5pat5LiA5LiL54i26IqC54K55piv5LiN5piv5rKh5pyJ5LqGLOWmguaenOayoeacieeahOivnSzopoHmiornur/kuI4rLeWPt+e7memakOiXj+aOiVxyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyZWVOb2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFRyZWVOb2RlLmRhdGEubm9kZS5faGlkZVRvZ2dsZSAmJiBwYXJlbnRUcmVlTm9kZS5kYXRhLm5vZGUuX2hpZGVUb2dnbGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL+mHjeaWsOeUn+aIkOaVsOaNrlxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoUG9zaXRpb25BbmRMaW5lKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZUNoaWxkcmVuXHJcbiAgICAgICAgICAgICAqIOWIoOmZpOmAieS4rXRvcG/oioLngrnkuIvnmoTmiYDmnInlrZDoioLngrlcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdG9wb+iKgueCuVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSDliKDpmaTmmK/lkKbmiJDlip9cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRyZWVMYXlvdXQucHJvdG90eXBlLnJlbW92ZUNoaWxkcmVuID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmVlTm9kZSA9IHRoaXMuZmluZFRyZWVOb2RlQnlOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgLy/pgY3ljoYgdG9wb+S4reWIoOmZpOWtqeWtkOiKgueCuVxyXG4gICAgICAgICAgICAgICAgdHJlZU5vZGUudHJhdmVyc2UoZnVuY3Rpb24gKGVhY2hUcmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlYWNoVHJlZU5vZGUgIT09IHRyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlzaFRvcG8ucmVtb3ZlKGVhY2hUcmVlTm9kZS5kYXRhLm5vZGUpOyAvL+WIoOmZpOiKgueCuVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sdGhpcylcclxuXHJcbiAgICAgICAgICAgICAgICB0cmVlTm9kZS5yZW1vdmVBbGxDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5faGlkZVRvZ2dsZSAmJiBub2RlLl9oaWRlVG9nZ2xlKCk7IC8vdGhpcy5faGlkZVBhdGgobm9kZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy/ph43mlrDnlJ/miJDmlbDmja5cclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaFBvc2l0aW9uQW5kTGluZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG1ldGhvZCByZWZyZXNoUG9zaXRpb25BbmRMaW5lXHJcbiAgICAgICAgICAgICAqIOWIt+aWsOW9k+WJjeagkeW4g+WxgOS4reaJgOacieiKgueCueeahOS9jee9ruWSjOiKgueCueS5i+mXtOeahOi/nue6v1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayDliLfmlrDkuYvlkI7miYDop6blj5HnmoTlm57osIPlh73mlbBcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRyZWVMYXlvdXQucHJvdG90eXBlLnJlZnJlc2hQb3NpdGlvbkFuZExpbmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZS5yb290LnVwZGF0ZURlcHRoQW5kSGVpZ2h0KDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VHJlZVNoYXBlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWUudHJhdmVyc2UoZnVuY3Rpb24gKGVhY2hUcmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpc2hUb3BvLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKGVhY2hUcmVlTm9kZS5kYXRhLm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG1ldGhvZCBjaGFuZ2VQb3NpdGlvblxyXG4gICAgICAgICAgICAgKiDmm7TmlLnlvZPliY10b3Bv6IqC54K55Zyo5YW25YWE5byf6IqC54K55Lit55qE5L2N572uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIOagkeiKgueCuVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uIOiKgueCueenu+WKqOeahOaWueWQke+8jG5leHTooajnpLrlvoDkuIvnp7vliqjvvIxwcmV26KGo56S65b6A5LiK56e75YqoXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5jaGFuZ2VQb3NpdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm93SW5kZXggPSB6clV0aWwuaW5kZXhPZihwYXJlbnROb2RlLmNoaWxkcmVuLCBub2RlKTtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRJbmRleDtcclxuICAgICAgICAgICAgICAgIGlmKGRpcmVjdGlvbiA9PSBcIm5leHRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSBub3dJbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZihkaXJlY3Rpb24gPT0gXCJwcmV2XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEluZGV4ID0gbm93SW5kZXggLSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSBwYXJlbnROb2RlLmNoaWxkcmVuW3RhcmdldEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmKHRhcmdldE5vZGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yYWdlID0gdGFyZ2V0Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuW3RhcmdldEluZGV4XSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbltub3dJbmRleF0gPSBzdG9yYWdlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoUG9zaXRpb25BbmRMaW5lKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpc2hUb3BvLnRyaWdnZXIoJ3RyZWVMYXlvdXQ6Y2hhbmdlUG9zaXRpb24nLHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlOm5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZTpwYXJlbnROb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGU6dGFyZ2V0Tm9kZVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFRyZWVMYXlvdXQ7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgYWRkQ3VzdG9tTGF5b3V0XHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvVHJlZUxheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNvbnN0cnVjdG9yIFRyZWVOb2RlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgTm9kZSBJRFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBUcmVlTm9kZShpZCwgZGF0YSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiKgueCueeahOa3seW6plxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Lul5b2T5YmN6IqC54K55Li65qC56IqC54K555qE5a2Q5qCR55qE6auY5bqmXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5a2Q6IqC54K55YiX6KGoXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxUcmVlTm9kZT59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7VHJlZU5vZGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDlrZjlgqjnmoTnlKjmiLfmlbDmja5cclxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwgbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOa3u+WKoOWtkOiKgueCuVxyXG4gICAgICogQHBhcmFtIHtUcmVlTm9kZX0gY2hpbGRcclxuICAgICAqL1xyXG4gICAgVHJlZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcbiAgICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOenu+mZpOWtkOiKgueCuVxyXG4gICAgICogQHBhcmFtIHtUcmVlTm9kZX0gY2hpbGRcclxuICAgICAqL1xyXG4gICAgVHJlZU5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIGlkeCA9IHpyVXRpbC5pbmRleE9mKGNoaWxkcmVuLCBjaGlsZCk7XHJcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgIFRyZWVOb2RlLnByb3RvdHlwZS5yZW1vdmVBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6YGN5Y6G5b2T5YmN6IqC54K55Y+K5YW25omA5pyJ5a2Q6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gICBbY29udGV4dF1cclxuICAgICAqL1xyXG4gICAgVHJlZU5vZGUucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XHJcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0udHJhdmVyc2UoY2IsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDpgY3ljoboioLliY3oioLngrnlj4rmiYDmnInlrZDoioLngrnnmoTmlbDph49cclxuICAgICAqL1xyXG4gICAgVHJlZU5vZGUucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy50cmF2ZXJzZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5pu05paw5b2T5YmN5qCR5Y+K5omA5pyJ5a2Q5qCR55qE6auY5bqm5ZKM5rex5bqmXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGRlcHRoXHJcbiAgICAgKi9cclxuICAgIFRyZWVOb2RlLnByb3RvdHlwZS51cGRhdGVEZXB0aEFuZEhlaWdodCA9IGZ1bmN0aW9uIChkZXB0aCkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgY2hpbGQudXBkYXRlRGVwdGhBbmRIZWlnaHQoZGVwdGggKyAxKTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLmhlaWdodCA+IGhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gY2hpbGQuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICsgMTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkXHJcbiAgICAgKiBAcmV0dXJuIFRyZWVOb2RlXHJcbiAgICAgKi9cclxuICAgIFRyZWVOb2RlLnByb3RvdHlwZS5nZXROb2RlQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlkID09PSBpZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLmNoaWxkcmVuW2ldLmdldE5vZGVCeUlkKGlkKTtcclxuICAgICAgICAgICAgaWYgKHJlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9kYXRhL1RyZWVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBUcmVlKGlkKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge1RyZWVOb2RlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucm9vdCA9IG5ldyBUcmVlTm9kZShpZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDpgY3ljobmoJHnmoTmiYDmnInlrZDoioLngrko5rex5bqm5LyY5YWI6YGN5Y6GKVxyXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgW2NvbnRleHRdXHJcbiAgICAgKi9cclxuICAgIFRyZWUucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24oY2IsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnJvb3QudHJhdmVyc2UoY2IsIGNvbnRleHQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUn+aIkOWtkOagkVxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBpZCDlrZDmoJHmoLnoioLngrkgaWRcclxuICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2RhdGEvVHJlZX1cclxuICAgICAqL1xyXG4gICAgVHJlZS5wcm90b3R5cGUuZ2V0U3ViVHJlZSA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmdldE5vZGVCeUlkKGlkKTtcclxuICAgICAgICBpZiAocm9vdCkge1xyXG4gICAgICAgICAgICB2YXIgdHJlZSA9IG5ldyBUcmVlKHJvb3QuaWQpO1xyXG4gICAgICAgICAgICB0cmVlLnJvb3QgPSByb290O1xyXG4gICAgICAgICAgICByZXR1cm4gdHJlZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBpZFxyXG4gICAgICogQHJldHVybiBUcmVlTm9kZVxyXG4gICAgICovXHJcbiAgICBUcmVlLnByb3RvdHlwZS5nZXROb2RlQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuZ2V0Tm9kZUJ5SWQoaWQpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDku44gb3B0aW9uIOmHjOeahCBkYXRhIOaVsOaNruaehOW7uuagkVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBkYXRhXHJcbiAgICAgKiBAcmV0dXJuIFRyZWVcclxuICAgICAqL1xyXG4gICAgVHJlZS5mcm9tT3B0aW9uRGF0YSA9IGZ1bmN0aW9uIChpZCwgZGF0YSkge1xyXG4gICAgICAgIHZhciB0cmVlID0gbmV3IFRyZWUoaWQpO1xyXG4gICAgICAgIHZhciByb290Tm9kZSA9IHRyZWUucm9vdDtcclxuICAgICAgICAvLyBSb290IG5vZGVcclxuICAgICAgICByb290Tm9kZS5kYXRhID0ge1xyXG4gICAgICAgICAgICBuYW1lOiBpZCxcclxuICAgICAgICAgICAgY2hpbGRyZW46IGRhdGFcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBidWlsZEhpZXJhcmNoeShkYXRhTm9kZSwgcGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBUcmVlTm9kZShkYXRhTm9kZS5uYW1lLCBkYXRhTm9kZSk7XHJcbiAgICAgICAgICAgIHBhcmVudE5vZGUuYWRkKG5vZGUpO1xyXG4gICAgICAgICAgICAvLyDpgY3ljobmt7vliqDlrZDoioLngrlcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZGF0YU5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkSGllcmFyY2h5KGNoaWxkcmVuW2ldLCBub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJ1aWxkSGllcmFyY2h5KGRhdGFbaV0sIHJvb3ROb2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRyZWUucm9vdC51cGRhdGVEZXB0aEFuZEhlaWdodCgwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRyZWU7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBUcmVlLmZyb21EYXRhU291cmNlID0gZnVuY3Rpb24gKGRhdGFTb3VyY2UsIHJvb3RJdGVtKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIF9maW5kQ2hpbGRJdGVtKG5vZGVOYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB6clV0aWwuZmlsdGVyKGRhdGFTb3VyY2UubGluayxmdW5jdGlvbihpdGVtKXtcclxuICAgICAgICAgICAgICAgIGlmKGl0ZW0uZnJvbSA9PT0gbm9kZU5hbWUgJiYgIWl0ZW0ucG9zKSB7ICAvLyDmlbDmja7kuK3mnIlwb3PlsZ7mgKfnmoTkuI3mmK/lrZDoioLngrlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYnVpbGRIaWVyYXJjaHkocm9vdCkge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRJdGVtID0gX2ZpbmRDaGlsZEl0ZW0ocm9vdC5pZCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRJdGVtLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGNoaWxkSXRlbVtpXTtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZFRyZWVOb2RlID0gdHJlZU5vZGVzTWFwW2l0ZW0udG9dO1xyXG4gICAgICAgICAgICAgICAgcm9vdC5jaGlsZHJlbi5wdXNoKGNoaWxkVHJlZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgYnVpbGRIaWVyYXJjaHkoY2hpbGRUcmVlTm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0cmVlTm9kZXNNYXAgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFTb3VyY2Uubm9kZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRhdGFTb3VyY2Uubm9kZVtpXTtcclxuICAgICAgICAgICAgdmFyIHRyZWVOb2RlID0gbmV3IFRyZWVOb2RlKG5vZGUubmFtZSxub2RlKTtcclxuICAgICAgICAgICAgdHJlZU5vZGVzTWFwW25vZGUubmFtZV0gPSB0cmVlTm9kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0cmVlID0gbmV3IFRyZWUocm9vdEl0ZW0ubmFtZSk7XHJcbiAgICAgICAgdmFyIHJvb3ROb2RlID0gdHJlZS5yb290O1xyXG4gICAgICAgIC8vIFJvb3Qgbm9kZVxyXG4gICAgICAgIHJvb3ROb2RlLmRhdGEgPSByb290SXRlbTtcclxuXHJcblxyXG4gICAgICAgIGJ1aWxkSGllcmFyY2h5KHRyZWUucm9vdCk7XHJcbiAgICAgICAgdHJlZS5yb290LnVwZGF0ZURlcHRoQW5kSGVpZ2h0KDApO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJlZTtcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUcmVlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvZGF0YS9UcmVlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblxyXG4gICAgZnVuY3Rpb24gVHJlZUhlbHBlcihvcHRzKSB7XHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XHJcblxyXG4gICAgICAgIHRoaXMubm9kZVBhZGRpbmcgPSBvcHRzLm5vZGVQYWRkaW5nIHx8IDMwO1xyXG5cclxuICAgICAgICB0aGlzLmxheWVyUGFkZGluZyA9IG9wdHMubGF5ZXJQYWRkaW5nIHx8IDEwMDtcclxuXHJcbiAgICAgICAgdGhpcy5fbGF5ZXJPZmZzZXRzID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuX2xheWVycyA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLl9oaWRlTm9kZXMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBUcmVlSGVscGVyLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICh0cmVlKSB7XHJcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICB0cmVlLnRyYXZlcnNlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY291bnQ7XHJcbiAgICB9XHJcblxyXG4gICAgVHJlZUhlbHBlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKHRyZWUpIHtcclxuICAgICAgICB0aGlzLl9sYXllck9mZnNldHMubGVuZ3RoID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUucm9vdC5oZWlnaHQgKyAxOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJPZmZzZXRzW2ldID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2ldID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZU5vZGVYUG9zaXRpb24odHJlZS5yb290KTtcclxuICAgICAgICB2YXIgcm9vdCA9IHRyZWUucm9vdDtcclxuICAgICAgICB0aGlzLl91cGRhdGVOb2RlWVBvc2l0aW9uKHJvb3QsIDAsIHJvb3QubGF5b3V0LmhlaWdodCk7XHJcbiAgICB9O1xyXG5cclxuICAgIFRyZWVIZWxwZXIucHJvdG90eXBlLl91cGRhdGVOb2RlWFBvc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB2YXIgbWluWCA9IEluZmluaXR5O1xyXG4gICAgICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xyXG4gICAgICAgIG5vZGUubGF5b3V0LnBvc2l0aW9uID0gbm9kZS5sYXlvdXQucG9zaXRpb24gfHwgdmVjMi5jcmVhdGUoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgaWYoenJVdGlsLmluZGV4T2YodGhpcy5faGlkZU5vZGVzLCBjaGlsZCkgPT0gLTEpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTm9kZVhQb3NpdGlvbihjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGNoaWxkLmxheW91dC5wb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgIGlmICh4IDwgbWluWCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblggPSB4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHggPiBtYXhYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiAoenJVdGlsLmluZGV4T2YodGhpcy5faGlkZU5vZGVzLCBub2RlLmNoaWxkcmVuWzBdKSA9PSAtMSkpIHtcclxuICAgICAgICAgICAgbm9kZS5sYXlvdXQucG9zaXRpb25bMF0gPSAobWluWCArIG1heFgpIC8gMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlLmxheW91dC5wb3NpdGlvblswXSA9IDA7XHJcbiAgICAgICAgICAgIG5vZGUuaGVpZ2h0ID0gMDsgICAvLyDpmpDol4/oioLngrnnmoQg5rex5bqm6K6+5Li6MFxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2ZmID0gdGhpcy5fbGF5ZXJPZmZzZXRzW25vZGUuZGVwdGhdIHx8IDA7XHJcbiAgICAgICAgaWYgKG9mZiA+IG5vZGUubGF5b3V0LnBvc2l0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGlmdCA9IG9mZiAtIG5vZGUubGF5b3V0LnBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICB0aGlzLl9zaGlmdFN1YnRyZWUobm9kZSwgc2hpZnQpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gbm9kZS5kZXB0aCArIDE7IGogPCBub2RlLmhlaWdodCArIG5vZGUuZGVwdGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJPZmZzZXRzW2pdICs9IHNoaWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xheWVyT2Zmc2V0c1tub2RlLmRlcHRoXSA9IG5vZGUubGF5b3V0LnBvc2l0aW9uWzBdICsgbm9kZS5sYXlvdXQud2lkdGggKyB0aGlzLm5vZGVQYWRkaW5nO1xyXG5cclxuICAgICAgICBpZih6clV0aWwuaW5kZXhPZih0aGlzLl9sYXllcnNbbm9kZS5kZXB0aF0sIG5vZGUpID09IC0xKXtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW25vZGUuZGVwdGhdLnB1c2gobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBUcmVlSGVscGVyLnByb3RvdHlwZS5fc2hpZnRTdWJ0cmVlID0gZnVuY3Rpb24gKHJvb3QsIG9mZnNldCkge1xyXG4gICAgICAgIHJvb3QubGF5b3V0LnBvc2l0aW9uWzBdICs9IG9mZnNldDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3QuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYoenJVdGlsLmluZGV4T2YodGhpcy5faGlkZU5vZGVzLHJvb3QuY2hpbGRyZW5baV0pID09IC0xKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NoaWZ0U3VidHJlZShyb290LmNoaWxkcmVuW2ldLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBUcmVlSGVscGVyLnByb3RvdHlwZS5fdXBkYXRlTm9kZVlQb3NpdGlvbiA9IGZ1bmN0aW9uIChub2RlLCB5LCBwcmV2TGF5ZXJIZWlnaHQpIHtcclxuICAgICAgICBpZih6clV0aWwuaW5kZXhPZih0aGlzLl9oaWRlTm9kZXMsbm9kZSkgPT0gLTEpe1xyXG4gICAgICAgICAgICBub2RlLmxheW91dC5wb3NpdGlvblsxXSA9IHk7XHJcbiAgICAgICAgICAgIHZhciBsYXllckhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGF5ZXJIZWlnaHQgPSBNYXRoLm1heChub2RlLmNoaWxkcmVuW2ldLmxheW91dC5oZWlnaHQsIGxheWVySGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbGF5ZXJQYWRkaW5nID0gdGhpcy5sYXllclBhZGRpbmc7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGxheWVyUGFkZGluZykgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGxheWVyUGFkZGluZyA9IGxheWVyUGFkZGluZyhub2RlLmRlcHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU5vZGVZUG9zaXRpb24obm9kZS5jaGlsZHJlbltqXSwgeSArIGxheWVyUGFkZGluZyArIHByZXZMYXllckhlaWdodCwgbGF5ZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRyZWVIZWxwZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvdHJlZUhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDlipvlr7zlkJHluIPlsYA8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubGF5b3V0LkZvcmNlTGF5b3V0XHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5sYXlvdXRcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBsYXlvdXQgPSBmaXNoVG9wb0Zsb3cubGF5b3V0O1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIGZ1bmN0aW9uIG5ld05vZGUoZGF0YSkge1xyXG4gKiAgICAgICAgICAgdmFyIGNpcmNsZSA9IG5ldyBub2RlLkNpcmNsZSh7XHJcbiAqICAgICAgICAgICAgICAgc2hhcGU6IHsgcjogMTUgfSxcclxuICogICAgICAgICAgICAgICBzdHlsZTogeyBmaWxsOiBcIiM0ODgzYjRcIiB9LFxyXG4gKiAgICAgICAgICAgICAgIG5hbWU6IGRhdGEubmFtZVxyXG4gKiAgICAgICAgICAgfSk7XHJcbiAqICAgICAgICAgICByZXR1cm4gY2lyY2xlO1xyXG4gKiAgICAgICB9XHJcbiAqICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gKiAgICAgICAgICAgY3JlYXRlTm9kZUZ1bmN0aW9uOiBuZXdOb2RlLFxyXG4gKiAgICAgICAgICAgZGF0YTpbe25vZGVzOltcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ+iKgueCuTEnfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ+iKgueCuTInfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ+iKgueCuTMnfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ+iKgueCuTQnfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ+iKgueCuTUnfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ+iKgueCuTYnfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ+iKgueCuTcnfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ+iKgueCuTgnfVxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICogICAgICAgICAgICAgICAgICAgbGlua3M6W1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzb3VyY2U6J+iKgueCuTEnLCB0YXJnZXQ6J+iKgueCuTInfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7c291cmNlOifoioLngrkyJywgdGFyZ2V0OifoioLngrkzJ30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge3NvdXJjZTon6IqC54K5MycsIHRhcmdldDon6IqC54K5NCd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzb3VyY2U6J+iKgueCuTQnLCB0YXJnZXQ6J+iKgueCuTUnfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7c291cmNlOifoioLngrk1JywgdGFyZ2V0OifoioLngrk2J30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge3NvdXJjZTon6IqC54K5NicsIHRhcmdldDon6IqC54K5Nyd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzb3VyY2U6J+iKgueCuTcnLCB0YXJnZXQ6J+iKgueCuTgnfVxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gKiAgICAgICAgICAgfV1cclxuICogICAgICAgfVxyXG4gKiAgICAgICB2YXIgZm9yY2VMYXlvdXQgPSBuZXcgbGF5b3V0LkZvcmNlTGF5b3V0KHtcclxuICogICAgICAgICAgZmlzaFRvcG86ZmlzaFRvcG8sXHJcbiAqICAgICAgICAgICByZXB1bHNpb246IDIwMFxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZm9yY2VMYXlvdXQuZG9MYXlvdXQob3B0aW9ucyk7XHJcbiAqL1xyXG5cclxuXHJcblxyXG4gICAgdmFyIGZvcmNlSGVscGVyID0gcmVxdWlyZSgnLi9mb3JjZUhlbHBlcicpO1xyXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgZnVuY3Rpb24gRm9yY2VMYXlvdXQob3B0cykge1xyXG4gICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IGZpc2hUb3BvIGZpc2hUb3Bv5a6e5L6LXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gW3JlcHVsc2lvbj0xMDBdIOiKgueCueS5i+mXtOeahOaWpeWKm+WboOWtkOOAguivpeWAvOi2iuWkp+iKgueCueS5i+mXtOeahOaWpeWKm+i2iuWkp++8jOS4pOS4quiKgueCuemXtOeahOi3neemu+S5n+S8mui2iui/nO+8jOm7mOiupOS4ujEwMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IFtncmF2aXR5PTAuMV0g6IqC54K55Y+X5Yiw55qE5ZCR5Lit5b+D55qE5byV5Yqb5Zug5a2Q44CC6K+l5YC86LaK5aSn6IqC54K56LaK5b6A5Lit5b+D54K56Z2g5oui44CC6buY6K6k5Li6MC4xXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBbZWRnZUxlbmd0aD0zMF0g6L6555qE5Lik5Liq6IqC54K55LmL6Ze055qE6Led56a777yM6L+Z5Liq6Led56a75Lmf5Lya5Y+XIHJlcHVsc2lvbuW9seWTjeOAgiDpu5jorqTkuLozMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge0Jvb2xlYW59IFtvbmNlPXRydWVdIOaYr+WQpuWPqui/m+ihjOW4g+WxgOS4gOasoeOAgjxici8+XHJcbiAgICAgICAgICog5aaC5p6c6K6+572u5Li6ZmFsc2XvvIzlnKjluIPlsYDnu5PmnZ/ku6XlkI7vvIzlho3mi5bmi73oioLngrnvvIzoioLngrnnmoTlrprkvY3kvJrorr7nva7kuLpmaXhlZO+8jOmHiuaUvuiiq+aLluaLveeahOiKgueCue+8jOiKgueCueS8muWbnuWIsOWOn+adpeeahOS9jee9riwg5a+86Ie06YeN5paw5biD5bGA77yM5ZCM5qC35Lya5YaN5qyh6Kem5Y+RZm9yY2VMYXlvdXRFbmTkuovku7bjgIJcclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IFtyZWN0XSDluIPlsYDmmL7npLrojIPlm7RcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gW3JlY3QueF0g5biD5bGA5pi+56S66IyD5Zu0eOWdkOagh1xyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gW3JlY3QueV0g5biD5bGA5pi+56S66IyD5Zu0eeWdkOagh1xyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gW3JlY3Qud2lkdGhdIOW4g+WxgOaYvuekuuWuveW6plxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gW3JlY3QuaGVpZ2h0XSDluIPlsYDmmL7npLrpq5jluqZcclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtCb29sZWFufSBbbGF5b3V0QW5pbWF0aW9uPXRydWVdIOaYr+WQpuaYvuekuuW4g+WxgOWKqOeUu1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gW2xpbmVTdHlsZV0g6L+e57q/55qE5qC35byPICDlj4Lop4F7QGxpbmsgZmlzaFRvcG9GbG93LmxpbmsjY29uc3RydWN0b3Ig5p6E6YCg5Ye95pWwb3B0aW9uc+WPguaVsH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZpc2hUb3BvID0gb3B0cy5maXNoVG9wbztcclxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHJlcHVsc2lvbjogMTAwLCAgLy/oioLngrnkuYvpl7TnmoTmlqXlipvlm6DlrZDjgILor6XlgLzotorlpKfoioLngrnkuYvpl7TnmoTmlqXlipvotorlpKfvvIzkuKTkuKroioLngrnpl7TnmoTot53nprvkuZ/kvJrotorov5zvvIzpu5jorqTkuLoxMDBcclxuICAgICAgICAgICAgZ3Jhdml0eTogMC4xLCAvL+iKgueCueWPl+WIsOeahOWQkeS4reW/g+eahOW8leWKm+WboOWtkOOAguivpeWAvOi2iuWkp+iKgueCuei2iuW+gOS4reW/g+eCuemdoOaLouOAgum7mOiupOS4ujAuMVxyXG4gICAgICAgICAgICBlZGdlTGVuZ3RoOiAzMCwgLy8g6L6555qE5Lik5Liq6IqC54K55LmL6Ze055qE6Led56a777yM6L+Z5Liq6Led56a75Lmf5Lya5Y+XIHJlcHVsc2lvbuOAgiDpu5jorqTkuLozMFxyXG4gICAgICAgICAgICBvbmNlOnRydWUsXHJcbiAgICAgICAgICAgIGxheW91dEFuaW1hdGlvbjp0cnVlLFxyXG4gICAgICAgICAgICByZWN0OiB7eDowLCB5OjAsIHdpZHRoOnRoaXMuZmlzaFRvcG8uZ2V0V2lkdGgoKSAsaGVpZ2h0OnRoaXMuZmlzaFRvcG8uZ2V0SGVpZ2h0KCl9LFxyXG4gICAgICAgICAgICBsaW5lU3R5bGU6IHtzeW1ib2w6e3R5cGU6J25vbmUnfX0sXHJcbiAgICAgICAgICAgIHByZXNlcnZlZFBvaW50czoge31cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB6clV0aWwuZGVmYXVsdHMoZGVmYXVsdE9wdGlvbnMsIG9wdHMsIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBkb0xheW91dFxyXG4gICAgICog5qC55o2uZm9yY2VEYXRh6L+b6KGM5Yqb5a+85ZCR5biD5bGAXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZm9yY2VEYXRhIOWKm+WvvOWQkeaVsOaNrlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm9yY2VEYXRhLmNyZWF0ZU5vZGVGdW5jdGlvbj1udWxsIOWIm+W7uuiKgueCueeahOWHveaVsCDkvJrmiopkYXRh5Litbm9kZXPnmoTmlbDmja4g5Lyg6YCS6L+H5Y67ICDlpoLmnpzmsqHmnInpu5jorqTlsLHmmK/liJvlu7rlnIblvaJcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZvcmNlRGF0YS5jcmVhdGVMaW5rRnVuY3Rpb249bnVsbCDliJvlu7rnur/mrrXlh73mlbDvvIzlj4LmlbDmmK9kYXRhLmxpbmtz5pWw5o2u77yM5aaC5p6c5rKh5pyJ6buY6K6k5Yib5bu655u057q/IHNpbmNlIFYyLjMuMFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZvcmNlRGF0YS5kYXRhIOWIm+W7uuWKm+WvvOWQkeW4g+WxgOaVsOaNrlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZvcmNlRGF0YS5kYXRhLm5vZGVzIOWIm+W7uuWKm+WvvOWQkeW4g+WxgOiKgueCueeahOWvueixoeaVsOaNru+8iOW/hemhu+WMheaLrG5hbWXlsZ7mgKfvvIlcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmb3JjZURhdGEuZGF0YS5saW5rcyDliJvlu7rlipvlr7zlkJHluIPlsYDov57nur/nmoTlr7nosaHmlbDmja7vvIjlv4XpobvljIXmi6xuYW1l5bGe5oCn77yJXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBGb3JjZUxheW91dC5wcm90b3R5cGUuZG9MYXlvdXQgPSBmdW5jdGlvbihmb3JjZURhdGEpIHtcclxuICAgICAgICAgdmFyIHJvb3REYXRhID0gZm9yY2VEYXRhLmRhdGFbMF07XHJcbiAgICAgICAgIHRoaXMuYWxsTm9kZXMgPSB0aGlzLl9idWlsZE5vZGUocm9vdERhdGEubm9kZXMsIGZvcmNlRGF0YS5jcmVhdGVOb2RlRnVuY3Rpb24pO1xyXG4gICAgICAgICB0aGlzLmFsbExpbmtzID0gdGhpcy5fYnVpbGRMaW5rcyhyb290RGF0YS5saW5rcywgZm9yY2VEYXRhLmNyZWF0ZUxpbmtGdW5jdGlvbik7XHJcbiAgICAgICAgIHRoaXMuX2ZvcmNlSW5zKCk7XHJcblxyXG4gICAgICAgICB0aGlzLl9zdGFydEZvcmNlTGF5b3V0SXRlcmF0aW9uKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgYXV0b0xheW91dFxyXG4gICAgICog5qC55o2u5bey5pyJ6IqC54K56L+b6KGM5Yqb5a+85ZCR5biD5bGAXHJcbiAgICAgKiBAc2luY2UgVjIuMy4wXHJcbiAgICAgKi9cclxuICAgIEZvcmNlTGF5b3V0LnByb3RvdHlwZS5hdXRvTGF5b3V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hbGxOb2RlcyA9IHRoaXMuZmlzaFRvcG8uYWxsTm9kZXM7XHJcbiAgICAgICAgdGhpcy5hbGxMaW5rcyA9IHRoaXMuZmlzaFRvcG8uY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycztcclxuICAgICAgICB0aGlzLl9mb3JjZUlucygpO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0Rm9yY2VMYXlvdXRJdGVyYXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICBGb3JjZUxheW91dC5wcm90b3R5cGUuX2J1aWxkTm9kZSA9IGZ1bmN0aW9uKGRhdGFzLCBjcmVhdGVOb2RlRnVuY3Rpb24pIHtcclxuICAgICAgICBpZighZmlzaC5pc0Z1bmN0aW9uKGNyZWF0ZU5vZGVGdW5jdGlvbikpIHtcclxuICAgICAgICAgICAgY3JlYXRlTm9kZUZ1bmN0aW9uID0gdGhpcy5fZGVmYXVsdENyZWF0ZU5vZGVGdW5jdGlvbi5iaW5kKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWxsTm9kZXMgPSBbXTtcclxuICAgICAgICAvL+WIpOaWreS4gOS4i+aYr+WQpuaciW5vZGUg5aaC5p6c5rKh5pyJ5YiZ6Ieq5bex5Yib5bu6XHJcbiAgICAgICAgenJVdGlsLmVhY2goZGF0YXMsICBmdW5jdGlvbihpdGVtLGlkeCkge1xyXG4gICAgICAgICAgICBpZighaXRlbS5ub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3JlYXRlTm9kZSA9IGl0ZW0uY3JlYXRlTm9kZUZ1bmN0aW9uIHx8IGNyZWF0ZU5vZGVGdW5jdGlvbjtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gY3JlYXRlTm9kZShpdGVtKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlzaFRvcG8uYWRkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTm9kZUV2ZW50KG5vZGUsaWR4KTtcclxuICAgICAgICAgICAgICAgIGFsbE5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBhbGxOb2RlcztcclxuICAgIH1cclxuXHJcbiAgICBGb3JjZUxheW91dC5wcm90b3R5cGUuX2FkZE5vZGVFdmVudCA9IGZ1bmN0aW9uKG5vZGUsaWR4KSB7XHJcbiAgICAgICAgaWYoIXRoaXMub3B0aW9ucy5vbmNlKSB7XHJcbiAgICAgICAgICAgIG5vZGUub24oJ2RyYWcnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5mb3JjZUxheW91dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5mb3JjZUxheW91dC53YXJtVXAoKTtcclxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5fbGF5b3V0aW5nICYmIHRoaXMuX3N0YXJ0Rm9yY2VMYXlvdXRJdGVyYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZm9yY2VMYXlvdXQuc2V0Rml4ZWQoaWR4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSx0aGlzKS5vbignZHJhZ2VuZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmZvcmNlTGF5b3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZvcmNlTGF5b3V0LnNldFVuZml4ZWQoaWR4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSx0aGlzKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBGb3JjZUxheW91dC5wcm90b3R5cGUuX2RlZmF1bHRDcmVhdGVOb2RlRnVuY3Rpb24gPSBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IHRoaXMuZmlzaFRvcG8uY3JlYXRlTm9kZShcIkNpcmNsZVwiLHtcclxuICAgICAgICAgICAgc2hhcGU6IHsgcjogMTUgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHsgZmlsbDogXCIjNDg4M2I0XCIgfSxcclxuICAgICAgICAgICAgbmFtZTogaXRlbS5sYWJsZSB8fCBpdGVtLm5hbWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY2lyY2xlO1xyXG4gICAgfVxyXG5cclxuICAgIEZvcmNlTGF5b3V0LnByb3RvdHlwZS5fYnVpbGRMaW5rcyA9IGZ1bmN0aW9uKGxpbmtzLGNyZWF0ZUxpbmtGdW5jdGlvbikge1xyXG4gICAgICAgIHZhciBhbGxMaW5rcyA9IFtdO1xyXG5cclxuICAgICAgICB6clV0aWwuZWFjaChsaW5rcywgZnVuY3Rpb24obGluaykge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnROb2RlID0gdGhpcy5maXNoVG9wby5jaGlsZE9mTmFtZShsaW5rLnNvdXJjZSk7XHJcbiAgICAgICAgICAgIHZhciBlbmROb2RlID0gdGhpcy5maXNoVG9wby5jaGlsZE9mTmFtZShsaW5rLnRhcmdldCk7XHJcbiAgICAgICAgICAgIGlmKHN0YXJ0Tm9kZSAmJiBlbmROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZihjcmVhdGVMaW5rRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1PYmogPSBsaW5rO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtT2JqLnN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbU9iai5lbmROb2RlID0gZW5kTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3IgPSBjcmVhdGVMaW5rRnVuY3Rpb24ocGFyYW1PYmopO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGlua1N0eWxlID0gdGhpcy5vcHRpb25zLmxpbmVTdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGluay5zdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rU3R5bGUgPSB6clV0aWwubWVyZ2UoenJVdGlsLmNsb25lKGxpbmtTdHlsZSksIGxpbmsuc3R5bGUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3IgPSB0aGlzLmZpc2hUb3BvLmNyZWF0ZUxpbmsoc3RhcnROb2RlLGVuZE5vZGUsbGlua1N0eWxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZmlzaFRvcG8uYWRkKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgICAgICBhbGxMaW5rcy5wdXNoKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBhbGxMaW5rcztcclxuICAgIH1cclxuXHJcblxyXG4gICAgRm9yY2VMYXlvdXQucHJvdG90eXBlLl9mb3JjZUlucyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5vcHRpb25zLnJlY3Q7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcmVzZXJ2ZWRQb2ludHMgPSB0aGlzLm9wdGlvbnMucHJlc2VydmVkUG9pbnRzO1xyXG4gICAgICAgIHZhciBub2RlcyA9IHpyVXRpbC5tYXAodGhpcy5hbGxOb2RlcywgZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVwID0gdGhpcy5vcHRpb25zLnJlcHVsc2lvbjsgbm9kZS53ID0gcmVwOyBub2RlLnJlcCA9IHJlcDsgbm9kZS5wID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHc6IHJlcCxcclxuICAgICAgICAgICAgICAgIHJlcDogcmVwLFxyXG4gICAgICAgICAgICAgICAgcDogbnVsbFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sdGhpcyk7XHJcbiAgICAgICAgaWYgKHByZXNlcnZlZFBvaW50cykge1xyXG4gICAgICAgICAgICB6clV0aWwuZWFjaCh0aGlzLmFsbE5vZGVzLCBmdW5jdGlvbihub2RlLGlkeCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5hdHRyKFwicG9zaXRpb25cIiwgcHJlc2VydmVkUG9pbnRzW2lkeF0pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICB6clV0aWwuZWFjaCh0aGlzLmFsbExpbmtzLCBmdW5jdGlvbihsaW5rKSB7XHJcbiAgICAgICAgICAgIGxpbmsubjEgPSBsaW5rLnN0YXJ0Tm9kZSxcclxuICAgICAgICAgICAgbGluay5uMiA9IGxpbmsuZW5kTm9kZSxcclxuICAgICAgICAgICAgbGluay5kID0gdGhpcy5vcHRpb25zLmVkZ2VMZW5ndGg7XHJcbiAgICAgICAgICAgIGxpbmsuY3VydmVuZXNzID0gMDtcclxuICAgICAgICB9LHRoaXMpXHJcblxyXG4gICAgICAgIHZhciBmb3JjZUluc3RhbmNlID0gZm9yY2VIZWxwZXIodGhpcy5hbGxOb2RlcywgdGhpcy5hbGxMaW5rcywge1xyXG4gICAgICAgICAgICByZWN0OiByZWN0LFxyXG4gICAgICAgICAgICBncmF2aXR5OiB0aGlzLm9wdGlvbnMuZ3Jhdml0eVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBvbGRTdGVwID0gZm9yY2VJbnN0YW5jZS5zdGVwO1xyXG4gICAgICAgIGZvcmNlSW5zdGFuY2Uuc3RlcCA9IGZ1bmN0aW9uKGNiKSB7XHJcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuYWxsTm9kZXMsIGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2Rlcy5maXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYzIuY29weShub2Rlcy5wLCBub2Rlcy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICBvbGRTdGVwKGZ1bmN0aW9uKGFsbE5vZGVzLCBhbGxMaW5rcywgc3RvcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhbGxOb2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbE5vZGVzW2ldLmZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbE5vZGVzW2ldLmF0dHIoXCJwb3NpdGlvblwiLCBhbGxOb2Rlc1tpXS5wKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVkUG9pbnRzW2ldID0gYWxsTm9kZXNbaV0ucDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChhbGxMaW5rcywgZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maXNoVG9wby5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoQ29ubmVjdG9yKGNvbm5lY3RvciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIGNiICYmIGNiKHN0b3BwZWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub3B0aW9ucy5mb3JjZUxheW91dCA9IGZvcmNlSW5zdGFuY2U7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zLnByZXNlcnZlZFBvaW50cyA9IHByZXNlcnZlZFBvaW50cztcclxuICAgICAgICAvLyBTdGVwIHRvIGdldCB0aGUgbGF5b3V0XHJcbiAgICAgICAgZm9yY2VJbnN0YW5jZS5zdGVwKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIEZvcmNlTGF5b3V0LnByb3RvdHlwZS5fc3RhcnRGb3JjZUxheW91dEl0ZXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGxheW91dEFuaW1hdGlvbiA9IHRoaXMub3B0aW9ucy5sYXlvdXRBbmltYXRpb247XHJcbiAgICAgICAgKGZ1bmN0aW9uIHN0ZXAoKSB7XHJcbiAgICAgICAgICAgIHNlbGYub3B0aW9ucy5mb3JjZUxheW91dC5zdGVwKGZ1bmN0aW9uIChzdG9wcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9sYXlvdXRpbmcgPSAhc3RvcHBlZDtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9sYXlvdXRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGF5b3V0QW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2xheW91dFRpbWVvdXQgPSBzZXRUaW1lb3V0KHN0ZXAsIDE2KVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICBzZWxmLmZpc2hUb3BvLnRyaWdnZXIoXCJmb3JjZUxheW91dEVuZFwiKTsgIC8v5rS+5Y+R5biD5bGA57uT5p2f5LqL5Lu2XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSkoKTtcclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEZvcmNlTGF5b3V0O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgYWRkQ3VzdG9tTGF5b3V0XHJcbiAqIEBoaWRlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBmb3JjZUxheW91dEVuZFxyXG4gKiDluIPlsYDnu5PmnZ/kuovku7ZcclxuICpcclxuICogPHByZT5cclxuICogZmlzaHRvcG8ub24oJ2ZvcmNlTGF5b3V0RW5kJywgZnVuY3Rpb24oZSkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xheW91dC9Gb3JjZUxheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cclxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcclxuICAgIHZhciBzY2FsZUFuZEFkZCA9IHZlYzIuc2NhbGVBbmRBZGQ7XHJcblxyXG4gICAgLy8gZnVuY3Rpb24gYWRqYWNlbnROb2RlKG4sIGUpIHtcclxuICAgIC8vICAgICByZXR1cm4gZS5uMSA9PT0gbiA/IGUubjIgOiBlLm4xO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5vZGVzLCBlZGdlcywgb3B0cykge1xyXG4gICAgICAgIHZhciByZWN0ID0gb3B0cy5yZWN0O1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBjZW50ZXIgPSBbcmVjdC54ICsgd2lkdGggLyAyLCByZWN0LnkgKyBoZWlnaHQgLyAyXTtcclxuICAgICAgICAvLyB2YXIgc2NhbGUgPSBvcHRzLnNjYWxlIHx8IDE7XHJcbiAgICAgICAgdmFyIGdyYXZpdHkgPSBvcHRzLmdyYXZpdHkgPT0gbnVsbCA/IDAuMSA6IG9wdHMuZ3Jhdml0eTtcclxuXHJcbiAgICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8vICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xyXG4gICAgICAgIC8vICAgICB2YXIgbjEgPSBlLm4xO1xyXG4gICAgICAgIC8vICAgICB2YXIgbjIgPSBlLm4yO1xyXG4gICAgICAgIC8vICAgICBuMS5lZGdlcyA9IG4xLmVkZ2VzIHx8IFtdO1xyXG4gICAgICAgIC8vICAgICBuMi5lZGdlcyA9IG4yLmVkZ2VzIHx8IFtdO1xyXG4gICAgICAgIC8vICAgICBuMS5lZGdlcy5wdXNoKGUpO1xyXG4gICAgICAgIC8vICAgICBuMi5lZGdlcy5wdXNoKGUpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBJbml0IHBvc2l0aW9uXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbiA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIW4ucCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBwb3NpdGlvbiBmcm9tIGZpcnN0IGFkamVjZW50IG5vZGUgd2l0aCBkZWZpbmVkIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyBPciB1c2UgYSByYW5kb20gcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIC8vIEZyb20gZDNcclxuICAgICAgICAgICAgICAgIC8vIGlmIChuLmVkZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgdmFyIGogPSAtMTtcclxuICAgICAgICAgICAgICAgIC8vICAgICB3aGlsZSAoKytqIDwgbi5lZGdlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgdmFyIGUgPSBuLmVkZ2VzW2pdO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB2YXIgb3RoZXIgPSBhZGphY2VudE5vZGUobiwgZSk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGlmIChvdGhlci5wKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBuLnAgPSB2ZWMyLmNsb25lKG90aGVyLnApO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZiAoIW4ucCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4ucCA9IHZlYzIuY3JlYXRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSArIGNlbnRlclswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICsgY2VudGVyWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuLnBwID0gdmVjMi5jbG9uZShuLnApO1xyXG4gICAgICAgICAgICBuLmVkZ2VzID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZvcm11bGEgaW4gJ0dyYXBoIERyYXdpbmcgYnkgRm9yY2UtZGlyZWN0ZWQgUGxhY2VtZW50J1xyXG4gICAgICAgIC8vIHZhciBrID0gc2NhbGUgKiBNYXRoLnNxcnQod2lkdGggKiBoZWlnaHQgLyBub2Rlcy5sZW5ndGgpO1xyXG4gICAgICAgIC8vIHZhciBrMiA9IGsgKiBrO1xyXG5cclxuICAgICAgICB2YXIgZnJpY3Rpb24gPSAwLjY7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHdhcm1VcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZnJpY3Rpb24gPSAwLjU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRGaXhlZDogZnVuY3Rpb24gKGlkeCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZXNbaWR4XS5maXhlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXRVbmZpeGVkOiBmdW5jdGlvbiAoaWR4KSB7XHJcbiAgICAgICAgICAgICAgICBub2Rlc1tpZHhdLmZpeGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzdGVwOiBmdW5jdGlvbiAoY2IpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2MTIgPSBbXTtcclxuICAgICAgICAgICAgICAgIHZhciBuTGVuID0gbm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gZWRnZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4xID0gZS5uMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbjIgPSBlLm4yO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2ZWMyLnN1Yih2MTIsIG4yLnAsIG4xLnApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gdmVjMi5sZW4odjEyKSAtIGUuZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IG4yLncgLyAobjEudyArIG4yLncpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKHYxMiwgdjEyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgIW4xLmZpeGVkICYmIHNjYWxlQW5kQWRkKG4xLnAsIG4xLnAsIHYxMiwgdyAqIGQgKiBmcmljdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgIW4yLmZpeGVkICYmIHNjYWxlQW5kQWRkKG4yLnAsIG4yLnAsIHYxMiwgLSgxIC0gdykgKiBkICogZnJpY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gR3Jhdml0eVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuTGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbi5maXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLnN1Yih2MTIsIGNlbnRlciwgbi5wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGQgPSB2ZWMyLmxlbih2MTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2ZWMyLnNjYWxlKHYxMiwgdjEyLCAxIC8gZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhciBncmF2aXR5RmFjdG9yID0gZ3Jhdml0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5zY2FsZUFuZEFkZChuLnAsIG4ucCwgdjEyLCBncmF2aXR5ICogZnJpY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXB1bHNpdmVcclxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkdcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4xID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbkxlbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuMiA9IG5vZGVzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLnN1Yih2MTIsIG4yLnAsIG4xLnApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHZlYzIubGVuKHYxMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSYW5kb20gcmVwdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5zZXQodjEyLCBNYXRoLnJhbmRvbSgpIC0gMC41LCBNYXRoLnJhbmRvbSgpIC0gMC41KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXBGYWN0ID0gKG4xLnJlcCArIG4yLnJlcCkgLyBkIC8gZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIW4xLmZpeGVkICYmIHNjYWxlQW5kQWRkKG4xLnBwLCBuMS5wcCwgdjEyLCByZXBGYWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIW4yLmZpeGVkICYmIHNjYWxlQW5kQWRkKG4yLnBwLCBuMi5wcCwgdjEyLCAtcmVwRmFjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW4uZml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5zdWIodiwgbi5wLCBuLnBwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5zY2FsZUFuZEFkZChuLnAsIG4ucCwgdiwgZnJpY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNvcHkobi5wcCwgbi5wKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZnJpY3Rpb24gPSBmcmljdGlvbiAqIDAuOTkyO1xyXG5cclxuICAgICAgICAgICAgICAgIGNiICYmIGNiKG5vZGVzLCBlZGdlcywgZnJpY3Rpb24gPCAwLjAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L2ZvcmNlSGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOW3peWFt+exu1xyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93LnV0aWxcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBpbml0SW1hZ2VQb29sXHJcbiAqIOWIneWni+WMluWbvueJh+axoCAg55So5LqO5a+55Zu+54mH5Yqg6L296L+b6KGM566h55CGXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXgg5pyA5aSn6L+e5o6l5pWw44CC5pWw5YC844CCXHJcbiAqIEByZXR1cm5zIHt7bG9hZDogRnVuY3Rpb24sIGluZm86IEZ1bmN0aW9ufX1cclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgdmFyIGltYWdlcG9vbCA9IGZpc2hUb3BvRmxvdy51dGlsLmluaXRJbWFnZVBvb2woMTAwKTtcclxuICAgICAgICBpbWFnZXBvb2wubG9hZChncmF5QXJyYXksIHtcclxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oaW1ncykge1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbmNlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaW5oZXJpdHNcclxuICog5p6E6YCg57G757un5om/5YWz57O7XHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsYXp6IOa6kOexu1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlQ2xhenog5Z+657G7XHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgZW1wdHlGbiA9IGZ1bmN0aW9uKCkge307XHJcbiAgICAvL+WIneWni+m7mOiupOmFjee9rlxyXG4gICAgdmFyIGNvbmZpZ19kZWZhdWx0ID0ge1xyXG4gICAgICAgIC8v57q/56iL5rGgXCLnur/nqItcIuaVsOmHj1xyXG4gICAgICAgIHRocmVhZDogNSxcclxuICAgICAgICAvL+WbvueJh+WKoOi9veWksei0pemHjeivleasoeaVsFxyXG4gICAgICAgIC8v6YeN6K+VMuasoe+8jOWKoOS4iuWOn+acieeahOS4gOasoe+8jOaAu+WFseaYrzPmrKFcclxuICAgICAgICBcInRyaWVzXCI6IDJcclxuICAgIH07XHJcbiAgICAvL+W3peWFt1xyXG4gICAgdmFyIF9oZWxwZXJzID0ge1xyXG4gICAgICAgIC8v6K6+572uZG9t5bGe5oCnXHJcbiAgICAgICAgc2V0QXR0cjogKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgIC8v5Yik5pat5rWP6KeI5Zmo5piv5ZCm5pSv5oyBSFRNTDUgZGF0YXNldFxyXG4gICAgICAgICAgICBpZiAoaW1nLmRhdGFzZXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkb20sIG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tLmRhdGFzZXRbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbSwgbmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiZGF0YS1cIiArIG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpKSxcclxuICAgICAgICAvL+iOt+WPlmRvbeWxnuaAp1xyXG4gICAgICAgIGdldEF0dHI6IChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICAvL+WIpOaWrea1j+iniOWZqOaYr+WQpuaUr+aMgUhUTUw1IGRhdGFzZXRcclxuICAgICAgICAgICAgaWYgKGltZy5kYXRhc2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZG9tLCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIWRvbS5kYXRhc2V0W25hbWVdKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLVwiICsgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb20uZGF0YXNldFtuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbSwgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb20uZ2V0QXR0cmlidXRlKFwiZGF0YS1cIiArIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSlcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOaehOmAoOaWueazlVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSBtYXgg5pyA5aSn6L+e5o6l5pWw44CC5pWw5YC844CCXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEltYWdlUG9vbChtYXgpIHtcclxuICAgICAgICAvL+acgOWkp+W5tuWPkeaVsOmHj1xyXG4gICAgICAgIHRoaXMubWF4ID0gbWF4IHx8IGNvbmZpZ19kZWZhdWx0LnRocmVhZDtcclxuICAgICAgICB0aGlzLmxpbmtIZWFkID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxpbmtOb2RlID0gbnVsbDtcclxuICAgICAgICAvL+WKoOi9veaxoFxyXG4gICAgICAgIC8vW3tpbWc6IGRvbSxmcmVlOiB0cnVlLCBub2RlOiBub2RlfV1cclxuICAgICAgICAvL25vZGVcclxuICAgICAgICAvL3tzcmM6IFwiXCIsIG9wdGlvbnM6IHtzdWNjZXNzOiBcImZuXCIsZXJyb3I6IFwiZm5cIiwgb25jZTogdHJ1ZX0sIHRyaWVzOiAwfVxyXG4gICAgICAgIHRoaXMucG9vbCA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDliJ3lp4vljJZcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuaW5pdFBvb2wgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaSwgaW1nLCBvYmosIF9zO1xyXG4gICAgICAgIF9zID0gdGhpcztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5tYXg7IGkrKykge1xyXG4gICAgICAgICAgICBvYmogPSB7fTtcclxuICAgICAgICAgICAgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgIF9oZWxwZXJzLnNldEF0dHIoaW1nLCBcImlkXCIsIGkpO1xyXG4gICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvL+Wbnuiwg1xyXG4gICAgICAgICAgICAgICAgX3Mubm90aWNlKF9zLmdldE5vZGUodGhpcyksIFwic3VjY2Vzc1wiLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIC8v5aSE55CG5Lu75YqhXHJcbiAgICAgICAgICAgICAgICBfcy5leGVjdXRlTGluayh0aGlzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gX3MuZ2V0Tm9kZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIC8v5Yik5pat5bCd6K+V5qyh5pWwXHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50cmllcyA8IGNvbmZpZ19kZWZhdWx0LnRyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS50cmllcyA9IG5vZGUudHJpZXMrMTtcclxuICAgICAgICAgICAgICAgICAgICAvL+WGjeasoei/veWKoOWIsOS7u+WKoemTvuihqOacq+WwvlxyXG4gICAgICAgICAgICAgICAgICAgIF9zLmFwcGVuZE5vZGUoX3MuY3JlYXRlTm9kZShub2RlLnNyYywgbm9kZS5vcHRpb25zLCBub2RlLm5vdGljZSwgbm9kZS5ncm91cCwgbm9kZS50cmllcykpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2Vycm9y5Zue6LCDXHJcbiAgICAgICAgICAgICAgICAgICAgLy9ub2RlLm9wdGlvbnMuZXJyb3IuY2FsbChudWxsLCB0aGlzLnNyYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Mubm90aWNlKG5vZGUsIFwiZXJyb3JcIiwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL+WkhOeQhuS7u+WKoVxyXG4gICAgICAgICAgICAgICAgX3MuZXhlY3V0ZUxpbmsodGhpcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIG9iai5pbWcgPSBpbWc7XHJcbiAgICAgICAgICAgIG9iai5mcmVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5wb29sLnB1c2gob2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlm57osIPlsIHoo4VcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gbm9kZSDoioLngrnjgILlr7nosaHjgIJcclxuICAgICAqIEBwYXJhbSBzdGF0dXMg54q25oCB44CC5a2X56ym5Liy44CC5Y+v6YCJ5YC877yac3VjY2VzcyjmiJDlip8pfGVycm9yKOWksei0pSlcclxuICAgICAqIEBwYXJhbSBpbWcg5Zu+54mH44CCXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUubm90aWNlID0gZnVuY3Rpb24obm9kZSwgc3RhdHVzLCBpbWcpIHtcclxuICAgICAgICBub2RlLm5vdGljZShzdGF0dXMsIGltZyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlpITnkIbpk77ooajku7vliqFcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gZG9tIOWbvuWDj2RvbeWvueixoeOAguWvueixoeOAglxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLmV4ZWN1dGVMaW5rID0gZnVuY3Rpb24oZG9tKSB7XHJcbiAgICAgICAgLy/liKTmlq3pk77ooajmmK/lkKblrZjlnKjoioLngrlcclxuICAgICAgICBpZiAodGhpcy5saW5rSGVhZCkge1xyXG4gICAgICAgICAgICAvL+WKoOi9veS4i+S4gOS4quWbvueJh1xyXG4gICAgICAgICAgICB0aGlzLnNldFNyYyhkb20sIHRoaXMubGlua0hlYWQpO1xyXG4gICAgICAgICAgICAvL+WOu+mZpOmTvuihqOWktFxyXG4gICAgICAgICAgICB0aGlzLnNoaWZ0Tm9kZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8v6K6+572u6Ieq6Lqr54q25oCB5Li656m66ZeyXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzKGRvbSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W56m66ZeyXCLnur/nqItcIlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5nZXRGcmVlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCwgaTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB0aGlzLnBvb2wubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucG9vbFtpXS5mcmVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb29sW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5bCB6KOFc3Jj5bGe5oCn6K6+572uXHJcbiAgICAgKiDlm6DkuLrmlLnlj5hzcmPlsZ7mgKfnm7jlvZPkuo7liqDovb3lm77niYfvvIzmiYDku6Xmiormk43kvZzlsIHoo4XotbfmnaVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gZG9tIOWbvuWDj2RvbeWvueixoeOAguWvueixoeOAglxyXG4gICAgICogQHBhcmFtIG5vZGUg6IqC54K544CC5a+56LGh44CCXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuc2V0U3JjID0gZnVuY3Rpb24oZG9tLCBub2RlKSB7XHJcbiAgICAgICAgLy/orr7nva7msaDkuK3nmoRcIue6v+eoi1wi5Li66Z2e56m66Zey54q25oCBXHJcbiAgICAgICAgdGhpcy5zdGF0dXMoZG9tLCBmYWxzZSk7XHJcbiAgICAgICAgLy/lhbPogZToioLngrlcclxuICAgICAgICB0aGlzLnNldE5vZGUoZG9tLCBub2RlKTtcclxuICAgICAgICAvL+WKoOi9veWbvueJh1xyXG4gICAgICAgIGRvbS5zcmMgPSBub2RlLnNyYztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOabtOaWsOaxoOS4reeahFwi57q/56iLXCLnirbmgIFcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gZG9tIOWbvuWDj2RvbeWvueixoeOAguWvueixoeOAglxyXG4gICAgICogQHBhcmFtIHN0YXR1cyDnirbmgIHjgILluIPlsJTjgILlj6/pgInlgLzvvJp0cnVlKOepuumXsil8ZmFsc2Uo6Z2e56m66ZeyKVxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLnN0YXR1cyA9IGZ1bmN0aW9uKGRvbSwgc3RhdHVzKSB7XHJcbiAgICAgICAgdmFyIGlkID0gX2hlbHBlcnMuZ2V0QXR0cihkb20sIFwiaWRcIik7XHJcbiAgICAgICAgaWYoaWQpe1xyXG4gICAgICAgICAgICB0aGlzLnBvb2xbaWRdLmZyZWUgPSBzdGF0dXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL+epuumXsueKtuaAge+8jOa4hemZpOWFs+iBlOeahOiKgueCuVxyXG4gICAgICAgIGlmIChzdGF0dXMpIHtcclxuICAgICAgICAgICAgdGhpcy5wb29sW2lkXS5ub2RlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmm7TmlrDmsaDkuK3nmoRcIue6v+eoi1wi55qE5YWz6IGU6IqC54K5XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIGRvbSDlm77lg49kb23lr7nosaHjgILlr7nosaHjgIJcclxuICAgICAqIEBwYXJhbSBub2RlIOiKgueCueOAguWvueixoeOAglxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLnNldE5vZGUgPSBmdW5jdGlvbihkb20sIG5vZGUpIHtcclxuICAgICAgICB2YXIgaWQgPSBfaGVscGVycy5nZXRBdHRyKGRvbSwgXCJpZFwiKTtcclxuICAgICAgICBpZihpZCl7XHJcbiAgICAgICAgICAgIHRoaXMucG9vbFtpZF0ubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvb2xbaWRdLm5vZGUgPT09IG5vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluaxoOS4reeahFwi57q/56iLXCLnmoTlhbPogZToioLngrlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gZG9tIOWbvuWDj2RvbeWvueixoeOAguWvueixoeOAglxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLmdldE5vZGUgPSBmdW5jdGlvbihkb20pIHtcclxuICAgICAgICB2YXIgaWQgPSBfaGVscGVycy5nZXRBdHRyKGRvbSwgXCJpZFwiKTtcclxuICAgICAgICBpZihpZCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvb2xbaWRdLm5vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWvueWkluaOpeWPo++8jOWKoOi9veWbvueJh1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSBzcmMg5Y+v5Lul5pivc3Jj5a2X56ym5Liy77yM5Lmf5Y+v5Lul5pivc3Jj5a2X56ym5Liy5pWw57uE44CCXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyDnlKjmiLfoh6rlrprkuYnlj4LmlbDjgILljIXlkKvvvJpzdWNjZXNz5Zue6LCD44CBZXJyb3Llm57osIPjgIFvbmNl5qCH6K+G44CCXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuX2xvYWQgPSBmdW5jdGlvbihzcmMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgc3JjcyA9IFtdLFxyXG4gICAgICAgICAgICBmcmVlID0gbnVsbCxcclxuICAgICAgICAgICAgbGVuZ3RoID0gMCxcclxuICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgIC8v5Y+q5Yid5aeL5YyW5LiA5qyh5Zue6LCD562W55WlXHJcbiAgICAgICAgICAgIG5vdGljZSA9IChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdHVzLCBpbWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSB0aGlzLmdyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy/orrDlvZVcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ1tzdGF0dXNdLnB1c2goaW1nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy/liKTmlq3mlLnnu4TmmK/lkKblhajpg6jlpITnkIblrozmiJBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGcuc3VjY2Vzcy5sZW5ndGggKyBnLmVycm9yLmxlbmd0aCA9PT0gZy5jb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy/lvILmraVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v5a6e6ZmF5LiK5piv5L2c5Li65Y+m5LiA5Liq5Lu75Yqh5Y2V54us5omn6KGM77yM6Ziy5q2i5Zue6LCD5Ye95pWw5omn6KGM5pe26Ze06L+H6ZW/5b2x5ZON5Zu+54mH5Yqg6L296YCf5bqmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uc3VjY2Vzcy5jYWxsKG51bGwsIGcuc3VjY2VzcywgZy5lcnJvciwgZy5jb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0dXMsIGltZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy/nm7TmjqXlm57osINcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9bc3RhdHVzXS5jYWxsKG51bGwsIGltZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0oKSksXHJcbiAgICAgICAgICAgIGdyb3VwID0ge1xyXG4gICAgICAgICAgICAgICAgY291bnQ6IDAsXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBbXSxcclxuICAgICAgICAgICAgICAgIGVycm9yOiBbXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBub2RlID0gbnVsbDtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3MgfHwgZW1wdHlGbjtcclxuICAgICAgICBvcHRpb25zLmVycm9yID0gb3B0aW9ucy5lcnJvciB8fCBlbXB0eUZuO1xyXG4gICAgICAgIHNyY3MgPSBzcmNzLmNvbmNhdChzcmMpO1xyXG4gICAgICAgIC8v6K6+572u57uE5YWD57Sg5Liq5pWwXHJcbiAgICAgICAgZ3JvdXAuY291bnQgPSBzcmNzLmxlbmd0aDtcclxuICAgICAgICAvL+mBjeWOhumcgOimgeWKoOi9veeahOWbvueJh1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNyY3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy/liJvlu7roioLngrlcclxuICAgICAgICAgICAgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZShzcmNzW2ldLCBvcHRpb25zLCBub3RpY2UsIGdyb3VwKTtcclxuICAgICAgICAgICAgLy/liKTmlq3nur/nqIvmsaDmmK/lkKbmnInnqbrpl7JcclxuICAgICAgICAgICAgZnJlZSA9IHRoaXMuZ2V0RnJlZSgpO1xyXG4gICAgICAgICAgICBpZiAoZnJlZSkge1xyXG4gICAgICAgICAgICAgICAgLy/mnInnqbrpl7LvvIzliJnnq4vljbPliqDovb3lm77niYdcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3JjKGZyZWUuaW1nLCBub2RlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8v5rKh5pyJ56m66Zey77yM5bCG5Lu75Yqh5re75Yqg5Yiw6ZO+6KGoXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZE5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5blhoXpg6jnirbmgIHkv6Hmga9cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLl9pbmZvID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGluZm8gPSB7fSxcclxuICAgICAgICAgICAgbGVuZ3RoID0gMCxcclxuICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgIG5vZGUgPSBudWxsO1xyXG4gICAgICAgIC8v57q/56iLXHJcbiAgICAgICAgaW5mby50aHJlYWQgPSB7fTtcclxuICAgICAgICAvL+e6v+eoi+aAu+aVsOmHj1xyXG4gICAgICAgIGluZm8udGhyZWFkLmNvdW50ID0gdGhpcy5wb29sLmxlbmd0aDtcclxuICAgICAgICAvL+epuumXsue6v+eoi+aVsOmHj1xyXG4gICAgICAgIGluZm8udGhyZWFkLmZyZWUgPSAwO1xyXG4gICAgICAgIC8v5Lu75YqhXHJcbiAgICAgICAgaW5mby50YXNrID0ge307XHJcbiAgICAgICAgLy/lvoXlpITnkIbku7vliqHmlbDph49cclxuICAgICAgICBpbmZvLnRhc2suY291bnQgPSAwO1xyXG4gICAgICAgIC8v6I635Y+W56m66ZeyXCLnur/nqItcIuaVsOmHj1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHRoaXMucG9vbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb29sW2ldLmZyZWUpIHtcclxuICAgICAgICAgICAgICAgIGluZm8udGhyZWFkLmZyZWUgPSBpbmZvLnRocmVhZC5mcmVlICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL+iOt+WPluS7u+WKoeaVsOmHjyjku7vliqHpk77plb/luqYpXHJcbiAgICAgICAgbm9kZSA9IHRoaXMubGlua0hlYWQ7XHJcbiAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgaW5mby50YXNrLmNvdW50ID0gaW5mby50YXNrLmNvdW50ICsgMTtcclxuICAgICAgICAgICAgd2hpbGUgKG5vZGUubmV4dCkge1xyXG4gICAgICAgICAgICAgICAgaW5mby50YXNrLmNvdW50ID0gaW5mby50YXNrLmNvdW50ICsgMTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluZm87XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66IqC54K5XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHNyYyDlm77niYfot6/lvoTjgILlrZfnrKbkuLLjgIJcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIOeUqOaIt+iHquWumuS5ieWPguaVsOOAguWMheWQq++8mnN1Y2Nlc3Plm57osIPjgIFlcnJvcuWbnuiwg+OAgW9uY2XmoIfor4bjgIJcclxuICAgICAqIEBwYXJhbSBub3RpY2Ug5Zue6LCD562W55Wl44CCIOWHveaVsOOAglxyXG4gICAgICogQHBhcmFtIGdyb3VwIOe7hOS/oeaBr+OAguWvueixoeOAgntjb3VudDogMCwgc3VjY2VzczogW10sIGVycm9yOiBbXX1cclxuICAgICAqIEBwYXJhbSB0ciDlh7rplJnph43or5XmrKHmlbDjgILmlbDlgLzjgILpu5jorqTkuLow44CCXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbihzcmMsIG9wdGlvbnMsIG5vdGljZSwgZ3JvdXAsIHRyKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB7fTtcclxuICAgICAgICBub2RlLnNyYyA9IHNyYztcclxuICAgICAgICBub2RlLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIG5vZGUubm90aWNlID0gbm90aWNlO1xyXG4gICAgICAgIG5vZGUuZ3JvdXAgPSBncm91cDtcclxuICAgICAgICBub2RlLnRyaWVzID0gdHIgfHwgMDtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWQkeS7u+WKoemTvuihqOacq+Wwvui/veWKoOiKgueCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSBub2RlIOiKgueCueOAguWvueixoeOAglxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLmFwcGVuZE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgLy/liKTmlq3pk77ooajmmK/lkKbkuLrnqbpcclxuICAgICAgICBpZiAoIXRoaXMubGlua0hlYWQpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5rSGVhZCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMubGlua05vZGUgPSBub2RlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlua05vZGUubmV4dCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMubGlua05vZGUgPSBub2RlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWIoOmZpOmTvuihqOWktFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5zaGlmdE5vZGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvL+WIpOaWremTvuihqOaYr+WQpuWtmOWcqOiKgueCuVxyXG4gICAgICAgIGlmICh0aGlzLmxpbmtIZWFkKSB7XHJcbiAgICAgICAgICAgIC8v5L+u5pS56ZO+6KGo5aS0XHJcbiAgICAgICAgICAgIHRoaXMubGlua0hlYWQgPSB0aGlzLmxpbmtIZWFkLm5leHQgfHwgbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDliJ3lp4vljJblm77niYfmsaBcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXgg5pyA5aSn6L+e5o6l5pWw44CC5pWw5YC844CCXHJcbiAgICAgKiBAcmV0dXJucyB7e2xvYWQ6IEZ1bmN0aW9uLCBpbmZvOiBGdW5jdGlvbn19XHJcbiAgICAgKi9cclxuICAgIHZhciBpbml0SW1hZ2VQb29sID0gZnVuY3Rpb24obWF4KSB7XHJcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IEltYWdlUG9vbChtYXgpO1xyXG4gICAgICAgIGluc3RhbmNlLmluaXRQb29sKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIOWKoOi9veWbvueJh1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gc3JjIOWPr+S7peaYr3NyY+Wtl+espuS4su+8jOS5n+WPr+S7peaYr3NyY+Wtl+espuS4suaVsOe7hOOAglxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyDnlKjmiLfoh6rlrprkuYnlj4LmlbDjgILljIXlkKvvvJpzdWNjZXNz5Zue6LCD44CBZXJyb3Llm57osIPjgIFvbmNl5qCH6K+G44CCXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnN1Y2Nlc3NdIHN1Y2Nlc3Plm57osINcclxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZXJyb3JdIGVycm9y5Zue6LCDXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMub25jZV0g5piv5ZCm5YWo6YOo5Yqg6L295a6M5q+V5ZCO77yM5LiA5qyh5Zue6LCDXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBsb2FkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLl9sb2FkLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICog6I635Y+W5YaF6YOo54q25oCB5L+h5oGvXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpbmZvOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5faW5mby5jYWxsKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0geyBpbml0SW1hZ2VQb29sOiBpbml0SW1hZ2VQb29sIH1cclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9JbWFnZVBvb2wuanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuICAgIHZhciBUb29sdGlwQ29udGVudCA9IHJlcXVpcmUoJy4vVG9vbHRpcENvbnRlbnQnKTtcclxuICAgIHZhciBnbG9iYWxMaXN0ZW5lciA9IHJlcXVpcmUoJy4vZ2xvYmFsTGlzdGVuZXInKTtcclxuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9tb2RlbCcpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XHJcbiAgICB2YXIgZmxvd1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL0Zsb3dVdGlsJyk7XHJcbiAgICB2YXIgbGF5b3V0ID0gcmVxdWlyZShcIi4uL2xheW91dC9sYXlvdXRcIik7XHJcbiAgICBmdW5jdGlvbiBUb29sdGlwVmlldyh0b29sdGlwTW9kZWwsIGFwaSkge1xyXG4gICAgICAgIHRoaXMuX3Rvb2x0aXBDb250ZW50ID0gbmV3IFRvb2x0aXBDb250ZW50KGFwaS5nZXREb20oKSxhcGkpO1xyXG4gICAgICAgIHRoaXMuX2FwaSA9IGFwaTtcclxuICAgICAgICB0aGlzLl90b29sdGlwTW9kZWwgPSB0b29sdGlwTW9kZWw7XHJcbiAgICAgICAgdGhpcy5fYWx3YXlzU2hvd0NvbnRlbnQgPSB0b29sdGlwTW9kZWwuZ2V0KCdhbHdheXNTaG93Q29udGVudCcpO1xyXG4gICAgICAgIHRoaXMuX2luaXRHbG9hYmxMaXN0ZW5lcigpO1xyXG4gICAgfVxyXG5cclxuICAgIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5faW5pdEdsb2FibExpc3RlbmVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRyaWdnZXJPbiA9IHRoaXMuX3Rvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXJPbicpO1xyXG4gICAgICAgIC8vIOW9k+aciSAnY2xpY2snIHwgJ21vdXNlbW92ZScgfCAnbm9uZScg5LqL5Lu25pe26Kem5Y+R5Zue6LCDXHJcbiAgICAgICAgZ2xvYmFsTGlzdGVuZXIucmVnaXN0ZXIoXHJcbiAgICAgICAgICAgICdpdGVtVG9vbHRpcCcsXHJcbiAgICAgICAgICAgIHRoaXMuX2FwaSxcclxuICAgICAgICAgICAgZnVuY3Rpb24oY3VyclRyaWdnZXIsIGUsIGRpc3BhdGNoQWN0aW9uKXtcclxuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyT24gIT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyT24uaW5kZXhPZihjdXJyVHJpZ2dlcikgPj0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJ5U2hvdyhlLCBkaXNwYXRjaEFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJUcmlnZ2VyID09PSAnbGVhdmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGUoZGlzcGF0Y2hBY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LmJpbmQodGhpcylcclxuICAgICAgICApXHJcbiAgICB9O1xyXG5cclxuICAgIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5fdHJ5U2hvdyA9IGZ1bmN0aW9uKGUsIGRpc3BhdGNoQWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xyXG4gICAgICAgICAgICB2YXIgdG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0b29sdGlwTW9kZWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2F2ZSBtb3VzZSB4LCBtb3VzZSB5LiBTbyB3ZSBjYW4gdHJ5IHRvIGtlZXAgc2hvd2luZyB0aGUgdGlwIGlmIGNoYXJ0IGlzIHJlZnJlc2hlZFxyXG4gICAgICAgICAgICB0aGlzLl9sYXN0WCA9IGUub2Zmc2V0WDtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdFkgPSBlLm9mZnNldFk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZWwgJiYgZWwudG9vbHRpcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd0NvbXBvbmVudEl0ZW1Ub29sdGlwKGUsIGVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hpZGUoZGlzcGF0Y2hBY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgICBUb29sdGlwVmlldy5wcm90b3R5cGUuX2hpZGUgPSBmdW5jdGlvbihkaXNwYXRjaEFjdGlvbikge1xyXG4gICAgICAgICAgICAvLyBEbyBub3QgZGlyZWN0bHkgaGlkZUxhdGVyIGhlcmUsIGJlY2F1c2UgdGhpcyBiZWhhdmlvciBtYXkgYmUgcHJldmVudGVkXHJcbiAgICAgICAgICAgIC8vIGluIGRpc3BhdGNoQWN0aW9uIHdoZW4gc2hvd1RpcCBpcyBkaXNwYXRjaGVkLlxyXG5cclxuICAgICAgICAgICAgLy8gRklYTUVcclxuICAgICAgICAgICAgLy8gZHVwbGljYXRlZCBoaWRlVGlwIGlmIG1hbnVhbGx5SGlkZVRpcCBpcyBjYWxsZWQgZnJvbSBkaXNwYXRjaEFjdGlvbi5cclxuICAgICAgICAgICAgdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzID0gbnVsbDtcclxuICAgICAgICAgICAgZGlzcGF0Y2hBY3Rpb24oe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2hpZGVUaXAnLFxyXG4gICAgICAgICAgICAgICAgZnJvbTogdGhpcy51aWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMubWFudWFsbHlIaWRlVGlwKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICBUb29sdGlwVmlldy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGVudi5ub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcENvbnRlbnQuaGlkZSgpO1xyXG4gICAgICAgICAgICBnbG9iYWxMaXN0ZW5lci51bnJlZ2lzdGVyKCdpdGVtVG9vbHRpcCcsIHRoaXMuX2FwaSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgVG9vbHRpcFZpZXcucHJvdG90eXBlLm1hbnVhbGx5SGlkZVRpcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRvb2x0aXBDb250ZW50ID0gdGhpcy5fdG9vbHRpcENvbnRlbnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Fsd2F5c1Nob3dDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwQ29udGVudC5oaWRlTGF0ZXIodGhpcy5fdG9vbHRpcE1vZGVsLmdldCgnaGlkZURlbGF5JykpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9sYXN0WCA9IHRoaXMuX2xhc3RZID0gbnVsbDtcclxuXHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl9zaG93Q29tcG9uZW50SXRlbVRvb2x0aXAgPSBmdW5jdGlvbiAoZSwgZWwpIHtcclxuICAgICAgICAgICAgdmFyIHRvb2x0aXBPcHQgPSBlbC50b29sdGlwO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvb2x0aXBPcHQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IHRvb2x0aXBPcHQ7XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwT3B0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZWQgZm9ybWF0dGVyXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBjb250ZW50XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzdWJUb29sdGlwTW9kZWwgPSBuZXcgTW9kZWwodG9vbHRpcE9wdCwgdGhpcy5fdG9vbHRpcE1vZGVsKTtcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRIdG1sID0gc3ViVG9vbHRpcE1vZGVsLmdldCgnY29udGVudCcpO1xyXG4gICAgICAgICAgICB2YXIgYXN5bmNUaWNrZXQgPSBNYXRoLnJhbmRvbSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gRG8gbm90IGNoZWNrIHdoZXRoZXIgYHRyaWdnZXJgIGlzICdub25lJyBoZXJlLCBiZWNhdXNlIGB0cmlnZ2VyYFxyXG4gICAgICAgICAgICAvLyBvbmx5IHdvcmtzIG9uIGNvb3JpZGluYXRlIHN5c3RlbS4gSW4gZmFjdCwgd2UgaGF2ZSBub3QgZm91bmQgY2FzZVxyXG4gICAgICAgICAgICAvLyB0aGF0IHJlcXVpcmVzIHNldHRpbmcgYHRyaWdnZXJgIG5vdGhpbmcgb24gY29tcG9uZW50IHlldC5cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3Nob3dPck1vdmUoc3ViVG9vbHRpcE1vZGVsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG93VG9vbHRpcENvbnRlbnQoXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViVG9vbHRpcE1vZGVsLCBkZWZhdWx0SHRtbCwgc3ViVG9vbHRpcE1vZGVsLmdldCgnZm9ybWF0dGVyUGFyYW1zJykgfHwge30sXHJcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNUaWNrZXQsIGUub2Zmc2V0WCwgZS5vZmZzZXRZLCBlLnBvc2l0aW9uLCBlbFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl9zaG93T3JNb3ZlID0gZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgY2IpIHtcclxuICAgICAgICAgICAgLy8gc2hvd0RlbGF5IGlzIHVzZWQgaW4gdGhpcyBjYXNlOiB0b29sdGlwLmVudGVyYWJsZSBpcyBzZXRcclxuICAgICAgICAgICAgLy8gYXMgdHJ1ZS4gVXNlciBpbnRlbnQgdG8gbW92ZSBtb3VzZSBpbnRvIHRvb2x0aXAgYW5kIGNsaWNrXHJcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZy4gYHNob3dEZWxheWAgbWFrZXMgaXQgZWFzeWVyIHRvIGVudGVyIHRoZSBjb250ZW50XHJcbiAgICAgICAgICAgIC8vIGJ1dCB0b29sdGlwIGRvIG5vdCBtb3ZlIGltbWVkaWF0ZWx5LlxyXG4gICAgICAgICAgICB2YXIgZGVsYXkgPSB0b29sdGlwTW9kZWwuZ2V0KCdzaG93RGVsYXknKTtcclxuICAgICAgICAgICAgY2IgPSB6clV0aWwuYmluZChjYiwgdGhpcyk7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zaG93VGltb3V0KTtcclxuICAgICAgICAgICAgZGVsYXkgPiAwXHJcbiAgICAgICAgICAgICAgICA/ICh0aGlzLl9zaG93VGltb3V0ID0gc2V0VGltZW91dChjYiwgZGVsYXkpKVxyXG4gICAgICAgICAgICAgICAgOiBjYigpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5fc2hvd1Rvb2x0aXBDb250ZW50ID0gZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZGVmYXVsdEh0bWwsIHBhcmFtcywgYXN5bmNUaWNrZXQsIHgsIHksIHBvc2l0aW9uRXhwciwgZWwpIHtcclxuICAgICAgICAgICAgLy8gUmVzZXQgdGlja2V0XHJcbiAgICAgICAgICAgIHRoaXMuX3RpY2tldCA9ICcnO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0b29sdGlwTW9kZWwuZ2V0KCdzaG93Q29udGVudCcpIHx8ICF0b29sdGlwTW9kZWwuZ2V0KCdzaG93JykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHRvb2x0aXBDb250ZW50ID0gdGhpcy5fdG9vbHRpcENvbnRlbnQ7XHJcblxyXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gdG9vbHRpcE1vZGVsLmdldCgnZm9ybWF0dGVyJyk7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRXhwciA9IHBvc2l0aW9uRXhwciB8fCB0b29sdGlwTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xyXG4gICAgICAgICAgICB2YXIgaHRtbCA9IGRlZmF1bHRIdG1sO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZvcm1hdHRlciAmJiB0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgaHRtbCA9IGZsb3dVdGlsLmZvcm1hdFRwbChmb3JtYXR0ZXIsIHBhcmFtcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKGNiVGlja2V0LCBodG1sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNiVGlja2V0ID09PSB0aGlzLl90aWNrZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcENvbnRlbnQuc2V0Q29udGVudChodG1sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwTW9kZWwsIHBvc2l0aW9uRXhwciwgeCwgeSwgdG9vbHRpcENvbnRlbnQsIHBhcmFtcywgZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aWNrZXQgPSBhc3luY1RpY2tldDtcclxuICAgICAgICAgICAgICAgIGh0bWwgPSBmb3JtYXR0ZXIocGFyYW1zLCBhc3luY1RpY2tldCwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0b29sdGlwQ29udGVudC5zZXRDb250ZW50KGh0bWwpO1xyXG4gICAgICAgICAgICB0b29sdGlwQ29udGVudC5zaG93KHRvb2x0aXBNb2RlbCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbihcclxuICAgICAgICAgICAgICAgIHRvb2x0aXBNb2RlbCwgcG9zaXRpb25FeHByLCB4LCB5LCB0b29sdGlwQ29udGVudCwgcGFyYW1zLCBlbFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ3xGdW5jdGlvbnxBcnJheS48bnVtYmVyPn0gcG9zaXRpb25FeHByXHJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4IE1vdXNlIHhcclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgTW91c2UgeVxyXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGNvbmZpbmUgV2hldGhlciBjb25maW5lIHRvb2x0aXAgY29udGVudCBpbiB2aWV3IHJlY3QuXHJcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fDxBcnJheS48T2JqZWN0Pn0gcGFyYW1zXHJcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcclxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxyXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5fdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBwb3NpdGlvbkV4cHIsIHgsIHksIGNvbnRlbnQsIHBhcmFtcywgZWwpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXdXaWR0aCA9IHRoaXMuX2FwaS5nZXRXaWR0aCgpO1xyXG4gICAgICAgICAgICB2YXIgdmlld0hlaWdodCA9IHRoaXMuX2FwaS5nZXRIZWlnaHQoKTtcclxuICAgICAgICAgICAgcG9zaXRpb25FeHByID0gcG9zaXRpb25FeHByIHx8IHRvb2x0aXBNb2RlbC5nZXQoJ3Bvc2l0aW9uJyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29udGVudFNpemUgPSBjb250ZW50LmdldFNpemUoKTtcclxuICAgICAgICAgICAgdmFyIGFsaWduID0gdG9vbHRpcE1vZGVsLmdldCgnYWxpZ24nKTtcclxuICAgICAgICAgICAgdmFyIHZBbGlnbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3ZlcnRpY2FsQWxpZ24nKTtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSBlbCAmJiBlbC5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xyXG4gICAgICAgICAgICBlbCAmJiByZWN0LmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvc2l0aW9uRXhwciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FsbGJhY2sgb2YgcG9zaXRpb24gY2FuIGJlIGFuIGFycmF5IG9yIGEgc3RyaW5nIHNwZWNpZnkgdGhlIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIgPSBwb3NpdGlvbkV4cHIoW3gsIHldLCBwYXJhbXMsIGNvbnRlbnQuZWwsIHJlY3QsIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3U2l6ZTogW3ZpZXdXaWR0aCwgdmlld0hlaWdodF0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFNpemU6IGNvbnRlbnRTaXplLnNsaWNlKClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXkocG9zaXRpb25FeHByKSkge1xyXG4gICAgICAgICAgICAgICAgeCA9IGZsb3dVdGlsLnBhcnNlUGVyY2VudChwb3NpdGlvbkV4cHJbMF0sIHZpZXdXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICB5ID0gZmxvd1V0aWwucGFyc2VQZXJjZW50KHBvc2l0aW9uRXhwclsxXSwgdmlld0hlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoenJVdGlsLmlzT2JqZWN0KHBvc2l0aW9uRXhwcikpIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uRXhwci53aWR0aCA9IGNvbnRlbnRTaXplWzBdO1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25FeHByLmhlaWdodCA9IGNvbnRlbnRTaXplWzFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxheW91dFJlY3QgPSBsYXlvdXQuZ2V0TGF5b3V0UmVjdChcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIsIHt3aWR0aDogdmlld1dpZHRoLCBoZWlnaHQ6IHZpZXdIZWlnaHR9XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgeCA9IGxheW91dFJlY3QueDtcclxuICAgICAgICAgICAgICAgIHkgPSBsYXlvdXRSZWN0Lnk7XHJcbiAgICAgICAgICAgICAgICBhbGlnbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHBvc2l0aW9uRXhwciBpcyBsZWZ0L3RvcC9yaWdodC9ib3R0b20sXHJcbiAgICAgICAgICAgICAgICAvLyBhbGlnbiBhbmQgdmVydGljYWxBbGlnbiB3aWxsIG5vdCB3b3JrLlxyXG4gICAgICAgICAgICAgICAgdkFsaWduID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTcGVjaWZ5IHRvb2x0aXAgcG9zaXRpb24gYnkgc3RyaW5nICd0b3AnICdib3R0b20nICdsZWZ0JyAncmlnaHQnIGFyb3VuZCBncmFwaGljIGVsZW1lbnRcclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBvc2l0aW9uRXhwciA9PT0gJ3N0cmluZycgJiYgZWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBjYWxjVG9vbHRpcFBvc2l0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uRXhwciwgcmVjdCwgY29udGVudFNpemVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB4ID0gcG9zWzBdO1xyXG4gICAgICAgICAgICAgICAgeSA9IHBvc1sxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3MxID0gcmVmaXhUb29sdGlwUG9zaXRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgeCwgeSwgY29udGVudC5lbCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0LCBhbGlnbiA/IDAgOiAyMCwgdkFsaWduID8gMCA6IDIwXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgeCA9IHBvczFbMF07XHJcbiAgICAgICAgICAgICAgICB5ID0gcG9zMVsxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYWxpZ24gJiYgKHggLT0gaXNDZW50ZXJBbGlnbihhbGlnbikgPyBjb250ZW50U2l6ZVswXSAvIDIgOiBhbGlnbiA9PT0gJ3JpZ2h0JyA/IGNvbnRlbnRTaXplWzBdIDogMCk7XHJcbiAgICAgICAgICAgIHZBbGlnbiAmJiAoeSAtPSBpc0NlbnRlckFsaWduKHZBbGlnbikgPyBjb250ZW50U2l6ZVsxXSAvIDIgOiB2QWxpZ24gPT09ICdib3R0b20nID8gY29udGVudFNpemVbMV0gOiAwKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0b29sdGlwTW9kZWwuZ2V0KCdjb25maW5lJykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3MyID0gY29uZmluZVRvb2x0aXBQb3NpdGlvbihcclxuICAgICAgICAgICAgICAgICAgICB4LCB5LCBjb250ZW50LmVsLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHRcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB4ID0gcG9zMlswXTtcclxuICAgICAgICAgICAgICAgIHkgPSBwb3MyWzFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb250ZW50Lm1vdmVUbyh4LCB5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2FsY1Rvb2x0aXBQb3NpdGlvbihwb3NpdGlvbiwgcmVjdCwgY29udGVudFNpemUpIHtcclxuICAgICAgICB2YXIgZG9tV2lkdGggPSBjb250ZW50U2l6ZVswXTtcclxuICAgICAgICB2YXIgZG9tSGVpZ2h0ID0gY29udGVudFNpemVbMV07XHJcbiAgICAgICAgdmFyIGdhcCA9IDU7XHJcbiAgICAgICAgdmFyIHggPSAwO1xyXG4gICAgICAgIHZhciB5ID0gMDtcclxuICAgICAgICB2YXIgcmVjdFdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICB2YXIgcmVjdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcclxuICAgICAgICAgICAgY2FzZSAnaW5zaWRlJzpcclxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyByZWN0V2lkdGggLyAyIC0gZG9tV2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgLyAyIC0gZG9tSGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCAvIDIgLSBkb21XaWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55IC0gZG9tSGVpZ2h0IC0gZ2FwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0ICsgZ2FwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCAtIGRvbVdpZHRoIC0gZ2FwO1xyXG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgLyAyIC0gZG9tSGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoICsgZ2FwO1xyXG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgLyAyIC0gZG9tSGVpZ2h0IC8gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlZml4VG9vbHRpcFBvc2l0aW9uKHgsIHksIGVsLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQsIGdhcEgsIGdhcFYpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBlbC5jbGllbnRXaWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAoeCArIHdpZHRoICsgZ2FwSCA+IHZpZXdXaWR0aCkge1xyXG4gICAgICAgICAgICB4IC09IHdpZHRoICsgZ2FwSDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHggKz0gZ2FwSDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHkgKyBoZWlnaHQgKyBnYXBWID4gdmlld0hlaWdodCkge1xyXG4gICAgICAgICAgICB5IC09IGhlaWdodCArIGdhcFY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB5ICs9IGdhcFY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNDZW50ZXJBbGlnbihhbGlnbikge1xyXG4gICAgICAgIHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcicgfHwgYWxpZ24gPT09ICdtaWRkbGUnO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbmZpbmVUb29sdGlwUG9zaXRpb24oeCwgeSwgZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodCkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IGVsLmNsaWVudFdpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XHJcblxyXG4gICAgICAgIHggPSBNYXRoLm1pbih4ICsgd2lkdGgsIHZpZXdXaWR0aCkgLSB3aWR0aDtcclxuICAgICAgICB5ID0gTWF0aC5taW4oeSArIGhlaWdodCwgdmlld0hlaWdodCkgLSBoZWlnaHQ7XHJcbiAgICAgICAgeCA9IE1hdGgubWF4KHgsIDApO1xyXG4gICAgICAgIHkgPSBNYXRoLm1heCh5LCAwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcclxuICAgIH1cclxuICAgIG1vZHVsZS5leHBvcnRzID0gVG9vbHRpcFZpZXc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi90b29sdGlwL1Rvb2x0aXBWaWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgenJDb2xvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvY29sb3InKTtcclxuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xyXG4gICAgdmFyIGV2ZW50VXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQnKTtcclxuICAgIHZhciBmbG93VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvRmxvd1V0aWwnKTtcclxuICAgIHZhciB0b0NhbWVsQ2FzZSA9IGZsb3dVdGlsLnRvQ2FtZWxDYXNlO1xyXG4gICAgdmFyIG5vcm1hbGl6ZUNzc0FycmF5ID0gZmxvd1V0aWwubm9ybWFsaXplQ3NzQXJyYXk7XHJcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xyXG5cclxuXHJcbiAgICB2YXIgdmVuZG9ycyA9IFsnJywgJy13ZWJraXQtJywgJy1tb3otJywgJy1vLSddO1xyXG5cclxuICAgIHZhciBnQ3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO2JvcmRlci1zdHlsZTpzb2xpZDt3aGl0ZS1zcGFjZTpub3dyYXA7ei1pbmRleDo5OTk7JzsvL2Zpc2ggcG9wdXAgemluZGV4OjEwNTBcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXNzZW1ibGVUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgdmFyIHRyYW5zaXRpb25DdXJ2ZSA9ICdjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSknO1xyXG4gICAgICAgIHZhciB0cmFuc2l0aW9uVGV4dCA9ICdsZWZ0ICcgKyBkdXJhdGlvbiArICdzICcgKyB0cmFuc2l0aW9uQ3VydmUgKyAnLCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJ3RvcCAnICsgZHVyYXRpb24gKyAncyAnICsgdHJhbnNpdGlvbkN1cnZlO1xyXG4gICAgICAgIHJldHVybiB6clV0aWwubWFwKHZlbmRvcnMsIGZ1bmN0aW9uICh2ZW5kb3JQcmVmaXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZlbmRvclByZWZpeCArICd0cmFuc2l0aW9uOicgKyB0cmFuc2l0aW9uVGV4dDtcclxuICAgICAgICB9KS5qb2luKCc7Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXNzZW1ibGVGb250KHRleHRTdHlsZU1vZGVsKSB7XHJcbiAgICAgICAgdmFyIGNzc1RleHQgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIGZvbnRTaXplID0gdGV4dFN0eWxlTW9kZWwuZ2V0KCdmb250U2l6ZScpO1xyXG4gICAgICAgIHZhciBjb2xvciA9IHRleHRTdHlsZU1vZGVsLmdldChcImNvbG9yXCIpO1xyXG5cclxuICAgICAgICBjb2xvciAmJiBjc3NUZXh0LnB1c2goJ2NvbG9yOicgKyBjb2xvcik7XHJcblxyXG4gICAgICAgIHZhciBmb250ID0gdGV4dFN0eWxlTW9kZWwuZ2V0KFwiZm9udFwiKTtcclxuICAgICAgICBmb250ICYmIGNzc1RleHQucHVzaCgnZm9udDonICsgZm9udCk7XHJcblxyXG4gICAgICAgIGZvbnRTaXplICYmXHJcbiAgICAgICAgICAgIGNzc1RleHQucHVzaCgnbGluZS1oZWlnaHQ6JyArIE1hdGgucm91bmQoZm9udFNpemUgKiAzIC8gMikgKyAncHgnKTtcclxuXHJcbiAgICAgICAgZWFjaChbJ2RlY29yYXRpb24nLCAnYWxpZ24nXSwgZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHRleHRTdHlsZU1vZGVsLmdldChuYW1lKTtcclxuICAgICAgICAgICAgdmFsICYmIGNzc1RleHQucHVzaCgndGV4dC0nICsgbmFtZSArICc6JyArIHZhbCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjc3NUZXh0LmpvaW4oJzsnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRvb2x0aXBNb2RlbFxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFzc2VtYmxlQ3NzVGV4dCh0b29sdGlwTW9kZWwpIHtcclxuXHJcbiAgICAgICAgdmFyIGNzc1RleHQgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3RyYW5zaXRpb25EdXJhdGlvbicpO1xyXG4gICAgICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSB0b29sdGlwTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcclxuICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSB0b29sdGlwTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xyXG4gICAgICAgIHZhciBwYWRkaW5nID0gdG9vbHRpcE1vZGVsLmdldCgncGFkZGluZycpO1xyXG5cclxuICAgICAgICAvLyBBbmltYXRpb24gdHJhbnNpdGlvbi4gRG8gbm90IGFuaW1hdGUgd2hlbiB0cmFuc2l0aW9uRHVyYXRpb24gaXMgMC5cclxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb24gJiZcclxuICAgICAgICAgICAgY3NzVGV4dC5wdXNoKGFzc2VtYmxlVHJhbnNpdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pKTtcclxuXHJcbiAgICAgICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xyXG4gICAgICAgICAgICBpZiAoZW52LmNhbnZhc1N1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdiYWNrZ3JvdW5kLUNvbG9yOicgKyBiYWNrZ3JvdW5kQ29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yIGllXHJcbiAgICAgICAgICAgICAgICBjc3NUZXh0LnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtQ29sb3I6IycgKyB6ckNvbG9yLnRvSGV4KGJhY2tncm91bmRDb2xvcilcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBjc3NUZXh0LnB1c2goJ2ZpbHRlcjphbHBoYShvcGFjaXR5PTcwKScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBCb3JkZXIgc3R5bGVcclxuICAgICAgICBlYWNoKFsnd2lkdGgnLCAnY29sb3InLCAncmFkaXVzJ10sIGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBib3JkZXJOYW1lID0gJ2JvcmRlci0nICsgbmFtZTtcclxuICAgICAgICAgICAgdmFyIGNhbWVsQ2FzZSA9IHRvQ2FtZWxDYXNlKGJvcmRlck5hbWUpO1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gdG9vbHRpcE1vZGVsLmdldChjYW1lbENhc2UpO1xyXG4gICAgICAgICAgICB2YWwgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgY3NzVGV4dC5wdXNoKGJvcmRlck5hbWUgKyAnOicgKyB2YWwgKyAobmFtZSA9PT0gJ2NvbG9yJyA/ICcnIDogJ3B4JykpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBUZXh0IHN0eWxlXHJcbiAgICAgICAgY3NzVGV4dC5wdXNoKGFzc2VtYmxlRm9udCh0ZXh0U3R5bGVNb2RlbCkpO1xyXG5cclxuICAgICAgICAvLyBQYWRkaW5nXHJcbiAgICAgICAgaWYgKHBhZGRpbmcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjc3NUZXh0LnB1c2goJ3BhZGRpbmc6JyArIG5vcm1hbGl6ZUNzc0FycmF5KHBhZGRpbmcpLmpvaW4oJ3B4ICcpICsgJ3B4Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY3NzVGV4dC5qb2luKCc7JykgKyAnOyc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHthbnl9IGNvbnRhaW5lclxyXG4gICAgICogQHBhcmFtIHthbnl9IGFwaVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBUb29sdGlwQ29udGVudChjb250YWluZXIsIGFwaSkge1xyXG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHZhciB6ciA9IHRoaXMuX3pyID0gYXBpLmdldFpyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZWwgPSBlbDtcclxuXHJcbiAgICAgICAgdGhpcy5feCA9IGFwaS5nZXRXaWR0aCgpIC8gMjtcclxuICAgICAgICB0aGlzLl95ID0gYXBpLmdldEhlaWdodCgpIC8gMjtcclxuXHJcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcclxuXHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xyXG5cclxuICAgICAgICB0aGlzLl9zaG93ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faGlkZVRpbWVvdXQ7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBlbC5vbm1vdXNlZW50ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIGNsZWFyIHRoZSB0aW1lb3V0IGluIGhpZGVMYXRlciBhbmQga2VlcCBzaG93aW5nIHRvb2x0aXBcclxuICAgICAgICAgICAgaWYgKHNlbGYuX2VudGVyYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX2hpZGVUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3Nob3cgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYuX2luQ29udGVudCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBlbC5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcclxuICAgICAgICAgICAgaWYgKCFzZWxmLl9lbnRlcmFibGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRyeSB0cmlnZ2VyIHpyZW5kZXIgZXZlbnQgdG8gYXZvaWQgbW91c2VcclxuICAgICAgICAgICAgICAgIC8vIGluIGFuZCBvdXQgc2hhcGUgdG9vIGZyZXF1ZW50bHlcclxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0genIuaGFuZGxlcjtcclxuICAgICAgICAgICAgICAgIGV2ZW50VXRpbC5ub3JtYWxpemVFdmVudChjb250YWluZXIsIGUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlci5kaXNwYXRjaCgnbW91c2Vtb3ZlJywgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGVsLm9ubW91c2VsZWF2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYuX2VudGVyYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3Nob3cpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmhpZGVMYXRlcihzZWxmLl9oaWRlRGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYuX2luQ29udGVudCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBUb29sdGlwQ29udGVudC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBUb29sdGlwQ29udGVudCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfZW50ZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGUgd2hlbiB0b29sdGlwIGlzIHJlbmRlcmVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIEZJWE1FXHJcbiAgICAgICAgICAgIC8vIE1vdmUgdGhpcyBsb2dpYyB0byBlYyBtYWluP1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG4gICAgICAgICAgICB2YXIgc3RsID0gY29udGFpbmVyLmN1cnJlbnRTdHlsZVxyXG4gICAgICAgICAgICAgICAgfHwgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xyXG4gICAgICAgICAgICB2YXIgZG9tU3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcbiAgICAgICAgICAgIGlmIChkb21TdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBzdGwucG9zaXRpb24gIT09ICdhYnNvbHV0ZScpIHtcclxuICAgICAgICAgICAgICAgIGRvbVN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBIaWRlIHRoZSB0b29sdGlwXHJcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcclxuICAgICAgICAgICAgLy8gdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faGlkZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xyXG5cclxuICAgICAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCA9IGdDc3NUZXh0ICsgYXNzZW1ibGVDc3NUZXh0KHRvb2x0aXBNb2RlbClcclxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjExMjU1ODcvY3NzMy10cmFuc2l0aW9uLW5vdC13b3JraW5nLWluLWNocm9tZS1hbnltb3JlXHJcbiAgICAgICAgICAgICAgICArICc7bGVmdDonICsgdGhpcy5feCArICdweDt0b3A6JyArIHRoaXMuX3kgKyAncHg7J1xyXG4gICAgICAgICAgICAgICAgKyAodG9vbHRpcE1vZGVsLmdldCgnZXh0cmFDc3NUZXh0JykgfHwgJycpO1xyXG5cclxuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLmlubmVySFRNTCA/ICAnYmxvY2snIDogJ25vbmUnO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fc2hvdyA9IHRydWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5pbm5lckhUTUwgPSBjb250ZW50O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldEVudGVyYWJsZTogZnVuY3Rpb24gKGVudGVyYWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbnRlcmFibGUgPSBlbnRlcmFibGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xyXG4gICAgICAgICAgICByZXR1cm4gW2VsLmNsaWVudFdpZHRoLCBlbC5jbGllbnRIZWlnaHRdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG1vdmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgLy8geHkgc2hvdWxkIGJlIGJhc2VkIG9uIGNhbnZhcyByb290LiBCdXQgdG9vbHRpcENvbnRlbnQgaXNcclxuICAgICAgICAgICAgLy8gdGhlIHNpYmxpbmcgb2YgY2FudmFzIHJvb3QuIFNvIHBhZGRpbmcgb2YgZWMgY29udGFpbmVyXHJcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBjb25zaWRlcmVkIGhlcmUuXHJcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX3pyO1xyXG4gICAgICAgICAgICB2YXIgdmlld3BvcnRSb290O1xyXG4gICAgICAgICAgICBpZiAoenIgJiYgenIucGFpbnRlciAmJiAodmlld3BvcnRSb290ID0genIucGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSkpIHtcclxuICAgICAgICAgICAgICAgIHggKz0gdmlld3BvcnRSb290Lm9mZnNldExlZnQgfHwgMDtcclxuICAgICAgICAgICAgICAgIHkgKz0gdmlld3BvcnRSb290Lm9mZnNldFRvcCB8fCAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmVsLnN0eWxlO1xyXG4gICAgICAgICAgICBzdHlsZS5sZWZ0ID0geCArICdweCc7XHJcbiAgICAgICAgICAgIHN0eWxlLnRvcCA9IHkgKyAncHgnO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5feCA9IHg7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICB0aGlzLl9zaG93ID0gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaGlkZUxhdGVyOiBmdW5jdGlvbiAodGltZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvdyAmJiAhKHRoaXMuX2luQ29udGVudCAmJiB0aGlzLl9lbnRlcmFibGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVEZWxheSA9IHRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHNob3cgZmFsc2UgdG8gYXZvaWQgaW52b2tlIGhpZGVMYXRlciBtdXRpcGxlIHRpbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVUaW1lb3V0ID0gc2V0VGltZW91dCh6clV0aWwuYmluZCh0aGlzLmhpZGUsIHRoaXMpLCB0aW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNTaG93OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaG93O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUb29sdGlwQ29udGVudDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL3Rvb2x0aXAvVG9vbHRpcENvbnRlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHJcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9lbnYnKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBnZXQgPSByZXF1aXJlKCcuLi91dGlsL0Zsb3dVdGlsJykubWFrZUdldHRlcigpO1xyXG5cclxuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XHJcblxyXG4gICAgdmFyIGdsb2JhbExpc3RlbmVyID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ga2V5IOazqOWGjOeahOWtl+espuS4slxyXG4gICAgICogQHBhcmFtIGFwaSBFeHRlbnNpb25BUElcclxuICAgICAqIEBwYXJhbSBoYW5kbGVyIOWkhOeQhuWbnuiwg1xyXG4gICAgICovXHJcbiAgICBnbG9iYWxMaXN0ZW5lci5yZWdpc3RlciA9IGZ1bmN0aW9uIChrZXksIGFwaSwgaGFuZGxlcikge1xyXG4gICAgICAgIGlmIChlbnYubm9kZSkgeyAgIC8vbm9kZeeOr+Wig+S4i+S4jeaJp+ihjFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5Yik5patenJlbmRlcueahCByZWNvcmRzICDlubbliJ3lp4vljJZcclxuICAgICAgICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcclxuICAgICAgICBnZXQoenIpLnJlY29yZHMgfHwgKGdldCh6cikucmVjb3JkcyA9IHt9KTtcclxuXHJcbiAgICAgICAgaW5pdEdsb2JhbExpc3RlbmVycyh6ciwgYXBpKTtcclxuXHJcbiAgICAgICAgLy/lsIblm57osIPliqDlhaVyZWNvcmRcclxuICAgICAgICB2YXIgcmVjb3JkID0gZ2V0KHpyKS5yZWNvcmRzW2tleV0gfHwgKGdldCh6cikucmVjb3Jkc1trZXldID0ge30pO1xyXG4gICAgICAgIHJlY29yZC5oYW5kbGVyID0gaGFuZGxlcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJ3lp4vljJblhajlsYDkvqblkKxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0genIgICB6cmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXBpICBFeHRlbnNpb25BUElcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGluaXRHbG9iYWxMaXN0ZW5lcnMoenIsIGFwaSkge1xyXG4gICAgICAgIGlmIChnZXQoenIpLmluaXRpYWxpemVkKSB7ICAgLy/pgb/lhY3ph43lpI3liJ3lp4vljJZcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2V0KHpyKS5pbml0aWFsaXplZCA9IHRydWU7XHJcblxyXG4gICAgICAgIC8v5L6m5ZCs5LqL5Lu2XHJcbiAgICAgICAgdXNlSGFuZGxlcignY2xpY2snLCB6clV0aWwuY3VycnkoZG9FbnRlciwgJ2NsaWNrJykpO1xyXG4gICAgICAgIHVzZUhhbmRsZXIoJ21vdXNlbW92ZScsIHpyVXRpbC5jdXJyeShkb0VudGVyLCAnbW91c2Vtb3ZlJykpO1xyXG4gICAgICAgIC8vIHVzZUhhbmRsZXIoJ21vdXNlb3V0Jywgb25MZWF2ZSk7XHJcbiAgICAgICAgdXNlSGFuZGxlcignZ2xvYmFsb3V0Jywgb25MZWF2ZSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUhhbmRsZXIoZXZlbnRUeXBlLCBjYikge1xyXG4gICAgICAgICAgICB6ci5vbihldmVudFR5cGUsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzID0gbWFrZURpc3BhdGNoQWN0aW9uKGFwaSk7XHJcbiAgICAgICAgICAgICAgICAvL+mBjeWOhuazqOWGjOeahCDmiYDmnIlyZWNvcmRz77yMIOW5tui/m+ihjOiwg+eUqFxyXG4gICAgICAgICAgICAgICAgZWFjaChnZXQoenIpLnJlY29yZHMsIGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWNvcmQgJiYgY2IocmVjb3JkLCBlLCBkaXMuZGlzcGF0Y2hBY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hUb29sdGlwRmluYWxseShkaXMucGVuZGluZ3MsIGFwaSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkaXNwYXRjaFRvb2x0aXBGaW5hbGx5KHBlbmRpbmdzLCBhcGkpIHtcclxuICAgICAgICB2YXIgc2hvd0xlbiA9IHBlbmRpbmdzLnNob3dUaXAubGVuZ3RoO1xyXG4gICAgICAgIHZhciBoaWRlTGVuID0gcGVuZGluZ3MuaGlkZVRpcC5sZW5ndGg7XHJcblxyXG4gICAgICAgIHZhciBhY3R1YWxseVBheWxvYWQ7XHJcbiAgICAgICAgaWYgKHNob3dMZW4pIHtcclxuICAgICAgICAgICAgYWN0dWFsbHlQYXlsb2FkID0gcGVuZGluZ3Muc2hvd1RpcFtzaG93TGVuIC0gMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhpZGVMZW4pIHtcclxuICAgICAgICAgICAgYWN0dWFsbHlQYXlsb2FkID0gcGVuZGluZ3MuaGlkZVRpcFtoaWRlTGVuIC0gMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhY3R1YWxseVBheWxvYWQpIHtcclxuICAgICAgICAgICAgYWN0dWFsbHlQYXlsb2FkLmRpc3BhdGNoQWN0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKGFjdHVhbGx5UGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uTGVhdmUocmVjb3JkLCBlLCBkaXNwYXRjaEFjdGlvbikge1xyXG4gICAgICAgIHJlY29yZC5oYW5kbGVyKCdsZWF2ZScsIG51bGwsIGRpc3BhdGNoQWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkb0VudGVyKGN1cnJUcmlnZ2VyLCByZWNvcmQsIGUsIGRpc3BhdGNoQWN0aW9uKSB7XHJcbiAgICAgICAgcmVjb3JkLmhhbmRsZXIoY3VyclRyaWdnZXIsIGUsIGRpc3BhdGNoQWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOa0vuWPkWFjdGlvbiAgIOihjOWwhuWPkeeUn+eahFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7YW55fSBhcGlcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1ha2VEaXNwYXRjaEFjdGlvbihhcGkpIHtcclxuICAgICAgICB2YXIgcGVuZGluZ3MgPSB7XHJcbiAgICAgICAgICAgIHNob3dUaXA6IFtdLFxyXG4gICAgICAgICAgICBoaWRlVGlwOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gRklYTUVcclxuICAgICAgICAvLyBiZXR0ZXIgYXBwcm9hY2g/XHJcbiAgICAgICAgLy8gJ3Nob3dUaXAnIGFuZCAnaGlkZVRpcCcgY2FuIGJlIHRyaWdnZXJlZCBieSBheGlzUG9pbnRlciBhbmQgdG9vbHRpcCxcclxuICAgICAgICAvLyB3aGljaCBtYXkgYmUgY29uZmxpY3QsIChheGlzUG9pbnRlciBjYWxsIHNob3dUaXAgYnV0IHRvb2x0aXAgY2FsbCBoaWRlVGlwKTtcclxuICAgICAgICAvLyBTbyB3ZSBoYXZlIHRvIGFkZCBcImZpbmFsIHN0YWdlXCIgdG8gbWVyZ2UgdGhvc2UgZGlzcGF0Y2hlZCBhY3Rpb25zLlxyXG4gICAgICAgIHZhciBkaXNwYXRjaEFjdGlvbiA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XHJcbiAgICAgICAgICAgIHZhciBwZW5kaW5nTGlzdCA9IHBlbmRpbmdzW3BheWxvYWQudHlwZV07XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZ0xpc3QucHVzaChwYXlsb2FkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBheWxvYWQuZGlzcGF0Y2hBY3Rpb24gPSBkaXNwYXRjaEFjdGlvbjtcclxuICAgICAgICAgICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbihwYXlsb2FkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoQWN0aW9uOiBkaXNwYXRjaEFjdGlvbixcclxuICAgICAgICAgICAgcGVuZGluZ3M6IHBlbmRpbmdzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcclxuICAgICAqL1xyXG4gICAgZ2xvYmFsTGlzdGVuZXIudW5yZWdpc3RlciA9IGZ1bmN0aW9uIChrZXksIGFwaSkge1xyXG4gICAgICAgIGlmIChlbnYubm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB6ciA9IGFwaS5nZXRacigpO1xyXG4gICAgICAgIHZhciByZWNvcmQgPSAoZ2V0KHpyKS5yZWNvcmRzIHx8IHt9KVtrZXldO1xyXG4gICAgICAgIGlmIChyZWNvcmQpIHtcclxuICAgICAgICAgICAgZ2V0KHpyKS5yZWNvcmRzW2tleV0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxMaXN0ZW5lcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL3Rvb2x0aXAvZ2xvYmFsTGlzdGVuZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHJcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvbW9kZWwnKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gTW9kZWwuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ3Rvb2x0aXAnLFxyXG5cclxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XHJcbiAgICAgICAgICAgIHpsZXZlbDogMCxcclxuXHJcbiAgICAgICAgICAgIHo6IDgsXHJcblxyXG4gICAgICAgICAgICBzaG93OiB0cnVlLFxyXG5cclxuICAgICAgICAgICAgLy8gdG9vbHRpcOS4u+S9k+WGheWuuVxyXG4gICAgICAgICAgICBzaG93Q29udGVudDogdHJ1ZSxcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy8gJ2NsaWNrJyB8ICdtb3VzZW1vdmUnIHwgJ25vbmUnXHJcbiAgICAgICAgICAgIHRyaWdnZXJPbjogJ21vdXNlbW92ZScsXHJcblxyXG4gICAgICAgICAgICBhbHdheXNTaG93Q29udGVudDogZmFsc2UsXHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5TW9kZTogJ3NpbmdsZScsIC8vICdzaW5nbGUnIHwgJ211bHRpcGxlQnlDb29yZFN5cydcclxuXHJcbiAgICAgICAgICAgIC8vIOS9jee9riB7QXJyYXl9IHwge0Z1bmN0aW9ufVxyXG4gICAgICAgICAgICAvLyBwb3NpdGlvbjogbnVsbFxyXG4gICAgICAgICAgICAvLyBDb25zaWRlciB0cmlnZ2VyZWQgZnJvbSBheGlzUG9pbnRlciBoYW5kbGUsIHZlcnRpY2FsQWxpZ24gc2hvdWxkIGJlICdtaWRkbGUnXHJcbiAgICAgICAgICAgIC8vIGFsaWduOiBudWxsLFxyXG4gICAgICAgICAgICAvLyB2ZXJ0aWNhbEFsaWduOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgLy8g5piv5ZCm57qm5p2fIGNvbnRlbnQg5ZyoIHZpZXdSZWN0IOS4reOAgum7mOiupCBmYWxzZSDmmK/kuLrkuoblhbzlrrnku6XliY3niYjmnKzjgIJcclxuICAgICAgICAgICAgY29uZmluZTogZmFsc2UsXHJcblxyXG4gICAgICAgICAgICAvLyDlhoXlrrnmoLzlvI/lmajvvJp7c3RyaW5nfe+8iFRlbXBsYXRl77yJIMKmIHtGdW5jdGlvbn1cclxuICAgICAgICAgICAgLy8gZm9ybWF0dGVyOiBudWxsXHJcblxyXG4gICAgICAgICAgICBzaG93RGVsYXk6IDAsXHJcblxyXG4gICAgICAgICAgICAvLyDpmpDol4/lu7bov5/vvIzljZXkvY1tc1xyXG4gICAgICAgICAgICBoaWRlRGVsYXk6IDEwMCxcclxuXHJcbiAgICAgICAgICAgIC8vIOWKqOeUu+WPmOaNouaXtumXtO+8jOWNleS9jXNcclxuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAwLjQsXHJcblxyXG4gICAgICAgICAgICBlbnRlcmFibGU6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgLy8g5o+Q56S66IOM5pmv6aKc6Imy77yM6buY6K6k5Li66YCP5piO5bqm5Li6MC4355qE6buR6ImyXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoNTAsNTAsNTAsMC43KScsXHJcblxyXG4gICAgICAgICAgICAvLyDmj5DnpLrovrnmoYbpopzoibJcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjMzMzJyxcclxuXHJcbiAgICAgICAgICAgIC8vIOaPkOekuui+ueahhuWchuinku+8jOWNleS9jXB477yM6buY6K6k5Li6NFxyXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDQsXHJcblxyXG4gICAgICAgICAgICAvLyDmj5DnpLrovrnmoYbnur/lrr3vvIzljZXkvY1weO+8jOm7mOiupOS4ujDvvIjml6DovrnmoYbvvIlcclxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDAsXHJcblxyXG4gICAgICAgICAgICAvLyDmj5DnpLrlhoXovrnot53vvIzljZXkvY1weO+8jOm7mOiupOWQhOaWueWQkeWGhei+uei3neS4ujXvvIxcclxuICAgICAgICAgICAgLy8g5o6l5Y+X5pWw57uE5YiG5Yir6K6+5a6a5LiK5Y+z5LiL5bem6L656Led77yM5ZCMY3NzXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDUsXHJcblxyXG4gICAgICAgICAgICAvLyBFeHRyYSBjc3MgdGV4dFxyXG4gICAgICAgICAgICBleHRyYUNzc1RleHQ6ICcnLFxyXG5cclxuICAgICAgICAgICAgdGV4dFN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogJyNmZmYnLFxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDE0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL3Rvb2x0aXAvVG9vbHRpcE1vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZShcIi4vZ3JhcGhpY1wiKTtcblxudmFyIF96cmVuZGVyID0gcmVxdWlyZShcIi4uL3pyZW5kZXJcIik7XG5cbnZhciByZWdpc3RlclBhaW50ZXIgPSBfenJlbmRlci5yZWdpc3RlclBhaW50ZXI7XG5cbnZhciBQYWludGVyID0gcmVxdWlyZShcIi4vUGFpbnRlclwiKTtcblxucmVnaXN0ZXJQYWludGVyKCd2bWwnLCBQYWludGVyKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvdm1sL3ZtbC5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBlbnYgPSByZXF1aXJlKFwiLi4vY29yZS9lbnZcIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgYXBwbHlUcmFuc2Zvcm0gPSBfdmVjdG9yLmFwcGx5VHJhbnNmb3JtO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgY29sb3JUb29sID0gcmVxdWlyZShcIi4uL3Rvb2wvY29sb3JcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3RleHRcIik7XG5cbnZhciB0ZXh0SGVscGVyID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvaGVscGVyL3RleHRcIik7XG5cbnZhciBSZWN0VGV4dCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL21peGluL1JlY3RUZXh0XCIpO1xuXG52YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9EaXNwbGF5YWJsZVwiKTtcblxudmFyIFpJbWFnZSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL0ltYWdlXCIpO1xuXG52YXIgVGV4dCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL1RleHRcIik7XG5cbnZhciBQYXRoID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvUGF0aFwiKTtcblxudmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BhdGhQcm94eVwiKTtcblxudmFyIEdyYWRpZW50ID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvR3JhZGllbnRcIik7XG5cbnZhciB2bWxDb3JlID0gcmVxdWlyZShcIi4vY29yZVwiKTtcblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvTk9URS1WTUxcbi8vIFRPRE8gVXNlIHByb3h5IGxpa2Ugc3ZnIGluc3RlYWQgb2Ygb3ZlcndyaXRlIGJydXNoIG1ldGhvZHNcbnZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIHNpbiA9IE1hdGguc2luO1xudmFyIG1hdGhNYXggPSBNYXRoLm1heDtcblxuaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gIHZhciBjb21tYSA9ICcsJztcbiAgdmFyIGltYWdlVHJhbnNmb3JtUHJlZml4ID0gJ3Byb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdCc7XG4gIHZhciBaID0gMjE2MDA7XG4gIHZhciBaMiA9IFogLyAyO1xuICB2YXIgWkxFVkVMX0JBU0UgPSAxMDAwMDA7XG4gIHZhciBaX0JBU0UgPSAxMDAwO1xuXG4gIHZhciBpbml0Um9vdEVsU3R5bGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBlbC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDt3aWR0aDoxcHg7aGVpZ2h0OjFweDsnO1xuICAgIGVsLmNvb3Jkc2l6ZSA9IFogKyAnLCcgKyBaO1xuICAgIGVsLmNvb3Jkb3JpZ2luID0gJzAsMCc7XG4gIH07XG5cbiAgdmFyIGVuY29kZUh0bWxBdHRyaWJ1dGUgPSBmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBTdHJpbmcocykucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gIH07XG5cbiAgdmFyIHJnYjJTdHIgPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgIHJldHVybiAncmdiKCcgKyBbciwgZywgYl0uam9pbignLCcpICsgJyknO1xuICB9O1xuXG4gIHZhciBhcHBlbmQgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCkge1xuICAgIGlmIChjaGlsZCAmJiBwYXJlbnQgJiYgY2hpbGQucGFyZW50Tm9kZSAhPT0gcGFyZW50KSB7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVtb3ZlID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgJiYgcGFyZW50ICYmIGNoaWxkLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldFpJbmRleCA9IGZ1bmN0aW9uICh6bGV2ZWwsIHosIHoyKSB7XG4gICAgLy8geiDnmoTlj5blgLzojIPlm7TkuLogWzAsIDEwMDBdXG4gICAgcmV0dXJuIChwYXJzZUZsb2F0KHpsZXZlbCkgfHwgMCkgKiBaTEVWRUxfQkFTRSArIChwYXJzZUZsb2F0KHopIHx8IDApICogWl9CQVNFICsgejI7XG4gIH07XG5cbiAgdmFyIHBhcnNlUGVyY2VudCA9IGZ1bmN0aW9uICh2YWx1ZSwgbWF4VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHZhbHVlLmxhc3RJbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBtYXhWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBQQVRIXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gIHZhciBzZXRDb2xvckFuZE9wYWNpdHkgPSBmdW5jdGlvbiAoZWwsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgdmFyIGNvbG9yQXJyID0gY29sb3JUb29sLnBhcnNlKGNvbG9yKTtcbiAgICBvcGFjaXR5ID0gK29wYWNpdHk7XG5cbiAgICBpZiAoaXNOYU4ob3BhY2l0eSkpIHtcbiAgICAgIG9wYWNpdHkgPSAxO1xuICAgIH1cblxuICAgIGlmIChjb2xvckFycikge1xuICAgICAgZWwuY29sb3IgPSByZ2IyU3RyKGNvbG9yQXJyWzBdLCBjb2xvckFyclsxXSwgY29sb3JBcnJbMl0pO1xuICAgICAgZWwub3BhY2l0eSA9IG9wYWNpdHkgKiBjb2xvckFyclszXTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldENvbG9yQW5kQWxwaGEgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICB2YXIgY29sb3JBcnIgPSBjb2xvclRvb2wucGFyc2UoY29sb3IpO1xuICAgIHJldHVybiBbcmdiMlN0cihjb2xvckFyclswXSwgY29sb3JBcnJbMV0sIGNvbG9yQXJyWzJdKSwgY29sb3JBcnJbM11dO1xuICB9O1xuXG4gIHZhciB1cGRhdGVGaWxsTm9kZSA9IGZ1bmN0aW9uIChlbCwgc3R5bGUsIHpyRWwpIHtcbiAgICAvLyBUT0RPIHBhdHRlcm5cbiAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGw7XG5cbiAgICBpZiAoZmlsbCAhPSBudWxsKSB7XG4gICAgICAvLyBNb2RpZmllZCBmcm9tIGV4Y2FudmFzXG4gICAgICBpZiAoZmlsbCBpbnN0YW5jZW9mIEdyYWRpZW50KSB7XG4gICAgICAgIHZhciBncmFkaWVudFR5cGU7XG4gICAgICAgIHZhciBhbmdsZSA9IDA7XG4gICAgICAgIHZhciBmb2N1cyA9IFswLCAwXTsgLy8gYWRkaXRpb25hbCBvZmZzZXRcblxuICAgICAgICB2YXIgc2hpZnQgPSAwOyAvLyBzY2FsZSBmYWN0b3IgZm9yIG9mZnNldFxuXG4gICAgICAgIHZhciBleHBhbnNpb24gPSAxO1xuICAgICAgICB2YXIgcmVjdCA9IHpyRWwuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIHZhciByZWN0V2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICB2YXIgcmVjdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuXG4gICAgICAgIGlmIChmaWxsLnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgZ3JhZGllbnRUeXBlID0gJ2dyYWRpZW50JztcbiAgICAgICAgICB2YXIgdHJhbnNmb3JtID0genJFbC50cmFuc2Zvcm07XG4gICAgICAgICAgdmFyIHAwID0gW2ZpbGwueCAqIHJlY3RXaWR0aCwgZmlsbC55ICogcmVjdEhlaWdodF07XG4gICAgICAgICAgdmFyIHAxID0gW2ZpbGwueDIgKiByZWN0V2lkdGgsIGZpbGwueTIgKiByZWN0SGVpZ2h0XTtcblxuICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAwLCBwMCwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgdHJhbnNmb3JtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZHggPSBwMVswXSAtIHAwWzBdO1xuICAgICAgICAgIHZhciBkeSA9IHAxWzFdIC0gcDBbMV07XG4gICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKGR4LCBkeSkgKiAxODAgLyBNYXRoLlBJOyAvLyBUaGUgYW5nbGUgc2hvdWxkIGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci5cblxuICAgICAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgICAgIGFuZ2xlICs9IDM2MDtcbiAgICAgICAgICB9IC8vIFZlcnkgc21hbGwgYW5nbGVzIHByb2R1Y2UgYW4gdW5leHBlY3RlZCByZXN1bHQgYmVjYXVzZSB0aGV5IGFyZVxuICAgICAgICAgIC8vIGNvbnZlcnRlZCB0byBhIHNjaWVudGlmaWMgbm90YXRpb24gc3RyaW5nLlxuXG5cbiAgICAgICAgICBpZiAoYW5nbGUgPCAxZS02KSB7XG4gICAgICAgICAgICBhbmdsZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyYWRpZW50VHlwZSA9ICdncmFkaWVudHJhZGlhbCc7XG4gICAgICAgICAgdmFyIHAwID0gW2ZpbGwueCAqIHJlY3RXaWR0aCwgZmlsbC55ICogcmVjdEhlaWdodF07XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHpyRWwudHJhbnNmb3JtO1xuICAgICAgICAgIHZhciBzY2FsZSA9IHpyRWwuc2NhbGU7XG4gICAgICAgICAgdmFyIHdpZHRoID0gcmVjdFdpZHRoO1xuICAgICAgICAgIHZhciBoZWlnaHQgPSByZWN0SGVpZ2h0O1xuICAgICAgICAgIGZvY3VzID0gWy8vIFBlcmNlbnQgaW4gYm91bmRpbmcgcmVjdFxuICAgICAgICAgIChwMFswXSAtIHJlY3QueCkgLyB3aWR0aCwgKHAwWzFdIC0gcmVjdC55KSAvIGhlaWdodF07XG5cbiAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMCwgcDAsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2lkdGggLz0gc2NhbGVbMF0gKiBaO1xuICAgICAgICAgIGhlaWdodCAvPSBzY2FsZVsxXSAqIFo7XG4gICAgICAgICAgdmFyIGRpbWVuc2lvbiA9IG1hdGhNYXgod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgc2hpZnQgPSAyICogMCAvIGRpbWVuc2lvbjtcbiAgICAgICAgICBleHBhbnNpb24gPSAyICogZmlsbC5yIC8gZGltZW5zaW9uIC0gc2hpZnQ7XG4gICAgICAgIH0gLy8gV2UgbmVlZCB0byBzb3J0IHRoZSBjb2xvciBzdG9wcyBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgb2Zmc2V0LFxuICAgICAgICAvLyBvdGhlcndpc2UgSUUgd29uJ3QgaW50ZXJwcmV0IGl0IGNvcnJlY3RseS5cblxuXG4gICAgICAgIHZhciBzdG9wcyA9IGZpbGwuY29sb3JTdG9wcy5zbGljZSgpO1xuICAgICAgICBzdG9wcy5zb3J0KGZ1bmN0aW9uIChjczEsIGNzMikge1xuICAgICAgICAgIHJldHVybiBjczEub2Zmc2V0IC0gY3MyLm9mZnNldDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsZW5ndGggPSBzdG9wcy5sZW5ndGg7IC8vIENvbG9yIGFuZCBhbHBoYSBsaXN0IG9mIGZpcnN0IGFuZCBsYXN0IHN0b3BcblxuICAgICAgICB2YXIgY29sb3JBbmRBbHBoYUxpc3QgPSBbXTtcbiAgICAgICAgdmFyIGNvbG9ycyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc3RvcCA9IHN0b3BzW2ldO1xuICAgICAgICAgIHZhciBjb2xvckFuZEFscGhhID0gZ2V0Q29sb3JBbmRBbHBoYShzdG9wLmNvbG9yKTtcbiAgICAgICAgICBjb2xvcnMucHVzaChzdG9wLm9mZnNldCAqIGV4cGFuc2lvbiArIHNoaWZ0ICsgJyAnICsgY29sb3JBbmRBbHBoYVswXSk7XG5cbiAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBjb2xvckFuZEFscGhhTGlzdC5wdXNoKGNvbG9yQW5kQWxwaGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPj0gMikge1xuICAgICAgICAgIHZhciBjb2xvcjEgPSBjb2xvckFuZEFscGhhTGlzdFswXVswXTtcbiAgICAgICAgICB2YXIgY29sb3IyID0gY29sb3JBbmRBbHBoYUxpc3RbMV1bMF07XG4gICAgICAgICAgdmFyIG9wYWNpdHkxID0gY29sb3JBbmRBbHBoYUxpc3RbMF1bMV0gKiBzdHlsZS5vcGFjaXR5O1xuICAgICAgICAgIHZhciBvcGFjaXR5MiA9IGNvbG9yQW5kQWxwaGFMaXN0WzFdWzFdICogc3R5bGUub3BhY2l0eTtcbiAgICAgICAgICBlbC50eXBlID0gZ3JhZGllbnRUeXBlO1xuICAgICAgICAgIGVsLm1ldGhvZCA9ICdub25lJztcbiAgICAgICAgICBlbC5mb2N1cyA9ICcxMDAlJztcbiAgICAgICAgICBlbC5hbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgIGVsLmNvbG9yID0gY29sb3IxO1xuICAgICAgICAgIGVsLmNvbG9yMiA9IGNvbG9yMjtcbiAgICAgICAgICBlbC5jb2xvcnMgPSBjb2xvcnMuam9pbignLCcpOyAvLyBXaGVuIGNvbG9ycyBhdHRyaWJ1dGUgaXMgdXNlZCwgdGhlIG1lYW5pbmdzIG9mIG9wYWNpdHkgYW5kIG86b3BhY2l0eTJcbiAgICAgICAgICAvLyBhcmUgcmV2ZXJzZWQuXG5cbiAgICAgICAgICBlbC5vcGFjaXR5ID0gb3BhY2l0eTI7IC8vIEZJWE1FIGdfb186b3BhY2l0eSA/XG5cbiAgICAgICAgICBlbC5vcGFjaXR5MiA9IG9wYWNpdHkxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyYWRpZW50VHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgICBlbC5mb2N1c3Bvc2l0aW9uID0gZm9jdXMuam9pbignLCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGSVhNRSBDaGFuZ2UgZnJvbSBHcmFkaWVudCBmaWxsIHRvIGNvbG9yIGZpbGxcbiAgICAgICAgc2V0Q29sb3JBbmRPcGFjaXR5KGVsLCBmaWxsLCBzdHlsZS5vcGFjaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZVN0cm9rZU5vZGUgPSBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XG4gICAgLy8gaWYgKHN0eWxlLmxpbmVKb2luICE9IG51bGwpIHtcbiAgICAvLyAgICAgZWwuam9pbnN0eWxlID0gc3R5bGUubGluZUpvaW47XG4gICAgLy8gfVxuICAgIC8vIGlmIChzdHlsZS5taXRlckxpbWl0ICE9IG51bGwpIHtcbiAgICAvLyAgICAgZWwubWl0ZXJsaW1pdCA9IHN0eWxlLm1pdGVyTGltaXQgKiBaO1xuICAgIC8vIH1cbiAgICAvLyBpZiAoc3R5bGUubGluZUNhcCAhPSBudWxsKSB7XG4gICAgLy8gICAgIGVsLmVuZGNhcCA9IHN0eWxlLmxpbmVDYXA7XG4gICAgLy8gfVxuICAgIGlmIChzdHlsZS5saW5lRGFzaCAhPSBudWxsKSB7XG4gICAgICBlbC5kYXNoc3R5bGUgPSBzdHlsZS5saW5lRGFzaC5qb2luKCcgJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlLnN0cm9rZSAhPSBudWxsICYmICEoc3R5bGUuc3Ryb2tlIGluc3RhbmNlb2YgR3JhZGllbnQpKSB7XG4gICAgICBzZXRDb2xvckFuZE9wYWNpdHkoZWwsIHN0eWxlLnN0cm9rZSwgc3R5bGUub3BhY2l0eSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciB1cGRhdGVGaWxsQW5kU3Ryb2tlID0gZnVuY3Rpb24gKHZtbEVsLCB0eXBlLCBzdHlsZSwgenJFbCkge1xuICAgIHZhciBpc0ZpbGwgPSB0eXBlID09ICdmaWxsJztcbiAgICB2YXIgZWwgPSB2bWxFbC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0eXBlKVswXTsgLy8gU3Ryb2tlIG11c3QgaGF2ZSBsaW5lV2lkdGhcblxuICAgIGlmIChzdHlsZVt0eXBlXSAhPSBudWxsICYmIHN0eWxlW3R5cGVdICE9PSAnbm9uZScgJiYgKGlzRmlsbCB8fCAhaXNGaWxsICYmIHN0eWxlLmxpbmVXaWR0aCkpIHtcbiAgICAgIHZtbEVsW2lzRmlsbCA/ICdmaWxsZWQnIDogJ3N0cm9rZWQnXSA9ICd0cnVlJzsgLy8gRklYTUUgUmVtb3ZlIGJlZm9yZSB1cGRhdGluZywgb3Igc2V0IGBjb2xvcnNgIHdpbGwgdGhyb3cgZXJyb3JcblxuICAgICAgaWYgKHN0eWxlW3R5cGVdIGluc3RhbmNlb2YgR3JhZGllbnQpIHtcbiAgICAgICAgcmVtb3ZlKHZtbEVsLCBlbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZWwpIHtcbiAgICAgICAgZWwgPSB2bWxDb3JlLmNyZWF0ZU5vZGUodHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlzRmlsbCA/IHVwZGF0ZUZpbGxOb2RlKGVsLCBzdHlsZSwgenJFbCkgOiB1cGRhdGVTdHJva2VOb2RlKGVsLCBzdHlsZSk7XG4gICAgICBhcHBlbmQodm1sRWwsIGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm1sRWxbaXNGaWxsID8gJ2ZpbGxlZCcgOiAnc3Ryb2tlZCddID0gJ2ZhbHNlJztcbiAgICAgIHJlbW92ZSh2bWxFbCwgZWwpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcG9pbnRzID0gW1tdLCBbXSwgW11dO1xuXG4gIHZhciBwYXRoRGF0YVRvU3RyaW5nID0gZnVuY3Rpb24gKHBhdGgsIG0pIHtcbiAgICB2YXIgTSA9IENNRC5NO1xuICAgIHZhciBDID0gQ01ELkM7XG4gICAgdmFyIEwgPSBDTUQuTDtcbiAgICB2YXIgQSA9IENNRC5BO1xuICAgIHZhciBRID0gQ01ELlE7XG4gICAgdmFyIHN0ciA9IFtdO1xuICAgIHZhciBuUG9pbnQ7XG4gICAgdmFyIGNtZFN0cjtcbiAgICB2YXIgY21kO1xuICAgIHZhciBpO1xuICAgIHZhciB4aTtcbiAgICB2YXIgeWk7XG4gICAgdmFyIGRhdGEgPSBwYXRoLmRhdGE7XG4gICAgdmFyIGRhdGFMZW5ndGggPSBwYXRoLmxlbigpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7KSB7XG4gICAgICBjbWQgPSBkYXRhW2krK107XG4gICAgICBjbWRTdHIgPSAnJztcbiAgICAgIG5Qb2ludCA9IDA7XG5cbiAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgTTpcbiAgICAgICAgICBjbWRTdHIgPSAnIG0gJztcbiAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHBvaW50c1swXVswXSA9IHhpO1xuICAgICAgICAgIHBvaW50c1swXVsxXSA9IHlpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgTDpcbiAgICAgICAgICBjbWRTdHIgPSAnIGwgJztcbiAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHBvaW50c1swXVswXSA9IHhpO1xuICAgICAgICAgIHBvaW50c1swXVsxXSA9IHlpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUTpcbiAgICAgICAgY2FzZSBDOlxuICAgICAgICAgIGNtZFN0ciA9ICcgYyAnO1xuICAgICAgICAgIG5Qb2ludCA9IDM7XG4gICAgICAgICAgdmFyIHgxID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB5MSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgeDIgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHkyID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB4MztcbiAgICAgICAgICB2YXIgeTM7XG5cbiAgICAgICAgICBpZiAoY21kID09PSBRKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHF1YWRyYXRpYyB0byBjdWJpYyB1c2luZyBkZWdyZWUgZWxldmF0aW9uXG4gICAgICAgICAgICB4MyA9IHgyO1xuICAgICAgICAgICAgeTMgPSB5MjtcbiAgICAgICAgICAgIHgyID0gKHgyICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICB5MiA9ICh5MiArIDIgKiB5MSkgLyAzO1xuICAgICAgICAgICAgeDEgPSAoeGkgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgIHkxID0gKHlpICsgMiAqIHkxKSAvIDM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHgzID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgeTMgPSBkYXRhW2krK107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9pbnRzWzBdWzBdID0geDE7XG4gICAgICAgICAgcG9pbnRzWzBdWzFdID0geTE7XG4gICAgICAgICAgcG9pbnRzWzFdWzBdID0geDI7XG4gICAgICAgICAgcG9pbnRzWzFdWzFdID0geTI7XG4gICAgICAgICAgcG9pbnRzWzJdWzBdID0geDM7XG4gICAgICAgICAgcG9pbnRzWzJdWzFdID0geTM7XG4gICAgICAgICAgeGkgPSB4MztcbiAgICAgICAgICB5aSA9IHkzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQTpcbiAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgdmFyIHkgPSAwO1xuICAgICAgICAgIHZhciBzeCA9IDE7XG4gICAgICAgICAgdmFyIHN5ID0gMTtcbiAgICAgICAgICB2YXIgYW5nbGUgPSAwO1xuXG4gICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgU1JUIGZyb20gbWF0cml4XG4gICAgICAgICAgICB4ID0gbVs0XTtcbiAgICAgICAgICAgIHkgPSBtWzVdO1xuICAgICAgICAgICAgc3ggPSBzcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICAgICAgc3kgPSBzcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZGF0YVtpKytdICsgYW5nbGU7XG4gICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZSArIGFuZ2xlOyAvLyBGSVhNRVxuICAgICAgICAgIC8vIHZhciBwc2kgPSBkYXRhW2krK107XG5cbiAgICAgICAgICBpKys7XG4gICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgeDAgPSBjeCArIGNvcyhzdGFydEFuZ2xlKSAqIHJ4O1xuICAgICAgICAgIHZhciB5MCA9IGN5ICsgc2luKHN0YXJ0QW5nbGUpICogcnk7XG4gICAgICAgICAgdmFyIHgxID0gY3ggKyBjb3MoZW5kQW5nbGUpICogcng7XG4gICAgICAgICAgdmFyIHkxID0gY3kgKyBzaW4oZW5kQW5nbGUpICogcnk7XG4gICAgICAgICAgdmFyIHR5cGUgPSBjbG9ja3dpc2UgPyAnIHdhICcgOiAnIGF0ICc7XG5cbiAgICAgICAgICBpZiAoTWF0aC5hYnMoeDAgLSB4MSkgPCAxZS00KSB7XG4gICAgICAgICAgICAvLyBJRSB3b24ndCByZW5kZXIgYXJjaGVzIGRyYXduIGNvdW50ZXIgY2xvY2t3aXNlIGlmIHgwID09IHgxLlxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgPiAxZS0yKSB7XG4gICAgICAgICAgICAgIC8vIE9mZnNldCB4MCBieSAxLzgwIG9mIGEgcGl4ZWwuIFVzZSBzb21ldGhpbmdcbiAgICAgICAgICAgICAgLy8gdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gYmluYXJ5XG4gICAgICAgICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICAgICAgICB4MCArPSAyNzAgLyBaO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBBdm9pZCBjYXNlIGRyYXcgZnVsbCBjaXJjbGVcbiAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHkwIC0gY3kpIDwgMWUtNCkge1xuICAgICAgICAgICAgICAgIGlmIChjbG9ja3dpc2UgJiYgeDAgPCBjeCB8fCAhY2xvY2t3aXNlICYmIHgwID4gY3gpIHtcbiAgICAgICAgICAgICAgICAgIHkxIC09IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHkxICs9IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNsb2Nrd2lzZSAmJiB5MCA8IGN5IHx8ICFjbG9ja3dpc2UgJiYgeTAgPiBjeSkge1xuICAgICAgICAgICAgICAgIHgxICs9IDI3MCAvIFo7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeDEgLT0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0ci5wdXNoKHR5cGUsIHJvdW5kKCgoY3ggLSByeCkgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCgoY3kgLSByeSkgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCgoY3ggKyByeCkgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCgoY3kgKyByeSkgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCh4MCAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSwgcm91bmQoKHkwICogc3kgKyB5KSAqIFogLSBaMiksIGNvbW1hLCByb3VuZCgoeDEgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCh5MSAqIHN5ICsgeSkgKiBaIC0gWjIpKTtcbiAgICAgICAgICB4aSA9IHgxO1xuICAgICAgICAgIHlpID0geTE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICB2YXIgcDAgPSBwb2ludHNbMF07XG4gICAgICAgICAgdmFyIHAxID0gcG9pbnRzWzFdOyAvLyB4MCwgeTBcblxuICAgICAgICAgIHAwWzBdID0gZGF0YVtpKytdO1xuICAgICAgICAgIHAwWzFdID0gZGF0YVtpKytdOyAvLyB4MSwgeTFcblxuICAgICAgICAgIHAxWzBdID0gcDBbMF0gKyBkYXRhW2krK107XG4gICAgICAgICAgcDFbMV0gPSBwMFsxXSArIGRhdGFbaSsrXTtcblxuICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMCwgcDAsIG0pO1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDEsIHAxLCBtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwMFswXSA9IHJvdW5kKHAwWzBdICogWiAtIFoyKTtcbiAgICAgICAgICBwMVswXSA9IHJvdW5kKHAxWzBdICogWiAtIFoyKTtcbiAgICAgICAgICBwMFsxXSA9IHJvdW5kKHAwWzFdICogWiAtIFoyKTtcbiAgICAgICAgICBwMVsxXSA9IHJvdW5kKHAxWzFdICogWiAtIFoyKTtcbiAgICAgICAgICBzdHIucHVzaCggLy8geDAsIHkwXG4gICAgICAgICAgJyBtICcsIHAwWzBdLCBjb21tYSwgcDBbMV0sIC8vIHgxLCB5MFxuICAgICAgICAgICcgbCAnLCBwMVswXSwgY29tbWEsIHAwWzFdLCAvLyB4MSwgeTFcbiAgICAgICAgICAnIGwgJywgcDFbMF0sIGNvbW1hLCBwMVsxXSwgLy8geDAsIHkxXG4gICAgICAgICAgJyBsICcsIHAwWzBdLCBjb21tYSwgcDFbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgLy8gRklYTUUgVXBkYXRlIHhpLCB5aVxuICAgICAgICAgIHN0ci5wdXNoKCcgeCAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5Qb2ludCA+IDApIHtcbiAgICAgICAgc3RyLnB1c2goY21kU3RyKTtcblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG5Qb2ludDsgaysrKSB7XG4gICAgICAgICAgdmFyIHAgPSBwb2ludHNba107XG4gICAgICAgICAgbSAmJiBhcHBseVRyYW5zZm9ybShwLCBwLCBtKTsgLy8g5LiNIHJvdW5kIOS8mumdnuW4uOaFolxuXG4gICAgICAgICAgc3RyLnB1c2gocm91bmQocFswXSAqIFogLSBaMiksIGNvbW1hLCByb3VuZChwWzFdICogWiAtIFoyKSwgayA8IG5Qb2ludCAtIDEgPyBjb21tYSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHIuam9pbignJyk7XG4gIH07IC8vIFJld3JpdGUgdGhlIG9yaWdpbmFsIHBhdGggbWV0aG9kXG5cblxuICBQYXRoLnByb3RvdHlwZS5icnVzaFZNTCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgdm1sRWwgPSB0aGlzLl92bWxFbDtcblxuICAgIGlmICghdm1sRWwpIHtcbiAgICAgIHZtbEVsID0gdm1sQ29yZS5jcmVhdGVOb2RlKCdzaGFwZScpO1xuICAgICAgaW5pdFJvb3RFbFN0eWxlKHZtbEVsKTtcbiAgICAgIHRoaXMuX3ZtbEVsID0gdm1sRWw7XG4gICAgfVxuXG4gICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh2bWxFbCwgJ2ZpbGwnLCBzdHlsZSwgdGhpcyk7XG4gICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh2bWxFbCwgJ3N0cm9rZScsIHN0eWxlLCB0aGlzKTtcbiAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgIHZhciBuZWVkVHJhbnNmb3JtID0gbSAhPSBudWxsO1xuICAgIHZhciBzdHJva2VFbCA9IHZtbEVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdHJva2UnKVswXTtcblxuICAgIGlmIChzdHJva2VFbCkge1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDsgLy8gR2V0IHRoZSBsaW5lIHNjYWxlLlxuICAgICAgLy8gRGV0ZXJtaW5hbnQgb2YgdGhpcy5tXyBtZWFucyBob3cgbXVjaCB0aGUgYXJlYSBpcyBlbmxhcmdlZCBieSB0aGVcbiAgICAgIC8vIHRyYW5zZm9ybWF0aW9uLiBTbyBpdHMgc3F1YXJlIHJvb3QgY2FuIGJlIHVzZWQgYXMgYSBzY2FsZSBmYWN0b3JcbiAgICAgIC8vIGZvciB3aWR0aC5cblxuICAgICAgaWYgKG5lZWRUcmFuc2Zvcm0gJiYgIXN0eWxlLnN0cm9rZU5vU2NhbGUpIHtcbiAgICAgICAgdmFyIGRldCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XG4gICAgICAgIGxpbmVXaWR0aCAqPSBzcXJ0KGFicyhkZXQpKTtcbiAgICAgIH1cblxuICAgICAgc3Ryb2tlRWwud2VpZ2h0ID0gbGluZVdpZHRoICsgJ3B4JztcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aCB8fCAodGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpKTtcblxuICAgIGlmICh0aGlzLl9fZGlydHlQYXRoKSB7XG4gICAgICBwYXRoLmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSk7XG4gICAgICBwYXRoLnRvU3RhdGljKCk7XG4gICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdm1sRWwucGF0aCA9IHBhdGhEYXRhVG9TdHJpbmcocGF0aCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIHZtbEVsLnN0eWxlLnpJbmRleCA9IGdldFpJbmRleCh0aGlzLnpsZXZlbCwgdGhpcy56LCB0aGlzLnoyKTsgLy8gQXBwZW5kIHRvIHJvb3RcblxuICAgIGFwcGVuZCh2bWxSb290LCB2bWxFbCk7IC8vIFRleHRcblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH1cbiAgfTtcblxuICBQYXRoLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgcmVtb3ZlKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcbiAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICB9O1xuXG4gIFBhdGgucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICBhcHBlbmQodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogSU1BR0VcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgdmFyIGlzSW1hZ2UgPSBmdW5jdGlvbiAoaW1nKSB7XG4gICAgLy8gRklYTUUgaW1nIGluc3RhbmNlb2YgSW1hZ2Ug5aaC5p6cIGltZyDmmK/kuIDkuKrlrZfnrKbkuLLnmoTml7blgJnvvIxJRTgg5LiL5Lya5oql6ZSZXG4gICAgcmV0dXJuIHR5cGVvZiBpbWcgPT09ICdvYmplY3QnICYmIGltZy50YWdOYW1lICYmIGltZy50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdJTUcnOyAvLyByZXR1cm4gaW1nIGluc3RhbmNlb2YgSW1hZ2U7XG4gIH07IC8vIFJld3JpdGUgdGhlIG9yaWdpbmFsIHBhdGggbWV0aG9kXG5cblxuICBaSW1hZ2UucHJvdG90eXBlLmJydXNoVk1MID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBpbWFnZSA9IHN0eWxlLmltYWdlOyAvLyBJbWFnZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0XG5cbiAgICB2YXIgb3c7XG4gICAgdmFyIG9oO1xuXG4gICAgaWYgKGlzSW1hZ2UoaW1hZ2UpKSB7XG4gICAgICB2YXIgc3JjID0gaW1hZ2Uuc3JjO1xuXG4gICAgICBpZiAoc3JjID09PSB0aGlzLl9pbWFnZVNyYykge1xuICAgICAgICBvdyA9IHRoaXMuX2ltYWdlV2lkdGg7XG4gICAgICAgIG9oID0gdGhpcy5faW1hZ2VIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW1hZ2VSdW50aW1lU3R5bGUgPSBpbWFnZS5ydW50aW1lU3R5bGU7XG4gICAgICAgIHZhciBvbGRSdW50aW1lV2lkdGggPSBpbWFnZVJ1bnRpbWVTdHlsZS53aWR0aDtcbiAgICAgICAgdmFyIG9sZFJ1bnRpbWVIZWlnaHQgPSBpbWFnZVJ1bnRpbWVTdHlsZS5oZWlnaHQ7XG4gICAgICAgIGltYWdlUnVudGltZVN0eWxlLndpZHRoID0gJ2F1dG8nO1xuICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS5oZWlnaHQgPSAnYXV0byc7IC8vIGdldCB0aGUgb3JpZ2luYWwgc2l6ZVxuXG4gICAgICAgIG93ID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgIG9oID0gaW1hZ2UuaGVpZ2h0OyAvLyBhbmQgcmVtb3ZlIG92ZXJpZGVzXG5cbiAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUud2lkdGggPSBvbGRSdW50aW1lV2lkdGg7XG4gICAgICAgIGltYWdlUnVudGltZVN0eWxlLmhlaWdodCA9IG9sZFJ1bnRpbWVIZWlnaHQ7IC8vIENhY2hpbmcgaW1hZ2Ugb3JpZ2luYWwgd2lkdGgsIGhlaWdodCBhbmQgc3JjXG5cbiAgICAgICAgdGhpcy5faW1hZ2VTcmMgPSBzcmM7XG4gICAgICAgIHRoaXMuX2ltYWdlV2lkdGggPSBvdztcbiAgICAgICAgdGhpcy5faW1hZ2VIZWlnaHQgPSBvaDtcbiAgICAgIH1cblxuICAgICAgaW1hZ2UgPSBzcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbWFnZSA9PT0gdGhpcy5faW1hZ2VTcmMpIHtcbiAgICAgICAgb3cgPSB0aGlzLl9pbWFnZVdpZHRoO1xuICAgICAgICBvaCA9IHRoaXMuX2ltYWdlSGVpZ2h0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgeCA9IHN0eWxlLnggfHwgMDtcbiAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcbiAgICB2YXIgZHcgPSBzdHlsZS53aWR0aDtcbiAgICB2YXIgZGggPSBzdHlsZS5oZWlnaHQ7XG4gICAgdmFyIHN3ID0gc3R5bGUuc1dpZHRoO1xuICAgIHZhciBzaCA9IHN0eWxlLnNIZWlnaHQ7XG4gICAgdmFyIHN4ID0gc3R5bGUuc3ggfHwgMDtcbiAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuICAgIHZhciBoYXNDcm9wID0gc3cgJiYgc2g7XG4gICAgdmFyIHZtbEVsID0gdGhpcy5fdm1sRWw7XG5cbiAgICBpZiAoIXZtbEVsKSB7XG4gICAgICAvLyBGSVhNRSDkvb/nlKggZ3JvdXAg5ZyoIGxlZnQsIHRvcCDpg73kuI3mmK8gMCDnmoTml7blgJnlsLHml6Dms5XmmL7npLrkuobjgIJcbiAgICAgIC8vIHZtbEVsID0gdm1sQ29yZS5jcmVhdGVOb2RlKCdncm91cCcpO1xuICAgICAgdm1sRWwgPSB2bWxDb3JlLmRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGluaXRSb290RWxTdHlsZSh2bWxFbCk7XG4gICAgICB0aGlzLl92bWxFbCA9IHZtbEVsO1xuICAgIH1cblxuICAgIHZhciB2bWxFbFN0eWxlID0gdm1sRWwuc3R5bGU7XG4gICAgdmFyIGhhc1JvdGF0aW9uID0gZmFsc2U7XG4gICAgdmFyIG07XG4gICAgdmFyIHNjYWxlWCA9IDE7XG4gICAgdmFyIHNjYWxlWSA9IDE7XG5cbiAgICBpZiAodGhpcy50cmFuc2Zvcm0pIHtcbiAgICAgIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgIHNjYWxlWCA9IHNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICBzY2FsZVkgPSBzcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgaGFzUm90YXRpb24gPSBtWzFdIHx8IG1bMl07XG4gICAgfVxuXG4gICAgaWYgKGhhc1JvdGF0aW9uKSB7XG4gICAgICAvLyBJZiBmaWx0ZXJzIGFyZSBuZWNlc3NhcnkgKHJvdGF0aW9uIGV4aXN0cyksIGNyZWF0ZSB0aGVtXG4gICAgICAvLyBmaWx0ZXJzIGFyZSBib2ctc2xvdywgc28gb25seSBjcmVhdGUgdGhlbSBpZiBhYmJzb2x1dGVseSBuZWNlc3NhcnlcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY2hlY2sgZG9lc24ndCBhY2NvdW50IGZvciBza2V3cyAod2hpY2ggZG9uJ3QgZXhpc3RcbiAgICAgIC8vIGluIHRoZSBjYW52YXMgc3BlYyAoeWV0KSBhbnl3YXkuXG4gICAgICAvLyBGcm9tIGV4Y2FudmFzXG4gICAgICB2YXIgcDAgPSBbeCwgeV07XG4gICAgICB2YXIgcDEgPSBbeCArIGR3LCB5XTtcbiAgICAgIHZhciBwMiA9IFt4LCB5ICsgZGhdO1xuICAgICAgdmFyIHAzID0gW3ggKyBkdywgeSArIGRoXTtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKHAwLCBwMCwgbSk7XG4gICAgICBhcHBseVRyYW5zZm9ybShwMSwgcDEsIG0pO1xuICAgICAgYXBwbHlUcmFuc2Zvcm0ocDIsIHAyLCBtKTtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKHAzLCBwMywgbSk7XG4gICAgICB2YXIgbWF4WCA9IG1hdGhNYXgocDBbMF0sIHAxWzBdLCBwMlswXSwgcDNbMF0pO1xuICAgICAgdmFyIG1heFkgPSBtYXRoTWF4KHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdKTtcbiAgICAgIHZhciB0cmFuc2Zvcm1GaWx0ZXIgPSBbXTtcbiAgICAgIHRyYW5zZm9ybUZpbHRlci5wdXNoKCdNMTE9JywgbVswXSAvIHNjYWxlWCwgY29tbWEsICdNMTI9JywgbVsyXSAvIHNjYWxlWSwgY29tbWEsICdNMjE9JywgbVsxXSAvIHNjYWxlWCwgY29tbWEsICdNMjI9JywgbVszXSAvIHNjYWxlWSwgY29tbWEsICdEeD0nLCByb3VuZCh4ICogc2NhbGVYICsgbVs0XSksIGNvbW1hLCAnRHk9Jywgcm91bmQoeSAqIHNjYWxlWSArIG1bNV0pKTtcbiAgICAgIHZtbEVsU3R5bGUucGFkZGluZyA9ICcwICcgKyByb3VuZChtYXhYKSArICdweCAnICsgcm91bmQobWF4WSkgKyAncHggMCc7IC8vIEZJWE1FIERYSW1hZ2VUcmFuc2Zvcm0g5ZyoIElFMTEg55qE5YW85a655qih5byP5LiL5LiN6LW35L2c55SoXG5cbiAgICAgIHZtbEVsU3R5bGUuZmlsdGVyID0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLk1hdHJpeCgnICsgdHJhbnNmb3JtRmlsdGVyLmpvaW4oJycpICsgJywgU2l6aW5nTWV0aG9kPWNsaXApJztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG0pIHtcbiAgICAgICAgeCA9IHggKiBzY2FsZVggKyBtWzRdO1xuICAgICAgICB5ID0geSAqIHNjYWxlWSArIG1bNV07XG4gICAgICB9XG5cbiAgICAgIHZtbEVsU3R5bGUuZmlsdGVyID0gJyc7XG4gICAgICB2bWxFbFN0eWxlLmxlZnQgPSByb3VuZCh4KSArICdweCc7XG4gICAgICB2bWxFbFN0eWxlLnRvcCA9IHJvdW5kKHkpICsgJ3B4JztcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VFbCA9IHRoaXMuX2ltYWdlRWw7XG4gICAgdmFyIGNyb3BFbCA9IHRoaXMuX2Nyb3BFbDtcblxuICAgIGlmICghaW1hZ2VFbCkge1xuICAgICAgaW1hZ2VFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5faW1hZ2VFbCA9IGltYWdlRWw7XG4gICAgfVxuXG4gICAgdmFyIGltYWdlRUxTdHlsZSA9IGltYWdlRWwuc3R5bGU7XG5cbiAgICBpZiAoaGFzQ3JvcCkge1xuICAgICAgLy8gTmVlZHMga25vdyBpbWFnZSBvcmlnaW5hbCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICBpZiAoIShvdyAmJiBvaCkpIHtcbiAgICAgICAgdmFyIHRtcEltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0bXBJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdG1wSW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICBvdyA9IHRtcEltYWdlLndpZHRoO1xuICAgICAgICAgIG9oID0gdG1wSW1hZ2UuaGVpZ2h0OyAvLyBBZGp1c3QgaW1hZ2Ugd2lkdGggYW5kIGhlaWdodCB0byBmaXQgdGhlIHJhdGlvIGRlc3RpbmF0aW9uU2l6ZSAvIHNvdXJjZVNpemVcblxuICAgICAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIG93ICogZHcgLyBzdykgKyAncHgnO1xuICAgICAgICAgIGltYWdlRUxTdHlsZS5oZWlnaHQgPSByb3VuZChzY2FsZVkgKiBvaCAqIGRoIC8gc2gpICsgJ3B4JzsgLy8gQ2FjaGluZyBpbWFnZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0IGFuZCBzcmNcblxuICAgICAgICAgIHNlbGYuX2ltYWdlV2lkdGggPSBvdztcbiAgICAgICAgICBzZWxmLl9pbWFnZUhlaWdodCA9IG9oO1xuICAgICAgICAgIHNlbGYuX2ltYWdlU3JjID0gaW1hZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdG1wSW1hZ2Uuc3JjID0gaW1hZ2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWFnZUVMU3R5bGUud2lkdGggPSByb3VuZChzY2FsZVggKiBvdyAqIGR3IC8gc3cpICsgJ3B4JztcbiAgICAgICAgaW1hZ2VFTFN0eWxlLmhlaWdodCA9IHJvdW5kKHNjYWxlWSAqIG9oICogZGggLyBzaCkgKyAncHgnO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNyb3BFbCkge1xuICAgICAgICBjcm9wRWwgPSB2bWxDb3JlLmRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY3JvcEVsLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIHRoaXMuX2Nyb3BFbCA9IGNyb3BFbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNyb3BFbFN0eWxlID0gY3JvcEVsLnN0eWxlO1xuICAgICAgY3JvcEVsU3R5bGUud2lkdGggPSByb3VuZCgoZHcgKyBzeCAqIGR3IC8gc3cpICogc2NhbGVYKTtcbiAgICAgIGNyb3BFbFN0eWxlLmhlaWdodCA9IHJvdW5kKChkaCArIHN5ICogZGggLyBzaCkgKiBzY2FsZVkpO1xuICAgICAgY3JvcEVsU3R5bGUuZmlsdGVyID0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLk1hdHJpeChEeD0nICsgLXN4ICogZHcgLyBzdyAqIHNjYWxlWCArICcsRHk9JyArIC1zeSAqIGRoIC8gc2ggKiBzY2FsZVkgKyAnKSc7XG5cbiAgICAgIGlmICghY3JvcEVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdm1sRWwuYXBwZW5kQ2hpbGQoY3JvcEVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGltYWdlRWwucGFyZW50Tm9kZSAhPSBjcm9wRWwpIHtcbiAgICAgICAgY3JvcEVsLmFwcGVuZENoaWxkKGltYWdlRWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbWFnZUVMU3R5bGUud2lkdGggPSByb3VuZChzY2FsZVggKiBkdykgKyAncHgnO1xuICAgICAgaW1hZ2VFTFN0eWxlLmhlaWdodCA9IHJvdW5kKHNjYWxlWSAqIGRoKSArICdweCc7XG4gICAgICB2bWxFbC5hcHBlbmRDaGlsZChpbWFnZUVsKTtcblxuICAgICAgaWYgKGNyb3BFbCAmJiBjcm9wRWwucGFyZW50Tm9kZSkge1xuICAgICAgICB2bWxFbC5yZW1vdmVDaGlsZChjcm9wRWwpO1xuICAgICAgICB0aGlzLl9jcm9wRWwgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaWx0ZXJTdHIgPSAnJztcbiAgICB2YXIgYWxwaGEgPSBzdHlsZS5vcGFjaXR5O1xuXG4gICAgaWYgKGFscGhhIDwgMSkge1xuICAgICAgZmlsdGVyU3RyICs9ICcuQWxwaGEob3BhY2l0eT0nICsgcm91bmQoYWxwaGEgKiAxMDApICsgJykgJztcbiAgICB9XG5cbiAgICBmaWx0ZXJTdHIgKz0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLkFscGhhSW1hZ2VMb2FkZXIoc3JjPScgKyBpbWFnZSArICcsIFNpemluZ01ldGhvZD1zY2FsZSknO1xuICAgIGltYWdlRUxTdHlsZS5maWx0ZXIgPSBmaWx0ZXJTdHI7XG4gICAgdm1sRWwuc3R5bGUuekluZGV4ID0gZ2V0WkluZGV4KHRoaXMuemxldmVsLCB0aGlzLnosIHRoaXMuejIpOyAvLyBBcHBlbmQgdG8gcm9vdFxuXG4gICAgYXBwZW5kKHZtbFJvb3QsIHZtbEVsKTsgLy8gVGV4dFxuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQodm1sUm9vdCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgfVxuICB9O1xuXG4gIFpJbWFnZS5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHJlbW92ZSh2bWxSb290LCB0aGlzLl92bWxFbCk7XG4gICAgdGhpcy5fdm1sRWwgPSBudWxsO1xuICAgIHRoaXMuX2Nyb3BFbCA9IG51bGw7XG4gICAgdGhpcy5faW1hZ2VFbCA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgfTtcblxuICBaSW1hZ2UucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICBhcHBlbmQodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogVEVYVFxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICB2YXIgREVGQVVMVF9TVFlMRV9OT1JNQUwgPSAnbm9ybWFsJztcbiAgdmFyIGZvbnRTdHlsZUNhY2hlID0ge307XG4gIHZhciBmb250U3R5bGVDYWNoZUNvdW50ID0gMDtcbiAgdmFyIE1BWF9GT05UX0NBQ0hFX1NJWkUgPSAxMDA7XG4gIHZhciBmb250RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICB2YXIgZ2V0Rm9udFN0eWxlID0gZnVuY3Rpb24gKGZvbnRTdHJpbmcpIHtcbiAgICB2YXIgZm9udFN0eWxlID0gZm9udFN0eWxlQ2FjaGVbZm9udFN0cmluZ107XG5cbiAgICBpZiAoIWZvbnRTdHlsZSkge1xuICAgICAgLy8gQ2xlYXIgY2FjaGVcbiAgICAgIGlmIChmb250U3R5bGVDYWNoZUNvdW50ID4gTUFYX0ZPTlRfQ0FDSEVfU0laRSkge1xuICAgICAgICBmb250U3R5bGVDYWNoZUNvdW50ID0gMDtcbiAgICAgICAgZm9udFN0eWxlQ2FjaGUgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlID0gZm9udEVsLnN0eWxlO1xuICAgICAgdmFyIGZvbnRGYW1pbHk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0eWxlLmZvbnQgPSBmb250U3RyaW5nO1xuICAgICAgICBmb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseS5zcGxpdCgnLCcpWzBdO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgZm9udFN0eWxlID0ge1xuICAgICAgICBzdHlsZTogc3R5bGUuZm9udFN0eWxlIHx8IERFRkFVTFRfU1RZTEVfTk9STUFMLFxuICAgICAgICB2YXJpYW50OiBzdHlsZS5mb250VmFyaWFudCB8fCBERUZBVUxUX1NUWUxFX05PUk1BTCxcbiAgICAgICAgd2VpZ2h0OiBzdHlsZS5mb250V2VpZ2h0IHx8IERFRkFVTFRfU1RZTEVfTk9STUFMLFxuICAgICAgICBzaXplOiBwYXJzZUZsb2F0KHN0eWxlLmZvbnRTaXplIHx8IDEyKSB8IDAsXG4gICAgICAgIGZhbWlseTogZm9udEZhbWlseSB8fCAnTWljcm9zb2Z0IFlhSGVpJ1xuICAgICAgfTtcbiAgICAgIGZvbnRTdHlsZUNhY2hlW2ZvbnRTdHJpbmddID0gZm9udFN0eWxlO1xuICAgICAgZm9udFN0eWxlQ2FjaGVDb3VudCsrO1xuICAgIH1cblxuICAgIHJldHVybiBmb250U3R5bGU7XG4gIH07XG5cbiAgdmFyIHRleHRNZWFzdXJlRWw7IC8vIE92ZXJ3cml0ZSBtZWFzdXJlIHRleHQgbWV0aG9kXG5cbiAgdGV4dENvbnRhaW4uJG92ZXJyaWRlKCdtZWFzdXJlVGV4dCcsIGZ1bmN0aW9uICh0ZXh0LCB0ZXh0Rm9udCkge1xuICAgIHZhciBkb2MgPSB2bWxDb3JlLmRvYztcblxuICAgIGlmICghdGV4dE1lYXN1cmVFbCkge1xuICAgICAgdGV4dE1lYXN1cmVFbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRleHRNZWFzdXJlRWwuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTIwMDAwcHg7bGVmdDowOycgKyAncGFkZGluZzowO21hcmdpbjowO2JvcmRlcjpub25lO3doaXRlLXNwYWNlOnByZTsnO1xuICAgICAgdm1sQ29yZS5kb2MuYm9keS5hcHBlbmRDaGlsZCh0ZXh0TWVhc3VyZUVsKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGV4dE1lYXN1cmVFbC5zdHlsZS5mb250ID0gdGV4dEZvbnQ7XG4gICAgfSBjYXRjaCAoZXgpIHsvLyBJZ25vcmUgZmFpbHVyZXMgdG8gc2V0IHRvIGludmFsaWQgZm9udC5cbiAgICB9XG5cbiAgICB0ZXh0TWVhc3VyZUVsLmlubmVySFRNTCA9ICcnOyAvLyBEb24ndCB1c2UgaW5uZXJIVE1MIG9yIGlubmVyVGV4dCBiZWNhdXNlIHRoZXkgYWxsb3cgbWFya3VwL3doaXRlc3BhY2UuXG5cbiAgICB0ZXh0TWVhc3VyZUVsLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0ZXh0TWVhc3VyZUVsLm9mZnNldFdpZHRoXG4gICAgfTtcbiAgfSk7XG4gIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgpO1xuXG4gIHZhciBkcmF3UmVjdFRleHQgPSBmdW5jdGlvbiAodm1sUm9vdCwgcmVjdCwgdGV4dFJlY3QsIGZyb21UZXh0RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlOyAvLyBPcHRpbWl6ZSwgYXZvaWQgbm9ybWFsaXplIGV2ZXJ5IHRpbWUuXG5cbiAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpO1xuICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDsgLy8gQ29udmVydCB0byBzdHJpbmdcblxuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENvbnZlcnQgcmljaCB0ZXh0IHRvIHBsYWluIHRleHQuIFJpY2ggdGV4dCBpcyBub3Qgc3VwcG9ydGVkIGluXG4gICAgLy8gSUU4LSwgYnV0IHRhZ3MgaW4gcmljaCB0ZXh0IHRlbXBsYXRlIHdpbGwgYmUgcmVtb3ZlZC5cblxuXG4gICAgaWYgKHN0eWxlLnJpY2gpIHtcbiAgICAgIHZhciBjb250ZW50QmxvY2sgPSB0ZXh0Q29udGFpbi5wYXJzZVJpY2hUZXh0KHRleHQsIHN0eWxlKTtcbiAgICAgIHRleHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QmxvY2subGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VucyA9IGNvbnRlbnRCbG9jay5saW5lc1tpXS50b2tlbnM7XG4gICAgICAgIHZhciB0ZXh0TGluZSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdGV4dExpbmUucHVzaCh0b2tlbnNbal0udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0LnB1c2godGV4dExpbmUuam9pbignJykpO1xuICAgICAgfVxuXG4gICAgICB0ZXh0ID0gdGV4dC5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICB2YXIgeDtcbiAgICB2YXIgeTtcbiAgICB2YXIgYWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gICAgdmFyIHZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbjtcbiAgICB2YXIgZm9udFN0eWxlID0gZ2V0Rm9udFN0eWxlKHN0eWxlLmZvbnQpOyAvLyBGSVhNRSBlbmNvZGVIdG1sQXR0cmlidXRlID9cblxuICAgIHZhciBmb250ID0gZm9udFN0eWxlLnN0eWxlICsgJyAnICsgZm9udFN0eWxlLnZhcmlhbnQgKyAnICcgKyBmb250U3R5bGUud2VpZ2h0ICsgJyAnICsgZm9udFN0eWxlLnNpemUgKyAncHggXCInICsgZm9udFN0eWxlLmZhbWlseSArICdcIic7XG4gICAgdGV4dFJlY3QgPSB0ZXh0UmVjdCB8fCB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgYWxpZ24sIHZlcnRpY2FsQWxpZ24pOyAvLyBUcmFuc2Zvcm0gcmVjdCB0byB2aWV3IHNwYWNlXG5cbiAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtOyAvLyBJZ25vcmUgdHJhbnNmb3JtIGZvciB0ZXh0IGluIG90aGVyIGVsZW1lbnRcblxuICAgIGlmIChtICYmICFmcm9tVGV4dEVsKSB7XG4gICAgICB0bXBSZWN0LmNvcHkocmVjdCk7XG4gICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKG0pO1xuICAgICAgcmVjdCA9IHRtcFJlY3Q7XG4gICAgfVxuXG4gICAgaWYgKCFmcm9tVGV4dEVsKSB7XG4gICAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuICAgICAgdmFyIGRpc3RhbmNlID0gc3R5bGUudGV4dERpc3RhbmNlOyAvLyBUZXh0IHBvc2l0aW9uIHJlcHJlc2VudGVkIGJ5IGNvb3JkXG5cbiAgICAgIGlmICh0ZXh0UG9zaXRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB4ID0gcmVjdC54ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblswXSwgcmVjdC53aWR0aCk7XG4gICAgICAgIHkgPSByZWN0LnkgKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzFdLCByZWN0LmhlaWdodCk7XG4gICAgICAgIGFsaWduID0gYWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlcyA9IHRleHRDb250YWluLmFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIGRpc3RhbmNlKTtcbiAgICAgICAgeCA9IHJlcy54O1xuICAgICAgICB5ID0gcmVzLnk7IC8vIERlZmF1bHQgYWxpZ24gYW5kIGJhc2VsaW5lIHdoZW4gaGFzIHRleHRQb3NpdGlvblxuXG4gICAgICAgIGFsaWduID0gYWxpZ24gfHwgcmVzLnRleHRBbGlnbjtcbiAgICAgICAgdmVydGljYWxBbGlnbiA9IHZlcnRpY2FsQWxpZ24gfHwgcmVzLnRleHRWZXJ0aWNhbEFsaWduO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gcmVjdC54O1xuICAgICAgeSA9IHJlY3QueTtcbiAgICB9XG5cbiAgICB4ID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFgoeCwgdGV4dFJlY3Qud2lkdGgsIGFsaWduKTtcbiAgICB5ID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFkoeSwgdGV4dFJlY3QuaGVpZ2h0LCB2ZXJ0aWNhbEFsaWduKTsgLy8gRm9yY2UgYmFzZWxpbmUgJ21pZGRsZSdcblxuICAgIHkgKz0gdGV4dFJlY3QuaGVpZ2h0IC8gMjsgLy8gdmFyIGZvbnRTaXplID0gZm9udFN0eWxlLnNpemU7XG4gICAgLy8gMS43NSBpcyBhbiBhcmJpdHJhcnkgbnVtYmVyLCBhcyB0aGVyZSBpcyBubyBpbmZvIGFib3V0IHRoZSB0ZXh0IGJhc2VsaW5lXG4gICAgLy8gc3dpdGNoIChiYXNlbGluZSkge1xuICAgIC8vIGNhc2UgJ2hhbmdpbmcnOlxuICAgIC8vIGNhc2UgJ3RvcCc6XG4gICAgLy8gICAgIHkgKz0gZm9udFNpemUgLyAxLjc1O1xuICAgIC8vICAgICBicmVhaztcbiAgICAvLyAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAvLyAgICAgICAgIGJyZWFrO1xuICAgIC8vICAgICBkZWZhdWx0OlxuICAgIC8vICAgICAvLyBjYXNlIG51bGw6XG4gICAgLy8gICAgIC8vIGNhc2UgJ2FscGhhYmV0aWMnOlxuICAgIC8vICAgICAvLyBjYXNlICdpZGVvZ3JhcGhpYyc6XG4gICAgLy8gICAgIC8vIGNhc2UgJ2JvdHRvbSc6XG4gICAgLy8gICAgICAgICB5IC09IGZvbnRTaXplIC8gMi4yNTtcbiAgICAvLyAgICAgICAgIGJyZWFrO1xuICAgIC8vIH1cbiAgICAvLyBzd2l0Y2ggKGFsaWduKSB7XG4gICAgLy8gICAgIGNhc2UgJ2xlZnQnOlxuICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgLy8gICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgLy8gICAgICAgICB4IC09IHRleHRSZWN0LndpZHRoIC8gMjtcbiAgICAvLyAgICAgICAgIGJyZWFrO1xuICAgIC8vICAgICBjYXNlICdyaWdodCc6XG4gICAgLy8gICAgICAgICB4IC09IHRleHRSZWN0LndpZHRoO1xuICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgLy8gY2FzZSAnZW5kJzpcbiAgICAvLyBhbGlnbiA9IGVsZW1lbnRTdHlsZS5kaXJlY3Rpb24gPT0gJ2x0cicgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIC8vIGJyZWFrO1xuICAgIC8vIGNhc2UgJ3N0YXJ0JzpcbiAgICAvLyBhbGlnbiA9IGVsZW1lbnRTdHlsZS5kaXJlY3Rpb24gPT0gJ3J0bCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIC8vIGJyZWFrO1xuICAgIC8vIGRlZmF1bHQ6XG4gICAgLy8gICAgIGFsaWduID0gJ2xlZnQnO1xuICAgIC8vIH1cblxuICAgIHZhciBjcmVhdGVOb2RlID0gdm1sQ29yZS5jcmVhdGVOb2RlO1xuICAgIHZhciB0ZXh0Vm1sRWwgPSB0aGlzLl90ZXh0Vm1sRWw7XG4gICAgdmFyIHBhdGhFbDtcbiAgICB2YXIgdGV4dFBhdGhFbDtcbiAgICB2YXIgc2tld0VsO1xuXG4gICAgaWYgKCF0ZXh0Vm1sRWwpIHtcbiAgICAgIHRleHRWbWxFbCA9IGNyZWF0ZU5vZGUoJ2xpbmUnKTtcbiAgICAgIHBhdGhFbCA9IGNyZWF0ZU5vZGUoJ3BhdGgnKTtcbiAgICAgIHRleHRQYXRoRWwgPSBjcmVhdGVOb2RlKCd0ZXh0cGF0aCcpO1xuICAgICAgc2tld0VsID0gY3JlYXRlTm9kZSgnc2tldycpOyAvLyBGSVhNRSBXaHkgaGVyZSBpcyBub3QgY2FtbWVsIGNhc2VcbiAgICAgIC8vIEFsaWduICdjZW50ZXInIHNlZW1zIHdyb25nXG5cbiAgICAgIHRleHRQYXRoRWwuc3R5bGVbJ3YtdGV4dC1hbGlnbiddID0gJ2xlZnQnO1xuICAgICAgaW5pdFJvb3RFbFN0eWxlKHRleHRWbWxFbCk7XG4gICAgICBwYXRoRWwudGV4dHBhdGhvayA9IHRydWU7XG4gICAgICB0ZXh0UGF0aEVsLm9uID0gdHJ1ZTtcbiAgICAgIHRleHRWbWxFbC5mcm9tID0gJzAgMCc7XG4gICAgICB0ZXh0Vm1sRWwudG8gPSAnMTAwMCAwLjA1JztcbiAgICAgIGFwcGVuZCh0ZXh0Vm1sRWwsIHNrZXdFbCk7XG4gICAgICBhcHBlbmQodGV4dFZtbEVsLCBwYXRoRWwpO1xuICAgICAgYXBwZW5kKHRleHRWbWxFbCwgdGV4dFBhdGhFbCk7XG4gICAgICB0aGlzLl90ZXh0Vm1sRWwgPSB0ZXh0Vm1sRWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIOi/memHjOaYr+WcqOWJjemdoiBhcHBlbmRDaGlsZCDkv53or4Hpobrluo/nmoTliY3mj5DkuItcbiAgICAgIHNrZXdFbCA9IHRleHRWbWxFbC5maXJzdENoaWxkO1xuICAgICAgcGF0aEVsID0gc2tld0VsLm5leHRTaWJsaW5nO1xuICAgICAgdGV4dFBhdGhFbCA9IHBhdGhFbC5uZXh0U2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY29vcmRzID0gW3gsIHldO1xuICAgIHZhciB0ZXh0Vm1sRWxTdHlsZSA9IHRleHRWbWxFbC5zdHlsZTsgLy8gSWdub3JlIHRyYW5zZm9ybSBmb3IgdGV4dCBpbiBvdGhlciBlbGVtZW50XG5cbiAgICBpZiAobSAmJiBmcm9tVGV4dEVsKSB7XG4gICAgICBhcHBseVRyYW5zZm9ybShjb29yZHMsIGNvb3JkcywgbSk7XG4gICAgICBza2V3RWwub24gPSB0cnVlO1xuICAgICAgc2tld0VsLm1hdHJpeCA9IG1bMF0udG9GaXhlZCgzKSArIGNvbW1hICsgbVsyXS50b0ZpeGVkKDMpICsgY29tbWEgKyBtWzFdLnRvRml4ZWQoMykgKyBjb21tYSArIG1bM10udG9GaXhlZCgzKSArICcsMCwwJzsgLy8gVGV4dCBwb3NpdGlvblxuXG4gICAgICBza2V3RWwub2Zmc2V0ID0gKHJvdW5kKGNvb3Jkc1swXSkgfHwgMCkgKyAnLCcgKyAocm91bmQoY29vcmRzWzFdKSB8fCAwKTsgLy8gTGVmdCB0b3AgcG9pbnQgYXMgb3JpZ2luXG5cbiAgICAgIHNrZXdFbC5vcmlnaW4gPSAnMCAwJztcbiAgICAgIHRleHRWbWxFbFN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgIHRleHRWbWxFbFN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBza2V3RWwub24gPSBmYWxzZTtcbiAgICAgIHRleHRWbWxFbFN0eWxlLmxlZnQgPSByb3VuZCh4KSArICdweCc7XG4gICAgICB0ZXh0Vm1sRWxTdHlsZS50b3AgPSByb3VuZCh5KSArICdweCc7XG4gICAgfVxuXG4gICAgdGV4dFBhdGhFbC5zdHJpbmcgPSBlbmNvZGVIdG1sQXR0cmlidXRlKHRleHQpOyAvLyBUT0RPXG5cbiAgICB0cnkge1xuICAgICAgdGV4dFBhdGhFbC5zdHlsZS5mb250ID0gZm9udDtcbiAgICB9IC8vIEVycm9yIGZvbnQgZm9ybWF0XG4gICAgY2F0Y2ggKGUpIHt9XG5cbiAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHRleHRWbWxFbCwgJ2ZpbGwnLCB7XG4gICAgICBmaWxsOiBzdHlsZS50ZXh0RmlsbCxcbiAgICAgIG9wYWNpdHk6IHN0eWxlLm9wYWNpdHlcbiAgICB9LCB0aGlzKTtcbiAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHRleHRWbWxFbCwgJ3N0cm9rZScsIHtcbiAgICAgIHN0cm9rZTogc3R5bGUudGV4dFN0cm9rZSxcbiAgICAgIG9wYWNpdHk6IHN0eWxlLm9wYWNpdHksXG4gICAgICBsaW5lRGFzaDogc3R5bGUubGluZURhc2hcbiAgICB9LCB0aGlzKTtcbiAgICB0ZXh0Vm1sRWwuc3R5bGUuekluZGV4ID0gZ2V0WkluZGV4KHRoaXMuemxldmVsLCB0aGlzLnosIHRoaXMuejIpOyAvLyBBdHRhY2hlZCB0byByb290XG5cbiAgICBhcHBlbmQodm1sUm9vdCwgdGV4dFZtbEVsKTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlUmVjdFRleHQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHJlbW92ZSh2bWxSb290LCB0aGlzLl90ZXh0Vm1sRWwpO1xuICAgIHRoaXMuX3RleHRWbWxFbCA9IG51bGw7XG4gIH07XG5cbiAgdmFyIGFwcGVuZFJlY3RUZXh0ID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICBhcHBlbmQodm1sUm9vdCwgdGhpcy5fdGV4dFZtbEVsKTtcbiAgfTtcblxuICB2YXIgbGlzdCA9IFtSZWN0VGV4dCwgRGlzcGxheWFibGUsIFpJbWFnZSwgUGF0aCwgVGV4dF07IC8vIEluIGNhc2UgRGlzcGxheWFibGUgaGFzIGJlZW4gbWl4ZWQgaW4gUmVjdFRleHRcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvdG8gPSBsaXN0W2ldLnByb3RvdHlwZTtcbiAgICBwcm90by5kcmF3UmVjdFRleHQgPSBkcmF3UmVjdFRleHQ7XG4gICAgcHJvdG8ucmVtb3ZlUmVjdFRleHQgPSByZW1vdmVSZWN0VGV4dDtcbiAgICBwcm90by5hcHBlbmRSZWN0VGV4dCA9IGFwcGVuZFJlY3RUZXh0O1xuICB9XG5cbiAgVGV4dC5wcm90b3R5cGUuYnJ1c2hWTUwgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRyYXdSZWN0VGV4dCh2bWxSb290LCB7XG4gICAgICAgIHg6IHN0eWxlLnggfHwgMCxcbiAgICAgICAgeTogc3R5bGUueSB8fCAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgICB9XG4gIH07XG5cbiAgVGV4dC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG5cbiAgVGV4dC5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3ZtbC9ncmFwaGljLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVudiA9IHJlcXVpcmUoXCIuLi9jb3JlL2VudlwiKTtcblxudmFyIHVybiA9ICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCc7XG52YXIgd2luID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93O1xudmFyIHZtbEluaXRlZCA9IGZhbHNlO1xudmFyIGRvYyA9IHdpbiAmJiB3aW4uZG9jdW1lbnQ7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUodGFnTmFtZSkge1xuICByZXR1cm4gZG9DcmVhdGVOb2RlKHRhZ05hbWUpO1xufSAvLyBBdm9pZCBhc3NpZ24gdG8gYW4gZXhwb3J0ZWQgdmFyaWFibGUsIGZvciB0cmFuc2Zvcm1pbmcgdG8gY2pzLlxuXG5cbnZhciBkb0NyZWF0ZU5vZGU7XG5cbmlmIChkb2MgJiYgIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgdHJ5IHtcbiAgICAhZG9jLm5hbWVzcGFjZXMuenJ2bWwgJiYgZG9jLm5hbWVzcGFjZXMuYWRkKCd6cnZtbCcsIHVybik7XG5cbiAgICBkb0NyZWF0ZU5vZGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KCc8enJ2bWw6JyArIHRhZ05hbWUgKyAnIGNsYXNzPVwienJ2bWxcIj4nKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgZG9DcmVhdGVOb2RlID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICAgIHJldHVybiBkb2MuY3JlYXRlRWxlbWVudCgnPCcgKyB0YWdOYW1lICsgJyB4bWxucz1cIicgKyB1cm4gKyAnXCIgY2xhc3M9XCJ6cnZtbFwiPicpO1xuICAgIH07XG4gIH1cbn0gLy8gRnJvbSByYXBoYWVsXG5cblxuZnVuY3Rpb24gaW5pdFZNTCgpIHtcbiAgaWYgKHZtbEluaXRlZCB8fCAhZG9jKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdm1sSW5pdGVkID0gdHJ1ZTtcbiAgdmFyIHN0eWxlU2hlZXRzID0gZG9jLnN0eWxlU2hlZXRzO1xuXG4gIGlmIChzdHlsZVNoZWV0cy5sZW5ndGggPCAzMSkge1xuICAgIGRvYy5jcmVhdGVTdHlsZVNoZWV0KCkuYWRkUnVsZSgnLnpydm1sJywgJ2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpJyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMxMTk0JTI4VlMuODUlMjkuYXNweFxuICAgIHN0eWxlU2hlZXRzWzBdLmFkZFJ1bGUoJy56cnZtbCcsICdiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKScpO1xuICB9XG59XG5cbmV4cG9ydHMuZG9jID0gZG9jO1xuZXhwb3J0cy5jcmVhdGVOb2RlID0gY3JlYXRlTm9kZTtcbmV4cG9ydHMuaW5pdFZNTCA9IGluaXRWTUw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3ZtbC9jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHpyTG9nID0gcmVxdWlyZShcIi4uL2NvcmUvbG9nXCIpO1xuXG52YXIgdm1sQ29yZSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBlYWNoID0gX3V0aWwuZWFjaDtcblxuLyoqXG4gKiBWTUwgUGFpbnRlci5cbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvdm1sL1BhaW50ZXJcbiAqL1xuZnVuY3Rpb24gcGFyc2VJbnQxMCh2YWwpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvdm1sL1BhaW50ZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIFZNTFBhaW50ZXIocm9vdCwgc3RvcmFnZSkge1xuICB2bWxDb3JlLmluaXRWTUwoKTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdmFyIHZtbFZpZXdwb3J0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciB2bWxSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZtbFZpZXdwb3J0LnN0eWxlLmNzc1RleHQgPSAnZGlzcGxheTppbmxpbmUtYmxvY2s7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjMwMHB4O2hlaWdodDoxNTBweDsnO1xuICB2bWxSb290LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowOyc7XG4gIHJvb3QuYXBwZW5kQ2hpbGQodm1sVmlld3BvcnQpO1xuICB0aGlzLl92bWxSb290ID0gdm1sUm9vdDtcbiAgdGhpcy5fdm1sVmlld3BvcnQgPSB2bWxWaWV3cG9ydDtcbiAgdGhpcy5yZXNpemUoKTsgLy8gTW9kaWZ5IHN0b3JhZ2VcblxuICB2YXIgb2xkRGVsRnJvbVN0b3JhZ2UgPSBzdG9yYWdlLmRlbEZyb21TdG9yYWdlO1xuICB2YXIgb2xkQWRkVG9TdG9yYWdlID0gc3RvcmFnZS5hZGRUb1N0b3JhZ2U7XG5cbiAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIG9sZERlbEZyb21TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5vblJlbW92ZSAmJiBlbC5vblJlbW92ZSh2bWxSb290KTtcbiAgICB9XG4gIH07XG5cbiAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAvLyBEaXNwbGF5YWJsZSBhbHJlYWR5IGhhcyBhIHZtbCBub2RlXG4gICAgZWwub25BZGQgJiYgZWwub25BZGQodm1sUm9vdCk7XG4gICAgb2xkQWRkVG9TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuICB9O1xuXG4gIHRoaXMuX2ZpcnN0UGFpbnQgPSB0cnVlO1xufVxuXG5WTUxQYWludGVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFZNTFBhaW50ZXIsXG4gIGdldFR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ3ZtbCc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZtbFZpZXdwb3J0O1xuICB9LFxuICBnZXRWaWV3cG9ydFJvb3RPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmlld3BvcnRSb290ID0gdGhpcy5nZXRWaWV3cG9ydFJvb3QoKTtcblxuICAgIGlmICh2aWV3cG9ydFJvb3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9mZnNldExlZnQ6IHZpZXdwb3J0Um9vdC5vZmZzZXRMZWZ0IHx8IDAsXG4gICAgICAgIG9mZnNldFRvcDogdmlld3BvcnRSb290Lm9mZnNldFRvcCB8fCAwXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yi35pawXG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLl9wYWludExpc3QobGlzdCk7XG4gIH0sXG4gIF9wYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgdmFyIHZtbFJvb3QgPSB0aGlzLl92bWxSb290O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWwgPSBsaXN0W2ldO1xuXG4gICAgICBpZiAoZWwuaW52aXNpYmxlIHx8IGVsLmlnbm9yZSkge1xuICAgICAgICBpZiAoIWVsLl9fYWxyZWFkeU5vdFZpc2libGUpIHtcbiAgICAgICAgICBlbC5vblJlbW92ZSh2bWxSb290KTtcbiAgICAgICAgfSAvLyBTZXQgYXMgYWxyZWFkeSBpbnZpc2libGVcblxuXG4gICAgICAgIGVsLl9fYWxyZWFkeU5vdFZpc2libGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsLl9fYWxyZWFkeU5vdFZpc2libGUpIHtcbiAgICAgICAgICBlbC5vbkFkZCh2bWxSb290KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLl9fYWxyZWFkeU5vdFZpc2libGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgICAgIGVsLmJlZm9yZUJydXNoICYmIGVsLmJlZm9yZUJydXNoKCk7XG4gICAgICAgICAgKGVsLmJydXNoVk1MIHx8IGVsLmJydXNoKS5jYWxsKGVsLCB2bWxSb290KTtcbiAgICAgICAgICBlbC5hZnRlckJydXNoICYmIGVsLmFmdGVyQnJ1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZpcnN0UGFpbnQpIHtcbiAgICAgIC8vIERldGFjaGVkIGZyb20gZG9jdW1lbnQgYXQgZmlyc3QgdGltZVxuICAgICAgLy8gdG8gYXZvaWQgcGFnZSByZWZyZXNoaW5nIHRvbyBtYW55IHRpbWVzXG4gICAgICAvLyBGSVhNRSDlpoLmnpzmr4/mrKHpg73lhYggcmVtb3ZlQ2hpbGQg5Y+v6IO95Lya5a+86Ie05LiA5Lqb5aGr5YWF5ZKM5o+P6L6555qE5pWI5p6c5pS55Y+YXG4gICAgICB0aGlzLl92bWxWaWV3cG9ydC5hcHBlbmRDaGlsZCh2bWxSb290KTtcblxuICAgICAgdGhpcy5fZmlyc3RQYWludCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciB3aWR0aCA9IHdpZHRoID09IG51bGwgPyB0aGlzLl9nZXRXaWR0aCgpIDogd2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGhlaWdodCA9PSBudWxsID8gdGhpcy5fZ2V0SGVpZ2h0KCkgOiBoZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5fd2lkdGggIT0gd2lkdGggfHwgdGhpcy5faGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgIHZhciB2bWxWaWV3cG9ydFN0eWxlID0gdGhpcy5fdm1sVmlld3BvcnQuc3R5bGU7XG4gICAgICB2bWxWaWV3cG9ydFN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgdm1sVmlld3BvcnRTdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgfSxcbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucm9vdC5pbm5lckhUTUwgPSAnJztcbiAgICB0aGlzLl92bWxSb290ID0gdGhpcy5fdm1sVmlld3BvcnQgPSB0aGlzLnN0b3JhZ2UgPSBudWxsO1xuICB9LFxuICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgfSxcbiAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgfSxcbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fdm1sVmlld3BvcnQpIHtcbiAgICAgIHRoaXMucm9vdC5yZW1vdmVDaGlsZCh0aGlzLl92bWxWaWV3cG9ydCk7XG4gICAgfVxuICB9LFxuICBfZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICB2YXIgc3RsID0gcm9vdC5jdXJyZW50U3R5bGU7XG4gICAgcmV0dXJuIChyb290LmNsaWVudFdpZHRoIHx8IHBhcnNlSW50MTAoc3RsLndpZHRoKSkgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nTGVmdCkgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nUmlnaHQpIHwgMDtcbiAgfSxcbiAgX2dldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgIHZhciBzdGwgPSByb290LmN1cnJlbnRTdHlsZTtcbiAgICByZXR1cm4gKHJvb3QuY2xpZW50SGVpZ2h0IHx8IHBhcnNlSW50MTAoc3RsLmhlaWdodCkpIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ1RvcCkgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nQm90dG9tKSB8IDA7XG4gIH1cbn07IC8vIE5vdCBzdXBwb3J0ZWQgbWV0aG9kc1xuXG5mdW5jdGlvbiBjcmVhdGVNZXRob2ROb3RTdXBwb3J0KG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHpyTG9nKCdJbiBJRTguMCBWTUwgbW9kZSBwYWludGVyIG5vdCBzdXBwb3J0IG1ldGhvZCBcIicgKyBtZXRob2QgKyAnXCInKTtcbiAgfTtcbn0gLy8gVW5zdXBwb3J0ZWQgbWV0aG9kc1xuXG5cbmVhY2goWydnZXRMYXllcicsICdpbnNlcnRMYXllcicsICdlYWNoTGF5ZXInLCAnZWFjaEJ1aWx0aW5MYXllcicsICdlYWNoT3RoZXJMYXllcicsICdnZXRMYXllcnMnLCAnbW9kTGF5ZXInLCAnZGVsTGF5ZXInLCAnY2xlYXJMYXllcicsICd0b0RhdGFVUkwnLCAncGF0aFRvSW1hZ2UnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgVk1MUGFpbnRlci5wcm90b3R5cGVbbmFtZV0gPSBjcmVhdGVNZXRob2ROb3RTdXBwb3J0KG5hbWUpO1xufSk7XG52YXIgX2RlZmF1bHQgPSBWTUxQYWludGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvdm1sL1BhaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9