(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["fishTopoBpmn"] = factory();
	else
		root["fishTopoBpmn"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Export fishTopo as CommonJS module
	 */
	module.exports = __webpack_require__(2);
	//兼容IE8 引入VML 如果不需要兼容IE8请删除
	__webpack_require__(159);
	


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * BPMN对象
	 * @class fish.topo.FishTopoBpmn
	 */
	
	/**
	 * @event click
	 * 节点或者线段的click事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *      this.fishTopoBpmn.on("click",function(e) {
	    *          var target = e.target;
	    *          if(FishTopoBpmn.Bpmn.isFlow(target)) { //判断类型
	    *              var lineNode = e.target;
	    *              that.fishTopoBpmn.bindLineDelete(lineNode); //给线段增加删除图标
	    *              //todo
	    *          }
	    *      }
	    */
	
	   /**
	    * @event dblclick
	    * 节点或者线段的双击事件
	    * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	    *
	    * **使用范例**：
	    *
	    *      @example
	    *          //双击弹出节点对应的json
	    *          this.fishTopoBpmn.on("dblclick",function(e) {
	    *              var target = e.target;
	    *
	    *              if(FishTopoBpmn.Bpmn.isFlow(target)) {
	    *                  console.log("dblclick line");
	    *              }
	    *              else{
	    *                  var json = nodeModel.option;
	    *                  fish.popupView({
	    *                      url: "views/dialog/ExportJsonDlg.js",
	    *                      viewOption:{bpmnJson:JSON.stringify(json,null,4)},
	    *                      callback: function(popup,view) {
	    *                          console.log("OK");
	    *                      },
	    *                      close: function(msg) {
	    *                          console.log("return value: " + msg);
	    *                      }
	    *                  });
	    *              }
	    *          });
	    */
	
	   /**
	    * @event create
	    * 节点与线段创建完毕的事件
	    * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	    *
	    * **使用范例**：
	    *
	    *      @example
	    *          this.fishTopoBpmn.on("create", function(e) {
	    *              if(FishTopoBpmn.Bpmn.isFlow(e.target)) {
	    *                  var line = e.target;
	    *                  console.log("连线创建完毕，从" + line.startNode.model.get("properties.name") + " 至 " + line.endNode.model.get("properties.name"));
	    *              } else {
	    *                  var node = e.target;
	    *                  console.log("节点：" + node.model.get("properties.name") + " 创建完毕");
	    *              }
	    *          });
	    */
	
	   /**
	    * @event delete
	    * 节点与线段删除完毕的事件
	    * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	    *
	    * **使用范例**：
	    *
	    *      @example
	    *          //节点删除完毕事件
	    *          this.fishTopoBpmn.on("delete", function(event) {
	    *              console.log("删除的是：" + event.target);
	    *          });
	    */
	
	   
	       var graphic = __webpack_require__(3);
	       var ExtensionAPI = __webpack_require__(63);
	       var Point = __webpack_require__(64);
	       var Eventful = __webpack_require__(11);
	       var zrender = __webpack_require__(65);
	       var zrUtil = __webpack_require__(4);
	       var BoundingRect = __webpack_require__(26);
	       var BpmnUtil = __webpack_require__(76);
	       var util = __webpack_require__(77);
	       var BPMNModel = __webpack_require__(82);
	       var BPMNNode = __webpack_require__(79);
	       var GroupNode = __webpack_require__(110);
	       var OperationNode = __webpack_require__(111);
	       var BpmnConnectionManager = __webpack_require__(114);
	       var Connector = __webpack_require__(105);
	       var textContain = __webpack_require__(25);
	       var LineOperationManager = __webpack_require__(117);
	       var Guidelines = __webpack_require__(118);
	       var promise = __webpack_require__(119);
	       var Bpmn = __webpack_require__(104);
	       var keyCode = {ENTER:13, ESCAPE:27};
	       __webpack_require__(158);
	       BpmnUtil.registerBPMNNode();
	
	       function FishTopoBpmn(dom, opts) {
	           this.id;
	           this.group;
	           this._dom = dom;
	           this._zr = zrender.init(dom, {
	               renderer: opts.renderer || 'canvas',
	               devicePixelRatio: opts.devicePixelRatio
	           });
	           this.allNodes = []; //存放所有节点
	           this.subProcessNode = [];  //存放子节点
	           this.domArray = []; //存放节点的位置信息，拖动的时候用到
	           this.overlapArray = []; // 存放节点的位置信息，判断重叠用到，除去了子流程里面的节点
	           this.selectedNode = null;  //选中的节点
	           this.isNode = false;
	           this.nowZoom = 1;
	           this.rect;  // 对齐线和移动框节点
	           this.operationNode;
	           this.step = 0;//前进后退计步数
	           this.stepJson = [];//存放每步的json
	           this.opts = opts;
	           this.selectedNodes = [];
	           this.lineOpt = {};  //初始的线段配置信息
	           this._api = new ExtensionAPI(this);
	           this.conPointsGroup = new graphic.Group();  //存放所有节点的连接点
	           this.conControlsGroup = new graphic.Group();  //存放所有节点的控制点
	           /**
	            * @cfg {Boolean} forbidEdit 是否禁用编辑功能
	            */
	           this.forbidEdit = opts.forbidEdit === undefined ? false : opts.forbidEdit;
	           this.mouseMode = 'default',                 //当前画布上鼠标的操作模式，default为正常点击、拖拽等操作，drag-select为框选操作
	           this.connectionManager = new BpmnConnectionManager();
	           this.lineOperationManager = new LineOperationManager(this.connectionManager,this._api);
	           this.model = new BPMNModel({});
	           this.model.set(Bpmn.RESOURCE_ID, util.getUUID());
	           this.model.set(Bpmn.BPMN_TYPE, Bpmn.TEMPLATE);
	           this.cursorMap = {
	               tl: 'nw-resize',
	               tr: 'ne-resize',
	               bl: 'sw-resize',
	               br: 'se-resize',
	               mtr:'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAAAYFBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD6T+iNAAAAH3RSTlMA7sUMoYXnEkYYzaaTjQiAQCweBcG7fvnULh2ZdjMy6Fzd7wAAALJJREFUGNN1kFkOwzAIBQHvW/Y6Sbfc/5Y1ltqoljIf2BohBA8qU096xeV5L/+uFH4SpsGAGSKmThCyMz64Ud38Te0meIpHcTP1ndTKvqzSUuQILFMQJAUwIngBLCd0UrJhSRGqzHHU3FcHBVMokqxS38YNGQLQbhmgZZ23sVEXnXVmS467Fq0892SSLaW5SHrN9rz9bXv9EHIB+E9pdMG7Ys48Z2cjxo7FL3k8kPIE13wAmEUIO2ML9YMAAAAASUVORK5CYII=) 10 10, auto'
	           }; // 节点控制点鼠标信息(上左，上右，下左，下右，旋转)
	           this.cursorMaps = [
	               'n-resize',
	               'ne-resize',
	               'e-resize',
	               'se-resize',
	               's-resize',
	               'sw-resize',
	               'w-resize',
	               'nw-resize'
	           ]
	           this.cursorOffset = {
	               tr: 1,
	               br: 3,
	               bl: 5,
	               tl: 7
	           }
	           Eventful.call(this);
	       }
	
	       var fishTopoProto = FishTopoBpmn.prototype;
	
	       /**
	        * 获取 fishTopo 实例容器的 dom 节点
	        * @return {HTMLElement}
	        */
	       fishTopoProto.getDom = function() {
	           return this._dom;
	       };
	
	       /**
	        * @private
	        */
	       fishTopoProto.getZr = function() {
	           return this._zr;
	       };
	       /**
	        * 获取 fishTopo 实例容器的宽度。
	        * @return {number}
	        */
	       fishTopoProto.getWidth = function() {
	           return this._zr.getWidth();
	       };
	
	       /**
	        * 获取 fishTopo 实例容器的高度。
	        * @return {number}
	        */
	       fishTopoProto.getHeight = function() {
	           return this._zr.getHeight();
	       };
	
	
	       /**
	        * 当前实例是否已经被释放。
	        * @return {boolean}
	        */
	       fishTopoProto.isDisposed = function() {
	           return this._disposed;
	       };
	
	       /**
	        * Dispose instance
	        */
	       fishTopoProto.dispose = function() {
	           this._disposed = true;
	
	           this._zr.dispose();
	
	           instances[this.id] = null;
	       };
	
	
	       /**
	        * 调整尺寸  在窗口大小发生改变时需要手工调用
	        * @param {number} width 宽度
	        * @param {number} height 高度
	        */
	       fishTopoProto.resize = function(width, height) {
	           this.getDom().style.width = width + 'px';
	           this.getDom().style.height = height + 'px';
	           this._zr.resize();
	           this._zr.remove(this.group);
	           this.group = new graphic.Group();
	           if (this.opts.showGridLine == true || this.opts.showGridLine == "true") {
	               this.gridLine();
	               this._zr.add(this.group);
	           }
	       };
	
	       /** @private 初始化 */
	       fishTopoProto.init = function() {
	           this.group = new graphic.Group();
	           if (this.opts.showGridLine == true || this.opts.showGridLine == "true") {
	               this.gridLine();
	               this._zr.add(this.group);
	           }
	
	           //mouseup 会在各个node或线的点击事件之前执行  在选中节点或线前 先清空选中效果
	           this._zr.on("mouseup", function(e) {
	               // 1. 清空节点的选中效果
	               // this._removeOperationNode();
	               // 2. 点击的线 ，则直接返回
	               var shape = e.target;
	               if (shape && shape.connector instanceof Connector) {
	                   return;
	               }
	               this.connectionManager.clearSelectCon();
	               if (shape && shape._isLineOperationIcon && shape._isLineOperationIcon == true) {
	                   return;
	               }
	           }.bind(this));
	           //派发不是节点或线 的画布点击事件
	           this._zr.on("click", function(e) {
	               // 如果点击了控制点，则不会取消选中状态(控制点不在节点范围内)
	               var target = e.target || {};
	               var type = target.type;
	               if (type !== 'ConnectControlLine' && type !== 'ConnectControl') {
	                   this.hideConnectorPoint();
	                   this.hideConnectorControl();
	                   this._removeOperationNode();
	                   this.lineOperationManager.hideAllLineOperation();
	                   var shape = e.target;
	                   //点击的线
	                   if (shape && shape.parent && shape.parent.resourceId) {
	                       return;
	                   } else {
	                       var params = {};
	                       params.event = e;
	                       params.type = "click";
	                       params.target = this;
	                       this._api.trigger(params.type, params);
	                   }
	               }
	           }.bind(this));
	
	           this._zr.on("mousedown", function (e) {
	               if (this.mouseMode === 'drag-select' && (!e.target || (e.target && e.target.type === 'grid-line') || (e.target && e.target.name === 'subprocess-rect'))) {
	                   this._dragSelect(e.target, e.offsetX, e.offsetY);
	               }
	           }.bind(this));
	
	           this.on('conPointsGroup:click', function(argument) {
	               this.lineOperationManager.bindOperation(argument.lineNode);
	           }.bind(this))
	       };
	
	       fishTopoProto._releaseSelectNode = function (flag) {
	           if (this.dragSelectRect) {
	               var nodes = this.dragSelectRect.children().filter(function (v) {
	                   return v.name !== "GROUP_RECT_NAME";
	               });
	               var startX = this.dragSelectRect.position[0];
	               var startY = this.dragSelectRect.position[1];
	               for (var i = 0; i < nodes.length; i++) {
	                   var item = nodes[i];
	                   var nodeX = Bpmn.isFlow(item) ? 0 : item.getRect().x;
	                   var nodeY = Bpmn.isFlow(item) ? 0 : item.getRect().y;
	                   this.dragSelectRect.remove(item);
	                   if (item.originParent && !flag) {
	                       item.originParent.add(item);
	                   } else {
	                       this._zr.add(item);
	                   }
	                   if (!Bpmn.isFlow(item)) {
	                       if (item.originParent && !flag) {
	                           item.setPosition(nodeX+startX-BpmnUtil.parentX(item.originParent), nodeY+startY-BpmnUtil.parentY(item.originParent));
	                       } else {
	                           item.setPosition(nodeX+startX, nodeY+startY);
	                       }
	                       this.connectionManager.refreshLineByNode(item);
	                   }
	                   if (item.originParent) {
	                       item.originParent = null;
	                   }
	               }
	               this.dragSelectRect.off("mousedown");
	               this._zr.remove(this.dragSelectRect);
	           }
	       }
	
	       fishTopoProto._dragSelect = function (node, x, y) {
	           this._releaseSelectNode();  //还原选中的节点
	           this.dragSelectRect = new GroupNode({
	               shape:{ width: 0, height: 0},
	               position:[x, y],
	               style: {
	                   lineDash:[2,2],
	                   fill: "rgba(239,222,221,0.7)",
	                   stroke: 'rgba(0, 0, 0, 1)'
	               }
	           });
	           this.dragSelectRect.type = "dragSelect";
	           this._zr.add(this.dragSelectRect);
	           this.dragSelectRect.on('mousedown', function(e) {
	               this.newDrag(this.dragSelectRect, e.event.clientX, e.event.clientY);
	               e.cancelBubble = true;
	           }.bind(this));
	
	           var moveHandler = function (event) {
	               if (Math.abs(event.offsetX - x) <= 1 && Math.abs(event.offsetY - y) <= 1) {
	                   return;
	               }
	               var posX = x <= event.offsetX ? x : event.offsetX;
	               var posY = y <= event.offsetY ? y : event.offsetY;
	               var width = Math.abs(event.offsetX - x);
	               var height = Math.abs(event.offsetY - y);
	               this.dragSelectRect.setProperties({shape: {width:width, height: height}, position: [posX, posY]});
	           }.bind(this);
	           this._zr.on('mousemove', moveHandler);
	
	           var endDragHandler = function (event) {
	               this._zr.off('mousemove', moveHandler);
	               this._zr.off('mouseup', endDragHandler);
	               this._zr.off("globalout", endDragHandler);
	               if (Math.abs(event.offsetX - x) <= 1 && Math.abs(event.offsetY - y) <= 1) {
	                   if (node && node.parent && Bpmn.isSubProcess(node.parent)) {
	                       this.nodeClickHandler(node.parent);
	                       this._trigger('selectNode', {target: node.parent});
	                   }
	                   return;
	               }
	               var ts = this;
	               var startX = this.dragSelectRect.position[0];
	               var startY = this.dragSelectRect.position[1];
	               var width = this.dragSelectRect.options.shape.width;
	               var height = this.dragSelectRect.options.shape.height;
	               var cnt = 0;
	               this.allNodes.forEach(function (item) {
	                   var rect = item.getRect();
	                   var nodeWidth = rect.width;
	                   var nodeHeight = rect.height;
	                   var nodeX = item.parent ? rect.x+BpmnUtil.parentX(item.parent) : rect.x;
	                   var nodeY = item.parent ? rect.y+BpmnUtil.parentY(item.parent) : rect.y;
	                   if (((Bpmn.isEvent(item) || Bpmn.isGateway(item)) &&
	                       nodeX-nodeWidth >= startX && nodeY-nodeWidth >= startY &&
	                       nodeX+nodeWidth <= startX+width && nodeY+nodeWidth <= startY+height) ||
	                       (!(Bpmn.isEvent(item) || Bpmn.isGateway(item)) &&
	                       nodeX-nodeWidth/2 >= startX && nodeY-nodeHeight/2 >= startY &&
	                       nodeX+nodeWidth/2 <= startX+width && nodeY+nodeHeight/2 <= startY+height)) {
	                       if (item.slotEvent && item.slotEvent.length > 0) {
	                           for (var n = 0; n < item.slotEvent.length; n++) {
	                               var slotEventPosition2 = [item.slotEvent[n].position[0] + (nodeX-startX) - zrUtil.clone(item.position[0]) - item.getBoundingRect().width / 2, item.slotEvent[n].position[1] + (nodeY-startY) - zrUtil.clone(item.position[1]) - item.getBoundingRect().height / 2];
	                               item.slotEvent[n].attr("position", slotEventPosition2);
	                               that.connectionManager.refreshLineByNode(item.slotEvent[n]);
	                           }
	                       }
	                       if (item.parent) {
	                           item.originParent = item.parent;
	                           item.parent.remove(item);
	                       } else {
	                           ts._zr.remove(item);
	                       }
	                       ts.dragSelectRect.add(item);
	                       ts.selectedNodes.push(item);
	                       item.setPosition(nodeX-startX, nodeY-startY);
	                       cnt++;
	                   }
	               });
	               if (!cnt) {
	                   this.dragSelectRect.off("mousedown");
	                   this._zr.remove(this.dragSelectRect);
	               } else {
	                   this.dragSelectRect.childOfName("GROUP_RECT_NAME").attr("style", {
	                       fill: "rgba(0,0,0,0)"
	                   });
	                   this.connectionManager.connectors.forEach(function (item) {
	                       var startNode = ts.dragSelectRect.children().find(function (v) {
	                           return v.id === item.startNode.id;
	                       });
	                       var endNode = ts.dragSelectRect.children().find(function (v) {
	                           return v.id === item.endNode.id;
	                       });
	                       if (startNode && endNode) {
	                           ts._zr.remove(item);
	                           ts.dragSelectRect.add(item);
	                           ts.connectionManager.refreshLineByNode(item.startNode);
	                       }
	                   });
	               }
	           }.bind(this);
	           this._zr.on('mouseup', endDragHandler);
	           this._zr.on("globalout", endDragHandler);
	       }
	
	       /**
	        * 根据传过来的值  设置节点模型
	        * @param {Object} shape  节点或线
	        * @param {Object} option 模型数据
	        * @param {number} width 宽度(仅用于调整画布大小)
	        * @param {number} height 高度(仅用于调整画布大小)
	        */
	       fishTopoProto.setShapeModel = function(shape, option, width, height) {
	           if (this.forbidEdit === true) {
	               return;
	           }
	           if (Bpmn.isTemplate(shape)) {
	               this.model.mergeOption(option);
	               if (width > 0 && height > 0) {
	                   this.resize(width, height);
	               }
	           } else if (Bpmn.isFlow(shape)) {
	               this.connectionManager.setModel(shape, option);
	           } else {
	               if (shape.bpmnInfo.name.indexOf("Task") !== -1) {
	                   option.properties.position = 'center';
	               }
	               if (shape.bpmnInfo.name === 'Comment') {
	                   option.properties.position = 'left';
	               }
	               shape.setModel(option);
	           }
	       };
	
	       /**
	        * 获取父
	        */
	       fishTopoProto._getParentZr = function(node) {
	           var parentZr = null;
	           if (node && node.parent) {
	               parentZr = node.parent;
	           } else {
	               parentZr = this._zr;
	           }
	           return parentZr;
	       }
	
	       /**
	        * 清空当前实例，会移除实例中所有的节点与线
	        * @method clear
	        */
	       fishTopoProto.clear = function(isNoCount) {
	           this.allNodes = [];
	
	           this.subProcessNode = [];
	
	           this.domArray = [];
	
	           this.overlapArray = [];
	
	           this.hideConnectorPoint();  //隐藏所有节点上的连接点
	
	           this.selectedNode = null;
	           this.rect = null;
	           this.connectionManager.connectors = [];
	           this._zr.clear();
	           this._zr.add(this.group); // 画网格线  代码放这比较恶心 后面改
	           if (isNoCount != true) {
	               this.stepCounter();
	           }
	       };
	
	       /**
	        * 设置是否显示网络线
	        * @param  {Boolean} isForbidden 是否显示网络线
	        */
	       fishTopoProto.forbidGridLine = function(isForbidden) {
	           this.opts.showGridLine = !isForbidden;
	           if (isForbidden == true) {
	               this._zr.remove(this.group);
	           } else {
	               this._zr.remove(this.group);
	               this.group = new graphic.Group();
	               this.gridLine(0.2);
	               this._zr.add(this.group);
	
	           }
	       };
	
	       /**
	        * 导出json
	        * @return {string} json字符串
	        */
	       fishTopoProto.toJson = function() {
	           return BpmnUtil.toJson(this.model, this.allNodes, this.connectionManager.connectors);
	       };
	
	       /**
	        * 导入json
	        * @param  {string} json json格式的字符串
	        */
	       fishTopoProto.fromJson = function(json) {
	           BpmnUtil.fromJson(this, json);
	       };
	
	       //背景网格线
	       fishTopoProto.gridLine = function() {
	           var pixel = this.opts.gridLineSpacing;
	           var widthLen = parseInt(this.getWidth() / pixel);
	           for (var x = 0; x <= widthLen; x++) {
	               var lineX = new graphic.Line({
	                   shape: {
	                       x1: x * pixel,
	                       y1: 0,
	                       x2: x * pixel,
	                       y2: this.getHeight()
	                   },
	                   style: {
	                       stroke: (x === 0 || (x + 1) % 4 === 0 ||  x === widthLen - 1) ? '#dddddd' : '#ddddddb8'
	                   },
	                   z: -1,
	                   draggable: false,
	                   cursor: 'default'
	               });
	               lineX.type = "grid-line";
	               this.group.add(lineX);
	           }
	
	           var heightLen = parseInt(this.getHeight() / pixel, pixel);
	           for (var y = 0; y <= heightLen; y++) {
	               var lineY = new graphic.Line({
	                   shape: {
	                       x1: 0,
	                       y1: y * pixel,
	                       x2: this.getWidth(),
	                       y2: y * pixel
	                   },
	                   style: {
	                       stroke: (y === 0 || (y + 1) % 4 === 0 || y === heightLen - 1) ? '#dddddd' : '#ddddddb8'
	                   },
	                   z: -1,
	                   draggable: false,
	                   cursor: 'default'
	               });
	               lineY.type = "grid-line";
	               this.group.add(lineY);
	           }
	       };
	
	       fishTopoProto._removeOperationNode = function() {
	           if (this.operationNode) {
	               this._zr.remove(this.operationNode);
	               this.operationNode.cleanup();
	               this.operationNode = null;
	           }
	       }
	
	       /**
	        * 通过界面拖动 增加节点
	        * @param {string} itemType 创建节点的类型（已有预定义类型包括StartNoneEvent、EndNoneEvent、UserTask、ManualTask、ScriptTask、MailTask、CatchTimerEvent、CatchSignalEvent、ThrowSignalEvent、InclusiveGateway、ExclusiveGateway、ParallelGateway、SubProcess）
	        * @param {number} x        节点创建的x坐标
	        * @param {number} y        节点创建的y坐标
	        * @param {Object} options 选项
	        * @param {Object} [options.name] 节点下面显示名称
	        * @param {Array} [options.operationIcons] 设置选中节点时 显示的操作小图标， 默认提供了 删除、直线、折线、曲线4种图标，也可以自定图标 eg.
	        * <pre>
	        *          operationIcons: [{ name: 'DEL' },
	        *              { name: 'STRAIGHT' },
	        *              { name: 'JAGGED' },
	        *              { name: 'CURVE' },
	        *              {
	        *                  name: "custom1",
	        *                  iconPath: "img/host.png",
	        *                  callback: function(e) { alert(e.data.name + " clicked") }  //e.node是当前的节点
	        *              }
	        *          ]
	        * </pre>
	        * @param {Object} userData 用户传递的业务数据
	        *
	        * **使用范例**：
	        *
	        *      @example
	        *      fishTopo.addNode(itemType, x, y, {
	        *                      name: itemType,   //节点的名称
	        *                      operationIcons:[{name:'DEL'},{ name: 'STRAIGHT' },{name:'JAGGED'},{ name: 'CURVE' }],
	        *                      // 增加节点操作图标 上面分别是"删除、直线、折线、曲线"，
	        *                      // 也可以增加自定图标 如{name: "custom1", iconPath: "img/host.png", callback: function(e) { alert(e.data.name + " clicked") }} //e.node是当前的节点
	        *                      userData:{businessData:'我是业务数据,通过Bpmn.getUserData可获取'}
	        *                      // 增加节点的自定义业务，可以通过Bpmn.getUserData(node)获取
	        *                  });
	        */
	       fishTopoProto.addNode = function(itemType, x, y, options) {
	           var that = this;
	           //判断是否在范围内
	           if (x >= 0 && y >= 0) {
	               var model = new BPMNModel({});
	               model.set(Bpmn.BPMN_TYPE, itemType);
	               model.set("bounds.upperLeft", {x: x, y: y});
	               if (options) {
	                   model.set("properties", options);
	               }
	               this._triggerAsync('beforeCreateNode', {target: null}, model).then(function (res) {
	                   if (res) {
	                       that.asyncAddNodeByModel(model, true);
	                   }
	               });
	           }
	       };
	
	       //添加一个流程图片段
	       fishTopoProto.addShapes = function(childShapes, x, y) {
	           if (x < 0 || y < 0) {
	               return;
	           }
	           //先拿到老的画布json数据
	           var cloneChildShapes = JSON.parse(JSON.stringify(childShapes));
	           var canvasData = this.toJson();
	           var oldChildShapes = JSON.parse(JSON.stringify(canvasData.childShapes));
	
	           //计算出要添加shapes的宽高
	           var allUpperLeftX = [], allUpperLeftY = [], allLowerRightX = [], allLowerRightY = [];
	           for (var i = 0; i < cloneChildShapes.length; i++) {
	               var node = cloneChildShapes[i];
	               if (node.stencil.type !== Bpmn.SEQUENCE_FLOW) {
	                   allUpperLeftX.push(node.bounds.upperLeft.x);
	                   allUpperLeftY.push(node.bounds.upperLeft.y);
	                   allLowerRightX.push(node.bounds.lowerRight.x);
	                   allLowerRightY.push(node.bounds.lowerRight.y);
	               }
	           }
	           var minX = Math.min.apply(Math, allUpperLeftX);
	           var minY = Math.min.apply(Math, allUpperLeftY);
	           var maxX = Math.max.apply(Math, allLowerRightX);
	           var maxY = Math.max.apply(Math, allLowerRightY);
	           var shapesWidth = maxX - minX;
	           var shapesHeight = maxY - minY;
	
	           //判断往画布里还是子进程里添加shapes
	           var insertPos = 'canvas';
	           function JudgeInSubProcess(subProcess, x, y) {
	               if (subProcess.length > 0) {
	                   for (var i = 0; i < subProcess.length; i++) {
	                       if (x > BpmnUtil.parentX(subProcess[i]) && x < BpmnUtil.parentX(subProcess[i]) + subProcess[i].getRect().width
	                        && y > BpmnUtil.parentY(subProcess[i]) && y < BpmnUtil.parentY(subProcess[i]) + subProcess[i].getRect().height) {
	                           if (subProcess[i].children() && subProcess[i].children().length > 0) {
	                               var newSubProcess = subProcess[i].children().filter(function (item) {
	                                   return item.bpmnInfo && item.nodeType === 'SubProcess'
	                               });
	                               var node = JudgeInSubProcess(newSubProcess, x, y);
	                           }
	                           return node || subProcess[i];
	                       }
	                   }
	               }
	               return null;
	           }
	
	           var _subProcess = JudgeInSubProcess(this.subProcessNode, x, y);
	           if (_subProcess) {
	               insertPos = _subProcess.resourceId;
	           }
	
	           //计算出shapes里每个shape的新位置， 并插入到画布或者某个子进程的childShapes里
	           var newChildShapes = [];
	           if (insertPos === 'canvas') {
	               for (var i = 0; i < cloneChildShapes.length; i++) {
	                   var item = cloneChildShapes[i];
	                   if (item.stencil.type !== Bpmn.SEQUENCE_FLOW) {
	                       item.bounds.upperLeft.x = item.bounds.upperLeft.x - minX + x;
	                       item.bounds.lowerRight.x = item.bounds.lowerRight.x - minX + x;
	                       item.bounds.upperLeft.y = item.bounds.upperLeft.y - minY + y;
	                       item.bounds.lowerRight.y = item.bounds.lowerRight.y - minY + y;
	                   } else {
	                       item.dockers = [];
	                   }
	               }
	               //画布里还存在其他节点
	               if (oldChildShapes.length > 0) {
	                   for (var j = 0; j < oldChildShapes.length; j++) {
	                       var node = oldChildShapes[j];
	                       if (node.stencil.type === Bpmn.SEQUENCE_FLOW) {
	                           node.dockers = [];
	                           continue;
	                       }
	                       if (node.bounds.lowerRight.x >= x && node.bounds.lowerRight.y >= y ) {
	                           //判断需要修改位置的节点
	                           if (node.bounds.upperLeft.x <= x ) {
	                               //节点位置向下移动
	                               node.bounds.upperLeft.y = node.bounds.upperLeft.y + shapesHeight;
	                               node.bounds.lowerRight.y = node.bounds.lowerRight.y + shapesHeight;
	                           } else {
	                               //节点位置向右移动
	                               node.bounds.upperLeft.x = node.bounds.upperLeft.x + shapesWidth;
	                               node.bounds.lowerRight.x = node.bounds.lowerRight.x + shapesWidth;
	                           }
	                       }
	                   }
	               }
	               newChildShapes = oldChildShapes.concat(cloneChildShapes);
	               canvasData.childShapes = newChildShapes;
	           } else {
	               for (var m = 0; m < cloneChildShapes.length; m++) {
	                   var item = cloneChildShapes[m];
	                   if (item.stencil.type !== Bpmn.SEQUENCE_FLOW) {
	                       item.bounds.upperLeft.x = item.bounds.upperLeft.x - minX + (x - BpmnUtil.parentX(_subProcess));
	                       item.bounds.lowerRight.x = item.bounds.lowerRight.x - minX + (x - BpmnUtil.parentX(_subProcess));
	                       item.bounds.upperLeft.y = item.bounds.upperLeft.y - minY + (y - BpmnUtil.parentY(_subProcess));
	                       item.bounds.lowerRight.y = item.bounds.lowerRight.y - minY + (y - BpmnUtil.parentY(_subProcess));
	                   } else {
	                       item.dockers = [];
	                   }
	               }
	               var newX, newY;
	               //修改所在子进程节点的宽高和它的位置信息
	               for (var n = 0; n < oldChildShapes.length; n++) {
	                   var node = oldChildShapes[n];
	                   if (node.resourceId === insertPos) {
	                       newX = node.bounds.upperLeft.x;
	                       newY = node.bounds.upperLeft.y;
	                       if (node.bounds.lowerRight.x - x < shapesWidth) {
	                           node.bounds.lowerRight.x = shapesWidth + x + 10;
	                       }
	                       if (node.bounds.lowerRight.y - y < shapesHeight) {
	                           node.bounds.lowerRight.y = shapesHeight + y + 10;
	                       }
	                       //插入的子进程节点里确保没有其他节点，若存在其他节点将会清空
	                       node.childShapes = [].concat(cloneChildShapes);
	                   }
	               }
	               //撑开子进程节点可能会影响它周围的节点，因此需要修改周围节点的位置信息
	               for (var k = 0; k < oldChildShapes.length; k++) {
	                   var node = oldChildShapes[k];
	                   if (node.resourceId === insertPos) {
	                       continue;
	                   }
	                   if (node.stencil.type === Bpmn.SEQUENCE_FLOW) {
	                       node.dockers = [];
	                       continue;
	                   }
	                   if (node.bounds.lowerRight.x >= newX && node.bounds.lowerRight.y >= newY ) {
	                       //判断需要修改位置的节点
	                       if (node.bounds.upperLeft.x <= newX ) {
	                           //节点位置向下移动
	                           node.bounds.upperLeft.y = node.bounds.upperLeft.y + shapesHeight;
	                           node.bounds.lowerRight.y = node.bounds.lowerRight.y + shapesHeight;
	                       } else {
	                           //节点位置向右移动
	                           node.bounds.upperLeft.x = node.bounds.upperLeft.x + shapesWidth;
	                           node.bounds.lowerRight.x = node.bounds.lowerRight.x + shapesWidth;
	                       }
	                   }
	               }
	               canvasData.childShapes = oldChildShapes;
	           }
	           //重新渲染整个画布
	           this.fromJson(canvasData);
	           this.stepCounter();
	       }
	
	       fishTopoProto._JudgeNodeInWhichSubProcess = function (subProcess, node) {
	           if (subProcess.length > 0) {
	               for (var i = 0; i < subProcess.length; i++) {
	                   var boundingRect = new BoundingRect(
	                       BpmnUtil.parentX(subProcess[i]),
	                       BpmnUtil.parentY(subProcess[i]),
	                       subProcess[i].getRect().width,
	                       subProcess[i].getRect().height
	                   );
	                   if (boundingRect.contain(node.x, node.y)) {
	                       var newNode;
	                       if (subProcess[i].children() && subProcess[i].children().length > 0) {
	                           var newSubProcess = subProcess[i].children().filter(function (item) {
	                               return item.bpmnInfo && item.nodeType === 'SubProcess'
	                           });
	                           newNode = this._JudgeNodeInWhichSubProcess(newSubProcess, node);
	                       }
	                       return newNode || subProcess[i];
	                   }
	               }
	           }
	           return null;
	       }
	       /**
	        * 根据模型增加节点(同步)
	        * @private
	        * @param {Object} model [description]
	        * @return {Object} 创建完成的节点
	        */
	       fishTopoProto.addNodeByModel = function(model, isFromDrag, isNoCount) {
	           var that = this;
	           var Shape = BPMNNode.getClass(model.get(Bpmn.BPMN_TYPE));
	
	           if (Shape) {
	               var node = new Shape(model, this._api);
	               var _subProcess = that._JudgeNodeInWhichSubProcess(that.subProcessNode, {x: node.getRect().x, y: node.getRect().y});
	               that.addNodeToShape(node, isFromDrag, isNoCount, _subProcess);
	               return node;
	           }
	       };
	
	       /**
	        * 根据模型增加节点(异步)
	        * @private
	        * @param {Object} model [description]
	        * @return {Object} 创建完成的节点
	        */
	       fishTopoProto.asyncAddNodeByModel = function(model, isFromDrag, isNoCount) {
	           var that = this;
	           var Shape = BPMNNode.getClass(model.get(Bpmn.BPMN_TYPE));
	
	           if (Shape) {
	               var node = new Shape(model, this._api);
	               var _subProcess = that._JudgeNodeInWhichSubProcess(that.subProcessNode, {x: node.getRect().x, y: node.getRect().y});
	               this._triggerAsync('beforeAddNode', {target: _subProcess}, node).then(function (res) {
	                   if (res) {
	                       that.addNodeToShape(node, isFromDrag, isNoCount, _subProcess);
	                   }
	               });
	           }
	       };
	
	       fishTopoProto.addNodeToShape = function (node, isFromDrag, isNoCount, _subProcess) {
	           var that = this;
	           var mesArray;
	           if (that.subProcessNode.length == 0) {
	               that._zr.add(node);
	               mesArray = {
	                   id: node.id,
	                   position: [node.getRect().x, node.getRect().y],
	                   width: node.getRect().width,
	                   height: node.getRect().height
	               };
	               if (!Bpmn.isSlotEvent(node)) {
	                   that.overlapArray.push(mesArray);
	               }
	           } else {
	               that._zr.add(node);
	               mesArray = {
	                   id: node.id,
	                   position: [node.getRect().x, node.getRect().y],
	                   width: node.getRect().width,
	                   height: node.getRect().height
	               };
	               if (!Bpmn.isSlotEvent(node)) {
	                   that.overlapArray.push(mesArray);
	               }
	               if (isFromDrag) {
	                   var offsetX = 0, offsetY = 0;
	                   if (_subProcess) {
	                       if (_subProcess.parent && Bpmn.isSubProcess(_subProcess.parent)) {
	                           offsetX = BpmnUtil.parentX(_subProcess.parent);
	                           offsetY = BpmnUtil.parentY(_subProcess.parent);
	                       }
	                       var groupNodePositionX = _subProcess.getRect().width / 2 + (node.getRect().x - (_subProcess.getRect().x + offsetX));
	                       var groupNodePositionY = _subProcess.getRect().height / 2 + (node.getRect().y - (_subProcess.getRect().y + offsetY));
	                       node.setPosition(groupNodePositionX, groupNodePositionY);
	                       _subProcess.add(node);
	                       that._zr.remove(node);
	                       for (var j = 0; j < that.overlapArray.length; j++) {
	                           if (node.id == that.overlapArray[j].id) {
	                               that.overlapArray.splice(j, 1);
	                           }
	                       }
	                   }
	               }
	           }
	           //2.如果是子节点 则加入到子节点数组中
	           if (Bpmn.isSubProcess(node)) {
	               that.subProcessNode.push(node);
	           }
	           that.allNodes.push(node);
	           //放入节点位置信息 用于拖拽
	           mesArray.position = [node.getRect().x, node.getRect().y];
	           mesArray.points = that._getControlsOfNode(node);
	           mesArray.rotation = node.rotation;
	           that.domArray.push(mesArray);
	
	           //侦听节点的事件 并把事件给取消掉 防止 如果父是子节点侦听到
	           node.on('mousedown', function(e) {
	               if (!(that.forbidEdit == true ||
	                   (this.parent && this.parent.type === "dragSelect") ||
	                   (that.mouseMode === "drag-select" && Bpmn.isSubProcess(this)))) {
	                   that.newDrag(this, e.event.clientX, e.event.clientY);
	               }
	               //如果选择的是事件节点，则为其他task绑定插槽
	               if (Bpmn.isSlotEvent(this)) {
	                   that.bindEventNode();
	               }
	               if (that.mouseMode !== "drag-select") {
	                   e.cancelBubble = true;
	               }
	           });
	           node.on('click', function(e) {
	               that.nodeClickHandler(this);
	               that._trigger('selectNode', {target: node});
	               e.cancelBubble = true;
	           });
	           //添加tip
	           if (Bpmn.isActivity(node)) {
	               that.creatTip(node);
	           }
	           node.on("mouseover", function() {
	               if (this.alarm && this.alarm.isShow == true) {
	
	                   this.alarm.show();
	                   this.alarm.eachChild(function(child) {
	                       child.show();
	                   });
	                   //根据字内容更改tip外框的大小
	                   var text = this.alarm.childOfName("Text");
	                   var groupWidth = text.getBoundingRect().width + 4;
	                   var groupHeight = text.getBoundingRect().height + 8;
	                   var points = [
	                       [0, 0],
	                       [groupWidth, 0],
	                       [groupWidth, groupHeight],
	                       [groupWidth / 2 - 3, groupHeight],
	                       [groupWidth / 2, groupHeight + 3],
	                       [groupWidth / 2 + 3, groupHeight],
	                       [0, groupHeight],
	                       [0, 0]
	                   ];
	                   var Polyline = this.alarm.childOfName("Polyline");
	                   Polyline.attr("shape", {points: points});
	                   var groupPosition = [BpmnUtil.parentX(node) + node.getBoundingRect().width - this.alarm.getBoundingRect().width / 2, BpmnUtil.parentY(node) - this.alarm.getBoundingRect().height - 3];
	                   this.alarm.attr("position", groupPosition);
	               }
	           });
	           node.on("mouseout", function() {
	               if (this.alarm) {
	                   this.alarm.hide();
	                   this.alarm.eachChild(function(child) {
	                       child.hide();
	                   });
	               }
	           });
	           if (isNoCount != true) {
	               that.stepCounter();
	           }
	           that._trigger('afterCreateNode', {target: node});
	       }
	
	       /**
	        * 选中场景中的某个节点,并且触发selectNode事件
	        * @param {Object} node 待选中的节点对象
	        * @since V2.3.0
	        *  **使用范例：**
	        * @example
	        * fishTopo.selectNode(node);
	        */
	
	       fishTopoProto.selectNode = function(node) {
	           if (node) {
	               this.nodeClickHandler(node);
	               this._trigger('selectNode', {target: node});
	           }
	       };
	
	       /**
	        * 根据name获取节点
	        * @param  {String} name 在创建节点中  name属性设置的值
	        * @return {Object}      name对应的节点
	        */
	       fishTopoProto.childOfName = function(name) {
	           var arrResult = [];
	           for (var i = 0; i < this.allNodes.length; i++) {
	               if (this.allNodes[i].model.get("properties.name") == name) {
	                   arrResult.push(this.allNodes[i]);
	               }
	           }
	           if (arrResult.length > 1) {
	               return arrResult;
	           } else {
	               return arrResult[0];
	           }
	       };
	
	       /**
	        * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(e){ return e.position[0] > 100; });
	        * @param  {Function} cb      回调函数
	        * @param  {Object}   context 回调函数执行的上下文
	        * @return {Array}           返回查找到的对象
	        */
	       fishTopoProto.findElements = function(cb, context) {
	           var childrenNode = this.allNodes;
	           var childrenLine = this.connectionManager.connectors;
	           var arr = [];
	           for (var i = 0; i < childrenNode.length; i++) {
	               var child = childrenNode[i];
	               if (cb.call(context, child, i)) {
	                   arr.push(child);
	               }
	           }
	           for (var j = 0; j < childrenLine.length; j++) {
	               var childLine = childrenLine[j];
	               if (cb.call(context, childLine, j)) {
	                   arr.push(childLine);
	               }
	           }
	           return arr;
	       };
	
	       /**
	        * @private
	        * 根据模型增加线
	        */
	       fishTopoProto.addConnectorByModel = function(model, parentZr) {
	           //找出 startNode 与 endNode
	           var startNode = null,
	               endNode = null;
	           zrUtil.each(this.allNodes, function(node) {
	               //startNode: 从allNode中找出outgoing为 线的id的起始节点
	               var nodeOutgoing = node.model.get("outgoing");
	               if (nodeOutgoing.indexOf(model.get("resourceId")) !== -1) {
	                   startNode = node;
	               }
	               //endNode : 从allNode中找出 id 为线的outgoing的结束节点
	               var connectorOutgoing = model.get("outgoing");
	               if (connectorOutgoing.indexOf(node.resourceId) !== -1) {
	                   endNode = node;
	               }
	           });
	           if (startNode && endNode) {
	               var connector = this.connectionManager.connectorCreateByOptions(startNode, endNode, {model: model,isFromModel:true}, this._api);
	               if (parentZr) {
	                   parentZr.add(connector);
	               } else {
	
	                   this._zr.add(connector);
	               }
	               this.connectionManager.connectorForbidEdit(this.forbidEdit);
	               this._createConnectorDragEvents(connector);
	               connector.on("mousedown", function(e) {
	                   this.lineOperationManager.isEdit = !this.forbidEdit;
	                   // 取消节点的选中
	                   this.hideConnectorPoint();
	                   this.hideConnectorControl();
	                   this._removeOperationNode();
	                   this.isNode = false;
	               }.bind(this));
	           }
	
	       };
	
	       /**
	        * 创建连线的小图标操作
	        * @param {string} key 小图标的名称
	        * @param {Object} options 小图标选项
	        * @param {String} [options.icon] 小图标路径
	        * @param {Object} [options.lineNode] 线段实例
	        * @param {Function} [options.callback] 点击后的回调
	        *
	        * **使用范例**：
	        *
	        *      @example
	        *      fishTopoBpmn.addIcon("icon1",{  //线上图标的名称
	        *                    icon:"bpmn2.0/icons/activity/list/mail.send.png", //线上图标的路径
	        *                     lineNode:lineNode,  //线
	        *                     callback:function(lineNode){  //回调
	        *                          alert(JSON.stringify(lineNode))
	        *                      },
	        *                  });*
	        */
	       fishTopoProto.addIcon = function(key, options) {
	           this.lineOperationManager.addIcon(key, options);
	       };
	
	       /**
	        * 创建连线的默认删除操作
	        * @param  {Object} lineNode 线
	        *
	        *  **使用范例**：
	        *
	        *      @example
	        *      fishTopoBpmn.bindLineDelete(lineNode);
	        */
	       fishTopoProto.bindLineDelete = function(lineNode,options) {
	           //创建删除
	           this.lineOperationManager.addDeleteIcon(lineNode,options);
	       };
	       /**
	        * @private
	        * 返回 连向该节点的节点数组：nodeArray[0]  以及该节点连向的节点数组 nodeArray[0]
	        */
	       fishTopoProto.checkLineNode = function(node) {
	           var startArray = [],
	               endArray = [];
	           var lineArray = this.connectionManager.connectors;
	           for (var i = 0, len = lineArray.length; i < len; i++) {
	               if (lineArray[i].startNode == node) {
	                   endArray.push(lineArray[i].endNode);
	               }
	           }
	           for (var j = 0, lenEnd = lineArray.length; j < lenEnd; j++) {
	               if (lineArray[j].endNode == node) {
	                   startArray.push(lineArray[j].startNode);
	               }
	           }
	           return [startArray, endArray];
	       };
	
	       /**
	        * @private
	        * 计算在subprocess内的节点的真实位置
	        */
	       fishTopoProto.calculateNodeRectInGroup = function(node) {
	           var rect = util.getRect(node);
	           if (node.parent && Bpmn.isSubProcess(node.parent)) {
	               rect.boundingRect.x += BpmnUtil.parentX(node.parent);
	               rect.boundingRect.y += BpmnUtil.parentY(node.parent);
	               rect.x += BpmnUtil.parentX(node.parent);
	               rect.y += BpmnUtil.parentY(node.parent);
	           }
	           return {
	               rect: rect,
	               parentNode: BpmnUtil.getParentNode(node)
	           }
	       }
	
	       /**
	        * @private
	        * 依次从节点递归至最外层的subprocess，计算节点最终的包围盒
	        */
	       fishTopoProto.calculateRect = function(node, nodeRect) {
	           if (!nodeRect) {
	               nodeRect = this.calculateNodeRectInGroup(node).rect;
	           }
	           if (!nodeRect.rotation) {
	               nodeRect.rotation = node.rotation;
	           } else {
	               nodeRect.rotation += node.rotation;
	           }
	           // 如果父节点旋转了，需要更新子节点的中心点
	           if (node.parent && Bpmn.isSubProcess(node.parent)) {
	               var rotation = node.parent.rotation;
	               if (Math.abs(rotation) > 0) {
	                   var center = this.calculateNodeRectInGroup(node.parent).rect;
	                   var point = {
	                       x: nodeRect.x,
	                       y: nodeRect.y
	                   }
	                   var nPoint = util.calculatePoints(point, center, rotation);
	                   nodeRect.x = nPoint.x;
	                   nodeRect.y = nPoint.y;
	                   nodeRect.boundingRect.x = nodeRect.x - nodeRect.width / 2;
	                   nodeRect.boundingRect.y = nodeRect.y - nodeRect.height / 2;
	               }
	               return this.calculateRect(node.parent, nodeRect);
	           } else {
	               return nodeRect;
	           }
	       }
	
	       fishTopoProto.createConnectorPoint = function(point, pos, lineType) {
	           var me = this;
	           var pointInstance = new graphic.Circle({
	               shape: {
	                   cx: point.x,
	                   cy: point.y,
	                   r: 4
	               },
	               style: {
	                   fill: '#FFFF33',
	                   stroke:'#000000'
	               },
	               z : 2,
	               cursor: 'crosshair',
	               draggable: true,
	               lineType: lineType
	           });
	           pointInstance.type = 'ConnectPoint';
	           pointInstance.pos = pos;                //记录是节点上哪个位置的连接点
	           var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	           zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	               pointInstance.on(eveName, function(e) {
	                   var params = {};
	                   params.event = e;
	                   params.type = "ConnectPoint:" + eveName;
	                   me.conPointsGroup.trigger(params.type, params);
	               });
	           });
	           this.conPointsGroup.add(pointInstance);
	       }
	
	       fishTopoProto.hideConnectorPoint = function() {
	           this.conPointsGroup.removeAll();  //隐藏所有节点上的连接点
	           this.conPointsGroup.off();        //清空所有事件
	           this._zr.remove(this.conPointsGroup);
	       }
	
	       fishTopoProto.filterConnectPoint = function(targetNodes, lineType) {
	           var that = this;
	           var nodes = targetNodes;
	           nodes.forEach(function(item) {
	               var calculateRect = that.calculateRect(item);
	               var connectorPoint = util.getConnectorPoints(calculateRect, { rotation: calculateRect.rotation });
	               that.createConnectorPoint(connectorPoint.left, "left", lineType);
	               that.createConnectorPoint(connectorPoint.right, "right", lineType);
	               that.createConnectorPoint(connectorPoint.top, "top", lineType);
	               that.createConnectorPoint(connectorPoint.bottom, "bottom", lineType);
	           });
	       }
	
	       fishTopoProto.showConnectorPoint = function(lineType, lineOpt, ifCurrentNode) {
	           var that = this;
	           this.hideConnectorPoint();
	           if (lineOpt) {
	               this.lineOpt = lineOpt;  //缓存线段的配置信息
	           }
	           if (lineType) {
	               this.lineType = lineType; // 缓存线段类型
	           }
	           if (!this.lineType) {
	               this.lineType = 'jagged'; // 线段默认折线类型
	           }
	           if (!ifCurrentNode) {
	               ifCurrentNode = false;
	           }
	           var targetNodes = ifCurrentNode ? [that.selectedNode] : that.allNodes;
	           // 让所有画布中的节点/当前节点显示连接点
	           this.filterConnectPoint(targetNodes, this.lineType);
	
	           function findConnectorNode(x, y, offset, pos) {
	               var node, endPos = null;
	               that.allNodes.forEach(function(item) {
	                   var calculateRect = that.calculateRect(item);
	                   var connectorPoint = util.getConnectorPoints(calculateRect, { rotation: calculateRect.rotation });
	                   if (pos) {
	                       if (Math.abs(connectorPoint[pos].x - x) <= offset && Math.abs(connectorPoint[pos].y - y) <= offset) {
	                           node = item;
	                       }
	                   } else {
	                       if (Math.abs(connectorPoint["left"].x - x) <= offset && Math.abs(connectorPoint["left"].y - y) <= offset) {
	                           endPos = "left";
	                           node = item;
	                       } else if (Math.abs(connectorPoint["top"].x - x) <= offset && Math.abs(connectorPoint["top"].y - y) <= offset) {
	                           endPos = "top";
	                           node = item;
	                       } else if (Math.abs(connectorPoint["right"].x - x) <= offset && Math.abs(connectorPoint["right"].y - y) <= offset) {
	                           endPos = "right";
	                           node = item;
	                       } else if (Math.abs(connectorPoint["bottom"].x - x) <= offset && Math.abs(connectorPoint["bottom"].y - y) <= offset) {
	                           endPos = "bottom";
	                           node = item;
	                       }
	                   }
	               });
	               return {
	                   node: node,
	                   endPos: endPos
	               };
	           }
	           this.conPointsGroup.on("ConnectPoint:dragstart", function(e) {
	               // 如果是当前节点显示连接点，需要在拖动剪头时让画布中的其他节点显示连接点
	               if (ifCurrentNode) {
	                   that.filterConnectPoint(that.allNodes, that.lineType);
	               }
	               var x = e.event.offsetX;
	               var y = e.event.offsetY;
	               var arrow = e.event.target;
	               that.startPos = arrow.pos;
	               that.selectConnNode = findConnectorNode(arrow.shape.cx, arrow.shape.cy, 0, that.startPos).node;
	               arrow.hide();
	               that.lineOperationManager.hideAllLineOperation();
	               that.reverseConnect = false;   //是否反向连线的标识
	               that.originNode = null;
	               var point = new Point(x, y);
	               var connector = that.connectionManager.manageTempConnector(that.selectConnNode, point, arrow.lineType, that.startPos);
	               that._zr.add(connector);
	           });
	           this.conPointsGroup.on("ConnectPoint:drag", function(e) {
	               var arrow = e.event.target;
	               that._handleLineDrag('drag', e, arrow.lineType);
	           });
	           this.conPointsGroup.on("ConnectPoint:dragend", function(e) {
	               var arrow = e.event.target;
	               that._handleLineDrag('dragend', e, arrow.lineType);
	           });
	           this._zr.add(this.conPointsGroup);
	       }
	
	       /**
	        * 处理连线和连接点drag事件
	        * @method _handleLineDrag
	        * @param  {String} dragType drag类型
	        * @param  {Object} e   event事件对象
	        * @param  {String} lineType 连线类型
	        */
	       fishTopoProto._handleLineDrag = function(dragType, e, lineType) {
	            var that = this;
	            var x = e.event.offsetX;
	            var y = e.event.offsetY;
	            function findConnectorNode(x, y, offset, pos) {
	                var node, endPos = null;
	                that.allNodes.forEach(function(item) {
	                    var calculateRect = that.calculateRect(item);
	                    var connectorPoint = util.getConnectorPoints(calculateRect, { rotation: calculateRect.rotation });
	                    if (pos) {
	                        if (Math.abs(connectorPoint[pos].x - x) <= offset && Math.abs(connectorPoint[pos].y - y) <= offset) {
	                            node = item;
	                        }
	                    } else {
	                        if (Math.abs(connectorPoint["left"].x - x) <= offset && Math.abs(connectorPoint["left"].y - y) <= offset) {
	                            endPos = "left";
	                            node = item;
	                        } else if (Math.abs(connectorPoint["top"].x - x) <= offset && Math.abs(connectorPoint["top"].y - y) <= offset) {
	                            endPos = "top";
	                            node = item;
	                        } else if (Math.abs(connectorPoint["right"].x - x) <= offset && Math.abs(connectorPoint["right"].y - y) <= offset) {
	                            endPos = "right";
	                            node = item;
	                        } else if (Math.abs(connectorPoint["bottom"].x - x) <= offset && Math.abs(connectorPoint["bottom"].y - y) <= offset) {
	                            endPos = "bottom";
	                            node = item;
	                        }
	                    }
	                });
	                return {
	                    node: node,
	                    endPos: endPos
	                };
	            }
	            var point = new Point(x, y);
	            if (dragType === 'drag') {
	            if (that.reverseConnect) {
	                that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, lineType, that.endPos);
	            } else {
	                that.connectionManager.manageTempConnector(that.selectConnNode, point, lineType, that.startPos);
	            }
	            that.conPointsGroup.children().forEach(function (v) {
	                v.attr({style:{fill: "#FFFF33"},scale:[1,1],origin:[v.shape.cx,v.shape.cy],cursor:'crosshair'});
	                if (Math.abs(v.shape.cx - x) <= 10 && Math.abs(v.shape.cy - y) <= 10) {
	                    var res = findConnectorNode(x, y, 10);
	                    if (that.reverseConnect) {
	                        that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, lineType, that.endPos, res.endPos, res.node);
	                    } else {
	                        that.connectionManager.manageTempConnector(that.selectConnNode, point, lineType, that.startPos, res.endPos, res.node);
	                    }
	                    v.attr({style:{fill: "#ff0000"},scale:[1.5,1.5],origin:[v.shape.cx,v.shape.cy],cursor:'pointer'});
	                }
	            })
	            }
	            if (dragType === 'dragend') {
	            var res = findConnectorNode(x, y, 10);
	            var targetNode = res.node;
	            var start;
	            var end;
	            var endPos = res.endPos || 'left';
	            var startPos;
	            var canConnect = false;       //两个节点是否可以连线的标识
	            //删除临时线
	            that.connectionManager.removeTempConnector(that._zr);
	            if (that.selectConnNode.parent && Bpmn.isSubProcess(that.selectConnNode.parent)) {
	                if (targetNode && Bpmn.isSlotEvent(that.selectConnNode)) {
	                    // 当前节点是边界节点可连线
	                    canConnect = true;
	                }
	                if (targetNode && targetNode.parent && Bpmn.isSubProcess(targetNode.parent) && targetNode.parent.id === that.selectConnNode.parent.id) {
	                    // 起始节点都在同一个子节点内则可以连线
	                    canConnect = true;
	                }
	            } else {
	                if (targetNode && !targetNode.parent) {
	                    canConnect = true;
	                }
	                if (targetNode && targetNode.parent && Bpmn.isSubProcess(targetNode.parent) && Bpmn.isSlotEvent(targetNode)) {
	                    // 目标节点是边界节点可连线
	                    canConnect = true;
	                }
	            }
	            //2.如果找到目标结点 则画线
	            if (canConnect && (that.selectConnNode.id !== targetNode.id)) {
	                var connectOptions = {
	                    style: {
	                        lineType: lineType
	                    }
	                }
	                var finalOpt = util.mergeOpt(connectOptions, that.lineOpt, true);
	                start = that.reverseConnect ? targetNode : that.selectConnNode;
	                end = that.reverseConnect ? that.selectConnNode : targetNode;
	                startPos = that.reverseConnect ? endPos : that.startPos;
	                endPos = that.reverseConnect ? that.endPos : endPos;
	                that._createConnectorByNodes(start, end, finalOpt, startPos, endPos);
	                that.hideConnectorPoint();      //隐藏所有节点上的连接点
	                that.hideConnectorControl();      //隐藏所有节点上的控制点
	            } else {
	                if (that.originNode) {
	                    //如果连线失败，且原始线段存在，则还原原始线段
	                    start = that.reverseConnect ? that.originNode : that.selectConnNode;
	                    end = that.reverseConnect ? that.selectConnNode : that.originNode;
	                    startPos = that.reverseConnect ? that.originPos : that.startPos;
	                    endPos = that.reverseConnect ? that.endPos : that.originPos;
	                    that._createConnectorByNodes(start, end, { style: that.lineOpt }, startPos, endPos);
	                    that.hideConnectorPoint();      //隐藏所有节点上的连接点
	                } else {
	                    //还原所有连接点的颜色
	                    that.conPointsGroup.children().forEach(function (v) {
	                        v.attr({style:{fill: "#FFFF33"},scale:[1,1],origin:[v.shape.cx,v.shape.cy],cursor:'crosshair'});
	                    });
	                }
	            }
	            }
	        }
	
	        fishTopoProto.showConnectorControl = function() {
	            var that = this;
	            this.hideConnectorControl();
	            // 让当前节点显示控制点
	            var calculateRect = this.calculateRect(this.selectedNode);
	            var node = {
	                id: this.selectedNode.id,
	                rotation: calculateRect.rotation
	            }
	            var connectorPoint = util.getConnectorControls(calculateRect, node);
	            var params = this.returnConnectorControlParam(this.selectedNode);
	            if (params.scaleable) {
	                that.createConnectorControl(connectorPoint.tl, "tl", node);
	                that.createConnectorControl(connectorPoint.tr, "tr", node);
	                that.createConnectorControl(connectorPoint.bl, "bl", node);
	                that.createConnectorControl(connectorPoint.br, "br", node);
	            }
	            if (params.rotatable) {
	                that.createConnectorControl(connectorPoint.mtr, "mtr", node);
	                that.createConnectorControl({ top: connectorPoint.mtr, bottom: connectorPoint.tc }, "mtr,tc", node);
	            }
	
	            function findControlNode (id) {
	                var node = null;
	                that.allNodes.forEach(function(item) {
	                    if (item.id === id) {
	                            node = item;
	                    }
	                });
	                return node;
	            }
	
	            this.conControlsGroup.on("ConnectControl:dragstart", function(e) {
	                // 首先清除其他所有节点的控制点和连接点
	                var cursor = e.event.target.cursor;
	                var pos = e.event.target.pos;
	                var posMap = {
	                    'tl': 'br',
	                    'tr': 'bl',
	                    'bl': 'tr',
	                    'br': 'tl'
	                };
	                that.selectConnNode = findControlNode(e.nodeId);
	                if (cursor && pos !== 'mtr') {
	                    var originNode = that.conControlsGroup.children().find(function (node) {
	                        return node.pos === posMap[pos];
	                    });
	                    var currentNode = that.conControlsGroup.children().find(function (node) {
	                        return node.pos === pos;
	                    });
	                    var boundingRect = that.selectConnNode.getBoundingRect();
	                    that.oppositeShape = zrUtil.clone(originNode.shape);
	                    that.currentShape = zrUtil.clone(currentNode.shape);
	                    var rect = zrUtil.clone(that.calculateRect(that.selectConnNode));
	                    var diagonal = Math.sqrt(Math.pow(rect.width, 2) + Math.pow(rect.height, 2));// 对角线长度
	                    that.diagonal = diagonal;
	                    that.originRect = zrUtil.clone(rect);
	                    that.ifPointCenter = boundingRect.x < -1; // 判断中心点是否在节点中心(原形在中心，矩形在左上角)
	                    // 移除node高亮
	                    that.selectConnNode.selectStyle && that._api.getZr().removeHover(that.selectConnNode);
	                }
	                Guidelines.createGuidelines(that._zr);
	            });
	            this.conControlsGroup.on("ConnectControl:drag", function(e) {
	                var pixel = that.opts.showGridLine ? that.opts.gridLineSpacing : 1;
	                var cursor = e.event.target.cursor;
	                var targetPos = e.event.target.pos;
	                var currentNode = that.selectConnNode;
	                var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;
	                var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;
	                var rectOrigin = util.getRect(currentNode, true);
	                if (targetPos === 'mtr') {
	                    if (currentNode.parent && Bpmn.isSubProcess(currentNode.parent)) {
	                        x -= BpmnUtil.parentX(currentNode.parent);
	                        y -= BpmnUtil.parentY(currentNode.parent);
	                    }
	                    // 旋转
	                    var m = parseInt(((x -currentNode.position[0]) / pixel), 10);
	                    var n = parseInt(((y -currentNode.position[1]) / pixel), 10);
	                    var r_x = pixel * m;
	                    var r_y = pixel * n;
	                    var origins = {
	                        x: rectOrigin.x - currentNode.position[0],
	                        y: rectOrigin.y - currentNode.position[1]
	                    }
	                    var rotation = Math.atan2(r_y, r_x);
	                    that.selectedNode.attr({
	                        'origin': [origins.x, origins.y],
	                        'rotation': -rotation
	                    });
	                    var calculateRect = that.calculateRect(that.selectedNode);
	                    var connectorPoint = util.getConnectorPoints(calculateRect, { rotation: calculateRect.rotation });
	                    var controlPoint = util.getConnectorControls(calculateRect, { rotation: calculateRect.rotation });
	                    // 节点连线点，控制点位置更新
	                    that.conPointsGroup.children().forEach(function (item) {
	                        var pos = item.pos;
	                        if (item.type === 'ConnectPoint') {
	                            item.setShape({ cx: connectorPoint[pos].x, cy: connectorPoint[pos].y });
	                        }
	                    });
	                    that.conControlsGroup.children().forEach(function (item) {
	                        var pos = item.pos;
	                        if (item.type === 'ConnectControl') {
	                            if (pos === 'mtr') {
	                                item.attr('position', [0, 0]);
	                                item.attr('rotation', 0);
	                            }
	                            item.setShape({ x: controlPoint[pos].x - 4, y: controlPoint[pos].y - 4 });
	                            item.attr({
	                                'origin': [item.shape.x + 4, item.shape.y + 4],
	                                'rotation': -rotation
	                            });
	                        } else if (item.type === 'ConnectControlLine') {
	                            item.setShape({ x1: controlPoint.mtr.x, x2: controlPoint.tc.x, y1: controlPoint.mtr.y, y2: controlPoint.tc.y });
	                        }
	                    });
	                } else {
	                    // 缩放(缩放点需要结合旋转角度计算)
	                    var ratio = 1,
	                        center = [],
	                        centerPoint = {},
	                        width0, height0, difference;
	                    var cursorsY = ['n-resize', 's-resize'];
	                    var positionOrg = {
	                        'tl': 'br',
	                        'tr': 'bl',
	                        'bl': 'tr',
	                        'br': 'tl'
	                    }
	
	                    var scaleNodes = that.conControlsGroup.children().filter(function (node) {
	                        return node.type === 'ConnectControl' && node.pos !== 'mtr'
	                    });
	                    var currentControlNode = scaleNodes.find(function(node) {
	                        return node.pos === targetPos;
	                    });
	
	                    if (x <= 8) {
	                        x = 8;
	                    }
	                    if (y <= 8) {
	                        y = 8;
	                    }
	
	                    if (cursorsY.includes(cursor)) {
	                        // 获取y轴比例即可
	                        var startY = currentControlNode.shape.y + 4;
	                        difference = Math.abs(y - that.oppositeShape.y - 4) - Math.abs(startY - that.oppositeShape.y);
	                        if (Math.abs(difference) % pixel !== 0) {
	                            difference = Math.round(difference / pixel) * pixel;
	                        }
	                        ratio = (Math.abs(startY - that.oppositeShape.y) + difference) / Math.abs(startY - that.oppositeShape.y);
	                    } else {
	                        // 获取x轴比例即可
	                        var startX = currentControlNode.shape.x + 4;
	                        difference = Math.abs(x - that.oppositeShape.x - 4) - Math.abs(startX - that.oppositeShape.x);
	                        if (Math.abs(difference) % pixel !== 0) {
	                            difference = Math.round(difference / pixel) * pixel;
	                        }
	                        ratio = (Math.abs(startX - that.oppositeShape.x) + difference) / Math.abs(startX - that.oppositeShape.x);
	                    }
	                    if (!/^[0-9]+.?[0-9]*/.test(ratio)) {
	                        ratio = 1;
	                    }
	                    currentNode.updateShape(ratio);
	
	                    var rectScale = util.getRect(currentNode);
	                    centerPoint = that.ifPointCenter ? { x: that.originRect.x, y: that.originRect.y } : { x: that.originRect.boundingRect.x, y: that.originRect.boundingRect.y };
	                    var diagonalNew = Math.sqrt(Math.pow(rectScale.width, 2) + Math.pow(rectScale.height, 2));// 对角线长度
	                    switch (cursor) {
	                        // 上,左上
	                        case 'n-resize':
	                        case 'nw-resize':
	                            width0 = (that.oppositeShape.x + 4 - centerPoint.x) * diagonalNew / that.diagonal;
	                            height0 = (that.oppositeShape.y + 4 - centerPoint.y) * diagonalNew / that.diagonal;
	                            center.push(that.oppositeShape.x - width0 + 4, that.oppositeShape.y - height0 + 4);
	                            break;
	                        // 右,右上
	                        case 'e-resize':
	                        case 'ne-resize':
	                            width0 = (centerPoint.x - that.oppositeShape.x - 4) * diagonalNew / that.diagonal;
	                            height0 = (that.oppositeShape.y + 4 - centerPoint.y) * diagonalNew / that.diagonal;
	                            center.push(that.oppositeShape.x + width0 + 4, that.oppositeShape.y - height0 + 4);
	                            break;
	                        // 下，右下
	                        case 's-resize':
	                        case 'se-resize':
	                            width0 = (centerPoint.x - that.oppositeShape.x - 4) * diagonalNew / that.diagonal;
	                            height0 = (centerPoint.y - that.oppositeShape.y - 4) * diagonalNew / that.diagonal;
	                            center.push(that.oppositeShape.x + width0 + 4, that.oppositeShape.y + height0 + 4);
	                            break;
	                        // 左,左下
	                        case 'w-resize':
	                        case 'sw-resize':
	                            width0 = (that.oppositeShape.x + 4 - centerPoint.x) * diagonalNew / that.diagonal;
	                            height0 = (centerPoint.y - that.oppositeShape.y - 4) * diagonalNew / that.diagonal;
	                            center.push(that.oppositeShape.x - width0 + 4, that.oppositeShape.y + height0 + 4);
	                            break;
	                        default:
	                            break;
	                    }
	
	                    if (currentNode.parent && Bpmn.isSubProcess(currentNode.parent)) {
	                        var parentRect = that.calculateRect(currentNode.parent);
	                        var newPosition = util.calculatePoints(center, parentRect, -parentRect.rotation);
	                        center = [newPosition[0] - parentRect.boundingRect.x, newPosition[1] - parentRect.boundingRect.y];
	                    }
	
	                    var originScale = {
	                        x: rectScale.x - center[0],
	                        y: rectScale.y - center[1]
	                    }
	                    currentNode.attr({
	                        'position': center,
	                        'origin': [originScale.x, originScale.y]
	                    });
	
	                    // 此时节点包围盒需要重新计算
	                    var rectNow = that.calculateRect(currentNode);
	                    var connectorPointScale = util.getConnectorPoints(rectNow, { rotation: rectNow.rotation });
	                    var controlPointScale = util.getConnectorControls(rectNow, { rotation: rectNow.rotation });
	                    that.conControlsGroup.children().forEach(function(item) {
	                        var pos = item.pos;
	                        if (pos === targetPos) {
	                            item.attr('position', [0, 0]);
	                        }
	                        if (item.type === 'ConnectControl' && pos !== positionOrg[targetPos]) {
	                            item.setShape({ x: controlPointScale[pos].x - 4, y: controlPointScale[pos].y - 4 });
	                            item.attr('origin', [controlPointScale[pos].x, controlPointScale[pos].y]);
	                        } else if (item.type === 'ConnectControlLine') {
	                            item.setShape({ x1: controlPointScale.mtr.x, x2: controlPointScale.tc.x, y1: controlPointScale.mtr.y, y2: controlPointScale.tc.y });
	
	                        }
	                    });
	                    that.conPointsGroup.children().forEach(function(item) {
	                        var pos = item.pos;
	                        if (item.type === 'ConnectPoint') {
	                            item.setShape({ cx: connectorPointScale[pos].x, cy: connectorPointScale[pos].y });
	                        }
	                    });
	                }
	                var currentRect = that.calculateRect(that.selectedNode);
	                that.operationNode.refreshPostion(that.selectedNode, currentRect);
	                if (that.selectedNode.slotEvent && that.selectedNode.slotEvent.length > 0) {
	                    // 更新事件节点
	                    that.updateSlotEvent(that.selectedNode);
	                }
	                // 1.5 刷新连线
	                that.connectionManager.refreshLineByNode(that.selectedNode);
	                // 1.6 刷新对齐线
	                Guidelines.judgeAlignment(that.selectedNode, [currentRect.x, currentRect.y], that.domArray, that.getWidth(), that.getHeight());
	            });
	            this.conControlsGroup.on("ConnectControl:dragend", function(e) {
	                // 更新节点position
	                var targetPos = e.event.target.pos;
	                var node = that.selectConnNode;
	                var pixel = that.opts.showGridLine ? that.opts.gridLineSpacing : 1;
	                var position = node.position;
	                var origin = node.origin;
	                // position origin取整
	                that.selectConnNode.attr('position', [Math.round(position[0] / pixel) * pixel, Math.round(position[1] / pixel) * pixel]);
	                if (Array.isArray(origin)) {
	                    that.selectConnNode.attr('origin', [Math.round(origin[0] / pixel) * pixel, Math.round(origin[1] / pixel) * pixel]);
	                }
	                // 宽高取整
	                if (targetPos !== 'mtr') {
	                    node.updateShape(1, true, pixel);
	                }
	                // 更新事件节点
	                if (node.slotEvent && node.slotEvent.length > 0) {
	                    that.updateSlotEvent(node);
	                }
	                // 更新domArray
	                zrUtil.each(that.domArray, function(item, index) {
	                    if (item.id === node.id) {
	                        var rect = util.getRect(node);
	                        item.rotation = node.rotation;
	                        item.position = [rect.x, rect.y];
	                        item.width = rect.width;
	                        item.height = rect.height;
	                        item.points = that._getControlsOfNode(node);
	                        that.domArray[index] = item;
	                    }
	                })
	                if (node.model) {
	                    // 更新model，支持序列化/反序列化
	                    node.model.set("options.rotation", node.rotation);
	                    node.model.set("options.origin", node.origin);
	                    var elementType = node.model.option.elementType;
	                    if (elementType === 'Image') {
	                        node.model.set("options.style", node.style);
	                    } else {
	                        node.model.set("options.shape", node.shape);
	                    }
	                }
	                Guidelines.resetLines();
	                // 1.4 触发点击
	                that.nodeClickHandler(node);
	                that.stepCounter();
	                that.oppositeShape = null;
	                that.currentShape = null;
	                that.diagonal = null;
	                that.originRect = null;
	                that.ifPointCenter = null;
	            });
	            this._zr.add(this.conControlsGroup);
	        }
	
	       fishTopoProto.getRotatedCornerCursor = function(node, pos) {
	           var that = this;
	           var rotation = node.rotation;
	           if (pos === 'mtr') {
	               return that.cursorMap[pos];
	           }
	           if (Math.abs(rotation) > 0) {
	               var angle = -rotation / (Math.PI/180);
	               var n = Math.round((angle % 360) / 45);
	               if (n < 0) {
	                   n += 8; // full circle ahead
	               }
	               n += that.cursorOffset[pos];
	               n %= 8;
	               return that.cursorMaps[n];
	           }
	           return that.cursorMap[pos];
	       }
	
	       fishTopoProto.createConnectorControl = function(point, pos, node) {
	           var me = this;
	           var posArr = pos.split(',');
	           if (posArr.length < 2) {
	               var controlCursor = me.getRotatedCornerCursor(node, pos);
	               var pointInstance = new graphic.Rect({
	                   shape:{
	                       x: point.x - 4,
	                       y: point.y - 4,
	                       width: 8,
	                       height: 8
	                   },
	                   style: {
	                       fill: '#ffffff',
	                       stroke:'#000000'
	                   },
	                   z: 2,
	                   rotation: node.rotation,
	                   origin: [point.x, point.y],
	                   cursor: controlCursor,
	                   draggable: true
	               });
	               pointInstance.type = 'ConnectControl';
	               pointInstance.pos = pos;// 记录是节点上哪个位置的连接点
	               var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	               zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	                   pointInstance.on(eveName, function(e) {
	                       var params = {};
	                       params.event = e;
	                       params.type = "ConnectControl:" + eveName;
	                       params.nodeId = node.id;
	                       params.cursor = controlCursor;
	                       me.conControlsGroup.trigger(params.type, params);
	                   });
	               });
	               this.conControlsGroup.add(pointInstance);
	           } else {
	               // 旋转点与节点之间需要连线
	               var line = new graphic.Line({
	                   shape: {
	                       x1: point.top.x,
	                       y1: point.top.y,
	                       x2: point.bottom.x,
	                       y2: point.bottom.y
	                   },
	                   style: {
	                       lineWidth: 1
	                   },
	                   z: 1,
	                   draggable: false,
	                   cursor: 'default'
	               });
	               line.type = 'ConnectControlLine';
	               line.nodeId = node.id;
	               this.conControlsGroup.add(line);
	           }
	       }
	
	       /**
		     * 获取节点的四角坐标
		     * @param  {[type]} node [description]
		     */
	       fishTopoProto._getControlsOfNode = function(node) {
	           var points = [];
	           var calculateRect = this.calculateRect(node);
	           var controls = util.getConnectorControls(calculateRect, { rotation: calculateRect.rotation });
	           points = [controls.tl, controls.tr, controls.bl, controls.br];
	           return points
	       }
	
	       fishTopoProto.returnConnectorControlParam = function(node) {
	           var scaleFlag = false;
	           var rotateFlag = false;
	           if (this.opts.scaleable) {
	               scaleFlag = true;
	           }
	           if (node.model.get("properties.scaleable")) {
	               scaleFlag = true;
	           } else {
	               scaleFlag = false;
	           }
	           if (node.scaleable) {
	               scaleFlag = true;
	           } else if (!node.scaleable && !node.model.get("properties.scaleable")) {
	               scaleFlag = false;
	           }
	
	           if (this.opts.rotatable) {
	               rotateFlag = true;
	           }
	           if (node.model.get("properties.rotatable")) {
	               rotateFlag = true;
	           } else {
	               rotateFlag = false;
	           }
	           if (node.rotatable) {
	               rotateFlag = true;
	           } else if (!node.rotatable && !node.model.get("properties.rotatable")) {
	               rotateFlag = false;
	           }
	           return {
	               scaleable: scaleFlag,
	               rotatable: rotateFlag
	           }
	       }
	
	       fishTopoProto.ifShowConnectorPoint = function(node) {
	           var connectable = node && typeof node.connectable === 'boolean' ? node.connectable : this.opts.connectable;
	           return connectable;
	       }
	
	       fishTopoProto.hideConnectorControl = function() {
	           this.conControlsGroup.removeAll();  //隐藏所有节点上的连接点
	           this.conControlsGroup.off();        //清空所有事件
	           this._zr.remove(this.conControlsGroup);
	       }
	
	       /**
	        * 点击连线按钮时创建除选中节点外其余节点边框上的连接点
	        */
	       fishTopoProto.createLineConnectorPoint = function(point, pos, lineType) {
	           var pointInstance = new graphic.Circle({
	               shape: {
	                   cx: point.x,
	                   cy: point.y,
	                   r: 4
	               },
	               style: {
	                   fill: '#FFFF33',
	                   stroke:'#000000'
	               },
	               z : 4,
	               draggable: true,
	               lineType: lineType
	           });
	           pointInstance.type = 'ConnectPoint';
	           pointInstance.pos = pos;                //记录是节点上哪个位置的连接点
	
	           this.conPointsGroup.add(pointInstance);
	       }
	
	       /**
	        * @private
	        * 初始化 操作的虚线框
	        */
	       fishTopoProto.initOperationNode = function(node) {
	           var that = this;
	           this.operationNode = new OperationNode(node, this._zr, this._api, this.forbidEdit);
	           function findConnectorNode(x, y, offset, pos) {
	               var node, endPos = null;
	               that.allNodes.forEach(function(item) {
	                   var canShowPoint = false;
	                   if (item !== that.selectedNode) {
	                       if (that.selectedNode.parent && Bpmn.isSubProcess(that.selectedNode.parent)) {
	                           if(item.parent && Bpmn.isSubProcess(item.parent) && item.parent.id === that.selectedNode.parent.id){
	                               canShowPoint = true;
	                           }
	                           if (Bpmn.isSlotEvent(that.selectedNode)) {
	                               canShowPoint = true;
	                           }
	                       } else {
	                           if (!(item.parent && Bpmn.isSubProcess(item.parent))) {
	                               canShowPoint = true;
	                           }
	                           if (item.parent && Bpmn.isSubProcess(item.parent) && Bpmn.isSlotEvent(item)) {
	                               canShowPoint = true;
	                           }
	                       }
	                   }
	                   if (canShowPoint) {
	                       var realNodeCal = that.calculateRect(item);
	                       var connectorPoint = util.getConnectorPoints(realNodeCal, { rotation: realNodeCal.rotation });
	                       if (pos) {
	                           if (Math.abs(connectorPoint[pos].x - x) <= offset && Math.abs(connectorPoint[pos].y - y) <= offset) {
	                               node = item;
	                           }
	                       } else {
	                           if (Math.abs(connectorPoint["left"].x - x) <= offset && Math.abs(connectorPoint["left"].y - y) <= offset) {
	                               endPos = "left";
	                               node = item;
	                           } else if (Math.abs(connectorPoint["top"].x - x) <= offset && Math.abs(connectorPoint["top"].y - y) <= offset) {
	                               endPos = "top";
	                               node = item;
	                           } else if (Math.abs(connectorPoint["right"].x - x) <= offset && Math.abs(connectorPoint["right"].y - y) <= offset) {
	                               endPos = "right";
	                               node = item;
	                           } else if (Math.abs(connectorPoint["bottom"].x - x) <= offset && Math.abs(connectorPoint["bottom"].y - y) <= offset) {
	                               endPos = "bottom";
	                               node = item;
	                           }
	                       }
	                   }
	               });
	               return {
	                   node: node,
	                   endPos: endPos
	               };
	           }
	           // 侦听 箭头 拖拽开始事件
	           this.operationNode.on(OperationNode.ARROW_DRAGSTART, function(e) {
	               that.hideConnectorPoint();
	               that.filterConnectPoint(that.allNodes, e.event.target.lineType);
	               that._zr.add(that.conPointsGroup);
	               var x = e.event.offsetX;
	               var y = e.event.offsetY;
	               //拖拽开始先把 箭头图标 给隐藏
	               var arrow = e.event.target;
	               if (e.data) {
	                   that.lineOpt = e.data;  //缓存线段的配置信息
	               }
	               arrow.hide();
	               var rEndPoint = new Point(x, y);
	               var connector = that.connectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType);
	               that._zr.add(connector);
	           });
	
	           // 侦听 箭头 拖拽事件
	           this.operationNode.on(OperationNode.ARROW_DRAG, function(e) {
	               var x = e.event.offsetX;
	               var y = e.event.offsetY;
	               var rEndPoint = new Point(x, y);
	               var arrow = e.event.target;
	               that.connectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType);
	               that.conPointsGroup.children().forEach(function (v) {
	                   v.attr({style:{fill: "#FFFF33"},scale:[1,1],origin:[v.shape.cx,v.shape.cy],cursor:'crosshair'});
	                   if (Math.abs(v.shape.cx - x) <= 10 && Math.abs(v.shape.cy - y) <= 10) {
	                       var res = findConnectorNode(x, y, 10);
	                       that.connectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType, 'right', res.endPos, res.node);
	                       v.attr({style:{fill: "#ff0000"},scale:[1.5,1.5],origin:[v.shape.cx,v.shape.cy],cursor:'pointer'});
	                   }
	               })
	           });
	
	           //侦听 箭头 拖拽结束事件 画线
	           this.operationNode.on(OperationNode.ARROW_DRAGEND, function(e) {
	               var x = e.event.offsetX;
	               var y = e.event.offsetY;
	               var targetNode = null;
	               //拖拽结束先把 箭头图标 给显示
	               var arrow = e.event.target;
	               arrow.show();
	
	               var res = findConnectorNode(x, y, 10);
	               var start;
	               var end;
	               var endPos = res.endPos || 'left';
	               var startPos;
	               var canConnect = false;       //两个节点是否可以连线的标识
	               targetNode = res.node;
	               arrow = e.event.target;
	               //删除临时线
	               that.connectionManager.removeTempConnector(that._zr);
	               if (that.selectedNode.parent && Bpmn.isSubProcess(that.selectedNode.parent)) {
	                    if (targetNode && Bpmn.isSlotEvent(that.selectedNode)) {
	                        // 当前节点是边界节点可连线
	                        canConnect = true;
	                    }
	                   if (targetNode && targetNode.parent && Bpmn.isSubProcess(targetNode.parent) && targetNode.parent.id === that.selectedNode.parent.id) {
	                       // 起始节点都在同一个子节点内则可以连线
	                       canConnect = true;
	                   }
	               } else {
	                   if (targetNode && !targetNode.parent) {
	                       canConnect = true;
	                   }
	                   if (targetNode && targetNode.parent && Bpmn.isSubProcess(targetNode.parent) && Bpmn.isSlotEvent(targetNode)) {
	                       // 目标节点是边界节点可连线
	                       canConnect = true;
	                   }
	               }
	               //2.如果找到目标结点 则画线
	               if (canConnect && (that.selectedNode.id !== targetNode.id)) {
	                   var connectOptions;
	                   start = that.selectedNode;
	                   end = targetNode;
	                   startPos = 'right';
	                   if (e.data) {
	                       connectOptions = e.data;
	                   } else {
	                       connectOptions = {
	                           style: {
	                               lineType: arrow.lineType
	                           }
	                       }
	                   }
	                   that._createConnectorByNodes(start, end, connectOptions, startPos, endPos);
	               }
	               that.hideConnectorPoint();      //隐藏所有节点上的连接点
	               // 连线成功/失败，当前节点依然是选中状态，需要重新计算虚线和图标位置
	               var node = that.selectedNode;
	               var shapeRect = that.calculateRect(node);
	               // 显示当前节点的连接点
	               that.showConnectorPoint(undefined, undefined, true);
	               that.operationNode.refreshPostion(node, shapeRect);
	           });
	           //删除按钮点击事件
	           this.operationNode.on("OperationNode:deleteClick", function() {
	               that.removeNode(that.selectedNode);
	           });
	           //注释按钮点击事件
	           this.operationNode.on("OperationNode:commentClick", function() {
	               var start = that.selectedNode;
	               if (!start.hasComment) {
	                   var endX, endY;
	                   if (start.bpmnInfo.name.indexOf('Event') !== -1 || start.bpmnInfo.name.indexOf('Gateway') !== -1) {
	                       endX = start.position[0] + 40;
	                       endY = start.position[1] - 80;
	                   } else if (start.nodeType === "SubProcess") {
	                       endX = start.position[0] + 200;
	                       endY = start.position[1] - 80;
	                   } else {
	                       endX = start.position[0] + 120;
	                       endY = start.position[1] - 80;
	                   }
	                   var model = new BPMNModel({});
	                   model.set(Bpmn.BPMN_TYPE, 'Comment');
	                   model.set("bounds.upperLeft", {x: endX, y: endY});
	                   model.set("properties", {
	                       name: "comment",
	                       operationIcons: [{name:'DEL', callback: function(e) {
	                           start.hasComment = false;
	                           that.remove(end);
	                       }}]
	                   });
	                   var end = that.addNodeByModel(model, true);
	                   model = new BPMNModel({});
	                   model.set("resourceId", util.getUUID());
	                   model.set("style.lineType", "straight");
	                   model.set("style.lineDash", [3]);
	                   model.set("style.stroke", "#000");
	                   model.set("symbol.type", "none");
	                   model.set("stencil.type", "SequenceFlow");
	                   var connector = that.connectionManager.connectorCreateByOptions(start, end, {model: model}, that._api);
	                   that._zr.add(connector);
	                   start.hasComment = true;
	               }
	           });
	           this._zr.add(this.operationNode);
	       };
	
	       fishTopoProto.findNodeChildIds = function (node, childIds) {
	           childIds.push(node.id);
	           node.children().filter(function (v) {
	               var pos = this.allNodes.findIndex(function (item) {
	                   return item.id === v.id
	               });
	               return pos !== -1
	           }.bind(this)).forEach(function (sub) {
	               if (Bpmn.isSubProcess(sub)) {
	                   this.findNodeChildIds(sub, childIds);
	               } else {
	                   childIds.push(sub.id);
	               }
	           }.bind(this));
	       }
	
	       /**
	        * 移除场景中的某个节点
	        * @param  {Object} selectedNode 待删除的节点
	        */
	       fishTopoProto.remove = fishTopoProto.removeNode = function(delNode) {
	           var parentZr = this._getParentZr(delNode), _this = this;
	           if (delNode instanceof Connector) {
	               this._triggerAsync('beforeDeleteLine', {target: delNode}, delNode).then(function (res) {
	                   if (res) {
	                       // 1.1 删除线段上的操作图标
	                       zrUtil.each(delNode.icons, function(lineOperationIcon) {
	                           parentZr.remove(lineOperationIcon);
	                       })
	                       // 1.2 删除当前选中线段
	                       _this.connectionManager.deleteLine(parentZr);
	                       _this._trigger('afterDeleteLine', {target: delNode});
	                       _this.stepCounter();
	                   }
	               });
	           } else {
	               this._triggerAsync('beforeDeleteNode', {target: delNode}, delNode).then(function (res) {
	                   if (res) {
	                       parentZr.remove(delNode);
	                       var childIds = [];
	                       if (Bpmn.isSubProcess(delNode)) {
	                           _this.findNodeChildIds(delNode, childIds);
	                       } else {
	                           childIds.push(delNode.id);
	                       }
	                       //2.从allNodes数组中删除
	                       _this.allNodes = _this.allNodes.filter(function (v) {
	                           return childIds.indexOf(v.id) === -1
	                       });
	                       _this.domArray = _this.domArray.filter(function (v) {
	                           return childIds.indexOf(v.id) === -1
	                       });
	                       for (var k = 0; k < _this.overlapArray.length; k++) {
	                           if (delNode.id == _this.overlapArray[k].id) {
	                               _this.overlapArray.splice(k, 1);
	                           }
	                       }
	                       if (Bpmn.isSubProcess(delNode)) {
	                           for (var m = 0; m < _this.subProcessNode.length; m++) {
	                               if (delNode.id == _this.subProcessNode[m].id) {
	                                   _this.subProcessNode.splice(m, 1);
	                               }
	                           }
	                       }
	                       // 删除节点操作
	                       _this._removeOperationNode();
	                       //3.将此节点交联的线也删除
	                       _this.connectionManager.deleteSelectCon(delNode, Bpmn.isSlotEvent(delNode) ? _this._zr : parentZr);
	                       //如果删除节点是task节点，需要将依附它的事件节点删除
	                       if (Bpmn.isActivity(delNode) || Bpmn.isSubProcess(delNode)) {
	                           if (delNode.slotEvent && delNode.slotEvent.length > 0) {
	                               for (var m = 0; m < delNode.slotEvent.length; m++) {
	                                   if (delNode.slotEvent[m].parent) {
	                                       if (Bpmn.isSubProcess(delNode.slotEvent[m].parent)) {
	                                           delNode.slotEvent[m].parent.remove(delNode.slotEvent[m]);
	                                       }
	                                   } else {
	                                       _this._zr.remove(delNode.slotEvent[m]);
	                                   }
	                                   for (var n = 0; n < _this.allNodes.length; n++) {
	                                       if (delNode.slotEvent[m].id == _this.allNodes[n].id) {
	                                           _this.allNodes.splice(n, 1);
	                                       }
	                                   }
	                                   for (var a = 0; a < _this.domArray.length; a++) {
	                                       if (delNode.slotEvent[m].id == _this.domArray[a].id) {
	                                           _this.domArray.splice(a, 1);
	                                       }
	                                   }
	                               }
	                           }
	                       }
	                       //4.如果删除的是事件节点，需要将绑定它的task节点的标识删除
	                       if (Bpmn.isSlotEvent(delNode)) {
	                           for (var b = 0; b < _this.allNodes.length; b++) {
	                               if (_this.allNodes[b].isCanSlot) {
	                                   if (_this.allNodes[b].slotEvent && _this.allNodes[b].slotEvent.length > 0) {
	                                       for (var c = 0; c < _this.allNodes[b].slotEvent.length; c++) {
	                                           if (delNode.id == _this.allNodes[b].slotEvent[c].id) {
	                                               _this.allNodes[b].slotEvent.splice(c, 1);
	                                           }
	                                       }
	                                   }
	                               }
	                           }
	                       }
	                       _this._trigger('afterDeleteNode', {target: delNode});
	                       _this.stepCounter();
	                   }
	               });
	           }
	       };
	       fishTopoProto.removeSelectedNodes = function() {
	           var that = this;
	           if (this.selectedNodes.length) {
	               var childs = that.dragSelectRect.children().filter(function (v) {
	                   return v.name !== "GROUP_RECT_NAME" && !Bpmn.isFlow(v);
	               });
	               var lines = that.dragSelectRect.children().filter(function (v) {
	                   return v.name !== "GROUP_RECT_NAME" && Bpmn.isFlow(v);
	               });
	               that.connectionManager.connectors.forEach(function (v) {
	                   var startNode = childs.find(function(node) {
	                       return node.id === v.startNode.id
	                   });
	                   var endNode = childs.find(function(node) {
	                       return node.id === v.endNode.id
	                   });
	                   var ifExist = lines.findIndex(function(line) {
	                       return line.id === v.id
	                   });
	                   if ((startNode || endNode) && ifExist === -1) {
	                       that.connectionManager.removeLine(v, v.parent ? v.parent : that._zr);
	                   }
	               });
	               this.selectedNodes.forEach(function(item) {
	                   that.removeNode(item);
	               });
	               this.selectedNodes = [];
	               this.dragSelectRect.off("mousedown");
	               this._zr.remove(this.dragSelectRect);
	           } else {
	               that.removeNode(that.selectedNode);
	           }
	       };
	       fishTopoProto._createConnectorByNodes = function(startNode, endNode, lineType, startPos, endPos) {
	           var _this = this;
	           this._triggerAsync('beforeCreateLine', {target: startNode}, [startNode, endNode]).then(function (res) {
	               if (res) {
	                   var connector = _this.connectionManager.connectorCreate(startNode, endNode, lineType, _this._api, startPos, endPos);
	                   if (startNode.parent && endNode.parent && startNode.parent.resourceId === endNode.parent.resourceId) {
	                       endNode.parent.add(connector);
	                   } else {
	                       _this._zr.add(connector);
	                   }
	                   _this.connectionManager.connectorForbidEdit();
	                   _this._createConnectorDragEvents(connector);
	                   connector.on("mousedown", zrUtil.bind(function(e) {
	                       this.lineOperationManager.isEdit = !this.forbidEdit;
	                       this.isNode = false;
	                       // 取消节点的选中
	                       this.hideConnectorPoint();
	                       this.hideConnectorControl();
	                       this._removeOperationNode();
	                    //    this.showConnectorPoint(e.target.style.lineType);
	                   }, _this));
	                   _this._trigger('afterCreateLine', {target: connector});
	                   _this.stepCounter();
	                   return connector;
	               }
	           })
	       };
	
	       fishTopoProto._createConnectorDragEvents = function(connector) {
	            var that = this;
	            connector.on("dragstart", function (e) {
	                var x = e.event.offsetX;
	                var y = e.event.offsetY;
	                var opt = this.opt;
	                var lineType = opt.style.lineType;
	                var dockers = opt.dockers;
	                var startPoint = dockers[0];
	                var endPoint = dockers[dockers.length - 1];
	                var startDiff = Math.abs(x - startPoint.x) + Math.abs(y - startPoint.y);
	                var endDiff = Math.abs(x - endPoint.x) + Math.abs(y - endPoint.y);
	                if (startDiff > 15 && endDiff > 15) {
	                    return;
	                }
	                var point = new Point(x, y);
	                that.showConnectorPoint(undefined, undefined);
	                that.reverseConnect = false;   //是否反向连线的标识
	                that.selectConnNode = connector.startNode;
	                that.lineOpt = opt.style; //缓存线段的配置信息
	                if (endDiff <= 15) {
	                    that.selectConnNode = connector.startNode;
	                    that.startPos = opt.style.sPos;
	                    that.originNode = this.endNode;
	                    that.originPos = opt.style.ePos;
	                }
	                if (startDiff <= 15) {
	                    that.reverseConnect = true;
	                    that.selectConnNode = connector.endNode;
	                    that.endPos = opt.style.ePos;
	                    that.originNode = this.startNode;
	                    that.originPos = opt.style.sPos;
	                }
	                that.connectionManager.deleteByLine(this, that._zr);
	                var connectorLine;
	                if (that.reverseConnect) {
	                    connectorLine = that.connectionManager.manageReverseTempConnector(point, that.selectConnNode, lineType, that.endPos);
	                } else {
	                    connectorLine = that.connectionManager.manageTempConnector(that.selectConnNode, point, lineType, that.startPos);
	                }
	                that._zr.add(connectorLine);
	                connectorLine.setSelectedStyle();
	            });
	            connector.on("drag", function (e) {
	                that._handleLineDrag('drag', e, this.opt.style.lineType);
	            });
	            connector.on("dragend", function (e) {
	                that._handleLineDrag('dragend', e, this.opt.style.lineType);
	                that.hideConnectorPoint();
	                that.hideConnectorControl();
	            });
	       }
	
	       fishTopoProto._triggerAsync = function(type, event, data) {
	           return this._trigger(type, event, data, true);
	       }
	       fishTopoProto._trigger = function(type, event, data, async) {
	           var callback = this.opts[type];
	
	           if (data === void 0) data = {};
	           if (event === null) {
	               event = {type:type, target:this}
	           } else {
	               event.type = type;
	           }
	           event.data = data;
	           this._api.trigger(event.type, event);
	           if (async) {
	               return promise.resolve(zrUtil.isFunction(callback) ? callback.apply(this, [event].concat(data)) : true)
	               .then(function (value) {
	                   return !(value === false);
	               }).catch(function (error) {
	                   console.log(error);
	               });
	           } else {
	               return !(zrUtil.isFunction(callback) && callback.apply(this, [event].concat(data)) === false);
	           }
	       }
	
	       /**
	        * @private
	        * 鼠标点下 将操作框 移到对应的节点上
	        * @param  {Object} node [description]
	        * @return {Object}      [description]
	        */
	       fishTopoProto.nodeClickHandler = function(node) {
	            var ifShowPoint = node.type !== 'dragSelect' && this.ifShowConnectorPoint(node);
	            if (node.parent && node.parent.type === "dragSelect") {
	                ifShowPoint = false;
	            }
	            // 1. 隐藏连线点
	            this.hideConnectorPoint();
	            // 2. 隐藏控制点
	            this.hideConnectorControl();
	            // 3. 隐藏操作node
	            this._removeOperationNode();
	            this._trigger('editOperationIcons', {target: node}, node.operationIcons);
	            if (this.forbidEdit === true) {
	                return;
	            }
	            this.selectedNode = node;
	            var shapeRect = this.calculateRect(node);
	            if (!this.operationNode) {
	                this.initOperationNode(node);
	            }
	            this.rect && this.rect.attr("style", {
	                stroke: "rgba(0, 0, 0, 1)"
	            });
	
	            if (ifShowPoint) {
	                // 显示当前节点的连接点
	                this.showConnectorPoint(undefined, undefined, true);
	                var params = this.returnConnectorControlParam(node);
	                if (params.scaleable || params.rotatable) {
	                    // 显示当前节点的控制点
	                    this.showConnectorControl();
	                }
	            }
	            this.operationNode.refreshPostion(node, shapeRect);
	        };
	
	       /**
	        * 初始化虚框对齐线
	        * @private
	        * @param  {Object} node [description]
	        * @param  {Object} shapeList [description]
	        */
	       fishTopoProto.initVirtualLine = function(node, shapeList) {
	           Guidelines.createGuidelines(this._zr);
	           this.rect = new graphic.Polyline({
	               position: [shapeList.x, shapeList.y],
	               shape: {
	                   points: shapeList.points
	               },
	               style: {
	                   lineDash: [2]
	               },
	               rotation: node.rotation,
	               z: 3
	           });
	           this._zr.add(this.rect);
	       };
	       //绑定事件节点
	       fishTopoProto.bindEventNode = function() {
	           //mousedown的时候为每个task创建插槽
	           for (var i = 0; i < this.allNodes.length; i++) {
	               if (this.allNodes[i].isCanSlot) {
	                   this.creatSlot(this.allNodes[i]);
	               }
	           }
	           //mouseup的时候删除插槽
	           this._zr.on("mouseup", function() {
	               for (var i = 0; i < this.allNodes.length; i++) {
	                   if (this.allNodes[i].isCanSlot) {
	                       if (this.allNodes[i].slot && this.allNodes[i].slot.length > 0) {
	                           for (var m = 0; m < this.allNodes[i].slot.length; m++) {
	                               this.allNodes[i].remove(this.allNodes[i].slot[m]);
	                           }
	                       }
	                   }
	               }
	           }.bind(this))
	
	       };
	
	       /**
	        * @private
	        */
	       fishTopoProto.creatSlot = function(node) {
	           //给task创建8个插槽
	           node.slot = [];
	           var position = util.getSoltPoints(node);
	           for (var j = 0; j < 8; j++) {
	               var Circle = new graphic.Circle({
	                   position: position[j],
	                   shape: {
	                       cx: 0,
	                       cy: 0,
	                       r: 10
	                   },
	                   style: {
	                       lineWidth: 1,
	                       stroke: 'rgba(0,0,0,0.6)',
	                       fill: 'transparent'
	                   }
	               });
	               node.slot.push(Circle);
	               node.add(Circle);
	           }
	       };
	
	       fishTopoProto.updateSlotEvent = function(node) {
	           if (node.slotEvent && node.slotEvent.length > 0) {
	               var position = util.getSoltPoints(node);
	               for (var n = 0; n < node.slotEvent.length; n++) {
	                   var index = node.slotEvent[n].index;
	                   var slotEventPosition2 = position[index];
	                   if (!Bpmn.isSubProcess(node)) {
	                       slotEventPosition2 = [position[index][0] + node.position[0], position[index][1] + node.position[1]]
	                   }
	                   node.slotEvent[n].attr("position", slotEventPosition2);
	                   this.connectionManager.refreshLineByNode(node.slotEvent[n]);
	               }
	           }
	       }
	
	       fishTopoProto._posInWhichSubprocess = function(containerNodes, node) {
	           if (containerNodes.length > 0) {
	               for (var i = 0; i < containerNodes.length; i++) {
	                   var containerNode = containerNodes[i];
	                   var rect = containerNode.getRect();
	                   var nodeWidth = rect.width;
	                   var nodeHeight = rect.height;
	                   var nodeX = BpmnUtil.parentX(containerNode);
	                   var nodeY = BpmnUtil.parentY(containerNode);
	                   if (node.x >= nodeX && node.y >= nodeY &&
	                       node.x+node.width <= nodeX+nodeWidth && node.y+node.height <= nodeY+nodeHeight) {
	                       var newNode;
	                       if (containerNode.children() && containerNode.children().length > 0) {
	                           var newContainer = containerNode.children().filter(function (item) {
	                               return item.bpmnInfo && item.nodeType === 'SubProcess'
	                           });
	                           newNode = this._posInWhichSubprocess(newContainer, node);
	                       }
	                       return newNode || containerNode;
	                   }
	               }
	           }
	           return null;
	       }
	
	       fishTopoProto.getDragSelectContainer = function () {
	           var LeftUpperPosX = [];
	           var LeftUpperPosY = [];
	           var RightLowerPosX = [];
	           var RightLowerPosY = [];
	           this.dragSelectRect.children().filter(function (v) {
	               return v.name !== "GROUP_RECT_NAME" && !Bpmn.isFlow(v);
	           }).forEach(function (item) {
	               var rect = item.getRect();
	               var nodeWidth = rect.width;
	               var nodeHeight = rect.height;
	               var nodeX = rect.x;
	               var nodeY = rect.y;
	
	               if (Bpmn.isEvent(item) || Bpmn.isGateway(item)) {
	                   LeftUpperPosX.push(nodeX - nodeWidth);
	                   LeftUpperPosY.push(nodeY - nodeHeight);
	                   RightLowerPosX.push(nodeX + nodeWidth);
	                   RightLowerPosY.push(nodeY + nodeHeight);
	               } else {
	                   LeftUpperPosX.push(nodeX - nodeWidth/2);
	                   LeftUpperPosY.push(nodeY - nodeHeight/2);
	                   RightLowerPosX.push(nodeX + nodeWidth/2);
	                   RightLowerPosY.push(nodeY + nodeHeight/2);
	               }
	           });
	           return {
	               x: Math.min.apply(Math, LeftUpperPosX),
	               y: Math.min.apply(Math, LeftUpperPosY),
	               width: Math.max.apply(Math, RightLowerPosX) - Math.min.apply(Math, LeftUpperPosX),
	               height: newHeight = Math.max.apply(Math, RightLowerPosY) - Math.min.apply(Math, LeftUpperPosY)
	           }
	       }
	
	       /**
	        * @private
	        * mousedown后 开始拖动
	        */
	       fishTopoProto.newDrag = function(dom, sX, sY) {
	           var that = this;
	           that._removeOperationNode();
	           that.hideConnectorPoint();
	           that.hideConnectorControl();
	           that.selectedNode = dom;
	           that.isNode = true;
	           var pixel = this.opts.showGridLine ? this.opts.gridLineSpacing : 1;
	           var shapeList = this.calculateRect(dom);
	           var domArray = that.domArray;
	           //zrender不支持键盘事件，只能侦听body元素上的了
	           document.body.onkeydown = function (e) {
	               var ev = e || window.event;
	               //判断 delete按键
	               if (ev.keycode == 46 || ev.charCode == 46 || ev.which == 46) {
	                   //1.如果是节点,移除事件,进行删除  如果是子节点 通过parent删除
	                   if (that.isNode == true) {
	                       that.selectedNode.off();
	                       if (that.selectedNode.parent) {
	                           if (Bpmn.isSubProcess(that.selectedNode.parent)) {
	                               that.selectedNode.parent.remove(that.selectedNode);
	                           }
	                       } else {
	                           that._zr.remove(that.selectedNode);
	                       }
	                       //2.删除维护的节点数组
	                       for (var i = 0; i < that.allNodes.length; i++) {
	                           if (that.selectedNode.id == that.allNodes[i].id) {
	                               that.allNodes.splice(i, 1);
	                           }
	                       }
	                       for (var j = 0; j < domArray.length; j++) {
	                           if (that.selectedNode.id == domArray[j].id) {
	                               domArray.splice(j, 1);
	                           }
	                       }
	                       for (var k = 0; k < that.overlapArray.length; k++) {
	                           if (that.selectedNode.id == that.overlapArray[k].id) {
	                               that.overlapArray.splice(k, 1);
	                           }
	                       }
	                       //3.移去操作框
	                       if (that.operationNode) {
	                           that._zr.remove(that.operationNode);
	                           that.operationNode = null;
	                       }
	                       //3.删除对应的线
	                       that.connectionManager.deleteSelectCon(that.selectedNode, that._zr);
	                   } else { //否则直接删除线
	                       that.connectionManager.deleteLine(that._zr);
	                   }
	                   // 4.删除连接点和控制点
	                   that.hideConnectorPoint();
	                   that.hideConnectorControl();
	                   that.stepCounter();
	               }
	           }
	
	           //初始化 对齐线
	           var startX, startY, rectPositionX, rectPositionY;
	           startX = sX;
	           startY = sY;
	           rectPositionX = shapeList.x;
	           rectPositionY = shapeList.y;
	           if (!that.rect) {
	               that.initVirtualLine(dom, shapeList);
	               that.rect.attr("position", [rectPositionX, rectPositionY]);
	           } else {
	               that.rect.attr({
	                   "position": [rectPositionX, rectPositionY],
	                   "rotation": shapeList.rotation || dom.rotation
	               });
	               that.rect.setShape({points: shapeList.points});
	               that.rect.show();
	           }
	           var nowRectPosition = [rectPositionX, rectPositionY];
	           var nowDragRectPosition, dragRectPositionX, dragRectPositionY, dragRect;
	           var dgRect, startContainer;
	           if (dom.type === "dragSelect") {
	               dragRect = this.getDragSelectContainer();
	               dragRectPositionX = dragRect.x + dragRect.width/2 + this.dragSelectRect.position[0];
	               dragRectPositionY = dragRect.y + dragRect.height/2 + this.dragSelectRect.position[1];
	               nowDragRectPosition = [dragRectPositionX, dragRectPositionY];
	
	               dgRect = that.dragSelectRect.getRect();
	               startContainer = that._posInWhichSubprocess(that.subProcessNode, {
	                   x: dgRect.x - dgRect.width/2,
	                   y: dgRect.y - dgRect.height/2,
	                   width: dgRect.width,
	                   height: dgRect.height
	               });
	           }
	
	           var isLap = 0;
	           var isMove = 0;
	           var moveFunction = function(e) {
	               moveDrag(e);
	           };
	           var upFunction = function(e) {
	               endDrag(e);
	           };
	           this._zr.on('mousemove', moveFunction);
	
	           //开始移动,节点移动时取消所有节点的选中状态
	           function moveDrag(e) {
	               //以10个像素为单位进行移动
	               var maxRectPosition = [that.getWidth() - (that.rect.shape.points[1][0] - that.rect.shape.points[0][0]) / 2, that.getHeight() - (that.rect.shape.points[2][1] - that.rect.shape.points[1][1]) / 2];
	               var minRectPosition = [(that.rect.shape.points[1][0] - that.rect.shape.points[0][0]) / 2, (that.rect.shape.points[2][1] - that.rect.shape.points[1][1]) / 2];
	               for (var n = 0; n < Math.abs(parseInt((e.event.clientX - startX) / pixel)); n++) {
	                   isMove = 1;
	                   if (e.event.clientX - startX < 0) {
	                       nowRectPosition[0] = rectPositionX - pixel * (n);
	                       if (dom.type === "dragSelect") {
	                           nowDragRectPosition[0] = dragRectPositionX - pixel * (n);
	                       }
	                   } else {
	                       nowRectPosition[0] = rectPositionX + pixel * (n);
	                       if (dom.type === "dragSelect") {
	                           nowDragRectPosition[0] = dragRectPositionX + pixel * (n);
	                       }
	                   }
	                   if (nowRectPosition[0] < minRectPosition[0]) {
	                       nowRectPosition[0] = minRectPosition[0];
	                   }
	                   if (nowRectPosition[0] > maxRectPosition[0]) {
	                       nowRectPosition[0] = maxRectPosition[0];
	                   }
	               }
	               for (var m = 0; m < Math.abs(parseInt((e.event.clientY - startY) / pixel)); m++) {
	                   isMove = 1;
	                   if (e.event.clientY - startY < 0) {
	                       nowRectPosition[1] = rectPositionY - pixel * (m);
	                       if (dom.type === "dragSelect") {
	                           nowDragRectPosition[1] = dragRectPositionY - pixel * (m);
	                       }
	                   } else {
	                       nowRectPosition[1] = rectPositionY + pixel * (m);
	                       if (dom.type === "dragSelect") {
	                           nowDragRectPosition[1] = dragRectPositionY + pixel * (m);
	                       }
	                   }
	                   if (nowRectPosition[1] < minRectPosition[1]) {
	                       nowRectPosition[1] = minRectPosition[1];
	                   }
	                   if (nowRectPosition[1] > maxRectPosition[1]) {
	                       nowRectPosition[1] = maxRectPosition[1];
	                   }
	               }
	               that.rect.attr('position', nowRectPosition);
	
	               function resultSuccess() {
	                   isLap = 0;
	                   that.rect.attr("style", {
	                       stroke: "rgba(0, 0, 0, 1)"
	                   });
	               }
	
	               function resultFalse() {
	                   isLap = 1;
	                   that.rect.attr("style", {
	                       stroke: "rgba(255, 0, 0, 1)"
	                   });
	               }
	
	               function isChild(node, subNode) {
	                   if (subNode.parent) {
	                       if (subNode.parent.id === node.id) {
	                           return true;
	                       } else {
	                           return isChild(node, subNode.parent);
	                       }
	                   }
	                   return false;
	               }
	
	               that.containerNode = null;
	               if (dom.type === "dragSelect") {
	                   var subNode = that._posInWhichSubprocess(that.subProcessNode, {
	                       x: nowDragRectPosition[0] - dragRect.width/2,
	                       y: nowDragRectPosition[1] - dragRect.height/2,
	                       width: dragRect.width,
	                       height: dragRect.height
	                   });
	                   var targetContainer = that._JudgeNodeInWhichSubProcess(that.subProcessNode, {x: e.event.offsetX, y: e.event.offsetY});
	                   if (!startContainer && targetContainer) {
	                       resultFalse();
	                   } else {
	                       resultSuccess();
	                   }
	                   that.resetBackground();
	                   if (startContainer && !subNode) {
	                       //改变画布颜色
	                       that.containerNode = 'zr';
	                       that.setBackground("#b6e3f5");
	                   } else {
	                       that.allNodes.filter(function (v) {
	                           return Bpmn.isSubProcess(v);
	                       }).forEach(function (item) {
	                           if (subNode && subNode.id === item.id) {
	                               resultSuccess();
	                               that.containerNode = item;
	                               if (!startContainer || (startContainer && startContainer.id !== item.id)) {
	                                   item.children().forEach(function (v) {
	                                       if (v.name === "subprocess-rect") {
	                                           if (!v.initStyle) {
	                                               var initFill = v.style.fill;
	                                               v.attr("initStyle", initFill);
	                                           }
	                                           v.attr("style", {
	                                               fill:'#b6e3f5'
	                                           });
	                                       }
	                                   });
	                               }
	                           } else {
	                               item.children().forEach(function (v) {
	                                   if (v.name === "subprocess-rect") {
	                                       if (!v.initStyle) {
	                                           var initFill = v.style.fill;
	                                           v.attr("initStyle", initFill);
	                                           v.attr("style", {
	                                               fill: v.initStyle
	                                           });
	                                       } else {
	                                           v.attr("style", {
	                                               fill: v.initStyle
	                                           });
	                                       }
	                                   }
	                               });
	                           }
	                       });
	                   }
	                   return true;
	               }
	
	               Guidelines.judgeAlignment(that.selectedNode, nowRectPosition, domArray, that.getWidth(), that.getHeight());
	               var targetSub = that._JudgeNodeInWhichSubProcess(that.subProcessNode, {x: nowRectPosition[0], y: nowRectPosition[1]});
	               for (var l = 0, len = that.allNodes.length; l < len; l++) {
	                   var posX, posY;
	                   var currentNode = that.allNodes[l];
	                   var rectDom = currentNode.getRect();
	                   var canCompare = true;
	                   resultSuccess();
	
	                   if ((currentNode.id === dom.id) || (Bpmn.isSubProcess(dom) && isChild(dom, currentNode))) {
	                       continue;
	                   }
	                   that.resetBackground();
	                   if (Bpmn.isSubProcess(currentNode)) {
	                       currentNode.children().forEach(function (v) {
	                           if (v.name === "subprocess-rect") {
	                               if (!v.initStyle) {
	                                   var initFill = v.style.fill;
	                                   v.attr("initStyle", initFill);
	                                   v.attr("style", {
	                                       fill: v.initStyle
	                                   });
	                               } else {
	                                   v.attr("style", {
	                                       fill: v.initStyle
	                                   });
	                               }
	                           }
	                       });
	                       if (targetSub && targetSub.id === currentNode.id) {
	                           that.containerNode = currentNode;
	                           if (!dom.parent || (dom.parent && targetSub.id !== dom.parent.id)) {
	                               currentNode.children().forEach(function (v) {
	                                   if (v.name === "subprocess-rect") {
	                                       if (!v.initStyle) {
	                                           var initFill = v.style.fill;
	                                           v.attr("initStyle", initFill);
	                                       }
	                                       v.attr("style", {
	                                           fill:'#b6e3f5'
	                                       });
	                                   }
	                               })
	                           }
	                       }
	                       canCompare = false;
	                   }
	                   if (dom.parent && !targetSub) {
	                       //改变画布颜色
	                       that.containerNode = 'zr';
	                       that.setBackground("#b6e3f5");
	                   }
	                   if (currentNode.parent && Bpmn.isSubProcess(currentNode.parent)) {
	                       posX = rectDom.x + BpmnUtil.parentX(currentNode.parent);
	                       posY = rectDom.y + BpmnUtil.parentY(currentNode.parent);
	                   } else {
	                       posX = rectDom.x;
	                       posY = rectDom.y;
	                   }
	                   if (canCompare) {
	                       if (shapeList.width > rectDom.width) {
	                           //移动的位置 减去当前节点的位置 小于拖拽节点高度及宽度一半， 则有重叠 标红
	                           if (shapeList.height > rectDom.height) {
	                               if (Math.abs(nowRectPosition[0] - posX) < (rectDom.width+shapeList.width) / 2 && Math.abs(nowRectPosition[1] - posY) < (rectDom.height+shapeList.height) / 2) {
	                                   resultFalse();
	                                   break;
	                               } else {
	                                   resultSuccess();
	                               }
	                           } else {
	                               if (Math.abs(nowRectPosition[0] - posX) < (rectDom.width+shapeList.width) / 2 && Math.abs(nowRectPosition[1] - posY) < (rectDom.height+shapeList.height) / 2) {
	                                   resultFalse();
	                                   break;
	                               } else {
	                                   resultSuccess();
	                               }
	                           }
	                       } else {
	                           if (shapeList.height > rectDom.height) {
	                               if (Math.abs(nowRectPosition[0] - posX) < (rectDom.width+shapeList.width) / 2 && Math.abs(nowRectPosition[1] - posY) < (rectDom.height+shapeList.height) / 2) {
	                                   resultFalse();
	                                   break;
	                               } else {
	                                   resultSuccess();
	                               }
	                           } else {
	                               if (Math.abs(nowRectPosition[0] - posX) < (rectDom.width+shapeList.width) / 2 && Math.abs(nowRectPosition[1] - posY) < (rectDom.height+shapeList.height) / 2) {
	                                   resultFalse();
	                                   break;
	                               } else {
	                                   resultSuccess();
	                               }
	                           }
	                       }
	                   }
	               }
	
	               //判断事件节点是否可以依附，可以依附显示绿框
	               if (Bpmn.isSlotEvent(dom)) {
	                   for (var i = 0; i < that.allNodes.length; i++) {
	                       if (that.allNodes[i].isCanSlot) {
	                           if (that.allNodes[i].slot && that.allNodes[i].slot.length > 0) {
	                               for (var a = 0; a < that.allNodes[i].slot.length; a++) {
	                                   var slotPosition = [that.allNodes[i].slot[a].position[0] + that.allNodes[i].position[0], that.allNodes[i].slot[a].position[1] + that.allNodes[i].position[1]];
	                                   if (nowRectPosition[0] == slotPosition[0] && nowRectPosition[1] == slotPosition[1]) {
	                                       that.rect.attr("style", {
	                                           stroke: "rgba(0, 255, 0, 1)"
	                                       });
	                                       isLap = 0;
	                                       break;
	                                   }
	                               }
	                           }
	                       }
	                   }
	               }
	           }
	
	           function endDrag() {
	               that._zr.off('mousemove', moveFunction);
	               that._zr.off('mouseup', upFunction);
	               that._zr.off('globalout', upFunction);
	               if (dom.parent) {
	                   dom.parent.off("globalout", upFunction);
	               }
	               that.rect.hide();
	               Guidelines.resetLines();
	
	               //处理单击子节点内的某一个节点时，当前的容器节点不为该子节点的bug（为null）
	               if (!that.containerNode && dom.parent && Bpmn.isSubProcess(dom.parent)) {
	                   that.containerNode = dom.parent;
	               } else if (that.containerNode === 'zr') {
	                   that.containerNode = null;
	               }
	               var removeLine = false;
	               var groupNodePositionX = null, groupNodePositionY = null;
	               if (isLap == 0) {
	                   if (that.containerNode) {
	                       // 将当前节点和父节点摆正，再计算当前节点到父节点两边的垂直距离
	                       var parentRect = that.calculateRect(that.containerNode);
	                       var rotation = -parentRect.rotation;
	                       var newPosition = nowRectPosition;
	                       if (Math.abs(rotation) > 0) {
	                           newPosition = util.calculatePoints(nowRectPosition, parentRect, rotation);
	                       }
	                       groupNodePositionX = newPosition[0] - parentRect.boundingRect.x;
	                       groupNodePositionY = newPosition[1] - parentRect.boundingRect.y;
	                   }
	                   var posX = typeof groupNodePositionX === 'number' ? groupNodePositionX : nowRectPosition[0];
	                   var posY = typeof groupNodePositionY === 'number' ? groupNodePositionY : nowRectPosition[1];
	                   dom.setPosition(posX, posY);
	                   that.updateSlotEvent(dom);
	                   if (that.containerNode) {
	                       if (dom.parent && that.containerNode.id !== dom.parent.id) {
	                           dom.parent.remove(dom);
	                           that.containerNode.add(dom);
	                           removeLine = true;
	                       } else if (!dom.parent && dom.type !== "dragSelect") {
	                           that._zr.remove(dom);
	                           that.containerNode.add(dom);
	                           removeLine = true;
	                           for (var j = 0; j < that.overlapArray.length; j++) {
	                               if (dom.id == that.overlapArray[j].id) {
	                                   that.overlapArray.splice(j, 1);
	                               }
	                           }
	                       } else if (dom.type === "dragSelect") {
	                           var nodes = that.dragSelectRect.children().filter(function (v) {
	                               return v.name !== "GROUP_RECT_NAME" && !Bpmn.isFlow(v);
	                           });
	                           var lines = that.dragSelectRect.children().filter(function (v) {
	                               return v.name !== "GROUP_RECT_NAME" && Bpmn.isFlow(v);
	                           });
	
	                           that.connectionManager.connectors.forEach(function (v) {
	                               var startNode = nodes.find(function(node) {
	                                   return node.id === v.startNode.id
	                               });
	                               var endNode = nodes.find(function(node) {
	                                   return node.id === v.endNode.id
	                               });
	                               var ifExist = lines.findIndex(function(line) {
	                                   return line.id === v.id
	                               });
	                               if ((startNode || endNode) && ifExist === -1) {
	                                   that.connectionManager.removeLine(v, v.parent ? v.parent : that._zr);
	                               }
	                           });
	                           lines.forEach(function (line) {
	                               that.dragSelectRect.remove(line);
	                               that.containerNode.add(line);
	                           });
	                           var width = startContainer && startContainer.id === that.containerNode.id ? dgRect.width : dragRect.width;
	                           var height = startContainer && startContainer.id === that.containerNode.id ? dgRect.height : dragRect.height;
	                           for (var i = 0; i < nodes.length; i++) {
	                               var item = nodes[i];
	                               var nodeX = item.getRect().x;
	                               var nodeY = item.getRect().y;
	                               var nowX, nowY;
	                               if (startContainer && startContainer.id === that.containerNode.id) {
	                                   nowX = nowRectPosition[0];
	                                   nowY = nowRectPosition[1];
	                               } else {
	                                   nowX = nowDragRectPosition[0];
	                                   nowY = nowDragRectPosition[1];
	                               }
	                               var offsetX = nowX - BpmnUtil.parentX(that.containerNode) - width/2;
	                               var offsetY = nowY - BpmnUtil.parentY(that.containerNode) - height/2;
	                               var posx = nodeX + offsetX;
	                               var posy = nodeY + offsetY;
	                               if (item.slotEvent && item.slotEvent.length > 0) {
	                                   for (var n = 0; n < item.slotEvent.length; n++) {
	                                       var slotEventPosition2 = [item.slotEvent[n].position[0] + posx - zrUtil.clone(item.position[0]) - item.getBoundingRect().width / 2, item.slotEvent[n].position[1] + posy - zrUtil.clone(item.position[1]) - item.getBoundingRect().height / 2];
	                                       item.slotEvent[n].attr("position", slotEventPosition2);
	                                       that.connectionManager.refreshLineByNode(item.slotEvent[n]);
	                                   }
	                               }
	                               that.dragSelectRect.remove(item);
	                               that.containerNode.add(item);
	                               item.setPosition(posx, posy);
	                               if (item.originParent) {
	                                   item.originParent = null;
	                               }
	                               for (var m = 0; m < that.overlapArray.length; m++) {
	                                   if (item.id == that.overlapArray[m].id) {
	                                       that.overlapArray.splice(m, 1);
	                                   }
	                               }
	                               for (var n = 0; n < that.domArray.length; n++) {
	                                   if (item.id == that.domArray[n].id) {
	                                       that.domArray[n].position = [nodeX + (nowDragRectPosition[0] - width/2), nodeY + (nowDragRectPosition[1] - height/2)];
	                                   }
	                               }
	                               that.connectionManager.refreshLineByNode(item);
	                           }
	                           that.dragSelectRect.off("mousedown");
	                           that._zr.remove(that.dragSelectRect);
	                       }
	                       that.containerNode.children().forEach(function (v) {
	                           if (v.name === "subprocess-rect") {
	                               if (!v.initStyle) {
	                                   var initFill = v.style.fill;
	                                   v.attr("initStyle", initFill);
	                                   v.attr("style", {
	                                       fill: v.initStyle
	                                   });
	                               } else {
	                                   v.attr("style", {
	                                       fill: v.initStyle
	                                   });
	                               }
	                           }
	                       })
	                   } else if (dom.parent) {
	                       dom.parent.remove(dom);
	                       that._zr.add(dom);
	                       removeLine = true;
	                       if (!Bpmn.isSlotEvent(dom)) {
	                           that.overlapArray.push({
	                               id: dom.id,
	                               position: [nowRectPosition[0], nowRectPosition[1]],
	                               width: dom.getRect().width,
	                               height: dom.getRect().height
	                           });
	                       }
	                   }
	                   if (dom.type !== "dragSelect") {
	                       for (var b = 0; b < that.domArray.length; b++) {
	                           if (dom.id == that.domArray[b].id) {
	                               that.domArray[b].position = [nowRectPosition[0], nowRectPosition[1]];
	                           }
	                       }
	                       if (!that.containerNode && !dom.parent) {
	                           for (var j = 0; j < that.overlapArray.length; j++) {
	                               if (dom.id == that.overlapArray[j].id) {
	                                   that.overlapArray[j] = {
	                                       id: dom.id,
	                                       position: [nowRectPosition[0], nowRectPosition[1]],
	                                       width: dom.getRect().width,
	                                       height: dom.getRect().height
	                                   };
	                               }
	                           }
	                       }
	                   } else if (!that.containerNode) {
	                       var childs = that.dragSelectRect.children().filter(function (v) {
	                           return v.name !== "GROUP_RECT_NAME" && !Bpmn.isFlow(v);
	                       });
	                       var lines = that.dragSelectRect.children().filter(function (v) {
	                           return v.name !== "GROUP_RECT_NAME" && Bpmn.isFlow(v);
	                       });
	                       that.connectionManager.connectors.forEach(function (v) {
	                           var startNode = childs.find(function(node) {
	                               return node.id === v.startNode.id
	                           });
	                           var endNode = childs.find(function(node) {
	                               return node.id === v.endNode.id
	                           });
	                           var ifExist = lines.findIndex(function(line) {
	                               return line.id === v.id
	                           });
	                           if ((startNode || endNode) && ifExist === -1) {
	                               that.connectionManager.removeLine(v, v.parent ? v.parent : that._zr);
	                           }
	                       });
	                       var rectWidth = that.dragSelectRect.options.shape.width;
	                       var rectHeight = that.dragSelectRect.options.shape.height;
	                       for (var i = 0; i < childs.length; i++) {
	                           var node = childs[i];
	                           var x = node.getRect().x;
	                           var y = node.getRect().y;
	                           for (var p = 0; p < that.domArray.length; p++) {
	                               if (node.id == that.domArray[p].id) {
	                                   that.domArray[p].position = [x + (nowRectPosition[0] - rectWidth/2), y + (nowRectPosition[1] - rectHeight/2)];
	                               }
	                           }
	                           for (var q = 0; q < that.overlapArray.length; q++) {
	                               if (node.id == that.overlapArray[q].id) {
	                                   that.overlapArray[q].position = [x + (nowRectPosition[0] - rectWidth/2), y + (nowRectPosition[1] - rectHeight/2)];
	                               }
	                           }
	                       }
	                       if (startContainer) {
	                           that._releaseSelectNode(true);
	                       }
	                   }
	               } else if (that.containerNode) {
	                   that.containerNode.children().forEach(function (v) {
	                       if (v.name === "subprocess-rect") {
	                           if (!v.initStyle) {
	                               var initFill = v.style.fill;
	                               v.attr("initStyle", initFill);
	                               v.attr("style", {
	                                   fill: v.initStyle
	                               });
	                           } else {
	                               v.attr("style", {
	                                   fill: v.initStyle
	                               });
	                           }
	                       }
	                   });
	               }
	               that.resetBackground();
	               that.containerNode = null;
	
	               if (isMove == 1) {
	                   if (removeLine) {
	                       that.connectionManager.connectors.filter(function (v) {
	                           return v.startNode.id === dom.id || v.endNode.id === dom.id
	                       }).forEach(function (item) {
	                           that.connectionManager.removeLine(item, item.parent ? item.parent : that._zr);
	                       })
	                   } else {
	                       that.connectionManager.refreshLineByNode(dom);
	                   }
	                   that.nodeClickHandler(dom);
	                   that.stepCounter();
	               }
	
	               //将事件节点与task节点绑定或解绑
	               if (Bpmn.isSlotEvent(dom) && isLap == 0) {
	                   var newRectPosition = [];
	                   if (dom.parent) {
	                       if (Bpmn.isSubProcess(dom.parent)) {
	                           newRectPosition[0] = nowRectPosition[0] - BpmnUtil.parentX(dom.parent);
	                           newRectPosition[1] = nowRectPosition[1] - BpmnUtil.parentY(dom.parent);
	                       }
	                   } else {
	                       newRectPosition = nowRectPosition;
	                   }
	                   for (var i = 0; i < that.allNodes.length; i++) {
	                       if (that.allNodes[i].isCanSlot) {
	                           if (that.allNodes[i].slot && that.allNodes[i].slot.length > 0) {
	                               var unbind = true, exist = false, index;
	                               for (var c = 0; c < that.allNodes[i].slot.length; c++) {
	                                   var slotPosition = [that.allNodes[i].slot[c].position[0] + that.allNodes[i].position[0], that.allNodes[i].slot[c].position[1] + that.allNodes[i].position[1]];
	                                   if (nowRectPosition[0] == slotPosition[0] && nowRectPosition[1] == slotPosition[1]) {
	                                       unbind = false;
	                                       index = c;
	                                       break;
	                                   }
	                               }
	                               for (var k = 0; k < that.allNodes[i].slotEvent.length; k++) {
	                                   if (dom.id == that.allNodes[i].slotEvent[k].id) {
	                                       exist = true;
	                                       that.allNodes[i].slotEvent[k].index = index;
	                                       if (unbind) {
	                                           that.allNodes[i].slotEvent.splice(k, 1);
	                                       }
	                                   }
	                               }
	                               if (!exist && !unbind) {
	                                   // 标记slotEvent与node slot数组关联
	                                   dom.index = index;
	                                   that.allNodes[i].slotEvent.push(dom);
	                               } else if (exist && unbind) {
	                                   delete dom.index;
	                               }
	                           }
	                       }
	                   }
	               }
	           }
	
	           this._zr.on("mouseup", upFunction);
	           this._zr.on("globalout", upFunction);
	       };
	
	       fishTopoProto.setBackground = function (color) {
	           this.zrBackground = new graphic.Rect({
	               shape: {
	                   width: this._zr.getWidth(),
	                   height: this._zr.getHeight()
	               },
	               style: {
	                   fill: color
	               },
	               cursor: 'default',
	               z: -1
	           });
	           this._zr.add(this.zrBackground);
	       }
	
	       fishTopoProto.resetBackground = function () {
	           if (this.zrBackground) {
	               this._zr.remove(this.zrBackground);
	           }
	       }
	
	       /**
	        * @private
	        */
	       fishTopoProto.creatTip = function(node) {
	           //创建task内容的提示
	           var group = new graphic.Group();
	           group.isShow = false;
	           var name = node.model.get("properties.name") || "";
	           var showName;
	           if (name.length > 64) {
	               showName = name.substr(0, 64) + '..';
	           } else {
	               showName = name;
	           }
	           var text = new graphic.Text({
	               style: {
	                   text: showName,
	                   textFont: '16px Microsoft YaHei',
	                   fill: "#000000",
	                   textBaseline: "top" //垂直对齐
	               },
	               position: [2, 0],
	               z: 2
	           });
	           text.name = "Text";
	           group.add(text);
	           var Polyline = new graphic.Polyline({
	               style: {
	                   fill: '#f9f9f9',
	                   stroke: '#bbbbbb'
	               },
	               z: 1
	           });
	           Polyline.name = "Polyline";
	           group.add(Polyline);
	           // var groupPosition = [node.position[0] - node.getBoundingRect().width/2 - (group.getBoundingRect().width - 6), node.position[1]- node.getBoundingRect().height / 2 - group.getBoundingRect().height - 3];
	           // group.attr("position", groupPosition);
	           this._zr.add(group);
	           node.alarm = group;
	           group.hide();
	           group.eachChild(function(child) {
	               child.hide();
	           });
	       };
	
	       fishTopoProto.stepCounter = function() {
	           this.stepJson.splice(this.step, this.stepJson.length - (this.step));
	           this.step += 1;
	           var json = this.toJson();
	           this.stepJson.push(JSON.stringify(json));
	       };
	
	       /**
	        * 放大或者缩小
	        * @param  {String|Number} type 当为字符串时 "enlarge"放大  "narrowing"缩小  当为数值时 缩放的比例  建议0.3-1.7
	        */
	       fishTopoProto.zrScale = function (type) {
	           if (type == "narrowing") {
	               var zoomDelta1 = -0.07;
	               this.zoom(zoomDelta1, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	           }
	           if (type == "enlarge") {
	               var zoomDelta = 0.07;
	               this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	           }
	           if (!isNaN(type)) {
	               var target = this.group;
	               if (target) {
	                   var zoomScale = type / this._zoom;
	                   this._zoom = type;
	                   this.nowZoom = type;
	                   this.setScale(this._zr.getWidth() / 2, this._zr.getHeight() / 2, zoomScale);
	               }
	           }
	       };
	
	       /**
	        * @private
	        */
	       fishTopoProto.zoom = function (zoomDelta, zoomX, zoomY) {
	           var target = this.group;
	           if (target) {
	               var newZoom = this._zoom = this._zoom || 1;
	               newZoom += zoomDelta;
	               newZoom = Number(newZoom.toFixed(2));
	               var zoomScale = newZoom / this._zoom;
	               if (newZoom > 1.7 || newZoom < 0.3) {
	                   return;
	               }
	               this._zoom = newZoom;
	               this.nowZoom = newZoom;
	               this.setScale(zoomX, zoomY, zoomScale);
	           }
	       };
	
	       /**
	        * @private
	        */
	       fishTopoProto.setScale = function (zoomX, zoomY, zoomScale) {
	           var self = this;
	           var nodes = this.findElements(function(e){return true;});
	           var target = this.group;
	           nodes.push(target);
	           nodes.forEach(function (v) {
	               var pos = v.position;
	               var scale = v.scale;
	               scale[0] *= zoomScale;
	               scale[1] *= zoomScale;
	               v.attr("scale", [scale[0], scale[1]]);
	           });
	       };
	
	       /**
	        * @private
	        * 节点上文字编辑
	        */
	       fishTopoProto.nodeEdit = function (thisNode) {
	           var lineText = thisNode.childOfName('lineText');
	           if (this.forbidEdit === true) {
	               return;
	           }
	           var OFFSET_MULTIPLE = 0.55; //文本框宽度、高度的偏移系数
	           var isNotSetText = false;
	           var nodeRect = util.getRect(thisNode);
	           var textarea = this.createTextArea();
	           var nodeText = zrUtil.clone(thisNode.model.get("properties.name"));
	           var textRect = (thisNode instanceof Connector) && lineText ? textContain.getBoundingRect(lineText.style.text, "12px") : textContain.getBoundingRect(nodeText, "12px");
	           var textareaMinWidth = 0.6 * nodeRect.width;
	           var textareaWidth = (textRect.width == 0 ? textareaMinWidth : ((thisNode instanceof Connector) && (textRect.width > 60) ? 1.2 * textRect.width : 2 * textRect.width)) * this.nowZoom;
	           var textareaHeight = (2 * textRect.height || 24) * this.nowZoom;
	           textarea.style.width = textareaWidth + "px";
	           textarea.style.height = textareaHeight + "px";
	           var textareaMaxWidth = 1.2 * nodeRect.width * this.nowZoom;
	           textarea.style.maxWidth = textareaMaxWidth + "px";
	           textarea.style.lineHeight = (1.2 * textRect.lineHeight || 14.4) + "px";
	           textarea.style.border = "1px dashed #2e2e2e";
	           textarea.innerHTML = thisNode.model.get("properties.name");
	           this.setShapeModel(thisNode, {properties: {name: ""}});
	           this._dom.appendChild(textarea);
	           this._dom.style.position = "relative";
	           var offestI = 1;
	           var offestP = 0;
	           var posX = 0, posY = 0;
	           if (thisNode instanceof Connector) {//连线
	               if (thisNode.parent && Bpmn.isSubProcess(thisNode.parent)) {
	                   posX = BpmnUtil.parentX(thisNode.parent);
	                   posY = BpmnUtil.parentY(thisNode.parent);
	               }
	               if (lineText) { //有文本时
	                   textarea.style.top = (lineText.position[1] + posY + textRect.height / 2 - textareaHeight / 2) * this.nowZoom + this.group
	                       .position[1] + "px";
	                   textarea.style.left = (lineText.position[0] + posX - textareaWidth / 2) * this.nowZoom +
	                       this.group.position[0] + "px";
	               } else {
	                   var lineMiddlePos = thisNode.middle();
	                   textarea.style.top = (lineMiddlePos[1] + posY + textRect.height / 2 - textareaHeight / 2) * this.nowZoom + this.group
	                       .position[1] + "px";
	                   textarea.style.left = (lineMiddlePos[0] + posX - textareaWidth / 2) * this.nowZoom +
	                       this.group.position[0] + "px";
	               }
	           } else { //节点
	               if (thisNode.parent && Bpmn.isSubProcess(thisNode.parent)) {
	                   posX = nodeRect.x + BpmnUtil.parentX(thisNode.parent);
	                   posY = nodeRect.y + BpmnUtil.parentY(thisNode.parent);
	               } else {
	                   posX = nodeRect.x;
	                   posY = nodeRect.y;
	               }
	               textarea.style.top = (posY - textareaHeight / 2 + offestP * (nodeRect.height - textRect.height /
	                   2)) * this.nowZoom + this.group.position[1] + "px";
	               textarea.style.left = (posX - offestI * (textareaWidth < textareaMaxWidth ? textareaWidth : textareaMaxWidth) / 2) * this.nowZoom +
	                   this.group.position[0] + "px";
	           }
	           textarea.focus();
	           textarea.select();
	           textarea.onkeyup = function() {
	               if (event.keyCode == keyCode.ESCAPE) {
	                   isNotSetText = true;
	                   textarea.blur();
	               } else {
	                   var textRect = textContain.getBoundingRect(textarea.value, "12px");
	                   this._textareaResize(textRect, textarea, textarea.style.maxWidth);
	               }
	           }.bind(this);
	
	           textarea.onblur = function() {
	               if (!isNotSetText) {
	                   var text = this.handleWrap(textarea.value, textarea.style.maxWidth);
	                   this.setShapeModel(thisNode, {properties: {name: text}});
	                   this._trigger('afterEditNode', {target: thisNode});
	               } else {
	                   this.setShapeModel(thisNode, {properties: {name: nodeText}});
	               }
	               textarea.remove();
	           }.bind(this);
	       };
	
	       /**
	        * @private
	        * 创建文本域
	        */
	       fishTopoProto.createTextArea = function () {
	           var textarea = document.createElement("textarea");
	           textarea.style.position = "absolute";
	           textarea.style.padding = "6px";
	           textarea.style.resize = "none";
	           textarea.style.whiteSpace = "pre";
	           textarea.style.lineHeight = "125%";
	           textarea.style.overflow = "hidden";
	           textarea.style.border = "0";
	           textarea.spellcheck = false;
	           return textarea;
	       };
	
	       /**
	        * @private
	        * 处理textarea自动换行
	        */
	       fishTopoProto.handleWrap = function (value, width) {
	           var spanNode = document.createElement("span");
	           spanNode.style.position = "absolute";
	           spanNode.style.overflow = "hidden";
	           spanNode.style.border = "0";
	           spanNode.style.padding = "0";
	           spanNode.style.left = "0";
	           spanNode.style.top = "0";
	           this._dom.appendChild(spanNode);
	           var content = value.split("\n");
	           var result = "";
	           content.forEach(function (val, i) {
	               var valLength = val.length;
	               if (valLength == 0) {
	                   //result += "\n";
	               } else {
	                   var pre = "",
	                       innerVal, tempWidth, conWidth;
	                   for (var innerI = 0; innerI < valLength; innerI++) {
	                       innerVal = val.charAt(innerI);
	                       spanNode.innerHTML = spanNode.innerHTML + innerVal;
	                       tempWidth = spanNode.clientWidth; //获取添加字符后隐藏域的宽度
	                       conWidth = Number(width.substring(0, width.length - 2));
	                       if (tempWidth > conWidth) {
	                           result += pre; //如果追加字符后隐藏域宽度大于TextArea宽度，则表明该字符为下一行字符，
	                           result += "\n";
	                           spanNode.innerHTML = innerVal;
	                           pre = innerVal;
	                       } else if (innerI == valLength - 1) {
	                           result += pre + innerVal; //最后一个字符
	                           if (i < content.length - 1) {
	                               result += "\n";
	                           }
	                           spanNode.innerHTML = "";
	                           pre = "";
	                       } else {
	                           pre += innerVal; //依次追加到pre变量中
	                       }
	
	                   }
	               }
	           });
	           this._dom.removeChild(spanNode);
	           return result;
	       };
	
	       /**
	        * @private
	        * 文本域自适应高宽
	        */
	       fishTopoProto._textareaResize = function (textRect, textarea, width) {
	           var minWidth = 0;
	           textarea.style.width = 0;
	           textarea.style.width = (1.1 * textRect.width) * this.nowZoom + "px";
	           if (width < 60) {
	               minWidth = width;
	           } else {
	               minWidth = 60
	           }
	           if (textRect.width <= minWidth) {
	               textarea.style.width = minWidth + "px";
	           }
	           textarea.style.height = "0px";
	           textarea.style.height = textarea.scrollHeight + 'px';
	           if (textarea.scrollHeight <= 0) {
	               textarea.style.height = "12px";
	           }
	       }
	
	       zrUtil.mixin(FishTopoBpmn, Eventful);
	
	       // ---------对外暴露fishTopoBpmn------------------
	       var idBase = new Date() - 0;
	       var instances = {};
	       var DOM_ATTRIBUTE_KEY = '_fishTopoBpmn_instance_';
	
	       /**
	        * fishTopoBpmn全局对象，如果是amd方式加载，则直接返回
	        * @class fishTopoBpmn
	        * @singleton
	        */
	       var fishTopoBpmn = {
	           /**
	            * 版本号
	            * @type {String}
	            */
	           version: '3.2.0',
	           dependencies: {
	               zrender: '3.0.4'
	           }
	       };
	
	       /**
	        * 初始化dom元素为 bpmn对象
	        * @member fishTopoBpmn
	        * @param {HTMLElement} dom  一个div元素
	        * @param {Object} opts  传递的选项参数
	        * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'
	        * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化
	        * @return {fish.topo.FishTopoBpmn}
	        */
	       fishTopoBpmn.init = function(dom, opts) {
	           if (!dom) {
	               throw new Error('Initialize failed: invalid dom.');
	           }
	
	           opts = opts || {};
	           // Default value
	           zrUtil.defaults(opts, {
	               type: "bpmn",
	               showGridLine: true,
	               gridLineSpacing: 10,
	               beforeDeleteNode: null,  //删除节点之前的事件
	               beforeCreateNode:null,   //创建节点之前的事件
	               beforeDeleteLine: null,  //删除连线之前的事件
	               beforeCreateLine:null,    //创建连线之前的事件
	               connectable: true,
	               scaleable: false,
	               rotatable: false
	           });
	
	           var fishTopoBpmn = new FishTopoBpmn(dom, opts);
	           fishTopoBpmn.init();
	
	           fishTopoBpmn.id = 'ft_' + idBase++;
	           instances[fishTopoBpmn.id] = fishTopoBpmn;
	
	           dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBpmn.id);
	
	           return fishTopoBpmn;
	       };
	
	
	       /**
	        * 获取 dom 容器上的实例。
	        * @member fishTopoBpmn
	        * @param  {HTMLElement} dom 一个div元素
	        * @return {fish.topo.FishTopoBpmn}
	        */
	       fishTopoBpmn.getInstanceByDom = function(dom) {
	           var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
	           return instances[key];
	       };
	
	       /**
	        * 销毁实例，实例销毁后无法再被使用。
	        * @member fishTopoBpmn
	        * @param  {Object|string} chart fishTopoBpmn实例 或 fishTopoBpmn的id
	        */
	       fishTopoBpmn.dispose = function(chart) {
	           var topo;
	           if (zrUtil.isDom(chart)) {
	               topo = fishTopoBpmn.getInstanceByDom(chart);
	           } else if (typeof chart === 'string') {
	               topo = instances[chart];
	           }
	           if ((topo instanceof fishTopoBpmn) && !topo.isDisposed()) {
	               topo.dispose();
	           }
	       };
	       //暴露出去的类 方便用户扩展图元
	       fishTopoBpmn.Bpmn = Bpmn;
	       fishTopoBpmn.BPMNNode = BPMNNode;
	       fishTopoBpmn.graphic = graphic;
	       fishTopoBpmn.BoundingRect = BoundingRect;
	       fishTopoBpmn.BPMNModel = BPMNModel;
	
	       fishTopoBpmn.util = {};
	       zrUtil.each([
	               'map', 'each', 'filter', 'indexOf', 'inherits',
	               'reduce', 'filter', 'bind', 'curry', 'isArray',
	               'isString', 'isObject', 'isFunction', 'extend'
	           ],
	           function(name) {
	               fishTopoBpmn.util[name] = zrUtil[name];
	           }
	       );
	       module.exports = fishTopoBpmn;
	   


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var pathTool = __webpack_require__(5);
	    var round = Math.round;
	    var Path = __webpack_require__(6);
	    var colorTool = __webpack_require__(19);
	    var matrix = __webpack_require__(13);
	    var vector = __webpack_require__(14);
	    var Gradient = __webpack_require__(41);
	    var Draggable = __webpack_require__(42);
	
	    var graphic = {};
	    graphic.Util = zrUtil;
	    graphic.Group = __webpack_require__(43);
	
	    graphic.Image = __webpack_require__(44);
	
	    graphic.Text = __webpack_require__(45);
	
	    graphic.textContain = __webpack_require__(25);
	
	    graphic.Circle = __webpack_require__(46);
	
	    graphic.Sector = __webpack_require__(47);
	
	    graphic.Ring = __webpack_require__(50);
	
	    graphic.Polygon = __webpack_require__(51);
	
	    graphic.Polyline = __webpack_require__(55);
	
	    graphic.Rect = __webpack_require__(56);
	
	    graphic.Line = __webpack_require__(57);
	
	    graphic.BezierCurve = __webpack_require__(58);
	
	    graphic.Arc = __webpack_require__(59);
	
	    graphic.LinearGradient = __webpack_require__(60);
	
	    graphic.RadialGradient = __webpack_require__(61);
	
	    graphic.BoundingRect = __webpack_require__(26);
	    graphic.States = __webpack_require__(62);
	    /**
	     * Extend shape with parameters
	     */
	    graphic.extendShape = function (opts) {
	        return Path.extend(opts);
	    };
	
	    /**
	     * Extend path
	     */
	    graphic.extendPath = function (pathData, opts) {
	        return pathTool.extendFromString(pathData, opts);
	    };
	
	    /**
	     * Create a path element from path data string
	     * @param {string} pathData
	     * @param {Object} opts
	     * @param {module:zrender/core/BoundingRect} rect
	     * @param {string} [layout=cover] 'center' or 'cover'
	     */
	    graphic.makePath = function (pathData, opts, rect, layout) {
	        var path = pathTool.createFromString(pathData, opts);
	        Draggable.call(path);
	        var boundingRect = path.getBoundingRect();
	        if (rect) {
	            var aspect = boundingRect.width / boundingRect.height;
	
	            if (layout === 'center') {
	                // Set rect to center, keep width / height ratio.
	                var width = rect.height * aspect;
	                var height;
	                if (width <= rect.width) {
	                    height = rect.height;
	                }
	                else {
	                    width = rect.width;
	                    height = width / aspect;
	                }
	                var cx = rect.x + rect.width / 2;
	                var cy = rect.y + rect.height / 2;
	
	                rect.x = cx - width / 2;
	                rect.y = cy - height / 2;
	                rect.width = width;
	                rect.height = height;
	            }
	
	            this.resizePath(path, rect);
	        }
	
	        zrUtil.inherits(path, Draggable);
	        return path;
	    };
	
	    graphic.mergePath = pathTool.mergePath;
	
	    /**
	     * Resize a path to fit the rect
	     * @param {module:zrender/graphic/Path} path
	     * @param {Object} rect
	     */
	    graphic.resizePath = function (path, rect) {
	        if (!path.applyTransform) {
	            return;
	        }
	
	        var pathRect = path.getBoundingRect();
	
	        var m = pathRect.calculateTransform(rect);
	
	        path.applyTransform(m);
	    };
	
	    /**
	     * Sub pixel optimize line for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x1]
	     * @param {number} [param.shape.y1]
	     * @param {number} [param.shape.x2]
	     * @param {number} [param.shape.y2]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeLine = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	
	        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
	            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
	        }
	        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
	            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
	        }
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize rect for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x]
	     * @param {number} [param.shape.y]
	     * @param {number} [param.shape.width]
	     * @param {number} [param.shape.height]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeRect = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	        var originX = shape.x;
	        var originY = shape.y;
	        var originWidth = shape.width;
	        var originHeight = shape.height;
	        shape.x = subPixelOptimize(shape.x, lineWidth, true);
	        shape.y = subPixelOptimize(shape.y, lineWidth, true);
	        shape.width = Math.max(
	            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,
	            originWidth === 0 ? 0 : 1
	        );
	        shape.height = Math.max(
	            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,
	            originHeight === 0 ? 0 : 1
	        );
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize for canvas
	     *
	     * @param {number} position Coordinate, such as x, y
	     * @param {number} lineWidth Should be nonnegative integer.
	     * @param {boolean=} positiveOrNegative Default false (negative).
	     * @return {number} Optimized position.
	     */
	    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {
	        // Assure that (position + lineWidth / 2) is near integer edge,
	        // otherwise line will be fuzzy in canvas.
	        var doubledPosition = round(position * 2);
	        return (doubledPosition + round(lineWidth)) % 2 === 0
	            ? doubledPosition / 2
	            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
	    };
	
	    /**
	     * @private
	     */
	    function doSingleEnterHover(el) {
	        if (el.__isHover) {
	            return;
	        }
	        if (el.__hoverStlDirty) {
	            var stroke = el.style.stroke;
	            var fill = el.style.fill;
	
	            // Create hoverStyle on mouseover
	            var hoverStyle = el.__hoverStl;
	            var lift = colorTool.lift;
	            hoverStyle.fill = hoverStyle.fill
	                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));
	            hoverStyle.stroke = hoverStyle.stroke
	                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));
	
	            var normalStyle = {};
	            for (var name in hoverStyle) {
	                if (hoverStyle.hasOwnProperty(name)) {
	                    normalStyle[name] = el.style[name];
	                }
	            }
	
	            el.__normalStl = normalStyle;
	
	            el.__hoverStlDirty = false;
	        }
	        el.setStyle(el.__hoverStl);
	        el.z2 += 1;
	
	        el.__isHover = true;
	    }
	
	    /**
	     * @inner
	     */
	    function doSingleLeaveHover(el) {
	        if (!el.__isHover) {
	            return;
	        }
	
	        var normalStl = el.__normalStl;
	        normalStl && el.setStyle(normalStl);
	        el.z2 -= 1;
	
	        el.__isHover = false;
	    }
	
	    /**
	     * @inner
	     */
	    function doEnterHover(el) {
	        (el.type === 'group' || el.type === 'GroupNode')
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleEnterHover(child);
	                }
	            })
	            : doSingleEnterHover(el);
	    }
	    graphic.doEnterHover = doEnterHover;
	    function doLeaveHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleLeaveHover(child);
	                }
	            })
	            : doSingleLeaveHover(el);
	    }
	    graphic.doLeaveHover = doLeaveHover;
	    /**
	     * @inner
	     */
	    function setElementHoverStl(el, hoverStl) {
	        // If element has sepcified hoverStyle, then use it instead of given hoverStyle
	        // Often used when item group has a label element and it's hoverStyle is different
	        el.__hoverStl = el.hoverStyle || hoverStl || {};
	        el.__hoverStlDirty = true;
	    }
	    graphic.setElementHoverStl = setElementHoverStl;
	    /**
	     * @inner
	     */
	    function onElementMouseOver() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function onElementMouseOut() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doLeaveHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function enterEmphasis() {
	        this.__isEmphasis = true;
	        doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function leaveEmphasis() {
	        this.__isEmphasis = false;
	        doLeaveHover(this);
	    }
	
	    /**
	     * Set hover style of element
	     * @param {module:zrender/Element} el
	     * @param {Object} [hoverStyle]
	     */
	    graphic.setHoverStyle = function (el, hoverStyle) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    setElementHoverStl(child, hoverStyle);
	                }
	            })
	            : setElementHoverStl(el, hoverStyle);
	        // Remove previous bound handlers
	        el.on('mouseover', onElementMouseOver)
	          .on('mouseout', onElementMouseOut);
	
	        // Emphasis, normal can be triggered manually
	        el.on('emphasis', enterEmphasis)
	          .on('normal', leaveEmphasis);
	    };
	
	    graphic.setNormalStyle = function(el, options) {
	        if (el.__normalStl) {
	            for (var name in options) {
	                if (el.__normalStl.hasOwnProperty(name)) {
	                    el.__normalStl[name] = options[name];
	                }
	            }
	        }
	    };
	
	    /**
	     * Set text option in the style
	     * @param {Object} textStyle
	     * @param {module:echarts/model/Model} labelModel
	     * @param {string} color
	     */
	    graphic.setText = function (textStyle, labelModel, color) {
	        var labelPosition = labelModel.getShallow('position') || 'inside';
	        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;
	        var textStyleModel = labelModel.getModel('textStyle');
	        zrUtil.extend(textStyle, {
	            textDistance: labelModel.getShallow('distance') || 5,
	            textFont: textStyleModel.getFont(),
	            textPosition: labelPosition,
	            textFill: textStyleModel.getTextColor() || labelColor
	        });
	    };
	
	    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {
	        var postfix = isUpdate ? 'Update' : '';
	        var duration = animatableModel
	            && animatableModel.getShallow('animationDuration' + postfix);
	        var animationEasing = animatableModel
	            && animatableModel.getShallow('animationEasing' + postfix);
	
	        animatableModel && animatableModel.getShallow('animation')
	            ? el.animateTo(props, duration, animationEasing, cb)
	            : (el.attr(props), cb && cb());
	    }
	    /**
	     * Update graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);
	
	    /**
	     * Init graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.initProps = zrUtil.curry(animateOrSetProps, false);
	
	    /**
	     * Get transform matrix of target (param target),
	     * in coordinate of its ancestor (param ancestor)
	     *
	     * @param {module:zrender/mixin/Transformable} target
	     * @param {module:zrender/mixin/Transformable} ancestor
	     */
	    graphic.getTransform = function (target, ancestor) {
	        var mat = matrix.identity([]);
	
	        while (target && target !== ancestor) {
	            matrix.mul(mat, target.getLocalTransform(), mat);
	            target = target.parent;
	        }
	
	        return mat;
	    };
	
	    /**
	     * Apply transform to an vertex.
	     * @param {Array.<number>} vertex [x, y]
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {Array.<number>} [x, y]
	     */
	    graphic.applyTransform = function (vertex, transform, invert) {
	        if (invert) {
	            transform = matrix.invert([], transform);
	        }
	        return vector.applyTransform([], vertex, transform);
	    };
	
	    /**
	     * @param {string} direction 'left' 'right' 'top' 'bottom'
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
	     */
	    graphic.transformDirection = function (direction, transform, invert) {
	
	        // Pick a base, ensure that transform result will not be (0, 0).
	        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[0]);
	        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[2]);
	
	        var vertex = [
	            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,
	            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0
	        ];
	
	        vertex = graphic.applyTransform(vertex, transform, invert);
	
	        return Math.abs(vertex[0]) > Math.abs(vertex[1])
	            ? (vertex[0] > 0 ? 'right' : 'left')
	            : (vertex[1] > 0 ? 'bottom' : 'top');
	    };
	
	    module.exports = graphic;
	


/***/ }),
/* 4 */
/***/ (function(module, exports) {

	/**
	 * @module zrender/core/util
	 */
	// 用于处理merge时无法遍历Date等对象的问题
	var BUILTIN_OBJECT = {
	  '[object Function]': 1,
	  '[object RegExp]': 1,
	  '[object Date]': 1,
	  '[object Error]': 1,
	  '[object CanvasGradient]': 1,
	  '[object CanvasPattern]': 1,
	  // For node-canvas
	  '[object Image]': 1,
	  '[object Canvas]': 1
	};
	var TYPED_ARRAY = {
	  '[object Int8Array]': 1,
	  '[object Uint8Array]': 1,
	  '[object Uint8ClampedArray]': 1,
	  '[object Int16Array]': 1,
	  '[object Uint16Array]': 1,
	  '[object Int32Array]': 1,
	  '[object Uint32Array]': 1,
	  '[object Float32Array]': 1,
	  '[object Float64Array]': 1
	};
	var objToString = Object.prototype.toString;
	var arrayProto = Array.prototype;
	var nativeForEach = arrayProto.forEach;
	var nativeFilter = arrayProto.filter;
	var nativeSlice = arrayProto.slice;
	var nativeMap = arrayProto.map;
	var nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.
	
	var methods = {};
	
	function $override(name, fn) {
	  methods[name] = fn;
	}
	/**
	 * Those data types can be cloned:
	 *     Plain object, Array, TypedArray, number, string, null, undefined.
	 * Those data types will be assgined using the orginal data:
	 *     BUILTIN_OBJECT
	 * Instance of user defined class will be cloned to a plain object, without
	 * properties in prototype.
	 * Other data types is not supported (not sure what will happen).
	 *
	 * Caution: do not support clone Date, for performance consideration.
	 * (There might be a large number of date in `series.data`).
	 * So date should not be modified in and out of echarts.
	 *
	 * @param {*} source
	 * @return {*} new
	 */
	
	
	function clone(source) {
	  if (source == null || typeof source != 'object') {
	    return source;
	  }
	
	  var result = source;
	  var typeStr = objToString.call(source);
	
	  if (typeStr === '[object Array]') {
	    result = [];
	
	    for (var i = 0, len = source.length; i < len; i++) {
	      result[i] = clone(source[i]);
	    }
	  } else if (TYPED_ARRAY[typeStr]) {
	    var Ctor = source.constructor;
	
	    if (source.constructor.from) {
	      result = Ctor.from(source);
	    } else {
	      result = new Ctor(source.length);
	
	      for (var i = 0, len = source.length; i < len; i++) {
	        result[i] = clone(source[i]);
	      }
	    }
	  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
	    result = {};
	
	    for (var key in source) {
	      if (source.hasOwnProperty(key)) {
	        result[key] = clone(source[key]);
	      }
	    }
	  }
	
	  return result;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} target
	 * @param {*} source
	 * @param {boolean} [overwrite=false]
	 */
	
	
	function merge(target, source, overwrite) {
	  // We should escapse that source is string
	  // and enter for ... in ...
	  if (!isObject(source) || !isObject(target)) {
	    return overwrite ? clone(source) : target;
	  }
	
	  for (var key in source) {
	    if (source.hasOwnProperty(key)) {
	      var targetProp = target[key];
	      var sourceProp = source[key];
	
	      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
	        // 如果需要递归覆盖，就递归调用merge
	        merge(targetProp, sourceProp, overwrite);
	      } else if (overwrite || !(key in target)) {
	        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	        // NOTE，在 target[key] 不存在的时候也是直接覆盖
	        target[key] = clone(source[key], true);
	      }
	    }
	  }
	
	  return target;
	}
	/**
	 * @param {Array} targetAndSources The first item is target, and the rests are source.
	 * @param {boolean} [overwrite=false]
	 * @return {*} target
	 */
	
	
	function mergeAll(targetAndSources, overwrite) {
	  var result = targetAndSources[0];
	
	  for (var i = 1, len = targetAndSources.length; i < len; i++) {
	    result = merge(result, targetAndSources[i], overwrite);
	  }
	
	  return result;
	}
	/**
	 * @param {*} target
	 * @param {*} source
	 * @memberOf module:zrender/core/util
	 */
	
	
	function extend(target, source) {
	  for (var key in source) {
	    if (source.hasOwnProperty(key)) {
	      target[key] = source[key];
	    }
	  }
	
	  return target;
	}
	/**
	 * @param {*} target
	 * @param {*} source
	 * @param {boolean} [overlay=false]
	 * @memberOf module:zrender/core/util
	 */
	
	
	function defaults(target, source, overlay) {
	  for (var key in source) {
	    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
	      target[key] = source[key];
	    }
	  }
	
	  return target;
	}
	
	var createCanvas = function () {
	  return methods.createCanvas();
	};
	
	methods.createCanvas = function () {
	  return document.createElement('canvas');
	}; // FIXME
	
	
	var _ctx;
	
	function getContext() {
	  if (!_ctx) {
	    // Use util.createCanvas instead of createCanvas
	    // because createCanvas may be overwritten in different environment
	    _ctx = createCanvas().getContext('2d');
	  }
	
	  return _ctx;
	}
	/**
	 * 查询数组中元素的index
	 * @memberOf module:zrender/core/util
	 */
	
	
	function indexOf(array, value) {
	  if (array) {
	    if (array.indexOf) {
	      return array.indexOf(value);
	    }
	
	    for (var i = 0, len = array.length; i < len; i++) {
	      if (array[i] === value) {
	        return i;
	      }
	    }
	  }
	
	  return -1;
	}
	/**
	 * 构造类继承关系
	 *
	 * @memberOf module:zrender/core/util
	 * @param {Function} clazz 源类
	 * @param {Function} baseClazz 基类
	 */
	
	
	function inherits(clazz, baseClazz) {
	  var clazzPrototype = clazz.prototype;
	
	  function F() {}
	
	  F.prototype = baseClazz.prototype;
	  clazz.prototype = new F();
	
	  for (var prop in clazzPrototype) {
	    clazz.prototype[prop] = clazzPrototype[prop];
	  }
	
	  clazz.prototype.constructor = clazz;
	  clazz.superClass = baseClazz;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Object|Function} target
	 * @param {Object|Function} sorce
	 * @param {boolean} overlay
	 */
	
	
	function mixin(target, source, overlay) {
	  target = 'prototype' in target ? target.prototype : target;
	  source = 'prototype' in source ? source.prototype : source;
	  defaults(target, source, overlay);
	}
	/**
	 * Consider typed array.
	 * @param {Array|TypedArray} data
	 */
	
	
	function isArrayLike(data) {
	  if (!data) {
	    return;
	  }
	
	  if (typeof data == 'string') {
	    return false;
	  }
	
	  return typeof data.length == 'number';
	}
	/**
	 * 数组或对象遍历
	 * @memberOf module:zrender/core/util
	 * @param {Object|Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 */
	
	
	function each(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.forEach && obj.forEach === nativeForEach) {
	    obj.forEach(cb, context);
	  } else if (obj.length === +obj.length) {
	    for (var i = 0, len = obj.length; i < len; i++) {
	      cb.call(context, obj[i], i, obj);
	    }
	  } else {
	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        cb.call(context, obj[key], key, obj);
	      }
	    }
	  }
	}
	/**
	 * 数组映射
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 * @return {Array}
	 */
	
	
	function map(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.map && obj.map === nativeMap) {
	    return obj.map(cb, context);
	  } else {
	    var result = [];
	
	    for (var i = 0, len = obj.length; i < len; i++) {
	      result.push(cb.call(context, obj[i], i, obj));
	    }
	
	    return result;
	  }
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {Object} [memo]
	 * @param {*} [context]
	 * @return {Array}
	 */
	
	
	function reduce(obj, cb, memo, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.reduce && obj.reduce === nativeReduce) {
	    return obj.reduce(cb, memo, context);
	  } else {
	    for (var i = 0, len = obj.length; i < len; i++) {
	      memo = cb.call(context, memo, obj[i], i, obj);
	    }
	
	    return memo;
	  }
	}
	/**
	 * 数组过滤
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 * @return {Array}
	 */
	
	
	function filter(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  if (obj.filter && obj.filter === nativeFilter) {
	    return obj.filter(cb, context);
	  } else {
	    var result = [];
	
	    for (var i = 0, len = obj.length; i < len; i++) {
	      if (cb.call(context, obj[i], i, obj)) {
	        result.push(obj[i]);
	      }
	    }
	
	    return result;
	  }
	}
	/**
	 * 数组项查找
	 * @memberOf module:zrender/core/util
	 * @param {Array} obj
	 * @param {Function} cb
	 * @param {*} [context]
	 * @return {*}
	 */
	
	
	function find(obj, cb, context) {
	  if (!(obj && cb)) {
	    return;
	  }
	
	  for (var i = 0, len = obj.length; i < len; i++) {
	    if (cb.call(context, obj[i], i, obj)) {
	      return obj[i];
	    }
	  }
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Function} func
	 * @param {*} context
	 * @return {Function}
	 */
	
	
	function bind(func, context) {
	  var args = nativeSlice.call(arguments, 2);
	  return function () {
	    return func.apply(context, args.concat(nativeSlice.call(arguments)));
	  };
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Function} func
	 * @return {Function}
	 */
	
	
	function curry(func) {
	  var args = nativeSlice.call(arguments, 1);
	  return function () {
	    return func.apply(this, args.concat(nativeSlice.call(arguments)));
	  };
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isArray(value) {
	  return objToString.call(value) === '[object Array]';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isFunction(value) {
	  return typeof value === 'function';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isString(value) {
	  return objToString.call(value) === '[object String]';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return type === 'function' || !!value && type == 'object';
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isBuiltInObject(value) {
	  return !!BUILTIN_OBJECT[objToString.call(value)];
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function isDom(value) {
	  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';
	}
	/**
	 * Whether is exactly NaN. Notice isNaN('a') returns true.
	 * @param {*} value
	 * @return {boolean}
	 */
	
	
	function eqNaN(value) {
	  return value !== value;
	}
	/**
	 * If value1 is not null, then return value1, otherwise judget rest of values.
	 * Low performance.
	 * @memberOf module:zrender/core/util
	 * @return {*} Final value
	 */
	
	
	function retrieve(values) {
	  for (var i = 0, len = arguments.length; i < len; i++) {
	    if (arguments[i] != null) {
	      return arguments[i];
	    }
	  }
	}
	
	function retrieve2(value0, value1) {
	  return value0 != null ? value0 : value1;
	}
	
	function retrieve3(value0, value1, value2) {
	  return value0 != null ? value0 : value1 != null ? value1 : value2;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {Array} arr
	 * @param {number} startIndex
	 * @param {number} endIndex
	 * @return {Array}
	 */
	
	
	function slice() {
	  return Function.call.apply(nativeSlice, arguments);
	}
	/**
	 * Normalize css liked array configuration
	 * e.g.
	 *  3 => [3, 3, 3, 3]
	 *  [4, 2] => [4, 2, 4, 2]
	 *  [4, 3, 2] => [4, 3, 2, 3]
	 * @param {number|Array.<number>} val
	 * @return {Array.<number>}
	 */
	
	
	function normalizeCssArray(val) {
	  if (typeof val === 'number') {
	    return [val, val, val, val];
	  }
	
	  var len = val.length;
	
	  if (len === 2) {
	    // vertical | horizontal
	    return [val[0], val[1], val[0], val[1]];
	  } else if (len === 3) {
	    // top | horizontal | bottom
	    return [val[0], val[1], val[2], val[1]];
	  }
	
	  return val;
	}
	/**
	 * @memberOf module:zrender/core/util
	 * @param {boolean} condition
	 * @param {string} message
	 */
	
	
	function assert(condition, message) {
	  if (!condition) {
	    throw new Error(message);
	  }
	}
	
	var primitiveKey = '__ec_primitive__';
	/**
	 * Set an object as primitive to be ignored traversing children in clone or merge
	 */
	
	function setAsPrimitive(obj) {
	  obj[primitiveKey] = true;
	}
	
	function isPrimitive(obj) {
	  return obj[primitiveKey];
	}
	/**
	 * @constructor
	 * @param {Object} obj Only apply `ownProperty`.
	 */
	
	
	function HashMap(obj) {
	  obj && each(obj, function (value, key) {
	    this.set(key, value);
	  }, this);
	} // Add prefix to avoid conflict with Object.prototype.
	
	
	var HASH_MAP_PREFIX = '_ec_';
	var HASH_MAP_PREFIX_LENGTH = 4;
	HashMap.prototype = {
	  constructor: HashMap,
	  // Do not provide `has` method to avoid defining what is `has`.
	  // (We usually treat `null` and `undefined` as the same, different
	  // from ES6 Map).
	  get: function (key) {
	    return this[HASH_MAP_PREFIX + key];
	  },
	  set: function (key, value) {
	    this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly
	    // used in this case: `var someVal = map.set('a', genVal());`
	
	    return value;
	  },
	  // Although util.each can be performed on this hashMap directly, user
	  // should not use the exposed keys, who are prefixed.
	  each: function (cb, context) {
	    context !== void 0 && (cb = bind(cb, context));
	
	    for (var prefixedKey in this) {
	      this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));
	    }
	  },
	  // Do not use this method if performance sensitive.
	  removeKey: function (key) {
	    delete this[HASH_MAP_PREFIX + key];
	  }
	};
	
	function createHashMap(obj) {
	  return new HashMap(obj);
	}
	
	function noop() {}
	
	exports.$override = $override;
	exports.clone = clone;
	exports.merge = merge;
	exports.mergeAll = mergeAll;
	exports.extend = extend;
	exports.defaults = defaults;
	exports.createCanvas = createCanvas;
	exports.getContext = getContext;
	exports.indexOf = indexOf;
	exports.inherits = inherits;
	exports.mixin = mixin;
	exports.isArrayLike = isArrayLike;
	exports.each = each;
	exports.map = map;
	exports.reduce = reduce;
	exports.filter = filter;
	exports.find = find;
	exports.bind = bind;
	exports.curry = curry;
	exports.isArray = isArray;
	exports.isFunction = isFunction;
	exports.isString = isString;
	exports.isObject = isObject;
	exports.isBuiltInObject = isBuiltInObject;
	exports.isDom = isDom;
	exports.eqNaN = eqNaN;
	exports.retrieve = retrieve;
	exports.retrieve2 = retrieve2;
	exports.retrieve3 = retrieve3;
	exports.slice = slice;
	exports.normalizeCssArray = normalizeCssArray;
	exports.assert = assert;
	exports.setAsPrimitive = setAsPrimitive;
	exports.isPrimitive = isPrimitive;
	exports.createHashMap = createHashMap;
	exports.noop = noop;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	var PathProxy = __webpack_require__(29);
	
	var transformPath = __webpack_require__(40);
	
	// command chars
	var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
	var mathSqrt = Math.sqrt;
	var mathSin = Math.sin;
	var mathCos = Math.cos;
	var PI = Math.PI;
	
	var vMag = function (v) {
	  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	};
	
	var vRatio = function (u, v) {
	  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	};
	
	var vAngle = function (u, v) {
	  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
	};
	
	function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
	  var psi = psiDeg * (PI / 180.0);
	  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;
	  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;
	  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
	
	  if (lambda > 1) {
	    rx *= mathSqrt(lambda);
	    ry *= mathSqrt(lambda);
	  }
	
	  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
	  var cxp = f * rx * yp / ry;
	  var cyp = f * -ry * xp / rx;
	  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;
	  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;
	  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
	  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
	  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
	  var dTheta = vAngle(u, v);
	
	  if (vRatio(u, v) <= -1) {
	    dTheta = PI;
	  }
	
	  if (vRatio(u, v) >= 1) {
	    dTheta = 0;
	  }
	
	  if (fs === 0 && dTheta > 0) {
	    dTheta = dTheta - 2 * PI;
	  }
	
	  if (fs === 1 && dTheta < 0) {
	    dTheta = dTheta + 2 * PI;
	  }
	
	  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
	}
	
	function createPathProxyFromString(data) {
	  if (!data) {
	    return [];
	  } // command string
	
	
	  var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');
	  var n; // create pipes so that we can split the data
	
	  for (n = 0; n < cc.length; n++) {
	    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
	  } // create array
	
	
	  var arr = cs.split('|'); // init context point
	
	  var cpx = 0;
	  var cpy = 0;
	  var path = new PathProxy();
	  var CMD = PathProxy.CMD;
	  var prevCmd;
	
	  for (n = 1; n < arr.length; n++) {
	    var str = arr[n];
	    var c = str.charAt(0);
	    var off = 0;
	    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
	    var cmd;
	
	    if (p.length > 0 && p[0] === '') {
	      p.shift();
	    }
	
	    for (var i = 0; i < p.length; i++) {
	      p[i] = parseFloat(p[i]);
	    }
	
	    while (off < p.length && !isNaN(p[off])) {
	      if (isNaN(p[0])) {
	        break;
	      }
	
	      var ctlPtx;
	      var ctlPty;
	      var rx;
	      var ry;
	      var psi;
	      var fa;
	      var fs;
	      var x1 = cpx;
	      var y1 = cpy; // convert l, H, h, V, and v to L
	
	      switch (c) {
	        case 'l':
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'L':
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'm':
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.M;
	          path.addData(cmd, cpx, cpy);
	          c = 'l';
	          break;
	
	        case 'M':
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.M;
	          path.addData(cmd, cpx, cpy);
	          c = 'L';
	          break;
	
	        case 'h':
	          cpx += p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'H':
	          cpx = p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'v':
	          cpy += p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'V':
	          cpy = p[off++];
	          cmd = CMD.L;
	          path.addData(cmd, cpx, cpy);
	          break;
	
	        case 'C':
	          cmd = CMD.C;
	          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
	          cpx = p[off - 2];
	          cpy = p[off - 1];
	          break;
	
	        case 'c':
	          cmd = CMD.C;
	          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
	          cpx += p[off - 2];
	          cpy += p[off - 1];
	          break;
	
	        case 'S':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.C) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cmd = CMD.C;
	          x1 = p[off++];
	          y1 = p[off++];
	          cpx = p[off++];
	          cpy = p[off++];
	          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	          break;
	
	        case 's':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.C) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cmd = CMD.C;
	          x1 = cpx + p[off++];
	          y1 = cpy + p[off++];
	          cpx += p[off++];
	          cpy += p[off++];
	          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	          break;
	
	        case 'Q':
	          x1 = p[off++];
	          y1 = p[off++];
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, x1, y1, cpx, cpy);
	          break;
	
	        case 'q':
	          x1 = p[off++] + cpx;
	          y1 = p[off++] + cpy;
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, x1, y1, cpx, cpy);
	          break;
	
	        case 'T':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.Q) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	          break;
	
	        case 't':
	          ctlPtx = cpx;
	          ctlPty = cpy;
	          var len = path.len();
	          var pathData = path.data;
	
	          if (prevCmd === CMD.Q) {
	            ctlPtx += cpx - pathData[len - 4];
	            ctlPty += cpy - pathData[len - 3];
	          }
	
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.Q;
	          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	          break;
	
	        case 'A':
	          rx = p[off++];
	          ry = p[off++];
	          psi = p[off++];
	          fa = p[off++];
	          fs = p[off++];
	          x1 = cpx, y1 = cpy;
	          cpx = p[off++];
	          cpy = p[off++];
	          cmd = CMD.A;
	          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
	          break;
	
	        case 'a':
	          rx = p[off++];
	          ry = p[off++];
	          psi = p[off++];
	          fa = p[off++];
	          fs = p[off++];
	          x1 = cpx, y1 = cpy;
	          cpx += p[off++];
	          cpy += p[off++];
	          cmd = CMD.A;
	          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
	          break;
	      }
	    }
	
	    if (c === 'z' || c === 'Z') {
	      cmd = CMD.Z;
	      path.addData(cmd);
	    }
	
	    prevCmd = cmd;
	  }
	
	  path.toStatic();
	  return path;
	} // TODO Optimize double memory cost problem
	
	
	function createPathOptions(str, opts) {
	  var pathProxy = createPathProxyFromString(str);
	  opts = opts || {};
	
	  opts.buildPath = function (path) {
	    if (path.setData) {
	      path.setData(pathProxy.data); // Svg and vml renderer don't have context
	
	      var ctx = path.getContext();
	
	      if (ctx) {
	        path.rebuildPath(ctx);
	      }
	    } else {
	      var ctx = path;
	      pathProxy.rebuildPath(ctx);
	    }
	  };
	
	  opts.applyTransform = function (m) {
	    transformPath(pathProxy, m);
	    this.dirty(true);
	  };
	
	  return opts;
	}
	/**
	 * Create a Path object from path string data
	 * http://www.w3.org/TR/SVG/paths.html#PathData
	 * @param  {Object} opts Other options
	 */
	
	
	function createFromString(str, opts) {
	  return new Path(createPathOptions(str, opts));
	}
	/**
	 * Create a Path class from path string data
	 * @param  {string} str
	 * @param  {Object} opts Other options
	 */
	
	
	function extendFromString(str, opts) {
	  return Path.extend(createPathOptions(str, opts));
	}
	/**
	 * Merge multiple paths
	 */
	// TODO Apply transform
	// TODO stroke dash
	// TODO Optimize double memory cost problem
	
	
	function mergePath(pathEls, opts) {
	  var pathList = [];
	  var len = pathEls.length;
	
	  for (var i = 0; i < len; i++) {
	    var pathEl = pathEls[i];
	
	    if (!pathEl.path) {
	      pathEl.createPathProxy();
	    }
	
	    if (pathEl.__dirtyPath) {
	      pathEl.buildPath(pathEl.path, pathEl.shape, true);
	    }
	
	    pathList.push(pathEl.path);
	  }
	
	  var pathBundle = new Path(opts); // Need path proxy.
	
	  pathBundle.createPathProxy();
	
	  pathBundle.buildPath = function (path) {
	    path.appendPath(pathList); // Svg and vml renderer don't have context
	
	    var ctx = path.getContext();
	
	    if (ctx) {
	      path.rebuildPath(ctx);
	    }
	  };
	
	  return pathBundle;
	}
	
	exports.createFromString = createFromString;
	exports.extendFromString = extendFromString;
	exports.mergePath = mergePath;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	var Displayable = __webpack_require__(7);
	
	var zrUtil = __webpack_require__(4);
	
	var PathProxy = __webpack_require__(29);
	
	var pathContain = __webpack_require__(32);
	
	var Pattern = __webpack_require__(39);
	
	var getCanvasPattern = Pattern.prototype.getCanvasPattern;
	var abs = Math.abs;
	var pathProxyForDraw = new PathProxy(true);
	/**
	 * @alias module:zrender/graphic/Path
	 * @extends module:zrender/graphic/Displayable
	 * @constructor
	 * @param {Object} opts
	 */
	
	function Path(opts) {
	  Displayable.call(this, opts);
	  /**
	   * @type {module:zrender/core/PathProxy}
	   * @readOnly
	   */
	
	  this.path = null;
	}
	
	Path.prototype = {
	  constructor: Path,
	  type: 'path',
	  __dirtyPath: true,
	  strokeContainThreshold: 5,
	  brush: function (ctx, prevEl) {
	    var style = this.style;
	    var path = this.path || pathProxyForDraw;
	    var hasStroke = style.hasStroke();
	    var hasFill = style.hasFill();
	    var fill = style.fill;
	    var stroke = style.stroke;
	    var hasFillGradient = hasFill && !!fill.colorStops;
	    var hasStrokeGradient = hasStroke && !!stroke.colorStops;
	    var hasFillPattern = hasFill && !!fill.image;
	    var hasStrokePattern = hasStroke && !!stroke.image;
	    style.bind(ctx, this, prevEl);
	    this.setTransform(ctx);
	
	    if (this.__dirty) {
	      var rect; // Update gradient because bounding rect may changed
	
	      if (hasFillGradient) {
	        rect = rect || this.getBoundingRect();
	        this._fillGradient = style.getGradient(ctx, fill, rect);
	      }
	
	      if (hasStrokeGradient) {
	        rect = rect || this.getBoundingRect();
	        this._strokeGradient = style.getGradient(ctx, stroke, rect);
	      }
	    } // Use the gradient or pattern
	
	
	    if (hasFillGradient) {
	      // PENDING If may have affect the state
	      ctx.fillStyle = this._fillGradient;
	    } else if (hasFillPattern) {
	      ctx.fillStyle = getCanvasPattern.call(fill, ctx);
	    }
	
	    if (hasStrokeGradient) {
	      ctx.strokeStyle = this._strokeGradient;
	    } else if (hasStrokePattern) {
	      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
	    }
	
	    var lineDash = style.lineDash;
	    var lineDashOffset = style.lineDashOffset;
	    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy
	
	    var scale = this.getGlobalScale();
	    path.setScale(scale[0], scale[1]); // Proxy context
	    // Rebuild path in following 2 cases
	    // 1. Path is dirty
	    // 2. Path needs javascript implemented lineDash stroking.
	    //    In this case, lineDash information will not be saved in PathProxy
	
	    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
	      path.beginPath(ctx); // Setting line dash before build path
	
	      if (lineDash && !ctxLineDash) {
	        path.setLineDash(lineDash);
	        path.setLineDashOffset(lineDashOffset);
	      }
	
	      this.buildPath(path, this.shape, false); // Clear path dirty flag
	
	      if (this.path) {
	        this.__dirtyPath = false;
	      }
	    } else {
	      // Replay path building
	      ctx.beginPath();
	      this.path.rebuildPath(ctx);
	    }
	
	    hasFill && path.fill(ctx);
	
	    if (lineDash && ctxLineDash) {
	      ctx.setLineDash(lineDash);
	      ctx.lineDashOffset = lineDashOffset;
	    }
	
	    hasStroke && path.stroke(ctx);
	
	    if (lineDash && ctxLineDash) {
	      // PENDING
	      // Remove lineDash
	      ctx.setLineDash([]);
	    }
	
	    this.restoreTransform(ctx); // Draw rect text
	
	    if (style.text != null) {
	      this.drawRectText(ctx, this.getBoundingRect());
	    }
	  },
	  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
	  // Like in circle
	  buildPath: function (ctx, shapeCfg, inBundle) {},
	  createPathProxy: function () {
	    this.path = new PathProxy();
	  },
	  getBoundingRect: function () {
	    var rect = this._rect;
	    var style = this.style;
	    var needsUpdateRect = !rect;
	
	    if (needsUpdateRect) {
	      var path = this.path;
	
	      if (!path) {
	        // Create path on demand.
	        path = this.path = new PathProxy();
	      }
	
	      if (this.__dirtyPath) {
	        path.beginPath();
	        this.buildPath(path, this.shape, false);
	      }
	
	      rect = path.getBoundingRect();
	    }
	
	    this._rect = rect;
	
	    if (style.hasStroke()) {
	      // Needs update rect with stroke lineWidth when
	      // 1. Element changes scale or lineWidth
	      // 2. Shape is changed
	      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
	
	      if (this.__dirty || needsUpdateRect) {
	        rectWithStroke.copy(rect); // FIXME Must after updateTransform
	
	        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical
	
	        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill
	
	        if (!style.hasFill()) {
	          w = Math.max(w, this.strokeContainThreshold || 4);
	        } // Consider line width
	        // Line scale can't be 0;
	
	
	        if (lineScale > 1e-10) {
	          rectWithStroke.width += w / lineScale;
	          rectWithStroke.height += w / lineScale;
	          rectWithStroke.x -= w / lineScale / 2;
	          rectWithStroke.y -= w / lineScale / 2;
	        }
	      } // Return rect with stroke
	
	
	      return rectWithStroke;
	    }
	
	    return rect;
	  },
	  contain: function (x, y) {
	    var localPos = this.transformCoordToLocal(x, y);
	    var rect = this.getBoundingRect();
	    var style = this.style;
	    x = localPos[0];
	    y = localPos[1];
	
	    if (rect.contain(x, y)) {
	      var pathData = this.path.data;
	
	      if (style.hasStroke()) {
	        var lineWidth = style.lineWidth;
	        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;
	
	        if (lineScale > 1e-10) {
	          // Only add extra hover lineWidth when there are no fill
	          if (!style.hasFill()) {
	            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
	          }
	
	          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {
	            return true;
	          }
	        }
	      }
	
	      if (style.hasFill()) {
	        return pathContain.contain(pathData, x, y);
	      }
	    }
	
	    return false;
	  },
	
	  /**
	   * @param  {boolean} dirtyPath
	   */
	  dirty: function (dirtyPath) {
	    if (dirtyPath == null) {
	      dirtyPath = true;
	    } // Only mark dirty, not mark clean
	
	
	    if (dirtyPath) {
	      this.__dirtyPath = dirtyPath;
	      this._rect = null;
	    }
	
	    this.__dirty = true;
	    this.__zr && this.__zr.refresh(); // Used as a clipping path
	
	    if (this.__clipTarget) {
	      this.__clipTarget.dirty();
	    }
	  },
	
	  /**
	   * Alias for animate('shape')
	   * @param {boolean} loop
	   */
	  animateShape: function (loop) {
	    return this.animate('shape', loop);
	  },
	  // Overwrite attrKV
	  attrKV: function (key, value) {
	    // FIXME
	    if (key === 'shape') {
	      this.setShape(value);
	      this.__dirtyPath = true;
	      this._rect = null;
	    } else {
	      Displayable.prototype.attrKV.call(this, key, value);
	    }
	  },
	
	  /**
	   * @param {Object|string} key
	   * @param {*} value
	   */
	  setShape: function (key, value) {
	    var shape = this.shape; // Path from string may not have shape
	
	    if (shape) {
	      if (zrUtil.isObject(key)) {
	        for (var name in key) {
	          if (key.hasOwnProperty(name)) {
	            shape[name] = key[name];
	          }
	        }
	      } else {
	        shape[key] = value;
	      }
	
	      this.dirty(true);
	    }
	
	    return this;
	  },
	  getLineScale: function () {
	    var m = this.transform; // Get the line scale.
	    // Determinant of `m` means how much the area is enlarged by the
	    // transformation. So its square root can be used as a scale factor
	    // for width.
	
	    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
	  }
	};
	/**
	 * 扩展一个 Path element, 比如星形，圆等。
	 * Extend a path element
	 * @param {Object} props
	 * @param {string} props.type Path type
	 * @param {Function} props.init Initialize
	 * @param {Function} props.buildPath Overwrite buildPath method
	 * @param {Object} [props.style] Extended default style config
	 * @param {Object} [props.shape] Extended default shape config
	 */
	
	Path.extend = function (defaults) {
	  var Sub = function (opts) {
	    Path.call(this, opts);
	
	    if (defaults.style) {
	      // Extend default style
	      this.style.extendFrom(defaults.style, false);
	    } // Extend default shape
	
	
	    var defaultShape = defaults.shape;
	
	    if (defaultShape) {
	      this.shape = this.shape || {};
	      var thisShape = this.shape;
	
	      for (var name in defaultShape) {
	        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {
	          thisShape[name] = defaultShape[name];
	        }
	      }
	    }
	
	    defaults.init && defaults.init.call(this, opts);
	  };
	
	  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象
	
	  for (var name in defaults) {
	    // Extending prototype values and methods
	    if (name !== 'style' && name !== 'shape') {
	      Sub.prototype[name] = defaults[name];
	    }
	  }
	
	  return Sub;
	};
	
	zrUtil.inherits(Path, Displayable);
	var _default = Path;
	module.exports = _default;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(4);
	
	var Style = __webpack_require__(8);
	
	var Element = __webpack_require__(9);
	
	var RectText = __webpack_require__(23);
	
	/**
	 * 可绘制的图形基类
	 * Base class of all displayable graphic objects
	 * @module zrender/graphic/Displayable
	 */
	
	/**
	 * @alias module:zrender/graphic/Displayable
	 * @extends module:zrender/Element
	 * @extends module:zrender/graphic/mixin/RectText
	 */
	function Displayable(opts) {
	  opts = opts || {};
	  Element.call(this, opts); // Extend properties
	
	  for (var name in opts) {
	    if (opts.hasOwnProperty(name) && name !== 'style') {
	      this[name] = opts[name];
	    }
	  }
	  /**
	   * @type {module:zrender/graphic/Style}
	   */
	
	
	  this.style = new Style(opts.style, this);
	  this._rect = null; // Shapes for cascade clipping.
	
	  this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted
	  // Stateful.call(this, opts);
	}
	
	Displayable.prototype = {
	  constructor: Displayable,
	  type: 'displayable',
	
	  /**
	   * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
	   * Dirty flag. From which painter will determine if this displayable object needs brush
	   * @name module:zrender/graphic/Displayable#__dirty
	   * @type {boolean}
	   */
	  __dirty: true,
	
	  /**
	   * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
	   * If ignore drawing of the displayable object. Mouse event will still be triggered
	   * @name module:/zrender/graphic/Displayable#invisible
	   * @type {boolean}
	   * @default false
	   */
	  invisible: false,
	
	  /**
	   * @name module:/zrender/graphic/Displayable#z
	   * @type {number}
	   * @default 0
	   */
	  z: 0,
	
	  /**
	   * @name module:/zrender/graphic/Displayable#z
	   * @type {number}
	   * @default 0
	   */
	  z2: 0,
	
	  /**
	   * z层level，决定绘画在哪层canvas中
	   * @name module:/zrender/graphic/Displayable#zlevel
	   * @type {number}
	   * @default 0
	   */
	  zlevel: 0,
	
	  /**
	   * 是否可拖拽
	   * @name module:/zrender/graphic/Displayable#draggable
	   * @type {boolean}
	   * @default false
	   */
	  draggable: false,
	
	  /**
	   * 是否正在拖拽
	   * @name module:/zrender/graphic/Displayable#draggable
	   * @type {boolean}
	   * @default false
	   */
	  dragging: false,
	
	  /**
	   * 是否相应鼠标事件
	   * @name module:/zrender/graphic/Displayable#silent
	   * @type {boolean}
	   * @default false
	   */
	  silent: false,
	
	  /**
	   * If enable culling
	   * @type {boolean}
	   * @default false
	   */
	  culling: false,
	
	  /**
	   * Mouse cursor when hovered
	   * @name module:/zrender/graphic/Displayable#cursor
	   * @type {string}
	   */
	  cursor: 'pointer',
	
	  /**
	   * If hover area is bounding rect
	   * @name module:/zrender/graphic/Displayable#rectHover
	   * @type {string}
	   */
	  rectHover: false,
	
	  /**
	   * Render the element progressively when the value >= 0,
	   * usefull for large data.
	   * @type {number}
	   */
	  progressive: -1,
	  beforeBrush: function (ctx) {},
	  afterBrush: function (ctx) {},
	
	  /**
	   * 图形绘制方法
	   * @param {CanvasRenderingContext2D} ctx
	   */
	  // Interface
	  brush: function (ctx, prevEl) {},
	
	  /**
	   * 获取最小包围盒
	   * @return {module:zrender/core/BoundingRect}
	   */
	  // Interface
	  getBoundingRect: function () {},
	
	  /**
	   * 判断坐标 x, y 是否在图形上
	   * If displayable element contain coord x, y
	   * @param  {number} x
	   * @param  {number} y
	   * @return {boolean}
	   */
	  contain: function (x, y) {
	    return this.rectContain(x, y);
	  },
	
	  /**
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  traverse: function (cb, context) {
	    cb.call(context, this);
	  },
	
	  /**
	   * 判断坐标 x, y 是否在图形的包围盒上
	   * If bounding rect of element contain coord x, y
	   * @param  {number} x
	   * @param  {number} y
	   * @return {boolean}
	   */
	  rectContain: function (x, y) {
	    var coord = this.transformCoordToLocal(x, y);
	    var rect = this.getBoundingRect();
	    return rect.contain(coord[0], coord[1]);
	  },
	
	  /**
	   * 标记图形元素为脏，并且在下一帧重绘
	   * Mark displayable element dirty and refresh next frame
	   */
	  dirty: function () {
	    this.__dirty = true;
	    this._rect = null;
	    this.__zr && this.__zr.refresh();
	  },
	
	  /**
	   * 图形是否会触发事件
	   * If displayable object binded any event
	   * @return {boolean}
	   */
	  // TODO, 通过 bind 绑定的事件
	  // isSilent: function () {
	  //     return !(
	  //         this.hoverable || this.draggable
	  //         || this.onmousemove || this.onmouseover || this.onmouseout
	  //         || this.onmousedown || this.onmouseup || this.onclick
	  //         || this.ondragenter || this.ondragover || this.ondragleave
	  //         || this.ondrop
	  //     );
	  // },
	
	  /**
	   * Alias for animate('style')
	   * @param {boolean} loop
	   */
	  animateStyle: function (loop) {
	    return this.animate('style', loop);
	  },
	  attrKV: function (key, value) {
	    if (key !== 'style') {
	      Element.prototype.attrKV.call(this, key, value);
	    } else {
	      this.style.set(value);
	    }
	  },
	
	  /**
	   * @param {Object|string} key
	   * @param {*} value
	   */
	  setStyle: function (key, value) {
	    this.style.set(key, value);
	    this.dirty(false);
	    return this;
	  },
	
	  /**
	   * Use given style object
	   * @param  {Object} obj
	   */
	  useStyle: function (obj) {
	    this.style = new Style(obj, this);
	    this.dirty(false);
	    return this;
	  }
	};
	zrUtil.inherits(Displayable, Element);
	zrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);
	
	var _default = Displayable;
	module.exports = _default;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
	// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);
	
	var Style = function (opts, host) {
	  this.extendFrom(opts, false);
	  this.host = host;
	};
	
	function createLinearGradient(ctx, obj, rect) {
	  var x = obj.x == null ? 0 : obj.x;
	  var x2 = obj.x2 == null ? 1 : obj.x2;
	  var y = obj.y == null ? 0 : obj.y;
	  var y2 = obj.y2 == null ? 0 : obj.y2;
	
	  if (!obj.global) {
	    x = x * rect.width + rect.x;
	    x2 = x2 * rect.width + rect.x;
	    y = y * rect.height + rect.y;
	    y2 = y2 * rect.height + rect.y;
	  }
	
	  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
	  return canvasGradient;
	}
	
	function createRadialGradient(ctx, obj, rect) {
	  var width = rect.width;
	  var height = rect.height;
	  var min = Math.min(width, height);
	  var x = obj.x == null ? 0.5 : obj.x;
	  var y = obj.y == null ? 0.5 : obj.y;
	  var r = obj.r == null ? 0.5 : obj.r;
	
	  if (!obj.global) {
	    x = x * width + rect.x;
	    y = y * height + rect.y;
	    r = r * min;
	  }
	
	  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
	  return canvasGradient;
	}
	
	Style.prototype = {
	  constructor: Style,
	
	  /**
	   * @type {module:zrender/graphic/Displayable}
	   */
	  host: null,
	
	  /**
	   * @type {string}
	   */
	  fill: '#000',
	
	  /**
	   * @type {string}
	   */
	  stroke: null,
	
	  /**
	   * @type {number}
	   */
	  opacity: 1,
	
	  /**
	   * @type {Array.<number>}
	   */
	  lineDash: null,
	
	  /**
	   * @type {number}
	   */
	  lineDashOffset: 0,
	
	  /**
	   * @type {number}
	   */
	  shadowBlur: 0,
	
	  /**
	   * @type {number}
	   */
	  shadowOffsetX: 0,
	
	  /**
	   * @type {number}
	   */
	  shadowOffsetY: 0,
	
	  /**
	   * @type {number}
	   */
	  lineWidth: 1,
	
	  /**
	   * If stroke ignore scale
	   * @type {Boolean}
	   */
	  strokeNoScale: false,
	  // Bounding rect text configuration
	  // Not affected by element transform
	
	  /**
	   * @type {string}
	   */
	  text: null,
	
	  /**
	   * If `fontSize` or `fontFamily` exists, `font` will be reset by
	   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
	   * So do not visit it directly in upper application (like echarts),
	   * but use `contain/text#makeFont` instead.
	   * @type {string}
	   */
	  font: null,
	
	  /**
	   * The same as font. Use font please.
	   * @deprecated
	   * @type {string}
	   */
	  textFont: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * @type {string}
	   */
	  fontStyle: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * @type {string}
	   */
	  fontWeight: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * Should be 12 but not '12px'.
	   * @type {number}
	   */
	  fontSize: null,
	
	  /**
	   * It helps merging respectively, rather than parsing an entire font string.
	   * @type {string}
	   */
	  fontFamily: null,
	
	  /**
	   * Reserved for special functinality, like 'hr'.
	   * @type {string}
	   */
	  textTag: null,
	
	  /**
	   * @type {string}
	   */
	  textFill: '#000',
	
	  /**
	   * @type {string}
	   */
	  textStroke: null,
	
	  /**
	   * @type {number}
	   */
	  textWidth: null,
	
	  /**
	   * Only for textBackground.
	   * @type {number}
	   */
	  textHeight: null,
	
	  /**
	   * textStroke may be set as some color as a default
	   * value in upper applicaion, where the default value
	   * of textStrokeWidth should be 0 to make sure that
	   * user can choose to do not use text stroke.
	   * @type {number}
	   */
	  textStrokeWidth: 0,
	
	  /**
	   * @type {number}
	   */
	  textLineHeight: null,
	
	  /**
	   * 'inside', 'left', 'right', 'top', 'bottom'
	   * [x, y]
	   * Based on x, y of rect.
	   * @type {string|Array.<number>}
	   * @default 'inside'
	   */
	  textPosition: 'inside',
	
	  /**
	   * If not specified, use the boundingRect of a `displayable`.
	   * @type {Object}
	   */
	  textRect: null,
	
	  /**
	   * [x, y]
	   * @type {Array.<number>}
	   */
	  textOffset: null,
	
	  /**
	   * @type {string}
	   */
	  textAlign: null,
	
	  /**
	   * @type {string}
	   */
	  textVerticalAlign: null,
	
	  /**
	   * @type {number}
	   */
	  textDistance: 5,
	
	  /**
	   * @type {string}
	   */
	  textShadowColor: 'transparent',
	
	  /**
	   * @type {number}
	   */
	  textShadowBlur: 0,
	
	  /**
	   * @type {number}
	   */
	  textShadowOffsetX: 0,
	
	  /**
	   * @type {number}
	   */
	  textShadowOffsetY: 0,
	
	  /**
	   * @type {string}
	   */
	  textBoxShadowColor: 'transparent',
	
	  /**
	   * @type {number}
	   */
	  textBoxShadowBlur: 0,
	
	  /**
	   * @type {number}
	   */
	  textBoxShadowOffsetX: 0,
	
	  /**
	   * @type {number}
	   */
	  textBoxShadowOffsetY: 0,
	
	  /**
	   * Whether transform text.
	   * Only useful in Path and Image element
	   * @type {boolean}
	   */
	  transformText: false,
	
	  /**
	   * Text rotate around position of Path or Image
	   * Only useful in Path and Image element and transformText is false.
	   */
	  textRotation: 0,
	
	  /**
	   * Text origin of text rotation, like [10, 40].
	   * Based on x, y of rect.
	   * Useful in label rotation of circular symbol.
	   * By default, this origin is textPosition.
	   * Can be 'center'.
	   * @type {string|Array.<number>}
	   */
	  textOrigin: null,
	
	  /**
	   * @type {string}
	   */
	  textBackgroundColor: null,
	
	  /**
	   * @type {string}
	   */
	  textBorderColor: null,
	
	  /**
	   * @type {number}
	   */
	  textBorderWidth: 0,
	
	  /**
	   * @type {number}
	   */
	  textBorderRadius: 0,
	
	  /**
	   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
	   * @type {number|Array.<number>}
	   */
	  textPadding: null,
	
	  /**
	   * Text styles for rich text.
	   * @type {Object}
	   */
	  rich: null,
	
	  /**
	   * {outerWidth, outerHeight, ellipsis, placeholder}
	   * @type {Object}
	   */
	  truncate: null,
	
	  /**
	   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
	   * @type {string}
	   */
	  blend: null,
	
	  /**
	   * @param {CanvasRenderingContext2D} ctx
	   */
	  bind: function (ctx, el, prevEl) {
	    var style = this;
	    var prevStyle = prevEl && prevEl.style;
	    var firstDraw = !prevStyle;
	
	    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	      var prop = STYLE_COMMON_PROPS[i];
	      var styleName = prop[0];
	
	      if (firstDraw || style[styleName] !== prevStyle[styleName]) {
	        // FIXME Invalid property value will cause style leak from previous element.
	        ctx[styleName] = style[styleName] || prop[1];
	      }
	    }
	
	    if (firstDraw || style.fill !== prevStyle.fill) {
	      ctx.fillStyle = style.fill;
	    }
	
	    if (firstDraw || style.stroke !== prevStyle.stroke) {
	      ctx.strokeStyle = style.stroke;
	    }
	
	    if (firstDraw || style.opacity !== prevStyle.opacity) {
	      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
	    }
	
	    if (firstDraw || style.blend !== prevStyle.blend) {
	      ctx.globalCompositeOperation = style.blend || 'source-over';
	    }
	
	    if (this.hasStroke()) {
	      var lineWidth = style.lineWidth;
	      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
	    }
	  },
	  hasFill: function () {
	    var fill = this.fill;
	    return fill != null && fill !== 'none';
	  },
	  hasStroke: function () {
	    var stroke = this.stroke;
	    return stroke != null && stroke !== 'none' && this.lineWidth > 0;
	  },
	
	  /**
	   * Extend from other style
	   * @param {zrender/graphic/Style} otherStyle
	   * @param {boolean} overwrite true: overwrirte any way.
	   *                            false: overwrite only when !target.hasOwnProperty
	   *                            others: overwrite when property is not null/undefined.
	   */
	  extendFrom: function (otherStyle, overwrite) {
	    if (otherStyle) {
	      for (var name in otherStyle) {
	        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {
	          this[name] = otherStyle[name];
	        }
	      }
	    }
	  },
	
	  /**
	   * Batch setting style with a given object
	   * @param {Object|string} obj
	   * @param {*} [obj]
	   */
	  set: function (obj, value) {
	    if (typeof obj === 'string') {
	      this[obj] = value;
	    } else {
	      this.extendFrom(obj, true);
	    }
	  },
	
	  /**
	   * Clone
	   * @return {zrender/graphic/Style} [description]
	   */
	  clone: function () {
	    var newStyle = new this.constructor();
	    newStyle.extendFrom(this, true);
	    return newStyle;
	  },
	  getGradient: function (ctx, obj, rect) {
	    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
	    var canvasGradient = method(ctx, obj, rect);
	    var colorStops = obj.colorStops;
	
	    for (var i = 0; i < colorStops.length; i++) {
	      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
	    }
	
	    return canvasGradient;
	  }
	};
	var styleProto = Style.prototype;
	
	for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	  var prop = STYLE_COMMON_PROPS[i];
	
	  if (!(prop[0] in styleProto)) {
	    styleProto[prop[0]] = prop[1];
	  }
	} // Provide for others
	
	
	Style.getGradient = styleProto.getGradient;
	var _default = Style;
	module.exports = _default;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	var guid = __webpack_require__(10);
	
	var Eventful = __webpack_require__(11);
	
	var Transformable = __webpack_require__(12);
	
	var Animatable = __webpack_require__(15);
	
	var zrUtil = __webpack_require__(4);
	
	/**
	 * @alias module:zrender/Element
	 * @constructor
	 * @extends {module:zrender/mixin/Animatable}
	 * @extends {module:zrender/mixin/Transformable}
	 * @extends {module:zrender/mixin/Eventful}
	 */
	var Element = function (opts) {
	  // jshint ignore:line
	  Transformable.call(this, opts);
	  Eventful.call(this, opts);
	  Animatable.call(this, opts);
	  /**
	   * 画布元素ID
	   * @type {string}
	   */
	
	  this.id = opts.id || guid();
	};
	
	Element.prototype = {
	  /**
	   * 元素类型
	   * Element type
	   * @type {string}
	   */
	  type: 'element',
	
	  /**
	   * 元素名字
	   * Element name
	   * @type {string}
	   */
	  name: '',
	
	  /**
	   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
	   * ZRender instance will be assigned when element is associated with zrender
	   * @name module:/zrender/Element#__zr
	   * @type {module:zrender/ZRender}
	   */
	  __zr: null,
	
	  /**
	   * 图形是否忽略，为true时忽略图形的绘制以及事件触发
	   * If ignore drawing and events of the element object
	   * @name module:/zrender/Element#ignore
	   * @type {boolean}
	   * @default false
	   */
	  ignore: false,
	
	  /**
	   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
	   * 该路径会继承被裁减对象的变换
	   * @type {module:zrender/graphic/Path}
	   * @see http://www.w3.org/TR/2dcontext/#clipping-region
	   * @readOnly
	   */
	  clipPath: null,
	
	  /**
	   * Drift element
	   * @param  {number} dx dx on the global space
	   * @param  {number} dy dy on the global space
	   */
	  drift: function (dx, dy) {
	    switch (this.draggable) {
	      case 'horizontal':
	        dy = 0;
	        break;
	
	      case 'vertical':
	        dx = 0;
	        break;
	    }
	
	    var m = this.transform;
	
	    if (!m) {
	      m = this.transform = [1, 0, 0, 1, 0, 0];
	    }
	
	    m[4] += dx;
	    m[5] += dy;
	    this.decomposeTransform();
	    this.dirty(false);
	  },
	
	  /**
	   * Hook before update
	   */
	  beforeUpdate: function () {},
	
	  /**
	   * Hook after update
	   */
	  afterUpdate: function () {},
	
	  /**
	   * Update each frame
	   */
	  update: function () {
	    this.updateTransform();
	  },
	
	  /**
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  traverse: function (cb, context) {},
	
	  /**
	   * @protected
	   */
	  attrKV: function (key, value) {
	    if (key === 'position' || key === 'scale' || key === 'origin') {
	      // Copy the array
	      if (value) {
	        var target = this[key];
	
	        if (!target) {
	          target = this[key] = [];
	        }
	
	        target[0] = value[0];
	        target[1] = value[1];
	      }
	    } else {
	      this[key] = value;
	    }
	  },
	
	  /**
	   * Hide the element
	   */
	  hide: function () {
	    this.ignore = true;
	    this.__zr && this.__zr.refresh();
	  },
	
	  /**
	   * Show the element
	   */
	  show: function () {
	    this.ignore = false;
	    this.__zr && this.__zr.refresh();
	  },
	
	  /**
	   * @param {string|Object} key
	   * @param {*} value
	   */
	  attr: function (key, value) {
	    if (typeof key === 'string') {
	      this.attrKV(key, value);
	    } else if (zrUtil.isObject(key)) {
	      for (var name in key) {
	        if (key.hasOwnProperty(name)) {
	          this.attrKV(name, key[name]);
	        }
	      }
	    }
	
	    this.dirty(false);
	    return this;
	  },
	
	  /**
	   * @param {module:zrender/graphic/Path} clipPath
	   */
	  setClipPath: function (clipPath) {
	    var zr = this.__zr;
	
	    if (zr) {
	      clipPath.addSelfToZr(zr);
	    } // Remove previous clip path
	
	
	    if (this.clipPath && this.clipPath !== clipPath) {
	      this.removeClipPath();
	    }
	
	    this.clipPath = clipPath;
	    clipPath.__zr = zr;
	    clipPath.__clipTarget = this;
	    this.dirty(false);
	  },
	
	  /**
	   */
	  removeClipPath: function () {
	    var clipPath = this.clipPath;
	
	    if (clipPath) {
	      if (clipPath.__zr) {
	        clipPath.removeSelfFromZr(clipPath.__zr);
	      }
	
	      clipPath.__zr = null;
	      clipPath.__clipTarget = null;
	      this.clipPath = null;
	      this.dirty(false);
	    }
	  },
	
	  /**
	   * Add self from zrender instance.
	   * Not recursively because it will be invoked when element added to storage.
	   * @param {module:zrender/ZRender} zr
	   */
	  addSelfToZr: function (zr) {
	    this.__zr = zr; // 添加动画
	
	    var animators = this.animators;
	
	    if (animators) {
	      for (var i = 0; i < animators.length; i++) {
	        zr.animation.addAnimator(animators[i]);
	      }
	    }
	
	    if (this.clipPath) {
	      this.clipPath.addSelfToZr(zr);
	    }
	  },
	
	  /**
	   * Remove self from zrender instance.
	   * Not recursively because it will be invoked when element added to storage.
	   * @param {module:zrender/ZRender} zr
	   */
	  removeSelfFromZr: function (zr) {
	    this.__zr = null; // 移除动画
	
	    var animators = this.animators;
	
	    if (animators) {
	      for (var i = 0; i < animators.length; i++) {
	        zr.animation.removeAnimator(animators[i]);
	      }
	    }
	
	    if (this.clipPath) {
	      this.clipPath.removeSelfFromZr(zr);
	    }
	  }
	};
	zrUtil.mixin(Element, Animatable);
	zrUtil.mixin(Element, Transformable);
	zrUtil.mixin(Element, Eventful);
	var _default = Element;
	module.exports = _default;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	/**
	 * zrender: 生成唯一id
	 *
	 * @author errorrik (errorrik@gmail.com)
	 */
	var idStart = 0x0907;
	
	function _default() {
	  return idStart++;
	}
	
	module.exports = _default;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	/**
	 * 事件扩展
	 * @module zrender/mixin/Eventful
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	var arrySlice = Array.prototype.slice;
	/**
	 * 事件分发器
	 * @alias module:zrender/mixin/Eventful
	 * @constructor
	 */
	
	var Eventful = function () {
	  this._$handlers = {};
	};
	
	Eventful.prototype = {
	  constructor: Eventful,
	
	  /**
	   * 单次触发绑定，trigger后销毁
	   *
	   * @param {string} event 事件名
	   * @param {Function} handler 响应函数
	   * @param {Object} context
	   */
	  one: function (event, handler, context) {
	    var _h = this._$handlers;
	
	    if (!handler || !event) {
	      return this;
	    }
	
	    if (!_h[event]) {
	      _h[event] = [];
	    }
	
	    for (var i = 0; i < _h[event].length; i++) {
	      if (_h[event][i].h === handler) {
	        return this;
	      }
	    }
	
	    _h[event].push({
	      h: handler,
	      one: true,
	      ctx: context || this
	    });
	
	    return this;
	  },
	
	  /**
	   * 绑定事件
	   * @param {string} event 事件名
	   * @param {Function} handler 事件处理函数
	   * @param {Object} [context]
	   */
	  on: function (event, handler, context) {
	    var _h = this._$handlers;
	
	    if (!handler || !event) {
	      return this;
	    }
	
	    if (!_h[event]) {
	      _h[event] = [];
	    }
	
	    for (var i = 0; i < _h[event].length; i++) {
	      if (_h[event][i].h === handler) {
	        return this;
	      }
	    }
	
	    _h[event].push({
	      h: handler,
	      one: false,
	      ctx: context || this
	    });
	
	    return this;
	  },
	
	  /**
	   * 是否绑定了事件
	   * @param  {string}  event
	   * @return {boolean}
	   */
	  isSilent: function (event) {
	    var _h = this._$handlers;
	    return _h[event] && _h[event].length;
	  },
	
	  /**
	   * 解绑事件
	   * @param {string} event 事件名
	   * @param {Function} [handler] 事件处理函数
	   */
	  off: function (event, handler) {
	    var _h = this._$handlers;
	
	    if (!event) {
	      this._$handlers = {};
	      return this;
	    }
	
	    if (handler) {
	      if (_h[event]) {
	        var newList = [];
	
	        for (var i = 0, l = _h[event].length; i < l; i++) {
	          if (_h[event][i]['h'] != handler) {
	            newList.push(_h[event][i]);
	          }
	        }
	
	        _h[event] = newList;
	      }
	
	      if (_h[event] && _h[event].length === 0) {
	        delete _h[event];
	      }
	    } else {
	      delete _h[event];
	    }
	
	    return this;
	  },
	
	  /**
	   * 事件分发
	   *
	   * @param {string} type 事件类型
	   */
	  trigger: function (type) {
	    if (this._$handlers[type]) {
	      var args = arguments;
	      var argLen = args.length;
	
	      if (argLen > 3) {
	        args = arrySlice.call(args, 1);
	      }
	
	      var _h = this._$handlers[type];
	      var len = _h.length;
	
	      for (var i = 0; i < len;) {
	        // Optimize advise from backbone
	        switch (argLen) {
	          case 1:
	            _h[i]['h'].call(_h[i]['ctx']);
	
	            break;
	
	          case 2:
	            _h[i]['h'].call(_h[i]['ctx'], args[1]);
	
	            break;
	
	          case 3:
	            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
	
	            break;
	
	          default:
	            // have more than 2 given arguments
	            _h[i]['h'].apply(_h[i]['ctx'], args);
	
	            break;
	        }
	
	        if (_h[i]['one']) {
	          _h.splice(i, 1);
	
	          len--;
	        } else {
	          i++;
	        }
	      }
	    }
	
	    return this;
	  },
	
	  /**
	   * 带有context的事件分发, 最后一个参数是事件回调的context
	   * @param {string} type 事件类型
	   */
	  triggerWithContext: function (type) {
	    if (this._$handlers[type]) {
	      var args = arguments;
	      var argLen = args.length;
	
	      if (argLen > 4) {
	        args = arrySlice.call(args, 1, args.length - 1);
	      }
	
	      var ctx = args[args.length - 1];
	      var _h = this._$handlers[type];
	      var len = _h.length;
	
	      for (var i = 0; i < len;) {
	        // Optimize advise from backbone
	        switch (argLen) {
	          case 1:
	            _h[i]['h'].call(ctx);
	
	            break;
	
	          case 2:
	            _h[i]['h'].call(ctx, args[1]);
	
	            break;
	
	          case 3:
	            _h[i]['h'].call(ctx, args[1], args[2]);
	
	            break;
	
	          default:
	            // have more than 2 given arguments
	            _h[i]['h'].apply(ctx, args);
	
	            break;
	        }
	
	        if (_h[i]['one']) {
	          _h.splice(i, 1);
	
	          len--;
	        } else {
	          i++;
	        }
	      }
	    }
	
	    return this;
	  }
	}; // 对象可以通过 onxxxx 绑定事件
	
	/**
	 * @event module:zrender/mixin/Eventful#onclick
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmouseover
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmouseout
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmousemove
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmousewheel
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmousedown
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#onmouseup
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondrag
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragstart
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragend
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragenter
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragleave
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondragover
	 * @type {Function}
	 * @default null
	 */
	
	/**
	 * @event module:zrender/mixin/Eventful#ondrop
	 * @type {Function}
	 * @default null
	 */
	
	var _default = Eventful;
	module.exports = _default;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	var matrix = __webpack_require__(13);
	
	var vector = __webpack_require__(14);
	
	/**
	 * 提供变换扩展
	 * @module zrender/mixin/Transformable
	 * @author pissang (https://www.github.com/pissang)
	 */
	var mIdentity = matrix.identity;
	var EPSILON = 5e-5;
	
	function isNotAroundZero(val) {
	  return val > EPSILON || val < -EPSILON;
	}
	/**
	 * @alias module:zrender/mixin/Transformable
	 * @constructor
	 */
	
	
	var Transformable = function (opts) {
	  opts = opts || {}; // If there are no given position, rotation, scale
	
	  if (!opts.position) {
	    /**
	     * 平移
	     * @type {Array.<number>}
	     * @default [0, 0]
	     */
	    this.position = [0, 0];
	  }
	
	  if (opts.rotation == null) {
	    /**
	     * 旋转
	     * @type {Array.<number>}
	     * @default 0
	     */
	    this.rotation = 0;
	  }
	
	  if (!opts.scale) {
	    /**
	     * 缩放
	     * @type {Array.<number>}
	     * @default [1, 1]
	     */
	    this.scale = [1, 1];
	  }
	  /**
	   * 旋转和缩放的原点
	   * @type {Array.<number>}
	   * @default null
	   */
	
	
	  this.origin = this.origin || null;
	};
	
	var transformableProto = Transformable.prototype;
	transformableProto.transform = null;
	/**
	 * 判断是否需要有坐标变换
	 * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
	 */
	
	transformableProto.needLocalTransform = function () {
	  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
	};
	
	transformableProto.updateTransform = function () {
	  var parent = this.parent;
	  var parentHasTransform = parent && parent.transform;
	  var needLocalTransform = this.needLocalTransform();
	  var m = this.transform;
	
	  if (!(needLocalTransform || parentHasTransform)) {
	    m && mIdentity(m);
	    return;
	  }
	
	  m = m || matrix.create();
	
	  if (needLocalTransform) {
	    this.getLocalTransform(m);
	  } else {
	    mIdentity(m);
	  } // 应用父节点变换
	
	
	  if (parentHasTransform) {
	    if (needLocalTransform) {
	      matrix.mul(m, parent.transform, m);
	    } else {
	      matrix.copy(m, parent.transform);
	    }
	  } // 保存这个变换矩阵
	
	
	  this.transform = m;
	  this.invTransform = this.invTransform || matrix.create();
	  matrix.invert(this.invTransform, m);
	};
	
	transformableProto.getLocalTransform = function (m) {
	  return Transformable.getLocalTransform(this, m);
	};
	/**
	 * 将自己的transform应用到context上
	 * @param {CanvasRenderingContext2D} ctx
	 */
	
	
	transformableProto.setTransform = function (ctx) {
	  var m = this.transform;
	  var dpr = ctx.dpr || 1;
	
	  if (m) {
	    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
	  } else {
	    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	  }
	};
	
	transformableProto.restoreTransform = function (ctx) {
	  var dpr = ctx.dpr || 1;
	  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	};
	
	var tmpTransform = [];
	/**
	 * 分解`transform`矩阵到`position`, `rotation`, `scale`
	 */
	
	transformableProto.decomposeTransform = function () {
	  if (!this.transform) {
	    return;
	  }
	
	  var parent = this.parent;
	  var m = this.transform;
	
	  if (parent && parent.transform) {
	    // Get local transform and decompose them to position, scale, rotation
	    matrix.mul(tmpTransform, parent.invTransform, m);
	    m = tmpTransform;
	  }
	
	  var sx = m[0] * m[0] + m[1] * m[1];
	  var sy = m[2] * m[2] + m[3] * m[3];
	  var position = this.position;
	  var scale = this.scale;
	
	  if (isNotAroundZero(sx - 1)) {
	    sx = Math.sqrt(sx);
	  }
	
	  if (isNotAroundZero(sy - 1)) {
	    sy = Math.sqrt(sy);
	  }
	
	  if (m[0] < 0) {
	    sx = -sx;
	  }
	
	  if (m[3] < 0) {
	    sy = -sy;
	  }
	
	  position[0] = m[4];
	  position[1] = m[5];
	  scale[0] = sx;
	  scale[1] = sy;
	  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
	};
	/**
	 * Get global scale
	 * @return {Array.<number>}
	 */
	
	
	transformableProto.getGlobalScale = function () {
	  var m = this.transform;
	
	  if (!m) {
	    return [1, 1];
	  }
	
	  var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
	  var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
	
	  if (m[0] < 0) {
	    sx = -sx;
	  }
	
	  if (m[3] < 0) {
	    sy = -sy;
	  }
	
	  return [sx, sy];
	};
	/**
	 * 变换坐标位置到 shape 的局部坐标空间
	 * @method
	 * @param {number} x
	 * @param {number} y
	 * @return {Array.<number>}
	 */
	
	
	transformableProto.transformCoordToLocal = function (x, y) {
	  var v2 = [x, y];
	  var invTransform = this.invTransform;
	
	  if (invTransform) {
	    vector.applyTransform(v2, v2, invTransform);
	  }
	
	  return v2;
	};
	/**
	 * 变换局部坐标位置到全局坐标空间
	 * @method
	 * @param {number} x
	 * @param {number} y
	 * @return {Array.<number>}
	 */
	
	
	transformableProto.transformCoordToGlobal = function (x, y) {
	  var v2 = [x, y];
	  var transform = this.transform;
	
	  if (transform) {
	    vector.applyTransform(v2, v2, transform);
	  }
	
	  return v2;
	};
	/**
	 * @static
	 * @param {Object} target
	 * @param {Array.<number>} target.origin
	 * @param {number} target.rotation
	 * @param {Array.<number>} target.position
	 * @param {Array.<number>} [m]
	 */
	
	
	Transformable.getLocalTransform = function (target, m) {
	  m = m || [];
	  mIdentity(m);
	  var origin = target.origin;
	  var scale = target.scale || [1, 1];
	  var rotation = target.rotation || 0;
	  var position = target.position || [0, 0];
	
	  if (origin) {
	    // Translate to origin
	    m[4] -= origin[0];
	    m[5] -= origin[1];
	  }
	
	  matrix.scale(m, m, scale);
	
	  if (rotation) {
	    matrix.rotate(m, m, rotation);
	  }
	
	  if (origin) {
	    // Translate back from origin
	    m[4] += origin[0];
	    m[5] += origin[1];
	  }
	
	  m[4] += position[0];
	  m[5] += position[1];
	  return m;
	};
	
	var _default = Transformable;
	module.exports = _default;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	/**
	 * 3x2矩阵操作类
	 * @exports zrender/tool/matrix
	 */
	var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
	/**
	 * 创建一个单位矩阵
	 * @return {Float32Array|Array.<number>}
	 */
	
	function create() {
	  var out = new ArrayCtor(6);
	  identity(out);
	  return out;
	}
	/**
	 * 设置矩阵为单位矩阵
	 * @param {Float32Array|Array.<number>} out
	 */
	
	
	function identity(out) {
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 1;
	  out[4] = 0;
	  out[5] = 0;
	  return out;
	}
	/**
	 * 复制矩阵
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} m
	 */
	
	
	function copy(out, m) {
	  out[0] = m[0];
	  out[1] = m[1];
	  out[2] = m[2];
	  out[3] = m[3];
	  out[4] = m[4];
	  out[5] = m[5];
	  return out;
	}
	/**
	 * 矩阵相乘
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} m1
	 * @param {Float32Array|Array.<number>} m2
	 */
	
	
	function mul(out, m1, m2) {
	  // Consider matrix.mul(m, m2, m);
	  // where out is the same as m2.
	  // So use temp variable to escape error.
	  var out0 = m1[0] * m2[0] + m1[2] * m2[1];
	  var out1 = m1[1] * m2[0] + m1[3] * m2[1];
	  var out2 = m1[0] * m2[2] + m1[2] * m2[3];
	  var out3 = m1[1] * m2[2] + m1[3] * m2[3];
	  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
	  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
	  out[0] = out0;
	  out[1] = out1;
	  out[2] = out2;
	  out[3] = out3;
	  out[4] = out4;
	  out[5] = out5;
	  return out;
	}
	/**
	 * 平移变换
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 * @param {Float32Array|Array.<number>} v
	 */
	
	
	function translate(out, a, v) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  out[4] = a[4] + v[0];
	  out[5] = a[5] + v[1];
	  return out;
	}
	/**
	 * 旋转变换
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 * @param {number} rad
	 */
	
	
	function rotate(out, a, rad) {
	  var aa = a[0];
	  var ac = a[2];
	  var atx = a[4];
	  var ab = a[1];
	  var ad = a[3];
	  var aty = a[5];
	  var st = Math.sin(rad);
	  var ct = Math.cos(rad);
	  out[0] = aa * ct + ab * st;
	  out[1] = -aa * st + ab * ct;
	  out[2] = ac * ct + ad * st;
	  out[3] = -ac * st + ct * ad;
	  out[4] = ct * atx + st * aty;
	  out[5] = ct * aty - st * atx;
	  return out;
	}
	/**
	 * 缩放变换
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 * @param {Float32Array|Array.<number>} v
	 */
	
	
	function scale(out, a, v) {
	  var vx = v[0];
	  var vy = v[1];
	  out[0] = a[0] * vx;
	  out[1] = a[1] * vy;
	  out[2] = a[2] * vx;
	  out[3] = a[3] * vy;
	  out[4] = a[4] * vx;
	  out[5] = a[5] * vy;
	  return out;
	}
	/**
	 * 求逆矩阵
	 * @param {Float32Array|Array.<number>} out
	 * @param {Float32Array|Array.<number>} a
	 */
	
	
	function invert(out, a) {
	  var aa = a[0];
	  var ac = a[2];
	  var atx = a[4];
	  var ab = a[1];
	  var ad = a[3];
	  var aty = a[5];
	  var det = aa * ad - ab * ac;
	
	  if (!det) {
	    return null;
	  }
	
	  det = 1.0 / det;
	  out[0] = ad * det;
	  out[1] = -ab * det;
	  out[2] = -ac * det;
	  out[3] = aa * det;
	  out[4] = (ac * aty - ad * atx) * det;
	  out[5] = (ab * atx - aa * aty) * det;
	  return out;
	}
	
	exports.create = create;
	exports.identity = identity;
	exports.copy = copy;
	exports.mul = mul;
	exports.translate = translate;
	exports.rotate = rotate;
	exports.scale = scale;
	exports.invert = invert;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
	/**
	 * 创建一个向量
	 * @param {number} [x=0]
	 * @param {number} [y=0]
	 * @return {Vector2}
	 */
	
	function create(x, y) {
	  var out = new ArrayCtor(2);
	
	  if (x == null) {
	    x = 0;
	  }
	
	  if (y == null) {
	    y = 0;
	  }
	
	  out[0] = x;
	  out[1] = y;
	  return out;
	}
	/**
	 * 复制向量数据
	 * @param {Vector2} out
	 * @param {Vector2} v
	 * @return {Vector2}
	 */
	
	
	function copy(out, v) {
	  out[0] = v[0];
	  out[1] = v[1];
	  return out;
	}
	/**
	 * 克隆一个向量
	 * @param {Vector2} v
	 * @return {Vector2}
	 */
	
	
	function clone(v) {
	  var out = new ArrayCtor(2);
	  out[0] = v[0];
	  out[1] = v[1];
	  return out;
	}
	/**
	 * 设置向量的两个项
	 * @param {Vector2} out
	 * @param {number} a
	 * @param {number} b
	 * @return {Vector2} 结果
	 */
	
	
	function set(out, a, b) {
	  out[0] = a;
	  out[1] = b;
	  return out;
	}
	/**
	 * 向量相加
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	
	function add(out, v1, v2) {
	  out[0] = v1[0] + v2[0];
	  out[1] = v1[1] + v2[1];
	  return out;
	}
	/**
	 * 向量缩放后相加
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @param {number} a
	 */
	
	
	function scaleAndAdd(out, v1, v2, a) {
	  out[0] = v1[0] + v2[0] * a;
	  out[1] = v1[1] + v2[1] * a;
	  return out;
	}
	/**
	 * 向量相减
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	
	function sub(out, v1, v2) {
	  out[0] = v1[0] - v2[0];
	  out[1] = v1[1] - v2[1];
	  return out;
	}
	/**
	 * 向量长度
	 * @param {Vector2} v
	 * @return {number}
	 */
	
	
	function len(v) {
	  return Math.sqrt(lenSquare(v));
	}
	
	var length = len; // jshint ignore:line
	
	/**
	 * 向量长度平方
	 * @param {Vector2} v
	 * @return {number}
	 */
	
	function lenSquare(v) {
	  return v[0] * v[0] + v[1] * v[1];
	}
	
	var lengthSquare = lenSquare;
	/**
	 * 向量乘法
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	function mul(out, v1, v2) {
	  out[0] = v1[0] * v2[0];
	  out[1] = v1[1] * v2[1];
	  return out;
	}
	/**
	 * 向量除法
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 */
	
	
	function div(out, v1, v2) {
	  out[0] = v1[0] / v2[0];
	  out[1] = v1[1] / v2[1];
	  return out;
	}
	/**
	 * 向量点乘
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @return {number}
	 */
	
	
	function dot(v1, v2) {
	  return v1[0] * v2[0] + v1[1] * v2[1];
	}
	/**
	 * 向量缩放
	 * @param {Vector2} out
	 * @param {Vector2} v
	 * @param {number} s
	 */
	
	
	function scale(out, v, s) {
	  out[0] = v[0] * s;
	  out[1] = v[1] * s;
	  return out;
	}
	/**
	 * 向量归一化
	 * @param {Vector2} out
	 * @param {Vector2} v
	 */
	
	
	function normalize(out, v) {
	  var d = len(v);
	
	  if (d === 0) {
	    out[0] = 0;
	    out[1] = 0;
	  } else {
	    out[0] = v[0] / d;
	    out[1] = v[1] / d;
	  }
	
	  return out;
	}
	/**
	 * 计算向量间距离
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @return {number}
	 */
	
	
	function distance(v1, v2) {
	  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
	}
	
	var dist = distance;
	/**
	 * 向量距离平方
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @return {number}
	 */
	
	function distanceSquare(v1, v2) {
	  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	}
	
	var distSquare = distanceSquare;
	/**
	 * 求负向量
	 * @param {Vector2} out
	 * @param {Vector2} v
	 */
	
	function negate(out, v) {
	  out[0] = -v[0];
	  out[1] = -v[1];
	  return out;
	}
	/**
	 * 插值两个点
	 * @param {Vector2} out
	 * @param {Vector2} v1
	 * @param {Vector2} v2
	 * @param {number} t
	 */
	
	
	function lerp(out, v1, v2, t) {
	  out[0] = v1[0] + t * (v2[0] - v1[0]);
	  out[1] = v1[1] + t * (v2[1] - v1[1]);
	  return out;
	}
	/**
	 * 矩阵左乘向量
	 * @param {Vector2} out
	 * @param {Vector2} v
	 * @param {Vector2} m
	 */
	
	
	function applyTransform(out, v, m) {
	  var x = v[0];
	  var y = v[1];
	  out[0] = m[0] * x + m[2] * y + m[4];
	  out[1] = m[1] * x + m[3] * y + m[5];
	  return out;
	}
	/**
	 * 求两个向量最小值
	 * @param  {Vector2} out
	 * @param  {Vector2} v1
	 * @param  {Vector2} v2
	 */
	
	
	function min(out, v1, v2) {
	  out[0] = Math.min(v1[0], v2[0]);
	  out[1] = Math.min(v1[1], v2[1]);
	  return out;
	}
	/**
	 * 求两个向量最大值
	 * @param  {Vector2} out
	 * @param  {Vector2} v1
	 * @param  {Vector2} v2
	 */
	
	
	function max(out, v1, v2) {
	  out[0] = Math.max(v1[0], v2[0]);
	  out[1] = Math.max(v1[1], v2[1]);
	  return out;
	}
	
	exports.create = create;
	exports.copy = copy;
	exports.clone = clone;
	exports.set = set;
	exports.add = add;
	exports.scaleAndAdd = scaleAndAdd;
	exports.sub = sub;
	exports.len = len;
	exports.length = length;
	exports.lenSquare = lenSquare;
	exports.lengthSquare = lengthSquare;
	exports.mul = mul;
	exports.div = div;
	exports.dot = dot;
	exports.scale = scale;
	exports.normalize = normalize;
	exports.distance = distance;
	exports.dist = dist;
	exports.distanceSquare = distanceSquare;
	exports.distSquare = distSquare;
	exports.negate = negate;
	exports.lerp = lerp;
	exports.applyTransform = applyTransform;
	exports.min = min;
	exports.max = max;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	var Animator = __webpack_require__(16);
	
	var log = __webpack_require__(21);
	
	var _util = __webpack_require__(4);
	
	var isString = _util.isString;
	var isFunction = _util.isFunction;
	var isObject = _util.isObject;
	var isArrayLike = _util.isArrayLike;
	var indexOf = _util.indexOf;
	
	/**
	 * @alias modue:zrender/mixin/Animatable
	 * @constructor
	 */
	var Animatable = function () {
	  /**
	   * @type {Array.<module:zrender/animation/Animator>}
	   * @readOnly
	   */
	  this.animators = [];
	};
	
	Animatable.prototype = {
	  constructor: Animatable,
	
	  /**
	   * 动画
	   *
	   * @param {string} path The path to fetch value from object, like 'a.b.c'.
	   * @param {boolean} [loop] Whether to loop animation.
	   * @return {module:zrender/animation/Animator}
	   * @example:
	   *     el.animate('style', false)
	   *         .when(1000, {x: 10} )
	   *         .done(function(){ // Animation done })
	   *         .start()
	   */
	  animate: function (path, loop) {
	    var target;
	    var animatingShape = false;
	    var el = this;
	    var zr = this.__zr;
	
	    if (path) {
	      var pathSplitted = path.split('.');
	      var prop = el; // If animating shape
	
	      animatingShape = pathSplitted[0] === 'shape';
	
	      for (var i = 0, l = pathSplitted.length; i < l; i++) {
	        if (!prop) {
	          continue;
	        }
	
	        prop = prop[pathSplitted[i]];
	      }
	
	      if (prop) {
	        target = prop;
	      }
	    } else {
	      target = el;
	    }
	
	    if (!target) {
	      log('Property "' + path + '" is not existed in element ' + el.id);
	      return;
	    }
	
	    var animators = el.animators;
	    var animator = new Animator(target, loop);
	    animator.during(function (target) {
	      el.dirty(animatingShape);
	    }).done(function () {
	      // FIXME Animator will not be removed if use `Animator#stop` to stop animation
	      animators.splice(indexOf(animators, animator), 1);
	    });
	    animators.push(animator); // If animate after added to the zrender
	
	    if (zr) {
	      zr.animation.addAnimator(animator);
	    }
	
	    return animator;
	  },
	
	  /**
	   * 停止动画
	   * @param {boolean} forwardToLast If move to last frame before stop
	   */
	  stopAnimation: function (forwardToLast) {
	    var animators = this.animators;
	    var len = animators.length;
	
	    for (var i = 0; i < len; i++) {
	      animators[i].stop(forwardToLast);
	    }
	
	    animators.length = 0;
	    return this;
	  },
	
	  /**
	   * Caution: this method will stop previous animation.
	   * So do not use this method to one element twice before
	   * animation starts, unless you know what you are doing.
	   * @param {Object} target
	   * @param {number} [time=500] Time in ms
	   * @param {string} [easing='linear']
	   * @param {number} [delay=0]
	   * @param {Function} [callback]
	   * @param {Function} [forceAnimate] Prevent stop animation and callback
	   *        immediently when target values are the same as current values.
	   *
	   * @example
	   *  // Animate position
	   *  el.animateTo({
	   *      position: [10, 10]
	   *  }, function () { // done })
	   *
	   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	   *  el.animateTo({
	   *      shape: {
	   *          width: 500
	   *      },
	   *      style: {
	   *          fill: 'red'
	   *      }
	   *      position: [10, 10]
	   *  }, 100, 100, 'cubicOut', function () { // done })
	   */
	  // TODO Return animation key
	  animateTo: function (target, time, delay, easing, callback, forceAnimate) {
	    // animateTo(target, time, easing, callback);
	    if (isString(delay)) {
	      callback = easing;
	      easing = delay;
	      delay = 0;
	    } // animateTo(target, time, delay, callback);
	    else if (isFunction(easing)) {
	        callback = easing;
	        easing = 'linear';
	        delay = 0;
	      } // animateTo(target, time, callback);
	      else if (isFunction(delay)) {
	          callback = delay;
	          delay = 0;
	        } // animateTo(target, callback)
	        else if (isFunction(time)) {
	            callback = time;
	            time = 500;
	          } // animateTo(target)
	          else if (!time) {
	              time = 500;
	            } // Stop all previous animations
	
	
	    this.stopAnimation();
	
	    this._animateToShallow('', this, target, time, delay); // Animators may be removed immediately after start
	    // if there is nothing to animate
	
	
	    var animators = this.animators.slice();
	    var count = animators.length;
	
	    function done() {
	      count--;
	
	      if (!count) {
	        callback && callback();
	      }
	    } // No animators. This should be checked before animators[i].start(),
	    // because 'done' may be executed immediately if no need to animate.
	
	
	    if (!count) {
	      callback && callback();
	    } // Start after all animators created
	    // Incase any animator is done immediately when all animation properties are not changed
	
	
	    for (var i = 0; i < animators.length; i++) {
	      animators[i].done(done).start(easing, forceAnimate);
	    }
	  },
	
	  /**
	   * @private
	   * @param {string} path=''
	   * @param {Object} source=this
	   * @param {Object} target
	   * @param {number} [time=500]
	   * @param {number} [delay=0]
	   *
	   * @example
	   *  // Animate position
	   *  el._animateToShallow({
	   *      position: [10, 10]
	   *  })
	   *
	   *  // Animate shape, style and position in 100ms, delayed 100ms
	   *  el._animateToShallow({
	   *      shape: {
	   *          width: 500
	   *      },
	   *      style: {
	   *          fill: 'red'
	   *      }
	   *      position: [10, 10]
	   *  }, 100, 100)
	   */
	  _animateToShallow: function (path, source, target, time, delay) {
	    var objShallow = {};
	    var propertyCount = 0;
	
	    for (var name in target) {
	      if (!target.hasOwnProperty(name)) {
	        continue;
	      }
	
	      if (source[name] != null) {
	        if (isObject(target[name]) && !isArrayLike(target[name])) {
	          this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);
	        } else {
	          objShallow[name] = target[name];
	          propertyCount++;
	        }
	      } else if (target[name] != null) {
	        // Attr directly if not has property
	        // FIXME, if some property not needed for element ?
	        if (!path) {
	          this.attr(name, target[name]);
	        } else {
	          // Shape or style
	          var props = {};
	          props[path] = {};
	          props[path][name] = target[name];
	          this.attr(props);
	        }
	      }
	    }
	
	    if (propertyCount > 0) {
	      this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
	    }
	
	    return this;
	  }
	};
	var _default = Animatable;
	module.exports = _default;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	var Clip = __webpack_require__(17);
	
	var color = __webpack_require__(19);
	
	var _util = __webpack_require__(4);
	
	var isArrayLike = _util.isArrayLike;
	
	/**
	 * @module echarts/animation/Animator
	 */
	var arraySlice = Array.prototype.slice;
	
	function defaultGetter(target, key) {
	  return target[key];
	}
	
	function defaultSetter(target, key, value) {
	  target[key] = value;
	}
	/**
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} percent
	 * @return {number}
	 */
	
	
	function interpolateNumber(p0, p1, percent) {
	  return (p1 - p0) * percent + p0;
	}
	/**
	 * @param  {string} p0
	 * @param  {string} p1
	 * @param  {number} percent
	 * @return {string}
	 */
	
	
	function interpolateString(p0, p1, percent) {
	  return percent > 0.5 ? p1 : p0;
	}
	/**
	 * @param  {Array} p0
	 * @param  {Array} p1
	 * @param  {number} percent
	 * @param  {Array} out
	 * @param  {number} arrDim
	 */
	
	
	function interpolateArray(p0, p1, percent, out, arrDim) {
	  var len = p0.length;
	
	  if (arrDim == 1) {
	    for (var i = 0; i < len; i++) {
	      out[i] = interpolateNumber(p0[i], p1[i], percent);
	    }
	  } else {
	    var len2 = len && p0[0].length;
	
	    for (var i = 0; i < len; i++) {
	      for (var j = 0; j < len2; j++) {
	        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
	      }
	    }
	  }
	} // arr0 is source array, arr1 is target array.
	// Do some preprocess to avoid error happened when interpolating from arr0 to arr1
	
	
	function fillArr(arr0, arr1, arrDim) {
	  var arr0Len = arr0.length;
	  var arr1Len = arr1.length;
	
	  if (arr0Len !== arr1Len) {
	    // FIXME Not work for TypedArray
	    var isPreviousLarger = arr0Len > arr1Len;
	
	    if (isPreviousLarger) {
	      // Cut the previous
	      arr0.length = arr1Len;
	    } else {
	      // Fill the previous
	      for (var i = arr0Len; i < arr1Len; i++) {
	        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
	      }
	    }
	  } // Handling NaN value
	
	
	  var len2 = arr0[0] && arr0[0].length;
	
	  for (var i = 0; i < arr0.length; i++) {
	    if (arrDim === 1) {
	      if (isNaN(arr0[i])) {
	        arr0[i] = arr1[i];
	      }
	    } else {
	      for (var j = 0; j < len2; j++) {
	        if (isNaN(arr0[i][j])) {
	          arr0[i][j] = arr1[i][j];
	        }
	      }
	    }
	  }
	}
	/**
	 * @param  {Array} arr0
	 * @param  {Array} arr1
	 * @param  {number} arrDim
	 * @return {boolean}
	 */
	
	
	function isArraySame(arr0, arr1, arrDim) {
	  if (arr0 === arr1) {
	    return true;
	  }
	
	  var len = arr0.length;
	
	  if (len !== arr1.length) {
	    return false;
	  }
	
	  if (arrDim === 1) {
	    for (var i = 0; i < len; i++) {
	      if (arr0[i] !== arr1[i]) {
	        return false;
	      }
	    }
	  } else {
	    var len2 = arr0[0].length;
	
	    for (var i = 0; i < len; i++) {
	      for (var j = 0; j < len2; j++) {
	        if (arr0[i][j] !== arr1[i][j]) {
	          return false;
	        }
	      }
	    }
	  }
	
	  return true;
	}
	/**
	 * Catmull Rom interpolate array
	 * @param  {Array} p0
	 * @param  {Array} p1
	 * @param  {Array} p2
	 * @param  {Array} p3
	 * @param  {number} t
	 * @param  {number} t2
	 * @param  {number} t3
	 * @param  {Array} out
	 * @param  {number} arrDim
	 */
	
	
	function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
	  var len = p0.length;
	
	  if (arrDim == 1) {
	    for (var i = 0; i < len; i++) {
	      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
	    }
	  } else {
	    var len2 = p0[0].length;
	
	    for (var i = 0; i < len; i++) {
	      for (var j = 0; j < len2; j++) {
	        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
	      }
	    }
	  }
	}
	/**
	 * Catmull Rom interpolate number
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @param  {number} t2
	 * @param  {number} t3
	 * @return {number}
	 */
	
	
	function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
	  var v0 = (p2 - p0) * 0.5;
	  var v1 = (p3 - p1) * 0.5;
	  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
	}
	
	function cloneValue(value) {
	  if (isArrayLike(value)) {
	    var len = value.length;
	
	    if (isArrayLike(value[0])) {
	      var ret = [];
	
	      for (var i = 0; i < len; i++) {
	        ret.push(arraySlice.call(value[i]));
	      }
	
	      return ret;
	    }
	
	    return arraySlice.call(value);
	  }
	
	  return value;
	}
	
	function rgba2String(rgba) {
	  rgba[0] = Math.floor(rgba[0]);
	  rgba[1] = Math.floor(rgba[1]);
	  rgba[2] = Math.floor(rgba[2]);
	  return 'rgba(' + rgba.join(',') + ')';
	}
	
	function getArrayDim(keyframes) {
	  var lastValue = keyframes[keyframes.length - 1].value;
	  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;
	}
	
	function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
	  var getter = animator._getter;
	  var setter = animator._setter;
	  var useSpline = easing === 'spline';
	  var trackLen = keyframes.length;
	
	  if (!trackLen) {
	    return;
	  } // Guess data type
	
	
	  var firstVal = keyframes[0].value;
	  var isValueArray = isArrayLike(firstVal);
	  var isValueColor = false;
	  var isValueString = false; // For vertices morphing
	
	  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
	  var trackMaxTime; // Sort keyframe as ascending
	
	  keyframes.sort(function (a, b) {
	    return a.time - b.time;
	  });
	  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe
	
	  var kfPercents = []; // Value of each keyframe
	
	  var kfValues = [];
	  var prevValue = keyframes[0].value;
	  var isAllValueEqual = true;
	
	  for (var i = 0; i < trackLen; i++) {
	    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string
	
	    var value = keyframes[i].value; // Check if value is equal, deep check if value is array
	
	    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
	      isAllValueEqual = false;
	    }
	
	    prevValue = value; // Try converting a string to a color array
	
	    if (typeof value == 'string') {
	      var colorArray = color.parse(value);
	
	      if (colorArray) {
	        value = colorArray;
	        isValueColor = true;
	      } else {
	        isValueString = true;
	      }
	    }
	
	    kfValues.push(value);
	  }
	
	  if (!forceAnimate && isAllValueEqual) {
	    return;
	  }
	
	  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value
	
	  for (var i = 0; i < trackLen - 1; i++) {
	    if (isValueArray) {
	      fillArr(kfValues[i], lastValue, arrDim);
	    } else {
	      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
	        kfValues[i] = lastValue;
	      }
	    }
	  }
	
	  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when
	  // animation playback is sequency
	
	  var lastFrame = 0;
	  var lastFramePercent = 0;
	  var start;
	  var w;
	  var p0;
	  var p1;
	  var p2;
	  var p3;
	
	  if (isValueColor) {
	    var rgba = [0, 0, 0, 0];
	  }
	
	  var onframe = function (target, percent) {
	    // Find the range keyframes
	    // kf1-----kf2---------current--------kf3
	    // find kf2 and kf3 and do interpolation
	    var frame; // In the easing function like elasticOut, percent may less than 0
	
	    if (percent < 0) {
	      frame = 0;
	    } else if (percent < lastFramePercent) {
	      // Start from next key
	      // PENDING start from lastFrame ?
	      start = Math.min(lastFrame + 1, trackLen - 1);
	
	      for (frame = start; frame >= 0; frame--) {
	        if (kfPercents[frame] <= percent) {
	          break;
	        }
	      } // PENDING really need to do this ?
	
	
	      frame = Math.min(frame, trackLen - 2);
	    } else {
	      for (frame = lastFrame; frame < trackLen; frame++) {
	        if (kfPercents[frame] > percent) {
	          break;
	        }
	      }
	
	      frame = Math.min(frame - 1, trackLen - 2);
	    }
	
	    lastFrame = frame;
	    lastFramePercent = percent;
	    var range = kfPercents[frame + 1] - kfPercents[frame];
	
	    if (range === 0) {
	      return;
	    } else {
	      w = (percent - kfPercents[frame]) / range;
	    }
	
	    if (useSpline) {
	      p1 = kfValues[frame];
	      p0 = kfValues[frame === 0 ? frame : frame - 1];
	      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
	      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
	
	      if (isValueArray) {
	        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
	      } else {
	        var value;
	
	        if (isValueColor) {
	          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
	          value = rgba2String(rgba);
	        } else if (isValueString) {
	          // String is step(0.5)
	          return interpolateString(p1, p2, w);
	        } else {
	          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
	        }
	
	        setter(target, propName, value);
	      }
	    } else {
	      if (isValueArray) {
	        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
	      } else {
	        var value;
	
	        if (isValueColor) {
	          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
	          value = rgba2String(rgba);
	        } else if (isValueString) {
	          // String is step(0.5)
	          return interpolateString(kfValues[frame], kfValues[frame + 1], w);
	        } else {
	          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
	        }
	
	        setter(target, propName, value);
	      }
	    }
	  };
	
	  var clip = new Clip({
	    target: animator._target,
	    life: trackMaxTime,
	    loop: animator._loop,
	    delay: animator._delay,
	    onframe: onframe,
	    ondestroy: oneTrackDone
	  });
	
	  if (easing && easing !== 'spline') {
	    clip.easing = easing;
	  }
	
	  return clip;
	}
	/**
	 * @alias module:zrender/animation/Animator
	 * @constructor
	 * @param {Object} target
	 * @param {boolean} loop
	 * @param {Function} getter
	 * @param {Function} setter
	 */
	
	
	var Animator = function (target, loop, getter, setter) {
	  this._tracks = {};
	  this._target = target;
	  this._loop = loop || false;
	  this._getter = getter || defaultGetter;
	  this._setter = setter || defaultSetter;
	  this._clipCount = 0;
	  this._delay = 0;
	  this._doneList = [];
	  this._onframeList = [];
	  this._clipList = [];
	};
	
	Animator.prototype = {
	  /**
	   * 设置动画关键帧
	   * @param  {number} time 关键帧时间，单位是ms
	   * @param  {Object} props 关键帧的属性值，key-value表示
	   * @return {module:zrender/animation/Animator}
	   */
	  when: function (time
	  /* ms */
	  , props) {
	    var tracks = this._tracks;
	
	    for (var propName in props) {
	      if (!props.hasOwnProperty(propName)) {
	        continue;
	      }
	
	      if (!tracks[propName]) {
	        tracks[propName] = []; // Invalid value
	
	        var value = this._getter(this._target, propName);
	
	        if (value == null) {
	          // zrLog('Invalid property ' + propName);
	          continue;
	        } // If time is 0
	        //  Then props is given initialize value
	        // Else
	        //  Initialize value from current prop value
	
	
	        if (time !== 0) {
	          tracks[propName].push({
	            time: 0,
	            value: cloneValue(value)
	          });
	        }
	      }
	
	      tracks[propName].push({
	        time: time,
	        value: props[propName]
	      });
	    }
	
	    return this;
	  },
	
	  /**
	   * 添加动画每一帧的回调函数
	   * @param  {Function} callback
	   * @return {module:zrender/animation/Animator}
	   */
	  during: function (callback) {
	    this._onframeList.push(callback);
	
	    return this;
	  },
	  pause: function () {
	    for (var i = 0; i < this._clipList.length; i++) {
	      this._clipList[i].pause();
	    }
	
	    this._paused = true;
	  },
	  resume: function () {
	    for (var i = 0; i < this._clipList.length; i++) {
	      this._clipList[i].resume();
	    }
	
	    this._paused = false;
	  },
	  isPaused: function () {
	    return !!this._paused;
	  },
	  _doneCallback: function () {
	    // Clear all tracks
	    this._tracks = {}; // Clear all clips
	
	    this._clipList.length = 0;
	    var doneList = this._doneList;
	    var len = doneList.length;
	
	    for (var i = 0; i < len; i++) {
	      doneList[i].call(this);
	    }
	  },
	
	  /**
	   * 开始执行动画
	   * @param  {string|Function} [easing]
	   *         动画缓动函数，详见{@link module:zrender/animation/easing}
	   * @param  {boolean} forceAnimate
	   * @return {module:zrender/animation/Animator}
	   */
	  start: function (easing, forceAnimate) {
	    var self = this;
	    var clipCount = 0;
	
	    var oneTrackDone = function () {
	      clipCount--;
	
	      if (!clipCount) {
	        self._doneCallback();
	      }
	    };
	
	    var lastClip;
	
	    for (var propName in this._tracks) {
	      if (!this._tracks.hasOwnProperty(propName)) {
	        continue;
	      }
	
	      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);
	
	      if (clip) {
	        this._clipList.push(clip);
	
	        clipCount++; // If start after added to animation
	
	        if (this.animation) {
	          this.animation.addClip(clip);
	        }
	
	        lastClip = clip;
	      }
	    } // Add during callback on the last clip
	
	
	    if (lastClip) {
	      var oldOnFrame = lastClip.onframe;
	
	      lastClip.onframe = function (target, percent) {
	        oldOnFrame(target, percent);
	
	        for (var i = 0; i < self._onframeList.length; i++) {
	          self._onframeList[i](target, percent);
	        }
	      };
	    } // This optimization will help the case that in the upper application
	    // the view may be refreshed frequently, where animation will be
	    // called repeatly but nothing changed.
	
	
	    if (!clipCount) {
	      this._doneCallback();
	    }
	
	    return this;
	  },
	
	  /**
	   * 停止动画
	   * @param {boolean} forwardToLast If move to last frame before stop
	   */
	  stop: function (forwardToLast) {
	    var clipList = this._clipList;
	    var animation = this.animation;
	
	    for (var i = 0; i < clipList.length; i++) {
	      var clip = clipList[i];
	
	      if (forwardToLast) {
	        // Move to last frame before stop
	        clip.onframe(this._target, 1);
	      }
	
	      animation && animation.removeClip(clip);
	    }
	
	    clipList.length = 0;
	  },
	
	  /**
	   * 设置动画延迟开始的时间
	   * @param  {number} time 单位ms
	   * @return {module:zrender/animation/Animator}
	   */
	  delay: function (time) {
	    this._delay = time;
	    return this;
	  },
	
	  /**
	   * 添加动画结束的回调
	   * @param  {Function} cb
	   * @return {module:zrender/animation/Animator}
	   */
	  done: function (cb) {
	    if (cb) {
	      this._doneList.push(cb);
	    }
	
	    return this;
	  },
	
	  /**
	   * @return {Array.<module:zrender/animation/Clip>}
	   */
	  getClips: function () {
	    return this._clipList;
	  }
	};
	var _default = Animator;
	module.exports = _default;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	var easingFuncs = __webpack_require__(18);
	
	/**
	 * 动画主控制器
	 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
	 * @config life(1000) 动画时长
	 * @config delay(0) 动画延迟时间
	 * @config loop(true)
	 * @config gap(0) 循环的间隔时间
	 * @config onframe
	 * @config easing(optional)
	 * @config ondestroy(optional)
	 * @config onrestart(optional)
	 *
	 * TODO pause
	 */
	function Clip(options) {
	  this._target = options.target; // 生命周期
	
	  this._life = options.life || 1000; // 延时
	
	  this._delay = options.delay || 0; // 开始时间
	  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒
	
	  this._initialized = false; // 是否循环
	
	  this.loop = options.loop == null ? false : options.loop;
	  this.gap = options.gap || 0;
	  this.easing = options.easing || 'Linear';
	  this.onframe = options.onframe;
	  this.ondestroy = options.ondestroy;
	  this.onrestart = options.onrestart;
	  this._pausedTime = 0;
	  this._paused = false;
	}
	
	Clip.prototype = {
	  constructor: Clip,
	  step: function (globalTime, deltaTime) {
	    // Set startTime on first step, or _startTime may has milleseconds different between clips
	    // PENDING
	    if (!this._initialized) {
	      this._startTime = globalTime + this._delay;
	      this._initialized = true;
	    }
	
	    if (this._paused) {
	      this._pausedTime += deltaTime;
	      return;
	    }
	
	    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始
	
	    if (percent < 0) {
	      return;
	    }
	
	    percent = Math.min(percent, 1);
	    var easing = this.easing;
	    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
	    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;
	    this.fire('frame', schedule); // 结束
	
	    if (percent == 1) {
	      if (this.loop) {
	        this.restart(globalTime); // 重新开始周期
	        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
	
	        return 'restart';
	      } // 动画完成将这个控制器标识为待删除
	      // 在Animation.update中进行批量删除
	
	
	      this._needsRemove = true;
	      return 'destroy';
	    }
	
	    return null;
	  },
	  restart: function (globalTime) {
	    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
	    this._startTime = globalTime - remainder + this.gap;
	    this._pausedTime = 0;
	    this._needsRemove = false;
	  },
	  fire: function (eventType, arg) {
	    eventType = 'on' + eventType;
	
	    if (this[eventType]) {
	      this[eventType](this._target, arg);
	    }
	  },
	  pause: function () {
	    this._paused = true;
	  },
	  resume: function () {
	    this._paused = false;
	  }
	};
	var _default = Clip;
	module.exports = _default;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

	/**
	 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
	 * @see http://sole.github.io/tween.js/examples/03_graphs.html
	 * @exports zrender/animation/easing
	 */
	var easing = {
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  linear: function (k) {
	    return k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quadraticIn: function (k) {
	    return k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quadraticOut: function (k) {
	    return k * (2 - k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quadraticInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k;
	    }
	
	    return -0.5 * (--k * (k - 2) - 1);
	  },
	  // 三次方的缓动（t^3）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  cubicIn: function (k) {
	    return k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  cubicOut: function (k) {
	    return --k * k * k + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  cubicInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k * k;
	    }
	
	    return 0.5 * ((k -= 2) * k * k + 2);
	  },
	  // 四次方的缓动（t^4）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quarticIn: function (k) {
	    return k * k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quarticOut: function (k) {
	    return 1 - --k * k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quarticInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k * k * k;
	    }
	
	    return -0.5 * ((k -= 2) * k * k * k - 2);
	  },
	  // 五次方的缓动（t^5）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quinticIn: function (k) {
	    return k * k * k * k * k;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quinticOut: function (k) {
	    return --k * k * k * k * k + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  quinticInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return 0.5 * k * k * k * k * k;
	    }
	
	    return 0.5 * ((k -= 2) * k * k * k * k + 2);
	  },
	  // 正弦曲线的缓动（sin(t)）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  sinusoidalIn: function (k) {
	    return 1 - Math.cos(k * Math.PI / 2);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  sinusoidalOut: function (k) {
	    return Math.sin(k * Math.PI / 2);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  sinusoidalInOut: function (k) {
	    return 0.5 * (1 - Math.cos(Math.PI * k));
	  },
	  // 指数曲线的缓动（2^t）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  exponentialIn: function (k) {
	    return k === 0 ? 0 : Math.pow(1024, k - 1);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  exponentialOut: function (k) {
	    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  exponentialInOut: function (k) {
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if ((k *= 2) < 1) {
	      return 0.5 * Math.pow(1024, k - 1);
	    }
	
	    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
	  },
	  // 圆形曲线的缓动（sqrt(1-t^2)）
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  circularIn: function (k) {
	    return 1 - Math.sqrt(1 - k * k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  circularOut: function (k) {
	    return Math.sqrt(1 - --k * k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  circularInOut: function (k) {
	    if ((k *= 2) < 1) {
	      return -0.5 * (Math.sqrt(1 - k * k) - 1);
	    }
	
	    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	  },
	  // 创建类似于弹簧在停止前来回振荡的动画
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  elasticIn: function (k) {
	    var s;
	    var a = 0.1;
	    var p = 0.4;
	
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if (!a || a < 1) {
	      a = 1;
	      s = p / 4;
	    } else {
	      s = p * Math.asin(1 / a) / (2 * Math.PI);
	    }
	
	    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  elasticOut: function (k) {
	    var s;
	    var a = 0.1;
	    var p = 0.4;
	
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if (!a || a < 1) {
	      a = 1;
	      s = p / 4;
	    } else {
	      s = p * Math.asin(1 / a) / (2 * Math.PI);
	    }
	
	    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  elasticInOut: function (k) {
	    var s;
	    var a = 0.1;
	    var p = 0.4;
	
	    if (k === 0) {
	      return 0;
	    }
	
	    if (k === 1) {
	      return 1;
	    }
	
	    if (!a || a < 1) {
	      a = 1;
	      s = p / 4;
	    } else {
	      s = p * Math.asin(1 / a) / (2 * Math.PI);
	    }
	
	    if ((k *= 2) < 1) {
	      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
	    }
	
	    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
	  },
	  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  backIn: function (k) {
	    var s = 1.70158;
	    return k * k * ((s + 1) * k - s);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  backOut: function (k) {
	    var s = 1.70158;
	    return --k * k * ((s + 1) * k + s) + 1;
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  backInOut: function (k) {
	    var s = 1.70158 * 1.525;
	
	    if ((k *= 2) < 1) {
	      return 0.5 * (k * k * ((s + 1) * k - s));
	    }
	
	    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	  },
	  // 创建弹跳效果
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  bounceIn: function (k) {
	    return 1 - easing.bounceOut(1 - k);
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  bounceOut: function (k) {
	    if (k < 1 / 2.75) {
	      return 7.5625 * k * k;
	    } else if (k < 2 / 2.75) {
	      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
	    } else if (k < 2.5 / 2.75) {
	      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
	    } else {
	      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
	    }
	  },
	
	  /**
	  * @param {number} k
	  * @return {number}
	  */
	  bounceInOut: function (k) {
	    if (k < 0.5) {
	      return easing.bounceIn(k * 2) * 0.5;
	    }
	
	    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
	  }
	};
	var _default = easing;
	module.exports = _default;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	var LRU = __webpack_require__(20);
	
	var kCSSColorTable = {
	  'transparent': [0, 0, 0, 0],
	  'aliceblue': [240, 248, 255, 1],
	  'antiquewhite': [250, 235, 215, 1],
	  'aqua': [0, 255, 255, 1],
	  'aquamarine': [127, 255, 212, 1],
	  'azure': [240, 255, 255, 1],
	  'beige': [245, 245, 220, 1],
	  'bisque': [255, 228, 196, 1],
	  'black': [0, 0, 0, 1],
	  'blanchedalmond': [255, 235, 205, 1],
	  'blue': [0, 0, 255, 1],
	  'blueviolet': [138, 43, 226, 1],
	  'brown': [165, 42, 42, 1],
	  'burlywood': [222, 184, 135, 1],
	  'cadetblue': [95, 158, 160, 1],
	  'chartreuse': [127, 255, 0, 1],
	  'chocolate': [210, 105, 30, 1],
	  'coral': [255, 127, 80, 1],
	  'cornflowerblue': [100, 149, 237, 1],
	  'cornsilk': [255, 248, 220, 1],
	  'crimson': [220, 20, 60, 1],
	  'cyan': [0, 255, 255, 1],
	  'darkblue': [0, 0, 139, 1],
	  'darkcyan': [0, 139, 139, 1],
	  'darkgoldenrod': [184, 134, 11, 1],
	  'darkgray': [169, 169, 169, 1],
	  'darkgreen': [0, 100, 0, 1],
	  'darkgrey': [169, 169, 169, 1],
	  'darkkhaki': [189, 183, 107, 1],
	  'darkmagenta': [139, 0, 139, 1],
	  'darkolivegreen': [85, 107, 47, 1],
	  'darkorange': [255, 140, 0, 1],
	  'darkorchid': [153, 50, 204, 1],
	  'darkred': [139, 0, 0, 1],
	  'darksalmon': [233, 150, 122, 1],
	  'darkseagreen': [143, 188, 143, 1],
	  'darkslateblue': [72, 61, 139, 1],
	  'darkslategray': [47, 79, 79, 1],
	  'darkslategrey': [47, 79, 79, 1],
	  'darkturquoise': [0, 206, 209, 1],
	  'darkviolet': [148, 0, 211, 1],
	  'deeppink': [255, 20, 147, 1],
	  'deepskyblue': [0, 191, 255, 1],
	  'dimgray': [105, 105, 105, 1],
	  'dimgrey': [105, 105, 105, 1],
	  'dodgerblue': [30, 144, 255, 1],
	  'firebrick': [178, 34, 34, 1],
	  'floralwhite': [255, 250, 240, 1],
	  'forestgreen': [34, 139, 34, 1],
	  'fuchsia': [255, 0, 255, 1],
	  'gainsboro': [220, 220, 220, 1],
	  'ghostwhite': [248, 248, 255, 1],
	  'gold': [255, 215, 0, 1],
	  'goldenrod': [218, 165, 32, 1],
	  'gray': [128, 128, 128, 1],
	  'green': [0, 128, 0, 1],
	  'greenyellow': [173, 255, 47, 1],
	  'grey': [128, 128, 128, 1],
	  'honeydew': [240, 255, 240, 1],
	  'hotpink': [255, 105, 180, 1],
	  'indianred': [205, 92, 92, 1],
	  'indigo': [75, 0, 130, 1],
	  'ivory': [255, 255, 240, 1],
	  'khaki': [240, 230, 140, 1],
	  'lavender': [230, 230, 250, 1],
	  'lavenderblush': [255, 240, 245, 1],
	  'lawngreen': [124, 252, 0, 1],
	  'lemonchiffon': [255, 250, 205, 1],
	  'lightblue': [173, 216, 230, 1],
	  'lightcoral': [240, 128, 128, 1],
	  'lightcyan': [224, 255, 255, 1],
	  'lightgoldenrodyellow': [250, 250, 210, 1],
	  'lightgray': [211, 211, 211, 1],
	  'lightgreen': [144, 238, 144, 1],
	  'lightgrey': [211, 211, 211, 1],
	  'lightpink': [255, 182, 193, 1],
	  'lightsalmon': [255, 160, 122, 1],
	  'lightseagreen': [32, 178, 170, 1],
	  'lightskyblue': [135, 206, 250, 1],
	  'lightslategray': [119, 136, 153, 1],
	  'lightslategrey': [119, 136, 153, 1],
	  'lightsteelblue': [176, 196, 222, 1],
	  'lightyellow': [255, 255, 224, 1],
	  'lime': [0, 255, 0, 1],
	  'limegreen': [50, 205, 50, 1],
	  'linen': [250, 240, 230, 1],
	  'magenta': [255, 0, 255, 1],
	  'maroon': [128, 0, 0, 1],
	  'mediumaquamarine': [102, 205, 170, 1],
	  'mediumblue': [0, 0, 205, 1],
	  'mediumorchid': [186, 85, 211, 1],
	  'mediumpurple': [147, 112, 219, 1],
	  'mediumseagreen': [60, 179, 113, 1],
	  'mediumslateblue': [123, 104, 238, 1],
	  'mediumspringgreen': [0, 250, 154, 1],
	  'mediumturquoise': [72, 209, 204, 1],
	  'mediumvioletred': [199, 21, 133, 1],
	  'midnightblue': [25, 25, 112, 1],
	  'mintcream': [245, 255, 250, 1],
	  'mistyrose': [255, 228, 225, 1],
	  'moccasin': [255, 228, 181, 1],
	  'navajowhite': [255, 222, 173, 1],
	  'navy': [0, 0, 128, 1],
	  'oldlace': [253, 245, 230, 1],
	  'olive': [128, 128, 0, 1],
	  'olivedrab': [107, 142, 35, 1],
	  'orange': [255, 165, 0, 1],
	  'orangered': [255, 69, 0, 1],
	  'orchid': [218, 112, 214, 1],
	  'palegoldenrod': [238, 232, 170, 1],
	  'palegreen': [152, 251, 152, 1],
	  'paleturquoise': [175, 238, 238, 1],
	  'palevioletred': [219, 112, 147, 1],
	  'papayawhip': [255, 239, 213, 1],
	  'peachpuff': [255, 218, 185, 1],
	  'peru': [205, 133, 63, 1],
	  'pink': [255, 192, 203, 1],
	  'plum': [221, 160, 221, 1],
	  'powderblue': [176, 224, 230, 1],
	  'purple': [128, 0, 128, 1],
	  'red': [255, 0, 0, 1],
	  'rosybrown': [188, 143, 143, 1],
	  'royalblue': [65, 105, 225, 1],
	  'saddlebrown': [139, 69, 19, 1],
	  'salmon': [250, 128, 114, 1],
	  'sandybrown': [244, 164, 96, 1],
	  'seagreen': [46, 139, 87, 1],
	  'seashell': [255, 245, 238, 1],
	  'sienna': [160, 82, 45, 1],
	  'silver': [192, 192, 192, 1],
	  'skyblue': [135, 206, 235, 1],
	  'slateblue': [106, 90, 205, 1],
	  'slategray': [112, 128, 144, 1],
	  'slategrey': [112, 128, 144, 1],
	  'snow': [255, 250, 250, 1],
	  'springgreen': [0, 255, 127, 1],
	  'steelblue': [70, 130, 180, 1],
	  'tan': [210, 180, 140, 1],
	  'teal': [0, 128, 128, 1],
	  'thistle': [216, 191, 216, 1],
	  'tomato': [255, 99, 71, 1],
	  'turquoise': [64, 224, 208, 1],
	  'violet': [238, 130, 238, 1],
	  'wheat': [245, 222, 179, 1],
	  'white': [255, 255, 255, 1],
	  'whitesmoke': [245, 245, 245, 1],
	  'yellow': [255, 255, 0, 1],
	  'yellowgreen': [154, 205, 50, 1]
	};
	
	function clampCssByte(i) {
	  // Clamp to integer 0 .. 255.
	  i = Math.round(i); // Seems to be what Chrome does (vs truncation).
	
	  return i < 0 ? 0 : i > 255 ? 255 : i;
	}
	
	function clampCssAngle(i) {
	  // Clamp to integer 0 .. 360.
	  i = Math.round(i); // Seems to be what Chrome does (vs truncation).
	
	  return i < 0 ? 0 : i > 360 ? 360 : i;
	}
	
	function clampCssFloat(f) {
	  // Clamp to float 0.0 .. 1.0.
	  return f < 0 ? 0 : f > 1 ? 1 : f;
	}
	
	function parseCssInt(str) {
	  // int or percentage.
	  if (str.length && str.charAt(str.length - 1) === '%') {
	    return clampCssByte(parseFloat(str) / 100 * 255);
	  }
	
	  return clampCssByte(parseInt(str, 10));
	}
	
	function parseCssFloat(str) {
	  // float or percentage.
	  if (str.length && str.charAt(str.length - 1) === '%') {
	    return clampCssFloat(parseFloat(str) / 100);
	  }
	
	  return clampCssFloat(parseFloat(str));
	}
	
	function cssHueToRgb(m1, m2, h) {
	  if (h < 0) {
	    h += 1;
	  } else if (h > 1) {
	    h -= 1;
	  }
	
	  if (h * 6 < 1) {
	    return m1 + (m2 - m1) * h * 6;
	  }
	
	  if (h * 2 < 1) {
	    return m2;
	  }
	
	  if (h * 3 < 2) {
	    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
	  }
	
	  return m1;
	}
	
	function lerpNumber(a, b, p) {
	  return a + (b - a) * p;
	}
	
	function setRgba(out, r, g, b, a) {
	  out[0] = r;
	  out[1] = g;
	  out[2] = b;
	  out[3] = a;
	  return out;
	}
	
	function copyRgba(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  return out;
	}
	
	var colorCache = new LRU(20);
	var lastRemovedArr = null;
	
	function putToCache(colorStr, rgbaArr) {
	  // Reuse removed array
	  if (lastRemovedArr) {
	    copyRgba(lastRemovedArr, rgbaArr);
	  }
	
	  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
	}
	/**
	 * @param {string} colorStr
	 * @param {Array.<number>} out
	 * @return {Array.<number>}
	 * @memberOf module:zrender/util/color
	 */
	
	
	function parse(colorStr, rgbaArr) {
	  if (!colorStr) {
	    return;
	  }
	
	  rgbaArr = rgbaArr || [];
	  var cached = colorCache.get(colorStr);
	
	  if (cached) {
	    return copyRgba(rgbaArr, cached);
	  } // colorStr may be not string
	
	
	  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.
	
	  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.
	
	  if (str in kCSSColorTable) {
	    copyRgba(rgbaArr, kCSSColorTable[str]);
	    putToCache(colorStr, rgbaArr);
	    return rgbaArr;
	  } // #abc and #abc123 syntax.
	
	
	  if (str.charAt(0) === '#') {
	    if (str.length === 4) {
	      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
	
	      if (!(iv >= 0 && iv <= 0xfff)) {
	        setRgba(rgbaArr, 0, 0, 0, 1);
	        return; // Covers NaN.
	      }
	
	      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);
	      putToCache(colorStr, rgbaArr);
	      return rgbaArr;
	    } else if (str.length === 7) {
	      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.
	
	      if (!(iv >= 0 && iv <= 0xffffff)) {
	        setRgba(rgbaArr, 0, 0, 0, 1);
	        return; // Covers NaN.
	      }
	
	      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);
	      putToCache(colorStr, rgbaArr);
	      return rgbaArr;
	    }
	
	    return;
	  }
	
	  var op = str.indexOf('('),
	      ep = str.indexOf(')');
	
	  if (op !== -1 && ep + 1 === str.length) {
	    var fname = str.substr(0, op);
	    var params = str.substr(op + 1, ep - (op + 1)).split(',');
	    var alpha = 1; // To allow case fallthrough.
	
	    switch (fname) {
	      case 'rgba':
	        if (params.length !== 4) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        alpha = parseCssFloat(params.pop());
	      // jshint ignore:line
	      // Fall through.
	
	      case 'rgb':
	        if (params.length !== 3) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	
	      case 'hsla':
	        if (params.length !== 4) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        params[3] = parseCssFloat(params[3]);
	        hsla2rgba(params, rgbaArr);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	
	      case 'hsl':
	        if (params.length !== 3) {
	          setRgba(rgbaArr, 0, 0, 0, 1);
	          return;
	        }
	
	        hsla2rgba(params, rgbaArr);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	
	      default:
	        return;
	    }
	  }
	
	  setRgba(rgbaArr, 0, 0, 0, 1);
	  return;
	}
	/**
	 * @param {Array.<number>} hsla
	 * @param {Array.<number>} rgba
	 * @return {Array.<number>} rgba
	 */
	
	
	function hsla2rgba(hsla, rgba) {
	  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1
	  // NOTE(deanm): According to the CSS spec s/l should only be
	  // percentages, but we don't bother and let float or percentage.
	
	  var s = parseCssFloat(hsla[1]);
	  var l = parseCssFloat(hsla[2]);
	  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	  var m1 = l * 2 - m2;
	  rgba = rgba || [];
	  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
	
	  if (hsla.length === 4) {
	    rgba[3] = hsla[3];
	  }
	
	  return rgba;
	}
	/**
	 * @param {Array.<number>} rgba
	 * @return {Array.<number>} hsla
	 */
	
	
	function rgba2hsla(rgba) {
	  if (!rgba) {
	    return;
	  } // RGB from 0 to 255
	
	
	  var R = rgba[0] / 255;
	  var G = rgba[1] / 255;
	  var B = rgba[2] / 255;
	  var vMin = Math.min(R, G, B); // Min. value of RGB
	
	  var vMax = Math.max(R, G, B); // Max. value of RGB
	
	  var delta = vMax - vMin; // Delta RGB value
	
	  var L = (vMax + vMin) / 2;
	  var H;
	  var S; // HSL results from 0 to 1
	
	  if (delta === 0) {
	    H = 0;
	    S = 0;
	  } else {
	    if (L < 0.5) {
	      S = delta / (vMax + vMin);
	    } else {
	      S = delta / (2 - vMax - vMin);
	    }
	
	    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
	    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
	    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
	
	    if (R === vMax) {
	      H = deltaB - deltaG;
	    } else if (G === vMax) {
	      H = 1 / 3 + deltaR - deltaB;
	    } else if (B === vMax) {
	      H = 2 / 3 + deltaG - deltaR;
	    }
	
	    if (H < 0) {
	      H += 1;
	    }
	
	    if (H > 1) {
	      H -= 1;
	    }
	  }
	
	  var hsla = [H * 360, S, L];
	
	  if (rgba[3] != null) {
	    hsla.push(rgba[3]);
	  }
	
	  return hsla;
	}
	/**
	 * @param {string} color
	 * @param {number} level
	 * @return {string}
	 * @memberOf module:zrender/util/color
	 */
	
	
	function lift(color, level) {
	  var colorArr = parse(color);
	
	  if (colorArr) {
	    for (var i = 0; i < 3; i++) {
	      if (level < 0) {
	        colorArr[i] = colorArr[i] * (1 - level) | 0;
	      } else {
	        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
	      }
	    }
	
	    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
	  }
	}
	/**
	 * @param {string} color
	 * @return {string}
	 * @memberOf module:zrender/util/color
	 */
	
	
	function toHex(color) {
	  var colorArr = parse(color);
	
	  if (colorArr) {
	    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
	  }
	}
	/**
	 * Map value to color. Faster than lerp methods because color is represented by rgba array.
	 * @param {number} normalizedValue A float between 0 and 1.
	 * @param {Array.<Array.<number>>} colors List of rgba color array
	 * @param {Array.<number>} [out] Mapped gba color array
	 * @return {Array.<number>} will be null/undefined if input illegal.
	 */
	
	
	function fastLerp(normalizedValue, colors, out) {
	  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
	    return;
	  }
	
	  out = out || [];
	  var value = normalizedValue * (colors.length - 1);
	  var leftIndex = Math.floor(value);
	  var rightIndex = Math.ceil(value);
	  var leftColor = colors[leftIndex];
	  var rightColor = colors[rightIndex];
	  var dv = value - leftIndex;
	  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
	  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
	  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
	  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
	  return out;
	}
	/**
	 * @deprecated
	 */
	
	
	var fastMapToColor = fastLerp;
	/**
	 * @param {number} normalizedValue A float between 0 and 1.
	 * @param {Array.<string>} colors Color list.
	 * @param {boolean=} fullOutput Default false.
	 * @return {(string|Object)} Result color. If fullOutput,
	 *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
	 * @memberOf module:zrender/util/color
	 */
	
	function lerp(normalizedValue, colors, fullOutput) {
	  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
	    return;
	  }
	
	  var value = normalizedValue * (colors.length - 1);
	  var leftIndex = Math.floor(value);
	  var rightIndex = Math.ceil(value);
	  var leftColor = parse(colors[leftIndex]);
	  var rightColor = parse(colors[rightIndex]);
	  var dv = value - leftIndex;
	  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');
	  return fullOutput ? {
	    color: color,
	    leftIndex: leftIndex,
	    rightIndex: rightIndex,
	    value: value
	  } : color;
	}
	/**
	 * @deprecated
	 */
	
	
	var mapToColor = lerp;
	/**
	 * @param {string} color
	 * @param {number=} h 0 ~ 360, ignore when null.
	 * @param {number=} s 0 ~ 1, ignore when null.
	 * @param {number=} l 0 ~ 1, ignore when null.
	 * @return {string} Color string in rgba format.
	 * @memberOf module:zrender/util/color
	 */
	
	function modifyHSL(color, h, s, l) {
	  color = parse(color);
	
	  if (color) {
	    color = rgba2hsla(color);
	    h != null && (color[0] = clampCssAngle(h));
	    s != null && (color[1] = parseCssFloat(s));
	    l != null && (color[2] = parseCssFloat(l));
	    return stringify(hsla2rgba(color), 'rgba');
	  }
	}
	/**
	 * @param {string} color
	 * @param {number=} alpha 0 ~ 1
	 * @return {string} Color string in rgba format.
	 * @memberOf module:zrender/util/color
	 */
	
	
	function modifyAlpha(color, alpha) {
	  color = parse(color);
	
	  if (color && alpha != null) {
	    color[3] = clampCssFloat(alpha);
	    return stringify(color, 'rgba');
	  }
	}
	/**
	 * @param {Array.<number>} arrColor like [12,33,44,0.4]
	 * @param {string} type 'rgba', 'hsva', ...
	 * @return {string} Result color. (If input illegal, return undefined).
	 */
	
	
	function stringify(arrColor, type) {
	  if (!arrColor || !arrColor.length) {
	    return;
	  }
	
	  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
	
	  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
	    colorStr += ',' + arrColor[3];
	  }
	
	  return type + '(' + colorStr + ')';
	}
	
	exports.parse = parse;
	exports.lift = lift;
	exports.toHex = toHex;
	exports.fastLerp = fastLerp;
	exports.fastMapToColor = fastMapToColor;
	exports.lerp = lerp;
	exports.mapToColor = mapToColor;
	exports.modifyHSL = modifyHSL;
	exports.modifyAlpha = modifyAlpha;
	exports.stringify = stringify;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	// Simple LRU cache use doubly linked list
	// @module zrender/core/LRU
	
	/**
	 * Simple double linked list. Compared with array, it has O(1) remove operation.
	 * @constructor
	 */
	var LinkedList = function () {
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	  this.head = null;
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	
	  this.tail = null;
	  this._len = 0;
	};
	
	var linkedListProto = LinkedList.prototype;
	/**
	 * Insert a new value at the tail
	 * @param  {} val
	 * @return {module:zrender/core/LRU~Entry}
	 */
	
	linkedListProto.insert = function (val) {
	  var entry = new Entry(val);
	  this.insertEntry(entry);
	  return entry;
	};
	/**
	 * Insert an entry at the tail
	 * @param  {module:zrender/core/LRU~Entry} entry
	 */
	
	
	linkedListProto.insertEntry = function (entry) {
	  if (!this.head) {
	    this.head = this.tail = entry;
	  } else {
	    this.tail.next = entry;
	    entry.prev = this.tail;
	    entry.next = null;
	    this.tail = entry;
	  }
	
	  this._len++;
	};
	/**
	 * Remove entry.
	 * @param  {module:zrender/core/LRU~Entry} entry
	 */
	
	
	linkedListProto.remove = function (entry) {
	  var prev = entry.prev;
	  var next = entry.next;
	
	  if (prev) {
	    prev.next = next;
	  } else {
	    // Is head
	    this.head = next;
	  }
	
	  if (next) {
	    next.prev = prev;
	  } else {
	    // Is tail
	    this.tail = prev;
	  }
	
	  entry.next = entry.prev = null;
	  this._len--;
	};
	/**
	 * @return {number}
	 */
	
	
	linkedListProto.len = function () {
	  return this._len;
	};
	/**
	 * Clear list
	 */
	
	
	linkedListProto.clear = function () {
	  this.head = this.tail = null;
	  this._len = 0;
	};
	/**
	 * @constructor
	 * @param {} val
	 */
	
	
	var Entry = function (val) {
	  /**
	   * @type {}
	   */
	  this.value = val;
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	
	  this.next;
	  /**
	   * @type {module:zrender/core/LRU~Entry}
	   */
	
	  this.prev;
	};
	/**
	 * LRU Cache
	 * @constructor
	 * @alias module:zrender/core/LRU
	 */
	
	
	var LRU = function (maxSize) {
	  this._list = new LinkedList();
	  this._map = {};
	  this._maxSize = maxSize || 10;
	  this._lastRemovedEntry = null;
	};
	
	var LRUProto = LRU.prototype;
	/**
	 * @param  {string} key
	 * @param  {} value
	 * @return {} Removed value
	 */
	
	LRUProto.put = function (key, value) {
	  var list = this._list;
	  var map = this._map;
	  var removed = null;
	
	  if (map[key] == null) {
	    var len = list.len(); // Reuse last removed entry
	
	    var entry = this._lastRemovedEntry;
	
	    if (len >= this._maxSize && len > 0) {
	      // Remove the least recently used
	      var leastUsedEntry = list.head;
	      list.remove(leastUsedEntry);
	      delete map[leastUsedEntry.key];
	      removed = leastUsedEntry.value;
	      this._lastRemovedEntry = leastUsedEntry;
	    }
	
	    if (entry) {
	      entry.value = value;
	    } else {
	      entry = new Entry(value);
	    }
	
	    entry.key = key;
	    list.insertEntry(entry);
	    map[key] = entry;
	  }
	
	  return removed;
	};
	/**
	 * @param  {string} key
	 * @return {}
	 */
	
	
	LRUProto.get = function (key) {
	  var entry = this._map[key];
	  var list = this._list;
	
	  if (entry != null) {
	    // Put the latest used entry in the tail
	    if (entry !== list.tail) {
	      list.remove(entry);
	      list.insertEntry(entry);
	    }
	
	    return entry.value;
	  }
	};
	/**
	 * Clear the cache
	 */
	
	
	LRUProto.clear = function () {
	  this._list.clear();
	
	  this._map = {};
	};
	
	var _default = LRU;
	module.exports = _default;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	var _config = __webpack_require__(22);
	
	var debugMode = _config.debugMode;
	
	var log = function () {};
	
	if (debugMode === 1) {
	  log = function () {
	    for (var k in arguments) {
	      throw new Error(arguments[k]);
	    }
	  };
	} else if (debugMode > 1) {
	  log = function () {
	    for (var k in arguments) {
	      console.log(arguments[k]);
	    }
	  };
	}
	
	var _default = log;
	module.exports = _default;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

	var dpr = 1; // If in browser environment
	
	if (typeof window !== 'undefined') {
	  dpr = Math.max(window.devicePixelRatio || 1, 1);
	}
	/**
	 * config默认配置项
	 * @exports zrender/config
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	
	/**
	 * debug日志选项：catchBrushException为true下有效
	 * 0 : 不生成debug数据，发布用
	 * 1 : 异常抛出，调试用
	 * 2 : 控制台输出，调试用
	 */
	
	
	var debugMode = 0; // retina 屏幕优化
	
	var devicePixelRatio = dpr;
	exports.debugMode = debugMode;
	exports.devicePixelRatio = devicePixelRatio;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	var textHelper = __webpack_require__(24);
	
	var BoundingRect = __webpack_require__(26);
	
	/**
	 * Mixin for drawing text in a element bounding rect
	 * @module zrender/mixin/RectText
	 */
	var tmpRect = new BoundingRect();
	
	var RectText = function () {};
	
	RectText.prototype = {
	  constructor: RectText,
	
	  /**
	   * Draw text in a rect with specified position.
	   * @param  {CanvasRenderingContext2D} ctx
	   * @param  {Object} rect Displayable rect
	   */
	  drawRectText: function (ctx, rect) {
	    var style = this.style;
	    rect = style.textRect || rect; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true);
	    var text = style.text; // Convert to string
	
	    text != null && (text += '');
	
	    if (!textHelper.needDrawText(text, style)) {
	      return;
	    } // FIXME
	
	
	    ctx.save(); // Transform rect to view space
	
	    var transform = this.transform;
	
	    if (!style.transformText) {
	      if (transform) {
	        tmpRect.copy(rect);
	        tmpRect.applyTransform(transform);
	        rect = tmpRect;
	      }
	    } else {
	      this.setTransform(ctx);
	    } // transformText and textRotation can not be used at the same time.
	
	
	    textHelper.renderText(this, ctx, text, style, rect);
	    ctx.restore();
	  }
	};
	var _default = RectText;
	module.exports = _default;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	var _util = __webpack_require__(4);
	
	var retrieve2 = _util.retrieve2;
	var retrieve3 = _util.retrieve3;
	var each = _util.each;
	var normalizeCssArray = _util.normalizeCssArray;
	var isString = _util.isString;
	var isObject = _util.isObject;
	
	var textContain = __webpack_require__(25);
	
	var roundRectHelper = __webpack_require__(28);
	
	var imageHelper = __webpack_require__(27);
	
	// TODO: Have not support 'start', 'end' yet.
	var VALID_TEXT_ALIGN = {
	  left: 1,
	  right: 1,
	  center: 1
	};
	var VALID_TEXT_VERTICAL_ALIGN = {
	  top: 1,
	  bottom: 1,
	  middle: 1
	};
	/**
	 * @param {module:zrender/graphic/Style} style
	 * @return {module:zrender/graphic/Style} The input style.
	 */
	
	function normalizeTextStyle(style) {
	  normalizeStyle(style);
	  each(style.rich, normalizeStyle);
	  return style;
	}
	
	function normalizeStyle(style) {
	  if (style) {
	    style.font = textContain.makeFont(style);
	    var textAlign = style.textAlign;
	    textAlign === 'middle' && (textAlign = 'center');
	    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.
	
	    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
	    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');
	    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';
	    var textPadding = style.textPadding;
	
	    if (textPadding) {
	      style.textPadding = normalizeCssArray(style.textPadding);
	    }
	  }
	}
	/**
	 * @param {CanvasRenderingContext2D} ctx
	 * @param {string} text
	 * @param {module:zrender/graphic/Style} style
	 * @param {Object|boolean} [rect] {x, y, width, height}
	 *                  If set false, rect text is not used.
	 */
	
	
	function renderText(hostEl, ctx, text, style, rect) {
	  style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);
	}
	
	function renderPlainText(hostEl, ctx, text, style, rect) {
	  var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);
	  var textPadding = style.textPadding;
	  var contentBlock = hostEl.__textCotentBlock;
	
	  if (!contentBlock || hostEl.__dirty) {
	    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, font, textPadding, style.truncate);
	  }
	
	  var outerHeight = contentBlock.outerHeight;
	  var textLines = contentBlock.lines;
	  var lineHeight = contentBlock.lineHeight;
	  var boxPos = getBoxPosition(outerHeight, style, rect);
	  var baseX = boxPos.baseX;
	  var baseY = boxPos.baseY;
	  var textAlign = boxPos.textAlign;
	  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.
	
	  applyTextRotation(ctx, style, rect, baseX, baseY);
	  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
	  var textX = baseX;
	  var textY = boxY;
	  var needDrawBg = needDrawBackground(style);
	
	  if (needDrawBg || textPadding) {
	    // Consider performance, do not call getTextWidth util necessary.
	    var textWidth = textContain.getWidth(text, font);
	    var outerWidth = textWidth;
	    textPadding && (outerWidth += textPadding[1] + textPadding[3]);
	    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
	    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
	
	    if (textPadding) {
	      textX = getTextXForPadding(baseX, textAlign, textPadding);
	      textY += textPadding[0];
	    }
	  }
	
	  setCtx(ctx, 'textAlign', textAlign || 'left'); // Force baseline to be "middle". Otherwise, if using "top", the
	  // text will offset downward a little bit in font "Microsoft YaHei".
	
	  setCtx(ctx, 'textBaseline', 'middle'); // Always set shadowBlur and shadowOffset to avoid leak from displayable.
	
	  setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);
	  setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');
	  setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);
	  setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0); // `textBaseline` is set as 'middle'.
	
	  textY += lineHeight / 2;
	  var textStrokeWidth = style.textStrokeWidth;
	  var textStroke = getStroke(style.textStroke, textStrokeWidth);
	  var textFill = getFill(style.textFill);
	
	  if (textStroke) {
	    setCtx(ctx, 'lineWidth', textStrokeWidth);
	    setCtx(ctx, 'strokeStyle', textStroke);
	  }
	
	  if (textFill) {
	    setCtx(ctx, 'fillStyle', textFill);
	  }
	
	  for (var i = 0; i < textLines.length; i++) {
	    // Fill after stroke so the outline will not cover the main part.
	    textStroke && ctx.strokeText(textLines[i], textX, textY);
	    textFill && ctx.fillText(textLines[i], textX, textY);
	    textY += lineHeight;
	  }
	}
	
	function renderRichText(hostEl, ctx, text, style, rect) {
	  var contentBlock = hostEl.__textCotentBlock;
	
	  if (!contentBlock || hostEl.__dirty) {
	    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);
	  }
	
	  drawRichText(hostEl, ctx, contentBlock, style, rect);
	}
	
	function drawRichText(hostEl, ctx, contentBlock, style, rect) {
	  var contentWidth = contentBlock.width;
	  var outerWidth = contentBlock.outerWidth;
	  var outerHeight = contentBlock.outerHeight;
	  var textPadding = style.textPadding;
	  var boxPos = getBoxPosition(outerHeight, style, rect);
	  var baseX = boxPos.baseX;
	  var baseY = boxPos.baseY;
	  var textAlign = boxPos.textAlign;
	  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.
	
	  applyTextRotation(ctx, style, rect, baseX, baseY);
	  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
	  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
	  var xLeft = boxX;
	  var lineTop = boxY;
	
	  if (textPadding) {
	    xLeft += textPadding[3];
	    lineTop += textPadding[0];
	  }
	
	  var xRight = xLeft + contentWidth;
	  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
	
	  for (var i = 0; i < contentBlock.lines.length; i++) {
	    var line = contentBlock.lines[i];
	    var tokens = line.tokens;
	    var tokenCount = tokens.length;
	    var lineHeight = line.lineHeight;
	    var usedWidth = line.width;
	    var leftIndex = 0;
	    var lineXLeft = xLeft;
	    var lineXRight = xRight;
	    var rightIndex = tokenCount - 1;
	    var token;
	
	    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {
	      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');
	      usedWidth -= token.width;
	      lineXLeft += token.width;
	      leftIndex++;
	    }
	
	    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {
	      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');
	      usedWidth -= token.width;
	      lineXRight -= token.width;
	      rightIndex--;
	    } // The other tokens are placed as textAlign 'center' if there is enough space.
	
	
	    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;
	
	    while (leftIndex <= rightIndex) {
	      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.
	
	      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');
	      lineXLeft += token.width;
	      leftIndex++;
	    }
	
	    lineTop += lineHeight;
	  }
	}
	
	function applyTextRotation(ctx, style, rect, x, y) {
	  // textRotation only apply in RectText.
	  if (rect && style.textRotation) {
	    var origin = style.textOrigin;
	
	    if (origin === 'center') {
	      x = rect.width / 2 + rect.x;
	      y = rect.height / 2 + rect.y;
	    } else if (origin) {
	      x = origin[0] + rect.x;
	      y = origin[1] + rect.y;
	    }
	
	    ctx.translate(x, y); // Positive: anticlockwise
	
	    ctx.rotate(-style.textRotation);
	    ctx.translate(-x, -y);
	  }
	}
	
	function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
	  var tokenStyle = style.rich[token.styleName] || {}; // 'ctx.textBaseline' is always set as 'middle', for sake of
	  // the bias of "Microsoft YaHei".
	
	  var textVerticalAlign = token.textVerticalAlign;
	  var y = lineTop + lineHeight / 2;
	
	  if (textVerticalAlign === 'top') {
	    y = lineTop + token.height / 2;
	  } else if (textVerticalAlign === 'bottom') {
	    y = lineTop + lineHeight - token.height / 2;
	  }
	
	  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
	  var textPadding = token.textPadding;
	
	  if (textPadding) {
	    x = getTextXForPadding(x, textAlign, textPadding);
	    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
	  }
	
	  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
	  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');
	  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
	  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
	  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be "middle". Otherwise, if using "top", the
	  // text will offset downward a little bit in font "Microsoft YaHei".
	
	  setCtx(ctx, 'textBaseline', 'middle');
	  setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);
	  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
	  var textFill = getFill(tokenStyle.textFill || style.textFill);
	  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.
	
	  if (textStroke) {
	    setCtx(ctx, 'lineWidth', textStrokeWidth);
	    setCtx(ctx, 'strokeStyle', textStroke);
	    ctx.strokeText(token.text, x, y);
	  }
	
	  if (textFill) {
	    setCtx(ctx, 'fillStyle', textFill);
	    ctx.fillText(token.text, x, y);
	  }
	}
	
	function needDrawBackground(style) {
	  return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;
	} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}
	// shape: {x, y, width, height}
	
	
	function drawBackground(hostEl, ctx, style, x, y, width, height) {
	  var textBackgroundColor = style.textBackgroundColor;
	  var textBorderWidth = style.textBorderWidth;
	  var textBorderColor = style.textBorderColor;
	  var isPlainBg = isString(textBackgroundColor);
	  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);
	  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');
	  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);
	  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);
	
	  if (isPlainBg || textBorderWidth && textBorderColor) {
	    ctx.beginPath();
	    var textBorderRadius = style.textBorderRadius;
	
	    if (!textBorderRadius) {
	      ctx.rect(x, y, width, height);
	    } else {
	      roundRectHelper.buildPath(ctx, {
	        x: x,
	        y: y,
	        width: width,
	        height: height,
	        r: textBorderRadius
	      });
	    }
	
	    ctx.closePath();
	  }
	
	  if (isPlainBg) {
	    setCtx(ctx, 'fillStyle', textBackgroundColor);
	    ctx.fill();
	  } else if (isObject(textBackgroundColor)) {
	    var image = textBackgroundColor.image;
	    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);
	
	    if (image && imageHelper.isImageReady(image)) {
	      ctx.drawImage(image, x, y, width, height);
	    }
	  }
	
	  if (textBorderWidth && textBorderColor) {
	    setCtx(ctx, 'lineWidth', textBorderWidth);
	    setCtx(ctx, 'strokeStyle', textBorderColor);
	    ctx.stroke();
	  }
	}
	
	function onBgImageLoaded(image, textBackgroundColor) {
	  // Replace image, so that `contain/text.js#parseRichText`
	  // will get correct result in next tick.
	  textBackgroundColor.image = image;
	}
	
	function getBoxPosition(blockHeiht, style, rect) {
	  var baseX = style.x || 0;
	  var baseY = style.y || 0;
	  var textAlign = style.textAlign;
	  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord
	
	  if (rect) {
	    var textPosition = style.textPosition;
	
	    if (textPosition instanceof Array) {
	      // Percent
	      baseX = rect.x + parsePercent(textPosition[0], rect.width);
	      baseY = rect.y + parsePercent(textPosition[1], rect.height);
	    } else {
	      var res = textContain.adjustTextPositionOnRect(textPosition, rect, style.textDistance);
	      baseX = res.x;
	      baseY = res.y; // Default align and baseline when has textPosition
	
	      textAlign = textAlign || res.textAlign;
	      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
	    } // textOffset is only support in RectText, otherwise
	    // we have to adjust boundingRect for textOffset.
	
	
	    var textOffset = style.textOffset;
	
	    if (textOffset) {
	      baseX += textOffset[0];
	      baseY += textOffset[1];
	    }
	  }
	
	  return {
	    baseX: baseX,
	    baseY: baseY,
	    textAlign: textAlign,
	    textVerticalAlign: textVerticalAlign
	  };
	}
	
	function setCtx(ctx, prop, value) {
	  // FIXME ??? performance try
	  // if (ctx.__currentValues[prop] !== value) {
	  // ctx[prop] = ctx.__currentValues[prop] = value;
	  ctx[prop] = value; // }
	
	  return ctx[prop];
	}
	/**
	 * @param {string} [stroke] If specified, do not check style.textStroke.
	 * @param {string} [lineWidth] If specified, do not check style.textStroke.
	 * @param {number} style
	 */
	
	
	function getStroke(stroke, lineWidth) {
	  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?
	  : stroke.image || stroke.colorStops ? '#000' : stroke;
	}
	
	function getFill(fill) {
	  return fill == null || fill === 'none' ? null // TODO pattern and gradient?
	  : fill.image || fill.colorStops ? '#000' : fill;
	}
	
	function parsePercent(value, maxValue) {
	  if (typeof value === 'string') {
	    if (value.lastIndexOf('%') >= 0) {
	      return parseFloat(value) / 100 * maxValue;
	    }
	
	    return parseFloat(value);
	  }
	
	  return value;
	}
	
	function getTextXForPadding(x, textAlign, textPadding) {
	  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
	}
	/**
	 * @param {string} text
	 * @param {module:zrender/Style} style
	 * @return {boolean}
	 */
	
	
	function needDrawText(text, style) {
	  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
	}
	
	exports.normalizeTextStyle = normalizeTextStyle;
	exports.renderText = renderText;
	exports.getStroke = getStroke;
	exports.getFill = getFill;
	exports.needDrawText = needDrawText;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var BoundingRect = __webpack_require__(26);
	
	var imageHelper = __webpack_require__(27);
	
	var _util = __webpack_require__(4);
	
	var getContext = _util.getContext;
	var extend = _util.extend;
	var retrieve2 = _util.retrieve2;
	var retrieve3 = _util.retrieve3;
	var textWidthCache = {};
	var textWidthCacheCounter = 0;
	var TEXT_CACHE_MAX = 5000;
	var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
	var DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.
	
	var methods = {};
	
	function $override(name, fn) {
	  methods[name] = fn;
	}
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @return {number} width
	 */
	
	
	function getWidth(text, font) {
	  font = font || DEFAULT_FONT;
	  var key = text + ':' + font;
	
	  if (textWidthCache[key]) {
	    return textWidthCache[key];
	  }
	
	  var textLines = (text + '').split('\n');
	  var width = 0;
	
	  for (var i = 0, l = textLines.length; i < l; i++) {
	    // textContain.measureText may be overrided in SVG or VML
	    width = Math.max(measureText(textLines[i], font).width, width);
	  }
	
	  if (textWidthCacheCounter > TEXT_CACHE_MAX) {
	    textWidthCacheCounter = 0;
	    textWidthCache = {};
	  }
	
	  textWidthCacheCounter++;
	  textWidthCache[key] = width;
	  return width;
	}
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @param {string} [textAlign='left']
	 * @param {string} [textVerticalAlign='top']
	 * @param {Array.<number>} [textPadding]
	 * @param {Object} [rich]
	 * @param {Object} [truncate]
	 * @return {Object} {x, y, width, height, lineHeight}
	 */
	
	
	function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
	  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);
	}
	
	function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {
	  var contentBlock = parsePlainText(text, font, textPadding, truncate);
	  var outerWidth = getWidth(text, font);
	
	  if (textPadding) {
	    outerWidth += textPadding[1] + textPadding[3];
	  }
	
	  var outerHeight = contentBlock.outerHeight;
	  var x = adjustTextX(0, outerWidth, textAlign);
	  var y = adjustTextY(0, outerHeight, textVerticalAlign);
	  var rect = new BoundingRect(x, y, outerWidth, outerHeight);
	  rect.lineHeight = contentBlock.lineHeight;
	  return rect;
	}
	
	function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
	  var contentBlock = parseRichText(text, {
	    rich: rich,
	    truncate: truncate,
	    font: font,
	    textAlign: textAlign,
	    textPadding: textPadding
	  });
	  var outerWidth = contentBlock.outerWidth;
	  var outerHeight = contentBlock.outerHeight;
	  var x = adjustTextX(0, outerWidth, textAlign);
	  var y = adjustTextY(0, outerHeight, textVerticalAlign);
	  return new BoundingRect(x, y, outerWidth, outerHeight);
	}
	/**
	 * @public
	 * @param {number} x
	 * @param {number} width
	 * @param {string} [textAlign='left']
	 * @return {number} Adjusted x.
	 */
	
	
	function adjustTextX(x, width, textAlign) {
	  // FIXME Right to left language
	  if (textAlign === 'right') {
	    x -= width;
	  } else if (textAlign === 'center') {
	    x -= width / 2;
	  }
	
	  return x;
	}
	/**
	 * @public
	 * @param {number} y
	 * @param {number} height
	 * @param {string} [textVerticalAlign='top']
	 * @return {number} Adjusted y.
	 */
	
	
	function adjustTextY(y, height, textVerticalAlign) {
	  if (textVerticalAlign === 'middle') {
	    y -= height / 2;
	  } else if (textVerticalAlign === 'bottom') {
	    y -= height;
	  }
	
	  return y;
	}
	/**
	 * @public
	 * @param {stirng} textPosition
	 * @param {Object} rect {x, y, width, height}
	 * @param {number} distance
	 * @return {Object} {x, y, textAlign, textVerticalAlign}
	 */
	
	
	function adjustTextPositionOnRect(textPosition, rect, distance) {
	  var x = rect.x;
	  var y = rect.y;
	  var height = rect.height;
	  var width = rect.width;
	  var halfHeight = height / 2;
	  var textAlign = 'left';
	  var textVerticalAlign = 'top';
	
	  switch (textPosition) {
	    case 'left':
	      x -= distance;
	      y += halfHeight;
	      textAlign = 'right';
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'right':
	      x += distance + width;
	      y += halfHeight;
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'top':
	      x += width / 2;
	      y -= distance;
	      textAlign = 'center';
	      textVerticalAlign = 'bottom';
	      break;
	
	    case 'bottom':
	      x += width / 2;
	      y += height + distance;
	      textAlign = 'center';
	      break;
	
	    case 'inside':
	      x += width / 2;
	      y += halfHeight;
	      textAlign = 'center';
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'insideLeft':
	      x += distance;
	      y += halfHeight;
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'insideRight':
	      x += width - distance;
	      y += halfHeight;
	      textAlign = 'right';
	      textVerticalAlign = 'middle';
	      break;
	
	    case 'insideTop':
	      x += width / 2;
	      y += distance;
	      textAlign = 'center';
	      break;
	
	    case 'insideBottom':
	      x += width / 2;
	      y += height - distance;
	      textAlign = 'center';
	      textVerticalAlign = 'bottom';
	      break;
	
	    case 'insideTopLeft':
	      x += distance;
	      y += distance;
	      break;
	
	    case 'insideTopRight':
	      x += width - distance;
	      y += distance;
	      textAlign = 'right';
	      break;
	
	    case 'insideBottomLeft':
	      x += distance;
	      y += height - distance;
	      textVerticalAlign = 'bottom';
	      break;
	
	    case 'insideBottomRight':
	      x += width - distance;
	      y += height - distance;
	      textAlign = 'right';
	      textVerticalAlign = 'bottom';
	      break;
	  }
	
	  return {
	    x: x,
	    y: y,
	    textAlign: textAlign,
	    textVerticalAlign: textVerticalAlign
	  };
	}
	/**
	 * Show ellipsis if overflow.
	 *
	 * @public
	 * @param  {string} text
	 * @param  {string} containerWidth
	 * @param  {string} font
	 * @param  {number} [ellipsis='...']
	 * @param  {Object} [options]
	 * @param  {number} [options.maxIterations=3]
	 * @param  {number} [options.minChar=0] If truncate result are less
	 *                  then minChar, ellipsis will not show, which is
	 *                  better for user hint in some cases.
	 * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
	 * @return {string}
	 */
	
	
	function truncateText(text, containerWidth, font, ellipsis, options) {
	  if (!containerWidth) {
	    return '';
	  }
	
	  var textLines = (text + '').split('\n');
	  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME
	  // It is not appropriate that every line has '...' when truncate multiple lines.
	
	  for (var i = 0, len = textLines.length; i < len; i++) {
	    textLines[i] = truncateSingleLine(textLines[i], options);
	  }
	
	  return textLines.join('\n');
	}
	
	function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
	  options = extend({}, options);
	  options.font = font;
	  var ellipsis = retrieve2(ellipsis, '...');
	  options.maxIterations = retrieve2(options.maxIterations, 2);
	  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME
	  // Other languages?
	
	  options.cnCharWidth = getWidth('国', font); // FIXME
	  // Consider proportional font?
	
	  var ascCharWidth = options.ascCharWidth = getWidth('a', font);
	  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
	  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.
	
	  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.
	
	  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
	    contentWidth -= ascCharWidth;
	  }
	
	  var ellipsisWidth = getWidth(ellipsis);
	
	  if (ellipsisWidth > contentWidth) {
	    ellipsis = '';
	    ellipsisWidth = 0;
	  }
	
	  contentWidth = containerWidth - ellipsisWidth;
	  options.ellipsis = ellipsis;
	  options.ellipsisWidth = ellipsisWidth;
	  options.contentWidth = contentWidth;
	  options.containerWidth = containerWidth;
	  return options;
	}
	
	function truncateSingleLine(textLine, options) {
	  var containerWidth = options.containerWidth;
	  var font = options.font;
	  var contentWidth = options.contentWidth;
	
	  if (!containerWidth) {
	    return '';
	  }
	
	  var lineWidth = getWidth(textLine, font);
	
	  if (lineWidth <= containerWidth) {
	    return textLine;
	  }
	
	  for (var j = 0;; j++) {
	    if (lineWidth <= contentWidth || j >= options.maxIterations) {
	      textLine += options.ellipsis;
	      break;
	    }
	
	    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
	    textLine = textLine.substr(0, subLength);
	    lineWidth = getWidth(textLine, font);
	  }
	
	  if (textLine === '') {
	    textLine = options.placeholder;
	  }
	
	  return textLine;
	}
	
	function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
	  var width = 0;
	  var i = 0;
	
	  for (var len = text.length; i < len && width < contentWidth; i++) {
	    var charCode = text.charCodeAt(i);
	    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
	  }
	
	  return i;
	}
	/**
	 * @public
	 * @param {string} font
	 * @return {number} line height
	 */
	
	
	function getLineHeight(font) {
	  // FIXME A rough approach.
	  return getWidth('国', font);
	}
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @return {Object} width
	 */
	
	
	function measureText(text, font) {
	  return methods.measureText(text, font);
	} // Avoid assign to an exported variable, for transforming to cjs.
	
	
	methods.measureText = function (text, font) {
	  var ctx = getContext();
	  ctx.font = font || DEFAULT_FONT;
	  return ctx.measureText(text);
	};
	/**
	 * @public
	 * @param {string} text
	 * @param {string} font
	 * @param {Object} [truncate]
	 * @return {Object} block: {lineHeight, lines, height, outerHeight}
	 *  Notice: for performance, do not calculate outerWidth util needed.
	 */
	
	
	function parsePlainText(text, font, padding, truncate) {
	  text != null && (text += '');
	  var lineHeight = getLineHeight(font);
	  var lines = text ? text.split('\n') : [];
	  var height = lines.length * lineHeight;
	  var outerHeight = height;
	
	  if (padding) {
	    outerHeight += padding[0] + padding[2];
	  }
	
	  if (text && truncate) {
	    var truncOuterHeight = truncate.outerHeight;
	    var truncOuterWidth = truncate.outerWidth;
	
	    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
	      text = '';
	      lines = [];
	    } else if (truncOuterWidth != null) {
	      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
	        minChar: truncate.minChar,
	        placeholder: truncate.placeholder
	      }); // FIXME
	      // It is not appropriate that every line has '...' when truncate multiple lines.
	
	      for (var i = 0, len = lines.length; i < len; i++) {
	        lines[i] = truncateSingleLine(lines[i], options);
	      }
	    }
	  }
	
	  return {
	    lines: lines,
	    height: height,
	    outerHeight: outerHeight,
	    lineHeight: lineHeight
	  };
	}
	/**
	 * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
	 * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
	 *
	 * @public
	 * @param {string} text
	 * @param {Object} style
	 * @return {Object} block
	 * {
	 *      width,
	 *      height,
	 *      lines: [{
	 *          lineHeight,
	 *          width,
	 *          tokens: [[{
	 *              styleName,
	 *              text,
	 *              width,      // include textPadding
	 *              height,     // include textPadding
	 *              textWidth, // pure text width
	 *              textHeight, // pure text height
	 *              lineHeihgt,
	 *              font,
	 *              textAlign,
	 *              textVerticalAlign
	 *          }], [...], ...]
	 *      }, ...]
	 * }
	 * If styleName is undefined, it is plain text.
	 */
	
	
	function parseRichText(text, style) {
	  var contentBlock = {
	    lines: [],
	    width: 0,
	    height: 0
	  };
	  text != null && (text += '');
	
	  if (!text) {
	    return contentBlock;
	  }
	
	  var lastIndex = STYLE_REG.lastIndex = 0;
	  var result;
	
	  while ((result = STYLE_REG.exec(text)) != null) {
	    var matchedIndex = result.index;
	
	    if (matchedIndex > lastIndex) {
	      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
	    }
	
	    pushTokens(contentBlock, result[2], result[1]);
	    lastIndex = STYLE_REG.lastIndex;
	  }
	
	  if (lastIndex < text.length) {
	    pushTokens(contentBlock, text.substring(lastIndex, text.length));
	  }
	
	  var lines = contentBlock.lines;
	  var contentHeight = 0;
	  var contentWidth = 0; // For `textWidth: 100%`
	
	  var pendingList = [];
	  var stlPadding = style.textPadding;
	  var truncate = style.truncate;
	  var truncateWidth = truncate && truncate.outerWidth;
	  var truncateHeight = truncate && truncate.outerHeight;
	
	  if (stlPadding) {
	    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
	    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
	  } // Calculate layout info of tokens.
	
	
	  for (var i = 0; i < lines.length; i++) {
	    var line = lines[i];
	    var lineHeight = 0;
	    var lineWidth = 0;
	
	    for (var j = 0; j < line.tokens.length; j++) {
	      var token = line.tokens[j];
	      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.
	
	      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.
	
	      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.
	
	      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified
	      // as box height of the block.
	      tokenStyle.textHeight, getLineHeight(font));
	      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
	      token.height = tokenHeight;
	      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);
	      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
	      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';
	
	      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
	        return {
	          lines: [],
	          width: 0,
	          height: 0
	        };
	      }
	
	      token.textWidth = getWidth(token.text, font);
	      var tokenWidth = tokenStyle.textWidth;
	      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate
	      // line when box width is needed to be auto.
	
	      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {
	        token.percentWidth = tokenWidth;
	        pendingList.push(token);
	        tokenWidth = 0; // Do not truncate in this case, because there is no user case
	        // and it is too complicated.
	      } else {
	        if (tokenWidthNotSpecified) {
	          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling
	          // `getBoundingRect()` will not get correct result.
	
	          var textBackgroundColor = tokenStyle.textBackgroundColor;
	          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:
	          // (1) If image is not loaded, it will be loaded at render phase and call
	          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded
	          // image, and then the right size will be calculated here at the next tick.
	          // See `graphic/helper/text.js`.
	          // (2) If image loaded, and `textBackgroundColor.image` is image src string,
	          // use `imageHelper.findExistImage` to find cached image.
	          // `imageHelper.findExistImage` will always be called here before
	          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`
	          // which ensures that image will not be rendered before correct size calcualted.
	
	          if (bgImg) {
	            bgImg = imageHelper.findExistImage(bgImg);
	
	            if (imageHelper.isImageReady(bgImg)) {
	              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
	            }
	          }
	        }
	
	        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
	        tokenWidth += paddingW;
	        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;
	
	        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
	          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
	            token.text = '';
	            token.textWidth = tokenWidth = 0;
	          } else {
	            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
	              minChar: truncate.minChar
	            });
	            token.textWidth = getWidth(token.text, font);
	            tokenWidth = token.textWidth + paddingW;
	          }
	        }
	      }
	
	      lineWidth += token.width = tokenWidth;
	      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
	    }
	
	    line.width = lineWidth;
	    line.lineHeight = lineHeight;
	    contentHeight += lineHeight;
	    contentWidth = Math.max(contentWidth, lineWidth);
	  }
	
	  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);
	  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);
	
	  if (stlPadding) {
	    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
	    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
	  }
	
	  for (var i = 0; i < pendingList.length; i++) {
	    var token = pendingList[i];
	    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.
	
	    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
	  }
	
	  return contentBlock;
	}
	
	function pushTokens(block, str, styleName) {
	  var isEmptyStr = str === '';
	  var strs = str.split('\n');
	  var lines = block.lines;
	
	  for (var i = 0; i < strs.length; i++) {
	    var text = strs[i];
	    var token = {
	      styleName: styleName,
	      text: text,
	      isLineHolder: !text && !isEmptyStr
	    }; // The first token should be appended to the last line.
	
	    if (!i) {
	      var tokens = (lines[lines.length - 1] || (lines[0] = {
	        tokens: []
	      })).tokens; // Consider cases:
	      // (1) ''.split('\n') => ['', '\n', ''], the '' at the first item
	      // (which is a placeholder) should be replaced by new token.
	      // (2) A image backage, where token likes {a|}.
	      // (3) A redundant '' will affect textAlign in line.
	      // (4) tokens with the same tplName should not be merged, because
	      // they should be displayed in different box (with border and padding).
	
	      var tokensLen = tokens.length;
	      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the "lineHolder" or
	      // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
	      (text || !tokensLen || isEmptyStr) && tokens.push(token);
	    } // Other tokens always start a new line.
	    else {
	        // If there is '', insert it as a placeholder.
	        lines.push({
	          tokens: [token]
	        });
	      }
	  }
	}
	
	function makeFont(style) {
	  // FIXME in node-canvas fontWeight is before fontStyle
	  // Use `fontSize` `fontFamily` to check whether font properties are defined.
	  return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.
	  style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;
	}
	
	exports.DEFAULT_FONT = DEFAULT_FONT;
	exports.$override = $override;
	exports.getWidth = getWidth;
	exports.getBoundingRect = getBoundingRect;
	exports.adjustTextX = adjustTextX;
	exports.adjustTextY = adjustTextY;
	exports.adjustTextPositionOnRect = adjustTextPositionOnRect;
	exports.truncateText = truncateText;
	exports.getLineHeight = getLineHeight;
	exports.measureText = measureText;
	exports.parsePlainText = parsePlainText;
	exports.parseRichText = parseRichText;
	exports.makeFont = makeFont;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(14);
	
	var matrix = __webpack_require__(13);
	
	/**
	 * @module echarts/core/BoundingRect
	 */
	var v2ApplyTransform = vec2.applyTransform;
	var mathMin = Math.min;
	var mathMax = Math.max;
	/**
	 * @alias module:echarts/core/BoundingRect
	 */
	
	function BoundingRect(x, y, width, height) {
	  if (width < 0) {
	    x = x + width;
	    width = -width;
	  }
	
	  if (height < 0) {
	    y = y + height;
	    height = -height;
	  }
	  /**
	   * @type {number}
	   */
	
	
	  this.x = x;
	  /**
	   * @type {number}
	   */
	
	  this.y = y;
	  /**
	   * @type {number}
	   */
	
	  this.width = width;
	  /**
	   * @type {number}
	   */
	
	  this.height = height;
	}
	
	BoundingRect.prototype = {
	  constructor: BoundingRect,
	
	  /**
	   * @param {module:echarts/core/BoundingRect} other
	   */
	  union: function (other) {
	    var x = mathMin(other.x, this.x);
	    var y = mathMin(other.y, this.y);
	    this.width = mathMax(other.x + other.width, this.x + this.width) - x;
	    this.height = mathMax(other.y + other.height, this.y + this.height) - y;
	    this.x = x;
	    this.y = y;
	  },
	
	  /**
	   * @param {Array.<number>} m
	   * @methods
	   */
	  applyTransform: function () {
	    var lt = [];
	    var rb = [];
	    var lb = [];
	    var rt = [];
	    return function (m) {
	      // In case usage like this
	      // el.getBoundingRect().applyTransform(el.transform)
	      // And element has no transform
	      if (!m) {
	        return;
	      }
	
	      lt[0] = lb[0] = this.x;
	      lt[1] = rt[1] = this.y;
	      rb[0] = rt[0] = this.x + this.width;
	      rb[1] = lb[1] = this.y + this.height;
	      v2ApplyTransform(lt, lt, m);
	      v2ApplyTransform(rb, rb, m);
	      v2ApplyTransform(lb, lb, m);
	      v2ApplyTransform(rt, rt, m);
	      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
	      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
	      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
	      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
	      this.width = maxX - this.x;
	      this.height = maxY - this.y;
	    };
	  }(),
	
	  /**
	   * Calculate matrix of transforming from self to target rect
	   * @param  {module:zrender/core/BoundingRect} b
	   * @return {Array.<number>}
	   */
	  calculateTransform: function (b) {
	    var a = this;
	    var sx = b.width / a.width;
	    var sy = b.height / a.height;
	    var m = matrix.create(); // 矩阵右乘
	
	    matrix.translate(m, m, [-a.x, -a.y]);
	    matrix.scale(m, m, [sx, sy]);
	    matrix.translate(m, m, [b.x, b.y]);
	    return m;
	  },
	
	  /**
	   * @param {(module:echarts/core/BoundingRect|Object)} b
	   * @return {boolean}
	   */
	  intersect: function (b) {
	    if (!b) {
	      return false;
	    }
	
	    if (!(b instanceof BoundingRect)) {
	      // Normalize negative width/height.
	      b = BoundingRect.create(b);
	    }
	
	    var a = this;
	    var ax0 = a.x;
	    var ax1 = a.x + a.width;
	    var ay0 = a.y;
	    var ay1 = a.y + a.height;
	    var bx0 = b.x;
	    var bx1 = b.x + b.width;
	    var by0 = b.y;
	    var by1 = b.y + b.height;
	    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
	  },
	  contain: function (x, y) {
	    var rect = this;
	    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
	  },
	
	  /**
	   * @return {module:echarts/core/BoundingRect}
	   */
	  clone: function () {
	    return new BoundingRect(this.x, this.y, this.width, this.height);
	  },
	
	  /**
	   * Copy from another rect
	   */
	  copy: function (other) {
	    this.x = other.x;
	    this.y = other.y;
	    this.width = other.width;
	    this.height = other.height;
	  },
	  plain: function () {
	    return {
	      x: this.x,
	      y: this.y,
	      width: this.width,
	      height: this.height
	    };
	  }
	};
	/**
	 * @param {Object|module:zrender/core/BoundingRect} rect
	 * @param {number} rect.x
	 * @param {number} rect.y
	 * @param {number} rect.width
	 * @param {number} rect.height
	 * @return {module:zrender/core/BoundingRect}
	 */
	
	BoundingRect.create = function (rect) {
	  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
	};
	
	var _default = BoundingRect;
	module.exports = _default;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	var LRU = __webpack_require__(20);
	
	var globalImageCache = new LRU(50);
	/**
	 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
	 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
	 */
	
	function findExistImage(newImageOrSrc) {
	  if (typeof newImageOrSrc === 'string') {
	    var cachedImgObj = globalImageCache.get(newImageOrSrc);
	    return cachedImgObj && cachedImgObj.image;
	  } else {
	    return newImageOrSrc;
	  }
	}
	/**
	 * Caution: User should cache loaded images, but not just count on LRU.
	 * Consider if required images more than LRU size, will dead loop occur?
	 *
	 * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
	 * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
	 * @param {module:zrender/Element} [hostEl] For calling `dirty`.
	 * @param {Function} [cb] params: (image, cbPayload)
	 * @param {Object} [cbPayload] Payload on cb calling.
	 * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
	 */
	
	
	function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
	  if (!newImageOrSrc) {
	    return image;
	  } else if (typeof newImageOrSrc === 'string') {
	    // Image should not be loaded repeatly.
	    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
	      return image;
	    } // Only when there is no existent image or existent image src
	    // is different, this method is responsible for load.
	
	
	    var cachedImgObj = globalImageCache.get(newImageOrSrc);
	    var pendingWrap = {
	      hostEl: hostEl,
	      cb: cb,
	      cbPayload: cbPayload
	    };
	
	    if (cachedImgObj) {
	      image = cachedImgObj.image;
	      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
	    } else {
	      !image && (image = new Image());
	      image.onload = imageOnLoad;
	      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
	        image: image,
	        pending: [pendingWrap]
	      });
	      image.src = image.__zrImageSrc = newImageOrSrc;
	    }
	
	    return image;
	  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas
	  else {
	      return newImageOrSrc;
	    }
	}
	
	function imageOnLoad() {
	  var cachedImgObj = this.__cachedImgObj;
	  this.onload = this.__cachedImgObj = null;
	
	  for (var i = 0; i < cachedImgObj.pending.length; i++) {
	    var pendingWrap = cachedImgObj.pending[i];
	    var cb = pendingWrap.cb;
	    cb && cb(this, pendingWrap.cbPayload);
	    pendingWrap.hostEl.dirty();
	  }
	
	  cachedImgObj.pending.length = 0;
	}
	
	function isImageReady(image) {
	  return image && image.width && image.height;
	}
	
	exports.findExistImage = findExistImage;
	exports.createOrUpdateImage = createOrUpdateImage;
	exports.isImageReady = isImageReady;

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	function buildPath(ctx, shape) {
	  var x = shape.x;
	  var y = shape.y;
	  var width = shape.width;
	  var height = shape.height;
	  var r = shape.r;
	  var r1;
	  var r2;
	  var r3;
	  var r4; // Convert width and height to positive for better borderRadius
	
	  if (width < 0) {
	    x = x + width;
	    width = -width;
	  }
	
	  if (height < 0) {
	    y = y + height;
	    height = -height;
	  }
	
	  if (typeof r === 'number') {
	    r1 = r2 = r3 = r4 = r;
	  } else if (r instanceof Array) {
	    if (r.length === 1) {
	      r1 = r2 = r3 = r4 = r[0];
	    } else if (r.length === 2) {
	      r1 = r3 = r[0];
	      r2 = r4 = r[1];
	    } else if (r.length === 3) {
	      r1 = r[0];
	      r2 = r4 = r[1];
	      r3 = r[2];
	    } else {
	      r1 = r[0];
	      r2 = r[1];
	      r3 = r[2];
	      r4 = r[3];
	    }
	  } else {
	    r1 = r2 = r3 = r4 = 0;
	  }
	
	  var total;
	
	  if (r1 + r2 > width) {
	    total = r1 + r2;
	    r1 *= width / total;
	    r2 *= width / total;
	  }
	
	  if (r3 + r4 > width) {
	    total = r3 + r4;
	    r3 *= width / total;
	    r4 *= width / total;
	  }
	
	  if (r2 + r3 > height) {
	    total = r2 + r3;
	    r2 *= height / total;
	    r3 *= height / total;
	  }
	
	  if (r1 + r4 > height) {
	    total = r1 + r4;
	    r1 *= height / total;
	    r4 *= height / total;
	  }
	
	  ctx.moveTo(x + r1, y);
	  ctx.lineTo(x + width - r2, y);
	  r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);
	  ctx.lineTo(x + width, y + height - r3);
	  r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);
	  ctx.lineTo(x + r4, y + height);
	  r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);
	  ctx.lineTo(x, y + r1);
	  r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
	}
	
	exports.buildPath = buildPath;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	var curve = __webpack_require__(30);
	
	var vec2 = __webpack_require__(14);
	
	var bbox = __webpack_require__(31);
	
	var BoundingRect = __webpack_require__(26);
	
	var _config = __webpack_require__(22);
	
	var dpr = _config.devicePixelRatio;
	
	/**
	 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
	 * 可以用于 isInsidePath 判断以及获取boundingRect
	 *
	 * @module zrender/core/PathProxy
	 * @author Yi Shen (http://www.github.com/pissang)
	 */
	// TODO getTotalLength, getPointAtLength
	var CMD = {
	  M: 1,
	  L: 2,
	  C: 3,
	  Q: 4,
	  A: 5,
	  Z: 6,
	  // Rect
	  R: 7
	}; // var CMD_MEM_SIZE = {
	//     M: 3,
	//     L: 3,
	//     C: 7,
	//     Q: 5,
	//     A: 9,
	//     R: 5,
	//     Z: 1
	// };
	
	var min = [];
	var max = [];
	var min2 = [];
	var max2 = [];
	var mathMin = Math.min;
	var mathMax = Math.max;
	var mathCos = Math.cos;
	var mathSin = Math.sin;
	var mathSqrt = Math.sqrt;
	var mathAbs = Math.abs;
	var hasTypedArray = typeof Float32Array != 'undefined';
	/**
	 * @alias module:zrender/core/PathProxy
	 * @constructor
	 */
	
	var PathProxy = function (notSaveData) {
	  this._saveData = !(notSaveData || false);
	
	  if (this._saveData) {
	    /**
	     * Path data. Stored as flat array
	     * @type {Array.<Object>}
	     */
	    this.data = [];
	  }
	
	  this._ctx = null;
	};
	/**
	 * 快速计算Path包围盒（并不是最小包围盒）
	 * @return {Object}
	 */
	
	
	PathProxy.prototype = {
	  constructor: PathProxy,
	  _xi: 0,
	  _yi: 0,
	  _x0: 0,
	  _y0: 0,
	  // Unit x, Unit y. Provide for avoiding drawing that too short line segment
	  _ux: 0,
	  _uy: 0,
	  _len: 0,
	  _lineDash: null,
	  _dashOffset: 0,
	  _dashIdx: 0,
	  _dashSum: 0,
	
	  /**
	   * @readOnly
	   */
	  setScale: function (sx, sy) {
	    this._ux = mathAbs(1 / dpr / sx) || 0;
	    this._uy = mathAbs(1 / dpr / sy) || 0;
	  },
	  getContext: function () {
	    return this._ctx;
	  },
	
	  /**
	   * @param  {CanvasRenderingContext2D} ctx
	   * @return {module:zrender/core/PathProxy}
	   */
	  beginPath: function (ctx) {
	    this._ctx = ctx;
	    ctx && ctx.beginPath();
	    ctx && (this.dpr = ctx.dpr); // Reset
	
	    if (this._saveData) {
	      this._len = 0;
	    }
	
	    if (this._lineDash) {
	      this._lineDash = null;
	      this._dashOffset = 0;
	    }
	
	    return this;
	  },
	
	  /**
	   * @param  {number} x
	   * @param  {number} y
	   * @return {module:zrender/core/PathProxy}
	   */
	  moveTo: function (x, y) {
	    this.addData(CMD.M, x, y);
	    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
	    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
	    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
	    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
	
	    this._x0 = x;
	    this._y0 = y;
	    this._xi = x;
	    this._yi = y;
	    return this;
	  },
	
	  /**
	   * @param  {number} x
	   * @param  {number} y
	   * @return {module:zrender/core/PathProxy}
	   */
	  lineTo: function (x, y) {
	    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment
	    || this._len < 5;
	    this.addData(CMD.L, x, y);
	
	    if (this._ctx && exceedUnit) {
	      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
	    }
	
	    if (exceedUnit) {
	      this._xi = x;
	      this._yi = y;
	    }
	
	    return this;
	  },
	
	  /**
	   * @param  {number} x1
	   * @param  {number} y1
	   * @param  {number} x2
	   * @param  {number} y2
	   * @param  {number} x3
	   * @param  {number} y3
	   * @return {module:zrender/core/PathProxy}
	   */
	  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
	    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
	
	    if (this._ctx) {
	      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
	    }
	
	    this._xi = x3;
	    this._yi = y3;
	    return this;
	  },
	
	  /**
	   * @param  {number} x1
	   * @param  {number} y1
	   * @param  {number} x2
	   * @param  {number} y2
	   * @return {module:zrender/core/PathProxy}
	   */
	  quadraticCurveTo: function (x1, y1, x2, y2) {
	    this.addData(CMD.Q, x1, y1, x2, y2);
	
	    if (this._ctx) {
	      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
	    }
	
	    this._xi = x2;
	    this._yi = y2;
	    return this;
	  },
	
	  /**
	   * @param  {number} cx
	   * @param  {number} cy
	   * @param  {number} r
	   * @param  {number} startAngle
	   * @param  {number} endAngle
	   * @param  {boolean} anticlockwise
	   * @return {module:zrender/core/PathProxy}
	   */
	  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
	    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
	    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
	    this._xi = mathCos(endAngle) * r + cx;
	    this._yi = mathSin(endAngle) * r + cx;
	    return this;
	  },
	  // TODO
	  arcTo: function (x1, y1, x2, y2, radius) {
	    if (this._ctx) {
	      this._ctx.arcTo(x1, y1, x2, y2, radius);
	    }
	
	    return this;
	  },
	  // TODO
	  rect: function (x, y, w, h) {
	    this._ctx && this._ctx.rect(x, y, w, h);
	    this.addData(CMD.R, x, y, w, h);
	    return this;
	  },
	
	  /**
	   * @return {module:zrender/core/PathProxy}
	   */
	  closePath: function () {
	    this.addData(CMD.Z);
	    var ctx = this._ctx;
	    var x0 = this._x0;
	    var y0 = this._y0;
	
	    if (ctx) {
	      this._needsDash() && this._dashedLineTo(x0, y0);
	      ctx.closePath();
	    }
	
	    this._xi = x0;
	    this._yi = y0;
	    return this;
	  },
	
	  /**
	   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
	   * stroke 同样
	   * @param {CanvasRenderingContext2D} ctx
	   * @return {module:zrender/core/PathProxy}
	   */
	  fill: function (ctx) {
	    ctx && ctx.fill();
	    this.toStatic();
	  },
	
	  /**
	   * @param {CanvasRenderingContext2D} ctx
	   * @return {module:zrender/core/PathProxy}
	   */
	  stroke: function (ctx) {
	    ctx && ctx.stroke();
	    this.toStatic();
	  },
	
	  /**
	   * 必须在其它绘制命令前调用
	   * Must be invoked before all other path drawing methods
	   * @return {module:zrender/core/PathProxy}
	   */
	  setLineDash: function (lineDash) {
	    if (lineDash instanceof Array) {
	      this._lineDash = lineDash;
	      this._dashIdx = 0;
	      var lineDashSum = 0;
	
	      for (var i = 0; i < lineDash.length; i++) {
	        lineDashSum += lineDash[i];
	      }
	
	      this._dashSum = lineDashSum;
	    }
	
	    return this;
	  },
	
	  /**
	   * 必须在其它绘制命令前调用
	   * Must be invoked before all other path drawing methods
	   * @return {module:zrender/core/PathProxy}
	   */
	  setLineDashOffset: function (offset) {
	    this._dashOffset = offset;
	    return this;
	  },
	
	  /**
	   *
	   * @return {boolean}
	   */
	  len: function () {
	    return this._len;
	  },
	
	  /**
	   * 直接设置 Path 数据
	   */
	  setData: function (data) {
	    var len = data.length;
	
	    if (!(this.data && this.data.length == len) && hasTypedArray) {
	      this.data = new Float32Array(len);
	    }
	
	    for (var i = 0; i < len; i++) {
	      this.data[i] = data[i];
	    }
	
	    this._len = len;
	  },
	
	  /**
	   * 添加子路径
	   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
	   */
	  appendPath: function (path) {
	    if (!(path instanceof Array)) {
	      path = [path];
	    }
	
	    var len = path.length;
	    var appendSize = 0;
	    var offset = this._len;
	
	    for (var i = 0; i < len; i++) {
	      appendSize += path[i].len();
	    }
	
	    if (hasTypedArray && this.data instanceof Float32Array) {
	      this.data = new Float32Array(offset + appendSize);
	    }
	
	    for (var i = 0; i < len; i++) {
	      var appendPathData = path[i].data;
	
	      for (var k = 0; k < appendPathData.length; k++) {
	        this.data[offset++] = appendPathData[k];
	      }
	    }
	
	    this._len = offset;
	  },
	
	  /**
	   * 填充 Path 数据。
	   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
	   */
	  addData: function (cmd) {
	    if (!this._saveData) {
	      return;
	    }
	
	    var data = this.data;
	
	    if (this._len + arguments.length > data.length) {
	      // 因为之前的数组已经转换成静态的 Float32Array
	      // 所以不够用时需要扩展一个新的动态数组
	      this._expandData();
	
	      data = this.data;
	    }
	
	    for (var i = 0; i < arguments.length; i++) {
	      data[this._len++] = arguments[i];
	    }
	
	    this._prevCmd = cmd;
	  },
	  _expandData: function () {
	    // Only if data is Float32Array
	    if (!(this.data instanceof Array)) {
	      var newData = [];
	
	      for (var i = 0; i < this._len; i++) {
	        newData[i] = this.data[i];
	      }
	
	      this.data = newData;
	    }
	  },
	
	  /**
	   * If needs js implemented dashed line
	   * @return {boolean}
	   * @private
	   */
	  _needsDash: function () {
	    return this._lineDash;
	  },
	  _dashedLineTo: function (x1, y1) {
	    var dashSum = this._dashSum;
	    var offset = this._dashOffset;
	    var lineDash = this._lineDash;
	    var ctx = this._ctx;
	    var x0 = this._xi;
	    var y0 = this._yi;
	    var dx = x1 - x0;
	    var dy = y1 - y0;
	    var dist = mathSqrt(dx * dx + dy * dy);
	    var x = x0;
	    var y = y0;
	    var dash;
	    var nDash = lineDash.length;
	    var idx;
	    dx /= dist;
	    dy /= dist;
	
	    if (offset < 0) {
	      // Convert to positive offset
	      offset = dashSum + offset;
	    }
	
	    offset %= dashSum;
	    x -= offset * dx;
	    y -= offset * dy;
	
	    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
	      idx = this._dashIdx;
	      dash = lineDash[idx];
	      x += dx * dash;
	      y += dy * dash;
	      this._dashIdx = (idx + 1) % nDash; // Skip positive offset
	
	      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
	        continue;
	      }
	
	      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));
	    } // Offset for next lineTo
	
	
	    dx = x - x1;
	    dy = y - y1;
	    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	  },
	  // Not accurate dashed line to
	  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
	    var dashSum = this._dashSum;
	    var offset = this._dashOffset;
	    var lineDash = this._lineDash;
	    var ctx = this._ctx;
	    var x0 = this._xi;
	    var y0 = this._yi;
	    var t;
	    var dx;
	    var dy;
	    var cubicAt = curve.cubicAt;
	    var bezierLen = 0;
	    var idx = this._dashIdx;
	    var nDash = lineDash.length;
	    var x;
	    var y;
	    var tmpLen = 0;
	
	    if (offset < 0) {
	      // Convert to positive offset
	      offset = dashSum + offset;
	    }
	
	    offset %= dashSum; // Bezier approx length
	
	    for (t = 0; t < 1; t += 0.1) {
	      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
	      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
	      bezierLen += mathSqrt(dx * dx + dy * dy);
	    } // Find idx after add offset
	
	
	    for (; idx < nDash; idx++) {
	      tmpLen += lineDash[idx];
	
	      if (tmpLen > offset) {
	        break;
	      }
	    }
	
	    t = (tmpLen - offset) / bezierLen;
	
	    while (t <= 1) {
	      x = cubicAt(x0, x1, x2, x3, t);
	      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier
	      // Bad result if dash is long
	
	      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
	      t += lineDash[idx] / bezierLen;
	      idx = (idx + 1) % nDash;
	    } // Finish the last segment and calculate the new offset
	
	
	    idx % 2 !== 0 && ctx.lineTo(x3, y3);
	    dx = x3 - x;
	    dy = y3 - y;
	    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	  },
	  _dashedQuadraticTo: function (x1, y1, x2, y2) {
	    // Convert quadratic to cubic using degree elevation
	    var x3 = x2;
	    var y3 = y2;
	    x2 = (x2 + 2 * x1) / 3;
	    y2 = (y2 + 2 * y1) / 3;
	    x1 = (this._xi + 2 * x1) / 3;
	    y1 = (this._yi + 2 * y1) / 3;
	
	    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
	  },
	
	  /**
	   * 转成静态的 Float32Array 减少堆内存占用
	   * Convert dynamic array to static Float32Array
	   */
	  toStatic: function () {
	    var data = this.data;
	
	    if (data instanceof Array) {
	      data.length = this._len;
	
	      if (hasTypedArray) {
	        this.data = new Float32Array(data);
	      }
	    }
	  },
	
	  /**
	   * @return {module:zrender/core/BoundingRect}
	   */
	  getBoundingRect: function () {
	    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
	    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
	    var data = this.data;
	    var xi = 0;
	    var yi = 0;
	    var x0 = 0;
	    var y0 = 0;
	
	    for (var i = 0; i < data.length;) {
	      var cmd = data[i++];
	
	      if (i == 1) {
	        // 如果第一个命令是 L, C, Q
	        // 则 previous point 同绘制命令的第一个 point
	        //
	        // 第一个命令为 Arc 的情况下会在后面特殊处理
	        xi = data[i];
	        yi = data[i + 1];
	        x0 = xi;
	        y0 = yi;
	      }
	
	      switch (cmd) {
	        case CMD.M:
	          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	          // 在 closePath 的时候使用
	          x0 = data[i++];
	          y0 = data[i++];
	          xi = x0;
	          yi = y0;
	          min2[0] = x0;
	          min2[1] = y0;
	          max2[0] = x0;
	          max2[1] = y0;
	          break;
	
	        case CMD.L:
	          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
	          xi = data[i++];
	          yi = data[i++];
	          break;
	
	        case CMD.C:
	          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
	          xi = data[i++];
	          yi = data[i++];
	          break;
	
	        case CMD.Q:
	          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
	          xi = data[i++];
	          yi = data[i++];
	          break;
	
	        case CMD.A:
	          // TODO Arc 判断的开销比较大
	          var cx = data[i++];
	          var cy = data[i++];
	          var rx = data[i++];
	          var ry = data[i++];
	          var startAngle = data[i++];
	          var endAngle = data[i++] + startAngle; // TODO Arc 旋转
	
	          var psi = data[i++];
	          var anticlockwise = 1 - data[i++];
	
	          if (i == 1) {
	            // 直接使用 arc 命令
	            // 第一个命令起点还未定义
	            x0 = mathCos(startAngle) * rx + cx;
	            y0 = mathSin(startAngle) * ry + cy;
	          }
	
	          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
	          xi = mathCos(endAngle) * rx + cx;
	          yi = mathSin(endAngle) * ry + cy;
	          break;
	
	        case CMD.R:
	          x0 = xi = data[i++];
	          y0 = yi = data[i++];
	          var width = data[i++];
	          var height = data[i++]; // Use fromLine
	
	          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
	          break;
	
	        case CMD.Z:
	          xi = x0;
	          yi = y0;
	          break;
	      } // Union
	
	
	      vec2.min(min, min, min2);
	      vec2.max(max, max, max2);
	    } // No data
	
	
	    if (i === 0) {
	      min[0] = min[1] = max[0] = max[1] = 0;
	    }
	
	    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	  },
	
	  /**
	   * Rebuild path from current data
	   * Rebuild path will not consider javascript implemented line dash.
	   * @param {CanvasRenderingContext2D} ctx
	   */
	  rebuildPath: function (ctx) {
	    var d = this.data;
	    var x0, y0;
	    var xi, yi;
	    var x, y;
	    var ux = this._ux;
	    var uy = this._uy;
	    var len = this._len;
	
	    for (var i = 0; i < len;) {
	      var cmd = d[i++];
	
	      if (i == 1) {
	        // 如果第一个命令是 L, C, Q
	        // 则 previous point 同绘制命令的第一个 point
	        //
	        // 第一个命令为 Arc 的情况下会在后面特殊处理
	        xi = d[i];
	        yi = d[i + 1];
	        x0 = xi;
	        y0 = yi;
	      }
	
	      switch (cmd) {
	        case CMD.M:
	          x0 = xi = d[i++];
	          y0 = yi = d[i++];
	          ctx.moveTo(xi, yi);
	          break;
	
	        case CMD.L:
	          x = d[i++];
	          y = d[i++]; // Not draw too small seg between
	
	          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
	            ctx.lineTo(x, y);
	            xi = x;
	            yi = y;
	          }
	
	          break;
	
	        case CMD.C:
	          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
	          xi = d[i - 2];
	          yi = d[i - 1];
	          break;
	
	        case CMD.Q:
	          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
	          xi = d[i - 2];
	          yi = d[i - 1];
	          break;
	
	        case CMD.A:
	          var cx = d[i++];
	          var cy = d[i++];
	          var rx = d[i++];
	          var ry = d[i++];
	          var theta = d[i++];
	          var dTheta = d[i++];
	          var psi = d[i++];
	          var fs = d[i++];
	          var r = rx > ry ? rx : ry;
	          var scaleX = rx > ry ? 1 : rx / ry;
	          var scaleY = rx > ry ? ry / rx : 1;
	          var isEllipse = Math.abs(rx - ry) > 1e-3;
	          var endAngle = theta + dTheta;
	
	          if (isEllipse) {
	            ctx.translate(cx, cy);
	            ctx.rotate(psi);
	            ctx.scale(scaleX, scaleY);
	            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
	            ctx.scale(1 / scaleX, 1 / scaleY);
	            ctx.rotate(-psi);
	            ctx.translate(-cx, -cy);
	          } else {
	            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
	          }
	
	          if (i == 1) {
	            // 直接使用 arc 命令
	            // 第一个命令起点还未定义
	            x0 = mathCos(theta) * rx + cx;
	            y0 = mathSin(theta) * ry + cy;
	          }
	
	          xi = mathCos(endAngle) * rx + cx;
	          yi = mathSin(endAngle) * ry + cy;
	          break;
	
	        case CMD.R:
	          x0 = xi = d[i];
	          y0 = yi = d[i + 1];
	          ctx.rect(d[i++], d[i++], d[i++], d[i++]);
	          break;
	
	        case CMD.Z:
	          ctx.closePath();
	          xi = x0;
	          yi = y0;
	      }
	    }
	  }
	};
	PathProxy.CMD = CMD;
	var _default = PathProxy;
	module.exports = _default;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	var _vector = __webpack_require__(14);
	
	var v2Create = _vector.create;
	var v2DistSquare = _vector.distSquare;
	
	/**
	 * 曲线辅助模块
	 * @module zrender/core/curve
	 * @author pissang(https://www.github.com/pissang)
	 */
	var mathPow = Math.pow;
	var mathSqrt = Math.sqrt;
	var EPSILON = 1e-8;
	var EPSILON_NUMERIC = 1e-4;
	var THREE_SQRT = mathSqrt(3);
	var ONE_THIRD = 1 / 3; // 临时变量
	
	var _v0 = v2Create();
	
	var _v1 = v2Create();
	
	var _v2 = v2Create();
	
	function isAroundZero(val) {
	  return val > -EPSILON && val < EPSILON;
	}
	
	function isNotAroundZero(val) {
	  return val > EPSILON || val < -EPSILON;
	}
	/**
	 * 计算三次贝塞尔值
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function cubicAt(p0, p1, p2, p3, t) {
	  var onet = 1 - t;
	  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
	}
	/**
	 * 计算三次贝塞尔导数值
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function cubicDerivativeAt(p0, p1, p2, p3, t) {
	  var onet = 1 - t;
	  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
	}
	/**
	 * 计算三次贝塞尔方程根，使用盛金公式
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} val
	 * @param  {Array.<number>} roots
	 * @return {number} 有效根数目
	 */
	
	
	function cubicRootAt(p0, p1, p2, p3, val, roots) {
	  // Evaluate roots of cubic functions
	  var a = p3 + 3 * (p1 - p2) - p0;
	  var b = 3 * (p2 - p1 * 2 + p0);
	  var c = 3 * (p1 - p0);
	  var d = p0 - val;
	  var A = b * b - 3 * a * c;
	  var B = b * c - 9 * a * d;
	  var C = c * c - 3 * b * d;
	  var n = 0;
	
	  if (isAroundZero(A) && isAroundZero(B)) {
	    if (isAroundZero(b)) {
	      roots[0] = 0;
	    } else {
	      var t1 = -c / b; //t1, t2, t3, b is not zero
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    }
	  } else {
	    var disc = B * B - 4 * A * C;
	
	    if (isAroundZero(disc)) {
	      var K = B / A;
	      var t1 = -b / a + K; // t1, a is not zero
	
	      var t2 = -K / 2; // t2, t3
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        roots[n++] = t2;
	      }
	    } else if (disc > 0) {
	      var discSqrt = mathSqrt(disc);
	      var Y1 = A * b + 1.5 * a * (-B + discSqrt);
	      var Y2 = A * b + 1.5 * a * (-B - discSqrt);
	
	      if (Y1 < 0) {
	        Y1 = -mathPow(-Y1, ONE_THIRD);
	      } else {
	        Y1 = mathPow(Y1, ONE_THIRD);
	      }
	
	      if (Y2 < 0) {
	        Y2 = -mathPow(-Y2, ONE_THIRD);
	      } else {
	        Y2 = mathPow(Y2, ONE_THIRD);
	      }
	
	      var t1 = (-b - (Y1 + Y2)) / (3 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    } else {
	      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
	      var theta = Math.acos(T) / 3;
	      var ASqrt = mathSqrt(A);
	      var tmp = Math.cos(theta);
	      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
	      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
	      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        roots[n++] = t2;
	      }
	
	      if (t3 >= 0 && t3 <= 1) {
	        roots[n++] = t3;
	      }
	    }
	  }
	
	  return n;
	}
	/**
	 * 计算三次贝塞尔方程极限值的位置
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {Array.<number>} extrema
	 * @return {number} 有效数目
	 */
	
	
	function cubicExtrema(p0, p1, p2, p3, extrema) {
	  var b = 6 * p2 - 12 * p1 + 6 * p0;
	  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
	  var c = 3 * p1 - 3 * p0;
	  var n = 0;
	
	  if (isAroundZero(a)) {
	    if (isNotAroundZero(b)) {
	      var t1 = -c / b;
	
	      if (t1 >= 0 && t1 <= 1) {
	        extrema[n++] = t1;
	      }
	    }
	  } else {
	    var disc = b * b - 4 * a * c;
	
	    if (isAroundZero(disc)) {
	      extrema[0] = -b / (2 * a);
	    } else if (disc > 0) {
	      var discSqrt = mathSqrt(disc);
	      var t1 = (-b + discSqrt) / (2 * a);
	      var t2 = (-b - discSqrt) / (2 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        extrema[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        extrema[n++] = t2;
	      }
	    }
	  }
	
	  return n;
	}
	/**
	 * 细分三次贝塞尔曲线
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} p3
	 * @param  {number} t
	 * @param  {Array.<number>} out
	 */
	
	
	function cubicSubdivide(p0, p1, p2, p3, t, out) {
	  var p01 = (p1 - p0) * t + p0;
	  var p12 = (p2 - p1) * t + p1;
	  var p23 = (p3 - p2) * t + p2;
	  var p012 = (p12 - p01) * t + p01;
	  var p123 = (p23 - p12) * t + p12;
	  var p0123 = (p123 - p012) * t + p012; // Seg0
	
	  out[0] = p0;
	  out[1] = p01;
	  out[2] = p012;
	  out[3] = p0123; // Seg1
	
	  out[4] = p0123;
	  out[5] = p123;
	  out[6] = p23;
	  out[7] = p3;
	}
	/**
	 * 投射点到三次贝塞尔曲线上，返回投射距离。
	 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x3
	 * @param {number} y3
	 * @param {number} x
	 * @param {number} y
	 * @param {Array.<number>} [out] 投射点
	 * @return {number}
	 */
	
	
	function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
	  // http://pomax.github.io/bezierinfo/#projections
	  var t;
	  var interval = 0.005;
	  var d = Infinity;
	  var prev;
	  var next;
	  var d1;
	  var d2;
	  _v0[0] = x;
	  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
	  // PENDING
	
	  for (var _t = 0; _t < 1; _t += 0.05) {
	    _v1[0] = cubicAt(x0, x1, x2, x3, _t);
	    _v1[1] = cubicAt(y0, y1, y2, y3, _t);
	    d1 = v2DistSquare(_v0, _v1);
	
	    if (d1 < d) {
	      t = _t;
	      d = d1;
	    }
	  }
	
	  d = Infinity; // At most 32 iteration
	
	  for (var i = 0; i < 32; i++) {
	    if (interval < EPSILON_NUMERIC) {
	      break;
	    }
	
	    prev = t - interval;
	    next = t + interval; // t - interval
	
	    _v1[0] = cubicAt(x0, x1, x2, x3, prev);
	    _v1[1] = cubicAt(y0, y1, y2, y3, prev);
	    d1 = v2DistSquare(_v1, _v0);
	
	    if (prev >= 0 && d1 < d) {
	      t = prev;
	      d = d1;
	    } else {
	      // t + interval
	      _v2[0] = cubicAt(x0, x1, x2, x3, next);
	      _v2[1] = cubicAt(y0, y1, y2, y3, next);
	      d2 = v2DistSquare(_v2, _v0);
	
	      if (next <= 1 && d2 < d) {
	        t = next;
	        d = d2;
	      } else {
	        interval *= 0.5;
	      }
	    }
	  } // t
	
	
	  if (out) {
	    out[0] = cubicAt(x0, x1, x2, x3, t);
	    out[1] = cubicAt(y0, y1, y2, y3, t);
	  } // console.log(interval, i);
	
	
	  return mathSqrt(d);
	}
	/**
	 * 计算二次方贝塞尔值
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function quadraticAt(p0, p1, p2, t) {
	  var onet = 1 - t;
	  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
	}
	/**
	 * 计算二次方贝塞尔导数值
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @return {number}
	 */
	
	
	function quadraticDerivativeAt(p0, p1, p2, t) {
	  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
	}
	/**
	 * 计算二次方贝塞尔方程根
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @param  {Array.<number>} roots
	 * @return {number} 有效根数目
	 */
	
	
	function quadraticRootAt(p0, p1, p2, val, roots) {
	  var a = p0 - 2 * p1 + p2;
	  var b = 2 * (p1 - p0);
	  var c = p0 - val;
	  var n = 0;
	
	  if (isAroundZero(a)) {
	    if (isNotAroundZero(b)) {
	      var t1 = -c / b;
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    }
	  } else {
	    var disc = b * b - 4 * a * c;
	
	    if (isAroundZero(disc)) {
	      var t1 = -b / (2 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	    } else if (disc > 0) {
	      var discSqrt = mathSqrt(disc);
	      var t1 = (-b + discSqrt) / (2 * a);
	      var t2 = (-b - discSqrt) / (2 * a);
	
	      if (t1 >= 0 && t1 <= 1) {
	        roots[n++] = t1;
	      }
	
	      if (t2 >= 0 && t2 <= 1) {
	        roots[n++] = t2;
	      }
	    }
	  }
	
	  return n;
	}
	/**
	 * 计算二次贝塞尔方程极限值
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @return {number}
	 */
	
	
	function quadraticExtremum(p0, p1, p2) {
	  var divider = p0 + p2 - 2 * p1;
	
	  if (divider === 0) {
	    // p1 is center of p0 and p2
	    return 0.5;
	  } else {
	    return (p0 - p1) / divider;
	  }
	}
	/**
	 * 细分二次贝塞尔曲线
	 * @memberOf module:zrender/core/curve
	 * @param  {number} p0
	 * @param  {number} p1
	 * @param  {number} p2
	 * @param  {number} t
	 * @param  {Array.<number>} out
	 */
	
	
	function quadraticSubdivide(p0, p1, p2, t, out) {
	  var p01 = (p1 - p0) * t + p0;
	  var p12 = (p2 - p1) * t + p1;
	  var p012 = (p12 - p01) * t + p01; // Seg0
	
	  out[0] = p0;
	  out[1] = p01;
	  out[2] = p012; // Seg1
	
	  out[3] = p012;
	  out[4] = p12;
	  out[5] = p2;
	}
	/**
	 * 投射点到二次贝塞尔曲线上，返回投射距离。
	 * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x
	 * @param {number} y
	 * @param {Array.<number>} out 投射点
	 * @return {number}
	 */
	
	
	function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
	  // http://pomax.github.io/bezierinfo/#projections
	  var t;
	  var interval = 0.005;
	  var d = Infinity;
	  _v0[0] = x;
	  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
	  // PENDING
	
	  for (var _t = 0; _t < 1; _t += 0.05) {
	    _v1[0] = quadraticAt(x0, x1, x2, _t);
	    _v1[1] = quadraticAt(y0, y1, y2, _t);
	    var d1 = v2DistSquare(_v0, _v1);
	
	    if (d1 < d) {
	      t = _t;
	      d = d1;
	    }
	  }
	
	  d = Infinity; // At most 32 iteration
	
	  for (var i = 0; i < 32; i++) {
	    if (interval < EPSILON_NUMERIC) {
	      break;
	    }
	
	    var prev = t - interval;
	    var next = t + interval; // t - interval
	
	    _v1[0] = quadraticAt(x0, x1, x2, prev);
	    _v1[1] = quadraticAt(y0, y1, y2, prev);
	    var d1 = v2DistSquare(_v1, _v0);
	
	    if (prev >= 0 && d1 < d) {
	      t = prev;
	      d = d1;
	    } else {
	      // t + interval
	      _v2[0] = quadraticAt(x0, x1, x2, next);
	      _v2[1] = quadraticAt(y0, y1, y2, next);
	      var d2 = v2DistSquare(_v2, _v0);
	
	      if (next <= 1 && d2 < d) {
	        t = next;
	        d = d2;
	      } else {
	        interval *= 0.5;
	      }
	    }
	  } // t
	
	
	  if (out) {
	    out[0] = quadraticAt(x0, x1, x2, t);
	    out[1] = quadraticAt(y0, y1, y2, t);
	  } // console.log(interval, i);
	
	
	  return mathSqrt(d);
	}
	
	exports.cubicAt = cubicAt;
	exports.cubicDerivativeAt = cubicDerivativeAt;
	exports.cubicRootAt = cubicRootAt;
	exports.cubicExtrema = cubicExtrema;
	exports.cubicSubdivide = cubicSubdivide;
	exports.cubicProjectPoint = cubicProjectPoint;
	exports.quadraticAt = quadraticAt;
	exports.quadraticDerivativeAt = quadraticDerivativeAt;
	exports.quadraticRootAt = quadraticRootAt;
	exports.quadraticExtremum = quadraticExtremum;
	exports.quadraticSubdivide = quadraticSubdivide;
	exports.quadraticProjectPoint = quadraticProjectPoint;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	var vec2 = __webpack_require__(14);
	
	var curve = __webpack_require__(30);
	
	/**
	 * @author Yi Shen(https://github.com/pissang)
	 */
	var mathMin = Math.min;
	var mathMax = Math.max;
	var mathSin = Math.sin;
	var mathCos = Math.cos;
	var PI2 = Math.PI * 2;
	var start = vec2.create();
	var end = vec2.create();
	var extremity = vec2.create();
	/**
	 * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
	 * @module zrender/core/bbox
	 * @param {Array<Object>} points 顶点数组
	 * @param {number} min
	 * @param {number} max
	 */
	
	function fromPoints(points, min, max) {
	  if (points.length === 0) {
	    return;
	  }
	
	  var p = points[0];
	  var left = p[0];
	  var right = p[0];
	  var top = p[1];
	  var bottom = p[1];
	  var i;
	
	  for (i = 1; i < points.length; i++) {
	    p = points[i];
	    left = mathMin(left, p[0]);
	    right = mathMax(right, p[0]);
	    top = mathMin(top, p[1]);
	    bottom = mathMax(bottom, p[1]);
	  }
	
	  min[0] = left;
	  min[1] = top;
	  max[0] = right;
	  max[1] = bottom;
	}
	/**
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	
	function fromLine(x0, y0, x1, y1, min, max) {
	  min[0] = mathMin(x0, x1);
	  min[1] = mathMin(y0, y1);
	  max[0] = mathMax(x0, x1);
	  max[1] = mathMax(y0, y1);
	}
	
	var xDim = [];
	var yDim = [];
	/**
	 * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {number} x3
	 * @param {number} y3
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
	  var cubicExtrema = curve.cubicExtrema;
	  var cubicAt = curve.cubicAt;
	  var i;
	  var n = cubicExtrema(x0, x1, x2, x3, xDim);
	  min[0] = Infinity;
	  min[1] = Infinity;
	  max[0] = -Infinity;
	  max[1] = -Infinity;
	
	  for (i = 0; i < n; i++) {
	    var x = cubicAt(x0, x1, x2, x3, xDim[i]);
	    min[0] = mathMin(x, min[0]);
	    max[0] = mathMax(x, max[0]);
	  }
	
	  n = cubicExtrema(y0, y1, y2, y3, yDim);
	
	  for (i = 0; i < n; i++) {
	    var y = cubicAt(y0, y1, y2, y3, yDim[i]);
	    min[1] = mathMin(y, min[1]);
	    max[1] = mathMax(y, max[1]);
	  }
	
	  min[0] = mathMin(x0, min[0]);
	  max[0] = mathMax(x0, max[0]);
	  min[0] = mathMin(x3, min[0]);
	  max[0] = mathMax(x3, max[0]);
	  min[1] = mathMin(y0, min[1]);
	  max[1] = mathMax(y0, max[1]);
	  min[1] = mathMin(y3, min[1]);
	  max[1] = mathMax(y3, max[1]);
	}
	/**
	 * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x0
	 * @param {number} y0
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	
	function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
	  var quadraticExtremum = curve.quadraticExtremum;
	  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero
	
	  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);
	  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);
	  var x = quadraticAt(x0, x1, x2, tx);
	  var y = quadraticAt(y0, y1, y2, ty);
	  min[0] = mathMin(x0, x2, x);
	  min[1] = mathMin(y0, y2, y);
	  max[0] = mathMax(x0, x2, x);
	  max[1] = mathMax(y0, y2, y);
	}
	/**
	 * 从圆弧中计算出最小包围盒，写入`min`和`max`中
	 * @method
	 * @memberOf module:zrender/core/bbox
	 * @param {number} x
	 * @param {number} y
	 * @param {number} rx
	 * @param {number} ry
	 * @param {number} startAngle
	 * @param {number} endAngle
	 * @param {number} anticlockwise
	 * @param {Array.<number>} min
	 * @param {Array.<number>} max
	 */
	
	
	function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
	  var vec2Min = vec2.min;
	  var vec2Max = vec2.max;
	  var diff = Math.abs(startAngle - endAngle);
	
	  if (diff % PI2 < 1e-4 && diff > 1e-4) {
	    // Is a circle
	    min[0] = x - rx;
	    min[1] = y - ry;
	    max[0] = x + rx;
	    max[1] = y + ry;
	    return;
	  }
	
	  start[0] = mathCos(startAngle) * rx + x;
	  start[1] = mathSin(startAngle) * ry + y;
	  end[0] = mathCos(endAngle) * rx + x;
	  end[1] = mathSin(endAngle) * ry + y;
	  vec2Min(min, start, end);
	  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]
	
	  startAngle = startAngle % PI2;
	
	  if (startAngle < 0) {
	    startAngle = startAngle + PI2;
	  }
	
	  endAngle = endAngle % PI2;
	
	  if (endAngle < 0) {
	    endAngle = endAngle + PI2;
	  }
	
	  if (startAngle > endAngle && !anticlockwise) {
	    endAngle += PI2;
	  } else if (startAngle < endAngle && anticlockwise) {
	    startAngle += PI2;
	  }
	
	  if (anticlockwise) {
	    var tmp = endAngle;
	    endAngle = startAngle;
	    startAngle = tmp;
	  } // var number = 0;
	  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
	
	
	  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
	    if (angle > startAngle) {
	      extremity[0] = mathCos(angle) * rx + x;
	      extremity[1] = mathSin(angle) * ry + y;
	      vec2Min(min, extremity, min);
	      vec2Max(max, extremity, max);
	    }
	  }
	}
	
	exports.fromPoints = fromPoints;
	exports.fromLine = fromLine;
	exports.fromCubic = fromCubic;
	exports.fromQuadratic = fromQuadratic;
	exports.fromArc = fromArc;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	var PathProxy = __webpack_require__(29);
	
	var line = __webpack_require__(33);
	
	var cubic = __webpack_require__(34);
	
	var quadratic = __webpack_require__(35);
	
	var arc = __webpack_require__(36);
	
	var _util = __webpack_require__(37);
	
	var normalizeRadian = _util.normalizeRadian;
	
	var curve = __webpack_require__(30);
	
	var windingLine = __webpack_require__(38);
	
	var CMD = PathProxy.CMD;
	var PI2 = Math.PI * 2;
	var EPSILON = 1e-4;
	
	function isAroundEqual(a, b) {
	  return Math.abs(a - b) < EPSILON;
	} // 临时数组
	
	
	var roots = [-1, -1, -1];
	var extrema = [-1, -1];
	
	function swapExtrema() {
	  var tmp = extrema[0];
	  extrema[0] = extrema[1];
	  extrema[1] = tmp;
	}
	
	function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
	  // Quick reject
	  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
	    return 0;
	  }
	
	  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
	
	  if (nRoots === 0) {
	    return 0;
	  } else {
	    var w = 0;
	    var nExtrema = -1;
	    var y0_, y1_;
	
	    for (var i = 0; i < nRoots; i++) {
	      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon
	
	      var unit = t === 0 || t === 1 ? 0.5 : 1;
	      var x_ = curve.cubicAt(x0, x1, x2, x3, t);
	
	      if (x_ < x) {
	        // Quick reject
	        continue;
	      }
	
	      if (nExtrema < 0) {
	        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
	
	        if (extrema[1] < extrema[0] && nExtrema > 1) {
	          swapExtrema();
	        }
	
	        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
	
	        if (nExtrema > 1) {
	          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
	        }
	      }
	
	      if (nExtrema == 2) {
	        // 分成三段单调函数
	        if (t < extrema[0]) {
	          w += y0_ < y0 ? unit : -unit;
	        } else if (t < extrema[1]) {
	          w += y1_ < y0_ ? unit : -unit;
	        } else {
	          w += y3 < y1_ ? unit : -unit;
	        }
	      } else {
	        // 分成两段单调函数
	        if (t < extrema[0]) {
	          w += y0_ < y0 ? unit : -unit;
	        } else {
	          w += y3 < y0_ ? unit : -unit;
	        }
	      }
	    }
	
	    return w;
	  }
	}
	
	function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
	  // Quick reject
	  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
	    return 0;
	  }
	
	  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
	
	  if (nRoots === 0) {
	    return 0;
	  } else {
	    var t = curve.quadraticExtremum(y0, y1, y2);
	
	    if (t >= 0 && t <= 1) {
	      var w = 0;
	      var y_ = curve.quadraticAt(y0, y1, y2, t);
	
	      for (var i = 0; i < nRoots; i++) {
	        // Remove one endpoint.
	        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
	        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
	
	        if (x_ < x) {
	          // Quick reject
	          continue;
	        }
	
	        if (roots[i] < t) {
	          w += y_ < y0 ? unit : -unit;
	        } else {
	          w += y2 < y_ ? unit : -unit;
	        }
	      }
	
	      return w;
	    } else {
	      // Remove one endpoint.
	      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
	      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
	
	      if (x_ < x) {
	        // Quick reject
	        return 0;
	      }
	
	      return y2 < y0 ? unit : -unit;
	    }
	  }
	} // TODO
	// Arc 旋转
	
	
	function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
	  y -= cy;
	
	  if (y > r || y < -r) {
	    return 0;
	  }
	
	  var tmp = Math.sqrt(r * r - y * y);
	  roots[0] = -tmp;
	  roots[1] = tmp;
	  var diff = Math.abs(startAngle - endAngle);
	
	  if (diff < 1e-4) {
	    return 0;
	  }
	
	  if (diff % PI2 < 1e-4) {
	    // Is a circle
	    startAngle = 0;
	    endAngle = PI2;
	    var dir = anticlockwise ? 1 : -1;
	
	    if (x >= roots[0] + cx && x <= roots[1] + cx) {
	      return dir;
	    } else {
	      return 0;
	    }
	  }
	
	  if (anticlockwise) {
	    var tmp = startAngle;
	    startAngle = normalizeRadian(endAngle);
	    endAngle = normalizeRadian(tmp);
	  } else {
	    startAngle = normalizeRadian(startAngle);
	    endAngle = normalizeRadian(endAngle);
	  }
	
	  if (startAngle > endAngle) {
	    endAngle += PI2;
	  }
	
	  var w = 0;
	
	  for (var i = 0; i < 2; i++) {
	    var x_ = roots[i];
	
	    if (x_ + cx > x) {
	      var angle = Math.atan2(y, x_);
	      var dir = anticlockwise ? 1 : -1;
	
	      if (angle < 0) {
	        angle = PI2 + angle;
	      }
	
	      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
	        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
	          dir = -dir;
	        }
	
	        w += dir;
	      }
	    }
	  }
	
	  return w;
	}
	
	function containPath(data, lineWidth, isStroke, x, y) {
	  var w = 0;
	  var xi = 0;
	  var yi = 0;
	  var x0 = 0;
	  var y0 = 0;
	
	  for (var i = 0; i < data.length;) {
	    var cmd = data[i++]; // Begin a new subpath
	
	    if (cmd === CMD.M && i > 1) {
	      // Close previous subpath
	      if (!isStroke) {
	        w += windingLine(xi, yi, x0, y0, x, y);
	      } // 如果被任何一个 subpath 包含
	      // if (w !== 0) {
	      //     return true;
	      // }
	
	    }
	
	    if (i == 1) {
	      // 如果第一个命令是 L, C, Q
	      // 则 previous point 同绘制命令的第一个 point
	      //
	      // 第一个命令为 Arc 的情况下会在后面特殊处理
	      xi = data[i];
	      yi = data[i + 1];
	      x0 = xi;
	      y0 = yi;
	    }
	
	    switch (cmd) {
	      case CMD.M:
	        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	        // 在 closePath 的时候使用
	        x0 = data[i++];
	        y0 = data[i++];
	        xi = x0;
	        yi = y0;
	        break;
	
	      case CMD.L:
	        if (isStroke) {
	          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
	          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
	        }
	
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.C:
	        if (isStroke) {
	          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
	        }
	
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.Q:
	        if (isStroke) {
	          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
	        }
	
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.A:
	        // TODO Arc 判断的开销比较大
	        var cx = data[i++];
	        var cy = data[i++];
	        var rx = data[i++];
	        var ry = data[i++];
	        var theta = data[i++];
	        var dTheta = data[i++]; // TODO Arc 旋转
	
	        var psi = data[i++];
	        var anticlockwise = 1 - data[i++];
	        var x1 = Math.cos(theta) * rx + cx;
	        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令
	
	        if (i > 1) {
	          w += windingLine(xi, yi, x1, y1, x, y);
	        } else {
	          // 第一个命令起点还未定义
	          x0 = x1;
	          y0 = y1;
	        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
	
	
	        var _x = (x - cx) * ry / rx + cx;
	
	        if (isStroke) {
	          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
	            return true;
	          }
	        } else {
	          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
	        }
	
	        xi = Math.cos(theta + dTheta) * rx + cx;
	        yi = Math.sin(theta + dTheta) * ry + cy;
	        break;
	
	      case CMD.R:
	        x0 = xi = data[i++];
	        y0 = yi = data[i++];
	        var width = data[i++];
	        var height = data[i++];
	        var x1 = x0 + width;
	        var y1 = y0 + height;
	
	        if (isStroke) {
	          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          // FIXME Clockwise ?
	          w += windingLine(x1, y0, x1, y1, x, y);
	          w += windingLine(x0, y1, x0, y0, x, y);
	        }
	
	        break;
	
	      case CMD.Z:
	        if (isStroke) {
	          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
	            return true;
	          }
	        } else {
	          // Close a subpath
	          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含
	          // FIXME subpaths may overlap
	          // if (w !== 0) {
	          //     return true;
	          // }
	        }
	
	        xi = x0;
	        yi = y0;
	        break;
	    }
	  }
	
	  if (!isStroke && !isAroundEqual(yi, y0)) {
	    w += windingLine(xi, yi, x0, y0, x, y) || 0;
	  }
	
	  return w !== 0;
	}
	
	function contain(pathData, x, y) {
	  return containPath(pathData, 0, false, x, y);
	}
	
	function containStroke(pathData, lineWidth, x, y) {
	  return containPath(pathData, lineWidth, true, x, y);
	}
	
	exports.contain = contain;
	exports.containStroke = containStroke;

/***/ }),
/* 33 */
/***/ (function(module, exports) {

	/**
	 * 线段包含判断
	 * @param  {number}  x0
	 * @param  {number}  y0
	 * @param  {number}  x1
	 * @param  {number}  y1
	 * @param  {number}  lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {boolean}
	 */
	function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth;
	  var _a = 0;
	  var _b = x0; // Quick reject
	
	  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
	    return false;
	  }
	
	  if (x0 !== x1) {
	    _a = (y0 - y1) / (x0 - x1);
	    _b = (x0 * y1 - x1 * y0) / (x0 - x1);
	  } else {
	    return Math.abs(x - x0) <= _l / 2;
	  }
	
	  var tmp = _a * x - y + _b;
	
	  var _s = tmp * tmp / (_a * _a + 1);
	
	  return _s <= _l / 2 * _l / 2;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	var curve = __webpack_require__(30);
	
	/**
	 * 三次贝塞尔曲线描边包含判断
	 * @param  {number}  x0
	 * @param  {number}  y0
	 * @param  {number}  x1
	 * @param  {number}  y1
	 * @param  {number}  x2
	 * @param  {number}  y2
	 * @param  {number}  x3
	 * @param  {number}  y3
	 * @param  {number}  lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {boolean}
	 */
	function containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth; // Quick reject
	
	  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
	    return false;
	  }
	
	  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
	  return d <= _l / 2;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	var _curve = __webpack_require__(30);
	
	var quadraticProjectPoint = _curve.quadraticProjectPoint;
	
	/**
	 * 二次贝塞尔曲线描边包含判断
	 * @param  {number}  x0
	 * @param  {number}  y0
	 * @param  {number}  x1
	 * @param  {number}  y1
	 * @param  {number}  x2
	 * @param  {number}  y2
	 * @param  {number}  lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {boolean}
	 */
	function containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth; // Quick reject
	
	  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
	    return false;
	  }
	
	  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
	  return d <= _l / 2;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	var _util = __webpack_require__(37);
	
	var normalizeRadian = _util.normalizeRadian;
	var PI2 = Math.PI * 2;
	/**
	 * 圆弧描边包含判断
	 * @param  {number}  cx
	 * @param  {number}  cy
	 * @param  {number}  r
	 * @param  {number}  startAngle
	 * @param  {number}  endAngle
	 * @param  {boolean}  anticlockwise
	 * @param  {number} lineWidth
	 * @param  {number}  x
	 * @param  {number}  y
	 * @return {Boolean}
	 */
	
	function containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
	  if (lineWidth === 0) {
	    return false;
	  }
	
	  var _l = lineWidth;
	  x -= cx;
	  y -= cy;
	  var d = Math.sqrt(x * x + y * y);
	
	  if (d - _l > r || d + _l < r) {
	    return false;
	  }
	
	  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
	    // Is a circle
	    return true;
	  }
	
	  if (anticlockwise) {
	    var tmp = startAngle;
	    startAngle = normalizeRadian(endAngle);
	    endAngle = normalizeRadian(tmp);
	  } else {
	    startAngle = normalizeRadian(startAngle);
	    endAngle = normalizeRadian(endAngle);
	  }
	
	  if (startAngle > endAngle) {
	    endAngle += PI2;
	  }
	
	  var angle = Math.atan2(y, x);
	
	  if (angle < 0) {
	    angle += PI2;
	  }
	
	  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;
	}
	
	exports.containStroke = containStroke;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	var PI2 = Math.PI * 2;
	
	function normalizeRadian(angle) {
	  angle %= PI2;
	
	  if (angle < 0) {
	    angle += PI2;
	  }
	
	  return angle;
	}
	
	exports.normalizeRadian = normalizeRadian;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

	function windingLine(x0, y0, x1, y1, x, y) {
	  if (y > y0 && y > y1 || y < y0 && y < y1) {
	    return 0;
	  } // Ignore horizontal line
	
	
	  if (y1 === y0) {
	    return 0;
	  }
	
	  var dir = y1 < y0 ? 1 : -1;
	  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon
	
	  if (t === 1 || t === 0) {
	    dir = y1 < y0 ? 0.5 : -0.5;
	  }
	
	  var x_ = t * (x1 - x0) + x0;
	  return x_ > x ? dir : 0;
	}
	
	module.exports = windingLine;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	var Pattern = function (image, repeat) {
	  // Should do nothing more in this constructor. Because gradient can be
	  // declard by `color: {image: ...}`, where this constructor will not be called.
	  this.image = image;
	  this.repeat = repeat; // Can be cloned
	
	  this.type = 'pattern';
	};
	
	Pattern.prototype.getCanvasPattern = function (ctx) {
	  return ctx.createPattern(this.image, this.repeat || 'repeat');
	};
	
	var _default = Pattern;
	module.exports = _default;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	var PathProxy = __webpack_require__(29);
	
	var _vector = __webpack_require__(14);
	
	var v2ApplyTransform = _vector.applyTransform;
	var CMD = PathProxy.CMD;
	var points = [[], [], []];
	var mathSqrt = Math.sqrt;
	var mathAtan2 = Math.atan2;
	
	function _default(path, m) {
	  var data = path.data;
	  var cmd;
	  var nPoint;
	  var i;
	  var j;
	  var k;
	  var p;
	  var M = CMD.M;
	  var C = CMD.C;
	  var L = CMD.L;
	  var R = CMD.R;
	  var A = CMD.A;
	  var Q = CMD.Q;
	
	  for (i = 0, j = 0; i < data.length;) {
	    cmd = data[i++];
	    j = i;
	    nPoint = 0;
	
	    switch (cmd) {
	      case M:
	        nPoint = 1;
	        break;
	
	      case L:
	        nPoint = 1;
	        break;
	
	      case C:
	        nPoint = 3;
	        break;
	
	      case Q:
	        nPoint = 2;
	        break;
	
	      case A:
	        var x = m[4];
	        var y = m[5];
	        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
	        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
	        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx
	
	        data[i] *= sx;
	        data[i++] += x; // cy
	
	        data[i] *= sy;
	        data[i++] += y; // Scale rx and ry
	        // FIXME Assume psi is 0 here
	
	        data[i++] *= sx;
	        data[i++] *= sy; // Start angle
	
	        data[i++] += angle; // end angle
	
	        data[i++] += angle; // FIXME psi
	
	        i += 2;
	        j = i;
	        break;
	
	      case R:
	        // x0, y0
	        p[0] = data[i++];
	        p[1] = data[i++];
	        v2ApplyTransform(p, p, m);
	        data[j++] = p[0];
	        data[j++] = p[1]; // x1, y1
	
	        p[0] += data[i++];
	        p[1] += data[i++];
	        v2ApplyTransform(p, p, m);
	        data[j++] = p[0];
	        data[j++] = p[1];
	    }
	
	    for (k = 0; k < nPoint; k++) {
	      var p = points[k];
	      p[0] = data[i++];
	      p[1] = data[i++];
	      v2ApplyTransform(p, p, m); // Write back
	
	      data[j++] = p[0];
	      data[j++] = p[1];
	    }
	  }
	}
	
	module.exports = _default;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	/**
	 * @param {Array.<Object>} colorStops
	 */
	var Gradient = function (colorStops) {
	  this.colorStops = colorStops || [];
	};
	
	Gradient.prototype = {
	  constructor: Gradient,
	  addColorStop: function (offset, color) {
	    this.colorStops.push({
	      offset: offset,
	      color: color
	    });
	  }
	};
	var _default = Gradient;
	module.exports = _default;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	// TODO Draggable for group
	// FIXME Draggable on element which has parent rotation or scale
	function Draggable() {
	  this.on('mousedown', this._dragStart, this);
	  this.on('mousemove', this._drag, this);
	  this.on('mouseup', this._dragEnd, this);
	  this.on('globalout', this._dragEnd, this); // this._dropTarget = null;
	  // this._draggingTarget = null;
	  // this._x = 0;
	  // this._y = 0;
	}
	
	Draggable.prototype = {
	  constructor: Draggable,
	  _dragStart: function (e) {
	    var draggingTarget = e.target;
	
	    if (draggingTarget && draggingTarget.draggable) {
	      this._draggingTarget = draggingTarget;
	      draggingTarget.dragging = true;
	      this._x = e.offsetX;
	      this._y = e.offsetY;
	      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);
	    }
	  },
	  _drag: function (e) {
	    var draggingTarget = this._draggingTarget;
	
	    if (draggingTarget) {
	      var x = e.offsetX;
	      var y = e.offsetY;
	      var dx = x - this._x;
	      var dy = y - this._y;
	      this._x = x;
	      this._y = y;
	      draggingTarget.drift(dx, dy, e);
	      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);
	      var dropTarget = this.findHover(x, y, draggingTarget).target;
	      var lastDropTarget = this._dropTarget;
	      this._dropTarget = dropTarget;
	
	      if (draggingTarget !== dropTarget) {
	        if (lastDropTarget && dropTarget !== lastDropTarget) {
	          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);
	        }
	
	        if (dropTarget && dropTarget !== lastDropTarget) {
	          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);
	        }
	      }
	    }
	  },
	  _dragEnd: function (e) {
	    var draggingTarget = this._draggingTarget;
	
	    if (draggingTarget) {
	      draggingTarget.dragging = false;
	    }
	
	    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);
	
	    if (this._dropTarget) {
	      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);
	    }
	
	    this._draggingTarget = null;
	    this._dropTarget = null;
	  }
	};
	
	function param(target, e) {
	  return {
	    target: target,
	    topTarget: e && e.topTarget
	  };
	}
	
	var _default = Draggable;
	module.exports = _default;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(4);
	
	var Element = __webpack_require__(9);
	
	var BoundingRect = __webpack_require__(26);
	
	/**
	 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
	 * @module zrender/graphic/Group
	 * @example
	 *     var Group = require('zrender/container/Group');
	 *     var Circle = require('zrender/graphic/shape/Circle');
	 *     var g = new Group();
	 *     g.position[0] = 100;
	 *     g.position[1] = 100;
	 *     g.add(new Circle({
	 *         style: {
	 *             x: 100,
	 *             y: 100,
	 *             r: 20,
	 *         }
	 *     }));
	 *     zr.add(g);
	 */
	
	/**
	 * @alias module:zrender/graphic/Group
	 * @constructor
	 * @extends module:zrender/mixin/Transformable
	 * @extends module:zrender/mixin/Eventful
	 */
	var Group = function (opts) {
	  opts = opts || {};
	  Element.call(this, opts);
	
	  for (var key in opts) {
	    if (opts.hasOwnProperty(key)) {
	      this[key] = opts[key];
	    }
	  }
	
	  this._children = [];
	  this.__storage = null;
	  this.__dirty = true;
	};
	
	Group.prototype = {
	  constructor: Group,
	  isGroup: true,
	
	  /**
	   * @type {string}
	   */
	  type: 'group',
	
	  /**
	   * 所有子孙元素是否响应鼠标事件
	   * @name module:/zrender/container/Group#silent
	   * @type {boolean}
	   * @default false
	   */
	  silent: false,
	
	  /**
	   * @return {Array.<module:zrender/Element>}
	   */
	  children: function () {
	    return this._children.slice();
	  },
	
	  /**
	   * 获取指定 index 的儿子节点
	   * @param  {number} idx
	   * @return {module:zrender/Element}
	   */
	  childAt: function (idx) {
	    return this._children[idx];
	  },
	
	  /**
	   * 获取指定名字的儿子节点
	   * @param  {string} name
	   * @return {module:zrender/Element}
	   */
	  childOfName: function (name) {
	    var children = this._children;
	
	    for (var i = 0; i < children.length; i++) {
	      if (children[i].name === name) {
	        return children[i];
	      }
	    }
	  },
	
	  /**
	   * @return {number}
	   */
	  childCount: function () {
	    return this._children.length;
	  },
	
	  /**
	   * 添加子节点到最后
	   * @param {module:zrender/Element} child
	   */
	  add: function (child) {
	    if (child && child !== this && child.parent !== this) {
	      this._children.push(child);
	
	      this._doAdd(child);
	    }
	
	    return this;
	  },
	
	  /**
	   * 添加子节点在 nextSibling 之前
	   * @param {module:zrender/Element} child
	   * @param {module:zrender/Element} nextSibling
	   */
	  addBefore: function (child, nextSibling) {
	    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
	      var children = this._children;
	      var idx = children.indexOf(nextSibling);
	
	      if (idx >= 0) {
	        children.splice(idx, 0, child);
	
	        this._doAdd(child);
	      }
	    }
	
	    return this;
	  },
	  _doAdd: function (child) {
	    if (child.parent) {
	      child.parent.remove(child);
	    }
	
	    child.parent = this;
	    var storage = this.__storage;
	    var zr = this.__zr;
	
	    if (storage && storage !== child.__storage) {
	      storage.addToStorage(child);
	
	      if (child instanceof Group) {
	        child.addChildrenToStorage(storage);
	      }
	    }
	
	    zr && zr.refresh();
	  },
	
	  /**
	   * 移除子节点
	   * @param {module:zrender/Element} child
	   */
	  remove: function (child) {
	    var zr = this.__zr;
	    var storage = this.__storage;
	    var children = this._children;
	    var idx = zrUtil.indexOf(children, child);
	
	    if (idx < 0) {
	      return this;
	    }
	
	    children.splice(idx, 1);
	    child.parent = null;
	
	    if (storage) {
	      storage.delFromStorage(child);
	
	      if (child instanceof Group) {
	        child.delChildrenFromStorage(storage);
	      }
	    }
	
	    zr && zr.refresh();
	    return this;
	  },
	
	  /**
	   * 移除所有子节点
	   */
	  removeAll: function () {
	    var children = this._children;
	    var storage = this.__storage;
	    var child;
	    var i;
	
	    for (i = 0; i < children.length; i++) {
	      child = children[i];
	
	      if (storage) {
	        storage.delFromStorage(child);
	
	        if (child instanceof Group) {
	          child.delChildrenFromStorage(storage);
	        }
	      }
	
	      child.parent = null;
	    }
	
	    children.length = 0;
	    return this;
	  },
	
	  /**
	   * 遍历所有子节点
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  eachChild: function (cb, context) {
	    var children = this._children;
	
	    for (var i = 0; i < children.length; i++) {
	      var child = children[i];
	      cb.call(context, child, i);
	    }
	
	    return this;
	  },
	
	  /**
	   * 深度优先遍历所有子孙节点
	   * @param  {Function} cb
	   * @param  {}   context
	   */
	  traverse: function (cb, context) {
	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      cb.call(context, child);
	
	      if (child.type === 'group') {
	        child.traverse(cb, context);
	      }
	    }
	
	    return this;
	  },
	  addChildrenToStorage: function (storage) {
	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      storage.addToStorage(child);
	
	      if (child instanceof Group) {
	        child.addChildrenToStorage(storage);
	      }
	    }
	  },
	  delChildrenFromStorage: function (storage) {
	    for (var i = 0; i < this._children.length; i++) {
	      var child = this._children[i];
	      storage.delFromStorage(child);
	
	      if (child instanceof Group) {
	        child.delChildrenFromStorage(storage);
	      }
	    }
	  },
	  dirty: function () {
	    this.__dirty = true;
	    this.__zr && this.__zr.refresh();
	    return this;
	  },
	
	  /**
	   * @return {module:zrender/core/BoundingRect}
	   */
	  getBoundingRect: function (includeChildren) {
	    // TODO Caching
	    var rect = null;
	    var tmpRect = new BoundingRect(0, 0, 0, 0);
	    var children = includeChildren || this._children;
	    var tmpMat = [];
	
	    for (var i = 0; i < children.length; i++) {
	      var child = children[i];
	
	      if (child.ignore || child.invisible) {
	        continue;
	      }
	
	      var childRect = child.getBoundingRect();
	      var transform = child.getLocalTransform(tmpMat); // TODO
	      // The boundingRect cacluated by transforming original
	      // rect may be bigger than the actual bundingRect when rotation
	      // is used. (Consider a circle rotated aginst its center, where
	      // the actual boundingRect should be the same as that not be
	      // rotated.) But we can not find better approach to calculate
	      // actual boundingRect yet, considering performance.
	
	      if (transform) {
	        tmpRect.copy(childRect);
	        tmpRect.applyTransform(transform);
	        rect = rect || tmpRect.clone();
	        rect.union(tmpRect);
	      } else {
	        rect = rect || childRect.clone();
	        rect.union(childRect);
	      }
	    }
	
	    return rect || tmpRect;
	  }
	};
	zrUtil.inherits(Group, Element);
	var _default = Group;
	module.exports = _default;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	var Displayable = __webpack_require__(7);
	
	var BoundingRect = __webpack_require__(26);
	
	var zrUtil = __webpack_require__(4);
	
	var imageHelper = __webpack_require__(27);
	
	/**
	 * @alias zrender/graphic/Image
	 * @extends module:zrender/graphic/Displayable
	 * @constructor
	 * @param {Object} opts
	 */
	function ZImage(opts) {
	  Displayable.call(this, opts);
	}
	
	ZImage.prototype = {
	  constructor: ZImage,
	  type: 'image',
	  brush: function (ctx, prevEl) {
	    var style = this.style;
	    var src = style.image; // Must bind each time
	
	    style.bind(ctx, this, prevEl);
	    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);
	
	    if (!image || !imageHelper.isImageReady(image)) {
	      return;
	    } // 图片已经加载完成
	    // if (image.nodeName.toUpperCase() == 'IMG') {
	    //     if (!image.complete) {
	    //         return;
	    //     }
	    // }
	    // Else is canvas
	
	
	    var x = style.x || 0;
	    var y = style.y || 0;
	    var width = style.width;
	    var height = style.height;
	    var aspect = image.width / image.height;
	
	    if (width == null && height != null) {
	      // Keep image/height ratio
	      width = height * aspect;
	    } else if (height == null && width != null) {
	      height = width / aspect;
	    } else if (width == null && height == null) {
	      width = image.width;
	      height = image.height;
	    } // 设置transform
	
	
	    this.setTransform(ctx);
	
	    if (style.sWidth && style.sHeight) {
	      var sx = style.sx || 0;
	      var sy = style.sy || 0;
	      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
	    } else if (style.sx && style.sy) {
	      var sx = style.sx;
	      var sy = style.sy;
	      var sWidth = width - sx;
	      var sHeight = height - sy;
	      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
	    } else {
	      ctx.drawImage(image, x, y, width, height);
	    }
	
	    this.restoreTransform(ctx); // Draw rect text
	
	    if (style.text != null) {
	      this.drawRectText(ctx, this.getBoundingRect());
	    }
	  },
	  getBoundingRect: function () {
	    var style = this.style;
	
	    if (!this._rect) {
	      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
	    }
	
	    return this._rect;
	  }
	};
	zrUtil.inherits(ZImage, Displayable);
	var _default = ZImage;
	module.exports = _default;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	var Displayable = __webpack_require__(7);
	
	var zrUtil = __webpack_require__(4);
	
	var textContain = __webpack_require__(25);
	
	var textHelper = __webpack_require__(24);
	
	/**
	 * @alias zrender/graphic/Text
	 * @extends module:zrender/graphic/Displayable
	 * @constructor
	 * @param {Object} opts
	 */
	var Text = function (opts) {
	  // jshint ignore:line
	  Displayable.call(this, opts);
	};
	
	Text.prototype = {
	  constructor: Text,
	  type: 'text',
	  brush: function (ctx, prevEl) {
	    var style = this.style; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.
	
	    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
	    var text = style.text; // Convert to string
	
	    text != null && (text += ''); // Always bind style
	
	    style.bind(ctx, this, prevEl);
	
	    if (!textHelper.needDrawText(text, style)) {
	      return;
	    }
	
	    this.setTransform(ctx);
	    textHelper.renderText(this, ctx, text, style);
	    this.restoreTransform(ctx);
	  },
	  getBoundingRect: function () {
	    var style = this.style; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true);
	
	    if (!this._rect) {
	      var text = style.text;
	      text != null ? text += '' : text = '';
	      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);
	      rect.x += style.x || 0;
	      rect.y += style.y || 0;
	
	      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {
	        var w = style.textStrokeWidth;
	        rect.x -= w / 2;
	        rect.y -= w / 2;
	        rect.width += w;
	        rect.height += w;
	      }
	
	      this._rect = rect;
	    }
	
	    return this._rect;
	  }
	};
	zrUtil.inherits(Text, Displayable);
	var _default = Text;
	module.exports = _default;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	/**
	 * 圆形
	 * @module zrender/shape/Circle
	 */
	var _default = Path.extend({
	  type: 'circle',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r: 0
	  },
	  buildPath: function (ctx, shape, inBundle) {
	    // Better stroking in ShapeBundle
	    // Always do it may have performence issue ( fill may be 2x more cost)
	    if (inBundle) {
	      ctx.moveTo(shape.cx + shape.r, shape.cy);
	    } // else {
	    //     if (ctx.allocate && !ctx.data.length) {
	    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);
	    //     }
	    // }
	    // Better stroking in ShapeBundle
	    // ctx.moveTo(shape.cx + shape.r, shape.cy);
	
	
	    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	var fixClipWithShadow = __webpack_require__(48);
	
	/**
	 * 扇形
	 * @module zrender/graphic/shape/Sector
	 */
	var _default = Path.extend({
	  type: 'sector',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r0: 0,
	    r: 0,
	    startAngle: 0,
	    endAngle: Math.PI * 2,
	    clockwise: true
	  },
	  brush: fixClipWithShadow(Path.prototype.brush),
	  buildPath: function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var r0 = Math.max(shape.r0 || 0, 0);
	    var r = Math.max(shape.r, 0);
	    var startAngle = shape.startAngle;
	    var endAngle = shape.endAngle;
	    var clockwise = shape.clockwise;
	    var unitX = Math.cos(startAngle);
	    var unitY = Math.sin(startAngle);
	    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
	    ctx.lineTo(unitX * r + x, unitY * r + y);
	    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);
	
	    if (r0 !== 0) {
	      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	    }
	
	    ctx.closePath();
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	var env = __webpack_require__(49);
	
	// Fix weird bug in some version of IE11 (like 11.0.9600.178**),
	// where exception "unexpected call to method or property access"
	// might be thrown when calling ctx.fill or ctx.stroke after a path
	// whose area size is zero is drawn and ctx.clip() is called and
	// shadowBlur is set. See #4572, #3112, #5777.
	// (e.g.,
	//  ctx.moveTo(10, 10);
	//  ctx.lineTo(20, 10);
	//  ctx.closePath();
	//  ctx.clip();
	//  ctx.shadowBlur = 10;
	//  ...
	//  ctx.fill();
	// )
	var shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];
	
	function _default(orignalBrush) {
	  // version string can be: '11.0'
	  return env.browser.ie && env.browser.version >= 11 ? function () {
	    var clipPaths = this.__clipPaths;
	    var style = this.style;
	    var modified;
	
	    if (clipPaths) {
	      for (var i = 0; i < clipPaths.length; i++) {
	        var clipPath = clipPaths[i];
	        var shape = clipPath && clipPath.shape;
	        var type = clipPath && clipPath.type;
	
	        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {
	          for (var j = 0; j < shadowTemp.length; j++) {
	            // It is save to put shadowTemp static, because shadowTemp
	            // will be all modified each item brush called.
	            shadowTemp[j][2] = style[shadowTemp[j][0]];
	            style[shadowTemp[j][0]] = shadowTemp[j][1];
	          }
	
	          modified = true;
	          break;
	        }
	      }
	    }
	
	    orignalBrush.apply(this, arguments);
	
	    if (modified) {
	      for (var j = 0; j < shadowTemp.length; j++) {
	        style[shadowTemp[j][0]] = shadowTemp[j][2];
	      }
	    }
	  } : orignalBrush;
	}
	
	module.exports = _default;

/***/ }),
/* 49 */
/***/ (function(module, exports) {

	/**
	 * echarts设备环境识别
	 *
	 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
	 * @author firede[firede@firede.us]
	 * @desc thanks zepto.
	 */
	var env = {};
	
	if (typeof navigator === 'undefined') {
	  // In node
	  env = {
	    browser: {},
	    os: {},
	    node: true,
	    // Assume canvas is supported
	    canvasSupported: true,
	    svgSupported: true
	  };
	} else {
	  env = detect(navigator.userAgent);
	}
	
	var _default = env; // Zepto.js
	// (c) 2010-2013 Thomas Fuchs
	// Zepto.js may be freely distributed under the MIT license.
	
	function detect(ua) {
	  var os = {};
	  var browser = {}; // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
	  // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
	  // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	  // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	  // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
	  // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
	  // var touchpad = webos && ua.match(/TouchPad/);
	  // var kindle = ua.match(/Kindle\/([\d.]+)/);
	  // var silk = ua.match(/Silk\/([\d._]+)/);
	  // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
	  // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
	  // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
	  // var playbook = ua.match(/PlayBook/);
	  // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
	
	  var firefox = ua.match(/Firefox\/([\d.]+)/); // var safari = webkit && ua.match(/Mobile\//) && !chrome;
	  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
	
	  var ie = ua.match(/MSIE\s([\d.]+)/) // IE 11 Trident/7.0; rv:11.0
	  || ua.match(/Trident\/.+?rv:(([\d.]+))/);
	  var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+
	
	  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:
	  // - discern (more) between multiple browsers on android
	  // - decide if kindle fire in silk mode is android or not
	  // - Firefox on Android doesn't specify the Android version
	  // - possibly devide in os, device and browser hashes
	  // if (browser.webkit = !!webkit) browser.version = webkit[1];
	  // if (android) os.android = true, os.version = android[2];
	  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
	  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
	  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	  // if (webos) os.webos = true, os.version = webos[2];
	  // if (touchpad) os.touchpad = true;
	  // if (blackberry) os.blackberry = true, os.version = blackberry[2];
	  // if (bb10) os.bb10 = true, os.version = bb10[2];
	  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
	  // if (playbook) browser.playbook = true;
	  // if (kindle) os.kindle = true, os.version = kindle[1];
	  // if (silk) browser.silk = true, browser.version = silk[1];
	  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
	  // if (chrome) browser.chrome = true, browser.version = chrome[1];
	
	  if (firefox) {
	    browser.firefox = true;
	    browser.version = firefox[1];
	  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
	  // if (webview) browser.webview = true;
	
	
	  if (ie) {
	    browser.ie = true;
	    browser.version = ie[1];
	  }
	
	  if (edge) {
	    browser.edge = true;
	    browser.version = edge[1];
	  } // It is difficult to detect WeChat in Win Phone precisely, because ua can
	  // not be set on win phone. So we do not consider Win Phone.
	
	
	  if (weChat) {
	    browser.weChat = true;
	  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
	  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
	  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
	  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
	  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));
	
	
	  return {
	    browser: browser,
	    os: os,
	    node: false,
	    // 原生canvas支持，改极端点了
	    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
	    canvasSupported: !!document.createElement('canvas').getContext,
	    svgSupported: typeof SVGRect !== 'undefined',
	    // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
	    // works on most browsers
	    // IE10/11 does not support touch event, and MS Edge supports them but not by
	    // default, so we dont check navigator.maxTouchPoints for them here.
	    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
	    // <http://caniuse.com/#search=pointer%20event>.
	    pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer
	    // events currently. So we dont use that on other browsers unless tested sufficiently.
	    // Although IE 10 supports pointer event, it use old style and is different from the
	    // standard. So we exclude that. (IE 10 is hardly used on touch device)
	    && (browser.edge || browser.ie && browser.version >= 11)
	  };
	}
	
	module.exports = _default;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	/**
	 * 圆环
	 * @module zrender/graphic/shape/Ring
	 */
	var _default = Path.extend({
	  type: 'ring',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r: 0,
	    r0: 0
	  },
	  buildPath: function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var PI2 = Math.PI * 2;
	    ctx.moveTo(x + shape.r, y);
	    ctx.arc(x, y, shape.r, 0, PI2, false);
	    ctx.moveTo(x + shape.r0, y);
	    ctx.arc(x, y, shape.r0, 0, PI2, true);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	var polyHelper = __webpack_require__(52);
	
	/**
	 * 多边形
	 * @module zrender/shape/Polygon
	 */
	var _default = Path.extend({
	  type: 'polygon',
	  shape: {
	    points: null,
	    smooth: false,
	    smoothConstraint: null
	  },
	  buildPath: function (ctx, shape) {
	    polyHelper.buildPath(ctx, shape, true);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	var smoothSpline = __webpack_require__(53);
	
	var smoothBezier = __webpack_require__(54);
	
	function buildPath(ctx, shape, closePath) {
	  var points = shape.points;
	  var smooth = shape.smooth;
	
	  if (points && points.length >= 2) {
	    if (smooth && smooth !== 'spline') {
	      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
	      ctx.moveTo(points[0][0], points[0][1]);
	      var len = points.length;
	
	      for (var i = 0; i < (closePath ? len : len - 1); i++) {
	        var cp1 = controlPoints[i * 2];
	        var cp2 = controlPoints[i * 2 + 1];
	        var p = points[(i + 1) % len];
	        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
	      }
	    } else {
	      if (smooth === 'spline') {
	        points = smoothSpline(points, closePath);
	      }
	
	      ctx.moveTo(points[0][0], points[0][1]);
	
	      for (var i = 1, l = points.length; i < l; i++) {
	        ctx.lineTo(points[i][0], points[i][1]);
	      }
	    }
	
	    closePath && ctx.closePath();
	  }
	}
	
	exports.buildPath = buildPath;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	var _vector = __webpack_require__(14);
	
	var v2Distance = _vector.distance;
	
	/**
	 * Catmull-Rom spline 插值折线
	 * @module zrender/shape/util/smoothSpline
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	/**
	 * @inner
	 */
	function interpolate(p0, p1, p2, p3, t, t2, t3) {
	  var v0 = (p2 - p0) * 0.5;
	  var v1 = (p3 - p1) * 0.5;
	  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
	}
	/**
	 * @alias module:zrender/shape/util/smoothSpline
	 * @param {Array} points 线段顶点数组
	 * @param {boolean} isLoop
	 * @return {Array}
	 */
	
	
	function _default(points, isLoop) {
	  var len = points.length;
	  var ret = [];
	  var distance = 0;
	
	  for (var i = 1; i < len; i++) {
	    distance += v2Distance(points[i - 1], points[i]);
	  }
	
	  var segs = distance / 2;
	  segs = segs < len ? len : segs;
	
	  for (var i = 0; i < segs; i++) {
	    var pos = i / (segs - 1) * (isLoop ? len : len - 1);
	    var idx = Math.floor(pos);
	    var w = pos - idx;
	    var p0;
	    var p1 = points[idx % len];
	    var p2;
	    var p3;
	
	    if (!isLoop) {
	      p0 = points[idx === 0 ? idx : idx - 1];
	      p2 = points[idx > len - 2 ? len - 1 : idx + 1];
	      p3 = points[idx > len - 3 ? len - 1 : idx + 2];
	    } else {
	      p0 = points[(idx - 1 + len) % len];
	      p2 = points[(idx + 1) % len];
	      p3 = points[(idx + 2) % len];
	    }
	
	    var w2 = w * w;
	    var w3 = w * w2;
	    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
	  }
	
	  return ret;
	}
	
	module.exports = _default;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	var _vector = __webpack_require__(14);
	
	var v2Min = _vector.min;
	var v2Max = _vector.max;
	var v2Scale = _vector.scale;
	var v2Distance = _vector.distance;
	var v2Add = _vector.add;
	var v2Clone = _vector.clone;
	var v2Sub = _vector.sub;
	
	/**
	 * 贝塞尔平滑曲线
	 * @module zrender/shape/util/smoothBezier
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	/**
	 * 贝塞尔平滑曲线
	 * @alias module:zrender/shape/util/smoothBezier
	 * @param {Array} points 线段顶点数组
	 * @param {number} smooth 平滑等级, 0-1
	 * @param {boolean} isLoop
	 * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
	 *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
	 *                           整个折线的包围盒做一个并集用来约束控制点。
	 * @param {Array} 计算出来的控制点数组
	 */
	function _default(points, smooth, isLoop, constraint) {
	  var cps = [];
	  var v = [];
	  var v1 = [];
	  var v2 = [];
	  var prevPoint;
	  var nextPoint;
	  var min, max;
	
	  if (constraint) {
	    min = [Infinity, Infinity];
	    max = [-Infinity, -Infinity];
	
	    for (var i = 0, len = points.length; i < len; i++) {
	      v2Min(min, min, points[i]);
	      v2Max(max, max, points[i]);
	    } // 与指定的包围盒做并集
	
	
	    v2Min(min, min, constraint[0]);
	    v2Max(max, max, constraint[1]);
	  }
	
	  for (var i = 0, len = points.length; i < len; i++) {
	    var point = points[i];
	
	    if (isLoop) {
	      prevPoint = points[i ? i - 1 : len - 1];
	      nextPoint = points[(i + 1) % len];
	    } else {
	      if (i === 0 || i === len - 1) {
	        cps.push(v2Clone(points[i]));
	        continue;
	      } else {
	        prevPoint = points[i - 1];
	        nextPoint = points[i + 1];
	      }
	    }
	
	    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length
	
	    v2Scale(v, v, smooth);
	    var d0 = v2Distance(point, prevPoint);
	    var d1 = v2Distance(point, nextPoint);
	    var sum = d0 + d1;
	
	    if (sum !== 0) {
	      d0 /= sum;
	      d1 /= sum;
	    }
	
	    v2Scale(v1, v, -d0);
	    v2Scale(v2, v, d1);
	    var cp0 = v2Add([], point, v1);
	    var cp1 = v2Add([], point, v2);
	
	    if (constraint) {
	      v2Max(cp0, cp0, min);
	      v2Min(cp0, cp0, max);
	      v2Max(cp1, cp1, min);
	      v2Min(cp1, cp1, max);
	    }
	
	    cps.push(cp0);
	    cps.push(cp1);
	  }
	
	  if (isLoop) {
	    cps.push(cps.shift());
	  }
	
	  return cps;
	}
	
	module.exports = _default;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	var polyHelper = __webpack_require__(52);
	
	/**
	 * @module zrender/graphic/shape/Polyline
	 */
	var _default = Path.extend({
	  type: 'polyline',
	  shape: {
	    points: null,
	    smooth: false,
	    smoothConstraint: null
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    polyHelper.buildPath(ctx, shape, false);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	var roundRectHelper = __webpack_require__(28);
	
	/**
	 * 矩形
	 * @module zrender/graphic/shape/Rect
	 */
	var _default = Path.extend({
	  type: 'rect',
	  shape: {
	    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
	    // r缩写为1         相当于 [1, 1, 1, 1]
	    // r缩写为[1]       相当于 [1, 1, 1, 1]
	    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
	    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
	    r: 0,
	    x: 0,
	    y: 0,
	    width: 0,
	    height: 0
	  },
	  buildPath: function (ctx, shape) {
	    var x = shape.x;
	    var y = shape.y;
	    var width = shape.width;
	    var height = shape.height;
	
	    if (!shape.r) {
	      ctx.rect(x, y, width, height);
	    } else {
	      roundRectHelper.buildPath(ctx, shape);
	    }
	
	    ctx.closePath();
	    return;
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	/**
	 * 直线
	 * @module zrender/graphic/shape/Line
	 */
	var _default = Path.extend({
	  type: 'line',
	  shape: {
	    // Start point
	    x1: 0,
	    y1: 0,
	    // End point
	    x2: 0,
	    y2: 0,
	    percent: 1
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    var x1 = shape.x1;
	    var y1 = shape.y1;
	    var x2 = shape.x2;
	    var y2 = shape.y2;
	    var percent = shape.percent;
	
	    if (percent === 0) {
	      return;
	    }
	
	    ctx.moveTo(x1, y1);
	
	    if (percent < 1) {
	      x2 = x1 * (1 - percent) + x2 * percent;
	      y2 = y1 * (1 - percent) + y2 * percent;
	    }
	
	    ctx.lineTo(x2, y2);
	  },
	
	  /**
	   * Get point at percent
	   * @param  {number} percent
	   * @return {Array.<number>}
	   */
	  pointAt: function (p) {
	    var shape = this.shape;
	    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	var vec2 = __webpack_require__(14);
	
	var _curve = __webpack_require__(30);
	
	var quadraticSubdivide = _curve.quadraticSubdivide;
	var cubicSubdivide = _curve.cubicSubdivide;
	var quadraticAt = _curve.quadraticAt;
	var cubicAt = _curve.cubicAt;
	var quadraticDerivativeAt = _curve.quadraticDerivativeAt;
	var cubicDerivativeAt = _curve.cubicDerivativeAt;
	
	/**
	 * 贝塞尔曲线
	 * @module zrender/shape/BezierCurve
	 */
	var out = [];
	
	function someVectorAt(shape, t, isTangent) {
	  var cpx2 = shape.cpx2;
	  var cpy2 = shape.cpy2;
	
	  if (cpx2 === null || cpy2 === null) {
	    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
	  } else {
	    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];
	  }
	}
	
	var _default = Path.extend({
	  type: 'bezier-curve',
	  shape: {
	    x1: 0,
	    y1: 0,
	    x2: 0,
	    y2: 0,
	    cpx1: 0,
	    cpy1: 0,
	    // cpx2: 0,
	    // cpy2: 0
	    // Curve show percent, for animating
	    percent: 1
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    var x1 = shape.x1;
	    var y1 = shape.y1;
	    var x2 = shape.x2;
	    var y2 = shape.y2;
	    var cpx1 = shape.cpx1;
	    var cpy1 = shape.cpy1;
	    var cpx2 = shape.cpx2;
	    var cpy2 = shape.cpy2;
	    var percent = shape.percent;
	
	    if (percent === 0) {
	      return;
	    }
	
	    ctx.moveTo(x1, y1);
	
	    if (cpx2 == null || cpy2 == null) {
	      if (percent < 1) {
	        quadraticSubdivide(x1, cpx1, x2, percent, out);
	        cpx1 = out[1];
	        x2 = out[2];
	        quadraticSubdivide(y1, cpy1, y2, percent, out);
	        cpy1 = out[1];
	        y2 = out[2];
	      }
	
	      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
	    } else {
	      if (percent < 1) {
	        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
	        cpx1 = out[1];
	        cpx2 = out[2];
	        x2 = out[3];
	        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
	        cpy1 = out[1];
	        cpy2 = out[2];
	        y2 = out[3];
	      }
	
	      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
	    }
	  },
	
	  /**
	   * Get point at percent
	   * @param  {number} t
	   * @return {Array.<number>}
	   */
	  pointAt: function (t) {
	    return someVectorAt(this.shape, t, false);
	  },
	
	  /**
	   * Get tangent at percent
	   * @param  {number} t
	   * @return {Array.<number>}
	   */
	  tangentAt: function (t) {
	    var p = someVectorAt(this.shape, t, true);
	    return vec2.normalize(p, p);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	var Path = __webpack_require__(6);
	
	/**
	 * 圆弧
	 * @module zrender/graphic/shape/Arc
	 */
	var _default = Path.extend({
	  type: 'arc',
	  shape: {
	    cx: 0,
	    cy: 0,
	    r: 0,
	    startAngle: 0,
	    endAngle: Math.PI * 2,
	    clockwise: true
	  },
	  style: {
	    stroke: '#000',
	    fill: null
	  },
	  buildPath: function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var r = Math.max(shape.r, 0);
	    var startAngle = shape.startAngle;
	    var endAngle = shape.endAngle;
	    var clockwise = shape.clockwise;
	    var unitX = Math.cos(startAngle);
	    var unitY = Math.sin(startAngle);
	    ctx.moveTo(unitX * r + x, unitY * r + y);
	    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	  }
	});
	
	module.exports = _default;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(4);
	
	var Gradient = __webpack_require__(41);
	
	/**
	 * x, y, x2, y2 are all percent from 0 to 1
	 * @param {number} [x=0]
	 * @param {number} [y=0]
	 * @param {number} [x2=1]
	 * @param {number} [y2=0]
	 * @param {Array.<Object>} colorStops
	 * @param {boolean} [globalCoord=false]
	 */
	var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
	  // Should do nothing more in this constructor. Because gradient can be
	  // declard by `color: {type: 'linear', colorStops: ...}`, where
	  // this constructor will not be called.
	  this.x = x == null ? 0 : x;
	  this.y = y == null ? 0 : y;
	  this.x2 = x2 == null ? 1 : x2;
	  this.y2 = y2 == null ? 0 : y2; // Can be cloned
	
	  this.type = 'linear'; // If use global coord
	
	  this.global = globalCoord || false;
	  Gradient.call(this, colorStops);
	};
	
	LinearGradient.prototype = {
	  constructor: LinearGradient
	};
	zrUtil.inherits(LinearGradient, Gradient);
	var _default = LinearGradient;
	module.exports = _default;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(4);
	
	var Gradient = __webpack_require__(41);
	
	/**
	 * x, y, r are all percent from 0 to 1
	 * @param {number} [x=0.5]
	 * @param {number} [y=0.5]
	 * @param {number} [r=0.5]
	 * @param {Array.<Object>} [colorStops]
	 * @param {boolean} [globalCoord=false]
	 */
	var RadialGradient = function (x, y, r, colorStops, globalCoord) {
	  // Should do nothing more in this constructor. Because gradient can be
	  // declard by `color: {type: 'radial', colorStops: ...}`, where
	  // this constructor will not be called.
	  this.x = x == null ? 0.5 : x;
	  this.y = y == null ? 0.5 : y;
	  this.r = r == null ? 0.5 : r; // Can be cloned
	
	  this.type = 'radial'; // If use global coord
	
	  this.global = globalCoord || false;
	  Gradient.call(this, colorStops);
	};
	
	RadialGradient.prototype = {
	  constructor: RadialGradient
	};
	zrUtil.inherits(RadialGradient, Gradient);
	var _default = RadialGradient;
	module.exports = _default;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	var zrUtil = __webpack_require__(4);
	
	var Style = __webpack_require__(8);
	
	var _vector = __webpack_require__(14);
	
	var vec2Copy = _vector.copy;
	
	/**
	 * States machine for managing graphic states
	 */
	
	/**
	 * @typedef {Object} IGraphicState
	 * @property {number} [zlevel]
	 * @property {number} [z]
	 * @property {Array.<number>} {position}
	 * @property {Array.<number>|number} {rotation}
	 * @property {Array.<number>} {scale}
	 * @property {Object} style
	 *
	 * @property {Function} onenter
	 * @property {Function} onleave
	 * @property {Function} ontransition
	 * @property {Array.<IGraphicStateTransition|string>} transition
	 *           Transition object or a string descriptor like '* 30 0 Linear'
	 */
	var transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];
	/**
	 * @module zrender/graphic/States~TransitionObject
	 */
	
	var TransitionObject = function (opts) {
	  if (typeof opts == 'string') {
	    this._fromStr(opts);
	  } else if (opts) {
	    opts.property && (this.property = opts.property);
	    opts.duration != null && (this.duration = opts.duration);
	    opts.easing && (this.easing = opts.easing);
	    opts.delay && (this.delay = opts.delay);
	  }
	
	  if (this.property !== '*') {
	    this.property = this.property.split(',');
	  } else {
	    this.property = transitionProperties;
	  }
	};
	
	TransitionObject.prototype = {
	  constructor: TransitionObject,
	
	  /**
	   * List of all transition properties. Splitted by comma. Must not have spaces in the string.
	   * e.g. 'position,style.color'. '*' will match all the valid properties.
	   * @type {string}
	   * @default *
	   */
	  property: '*',
	
	  /**
	   * @type {string}
	   * @default 'Linear'
	   */
	  easing: 'Linear',
	
	  /**
	   * @type {number}
	   * @default 'number'
	   */
	  duration: 500,
	
	  /**
	   * @type {number}
	   */
	  delay: 0,
	  _fromStr: function (str) {
	    var arr = str.split(/\s+/g);
	    this.property = arr[0];
	    this.duration = +arr[1];
	    this.delay = +arr[2];
	    this.easing = arr[3];
	  }
	};
	/**
	 * @alias module:zrender/graphic/States
	 */
	
	var GraphicStates = function (opts) {
	  opts = opts || {};
	  this._states = {};
	  /**
	   * Target element
	   * @type {zrender/graphic/Displayable|zrender/container/Group}
	   */
	
	  this._el = opts.el;
	  this._subStates = [];
	  this._transitionAnimators = [];
	
	  if (opts.initialState) {
	    this._initialState = opts.initialState;
	  }
	
	  var optsStates = opts.states;
	
	  if (optsStates) {
	    for (var name in optsStates) {
	      if (optsStates.hasOwnProperty(name)) {
	        var state = optsStates[name];
	
	        this._addState(name, state);
	      }
	    }
	  }
	
	  this.setState(this._initialState);
	};
	
	GraphicStates.prototype = {
	  constructor: GraphicStates,
	
	  /**
	   * All other state will be extended from initial state
	   * @type {string}
	   * @private
	   */
	  _initialState: 'normal',
	
	  /**
	   * Current state
	   * @type {string}
	   * @private
	   */
	  _currentState: '',
	  el: function () {
	    return this._el;
	  },
	  _addState: function (name, state) {
	    this._states[name] = state;
	
	    if (state.transition) {
	      state.transition = new TransitionObject(state.transition);
	    } // Extend from initial state
	
	
	    if (name !== this._initialState) {
	      this._extendFromInitial(state);
	    } else {
	      var el = this._el; // setState 的时候自带的 style 和 shape 都会被直接覆盖
	      // 所以这边先把自带的 style 和 shape 扩展到初始状态中
	
	      zrUtil.merge(state.style, el.style, false, false);
	
	      if (state.shape) {
	        zrUtil.merge(state.shape, el.shape, false, true);
	      } else {
	        state.shape = zrUtil.clone(el.shape, true);
	      }
	
	      for (var name in this._states) {
	        if (this._states.hasOwnProperty(name)) {
	          this._extendFromInitial(this._states[name]);
	        }
	      }
	    }
	  },
	  _extendFromInitial: function (state) {
	    var initialState = this._states[this._initialState];
	
	    if (initialState && state !== initialState) {
	      zrUtil.merge(state, initialState, false, true);
	    }
	  },
	  setState: function (name, silent) {
	    if (name === this._currentState && !this.transiting()) {
	      return;
	    }
	
	    var state = this._states[name];
	
	    if (state) {
	      this._stopTransition();
	
	      if (!silent) {
	        var prevState = this._states[this._currentState];
	
	        if (prevState) {
	          prevState.onleave && prevState.onleave.call(this);
	        }
	
	        state.onenter && state.onenter.call(this);
	      }
	
	      this._currentState = name;
	
	      if (this._el) {
	        var el = this._el; // Setting attributes
	
	        if (state.zlevel != null) {
	          el.zlevel = state.zlevel;
	        }
	
	        if (state.z != null) {
	          el.z = state.z;
	        } // SRT
	
	
	        state.position && vec2Copy(el.position, state.position);
	        state.scale && vec2Copy(el.scale, state.scale);
	
	        if (state.rotation != null) {
	          el.rotation = state.rotation;
	        } // Style
	
	
	        if (state.style) {
	          var initialState = this._states[this._initialState];
	          el.style = new Style();
	
	          if (initialState) {
	            el.style.extendFrom(initialState.style, false);
	          }
	
	          if ( // Not initial state
	          name != this._initialState // Not copied from initial state in _extendFromInitial method
	          && initialState.style !== state.style) {
	            el.style.extendFrom(state.style, true);
	          }
	        }
	
	        if (state.shape) {
	          el.shape = zrUtil.clone(state.shape, true);
	        }
	
	        el.dirty();
	      }
	    }
	
	    for (var i = 0; i < this._subStates.length; i++) {
	      this._subStates.setState(name);
	    }
	  },
	  getState: function () {
	    return this._currentState;
	  },
	  transitionState: function (target, done) {
	    if (target === this._currentState && !this.transiting()) {
	      return;
	    }
	
	    var state = this._states[target];
	    var styleShapeReg = /$[style|shape]\./;
	    var self = this; // Animation 去重
	
	    var propPathMap = {};
	
	    if (state) {
	      self._stopTransition();
	
	      var el = self._el;
	
	      if (state.transition && el && el.__zr) {
	        // El can be animated
	        var transitionCfg = state.transition;
	        var property = transitionCfg.property;
	        var animatingCount = 0;
	
	        var animationDone = function () {
	          animatingCount--;
	
	          if (animatingCount === 0) {
	            self.setState(target);
	            done && done();
	          }
	        };
	
	        for (var i = 0; i < property.length; i++) {
	          var propName = property[i]; // Animating all the properties in style or shape
	
	          if (propName === 'style' || propName === 'shape') {
	            if (state[propName]) {
	              for (var key in state[propName]) {
	                if (!state[propName].hasOwnProperty(key)) {
	                  continue;
	                }
	
	                var path = propName + '.' + key;
	
	                if (propPathMap[path]) {
	                  continue;
	                }
	
	                propPathMap[path] = 1;
	                animatingCount += self._animProp(state, propName, key, transitionCfg, animationDone);
	              }
	            }
	          } else {
	            if (propPathMap[propName]) {
	              continue;
	            }
	
	            propPathMap[propName] = 1; // Animating particular property in style or style
	
	            if (propName.match(styleShapeReg)) {
	              // remove 'style.', 'shape.' prefix
	              var subProp = propName.slice(0, 5);
	              propName = propName.slice(6);
	              animatingCount += self._animProp(state, subProp, propName, transitionCfg, animationDone);
	            } else {
	              animatingCount += self._animProp(state, '', propName, transitionCfg, animationDone);
	            }
	          }
	        } // No transition properties
	
	
	        if (animatingCount === 0) {
	          self.setState(target);
	          done && done();
	        }
	      } else {
	        self.setState(target);
	        done && done();
	      }
	    }
	
	    var subStates = self._subStates;
	
	    for (var i = 0; i < subStates.length; i++) {
	      subStates.transitionState(target);
	    }
	  },
	
	  /**
	   * Do transition animation of particular property
	   * @param {Object} state
	   * @param {string} subPropKey
	   * @param {string} key
	   * @param {Object} transitionCfg
	   * @param {Function} done
	   * @private
	   */
	  _animProp: function (state, subPropKey, key, transitionCfg, done) {
	    var el = this._el;
	    var stateObj = subPropKey ? state[subPropKey] : state;
	    var elObj = subPropKey ? el[subPropKey] : el;
	    var availableProp = stateObj && key in stateObj && elObj && key in elObj;
	    var transitionAnimators = this._transitionAnimators;
	
	    if (availableProp) {
	      var obj = {};
	
	      if (stateObj[key] === elObj[key]) {
	        return 0;
	      }
	
	      obj[key] = stateObj[key];
	      var animator = el.animate(subPropKey).when(transitionCfg.duration, obj).delay(transitionCfg.dealy).done(function () {
	        var idx = zrUtil.indexOf(transitionAnimators, 1);
	
	        if (idx > 0) {
	          transitionAnimators.splice(idx, 1);
	        }
	
	        done();
	      }).start(transitionCfg.easing);
	      transitionAnimators.push(animator);
	      return 1;
	    }
	
	    return 0;
	  },
	  _stopTransition: function () {
	    var transitionAnimators = this._transitionAnimators;
	
	    for (var i = 0; i < transitionAnimators.length; i++) {
	      transitionAnimators[i].stop();
	    }
	
	    transitionAnimators.length = 0;
	  },
	  transiting: function () {
	    return this._transitionAnimators.length > 0;
	  },
	  addSubStates: function (states) {
	    this._subStates.push(states);
	  },
	  removeSubStates: function (states) {
	    var idx = zrUtil.indexOf(this._subStates, states);
	
	    if (idx >= 0) {
	      this._subStates.splice(states, 1);
	    }
	  }
	};
	var _default = GraphicStates;
	module.exports = _default;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var apiList = [
	        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',
	        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',
	        "remove", "_getParentZr"
	    ];
	
	    function ExtensionAPI(instance) {
	        zrUtil.each(apiList, function (name) {
	            this[name] = zrUtil.bind(instance[name], instance);
	        }, this);
	    }
	
	    module.exports = ExtensionAPI;
	


/***/ }),
/* 64 */
/***/ (function(module, exports) {

	
	
	    /**
	      * Creates an instance of Point
	      *
	      *
	      * @constructor
	      * @this {Point}
	      * @param {Number} x The x coordinate of point.
	      * @param {Number} y The y coordinate of point.
	      * Note: Even if it is named Point this class should be named Dot as Dot is closer
	      * then Point from math perspective.
	      **/
	    function Point(x, y){
	        /**The x coordinate of point*/
	        this.x = x;
	
	        /**The y coordinate of point*/
	        this.y = y;
	
	
	    }
	
	    /**Creates a {Point} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Point} a newly constructed Point
	     **/
	    Point.load = function(o){
	        var newPoint = new Point(Number(o.x), Number(o.y));
	        return newPoint;
	    };
	
	
	    /**Creates an array of points from an array of {JSONObject}s
	     *@param {Array} v - the array of JSONObjects
	     *@return an {Array} of {Point}s
	     **/
	    Point.loadArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(Point.load(v[i]));
	        }
	        return newPoints;
	    };
	
	
	    /**Clones an array of points
	     *@param {Array} v - the array of {Point}s
	     *@return an {Array} of {Point}s
	     **/
	    Point.cloneArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(v[i].clone());
	        }
	        return newPoints;
	    };
	
	    Point.prototype = {
	        constructor : Point,
	
	        transform:function(matrix){
	            var oldX = this.x;
	            var oldY = this.y;
	            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];
	            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];
	        },
	
	        /**Tests if this point is similar to other point
	         *@param {Point} anotherPoint - the other point
	         **/
	        equals:function(anotherPoint){
	            if(! (anotherPoint instanceof Point) ){
	                return false;
	            }
	            return (this.x == anotherPoint.x)
	            && (this.y == anotherPoint.y)
	        },
	
	        /**Clone current Point
	         **/
	        clone: function(){
	            var newPoint = new Point(this.x, this.y);
	            return newPoint;
	        },
	
	        add: function(point) {
	            this.x = this.x + point.x;
	            this.y = this.y + point.y;
	            return this;
	        },
	
	        /**Tests to see if a point (x, y) is within a range of current Point
	         *@param {Numeric} x - the x coordinate of tested point
	         *@param {Numeric} y - the x coordinate of tested point
	         *@param {Numeric} radius - the radius of the vicinity
	         **/
	        near:function(x, y, radius){
	            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));
	
	            return (distance <= radius);
	        },
	
	        contains: function(x,y){
	            return this.x == x && this.y == y;
	        },
	
	        toString:function(){
	            return '[' + this.x + ',' + this.y + ']';
	        },
	
	        getPoints:function(){
	            return [this];
	        }
	    };
	    module.exports = Point;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	var guid = __webpack_require__(10);
	
	var env = __webpack_require__(49);
	
	var zrUtil = __webpack_require__(4);
	
	var Handler = __webpack_require__(66);
	
	var Storage = __webpack_require__(67);
	
	var Painter = __webpack_require__(69);
	
	var Animation = __webpack_require__(72);
	
	var HandlerProxy = __webpack_require__(74);
	
	/*!
	* ZRender, a high performance 2d drawing library.
	*
	* Copyright (c) 2013, Baidu Inc.
	* All rights reserved.
	*
	* LICENSE
	* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	*/
	var useVML = !env.canvasSupported;
	var painterCtors = {
	  canvas: Painter
	};
	var instances = {}; // ZRender实例map索引
	
	/**
	 * @type {string}
	 */
	
	var version = '3.7.4';
	/**
	 * Initializing a zrender instance
	 * @param {HTMLElement} dom
	 * @param {Object} opts
	 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	 * @param {number} [opts.devicePixelRatio]
	 * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
	 * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
	 * @return {module:zrender/ZRender}
	 */
	
	function init(dom, opts) {
	  var zr = new ZRender(guid(), dom, opts);
	  instances[zr.id] = zr;
	  return zr;
	}
	/**
	 * Dispose zrender instance
	 * @param {module:zrender/ZRender} zr
	 */
	
	
	function dispose(zr) {
	  if (zr) {
	    zr.dispose();
	  } else {
	    for (var key in instances) {
	      if (instances.hasOwnProperty(key)) {
	        instances[key].dispose();
	      }
	    }
	
	    instances = {};
	  }
	
	  return this;
	}
	/**
	 * Get zrender instance by id
	 * @param {string} id zrender instance id
	 * @return {module:zrender/ZRender}
	 */
	
	
	function getInstance(id) {
	  return instances[id];
	}
	
	function registerPainter(name, Ctor) {
	  painterCtors[name] = Ctor;
	}
	
	function delInstance(id) {
	  delete instances[id];
	}
	/**
	 * @module zrender/ZRender
	 */
	
	/**
	 * @constructor
	 * @alias module:zrender/ZRender
	 * @param {string} id
	 * @param {HTMLElement} dom
	 * @param {Object} opts
	 * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	 * @param {number} [opts.devicePixelRatio]
	 * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
	 * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
	 */
	
	
	var ZRender = function (id, dom, opts) {
	  opts = opts || {};
	  /**
	   * @type {HTMLDomElement}
	   */
	
	  this.dom = dom;
	  /**
	   * @type {string}
	   */
	
	  this.id = id;
	  var self = this;
	  var storage = new Storage();
	  var rendererType = opts.renderer; // TODO WebGL
	
	  if (useVML) {
	    if (!painterCtors.vml) {
	      throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
	    }
	
	    rendererType = 'vml';
	  } else if (!rendererType || !painterCtors[rendererType]) {
	    rendererType = 'canvas';
	  }
	
	  var painter = new painterCtors[rendererType](dom, storage, opts);
	  this.storage = storage;
	  this.painter = painter;
	  var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;
	  this.handler = new Handler(storage, painter, handerProxy, painter.root);
	  /**
	   * @type {module:zrender/animation/Animation}
	   */
	
	  this.animation = new Animation({
	    stage: {
	      update: zrUtil.bind(this.flush, this)
	    }
	  });
	  this.animation.start();
	  /**
	   * @type {boolean}
	   * @private
	   */
	
	  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画
	  // FIXME 有点ugly
	
	  var oldDelFromStorage = storage.delFromStorage;
	  var oldAddToStorage = storage.addToStorage;
	
	  storage.delFromStorage = function (el) {
	    oldDelFromStorage.call(storage, el);
	    el && el.removeSelfFromZr(self);
	  };
	
	  storage.addToStorage = function (el) {
	    oldAddToStorage.call(storage, el);
	    el.addSelfToZr(self);
	  };
	};
	
	ZRender.prototype = {
	  constructor: ZRender,
	
	  /**
	   * 获取实例唯一标识
	   * @return {string}
	   */
	  getId: function () {
	    return this.id;
	  },
	
	  /**
	   * 添加元素
	   * @param  {module:zrender/Element} el
	   */
	  add: function (el) {
	    this.storage.addRoot(el);
	    this._needsRefresh = true;
	  },
	
	  /**
	   * 删除元素
	   * @param  {module:zrender/Element} el
	   */
	  remove: function (el) {
	    this.storage.delRoot(el);
	    this._needsRefresh = true;
	  },
	
	  /**
	   * Change configuration of layer
	   * @param {string} zLevel
	   * @param {Object} config
	   * @param {string} [config.clearColor=0] Clear color
	   * @param {string} [config.motionBlur=false] If enable motion blur
	   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
	  */
	  configLayer: function (zLevel, config) {
	    this.painter.configLayer(zLevel, config);
	    this._needsRefresh = true;
	  },
	
	  /**
	   * Repaint the canvas immediately
	   */
	  refreshImmediately: function () {
	    // var start = new Date();
	    // Clear needsRefresh ahead to avoid something wrong happens in refresh
	    // Or it will cause zrender refreshes again and again.
	    this._needsRefresh = false;
	    this.painter.refresh();
	    /**
	     * Avoid trigger zr.refresh in Element#beforeUpdate hook
	     */
	
	    this._needsRefresh = false; // var end = new Date();
	    // var log = document.getElementById('log');
	    // if (log) {
	    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);
	    // }
	  },
	
	  /**
	   * Mark and repaint the canvas in the next frame of browser
	   */
	  refresh: function () {
	    this._needsRefresh = true;
	  },
	
	  /**
	   * Perform all refresh
	   */
	  flush: function () {
	    if (this._needsRefresh) {
	      this.refreshImmediately();
	    }
	
	    if (this._needsRefreshHover) {
	      this.refreshHoverImmediately();
	    }
	  },
	
	  /**
	   * Add element to hover layer
	   * @param  {module:zrender/Element} el
	   * @param {Object} style
	   */
	  addHover: function (el, style) {
	    if (this.painter.addHover) {
	      this.painter.addHover(el, style);
	      this.refreshHover();
	    }
	  },
	
	  /**
	   * Add element from hover layer
	   * @param  {module:zrender/Element} el
	   */
	  removeHover: function (el) {
	    if (this.painter.removeHover) {
	      this.painter.removeHover(el);
	      this.refreshHover();
	    }
	  },
	
	  /**
	   * Clear all hover elements in hover layer
	   * @param  {module:zrender/Element} el
	   */
	  clearHover: function () {
	    if (this.painter.clearHover) {
	      this.painter.clearHover();
	      this.refreshHover();
	    }
	  },
	
	  /**
	   * Refresh hover in next frame
	   */
	  refreshHover: function () {
	    this._needsRefreshHover = true;
	  },
	
	  /**
	   * Refresh hover immediately
	   */
	  refreshHoverImmediately: function () {
	    this._needsRefreshHover = false;
	    this.painter.refreshHover && this.painter.refreshHover();
	  },
	
	  /**
	   * Resize the canvas.
	   * Should be invoked when container size is changed
	   * @param {Object} [opts]
	   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
	   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
	   */
	  resize: function (opts) {
	    opts = opts || {};
	    this.painter.resize(opts.width, opts.height);
	    this.handler.resize();
	  },
	
	  /**
	   * Stop and clear all animation immediately
	   */
	  clearAnimation: function () {
	    this.animation.clear();
	  },
	
	  /**
	   * Get container width
	   */
	  getWidth: function () {
	    return this.painter.getWidth();
	  },
	
	  /**
	   * Get container height
	   */
	  getHeight: function () {
	    return this.painter.getHeight();
	  },
	
	  /**
	   * Export the canvas as Base64 URL
	   * @param {string} type
	   * @param {string} [backgroundColor='#fff']
	   * @return {string} Base64 URL
	   */
	  // toDataURL: function(type, backgroundColor) {
	  //     return this.painter.getRenderedCanvas({
	  //         backgroundColor: backgroundColor
	  //     }).toDataURL(type);
	  // },
	
	  /**
	   * Converting a path to image.
	   * It has much better performance of drawing image rather than drawing a vector path.
	   * @param {module:zrender/graphic/Path} e
	   * @param {number} width
	   * @param {number} height
	   */
	  pathToImage: function (e, dpr) {
	    return this.painter.pathToImage(e, dpr);
	  },
	
	  /**
	   * Set default cursor
	   * @param {string} [cursorStyle='default'] 例如 crosshair
	   */
	  setCursorStyle: function (cursorStyle) {
	    this.handler.setCursorStyle(cursorStyle);
	  },
	
	  /**
	   * Find hovered element
	   * @param {number} x
	   * @param {number} y
	   * @return {Object} {target, topTarget}
	   */
	  findHover: function (x, y) {
	    return this.handler.findHover(x, y);
	  },
	
	  /**
	   * Bind event
	   *
	   * @param {string} eventName Event name
	   * @param {Function} eventHandler Handler function
	   * @param {Object} [context] Context object
	   */
	  on: function (eventName, eventHandler, context) {
	    this.handler.on(eventName, eventHandler, context);
	  },
	
	  /**
	   * Unbind event
	   * @param {string} eventName Event name
	   * @param {Function} [eventHandler] Handler function
	   */
	  off: function (eventName, eventHandler) {
	    this.handler.off(eventName, eventHandler);
	  },
	
	  /**
	   * Trigger event manually
	   *
	   * @param {string} eventName Event name
	   * @param {event=} event Event object
	   */
	  trigger: function (eventName, event) {
	    this.handler.trigger(eventName, event);
	  },
	
	  /**
	   * Clear all objects and the canvas.
	   */
	  clear: function () {
	    this.storage.delRoot();
	    this.painter.clear();
	  },
	
	  /**
	   * Dispose self.
	   */
	  dispose: function () {
	    this.animation.stop();
	    this.clear();
	    this.storage.dispose();
	    this.painter.dispose();
	    this.handler.dispose();
	    this.animation = this.storage = this.painter = this.handler = null;
	    delInstance(this.id);
	  }
	};
	exports.version = version;
	exports.init = init;
	exports.dispose = dispose;
	exports.getInstance = getInstance;
	exports.registerPainter = registerPainter;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(4);
	
	var vec2 = __webpack_require__(14);
	
	var Draggable = __webpack_require__(42);
	
	var Eventful = __webpack_require__(11);
	
	/**
	 * Handler
	 * @module zrender/Handler
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (shenyi.914@gmail.com)
	 */
	var SILENT = 'silent';
	
	function makeEventPacket(eveType, targetInfo, event) {
	  return {
	    type: eveType,
	    event: event,
	    // target can only be an element that is not silent.
	    target: targetInfo.target,
	    // topTarget can be a silent element.
	    topTarget: targetInfo.topTarget,
	    cancelBubble: false,
	    offsetX: event.zrX,
	    offsetY: event.zrY,
	    gestureEvent: event.gestureEvent,
	    pinchX: event.pinchX,
	    pinchY: event.pinchY,
	    pinchScale: event.pinchScale,
	    wheelDelta: event.zrDelta,
	    zrByTouch: event.zrByTouch,
	    which: event.which
	  };
	}
	
	function EmptyProxy() {}
	
	EmptyProxy.prototype.dispose = function () {};
	
	var handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
	/**
	 * @alias module:zrender/Handler
	 * @constructor
	 * @extends module:zrender/mixin/Eventful
	 * @param {module:zrender/Storage} storage Storage instance.
	 * @param {module:zrender/Painter} painter Painter instance.
	 * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
	 * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
	 */
	
	var Handler = function (storage, painter, proxy, painterRoot) {
	  Eventful.call(this);
	  this.storage = storage;
	  this.painter = painter;
	  this.painterRoot = painterRoot;
	  proxy = proxy || new EmptyProxy();
	  /**
	   * Proxy of event. can be Dom, WebGLSurface, etc.
	   */
	
	  this.proxy = proxy; // Attach handler
	
	  proxy.handler = this;
	  /**
	   * {target, topTarget, x, y}
	   * @private
	   * @type {Object}
	   */
	
	  this._hovered = {};
	  /**
	   * @private
	   * @type {Date}
	   */
	
	  this._lastTouchMoment;
	  /**
	   * @private
	   * @type {number}
	   */
	
	  this._lastX;
	  /**
	   * @private
	   * @type {number}
	   */
	
	  this._lastY;
	  Draggable.call(this);
	  util.each(handlerNames, function (name) {
	    proxy.on && proxy.on(name, this[name], this);
	  }, this);
	};
	
	Handler.prototype = {
	  constructor: Handler,
	  mousemove: function (event) {
	    var x = event.zrX;
	    var y = event.zrY;
	    var lastHovered = this._hovered;
	    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call
	    // (like 'setOption' or 'dispatchAction') in event handlers, we should find
	    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.
	    // See #6198.
	
	    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
	      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
	      lastHoveredTarget = lastHovered.target;
	    }
	
	    var hovered = this._hovered = this.findHover(x, y);
	    var hoveredTarget = hovered.target;
	    var proxy = this.proxy;
	    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element
	
	    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
	      this.dispatchToElement(lastHovered, 'mouseout', event);
	    } // Mouse moving on one element
	
	
	    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element
	
	    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
	      this.dispatchToElement(hovered, 'mouseover', event);
	    }
	  },
	  mouseout: function (event) {
	    this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application
	    // at the same level of painter.getViewportRoot() (e.g., tooltip
	    // dom created by echarts), where 'globalout' event should not
	    // be triggered when mouse enters these doms. (But 'mouseout'
	    // should be triggered at the original hovered element as usual).
	
	    var element = event.toElement || event.relatedTarget;
	    var innerDom;
	
	    do {
	      element = element && element.parentNode;
	    } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));
	
	    !innerDom && this.trigger('globalout', {
	      event: event
	    });
	  },
	
	  /**
	   * Resize
	   */
	  resize: function (event) {
	    this._hovered = {};
	  },
	
	  /**
	   * Dispatch event
	   * @param {string} eventName
	   * @param {event=} eventArgs
	   */
	  dispatch: function (eventName, eventArgs) {
	    var handler = this[eventName];
	    handler && handler.call(this, eventArgs);
	  },
	
	  /**
	   * Dispose
	   */
	  dispose: function () {
	    this.proxy.dispose();
	    this.storage = this.proxy = this.painter = null;
	  },
	
	  /**
	   * 设置默认的cursor style
	   * @param {string} [cursorStyle='default'] 例如 crosshair
	   */
	  setCursorStyle: function (cursorStyle) {
	    var proxy = this.proxy;
	    proxy.setCursor && proxy.setCursor(cursorStyle);
	  },
	
	  /**
	   * 事件分发代理
	   *
	   * @private
	   * @param {Object} targetInfo {target, topTarget} 目标图形元素
	   * @param {string} eventName 事件名称
	   * @param {Object} event 事件对象
	   */
	  dispatchToElement: function (targetInfo, eventName, event) {
	    targetInfo = targetInfo || {};
	    var el = targetInfo.target;
	
	    if (el && el.silent) {
	      return;
	    }
	
	    var eventHandler = 'on' + eventName;
	    var eventPacket = makeEventPacket(eventName, targetInfo, event);
	
	    while (el) {
	      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
	      el.trigger(eventName, eventPacket);
	      el = el.parent;
	
	      if (eventPacket.cancelBubble) {
	        break;
	      }
	    }
	
	    if (!eventPacket.cancelBubble) {
	      // 冒泡到顶级 zrender 对象
	      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层
	      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
	
	      this.painter && this.painter.eachOtherLayer(function (layer) {
	        if (typeof layer[eventHandler] == 'function') {
	          layer[eventHandler].call(layer, eventPacket);
	        }
	
	        if (layer.trigger) {
	          layer.trigger(eventName, eventPacket);
	        }
	      });
	    }
	  },
	
	  /**
	   * @private
	   * @param {number} x
	   * @param {number} y
	   * @param {module:zrender/graphic/Displayable} exclude
	   * @return {model:zrender/Element}
	   * @method
	   */
	  findHover: function (x, y, exclude) {
	    var list = this.storage.getDisplayList();
	    var out = {
	      x: x,
	      y: y
	    };
	
	    for (var i = list.length - 1; i >= 0; i--) {
	      var hoverCheckResult;
	
	      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode
	      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
	        !out.topTarget && (out.topTarget = list[i]);
	
	        if (hoverCheckResult !== SILENT) {
	          out.target = list[i];
	          break;
	        }
	      }
	    }
	
	    return out;
	  }
	}; // Common handlers
	
	util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
	  Handler.prototype[name] = function (event) {
	    // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
	    var hovered = this.findHover(event.zrX, event.zrY);
	    var hoveredTarget = hovered.target;
	
	    if (name === 'mousedown') {
	      this._downEl = hoveredTarget;
	      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup
	
	      this._upEl = hoveredTarget;
	    } else if (name === 'mosueup') {
	      this._upEl = hoveredTarget;
	    } else if (name === 'click') {
	      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,
	      // including the case that `mousedown` - `mousemove` - `mouseup`,
	      // which should be filtered, otherwise it will bring trouble to
	      // pan and zoom.
	      || !this._downPoint // Arbitrary value
	      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
	        return;
	      }
	
	      this._downPoint = null;
	    }
	
	    this.dispatchToElement(hovered, name, event);
	  };
	});
	
	function isHover(displayable, x, y) {
	  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
	    var el = displayable;
	    var isSilent;
	
	    while (el) {
	      // If clipped by ancestor.
	      // FIXME: If clipPath has neither stroke nor fill,
	      // el.clipPath.contain(x, y) will always return false.
	      if (el.clipPath && !el.clipPath.contain(x, y)) {
	        return false;
	      }
	
	      if (el.silent) {
	        isSilent = true;
	      }
	
	      el = el.parent;
	    }
	
	    return isSilent ? SILENT : true;
	  }
	
	  return false;
	}
	
	util.mixin(Handler, Eventful);
	util.mixin(Handler, Draggable);
	var _default = Handler;
	module.exports = _default;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(4);
	
	var env = __webpack_require__(49);
	
	var Group = __webpack_require__(43);
	
	var timsort = __webpack_require__(68);
	
	/**
	 * Storage内容仓库模块
	 * @module zrender/Storage
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 * @author errorrik (errorrik@gmail.com)
	 * @author pissang (https://github.com/pissang/)
	 */
	// Use timsort because in most case elements are partially sorted
	// https://jsfiddle.net/pissang/jr4x7mdm/8/
	function shapeCompareFunc(a, b) {
	  if (a.zlevel === b.zlevel) {
	    if (a.z === b.z) {
	      // if (a.z2 === b.z2) {
	      //     // FIXME Slow has renderidx compare
	      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
	      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
	      //     return a.__renderidx - b.__renderidx;
	      // }
	      return a.z2 - b.z2;
	    }
	
	    return a.z - b.z;
	  }
	
	  return a.zlevel - b.zlevel;
	}
	/**
	 * 内容仓库 (M)
	 * @alias module:zrender/Storage
	 * @constructor
	 */
	
	
	var Storage = function () {
	  // jshint ignore:line
	  this._roots = [];
	  this._displayList = [];
	  this._displayListLen = 0;
	};
	
	Storage.prototype = {
	  constructor: Storage,
	
	  /**
	   * @param  {Function} cb
	   *
	   */
	  traverse: function (cb, context) {
	    for (var i = 0; i < this._roots.length; i++) {
	      this._roots[i].traverse(cb, context);
	    }
	  },
	
	  /**
	   * 返回所有图形的绘制队列
	   * @param {boolean} [update=false] 是否在返回前更新该数组
	   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
	   *
	   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
	   * @return {Array.<module:zrender/graphic/Displayable>}
	   */
	  getDisplayList: function (update, includeIgnore) {
	    includeIgnore = includeIgnore || false;
	
	    if (update) {
	      this.updateDisplayList(includeIgnore);
	    }
	
	    return this._displayList;
	  },
	
	  /**
	   * 更新图形的绘制队列。
	   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
	   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
	   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
	   */
	  updateDisplayList: function (includeIgnore) {
	    this._displayListLen = 0;
	    var roots = this._roots;
	    var displayList = this._displayList;
	
	    for (var i = 0, len = roots.length; i < len; i++) {
	      this._updateAndAddDisplayable(roots[i], null, includeIgnore);
	    }
	
	    displayList.length = this._displayListLen; // for (var i = 0, len = displayList.length; i < len; i++) {
	    //     displayList[i].__renderidx = i;
	    // }
	    // displayList.sort(shapeCompareFunc);
	
	    env.canvasSupported && timsort(displayList, shapeCompareFunc);
	  },
	  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
	    if (el.ignore && !includeIgnore) {
	      return;
	    }
	
	    el.beforeUpdate();
	
	    if (el.__dirty) {
	      el.update();
	    }
	
	    el.afterUpdate();
	    var userSetClipPath = el.clipPath;
	
	    if (userSetClipPath) {
	      // FIXME 效率影响
	      if (clipPaths) {
	        clipPaths = clipPaths.slice();
	      } else {
	        clipPaths = [];
	      }
	
	      var currentClipPath = userSetClipPath;
	      var parentClipPath = el; // Recursively add clip path
	
	      while (currentClipPath) {
	        // clipPath 的变换是基于使用这个 clipPath 的元素
	        currentClipPath.parent = parentClipPath;
	        currentClipPath.updateTransform();
	        clipPaths.push(currentClipPath);
	        parentClipPath = currentClipPath;
	        currentClipPath = currentClipPath.clipPath;
	      }
	    }
	
	    if (el.isGroup) {
	      var children = el._children;
	
	      for (var i = 0; i < children.length; i++) {
	        var child = children[i]; // Force to mark as dirty if group is dirty
	        // FIXME __dirtyPath ?
	
	        if (el.__dirty) {
	          child.__dirty = true;
	        }
	
	        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
	      } // Mark group clean here
	
	
	      el.__dirty = false;
	    } else {
	      el.__clipPaths = clipPaths;
	      this._displayList[this._displayListLen++] = el;
	    }
	  },
	
	  /**
	   * 添加图形(Shape)或者组(Group)到根节点
	   * @param {module:zrender/Element} el
	   */
	  addRoot: function (el) {
	    if (el.__storage === this) {
	      return;
	    }
	
	    if (el instanceof Group) {
	      el.addChildrenToStorage(this);
	    }
	
	    this.addToStorage(el);
	
	    this._roots.push(el);
	  },
	
	  /**
	   * 删除指定的图形(Shape)或者组(Group)
	   * @param {string|Array.<string>} [el] 如果为空清空整个Storage
	   */
	  delRoot: function (el) {
	    if (el == null) {
	      // 不指定el清空
	      for (var i = 0; i < this._roots.length; i++) {
	        var root = this._roots[i];
	
	        if (root instanceof Group) {
	          root.delChildrenFromStorage(this);
	        }
	      }
	
	      this._roots = [];
	      this._displayList = [];
	      this._displayListLen = 0;
	      return;
	    }
	
	    if (el instanceof Array) {
	      for (var i = 0, l = el.length; i < l; i++) {
	        this.delRoot(el[i]);
	      }
	
	      return;
	    }
	
	    var idx = util.indexOf(this._roots, el);
	
	    if (idx >= 0) {
	      this.delFromStorage(el);
	
	      this._roots.splice(idx, 1);
	
	      if (el instanceof Group) {
	        el.delChildrenFromStorage(this);
	      }
	    }
	  },
	  addToStorage: function (el) {
	    el.__storage = this;
	    el.dirty(false);
	    return this;
	  },
	  delFromStorage: function (el) {
	    if (el) {
	      el.__storage = null;
	    }
	
	    return this;
	  },
	
	  /**
	   * 清空并且释放Storage
	   */
	  dispose: function () {
	    this._renderList = this._roots = null;
	  },
	  displayableSortFunc: shapeCompareFunc
	};
	var _default = Storage;
	module.exports = _default;

/***/ }),
/* 68 */
/***/ (function(module, exports) {

	// https://github.com/mziccard/node-timsort
	var DEFAULT_MIN_MERGE = 32;
	var DEFAULT_MIN_GALLOPING = 7;
	var DEFAULT_TMP_STORAGE_LENGTH = 256;
	
	function minRunLength(n) {
	  var r = 0;
	
	  while (n >= DEFAULT_MIN_MERGE) {
	    r |= n & 1;
	    n >>= 1;
	  }
	
	  return n + r;
	}
	
	function makeAscendingRun(array, lo, hi, compare) {
	  var runHi = lo + 1;
	
	  if (runHi === hi) {
	    return 1;
	  }
	
	  if (compare(array[runHi++], array[lo]) < 0) {
	    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
	      runHi++;
	    }
	
	    reverseRun(array, lo, runHi);
	  } else {
	    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
	      runHi++;
	    }
	  }
	
	  return runHi - lo;
	}
	
	function reverseRun(array, lo, hi) {
	  hi--;
	
	  while (lo < hi) {
	    var t = array[lo];
	    array[lo++] = array[hi];
	    array[hi--] = t;
	  }
	}
	
	function binaryInsertionSort(array, lo, hi, start, compare) {
	  if (start === lo) {
	    start++;
	  }
	
	  for (; start < hi; start++) {
	    var pivot = array[start];
	    var left = lo;
	    var right = start;
	    var mid;
	
	    while (left < right) {
	      mid = left + right >>> 1;
	
	      if (compare(pivot, array[mid]) < 0) {
	        right = mid;
	      } else {
	        left = mid + 1;
	      }
	    }
	
	    var n = start - left;
	
	    switch (n) {
	      case 3:
	        array[left + 3] = array[left + 2];
	
	      case 2:
	        array[left + 2] = array[left + 1];
	
	      case 1:
	        array[left + 1] = array[left];
	        break;
	
	      default:
	        while (n > 0) {
	          array[left + n] = array[left + n - 1];
	          n--;
	        }
	
	    }
	
	    array[left] = pivot;
	  }
	}
	
	function gallopLeft(value, array, start, length, hint, compare) {
	  var lastOffset = 0;
	  var maxOffset = 0;
	  var offset = 1;
	
	  if (compare(value, array[start + hint]) > 0) {
	    maxOffset = length - hint;
	
	    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    lastOffset += hint;
	    offset += hint;
	  } else {
	    maxOffset = hint + 1;
	
	    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    var tmp = lastOffset;
	    lastOffset = hint - offset;
	    offset = hint - tmp;
	  }
	
	  lastOffset++;
	
	  while (lastOffset < offset) {
	    var m = lastOffset + (offset - lastOffset >>> 1);
	
	    if (compare(value, array[start + m]) > 0) {
	      lastOffset = m + 1;
	    } else {
	      offset = m;
	    }
	  }
	
	  return offset;
	}
	
	function gallopRight(value, array, start, length, hint, compare) {
	  var lastOffset = 0;
	  var maxOffset = 0;
	  var offset = 1;
	
	  if (compare(value, array[start + hint]) < 0) {
	    maxOffset = hint + 1;
	
	    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    var tmp = lastOffset;
	    lastOffset = hint - offset;
	    offset = hint - tmp;
	  } else {
	    maxOffset = length - hint;
	
	    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
	      lastOffset = offset;
	      offset = (offset << 1) + 1;
	
	      if (offset <= 0) {
	        offset = maxOffset;
	      }
	    }
	
	    if (offset > maxOffset) {
	      offset = maxOffset;
	    }
	
	    lastOffset += hint;
	    offset += hint;
	  }
	
	  lastOffset++;
	
	  while (lastOffset < offset) {
	    var m = lastOffset + (offset - lastOffset >>> 1);
	
	    if (compare(value, array[start + m]) < 0) {
	      offset = m;
	    } else {
	      lastOffset = m + 1;
	    }
	  }
	
	  return offset;
	}
	
	function TimSort(array, compare) {
	  var minGallop = DEFAULT_MIN_GALLOPING;
	  var length = 0;
	  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
	  var stackLength = 0;
	  var runStart;
	  var runLength;
	  var stackSize = 0;
	  length = array.length;
	
	  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
	    tmpStorageLength = length >>> 1;
	  }
	
	  var tmp = [];
	  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
	  runStart = [];
	  runLength = [];
	
	  function pushRun(_runStart, _runLength) {
	    runStart[stackSize] = _runStart;
	    runLength[stackSize] = _runLength;
	    stackSize += 1;
	  }
	
	  function mergeRuns() {
	    while (stackSize > 1) {
	      var n = stackSize - 2;
	
	      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
	        if (runLength[n - 1] < runLength[n + 1]) {
	          n--;
	        }
	      } else if (runLength[n] > runLength[n + 1]) {
	        break;
	      }
	
	      mergeAt(n);
	    }
	  }
	
	  function forceMergeRuns() {
	    while (stackSize > 1) {
	      var n = stackSize - 2;
	
	      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
	        n--;
	      }
	
	      mergeAt(n);
	    }
	  }
	
	  function mergeAt(i) {
	    var start1 = runStart[i];
	    var length1 = runLength[i];
	    var start2 = runStart[i + 1];
	    var length2 = runLength[i + 1];
	    runLength[i] = length1 + length2;
	
	    if (i === stackSize - 3) {
	      runStart[i + 1] = runStart[i + 2];
	      runLength[i + 1] = runLength[i + 2];
	    }
	
	    stackSize--;
	    var k = gallopRight(array[start2], array, start1, length1, 0, compare);
	    start1 += k;
	    length1 -= k;
	
	    if (length1 === 0) {
	      return;
	    }
	
	    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
	
	    if (length2 === 0) {
	      return;
	    }
	
	    if (length1 <= length2) {
	      mergeLow(start1, length1, start2, length2);
	    } else {
	      mergeHigh(start1, length1, start2, length2);
	    }
	  }
	
	  function mergeLow(start1, length1, start2, length2) {
	    var i = 0;
	
	    for (i = 0; i < length1; i++) {
	      tmp[i] = array[start1 + i];
	    }
	
	    var cursor1 = 0;
	    var cursor2 = start2;
	    var dest = start1;
	    array[dest++] = array[cursor2++];
	
	    if (--length2 === 0) {
	      for (i = 0; i < length1; i++) {
	        array[dest + i] = tmp[cursor1 + i];
	      }
	
	      return;
	    }
	
	    if (length1 === 1) {
	      for (i = 0; i < length2; i++) {
	        array[dest + i] = array[cursor2 + i];
	      }
	
	      array[dest + length2] = tmp[cursor1];
	      return;
	    }
	
	    var _minGallop = minGallop;
	    var count1, count2, exit;
	
	    while (1) {
	      count1 = 0;
	      count2 = 0;
	      exit = false;
	
	      do {
	        if (compare(array[cursor2], tmp[cursor1]) < 0) {
	          array[dest++] = array[cursor2++];
	          count2++;
	          count1 = 0;
	
	          if (--length2 === 0) {
	            exit = true;
	            break;
	          }
	        } else {
	          array[dest++] = tmp[cursor1++];
	          count1++;
	          count2 = 0;
	
	          if (--length1 === 1) {
	            exit = true;
	            break;
	          }
	        }
	      } while ((count1 | count2) < _minGallop);
	
	      if (exit) {
	        break;
	      }
	
	      do {
	        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
	
	        if (count1 !== 0) {
	          for (i = 0; i < count1; i++) {
	            array[dest + i] = tmp[cursor1 + i];
	          }
	
	          dest += count1;
	          cursor1 += count1;
	          length1 -= count1;
	
	          if (length1 <= 1) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest++] = array[cursor2++];
	
	        if (--length2 === 0) {
	          exit = true;
	          break;
	        }
	
	        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
	
	        if (count2 !== 0) {
	          for (i = 0; i < count2; i++) {
	            array[dest + i] = array[cursor2 + i];
	          }
	
	          dest += count2;
	          cursor2 += count2;
	          length2 -= count2;
	
	          if (length2 === 0) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest++] = tmp[cursor1++];
	
	        if (--length1 === 1) {
	          exit = true;
	          break;
	        }
	
	        _minGallop--;
	      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	      if (exit) {
	        break;
	      }
	
	      if (_minGallop < 0) {
	        _minGallop = 0;
	      }
	
	      _minGallop += 2;
	    }
	
	    minGallop = _minGallop;
	    minGallop < 1 && (minGallop = 1);
	
	    if (length1 === 1) {
	      for (i = 0; i < length2; i++) {
	        array[dest + i] = array[cursor2 + i];
	      }
	
	      array[dest + length2] = tmp[cursor1];
	    } else if (length1 === 0) {
	      throw new Error(); // throw new Error('mergeLow preconditions were not respected');
	    } else {
	      for (i = 0; i < length1; i++) {
	        array[dest + i] = tmp[cursor1 + i];
	      }
	    }
	  }
	
	  function mergeHigh(start1, length1, start2, length2) {
	    var i = 0;
	
	    for (i = 0; i < length2; i++) {
	      tmp[i] = array[start2 + i];
	    }
	
	    var cursor1 = start1 + length1 - 1;
	    var cursor2 = length2 - 1;
	    var dest = start2 + length2 - 1;
	    var customCursor = 0;
	    var customDest = 0;
	    array[dest--] = array[cursor1--];
	
	    if (--length1 === 0) {
	      customCursor = dest - (length2 - 1);
	
	      for (i = 0; i < length2; i++) {
	        array[customCursor + i] = tmp[i];
	      }
	
	      return;
	    }
	
	    if (length2 === 1) {
	      dest -= length1;
	      cursor1 -= length1;
	      customDest = dest + 1;
	      customCursor = cursor1 + 1;
	
	      for (i = length1 - 1; i >= 0; i--) {
	        array[customDest + i] = array[customCursor + i];
	      }
	
	      array[dest] = tmp[cursor2];
	      return;
	    }
	
	    var _minGallop = minGallop;
	
	    while (true) {
	      var count1 = 0;
	      var count2 = 0;
	      var exit = false;
	
	      do {
	        if (compare(tmp[cursor2], array[cursor1]) < 0) {
	          array[dest--] = array[cursor1--];
	          count1++;
	          count2 = 0;
	
	          if (--length1 === 0) {
	            exit = true;
	            break;
	          }
	        } else {
	          array[dest--] = tmp[cursor2--];
	          count2++;
	          count1 = 0;
	
	          if (--length2 === 1) {
	            exit = true;
	            break;
	          }
	        }
	      } while ((count1 | count2) < _minGallop);
	
	      if (exit) {
	        break;
	      }
	
	      do {
	        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
	
	        if (count1 !== 0) {
	          dest -= count1;
	          cursor1 -= count1;
	          length1 -= count1;
	          customDest = dest + 1;
	          customCursor = cursor1 + 1;
	
	          for (i = count1 - 1; i >= 0; i--) {
	            array[customDest + i] = array[customCursor + i];
	          }
	
	          if (length1 === 0) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest--] = tmp[cursor2--];
	
	        if (--length2 === 1) {
	          exit = true;
	          break;
	        }
	
	        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
	
	        if (count2 !== 0) {
	          dest -= count2;
	          cursor2 -= count2;
	          length2 -= count2;
	          customDest = dest + 1;
	          customCursor = cursor2 + 1;
	
	          for (i = 0; i < count2; i++) {
	            array[customDest + i] = tmp[customCursor + i];
	          }
	
	          if (length2 <= 1) {
	            exit = true;
	            break;
	          }
	        }
	
	        array[dest--] = array[cursor1--];
	
	        if (--length1 === 0) {
	          exit = true;
	          break;
	        }
	
	        _minGallop--;
	      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	      if (exit) {
	        break;
	      }
	
	      if (_minGallop < 0) {
	        _minGallop = 0;
	      }
	
	      _minGallop += 2;
	    }
	
	    minGallop = _minGallop;
	
	    if (minGallop < 1) {
	      minGallop = 1;
	    }
	
	    if (length2 === 1) {
	      dest -= length1;
	      cursor1 -= length1;
	      customDest = dest + 1;
	      customCursor = cursor1 + 1;
	
	      for (i = length1 - 1; i >= 0; i--) {
	        array[customDest + i] = array[customCursor + i];
	      }
	
	      array[dest] = tmp[cursor2];
	    } else if (length2 === 0) {
	      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');
	    } else {
	      customCursor = dest - (length2 - 1);
	
	      for (i = 0; i < length2; i++) {
	        array[customCursor + i] = tmp[i];
	      }
	    }
	  }
	
	  this.mergeRuns = mergeRuns;
	  this.forceMergeRuns = forceMergeRuns;
	  this.pushRun = pushRun;
	}
	
	function sort(array, compare, lo, hi) {
	  if (!lo) {
	    lo = 0;
	  }
	
	  if (!hi) {
	    hi = array.length;
	  }
	
	  var remaining = hi - lo;
	
	  if (remaining < 2) {
	    return;
	  }
	
	  var runLength = 0;
	
	  if (remaining < DEFAULT_MIN_MERGE) {
	    runLength = makeAscendingRun(array, lo, hi, compare);
	    binaryInsertionSort(array, lo, hi, lo + runLength, compare);
	    return;
	  }
	
	  var ts = new TimSort(array, compare);
	  var minRun = minRunLength(remaining);
	
	  do {
	    runLength = makeAscendingRun(array, lo, hi, compare);
	
	    if (runLength < minRun) {
	      var force = remaining;
	
	      if (force > minRun) {
	        force = minRun;
	      }
	
	      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
	      runLength = force;
	    }
	
	    ts.pushRun(lo, runLength);
	    ts.mergeRuns();
	    remaining -= runLength;
	    lo += runLength;
	  } while (remaining !== 0);
	
	  ts.forceMergeRuns();
	}
	
	module.exports = sort;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	var _config = __webpack_require__(22);
	
	var devicePixelRatio = _config.devicePixelRatio;
	
	var util = __webpack_require__(4);
	
	var log = __webpack_require__(21);
	
	var BoundingRect = __webpack_require__(26);
	
	var timsort = __webpack_require__(68);
	
	var Layer = __webpack_require__(70);
	
	var requestAnimationFrame = __webpack_require__(71);
	
	var Image = __webpack_require__(44);
	
	/**
	 * Default canvas painter
	 * @module zrender/Painter
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	// PENDIGN
	// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
	//
	// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
	var MAX_PROGRESSIVE_LAYER_NUMBER = 5;
	
	function parseInt10(val) {
	  return parseInt(val, 10);
	}
	
	function isLayerValid(layer) {
	  if (!layer) {
	    return false;
	  }
	
	  if (layer.__builtin__) {
	    return true;
	  }
	
	  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {
	    return false;
	  }
	
	  return true;
	}
	
	function preProcessLayer(layer) {
	  layer.__unusedCount++;
	}
	
	function postProcessLayer(layer) {
	  if (layer.__unusedCount == 1) {
	    layer.clear();
	  }
	}
	
	var tmpRect = new BoundingRect(0, 0, 0, 0);
	var viewRect = new BoundingRect(0, 0, 0, 0);
	
	function isDisplayableCulled(el, width, height) {
	  tmpRect.copy(el.getBoundingRect());
	
	  if (el.transform) {
	    tmpRect.applyTransform(el.transform);
	  }
	
	  viewRect.width = width;
	  viewRect.height = height;
	  return !tmpRect.intersect(viewRect);
	}
	
	function isClipPathChanged(clipPaths, prevClipPaths) {
	  if (clipPaths == prevClipPaths) {
	    // Can both be null or undefined
	    return false;
	  }
	
	  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
	    return true;
	  }
	
	  for (var i = 0; i < clipPaths.length; i++) {
	    if (clipPaths[i] !== prevClipPaths[i]) {
	      return true;
	    }
	  }
	}
	
	function doClip(clipPaths, ctx) {
	  for (var i = 0; i < clipPaths.length; i++) {
	    var clipPath = clipPaths[i];
	    clipPath.setTransform(ctx);
	    ctx.beginPath();
	    clipPath.buildPath(ctx, clipPath.shape);
	    ctx.clip(); // Transform back
	
	    clipPath.restoreTransform(ctx);
	  }
	}
	
	function createRoot(width, height) {
	  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
	
	  domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';
	  return domRoot;
	}
	/**
	 * @alias module:zrender/Painter
	 * @constructor
	 * @param {HTMLElement} root 绘图容器
	 * @param {module:zrender/Storage} storage
	 * @param {Object} opts
	 */
	
	
	var Painter = function (root, storage, opts) {
	  this.type = 'canvas'; // In node environment using node-canvas
	
	  var singleCanvas = !root.nodeName // In node ?
	  || root.nodeName.toUpperCase() === 'CANVAS';
	  this._opts = opts = util.extend({}, opts || {});
	  /**
	   * @type {number}
	   */
	
	  this.dpr = opts.devicePixelRatio || devicePixelRatio;
	  /**
	   * @type {boolean}
	   * @private
	   */
	
	  this._singleCanvas = singleCanvas;
	  /**
	   * 绘图容器
	   * @type {HTMLElement}
	   */
	
	  this.root = root;
	  var rootStyle = root.style;
	
	  if (rootStyle) {
	    rootStyle['-webkit-tap-highlight-color'] = 'transparent';
	    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';
	    root.innerHTML = '';
	  }
	  /**
	   * @type {module:zrender/Storage}
	   */
	
	
	  this.storage = storage;
	  /**
	   * @type {Array.<number>}
	   * @private
	   */
	
	  var zlevelList = this._zlevelList = [];
	  /**
	   * @type {Object.<string, module:zrender/Layer>}
	   * @private
	   */
	
	  var layers = this._layers = {};
	  /**
	   * @type {Object.<string, Object>}
	   * @type {private}
	   */
	
	  this._layerConfig = {};
	
	  if (!singleCanvas) {
	    this._width = this._getSize(0);
	    this._height = this._getSize(1);
	    var domRoot = this._domRoot = createRoot(this._width, this._height);
	    root.appendChild(domRoot);
	  } else {
	    if (opts.width != null) {
	      root.width = opts.width;
	    }
	
	    if (opts.height != null) {
	      root.height = opts.height;
	    } // Use canvas width and height directly
	
	
	    var width = root.width;
	    var height = root.height;
	    this._width = width;
	    this._height = height; // Create layer if only one given canvas
	    // Device pixel ratio is fixed to 1 because given canvas has its specified width and height
	
	    var mainLayer = new Layer(root, this, 1);
	    mainLayer.initContext(); // FIXME Use canvas width and height
	    // mainLayer.resize(width, height);
	
	    layers[0] = mainLayer;
	    zlevelList.push(0);
	    this._domRoot = root;
	  } // Layers for progressive rendering
	
	
	  this._progressiveLayers = [];
	  /**
	   * @type {module:zrender/Layer}
	   * @private
	   */
	
	  this._hoverlayer;
	  this._hoverElements = [];
	};
	
	Painter.prototype = {
	  constructor: Painter,
	  getType: function () {
	    return 'canvas';
	  },
	
	  /**
	   * If painter use a single canvas
	   * @return {boolean}
	   */
	  isSingleCanvas: function () {
	    return this._singleCanvas;
	  },
	
	  /**
	   * @return {HTMLDivElement}
	   */
	  getViewportRoot: function () {
	    return this._domRoot;
	  },
	  getViewportRootOffset: function () {
	    var viewportRoot = this.getViewportRoot();
	
	    if (viewportRoot) {
	      return {
	        offsetLeft: viewportRoot.offsetLeft || 0,
	        offsetTop: viewportRoot.offsetTop || 0
	      };
	    }
	  },
	
	  /**
	   * 刷新
	   * @param {boolean} [paintAll=false] 强制绘制所有displayable
	   */
	  refresh: function (paintAll) {
	    var list = this.storage.getDisplayList(true);
	    var zlevelList = this._zlevelList;
	
	    this._paintList(list, paintAll); // Paint custum layers
	
	
	    for (var i = 0; i < zlevelList.length; i++) {
	      var z = zlevelList[i];
	      var layer = this._layers[z];
	
	      if (!layer.__builtin__ && layer.refresh) {
	        layer.refresh();
	      }
	    }
	
	    this.refreshHover();
	
	    if (this._progressiveLayers.length) {
	      this._startProgessive();
	    }
	
	    return this;
	  },
	  addHover: function (el, hoverStyle) {
	    if (el.__hoverMir) {
	      return;
	    }
	
	    var elMirror = new el.constructor({
	      style: el.style,
	      shape: el.shape
	    });
	    elMirror.__from = el;
	    el.__hoverMir = elMirror;
	    elMirror.setStyle(hoverStyle);
	
	    this._hoverElements.push(elMirror);
	  },
	  removeHover: function (el) {
	    var elMirror = el.__hoverMir;
	    var hoverElements = this._hoverElements;
	    var idx = util.indexOf(hoverElements, elMirror);
	
	    if (idx >= 0) {
	      hoverElements.splice(idx, 1);
	    }
	
	    el.__hoverMir = null;
	  },
	  clearHover: function (el) {
	    var hoverElements = this._hoverElements;
	
	    for (var i = 0; i < hoverElements.length; i++) {
	      var from = hoverElements[i].__from;
	
	      if (from) {
	        from.__hoverMir = null;
	      }
	    }
	
	    hoverElements.length = 0;
	  },
	  refreshHover: function () {
	    var hoverElements = this._hoverElements;
	    var len = hoverElements.length;
	    var hoverLayer = this._hoverlayer;
	    hoverLayer && hoverLayer.clear();
	
	    if (!len) {
	      return;
	    }
	
	    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel
	    // FIXME?
	
	    if (!hoverLayer) {
	      hoverLayer = this._hoverlayer = this.getLayer(1e5);
	    }
	
	    var scope = {};
	    hoverLayer.ctx.save();
	
	    for (var i = 0; i < len;) {
	      var el = hoverElements[i];
	      var originalEl = el.__from; // Original el is removed
	      // PENDING
	
	      if (!(originalEl && originalEl.__zr)) {
	        hoverElements.splice(i, 1);
	        originalEl.__hoverMir = null;
	        len--;
	        continue;
	      }
	
	      i++; // Use transform
	      // FIXME style and shape ?
	
	      if (!originalEl.invisible) {
	        el.transform = originalEl.transform;
	        el.invTransform = originalEl.invTransform;
	        el.__clipPaths = originalEl.__clipPaths; // el.
	
	        this._doPaintEl(el, hoverLayer, true, scope);
	      }
	    }
	
	    hoverLayer.ctx.restore();
	  },
	  _startProgessive: function () {
	    var self = this;
	
	    if (!self._furtherProgressive) {
	      return;
	    } // Use a token to stop progress steps triggered by
	    // previous zr.refresh calling.
	
	
	    var token = self._progressiveToken = +new Date();
	    self._progress++;
	    requestAnimationFrame(step);
	
	    function step() {
	      // In case refreshed or disposed
	      if (token === self._progressiveToken && self.storage) {
	        self._doPaintList(self.storage.getDisplayList());
	
	        if (self._furtherProgressive) {
	          self._progress++;
	          requestAnimationFrame(step);
	        } else {
	          self._progressiveToken = -1;
	        }
	      }
	    }
	  },
	  _clearProgressive: function () {
	    this._progressiveToken = -1;
	    this._progress = 0;
	    util.each(this._progressiveLayers, function (layer) {
	      layer.__dirty && layer.clear();
	    });
	  },
	  _paintList: function (list, paintAll) {
	    if (paintAll == null) {
	      paintAll = false;
	    }
	
	    this._updateLayerStatus(list);
	
	    this._clearProgressive();
	
	    this.eachBuiltinLayer(preProcessLayer);
	
	    this._doPaintList(list, paintAll);
	
	    this.eachBuiltinLayer(postProcessLayer);
	  },
	  _doPaintList: function (list, paintAll) {
	    var currentLayer;
	    var currentZLevel;
	    var ctx; // var invTransform = [];
	
	    var scope;
	    var progressiveLayerIdx = 0;
	    var currentProgressiveLayer;
	    var width = this._width;
	    var height = this._height;
	    var layerProgress;
	    var frame = this._progress;
	
	    function flushProgressiveLayer(layer) {
	      var dpr = ctx.dpr || 1;
	      ctx.save();
	      ctx.globalAlpha = 1;
	      ctx.shadowBlur = 0; // Avoid layer don't clear in next progressive frame
	
	      currentLayer.__dirty = true;
	      ctx.setTransform(1, 0, 0, 1, 0, 0);
	      ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
	      ctx.restore();
	    }
	
	    for (var i = 0, l = list.length; i < l; i++) {
	      var el = list[i];
	      var elZLevel = this._singleCanvas ? 0 : el.zlevel;
	      var elFrame = el.__frame; // Flush at current context
	      // PENDING
	
	      if (elFrame < 0 && currentProgressiveLayer) {
	        flushProgressiveLayer(currentProgressiveLayer);
	        currentProgressiveLayer = null;
	      } // Change draw layer
	
	
	      if (currentZLevel !== elZLevel) {
	        if (ctx) {
	          ctx.restore();
	        } // Reset scope
	
	
	        scope = {}; // Only 0 zlevel if only has one canvas
	
	        currentZLevel = elZLevel;
	        currentLayer = this.getLayer(currentZLevel);
	
	        if (!currentLayer.__builtin__) {
	          log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);
	        }
	
	        ctx = currentLayer.ctx;
	        ctx.save(); // Reset the count
	
	        currentLayer.__unusedCount = 0;
	
	        if (currentLayer.__dirty || paintAll) {
	          currentLayer.clear();
	        }
	      }
	
	      if (!(currentLayer.__dirty || paintAll)) {
	        continue;
	      }
	
	      if (elFrame >= 0) {
	        // Progressive layer changed
	        if (!currentProgressiveLayer) {
	          currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];
	          currentProgressiveLayer.ctx.save();
	          currentProgressiveLayer.renderScope = {};
	
	          if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {
	            // flushProgressiveLayer(currentProgressiveLayer);
	            // Quick jump all progressive elements
	            // All progressive element are not dirty, jump over and flush directly
	            i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null;
	
	            continue;
	          }
	
	          layerProgress = currentProgressiveLayer.__progress;
	
	          if (!currentProgressiveLayer.__dirty) {
	            // Keep rendering
	            frame = layerProgress;
	          }
	
	          currentProgressiveLayer.__progress = frame + 1;
	        }
	
	        if (elFrame === frame) {
	          this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
	        }
	      } else {
	        this._doPaintEl(el, currentLayer, paintAll, scope);
	      }
	
	      el.__dirty = false;
	    }
	
	    if (currentProgressiveLayer) {
	      flushProgressiveLayer(currentProgressiveLayer);
	    } // Restore the lastLayer ctx
	
	
	    ctx && ctx.restore(); // If still has clipping state
	    // if (scope.prevElClipPaths) {
	    //     ctx.restore();
	    // }
	
	    this._furtherProgressive = false;
	    util.each(this._progressiveLayers, function (layer) {
	      if (layer.__maxProgress >= layer.__progress) {
	        this._furtherProgressive = true;
	      }
	    }, this);
	  },
	  _doPaintEl: function (el, currentLayer, forcePaint, scope) {
	    var ctx = currentLayer.ctx;
	    var m = el.transform;
	
	    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element
	    !el.invisible // Ignore transparent element
	    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas
	    // Draw a scale 0 element can cause all following draw wrong
	    // And setTransform with scale 0 will cause set back transform failed.
	    && !(m && !m[0] && !m[3]) // Ignore culled element
	    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
	      var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements
	
	      if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {
	        // If has previous clipping state, restore from it
	        if (scope.prevElClipPaths) {
	          scope.prevClipLayer.ctx.restore();
	          scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored
	
	          scope.prevEl = null;
	        } // New clipping state
	
	
	        if (clipPaths) {
	          ctx.save();
	          doClip(clipPaths, ctx);
	          scope.prevClipLayer = currentLayer;
	          scope.prevElClipPaths = clipPaths;
	        }
	      }
	
	      el.beforeBrush && el.beforeBrush(ctx);
	      el.brush(ctx, scope.prevEl || null);
	      scope.prevEl = el;
	      el.afterBrush && el.afterBrush(ctx);
	    }
	  },
	
	  /**
	   * 获取 zlevel 所在层，如果不存在则会创建一个新的层
	   * @param {number} zlevel
	   * @return {module:zrender/Layer}
	   */
	  getLayer: function (zlevel) {
	    if (this._singleCanvas) {
	      return this._layers[0];
	    }
	
	    var layer = this._layers[zlevel];
	
	    if (!layer) {
	      // Create a new layer
	      layer = new Layer('zr_' + zlevel, this, this.dpr);
	      layer.__builtin__ = true;
	
	      if (this._layerConfig[zlevel]) {
	        util.merge(layer, this._layerConfig[zlevel], true);
	      }
	
	      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document
	      // Or excanvas will get 0px clientWidth and clientHeight
	
	      layer.initContext();
	    }
	
	    return layer;
	  },
	  insertLayer: function (zlevel, layer) {
	    var layersMap = this._layers;
	    var zlevelList = this._zlevelList;
	    var len = zlevelList.length;
	    var prevLayer = null;
	    var i = -1;
	    var domRoot = this._domRoot;
	
	    if (layersMap[zlevel]) {
	      log('ZLevel ' + zlevel + ' has been used already');
	      return;
	    } // Check if is a valid layer
	
	
	    if (!isLayerValid(layer)) {
	      log('Layer of zlevel ' + zlevel + ' is not valid');
	      return;
	    }
	
	    if (len > 0 && zlevel > zlevelList[0]) {
	      for (i = 0; i < len - 1; i++) {
	        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
	          break;
	        }
	      }
	
	      prevLayer = layersMap[zlevelList[i]];
	    }
	
	    zlevelList.splice(i + 1, 0, zlevel);
	    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.
	    // (It can be a WebGL layer and assigned to a ZImage element)
	    // But it still under management of zrender.
	
	    if (!layer.virtual) {
	      if (prevLayer) {
	        var prevDom = prevLayer.dom;
	
	        if (prevDom.nextSibling) {
	          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
	        } else {
	          domRoot.appendChild(layer.dom);
	        }
	      } else {
	        if (domRoot.firstChild) {
	          domRoot.insertBefore(layer.dom, domRoot.firstChild);
	        } else {
	          domRoot.appendChild(layer.dom);
	        }
	      }
	    }
	  },
	  // Iterate each layer
	  eachLayer: function (cb, context) {
	    var zlevelList = this._zlevelList;
	    var z;
	    var i;
	
	    for (i = 0; i < zlevelList.length; i++) {
	      z = zlevelList[i];
	      cb.call(context, this._layers[z], z);
	    }
	  },
	  // Iterate each buildin layer
	  eachBuiltinLayer: function (cb, context) {
	    var zlevelList = this._zlevelList;
	    var layer;
	    var z;
	    var i;
	
	    for (i = 0; i < zlevelList.length; i++) {
	      z = zlevelList[i];
	      layer = this._layers[z];
	
	      if (layer.__builtin__) {
	        cb.call(context, layer, z);
	      }
	    }
	  },
	  // Iterate each other layer except buildin layer
	  eachOtherLayer: function (cb, context) {
	    var zlevelList = this._zlevelList;
	    var layer;
	    var z;
	    var i;
	
	    for (i = 0; i < zlevelList.length; i++) {
	      z = zlevelList[i];
	      layer = this._layers[z];
	
	      if (!layer.__builtin__) {
	        cb.call(context, layer, z);
	      }
	    }
	  },
	
	  /**
	   * 获取所有已创建的层
	   * @param {Array.<module:zrender/Layer>} [prevLayer]
	   */
	  getLayers: function () {
	    return this._layers;
	  },
	  _updateLayerStatus: function (list) {
	    var layers = this._layers;
	    var progressiveLayers = this._progressiveLayers;
	    var elCountsLastFrame = {};
	    var progressiveElCountsLastFrame = {};
	    this.eachBuiltinLayer(function (layer, z) {
	      elCountsLastFrame[z] = layer.elCount;
	      layer.elCount = 0;
	      layer.__dirty = false;
	    });
	    util.each(progressiveLayers, function (layer, idx) {
	      progressiveElCountsLastFrame[idx] = layer.elCount;
	      layer.elCount = 0;
	      layer.__dirty = false;
	    });
	    var progressiveLayerCount = 0;
	    var currentProgressiveLayer;
	    var lastProgressiveKey;
	    var frameCount = 0;
	
	    for (var i = 0, l = list.length; i < l; i++) {
	      var el = list[i];
	      var zlevel = this._singleCanvas ? 0 : el.zlevel;
	      var layer = layers[zlevel];
	      var elProgress = el.progressive;
	
	      if (layer) {
	        layer.elCount++;
	        layer.__dirty = layer.__dirty || el.__dirty;
	      } /////// Update progressive
	
	
	      if (elProgress >= 0) {
	        // Fix wrong progressive sequence problem.
	        if (lastProgressiveKey !== elProgress) {
	          lastProgressiveKey = elProgress;
	          frameCount++;
	        }
	
	        var elFrame = el.__frame = frameCount - 1;
	
	        if (!currentProgressiveLayer) {
	          var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
	          currentProgressiveLayer = progressiveLayers[idx];
	
	          if (!currentProgressiveLayer) {
	            currentProgressiveLayer = progressiveLayers[idx] = new Layer('progressive', this, this.dpr);
	            currentProgressiveLayer.initContext();
	          }
	
	          currentProgressiveLayer.__maxProgress = 0;
	        }
	
	        currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
	        currentProgressiveLayer.elCount++;
	        currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);
	
	        if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
	          // Should keep rendering this  layer because progressive rendering is not finished yet
	          layer.__dirty = true;
	        }
	      } else {
	        el.__frame = -1;
	
	        if (currentProgressiveLayer) {
	          currentProgressiveLayer.__nextIdxNotProg = i;
	          progressiveLayerCount++;
	          currentProgressiveLayer = null;
	        }
	      }
	    }
	
	    if (currentProgressiveLayer) {
	      progressiveLayerCount++;
	      currentProgressiveLayer.__nextIdxNotProg = i;
	    } // 层中的元素数量有发生变化
	
	
	    this.eachBuiltinLayer(function (layer, z) {
	      if (elCountsLastFrame[z] !== layer.elCount) {
	        layer.__dirty = true;
	      }
	    });
	    progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
	    util.each(progressiveLayers, function (layer, idx) {
	      if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
	        el.__dirty = true;
	      }
	
	      if (layer.__dirty) {
	        layer.__progress = 0;
	      }
	    });
	  },
	
	  /**
	   * 清除hover层外所有内容
	   */
	  clear: function () {
	    this.eachBuiltinLayer(this._clearLayer);
	    return this;
	  },
	  _clearLayer: function (layer) {
	    layer.clear();
	  },
	
	  /**
	   * 修改指定zlevel的绘制参数
	   *
	   * @param {string} zlevel
	   * @param {Object} config 配置对象
	   * @param {string} [config.clearColor=0] 每次清空画布的颜色
	   * @param {string} [config.motionBlur=false] 是否开启动态模糊
	   * @param {number} [config.lastFrameAlpha=0.7]
	   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	   */
	  configLayer: function (zlevel, config) {
	    if (config) {
	      var layerConfig = this._layerConfig;
	
	      if (!layerConfig[zlevel]) {
	        layerConfig[zlevel] = config;
	      } else {
	        util.merge(layerConfig[zlevel], config, true);
	      }
	
	      var layer = this._layers[zlevel];
	
	      if (layer) {
	        util.merge(layer, layerConfig[zlevel], true);
	      }
	    }
	  },
	
	  /**
	   * 删除指定层
	   * @param {number} zlevel 层所在的zlevel
	   */
	  delLayer: function (zlevel) {
	    var layers = this._layers;
	    var zlevelList = this._zlevelList;
	    var layer = layers[zlevel];
	
	    if (!layer) {
	      return;
	    }
	
	    layer.dom.parentNode.removeChild(layer.dom);
	    delete layers[zlevel];
	    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
	  },
	
	  /**
	   * 区域大小变化后重绘
	   */
	  resize: function (width, height) {
	    var domRoot = this._domRoot; // FIXME Why ?
	
	    domRoot.style.display = 'none'; // Save input w/h
	
	    var opts = this._opts;
	    width != null && (opts.width = width);
	    height != null && (opts.height = height);
	    width = this._getSize(0);
	    height = this._getSize(1);
	    domRoot.style.display = ''; // 优化没有实际改变的resize
	
	    if (this._width != width || height != this._height) {
	      domRoot.style.width = width + 'px';
	      domRoot.style.height = height + 'px';
	
	      for (var id in this._layers) {
	        if (this._layers.hasOwnProperty(id)) {
	          this._layers[id].resize(width, height);
	        }
	      }
	
	      util.each(this._progressiveLayers, function (layer) {
	        layer.resize(width, height);
	      });
	      this.refresh(true);
	    }
	
	    this._width = width;
	    this._height = height;
	    return this;
	  },
	
	  /**
	   * 清除单独的一个层
	   * @param {number} zlevel
	   */
	  clearLayer: function (zlevel) {
	    var layer = this._layers[zlevel];
	
	    if (layer) {
	      layer.clear();
	    }
	  },
	
	  /**
	   * 释放
	   */
	  dispose: function () {
	    this.root.innerHTML = '';
	    this.root = this.storage = this._domRoot = this._layers = null;
	  },
	
	  /**
	   * Get canvas which has all thing rendered
	   * @param {Object} opts
	   * @param {string} [opts.backgroundColor]
	   * @param {number} [opts.pixelRatio]
	   */
	  getRenderedCanvas: function (opts) {
	    opts = opts || {};
	
	    if (this._singleCanvas) {
	      return this._layers[0].dom;
	    }
	
	    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
	    imageLayer.initContext();
	    imageLayer.clearColor = opts.backgroundColor;
	    imageLayer.clear();
	    var displayList = this.storage.getDisplayList(true);
	    var scope = {};
	    var zlevel;
	    var self = this;
	
	    function findAndDrawOtherLayer(smaller, larger) {
	      var zlevelList = self._zlevelList;
	
	      if (smaller == null) {
	        smaller = -Infinity;
	      }
	
	      var intermediateLayer;
	
	      for (var i = 0; i < zlevelList.length; i++) {
	        var z = zlevelList[i];
	        var layer = self._layers[z];
	
	        if (!layer.__builtin__ && z > smaller && z < larger) {
	          intermediateLayer = layer;
	          break;
	        }
	      }
	
	      if (intermediateLayer && intermediateLayer.renderToCanvas) {
	        imageLayer.ctx.save();
	        intermediateLayer.renderToCanvas(imageLayer.ctx);
	        imageLayer.ctx.restore();
	      }
	    }
	
	    for (var i = 0; i < displayList.length; i++) {
	      var el = displayList[i];
	
	      if (el.zlevel !== zlevel) {
	        findAndDrawOtherLayer(zlevel, el.zlevel);
	        zlevel = el.zlevel;
	      }
	
	      this._doPaintEl(el, imageLayer, true, scope);
	    }
	
	    findAndDrawOtherLayer(zlevel, Infinity);
	    return imageLayer.dom;
	  },
	
	  /**
	   * 获取绘图区域宽度
	   */
	  getWidth: function () {
	    return this._width;
	  },
	
	  /**
	   * 获取绘图区域高度
	   */
	  getHeight: function () {
	    return this._height;
	  },
	  _getSize: function (whIdx) {
	    var opts = this._opts;
	    var wh = ['width', 'height'][whIdx];
	    var cwh = ['clientWidth', 'clientHeight'][whIdx];
	    var plt = ['paddingLeft', 'paddingTop'][whIdx];
	    var prb = ['paddingRight', 'paddingBottom'][whIdx];
	
	    if (opts[wh] != null && opts[wh] !== 'auto') {
	      return parseFloat(opts[wh]);
	    }
	
	    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.
	
	    var stl = document.defaultView.getComputedStyle(root);
	    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
	  },
	  pathToImage: function (path, dpr) {
	    dpr = dpr || this.dpr;
	    var canvas = document.createElement('canvas');
	    var ctx = canvas.getContext('2d');
	    var rect = path.getBoundingRect();
	    var style = path.style;
	    var shadowBlurSize = style.shadowBlur;
	    var shadowOffsetX = style.shadowOffsetX;
	    var shadowOffsetY = style.shadowOffsetY;
	    var lineWidth = style.hasStroke() ? style.lineWidth : 0;
	    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
	    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
	    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
	    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
	    var width = rect.width + leftMargin + rightMargin;
	    var height = rect.height + topMargin + bottomMargin;
	    canvas.width = width * dpr;
	    canvas.height = height * dpr;
	    ctx.scale(dpr, dpr);
	    ctx.clearRect(0, 0, width, height);
	    ctx.dpr = dpr;
	    var pathTransform = {
	      position: path.position,
	      rotation: path.rotation,
	      scale: path.scale
	    };
	    path.position = [leftMargin - rect.x, topMargin - rect.y];
	    path.rotation = 0;
	    path.scale = [1, 1];
	    path.updateTransform();
	
	    if (path) {
	      path.brush(ctx);
	    }
	
	    var ImageShape = Image;
	    var imgShape = new ImageShape({
	      style: {
	        x: 0,
	        y: 0,
	        image: canvas
	      }
	    });
	
	    if (pathTransform.position != null) {
	      imgShape.position = path.position = pathTransform.position;
	    }
	
	    if (pathTransform.rotation != null) {
	      imgShape.rotation = path.rotation = pathTransform.rotation;
	    }
	
	    if (pathTransform.scale != null) {
	      imgShape.scale = path.scale = pathTransform.scale;
	    }
	
	    return imgShape;
	  }
	};
	var _default = Painter;
	module.exports = _default;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(4);
	
	var _config = __webpack_require__(22);
	
	var devicePixelRatio = _config.devicePixelRatio;
	
	var Style = __webpack_require__(8);
	
	var Pattern = __webpack_require__(39);
	
	/**
	 * @module zrender/Layer
	 * @author pissang(https://www.github.com/pissang)
	 */
	function returnFalse() {
	  return false;
	}
	/**
	 * 创建dom
	 *
	 * @inner
	 * @param {string} id dom id 待用
	 * @param {Painter} painter painter instance
	 * @param {number} number
	 */
	
	
	function createDom(id, painter, dpr) {
	  var newDom = util.createCanvas();
	  var width = painter.getWidth();
	  var height = painter.getHeight();
	  var newDomStyle = newDom.style; // 没append呢，请原谅我这样写，清晰~
	
	  newDomStyle.position = 'absolute';
	  newDomStyle.left = 0;
	  newDomStyle.top = 0;
	  newDomStyle.width = width + 'px';
	  newDomStyle.height = height + 'px';
	  newDom.width = width * dpr;
	  newDom.height = height * dpr; // id不作为索引用，避免可能造成的重名，定义为私有属性
	
	  newDom.setAttribute('data-zr-dom-id', id);
	  return newDom;
	}
	/**
	 * @alias module:zrender/Layer
	 * @constructor
	 * @extends module:zrender/mixin/Transformable
	 * @param {string} id
	 * @param {module:zrender/Painter} painter
	 * @param {number} [dpr]
	 */
	
	
	var Layer = function (id, painter, dpr) {
	  var dom;
	  dpr = dpr || devicePixelRatio;
	
	  if (typeof id === 'string') {
	    dom = createDom(id, painter, dpr);
	  } // Not using isDom because in node it will return false
	  else if (util.isObject(id)) {
	      dom = id;
	      id = dom.id;
	    }
	
	  this.id = id;
	  this.dom = dom;
	  var domStyle = dom.style;
	
	  if (domStyle) {
	    // Not in node
	    dom.onselectstart = returnFalse; // 避免页面选中的尴尬
	
	    domStyle['-webkit-user-select'] = 'none';
	    domStyle['user-select'] = 'none';
	    domStyle['-webkit-touch-callout'] = 'none';
	    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	    domStyle['padding'] = 0;
	    domStyle['margin'] = 0;
	    domStyle['border-width'] = 0;
	  }
	
	  this.domBack = null;
	  this.ctxBack = null;
	  this.painter = painter;
	  this.config = null; // Configs
	
	  /**
	   * 每次清空画布的颜色
	   * @type {string}
	   * @default 0
	   */
	
	  this.clearColor = 0;
	  /**
	   * 是否开启动态模糊
	   * @type {boolean}
	   * @default false
	   */
	
	  this.motionBlur = false;
	  /**
	   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	   * @type {number}
	   * @default 0.7
	   */
	
	  this.lastFrameAlpha = 0.7;
	  /**
	   * Layer dpr
	   * @type {number}
	   */
	
	  this.dpr = dpr;
	};
	
	Layer.prototype = {
	  constructor: Layer,
	  elCount: 0,
	  __dirty: true,
	  initContext: function () {
	    this.ctx = this.dom.getContext('2d');
	    this.ctx.__currentValues = {};
	    this.ctx.dpr = this.dpr;
	  },
	  createBackBuffer: function () {
	    var dpr = this.dpr;
	    this.domBack = createDom('back-' + this.id, this.painter, dpr);
	    this.ctxBack = this.domBack.getContext('2d');
	    this.ctxBack.__currentValues = {};
	
	    if (dpr != 1) {
	      this.ctxBack.scale(dpr, dpr);
	    }
	  },
	
	  /**
	   * @param  {number} width
	   * @param  {number} height
	   */
	  resize: function (width, height) {
	    var dpr = this.dpr;
	    var dom = this.dom;
	    var domStyle = dom.style;
	    var domBack = this.domBack;
	    domStyle.width = width + 'px';
	    domStyle.height = height + 'px';
	    dom.width = width * dpr;
	    dom.height = height * dpr;
	
	    if (domBack) {
	      domBack.width = width * dpr;
	      domBack.height = height * dpr;
	
	      if (dpr != 1) {
	        this.ctxBack.scale(dpr, dpr);
	      }
	    }
	  },
	
	  /**
	   * 清空该层画布
	   * @param {boolean} clearAll Clear all with out motion blur
	   */
	  clear: function (clearAll) {
	    var dom = this.dom;
	    var ctx = this.ctx;
	    var width = dom.width;
	    var height = dom.height;
	    var clearColor = this.clearColor;
	    var haveMotionBLur = this.motionBlur && !clearAll;
	    var lastFrameAlpha = this.lastFrameAlpha;
	    var dpr = this.dpr;
	
	    if (haveMotionBLur) {
	      if (!this.domBack) {
	        this.createBackBuffer();
	      }
	
	      this.ctxBack.globalCompositeOperation = 'copy';
	      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
	    }
	
	    ctx.clearRect(0, 0, width, height);
	
	    if (clearColor) {
	      var clearColorGradientOrPattern; // Gradient
	
	      if (clearColor.colorStops) {
	        // Cache canvas gradient
	        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
	          x: 0,
	          y: 0,
	          width: width,
	          height: height
	        });
	        clearColor.__canvasGradient = clearColorGradientOrPattern;
	      } // Pattern
	      else if (clearColor.image) {
	          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
	        }
	
	      ctx.save();
	      ctx.fillStyle = clearColorGradientOrPattern || clearColor;
	      ctx.fillRect(0, 0, width, height);
	      ctx.restore();
	    }
	
	    if (haveMotionBLur) {
	      var domBack = this.domBack;
	      ctx.save();
	      ctx.globalAlpha = lastFrameAlpha;
	      ctx.drawImage(domBack, 0, 0, width, height);
	      ctx.restore();
	    }
	  }
	};
	var _default = Layer;
	module.exports = _default;

/***/ }),
/* 71 */
/***/ (function(module, exports) {

	var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
	window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {
	  setTimeout(func, 16);
	};
	
	module.exports = _default;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	var util = __webpack_require__(4);
	
	var _event = __webpack_require__(73);
	
	var Dispatcher = _event.Dispatcher;
	
	var requestAnimationFrame = __webpack_require__(71);
	
	var Animator = __webpack_require__(16);
	
	/**
	 * 动画主类, 调度和管理所有动画控制器
	 *
	 * @module zrender/animation/Animation
	 * @author pissang(https://github.com/pissang)
	 */
	// TODO Additive animation
	// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
	// https://developer.apple.com/videos/wwdc2014/#236
	
	/**
	 * @typedef {Object} IZRenderStage
	 * @property {Function} update
	 */
	
	/**
	 * @alias module:zrender/animation/Animation
	 * @constructor
	 * @param {Object} [options]
	 * @param {Function} [options.onframe]
	 * @param {IZRenderStage} [options.stage]
	 * @example
	 *     var animation = new Animation();
	 *     var obj = {
	 *         x: 100,
	 *         y: 100
	 *     };
	 *     animation.animate(node.position)
	 *         .when(1000, {
	 *             x: 500,
	 *             y: 500
	 *         })
	 *         .when(2000, {
	 *             x: 100,
	 *             y: 100
	 *         })
	 *         .start('spline');
	 */
	var Animation = function (options) {
	  options = options || {};
	  this.stage = options.stage || {};
	
	  this.onframe = options.onframe || function () {}; // private properties
	
	
	  this._clips = [];
	  this._running = false;
	  this._time;
	  this._pausedTime;
	  this._pauseStart;
	  this._paused = false;
	  Dispatcher.call(this);
	};
	
	Animation.prototype = {
	  constructor: Animation,
	
	  /**
	   * 添加 clip
	   * @param {module:zrender/animation/Clip} clip
	   */
	  addClip: function (clip) {
	    this._clips.push(clip);
	  },
	
	  /**
	   * 添加 animator
	   * @param {module:zrender/animation/Animator} animator
	   */
	  addAnimator: function (animator) {
	    animator.animation = this;
	    var clips = animator.getClips();
	
	    for (var i = 0; i < clips.length; i++) {
	      this.addClip(clips[i]);
	    }
	  },
	
	  /**
	   * 删除动画片段
	   * @param {module:zrender/animation/Clip} clip
	   */
	  removeClip: function (clip) {
	    var idx = util.indexOf(this._clips, clip);
	
	    if (idx >= 0) {
	      this._clips.splice(idx, 1);
	    }
	  },
	
	  /**
	   * 删除动画片段
	   * @param {module:zrender/animation/Animator} animator
	   */
	  removeAnimator: function (animator) {
	    var clips = animator.getClips();
	
	    for (var i = 0; i < clips.length; i++) {
	      this.removeClip(clips[i]);
	    }
	
	    animator.animation = null;
	  },
	  _update: function () {
	    var time = new Date().getTime() - this._pausedTime;
	
	    var delta = time - this._time;
	    var clips = this._clips;
	    var len = clips.length;
	    var deferredEvents = [];
	    var deferredClips = [];
	
	    for (var i = 0; i < len; i++) {
	      var clip = clips[i];
	      var e = clip.step(time, delta); // Throw out the events need to be called after
	      // stage.update, like destroy
	
	      if (e) {
	        deferredEvents.push(e);
	        deferredClips.push(clip);
	      }
	    } // Remove the finished clip
	
	
	    for (var i = 0; i < len;) {
	      if (clips[i]._needsRemove) {
	        clips[i] = clips[len - 1];
	        clips.pop();
	        len--;
	      } else {
	        i++;
	      }
	    }
	
	    len = deferredEvents.length;
	
	    for (var i = 0; i < len; i++) {
	      deferredClips[i].fire(deferredEvents[i]);
	    }
	
	    this._time = time;
	    this.onframe(delta);
	    this.trigger('frame', delta);
	
	    if (this.stage.update) {
	      this.stage.update();
	    }
	  },
	  _startLoop: function () {
	    var self = this;
	    this._running = true;
	
	    function step() {
	      if (self._running) {
	        requestAnimationFrame(step);
	        !self._paused && self._update();
	      }
	    }
	
	    requestAnimationFrame(step);
	  },
	
	  /**
	   * 开始运行动画
	   */
	  start: function () {
	    this._time = new Date().getTime();
	    this._pausedTime = 0;
	
	    this._startLoop();
	  },
	
	  /**
	   * 停止运行动画
	   */
	  stop: function () {
	    this._running = false;
	  },
	
	  /**
	   * Pause
	   */
	  pause: function () {
	    if (!this._paused) {
	      this._pauseStart = new Date().getTime();
	      this._paused = true;
	    }
	  },
	
	  /**
	   * Resume
	   */
	  resume: function () {
	    if (this._paused) {
	      this._pausedTime += new Date().getTime() - this._pauseStart;
	      this._paused = false;
	    }
	  },
	
	  /**
	   * 清除所有动画片段
	   */
	  clear: function () {
	    this._clips = [];
	  },
	
	  /**
	   * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
	   * @param  {Object} target
	   * @param  {Object} options
	   * @param  {boolean} [options.loop=false] 是否循环播放动画
	   * @param  {Function} [options.getter=null]
	   *         如果指定getter函数，会通过getter函数取属性值
	   * @param  {Function} [options.setter=null]
	   *         如果指定setter函数，会通过setter函数设置属性值
	   * @return {module:zrender/animation/Animation~Animator}
	   */
	  // TODO Gap
	  animate: function (target, options) {
	    options = options || {};
	    var animator = new Animator(target, options.loop, options.getter, options.setter);
	    this.addAnimator(animator);
	    return animator;
	  }
	};
	util.mixin(Animation, Dispatcher);
	var _default = Animation;
	module.exports = _default;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	var Eventful = __webpack_require__(11);
	
	exports.Dispatcher = Eventful;
	
	var env = __webpack_require__(49);
	
	/**
	 * 事件辅助类
	 * @module zrender/core/event
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;
	var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
	
	function getBoundingClientRect(el) {
	  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
	  return el.getBoundingClientRect ? el.getBoundingClientRect() : {
	    left: 0,
	    top: 0
	  };
	} // `calculate` is optional, default false
	
	
	function clientToLocal(el, e, out, calculate) {
	  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative
	  // to the padding edge of the target element. The only browser using this convention
	  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
	  // not support the properties.
	  // (see http://www.jacklmoore.com/notes/mouse-position/)
	  // In zr painter.dom, padding edge equals to border edge.
	  // FIXME
	  // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and
	  // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y
	  // is too complex. So css-transfrom dont support in this case temporarily.
	
	  if (calculate || !env.canvasSupported) {
	    defaultGetZrXY(el, e, out);
	  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
	  // ancestor element, so we should make sure el is positioned (e.g., not position:static).
	  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
	  // zoom-factor, overflow / opacity layers, transforms ...)
	  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
	  // <https://bugs.jquery.com/ticket/8523#comment:14>
	  // BTW3, In ff, offsetX/offsetY is always 0.
	  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
	      out.zrX = e.layerX;
	      out.zrY = e.layerY;
	    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
	    else if (e.offsetX != null) {
	        out.zrX = e.offsetX;
	        out.zrY = e.offsetY;
	      } // For some other device, e.g., IOS safari.
	      else {
	          defaultGetZrXY(el, e, out);
	        }
	
	  return out;
	}
	
	function defaultGetZrXY(el, e, out) {
	  // This well-known method below does not support css transform.
	  var box = getBoundingClientRect(el);
	  out.zrX = e.clientX - box.left;
	  out.zrY = e.clientY - box.top;
	}
	/**
	 * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.
	 * `calculate` is optional, default false.
	 */
	
	
	function normalizeEvent(el, e, calculate) {
	  e = e || window.event;
	
	  if (e.zrX != null) {
	    return e;
	  }
	
	  var eventType = e.type;
	  var isTouch = eventType && eventType.indexOf('touch') >= 0;
	
	  if (!isTouch) {
	    clientToLocal(el, e, e, calculate);
	    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
	  } else {
	    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];
	    touch && clientToLocal(el, touch, e, calculate);
	  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;
	  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js
	  // If e.which has been defined, if may be readonly,
	  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which
	
	
	  var button = e.button;
	
	  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
	    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
	  }
	
	  return e;
	}
	
	function addEventListener(el, name, handler) {
	  if (isDomLevel2) {
	    el.addEventListener(name, handler);
	  } else {
	    el.attachEvent('on' + name, handler);
	  }
	}
	
	function removeEventListener(el, name, handler) {
	  if (isDomLevel2) {
	    el.removeEventListener(name, handler);
	  } else {
	    el.detachEvent('on' + name, handler);
	  }
	}
	/**
	 * preventDefault and stopPropagation.
	 * Notice: do not do that in zrender. Upper application
	 * do that if necessary.
	 *
	 * @memberOf module:zrender/core/event
	 * @method
	 * @param {Event} e : event对象
	 */
	
	
	var stop = isDomLevel2 ? function (e) {
	  e.preventDefault();
	  e.stopPropagation();
	  e.cancelBubble = true;
	} : function (e) {
	  e.returnValue = false;
	  e.cancelBubble = true;
	};
	
	function notLeftMouse(e) {
	  // If e.which is undefined, considered as left mouse event.
	  return e.which > 1;
	} // 做向上兼容
	
	
	exports.clientToLocal = clientToLocal;
	exports.normalizeEvent = normalizeEvent;
	exports.addEventListener = addEventListener;
	exports.removeEventListener = removeEventListener;
	exports.stop = stop;
	exports.notLeftMouse = notLeftMouse;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	var _event = __webpack_require__(73);
	
	var addEventListener = _event.addEventListener;
	var removeEventListener = _event.removeEventListener;
	var normalizeEvent = _event.normalizeEvent;
	
	var zrUtil = __webpack_require__(4);
	
	var Eventful = __webpack_require__(11);
	
	var env = __webpack_require__(49);
	
	var GestureMgr = __webpack_require__(75);
	
	var TOUCH_CLICK_DELAY = 300;
	var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
	var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];
	var pointerEventNames = {
	  pointerdown: 1,
	  pointerup: 1,
	  pointermove: 1,
	  pointerout: 1
	};
	var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {
	  var nm = name.replace('mouse', 'pointer');
	  return pointerEventNames[nm] ? nm : name;
	});
	
	function eventNameFix(name) {
	  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;
	}
	
	function processGesture(proxy, event, stage) {
	  var gestureMgr = proxy._gestureMgr;
	  stage === 'start' && gestureMgr.clear();
	  var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);
	  stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.
	
	  if (gestureInfo) {
	    var type = gestureInfo.type;
	    event.gestureEvent = type;
	    proxy.handler.dispatchToElement({
	      target: gestureInfo.target
	    }, type, gestureInfo.event);
	  }
	} // function onMSGestureChange(proxy, event) {
	//     if (event.translationX || event.translationY) {
	//         // mousemove is carried by MSGesture to reduce the sensitivity.
	//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
	//     }
	//     if (event.scale !== 1) {
	//         event.pinchX = event.offsetX;
	//         event.pinchY = event.offsetY;
	//         event.pinchScale = event.scale;
	//         proxy.handler.dispatchToElement(event.target, 'pinch', event);
	//     }
	// }
	
	/**
	 * Prevent mouse event from being dispatched after Touch Events action
	 * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
	 * 1. Mobile browsers dispatch mouse events 300ms after touchend.
	 * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
	 * Result: Blocking Mouse Events for 700ms.
	 */
	
	
	function setTouchTimer(instance) {
	  instance._touching = true;
	  clearTimeout(instance._touchTimer);
	  instance._touchTimer = setTimeout(function () {
	    instance._touching = false;
	  }, 700);
	}
	
	var domHandlers = {
	  /**
	   * Mouse move handler
	   * @inner
	   * @param {Event} event
	   */
	  mousemove: function (event) {
	    event = normalizeEvent(this.dom, event);
	    this.trigger('mousemove', event);
	  },
	
	  /**
	   * Mouse out handler
	   * @inner
	   * @param {Event} event
	   */
	  mouseout: function (event) {
	    event = normalizeEvent(this.dom, event);
	    var element = event.toElement || event.relatedTarget;
	
	    if (element != this.dom) {
	      while (element && element.nodeType != 9) {
	        // 忽略包含在root中的dom引起的mouseOut
	        if (element === this.dom) {
	          return;
	        }
	
	        element = element.parentNode;
	      }
	    }
	
	    this.trigger('mouseout', event);
	  },
	
	  /**
	   * Touch开始响应函数
	   * @inner
	   * @param {Event} event
	   */
	  touchstart: function (event) {
	    // Default mouse behaviour should not be disabled here.
	    // For example, page may needs to be slided.
	    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
	    // mouse event in upper applicatoin.
	
	    event.zrByTouch = true;
	    this._lastTouchMoment = new Date();
	    processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should
	    // be triggered, and must before `mousedown` triggered.
	
	    domHandlers.mousemove.call(this, event);
	    domHandlers.mousedown.call(this, event);
	    setTouchTimer(this);
	  },
	
	  /**
	   * Touch移动响应函数
	   * @inner
	   * @param {Event} event
	   */
	  touchmove: function (event) {
	    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
	    // mouse event in upper applicatoin.
	
	    event.zrByTouch = true;
	    processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether
	    // there is gestrue event, because mouse move and pinch may
	    // be used at the same time.
	
	    domHandlers.mousemove.call(this, event);
	    setTouchTimer(this);
	  },
	
	  /**
	   * Touch结束响应函数
	   * @inner
	   * @param {Event} event
	   */
	  touchend: function (event) {
	    event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
	    // mouse event in upper applicatoin.
	
	    event.zrByTouch = true;
	    processGesture(this, event, 'end');
	    domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
	    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
	    // we can conveniently implement "hover style" in both PC and touch device just
	    // by listening to `mouseover` to add "hover style" and listening to `mouseout`
	    // to remove "hover style" on an element, without any additional code for
	    // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
	    // style" will remain for user view)
	    // click event should always be triggered no matter whether
	    // there is gestrue event. System click can not be prevented.
	
	    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
	      domHandlers.click.call(this, event);
	    }
	
	    setTouchTimer(this);
	  },
	  pointerdown: function (event) {
	    domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {
	    //     this._msGesture.addPointer(event.pointerId);
	    // }
	  },
	  pointermove: function (event) {
	    // FIXME
	    // pointermove is so sensitive that it always triggered when
	    // tap(click) on touch screen, which affect some judgement in
	    // upper application. So, we dont support mousemove on MS touch
	    // device yet.
	    if (!isPointerFromTouch(event)) {
	      domHandlers.mousemove.call(this, event);
	    }
	  },
	  pointerup: function (event) {
	    domHandlers.mouseup.call(this, event);
	  },
	  pointerout: function (event) {
	    // pointerout will be triggered when tap on touch screen
	    // (IE11+/Edge on MS Surface) after click event triggered,
	    // which is inconsistent with the mousout behavior we defined
	    // in touchend. So we unify them.
	    // (check domHandlers.touchend for detailed explanation)
	    if (!isPointerFromTouch(event)) {
	      domHandlers.mouseout.call(this, event);
	    }
	  }
	};
	
	function isPointerFromTouch(event) {
	  var pointerType = event.pointerType;
	  return pointerType === 'pen' || pointerType === 'touch';
	} // function useMSGuesture(handlerProxy, event) {
	//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
	// }
	// Common handlers
	
	
	zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
	  domHandlers[name] = function (event) {
	    event = normalizeEvent(this.dom, event);
	    this.trigger(name, event);
	  };
	});
	/**
	 * 为控制类实例初始化dom 事件处理函数
	 *
	 * @inner
	 * @param {module:zrender/Handler} instance 控制类实例
	 */
	
	function initDomHandler(instance) {
	  zrUtil.each(touchHandlerNames, function (name) {
	    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	  });
	  zrUtil.each(pointerHandlerNames, function (name) {
	    instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	  });
	  zrUtil.each(mouseHandlerNames, function (name) {
	    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
	  });
	
	  function makeMouseHandler(fn, instance) {
	    return function () {
	      if (instance._touching) {
	        return;
	      }
	
	      return fn.apply(instance, arguments);
	    };
	  }
	}
	
	function HandlerDomProxy(dom) {
	  Eventful.call(this);
	  this.dom = dom;
	  /**
	   * @private
	   * @type {boolean}
	   */
	
	  this._touching = false;
	  /**
	   * @private
	   * @type {number}
	   */
	
	  this._touchTimer;
	  /**
	   * @private
	   * @type {module:zrender/core/GestureMgr}
	   */
	
	  this._gestureMgr = new GestureMgr();
	  this._handlers = {};
	  initDomHandler(this);
	
	  if (env.pointerEventsSupported) {
	    // Only IE11+/Edge
	    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
	    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
	    // at the same time.
	    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
	    // screen, which do not occurs in pointer event.
	    // So we use pointer event to both detect touch gesture and mouse behavior.
	    mountHandlers(pointerHandlerNames, this); // FIXME
	    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
	    // which does not prevent defuault behavior occasionally (which may cause view port
	    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.
	    // So we have to not to use MSGesture and not to support touchmove and pinch on MS
	    // touch screen. And we only support click behavior on MS touch screen now.
	    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
	    // We dont support touch on IE on win7.
	    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
	    // if (typeof MSGesture === 'function') {
	    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
	    //     dom.addEventListener('MSGestureChange', onMSGestureChange);
	    // }
	  } else {
	    if (env.touchEventsSupported) {
	      mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
	      // addEventListener(root, 'mouseout', this._mouseoutHandler);
	    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface
	    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
	    // mouse event can not be handle in those devices.
	    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
	    // mouseevent after touch event triggered, see `setTouchTimer`.
	
	
	    mountHandlers(mouseHandlerNames, this);
	  }
	
	  function mountHandlers(handlerNames, instance) {
	    zrUtil.each(handlerNames, function (name) {
	      addEventListener(dom, eventNameFix(name), instance._handlers[name]);
	    }, instance);
	  }
	}
	
	var handlerDomProxyProto = HandlerDomProxy.prototype;
	
	handlerDomProxyProto.dispose = function () {
	  var handlerNames = mouseHandlerNames.concat(touchHandlerNames);
	
	  for (var i = 0; i < handlerNames.length; i++) {
	    var name = handlerNames[i];
	    removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
	  }
	};
	
	handlerDomProxyProto.setCursor = function (cursorStyle) {
	  this.dom.style.cursor = cursorStyle || 'default';
	};
	
	zrUtil.mixin(HandlerDomProxy, Eventful);
	var _default = HandlerDomProxy;
	module.exports = _default;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	var eventUtil = __webpack_require__(73);
	
	/**
	 * Only implements needed gestures for mobile.
	 */
	var GestureMgr = function () {
	  /**
	   * @private
	   * @type {Array.<Object>}
	   */
	  this._track = [];
	};
	
	GestureMgr.prototype = {
	  constructor: GestureMgr,
	  recognize: function (event, target, root) {
	    this._doTrack(event, target, root);
	
	    return this._recognize(event);
	  },
	  clear: function () {
	    this._track.length = 0;
	    return this;
	  },
	  _doTrack: function (event, target, root) {
	    var touches = event.touches;
	
	    if (!touches) {
	      return;
	    }
	
	    var trackItem = {
	      points: [],
	      touches: [],
	      target: target,
	      event: event
	    };
	
	    for (var i = 0, len = touches.length; i < len; i++) {
	      var touch = touches[i];
	      var pos = eventUtil.clientToLocal(root, touch, {});
	      trackItem.points.push([pos.zrX, pos.zrY]);
	      trackItem.touches.push(touch);
	    }
	
	    this._track.push(trackItem);
	  },
	  _recognize: function (event) {
	    for (var eventName in recognizers) {
	      if (recognizers.hasOwnProperty(eventName)) {
	        var gestureInfo = recognizers[eventName](this._track, event);
	
	        if (gestureInfo) {
	          return gestureInfo;
	        }
	      }
	    }
	  }
	};
	
	function dist(pointPair) {
	  var dx = pointPair[1][0] - pointPair[0][0];
	  var dy = pointPair[1][1] - pointPair[0][1];
	  return Math.sqrt(dx * dx + dy * dy);
	}
	
	function center(pointPair) {
	  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
	}
	
	var recognizers = {
	  pinch: function (track, event) {
	    var trackLen = track.length;
	
	    if (!trackLen) {
	      return;
	    }
	
	    var pinchEnd = (track[trackLen - 1] || {}).points;
	    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
	
	    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
	      var pinchScale = dist(pinchEnd) / dist(pinchPre);
	      !isFinite(pinchScale) && (pinchScale = 1);
	      event.pinchScale = pinchScale;
	      var pinchCenter = center(pinchEnd);
	      event.pinchX = pinchCenter[0];
	      event.pinchY = pinchCenter[1];
	      return {
	        type: 'pinch',
	        target: track[0].target,
	        event: event
	      };
	    }
	  } // Only pinch currently.
	
	};
	var _default = GestureMgr;
	module.exports = _default;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var util = __webpack_require__(77);
	    var BPMNNode = __webpack_require__(79);
	    var BPMNModel = __webpack_require__(82);
	    var StartEventNode = __webpack_require__(84);
	    var EndEventNode = __webpack_require__(86);
	    var UserTaskNode = __webpack_require__(87);
	    var ManualTaskNode = __webpack_require__(89);
	    var ScriptTaskNode = __webpack_require__(90);
	    var MailTaskNode = __webpack_require__(91);
	    var ServiceTaskNode = __webpack_require__(92);
	    var SmsTaskNode = __webpack_require__(93);
	    var CommentNode = __webpack_require__(94);
	    var CatchTimerEventNode = __webpack_require__(95);
	    var CatchSignalEventNode = __webpack_require__(96);
	    var ThrowSignalEventNode = __webpack_require__(97);
	    var CatchMessageEventNode = __webpack_require__(98);
	    var InclusiveGatewayNode = __webpack_require__(99);
	    var ExclusiveGatewayNode = __webpack_require__(101);
	    var ParallelGatewayNode = __webpack_require__(102);
	    var SubPrcessNode = __webpack_require__(103);
	    var Bpmn = __webpack_require__(104);
	    /**
	     * 根据结点数组 导出JSON格式的数据
	     *
	     * @param {Array} nodes 结点数组
	     * @param {String} bpmnModel bpmn的model
	     * @param {Array} connectors 所有连线
	     * @return {JSON} JSON格式的数据
	     */
	    function toJson(bpmnModel, nodes, connectors) {
	        var jsonArr = [];
	        for(var i = 0; i < nodes.length;i++){
	            var node = nodes[i];
	            //去掉子流程里面的节点
	            if (node.parent && Bpmn.isSubProcess(node.parent)) {
	                continue;
	            }
	            if( node && node.toJSON) {
	                jsonArr.push(node.toJSON());
	            }
	        }
	        //增加线
	        for(var j = 0; j < connectors.length;j++){
	            var connector = connectors[j];
	            //去掉子流程里面的线段
	            if (connector.parent && Bpmn.isSubProcess(connector.parent)) {
	                continue;
	            }
	            if( connector && connector.toJSON) {
	                jsonArr.push(connector.toJSON());
	            }
	        }
	        bpmnModel.set("childShapes", jsonArr);
	
	
	        return bpmnModel.option;
	    }
	
	    /**
	     * 根据 JSON 生成节点
	     * @param  {[type]} fishTopoBpmn [description]
	     * @param  {[type]} json         [description]
	     * @return {[type]}              [description]
	     */
	    function fromJson(fishTopoBpmn, json) {
	        // 1.清空画布
	        fishTopoBpmn.clear(true);
	
	        // 2.先创建节点  遍历形状 获取模型
	        var bpmnModel = new BPMNModel(json);
	
	        fishTopoBpmn.model = bpmnModel;
	
	        var bpmnWidth = bpmnModel.get("properties.width");
	        var bpmnHeight = bpmnModel.get("properties.height");
	        if (bpmnWidth > 0 && bpmnHeight > 0) {
	            fishTopoBpmn.resize(bpmnWidth,bpmnHeight);
	        }
	        function loopAddSubNode(node, model) {
	            if (node.nodeType === Bpmn.SUB_PROCESS) {
	                var subShapes = model.get("childShapes");
	                for (var j = 0; j < subShapes.length; j++) {
	                    var subModel = new BPMNModel(subShapes[j]);
	                    if(Bpmn.isFlowModel(subModel)) {
	                        fishTopoBpmn.addConnectorByModel(subModel, node);
	                    } else {
	                        var superUpperLeft = model.get("bounds.upperLeft");
	                        var subUpperLeft = subModel.get("bounds.upperLeft");
	                        var subLowerRight = subModel.get("bounds.lowerRight");
	                        subModel.set("bounds.upperLeft", { x: subUpperLeft.x + superUpperLeft.x, y: subUpperLeft.y + superUpperLeft.y });
	                        subModel.set("bounds.lowerRight", { x: subLowerRight.x + superUpperLeft.x, y: subLowerRight.y + superUpperLeft.y });
	                        var subNode = fishTopoBpmn.addNodeByModel(subModel,true,true);
	                        loopAddSubNode(subNode, subModel);
	                    }
	                }
	            }
	        }
	        var childShapes = bpmnModel.get("childShapes");
	        var connectors = [];
	        for (var i = 0; i < childShapes.length; i++) {
	            var shape = childShapes[i];
	            var type = shape.stencil.type;
	            if (type === Bpmn.SEQUENCE_FLOW) {
	                connectors.push(shape);
	            } else {
	                var model = new BPMNModel(shape);
	                var createdNode = fishTopoBpmn.addNodeByModel(model,false,true);
	                loopAddSubNode(createdNode, model);
	            }
	        }
	        // 3. 再创建线
	        for(var k = 0, len = connectors.length; k < len; k++) {
	            var modelLine = new BPMNModel(connectors[k]); // shape
	            fishTopoBpmn.addConnectorByModel(modelLine);
	        }
	
	        // 4.创建事件插槽
	        for (var m = 0; m < childShapes.length; m++) {
	            if (childShapes[m].properties.slotEvent) {
	                for(var n = 0;n < childShapes[m].properties.slotEvent.length; n++){
	                    findNodeById(fishTopoBpmn,childShapes[m].resourceId).slotEvent.push(findNodeById(fishTopoBpmn,childShapes[m].properties.slotEvent[n]))
	                }
	            }
	
	        }
	
	    }
	
	    /**
	     * 根据id在fishTopoBpmn中查找
	     * @param  {[type]} fishTopoBpmn  [description]
	     * @param  {[type]} nodeId [description]
	     * @return {[type]}        [description]
	     */
	    function findNodeById(fishTopoBpmn, nodeId) {
	        var node;
	        for (var i = fishTopoBpmn.allNodes.length - 1; i >= 0; i--) {
	            if (fishTopoBpmn.allNodes[i].model.get("resourceId") == nodeId) {
	                node = fishTopoBpmn.allNodes[i];
	            }
	        }
	        return node;
	    }
	
	
	
	    function registerBPMNNode () {
	        BPMNNode.registerClass(StartEventNode, "StartNoneEvent");
	        BPMNNode.registerClass(EndEventNode, "EndNoneEvent");
	        BPMNNode.registerClass(UserTaskNode, "UserTask");
	        BPMNNode.registerClass(ManualTaskNode, "ManualTask");
	        BPMNNode.registerClass(ScriptTaskNode, "ScriptTask");
	        BPMNNode.registerClass(MailTaskNode, "MailTask");
	        BPMNNode.registerClass(ServiceTaskNode, "ServiceTask");
	        BPMNNode.registerClass(SmsTaskNode, "SmsTask");
	        BPMNNode.registerClass(CommentNode, "Comment");
	        BPMNNode.registerClass(CatchTimerEventNode, "CatchTimerEvent");
	        BPMNNode.registerClass(CatchMessageEventNode, "CatchMessageEvent");
	        BPMNNode.registerClass(CatchSignalEventNode, "CatchSignalEvent");
	        BPMNNode.registerClass(ThrowSignalEventNode, "ThrowSignalEvent");
	        BPMNNode.registerClass(InclusiveGatewayNode, "InclusiveGateway");
	        BPMNNode.registerClass(ExclusiveGatewayNode, "ExclusiveGateway");
	        BPMNNode.registerClass(ParallelGatewayNode, "ParallelGateway");
	        BPMNNode.registerClass(SubPrcessNode, "SubProcess");
	    }
	
	    function parentX(node) {
	        if (node.parent && Bpmn.isSubProcess(node.parent)) {
	            return node.position[0] + parentX(node.parent)
	        } else {
	            return node.position[0]
	        }
	    }
	
	    function parentY(node) {
	        if (node.parent && Bpmn.isSubProcess(node.parent)) {
	            return node.position[1] + parentY(node.parent)
	        } else {
	            return node.position[1]
	        }
	    }
	
	    function getParentNode(node) {
	        if (node.parent && Bpmn.isSubProcess(node.parent)) {
	            return getParentNode(node.parent);
	        } else {
	            return node;
	        }
	    }
	
	    function isHover(node, x, y) {
	        var cx , cy;
	        if(node.parent){
	            if(Bpmn.isSubProcess(node.parent)){
	                cx = x - parentX(node.parent);
	                cy = y - parentY(node.parent);
	                return node.rectContain(cx, cy)
	            }
	        }else{
	            return node.rectContain(x, y);
	        }
	
	     }
	
	    function findHover(list, x, y, excludes) {
	        for (var i = list.length - 1; i >= 0 ; i--) {
	            if (isExclude(excludes,list[i]) //list[i] !== exclude
	             // getDisplayList may include ignored item in VML mode
	             && !list[i].ignore
	             && isHover(list[i], x, y)) {
	                return list[i];
	            }
	        }
	    }
	
	
	    function isExclude(excludes, node) {
	        return zrUtil.indexOf(excludes,node) == -1;
	     }
	
	
	
	
	    var BpmnUtil = {
	        toJson: toJson,
	        fromJson: fromJson,
	        registerBPMNNode: registerBPMNNode,
	        findHover: findHover,
	        parentX: parentX,
	        parentY: parentY,
	        getParentNode: getParentNode,
	        getUUID: util.getUUID
	    };
	    module.exports = BpmnUtil;
	


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 工具方法类
	 * @author wang.xiaohu
	 */
	
	    var Point = __webpack_require__(64);
	    var Line = __webpack_require__(78);
	    var BoundingRect = __webpack_require__(26);
	    var zrUtil = __webpack_require__(4);
	    /**
	     * 构造类继承关系
	     *
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    function getUUID() {
	        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),
	            uuid = new Array(36),
	            rnd = 0,
	            r;
	        for (var i = 0; i < 36; i++) {
	            if (i == 8 || i == 13 || i == 18 || i == 23) {
	                uuid[i] = '-';
	            } else if (i == 14) {
	                uuid[i] = '4';
	            } else {
	                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
	                r = rnd & 0xf;
	                rnd = rnd >> 4;
	                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
	            }
	        }
	        return "sid-" + uuid.join('');
	    }
	
	
	    /**
	     * 计算两点之间的距离
	     *@param {Point} p1 - first {Point}
	     *@param {Point} p2 - second {Point}
	     *@return {Number} - the distance between those 2 points. It is always positive.
	     **/
	    function distance(p1, p2) {
	        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
	    }
	
	    /**
	     * 返回一条折线 最长的两个点
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    function getMaxLineLength(points) {
	        var m = distance(points[0], points[1]);
	        var result = [points[0], points[1]];
	        for (var i = 1; i < points.length - 1; i++) {
	
	            if (m < distance(points[i], points[i + 1])) {
	                m = distance(points[i], points[i + 1])
	                result = [points[i], points[i + 1]];
	            }
	        }
	
	        return result;
	    }
	
	    /**Returns the length of a Polyline that would be created with a set of points
	     *@param {Array} v - an {Array} of {Points}
	     *@return {Number} - a positive number equal with total length*/
	    function getPolylineLength(v) {
	        var l = 0;
	        for (var i = 0; i < v.length - 1; i++) {
	            l += distance(v[i], v[i + 1]);
	        }
	
	        return l;
	    }
	
	
	    /**Returns the max of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the maximum number from the vector or NaN if vector is empty
	     **/
	    function max(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m < v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	
	    /**Returns the min of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the minimum number from the vector or NaN if vector is empty
	     *@author alex@scriptoid.com
	     **/
	    function min(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m > v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	    /**
	     * 判断 点数组 是否正交直线路径
	     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function orthogonalPath(v) {
	        if (v.length <= 1) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 1; i++) {
	            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	
	
	    /**
	     *Test to see if 2 {Line}s intersects. They are considered finite segments
	     *and not the infinite lines from geometry
	     *@param {Line} l1 - fist line/segment
	     *@param {Line} l2 - last line/segment
	     *@return {Boolean} true - if the lines intersect or false if not
	     **/
	    function lineIntersectsLine(l1, l2) {
	        // check for two vertical lines
	        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {
	            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,
	                // then check segment bounds for overlapping
	                l1.contains(l2.startPoint.x, l2.startPoint.y) ||
	                l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                // lines are paralel
	                false;
	        }
	        // if one line is vertical, and another line is not vertical
	        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {
	            // let assume l2 is vertical, otherwise exchange them
	            if (l1.startPoint.x == l1.endPoint.x) {
	                var l = l1;
	                l1 = l2;
	                l2 = l;
	            }
	            // finding intersection of 'infinite' lines
	            // equation of the first line is y = ax + b, second: x = c
	            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b = l1.startPoint.y - a * l1.startPoint.x;
	            var x0 = l2.startPoint.x;
	            var y0 = a * x0 + b;
	            return l1.contains(x0, y0) && l2.contains(x0, y0);
	        }
	
	        // check normal case - both lines are not vertical
	        else {
	            //line equation is : y = a*x + b, b = y - a * x
	            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;
	
	            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);
	            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;
	
	            if (a1 == a2) { //paralel lines
	                return b1 == b2 ?
	                    // for coincide lines, check for segment bounds overlapping
	                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                    // not coincide paralel lines have no chance to intersect
	                    false;
	            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment
	
	                /*
	                 * if one of the lines are vertical, then x0 is equal to their x,
	                 * otherwise:
	                 * y1 = a1 * x + b1
	                 * y2 = a2 * x + b2
	                 * => x0 = (b2 - b1) / (a1 - a2)
	                 * => y0 = a1 * x0 + b1
	                 **/
	                x0 = (b2 - b1) / (a1 - a2);
	                y0 = a1 * x0 + b1;
	                return l1.contains(x0, y0) && l2.contains(x0, y0);
	            }
	        }
	    }
	
	    /**
	     *
	     *Tests if a a polyline defined by a set of points intersects a rectangle
	     *@param {Array} points - and {Array} of {Point}s
	     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)
	     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false
	     *
	     *@return true - if line intersects the rectangle, false - if not
	     **/
	    function polylineIntersectsRectangle(points, bounds, closedPolyline) {
	
	
	        //get the 4 lines/segments represented by the bounds
	        var lines = [];
	        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));
	        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));
	        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));
	        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));
	
	        for (var k = 0; k < points.length - 1; k++) {
	            //create a line out of each 2 consecutive points
	            var tempLine = new Line(points[k], points[k + 1]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var i = 0; i < lines.length; i++) {
	                if (lineIntersectsLine(tempLine, lines[i])) {
	                    return true;
	                }
	            }
	        }
	
	        //check the closed figure - that is last point connected to the first
	        if (closedPolyline) {
	            //create a line out of each 2 consecutive points
	            var tempLine1 = new Line(points[points.length - 1], points[0]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var j = 0; j < lines.length; j++) {
	                if (lineIntersectsLine(tempLine1, lines[j])) {
	                    return true;
	                }
	            }
	        }
	
	        return false;
	    }
	
	    /**
	     * 计算路径的分数
	     * Score a ortogonal path made out of Points
	     *Iterates over a set of points (minimum 3)
	     *For each 3 points (i, i+1, i+2) :
	     *  - if the 3rd one is after the 2nd on the same line we add +1
	     *  - if the 3rd is up or down related to the 2nd we do not do anything +0
	     *  - if the 3rd goes back we imediatelly return -1
	     *@param {Array} v - an array of {Point}s
	     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine
	     *  The bigger the number the smooth the path is
	     **/
	    function scorePath(v) {
	        if (v.length <= 2) {
	            return -1;
	        }
	
	        var score = 0;
	        for (var i = 1; i < v.length - 1; i++) {
	            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else { //not on same vertical nor horizontal
	                score--;
	            }
	        }
	
	        return score;
	    }
	
	    /**
	     * 返回数字符号（+ -)
	     * Returns the sign of a number
	     *@param {Number} x - the number
	     *@returns {Number}
	     *@see <a href="http://en.wikipedia.org/wiki/Sign_function">http://en.wikipedia.org/wiki/Sign_function</a>
	     **/
	    function signum(x) {
	        if (x > 0)
	            return 1;
	        else if (x < 0)
	            return -1;
	        else
	            return 0;
	    }
	
	    /**
	     * 判断 点数组 是不是有效路径（没有回路）
	     *Tests if a vector of points is a valid path (not going back)
	     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function forwardPath(v) {
	        if (v.length <= 2) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 2; i++) {
	            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            }
	        }
	
	        return true;
	    }
	
	    /**
	     * 将[x:0,y:0]转化为[0, 0]  给zrender使用
	     * @param  {[type]} points [description]
	     * @param  {[type]} isRevert [description]
	     * @return {[type]}        [description]
	     */
	    function traslatePoints(points, isRevert) {
	        var newPoints = [];
	        if (isRevert) {
	            for (var i = 0; i < points.length; i++) {
	                var point = points[i];
	                newPoints.push(new Point(point[0], point[1]));
	            }
	            return newPoints;
	        } else {
	            for (var j = 0; j < points.length; j++) {
	                var point1 = points[j];
	                newPoints.push([point1.x, point1.y]);
	            }
	            return newPoints;
	        }
	
	
	    }
	
	    function rotationMatrix(angle) {
	        var mReturn = [
	            [Math.cos(angle), -Math.sin(angle), 0],
	            [Math.sin(angle), Math.cos(angle), 0],
	            [0, 0, 1]
	        ];
	        return mReturn;
	    }
	
	    function translationMatrix(dx, dy) {
	        return [
	            [1, 0, dx],
	            [0, 1, dy],
	            [0, 0, 1]
	        ];
	    }
	
	    function scaleMatrix(sx, sy) {
	        if (sy == null) {
	            sy = sx;
	        }
	        return [
	            [sx, 0, 0],
	            [0, sy, 0],
	            [0, 0, 1]
	        ];
	    }
	
	    /** It will return the end point of a line on a given angle (clockwise).
	     * @param {Point} startPoint - the start of the line
	     * @param {Number} length - the length of the line
	     * @param {Number} angle - the angle of the line in radians
	     * @return {Point} - the endPoint of the line
	     */
	    function getEndPoint(startPoint, length, angle) {
	        var endPoint = startPoint.clone();
	        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));
	        endPoint.y -= length;
	        endPoint.transform(rotationMatrix(angle));
	        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));
	        return endPoint;
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} rect [description]
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getConnectorPoints(rect, node) {
	        node = node || {};
	        var boundingRect = zrUtil.clone(rect.boundingRect || rect);
	        var rotation = node.rotation;
	        var points = {
	            left: new Point(boundingRect.x, boundingRect.y + boundingRect.height / 2), //矩形 左中的位置
	            top: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y), //矩形 上中的位置
	            right: new Point(boundingRect.x + boundingRect.width, boundingRect.y + boundingRect.height / 2), //矩形 右中的位置
	            bottom: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y + boundingRect.height), //矩形 下中的位置
	            center: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y + boundingRect.height / 2) //中间位置
	
	        };
	        if (Object.keys(node).length > 0 && Math.abs(rotation) > 0) {
	            var rectNew = rect.boundingRect ? rect : getRect(node);
	            var center = { x: rectNew.x, y: rectNew.y }; // 中心点
	            Object.keys(points).forEach(function(key) {
	                var value = points[key];
	                var x0 = center.x - value.x;
	                var y0 = center.y - value.y;
	                var sin = Math.sin(-rotation);
	                var cos = Math.cos(-rotation);
	                var position_n_x = center.x - (x0 * cos - y0 * sin);
	                var position_n_y = center.y - (x0 * sin + y0 * cos);
	                points[key].x = position_n_x;
	                points[key].y = position_n_y;
	            });
	        }
	        return points;
	    }
	
	    /**
	     * 获取节点外面四个控制点和旋转点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getConnectorControls(rect, node) {
	        node = node || {};
	        var boundingRect = zrUtil.clone(rect.boundingRect);
	        var rotation = node.rotation;
	        var controls = {
	            tl: new Point(boundingRect.x, boundingRect.y), //矩形 左上角位置
	            tc: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y - 4), //矩形 上中位置
	            tr: new Point(boundingRect.x + boundingRect.width, boundingRect.y), //矩形 右上角位置
	            bl: new Point(boundingRect.x, boundingRect.y + boundingRect.height), //矩形 左下角
	            br: new Point(boundingRect.x + boundingRect.width, boundingRect.y + boundingRect.height), //矩形 右下角位置
	            mtr: new Point(boundingRect.x + boundingRect.width / 2, boundingRect.y - 20) // 旋转点位置
	        };
	        if (Object.keys(node).length > 0 && Math.abs(rotation) > 0) {
	            var rectNew = rect;
	            var center = { x: rectNew.x, y: rectNew.y }; // 中心点
	            Object.keys(controls).forEach(function(key) {
	                var value = controls[key];
	                var x0 = center.x - value.x;
	                var y0 = center.y - value.y;
	                var sin = Math.sin(-rotation);
	                var cos = Math.cos(-rotation);
	                var position_n_x = center.x - (x0 * cos - y0 * sin);
	                var position_n_y = center.y - (x0 * sin + y0 * cos);
	                controls[key].x = position_n_x;
	                controls[key].y = position_n_y;
	            });
	        }
	        return controls;
	    }
	
	    /**
	     * 根据中心点和旋转弧度，计算旋转后的点坐标
	     * @param  {[object|array]} points [原坐标]
	     * @param  {[object]}       center [中心点]
	     * @param  {[number]}       rotation [旋转弧度]
	     * @return {[type]}      [description]
	     */
	    function calculatePoints(points, center, rotation) {
	        var x = Array.isArray(points) ? points[0] : points.x;
	        var y = Array.isArray(points) ? points[1] : points.y;
	        var x0 = center.x - x;
	        var y0 = center.y - y;
	        var sin = Math.sin(-rotation);
	        var cos = Math.cos(-rotation);
	        var position_n_x = center.x - (x0 * cos - y0 * sin);
	        var position_n_y = center.y - (x0 * sin + y0 * cos);
	        if (Array.isArray(points)) {
	            return [position_n_x, position_n_y];
	        }
	        return {
	            x: position_n_x,
	            y: position_n_y
	        }
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getSoltPoints(node) {
	        return [
	            //top
	            [Math.round(node.getRect().width / 3 /10)*10, 0 ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],
	            //right
	            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],
	            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],
	            //bottom
	            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],
	            //left
	            [0, Math.round(node.getRect().height / 3 /10)*10 ],
	            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]
	
	        ]
	    }
	
	    /**
	     * 计算 p1 p2两点所连接的直线的角度
	     * @param  {[type]} p1 [description]
	     * @param  {[type]} p2 [description]
	     * @return {[type]}    [description]
	     */
	    function tangentRotation(p1, p2) {
	        return -Math.PI / 2 - Math.atan2(
	            p2.y - p1.y, p2.x - p1.x
	        );
	    }
	
	    /**
	     * 判断3点是否在一条直线上
	     * Tests if 3 points are coliniar with matrix determinants.
	     * If the determinat of matrix
	     * /         \
	     * | x1 y1 1 |
	     * | x2 y2 1 |
	     * | x3 y3 1 |
	     * \         /
	     * is zero it means that the points are colinear
	     *@param {Point} p1 - first point
	     *@param {Point} p2 - second point
	     *@param {Point} p3 - third point
	     * @param {Number} precission
	     *@return {Boolean} - true if coliniar and false if not
	     *@author Alex
	     *@see http://en.wikipedia.org/wiki/Determinant
	     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html
	     **/
	    function collinearity(p1, p2, p3, precission) {
	        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);
	
	        if (precission) {
	            return Math.abs(determinant) <= precission;
	        } else {
	            return determinant === 0;
	        }
	    }
	
	
	    /**
	     * 四舍五入 保存decimals的小数
	     **/
	    function enhancedRound(number, decimals) {
	        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	    }
	
	    /**
	     * 获取两点之间的长度
	     **/
	    function getLength(startPoint, endPoint) {
	        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));
	    }
	
	    /**
	     * 获取角度
	     * @param  {[type]} centerPoint  [description]
	     * @param  {[type]} outsidePoint [description]
	     * @param  {[type]} round        [description]
	     * @return {[type]}              [description]
	     */
	    function getAngle(centerPoint, outsidePoint, round) {
	        centerPoint.x = enhancedRound(centerPoint.x, 5);
	        centerPoint.y = enhancedRound(centerPoint.y, 5);
	        outsidePoint.x = enhancedRound(outsidePoint.x, 5);
	        outsidePoint.y = enhancedRound(outsidePoint.y, 5);
	        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));
	        angle = -angle;
	
	        //endAngle+=90;
	        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {
	            angle += Math.PI * 2;
	        }
	        while (angle >= Math.PI * 2) {
	            angle -= Math.PI * 2;
	        }
	        if (isNaN(angle)) { //Nan
	            angle = 0; //we are at center point;
	        }
	        if (round) {
	            angle = Math.round(angle / round) * round
	        }
	        return angle;
	    }
	
	    /**
	     * 获取父节点的position[0]
	     * @param  {object} node  [节点]
	     * @param  {string} parentKey [判断是否有指定父节点的key,对于group是type；对于subprocess是nodeType]
	     * @param  {string} parentValue  [判断是否有指定父节点的value,对于group是GroupNode；对于subprocess是SubProcess]
	     * @return {number}              父节点的position[0]
	     */
	    function getParentX(node, parentKey, parentValue) {
	        if (!parentKey) {
	            parentKey = 'type';
	        }
	        if (!parentValue) {
	            parentValue = 'GroupNode';
	        }
	        if (node.parent && node.parent[parentKey] === parentValue) {
	            return node.position[0] + getParentX(node.parent)
	        } else {
	            return node.position[0]
	        }
	    }
	
	    /**
	     * 获取父节点的position[1]
	     * @param  {object} node  [节点]
	     * @param  {string} parentKey [判断是否有指定父节点的key,对于group是type；对于subprocess是nodeType]
	     * @param  {string} parentValue  [判断是否有指定父节点的value,对于group是GroupNode；对于subprocess是SubProcess]
	     * @return {number}              父节点的position[1]
	     */
	    function getParentY(node, parentKey, parentValue) {
	        if (!parentKey) {
	            parentKey = 'type';
	        }
	        if (!parentValue) {
	            parentValue = 'GroupNode';
	        }
	        if (node.parent && node.parent[parentKey] === parentValue) {
	            return node.position[1] + getParentY(node.parent)
	        } else {
	            return node.position[1]
	        }
	    }
	
	    function getRect(node, isCalcParent) {
	        var clipPath = node.clipPath;
	            var rect = node.getBoundingRect();
		        // 节点裁剪后，以裁剪节点包围盒为准
		        if (clipPath) {
		            rect = clipPath.getBoundingRect();
		        }
	            var boundingRect = zrUtil.clone(rect);
		        //创建最小包围盒虚线
	            var points = [];
	            var width = (boundingRect.x >= -1 && boundingRect.x <= 0) ? Number(boundingRect.width) + Number(boundingRect.x) * 2 : Number(boundingRect.width);
	            var height = (boundingRect.y >= -1 && boundingRect.y <= 0) ? Number(boundingRect.height) + Number(boundingRect.y) * 2 : Number(boundingRect.height);
		        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];
		        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];
		        points[2] = [boundingRect.width / 2, boundingRect.height / 2];
		        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];
		        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];
	
		        var positionX = node.position[0];
		        var positionY = node.position[1];
		        //这里要循环判断一把 有没有父节点 并且父节点不是根节点 然后进行相加
		        if (node.parent && isCalcParent) {
		            if (node.parent.type === 'GroupNode' || node.parent.nodeType === 'SubProcess') {
		                positionX += getParentX(node.parent);
		                positionY += getParentY(node.parent);
		            }
		        }
	
		        var boundRect = new BoundingRect(
	                    (boundingRect.x >= -1 && boundingRect.x <= 0) ? Number(positionX) : Number(positionX + boundingRect.x),   //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半
		                (boundingRect.y >= -1 && boundingRect.y <= 0) ? Number(positionY) : Number(positionY + boundingRect.y),
		                Number(width),
		                Number(height)
	                );
		        //中心点
		        var cx = Number(positionX) + Number(boundingRect.width) / 2 + Number(boundingRect.x);
		        var cy = Number(positionY) + Number(boundingRect.height) / 2 + Number(boundingRect.y);
		        return {
		            x: Number(cx),
		            y: Number(cy),
		            width: width,
		            height: height,
		            points: points,
		            boundingRect: boundRect
		        };
	    }
	
	    var StackedMap = {
	        createNew: function() {
	            var stack = [];
	
	            return {
	                add: function(key, value) {
	                    var arrKey = this.get(key);
	                    arrKey.push(value)
	
	                },
	                // 获取起始点有offset间隔的arrKey
	                getsimilar: function(key) {
	                    var value = [];
	                    var keyArr = key.split(',');
	                    stack.forEach(function(item) {
	                        var itemKeyArr = item.key.split(',');
	                        if (itemKeyArr[0].indexOf(keyArr[0]) > -1 && itemKeyArr[1].indexOf(keyArr[1]) > -1) {
	                            value = value.concat(item.value);
	                        }
	                    });
	                    if (value.length <= 0) {
	                        stack.push({ key: key, value: value });
	                    }
	                    return value;
	                },
	                get: function(key) {
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            return stack[i].value;
	                        }
	                    }
	                    //如果没有找到的话，则创建一个新的数组
	                    var value = [];
	                    stack.push({ key: key, value: value });
	                    return value;
	                },
	                keys: function() {
	                    var keys = [];
	                    for (var i = 0; i < stack.length; i++) {
	                        keys.push(stack[i].key);
	                    }
	                    return keys;
	                },
	                top: function() {
	                    return stack[stack.length - 1];
	                },
	                remove: function(key) {
	                    var idx = -1;
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            idx = i;
	                            break;
	                        }
	                    }
	                    return stack.splice(idx, 1)[0];
	                },
	                removeItem: function(key, item) {
	                    var arrKey = this.get(key);
	                    var index = zrUtil.indexOf(arrKey, item);
	                    arrKey.splice(index, 1);
	
	                },
	                removeTop: function() {
	                    return stack.splice(stack.length - 1, 1)[0];
	                },
	                length: function() {
	                    return stack.length;
	                },
	                clear: function() {
	                    stack.splice(0, stack.length);
	                }
	            };
	        }
	    };
	
	    function randomColor() {
	        var arrHex = ["0", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d"],
	            strHex = "#",
	            index;
	        for (var i = 0; i < 6; i++) {
	            index = Math.round(Math.random() * 15);
	            strHex += arrHex[index];
	        }
	        return strHex;
	    }
	
	    function isUndefined(obj) {
	        return obj === void 0;
	    }
	
	    function collinearReduction (v) {
	        var r = [];
	
	        if(v.length < 3){
	            return Point.cloneArray(v);
	        }
	
	        r.push( v[0].clone() );
	        for(var i=1; i < v.length-1; i++){
	            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )
	            {
	                continue;
	            }
	            else{
	                r.push( v[i].clone() );
	            }
	        }
	        r.push( v[v.length-1].clone() );
	
	        return r;
	    }
	
	    // By default, Underscore uses ERB-style template delimiters, change the
	    // following template settings to use alternative delimiters.
	    var templateSettings = {
	        evaluate: /<%([\s\S]+?)%>/g,
	        interpolate: /<%=([\s\S]+?)%>/g,
	        escape: /<%-([\s\S]+?)%>/g
	    };
	
	    // When customizing `templateSettings`, if you don't want to define an
	    // interpolation, evaluation or escaping regex, we need one that is
	    // guaranteed not to match.
	    var noMatch = /(.)^/;
	
	    // Certain characters need to be escaped so that they can be put into a
	    // string literal.
	    var escapes = {
	        "'": "'",
	        '\\': '\\',
	        '\r': 'r',
	        '\n': 'n',
	        '\u2028': 'u2028',
	        '\u2029': 'u2029'
	    };
	
	    var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
	
	    var escapeChar = function(match) {
	        return '\\' + escapes[match];
	    };
	
	    // JavaScript micro-templating, similar to John Resig's implementation.
	    // Underscore templating handles arbitrary delimiters, preserves whitespace,
	    // and correctly escapes quotes within interpolated code.
	    // NB: `oldSettings` only exists for backwards compatibility.
	    function template(text, settings, oldSettings) {
	        if (!settings && oldSettings) settings = oldSettings;
	        settings = settings || {};
	        settings = zrUtil.defaults(settings, templateSettings, true);
	
	        // Combine delimiters into one regular expression via alternation.
	        var matcher = RegExp([
	            (settings.escape || noMatch).source,
	            (settings.interpolate || noMatch).source,
	            (settings.evaluate || noMatch).source
	        ].join('|') + '|$', 'g');
	
	        // Compile the template source, escaping string literals appropriately.
	        var index = 0;
	        var source = "__p+='";
	        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	            source += text.slice(index, offset).replace(escaper, escapeChar);
	            index = offset + match.length;
	
	            if (escape) {
	                source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	            } else if (interpolate) {
	                source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	            } else if (evaluate) {
	                source += "';\n" + evaluate + "\n__p+='";
	            }
	
	            // Adobe VMs need the match returned to produce the correct offest.
	            return match;
	        });
	        source += "';\n";
	
	        // If a variable is not specified, place data values in local scope.
	        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	
	        source = "var __t,__p='',__j=Array.prototype.join," +
	            "print=function(){__p+=__j.call(arguments,'');};\n" +
	            source + 'return __p;\n';
	
	        try {
	            var render = new Function(settings.variable || 'obj', source);
	        } catch (e) {
	            e.source = source;
	            throw e;
	        }
	
	        var template = function(data) {
	            return render.call(this, data);
	        };
	
	        // Provide the compiled source as a convenience for precompilation.
	        var argument = settings.variable || 'obj';
	        template.source = 'function(' + argument + '){\n' + source + '}';
	
	        return template;
	    }
	
	    function isEmpty(obj) {
	        if (obj == null) return true;
	        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;
	    }
	    function mergeOpt(target, source, overwrite, exclude) {
	        // We should escapse that source is string
	        // and enter for ... in ...
	        if (!zrUtil.isObject(source) || !zrUtil.isObject(target)) {
	          return overwrite ? zrUtil.clone(source) : target;
	        }
	
	        for (var key in source) {
	          if (source.hasOwnProperty(key)) {
	            var targetProp = target[key];
	            var sourceProp = source[key];
	
	            if (zrUtil.isObject(sourceProp) && zrUtil.isObject(targetProp) && !zrUtil.isArray(sourceProp) && !zrUtil.isArray(targetProp) && !zrUtil.isDom(sourceProp) && !zrUtil.isDom(targetProp) && !zrUtil.isBuiltInObject(sourceProp) && !zrUtil.isBuiltInObject(targetProp) && !zrUtil.isPrimitive(sourceProp) && !zrUtil.isPrimitive(targetProp)) {
	              // 如果需要递归覆盖，就递归调用merge
	              mergeOpt(targetProp, sourceProp, overwrite, exclude);
	            } else if (overwrite || !(key in target)) {
	              // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	              // NOTE，在 target[key] 不存在的时候也是直接覆盖
	                if (key !== exclude) {
	                    target[key] = zrUtil.clone(source[key], true);
	                }
	            }
	          }
	        }
	        return target;
	    }
	    function Class() {}
	    Class.extend = function(proto) {
	        var base = function() {},
	            member,
	            that = this,
	            subclass = proto && proto.init ? proto.init : function () {
	                that.apply(this, arguments);
	            },
	            fn;
	
	        base.prototype = that.prototype;
	        fn = subclass.fn = subclass.prototype = new base();
	
	        for (member in proto) {
	            if (proto[member] != null && proto[member].constructor === Object) {
	                // Merge object members
	                fn[member] = zrUtil.mergeAll([{}, base.prototype[member], proto[member]],true);
	            } else {
	                fn[member] = proto[member];
	            }
	        }
	
	        fn.constructor = subclass;
	        subclass.extend = that.extend;
	
	        return subclass;
	    };
	
	    module.exports = {
	        inherits: inherits,
	        getUUID: getUUID,
	        distance: distance,
	        getPolylineLength: getPolylineLength,
	        max: max,
	        min: min,
	        isEmpty: isEmpty,
	        mergeOpt: mergeOpt,
	        orthogonalPath: orthogonalPath,
	        polylineIntersectsRectangle: polylineIntersectsRectangle,
	        scorePath: scorePath,
	        forwardPath: forwardPath,
	        traslatePoints: traslatePoints,
	        getEndPoint: getEndPoint,
	        getConnectorPoints: getConnectorPoints,
	        getConnectorControls: getConnectorControls,
	        calculatePoints: calculatePoints,
	        tangentRotation: tangentRotation,
	        collinearity: collinearity,
	        translationMatrix: translationMatrix,
	        scaleMatrix: scaleMatrix,
	        round: enhancedRound,
	        getLength: getLength,
	        getAngle: getAngle,
	        getParentX: getParentX,
	        getParentY: getParentY,
	        getRect: getRect,
	        StackedMap: StackedMap,
	        getMaxLineLength: getMaxLineLength,
	        randomColor: randomColor,
	        template: template,
	        isUndefined: isUndefined,
	        getSoltPoints:getSoltPoints,
	        collinearReduction: collinearReduction,
	        Class:Class
	    };
	


/***/ }),
/* 78 */
/***/ (function(module, exports) {

	
	
	    /**
	      * Creates an instance of a Line. A Line is actually a segment and not a pure
	      * geometrical Line
	      *
	      * @constructor
	      * @this {Line}
	      * @param {Point} startPoint - starting point of the line
	      * @param {Point} endPoint - the ending point of the line
	      **/
	    function Line(startPoint, endPoint){
	        /**Starting {@link Point} of the line*/
	        this.startPoint = startPoint;
	
	        /**Ending {@link Point} of the line*/
	        this.endPoint = endPoint;
	
	        /**Serialization type*/
	        this.oType = 'Line'; //object type used for JSON deserialization
	    }
	
	    /**Creates a {Line} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Line} a newly constructed Line
	     **/
	    Line.load = function(o){
	        var newLine = new Line(
	            Point.load(o.startPoint),
	            Point.load(o.endPoint)
	        );
	
	        return newLine;
	    };
	
	    Line.prototype = {
	        contructor: Line,
	
	
	
	        clone:function(){
	            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());
	            return ret;
	        },
	
	        equals:function(anotherLine){
	            if(!anotherLine instanceof Line){
	                return false;
	            }
	            return this.startPoint.equals(anotherLine.startPoint)
	            && this.endPoint.equals(anotherLine.endPoint)
	        },
	
	        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)
	         * Algorithm: Compute line's equation and see if (x, y) verifies it.
	         * @param {Number} x - the X coordinates
	         * @param {Number} y - the Y coordinates
	         **/
	        contains: function(x, y){
	            // if the point is inside rectangle bounds of the segment
	            if (Math.min(this.startPoint.x, this.endPoint.x) <= x
	                && x <= Math.max(this.startPoint.x, this.endPoint.x)
	                && Math.min(this.startPoint.y, this.endPoint.y) <= y
	                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {
	
	                // check for vertical line
	                if (this.startPoint.x == this.endPoint.x) {
	                    return x == this.startPoint.x;
	                } else { // usual (not vertical) line can be represented as y = a * x + b
	                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);
	                    var b = this.startPoint.y - a * this.startPoint.x;
	                    return y == a * x + b;
	                }
	            } else {
	                return false;
	            }
	        },
	
	        /*
	         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)
	         *@param {Number} x - the x coordinates
	         *@param {Number} y - the y coordinates
	         *@param {Number} radius - the radius to search for
	         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	         *@see "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	         **/
	        near:function(x,y,radius){
	
	            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle
	                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)
	                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))
	                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;
	            }
	
	            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle
	                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)
	                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))
	                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;
	            }
	
	
	            var startX = Math.min(this.endPoint.x,this.startPoint.x);
	            var startY = Math.min(this.endPoint.y,this.startPoint.y);
	            var endX = Math.max(this.endPoint.x,this.startPoint.x);
	            var endY = Math.max(this.endPoint.y,this.startPoint.y);
	
	            /*We will compute the distance from point to the line
	             * by using the algorithm from
	             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	             * */
	
	            //First we need to find a,b,c of the line equation ax + by + c = 0
	            var a = this.endPoint.y - this.startPoint.y;
	            var b = this.startPoint.x - this.endPoint.x;
	            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);
	
	            //Secondly we get the distance "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );
	
	            //Thirdly we get coordinates of closest line's point to target point
	            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates
	            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	
	            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment
	                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment
	
	            return  r;
	
	        },
	
	        /**we need to create a new array each time, or we will affect the actual shape*/
	        getPoints:function(){
	            var points = [];
	            points.push(this.startPoint);
	            points.push(this.endPoint);
	            return points;
	        },
	
	        /**Return the {Point} corresponding the t certain t value
	         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/
	        getPoint: function(t){
	            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;
	            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;
	
	            return new Point(Xp, Yp);
	        },
	
	        // /**
	        //  * Returns the middle of the line
	        //  * @return {Point} the middle point
	        //  * */
	        // getMiddle : function(){
	        //     return Util.getMiddle(this.startPoint, this.endPoint);
	        // },
	
	
	        // getLength : function(){
	        //     return Util.getLength(this.startPoint, this.endPoint);
	        // },
	
	        // /**
	        //  *Get bounds for this line
	        //  *@author Alex Gheorghiu <alex@scriptoid.com>
	        //  **/
	        // getBounds:function(){
	        //     return Util.getBounds(this.getPoints());
	        // },
	
	        /**String representation*/
	        toString:function(){
	            return 'line(' + this.startPoint + ',' + this.endPoint + ')';
	        }
	    };
	    module.exports = Line;
	
	


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * BPMN节点类  所有的BPMN形状都继承与它，用户自定义节点可以继承它并注册即可使用
	 * @class fish.topo.FishTopoBpmn.BPMNNode
	 */
	
	
		var Node = __webpack_require__(80);
		var zrUtil = __webpack_require__(4);
		var graphic = __webpack_require__(3);
	    var clazzUtil = __webpack_require__(81);
		//创建Node类 所有形状都继承Node
		function BPMNNode(model, api) {
			Node.call(this);
			this.model = model;
			this.options =
			{
				outline: {
					enable: true, // 是否有外框
					radius: true, // 是否圆角
					initVisible: false
				},
				text: {
					color: '#000000', // 文本颜色
					lineHeight: 24 // 文本行高
				}
			};
			this.bpmnInfo = {type: -1, name:"BPMNDiagram", displayName:"Task" };    //节点信息
			var resourceId = model.get("resourceId");
			if(resourceId && resourceId != "") {
				this.resourceId = resourceId;
			}
	
	        //判断是否有operationNode
	        var prop = model.get("properties");
	        if (prop.operationIcons) {
	            this.operationIcons = prop.operationIcons;
	        }
			this.initEvent(api);
	    }
	    
	    function utf8Length(str) {
	        var m = encodeURIComponent(str).match(/%[89ABab]/g);
	        return str.length + (m ? m.length : 0);
	    }
	
	    BPMNNode.prototype.initEvent = function(api) {
	        var that = this;
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'
	
	
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            that.on(eveName, function (e) {
		            var params = {};
		            params.event = e;
		            params.type = eveName;
		            params.target = that;
		            api.trigger(eveName, params);
	            }, this);
	        });
	    };
	
	    /**
	     * 获取当前节点的包围和 相关参数
	     * @returns {{x:Number, y:Number, width:Number, height:Number, points:Array, boundingRect:Object}}
	     * @returns {Number} return.x 当前节点的中心点x值
	     * @returns {Number} return.y 当前节点的中心点y值
	     * @returns {Number} return.width 当前节点的宽度
	     * @returns {Number} return.height 当前节点的高度
	     * @returns {Array} return.points 当前节点的包围和 [左上角坐标，右上角坐标，右下角坐标，右下角坐标] 用于节点选中时包围虚线框
	     * @returns {Object} return.boundingRect 当前节点的包围矩形
	     */
	    BPMNNode.prototype.getRect = function() {
	    };
	
	    /**
	     * 返回当前节点的包围矩形
	     * @return {Object} 当前节点的包围矩形  一般不包括下面的文字
	     */
	    BPMNNode.prototype.getBoundingRect = function() {
	    };
	
	    /**
	     * 设置图元的位置
	     * @param {Number} x x坐标
	     * @param {Number} y y坐标
	     */
	    BPMNNode.prototype.setPosition  = function(x, y) {
	    };
	
	    /**
	     * @private
	     * 查看当前节点是否 包括x ,y 坐标
	     * @param  {number} x x坐标
	     * @param  {number} y y坐标
	     * @return {Boolean}   是否在范围内
	     */
	    BPMNNode.prototype.rectContain = function(x, y) {
	    	var rect = this.getRect();
	        return rect.boundingRect.contain(x,y);
	    };
	
	    /**
	     * 返回json对象
	     * @return {String} json对象
	     */
		BPMNNode.prototype.toJSON = function() {
			this.model.set("resourceId", this.resourceId);
			this.model.set("properties.type", this.bpmnInfo.type);
			this.model.set("stencil.type", this.bpmnInfo.name);  //stencil.id
	
	        if (this.slotEvent && this.slotEvent.length > 0) {
	            var arrSlotEvent = [];
	            for (var i = this.slotEvent.length - 1; i >= 0; i--) {
	                arrSlotEvent.push(this.slotEvent[i].resourceId)
	            }
	            this.model.set("properties.slotEvent", arrSlotEvent);
	        }
	        this.model.set("properties.type", this.bpmnInfo.type);
	
	        var rect = this.getRect().boundingRect;
	        this.model.set("bounds.upperLeft.x", parseInt(rect.x));
	        this.model.set("bounds.upperLeft.y", parseInt(rect.y));
	        this.model.set("bounds.lowerRight.x", parseInt(rect.x + rect.width));
	        this.model.set("bounds.lowerRight.y", parseInt(rect.y + rect.height));
			return this.model.option;
		};
	
		/**
	     * @private
	     * 根据属性设置模型数据
	     * @param {Object} option 模型数据
	     */
	    BPMNNode.prototype.setModel = function(option) {
	        var that = this, pos;
	        var originText = this.model.get("properties.name");
	        this.model.mergeOption(option);
	
	        function parentX(node) {
	            if (node.parent && node.parent.nodeType == "SubProcess") {
	                return node.position[0] + parentX(node.parent)
	            } else {
	                return node.position[0]
	            }
	        }
	    
	        function parentY(node) {
	            if (node.parent && node.parent.nodeType == "SubProcess") {
	                return node.position[1] + parentY(node.parent)
	            } else {
	                return node.position[1]
	            }
	        }
	
	        if(!option.properties.name && option.properties.name != '' && option.properties.name != '0') {
	            return;
	        }
	        if(originText != option.properties.name) {
	            var title = this.childOfName("Title");
	            var nameByteLength = utf8Length(option.properties.name);
	            var showName;
	            if(nameByteLength > 15){
	                showName = option.properties.name.substr(0,6)+'..';
	                if(this.alarm){
	                    this.alarm.isShow = true;
	                }
	            }else{
	                showName = option.properties.name;
	                if(this.alarm){
	                    this.alarm.isShow = false;
	                }
	
	            }
	            title.attr("style",{text:showName});
	            pos = option.properties.position ? option.properties.position : 'init';
	            that.refreshText(pos);
	           if(this.alarm) {
	                var name = option.properties.name;
	                var text = this.alarm.childOfName("Text");
	                text.attr("style",{text:name});
	                var groupWidth = text.getBoundingRect().width+4;
	                var groupHeight = text.getBoundingRect().height+8;
	                var points = [
	                    [0,0],
	                    [groupWidth,0],
	                    [groupWidth,groupHeight],
	                    [groupWidth-3,groupHeight],
	                    [groupWidth-6,groupHeight+3],
	                    [groupWidth-9,groupHeight],
	                    [0,groupHeight],
	                    [0,0]
	                ];
	                var Polyline = this.alarm.childOfName("Polyline");
	                Polyline.attr("shape",{points:points});
	                var posX = parentX(this), posY = parentY(this);
	                var groupPosition = [posX + this.getBoundingRect().width - (this.alarm.getBoundingRect().width-6), posY - this.alarm.getBoundingRect().height - 3];
	                this.alarm.attr("position",groupPosition);
	           }
	        }
	    };
	
	
		zrUtil.inherits(BPMNNode,Node);
	
	    /**
	     * 注册BPMN节点的类，只有注册过后，才能在BPMN编辑器中添加
	     * @method registerClass
	     * @param {Object} Clazz 继承了BPMNNode的实现类
	     * @param {String} componentType 注册类的名称
	     *
	     * **使用范例**：
	     *
	     *     @example
	     *     BPMNNode.registerClass(CustomNode, "CustomNode");
	     */
		clazzUtil.enableClassManagement(BPMNNode, {
	        registerWhenExtend: true
	    });
		module.exports = BPMNNode;
	
	
	


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var graphic = __webpack_require__(3);
	    var util = __webpack_require__(77)
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    function Node() {
	        this.resourceId = util.getUUID(); // 生成节点ID
	        graphic.Group.call(this);
	    }
	
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.render = function() {};
	
	    /**
	     * 由父类实现
	     * @param  {[type]} json [description]
	     * @return {[type]}      [description]
	     */
	    Node.prototype.getRect = function(json) {};
	
	    /**
	     * drawText
	     * @description 画一个文本
	     * @param {string} name
	     * @param {string} color
	     */
	    Node.prototype.drawText = function(name, color, position) {
	        var textName = this.bpmnInfo.name, x, y;
	        if(name != null){
	            textName = name;
	        }
	        var text = new graphic.Text({
	            style: {
	                text: textName,
	                color: color ? color : this.options.text.color,
	                textFont: '12px Microsoft YaHei'
	            },
	            zlevel: 20
	        });
	        //文字绘制的位置 
	        position = position ? position : 'init';
	        switch (position) {
	            //节点下方居中位置
	            case 'init': 
	                //x = 中心点.x - 起始位置.x - 文字宽度的一半
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                //y = 中心点.y - 起始位置.y + 偏移值（6）
	                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;
	                break;
	            //节点内部居中位置
	            case 'center':
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            //节点内部居左位置
	            case 'left': 
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width + 6;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            default: break;
	        }
	        text.attr("style", { x: x, y: y });
	        return {
	            text: text,
	            rect: text.getBoundingRect()
	        };
	    };
	    /**
	     * refreshText
	     * @description 刷新文本
	     */
	    Node.prototype.refreshText = function(pos) {
	        var text = this.childOfName("Title"), x, y;
	        pos = pos ? pos : 'init';
	        switch (pos) {
	            case 'init': 
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + 6;
	                break;
	            case 'center':
	                x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            case 'left':
	                x = 2;
	                y = this.getRect().y - this.position[1] - 6;
	                break;
	            default: break;
	        }
	        text.attr("style", { x: x, y: y });
	    };
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.toJSON = function() {};
	
	    graphic.Util.inherits(Node, graphic.Group);
	    module.exports = Node;
	


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var zrUtil = __webpack_require__(4);
	
	    var clazz = {};
	
	    var TYPE_DELIMITER = '.';
	    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';
	    /**
	     * @public
	     */
	    var parseClassType = clazz.parseClassType = function (componentType) {
	        var ret = {main: '', sub: ''};
	        if (componentType) {
	            componentType = componentType.split(TYPE_DELIMITER);
	            ret.main = componentType[0] || '';
	            ret.sub = componentType[1] || '';
	        }
	        return ret;
	    };
	    /**
	     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数
	     */
	    clazz.enableClassExtend = function (RootClass, preConstruct) {
	        RootClass.extend = function (proto) {
	            var ExtendedClass = function () {
	                preConstruct && preConstruct.apply(this, arguments);
	                RootClass.apply(this, arguments);
	            };
	
	            zrUtil.extend(ExtendedClass.prototype, proto);
	
	            ExtendedClass.extend = this.extend;
	            ExtendedClass.superCall = superCall;
	            ExtendedClass.superApply = superApply;
	            zrUtil.inherits(ExtendedClass, this);
	            ExtendedClass.superClass = this;
	
	            return ExtendedClass;
	        };
	    };
	
	    // superCall should have class info, which can not be fetch from 'this'.
	    // Consider this case:
	    // class A has method f,
	    // class B inherits class A, overrides method f, f call superApply('f'),
	    // class C inherits class B, do not overrides method f,
	    // then when method of class C is called, dead loop occured.
	    function superCall(context, methodName) {
	        var args = zrUtil.slice(arguments, 2);
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    function superApply(context, methodName, args) {
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    /**
	     * @param {Object} entity
	     * @param {Object} options
	     * @param {boolean} [options.registerWhenExtend]
	     * @public
	     */
	    clazz.enableClassManagement = function (entity, options) {
	        options = options || {};
	
	        /**
	         * Component model classes
	         * key: componentType,
	         * value:
	         *     componentClass, when componentType is 'xxx'
	         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
	         * @type {Object}
	         */
	        var storage = {};
	
	        entity.registerClass = function (Clazz, componentType) {
	            if (componentType) {
	                componentType = parseClassType(componentType);
	
	                if (!componentType.sub) {
	                    if (storage[componentType.main]) {
	                        //已经注册过了，直接返回
	                        return;
	                    }
	                    storage[componentType.main] = Clazz;
	                }
	                else if (componentType.sub !== IS_CONTAINER) {
	                    var container = makeContainer(componentType);
	                    container[componentType.sub] = Clazz;
	                }
	            }
	            return Clazz;
	        };
	
	        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {
	            var Clazz = storage[componentTypeMain];
	
	            if (Clazz && Clazz[IS_CONTAINER]) {
	                Clazz = subType ? Clazz[subType] : null;
	            }
	
	            if (throwWhenNotFound && !Clazz) {
	                throw new Error(
	                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'
	                );
	            }
	
	            return Clazz;
	        };
	
	        entity.getClassesByMainType = function (componentType) {
	            componentType = parseClassType(componentType);
	
	            var result = [];
	            var obj = storage[componentType.main];
	
	            if (obj && obj[IS_CONTAINER]) {
	                zrUtil.each(obj, function (o, type) {
	                    type !== IS_CONTAINER && result.push(o);
	                });
	            }
	            else {
	                result.push(obj);
	            }
	
	            return result;
	        };
	
	        entity.hasClass = function (componentType) {
	            // Just consider componentType.main.
	            componentType = parseClassType(componentType);
	            return !!storage[componentType.main];
	        };
	
	        /**
	         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
	         */
	        entity.getAllClassMainTypes = function () {
	            var types = [];
	            zrUtil.each(storage, function (obj, type) {
	                types.push(type);
	            });
	            return types;
	        };
	
	        /**
	         * If a main type is container and has sub types
	         * @param  {string}  componentType
	         * @return {boolean}
	         */
	        entity.hasSubTypes = function (componentType) {
	            componentType = parseClassType(componentType);
	            var obj = storage[componentType.main];
	            return obj && obj[IS_CONTAINER];
	        };
	
	        entity.parseClassType = parseClassType;
	
	        function makeContainer(componentType) {
	            var container = storage[componentType.main];
	            if (!container || !container[IS_CONTAINER]) {
	                container = storage[componentType.main] = {};
	                container[IS_CONTAINER] = true;
	            }
	            return container;
	        }
	
	        if (options.registerWhenExtend) {
	            var originalExtend = entity.extend;
	            if (originalExtend) {
	                entity.extend = function (proto) {
	                    var ExtendedClass = originalExtend.call(this, proto);
	                    return entity.registerClass(ExtendedClass, proto.type);
	                };
	            }
	        }
	
	        return entity;
	    };
	
	    module.exports = clazz;
	


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * BPMN model
	 *
	 */
	
	
	    var Model = __webpack_require__(83);
	    var BPMNModel = Model.extend({
	
	        type: 'BPMN',
	        /**
	         * @type {Object}
	         * @protected
	         */
	        defaultOption: {
	            resourceId: "",  //资源ID
	
	            properties: {
	                type: -1,  //类型
	                name: null, //名称
	                notes: "",  //备注
	                //no: ""
	                extProperties: {}  //扩展属性
	            },
	
	            stencil: {type: "BPMNDiagram"},
	
	            childShapes: [],    //子形状
	
	            outgoing: [],  // 下一个要连接的形状
	
	            bounds: {
	                upperLeft: {x:0, y:0},  //左上角坐标
	                lowerRight: {x:0, y:0} //右下角坐标
	            }
	        }
	    });
	    module.exports = BPMNModel;
	
	


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 节点等的模型
	 * 里面存的数据用来处理序列化和反序列化
	 * @class fish.topo.model
	 */
	
	
	    var zrUtil = __webpack_require__(4);
	    var clazzUtil = __webpack_require__(81);
	
	    function Model(option, parentModel,  extraOpt) {
	        this.parentModel = parentModel;
	        this.option = option;
	
	        // Simple optimization
	        if (this.init) {
	            if (arguments.length <= 3) {
	                this.init(option, parentModel,  extraOpt);
	            }
	            else {
	                this.init.apply(this, arguments);
	            }
	        }
	    }
	
	    Model.prototype = {
	
	        constructor: Model,
	
	        /**
	         * Model 的初始化函数
	         * @private
	         * @param {Object} option
	         */
	        init: function (option) {
	            zrUtil.merge(option, this.getDefaultOption());
	        },
	
	        getDefaultOption: function () {
	            if (!this.hasOwnProperty('__defaultOption')) {
	                var optList = [];
	                var Class = this.constructor;
	                while (Class) {
	                    var opt = Class.prototype.defaultOption;
	                    opt && optList.push(opt);
	                    Class = Class.superClass;
	                }
	
	                var defaultOption = {};
	                for (var i = optList.length - 1; i >= 0; i--) {
	                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);
	                }
	                this.__defaultOption = defaultOption;
	            }
	            return this.__defaultOption;
	        },
	
	        /**
	         * @private
	         */
	        mergeOption: function (option) {
	            zrUtil.merge(this.option, option, true);
	        },
	
	        /**
	         * 获取model的某个属性的值
	         * @param {string} path model中的属性
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.get("options.text");
	         */
	        get: function (path, ignoreParent) {
	            if (!path) {
	                return this.option;
	            }
	
	            if (typeof path === 'string') {
	                path = path.split('.');
	            }
	
	            var obj = this.option;
	            var parentModel = this.parentModel;
	            for (var i = 0; i < path.length; i++) {
	                // obj could be number/string/... (like 0)
	                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;
	                if (obj == null) {
	                    break;
	                }
	            }
	            if (obj == null && parentModel && !ignoreParent) {
	                obj = parentModel.get(path);
	            }
	            return obj;
	        },
	
	        /**
	         * 设置model的某个属性的值
	         * @param {string} path model中的属性
	         * @param {String} value 所需要设置的值
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.set("options.text","例子");
	         */
	        set: function (path, value) {
	            var obj = this.option;
	
	            if (path.indexOf(".") == -1) {
	                obj[path] = value;
	            } else {
	                var fieldArray  = path.split('.');
	                var n = fieldArray.length;
	                var currentRef = obj;
	                var fieldName;
	
	                for (var i = 0; i < n - 1; i++) {
	                    fieldName = fieldArray[i];
	                    if(currentRef[fieldName] == null) {
	                        currentRef[fieldName] = {};
	                    }
	                    currentRef = currentRef[fieldName];
	                }
	                fieldName = fieldArray[n-1];
	                currentRef[fieldName] = value;
	            }
	        },
	
	        /**
	         * @private
	         */
	        getShallow: function (key, ignoreParent) {
	            var option = this.option;
	            var val = option && option[key];
	            var parentModel = this.parentModel;
	            if (val == null && parentModel && !ignoreParent) {
	                val = parentModel.getShallow(key);
	            }
	            return val;
	        },
	
	        /**
	         * @private
	         */
	        getModel: function (path, parentModel) {
	            var obj = this.get(path, true);
	            var thisParentModel = this.parentModel;
	            var model = new Model(
	                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))
	            );
	            return model;
	        },
	
	        /**
	         *清空model的option
	         * @private
	         */
	        isEmpty: function () {
	            return this.option == null;
	        },
	
	        restoreData: function () {},
	
	        /**
	         * @private
	         */
	        clone: function () {
	            var Ctor = this.constructor;
	            return new Ctor(zrUtil.clone(this.option));
	        }
	    };
	
	    // Enable Model.extend.
	    clazzUtil.enableClassExtend(Model);
	
	    module.exports = Model;
	


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	
		var EventNode = __webpack_require__(85);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
		function StartEventNode(model, api) {
			EventNode.call(this, model, api);
	        this.itemSize = 20;
	        this.model = model;
			this.bpmnInfo = {type: 29, name:"StartNoneEvent" };    //节点信息
	        this.render(model);
		}
	
	    StartEventNode.prototype.render = function(model) {
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize
	            },
	            style: {
	                fill: '#000'
	            },
	            z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-2
	            },
	            style: {
	                fill: '#fff'
	            },
	            z:2
	        });
	        circle1.name = "Circle1";
	        this.add(circle1);
	        this.position = [model.get("bounds.upperLeft.x") + this.itemSize, model.get("bounds.upperLeft.y") + this.itemSize];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	
	    };
	
		zrUtil.inherits(StartEventNode, EventNode);
		module.exports = StartEventNode;
	


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var BPMNNode = __webpack_require__(79);
	    var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(26);
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    //
	    function EventNode(model,api) {
	        BPMNNode.call(this, model, api);
	        this.bpmnInfo = {type: -1, name:"EventNode" };    //节点信息
	        this.model = model;
	
	    }
	
	    EventNode.prototype.render = function() {
	
	    };
	
	
	    EventNode.prototype.getRect = function() {
	        // body...
	        var rect = this.getBoundingRect();
	        var boundingRect = zrUtil.clone(rect);
	        // 取整
	        boundingRect.x = parseInt(boundingRect.x, 10);
	        boundingRect.y = parseInt(boundingRect.y, 10);
	        boundingRect.width = parseInt(boundingRect.width, 10);
	        boundingRect.height = parseInt(boundingRect.height, 10);
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	
	        //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半
	        var boundRect = new BoundingRect(this.position[0] - boundingRect.width/2 ,
	                                         this.position[1] - boundingRect.height/2,
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0],
	            y: this.position[1],
	            width: boundingRect.width,
	            height: boundingRect.height,
	            points: points,
	            boundingRect: boundRect
	        };
	
	    };
	    EventNode.prototype.setPosition = function(pX,pY) {
	        // body...
	        this.attr('position',[pX,pY]);
	    };
	
	    EventNode.prototype.getBoundingRect = function() {
	        var circle = this.childOfName("Circle");
	        return circle.getBoundingRect();
	    };
	
	    EventNode.prototype.updateShape = function(ratio, ifParse) {
	        var circle = this.childOfName("Circle");
	        var circle1 = this.childOfName("Circle1");
	        var scaleRatio = Number(ratio);
	        var shape = circle.shape;
	        var shape1 = circle1.shape;
	        var newR = Number(shape.r * scaleRatio);
	        var newR1 = Number(shape1.r * scaleRatio);
	        if (ifParse) {
	            newR = parseInt(newR, 10);
	            newR1 = parseInt(newR1, 10);
	        }
	        circle.setShape({
	            r: newR
	        });
	        circle1.setShape({
	            r: newR1
	        });
	    };
	
	
	    zrUtil.inherits(EventNode,BPMNNode);
	    module.exports = EventNode;
	


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	
		var EventNode = __webpack_require__(85);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
		function EndEventNode(model, api) {
	        EventNode.call(this,model, api);
	        this.itemSize = 20;
	        this.model = model;
			this.bpmnInfo = {type: 31, name:"EndNoneEvent" };
	        this.render(model);
		}
	
	    EndEventNode.prototype.render = function(model) {
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize
	            },
	            style: {
	                fill: '#000'
	            },
	            z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-5
	            },
	            style: {
	                fill: '#fff'
	            },
	            z:2
	        });
	        circle1.name = "Circle1";
	        this.add(circle1);
	        this.position = [model.get("bounds.upperLeft.x") + this.itemSize, model.get("bounds.upperLeft.y") + this.itemSize];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	
	    };
	
		zrUtil.inherits(EndEventNode, EventNode);
		module.exports = EndEventNode;
	


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	
		var TaskNode = __webpack_require__(88);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 * <g pointer-events="fill" minimumSize="85 55" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6D" title="User task">
	 *   <rect id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Dtext_frame" anchors="bottom top right left" x="1.000000059837755" y="1.0162024924" width="72" height="22.000000000000004" rx="7" ry="7" stroke="none" stroke-width="0" fill="none">
	 *   </rect>
	 *   <rect id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Dbg_frame" resize="vertical horizontal" x="5.98377549e-8" y="0.0162024924" width="85" height="55" rx="7" ry="7" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9">
	 *   </rect>
	 *   <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Darea_state" anchors="bottom" x="5.98377549e-8" y="45.0162024924" width="85" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style="">
	 *   </rect>
	 *   <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Dtext_name" x="52" y="35" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 52 35)" oryx:fontSize="12" text-anchor="middle">
	 *       <tspan x="52" y="35" dy="5">Task
	 *       </tspan>
	 *   </text>
	 *   <g id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6DuserTask" transform="translate(5.000000, 5.000000)" fill="#4990E2">
	 *       <path anchors="top left" d=" M4.689754749837755 0.7547497214000001  C3.124908639837755 1.5094994424 2.536902989837755 2.8359404524 3.0388532998377547 5.3878194723999995  C3.540803599837755 7.9396985024 4.256854379837756 7.9729218124 4.689754749837755 8.9207625924  C5.122655119837755 9.868603372399999 4.8340548898377556 10.6706224924 3.8239538798377546 11.1080874924  C2.813852879837755 11.5455524924 1.1967550949999999e-7 12.8579473924 5.98377549e-8 13.5870556924  C0 14.3161639924 1.226551289837755 14.2432530924 2.3088023698377547 14.2432530924  C3.391053449837755 14.2432530924 9.090909149837755 14.2432530924 9.090909149837755 14.2432530924  L9.163059219837754 0.5237704804000001  C9.163059219837754 0.5237704804000001 6.254600859837756 0 4.689754749837755 0.7547497214000001  z" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6DPath-14">
	 *       </path>
	 *       <path anchors="top left" d=" M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6DPath-14-Copy">
	 *       </path>
	 *   </g>
	 * </g>
	 */
	
	    function UserTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "M765.573741 718.489888c-14.999622-112.659873-119.671567-196.438974-237.776452-196.438974-118.912273 0-220.514299 85.277222-238.20317 198.770066-11.840676 76.071559 54.585199 71.326489 54.585199 71.326489l360.734878 0C704.913173 792.148491 776.608052 801.364387 765.573741 718.489888zM690.249195 365.718379c0 89.911776-72.889077 162.810063-162.79676 162.810063-89.908706 0-162.797783-72.898287-162.797783-162.810063 0-89.916892 72.889077-162.80597 162.797783-162.80597C617.360118 202.912409 690.249195 275.801487 690.249195 365.718379z";
	        this.bpmnInfo = {type: 0, name:"UserTask" };    //节点信息
	        this.render(model);
	    }
	
	    UserTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#fff',
	                stroke: '#000'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconRect = {x:5, y: 5, width: 15, height:15};
	        var pathIcon = graphic.makePath(this.iconPath, {style: {fill: '#fff', stroke: '#000'},z:2}, iconRect);
	        this.add(pathIcon);
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"), '', 'center');
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
	
	
		zrUtil.inherits(UserTaskNode,TaskNode);
		module.exports = UserTaskNode;
	


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	
		var BPMNNode = __webpack_require__(79);
		var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(26);
		//创建Node类 所有形状都继承Node
		//
		function TaskNode(model, api) {
	
			BPMNNode.call(this, model, api);
			this.bpmnInfo = {type: -1, name:"TaskNode" };    //节点信息
	        this.model = model;
	        this.slot = [];
	        this.slotEvent = [];
	        this.isCanSlot = true;  //用于控制本节点是否可以被插槽
		}
	
	    TaskNode.prototype.render = function() {
	
	    };
	
	    TaskNode.prototype.getRect = function() {
	        var rect = this.getBoundingRect();
	        var boundingRect = zrUtil.clone(rect);
	        // 取整
	        boundingRect.x = parseInt(boundingRect.x, 10);
	        boundingRect.y = parseInt(boundingRect.y, 10);
	        boundingRect.width = parseInt(boundingRect.width, 10);
	        boundingRect.height = parseInt(boundingRect.height, 10);
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	
	        var boundRect = new BoundingRect(this.position[0] ,
	                                         this.position[1],
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0]+boundingRect.width/2,
	            y: this.position[1]+boundingRect.height/2,
	            width: boundingRect.width,
	            height: boundingRect.height,
	            points: points,
	            boundingRect: boundRect
	        };
	    };
	
	    TaskNode.prototype.getBoundingRect = function() {
	        var rect = this.childOfName("Rect");
	        return rect.getBoundingRect();
	    };
	
	    TaskNode.prototype.setPosition = function(pX,pY) {
	        var boundingRect = this.getBoundingRect();
	        this.attr('position',[pX-boundingRect.width/2,pY-boundingRect.height/2]);
	
	    };
	
	    TaskNode.prototype.updateShape = function(ratio, ifParse) {
	        var rect = this.childOfName("Rect");
	        var scaleRatio = Number(ratio);
	        var shape = rect.shape;
	        var newW = Number(shape.width * scaleRatio);
	        var newH = Number(newW * shape.height / shape.width);
	        if (ifParse) {
	            newW = parseInt(newW, 10);
	            newH = parseInt(newH, 10);
	        }
	        rect.setShape({
	            width: newW,
	            height: newH
	        });
	        this.refreshText();
	    };
	
		zrUtil.inherits(TaskNode,BPMNNode);
		module.exports = TaskNode;
	


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	//ManualTask节点
	
		var TaskNode = __webpack_require__(88);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 *  <g pointer-events="fill" minimumSize="82 42" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825" title="Manual task">
	 *     <rect id="sid-A9545224-4CAE-450D-893D-12CFA7E68825text_frame" anchors="bottom top right left" x="1" y="1" width="74" height="39" rx="10" ry="10" stroke="none" stroke-width="0" fill="none"></rect>
	 *     <rect id="sid-A9545224-4CAE-450D-893D-12CFA7E68825bg_frame" resize="vertical horizontal" x="0" y="0" width="80" height="40" rx="10" ry="10" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9"></rect>
	 *     <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825area_state" anchors="bottom" x="0" y="30" width="80" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style=""></rect>
	 *     <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825text_name" x="43" y="24" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 43 24)" oryx:fontSize="12" text-anchor="middle"><tspan x="43" y="24" dy="5">Task</tspan></text>
	 *     <g id="sid-A9545224-4CAE-450D-893D-12CFA7E68825manualTask" transform="translate(3,1) scale(0.8)">
	 *     <path anchors="top left" style="fill:#d1b575;stroke=none" d="m 17,9.3290326 c -0.0069,0.5512461 -0.455166,1.0455894 -0.940778,1.0376604 l -5.792746,0 c 0.0053,0.119381 0.0026,0.237107 0.0061,0.355965 l 5.154918,0 c 0.482032,-0.0096 0.925529,0.49051 0.919525,1.037574 -0.0078,0.537128 -0.446283,1.017531 -0.919521,1.007683 l -5.245273,0 c -0.01507,0.104484 -0.03389,0.204081 -0.05316,0.301591 l 2.630175,0 c 0.454137,-0.0096 0.872112,0.461754 0.866386,0.977186 C 13.619526,14.554106 13.206293,15.009498 12.75924,15 L 3.7753054,15 C 3.6045812,15 3.433552,14.94423 3.2916363,14.837136 c -0.00174,0 -0.00436,0 -0.00609,0 C 1.7212035,14.367801 0.99998255,11.458641 1,11.458641 L 1,7.4588393 c 0,0 0.6623144,-1.316333 1.8390583,-2.0872584 1.1767614,-0.7711868 6.8053358,-2.40497 7.2587847,-2.8052901 0.453484,-0.40032 1.660213,1.4859942 0.04775,2.4010487 C 8.5332315,5.882394 8.507351,5.7996113 8.4370292,5.7936859 l 6.3569748,-0.00871 c 0.497046,-0.00958 0.952273,0.5097676 0.94612,1.0738232 -0.0053,0.556126 -0.456176,1.0566566 -0.94612,1.0496854 l -4.72435,0 c 0.01307,0.1149374 0.0244,0.2281319 0.03721,0.3498661 l 5.952195,0 c 0.494517,-0.00871 0.947906,0.5066305 0.940795,1.0679848 z" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825_sid-A9545224-4CAE-450D-893D-12CFA7E68825_17"></path>
	 *     </g>
	 * </g>
	 */
	    function ManualTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "m 17,9.3290326 c -0.0069,0.5512461 -0.455166,1.0455894 -0.940778,1.0376604 l -5.792746,0 c 0.0053,0.119381 0.0026,0.237107 0.0061,0.355965 l 5.154918,0 c 0.482032,-0.0096 0.925529,0.49051 0.919525,1.037574 -0.0078,0.537128 -0.446283,1.017531 -0.919521,1.007683 l -5.245273,0 c -0.01507,0.104484 -0.03389,0.204081 -0.05316,0.301591 l 2.630175,0 c 0.454137,-0.0096 0.872112,0.461754 0.866386,0.977186 C 13.619526,14.554106 13.206293,15.009498 12.75924,15 L 3.7753054,15 C 3.6045812,15 3.433552,14.94423 3.2916363,14.837136 c -0.00174,0 -0.00436,0 -0.00609,0 C 1.7212035,14.367801 0.99998255,11.458641 1,11.458641 L 1,7.4588393 c 0,0 0.6623144,-1.316333 1.8390583,-2.0872584 1.1767614,-0.7711868 6.8053358,-2.40497 7.2587847,-2.8052901 0.453484,-0.40032 1.660213,1.4859942 0.04775,2.4010487 C 8.5332315,5.882394 8.507351,5.7996113 8.4370292,5.7936859 l 6.3569748,-0.00871 c 0.497046,-0.00958 0.952273,0.5097676 0.94612,1.0738232 -0.0053,0.556126 -0.456176,1.0566566 -0.94612,1.0496854 l -4.72435,0 c 0.01307,0.1149374 0.0244,0.2281319 0.03721,0.3498661 l 5.952195,0 c 0.494517,-0.00871 0.947906,0.5066305 0.940795,1.0679848 z";
	      //  this.iconPath2 = "M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z";
	        this.bpmnInfo = {type: 4, name:"ManualTask" };    //节点信息
	        this.render(model);
	    }
	
	    ManualTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#fff',
	                stroke: '#000'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 15, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#fff', stroke: '#000'},z:2}, iconrect));
	
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"), '', 'center');
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ManualTaskNode,TaskNode);
		module.exports = ManualTaskNode;
	


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	//ScriptTask节点
	
		var TaskNode = __webpack_require__(88);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 *  <g pointer-events="fill" minimumSize="82 42" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D" title="Script task">
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_frame" anchors="bottom top right left" x="1" y="1" width="74" height="39" rx="10" ry="10" stroke="none" stroke-width="0" fill="none"></rect>
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dbg_frame" resize="vertical horizontal" x="0" y="0" width="80" height="40" rx="10" ry="10" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9"></rect>
	 *     <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Darea_state" anchors="bottom" x="0" y="30" width="80" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style=""></rect>
	 *     <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_name" x="43" y="24" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 43 24)" oryx:fontSize="12" text-anchor="middle"><tspan x="43" y="24" dy="5">Task</tspan></text>
	 *     <g id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5DscriptTask" transform="translate(2,2) scale(0.8)">
	 *     <path anchors="top left" d="m 5,2 0,0.094 c 0.23706,0.064 0.53189,0.1645 0.8125,0.375 0.5582,0.4186 1.05109,1.228 1.15625,2.5312 l 8.03125,0 1,0 1,0 c 0,-3 -2,-3 -2,-3 l -10,0 z M 4,3 4,13 2,13 c 0,3 2,3 2,3 l 9,0 c 0,0 2,0 2,-3 L 15,6 6,6 6,5.5 C 6,4.1111 5.5595,3.529 5.1875,3.25 4.8155,2.971 4.5,3 4.5,3 L 4,3 z" style="fill:#72a7d0;stroke:none" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D_sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D_17"></path>
	 *     </g>
	 * </g>
	 */
	    function ScriptTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "m 5,2 0,0.094 c 0.23706,0.064 0.53189,0.1645 0.8125,0.375 0.5582,0.4186 1.05109,1.228 1.15625,2.5312 l 8.03125,0 1,0 1,0 c 0,-3 -2,-3 -2,-3 l -10,0 z M 4,3 4,13 2,13 c 0,3 2,3 2,3 l 9,0 c 0,0 2,0 2,-3 L 15,6 6,6 6,5.5 C 6,4.1111 5.5595,3.529 5.1875,3.25 4.8155,2.971 4.5,3 4.5,3 L 4,3 z";
	      //  this.iconPath2 = "M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z";
	        this.bpmnInfo = {type: 7, name:"ScriptTask" };    //节点信息
	        this.render(model);
	    }
	
	    ScriptTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#fff',
	                stroke: '#000'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 15, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#fff', stroke: '#000'},z:2}, iconrect));
	
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"), '', 'center');
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ScriptTaskNode,TaskNode);
		module.exports = ScriptTaskNode;
	


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	//MailTask节点
	
		var TaskNode = __webpack_require__(88);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 *  <g pointer-events="fill" minimumSize="82 42" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D" title="Script task">
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_frame" anchors="bottom top right left" x="1" y="1" width="74" height="39" rx="10" ry="10" stroke="none" stroke-width="0" fill="none"></rect>
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dbg_frame" resize="vertical horizontal" x="0" y="0" width="80" height="40" rx="10" ry="10" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9"></rect>
	 *     <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Darea_state" anchors="bottom" x="0" y="30" width="80" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style=""></rect>
	 *     <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_name" x="43" y="24" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 43 24)" oryx:fontSize="12" text-anchor="middle"><tspan x="43" y="24" dy="5">Task</tspan></text>
	 *     <g id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5DscriptTask" transform="translate(2,2) scale(0.8)">
	 *        <path anchors="top left" d="M0.332638936,1.17391304 L8.98125126,6.65217391" id="sid-09B97C5E-BEA8-40A2-9F22-3064A2745DBELine" stroke="#FFFFFF" stroke-linecap="square"></path>
	 *        <path anchors="top left" d="M17.5500302,1.17391304 L8.90141792,6.65217391" id="sid-09B97C5E-BEA8-40A2-9F22-3064A2745DBELine-Copy-4" stroke="#FFFFFF" stroke-linecap="square"></path>
	 *	   </g>
	 * </g>
	 */
	    function MailTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "M49.013,51.003c1.847,1.303,7.414,5.174,16.702,11.61S82.118,74.005,87.061,77.48c0.543,0.381,1.697,1.209,3.462,2.485c1.765,1.277,3.232,2.31,4.399,3.097c1.168,0.787,2.58,1.67,4.237,2.647c1.657,0.977,3.219,1.711,4.685,2.198c1.467,0.49,2.825,0.733,4.074,0.733H108h0.082c1.249,0,2.607-0.243,4.074-0.733c1.466-0.487,3.029-1.222,4.685-2.198c1.656-0.978,3.068-1.86,4.236-2.647s2.634-1.82,4.399-3.097s2.92-2.104,3.463-2.485c4.996-3.476,17.707-12.302,38.129-26.479c3.965-2.769,7.277-6.11,9.939-10.021C179.67,37.071,181,32.97,181,28.679c0-3.585-1.291-6.654-3.871-9.207c-2.58-2.553-5.636-3.829-9.165-3.829H48.035c-4.182,0-7.4,1.412-9.654,4.236C36.127,22.704,35,26.235,35,30.471c0,3.422,1.494,7.13,4.481,11.122S45.646,48.722,49.013,51.003z M172.852,59.72c-17.814,12.057-31.34,21.427-40.572,28.108c-3.096,2.281-5.608,4.061-7.537,5.336c-1.928,1.277-4.494,2.58-7.699,3.911c-3.204,1.331-6.191,1.996-8.961,1.996H108h-0.082c-2.77,0-5.758-0.665-8.962-1.996s-5.771-2.634-7.699-3.911c-1.928-1.275-4.44-3.055-7.536-5.336c-7.333-5.377-20.83-14.747-40.492-28.108c-3.096-2.063-5.839-4.427-8.229-7.088v64.688c0,3.586,1.276,6.654,3.829,9.207c2.553,2.554,5.622,3.83,9.207,3.83h119.929c3.584,0,6.653-1.276,9.206-3.83c2.554-2.554,3.829-5.621,3.829-9.207V52.632C178.664,55.238,175.949,57.602,172.852,59.72z";
	      //  this.iconPath2 = "M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z";
	        this.bpmnInfo = {type: 8, name:"MailTask" };    //节点信息
	        this.render(model);
	    }
	
	    MailTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#fff',
	                stroke: '#000'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 15, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#fff', stroke: '#000'},z:2}, iconrect));
	
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"), '', 'center');
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(MailTaskNode,TaskNode);
		module.exports = MailTaskNode;
	


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	
		var TaskNode = __webpack_require__(88);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    
	    function ServiceTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "M891.84 410.072c-8.936-33.48-22.192-65.232-39.192-94.584l74.512-112.4-106.272-106.184-112.344 74.456c-29.384-16.944-61.144-30.256-94.648-39.2L587.08 0l-150.16 0-26.816 132.16c-33.504 8.944-65.264 22.256-94.648 39.2l-112.4-74.456L96.832 203.08l74.52 112.4c-17 29.352-30.256 61.112-39.2 94.648L0 436.888l0 150.192 132.16 26.824c8.944 33.504 22.192 65.264 39.2 94.648l-74.52 112.408 106.216 106.152 112.4-74.456c29.384 16.936 61.144 30.256 94.648 39.192L436.92 1024l150.16 0 26.824-132.16c33.504-8.936 65.264-22.256 94.648-39.192l112.344 74.456 106.272-106.152-74.512-112.408c17-29.384 30.256-61.144 39.192-94.648L1024 587.08 1024 436.888 891.84 410.072 891.84 410.072zM689.8 512c0 98.152-79.584 177.8-177.8 177.8S334.208 610.152 334.208 512c0-98.176 79.584-177.792 177.792-177.792S689.8 413.824 689.8 512z";
	        this.bpmnInfo = {type: 12, name:"ServiceTask" };    //节点信息
	        this.render(model);
	    }
	
	    ServiceTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#fff',
	                stroke: '#000'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 15, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#fff', stroke: '#000'},z:2}, iconrect));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"), '', 'center');
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ServiceTaskNode,TaskNode);
		module.exports = ServiceTaskNode;
	


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	
		var TaskNode = __webpack_require__(88);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    
	    function SmsTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "M959.907775 439.894775c0 195.140399-200.607924 352.909655-447.964568 352.909655-21.76163 0-43.083238-1.203408-64.080457-3.499707-41.555441-4.701069-109.897969 121.601522-300.828486 147.517775 100.164281-117.992321 106.727767-206.485795 74.250074-228.301659C125.053646 643.782396 64.091202 547.553751 64.091202 439.894775c0-194.757682 200.607924-352.717274 447.852004-352.717274C759.299851 87.177502 959.907775 245.13607 959.907775 439.894775z";
	        this.bpmnInfo = {type: 11, name:"SmsTask" };    //节点信息
	        this.render(model);
	    }
	
	    SmsTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#fff',
	                stroke: '#000'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 15, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#fff', stroke: '#000'},z:2}, iconrect));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"), '', 'center');
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(SmsTaskNode,TaskNode);
		module.exports = SmsTaskNode;
	


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	
		var BPMNNode = __webpack_require__(79);
		var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(26);
	    var graphic = __webpack_require__(3);
	    var imageUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAADIElEQVR4Xu2XwU3DUBQEX/pBaYpG6IKiOEYcKYAGuIYjIkI4UjzxRJ6cv/6uZ0e2cph+uyZw2PXT9/CTADuXIAESYJHAy+KJ9Q98zszr+td24yWBa94A5w2wnWbmuEHu7iITYHeT/37gBEiARQJ9AhYRPe6B3gCPu90qzRNgFYyPe8mtAjzNzPvjPn7NE2DnDiRAAiwS+O9fQJ+ARXzuA70B3Pvg7RIAR+wOSAD3Pni7BMARuwMSwL0P3i4BcMTugARw74O3SwAcsTsgAdz74O0SAEfsDkgA9z54uwTAEbsDEsC9D94uAXDE7oAEcO+Dt0sAHLE7IAHc++DtEgBH7A5IAPc+eLsEwBG7AxLAvQ/eLgFwxO6ABHDvg7dLAByxOyAB3Pvg7RIAR+wOSAD3Pni7BMARuwMSwL0P3i4BcMTugARw74O3SwAcsTsgAdz74O0SAEfsDkgA9z54uwTAEbsDEsC9D94uAXDE7oAEcO+Dt0sAHLE7IAHc++DtEgBH7A5IAPc+eLsEwBG7AxLAvQ/eLgFwxO6ABHDvg7dLAByxOyAB3Pvg7RIAR+wOSAD3Pni7BMARuwMSwL0P3i4BcMTugARw74O3SwAcsTsgAdz74O0SAEfsDkgA9z54uwTAEbsDEsC9D94uAXDE7oAEcO+Dt0sAHLE7IAHc++DtEgBH7A5IAPc+eLsEwBG7AxLAvQ/eLgFwxO6ABHDvg7dLAByxOyAB3Pvg7RIAR+wOSAD3Pni7BMARuwMSwL0P3i4BcMTugARw74O3SwAcsTsgAdz74O0SAEfsDkgA9z54uwTAEbsDEsC9D94uAXDE7oAEcO+Dt0sAHLE7IAHc++DtEgBH7A5IAPc+eLsEwBG7AxLAvQ/eLgFwxO6ABHDvg7dLAByxOyAB3Pvg7RIAR+wOSAD3Pni7BMARuwMSwL0P3i4BcMTugFsFeJuZL+ARP2bmGbi3Ky8I3CoABfQ0M0fq8u79IZAAO7chARJgkcB58cT6B/oErM/0zxt7A9wJtDUmAazL3KnXNQLcqUoxWxBIgC2oizITQDTGFlUSYAvqosxvSbnygcc7wDsAAAAASUVORK5CYII=";
	
	    function CommentNode(model,api) {
	        BPMNNode.call(this, model, api);
	        this.bpmnInfo = {type: 21, name:"Comment" };
	        this.model = model;
	        this.render(model);
	    }
	
	    CommentNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0,
	                y: 0,
	                width: 100,
	                height: 40
	            },
	            style: {
	                opacity: 0
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	        var line = new graphic.Line({
	            shape: {x1:0,  y1:0, x2:10, y2:0},
	            style: {lineWidth:1, stroke: "#000"}
	        });
	        this.add(line);
	        var line1 = new graphic.Line({
	            shape: {x1:0,  y1:0, x2:0, y2:40},
	            style: {lineWidth:1, stroke: "#000"}
	        });
	        this.add(line1);
	        var line2 = new graphic.Line({
	            shape: {x1:0,  y1:40, x2:10, y2:40},
	            style: {lineWidth:1, stroke: "#000"}
	        });
	        this.add(line2);
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"), '', 'left');
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
	    CommentNode.prototype.getRect = function(json) {
	        var rect = this.getBoundingRect();
	        var boundingRect = zrUtil.clone(rect);
	        // 取整
	        boundingRect.x = parseInt(boundingRect.x, 10);
	        boundingRect.y = parseInt(boundingRect.y, 10);
	        boundingRect.width = parseInt(boundingRect.width, 10);
	        boundingRect.height = parseInt(boundingRect.height, 10);
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	
	        var boundRect = new BoundingRect(this.position[0] ,
	                                         this.position[1],
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0]+boundingRect.width/2,
	            y: this.position[1]+boundingRect.height/2,
	            width: boundingRect.width,
	            height: boundingRect.height,
	            points: points,
	            boundingRect: boundRect
	        };
	    };
	    CommentNode.prototype.setPosition = function(pX,pY) {
	        var boundingRect = this.getBoundingRect();
	        this.attr('position',[pX-boundingRect.width/2,pY-boundingRect.height/2]);
	    };
	
	    CommentNode.prototype.getBoundingRect = function() {
	        var rect = this.childOfName("Rect");
	        return rect.getBoundingRect();
	    };
	
	    CommentNode.prototype.updateShape = function(ratio, ifParse) {
	        var rect = this.childOfName("Rect");
	        var scaleRatio = Number(ratio);
	        var shape = rect.shape;
	        var newW = Number(shape.width * scaleRatio);
	        var newH = Number(newW * shape.height / shape.width);
	        if (ifParse) {
	            newW = parseInt(newW, 10);
	            newH = parseInt(newH, 10);
	        }
	        rect.setShape({
	            width: newW,
	            height: newH
	        });
	    };
	
		zrUtil.inherits(CommentNode, BPMNNode);
		module.exports = CommentNode;
	


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	//边界事件---捕获定时器事件节点
	
		var EventNode = __webpack_require__(85);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bbg_frame" cx="16" cy="16" r="15" stroke="#585858" fill="#ffffff" stroke-width="1" style="stroke-dasharray: 5.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2_non_interrupting" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1" style="stroke-dasharray: 4.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe" cx="16" cy="16" r="15" stroke="#585858" fill="none" stroke-width="1"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1"></circle>
	 *    <path id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bpath1" transform="translate(6,6)" d="M 10 0 C 4.4771525 0 0 4.4771525 0 10 C 0 15.522847 4.4771525 20 10 20 C 15.522847 20 20 15.522847 20 10 C 20 4.4771525 15.522847 1.1842379e-15 10 0 z M 9.09375 1.03125 C 9.2292164 1.0174926 9.362825 1.0389311 9.5 1.03125 L 9.5 3.5 L 10.5 3.5 L 10.5 1.03125 C 15.063526 1.2867831 18.713217 4.9364738 18.96875 9.5 L 16.5 9.5 L 16.5 10.5 L 18.96875 10.5 C 18.713217 15.063526 15.063526 18.713217 10.5 18.96875 L 10.5 16.5 L 9.5 16.5 L 9.5 18.96875 C 4.9364738 18.713217 1.2867831 15.063526 1.03125 10.5 L 3.5 10.5 L 3.5 9.5 L 1.03125 9.5 C 1.279102 5.0736488 4.7225326 1.4751713 9.09375 1.03125 z M 9.5 5 L 9.5 8.0625 C 8.6373007 8.2844627 8 9.0680195 8 10 C 8 11.104569 8.8954305 12 10 12 C 10.931981 12 11.715537 11.362699 11.9375 10.5 L 14 10.5 L 14 9.5 L 11.9375 9.5 C 11.756642 8.7970599 11.20294 8.2433585 10.5 8.0625 L 10.5 5 L 9.5 5 z " fill="#585858" stroke="none"></path>
	 * </g>
	 */
	
		function CatchTimerEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.startIcon = 'M 10 0 C 4.4771525 0 0 4.4771525 0 10 C 0 15.522847 4.4771525 20 10 20 C 15.522847 20 20 15.522847 20 10 C 20 4.4771525 15.522847 1.1842379e-15 10 0 z M 9.09375 1.03125 C 9.2292164 1.0174926 9.362825 1.0389311 9.5 1.03125 L 9.5 3.5 L 10.5 3.5 L 10.5 1.03125 C 15.063526 1.2867831 18.713217 4.9364738 18.96875 9.5 L 16.5 9.5 L 16.5 10.5 L 18.96875 10.5 C 18.713217 15.063526 15.063526 18.713217 10.5 18.96875 L 10.5 16.5 L 9.5 16.5 L 9.5 18.96875 C 4.9364738 18.713217 1.2867831 15.063526 1.03125 10.5 L 3.5 10.5 L 3.5 9.5 L 1.03125 9.5 C 1.279102 5.0736488 4.7225326 1.4751713 9.09375 1.03125 z M 9.5 5 L 9.5 8.0625 C 8.6373007 8.2844627 8 9.0680195 8 10 C 8 11.104569 8.8954305 12 10 12 C 10.931981 12 11.715537 11.362699 11.9375 10.5 L 14 10.5 L 14 9.5 L 11.9375 9.5 C 11.756642 8.7970599 11.20294 8.2433585 10.5 8.0625 L 10.5 5 L 9.5 5 z';
	        this.itemSize = 10;
			this.bpmnInfo = {type: 43, name:"CatchTimerEvent" };    //节点信息
	        this.render(model);
		}
	
	    CatchTimerEventNode.prototype.render = function(model) {
	
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-0.5
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:3
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-3
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:3
	        });
	        circle1.name = "Circle1";
	        this.add(circle1);
	
	        var itemSize = this.itemSize+6;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {stroke:'#000'},z:3}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+this.itemSize , model.get("bounds.upperLeft.y")+this.itemSize];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	        this.z = 3;
	    };
	
		zrUtil.inherits(CatchTimerEventNode, EventNode);
		module.exports = CatchTimerEventNode;
	


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	//边界事件---捕获信号量事件
	
		var EventNode = __webpack_require__(85);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bbg_frame" cx="16" cy="16" r="15" stroke="#585858" fill="#ffffff" stroke-width="1" style="stroke-dasharray: 5.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2_non_interrupting" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1" style="stroke-dasharray: 4.5, 3"></circle>
	 *    <path id="sid-3CC33924-73F3-4D13-A2A9-0242530680DEsignalCatching" stroke="#585858" d=" M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z" style="fill:none;stroke-width:1.4;stroke-miterlimit:4;stroke-dasharray:none"></path>
	 * </g>
	 */
	
		function CatchSignalEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.startIcon = 'M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z';
	        this.itemSize = 10;
			this.bpmnInfo = {type: 72, name:"CatchSignalEvent" };    //节点信息
	        this.render(model);
		}
	
	    CatchSignalEventNode.prototype.render = function(model) {
	
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-0.5
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:3
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-3
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:3
	        });
	        circle1.name = "Circle1";
	        this.add(circle1);
	
	        var itemSize = this.itemSize;
	        var rect = {x:-itemSize/2, y: -itemSize/2-2, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {stroke:'#000',fill:'#ffffff'},z:3}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+this.itemSize , model.get("bounds.upperLeft.y")+this.itemSize];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	        this.z = 3;
	    };
	
		zrUtil.inherits(CatchSignalEventNode, EventNode);
		module.exports = CatchSignalEventNode;
	


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	//边界事件---ThrowSignalEvent节点
	
		var EventNode = __webpack_require__(85);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bbg_frame" cx="16" cy="16" r="15" stroke="#585858" fill="#ffffff" stroke-width="1" style="stroke-dasharray: 5.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2_non_interrupting" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1" style="stroke-dasharray: 4.5, 3"></circle>
	 *    <path id="sid-3CC33924-73F3-4D13-A2A9-0242530680DEsignalCatching" stroke="#585858" d=" M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z" style="fill:none;stroke-width:1.4;stroke-miterlimit:4;stroke-dasharray:none"></path>
	 * </g>
	 */
	
		function ThrowSignalEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.startIcon = 'M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z';
	        this.itemSize = 10;
			this.bpmnInfo = {type: 75, name:"ThrowSignalEvent" };    //节点信息
	        this.render(model);
		}
	
	    ThrowSignalEventNode.prototype.render = function(model) {
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-0.5
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:3
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-3
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:3
	        });
	        circle1.name = "Circle1";
	        this.add(circle1);
	
	        var itemSize = this.itemSize;
	        var rect = {x:-itemSize/2, y: -itemSize/2-2, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {stroke:'#000',fill:'#000000'},z:3}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+this.itemSize , model.get("bounds.upperLeft.y")+this.itemSize];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	        this.z = 3;
	    };
	
		zrUtil.inherits(ThrowSignalEventNode, EventNode);
		module.exports = ThrowSignalEventNode;
	


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	//边界事件---捕获定时器事件节点
	
		var EventNode = __webpack_require__(85);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
		function CatchMessageEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.startIcon = "M664.356571 633.344l-50.797714 0 228.827429 146.980571L181.613714 780.324571l228.827429-146.980571-50.834286 0-203.190857 130.450286L156.416 359.094857l359.021714 242.578286 352.146286-235.300571 0 397.458286L664.356571 633.344zM156.416 299.922286 156.416 243.675429l711.168 0 0 71.314286-351.378286 222.171429L156.416 299.922286z";
	        this.itemSize = 20;
			this.bpmnInfo = {type: 100, name:"CatchMessageEvent" };    //节点信息
	        this.render(model);
		}
	
	    CatchMessageEventNode.prototype.render = function(model) {
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-3
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#000'
	            },
	            z:2
	        });
	        circle1.name = "Circle1";
	        this.add(circle1);
	
	        var itemSize = this.itemSize;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {stroke:'#fff'},z:2}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+this.itemSize , model.get("bounds.upperLeft.y")+this.itemSize];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(CatchMessageEventNode, EventNode);
		module.exports = CatchMessageEventNode;
	


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	//InclusiveGateWay节点
	
		var GatewayNode = __webpack_require__(100);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <path d=" M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Rectangle-1" fill="#F6A623"></path>
	 *    <path d=" M19.851221564 27.782256064000002  C24.231410964 27.782256064000002 27.782256064000002 24.231410964 27.782256064000002 19.851221564  C27.782256064000002 15.471032163999999 24.231410964 11.920187063999999 19.851221564 11.920187063999999  C15.471032163999999 11.920187063999999 11.920187063999999 15.471032163999999 11.920187063999999 19.851221564  C11.920187063999999 24.231410964 15.471032163999999 27.782256064000002 19.851221564 27.782256064000002  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Oval-4" fill="#FFFFFF"></path>
	 * </g>
	 */
	
		function InclusiveGatewayNode(model, api) {
			GatewayNode.call(this, model, api);
	        this.startIcon = 'M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z';
	        this.nextIcon = 'M507.7383 49.463867C327.38957 48.865055 154.337045 165.397235 85.887695 332.095705 13.82828 497.171875 51.26921 702.2376 177.31836 830.98145 298.5502 961.4774 498.29297 1009.3747 665.5781 948.3174 838.948 889.28065 966.9399 719.02055 973.89745 535.7715 985.56715 355.706145 879.6298 176.060825 717.4209 97.625 653.90365 65.927975 582.97465 49.398509 512 49.5 510.57905 49.480728 509.15835 49.468582 507.7383 49.463867zM520.41405 99.450195C696.9503 100.419315 863.2164 228.12953 908.87305 398.964845 957.3881 562.41865 891.7662 751.6676 750.9199 848.47755 604.61365 956.01475 387.64963 948.23445 249.48828 830.3994 110.28125 719.40945 60.452365 514.11165 131.875 351.308595 193.77873 200.80243 349.16891 97.58941 512 99.5 514.8069 99.451185 517.6119 99.43481 520.41405 99.450195z';
	        this.itemSize = 20;
			this.bpmnInfo = {type: 20, name:"InclusiveGateway" };    //节点信息
	        this.render(model);
		}
	
	    InclusiveGatewayNode.prototype.render = function(model) {
	        var itemSize = this.itemSize*2;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        var path = graphic.makePath(this.startIcon, {style: {stroke: '#000', fill: '#fff'},z:2}, rect,"center");
	        path.name = 'Path';
	        this.add(path);
	        var itemSize1 = this.itemSize;
	        var rect1 = {x:-itemSize1/2, y: -itemSize1/2, width: itemSize1, height:itemSize1};
	        this.add(graphic.makePath(this.nextIcon, {style: {stroke: '#000'},z:2}, rect1,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+itemSize1 , model.get("bounds.upperLeft.y")+itemSize1];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(InclusiveGatewayNode, GatewayNode);
		module.exports = InclusiveGatewayNode;
	


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	//所有GateWay节点的基类
	
	    var BPMNNode = __webpack_require__(79);
	    var graphic = __webpack_require__(3);
	    var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(26);
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    //
	    function GatewayNode(model, api) {
	        BPMNNode.call(this, model, api);
	        this.bpmnInfo = {type: -1, name:"GatewayNode" };    //节点信息
	        this.model = model;
	    }
	
	    GatewayNode.prototype.render = function() {
	
	    };
	
	    GatewayNode.prototype.getRect = function() {
	        var rect = this.getBoundingRect();
	        var boundingRect = zrUtil.clone(rect);
	        // 取整
	        boundingRect.x = parseInt(boundingRect.x, 10);
	        boundingRect.y = parseInt(boundingRect.y, 10);
	        boundingRect.width = parseInt(boundingRect.width, 10);
	        boundingRect.height = parseInt(boundingRect.height, 10);
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	        var boundRect = new BoundingRect(this.position[0] - boundingRect.width/2 ,
	                                         this.position[1] - boundingRect.height/2,
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0],
	            y: this.position[1],
	            width: boundingRect.width,
	            height: boundingRect.height,
	            points: points,
	            boundingRect: boundRect
	        };
	
	    };
	    GatewayNode.prototype.setPosition = function(pX,pY) {
	        // body...
	        this.attr('position',[pX,pY]);
	    };
	    GatewayNode.prototype.getBoundingRect = function() {
	        var path = this.childOfName("Path");
	        return path.getBoundingRect();
	    };
	    GatewayNode.prototype.updateShape = function(ratio, ifParse) {
	        var scaleRatio = Number(ratio);
	        var getBoundingRect = this.getBoundingRect();
	        var path = this.childOfName("Path");
	        var width = getBoundingRect.width * scaleRatio;
	        var height = getBoundingRect.height * scaleRatio;
	        if (ifParse) {
	            width = parseInt(width, 10);
	            height = parseInt(height, 10);
	        }
	        var rect = {x:-width/2, y: -height/2, width: width, height:height};
	        graphic.resizePath(path, rect);
	    };
	
	    zrUtil.inherits(GatewayNode,BPMNNode);
	    module.exports = GatewayNode;
	


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	//ExclusiveGateWay节点
	
		var GatewayNode = __webpack_require__(100);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <path d=" M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Rectangle-1" fill="#F6A623"></path>
	 *    <path d=" M8.275862069 11.965517269000001  L1.499999999 11.965517269000001  L0 11.965517269000001  L0 8.965517239  L1.499999999 8.965517239  L8.275862069 8.965517239  L8.275862069 1.499999999  L8.275862069 0  L11.275862069 0  L11.275862069 1.499999999  L11.275862069 8.965517239  L18.741379269 8.965517239  L20.241379269 8.965517239  L20.241379269 11.965517269000001  L18.741379269 11.965517269000001  L11.275862069 11.965517269000001  L11.275862069 18.741379269  L11.275862069 20.241379269  L8.275862069 20.241379269  L8.275862069 18.741379269  L8.275862069 11.965517269000001  z" id="sid-1B88D2DF-A08F-4837-91F2-91F67ACAB29ALine-Copy"></path>
	 * </g>
	 */
	
		function ExclusiveGatewayNode(model, api) {
			GatewayNode.call(this, model, api);
	        this.startIcon = 'M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z';
	        this.nextIcon = 'M19.904129064000003 17.676993964000005  L24.997457864000005 12.583664864000003  L26.058118064000006 11.523004664000002  L28.179438464 13.644324964000003  L27.118778264 14.704985164000002  L22.025449364000004 19.798314364  L27.118778264 24.891643464000005  L28.179438464 25.952303664000006  L26.058118064000006 28.073623964000003  L24.997457864000005 27.012963764000006  L19.904129064000003 21.919634764  L14.810800164000003 27.012963764000006  L13.750140064000002 28.073623964000003  L11.628819664000003 25.952303664000006  L12.689479764000003 24.891643464000005  L17.782808764000002 19.798314364  L12.689479764000003 14.704985164000002  L11.628819664000003 13.644324964000003  L13.750140064000002 11.523004664000002  L14.810800164000003 12.583664864000003  L19.904129064000003 17.676993964000005  z';
	        this.itemSize = 20;
			this.bpmnInfo = {type: 17, name:"ExclusiveGateway" };    //节点信息
	        this.render(model);
		}
	
	    ExclusiveGatewayNode.prototype.render = function(model) {
	        var itemSize = this.itemSize*2;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        var path = graphic.makePath(this.startIcon, {style: {stroke: '#000', fill: '#fff'},z:2}, rect,"center");
	        path.name = 'Path';
	        this.add(path);
	        var itemSize1 = this.itemSize;
	        var rect1 = {x:-itemSize1/2, y: -itemSize1/2, width: itemSize1, height:itemSize1};
	        this.add(graphic.makePath(this.nextIcon, {style: {stroke: '#000'},z:2}, rect1,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+itemSize1 , model.get("bounds.upperLeft.y")+itemSize1];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ExclusiveGatewayNode, GatewayNode);
		module.exports = ExclusiveGatewayNode;
	


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	//ParallelGateWay节点
	
		var GatewayNode = __webpack_require__(100);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <path d=" M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Rectangle-1" fill="#F6A623"></path>
	 *    <path d=" M19.904129064000003 17.676993964000005  L24.997457864000005 12.583664864000003  L26.058118064000006 11.523004664000002  L28.179438464 13.644324964000003  L27.118778264 14.704985164000002  L22.025449364000004 19.798314364  L27.118778264 24.891643464000005  L28.179438464 25.952303664000006  L26.058118064000006 28.073623964000003  L24.997457864000005 27.012963764000006  L19.904129064000003 21.919634764  L14.810800164000003 27.012963764000006  L13.750140064000002 28.073623964000003  L11.628819664000003 25.952303664000006  L12.689479764000003 24.891643464000005  L17.782808764000002 19.798314364  L12.689479764000003 14.704985164000002  L11.628819664000003 13.644324964000003  L13.750140064000002 11.523004664000002  L14.810800164000003 12.583664864000003  L19.904129064000003 17.676993964000005  z" id="sid-8FCD6C01-B973-4C9C-A90B-3D2ADFC75217Line" fill="#FFFFFF"></path>
	 * </g>
	 */
	
		function ParallelGatewayNode(model, api) {
			GatewayNode.call(this, model, api);
	        this.startIcon = 'M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z';
	        this.nextIcon = 'M8.275862069 11.965517269000001  L1.499999999 11.965517269000001  L0 11.965517269000001  L0 8.965517239  L1.499999999 8.965517239  L8.275862069 8.965517239  L8.275862069 1.499999999  L8.275862069 0  L11.275862069 0  L11.275862069 1.499999999  L11.275862069 8.965517239  L18.741379269 8.965517239  L20.241379269 8.965517239  L20.241379269 11.965517269000001  L18.741379269 11.965517269000001  L11.275862069 11.965517269000001  L11.275862069 18.741379269  L11.275862069 20.241379269  L8.275862069 20.241379269  L8.275862069 18.741379269  L8.275862069 11.965517269000001  z';
	        this.itemSize = 20;
			this.bpmnInfo = {type: 20, name:"ParallelGateway" };    //节点信息
	        this.render(model);
		}
	
	    ParallelGatewayNode.prototype.render = function(model) {
	        var itemSize = this.itemSize*2;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        var path = graphic.makePath(this.startIcon, {style: {stroke: '#000', fill: '#fff'},z:2}, rect,"center");
	        path.name = 'Path';
	        this.add(path);
	        var itemSize1 = this.itemSize;
	        var rect1 = {x:-itemSize1/2, y: -itemSize1/2, width: itemSize1, height:itemSize1};
	        this.add(graphic.makePath(this.nextIcon, {style: {stroke: '#000'},z:2}, rect1,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+itemSize1 , model.get("bounds.upperLeft.y")+itemSize1];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ParallelGatewayNode, GatewayNode);
		module.exports = ParallelGatewayNode;
	


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	//子流程
	
	    var Bpmn = __webpack_require__(104);
		var BPMNNode = __webpack_require__(79);
		var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(26);
	    var graphic = __webpack_require__(3);
	    var Connector = __webpack_require__(105);
		//创建Node类 所有形状都继承Node
		//
		function SubProcessNode(model, api) {
	
			BPMNNode.call(this, model, api);
			this.bpmnInfo = {type: -1, name:"SubProcess" };    //节点信息
	        this.model = model;
	        this.slot = [];
	        this.slotEvent = [];
	        this.isCanSlot = true;
	        var width,height;
	        width = model.get("bounds.lowerRight.x")-model.get("bounds.upperLeft.x");
	        height = model.get("bounds.lowerRight.y")-model.get("bounds.upperLeft.y");
	        if(!width || width <= 0){
	            width = 160;
	        }
	        if(!height || height <= 0){
	            height = 100;
	        }
	
	        this.rectSize = {width:width, height:height};
	        this.render(model);
		}
	
	
	    SubProcessNode.prototype.initEvent = function(api) {
	        var that = this;
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'
	
	
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            that.on(eveName, function (e) {
	                var params = {};
	                params.event = e;
	                var current = e.target;
	                if (current.parent &&  current.parent instanceof Connector) {
	                    return;
	                }
	                params.type = eveName;
	                params.target = that;
	                api.trigger(eveName, params);
	            }, this);
	        });
	    };
	
	
	    SubProcessNode.prototype.render = function(model) {
	    	var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	                fill: '#f9f9f9',
	                stroke: '#bbbbbb'
	            },
	            z:0
	        });
	        rect.name = "subprocess-rect";
	        this.add(rect);
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
	
	    SubProcessNode.prototype.getRect = function() {
	        // body...
	        var rect = this.getBoundingRect();
	        var boundingRect = zrUtil.clone(rect);
	        // 取整
	        boundingRect.x = parseInt(boundingRect.x, 10);
	        boundingRect.y = parseInt(boundingRect.y, 10);
	        boundingRect.width = parseInt(boundingRect.width, 10);
	        boundingRect.height = parseInt(boundingRect.height, 10);
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	
	        var boundRect = new BoundingRect(this.position[0] ,
	                                         this.position[1],
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0]+boundingRect.width/2,
	            y: this.position[1]+boundingRect.height/2,
	            width: boundingRect.width,
	            height: boundingRect.height,
	            points: points,
	            boundingRect: boundRect
	        };
	    };
	
	    SubProcessNode.prototype.setPosition = function(pX,pY) {
	        // body...
	        var boundingRect = this.getBoundingRect();
	        this.attr('position',[pX-boundingRect.width/2,pY-boundingRect.height/2]);
	
	    };
	
	
	    SubProcessNode.prototype.refresh = function(opt) {
	        var rect = this.childOfName("subprocess-rect");
	        rect.setShape(opt.shape);
	        this.attr('position',opt.position);
	        this.refreshText();
	    };
	
	    SubProcessNode.prototype.getBoundingRect = function() {
	        var rect = this.childOfName("subprocess-rect");
	        return rect.getBoundingRect();
	    };
	
	    SubProcessNode.prototype.toJSON = function() {
	        this.model.set("resourceId", this.resourceId);
	        this.model.set("properties.type", this.bpmnInfo.type);
	        this.model.set("stencil.type", this.bpmnInfo.name);  //stencil.id
	        if (this.slotEvent && this.slotEvent.length > 0) {
	            var arrSlotEvent = [];
	            for (var i = this.slotEvent.length - 1; i >= 0; i--) {
	                arrSlotEvent.push(this.slotEvent[i].resourceId)
	            }
	            this.model.set("properties.slotEvent", arrSlotEvent);
	        }
	            // var rect = this.getRect();
	            // this.model.set("bounds.upperLeft.x", rect.x);
	            // this.model.set("bounds.upperLeft.y", rect.y);
	            // this.model.set("bounds.lowerRight.x", rect.x + rect.boundingRect.width);
	            // this.model.set("bounds.lowerRight.y", rect.y + rect.boundingRect.height);
	        function parentX(node) {
	            var rect = node.getRect().boundingRect;
	            if (node.parent && Bpmn.isSubProcess(node.parent)) {
	                return rect.x + parentX(node.parent)
	            } else {
	                return rect.x
	            }
	        }
	
	        function parentY(node) {
	            var rect = node.getRect().boundingRect;
	            if (node.parent && Bpmn.isSubProcess(node.parent)) {
	                return rect.y + parentY(node.parent)
	            } else {
	                return rect.y
	            }
	        }
	
	        var rect = this.getRect().boundingRect;
	
	        this.model.set("bounds.upperLeft.x", parseInt(rect.x));
	        this.model.set("bounds.upperLeft.y", parseInt(rect.y));
	        this.model.set("bounds.lowerRight.x", parseInt(rect.x + rect.width));
	        this.model.set("bounds.lowerRight.y", parseInt(rect.y + rect.height));
	
	
	
	        // 加入子流程的 节点
	        var arrChildShapes = [];
	        this.eachChild(function(child){
	            if (child instanceof BPMNNode || child instanceof Connector) {
	                arrChildShapes.push(child.toJSON());
	            }
	        });
	
	
	
	        this.model.set("childShapes", arrChildShapes);
	        return this.model.option;
	    };
	
	    SubProcessNode.prototype.updateShape = function(ratio, ifParse, pixel) {
	        var rect = this.childOfName("subprocess-rect");
	        var scaleRatio = Number(ratio);
	        var shape = rect.shape;
	        var newW = Number(shape.width * scaleRatio);
	        var newH = Number(newW * shape.height / shape.width);
	        if (ifParse) {
	            var w = Math.round(newW / 2 / pixel) * pixel;
	            var h = Math.round(newH / 2 / pixel) * pixel;
	            newW = w * 2 - 1;
	            newH = h * 2 - 1;
	        }
	        rect.setShape({
	            width: newW,
	            height: newH
	        });
	        this.refreshText();
	    };
	
	    SubProcessNode.prototype.nodeType = "SubProcess";
	
		zrUtil.inherits(SubProcessNode,BPMNNode);
		module.exports = SubProcessNode;
	


/***/ }),
/* 104 */
/***/ (function(module, exports) {

	/**
	 * BPMN静态方法类
	 * @class fish.topo.FishTopoBpmn.Bpmn
	 */
	
		var Bpmn = {
			BPMN_TYPE:"stencil.type",
			BPMN_SCRIPT_TASK: "ScriptTask",
			BPMN_EVENT_SUB_PROCESS: "SubProcessTask",
			BPMN_TASK:"Task",
			TEMPLATE: "BPMNDiagram",
			RESOURCE_ID: "resourceId",
			SEQUENCE_FLOW: "SequenceFlow",
			SUB_PROCESS: "SubProcess",
			USER_DATA: "properties.userData",
	
			START_EVENT: "StartNoneEvent",
			END_EVENT: "EndNoneEvent",
			USER_TASK: "UserTask",
			MANUAL_TASK: "ManualTask",
			SCRIPT_TASK: "ScriptTask",
			MAIL_TASK: "MailTask",
			SERVICE_TASK: "ServiceTask",
			SMS_TASK: "SmsTask",
			COMMENT: "Comment",
			CATCH_TIMER_EVENT: "CatchTimerEvent",
			CATCH_SIGNAL_EVENT: "CatchSignalEvent",
			THROW_SIGNAL_EVENT: "ThrowSignalEvent",
			CATCH_MESSAGE_EVENT: "CatchMessageEvent",
			INCLUSIVE_GATEWAY: "InclusiveGateway",
			EXCLUSIVE_GATEWAY: "ExclusiveGateway",
			PARALLEL_GATEWAY: "ParallelGateway",
	
			/**
			 * 判断节点是否 BPMN模板 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isTemplate: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype === Bpmn.TEMPLATE;
			},
	
			/**
			 * 判断节点是否 Activity 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isActivity: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return (bpmntype.indexOf("Task") != -1 || bpmntype === Bpmn.COMMENT);
			},
	
			/**
			 * 判断节点是否 子流程 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isSubProcess: function(node) {
				var bpmntype = node.nodeType;
				return  bpmntype == Bpmn.SUB_PROCESS
			},
	
			/**
			 * 判断节点是否 网关 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isGateway: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype.indexOf("Gateway") != -1;
			},
	
			/**
			 * 判断节点是否 线段 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isFlow: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype === Bpmn.SEQUENCE_FLOW;
			},
	
			/**
			 * @private
			 * 判断模型是否 线段 类型
			 * @param  {Object}  model 需要判断类型的模型
			 * @return {Boolean}      是 否
			 */
			isFlowModel: function(model) {
				var bpmntype = model.get(Bpmn.BPMN_TYPE);
				return bpmntype === Bpmn.SEQUENCE_FLOW;
			},
	
			/**
			 * 判断节点是否 事件 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isEvent: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype.indexOf("Event") != -1;
			},
	
			/**
			 * 判断节点是否 插糟事件 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isSlotEvent: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype == Bpmn.CATCH_TIMER_EVENT || bpmntype == Bpmn.CATCH_SIGNAL_EVENT || bpmntype == Bpmn.THROW_SIGNAL_EVENT;
			},
	
			/**
			 * 判断节点是否 注释 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isComment: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype === Bpmn.COMMENT;
			},
	
			/**
			 * 获取当前节点的类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {String}      节点的类型
			 */
			getType: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype;
			},
	
			/**
			 * 返回当前节点的样式选项
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Object}      样式对象
			 */
			getStyle: function(node) {
				return node.model.option.style;
			},
	
			/**
			 * 返回当前节点的属性选项
			 * @param  {Object}  node 需要判断类型的节点
			 * @return  {Object}      属性对象
			 */
			getProp: function(node) {
				return node.model.option.properties;
			},
	
			/**
			 * 获取用户自定义的数据
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Object}   用户自定义的数据
			 */
			getUserData: function(node) {
				var model = node.model;
				return model.get(Bpmn.USER_DATA);
			},
	
			/**
			 * 设置用户的自定义数据
			 * @param  {Object}  node 需要判断类型的节点
			 * @param {Object} userData 用户的自定义数据
			 */
			setUserData: function(node, userData) {
				var model = node.model;
				model.set(Bpmn.USER_DATA, userData);
			}
		};
	
		module.exports = Bpmn;
	


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连接线
	 * @author wang.xiaohu
	 */
	
	    var Util = __webpack_require__(77);
	    var zrUtil = __webpack_require__(4);
	    var vec2 = __webpack_require__(14);
	    var graphic = __webpack_require__(3);
	    var Node = __webpack_require__(80);
	    var symbolUtil = __webpack_require__(106);
	    var Handle = __webpack_require__(107);
	    var EffectLine = __webpack_require__(108);
	    var ConnectionPoint = __webpack_require__(109);
	    var Point = __webpack_require__(64);
	    var Model = __webpack_require__(83);
	
	    Connector.TYPE_STRAIGHT = 'straight';
	    Connector.TYPE_JAGGED = 'jagged';
	    Connector.TYPE_CURVE = 'curve';
	    Connector.TYPE_CHAIN = 'chain';
	    Connector.RADIUS = 3;
	    Connector.START_NODE = "startNode";
	    Connector.END_NODE = "endNode";
	    Connector.LEFT = "left";
	    Connector.RIGHT = "right";
	    Connector.TOP = "top";
	    Connector.BOTTOM = "bottom";
	    Connector.BOTTOM = "bottom";
	    Connector.SEPERATOR = "-";
	    Connector.NORMAL_COLOR = "#000";
	    Connector.SELECTED_COLOR = '#74B7E0';
	    Connector.CHILD_NAME = ['lineText', 'lineImage'];
	    /**
	     * 构造函数
	     * @param {[type]} options [description]
	     */
	    function Connector(options) {
	        Node.call(this);
	        this.opt = options || {};
	        if (this.opt.model) {
	            this.resourceId = this.opt.model.get("resourceId");
	            this.model = this.opt.model;
	            this.opt = this.opt.model.option;
	        } else {
	            this.resourceId = Util.getUUID(); // 生成节点ID
	            this.model = new Model({});
	        }
	        var defaultOptions = {
	            symbol: { type: "arrow", size: 10, color: Connector.NORMAL_COLOR, both:false, offset:0 }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	            style: { lineWidth: 1, stroke: Connector.NORMAL_COLOR, lineType: Connector.TYPE_STRAIGHT }, //样式
	            hoverStyle: { lineWidth: 2, stroke: Connector.SELECTED_COLOR }, //移上去的样式
	            arrowHoverStyle: { fill: Connector.SELECTED_COLOR},
	            shape: { points: null, smooth: false, smoothConstraint: null }, //形状
	            position: { startPos:null, endPos:null,  //指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	                        startOffset:[0,0],  // 起始线段离节点的偏移
	                        endOffset:[0,0],    // 终止线段离节点的偏移
	                        escapeDistance:[30,30], // 第一条折线的长度，最后一条折线的长度
	                        points:null    //不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	                    },
	            autoChangePosition: false,
	            textContextMenu: null,
	            isEdit: true, //是否可编辑
	            text: {
	                text: null,
	                textFill: '#000000', // 文本颜色
	                textFont: '12px Microsoft YaHei',
	                textPos: 'center',
	                textRotateable: true
	            },
	            image: {
	                image: null,
	                width: 50,
	                height: 50,
	                // style: {
	                //     // image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAAyCAYAAAAA9rgCAAAEZklEQVRoQ+2aXYgbVRTHz/8muwSJWPx4sFgoaBUrWorUL8SK9UGhFCt2URRhQai6uLDZyR0DhTaIZu/NZPdNrYL4haKlflDwoSgUVKrYIhRaP7B92Ibtg1JfIqzZnRy5y0Rmx2R3MqlJZpN5nDnn3v/vnnvnnvsBavBora8HcFutVtvS6HsvvxNCnAdwipnPZLPZv4JaEXyhtS4SkdXLUCG1zQoh9lmW9Z7ffhmw1nqWiDaELDAWZsyct237QF3sv8Ba6++I6M5YULQu8j4p5dfGbQlYKXUAwP7Wy4mNxy8Abjdjug78IYDHffLLzPySbdtvxAbJE+o4zmbXdUeCARRC3GFZ1g91YNMCN/rgDkkpR+IGW9ertd5JREcC+kellG8vAWut2f8xONDjCN6MaQBsojmIcAz79KBLewnIYAz30hguFou7mXkTgN+FELOTk5NfhR1dsevSWuuPiWhPAPBTKeWjYaBjBayUOmFSwSZgz0spX1sNOjbATbKkZXzJZPKqTCZzcSXo2AArpSYBOCvBALgrm81+vyaAi8XiKDO/tRKMEOJmy7J+XhPApVJph+u6XzaDAfBrpVLZks/n5zsOPDMzs25hYWEjM/9h23Z5tR9J2O9a60+IaHcj+0Qi8WCY6emSjOFCoXC/EGIPgHuIaCMRrfOJOk1ER4noODMfb7cBtNbPEdGrvvLnvDX662Eari1gpVQWgJkTt4WpzEteCul0+pWxsbFKWJ+g3fT09JWu625i5oupVGp2fHz877BlRQbWWheI6MWwFfntAPwI4CnLss5E8W/Hpx3gZZsDEUScFkKMdBr6kgEz828APgdweHFx8cL8/PxcOp3eWqvVHgbwUJOdz8NSysciNFZkl8jA3o7mdq/mopTyi1WmA2k2QoM2AJ7NZrMHIxO06BgZuMV6lsy11k8T0TsB33IymdyeyWTORSmzVZ+OAnvQJsom2v7nAynlk62Kj2LfcWDHca6u1WrfENFNfsHM/LJt2/uiQLTi03FgL8rPENGbQaHMvCFMYlIoFLYJIcwy8VYAmwF8S0QnmfmUlPLsKv+ShlvP//sWj9ba5MU7Goi7V0ppAP7zTE1NmZODJwA8sgLUR8zs2LZ9opFNVyJshCildplprIlwk4YeNWe6ruuWhRAPMPMogGtCdt8qETmu6zq5XO5Pv0/XgL2ubfLfvSEhopj9RET7pZSH6s5dBfagTZR3RaCZMwsSAOeY2SxY7iai6xqVMzQ0tH5iYuKCV193xnCgmzX8iTVphLPM/P7w8PDBOoQvei8w8ziAG/y+9RPCngE2QnzHmSbVvKUB7GcA3q1UKkfy+fxisx7hraQMuJnrLyOiYwB21u91dL1LNxKulLo8mUxeW61W1ycSifOpVKrcyhLQlFkqlbZWq9UrcrncsZ75aUUYt2279GSE26ZaoYAB8OAwzdc91vyBuFKqvy61KKX67tpSf11M81Kx/rl66MtR++dyqQ+6f64P+6DX7AXxfwANvfFgWcCyjAAAAABJRU5ErkJggg==",
	                //     // width:50,
	                //     // height:50
	                // },
	                imagePos: 'center',
	                imageRotateable: true // 图片是否跟随线段旋转
	            },
	            z: 0
	        }
	
	        this.options = Util.mergeOpt(defaultOptions, this.opt, true, 'textContextMenu');
	        this.handles = [];
	        this.conPointsGroup = new graphic.Group();
	        this.startNode = null;
	        this.endNode = null;
	        this.line = null;
	        this.groupCurve = new graphic.Group();
	        this.icons = []; // 用于存储线段上面的操作图标
	        this.render();
	    }
	
	        /**
	     * 创建连线节点
	     * @param  {[Object]} options [节点参数]
	     * @param  {[String]} type [节点类型] 'text' 'image'
	     */
	    Connector.prototype.createLineNode = function(options, type) {
	        var that = this;
	        var text = null;
	        if (!type) {
	            type = 'text';
	        }
	        var nodeName = zrUtil.find(Connector.CHILD_NAME, function(name) {
	            return name.toLocaleLowerCase().indexOf(type) > -1;
	        });
	        if (zrUtil.isArray(options[type]) && this.options.style.lineType == Connector.TYPE_CHAIN) {
	            options[type].forEach(function (v, i) {
	                var content = that.drawText(nodeName+"-"+i, v, 0, 0, type);
	                if (zrUtil.isString(v)) {
	                    var obj = {};
	                    obj[type] = v;
	                    obj[type+'Id'] = content.text.id;
	                    that.options[type][type][i] = obj;
	                } else {
	                    that.options[type][type][i].textId = content.text.id;
	                }
	                that.add(content.text);
	                that.createNodeContextMenu(content.text);
	            });
	        } else {
	            text = this.drawText(nodeName, options, 0, 0, type);
	            this.add(text.text);
	        }
	        if (text) {
	            that.createNodeContextMenu(text.text);
	        }
	    }
	
	    Connector.prototype.ifLineNodeRotateable = function(type) {
	        if (!type) {
	            type = 'text';
	        }
	        if (this.options.style.lineType == Connector.TYPE_STRAIGHT) {
	            if ((type === 'text' && this.options.text.textRotateable) || (type === 'image' && this.options.image.imageRotateable))
	            return true;
	        }
	        return false;
	    }
	
	    /**
	     * 更新连线的文字/图片节点
	     * @param  {[Object]} lineNode [节点]
	     * @param  {[Object]} options [节点参数]
	     * @param  {[String]} type [节点类型] 'text' 'image'
	     */
	    Connector.prototype.refreshLineNode = function(lineNode, options, type) {
	        var self = this, lineNodeArr = [], nodeName = Connector.CHILD_NAME[0];
	        if (!type) {
	            type = 'text';
	        }
	        nodeName = zrUtil.find(Connector.CHILD_NAME, function(name) {
	            return name.toLocaleLowerCase().indexOf(type) > -1;
	        });
	        if (this.options.style.lineType == Connector.TYPE_CHAIN && zrUtil.isArray(options[type])) {
	            options[type].forEach(function (v, i) {
	                lineNodeArr.push(self.childOfName(nodeName+'-'+i));
	            });
	        } else if (!lineNode && options[type]) {
	            var text = this.drawText(nodeName, options, 0, 0, type);
	            this.add(text.text);
	            lineNode = this.childOfName(nodeName);
	        }
	        if (lineNodeArr.length > 0) {
	            var cnt = lineNodeArr.length,
	                distance = this.turningPoints[1].x - this.turningPoints[0].x,
	                gap = parseInt(distance/cnt),
	                pos = -(gap) * parseInt(cnt/2);
	
	                lineNodeArr.forEach(function (v, i) {
	                var textPoint = self.getTextPostion(options, v), way = '';
	
	                var rate = self.getTextRotation(textPoint, v);
	                if (Math.abs(rate) === 0) {
	                    rate = 0;
	                } else {
	                    way = rate > 0 ? 'plus' : 'minus';
	                }
	                rate = Math.abs(rate);
	                var deg = (180*rate)/Math.PI;
	                var rotation = null, length = null;
	                if (type === 'text') {
	                    v.setStyle("text", zrUtil.isString(options[type][i]) ? options[type][i] : options[type][i].text);
	                    // 更新文字矩形包围盒
	                    var textBoundingRect = self.getTextBoundingRect(v.style);
	                    v.setShape({
	                        width: textBoundingRect.width,
	                        height: textBoundingRect.height
	                    });
	                }
	
	                if (way) {
	                    rotation = deg > 90 ? ((deg-45)*Math.PI)/180 : ((45+deg)*Math.PI)/180;
	                    rotation = way === 'minus' ? -(rotation) : rotation;
	                } else {
	                    rotation = (45*Math.PI)/180
	                }
	                v.attr('rotation', rotation);
	
	                if (deg === 90) {
	                    textPoint[1] -= pos;
	                } else {
	                    textPoint[0] += pos;
	                    if (rate !== 0) {
	                        length = Math.tan(deg*Math.PI/180)*pos;
	                        if (pos > 0) {
	                            textPoint[1] -= way === 'plus' ? length : -(length);
	                        } else {
	                            textPoint[1] += way === 'plus' ? -(length) : (length);
	                        }
	                    }
	                }
	
	                v.attr("position", textPoint);
	                pos += gap;
	            });
	        }
	        if (lineNode) {
	            if (type === 'text') {
	                lineNode.setStyle("text", options[type]);
	                var textRect = this.getTextBoundingRect(options);
	                lineNode.setShape({
	                    width: textRect.width,
	                    height: textRect.height
	                });
	            }
	            var textPoint = this.getTextPostion(options, lineNode);
	            if (this.ifLineNodeRotateable(type)) { //#187
	                lineNode.attr('rotation', this.getTextRotation(textPoint, lineNode));
	            }
	            lineNode.attr("position", textPoint);
	        }
	    }
	
	
	    /**
	     * 重新画线，如果传空则根据turningPoints 重新画线
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    Connector.prototype.refresh = function(arrPoints) {
	        var that = this;
	        if (arrPoints) {
	            this.turningPoints = arrPoints;
	        }
	        //将[x:0,y:0]转化为[0, 0]  给zrender使用
	        var points = Util.traslatePoints(this.turningPoints);
	
	        if ((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {
	            this.modifyCurve(this.turningPoints);
	        } else {
	            this.line.attr('shape', { points: points });
	        }
	
	        // 更新线段文字/图片节点
	        Connector.CHILD_NAME.forEach(function(name) {
	            var lineNode = that.childOfName(name);
	            var type = name === Connector.CHILD_NAME[0] ? 'text' : 'image';
	            that.refreshLineNode(lineNode, that.options[type], type);
	        });
	
	        this.refreshFromToSymbol(points);
	        this.refreshHandles();
	    };
	    /**
	     * 创建线上节点的右击监听
	     * @return {[type]} [description]
	     */
	    Connector.prototype.createNodeContextMenu = function (node) {
	        if (node && this.opt.textContextMenu) {
	            var textContextMenu = this.opt.textContextMenu;
	            node.on("contextmenu",function(e) {
	                e.event.preventDefault();
	                e.event.stopPropagation();
	                textContextMenu.buildMenu(e.event,this);
	            })
	        }
	    }
	    /**
	     * 渲染
	     * @return {[type]} [description]
	     */
	    Connector.prototype.render = function() {
	        var that = this;
	        //1.创建箭头
	        this.renderFromToSymbol();
	
	        //2.创建线
	        this.curveLine = new graphic.BezierCurve({
	            //position: this.options.position,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.groupCurve.add(this.curveLine);
	        this.add(this.groupCurve);
	        this.add(this.conPointsGroup);
	        this.polyLine = new graphic.Polyline({
	            //position: this.options.position,
	            shape: this.options.shape,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.add(this.polyLine);
	
	        if ((this.options.style.lineType == Connector.TYPE_CURVE)) {
	            this.line = this.groupCurve;
	            this.createHoverStyle(this.curveLine);
	            this.polyLine.hide();
	        } else {
	            this.line = this.polyLine;
	            this.createHoverStyle(this.polyLine);
	            this.curveLine.hide();
	        }
	
	        //3.侦听线事件
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click']; //'click', 'dblclick', 'mouseover', 'mouseout'
	        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	            this.line.on(eveName, zrUtil.bind(function(e) {
	                e.cancelBubble = true;
	                var params = {};
	                params.event = e;
	                params.type = "Connector:" + eveName;
	                params.target = that;
	                this.trigger(params.type, params);
	                if (this.options.isEdit == false) {
	                    return; }
	                that.setSelectedStyle(this);
	                if (this.handles.length < 1) {
	                    this.shapeSetHandle();
	                }
	
	            }, this));
	        }, this);
	
	        //4.创建线上文本
	        if (this.options.text.text) {
	            this.createLineNode(this.options.text, 'text');
	        }
	        // // 5.创建线上图片节点
	        if (this.options.image.image) {
	            this.createLineNode(this.options.image, 'image');
	        }
	    };
	
	    Connector.prototype.renderFromToSymbol = function(options) {
	        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle
	        if (symbolTo) {
	            this.add(symbolTo);
	        }
	        //如果双向箭头 则再创建首箭头
	        if (this.options.symbol.both) {
	            var symbolFrom = this.createSymbol('fromSymbol', this.options); //arrow,triangle
	            if (symbolFrom) {
	                this.add(symbolFrom);
	            }
	        }
	    }
	
	    Connector.prototype.refreshFromToSymbol = function(points) {
	        var symbolTo = this.childOfName('toSymbol');
	        var symbolFrom = this.childOfName('fromSymbol');
	        var position = [], offset = this.options.symbol.offset;
	        if (symbolTo) {
	            if (this.options.effect && this.options.effect.show) {
	                new EffectLine(symbolTo, this.options, this.groupCurve, this.polyLine);
	            } else {
	                position = points[points.length - 1];
	                if (this.options.style.lineType !== Connector.TYPE_CURVE) {
	                    var distance = vec2.distance(points[points.length - 1], points[points.length - 2]);
	                    if (offset <= distance) {
	                        position = vec2.lerp(
	                            [], points[points.length - 1], points[points.length - 2],
	                            offset / distance);
	                    } else {
	                        position = points[points.length - 1];
	                    }
	                }
	                symbolTo.attr('position', position);
	                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]));
	            }
	        }
	
	        if (symbolFrom) {
	            position = points[0];
	            if (this.options.style.lineType !== Connector.TYPE_CURVE) {
	                var distanceFrom = vec2.distance(points[0], points[1]);
	                if (offset <= distanceFrom) {
	                    position = vec2.lerp(
	                        [], points[0], points[1],
	                        offset / distanceFrom);
	                } else {
	                    position = points[0];
	                }
	            }
	            symbolFrom.attr('position', position);
	            symbolFrom.attr('rotation', Util.tangentRotation(this.turningPoints[1], this.turningPoints[0]));
	        }
	    }
	    /**
	     * 设置style
	     * @param {object} options 样式对象
	     * @param {boolean} notSaveModel 设置样式是否保存到模型中,默认是false
	     */
	    Connector.prototype.setStyle = function(options,notSaveModel) {
	        var lineOpt = {};
	        var symbolTo = null;
	        var notLineKeys = ['text', 'image', 'symbol'];
	        // if (options.color) {
	        //     if (this.options.style.lineType == Connector.TYPE_CURVE) {
	        //         this.groupCurve.eachChild(function(curve) {
	        //             curve.attr("style", { stroke: options.color });
	        //             graphic.setNormalStyle(curve, { stroke: options.color });
	        //         });
	        //     } else {
	        //         this.polyLine.attr("style", { stroke: options.color });
	        //         graphic.setNormalStyle(this.polyLine, { stroke: options.color });
	        //     }
	        //     symbolTo = this.childOfName('toSymbol');
	        //     if (symbolTo) {
	        //         symbolTo.attr("style", { fill: options.color });
	        //         graphic.setNormalStyle(symbolTo, { fill: options.color });
	        //     }
	        //     if(!notSaveModel) {
	        //         this.options.style.stroke = options.color;
	        //         this.model.set("options.style.stroke", options.color);
	        //         this.model.set("options.symbol.color", options.color);
	        //         this.options.symbol.color = options.color;
	        //     }
	        // }
	
	        if (options.text) {
	            var lineText = this.childOfName(Connector.CHILD_NAME[0]);
	            //开始没有创建文本，后来传进来text了，需要先创建文本
	            if (!lineText && options.text.text) {
	                var text = this.drawText(Connector.CHILD_NAME[0], options.text, 0, 0);
	                this.add(text.text);
	                lineText = this.childOfName(Connector.CHILD_NAME[0]);
	            }
	
	            if (options.text.text || options.text.text == "") {
	                lineText.setStyle("text", options.text.text);
	                this.options.text.text = options.text.text;
	            }
	            var textPoint = this.getTextPostion(options.text);
	            lineText.attr("position", textPoint);
	            if (options.text.textPos) {
	                this.options.text.textPos = options.text.textPos;
	            }
	            if (options.text.offset) { //#187
	                this.options.text.offset = options.text.offset;
	            }
	
	            if (options.text.color) {
	                lineText.attr("style", {
	                    textFill: options.text.color
	                });
	                this.options.text.textFill = options.text.color;
	            }
	
	            if (options.text.textFont) {
	                lineText.attr("style", {
	                    textFont:options.text.textFont
	                });
	                this.options.text.textFont = options.text.textFont;
	            }
	
	            if (options.text.textFill) {
	                lineText.attr("style", {
	                    textFill: options.text.textFill
	                });
	                this.options.text.textFill = options.text.textFill;
	            }
	            this.model.set("options.text", options.text);
	        }
	
	        if (options.image) {
	            var lineImage = this.childOfName(Connector.CHILD_NAME[1]);
	            //开始没有创建图片，后来传进来image了，需要先创建图片
	            if (!lineImage && options.image.image) {
	                var image = this.drawText(Connector.CHILD_NAME[1], options.image, 0, 0, 'image');
	                this.add(image.text);
	                lineImage = this.childOfName(Connector.CHILD_NAME[1]);
	            }
	            var imagePoint = this.getTextPostion(options.image, lineImage);
	            lineImage.attr("position", imagePoint);
	            Object.keys(options).forEach(function(key) {
	                this.options.image[key] = options[key];
	            }.bind(this));
	            if (options.image.offset) { //#187
	                this.options.image.offset = options.image.offset;
	            }
	            this.model.set("options.image", options.image);
	        }
	
	        if (options.symbol) {
	            if (options.symbol.type) {
	                this.options.symbol.type = options.symbol.type;
	                this.model.set("options.symbol.type", options.symbol.type);
	            }
	            if (options.symbol.size) {
	                this.options.symbol.size = options.symbol.size;
	                this.model.set("options.symbol.size", options.symbol.size);
	            }
	            if (options.symbol.color) {
	                this.options.symbol.color = options.symbol.color;
	                this.model.set("options.symbol.color", options.symbol.color);
	            }
	            if (options.symbol.z) {
	                this.options.symbol.z = options.symbol.z;
	                this.model.set("options.symbol.z", options.symbol.z);
	            }
	
	            symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) {
	                this.remove(symbolTo);
	            }
	            var symbol = this.createSymbol("toSymbol", this.model.get("options"))
	            if (symbol) {
	                this.add(symbol);
	            }
	        }
	        Object.keys(options).forEach(function(key) {
	            if (notLineKeys.indexOf(key) < 0) {
	                lineOpt[key] = options[key];
	            }
	        });
	        if (JSON.stringify(lineOpt) !== '{}') {
	            if (lineOpt.color) {
	                lineOpt.stroke = lineOpt.color;
	            }
	            if (lineOpt.stroke) {
	                lineOpt.color = lineOpt.stroke;
	            }
	            if (this.options.style.lineType == Connector.TYPE_CURVE) {
	                this.groupCurve.eachChild(function(curve) {
	                    curve.attr("style", lineOpt);
	                    graphic.setNormalStyle(curve, lineOpt);
	                });
	            } else {
	                this.polyLine.attr("style", lineOpt);
	                graphic.setNormalStyle(this.polyLine, lineOpt);
	            }
	            symbolTo = this.childOfName('toSymbol');
	            if (symbolTo && lineOpt.color) {
	                symbolTo.attr("style", { fill: lineOpt.color });
	                graphic.setNormalStyle(symbolTo, { fill: lineOpt.color });
	            }
	            if(!notSaveModel) {
	                Object.keys(lineOpt).forEach(function(key) {
	                    this.options.style[key] = lineOpt[key];
	                    this.model.set("options.style"+ key, lineOpt[key]);
	                }.bind(this));
	                if (lineOpt.color) {
	                    this.options.symbol.color = lineOpt.color;
	                }
	            }
	        }
	        this.refresh();
	    };
	
	    /**
	     * 设置选中style
	     */
	    Connector.prototype.setSelectedStyle = function() {
	        // 选中的连线层级是最高的
	        var symbolTo;
	        this.setStyle(this.options.hoverStyle, true);
	        if (this.options.style.lineType == Connector.TYPE_CURVE) {
	            this.groupCurve.eachChild(function(curve) {
	                curve.attr("z", this.options.z + 2);
	            }.bind(this));
	        } else {
	            this.polyLine.attr('z', this.options.z + 2);
	        }
	        symbolTo = this.childOfName('toSymbol');
	        if (symbolTo) {
	            symbolTo.attr("z", this.options.z + 2);
	        }
	    };
	
	    /**
	     * 设置取消选中style
	     */
	    Connector.prototype.removeSelectedStyle = function() {
	        var symbolTo;
	        this.setStyle({color:this.options.style.stroke,lineWidth:this.options.style.lineWidth},true);
	        if (this.options.style.lineType == Connector.TYPE_CURVE) {
	            this.groupCurve.eachChild(function(curve) {
	                curve.attr("z", this.options.z);
	            }.bind(this));
	        } else {
	            this.polyLine.attr('z', this.options.z);
	        }
	        symbolTo = this.childOfName('toSymbol');
	        if (symbolTo) {
	            symbolTo.attr("z", this.options.z);
	        }
	    };
	
	    /**
	     * 获取线段节点的位置
	     * @param  {Object} text {text:'', color:'', textPos:''}
	     * @return {Object}      {x,y}
	     */
	    Connector.prototype.getTextPostion = function(text, node) {
	        var textPostion = [];
	        var textRect = text.image && node ? node.getBoundingRect() : this.getTextBoundingRect(text);
	        var textWidth = textRect.width;
	        var textHeight = textRect.height || 12;
	        var pos;
	        if (text && (text.textPos || text.imagePos)) {
	            var offset = text.offset || 0;
	            var arrOffset = offset;
	            pos = text.textPos || text.imagePos;
	            if (!zrUtil.isArray(offset)) {
	                arrOffset = [offset, 0];
	            }
	            var pointsOrigin = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]]);
	            var points = [], beizierPoints =[];
	              var angle = Util.getAngle(pointsOrigin[0], pointsOrigin[1]);
	            var length, newPoint;
	            if (this.options.style.lineType == Connector.TYPE_CURVE) {
	                beizierPoints = this.getPointsFromCurve();
	            }
	            pointsOrigin.forEach(function(item) {
	                var itemCopy = new Point(item.x, pointsOrigin[1].x >= pointsOrigin[0].x ? item.y - textHeight / 2 : item.y + textHeight / 2);
	                points.push(itemCopy);
	            });
	            switch(pos) {
	                case 'start':
	                    if (this.options.style.lineType === Connector.TYPE_STRAIGHT) {
	                        length = arrOffset[0];
	                        newPoint = Util.getEndPoint(points[0], length, angle);
	                        textPostion = [newPoint.x, newPoint.y + arrOffset[1]];
	                    } else {
	                        textPostion = [this.turningPoints[0].x - textWidth / 2 + arrOffset[0], this.turningPoints[0].y + arrOffset[1] - textHeight / 2];
	                    }
	                    break;
	                case 'end':
	                    if (this.options.style.lineType === Connector.TYPE_STRAIGHT && !this.options.text.textRotateable) {
	                        length = Util.distance(points[0], points[1]);
	                        newPoint = Util.getEndPoint(points[0], length, angle);
	                        textPostion = [newPoint.x  - textWidth + arrOffset[0], newPoint.y + arrOffset[1]];
	                    } else {
	                        length = Util.distance(points[0], points[1]) - textWidth + arrOffset[0];
	                        newPoint = Util.getEndPoint(points[0], length, angle);
	                        textPostion = [newPoint.x, newPoint.y + arrOffset[1]];
	                    }
	                    break;
	                default:
	                    var midPoint = this.middle(text);
	                    if (this.ifLineNodeRotateable(text.image ? 'image' : 'text')) {
	                          var rotate = this.getTextRotation(text);
	                          var positionBefore = [midPoint[0] - textWidth / 2, midPoint[1] - textHeight / 2];
	                          textPostion = Util.calculatePoints(positionBefore, {x: midPoint[0], y: midPoint[1]}, rotate);
	                    } else if (this.options.style.lineType == Connector.TYPE_CURVE) {
	                        // 曲线的文字position单独计算
	                        var arr = [];
	                        beizierPoints.forEach(function(item) {
	                            arr = arr.concat(item);
	                        });
	                        var index = Math.round(arr.length / 2);
	                        textPostion = [arr[index].x - textWidth / 2, arr[index].y -textHeight / 2];
	                    } else {
	                        textPostion = [midPoint[0] + arrOffset[0], midPoint[1] + arrOffset[1]];
	                        if (this.options.style.lineType !== Connector.TYPE_CHAIN) {
	                            textPostion = [textPostion[0] - textWidth / 2, textPostion[1] - textHeight / 2];
	                        }
	                    }
	                    break;
	            }
	        } else {
	            var position = this.middle(text);
	            textPostion = [position[0] - textWidth / 2, position[1]];
	        }
	
	        return textPostion;
	    };
	
	    /**
	     * 获取线段的旋转角度
	     * @param  {Object} textPostion {x,y}
	     * @return {Number}             角度值
	     */
	    Connector.prototype.getTextRotation = function(options) {
	        //计算出极坐标的角度
	        var points = Util.getMaxLineLength(this.turningPoints);
	        var midPoint = this.middle(options);
	        var angle = -Math.atan2(points[1].y - midPoint[1], points[1].x - midPoint[0]); //,Math.PI/2
	        return angle;
	    };
	
	    Connector.prototype.createHoverStyle = function(el) {
	        if (this.options.hoverStyle && this.options.isEdit) {
	            graphic.setElementHoverStl(el, this.options.hoverStyle);
	
	            var symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) { graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle); }
	
	            el.on('mouseover', zrUtil.bind(function() {
	                graphic.doEnterHover(el);
	                if (symbolTo) { graphic.doEnterHover(symbolTo); }
	
	                this.groupCurve.eachChild(function(line) {
	                    graphic.doEnterHover(line);
	                });
	            }, this))
	            .on('mousemove', zrUtil.bind(function(e) {
	                var startPoint = this.turningPoints[0];
	                var endPoint = this.turningPoints[this.turningPoints.length - 1];
	                var startDiff = Math.abs(e.event.offsetX - startPoint.x) + Math.abs(e.event.offsetY - startPoint.y);
	                var endDiff = Math.abs(e.event.offsetX - endPoint.x) + Math.abs(e.event.offsetY - endPoint.y);
	                if (startDiff <= 15 || endDiff <= 15) {
	                    el.cursor = 'move';
	                    el.draggable = true;
	                } else {
	                    el.cursor = 'pointer';
	                    el.draggable = false;
	                }
	            }, this))
	            .on('mouseout', zrUtil.bind(function() {
	                graphic.doLeaveHover(el);
	                if (symbolTo) { graphic.doLeaveHover(symbolTo); }
	                this.groupCurve.eachChild(function(line) {
	                    graphic.doLeaveHover(line);
	                });
	            }, this));
	        }
	    };
	    /**
	     * 创建Node的连接点
	     * @private
	     *
	     * @return {[type]} [description]
	     */
	    Connector.prototype.createAllconnectionPoint = function() {
	        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);
	        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length - 1].clone(), ConnectionPoint.TYPE_CONNECTOR);
	    };
	
	    /**
	     * 创建连接点
	     * @private
	     * @param  {[type]} shape [description]
	     * @param  {[type]} point [description]
	     * @param  {[type]} type  [description]
	     * @return {[type]}       [description]
	     */
	    Connector.prototype.connectionPointCreate = function(shape, point, type) {
	        var conPoint = new ConnectionPoint(this, point, type, this.options);
	        this.conPointsGroup.add(conPoint.shape);
	    };
	
	    /**
	     * 清空控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.clearHandles = function() {
	        for (var i = 0; i < this.handles.length; i++) {
	            this.remove(this.handles[i].handleShape);
	        }
	        this.handles = [];
	        if (this.conPointsGroup) {
	            this.conPointsGroup.removeAll();
	        }
	        //恢复原来的颜色
	        this.removeSelectedStyle();
	    };
	
	    /**
	     * 更新控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.refreshHandles = function() {
	        var points = this.turningPoints;
	        var beizierPoints = [];
	        var x, y, type;
	        if (this.handles.length > 0) {
	            if (this.options.style.lineType == Connector.TYPE_CURVE) {
	                // 获取曲线的路径点集合
	                beizierPoints = this.getPointsFromCurve();
	            }
	            for(var i = 0; i < this.handles.length; i++) {
	                var associatedPoint = this.handles[i].associatedPoint;
	                type = this.handles[i].type;
	                var index = points.findIndex(function(item) {
	                    return item.x == associatedPoint.x && item.y == associatedPoint.y;
	                });
	                if (index > 1) {
	                    if (type == 'h') {
	                        x = points[index - 1].x;
	                        y = (points[index - 1].y + points[index].y) / 2;
	                    } else if (type == 'v') {
	                        x = (points[index - 1].x + points[index].x) / 2;
	                        y = points[index - 1].y;
	                    }
	                    if (this.options.style.lineType == Connector.TYPE_CURVE && beizierPoints.length > 0) {
	                        var beizierPoint = zrUtil.find(beizierPoints[index - 2], function(point) {
	                            var dValue;
	                            if (type === 'h') {
	                                dValue = Math.abs(point.y - y);
	                            } else if (type === 'v') {
	                                dValue = Math.abs(point.x - x);
	                            }
	                            return dValue < 1;
	                        });
	                        if (beizierPoint) {
	                            x = beizierPoint.x;
	                            y = beizierPoint.y;
	                        }
	                    }
	                    this.handles[i].update(x, y);
	                }
	            }
	        }
	    }
	
	    /**
	     * 创建拆线 线断的控制点
	     * 曲线控制点位置计算精确
	     * @return {[type]} [description]
	     */
	    Connector.prototype.shapeSetHandle = function() {
	        var points = this.turningPoints;
	        // 获取曲线的路径点集合
	        var beizierPoints = this.getPointsFromCurve();
	        var type;
	        for (var i = 1; i < points.length - 2; i++) {
	            var h;
	            var x, y;
	            //是否在一条线上
	            var isCollineaityFirst = Util.collinearity(points[i - 1], points[i], points[i + 1]);
	            var isCollineaitySecond = Util.collinearity(points[i], points[i + 1], points[i + 2]);
	            if ((!isCollineaityFirst && (!isCollineaitySecond || points[i + 1].equals(points[i + 2]))) || ((!isCollineaityFirst || points[i - 1].equals(points[i])) && !isCollineaitySecond)) {
	
	                if (points[i].x === points[i + 1].x) { //same vertical
	                    x = points[i].x;
	                    y = (points[i].y + points[i + 1].y) / 2;
	                    type = 'h';
	                } else if (points[i].y === points[i + 1].y) { // same horizontal
	                    x = (points[i].x + points[i + 1].x) / 2;
	                    y = points[i].y;
	                    type = 'v';
	                }
	                if (x && y) {
	                    if (this.options.style.lineType == Connector.TYPE_CURVE && beizierPoints.length > 0) {
	                        var beizierPoint = zrUtil.find(beizierPoints[i - 1], function(point) {
	                            var dValue;
	                            if (type === 'h') {
	                                dValue = Math.abs(point.y - y);
	                            } else if (type === 'v') {
	                                dValue = Math.abs(point.x - x);
	                            }
	                            return dValue < 1;
	                        });
	                        if (beizierPoint) {
	                            x = beizierPoint.x;
	                            y = beizierPoint.y;
	                        }
	                    }
	                    h = new Handle(type, x, y, this);
	                    h.associatedPoint = points[i + 1]; // 连线控制点与this.turningPoints关联
	                }
	                if (h) {
	                    this.add(h.handleShape);
	                    this.handles.push(h);
	                }
	
	            }
	        }
	    };
	
	
	    /**
	     * 创建箭头
	     * @param  {[type]} name       [description]
	     * @param  {[type]} options [description]
	     * @return {[type]}            [description]
	     */
	    Connector.prototype.createSymbol = function(name, options) {
	        var symbolType = options.symbol.type;
	        var symbolSize = options.symbol.size;
	        if (symbolType === 'none') {
	            return;
	        }
	
	        if (!zrUtil.isArray(symbolSize)) {
	            symbolSize = [symbolSize, symbolSize];
	        }
	
	        var symbolZIndex = options.z;
	
	        if (options.symbol.z) { symbolZIndex = options.symbol.z }
	
	        var symbolPath = symbolUtil.createSymbol(
	            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,
	            symbolSize[0], symbolSize[1], symbolZIndex, options.symbol.color
	        );
	        symbolPath.name = name;
	
	        return symbolPath;
	    };
	
	    Connector.prototype.draw = function(name, content) {
	
	    }
	
	    /**
	     * 绘制线段上的文本
	     * 用矩形代替文本
	     * @param  {[type]} content [description]
	     * @param  {[type]} name [description]
	     * @param  {[type]} x       [description]
	     * @param  {[type]} y       [description]
	     * @param  {[type]} color   [description]
	     * @return {[type]}         [description]
	     */
	    Connector.prototype.drawText = function(name, content, x, y, type) {
	        if (!type) {
	            type = 'text';
	        }
	        var opt = zrUtil.isString(content) ? (type === 'text' ? {text:content, x:x, y:y} : {image:content, x:x, y:y})
	                                           : zrUtil.defaults({x:x, y:y}, content, true);
	
	        var textStyle = zrUtil.defaults(zrUtil.clone(this.options.text), opt, true);
	        var node;
	        if (type === 'text') {
	            var textBoundingRect = this.getTextBoundingRect(textStyle);
	            textStyle = zrUtil.defaults(textStyle, { fill: '#F9F9F9', transformText: true }, true);
	            node = new graphic.Rect({
	                shape: { width: textBoundingRect.width, height: textBoundingRect.height },
	                style: textStyle,
	                zlevel: 20,
	                name : name
	            });
	        } else {
	            node = new graphic.Image({
	                type: 'LinkImage',
	                style: textStyle,
	                zlevel: 20,
	                name : name
	            });
	        }
	        return {
	            text: node,
	            rect: node.getBoundingRect()
	        };
	    };
	     /**
	     * 获取线段文本包围盒
	     * @param  {[type]} content [description]
	     * @return {[type]}         [description]
	     */
	    Connector.prototype.getTextBoundingRect = function(text) {
	        var textRect = graphic.textContain.getBoundingRect(text.text, text.textFont);
	        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	        var textHeight = textRect.height || 12;
	        return {
	            width: textWidth,
	            height: textHeight
	        }
	    };
	
	    /**
	     * 获取线段的中间值
	     * @return {[type]} text
	     */
	    Connector.prototype.middle = function() {
	
	        if (this.options.style.lineType == Connector.TYPE_STRAIGHT || this.options.style.lineType == Connector.TYPE_CHAIN) {
	            var points = Util.getMaxLineLength(this.turningPoints);
	            //如果是求线段上的文字的中间值
	            // if(text) {
	            //     //取出字的长度，计算角度，
	            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	            //     var angle = Util.getAngle(points[0],points[1]);
	            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;
	            //     var newPoint = Util.getEndPoint(points[0], length, angle);
	            //     return [newPoint.x, newPoint.y];
	            // } else {
	            //     var middleX = (points[0].x + points[1].x)/2;
	            //     var middleY = (points[0].y + points[1].y) /2;
	            //     return [middleX, middleY];
	            // }
	            var middleX = (points[0].x + points[1].x) / 2;
	            var middleY = (points[0].y + points[1].y) / 2;
	            return [middleX, middleY];
	        } else if (this.options.style.lineType == Connector.TYPE_JAGGED) {
	
	            //find total distance
	            var distance = this.getLength();
	
	            //find between what turning points the half distance is
	            var index = -1;
	            var ellapsedDistance = 0;
	            for (var i = 0; i < this.turningPoints.length - 1; i++) {
	                index = i;
	                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);
	                if (ellapsedDistance + segment < distance / 2) {
	                    ellapsedDistance += segment;
	                } else {
	                    break;
	                }
	            }
	
	            //we have the middle distance somewhere between i(ndex) and i(ndex)+1
	            if (index != -1) {
	                var missingDistance = distance / 2 - ellapsedDistance;
	                if (Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3)) { //vertical segment (same x)
	                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];
	                } else if (Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3)) { //horizontal segment (same y)
	                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];
	                } else {
	                    console.error("Connector:middle() - this should never happen " + this.turningPoints[index] + " " + this.turningPoints[index + 1] + " nr of points " + this.turningPoints.length);
	                }
	
	            }
	        } else if (this.options.style.lineType == Connector.TYPE_CURVE) {
	            var t = 0.5;
	            var l = this.getLength();
	
	            var walked = 0;
	            for (var j = 0; j < this.turningPoints.length - 1; j++) {
	                if (walked + Util.distance(this.turningPoints[j], this.turningPoints[j + 1]) > l * t) {
	                    break;
	                }
	
	                walked += Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);
	            }
	
	            var rest = l * t - walked;
	            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);
	
	            //find the position/ration of the middle of Polyline on current segment
	            var segmentPercent = rest / currentSegmentLength;
	
	            var Xp = segmentPercent * (this.turningPoints[j + 1].x - this.turningPoints[j].x) + this.turningPoints[j].x;
	            var Yp = segmentPercent * (this.turningPoints[j + 1].y - this.turningPoints[j].y) + this.turningPoints[j].y;
	
	            return [Xp, Yp];
	
	        }
	
	        return null;
	    };
	
	    /**
	     * find total distance
	     * @return {Number} [description]
	     */
	    Connector.prototype.getLength = function() {
	        //find total distance
	        var distance = 0;
	        for (var i = 0; i < this.turningPoints.length - 1; i++) {
	            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);
	        }
	        return distance;
	    };
	
	    /**
	     * 转JSON对象 bpmn使用
	     * @return {[type]} [description]
	     */
	    Connector.prototype.toJSON = function() {
	
	        this.model.set("resourceId", this.resourceId);
	        this.model.set("properties.type", 14);
	
	        this.model.set("bounds.upperLeft.x", this.position[0]);
	        this.model.set("bounds.upperLeft.y", this.position[1]);
	        this.model.set("bounds.lowerRight.x", parseInt(this.position[0] + this.getBoundingRect().width));
	        this.model.set("bounds.lowerRight.y", parseInt(this.position[1] + this.getBoundingRect().height));
	        this.model.set("style.sPos", this.options.position.startPos);
	        this.model.set("style.ePos", this.options.position.endPos);
	        this.model.set("style.lineDash", this.options.style.lineDash);
	        this.model.set("style.stroke", this.options.style.stroke);
	        this.model.set("symbol.type", this.options.symbol.type);
	        this.model.set("dockers", this.turningPoints);
	        return this.model.option;
	    };
	
	    /**
	     * refreshModel  flow当序列化的时候调用 更新线段的位置 及线上的icons
	     * @return {[type]} [description]
	     */
	    Connector.prototype.refreshModel = function() {
	        this.model.set("options", zrUtil.clone(this.options));
	        this.model.set("options.dockers", this.turningPoints);
	        var icons = [];
	        for (var i = 0; i < this.icons.length; i++) {
	            var iconNode = this.icons[i];
	            var option = [iconNode.key, {
	                icon: iconNode.style.image,
	                width: iconNode.style.width,
	                height: iconNode.style.height
	            }];
	            icons.push(option);
	        }
	        this.model.set("icons", icons);
	    };
	
	    /**
	     * 调整曲线的形状
	     * @param  {array} points 点数组
	     * @return {void}
	     */
	    Connector.prototype.modifyCurve = function(points) {
	        var sol = this.getCurvePoint(points);
	
	        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段
	        var willDelCurves = [];
	        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve; j++) {
	            willDelCurves.push(this.groupCurve.childAt(j));
	        }
	        zrUtil.each(willDelCurves, function(curve) {
	            this.groupCurve.remove(curve);
	        }, this);
	        // 2. 遍历曲线   如果存在则直接设置形状，否则创建
	        for (var i = 0; i < sol.length; i++) {
	            var line = this.groupCurve.childAt(i);
	            if (line) {
	                line.attr('shape', sol[i]);
	            } else {
	                var cure = new graphic.BezierCurve({
	                   // position: this.options.position,
	                    style: this.options.style,
	                    shape: sol[i],
	                    z: this.options.z
	                });
	                this.groupCurve.add(cure);
	                this.createHoverStyle(cure);
	            }
	        }
	    };
	
	    /**
	     * @desc 获取点，这里可以设置点的个数
	     * @param {number} num 点个数
	     * @param {Array} p1 点坐标
	     * @param {Array} p2 点坐标
	     * @param {Array} p3 点坐标
	     * @param {Array} p4 点坐标
	     * 如果参数是 num, p1, p2 为一阶贝塞尔
	     * 如果参数是 num, p1, c1, p2 为二阶贝塞尔
	     * 如果参数是 num, p1, c1, c2, p2 为三阶贝塞尔
	     */
	    Connector.prototype.getBezierPoints = function(point, num) {
	        var points = [];
	        var func = null;
	        var start = point.start;
	        var cp1 = point.cp1;
	        var cp2 = point.cp2;
	        var end = point.end;
	        if (!num || num <= 50) {
	            num = 50;
	        }
	        if (!cp1 && !cp2) {
	            func = this.oneBezier;
	        } else if (cp1 && !cp2) {
	            func = this.twoBezier;
	        } else if (cp1 && cp2) {
	            func = this.threeBezier;
	        }
	        for (var i = 0; i < num; i++) {
	            points.push(func(i / num, start, cp1, cp2, end));
	        }
	        points.push(end);
	        return points;
	    };
	
	    /**
	     * @desc 一阶贝塞尔
	     * @param {number} t 当前百分比
	     * @param {Array} start 起点坐标
	     * @param {Array} end 终点坐标
	     */
	    Connector.prototype.oneBezier = function(t, start, cp1, cp2, end) {
	        var x1 = start.x1;
	        var y1 = start.y1;
	        var x2 = end.x2;
	        var y2 = end.y2;
	        return {
	            x: x1 + (x2 - x1) * t,
	            y: y1 + (y2 - y1) * t
	        }
	    };
	
	    /**
	     * @desc 二阶贝塞尔
	     * @param {number} t 当前百分比
	     * @param {Array} start 起点坐标
	     * @param {Array} end 终点坐标
	     * @param {Array} cp1 控制点
	     */
	    Connector.prototype.twoBezier = function(t, start, cp1, cp2, end) {
	        var x1 = start.x1;
	        var y1 = start.y1;
	        var x2 = end.x2;
	        var y2 = end.y2;
	        var cpx1 = cp1.cpx1;
	        var cpy1 = cp1.cpy1;
	        var x = (1 - t) * (1 - t) * x1 + 2 * t * (1 - t) * cpx1 + t * t * x2;
	        var y = (1 - t) * (1 - t) * y1 + 2 * t * (1 - t) * cpy1 + t * t * y2;
	        return {
	            x: x,
	            y: y
	        }
	    };
	
	    /**
	     * @desc 三阶贝塞尔
	     * @param {number} t 当前百分比
	     * @param {Array} start 起点坐标
	     * @param {Array} end 终点坐标
	     * @param {Array} cp1 控制点
	     * @param {Array} cp2 控制点
	     */
	    Connector.prototype.threeBezier = function(t, start, cp1, cp2, end) {
	        var x1 = start.x1;
	        var y1 = start.y1;
	        var x2 = end.x2;
	        var y2 = end.y2;
	        var cpx1 = cp1.cpx1;
	        var cpy1 = cp1.cpy1;
	        var cpx2 = cp2.cpx2;
	        var cpy2 = cp2.cpy2;
	        var x =
	            x1 * (1 - t) * (1 - t) * (1 - t) +
	            3 * cpx1 * t * (1 - t) * (1 - t) +
	            3 * cpx2 * t * t * (1 - t) +
	            x2 * t * t * t;
	        var y =
	            y1 * (1 - t) * (1 - t) * (1 - t) +
	            3 * cpy1 * t * (1 - t) * (1 - t) +
	            3 * cpy2 * t * t * (1 - t) +
	            y2 * t * t * t;
	        return {
	            x: x,
	            y: y
	        }
	    };
	
	    /**
	     * 获取曲线上的点轨迹
	     * @return {array}
	     */
	    Connector.prototype.getPointsFromCurve = function() {
	        var that = this;
	        var percent = 0;
	        var points = this.turningPoints;
	        var maxMinPoints = Util.getMaxLineLength(points);
	        var beizierPoints = [];
	        percent = parseInt(maxMinPoints[0].x - maxMinPoints[1].x);
	        if ((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {
	            var sols = this.transformCurvePoint(this.getCurvePoint(points));
	            if (sols.length > 0) {
	                sols.forEach(function(item) {
	                    beizierPoints.push(that.getBezierPoints(item, percent))
	                });
	            }
	        }
	        return beizierPoints;
	    }
	
	    /**
	     * 根据传入的点数组转换成需要的类型
	     * @param  {array} sol 点数组
	     * @return {object}
	     */
	    Connector.prototype.transformCurvePoint = function(sol) {
	        var points = [];
	        sol.forEach(function(point) {
	            var pointParam = {};
	            if (point.x1 && point.y1) {
	                pointParam.start = {
	                    x1: point.x1,
	                    y1: point.y1
	                }
	            }
	            if (point.cpx1 && point.cpy1) {
	                pointParam.cp1 = {
	                    cpx1: point.cpx1,
	                    cpy1: point.cpy1
	                }
	            }
	            if (point.cpx2 && point.cpy2) {
	                pointParam.cp2 = {
	                    cpx2: point.cpx2,
	                    cpy2: point.cpy2
	                }
	            }
	            if (point.x2 && point.y2) {
	                pointParam.end = {
	                    x2: point.x2,
	                    y2: point.y2
	                }
	            }
	            points.push(pointParam);
	        });
	        return points;
	    }
	
	    /**
	     * 根据传入的点数组计算曲线的点
	     * @param  {array} P 点数组
	     * @return {object}        曲线的点数组
	     */
	    Connector.prototype.getCurvePoint = function(P) {
	        var n = P.length;
	        var sol = [];
	        if (n === 3) {
	            sol.push({
	                x1: P[0].x,
	                y1: P[0].y,
	                cpx1: P[1].x,
	                cpy1: P[1].y,
	                x2: P[2].x,
	                y2: P[2].y
	            });
	            return sol;
	        } else if (n === 4) {
	            sol.push({
	                x1: P[0].x,
	                y1: P[0].y,
	                cpx1: P[1].x,
	                cpy1: P[1].y,
	                cpx2: P[2].x,
	                cpy2: P[2].y,
	                x2: P[3].x,
	                y2: P[3].y
	            });
	            return sol;
	        }
	
	
	        /**Computes the sum between two point
	         *@param p1 - {Point}
	         *@param p2 - {Point}
	         *@return {Point} the sum of initial points
	         **/
	        function sum(p1, p2) {
	            return new Point(p1.x + p2.x, p1.y + p2.y);
	        }
	
	
	        /**Computes the division of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function divide(p, nr) {
	            if (nr == 0) {
	                throw "Division by zero not allowed (yet :) " + this.callee;
	            }
	            return new Point(p.x / nr, p.y / nr);
	        }
	
	        /**Computes the multiplication of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function multiply(p, nr) {
	            return new Point(p.x * nr, p.y * nr);
	        }
	
	
	
	
	        /*
	         *I do not get why first 4 must be 0 and last 3 of same value.....
	         *but otherwise we will get division by zero
	         */
	        var k = [0, 0, 0];
	
	        var j;
	        for (j = 0; j <= n - 3; j++) {
	            k.push(j);
	        }
	
	        k.push(n - 3, n - 3);
	
	
	
	        for (var i = 1; i <= n - 3; i++) {
	            //q1 - compute start point
	            var q1 = divide(sum(multiply(P[i], k[i + 4] - k[i + 2]), multiply(P[i + 1], k[i + 2] - k[i + 1])), k[i + 4] - k[i + 1]);
	
	            //q0 - compute 1st controll point
	            var q_01 = (k[i + 3] - k[i + 2]) / (k[i + 3] - k[i + 1]);
	            var q_02 = divide(sum(multiply(P[i - 1], k[i + 3] - k[i + 2]), multiply(P[i], k[i + 2] - k[i])), k[i + 3] - k[i]);
	            var q_03 = multiply(q1, (k[i + 2] - k[i + 1]) / (k[i + 3] - k[i + 1]));
	            var q0 = sum(multiply(q_02, q_01), q_03);
	
	            //q2 - compute 2nd controll point
	            var q2 = divide(sum(multiply(P[i], k[i + 4] - k[i + 3]), multiply(P[i + 1], k[i + 3] - k[i + 1])), k[i + 4] - k[i + 1]);
	
	            //q3 - compute end point
	            var q_31 = (k[i + 3] - k[i + 2]) / (k[i + 4] - k[i + 2]);
	            var q_32 = divide(sum(multiply(P[i + 1], k[i + 5] - k[i + 3]), multiply(P[i + 2], k[i + 3] - k[i + 2])), k[i + 5] - k[i + 2]);
	            var q_33 = multiply(q2, (k[i + 4] - k[i + 3]) / (k[i + 4] - k[i + 2]));
	            var q3 = sum(multiply(q_32, q_31), q_33);
	
	            //store solution
	            //
	            sol.push({
	                x1: q0.x,
	                y1: q0.y,
	                cpx1: q1.x,
	                cpy1: q1.y,
	                cpx2: q2.x,
	                cpy2: q2.y,
	                x2: q3.x,
	                y2: q3.y
	            });
	        }
	
	        return sol;
	    };
	
	
	    Util.inherits(Connector, Node);
	
	    module.exports = Connector;
	
	


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// Symbol factory
	
	
	    var graphic = __webpack_require__(3);
	    var BoundingRect = __webpack_require__(26);
	    /**
	     * Triangle shape
	     * @inner
	     */
	    var Triangle = graphic.extendShape({
	        type: 'triangle',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy + height);
	            path.lineTo(cx - width, cy + height);
	            path.closePath();
	        }
	    });
	    /**
	     * Diamond shape
	     * @inner
	     */
	    var Diamond = graphic.extendShape({
	        type: 'diamond',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy);
	            path.lineTo(cx, cy + height);
	            path.lineTo(cx - width, cy);
	            path.closePath();
	        }
	    });
	
	    /**
	     * Pin shape
	     * @inner
	     */
	    var Pin = graphic.extendShape({
	        type: 'pin',
	        shape: {
	            // x, y on the cusp
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (path, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var w = shape.width / 5 * 3;
	            // Height must be larger than width
	            var h = Math.max(w, shape.height);
	            var r = w / 2;
	
	            // Dist on y with tangent point and circle center
	            var dy = r * r / (h - r);
	            var cy = y - h + r + dy;
	            var angle = Math.asin(dy / r);
	            // Dist on x with tangent point and circle center
	            var dx = Math.cos(angle) * r;
	
	            var tanX = Math.sin(angle);
	            var tanY = Math.cos(angle);
	
	            path.arc(
	                x, cy, r,
	                Math.PI - angle,
	                Math.PI * 2 + angle
	            );
	
	            var cpLen = r * 0.6;
	            var cpLen2 = r * 0.7;
	            path.bezierCurveTo(
	                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,
	                x, y - cpLen2,
	                x, y
	            );
	            path.bezierCurveTo(
	                x, y - cpLen2,
	                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,
	                x - dx, cy + dy
	            );
	            path.closePath();
	        }
	    });
	
	    /**
	     * Arrow shape
	     * @inner
	     */
	    var Arrow = graphic.extendShape({
	
	        type: 'arrow',
	
	        shape: {
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var height = shape.height;
	            var width = shape.width;
	            var x = shape.x;
	            var y = shape.y;
	            var dx = width / 3 * 2;
	            ctx.moveTo(x, y);
	            ctx.lineTo(x + dx, y + height);
	            ctx.lineTo(x, y + height / 4 * 3);
	            ctx.lineTo(x - dx, y + height);
	            ctx.lineTo(x, y);
	            ctx.closePath();
	        }
	    });
	
	    /**
	     * Map of path contructors
	     * @type {Object.<string, module:zrender/graphic/Path>}
	     */
	    var symbolCtors = {
	        line: graphic.Line,
	
	        rect: graphic.Rect,
	
	        roundRect: graphic.Rect,
	
	        square: graphic.Rect,
	
	        circle: graphic.Circle,
	
	        diamond: Diamond,
	
	        pin: Pin,
	
	        arrow: Arrow,
	
	        triangle: Triangle
	    };
	
	    var symbolShapeMakers = {
	
	        line: function (x, y, w, h, shape) {
	            // FIXME
	            shape.x1 = x;
	            shape.y1 = y + h / 2;
	            shape.x2 = x + w;
	            shape.y2 = y + h / 2;
	        },
	
	        rect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        roundRect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	            shape.r = Math.min(w, h) / 4;
	        },
	
	        square: function (x, y, w, h, shape) {
	            var size = Math.min(w, h);
	            shape.x = x;
	            shape.y = y;
	            shape.width = size;
	            shape.height = size;
	        },
	
	        circle: function (x, y, w, h, shape) {
	            // Put circle in the center of square
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.r = Math.min(w, h) / 2;
	        },
	
	        diamond: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        pin: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        arrow: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        triangle: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        }
	    };
	
	    var symbolBuildProxies = {};
	    for (var name in symbolCtors) {
	        symbolBuildProxies[name] = new symbolCtors[name]();
	    }
	
	    var Symbol = graphic.extendShape({
	
	        type: 'symbol',
	
	        shape: {
	            symbolType: '',
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        beforeBrush: function () {
	            var style = this.style;
	            var shape = this.shape;
	            // FIXME
	            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
	                style.textPosition = ['50%', '40%'];
	                style.textAlign = 'center';
	                style.textVerticalAlign = 'middle';
	            }
	        },
	
	        buildPath: function (ctx, shape) {
	            var symbolType = shape.symbolType;
	            var proxySymbol = symbolBuildProxies[symbolType];
	            if (shape.symbolType !== 'none') {
	                if (!proxySymbol) {
	                    // Default rect
	                    symbolType = 'rect';
	                    proxySymbol = symbolBuildProxies[symbolType];
	                }
	                symbolShapeMakers[symbolType](
	                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape
	                );
	                proxySymbol.buildPath(ctx, proxySymbol.shape);
	            }
	        }
	    });
	
	    // Provide setColor helper method to avoid determine if set the fill or stroke outside
	    var symbolPathSetColor = function (color) {
	        if (this.type !== 'image') {
	            var symbolStyle = this.style;
	            var symbolShape = this.shape;
	            if (symbolShape && symbolShape.symbolType === 'line') {
	                symbolStyle.stroke = color;
	            }
	            else if (this.__isEmptyBrush) {
	                symbolStyle.stroke = color;
	                symbolStyle.fill = '#fff';
	            }
	            else {
	                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
	                symbolStyle.fill && (symbolStyle.fill = color);
	                symbolStyle.stroke && (symbolStyle.stroke = color);
	            }
	            this.dirty();
	        }
	    };
	
	    var symbolUtil = {
	        /**
	         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
	         * @param {string} symbolType
	         * @param {number} x
	         * @param {number} y
	         * @param {number} w
	         * @param {number} h
	         * @param {number} z
	         * @param {string} color
	         */
	        createSymbol: function (symbolType, x, y, w, h, z, color) {
	            var isEmpty = symbolType.indexOf('empty') === 0;
	            if (isEmpty) {
	                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
	            }
	            var symbolPath;
	
	            if (symbolType.indexOf('image://') === 0) {
	                symbolPath = new graphic.Image({
	                    style: {
	                        image: symbolType.slice(8),
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	            else if (symbolType.indexOf('path://') === 0) {
	                symbolPath = graphic.makePath(symbolType.slice(7), {z: z, rectHover: true}, new BoundingRect(x, y, w, h));
	            }
	            else {
	                symbolPath = new Symbol({
	                    shape: {
	                        symbolType: symbolType,
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	
	            symbolPath.__isEmptyBrush = isEmpty;
	
	            symbolPath.setColor = symbolPathSetColor;
	
	            symbolPath.setColor(color);
	
	            return symbolPath;
	        }
	    };
	
	    module.exports = symbolUtil;
	


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 画句柄
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(3);
	    var Util = __webpack_require__(77);
	    function Handle(type, x, y, connector){
	        this.type = type;
	
	        this.x = x;
	
	        this.y = y;
	
	        this.visible = true;
	
	        this.connector = connector;
	
	        this.handleShape = new graphic.Circle({
	            shape: {
	                cx: x,
	                cy: y,
	                r: Handle.RADIUS
	            },
	
	            style: {
	                fill: "rgb(0,255,0)",
	                stroke:"rgb(0,0,0)"
	            },
	            zlevel : connector.options.z + 2,  //节点Z为1 线段为0;
	            draggable:true
	        });
	
	        var that = this;
	        this.handleShape.on("drag", function(e) {
	            that.actionConnector(e.offsetX,e.offsetY);
	        });
	       // return this.circle;
	    }
	
	    Handle.RADIUS = 4;
	
	    Handle.prototype = {
	
	        constructor : Handle,
	
	        equals : function(anotherHandle){
	            if(!anotherHandle instanceof Handle){
	                return false;
	            }
	
	            return this.type == anotherHandle.type
	            && this.x == anotherHandle.x
	            && this.y == anotherHandle.y
	            && this.visible == anotherHandle.visible;
	        },
	        update: function (x, y) {
	            this.handleShape.attr('position', [0, 0]);
	            this.x = x;
	            this.y = y;
	            this.handleShape.setShape({
	                cx: x,
	                cy: y
	            });
	        },
	
	        /**
	         * 移动句柄
	         * @param  {[type]} newX [description]
	         * @param  {[type]} newY [description]
	         * @return {[type]}      [description]
	         */
	        actionConnector: function(newX, newY){
	            switch(this.type){
	                case 'v':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if (this.associatedPoint && this.connector.turningPoints[i].x == this.associatedPoint.x && this.connector.turningPoints[i].y == this.associatedPoint.y) {
	                            index = i;
	                            break;
	                        }
	                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y
	                            && this.connector.turningPoints[i].y == this.y
	                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x
	                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)
	                        {
	                            index = i;
	                        }
	                    }
	                    var deltaY = newY - this.y;
	                    var translationMatrix = Util.translationMatrix(0, deltaY);
	
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	
	                    break;
	
	                case 'h':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if (this.associatedPoint && this.connector.turningPoints[i].x == this.associatedPoint.x && this.connector.turningPoints[i].y == this.associatedPoint.y) {
	                            index = i;
	                            break;
	                        }
	                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x
	                            && this.connector.turningPoints[i].x == this.x
	                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y
	                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)
	                            {
	                            index = i;
	                        }
	                    }
	                    var deltaX = newX-this.x;
	                    var translationMatrix = Util.translationMatrix(deltaX, 0);
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	
	                    break;
	            }
	           //. this.shape.updateMiddleText();
	        }
	    };
	    module.exports = Handle;
	
	
	


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连线动态效果
	 * @author miao.cunzhi
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var vec2 = __webpack_require__(14);
	    var curveUtil = __webpack_require__(30);
	    var symbolUtil = __webpack_require__(106);
	
	    function EffectLine(symbol, options, groupCurve, polyLine) {
	        this._lastFrame = 0;
	        this._lastFramePercent = 0;
	        this.symbol = symbol;
	        this.groupCurve = groupCurve;
	        this.initSymbol(options, polyLine);
	    }
	    var EffectLineProto = EffectLine.prototype;
	
	    EffectLineProto.initSymbol = function(options, polyLine) {
	        var that = this;
	        this.symbol.z2 = 100;
	        this.symbol.culling = true;
	        var period = options.effect.period * 1000;
	        this.symbol.__t = 0;
	        this.symbol.stopAnimation();
	        if ((options.style.lineType == "curve")) {
	            if (this.groupCurve) {
	                var i = 0;
	                period = period / this.groupCurve._children.length;
	                this.groupCurveAnimate(this.groupCurve._children[0], i, period);
	            }
	
	        } else {
	            this.symbol.animate('', true)
	                .when(period, {
	                    __t: 1
	                })
	                .delay(0)
	                .during(function() {
	                    that.updateSymbolPositionPolyline();
	                })
	                .start();
	            this.setAnimationPointsPolyline(polyLine.shape.points);
	        }
	
	    };
	
	    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {
	        var that = this;
	        if (curveLine == undefined) {
	            curveLine = this.groupCurve._children[0];
	            i = 0;
	        }
	        var points;
	        var pos = curveLine.shape;
	        points = [
	            [pos.x1, pos.y1],
	            [pos.x2, pos.y2],
	            [pos.cpx1, pos.cpy1],
	            [pos.cpx2, pos.cpy2]
	        ];
	        this.setAnimationPointsBezierCurve(points);
	        this.symbol.animate('')
	            .when(period, {
	                __t: 1
	            })
	            .delay(0)
	            .during(function() {
	                that.updateSymbolPositionBezierCurve();
	            })
	            .done(function() {
	                that.symbol.__t = 0;
	                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);
	            })
	            .start();
	
	    };
	
	
	    EffectLineProto.setAnimationPointsBezierCurve = function(points) {
	        this.symbol.__p1 = points[0];
	        this.symbol.__p2 = points[1];
	        this.symbol.__cp1 = points[2] || [
	            (points[0][0] + points[1][0]) / 2,
	            (points[0][1] + points[1][1]) / 2
	        ];
	        this.symbol.__cp2 = points[3];
	    };
	
	    EffectLineProto.updateSymbolPositionBezierCurve = function() {
	        var p1 = this.symbol.__p1;
	        var p2 = this.symbol.__p2;
	        var cp1 = this.symbol.__cp1;
	        var cp2 = this.symbol.__cp2;
	        var t = this.symbol.__t;
	        var pos = this.symbol.position;
	        var tx, ty;
	        if (cp2[0] != undefined) {
	            var cubicAt = curveUtil.cubicAt;
	            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;
	            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);
	            // Tangent
	            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);
	        } else {
	            var quadraticAt = curveUtil.quadraticAt;
	            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;
	            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);
	            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);
	            // Tangent
	            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);
	            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
	        }
	        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
	
	        this.symbol.ignore = false;
	    };
	
	    EffectLineProto.setAnimationPointsPolyline = function(points) {
	        this._points = points;
	        var accLenArr = [0];
	        var len = 0;
	        for (var i = 1; i < points.length; i++) {
	            var p1 = points[i - 1];
	            var p2 = points[i];
	            len += vec2.dist(p1, p2);
	            accLenArr.push(len);
	        }
	        if (len === 0) {
	            return;
	        }
	
	        for (var j = 0; j < accLenArr.length; j++) {
	            accLenArr[j] /= len;
	        }
	        this._offsets = accLenArr;
	        this._length = len;
	        this.symbol._lastFrame = 0;
	        this.symbol.__lastFramePercent = 0;
	    };
	
	    EffectLineProto.updateSymbolPositionPolyline = function() {
	        var t = this.symbol.__t;
	        var points = this._points;
	        var offsets = this._offsets;
	        var len = points.length;
	
	        if (!offsets) {
	            // Has length 0
	            return;
	        }
	
	        var lastFrame = this._lastFrame;
	        var frame;
	
	        if (t < this._lastFramePercent) {
	            // Start from the next frame
	            // PENDING start from lastFrame ?
	            var start = Math.min(lastFrame + 1, len - 1);
	            for (frame = start; frame >= 0; frame--) {
	                if (offsets[frame] <= t) {
	                    break;
	                }
	            }
	            // PENDING really need to do this ?
	            frame = Math.min(frame, len - 2);
	        } else {
	            for (var frame = lastFrame; frame < len; frame++) {
	                if (offsets[frame] > t) {
	                    break;
	                }
	            }
	            frame = Math.min(frame - 1, len - 2);
	        }
	        vec2.lerp(
	            this.symbol.position, points[frame], points[frame + 1],
	            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])
	        );
	
	        this._lastFrame = frame;
	        this._lastFramePercent = t;
	        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);
	        this.symbol.rotation = angle - Math.PI / 2;
	        this.symbol.ignore = false;
	    };
	    module.exports = EffectLine;
	


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 控制点
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(3);
	    function ConnectionPoint(connector, point, type, options){
	        this.connector = connector;
	
	        this.point = point.clone();
	
	        this.type = type;
	
	        this.color = ConnectionPoint.NORMAL_COLOR;
	
	        this.oType = 'ConnectionPoint';
	
	        this.shape = new graphic.Circle({
	            shape: {
	                cx: this.point.x,
	                cy: this.point.y,
	                r: ConnectionPoint.RADIUS
	            },
	
	            style: {
	                fill: this.color,
	                stroke:'#000000'
	            },
	            z : options.z + 2  //节点Z为1 线段为0;
	        });
	        this.shape.type =  this.type;
	
	        this.shape.connector = connector;
	        //return this.circle;
	    }
	
	    ConnectionPoint.NORMAL_COLOR = "#FFFF33"; //yellow.
	
	    ConnectionPoint.OVER_COLOR = "#FF9900"; //orange
	
	    ConnectionPoint.CONNECTED_COLOR = "#ff0000"; //red
	
	    ConnectionPoint.RADIUS = 4;
	
	    ConnectionPoint.TYPE_FIGURE = 'figure';
	
	    ConnectionPoint.TYPE_CONNECTOR = 'connector';
	
	    ConnectionPoint.prototype = {
	
	        constructor : ConnectionPoint,
	
	        equals : function(anotherConnectionPoint){
	            return this.point.equals(anotherConnectionPoint.point)
	            && this.connector == anotherConnectionPoint.connector
	            && this.type == anotherConnectionPoint.type
	            && this.color == anotherConnectionPoint.color
	            && this.radius == anotherConnectionPoint.radius;
	        }
	
	
	    };
	    module.exports = ConnectionPoint;
	
	
	


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 组， 组中元素的坐标都是相对于这个组的<br>
	 * @class fishTopoFlow.node.GroupNode
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var group1 = new node.Group({
	 *           position:[60,50]
	 *       });
	 *
	 *       var rect1 = new node.Rect({
	 *           shape:{width:120,height:30},
	 *           style:{text:"标题", fill:"#FFB90F",stroke:"#bbbbbb"},
	 *           position:[0,0],
	 *           selectable:false
	 *       });
	 *
	 *       var rect2 = new node.Rect({
	 *           shape:{width:120,height:60},
	 *           style:{text:"内容", fill:"#FFFFFF",stroke:"#bbbbbb"},
	 *           position:[0,30],
	 *           selectable:false
	 *       });
	 *
	 *       group1.add(rect1);
	 *       group1.add(rect2);
	 *       fishTopo.add(group1);
	 */
	
	
	    var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(26);
	    var graphic = __webpack_require__(3);
	    var util = __webpack_require__(77);
	    var Model = __webpack_require__(83);
	    var Connector = __webpack_require__(105);
	
	    function GroupNode(opts) {
	        var model = new Model({});
			if (!opts.id) {
				opts.id = util.getUUID();
	        }
	        if (opts.style && opts.style.textLineHeight !== 0 && !opts.style.rich) { //#170
	            opts.style.rich = {};
	        }
	        model.set("elementType", "GroupNode");
	        if (opts.style && opts.style.host) {
	            delete opts.style.host;
	        }
	        model.set("options", zrUtil.clone(opts));
	        if ("draggable" in opts) {
	            opts.isdraggable = opts.draggable;
	            delete opts.draggable;
	        }
	        if (!opts.z) {
	            opts.z = 1; //节点默认为1，线段0;
	        }
	
	        if (util.isUndefined(opts.hoverAnimation)) {
	            opts.hoverAnimation = false;
	        }
	
	        if (util.isUndefined(opts.selectable)) {
	            opts.selectable = true;  //默认可以选中
	        }
	        this.model = model;
	        graphic.Group.call(this, opts);
	
	        var defaultOptions = {
	            shape: {
	                width: 5,
	                height: 5,
	                r: 5
	            },
	            style: {
	                fill: 'rgba(0,0,0,0)',//'#f9f9f9',
	                stroke: 'rgba(0,0,0,0)'//'#bbbbbb'
	            },
	            position: [0, 0]
	        };
	        this.options = zrUtil.merge(defaultOptions, opts, true);
	        this.render(this.options);
	    }
	    GroupNode.RECT_NAME = "GROUP_RECT_NAME";
	    GroupNode.prototype = {
	        constructor: GroupNode,
	        type: "GroupNode",
	        render: function (model) {
	            var rect = new graphic.Rect({
	                shape: model.shape,
	                style: model.style,
	                //silent:true, //加上后 拖动 组中没有子元素的地方 无法手动了
	                z: 3
	            });
	            rect.name = GroupNode.RECT_NAME;
	            this.add(rect);
	            this.position = model.position;
	        },
	        rectContain: function (x, y) {
	            var rect = util.getRect(this);
	            return rect.boundingRect.contain(x, y);
	        },
	
	        add: function(child) {
	            if (child && child !== this && child.parent !== this) {
	                this._children.push(child);
	                this._doAdd(child);
	            }
	            this._api && this._api._addGroupNode(this,child);
	            return this;
	
	        },
	
	        /**
	         * 遍历组中每一个子节点
	         * @param  {Function} cb 回调函数cb
	         * @param  {Object} context   上下文context
	         */
	        each: function (cb, context) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                if (child.name != GroupNode.RECT_NAME) {
	                    cb.call(context, child, i);
	                }
	            }
	            return this;
	        },
	
	        getRect: function () {
	            var rect = this.getBoundingRect();
	            var boundingRect = zrUtil.clone(rect);
	            // 取整
	            boundingRect.x = parseInt(boundingRect.x, 10);
	            boundingRect.y = parseInt(boundingRect.y, 10);
	            boundingRect.width = parseInt(boundingRect.width, 10);
	            boundingRect.height = parseInt(boundingRect.height, 10);
	            //创建最小包围盒虚线
	            var points = [];
	            points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];
	            points[1] = [boundingRect.width / 2, -boundingRect.height / 2];
	            points[2] = [boundingRect.width / 2, boundingRect.height / 2];
	            points[3] = [-boundingRect.width / 2, boundingRect.height / 2];
	            points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];
	
	            var boundRect = new BoundingRect(this.position[0],
	                this.position[1],
	                boundingRect.width, boundingRect.height);
	            return {
	                x: this.position[0] + boundingRect.width / 2,
	                y: this.position[1] + boundingRect.height / 2,
	                width: boundingRect.width,
	                height: boundingRect.height,
	                points: points,
	                boundingRect: boundRect
	            };
	        },
	
	        setPosition: function(pX,pY) {
	            var boundingRect = this.getBoundingRect();
	            this.attr('position',[pX-boundingRect.width/2,pY-boundingRect.height/2]);
	
	        },
	
	        setProperties: function (opt) {
	            var rect = this.childOfName(GroupNode.RECT_NAME);
	            rect.setShape(opt.shape);
	            this.attr('position', opt.position);
	        },
	        updateShape: function (ratio, ifParse) {
	            var scaleRatio = Number(ratio);
	            var shape = this.options.shape;
	            var newW = Number(shape.width * scaleRatio);
	            var newH = Number(newW * shape.height / shape.width);
	            if (ifParse) {
	                newW = parseInt(newW, 10);
	                newH = parseInt(newH, 10);
	            }
	            // 按比例缩放
	            this.setProperties({
	                shape: {
	                    width: newW,
	                    height: newH
	                }
	            });
	            // 更新组内节点
	            this.children().forEach(function(v) {
	                var position = v.position;
	                if (v.name !== GroupNode.RECT_NAME && !(v instanceof Connector) && v.type !== 'ZPath') {
	                    // 每个节点的position更新
	                    v.updateShape(ratio, ifParse);
	                    v.attr('position', [position[0] * scaleRatio, position[1] * scaleRatio]);
	                } else {
	                    var rect = v.rect;
	                    rect.height = rect.height * scaleRatio;
	                    rect.width = rect.width * scaleRatio;
	                    v.attr({
	                        position: [position[0] * scaleRatio, position[1] * scaleRatio],
	                        rect: rect
	                    });
	                }
	            });
	        }
	    }
	
	    zrUtil.inherits(GroupNode, graphic.Group);
	    module.exports = GroupNode;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 选中节点后，出现的操作框及按钮
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var Bpmn = __webpack_require__(104);
	    var BpmnUtil = __webpack_require__(76);
	    var OperationNode = __webpack_require__(112);
	    var Util = __webpack_require__(77);
	
	    function BpmnOperationNode(node, zr, forbidEdit) {
	        OperationNode.call(this, node, zr, forbidEdit);
	    }
	
	    BpmnOperationNode.prototype.refreshPositionOther = function(node,nodeRect) {
	
	        // 计算整个的位置
	        if (node.parent) {
	            if (Bpmn.isSubProcess(node.parent)) {
	                this.attr("position", [nodeRect.x + BpmnUtil.parentX(node.parent), nodeRect.y + BpmnUtil.parentY(node.parent)])
	            }
	        } else {
	            this.attr("position", [nodeRect.x, nodeRect.y])
	        }
	
	    };
	
	    BpmnOperationNode.prototype.refreshPostion = function(node, nodeRect) {
	        if (node.parent && Bpmn.isSubProcess(node.parent)) {
	            nodeRect.x -= BpmnUtil.parentX(node.parent);
	            nodeRect.y -= BpmnUtil.parentY(node.parent);
	            nodeRect.boundingRect.x = nodeRect.boundingRect.x - BpmnUtil.parentX(node.parent);
	            nodeRect.boundingRect.y = nodeRect.boundingRect.y - BpmnUtil.parentY(node.parent);
	        }
	        var i = 0;
	        var rbPoint = zrUtil.clone(nodeRect.points[2]); //取右下角坐标
	        var rotation = nodeRect.rotation || node.rotation;
	        var angle = rotation / (Math.PI/180);
	        if (Math.abs(rotation) > 0) {
	            var connectorControls = Util.getConnectorControls(nodeRect, node);
	            var brControl = connectorControls.br;
	            rbPoint = [brControl.x - nodeRect.x,  brControl.y - nodeRect.y];
	        }
	        //1.定位虚框
	        if (this.virtualRect) {
	            this.virtualRect.setShape({ points: nodeRect.points });
	            this.virtualRect.attr('rotation', rotation);
	        }
	        //2.定位每个小图标
	        this.eachChild(function(nodeItem) {
	            if (!nodeItem.isSelfComputePos) {
	                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离
	                nodeItem.attr("position", [angle >= 0 ? rbPoint[0] + 8 + (i++ * 20) : rbPoint[0] - 20 - (i++ * 20), rbPoint[1] - 10]);
	            }
	        });
	
	        this.refreshPositionOther(node,nodeRect);
	    };
	
	    BpmnOperationNode.ARROW_DRAGEND = "OperationNode:dragendArrow";
	    BpmnOperationNode.ARROW_DRAG = "OperationNode:dragArrow";
	    BpmnOperationNode.ARROW_DRAGSTART = "OperationNode:dragstartArrow";
	    BpmnOperationNode.DELETE_CLICK = "OperationNode:deleteClick";
	
	    zrUtil.inherits(BpmnOperationNode, OperationNode);
	
	
	    module.exports = BpmnOperationNode;
	


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 选中节点后，出现的操作框及按钮
	 * @author wang.xiaohu
	 */
	
	    var Node = __webpack_require__(80);
	    var zrUtil = __webpack_require__(4);
	    var Util = __webpack_require__(77);
	    var graphic = __webpack_require__(3);
	    var Connector = __webpack_require__(105);
	    var env = __webpack_require__(49);
	    var icon = __webpack_require__(113);
	    var symbolUtil = __webpack_require__(106);
	    function OperationNode(node, zr, api,forbidEdit) {
	        Node.call(this);
	        this.node = node;
	        this.zr = zr;
	        this.forbidEdit = forbidEdit;
	        this._api = api;
	        this.render();
	    }
	
	    //事件
	    OperationNode.ARROW_DRAGEND = "OperationNode:dragendArrow";
	    OperationNode.ARROW_DRAG = "OperationNode:dragArrow";
	    OperationNode.ARROW_DRAGSTART = "OperationNode:dragstartArrow";
	    OperationNode.DELETE_CLICK = "OperationNode:deleteClick";
	    OperationNode.DEL = "DEL";
	    OperationNode.COMMENT_CLICK = "OperationNode:commentClick";
	    OperationNode.COMMENT = "COMMENT";
	        //内置操作图标的图像
	    OperationNode.opicons = {
	        STRAIGHT: icon.STRAIGHT_SVG,
	        JAGGED: icon.JAGGED_SVG,
	        CURVE: icon.CURVE_SVG,
	        DEL: icon.DEL_SVG,
	        COMMENT: icon.COMMENT_SVG
	    };
	
	    OperationNode.prototype.render = function() {
	        this.renderBase();
	        if (!this.forbidEdit) {
	            this.renderOther();
	        }
	    };
	
	    OperationNode.prototype.renderBase = function() {
	        this.createOperation();
	    };
	
	    OperationNode.prototype.createOperation = function() {
	        var me = this;
	        var ifShowNodeOperationIcons = this.node.operationIcons;
	        if (this.node.parent && this.node.parent.type === 'dragSelect') {
	            ifShowNodeOperationIcons = false;
	        }
	        if (!this.node.selectStyle) {
	            this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });
	            this.virtualRect.isSelfComputePos = true;  // 自己计算位置
	            this.add(this.virtualRect);
	        } else {
	             if (this.node.type === 'ZPath') {  //addHover需要从它自身的构造函数中创建。1.Painter中addHover源码是根据shape与style创建 2.path中的构造函数是返回另一个元素
	                this.node._zCloneStyle = this.node.style.clone();
	                 this.node.setStyle(this.node.selectStyle);
	             } else if(this.node.setOrCancelSelectStyle) {
	                this.node.setOrCancelSelectStyle(true);
	             } else {
	                this._api.getZr().addHover(this.node, this.node.selectStyle);
	             }
	
	        }
	
	        if (ifShowNodeOperationIcons) {
	            zrUtil.each(this.node.operationIcons, function(item) {
	                //检查是否是内置图标
	                var opIconInstance = null;
	                var operationIcon = OperationNode.opicons[item.name.toUpperCase() + ""]
	                if (operationIcon) {
	
	                    if (this.forbidEdit) {
	                        return;
	                    }
	                    if (item.hidden) {
	                        return;
	                    }
	                    if (item.name == OperationNode.DEL) {
	                        //垃圾桶
	                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },z:me.node.z+1,rectHover: true }, { x: 0, y: 0, width: 10, height: 15 });
	
	                        if(item.callback){
	                            opIconInstance.on("click", function(e) {
	                                e.data = item;
	                                e.node = me.node;  // 将所附的节点也传递出去
	                                if (item.callback) {
	                                    item.callback(e);
	                                }
	                            });
	                        }else{
	                            opIconInstance.on("click", function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.target = this;
	                                params.type = OperationNode.DELETE_CLICK;
	                                me.trigger(params.type, params);
	                            });
	                        }
	                    } else if (item.name == OperationNode.COMMENT) {
	                        var rect = { x: 0, y: 0, width: 16, height: 16 };
	                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' }, z:me.node.z+2, rectHover: true }, rect);
	                        opIconInstance.on("click", function(e) {
	                            var params = {};
	                            params.event = e;
	                            params.target = this;
	                            params.type = OperationNode.COMMENT_CLICK;
	                            me.trigger(params.type, params);
	                        });
	                    } else {
	                        var rectOther = { x: 0, y: 0, width: 15, height: 15 };
	                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#aaaaac' },draggable:true,z:me.node.z+2,lineType: Connector["TYPE_" + item.name.toUpperCase()],rectHover: true }, rectOther);
	                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	                            opIconInstance.on(eveName, function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.data = item.options
	                                params.type = "OperationNode:" + eveName + "Arrow";
	                                me.trigger(params.type, params);
	                            });
	                        });
	                    }
	
	                } else {
	                    opIconInstance = symbolUtil.createSymbol(item.iconPath, 0, 0, item.width || 15, item.height || 15, me.node.z+1, item.color||'#000');
	                    opIconInstance.on("click", function(e) {
	                        e.data = item;
	                        e.node = me.node;  // 将所附的节点也传递出去
	                        if (item.callback) {
	                            item.callback(e);
	                        }
	                        var param = {event:e, type:"OperationNode:" + item.name + "Click"};
	                        me._api.trigger(param.type, param);
	                    });
	                }
	                opIconInstance.name = item.name;
	                me.add(opIconInstance);
	            });
	        }
	    };
	
	    OperationNode.prototype.refreshPostion = function(node, nodeRect) {
	        var i = 0;
	        var rbPoint = zrUtil.clone(nodeRect.points[2]); //取右下角坐标
	        var rotation = node.rotation;
	        var angle = rotation / (Math.PI/180);
	        if (Math.abs(rotation) > 0) {
	            var connectorControls = Util.getConnectorControls(nodeRect, node);
	            var brControl = connectorControls.br;
	            rbPoint = [brControl.x - nodeRect.x,  brControl.y - nodeRect.y];
	        }
	        //1.定位虚框
	        if (this.virtualRect) {
	            this.virtualRect.setShape({ points: nodeRect.points });
	            if (node.parent && node.parent.childDraggable) {
	                this.virtualRect.attr('z', node.parent.z + 1)
	            }
	            this.virtualRect.attr('rotation', rotation);
	        }
	        //2.定位每个小图标
	        this.eachChild(function(nodeItem) {
	            if (!nodeItem.isSelfComputePos) {
	                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离
	                nodeItem.attr("position", [angle >= 0 ? rbPoint[0] + 8 + (i++ * 20) : rbPoint[0] - 20 - (i++ * 20), rbPoint[1] - 10]);
	            }
	        });
	
	        this.refreshPositionOther(node,nodeRect);
	    };
	
	    OperationNode.prototype.renderOther = function() {
	        //留给扩展使用
	    };
	    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {
	        //留给扩展使用
	        //3.定位整个operationNode
	        if ((node.parent && node.parent.isBg && node.parent.isBg == true) || (node.parent.type === "GroupNode")) {
	            this.attr("position", [nodeRect.x, nodeRect.y])
	        } else {
	            var nodeShapeX = node.shape? node.shape.x:0;
	            var nodeSahpeY = node.shape? node.shape.y:0;
	            this.attr("position", [nodeRect.x + node.parent.position[0]+nodeShapeX, nodeRect.y + node.parent.position[1]+nodeSahpeY])
	        }
	    };
	
	    OperationNode.prototype.cleanup = function() {
	        if(this.node.selectStyle) {
	            if (this.node.type === 'ZPath') {
	                this.node.setStyle(this.node._zCloneStyle);
	            } else if(this.node.setOrCancelSelectStyle) {
	                this.node.setOrCancelSelectStyle(false);
	             } else {
	                this._api.getZr().removeHover(this.node);
	            }
	
	        }
	    };
	
	    zrUtil.inherits(OperationNode, Node);
	    module.exports = OperationNode;
	


/***/ }),
/* 113 */
/***/ (function(module, exports) {

	/**
	 * 操作图标类
	 * @author wang.xiaohu
	 */
	
	
	    var IconOperation = {
	        STRAIGHT_SVG: 'M937.353846 724.676923C882.215385 669.538462 795.569231 661.661538 732.553846 701.046154L362.338462 330.830769C401.723077 267.815385 393.846154 181.169231 338.707692 126.030769 267.815385 55.138462 165.415385 55.138462 94.523077 126.030769 23.630769 196.923077 23.630769 299.323077 94.523077 370.215385 149.661538 425.353846 236.307692 433.230769 299.323077 393.846154L669.538462 764.061538C630.153846 827.076923 638.030769 913.723077 693.169231 968.861538 764.061538 1039.753846 866.461538 1039.753846 937.353846 968.861538 1000.369231 897.969231 1000.369231 795.569231 937.353846 724.676923L937.353846 724.676923ZM275.692308 307.2C244.184615 338.707692 189.046154 338.707692 157.538462 307.2 126.030769 275.692308 126.030769 220.553846 157.538462 189.046154 189.046154 157.538462 244.184615 157.538462 275.692308 189.046154 307.2 220.553846 307.2 267.815385 275.692308 307.2L275.692308 307.2ZM874.338462 913.723077C842.830769 945.230769 787.692308 945.230769 756.184615 913.723077 724.676923 882.215385 724.676923 827.076923 756.184615 795.569231 787.692308 764.061538 842.830769 764.061538 874.338462 795.569231 905.846154 827.076923 905.846154 874.338462 874.338462 913.723077L874.338462 913.723077Z',
	        JAGGED_SVG: 'M204.8 819.2l-51.2-102.4 204.8-307.2 51.2 102.4-204.8 307.2zM409.6 512l51.2-102.4 153.6 204.8-51.2 102.4-153.6-204.8zM819.2 204.8l51.2 102.4-204.8 409.6-51.2-102.4 204.8-409.6z                                    M153.6 716.8c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H102.4v-102.4h102.4v102.4zM409.6 204.8C322.56 204.8 256 271.36 256 358.4s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8H358.4V307.2h102.4v102.4zM614.4 614.4c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4v-102.4h102.4v102.4zM870.4 0c-87.04 0-153.6 66.56-153.6 153.6s66.56 153.6 153.6 153.6 153.6-66.56 153.6-153.6-66.56-153.6-153.6-153.6z m51.2 204.8h-102.4V102.4h102.4v102.4z',
	        CURVE_SVG: 'M1014.285039 824.024234l-145.168428-144.37205c-12.969593-12.855825-37.543559-14.505466-44.597197 2.332252-1.877178 4.550734-2.275367 17.179022-2.275368 17.179022v97.556369H330.935383a118.319095 118.319095 0 0 1-118.546632-117.920905A118.319095 118.319095 0 0 1 330.992267 560.878016h445.516899c121.561493 0 220.426198-98.352747 220.426198-219.23163s-98.864705-219.174746-220.426198-219.174746H340.491925A174.236244 174.236244 0 0 0 174.105698 0 173.78117 173.78117 0 0 0 0.040107 173.09856a173.78117 173.78117 0 0 0 174.065591 173.09856 174.236244 174.236244 0 0 0 166.386227-122.471639h436.017241c65.416807 0 118.603516 52.902288 118.603515 117.920905A118.319095 118.319095 0 0 1 776.509166 459.624176H330.992267c-121.504609 0-220.369314 98.352747-220.369314 219.23163s98.864705 219.174746 220.369314 219.174746h491.194895v92.550561s0 14.221045 2.332252 19.795695c7.053638 16.894602 31.627604 17.577212 44.597197 4.664502l145.111543-144.315165a32.879056 32.879056 0 0 0 0-46.645027zM174.105698 244.94328c-39.818926 0-72.242909-32.25333-72.242909-71.84472s32.423983-71.787835 72.242909-71.787835c39.818926 0 72.186025 32.196446 72.186025 71.787835 0 39.591389-32.423983 71.787835-72.242909 71.787836z',
	        DEL_SVG: 'M980.992 256h-84.992v683.008c0 47.104-37.888 84.992-84.992 84.992H212.992c-47.104 0-84.992-37.888-84.992-84.992V256H43.008C19.456 256 0 236.544 0 212.992c0-23.552 19.456-43.008 43.008-43.008H256V84.992C256 37.888 293.888 0 340.992 0h340.992C730.112 0 768 37.888 768 84.992v84.992h214.016c23.552 0 43.008 19.456 43.008 43.008-1.024 23.552-20.48 43.008-44.032 43.008zM683.008 84.992H340.992v84.992h340.992V84.992zM212.992 939.008h596.992V256H212.992v683.008z m171.008-470.016v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-23.552 19.456-43.008 43.008-43.008 23.552 1.024 43.008 19.456 43.008 43.008zM512 427.008c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z m171.008 0c23.552 0 43.008 19.456 43.008 43.008v256c0 23.552-19.456 43.008-43.008 43.008-23.552 0-43.008-19.456-43.008-43.008v-256c0-24.576 19.456-43.008 43.008-43.008z',
	        COMMENT_SVG: 'M209.92 152.064l572.416 1.536c12.8 0 23.04 10.24 23.04 23.04v237.568c0 12.8 10.24 23.04 23.04 23.04s23.04-10.24 23.04-23.04V125.44c0-12.8-10.24-23.04-23.04-23.04H158.72c-12.8 0-23.04 10.24-23.04 23.04v773.12c0 12.8 10.24 23.04 23.04 23.04h236.032c12.8 0 23.04-10.24 23.04-23.04s-10.24-22.528-22.528-23.04l-185.856-1.536c-12.8 0-22.528-10.24-22.528-23.04V174.592c0-12.288 10.24-22.528 23.04-22.528z                                            M268.8 570.368h159.232c13.312 0 24.064 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.064-10.752-24.576-24.064v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0-312.32h441.344c13.312 0 24.576 10.752 24.576 24.576v2.56c0 13.312-10.752 24.576-24.576 24.576H268.8c-13.312 0-24.576-10.752-24.576-24.576v-2.56c0.512-13.312 11.264-24.576 24.576-24.576z m0.512 155.648h269.312c13.312 0 24.576 10.752 24.576 24.064v2.56c0 13.312-10.752 24.576-24.576 24.576H269.312c-13.312 0-24.576-10.752-24.576-24.064v-2.56c0-13.824 10.752-24.576 24.576-24.576z m471.04 13.312l-246.784 339.456c-1.536 2.56-2.56 5.632-2.56 8.704l-1.536 132.096c0 9.728 9.728 16.896 18.944 14.336l122.88-37.888c3.072-1.024 5.632-3.072 7.68-5.632l246.784-338.944c4.608-6.144 3.584-15.36-2.56-19.968l-121.344-94.72c-7.168-5.632-16.896-4.096-21.504 2.56z m23.04 67.584l51.2 39.936c2.048 1.536 2.56 5.12 1.024 7.168l-26.112 35.84c-1.536 2.56-5.12 3.072-7.68 1.024l-51.712-38.912c-2.048-1.536-2.56-4.608-1.024-7.168l26.624-37.376c2.048-1.536 5.632-2.048 7.68-0.512z m-165.888 341.504l-35.328 10.752c-9.216 3.072-18.944-4.096-18.944-13.824l0.512-40.96c0-3.072 1.024-6.144 2.56-8.704l137.216-187.904c1.536-2.56 5.12-2.56 7.168-1.024l51.2 38.4c2.56 2.048 3.072 5.12 1.024 7.68l-137.728 189.952c-2.048 2.56-4.608 4.608-7.68 5.632z',
	        CHANGE_LINE_TYPE_SVG: 'M1008 335.2 1008 335.2l-160 144 0 0c-8.8 8-20 12.8-32 12.8-26.4 0-48-21.6-48-48 0-14.4 6.4-26.4 16-35.2l0 0 67.2-60L560 348.8c0 0 0 0 0 0L464 348.8l0 0L352 348.8 48 348.8c-26.4 0-48-21.6-48-48 0-26.4 21.6-48 48-48l124.8 0 0 0L416 252.8l0 0 208 0 0 0 227.2 0L784 192l0 0c-9.6-8.8-16-21.6-16-35.2 0-26.4 21.6-48 48-48 12 0 23.2 4.8 32 12.8l0 0 160 144 0 0c9.6 8.8 16 21.6 16 35.2C1024 314.4 1017.6 326.4 1008 335.2zM16 680.8 16 680.8l160-144 0 0c8.8-8 20-12.8 32-12.8 26.4 0 48 21.6 48 48 0 14.4-6.4 26.4-16 35.2l0 0-67.2 60L400 667.2l0 0 208 0 0 0 243.2 0 0 0L976 667.2c26.4 0 48 21.6 48 48 0 26.4-21.6 48-48 48L672 763.2 560 763.2c0 0 0 0 0 0L464 763.2l0 0L172.8 763.2 240 824l0 0c9.6 8.8 16 21.6 16 35.2 0 26.4-21.6 48-48 48-12 0-23.2-4.8-32-12.8l0 0L16 752l0 0c-9.6-8.8-16-21.6-16-35.2C0 701.6 6.4 689.6 16 680.8z'
	    }
	    module.exports = IconOperation;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * bpmn连线管理类
	 * @author wang.xiaohu
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var ConnectionManager = __webpack_require__(115);
	    var BPMNModel = __webpack_require__(82);
	    var Connector = __webpack_require__(105);
	    var Point = __webpack_require__(64);
	    var util = __webpack_require__(77);
	
	    function BpmnConnectionManager() {
	        ConnectionManager.call(this);
	        this.stencilType = "SequenceFlow";
	    }
	    /**
	     * 创建连线
	     * @param  {[type]} startNode [开始节点]
	     * @param  {[type]} endNode   [结束节点]
	     * @param  {[type]} type      [类型]
	     * @param {[type]} [api] [description]
	     * @return {[type]}           [返回连线]
	     */
	    BpmnConnectionManager.prototype.connectorCreate = function(startNode, endNode, style, api, startPos, endPos) {
	        var model = new BPMNModel({});
	        model.set("resourceId", util.getUUID());
	        model.set("style", style.style);
	        model.set("stencil.type", this.stencilType);
	        startPos && model.set("style.sPos", startPos);
	        endPos && model.set("style.ePos", endPos);
	
	        return this.connectorCreateByOptions(startNode, endNode, { model: model, isEdit: true, style: style}, api);
	    }
	
	
	    /**
	     * 根据opetions.model 反序列化线
	     * @param  {[type]} startNode [description]
	     * @param  {[type]} endNode   [description]
	     * @param  {[type]} options   [description]
	     * @param  {[type]} api       [description]
	     * @return {[type]}           [description]
	     */
	    BpmnConnectionManager.prototype.connectorCreateByOptions = function(startNode, endNode, options, api) {
	        var that = this;
	        var model = options.model;
	        model.option.text = {
	            text: model.option.properties.name
	        }
	        options.text = {
	            text: model.option.properties.name
	        }
	        var connector = new Connector(options);
	        connector.startNode = startNode;
	        connector.endNode = endNode;
	
	        this.connectors.push(connector);
	
	        //判断一下sPos,ePos
	        connector.options.position.startPos = model.get("style.sPos");
	        connector.options.position.endPos = model.get("style.ePos");
	
	        //判断一下 model里有没有dockers，如果有则调用构造point数组  或者调用refreshConnector计算如何画线
	        var dockers = model.get("dockers");
	        if (dockers && dockers.length >= 2) {
	            var points = Point.loadArray(dockers);
	            connector.refresh(points);
	        } else {
	            this.refreshConnector(connector, true);
	        }
	
	        connector.conPointsGroup.on("click", function(e) {
	            var arrSplit = e.target.type.split(Connector.SEPERATOR);
	            var connector = e.target.connector;
	            if (arrSplit[0] === Connector.START_NODE) {
	                 connector.options.position.startPos = arrSplit[1];
	            } else if (arrSplit[0] === Connector.END_NODE) {
	                connector.options.position.endPos = arrSplit[1];
	            }
	            that.refreshConnector(connector, true);
	
	            var params = {};
	            params.event = e;
	            params.type = "conPointsGroup:click";
	            params.lineNode = that.selConnector;
	            api.trigger(params.type, params);
	        });
	
	
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];
	        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	            connector.on("Connector:" + eveName, function(e) {
	                var selected = e.target;
	
	                if (that.selConnector !== selected) {
	                    that.selConnector && that.refreshConnector(that.selConnector);
	                    that.selConnector = selected;
	                }
	
	                var params = {};
	                params.event = e;
	                params.type = eveName;
	                params.target = that.selConnector;
	                api.trigger(params.type, params);
	            });
	        });
	        if (!options.isFromModel) {
	            //1.设置起始节点的outgoing数组 为线段的ID
	            var startNodeOutgoing = startNode.model.get("outgoing");
	            startNodeOutgoing.push(connector.resourceId);
	            //2.设置线段的outgoing数组 为结束节点的ID
	            var connectorOutgoing = connector.model.get("outgoing");
	            connectorOutgoing.push(endNode.resourceId);
	        }
	
	
	        return connector;
	    }
	
	    /**
	     * 设置线段的模型数据  (类型 文字)
	     * @param {[type]} connector [description]
	     * @param {[type]} option    [description]
	     */
	    BpmnConnectionManager.prototype.setModel = function(connector, option) {
	        var originName = connector.options.text.text;
	        connector.options.text.text = option.properties.name;
	        connector.model.mergeOption(option);
	        //文字不一致时
	        if (originName != option.properties.name) {
	            this.refreshConnector(connector, true);
	        }
	    }
	    /**
	     * 删除指定的线
	     * @param connector 欲删除的连线
	     * @param _zr zr
	     */
	    BpmnConnectionManager.prototype.deleteByLine = function (connector,_zr) {
	        //1.将线 所联的startNode的outgoing数据删除
	        if(connector.startNode){
	            var startNodeOutgoing = connector.startNode.model.get("outgoing");
	            index = zrUtil.indexOf(startNodeOutgoing, connector.resourceId);
	            if (index != -1) {
	                startNodeOutgoing.splice(index, 1);
	            }
	
	            if (this.connectorMap) {
	                var key = this.getTwoNodeId(connector.startNode, connector.endNode, connector.options.position);
	                this.connectorMap.removeItem(key, connector);
	            }
	        }
	
	
	        //2.从_zr上删除
	        _zr.remove(connector);
	
	
	        //3.从线数据中删除
	        var index = zrUtil.indexOf(this.connectors, connector);
	        if (index != -1) {
	            this.connectors.splice(index, 1);
	        }
	        if (this.selConnector === connector) {
	            this.selConnector = null;
	        }
	    }
	    /**
	     * 刷新连接线
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    BpmnConnectionManager.prototype.refreshLineByNode = function(node) {
	        for (var i = 0, len = this.connectors.length; i < len; i++) {
	            if (this.connectors[i].startNode == node || this.connectors[i].endNode == node) {
	                this.refreshConnector(this.connectors[i], true);
	            }
	        }
	    }
	
	    zrUtil.inherits(BpmnConnectionManager, ConnectionManager);
	
	    module.exports = BpmnConnectionManager;
	


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连线管理类
	 * @author wang.xiaohu
	 */
	
	    var Util = __webpack_require__(77);
	    var Point = __webpack_require__(64);
	    var Connector = __webpack_require__(105);
	    var Log = __webpack_require__(116);
	    var zrUtil = __webpack_require__(4);
	
	    function ConnectionManager() {
	        this.connectors = []; //当前画布所有的线段
	        this.selConnector = null; //当前选中的线段
	        this.tempConnector = null; //临时线段
	    }
	
	    /**
	     * 设置线的不可编辑
	     * @param  {[type]} forbidEdit [description]
	     * @return {[type]}            [description]
	     */
	    ConnectionManager.prototype.connectorForbidEdit = function (forbidEdit) {
	        for (var i = 0; i < this.connectors.length; i++) {
	            this.connectors[i].options.isEdit = !forbidEdit;
	        }
	        if (forbidEdit) {
	            this.removeConnectorEventListener();
	        }
	    }
	
	    /**
	     * 移除线条监听事件
	     */
	    ConnectionManager.prototype.removeConnectorEventListener = function () {
	        if (this.connectors.length > 0) {
	            this.connectors.forEach(function(connector) {
	                connector.polyLine.off('mouseover');
	                connector.polyLine.off('mousemove');
	                connector.polyLine.off('mouseout');
	                connector.curveLine.off('mouseover');
	                connector.curveLine.off('mousemove');
	                connector.curveLine.off('mouseout');
	            });
	        }
	    }
	
	
	    /**
	     * 清空连接线上的调整位置按钮
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.clearSelectCon = function () {
	        if (this.selConnector != null) {
	            this.refreshConnector(this.selConnector);
	        }
	    }
	    /**
	     * 删除和节点相关联的连接线
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.deleteSelectCon = function (node, _zr) {
	        for (var i = 0; i < this.connectors.length; i++) {
	            if (this.connectors[i].startNode == node || this.connectors[i].endNode == node) {
	                //1.将线 所联的startNode的outgoing数据删除
	                var startNodeOutgoing = this.connectors[i].startNode.model.get("outgoing");
	                var index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);
	                if (index != -1) {
	                    startNodeOutgoing.splice(index, 1);
	                }
	                //2.从_zr上删除
	                _zr.remove(this.connectors[i]);
	                this.connectors.splice(i, 1);
	                i--;
	                this.selConnector = null;
	            }
	        }
	    }
	    ConnectionManager.prototype.removeLine = function (line, zr) {
	        this.selConnector = line;
	        this.deleteLine(zr);
	    }
	    /**
	     * 删除选定的线
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.deleteLine = function (_zr) {
	        //1.将线 所联的startNode的outgoing数据删除
	        if(this.selConnector.startNode){
	            var startNodeOutgoing = this.selConnector.startNode.model.get("outgoing");
	            index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);
	            if (index != -1) {
	                startNodeOutgoing.splice(index, 1);
	            }
	
	            if (this.connectorMap) {
	                var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode, this.selConnector.options.position);
	                this.connectorMap.removeItem(key, this.selConnector);
	            }
	        }
	
	
	        //2.从_zr上删除
	        _zr.remove(this.selConnector);
	
	
	        //3.从线数据中删除
	        var index = zrUtil.indexOf(this.connectors, this.selConnector);
	        if (index != -1) {
	            this.connectors.splice(index, 1);
	        }
	        this.selConnector = null;
	    }
	
	    /**
	     * 重新画线
	     * @param  {[type]} connector          [description]
	     * @param  {[type]} force
	     * @return {[type]}                    [description]
	     */
	    ConnectionManager.prototype.refreshConnector = function (connector, force) {
	        // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘
	        if (force || (!connector.turningPoints) || (connector.turningPoints.length < 2)) {
	            if (connector.model && connector.model.get("style.lineType")) {
	                connector.options.style.lineType = connector.model.get("style.lineType");
	            }
	            var arrStartEndPoint = this.getStartEndPoint(connector);
	            var escapeDistance = null;
	            if (connector.options.position && connector.options.position.escapeDistance) {
	                escapeDistance = connector.options.position.escapeDistance;
	            }
	            var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0],
	                arrStartEndPoint[1],
	                arrStartEndPoint[2], arrStartEndPoint[3], escapeDistance); // TYPE_STRAIGHT TYPE_JAGGED
	
	            connector.refresh(solutions[0][2]);
	        }
	
	        connector.clearHandles(); //清空handle
	    }
	
	
	    ConnectionManager.prototype.getStartEndPoint = function (connector) {
	        var startNode = connector.startNode;
	        var endNode = connector.endNode;
	        var isNotInSameGroup = true;
	        isNotInSameGroup = startNode.parent !== endNode.parent;
	
	        var sRect = Util.getRect(startNode, isNotInSameGroup).boundingRect;
	        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(
	            sRect.y) + Number(sRect.height)];
	
	        var eRect = Util.getRect(endNode, isNotInSameGroup).boundingRect;
	        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(
	            eRect.y) + Number(eRect.height)];
	
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);
	        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);
	
	        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	        var position = connector.options.position;
	        if (position.direction) {
	            var posArr = position.direction.split(',');
	            position.startPos = posArr[0];
	            position.endPos = posArr[1];
	        }
	        if (!position.startPos || !position.endPos) {
	            if (sRect.x < eRect.x) {
	                position.startPos = "right";
	                position.endPos = "left";
	            } else {
	                position.startPos = "left";
	                position.endPos = "right";
	            }
	        }
	        var startPoint = this.calcPointExpression(position.startPos, sConnectorPoint);
	        var endPoint = this.calcPointExpression(position.endPos, eConnectorPoint);
	        startPoint.add(new Point(position.startOffset[0], position.startOffset[1]));
	        endPoint.add(new Point(position.endOffset[0], position.endOffset[1]));
	        return [startPoint, endPoint, sBounds, eBounds];
	    }
	
	    ConnectionManager.prototype.calcPointExpression = function (pos, point) {
	        var variable = {
	            top: point.top.x,
	            left: point.left.y,
	            right: point.right.y,
	            bottom: point.bottom.x,
	            center: point.center.x
	        };
	
	        var expression = "<% print(" + pos + ") %>";
	        var val = parseInt(Util.template(expression)(variable));
	        if (pos.indexOf("top") != -1) {
	            return new Point(val, point.top.y);
	        } else if (pos.indexOf("left") != -1) {
	            return new Point(point.left.x, val);
	        } else if (pos.indexOf("right") != -1) {
	            return new Point(point.right.x, val);
	        } else if (pos.indexOf("bottom") != -1) {
	            return new Point(val, point.bottom.y);
	        } else if (pos.indexOf("center") != -1) {
	            return new Point(val, point.bottom.y);
	        } else {
	            throw new Error("pos参数错误");
	        }
	    }
	
	    /**
	     * 创建或修改临时线
	     * @param  {[type]} startNode             [description]
	     * @param  {[type]} rEndPoint             [description]
	     * @param  {[type]} lineType              [description]
	     * @param  {[type]} startPos              [description]
	     * @return {[type]}                       [description]
	     */
	    ConnectionManager.prototype.manageTempConnector = function (startNode, rEndPoint, lineType, startPos, endPos, endNode) {
	        var eRect = null;
	        var eBounds = null;
	        var sRect = Util.getRect(startNode, true).boundingRect;
	        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(
	            sRect.y) + Number(sRect.height)];
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect, startNode);
	
	        if (!this.tempConnector) {
	            this.tempConnector = new Connector({
	                isEdit: false,
	                style: {
	                    lineType: lineType
	                }
	            });
	        }
	
	        var connector = this.tempConnector;
	        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	        var position = connector.options.position;
	        position.startPos = startPos ? startPos : (sRect.x < rEndPoint.x ? "right" : "left");
	        position.endPos = endPos ? endPos : (sRect.x < rEndPoint.x ? "left" : "right");
	
	        connector.options.style.lineType = lineType;
	        if (endNode) {
	            eRect = Util.getRect(endNode, true).boundingRect;
	            eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(
	                eRect.y) + Number(eRect.height)];
	        }
	        var solutions = this.connector2Points(lineType, sConnectorPoint[position.startPos], rEndPoint,
	            sBounds, eBounds); // TYPE_STRAIGHT TYPE_JAGGED
	
	        connector.refresh(solutions[0][2]);
	        return connector;
	    }
	
	    /**
	     * 创建或修改临时反转线
	     * @param  {[type]} startPoint              [description]
	     * @param  {[type]} endNode                 [description]
	     * @param  {[type]} lineType                [description]
	     * @param  {[type]} endPos                  [description]
	     * @return {[type]}                         [description]
	     */
	    ConnectionManager.prototype.manageReverseTempConnector = function (startPoint, endNode, lineType, endPos, startPos, startNode) {
	        var sRect = null;
	        var sBounds = null;
	        var eRect = Util.getRect(endNode, true).boundingRect;
	        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(eRect.y) + Number(eRect.height)];
	        var eConnectorPoint = Util.getConnectorPoints(eRect, endNode);
	        if (!this.tempConnector) {
	            this.tempConnector = new Connector({
	                isEdit: false,
	                style: {
	                    lineType: lineType
	                }
	            });
	        }
	        var connector = this.tempConnector;
	        var position = connector.options.position;
	        position.endPos = endPos ? endPos : (eRect.x < startPoint.x ? "right" : "left");
	        position.startPos = startPos ? startPos : (eRect.x < startPoint.x ? "left" : "right");
	
	        connector.options.style.lineType = lineType;
	        if (startNode) {
	            sRect = Util.getRect(startNode, true).boundingRect;
	            sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(
	            sRect.y) + Number(sRect.height)];
	        }
	        var solutions = this.connector2Points(lineType, startPoint, eConnectorPoint[position.endPos],
	            sBounds, eBounds); // TYPE_STRAIGHT TYPE_JAGGED
	
	        connector.refresh(solutions[0][2]);
	        return connector;
	    }
	
	    /**
	     * 删除临时线
	     * @param  {[type]} zr             [description]
	     */
	    ConnectionManager.prototype.removeTempConnector = function (zr) {
	        if (this.tempConnector) {
	            zr.remove(this.tempConnector);
	            this.tempConnector = null;
	        }
	    }
	
	
	    /**
	     * 算出 两个节点 指定两个点如何联线
	     * @param  {[type]} type       [description]
	     * @param  {[type]} startPoint [description]
	     * @param  {[type]} endPoint   [description]
	     * @param  {[type]} sBounds    [description]
	     * @param  {[type]} eBounds    [description]
	     * @return {[type]}            [description]
	     */
	    ConnectionManager.prototype.connector2Points = function (type, startPoint, endPoint, sBounds, eBounds,
	        escapeDistance) {
	        var figureEscapeDistance = [30, 30];
	        if (escapeDistance) {
	            if (!zrUtil.isArray(escapeDistance)) {
	                figureEscapeDistance = [escapeDistance, escapeDistance];
	            } else {
	                figureEscapeDistance = escapeDistance;
	            }
	        }
	
	        Log.group("connectionManager: connector2Points");
	
	
	        Log.info("ConnectionManager: connector2Points (" + type + ", " + startPoint + ", " + endPoint +
	            ", " + sBounds + ", " + eBounds + ')');
	        var solutions = [];
	
	
	
	        switch (type) {
	            case Connector.TYPE_CHAIN:
	
	            case Connector.TYPE_STRAIGHT: //直线
	                var points = [startPoint.clone(), endPoint.clone()];
	                solutions.push(['straight', 'straight', points]);
	                break;
	
	            case Connector.TYPE_CURVE: //曲线
	
	            case Connector.TYPE_JAGGED: //折线
	                var startExitPoint = null;
	                var endExitPoint = null;
	
	                //find start exit point  寻找开始出口
	                if (sBounds != null) {
	                    var potentialExits = [];
	
	                    potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北
	                    potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东
	                    potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南
	                    potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西
	
	                    //pick closest exit point  寻找与 startPoint 最靠近的出口点
	                    startExitPoint = potentialExits[0];
	                    for (var i = 1; i < potentialExits.length; i++) {
	                        if (Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint,
	                                startExitPoint)) {
	                            startExitPoint = potentialExits[i];
	                        }
	                    }
	                }
	
	
	                //find end exit point  寻找结束出口
	                if (eBounds != null) {
	                    var potentialExits = [];
	
	                    potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north
	                    potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east
	                    potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south
	                    potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west
	
	                    //pick closest exit point  寻找与 endPoint 最靠近的出口点
	                    endExitPoint = potentialExits[0];
	                    for (var i = 1; i < potentialExits.length; i++) {
	                        if (Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint,
	                                endExitPoint)) {
	                            endExitPoint = potentialExits[i];
	                        }
	                    }
	                }
	
	                //Basic solution 最基本的解决方案   为其他解决方案做准备
	                var s = [startPoint];
	                var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT
	                if (startExitPoint) {
	                    s.push(startExitPoint);
	                    gapIndex = 1;
	                }
	                if (endExitPoint) {
	                    s.push(endExitPoint);
	                }
	                s.push(endPoint);
	
	
	
	                //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用
	                var s0 = Point.cloneArray(s);
	                solutions.push(['s0', 's0', s0]);
	
	
	
	                //S1   S1 解决方案  只有一个折点
	                var s1 = Point.cloneArray(s);
	
	                //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置
	                var s1_1 = Point.cloneArray(s1);
	                s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x, s1_1[gapIndex + 1].y));
	                solutions.push(['s1', 's1_1', s1_1]);
	
	                //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置
	                var s1_2 = Point.cloneArray(s1);
	                s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex + 1].x, s1_2[gapIndex].y));
	                solutions.push(['s1', 's1_2', s1_2]);
	
	
	                //S2  S2 解决方案  添加两个折点
	
	                //Variant I   s2_1方案
	                var s2_1 = Point.cloneArray(s);
	                var s2_1_1 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex].y);
	                var s2_1_2 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex + 1].y);
	                s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);
	                solutions.push(['s2', 's2_1', s2_1]);
	
	
	                //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2
	                //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2
	                var s2_2 = Point.cloneArray(s);
	                var s2_2_1 = new Point(s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);
	                var s2_2_2 = new Point(s2_2[gapIndex + 1].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);
	                s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);
	                solutions.push(['s2', 's2_2', s2_2]);
	
	
	                //Variant III
	                var s2_3 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex + 1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    eastExits.push(sBounds[2] + 20);
	                }
	
	                if (eBounds) {
	                    eastExits.push(eBounds[2] + 20);
	                }
	
	                var eastExit = Util.max(eastExits);
	                var s2_3_1 = new Point(eastExit, s2_3[gapIndex].y);
	                var s2_3_2 = new Point(eastExit, s2_3[gapIndex + 1].y);
	                s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);
	                solutions.push(['s2', 's2_3', s2_3]);
	
	
	                //Variant IV  s2_4方案
	                var s2_4 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex + 1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    northExits.push(sBounds[1] - 20);
	                }
	
	                if (eBounds) {
	                    northExits.push(eBounds[1] - 20);
	                }
	
	                var northExit = Util.min(northExits);
	                var s2_4_1 = new Point(s2_4[gapIndex].x, northExit);
	                var s2_4_2 = new Point(s2_4[gapIndex + 1].x, northExit);
	                s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);
	                solutions.push(['s2', 's2_4', s2_4]);
	
	
	                //Variant V
	                var s2_5 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex + 1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    westExits.push(sBounds[0] - 20);
	                }
	
	                if (eBounds) {
	                    westExits.push(eBounds[0] - 20);
	                }
	
	                var westExit = Util.min(westExits);
	                var s2_5_1 = new Point(westExit, s2_5[gapIndex].y);
	                var s2_5_2 = new Point(westExit, s2_5[gapIndex + 1].y);
	                s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);
	                solutions.push(['s2', 's2_5', s2_5]);
	
	
	                //Variant VI
	                var s2_6 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex + 1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    southExits.push(sBounds[3] + 20);
	                }
	
	                if (eBounds) {
	                    southExits.push(eBounds[3] + 20);
	                }
	
	                var southExit = Util.max(southExits);
	                var s2_6_1 = new Point(s2_6[gapIndex].x, southExit);
	                var s2_6_2 = new Point(s2_6[gapIndex + 1].x, southExit);
	                s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);
	                solutions.push(['s2', 's2_6', s2_6]);
	
	
	
	                //FILTER solutions
	
	                /*Algorithm
	                 * 0. solutions are ordered from minimmun nr of points to maximum >:)
	                 * 1. remove all solutions that are not orthogonal (mainly s0 solution)
	                 * 2. remove all solutions that go backward (we will not need them ever)
	                 * 3. remove all solutions with intersections
	                 * 4. pick first class of solutions with same nr of points (ex: 2)
	                 * 5. pick the first solution with 90 degree angles (less turnarounds)
	                 * (not interesteted) sort by length :p
	                 */
	
	                //1. filter non ortogonal solutions 删除不是正交直线的方案
	                Log.info("Filter orthogonal solutions. Initial number of solutions = " + solutions.length);
	                var orthogonalSolution = [];
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    if (Util.orthogonalPath(solution)) {
	                        orthogonalSolution.push(solutions[l]);
	                    }
	                }
	                solutions = orthogonalSolution;
	                Log.info("\n\tOrthogonalSolutions = " + solutions.length);
	
	                //2. filter backward solutions  过滤 倒退的方案
	                //do not allow start and end points to coincide - ignore them
	                if (startPoint.equals(endPoint)) {
	                    Log.info(
	                        "Start and end point coincide...skip backward solution. I think we will just fall on s0 :)"
	                    );
	                } else {
	                    Log.info("Filter backward solutions. Initial number of solutions = " + solutions.length);
	                    var forwardSolutions = [];
	                    var temp = '';
	                    for (var l = 0; l < solutions.length; l++) {
	                        var solution = solutions[l][2];
	                        if (Util.forwardPath(solution)) {
	                            forwardSolutions.push(solutions[l]);
	                        } else {
	                            temp = temp + "\n\t" + solution;
	                        }
	                    }
	                    solutions = forwardSolutions;
	                    Log.info("\n\t ForwardSolutions = " + solutions.length);
	                    if (solutions.length == 0) {
	                        Log.info("Discarded solutions: " + temp);
	                    }
	                }
	
	
	                //3. Filter non intersecting solutions  去除没有交集()的方案
	                Log.info("Filter non intersecting solutions. Initial number of solutions = " + solutions.length);
	                var nonIntersectionSolutions = []
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    //Log.info("Solution id= " + solutions[l][1] + ' nr points = ' + solution.length + ", points = " + solution);
	                    var intersect = false;
	
	                    var innerLines = solution.slice(); //just a shallow copy
	
	                    /*If any bounds just trim the solution. So we avoid the strange case when a connection
	                     *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/
	                    if (eBounds || sBounds) {
	                        //i0nnerLines = innerLines.slice(0, innerLines.length - 1);
	                        innerLines = innerLines.slice(1, innerLines.length - 1);
	                        //Log.info("\t eBounds present,innerLines nr. points = " + innerLines.length + ", points = " + innerLines);
	                    }
	
	
	
	                    //now test for intersection
	                    if (sBounds) {
	                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);
	                    }
	                    if (eBounds) {
	                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);
	                    }
	
	                    if (!intersect) {
	                        nonIntersectionSolutions.push(solutions[l]);
	                    }
	                }
	
	                //If all solutions intersect than this is destiny  :) and just ignore the intersection filter
	                if (nonIntersectionSolutions.length != 0) {
	                    //reasign to solutions
	                    solutions = nonIntersectionSolutions;
	                }
	
	                Log.info("\n\t nonIntersectionSolutions = " + solutions.length);
	
	
	                //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）
	                Log.info("Get first class of solutions with same nr of points");
	                if (solutions.length == 0) {
	                    Log.info("This is not possible");
	                }
	
	                var firstSolution = solutions[0][2]; //pick first solution
	                var nrOfPoints = firstSolution.length;
	                var sameNrPointsSolution = [];
	
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    if (solution.length == nrOfPoints) {
	                        sameNrPointsSolution.push(solutions[l]);
	                    }
	                }
	
	                solutions = sameNrPointsSolution;
	
	
	
	
	                /*5.  计算路径分数 ，取最分数高的
	                 Pick the first solution with 90 degree angles (less turnarounds)
	                 *in case we have more than one solution in our class
	                 */
	                Log.info("pick the first solution with 90 degree angles (less turnarounds)");
	                var solIndex = 0;
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    if (Util.scorePath(solutions[solIndex][2]) < Util.scorePath(solutions[l][2])) {
	                        solIndex = l;
	                    }
	                }
	                solutions = [solutions[solIndex]];
	
	
	                break;
	        }
	
	        //SMOOTHING curve
	        if (type === Connector.TYPE_CURVE) {
	            this.smoothCurve(solutions);
	        }
	        //END SMOOTHING curve
	
	        Log.groupEnd();
	
	        return solutions;
	    }
	
	    ConnectionManager.prototype.smoothCurve = function (solutions) {
	        var option = 3;
	
	        switch (option) {
	            case 0:
	                //do nothing
	                break;
	
	            case 1: //add intermediate points
	                //Add the middle point for start and end segment so that we "force" the
	                //curve to both come "perpendicular" on bounds and also make the curve
	                //"flee" more from bounds (on exit)
	                for (var s = 0; s < solutions.length; s++) {
	                    var solTurningPoints = solutions[s][2];
	
	                    //first segment
	                    var a1 = solTurningPoints[0];
	                    var a2 = solTurningPoints[1];
	                    var startMiddlePoint = Util.getMiddle(a1, a2);
	                    solTurningPoints.splice(1, 0, startMiddlePoint);
	
	                    //last segment
	                    var a3 = solTurningPoints[solTurningPoints.length - 2];
	                    var a4 = solTurningPoints[solTurningPoints.length - 1];
	                    var endMiddlePoint = Util.getMiddle(a3, a4);
	                    solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);
	                }
	                break;
	
	            case 2: //remove points
	
	                zrUtil.each(solutions, function(solution) {
	                    var solType = solution[0];
	                    if (solType == 's1' || solType == 's2') {
	                        var solTurningPoints = solution[2];
	                        solTurningPoints.splice(1, 1);
	                        solTurningPoints.splice(solTurningPoints.length - 2, 1);
	                    }
	                });
	                break;
	
	            case 3:
	                /*remove colinear point for s1 as it seems that more colinear points do not look good
	                 * on organic solutions >:D*/
	                zrUtil.each(solutions, function(solution) {
	                    var solType = solution[0];
	                    if (solType == 's1') {
	                        var solTurningPoints = solution[2];
	                        var reducedSolution = Util.collinearReduction(solTurningPoints);
	                        solution[2] = reducedSolution;
	                    }
	                });
	                break;
	        } //end switch
	
	    }
	
	    module.exports = ConnectionManager;


/***/ }),
/* 116 */
/***/ (function(module, exports) {

	/**
	 * 日志类
	 * @author wang.xiaohu
	 */
	
	
	    var Log  = {
	        LOG_LEVEL_NONE  : 0,
	
	        LOG_LEVEL_DEBUG : 1,
	
	        LOG_LEVEL_INFO : 2,
	
	        LOG_LEVEL_ERROR : 3,
	
	        level : this.LOG_LEVEL_ERROR,
	        
	        /**
	        * The less important of all messages
	        * @param {String} message - the message to be logged
	        **/
	        debug: function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_DEBUG){
	                    
	                    //in FF is debug
	                    if(typeof console.debug == 'function'){
	                        console.debug(message);
	                    }
	                    else{//TODO: in IE is log
	    //                    console.info(message);
	                    }
	                }
	            }
	        },
	
	
	        /**
	        * The commonly used log message
	        * @param {String} message - the message to be logged
	        **/
	        info : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_INFO){
	                    console.info(message);
	                }
	            }
	        },
	
	        /**
	        * The worse kind of message. Usually a crash
	        * @param {String} message - the message to be logged
	        **/
	        error : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_ERROR){
	                    console.error(message);
	                }
	            }
	        },
	
	        /**
	         *Start grouping the log messages
	         *@param {String} title - the title of the group
	         *@see <a href="http://getfirebug.com/logging">http://getfirebug.com/logging</a>
	         **/
	        group : function(title){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){           
	                    /**If we do not test for group() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.group === 'function'){
	                        console.group(title);
	                    }
	                }
	            }
	        },
	
	        /**Ends current message grouping*/
	        groupEnd : function(){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){
	                    /**If we do not test for groupEnd() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.groupEnd === 'function'){
	                        console.groupEnd();
	                    }
	                }
	            }
	        }
	
	    };
	
	    //Log.level = Log.LOG_LEVEL_DEBUG; 
	    Log.level = Log.LOG_LEVEL_ERROR; 
	    //Log.level = Log.LOG_LEVEL_ERROR;
	    //Log.level = Log.LOG_LEVEL_NONE;
	    module.exports = Log;
	    


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连线操作类
	 * @author miao.cunzhi
	 */
	
	    var symbolUtil = __webpack_require__(106);
	    var zrUtil = __webpack_require__(4);
	    var icon = __webpack_require__(113);
	    function LineOperationManager(connectionManager, api) {
	        this.lineOperations = [],
	        this.isEdit = true;
	        this.connectionManager = connectionManager;
	        this._api = api;
	    }
	
	    /**
	     *  this.lineOperationManager.addIcon(key, options);
	     */
	    LineOperationManager.prototype.addIcon = function(key, options) {
	        //判断是小图标否存在 ，存在则直接返回
	        var lineOperationIcon = zrUtil.find(options.lineNode.icons, function(icon) {
	            return icon.key === key;
	        });
	
	        if (lineOperationIcon) {
	            this.bindOperation(options.lineNode);
	            return;
	        }else {
	            var lineOperation = this.creatOperation(key, options);
	            this._api._getParentZr().add(lineOperation);
	            this.bindOperation(options.lineNode);
	            return lineOperation;
	        }
	    }
	
	
	    LineOperationManager.prototype.creatOperation = function(key, options) {
	        var lineOperation = symbolUtil.createSymbol(options.iconPath, 0, 0, options.width || 15, options.height || 15, 0, options.color||'#aaaaac');
	        lineOperation.key = key;
	        lineOperation._width =  options.width || 15;  // path情况下无法计算
	        lineOperation._isLineOperationIcon = true;
	        lineOperation.hide();
	        options.lineNode.icons.push(lineOperation);
	        this.lineOperations.push(lineOperation);
	
	        //小图标 点击事件  如果有回调则调用回调，否则派发事件
	        lineOperation.on("click", function(event) {
	            if (options.callback) {
	                event.data = options;
	                event.lineNode = options.lineNode;
	                options.callback(event);
	            } else {
	                var params = {};
	                params.event = event;
	                params.type = "click";
	                params.elementType = "LineOperationIcon";
	                this._api.trigger(params.type, params);
	            }
	        }.bind(this));
	        return lineOperation;
	    }
	
	    /**
	     * 计算小图标的位置，并显示
	     * @param  {[type]} connector [description]
	     * @return {[type]}           [description]
	     */
	    LineOperationManager.prototype.bindOperation = function(connector) {
	        function parentX(node) {
	            if (node.parent && node.parent.nodeType == "SubProcess") {
	                return node.position[0] + parentX(node.parent)
	            } else {
	                return node.position[0]
	            }
	        }
	    
	        function parentY(node) {
	            if (node.parent && node.parent.nodeType == "SubProcess") {
	                return node.position[1] + parentY(node.parent)
	            } else {
	                return node.position[1]
	            }
	        }
	
	        if (this.isEdit == false) {
	            return;
	        }
	        var pointPosition = connector.middle(), posX, posY;
	        if (connector.parent && connector.parent.nodeType == "SubProcess") {
	            posX = pointPosition[0] + parentX(connector.parent);
	            posY = pointPosition[1] + parentY(connector.parent);
	        } else {
	            posX = pointPosition[0];
	            posY = pointPosition[1];
	        }
	
	        var arrLength = zrUtil.map(connector.icons, function(icon) {
	            return icon._width;
	        });
	
	        var totalLength = zrUtil.reduce(arrLength, function(previousValue,currentValue) {
	            return previousValue + currentValue + 10;
	        }, 0 );
	
	        zrUtil.each(connector.icons, function(icon, index) {
	            var connectorPosition = 0;
	            for (var k = 0; k < index; k++) {
	                connectorPosition += arrLength[k] + 10;
	            }
	            icon.attr("position", [posX + connectorPosition - totalLength / 2, posY + 5]);
	            icon.show();
	            icon.attachLine = connector;
	        })
	    }
	
	    LineOperationManager.prototype.hideAllLineOperation = function() {
	        zrUtil.each(this.lineOperations, function(lineOperation) {
	            lineOperation.hide();
	        });
	    }
	
	    LineOperationManager.prototype.addDeleteIcon = function(lineNode,options) {
	        var opts = zrUtil.defaults({
	            iconPath: 'path://' + icon.DEL_SVG,
	            width: 12,
	            height: 14,
	            lineNode: lineNode,
	            callback: function(e) {
	                this._api.remove(e.target.attachLine);//this.connectionManager.selConnector);
	            }.bind(this)
	        }, options,true);
	
	        this.addIcon("delete", opts);
	    }
	
	    LineOperationManager.prototype.addChangeLineTypeIcon = function(lineNode,options) {
	        var opts = zrUtil.defaults({
	            iconPath: 'path://' + icon.CHANGE_LINE_TYPE_SVG,
	            width: 15,
	            height: 15,
	            lineNode: lineNode,
	            callback: function () {
	                this._api.changeSelectConnectorType();
	            }.bind(this)
	        }, options,true);
	
	        this.addIcon("change", opts)
	    }
	
	    module.exports = LineOperationManager;
	


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 辅助线操作类
	 * @author miao.cunzhi
	 */
	
	    var graphic = __webpack_require__(3);
	    var zrUtil = __webpack_require__(4);
	    var util = __webpack_require__(77);
	    var virtualXNames = ['virtualXTop', 'virtualXCenter', 'virtualXBottom'];
	    var virtualYNames = ['virtualYLeft', 'virtualYCenter', 'virtualYRight'];
	
	    var Guidelines = {
	        virtualXLines: [],
	        virtualYLines: [],
	        createLine: function (name) {
	            var virtualLine = new graphic.Line({
	                style: {
	                    stroke: "#5693f78c"
	                },
	                z: 3,
	                name: name
	            });
	            return virtualLine;
	        },
	        createGuidelines: function (zr) {
	            if (this.virtualXLines.length < 3) {
	                this.virtualXLines = [];
	                //创建x轴虚线
	                for (var i = 0; i < 3; i++) {
	                    var xLine = this.createLine(virtualXNames[i]);
	                    this.virtualXLines.push(xLine);
	                    zr.add(xLine);
	                }
	            }
	            if (this.virtualYLines.length < 3) {
	                this.virtualYLines = [];
	                //创建Y轴虚线
	                for (var j = 0; j < 3; j++) {
	                    var yLine = this.createLine(virtualYNames[i]);
	                    this.virtualYLines.push(yLine);
	                    zr.add(yLine);
	                }
	
	            }
	        },
	        resetLines: function () {
	            zrUtil.each(this.virtualXLines, function(item) {
	                item.attr("shape", {
	                    x2: 0
	                });
	            });
	            zrUtil.each(this.virtualYLines, function(item) {
	                item.attr("shape", {
	                    y2: 0
	                });
	            });
	        },
	        destoryLines: function(zr) {
	            for (var m = 0; m < this.virtualXLines.length; m++) {
	                zr.remove(this.virtualXLines[m]);
	            }
	            for (var n = 0; n < this.virtualYLines.length; n++) {
	                zr.remove(this.virtualYLines[n]);
	            }
	            this.virtualXLines = [];
	            this.virtualYLines = [];
	        },
	        getMinMax: function(points) {
	           var minX = points[0].x,
	               minY = points[0].y,
	               maxX = points[0].x,
	               maxY = points[0].y;
	            zrUtil.each(points, function(item) {
	                if (minX > item.x) {
	                    minX = item.x;
	                }
	                if (minY > item.y) {
	                    minY = item.y;
	                }
	                if (maxX < item.x) {
	                    maxX = item.x;
	                }
	                if (maxY < item.y) {
	                    maxY = item.y;
	                }
	            });
	            return {
	                minX: minX,
	                minY: minY,
	                maxX: maxX,
	                maxY: maxY
	            }
	        },
	        judgeAlignment: function (selectedNode, nowRectPosition, domArray, maxWidth, maxHeight) {
	            var that = this;
	            var rotation = selectedNode.rotation;
	            var targetDom = zrUtil.find(domArray, function (item) {
	                return item.id == selectedNode.id;
	            });
	            if (!targetDom) {
	                return;
	            }
	            var points = targetDom.points;
	            var endPointCurrent = {};
	            points[0].x = nowRectPosition[0] - targetDom.width / 2;
	            points[0].y = nowRectPosition[1] - targetDom.height / 2;
	            points[1].x = nowRectPosition[0] + targetDom.width / 2;
	            points[1].y = nowRectPosition[1] - targetDom.height / 2;
	            points[2].x = nowRectPosition[0] - targetDom.width / 2;
	            points[2].y = nowRectPosition[1] + targetDom.height / 2;
	            points[3].x = nowRectPosition[0] + targetDom.width / 2;
	            points[3].y = nowRectPosition[1] + targetDom.height / 2;
	            if (Math.abs(rotation) > 0) {
	                var newPoints = []
	                zrUtil.each(points, function(point) {
	                    var newPoint = util.calculatePoints(point, { x: nowRectPosition[0], y: nowRectPosition[1] }, rotation);
	                    var x = parseInt(newPoint.x, 10);
	                    var y = parseInt(newPoint.y, 10);
	                    newPoints.push({x: x, y: y});
	                });
	                endPointCurrent = this.getMinMax(newPoints);
	            } else {
	                endPointCurrent = this.getMinMax(points);
	            }
	            // 重置
	            this.resetLines();
	            zrUtil.each(domArray, function (item) {
	                if (item.id != targetDom.id) {
	                    var position = item.position;
	                    var endPoints = that.getMinMax(item.points);
	                    // horizontal
	
	                    // 最顶部水平对齐
	                    // 当前最顶部与目标中点水平对齐
	                    // 当前最顶部与目标最底部水平对齐
	                    if ((endPointCurrent.minY == endPoints.minY)
	                        || (endPointCurrent.minY == position[1])
	                        || (endPointCurrent.minY == endPoints.maxY)) {
	                        that.virtualXLines[0].attr({
	                            position: [0, endPointCurrent.minY],
	                            shape: {
	                                x2: maxWidth
	                            }
	                        });
	                    }
	                    // 中点水平对齐
	                    // 当前中点与目标最顶部水平对齐
	                    // 当前中点与目标最底部水平对齐
	                    if ((nowRectPosition[1] == position[1])
	                        || (nowRectPosition[1] == endPoints.minY)
	                        || (nowRectPosition[1] == endPoints.maxY)) {
	                        that.virtualXLines[1].attr({
	                            position: [0, nowRectPosition[1]],
	                            shape: {
	                                x2: maxWidth
	                            }
	                        });
	                    }
	                    // 最底部水平对齐
	                    // 当前最底部与目标中点水平对齐
	                    // 当前最底部与目标最顶部水平对齐
	                    if ((endPointCurrent.maxY == endPoints.maxY)
	                        || (endPointCurrent.maxY == position[1])
	                        || (endPointCurrent.maxY == endPoints.minY)) {
	                        that.virtualXLines[2].attr({
	                            position: [0, endPointCurrent.maxY],
	                            shape: {
	                                x2: maxWidth
	                            }
	                        });
	                    }
	                    // vertical
	
	                    // 最左侧垂直对齐
	                    // 当前最左侧与目标中点垂直对齐
	                    // 当前最左侧与目标最右侧垂直对齐
	                    if ((endPointCurrent.minX == endPoints.minX)
	                        || (endPointCurrent.minX == position[0])
	                        || (endPointCurrent.minX == endPoints.maxX)) {
	                        that.virtualYLines[0].attr({
	                            position: [endPointCurrent.minX, 0],
	                            shape: {
	                                y2: maxHeight
	                            }
	                        });
	                    }
	                    // 中点垂直对齐
	                    // 当前中点与目标最左侧垂直对齐
	                    // 当前中点与目标最右侧垂直对齐
	                    if ((nowRectPosition[0] == position[0])
	                        || (nowRectPosition[0] == endPoints.minX)
	                        || (nowRectPosition[0] == endPoints.maxX)) {
	                        that.virtualYLines[1].attr({
	                            position: [nowRectPosition[0], 0],
	                            shape: {
	                                y2: maxHeight
	                            }
	                        });
	                    }
	                    // 最右侧垂直对齐
	                    // 当前最右侧与目标中点垂直对齐
	                    // 当前最右侧与目标最左侧垂直对齐
	                    if ((endPointCurrent.maxX == endPoints.maxX)
	                        || (endPointCurrent.maxX == position[0])
	                        || (endPointCurrent.maxX == endPoints.minX)) {
	                        that.virtualYLines[2].attr({
	                            position: [endPointCurrent.maxX, 0],
	                            shape: {
	                                y2: maxHeight
	                            }
	                        });
	                    }
	                }
	            });
	        }
	    };
	
	    module.exports = Guidelines;
	


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict() {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	var bluebird = __webpack_require__(120)();
	bluebird.noConflict = noConflict;
	module.exports = bluebird;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	module.exports = function() {
	var makeSelfResolutionError = function () {
	    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	};
	var reflectHandler = function() {
	    return new Promise.PromiseInspection(this._target());
	};
	var apiRejection = function(msg) {
	    return Promise.reject(new TypeError(msg));
	};
	function Proxyable() {}
	var UNDEFINED_BINDING = {};
	var util = __webpack_require__(122);
	
	var getDomain;
	if (util.isNode) {
	    getDomain = function() {
	        var ret = process.domain;
	        if (ret === undefined) ret = null;
	        return ret;
	    };
	} else {
	    getDomain = function() {
	        return null;
	    };
	}
	util.notEnumerableProp(Promise, "_getDomain", getDomain);
	
	var es5 = __webpack_require__(123);
	var Async = __webpack_require__(124);
	var async = new Async();
	es5.defineProperty(Promise, "_async", {value: async});
	var errors = __webpack_require__(129);
	var TypeError = Promise.TypeError = errors.TypeError;
	Promise.RangeError = errors.RangeError;
	var CancellationError = Promise.CancellationError = errors.CancellationError;
	Promise.TimeoutError = errors.TimeoutError;
	Promise.OperationalError = errors.OperationalError;
	Promise.RejectionError = errors.OperationalError;
	Promise.AggregateError = errors.AggregateError;
	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {};
	var tryConvertToPromise = __webpack_require__(130)(Promise, INTERNAL);
	var PromiseArray =
	    __webpack_require__(131)(Promise, INTERNAL,
	                               tryConvertToPromise, apiRejection, Proxyable);
	var Context = __webpack_require__(132)(Promise);
	 /*jshint unused:false*/
	var createContext = Context.create;
	var debug = __webpack_require__(133)(Promise, Context);
	var CapturedTrace = debug.CapturedTrace;
	var PassThroughHandlerContext =
	    __webpack_require__(134)(Promise, tryConvertToPromise, NEXT_FILTER);
	var catchFilter = __webpack_require__(135)(NEXT_FILTER);
	var nodebackForPromise = __webpack_require__(136);
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	function check(self, executor) {
	    if (self == null || self.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    if (typeof executor !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(executor));
	    }
	
	}
	
	function Promise(executor) {
	    if (executor !== INTERNAL) {
	        check(this, executor);
	    }
	    this._bitField = 0;
	    this._fulfillmentHandler0 = undefined;
	    this._rejectionHandler0 = undefined;
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._resolveFromExecutor(executor);
	    this._promiseCreated();
	    this._fireEvent("promiseCreated", this);
	}
	
	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};
	
	Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (util.isObject(item)) {
	                catchInstances[j++] = item;
	            } else {
	                return apiRejection("Catch statement predicate: " +
	                    "expecting an object but got " + util.classString(item));
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];
	        return this.then(undefined, catchFilter(catchInstances, fn, this));
	    }
	    return this.then(undefined, fn);
	};
	
	Promise.prototype.reflect = function () {
	    return this._then(reflectHandler,
	        reflectHandler, undefined, this, undefined);
	};
	
	Promise.prototype.then = function (didFulfill, didReject) {
	    if (debug.warnings() && arguments.length > 0 &&
	        typeof didFulfill !== "function" &&
	        typeof didReject !== "function") {
	        var msg = ".then() only accepts functions but was passed: " +
	                util.classString(didFulfill);
	        if (arguments.length > 1) {
	            msg += ", " + util.classString(didReject);
	        }
	        this._warn(msg);
	    }
	    return this._then(didFulfill, didReject, undefined, undefined, undefined);
	};
	
	Promise.prototype.done = function (didFulfill, didReject) {
	    var promise =
	        this._then(didFulfill, didReject, undefined, undefined, undefined);
	    promise._setIsFinal();
	};
	
	Promise.prototype.spread = function (fn) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
	};
	
	Promise.prototype.toJSON = function () {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: undefined,
	        rejectionReason: undefined
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this.value();
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this.reason();
	        ret.isRejected = true;
	    }
	    return ret;
	};
	
	Promise.prototype.all = function () {
	    if (arguments.length > 0) {
	        this._warn(".all() was passed arguments but it does not take any");
	    }
	    return new PromiseArray(this).promise();
	};
	
	Promise.prototype.error = function (fn) {
	    return this.caught(util.originatesFromRejection, fn);
	};
	
	Promise.getNewLibraryCopy = module.exports;
	
	Promise.is = function (val) {
	    return val instanceof Promise;
	};
	
	Promise.fromNode = Promise.fromCallback = function(fn) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs
	                                         : false;
	    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
	    if (result === errorObj) {
	        ret._rejectCallback(result.e, true);
	    }
	    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
	    return ret;
	};
	
	Promise.all = function (promises) {
	    return new PromiseArray(promises).promise();
	};
	
	Promise.cast = function (obj) {
	    var ret = tryConvertToPromise(obj);
	    if (!(ret instanceof Promise)) {
	        ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._setFulfilled();
	        ret._rejectionHandler0 = obj;
	    }
	    return ret;
	};
	
	Promise.resolve = Promise.fulfilled = Promise.cast;
	
	Promise.reject = Promise.rejected = function (reason) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._rejectCallback(reason, true);
	    return ret;
	};
	
	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    return async.setScheduler(fn);
	};
	
	Promise.prototype._then = function (
	    didFulfill,
	    didReject,
	    _,    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== undefined;
	    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
	    var target = this._target();
	    var bitField = target._bitField;
	
	    if (!haveInternalData) {
	        promise._propagateFrom(this, 3);
	        promise._captureStackTrace();
	        if (receiver === undefined &&
	            ((this._bitField & 2097152) !== 0)) {
	            if (!((bitField & 50397184) === 0)) {
	                receiver = this._boundValue();
	            } else {
	                receiver = target === this ? undefined : this._boundTo;
	            }
	        }
	        this._fireEvent("promiseChained", this, promise);
	    }
	
	    var domain = getDomain();
	    if (!((bitField & 50397184) === 0)) {
	        var handler, value, settler = target._settlePromiseCtx;
	        if (((bitField & 33554432) !== 0)) {
	            value = target._rejectionHandler0;
	            handler = didFulfill;
	        } else if (((bitField & 16777216) !== 0)) {
	            value = target._fulfillmentHandler0;
	            handler = didReject;
	            target._unsetRejectionIsUnhandled();
	        } else {
	            settler = target._settlePromiseLateCancellationObserver;
	            value = new CancellationError("late cancellation observer");
	            target._attachExtraTrace(value);
	            handler = didReject;
	        }
	
	        async.invoke(settler, target, {
	            handler: domain === null ? handler
	                : (typeof handler === "function" &&
	                    util.domainBind(domain, handler)),
	            promise: promise,
	            receiver: receiver,
	            value: value
	        });
	    } else {
	        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
	    }
	
	    return promise;
	};
	
	Promise.prototype._length = function () {
	    return this._bitField & 65535;
	};
	
	Promise.prototype._isFateSealed = function () {
	    return (this._bitField & 117506048) !== 0;
	};
	
	Promise.prototype._isFollowing = function () {
	    return (this._bitField & 67108864) === 67108864;
	};
	
	Promise.prototype._setLength = function (len) {
	    this._bitField = (this._bitField & -65536) |
	        (len & 65535);
	};
	
	Promise.prototype._setFulfilled = function () {
	    this._bitField = this._bitField | 33554432;
	    this._fireEvent("promiseFulfilled", this);
	};
	
	Promise.prototype._setRejected = function () {
	    this._bitField = this._bitField | 16777216;
	    this._fireEvent("promiseRejected", this);
	};
	
	Promise.prototype._setFollowing = function () {
	    this._bitField = this._bitField | 67108864;
	    this._fireEvent("promiseResolved", this);
	};
	
	Promise.prototype._setIsFinal = function () {
	    this._bitField = this._bitField | 4194304;
	};
	
	Promise.prototype._isFinal = function () {
	    return (this._bitField & 4194304) > 0;
	};
	
	Promise.prototype._unsetCancelled = function() {
	    this._bitField = this._bitField & (~65536);
	};
	
	Promise.prototype._setCancelled = function() {
	    this._bitField = this._bitField | 65536;
	    this._fireEvent("promiseCancelled", this);
	};
	
	Promise.prototype._setWillBeCancelled = function() {
	    this._bitField = this._bitField | 8388608;
	};
	
	Promise.prototype._setAsyncGuaranteed = function() {
	    if (async.hasCustomScheduler()) return;
	    this._bitField = this._bitField | 134217728;
	};
	
	Promise.prototype._receiverAt = function (index) {
	    var ret = index === 0 ? this._receiver0 : this[
	            index * 4 - 4 + 3];
	    if (ret === UNDEFINED_BINDING) {
	        return undefined;
	    } else if (ret === undefined && this._isBound()) {
	        return this._boundValue();
	    }
	    return ret;
	};
	
	Promise.prototype._promiseAt = function (index) {
	    return this[
	            index * 4 - 4 + 2];
	};
	
	Promise.prototype._fulfillmentHandlerAt = function (index) {
	    return this[
	            index * 4 - 4 + 0];
	};
	
	Promise.prototype._rejectionHandlerAt = function (index) {
	    return this[
	            index * 4 - 4 + 1];
	};
	
	Promise.prototype._boundValue = function() {};
	
	Promise.prototype._migrateCallback0 = function (follower) {
	    var bitField = follower._bitField;
	    var fulfill = follower._fulfillmentHandler0;
	    var reject = follower._rejectionHandler0;
	    var promise = follower._promise0;
	    var receiver = follower._receiverAt(0);
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, promise, receiver, null);
	};
	
	Promise.prototype._migrateCallbackAt = function (follower, index) {
	    var fulfill = follower._fulfillmentHandlerAt(index);
	    var reject = follower._rejectionHandlerAt(index);
	    var promise = follower._promiseAt(index);
	    var receiver = follower._receiverAt(index);
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, promise, receiver, null);
	};
	
	Promise.prototype._addCallbacks = function (
	    fulfill,
	    reject,
	    promise,
	    receiver,
	    domain
	) {
	    var index = this._length();
	
	    if (index >= 65535 - 4) {
	        index = 0;
	        this._setLength(0);
	    }
	
	    if (index === 0) {
	        this._promise0 = promise;
	        this._receiver0 = receiver;
	        if (typeof fulfill === "function") {
	            this._fulfillmentHandler0 =
	                domain === null ? fulfill : util.domainBind(domain, fulfill);
	        }
	        if (typeof reject === "function") {
	            this._rejectionHandler0 =
	                domain === null ? reject : util.domainBind(domain, reject);
	        }
	    } else {
	        var base = index * 4 - 4;
	        this[base + 2] = promise;
	        this[base + 3] = receiver;
	        if (typeof fulfill === "function") {
	            this[base + 0] =
	                domain === null ? fulfill : util.domainBind(domain, fulfill);
	        }
	        if (typeof reject === "function") {
	            this[base + 1] =
	                domain === null ? reject : util.domainBind(domain, reject);
	        }
	    }
	    this._setLength(index + 1);
	    return index;
	};
	
	Promise.prototype._proxy = function (proxyable, arg) {
	    this._addCallbacks(undefined, undefined, arg, proxyable, null);
	};
	
	Promise.prototype._resolveCallback = function(value, shouldBind) {
	    if (((this._bitField & 117506048) !== 0)) return;
	    if (value === this)
	        return this._rejectCallback(makeSelfResolutionError(), false);
	    var maybePromise = tryConvertToPromise(value, this);
	    if (!(maybePromise instanceof Promise)) return this._fulfill(value);
	
	    if (shouldBind) this._propagateFrom(maybePromise, 2);
	
	    var promise = maybePromise._target();
	
	    if (promise === this) {
	        this._reject(makeSelfResolutionError());
	        return;
	    }
	
	    var bitField = promise._bitField;
	    if (((bitField & 50397184) === 0)) {
	        var len = this._length();
	        if (len > 0) promise._migrateCallback0(this);
	        for (var i = 1; i < len; ++i) {
	            promise._migrateCallbackAt(this, i);
	        }
	        this._setFollowing();
	        this._setLength(0);
	        this._setFollowee(promise);
	    } else if (((bitField & 33554432) !== 0)) {
	        this._fulfill(promise._value());
	    } else if (((bitField & 16777216) !== 0)) {
	        this._reject(promise._reason());
	    } else {
	        var reason = new CancellationError("late cancellation observer");
	        promise._attachExtraTrace(reason);
	        this._reject(reason);
	    }
	};
	
	Promise.prototype._rejectCallback =
	function(reason, synchronous, ignoreNonErrorWarnings) {
	    var trace = util.ensureErrorObject(reason);
	    var hasStack = trace === reason;
	    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
	        var message = "a promise was rejected with a non-error: " +
	            util.classString(reason);
	        this._warn(message, true);
	    }
	    this._attachExtraTrace(trace, synchronous ? hasStack : false);
	    this._reject(reason);
	};
	
	Promise.prototype._resolveFromExecutor = function (executor) {
	    if (executor === INTERNAL) return;
	    var promise = this;
	    this._captureStackTrace();
	    this._pushContext();
	    var synchronous = true;
	    var r = this._execute(executor, function(value) {
	        promise._resolveCallback(value);
	    }, function (reason) {
	        promise._rejectCallback(reason, synchronous);
	    });
	    synchronous = false;
	    this._popContext();
	
	    if (r !== undefined) {
	        promise._rejectCallback(r, true);
	    }
	};
	
	Promise.prototype._settlePromiseFromHandler = function (
	    handler, receiver, value, promise
	) {
	    var bitField = promise._bitField;
	    if (((bitField & 65536) !== 0)) return;
	    promise._pushContext();
	    var x;
	    if (receiver === APPLY) {
	        if (!value || typeof value.length !== "number") {
	            x = errorObj;
	            x.e = new TypeError("cannot .spread() a non-array: " +
	                                    util.classString(value));
	        } else {
	            x = tryCatch(handler).apply(this._boundValue(), value);
	        }
	    } else {
	        x = tryCatch(handler).call(receiver, value);
	    }
	    var promiseCreated = promise._popContext();
	    bitField = promise._bitField;
	    if (((bitField & 65536) !== 0)) return;
	
	    if (x === NEXT_FILTER) {
	        promise._reject(value);
	    } else if (x === errorObj) {
	        promise._rejectCallback(x.e, false);
	    } else {
	        debug.checkForgottenReturns(x, promiseCreated, "",  promise, this);
	        promise._resolveCallback(x);
	    }
	};
	
	Promise.prototype._target = function() {
	    var ret = this;
	    while (ret._isFollowing()) ret = ret._followee();
	    return ret;
	};
	
	Promise.prototype._followee = function() {
	    return this._rejectionHandler0;
	};
	
	Promise.prototype._setFollowee = function(promise) {
	    this._rejectionHandler0 = promise;
	};
	
	Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
	    var isPromise = promise instanceof Promise;
	    var bitField = this._bitField;
	    var asyncGuaranteed = ((bitField & 134217728) !== 0);
	    if (((bitField & 65536) !== 0)) {
	        if (isPromise) promise._invokeInternalOnCancel();
	
	        if (receiver instanceof PassThroughHandlerContext &&
	            receiver.isFinallyHandler()) {
	            receiver.cancelPromise = promise;
	            if (tryCatch(handler).call(receiver, value) === errorObj) {
	                promise._reject(errorObj.e);
	            }
	        } else if (handler === reflectHandler) {
	            promise._fulfill(reflectHandler.call(receiver));
	        } else if (receiver instanceof Proxyable) {
	            receiver._promiseCancelled(promise);
	        } else if (isPromise || promise instanceof PromiseArray) {
	            promise._cancel();
	        } else {
	            receiver.cancel();
	        }
	    } else if (typeof handler === "function") {
	        if (!isPromise) {
	            handler.call(receiver, value, promise);
	        } else {
	            if (asyncGuaranteed) promise._setAsyncGuaranteed();
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (receiver instanceof Proxyable) {
	        if (!receiver._isResolved()) {
	            if (((bitField & 33554432) !== 0)) {
	                receiver._promiseFulfilled(value, promise);
	            } else {
	                receiver._promiseRejected(value, promise);
	            }
	        }
	    } else if (isPromise) {
	        if (asyncGuaranteed) promise._setAsyncGuaranteed();
	        if (((bitField & 33554432) !== 0)) {
	            promise._fulfill(value);
	        } else {
	            promise._reject(value);
	        }
	    }
	};
	
	Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
	    var handler = ctx.handler;
	    var promise = ctx.promise;
	    var receiver = ctx.receiver;
	    var value = ctx.value;
	    if (typeof handler === "function") {
	        if (!(promise instanceof Promise)) {
	            handler.call(receiver, value, promise);
	        } else {
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (promise instanceof Promise) {
	        promise._reject(value);
	    }
	};
	
	Promise.prototype._settlePromiseCtx = function(ctx) {
	    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
	};
	
	Promise.prototype._settlePromise0 = function(handler, value, bitField) {
	    var promise = this._promise0;
	    var receiver = this._receiverAt(0);
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._settlePromise(promise, handler, receiver, value);
	};
	
	Promise.prototype._clearCallbackDataAtIndex = function(index) {
	    var base = index * 4 - 4;
	    this[base + 2] =
	    this[base + 3] =
	    this[base + 0] =
	    this[base + 1] = undefined;
	};
	
	Promise.prototype._fulfill = function (value) {
	    var bitField = this._bitField;
	    if (((bitField & 117506048) >>> 16)) return;
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._reject(err);
	    }
	    this._setFulfilled();
	    this._rejectionHandler0 = value;
	
	    if ((bitField & 65535) > 0) {
	        if (((bitField & 134217728) !== 0)) {
	            this._settlePromises();
	        } else {
	            async.settlePromises(this);
	        }
	    }
	};
	
	Promise.prototype._reject = function (reason) {
	    var bitField = this._bitField;
	    if (((bitField & 117506048) >>> 16)) return;
	    this._setRejected();
	    this._fulfillmentHandler0 = reason;
	
	    if (this._isFinal()) {
	        return async.fatalError(reason, util.isNode);
	    }
	
	    if ((bitField & 65535) > 0) {
	        async.settlePromises(this);
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};
	
	Promise.prototype._fulfillPromises = function (len, value) {
	    for (var i = 1; i < len; i++) {
	        var handler = this._fulfillmentHandlerAt(i);
	        var promise = this._promiseAt(i);
	        var receiver = this._receiverAt(i);
	        this._clearCallbackDataAtIndex(i);
	        this._settlePromise(promise, handler, receiver, value);
	    }
	};
	
	Promise.prototype._rejectPromises = function (len, reason) {
	    for (var i = 1; i < len; i++) {
	        var handler = this._rejectionHandlerAt(i);
	        var promise = this._promiseAt(i);
	        var receiver = this._receiverAt(i);
	        this._clearCallbackDataAtIndex(i);
	        this._settlePromise(promise, handler, receiver, reason);
	    }
	};
	
	Promise.prototype._settlePromises = function () {
	    var bitField = this._bitField;
	    var len = (bitField & 65535);
	
	    if (len > 0) {
	        if (((bitField & 16842752) !== 0)) {
	            var reason = this._fulfillmentHandler0;
	            this._settlePromise0(this._rejectionHandler0, reason, bitField);
	            this._rejectPromises(len, reason);
	        } else {
	            var value = this._rejectionHandler0;
	            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
	            this._fulfillPromises(len, value);
	        }
	        this._setLength(0);
	    }
	    this._clearCancellationData();
	};
	
	Promise.prototype._settledValue = function() {
	    var bitField = this._bitField;
	    if (((bitField & 33554432) !== 0)) {
	        return this._rejectionHandler0;
	    } else if (((bitField & 16777216) !== 0)) {
	        return this._fulfillmentHandler0;
	    }
	};
	
	function deferResolve(v) {this.promise._resolveCallback(v);}
	function deferReject(v) {this.promise._rejectCallback(v, false);}
	
	Promise.defer = Promise.pending = function() {
	    debug.deprecated("Promise.defer", "new Promise");
	    var promise = new Promise(INTERNAL);
	    return {
	        promise: promise,
	        resolve: deferResolve,
	        reject: deferReject
	    };
	};
	
	util.notEnumerableProp(Promise,
	                       "_makeSelfResolutionError",
	                       makeSelfResolutionError);
	
	__webpack_require__(137)(Promise, INTERNAL, tryConvertToPromise, apiRejection,
	    debug);
	__webpack_require__(138)(Promise, INTERNAL, tryConvertToPromise, debug);
	__webpack_require__(139)(Promise, PromiseArray, apiRejection, debug);
	__webpack_require__(140)(Promise);
	__webpack_require__(141)(Promise);
	__webpack_require__(142)(
	    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
	Promise.Promise = Promise;
	Promise.version = "3.5.0";
	__webpack_require__(143)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
	__webpack_require__(144)(Promise);
	__webpack_require__(145)(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
	__webpack_require__(146)(Promise, INTERNAL, debug);
	__webpack_require__(147)(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
	__webpack_require__(148)(Promise);
	__webpack_require__(149)(Promise, INTERNAL);
	__webpack_require__(150)(Promise, PromiseArray, tryConvertToPromise, apiRejection);
	__webpack_require__(151)(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	__webpack_require__(152)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
	__webpack_require__(153)(Promise, PromiseArray, debug);
	__webpack_require__(154)(Promise, PromiseArray, apiRejection);
	__webpack_require__(155)(Promise, INTERNAL);
	__webpack_require__(156)(Promise, INTERNAL);
	__webpack_require__(157)(Promise);
	                                                         
	    util.toFastProperties(Promise);                                          
	    util.toFastProperties(Promise.prototype);                                
	    function fillTypes(value) {                                              
	        var p = new Promise(INTERNAL);                                       
	        p._fulfillmentHandler0 = value;                                      
	        p._rejectionHandler0 = value;                                        
	        p._promise0 = value;                                                 
	        p._receiver0 = value;                                                
	    }                                                                        
	    // Complete slack tracking, opt out of field-type tracking and           
	    // stabilize map                                                         
	    fillTypes({a: 1});                                                       
	    fillTypes({b: 2});                                                       
	    fillTypes({c: 3});                                                       
	    fillTypes(1);                                                            
	    fillTypes(function(){});                                                 
	    fillTypes(undefined);                                                    
	    fillTypes(false);                                                        
	    fillTypes(new Promise(INTERNAL));                                        
	    debug.setBounds(Async.firstLineError, util.lastLineError);               
	    return Promise;                                                          
	
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ }),
/* 121 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {"use strict";
	var es5 = __webpack_require__(123);
	var canEvaluate = typeof navigator == "undefined";
	
	var errorObj = {e: {}};
	var tryCatchTarget;
	var globalObject = typeof self !== "undefined" ? self :
	    typeof window !== "undefined" ? window :
	    typeof global !== "undefined" ? global :
	    this !== undefined ? this : null;
	
	function tryCatcher() {
	    try {
	        var target = tryCatchTarget;
	        tryCatchTarget = null;
	        return target.apply(this, arguments);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	
	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;
	
	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};
	
	
	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";
	
	}
	
	function isObject(value) {
	    return typeof value === "function" ||
	           typeof value === "object" && value !== null;
	}
	
	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;
	
	    return new Error(safeToString(maybeError));
	}
	
	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}
	
	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);
	
	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
	    }
	}
	
	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}
	
	function thrower(r) {
	    throw r;
	}
	
	var inheritedDataKeys = (function() {
	    var excludedPrototypes = [
	        Array.prototype,
	        Object.prototype,
	        Function.prototype
	    ];
	
	    var isExcludedProto = function(val) {
	        for (var i = 0; i < excludedPrototypes.length; ++i) {
	            if (excludedPrototypes[i] === val) {
	                return true;
	            }
	        }
	        return false;
	    };
	
	    if (es5.isES5) {
	        var getKeys = Object.getOwnPropertyNames;
	        return function(obj) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            while (obj != null && !isExcludedProto(obj)) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        var hasProp = {}.hasOwnProperty;
	        return function(obj) {
	            if (isExcludedProto(obj)) return [];
	            var ret = [];
	
	            /*jshint forin:false */
	            enumeration: for (var key in obj) {
	                if (hasProp.call(obj, key)) {
	                    ret.push(key);
	                } else {
	                    for (var i = 0; i < excludedPrototypes.length; ++i) {
	                        if (hasProp.call(excludedPrototypes[i], key)) {
	                            continue enumeration;
	                        }
	                    }
	                    ret.push(key);
	                }
	            }
	            return ret;
	        };
	    }
	
	})();
	
	var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.names(fn.prototype);
	
	            var hasMethods = es5.isES5 && keys.length > 1;
	            var hasMethodsOtherThanConstructor = keys.length > 0 &&
	                !(keys.length === 1 && keys[0] === "constructor");
	            var hasThisAssignmentAndStaticMethods =
	                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
	
	            if (hasMethods || hasMethodsOtherThanConstructor ||
	                hasThisAssignmentAndStaticMethods) {
	                return true;
	            }
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}
	
	function toFastProperties(obj) {
	    /*jshint -W027,-W055,-W031*/
	    function FakeConstructor() {}
	    FakeConstructor.prototype = obj;
	    var l = 8;
	    while (l--) new FakeConstructor();
	    return obj;
	    eval(obj);
	}
	
	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}
	
	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}
	
	function safeToString(obj) {
	    try {
	        return obj + "";
	    } catch (e) {
	        return "[no string representation]";
	    }
	}
	
	function isError(obj) {
	    return obj !== null &&
	           typeof obj === "object" &&
	           typeof obj.message === "string" &&
	           typeof obj.name === "string";
	}
	
	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}
	
	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
	        e["isOperational"] === true);
	}
	
	function canAttachTrace(obj) {
	    return isError(obj) && es5.propertyIsWritable(obj, "stack");
	}
	
	var ensureErrorObject = (function() {
	    if (!("stack" in new Error())) {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            try {throw new Error(safeToString(value));}
	            catch(err) {return err;}
	        };
	    } else {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            return new Error(safeToString(value));
	        };
	    }
	})();
	
	function classString(obj) {
	    return {}.toString.call(obj);
	}
	
	function copyDescriptors(from, to, filter) {
	    var keys = es5.names(from);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        if (filter(key)) {
	            try {
	                es5.defineProperty(to, key, es5.getDescriptor(from, key));
	            } catch (ignore) {}
	        }
	    }
	}
	
	var asArray = function(v) {
	    if (es5.isArray(v)) {
	        return v;
	    }
	    return null;
	};
	
	if (typeof Symbol !== "undefined" && Symbol.iterator) {
	    var ArrayFrom = typeof Array.from === "function" ? function(v) {
	        return Array.from(v);
	    } : function(v) {
	        var ret = [];
	        var it = v[Symbol.iterator]();
	        var itResult;
	        while (!((itResult = it.next()).done)) {
	            ret.push(itResult.value);
	        }
	        return ret;
	    };
	
	    asArray = function(v) {
	        if (es5.isArray(v)) {
	            return v;
	        } else if (v != null && typeof v[Symbol.iterator] === "function") {
	            return ArrayFrom(v);
	        }
	        return null;
	    };
	}
	
	var isNode = typeof process !== "undefined" &&
	        classString(process).toLowerCase() === "[object process]";
	
	var hasEnvVariables = typeof process !== "undefined" &&
	    typeof process.env !== "undefined";
	
	function env(key) {
	    return hasEnvVariables ? process.env[key] : undefined;
	}
	
	function getNativePromise() {
	    if (typeof Promise === "function") {
	        try {
	            var promise = new Promise(function(){});
	            if ({}.toString.call(promise) === "[object Promise]") {
	                return Promise;
	            }
	        } catch (e) {}
	    }
	}
	
	function domainBind(self, cb) {
	    return self.bind(cb);
	}
	
	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    asArray: asArray,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    isError: isError,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch: tryCatch,
	    inherits: inherits,
	    withAppended: withAppended,
	    maybeWrapAsError: maybeWrapAsError,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange,
	    toString: safeToString,
	    canAttachTrace: canAttachTrace,
	    ensureErrorObject: ensureErrorObject,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    classString: classString,
	    copyDescriptors: copyDescriptors,
	    hasDevTools: typeof chrome !== "undefined" && chrome &&
	                 typeof chrome.loadTimes === "function",
	    isNode: isNode,
	    hasEnvVariables: hasEnvVariables,
	    env: env,
	    global: globalObject,
	    getNativePromise: getNativePromise,
	    domainBind: domainBind
	};
	ret.isRecentNode = ret.isNode && (function() {
	    var version = process.versions.node.split(".").map(Number);
	    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
	})();
	
	if (ret.isNode) ret.toFastProperties(process);
	
	try {throw new Error(); } catch (e) {ret.lastLineError = e;}
	module.exports = ret;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(121)))

/***/ }),
/* 123 */
/***/ (function(module, exports) {

	var isES5 = (function(){
	    "use strict";
	    return this === undefined;
	})();
	
	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        getDescriptor: Object.getOwnPropertyDescriptor,
	        keys: Object.keys,
	        names: Object.getOwnPropertyNames,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5,
	        propertyIsWritable: function(obj, prop) {
	            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	            return !!(!descriptor || descriptor.writable || descriptor.set);
	        }
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;
	
	    var ObjectKeys = function (o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    };
	
	    var ObjectGetDescriptor = function(o, key) {
	        return {value: o[key]};
	    };
	
	    var ObjectDefineProperty = function (o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    };
	
	    var ObjectFreeze = function (obj) {
	        return obj;
	    };
	
	    var ObjectGetPrototypeOf = function (obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    };
	
	    var ArrayIsArray = function (obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    };
	
	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        names: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        getDescriptor: ObjectGetDescriptor,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5,
	        propertyIsWritable: function() {
	            return true;
	        }
	    };
	}


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	var firstLineError;
	try {throw new Error(); } catch (e) {firstLineError = e;}
	var schedule = __webpack_require__(125);
	var Queue = __webpack_require__(128);
	var util = __webpack_require__(122);
	
	function Async() {
	    this._customScheduler = false;
	    this._isTickUsed = false;
	    this._lateQueue = new Queue(16);
	    this._normalQueue = new Queue(16);
	    this._haveDrainedQueues = false;
	    this._trampolineEnabled = true;
	    var self = this;
	    this.drainQueues = function () {
	        self._drainQueues();
	    };
	    this._schedule = schedule;
	}
	
	Async.prototype.setScheduler = function(fn) {
	    var prev = this._schedule;
	    this._schedule = fn;
	    this._customScheduler = true;
	    return prev;
	};
	
	Async.prototype.hasCustomScheduler = function() {
	    return this._customScheduler;
	};
	
	Async.prototype.enableTrampoline = function() {
	    this._trampolineEnabled = true;
	};
	
	Async.prototype.disableTrampolineIfNecessary = function() {
	    if (util.hasDevTools) {
	        this._trampolineEnabled = false;
	    }
	};
	
	Async.prototype.haveItemsQueued = function () {
	    return this._isTickUsed || this._haveDrainedQueues;
	};
	
	
	Async.prototype.fatalError = function(e, isNode) {
	    if (isNode) {
	        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) +
	            "\n");
	        process.exit(2);
	    } else {
	        this.throwLater(e);
	    }
	};
	
	Async.prototype.throwLater = function(fn, arg) {
	    if (arguments.length === 1) {
	        arg = fn;
	        fn = function () { throw arg; };
	    }
	    if (typeof setTimeout !== "undefined") {
	        setTimeout(function() {
	            fn(arg);
	        }, 0);
	    } else try {
	        this._schedule(function() {
	            fn(arg);
	        });
	    } catch (e) {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	};
	
	function AsyncInvokeLater(fn, receiver, arg) {
	    this._lateQueue.push(fn, receiver, arg);
	    this._queueTick();
	}
	
	function AsyncInvoke(fn, receiver, arg) {
	    this._normalQueue.push(fn, receiver, arg);
	    this._queueTick();
	}
	
	function AsyncSettlePromises(promise) {
	    this._normalQueue._pushOne(promise);
	    this._queueTick();
	}
	
	if (!util.hasDevTools) {
	    Async.prototype.invokeLater = AsyncInvokeLater;
	    Async.prototype.invoke = AsyncInvoke;
	    Async.prototype.settlePromises = AsyncSettlePromises;
	} else {
	    Async.prototype.invokeLater = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvokeLater.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                setTimeout(function() {
	                    fn.call(receiver, arg);
	                }, 100);
	            });
	        }
	    };
	
	    Async.prototype.invoke = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvoke.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                fn.call(receiver, arg);
	            });
	        }
	    };
	
	    Async.prototype.settlePromises = function(promise) {
	        if (this._trampolineEnabled) {
	            AsyncSettlePromises.call(this, promise);
	        } else {
	            this._schedule(function() {
	                promise._settlePromises();
	            });
	        }
	    };
	}
	
	Async.prototype._drainQueue = function(queue) {
	    while (queue.length() > 0) {
	        var fn = queue.shift();
	        if (typeof fn !== "function") {
	            fn._settlePromises();
	            continue;
	        }
	        var receiver = queue.shift();
	        var arg = queue.shift();
	        fn.call(receiver, arg);
	    }
	};
	
	Async.prototype._drainQueues = function () {
	    this._drainQueue(this._normalQueue);
	    this._reset();
	    this._haveDrainedQueues = true;
	    this._drainQueue(this._lateQueue);
	};
	
	Async.prototype._queueTick = function () {
	    if (!this._isTickUsed) {
	        this._isTickUsed = true;
	        this._schedule(this.drainQueues);
	    }
	};
	
	Async.prototype._reset = function () {
	    this._isTickUsed = false;
	};
	
	module.exports = Async;
	module.exports.firstLineError = firstLineError;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process, setImmediate) {"use strict";
	var util = __webpack_require__(122);
	var schedule;
	var noAsyncScheduler = function() {
	    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	};
	var NativePromise = util.getNativePromise();
	if (util.isNode && typeof MutationObserver === "undefined") {
	    var GlobalSetImmediate = global.setImmediate;
	    var ProcessNextTick = process.nextTick;
	    schedule = util.isRecentNode
	                ? function(fn) { GlobalSetImmediate.call(global, fn); }
	                : function(fn) { ProcessNextTick.call(process, fn); };
	} else if (typeof NativePromise === "function" &&
	           typeof NativePromise.resolve === "function") {
	    var nativePromise = NativePromise.resolve();
	    schedule = function(fn) {
	        nativePromise.then(fn);
	    };
	} else if ((typeof MutationObserver !== "undefined") &&
	          !(typeof window !== "undefined" &&
	            window.navigator &&
	            (window.navigator.standalone || window.cordova))) {
	    schedule = (function() {
	        var div = document.createElement("div");
	        var opts = {attributes: true};
	        var toggleScheduled = false;
	        var div2 = document.createElement("div");
	        var o2 = new MutationObserver(function() {
	            div.classList.toggle("foo");
	            toggleScheduled = false;
	        });
	        o2.observe(div2, opts);
	
	        var scheduleToggle = function() {
	            if (toggleScheduled) return;
	            toggleScheduled = true;
	            div2.classList.toggle("foo");
	        };
	
	        return function schedule(fn) {
	            var o = new MutationObserver(function() {
	                o.disconnect();
	                fn();
	            });
	            o.observe(div, opts);
	            scheduleToggle();
	        };
	    })();
	} else if (typeof setImmediate !== "undefined") {
	    schedule = function (fn) {
	        setImmediate(fn);
	    };
	} else if (typeof setTimeout !== "undefined") {
	    schedule = function (fn) {
	        setTimeout(fn, 0);
	    };
	} else {
	    schedule = noAsyncScheduler;
	}
	module.exports = schedule;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(121), __webpack_require__(126).setImmediate))

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
	            (typeof self !== "undefined" && self) ||
	            window;
	var apply = Function.prototype.apply;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(scope, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// setimmediate attaches itself to the global object
	__webpack_require__(127);
	// On some exotic environments, it's not clear which object `setimmediate` was
	// able to install onto.  Search each possibility in the same order as the
	// `setimmediate` library.
	exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
	                       (typeof global !== "undefined" && global.setImmediate) ||
	                       (this && this.setImmediate);
	exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
	                         (typeof global !== "undefined" && global.clearImmediate) ||
	                         (this && this.clearImmediate);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
	    "use strict";
	
	    if (global.setImmediate) {
	        return;
	    }
	
	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;
	
	    function setImmediate(callback) {
	      // Callback can either be a function or a string
	      if (typeof callback !== "function") {
	        callback = new Function("" + callback);
	      }
	      // Copy function arguments
	      var args = new Array(arguments.length - 1);
	      for (var i = 0; i < args.length; i++) {
	          args[i] = arguments[i + 1];
	      }
	      // Store and register the task
	      var task = { callback: callback, args: args };
	      tasksByHandle[nextHandle] = task;
	      registerImmediate(nextHandle);
	      return nextHandle++;
	    }
	
	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }
	
	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	        case 0:
	            callback();
	            break;
	        case 1:
	            callback(args[0]);
	            break;
	        case 2:
	            callback(args[0], args[1]);
	            break;
	        case 3:
	            callback(args[0], args[1], args[2]);
	            break;
	        default:
	            callback.apply(undefined, args);
	            break;
	        }
	    }
	
	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }
	
	    function installNextTickImplementation() {
	        registerImmediate = function(handle) {
	            process.nextTick(function () { runIfPresent(handle); });
	        };
	    }
	
	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function() {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }
	
	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	
	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function(event) {
	            if (event.source === global &&
	                typeof event.data === "string" &&
	                event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	
	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }
	
	        registerImmediate = function(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }
	
	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function(event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };
	
	        registerImmediate = function(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }
	
	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }
	
	    function installSetTimeoutImplementation() {
	        registerImmediate = function(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }
	
	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
	
	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();
	
	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();
	
	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();
	
	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 6–8
	        installReadyStateChangeImplementation();
	
	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }
	
	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(121)))

/***/ }),
/* 128 */
/***/ (function(module, exports) {

	"use strict";
	function arrayMove(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	        src[j + srcIndex] = void 0;
	    }
	}
	
	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	}
	
	Queue.prototype._willBeOverCapacity = function (size) {
	    return this._capacity < size;
	};
	
	Queue.prototype._pushOne = function (arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};
	
	Queue.prototype.push = function (fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};
	
	Queue.prototype.shift = function () {
	    var front = this._front,
	        ret = this[front];
	
	    this[front] = undefined;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};
	
	Queue.prototype.length = function () {
	    return this._length;
	};
	
	Queue.prototype._checkCapacity = function (size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 1);
	    }
	};
	
	Queue.prototype._resizeTo = function (capacity) {
	    var oldCapacity = this._capacity;
	    this._capacity = capacity;
	    var front = this._front;
	    var length = this._length;
	    var moveItemsCount = (front + length) & (oldCapacity - 1);
	    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
	};
	
	module.exports = Queue;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var es5 = __webpack_require__(123);
	var Objectfreeze = es5.freeze;
	var util = __webpack_require__(122);
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;
	
	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        notEnumerableProp(this, "message",
	            typeof message === "string" ? message : defaultMessage);
	        notEnumerableProp(this, "name", nameProperty);
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            Error.call(this);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}
	
	var _TypeError, _RangeError;
	var Warning = subError("Warning", "warning");
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}
	
	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
	
	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}
	
	es5.defineProperty(AggregateError.prototype, "length", {
	    value: 0,
	    configurable: false,
	    writable: true,
	    enumerable: true
	});
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};
	
	function OperationalError(message) {
	    if (!(this instanceof OperationalError))
	        return new OperationalError(message);
	    notEnumerableProp(this, "name", "OperationalError");
	    notEnumerableProp(this, "message", message);
	    this.cause = message;
	    this["isOperational"] = true;
	
	    if (message instanceof Error) {
	        notEnumerableProp(this, "message", message.message);
	        notEnumerableProp(this, "stack", message.stack);
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }
	
	}
	inherits(OperationalError, Error);
	
	var errorTypes = Error["__BluebirdErrorTypes__"];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
	        value: errorTypes,
	        writable: false,
	        enumerable: false,
	        configurable: false
	    });
	}
	
	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    Warning: Warning
	};


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = __webpack_require__(122);
	var errorObj = util.errorObj;
	var isObject = util.isObject;
	
	function tryConvertToPromise(obj, context) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) return obj;
	        var then = getThen(obj);
	        if (then === errorObj) {
	            if (context) context._pushContext();
	            var ret = Promise.reject(then.e);
	            if (context) context._popContext();
	            return ret;
	        } else if (typeof then === "function") {
	            if (isAnyBluebirdPromise(obj)) {
	                var ret = new Promise(INTERNAL);
	                obj._then(
	                    ret._fulfill,
	                    ret._reject,
	                    undefined,
	                    ret,
	                    null
	                );
	                return ret;
	            }
	            return doThenable(obj, then, context);
	        }
	    }
	    return obj;
	}
	
	function doGetThen(obj) {
	    return obj.then;
	}
	
	function getThen(obj) {
	    try {
	        return doGetThen(obj);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	
	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    try {
	        return hasProp.call(obj, "_promise0");
	    } catch (e) {
	        return false;
	    }
	}
	
	function doThenable(x, then, context) {
	    var promise = new Promise(INTERNAL);
	    var ret = promise;
	    if (context) context._pushContext();
	    promise._captureStackTrace();
	    if (context) context._popContext();
	    var synchronous = true;
	    var result = util.tryCatch(then).call(x, resolve, reject);
	    synchronous = false;
	
	    if (promise && result === errorObj) {
	        promise._rejectCallback(result.e, true, true);
	        promise = null;
	    }
	
	    function resolve(value) {
	        if (!promise) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }
	
	    function reject(reason) {
	        if (!promise) return;
	        promise._rejectCallback(reason, synchronous, true);
	        promise = null;
	    }
	    return ret;
	}
	
	return tryConvertToPromise;
	};


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise,
	    apiRejection, Proxyable) {
	var util = __webpack_require__(122);
	var isArray = util.isArray;
	
	function toResolutionValue(val) {
	    switch(val) {
	    case -2: return [];
	    case -3: return {};
	    case -6: return new Map();
	    }
	}
	
	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    if (values instanceof Promise) {
	        promise._propagateFrom(values, 3);
	    }
	    promise._setOnCancel(this);
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(undefined, -2);
	}
	util.inherits(PromiseArray, Proxyable);
	
	PromiseArray.prototype.length = function () {
	    return this._length;
	};
	
	PromiseArray.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
	    var values = tryConvertToPromise(this._values, this._promise);
	    if (values instanceof Promise) {
	        values = values._target();
	        var bitField = values._bitField;
	        ;
	        this._values = values;
	
	        if (((bitField & 50397184) === 0)) {
	            this._promise._setAsyncGuaranteed();
	            return values._then(
	                init,
	                this._reject,
	                undefined,
	                this,
	                resolveValueIfEmpty
	           );
	        } else if (((bitField & 33554432) !== 0)) {
	            values = values._value();
	        } else if (((bitField & 16777216) !== 0)) {
	            return this._reject(values._reason());
	        } else {
	            return this._cancel();
	        }
	    }
	    values = util.asArray(values);
	    if (values === null) {
	        var err = apiRejection(
	            "expecting an array or an iterable object but got " + util.classString(values)).reason();
	        this._promise._rejectCallback(err, false);
	        return;
	    }
	
	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    this._iterate(values);
	};
	
	PromiseArray.prototype._iterate = function(values) {
	    var len = this.getActualLength(values.length);
	    this._length = len;
	    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
	    var result = this._promise;
	    var isResolved = false;
	    var bitField = null;
	    for (var i = 0; i < len; ++i) {
	        var maybePromise = tryConvertToPromise(values[i], result);
	
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            bitField = maybePromise._bitField;
	        } else {
	            bitField = null;
	        }
	
	        if (isResolved) {
	            if (bitField !== null) {
	                maybePromise.suppressUnhandledRejections();
	            }
	        } else if (bitField !== null) {
	            if (((bitField & 50397184) === 0)) {
	                maybePromise._proxy(this, i);
	                this._values[i] = maybePromise;
	            } else if (((bitField & 33554432) !== 0)) {
	                isResolved = this._promiseFulfilled(maybePromise._value(), i);
	            } else if (((bitField & 16777216) !== 0)) {
	                isResolved = this._promiseRejected(maybePromise._reason(), i);
	            } else {
	                isResolved = this._promiseCancelled(i);
	            }
	        } else {
	            isResolved = this._promiseFulfilled(maybePromise, i);
	        }
	    }
	    if (!isResolved) result._setAsyncGuaranteed();
	};
	
	PromiseArray.prototype._isResolved = function () {
	    return this._values === null;
	};
	
	PromiseArray.prototype._resolve = function (value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};
	
	PromiseArray.prototype._cancel = function() {
	    if (this._isResolved() || !this._promise._isCancellable()) return;
	    this._values = null;
	    this._promise._cancel();
	};
	
	PromiseArray.prototype._reject = function (reason) {
	    this._values = null;
	    this._promise._rejectCallback(reason, false);
	};
	
	PromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	        return true;
	    }
	    return false;
	};
	
	PromiseArray.prototype._promiseCancelled = function() {
	    this._cancel();
	    return true;
	};
	
	PromiseArray.prototype._promiseRejected = function (reason) {
	    this._totalResolved++;
	    this._reject(reason);
	    return true;
	};
	
	PromiseArray.prototype._resultCancelled = function() {
	    if (this._isResolved()) return;
	    var values = this._values;
	    this._cancel();
	    if (values instanceof Promise) {
	        values.cancel();
	    } else {
	        for (var i = 0; i < values.length; ++i) {
	            if (values[i] instanceof Promise) {
	                values[i].cancel();
	            }
	        }
	    }
	};
	
	PromiseArray.prototype.shouldCopyValues = function () {
	    return true;
	};
	
	PromiseArray.prototype.getActualLength = function (len) {
	    return len;
	};
	
	return PromiseArray;
	};


/***/ }),
/* 132 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = function(Promise) {
	var longStackTraces = false;
	var contextStack = [];
	
	Promise.prototype._promiseCreated = function() {};
	Promise.prototype._pushContext = function() {};
	Promise.prototype._popContext = function() {return null;};
	Promise._peekContext = Promise.prototype._peekContext = function() {};
	
	function Context() {
	    this._trace = new Context.CapturedTrace(peekContext());
	}
	Context.prototype._pushContext = function () {
	    if (this._trace !== undefined) {
	        this._trace._promiseCreated = null;
	        contextStack.push(this._trace);
	    }
	};
	
	Context.prototype._popContext = function () {
	    if (this._trace !== undefined) {
	        var trace = contextStack.pop();
	        var ret = trace._promiseCreated;
	        trace._promiseCreated = null;
	        return ret;
	    }
	    return null;
	};
	
	function createContext() {
	    if (longStackTraces) return new Context();
	}
	
	function peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return undefined;
	}
	Context.CapturedTrace = null;
	Context.create = createContext;
	Context.deactivateLongStackTraces = function() {};
	Context.activateLongStackTraces = function() {
	    var Promise_pushContext = Promise.prototype._pushContext;
	    var Promise_popContext = Promise.prototype._popContext;
	    var Promise_PeekContext = Promise._peekContext;
	    var Promise_peekContext = Promise.prototype._peekContext;
	    var Promise_promiseCreated = Promise.prototype._promiseCreated;
	    Context.deactivateLongStackTraces = function() {
	        Promise.prototype._pushContext = Promise_pushContext;
	        Promise.prototype._popContext = Promise_popContext;
	        Promise._peekContext = Promise_PeekContext;
	        Promise.prototype._peekContext = Promise_peekContext;
	        Promise.prototype._promiseCreated = Promise_promiseCreated;
	        longStackTraces = false;
	    };
	    longStackTraces = true;
	    Promise.prototype._pushContext = Context.prototype._pushContext;
	    Promise.prototype._popContext = Context.prototype._popContext;
	    Promise._peekContext = Promise.prototype._peekContext = peekContext;
	    Promise.prototype._promiseCreated = function() {
	        var ctx = this._peekContext();
	        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
	    };
	};
	return Context;
	};


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	module.exports = function(Promise, Context) {
	var getDomain = Promise._getDomain;
	var async = Promise._async;
	var Warning = __webpack_require__(129).Warning;
	var util = __webpack_require__(122);
	var canAttachTrace = util.canAttachTrace;
	var unhandledRejectionHandled;
	var possiblyUnhandledRejection;
	var bluebirdFramePattern =
	    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
	var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
	var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
	var stackFramePattern = null;
	var formatStack = null;
	var indentStackFrames = false;
	var printWarning;
	var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 &&
	                        (false ||
	                         util.env("BLUEBIRD_DEBUG") ||
	                         util.env("NODE_ENV") === "development"));
	
	var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 &&
	    (debugging || util.env("BLUEBIRD_WARNINGS")));
	
	var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 &&
	    (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
	
	var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 &&
	    (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
	
	Promise.prototype.suppressUnhandledRejections = function() {
	    var target = this._target();
	    target._bitField = ((target._bitField & (~1048576)) |
	                      524288);
	};
	
	Promise.prototype._ensurePossibleRejectionHandled = function () {
	    if ((this._bitField & 524288) !== 0) return;
	    this._setRejectionIsUnhandled();
	    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
	};
	
	Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
	    fireRejectionEvent("rejectionHandled",
	                                  unhandledRejectionHandled, undefined, this);
	};
	
	Promise.prototype._setReturnedNonUndefined = function() {
	    this._bitField = this._bitField | 268435456;
	};
	
	Promise.prototype._returnedNonUndefined = function() {
	    return (this._bitField & 268435456) !== 0;
	};
	
	Promise.prototype._notifyUnhandledRejection = function () {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._settledValue();
	        this._setUnhandledRejectionIsNotified();
	        fireRejectionEvent("unhandledRejection",
	                                      possiblyUnhandledRejection, reason, this);
	    }
	};
	
	Promise.prototype._setUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField | 262144;
	};
	
	Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField & (~262144);
	};
	
	Promise.prototype._isUnhandledRejectionNotified = function () {
	    return (this._bitField & 262144) > 0;
	};
	
	Promise.prototype._setRejectionIsUnhandled = function () {
	    this._bitField = this._bitField | 1048576;
	};
	
	Promise.prototype._unsetRejectionIsUnhandled = function () {
	    this._bitField = this._bitField & (~1048576);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};
	
	Promise.prototype._isRejectionUnhandled = function () {
	    return (this._bitField & 1048576) > 0;
	};
	
	Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
	    return warn(message, shouldUseOwnTrace, promise || this);
	};
	
	Promise.onPossiblyUnhandledRejection = function (fn) {
	    var domain = getDomain();
	    possiblyUnhandledRejection =
	        typeof fn === "function" ? (domain === null ?
	                                            fn : util.domainBind(domain, fn))
	                                 : undefined;
	};
	
	Promise.onUnhandledRejectionHandled = function (fn) {
	    var domain = getDomain();
	    unhandledRejectionHandled =
	        typeof fn === "function" ? (domain === null ?
	                                            fn : util.domainBind(domain, fn))
	                                 : undefined;
	};
	
	var disableLongStackTraces = function() {};
	Promise.longStackTraces = function () {
	    if (async.haveItemsQueued() && !config.longStackTraces) {
	        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    if (!config.longStackTraces && longStackTracesIsSupported()) {
	        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
	        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
	        config.longStackTraces = true;
	        disableLongStackTraces = function() {
	            if (async.haveItemsQueued() && !config.longStackTraces) {
	                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	            }
	            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
	            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
	            Context.deactivateLongStackTraces();
	            async.enableTrampoline();
	            config.longStackTraces = false;
	        };
	        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
	        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
	        Context.activateLongStackTraces();
	        async.disableTrampolineIfNecessary();
	    }
	};
	
	Promise.hasLongStackTraces = function () {
	    return config.longStackTraces && longStackTracesIsSupported();
	};
	
	var fireDomEvent = (function() {
	    try {
	        if (typeof CustomEvent === "function") {
	            var event = new CustomEvent("CustomEvent");
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = new CustomEvent(name.toLowerCase(), {
	                    detail: event,
	                    cancelable: true
	                });
	                return !util.global.dispatchEvent(domEvent);
	            };
	        } else if (typeof Event === "function") {
	            var event = new Event("CustomEvent");
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = new Event(name.toLowerCase(), {
	                    cancelable: true
	                });
	                domEvent.detail = event;
	                return !util.global.dispatchEvent(domEvent);
	            };
	        } else {
	            var event = document.createEvent("CustomEvent");
	            event.initCustomEvent("testingtheevent", false, true, {});
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = document.createEvent("CustomEvent");
	                domEvent.initCustomEvent(name.toLowerCase(), false, true,
	                    event);
	                return !util.global.dispatchEvent(domEvent);
	            };
	        }
	    } catch (e) {}
	    return function() {
	        return false;
	    };
	})();
	
	var fireGlobalEvent = (function() {
	    if (util.isNode) {
	        return function() {
	            return process.emit.apply(process, arguments);
	        };
	    } else {
	        if (!util.global) {
	            return function() {
	                return false;
	            };
	        }
	        return function(name) {
	            var methodName = "on" + name.toLowerCase();
	            var method = util.global[methodName];
	            if (!method) return false;
	            method.apply(util.global, [].slice.call(arguments, 1));
	            return true;
	        };
	    }
	})();
	
	function generatePromiseLifecycleEventObject(name, promise) {
	    return {promise: promise};
	}
	
	var eventToObjectGenerator = {
	    promiseCreated: generatePromiseLifecycleEventObject,
	    promiseFulfilled: generatePromiseLifecycleEventObject,
	    promiseRejected: generatePromiseLifecycleEventObject,
	    promiseResolved: generatePromiseLifecycleEventObject,
	    promiseCancelled: generatePromiseLifecycleEventObject,
	    promiseChained: function(name, promise, child) {
	        return {promise: promise, child: child};
	    },
	    warning: function(name, warning) {
	        return {warning: warning};
	    },
	    unhandledRejection: function (name, reason, promise) {
	        return {reason: reason, promise: promise};
	    },
	    rejectionHandled: generatePromiseLifecycleEventObject
	};
	
	var activeFireEvent = function (name) {
	    var globalEventFired = false;
	    try {
	        globalEventFired = fireGlobalEvent.apply(null, arguments);
	    } catch (e) {
	        async.throwLater(e);
	        globalEventFired = true;
	    }
	
	    var domEventFired = false;
	    try {
	        domEventFired = fireDomEvent(name,
	                    eventToObjectGenerator[name].apply(null, arguments));
	    } catch (e) {
	        async.throwLater(e);
	        domEventFired = true;
	    }
	
	    return domEventFired || globalEventFired;
	};
	
	Promise.config = function(opts) {
	    opts = Object(opts);
	    if ("longStackTraces" in opts) {
	        if (opts.longStackTraces) {
	            Promise.longStackTraces();
	        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
	            disableLongStackTraces();
	        }
	    }
	    if ("warnings" in opts) {
	        var warningsOption = opts.warnings;
	        config.warnings = !!warningsOption;
	        wForgottenReturn = config.warnings;
	
	        if (util.isObject(warningsOption)) {
	            if ("wForgottenReturn" in warningsOption) {
	                wForgottenReturn = !!warningsOption.wForgottenReturn;
	            }
	        }
	    }
	    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
	        if (async.haveItemsQueued()) {
	            throw new Error(
	                "cannot enable cancellation after promises are in use");
	        }
	        Promise.prototype._clearCancellationData =
	            cancellationClearCancellationData;
	        Promise.prototype._propagateFrom = cancellationPropagateFrom;
	        Promise.prototype._onCancel = cancellationOnCancel;
	        Promise.prototype._setOnCancel = cancellationSetOnCancel;
	        Promise.prototype._attachCancellationCallback =
	            cancellationAttachCancellationCallback;
	        Promise.prototype._execute = cancellationExecute;
	        propagateFromFunction = cancellationPropagateFrom;
	        config.cancellation = true;
	    }
	    if ("monitoring" in opts) {
	        if (opts.monitoring && !config.monitoring) {
	            config.monitoring = true;
	            Promise.prototype._fireEvent = activeFireEvent;
	        } else if (!opts.monitoring && config.monitoring) {
	            config.monitoring = false;
	            Promise.prototype._fireEvent = defaultFireEvent;
	        }
	    }
	    return Promise;
	};
	
	function defaultFireEvent() { return false; }
	
	Promise.prototype._fireEvent = defaultFireEvent;
	Promise.prototype._execute = function(executor, resolve, reject) {
	    try {
	        executor(resolve, reject);
	    } catch (e) {
	        return e;
	    }
	};
	Promise.prototype._onCancel = function () {};
	Promise.prototype._setOnCancel = function (handler) { ; };
	Promise.prototype._attachCancellationCallback = function(onCancel) {
	    ;
	};
	Promise.prototype._captureStackTrace = function () {};
	Promise.prototype._attachExtraTrace = function () {};
	Promise.prototype._clearCancellationData = function() {};
	Promise.prototype._propagateFrom = function (parent, flags) {
	    ;
	    ;
	};
	
	function cancellationExecute(executor, resolve, reject) {
	    var promise = this;
	    try {
	        executor(resolve, reject, function(onCancel) {
	            if (typeof onCancel !== "function") {
	                throw new TypeError("onCancel must be a function, got: " +
	                                    util.toString(onCancel));
	            }
	            promise._attachCancellationCallback(onCancel);
	        });
	    } catch (e) {
	        return e;
	    }
	}
	
	function cancellationAttachCancellationCallback(onCancel) {
	    if (!this._isCancellable()) return this;
	
	    var previousOnCancel = this._onCancel();
	    if (previousOnCancel !== undefined) {
	        if (util.isArray(previousOnCancel)) {
	            previousOnCancel.push(onCancel);
	        } else {
	            this._setOnCancel([previousOnCancel, onCancel]);
	        }
	    } else {
	        this._setOnCancel(onCancel);
	    }
	}
	
	function cancellationOnCancel() {
	    return this._onCancelField;
	}
	
	function cancellationSetOnCancel(onCancel) {
	    this._onCancelField = onCancel;
	}
	
	function cancellationClearCancellationData() {
	    this._cancellationParent = undefined;
	    this._onCancelField = undefined;
	}
	
	function cancellationPropagateFrom(parent, flags) {
	    if ((flags & 1) !== 0) {
	        this._cancellationParent = parent;
	        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
	        if (branchesRemainingToCancel === undefined) {
	            branchesRemainingToCancel = 0;
	        }
	        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
	    }
	    if ((flags & 2) !== 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	}
	
	function bindingPropagateFrom(parent, flags) {
	    if ((flags & 2) !== 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	}
	var propagateFromFunction = bindingPropagateFrom;
	
	function boundValueFunction() {
	    var ret = this._boundTo;
	    if (ret !== undefined) {
	        if (ret instanceof Promise) {
	            if (ret.isFulfilled()) {
	                return ret.value();
	            } else {
	                return undefined;
	            }
	        }
	    }
	    return ret;
	}
	
	function longStackTracesCaptureStackTrace() {
	    this._trace = new CapturedTrace(this._peekContext());
	}
	
	function longStackTracesAttachExtraTrace(error, ignoreSelf) {
	    if (canAttachTrace(error)) {
	        var trace = this._trace;
	        if (trace !== undefined) {
	            if (ignoreSelf) trace = trace._parent;
	        }
	        if (trace !== undefined) {
	            trace.attachExtraTrace(error);
	        } else if (!error.__stackCleaned__) {
	            var parsed = parseStackAndMessage(error);
	            util.notEnumerableProp(error, "stack",
	                parsed.message + "\n" + parsed.stack.join("\n"));
	            util.notEnumerableProp(error, "__stackCleaned__", true);
	        }
	    }
	}
	
	function checkForgottenReturns(returnValue, promiseCreated, name, promise,
	                               parent) {
	    if (returnValue === undefined && promiseCreated !== null &&
	        wForgottenReturn) {
	        if (parent !== undefined && parent._returnedNonUndefined()) return;
	        if ((promise._bitField & 65535) === 0) return;
	
	        if (name) name = name + " ";
	        var handlerLine = "";
	        var creatorLine = "";
	        if (promiseCreated._trace) {
	            var traceLines = promiseCreated._trace.stack.split("\n");
	            var stack = cleanStack(traceLines);
	            for (var i = stack.length - 1; i >= 0; --i) {
	                var line = stack[i];
	                if (!nodeFramePattern.test(line)) {
	                    var lineMatches = line.match(parseLinePattern);
	                    if (lineMatches) {
	                        handlerLine  = "at " + lineMatches[1] +
	                            ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
	                    }
	                    break;
	                }
	            }
	
	            if (stack.length > 0) {
	                var firstUserLine = stack[0];
	                for (var i = 0; i < traceLines.length; ++i) {
	
	                    if (traceLines[i] === firstUserLine) {
	                        if (i > 0) {
	                            creatorLine = "\n" + traceLines[i - 1];
	                        }
	                        break;
	                    }
	                }
	
	            }
	        }
	        var msg = "a promise was created in a " + name +
	            "handler " + handlerLine + "but was not returned from it, " +
	            "see http://goo.gl/rRqMUw" +
	            creatorLine;
	        promise._warn(msg, true, promiseCreated);
	    }
	}
	
	function deprecated(name, replacement) {
	    var message = name +
	        " is deprecated and will be removed in a future version.";
	    if (replacement) message += " Use " + replacement + " instead.";
	    return warn(message);
	}
	
	function warn(message, shouldUseOwnTrace, promise) {
	    if (!config.warnings) return;
	    var warning = new Warning(message);
	    var ctx;
	    if (shouldUseOwnTrace) {
	        promise._attachExtraTrace(warning);
	    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
	        ctx.attachExtraTrace(warning);
	    } else {
	        var parsed = parseStackAndMessage(warning);
	        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
	    }
	
	    if (!activeFireEvent("warning", warning)) {
	        formatAndLogError(warning, "", true);
	    }
	}
	
	function reconstructStack(message, stacks) {
	    for (var i = 0; i < stacks.length - 1; ++i) {
	        stacks[i].push("From previous event:");
	        stacks[i] = stacks[i].join("\n");
	    }
	    if (i < stacks.length) {
	        stacks[i] = stacks[i].join("\n");
	    }
	    return message + "\n" + stacks.join("\n");
	}
	
	function removeDuplicateOrEmptyJumps(stacks) {
	    for (var i = 0; i < stacks.length; ++i) {
	        if (stacks[i].length === 0 ||
	            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
	            stacks.splice(i, 1);
	            i--;
	        }
	    }
	}
	
	function removeCommonRoots(stacks) {
	    var current = stacks[0];
	    for (var i = 1; i < stacks.length; ++i) {
	        var prev = stacks[i];
	        var currentLastIndex = current.length - 1;
	        var currentLastLine = current[currentLastIndex];
	        var commonRootMeetPoint = -1;
	
	        for (var j = prev.length - 1; j >= 0; --j) {
	            if (prev[j] === currentLastLine) {
	                commonRootMeetPoint = j;
	                break;
	            }
	        }
	
	        for (var j = commonRootMeetPoint; j >= 0; --j) {
	            var line = prev[j];
	            if (current[currentLastIndex] === line) {
	                current.pop();
	                currentLastIndex--;
	            } else {
	                break;
	            }
	        }
	        current = prev;
	    }
	}
	
	function cleanStack(stack) {
	    var ret = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        var isTraceLine = "    (No stack trace)" === line ||
	            stackFramePattern.test(line);
	        var isInternalFrame = isTraceLine && shouldIgnore(line);
	        if (isTraceLine && !isInternalFrame) {
	            if (indentStackFrames && line.charAt(0) !== " ") {
	                line = "    " + line;
	            }
	            ret.push(line);
	        }
	    }
	    return ret;
	}
	
	function stackFramesAsArray(error) {
	    var stack = error.stack.replace(/\s+$/g, "").split("\n");
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
	            break;
	        }
	    }
	    if (i > 0 && error.name != "SyntaxError") {
	        stack = stack.slice(i);
	    }
	    return stack;
	}
	
	function parseStackAndMessage(error) {
	    var stack = error.stack;
	    var message = error.toString();
	    stack = typeof stack === "string" && stack.length > 0
	                ? stackFramesAsArray(error) : ["    (No stack trace)"];
	    return {
	        message: message,
	        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
	    };
	}
	
	function formatAndLogError(error, title, isSoft) {
	    if (typeof console !== "undefined") {
	        var message;
	        if (util.isObject(error)) {
	            var stack = error.stack;
	            message = title + formatStack(stack, error);
	        } else {
	            message = title + String(error);
	        }
	        if (typeof printWarning === "function") {
	            printWarning(message, isSoft);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	}
	
	function fireRejectionEvent(name, localHandler, reason, promise) {
	    var localEventFired = false;
	    try {
	        if (typeof localHandler === "function") {
	            localEventFired = true;
	            if (name === "rejectionHandled") {
	                localHandler(promise);
	            } else {
	                localHandler(reason, promise);
	            }
	        }
	    } catch (e) {
	        async.throwLater(e);
	    }
	
	    if (name === "unhandledRejection") {
	        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
	            formatAndLogError(reason, "Unhandled rejection ");
	        }
	    } else {
	        activeFireEvent(name, promise);
	    }
	}
	
	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj && typeof obj.toString === "function"
	            ? obj.toString() : util.toString(obj);
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {
	
	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}
	
	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}
	
	function longStackTracesIsSupported() {
	    return typeof captureStackTrace === "function";
	}
	
	var shouldIgnore = function() { return false; };
	var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
	function parseLineInfo(line) {
	    var matches = line.match(parseLineInfoRegex);
	    if (matches) {
	        return {
	            fileName: matches[1],
	            line: parseInt(matches[2], 10)
	        };
	    }
	}
	
	function setBounds(firstLineError, lastLineError) {
	    if (!longStackTracesIsSupported()) return;
	    var firstStackLines = firstLineError.stack.split("\n");
	    var lastStackLines = lastLineError.stack.split("\n");
	    var firstIndex = -1;
	    var lastIndex = -1;
	    var firstFileName;
	    var lastFileName;
	    for (var i = 0; i < firstStackLines.length; ++i) {
	        var result = parseLineInfo(firstStackLines[i]);
	        if (result) {
	            firstFileName = result.fileName;
	            firstIndex = result.line;
	            break;
	        }
	    }
	    for (var i = 0; i < lastStackLines.length; ++i) {
	        var result = parseLineInfo(lastStackLines[i]);
	        if (result) {
	            lastFileName = result.fileName;
	            lastIndex = result.line;
	            break;
	        }
	    }
	    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
	        firstFileName !== lastFileName || firstIndex >= lastIndex) {
	        return;
	    }
	
	    shouldIgnore = function(line) {
	        if (bluebirdFramePattern.test(line)) return true;
	        var info = parseLineInfo(line);
	        if (info) {
	            if (info.fileName === firstFileName &&
	                (firstIndex <= info.line && info.line <= lastIndex)) {
	                return true;
	            }
	        }
	        return false;
	    };
	}
	
	function CapturedTrace(parent) {
	    this._parent = parent;
	    this._promisesCreated = 0;
	    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
	    captureStackTrace(this, CapturedTrace);
	    if (length > 32) this.uncycle();
	}
	util.inherits(CapturedTrace, Error);
	Context.CapturedTrace = CapturedTrace;
	
	CapturedTrace.prototype.uncycle = function() {
	    var length = this._length;
	    if (length < 2) return;
	    var nodes = [];
	    var stackToIndex = {};
	
	    for (var i = 0, node = this; node !== undefined; ++i) {
	        nodes.push(node);
	        node = node._parent;
	    }
	    length = this._length = i;
	    for (var i = length - 1; i >= 0; --i) {
	        var stack = nodes[i].stack;
	        if (stackToIndex[stack] === undefined) {
	            stackToIndex[stack] = i;
	        }
	    }
	    for (var i = 0; i < length; ++i) {
	        var currentStack = nodes[i].stack;
	        var index = stackToIndex[currentStack];
	        if (index !== undefined && index !== i) {
	            if (index > 0) {
	                nodes[index - 1]._parent = undefined;
	                nodes[index - 1]._length = 1;
	            }
	            nodes[i]._parent = undefined;
	            nodes[i]._length = 1;
	            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
	
	            if (index < length - 1) {
	                cycleEdgeNode._parent = nodes[index + 1];
	                cycleEdgeNode._parent.uncycle();
	                cycleEdgeNode._length =
	                    cycleEdgeNode._parent._length + 1;
	            } else {
	                cycleEdgeNode._parent = undefined;
	                cycleEdgeNode._length = 1;
	            }
	            var currentChildLength = cycleEdgeNode._length + 1;
	            for (var j = i - 2; j >= 0; --j) {
	                nodes[j]._length = currentChildLength;
	                currentChildLength++;
	            }
	            return;
	        }
	    }
	};
	
	CapturedTrace.prototype.attachExtraTrace = function(error) {
	    if (error.__stackCleaned__) return;
	    this.uncycle();
	    var parsed = parseStackAndMessage(error);
	    var message = parsed.message;
	    var stacks = [parsed.stack];
	
	    var trace = this;
	    while (trace !== undefined) {
	        stacks.push(cleanStack(trace.stack.split("\n")));
	        trace = trace._parent;
	    }
	    removeCommonRoots(stacks);
	    removeDuplicateOrEmptyJumps(stacks);
	    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
	    util.notEnumerableProp(error, "__stackCleaned__", true);
	};
	
	var captureStackTrace = (function stackDetection() {
	    var v8stackFramePattern = /^\s*at\s*/;
	    var v8stackFormatter = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if (error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        Error.stackTraceLimit += 6;
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        var captureStackTrace = Error.captureStackTrace;
	
	        shouldIgnore = function(line) {
	            return bluebirdFramePattern.test(line);
	        };
	        return function(receiver, ignoreUntil) {
	            Error.stackTraceLimit += 6;
	            captureStackTrace(receiver, ignoreUntil);
	            Error.stackTraceLimit -= 6;
	        };
	    }
	    var err = new Error();
	
	    if (typeof err.stack === "string" &&
	        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
	        stackFramePattern = /@/;
	        formatStack = v8stackFormatter;
	        indentStackFrames = true;
	        return function captureStackTrace(o) {
	            o.stack = new Error().stack;
	        };
	    }
	
	    var hasStackAfterThrow;
	    try { throw new Error(); }
	    catch(e) {
	        hasStackAfterThrow = ("stack" in e);
	    }
	    if (!("stack" in err) && hasStackAfterThrow &&
	        typeof Error.stackTraceLimit === "number") {
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        return function captureStackTrace(o) {
	            Error.stackTraceLimit += 6;
	            try { throw new Error(); }
	            catch(e) { o.stack = e.stack; }
	            Error.stackTraceLimit -= 6;
	        };
	    }
	
	    formatStack = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if ((typeof error === "object" ||
	            typeof error === "function") &&
	            error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    return null;
	
	})([]);
	
	if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
	    printWarning = function (message) {
	        console.warn(message);
	    };
	    if (util.isNode && process.stderr.isTTY) {
	        printWarning = function(message, isSoft) {
	            var color = isSoft ? "\u001b[33m" : "\u001b[31m";
	            console.warn(color + message + "\u001b[0m\n");
	        };
	    } else if (!util.isNode && typeof (new Error().stack) === "string") {
	        printWarning = function(message, isSoft) {
	            console.warn("%c" + message,
	                        isSoft ? "color: darkorange" : "color: red");
	        };
	    }
	}
	
	var config = {
	    warnings: warnings,
	    longStackTraces: false,
	    cancellation: false,
	    monitoring: false
	};
	
	if (longStackTraces) Promise.longStackTraces();
	
	return {
	    longStackTraces: function() {
	        return config.longStackTraces;
	    },
	    warnings: function() {
	        return config.warnings;
	    },
	    cancellation: function() {
	        return config.cancellation;
	    },
	    monitoring: function() {
	        return config.monitoring;
	    },
	    propagateFromFunction: function() {
	        return propagateFromFunction;
	    },
	    boundValueFunction: function() {
	        return boundValueFunction;
	    },
	    checkForgottenReturns: checkForgottenReturns,
	    setBounds: setBounds,
	    warn: warn,
	    deprecated: deprecated,
	    CapturedTrace: CapturedTrace,
	    fireDomEvent: fireDomEvent,
	    fireGlobalEvent: fireGlobalEvent
	};
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {
	var util = __webpack_require__(122);
	var CancellationError = Promise.CancellationError;
	var errorObj = util.errorObj;
	var catchFilter = __webpack_require__(135)(NEXT_FILTER);
	
	function PassThroughHandlerContext(promise, type, handler) {
	    this.promise = promise;
	    this.type = type;
	    this.handler = handler;
	    this.called = false;
	    this.cancelPromise = null;
	}
	
	PassThroughHandlerContext.prototype.isFinallyHandler = function() {
	    return this.type === 0;
	};
	
	function FinallyHandlerCancelReaction(finallyHandler) {
	    this.finallyHandler = finallyHandler;
	}
	
	FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
	    checkCancel(this.finallyHandler);
	};
	
	function checkCancel(ctx, reason) {
	    if (ctx.cancelPromise != null) {
	        if (arguments.length > 1) {
	            ctx.cancelPromise._reject(reason);
	        } else {
	            ctx.cancelPromise._cancel();
	        }
	        ctx.cancelPromise = null;
	        return true;
	    }
	    return false;
	}
	
	function succeed() {
	    return finallyHandler.call(this, this.promise._target()._settledValue());
	}
	function fail(reason) {
	    if (checkCancel(this, reason)) return;
	    errorObj.e = reason;
	    return errorObj;
	}
	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;
	
	    if (!this.called) {
	        this.called = true;
	        var ret = this.isFinallyHandler()
	            ? handler.call(promise._boundValue())
	            : handler.call(promise._boundValue(), reasonOrValue);
	        if (ret === NEXT_FILTER) {
	            return ret;
	        } else if (ret !== undefined) {
	            promise._setReturnedNonUndefined();
	            var maybePromise = tryConvertToPromise(ret, promise);
	            if (maybePromise instanceof Promise) {
	                if (this.cancelPromise != null) {
	                    if (maybePromise._isCancelled()) {
	                        var reason =
	                            new CancellationError("late cancellation observer");
	                        promise._attachExtraTrace(reason);
	                        errorObj.e = reason;
	                        return errorObj;
	                    } else if (maybePromise.isPending()) {
	                        maybePromise._attachCancellationCallback(
	                            new FinallyHandlerCancelReaction(this));
	                    }
	                }
	                return maybePromise._then(
	                    succeed, fail, undefined, this, undefined);
	            }
	        }
	    }
	
	    if (promise.isRejected()) {
	        checkCancel(this);
	        errorObj.e = reasonOrValue;
	        return errorObj;
	    } else {
	        checkCancel(this);
	        return reasonOrValue;
	    }
	}
	
	Promise.prototype._passThrough = function(handler, type, success, fail) {
	    if (typeof handler !== "function") return this.then();
	    return this._then(success,
	                      fail,
	                      undefined,
	                      new PassThroughHandlerContext(this, type, handler),
	                      undefined);
	};
	
	Promise.prototype.lastly =
	Promise.prototype["finally"] = function (handler) {
	    return this._passThrough(handler,
	                             0,
	                             finallyHandler,
	                             finallyHandler);
	};
	
	
	Promise.prototype.tap = function (handler) {
	    return this._passThrough(handler, 1, finallyHandler);
	};
	
	Promise.prototype.tapCatch = function (handlerOrPredicate) {
	    var len = arguments.length;
	    if(len === 1) {
	        return this._passThrough(handlerOrPredicate,
	                                 1,
	                                 undefined,
	                                 finallyHandler);
	    } else {
	         var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (util.isObject(item)) {
	                catchInstances[j++] = item;
	            } else {
	                return Promise.reject(new TypeError(
	                    "tapCatch statement predicate: "
	                    + "expecting an object but got " + util.classString(item)
	                ));
	            }
	        }
	        catchInstances.length = j;
	        var handler = arguments[i];
	        return this._passThrough(catchFilter(catchInstances, handler, this),
	                                 1,
	                                 undefined,
	                                 finallyHandler);
	    }
	
	};
	
	return PassThroughHandlerContext;
	};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = __webpack_require__(122);
	var getKeys = __webpack_require__(123).keys;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	function catchFilter(instances, cb, promise) {
	    return function(e) {
	        var boundTo = promise._boundValue();
	        predicateLoop: for (var i = 0; i < instances.length; ++i) {
	            var item = instances[i];
	
	            if (item === Error ||
	                (item != null && item.prototype instanceof Error)) {
	                if (e instanceof item) {
	                    return tryCatch(cb).call(boundTo, e);
	                }
	            } else if (typeof item === "function") {
	                var matchesPredicate = tryCatch(item).call(boundTo, e);
	                if (matchesPredicate === errorObj) {
	                    return matchesPredicate;
	                } else if (matchesPredicate) {
	                    return tryCatch(cb).call(boundTo, e);
	                }
	            } else if (util.isObject(e)) {
	                var keys = getKeys(item);
	                for (var j = 0; j < keys.length; ++j) {
	                    var key = keys[j];
	                    if (item[key] != e[key]) {
	                        continue predicateLoop;
	                    }
	                }
	                return tryCatch(cb).call(boundTo, e);
	            }
	        }
	        return NEXT_FILTER;
	    };
	}
	
	return catchFilter;
	};


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var util = __webpack_require__(122);
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = __webpack_require__(129);
	var OperationalError = errors.OperationalError;
	var es5 = __webpack_require__(123);
	
	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}
	
	var rErrorKey = /^(?:name|message|stack|cause)$/;
	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	        ret.name = obj.name;
	        ret.message = obj.message;
	        ret.stack = obj.stack;
	        var keys = es5.keys(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!rErrorKey.test(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    util.markAsOriginatingFromRejection(obj);
	    return obj;
	}
	
	function nodebackForPromise(promise, multiArgs) {
	    return function(err, value) {
	        if (promise === null) return;
	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (!multiArgs) {
	            promise._fulfill(value);
	        } else {
	            var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};
	            promise._fulfill(args);
	        }
	        promise = null;
	    };
	}
	
	module.exports = nodebackForPromise;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports =
	function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
	var util = __webpack_require__(122);
	var tryCatch = util.tryCatch;
	
	Promise.method = function (fn) {
	    if (typeof fn !== "function") {
	        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
	    }
	    return function () {
	        var ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._pushContext();
	        var value = tryCatch(fn).apply(this, arguments);
	        var promiseCreated = ret._popContext();
	        debug.checkForgottenReturns(
	            value, promiseCreated, "Promise.method", ret);
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};
	
	Promise.attempt = Promise["try"] = function (fn) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._pushContext();
	    var value;
	    if (arguments.length > 1) {
	        debug.deprecated("calling Promise.try with more than 1 argument");
	        var arg = arguments[1];
	        var ctx = arguments[2];
	        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
	                                  : tryCatch(fn).call(ctx, arg);
	    } else {
	        value = tryCatch(fn)();
	    }
	    var promiseCreated = ret._popContext();
	    debug.checkForgottenReturns(
	        value, promiseCreated, "Promise.try", ret);
	    ret._resolveFromSyncValue(value);
	    return ret;
	};
	
	Promise.prototype._resolveFromSyncValue = function (value) {
	    if (value === util.errorObj) {
	        this._rejectCallback(value.e, false);
	    } else {
	        this._resolveCallback(value, true);
	    }
	};
	};


/***/ }),
/* 138 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
	var calledBind = false;
	var rejectThis = function(_, e) {
	    this._reject(e);
	};
	
	var targetRejected = function(e, context) {
	    context.promiseRejectionQueued = true;
	    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
	};
	
	var bindingResolved = function(thisArg, context) {
	    if (((this._bitField & 50397184) === 0)) {
	        this._resolveCallback(context.target);
	    }
	};
	
	var bindingRejected = function(e, context) {
	    if (!context.promiseRejectionQueued) this._reject(e);
	};
	
	Promise.prototype.bind = function (thisArg) {
	    if (!calledBind) {
	        calledBind = true;
	        Promise.prototype._propagateFrom = debug.propagateFromFunction();
	        Promise.prototype._boundValue = debug.boundValueFunction();
	    }
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 1);
	    var target = this._target();
	    ret._setBoundTo(maybePromise);
	    if (maybePromise instanceof Promise) {
	        var context = {
	            promiseRejectionQueued: false,
	            promise: ret,
	            target: target,
	            bindingPromise: maybePromise
	        };
	        target._then(INTERNAL, targetRejected, undefined, ret, context);
	        maybePromise._then(
	            bindingResolved, bindingRejected, undefined, ret, context);
	        ret._setOnCancel(maybePromise);
	    } else {
	        ret._resolveCallback(target);
	    }
	    return ret;
	};
	
	Promise.prototype._setBoundTo = function (obj) {
	    if (obj !== undefined) {
	        this._bitField = this._bitField | 2097152;
	        this._boundTo = obj;
	    } else {
	        this._bitField = this._bitField & (~2097152);
	    }
	};
	
	Promise.prototype._isBound = function () {
	    return (this._bitField & 2097152) === 2097152;
	};
	
	Promise.bind = function (thisArg, value) {
	    return Promise.resolve(value).bind(thisArg);
	};
	};


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, PromiseArray, apiRejection, debug) {
	var util = __webpack_require__(122);
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var async = Promise._async;
	
	Promise.prototype["break"] = Promise.prototype.cancel = function() {
	    if (!debug.cancellation()) return this._warn("cancellation is disabled");
	
	    var promise = this;
	    var child = promise;
	    while (promise._isCancellable()) {
	        if (!promise._cancelBy(child)) {
	            if (child._isFollowing()) {
	                child._followee().cancel();
	            } else {
	                child._cancelBranched();
	            }
	            break;
	        }
	
	        var parent = promise._cancellationParent;
	        if (parent == null || !parent._isCancellable()) {
	            if (promise._isFollowing()) {
	                promise._followee().cancel();
	            } else {
	                promise._cancelBranched();
	            }
	            break;
	        } else {
	            if (promise._isFollowing()) promise._followee().cancel();
	            promise._setWillBeCancelled();
	            child = promise;
	            promise = parent;
	        }
	    }
	};
	
	Promise.prototype._branchHasCancelled = function() {
	    this._branchesRemainingToCancel--;
	};
	
	Promise.prototype._enoughBranchesHaveCancelled = function() {
	    return this._branchesRemainingToCancel === undefined ||
	           this._branchesRemainingToCancel <= 0;
	};
	
	Promise.prototype._cancelBy = function(canceller) {
	    if (canceller === this) {
	        this._branchesRemainingToCancel = 0;
	        this._invokeOnCancel();
	        return true;
	    } else {
	        this._branchHasCancelled();
	        if (this._enoughBranchesHaveCancelled()) {
	            this._invokeOnCancel();
	            return true;
	        }
	    }
	    return false;
	};
	
	Promise.prototype._cancelBranched = function() {
	    if (this._enoughBranchesHaveCancelled()) {
	        this._cancel();
	    }
	};
	
	Promise.prototype._cancel = function() {
	    if (!this._isCancellable()) return;
	    this._setCancelled();
	    async.invoke(this._cancelPromises, this, undefined);
	};
	
	Promise.prototype._cancelPromises = function() {
	    if (this._length() > 0) this._settlePromises();
	};
	
	Promise.prototype._unsetOnCancel = function() {
	    this._onCancelField = undefined;
	};
	
	Promise.prototype._isCancellable = function() {
	    return this.isPending() && !this._isCancelled();
	};
	
	Promise.prototype.isCancellable = function() {
	    return this.isPending() && !this.isCancelled();
	};
	
	Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
	    if (util.isArray(onCancelCallback)) {
	        for (var i = 0; i < onCancelCallback.length; ++i) {
	            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
	        }
	    } else if (onCancelCallback !== undefined) {
	        if (typeof onCancelCallback === "function") {
	            if (!internalOnly) {
	                var e = tryCatch(onCancelCallback).call(this._boundValue());
	                if (e === errorObj) {
	                    this._attachExtraTrace(e.e);
	                    async.throwLater(e.e);
	                }
	            }
	        } else {
	            onCancelCallback._resultCancelled(this);
	        }
	    }
	};
	
	Promise.prototype._invokeOnCancel = function() {
	    var onCancelCallback = this._onCancel();
	    this._unsetOnCancel();
	    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
	};
	
	Promise.prototype._invokeInternalOnCancel = function() {
	    if (this._isCancellable()) {
	        this._doInvokeOnCancel(this._onCancel(), true);
	        this._unsetOnCancel();
	    }
	};
	
	Promise.prototype._resultCancelled = function() {
	    this.cancel();
	};
	
	};


/***/ }),
/* 140 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = function(Promise) {
	function returner() {
	    return this.value;
	}
	function thrower() {
	    throw this.reason;
	}
	
	Promise.prototype["return"] =
	Promise.prototype.thenReturn = function (value) {
	    if (value instanceof Promise) value.suppressUnhandledRejections();
	    return this._then(
	        returner, undefined, undefined, {value: value}, undefined);
	};
	
	Promise.prototype["throw"] =
	Promise.prototype.thenThrow = function (reason) {
	    return this._then(
	        thrower, undefined, undefined, {reason: reason}, undefined);
	};
	
	Promise.prototype.catchThrow = function (reason) {
	    if (arguments.length <= 1) {
	        return this._then(
	            undefined, thrower, undefined, {reason: reason}, undefined);
	    } else {
	        var _reason = arguments[1];
	        var handler = function() {throw _reason;};
	        return this.caught(reason, handler);
	    }
	};
	
	Promise.prototype.catchReturn = function (value) {
	    if (arguments.length <= 1) {
	        if (value instanceof Promise) value.suppressUnhandledRejections();
	        return this._then(
	            undefined, returner, undefined, {value: value}, undefined);
	    } else {
	        var _value = arguments[1];
	        if (_value instanceof Promise) _value.suppressUnhandledRejections();
	        var handler = function() {return _value;};
	        return this.caught(value, handler);
	    }
	};
	};


/***/ }),
/* 141 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== undefined) {
	        promise = promise._target();
	        this._bitField = promise._bitField;
	        this._settledValueField = promise._isFateSealed()
	            ? promise._settledValue() : undefined;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValueField = undefined;
	    }
	}
	
	PromiseInspection.prototype._settledValue = function() {
	    return this._settledValueField;
	};
	
	var value = PromiseInspection.prototype.value = function () {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    return this._settledValue();
	};
	
	var reason = PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason = function () {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    return this._settledValue();
	};
	
	var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
	    return (this._bitField & 33554432) !== 0;
	};
	
	var isRejected = PromiseInspection.prototype.isRejected = function () {
	    return (this._bitField & 16777216) !== 0;
	};
	
	var isPending = PromiseInspection.prototype.isPending = function () {
	    return (this._bitField & 50397184) === 0;
	};
	
	var isResolved = PromiseInspection.prototype.isResolved = function () {
	    return (this._bitField & 50331648) !== 0;
	};
	
	PromiseInspection.prototype.isCancelled = function() {
	    return (this._bitField & 8454144) !== 0;
	};
	
	Promise.prototype.__isCancelled = function() {
	    return (this._bitField & 65536) === 65536;
	};
	
	Promise.prototype._isCancelled = function() {
	    return this._target().__isCancelled();
	};
	
	Promise.prototype.isCancelled = function() {
	    return (this._target()._bitField & 8454144) !== 0;
	};
	
	Promise.prototype.isPending = function() {
	    return isPending.call(this._target());
	};
	
	Promise.prototype.isRejected = function() {
	    return isRejected.call(this._target());
	};
	
	Promise.prototype.isFulfilled = function() {
	    return isFulfilled.call(this._target());
	};
	
	Promise.prototype.isResolved = function() {
	    return isResolved.call(this._target());
	};
	
	Promise.prototype.value = function() {
	    return value.call(this._target());
	};
	
	Promise.prototype.reason = function() {
	    var target = this._target();
	    target._unsetRejectionIsUnhandled();
	    return reason.call(target);
	};
	
	Promise.prototype._value = function() {
	    return this._settledValue();
	};
	
	Promise.prototype._reason = function() {
	    this._unsetRejectionIsUnhandled();
	    return this._settledValue();
	};
	
	Promise.PromiseInspection = PromiseInspection;
	};


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports =
	function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,
	         getDomain) {
	var util = __webpack_require__(122);
	var canEvaluate = util.canEvaluate;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var reject;
	
	if (true) {
	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };
	
	    var promiseSetter = function(i) {
	        return new Function("promise", "holder", "                           \n\
	            'use strict';                                                    \n\
	            holder.pIndex = promise;                                         \n\
	            ".replace(/Index/g, i));
	    };
	
	    var generateHolderClass = function(total) {
	        var props = new Array(total);
	        for (var i = 0; i < props.length; ++i) {
	            props[i] = "this.p" + (i+1);
	        }
	        var assignment = props.join(" = ") + " = null;";
	        var cancellationCode= "var promise;\n" + props.map(function(prop) {
	            return "                                                         \n\
	                promise = " + prop + ";                                      \n\
	                if (promise instanceof Promise) {                            \n\
	                    promise.cancel();                                        \n\
	                }                                                            \n\
	            ";
	        }).join("\n");
	        var passedArguments = props.join(", ");
	        var name = "Holder$" + total;
	
	
	        var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
	            'use strict';                                                    \n\
	            function [TheName](fn) {                                         \n\
	                [TheProperties]                                              \n\
	                this.fn = fn;                                                \n\
	                this.asyncNeeded = true;                                     \n\
	                this.now = 0;                                                \n\
	            }                                                                \n\
	                                                                             \n\
	            [TheName].prototype._callFunction = function(promise) {          \n\
	                promise._pushContext();                                      \n\
	                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
	                promise._popContext();                                       \n\
	                if (ret === errorObj) {                                      \n\
	                    promise._rejectCallback(ret.e, false);                   \n\
	                } else {                                                     \n\
	                    promise._resolveCallback(ret);                           \n\
	                }                                                            \n\
	            };                                                               \n\
	                                                                             \n\
	            [TheName].prototype.checkFulfillment = function(promise) {       \n\
	                var now = ++this.now;                                        \n\
	                if (now === [TheTotal]) {                                    \n\
	                    if (this.asyncNeeded) {                                  \n\
	                        async.invoke(this._callFunction, this, promise);     \n\
	                    } else {                                                 \n\
	                        this._callFunction(promise);                         \n\
	                    }                                                        \n\
	                                                                             \n\
	                }                                                            \n\
	            };                                                               \n\
	                                                                             \n\
	            [TheName].prototype._resultCancelled = function() {              \n\
	                [CancellationCode]                                           \n\
	            };                                                               \n\
	                                                                             \n\
	            return [TheName];                                                \n\
	        }(tryCatch, errorObj, Promise, async);                               \n\
	        ";
	
	        code = code.replace(/\[TheName\]/g, name)
	            .replace(/\[TheTotal\]/g, total)
	            .replace(/\[ThePassedArguments\]/g, passedArguments)
	            .replace(/\[TheProperties\]/g, assignment)
	            .replace(/\[CancellationCode\]/g, cancellationCode);
	
	        return new Function("tryCatch", "errorObj", "Promise", "async", code)
	                           (tryCatch, errorObj, Promise, async);
	    };
	
	    var holderClasses = [];
	    var thenCallbacks = [];
	    var promiseSetters = [];
	
	    for (var i = 0; i < 8; ++i) {
	        holderClasses.push(generateHolderClass(i + 1));
	        thenCallbacks.push(thenCallback(i + 1));
	        promiseSetters.push(promiseSetter(i + 1));
	    }
	
	    reject = function (reason) {
	        this._reject(reason);
	    };
	}}
	
	Promise.join = function () {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (true) {
	            if (last <= 8 && canEvaluate) {
	                var ret = new Promise(INTERNAL);
	                ret._captureStackTrace();
	                var HolderClass = holderClasses[last - 1];
	                var holder = new HolderClass(fn);
	                var callbacks = thenCallbacks;
	
	                for (var i = 0; i < last; ++i) {
	                    var maybePromise = tryConvertToPromise(arguments[i], ret);
	                    if (maybePromise instanceof Promise) {
	                        maybePromise = maybePromise._target();
	                        var bitField = maybePromise._bitField;
	                        ;
	                        if (((bitField & 50397184) === 0)) {
	                            maybePromise._then(callbacks[i], reject,
	                                               undefined, ret, holder);
	                            promiseSetters[i](maybePromise, holder);
	                            holder.asyncNeeded = false;
	                        } else if (((bitField & 33554432) !== 0)) {
	                            callbacks[i].call(ret,
	                                              maybePromise._value(), holder);
	                        } else if (((bitField & 16777216) !== 0)) {
	                            ret._reject(maybePromise._reason());
	                        } else {
	                            ret._cancel();
	                        }
	                    } else {
	                        callbacks[i].call(ret, maybePromise, holder);
	                    }
	                }
	
	                if (!ret._isFateSealed()) {
	                    if (holder.asyncNeeded) {
	                        var domain = getDomain();
	                        if (domain !== null) {
	                            holder.fn = util.domainBind(domain, holder.fn);
	                        }
	                    }
	                    ret._setAsyncGuaranteed();
	                    ret._setOnCancel(holder);
	                }
	                return ret;
	            }
	        }
	    }
	    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];};
	    if (fn) args.pop();
	    var ret = new PromiseArray(args).promise();
	    return fn !== undefined ? ret.spread(fn) : ret;
	};
	
	};


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL,
	                          debug) {
	var getDomain = Promise._getDomain;
	var util = __webpack_require__(122);
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var async = Promise._async;
	
	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    var domain = getDomain();
	    this._callback = domain === null ? fn : util.domainBind(domain, fn);
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = [];
	    async.invoke(this._asyncInit, this, undefined);
	}
	util.inherits(MappingPromiseArray, PromiseArray);
	
	MappingPromiseArray.prototype._asyncInit = function() {
	    this._init$(undefined, -2);
	};
	
	MappingPromiseArray.prototype._init = function () {};
	
	MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;
	
	    if (index < 0) {
	        index = (index * -1) - 1;
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return true;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return false;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;
	
	        var promise = this._promise;
	        var callback = this._callback;
	        var receiver = promise._boundValue();
	        promise._pushContext();
	        var ret = tryCatch(callback).call(receiver, value, index, length);
	        var promiseCreated = promise._popContext();
	        debug.checkForgottenReturns(
	            ret,
	            promiseCreated,
	            preservedValues !== null ? "Promise.filter" : "Promise.map",
	            promise
	        );
	        if (ret === errorObj) {
	            this._reject(ret.e);
	            return true;
	        }
	
	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            var bitField = maybePromise._bitField;
	            ;
	            if (((bitField & 50397184) === 0)) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = maybePromise;
	                maybePromise._proxy(this, (index + 1) * -1);
	                return false;
	            } else if (((bitField & 33554432) !== 0)) {
	                ret = maybePromise._value();
	            } else if (((bitField & 16777216) !== 0)) {
	                this._reject(maybePromise._reason());
	                return true;
	            } else {
	                this._cancel();
	                return true;
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }
	        return true;
	    }
	    return false;
	};
	
	MappingPromiseArray.prototype._drainQueue = function () {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        if (this._isResolved()) return;
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};
	
	MappingPromiseArray.prototype._filter = function (booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};
	
	MappingPromiseArray.prototype.preservedValues = function () {
	    return this._preservedValues;
	};
	
	function map(promises, fn, options, _filter) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	
	    var limit = 0;
	    if (options !== undefined) {
	        if (typeof options === "object" && options !== null) {
	            if (typeof options.concurrency !== "number") {
	                return Promise.reject(
	                    new TypeError("'concurrency' must be a number but it is " +
	                                    util.classString(options.concurrency)));
	            }
	            limit = options.concurrency;
	        } else {
	            return Promise.reject(new TypeError(
	                            "options argument must be an object but it is " +
	                             util.classString(options)));
	        }
	    }
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter).promise();
	}
	
	Promise.prototype.map = function (fn, options) {
	    return map(this, fn, options, null);
	};
	
	Promise.map = function (promises, fn, options, _filter) {
	    return map(promises, fn, options, _filter);
	};
	
	
	};


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var cr = Object.create;
	if (cr) {
	    var callerCache = cr(null);
	    var getterCache = cr(null);
	    callerCache[" size"] = getterCache[" size"] = 0;
	}
	
	module.exports = function(Promise) {
	var util = __webpack_require__(122);
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;
	
	var getMethodCaller;
	var getGetter;
	if (true) {
	var makeMethodCaller = function (methodName) {
	    return new Function("ensureMethod", "                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g, methodName))(ensureMethod);
	};
	
	var makeGetter = function (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	};
	
	var getCompiled = function(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	};
	
	getMethodCaller = function(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	};
	
	getGetter = function(name) {
	    return getCompiled(name, makeGetter, getterCache);
	};
	}
	
	function ensureMethod(obj, methodName) {
	    var fn;
	    if (obj != null) fn = obj[methodName];
	    if (typeof fn !== "function") {
	        var message = "Object " + util.classString(obj) + " has no method '" +
	            util.toString(methodName) + "'";
	        throw new Promise.TypeError(message);
	    }
	    return fn;
	}
	
	function caller(obj) {
	    var methodName = this.pop();
	    var fn = ensureMethod(obj, methodName);
	    return fn.apply(obj, this);
	}
	Promise.prototype.call = function (methodName) {
	    var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};
	    if (true) {
	        if (canEvaluate) {
	            var maybeCaller = getMethodCaller(methodName);
	            if (maybeCaller !== null) {
	                return this._then(
	                    maybeCaller, undefined, undefined, args, undefined);
	            }
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, undefined, undefined, args, undefined);
	};
	
	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    var index = +this;
	    if (index < 0) index = Math.max(0, index + obj.length);
	    return obj[index];
	}
	Promise.prototype.get = function (propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, undefined, undefined, propertyName, undefined);
	};
	};


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function (Promise, apiRejection, tryConvertToPromise,
	    createContext, INTERNAL, debug) {
	    var util = __webpack_require__(122);
	    var TypeError = __webpack_require__(129).TypeError;
	    var inherits = __webpack_require__(122).inherits;
	    var errorObj = util.errorObj;
	    var tryCatch = util.tryCatch;
	    var NULL = {};
	
	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }
	
	    function castPreservingDisposable(thenable) {
	        var maybePromise = tryConvertToPromise(thenable);
	        if (maybePromise !== thenable &&
	            typeof thenable._isDisposable === "function" &&
	            typeof thenable._getDisposer === "function" &&
	            thenable._isDisposable()) {
	            maybePromise._setDisposable(thenable._getDisposer());
	        }
	        return maybePromise;
	    }
	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = new Promise(INTERNAL);
	        function iterator() {
	            if (i >= len) return ret._fulfill();
	            var maybePromise = castPreservingDisposable(resources[i++]);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = tryConvertToPromise(
	                        maybePromise._getDisposer().tryDispose(inspection),
	                        resources.promise);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret;
	    }
	
	    function Disposer(data, promise, context) {
	        this._data = data;
	        this._promise = promise;
	        this._context = context;
	    }
	
	    Disposer.prototype.data = function () {
	        return this._data;
	    };
	
	    Disposer.prototype.promise = function () {
	        return this._promise;
	    };
	
	    Disposer.prototype.resource = function () {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return NULL;
	    };
	
	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var context = this._context;
	        if (context !== undefined) context._pushContext();
	        var ret = resource !== NULL
	            ? this.doDispose(resource, inspection) : null;
	        if (context !== undefined) context._popContext();
	        this._promise._unsetDisposable();
	        this._data = null;
	        return ret;
	    };
	
	    Disposer.isDisposer = function (d) {
	        return (d != null &&
	                typeof d.resource === "function" &&
	                typeof d.tryDispose === "function");
	    };
	
	    function FunctionDisposer(fn, promise, context) {
	        this.constructor$(fn, promise, context);
	    }
	    inherits(FunctionDisposer, Disposer);
	
	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };
	
	    function maybeUnwrapDisposer(value) {
	        if (Disposer.isDisposer(value)) {
	            this.resources[this.index]._setDisposable(value);
	            return value.promise();
	        }
	        return value;
	    }
	
	    function ResourceList(length) {
	        this.length = length;
	        this.promise = null;
	        this[length-1] = null;
	    }
	
	    ResourceList.prototype._resultCancelled = function() {
	        var len = this.length;
	        for (var i = 0; i < len; ++i) {
	            var item = this[i];
	            if (item instanceof Promise) {
	                item.cancel();
	            }
	        }
	    };
	
	    Promise.using = function () {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") {
	            return apiRejection("expecting a function but got " + util.classString(fn));
	        }
	        var input;
	        var spreadArgs = true;
	        if (len === 2 && Array.isArray(arguments[0])) {
	            input = arguments[0];
	            len = input.length;
	            spreadArgs = false;
	        } else {
	            input = arguments;
	            len--;
	        }
	        var resources = new ResourceList(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = input[i];
	            if (Disposer.isDisposer(resource)) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            } else {
	                var maybePromise = tryConvertToPromise(resource);
	                if (maybePromise instanceof Promise) {
	                    resource =
	                        maybePromise._then(maybeUnwrapDisposer, null, null, {
	                            resources: resources,
	                            index: i
	                    }, undefined);
	                }
	            }
	            resources[i] = resource;
	        }
	
	        var reflectedResources = new Array(resources.length);
	        for (var i = 0; i < reflectedResources.length; ++i) {
	            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
	        }
	
	        var resultPromise = Promise.all(reflectedResources)
	            .then(function(inspections) {
	                for (var i = 0; i < inspections.length; ++i) {
	                    var inspection = inspections[i];
	                    if (inspection.isRejected()) {
	                        errorObj.e = inspection.error();
	                        return errorObj;
	                    } else if (!inspection.isFulfilled()) {
	                        resultPromise.cancel();
	                        return;
	                    }
	                    inspections[i] = inspection.value();
	                }
	                promise._pushContext();
	
	                fn = tryCatch(fn);
	                var ret = spreadArgs
	                    ? fn.apply(undefined, inspections) : fn(inspections);
	                var promiseCreated = promise._popContext();
	                debug.checkForgottenReturns(
	                    ret, promiseCreated, "Promise.using", promise);
	                return ret;
	            });
	
	        var promise = resultPromise.lastly(function() {
	            var inspection = new Promise.PromiseInspection(resultPromise);
	            return dispose(resources, inspection);
	        });
	        resources.promise = promise;
	        promise._setOnCancel(resources);
	        return promise;
	    };
	
	    Promise.prototype._setDisposable = function (disposer) {
	        this._bitField = this._bitField | 131072;
	        this._disposer = disposer;
	    };
	
	    Promise.prototype._isDisposable = function () {
	        return (this._bitField & 131072) > 0;
	    };
	
	    Promise.prototype._getDisposer = function () {
	        return this._disposer;
	    };
	
	    Promise.prototype._unsetDisposable = function () {
	        this._bitField = this._bitField & (~131072);
	        this._disposer = undefined;
	    };
	
	    Promise.prototype.disposer = function (fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this, createContext());
	        }
	        throw new TypeError();
	    };
	
	};


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, INTERNAL, debug) {
	var util = __webpack_require__(122);
	var TimeoutError = Promise.TimeoutError;
	
	function HandleWrapper(handle)  {
	    this.handle = handle;
	}
	
	HandleWrapper.prototype._resultCancelled = function() {
	    clearTimeout(this.handle);
	};
	
	var afterValue = function(value) { return delay(+this).thenReturn(value); };
	var delay = Promise.delay = function (ms, value) {
	    var ret;
	    var handle;
	    if (value !== undefined) {
	        ret = Promise.resolve(value)
	                ._then(afterValue, null, null, ms, undefined);
	        if (debug.cancellation() && value instanceof Promise) {
	            ret._setOnCancel(value);
	        }
	    } else {
	        ret = new Promise(INTERNAL);
	        handle = setTimeout(function() { ret._fulfill(); }, +ms);
	        if (debug.cancellation()) {
	            ret._setOnCancel(new HandleWrapper(handle));
	        }
	        ret._captureStackTrace();
	    }
	    ret._setAsyncGuaranteed();
	    return ret;
	};
	
	Promise.prototype.delay = function (ms) {
	    return delay(ms, this);
	};
	
	var afterTimeout = function (promise, message, parent) {
	    var err;
	    if (typeof message !== "string") {
	        if (message instanceof Error) {
	            err = message;
	        } else {
	            err = new TimeoutError("operation timed out");
	        }
	    } else {
	        err = new TimeoutError(message);
	    }
	    util.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._reject(err);
	
	    if (parent != null) {
	        parent.cancel();
	    }
	};
	
	function successClear(value) {
	    clearTimeout(this.handle);
	    return value;
	}
	
	function failureClear(reason) {
	    clearTimeout(this.handle);
	    throw reason;
	}
	
	Promise.prototype.timeout = function (ms, message) {
	    ms = +ms;
	    var ret, parent;
	
	    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
	        if (ret.isPending()) {
	            afterTimeout(ret, message, parent);
	        }
	    }, ms));
	
	    if (debug.cancellation()) {
	        parent = this.then();
	        ret = parent._then(successClear, failureClear,
	                            undefined, handleWrapper, undefined);
	        ret._setOnCancel(handleWrapper);
	    } else {
	        ret = this._then(successClear, failureClear,
	                            undefined, handleWrapper, undefined);
	    }
	
	    return ret;
	};
	
	};


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise,
	                          apiRejection,
	                          INTERNAL,
	                          tryConvertToPromise,
	                          Proxyable,
	                          debug) {
	var errors = __webpack_require__(129);
	var TypeError = errors.TypeError;
	var util = __webpack_require__(122);
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	var yieldHandlers = [];
	
	function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
	    for (var i = 0; i < yieldHandlers.length; ++i) {
	        traceParent._pushContext();
	        var result = tryCatch(yieldHandlers[i])(value);
	        traceParent._popContext();
	        if (result === errorObj) {
	            traceParent._pushContext();
	            var ret = Promise.reject(errorObj.e);
	            traceParent._popContext();
	            return ret;
	        }
	        var maybePromise = tryConvertToPromise(result, traceParent);
	        if (maybePromise instanceof Promise) return maybePromise;
	    }
	    return null;
	}
	
	function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
	    if (debug.cancellation()) {
	        var internal = new Promise(INTERNAL);
	        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
	        this._promise = internal.lastly(function() {
	            return _finallyPromise;
	        });
	        internal._captureStackTrace();
	        internal._setOnCancel(this);
	    } else {
	        var promise = this._promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	    }
	    this._stack = stack;
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = undefined;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	    this._yieldedPromise = null;
	    this._cancellationPhase = false;
	}
	util.inherits(PromiseSpawn, Proxyable);
	
	PromiseSpawn.prototype._isResolved = function() {
	    return this._promise === null;
	};
	
	PromiseSpawn.prototype._cleanup = function() {
	    this._promise = this._generator = null;
	    if (debug.cancellation() && this._finallyPromise !== null) {
	        this._finallyPromise._fulfill();
	        this._finallyPromise = null;
	    }
	};
	
	PromiseSpawn.prototype._promiseCancelled = function() {
	    if (this._isResolved()) return;
	    var implementsReturn = typeof this._generator["return"] !== "undefined";
	
	    var result;
	    if (!implementsReturn) {
	        var reason = new Promise.CancellationError(
	            "generator .return() sentinel");
	        Promise.coroutine.returnSentinel = reason;
	        this._promise._attachExtraTrace(reason);
	        this._promise._pushContext();
	        result = tryCatch(this._generator["throw"]).call(this._generator,
	                                                         reason);
	        this._promise._popContext();
	    } else {
	        this._promise._pushContext();
	        result = tryCatch(this._generator["return"]).call(this._generator,
	                                                          undefined);
	        this._promise._popContext();
	    }
	    this._cancellationPhase = true;
	    this._yieldedPromise = null;
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._promiseFulfilled = function(value) {
	    this._yieldedPromise = null;
	    this._promise._pushContext();
	    var result = tryCatch(this._generator.next).call(this._generator, value);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._promiseRejected = function(reason) {
	    this._yieldedPromise = null;
	    this._promise._attachExtraTrace(reason);
	    this._promise._pushContext();
	    var result = tryCatch(this._generator["throw"])
	        .call(this._generator, reason);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._resultCancelled = function() {
	    if (this._yieldedPromise instanceof Promise) {
	        var promise = this._yieldedPromise;
	        this._yieldedPromise = null;
	        promise.cancel();
	    }
	};
	
	PromiseSpawn.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseSpawn.prototype._run = function () {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = undefined;
	    this._promiseFulfilled(undefined);
	};
	
	PromiseSpawn.prototype._continue = function (result) {
	    var promise = this._promise;
	    if (result === errorObj) {
	        this._cleanup();
	        if (this._cancellationPhase) {
	            return promise.cancel();
	        } else {
	            return promise._rejectCallback(result.e, false);
	        }
	    }
	
	    var value = result.value;
	    if (result.done === true) {
	        this._cleanup();
	        if (this._cancellationPhase) {
	            return promise.cancel();
	        } else {
	            return promise._resolveCallback(value);
	        }
	    } else {
	        var maybePromise = tryConvertToPromise(value, this._promise);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise,
	                                        this._yieldHandlers,
	                                        this._promise);
	            if (maybePromise === null) {
	                this._promiseRejected(
	                    new TypeError(
	                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", String(value)) +
	                        "From coroutine:\u000a" +
	                        this._stack.split("\n").slice(1, -7).join("\n")
	                    )
	                );
	                return;
	            }
	        }
	        maybePromise = maybePromise._target();
	        var bitField = maybePromise._bitField;
	        ;
	        if (((bitField & 50397184) === 0)) {
	            this._yieldedPromise = maybePromise;
	            maybePromise._proxy(this, null);
	        } else if (((bitField & 33554432) !== 0)) {
	            Promise._async.invoke(
	                this._promiseFulfilled, this, maybePromise._value()
	            );
	        } else if (((bitField & 16777216) !== 0)) {
	            Promise._async.invoke(
	                this._promiseRejected, this, maybePromise._reason()
	            );
	        } else {
	            this._promiseCancelled();
	        }
	    }
	};
	
	Promise.coroutine = function (generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    var stack = new Error().stack;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
	                                      stack);
	        var ret = spawn.promise();
	        spawn._generator = generator;
	        spawn._promiseFulfilled(undefined);
	        return ret;
	    };
	};
	
	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    yieldHandlers.push(fn);
	};
	
	Promise.spawn = function (generatorFunction) {
	    debug.deprecated("Promise.spawn()", "Promise.coroutine()");
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise) {
	var util = __webpack_require__(122);
	var async = Promise._async;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	function spreadAdapter(val, nodeback) {
	    var promise = this;
	    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
	    var ret =
	        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	function successAdapter(val, nodeback) {
	    var promise = this;
	    var receiver = promise._boundValue();
	    var ret = val === undefined
	        ? tryCatch(nodeback).call(receiver, null)
	        : tryCatch(nodeback).call(receiver, null, val);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	function errorAdapter(reason, nodeback) {
	    var promise = this;
	    if (!reason) {
	        var newReason = new Error(reason + "");
	        newReason.cause = reason;
	        reason = newReason;
	    }
	    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,
	                                                                     options) {
	    if (typeof nodeback == "function") {
	        var adapter = successAdapter;
	        if (options !== undefined && Object(options).spread) {
	            adapter = spreadAdapter;
	        }
	        this._then(
	            adapter,
	            errorAdapter,
	            undefined,
	            this,
	            nodeback
	        );
	    }
	    return this;
	};
	};


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = __webpack_require__(122);
	var nodebackForPromise = __webpack_require__(136);
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = __webpack_require__(129).TypeError;
	var defaultSuffix = "Async";
	var defaultPromisified = {__isPromisified__: true};
	var noCopyProps = [
	    "arity",    "length",
	    "name",
	    "arguments",
	    "caller",
	    "callee",
	    "prototype",
	    "__isPromisified__"
	];
	var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
	
	var defaultFilter = function(name) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        name !== "constructor";
	};
	
	function propsFilter(key) {
	    return !noCopyPropsPattern.test(key);
	}
	
	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}
	
	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a"
	                        .replace("%s", suffix));
	                }
	            }
	        }
	    }
	}
	
	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        var passesDefaultFilter = filter === defaultFilter
	            ? true : defaultFilter(key, value, obj);
	        if (typeof value === "function" &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj, passesDefaultFilter)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}
	
	var escapeIdentRegex = function(str) {
	    return str.replace(/([$])/, "\\$");
	};
	
	var makeNodePromisifiedEval;
	if (true) {
	var switchCaseArgumentOrder = function(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 3);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
	        ret.push(i);
	    }
	    return ret;
	};
	
	var argumentSequence = function(argumentCount) {
	    return util.filledRange(argumentCount, "_arg", "");
	};
	
	var parameterDeclaration = function(parameterCount) {
	    return util.filledRange(
	        Math.max(parameterCount, 3), "_arg", "");
	};
	
	var parameterCount = function(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	};
	
	makeNodePromisifiedEval =
	function(callback, receiver, originalName, fn, _, multiArgs) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var shouldProxyThis = typeof callback === "string" || receiver === THIS;
	
	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (shouldProxyThis) {
	            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
	        } else {
	            ret = receiver === undefined
	                ? "ret = callback({{args}}, nodeback); break;\n"
	                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
	        }
	        return ret.replace("{{args}}", args).replace(", ", comma);
	    }
	
	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for (var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }
	
	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", (shouldProxyThis
	                                ? "ret = callback.apply(this, args);\n"
	                                : "ret = callback.apply(receiver, args);\n"));
	        return ret;
	    }
	
	    var getFunctionCode = typeof callback === "string"
	                                ? ("this != null ? this['"+callback+"'] : fn")
	                                : "fn";
	    var body = "'use strict';                                                \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
	        return ret;                                                          \n\
	    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
	        .replace("[GetFunctionCode]", getFunctionCode);
	    body = body.replace("Parameters", parameterDeclaration(newParameterCount));
	    return new Function("Promise",
	                        "fn",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "tryCatch",
	                        "errorObj",
	                        "notEnumerableProp",
	                        "INTERNAL",
	                        body)(
	                    Promise,
	                    fn,
	                    receiver,
	                    withAppended,
	                    maybeWrapAsError,
	                    nodebackForPromise,
	                    util.tryCatch,
	                    util.errorObj,
	                    util.notEnumerableProp,
	                    INTERNAL);
	};
	}
	
	function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
	    var defaultThis = (function() {return this;})();
	    var method = callback;
	    if (typeof method === "string") {
	        callback = fn;
	    }
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        var promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	        var cb = typeof method === "string" && this !== defaultThis
	            ? this[method] : callback;
	        var fn = nodebackForPromise(promise, multiArgs);
	        try {
	            cb.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            promise._rejectCallback(maybeWrapAsError(e), true, true);
	        }
	        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
	        return promise;
	    }
	    util.notEnumerableProp(promisified, "__isPromisified__", true);
	    return promisified;
	}
	
	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;
	
	function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);
	
	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        if (promisifier === makeNodePromisified) {
	            obj[promisifiedKey] =
	                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
	        } else {
	            var promisified = promisifier(fn, function() {
	                return makeNodePromisified(key, THIS, key,
	                                           fn, suffix, multiArgs);
	            });
	            util.notEnumerableProp(promisified, "__isPromisified__", true);
	            obj[promisifiedKey] = promisified;
	        }
	    }
	    util.toFastProperties(obj);
	    return obj;
	}
	
	function promisify(callback, receiver, multiArgs) {
	    return makeNodePromisified(callback, receiver, undefined,
	                                callback, null, multiArgs);
	}
	
	Promise.promisify = function (fn, options) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    options = Object(options);
	    var receiver = options.context === undefined ? THIS : options.context;
	    var multiArgs = !!options.multiArgs;
	    var ret = promisify(fn, receiver, multiArgs);
	    util.copyDescriptors(fn, ret, propsFilter);
	    return ret;
	};
	
	Promise.promisifyAll = function (target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    options = Object(options);
	    var multiArgs = !!options.multiArgs;
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;
	
	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	
	    var keys = util.inheritedDataKeys(target);
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier,
	                multiArgs);
	            promisifyAll(value, suffix, filter, promisifier, multiArgs);
	        }
	    }
	
	    return promisifyAll(target, suffix, filter, promisifier, multiArgs);
	};
	};
	


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(
	    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
	var util = __webpack_require__(122);
	var isObject = util.isObject;
	var es5 = __webpack_require__(123);
	var Es6Map;
	if (typeof Map === "function") Es6Map = Map;
	
	var mapToEntries = (function() {
	    var index = 0;
	    var size = 0;
	
	    function extractEntry(value, key) {
	        this[index] = value;
	        this[index + size] = key;
	        index++;
	    }
	
	    return function mapToEntries(map) {
	        size = map.size;
	        index = 0;
	        var ret = new Array(map.size * 2);
	        map.forEach(extractEntry, ret);
	        return ret;
	    };
	})();
	
	var entriesToMap = function(entries) {
	    var ret = new Es6Map();
	    var length = entries.length / 2 | 0;
	    for (var i = 0; i < length; ++i) {
	        var key = entries[length + i];
	        var value = entries[i];
	        ret.set(key, value);
	    }
	    return ret;
	};
	
	function PropertiesPromiseArray(obj) {
	    var isMap = false;
	    var entries;
	    if (Es6Map !== undefined && obj instanceof Es6Map) {
	        entries = mapToEntries(obj);
	        isMap = true;
	    } else {
	        var keys = es5.keys(obj);
	        var len = keys.length;
	        entries = new Array(len * 2);
	        for (var i = 0; i < len; ++i) {
	            var key = keys[i];
	            entries[i] = obj[key];
	            entries[i + len] = key;
	        }
	    }
	    this.constructor$(entries);
	    this._isMap = isMap;
	    this._init$(undefined, isMap ? -6 : -3);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);
	
	PropertiesPromiseArray.prototype._init = function () {};
	
	PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val;
	        if (this._isMap) {
	            val = entriesToMap(this._values);
	        } else {
	            val = {};
	            var keyOffset = this.length();
	            for (var i = 0, len = this.length(); i < len; ++i) {
	                val[this._values[i + keyOffset]] = this._values[i];
	            }
	        }
	        this._resolve(val);
	        return true;
	    }
	    return false;
	};
	
	PropertiesPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};
	
	PropertiesPromiseArray.prototype.getActualLength = function (len) {
	    return len >> 1;
	};
	
	function props(promises) {
	    var ret;
	    var castValue = tryConvertToPromise(promises);
	
	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(
	            Promise.props, undefined, undefined, undefined, undefined);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }
	
	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 2);
	    }
	    return ret;
	}
	
	Promise.prototype.props = function () {
	    return props(this);
	};
	
	Promise.props = function (promises) {
	    return props(promises);
	};
	};


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(
	    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var util = __webpack_require__(122);
	
	var raceLater = function (promise) {
	    return promise.then(function(array) {
	        return race(array, promise);
	    });
	};
	
	function race(promises, parent) {
	    var maybePromise = tryConvertToPromise(promises);
	
	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else {
	        promises = util.asArray(promises);
	        if (promises === null)
	            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
	    }
	
	    var ret = new Promise(INTERNAL);
	    if (parent !== undefined) {
	        ret._propagateFrom(parent, 3);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];
	
	        if (val === undefined && !(i in promises)) {
	            continue;
	        }
	
	        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
	    }
	    return ret;
	}
	
	Promise.race = function (promises) {
	    return race(promises, undefined);
	};
	
	Promise.prototype.race = function () {
	    return race(this, undefined);
	};
	
	};


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL,
	                          debug) {
	var getDomain = Promise._getDomain;
	var util = __webpack_require__(122);
	var tryCatch = util.tryCatch;
	
	function ReductionPromiseArray(promises, fn, initialValue, _each) {
	    this.constructor$(promises);
	    var domain = getDomain();
	    this._fn = domain === null ? fn : util.domainBind(domain, fn);
	    if (initialValue !== undefined) {
	        initialValue = Promise.resolve(initialValue);
	        initialValue._attachCancellationCallback(this);
	    }
	    this._initialValue = initialValue;
	    this._currentCancellable = null;
	    if(_each === INTERNAL) {
	        this._eachValues = Array(this._length);
	    } else if (_each === 0) {
	        this._eachValues = null;
	    } else {
	        this._eachValues = undefined;
	    }
	    this._promise._captureStackTrace();
	    this._init$(undefined, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);
	
	ReductionPromiseArray.prototype._gotAccum = function(accum) {
	    if (this._eachValues !== undefined && 
	        this._eachValues !== null && 
	        accum !== INTERNAL) {
	        this._eachValues.push(accum);
	    }
	};
	
	ReductionPromiseArray.prototype._eachComplete = function(value) {
	    if (this._eachValues !== null) {
	        this._eachValues.push(value);
	    }
	    return this._eachValues;
	};
	
	ReductionPromiseArray.prototype._init = function() {};
	
	ReductionPromiseArray.prototype._resolveEmptyArray = function() {
	    this._resolve(this._eachValues !== undefined ? this._eachValues
	                                                 : this._initialValue);
	};
	
	ReductionPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};
	
	ReductionPromiseArray.prototype._resolve = function(value) {
	    this._promise._resolveCallback(value);
	    this._values = null;
	};
	
	ReductionPromiseArray.prototype._resultCancelled = function(sender) {
	    if (sender === this._initialValue) return this._cancel();
	    if (this._isResolved()) return;
	    this._resultCancelled$();
	    if (this._currentCancellable instanceof Promise) {
	        this._currentCancellable.cancel();
	    }
	    if (this._initialValue instanceof Promise) {
	        this._initialValue.cancel();
	    }
	};
	
	ReductionPromiseArray.prototype._iterate = function (values) {
	    this._values = values;
	    var value;
	    var i;
	    var length = values.length;
	    if (this._initialValue !== undefined) {
	        value = this._initialValue;
	        i = 0;
	    } else {
	        value = Promise.resolve(values[0]);
	        i = 1;
	    }
	
	    this._currentCancellable = value;
	
	    if (!value.isRejected()) {
	        for (; i < length; ++i) {
	            var ctx = {
	                accum: null,
	                value: values[i],
	                index: i,
	                length: length,
	                array: this
	            };
	            value = value._then(gotAccum, undefined, undefined, ctx, undefined);
	        }
	    }
	
	    if (this._eachValues !== undefined) {
	        value = value
	            ._then(this._eachComplete, undefined, undefined, this, undefined);
	    }
	    value._then(completed, completed, undefined, value, this);
	};
	
	Promise.prototype.reduce = function (fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};
	
	Promise.reduce = function (promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};
	
	function completed(valueOrReason, array) {
	    if (this.isFulfilled()) {
	        array._resolve(valueOrReason);
	    } else {
	        array._reject(valueOrReason);
	    }
	}
	
	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}
	
	function gotAccum(accum) {
	    this.accum = accum;
	    this.array._gotAccum(accum);
	    var value = tryConvertToPromise(this.value, this.array._promise);
	    if (value instanceof Promise) {
	        this.array._currentCancellable = value;
	        return value._then(gotValue, undefined, undefined, this, undefined);
	    } else {
	        return gotValue.call(this, value);
	    }
	}
	
	function gotValue(value) {
	    var array = this.array;
	    var promise = array._promise;
	    var fn = tryCatch(array._fn);
	    promise._pushContext();
	    var ret;
	    if (array._eachValues !== undefined) {
	        ret = fn.call(promise._boundValue(), value, this.index, this.length);
	    } else {
	        ret = fn.call(promise._boundValue(),
	                              this.accum, value, this.index, this.length);
	    }
	    if (ret instanceof Promise) {
	        array._currentCancellable = ret;
	    }
	    var promiseCreated = promise._popContext();
	    debug.checkForgottenReturns(
	        ret,
	        promiseCreated,
	        array._eachValues !== undefined ? "Promise.each" : "Promise.reduce",
	        promise
	    );
	    return ret;
	}
	};


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports =
	    function(Promise, PromiseArray, debug) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = __webpack_require__(122);
	
	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);
	
	SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	        return true;
	    }
	    return false;
	};
	
	SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 33554432;
	    ret._settledValueField = value;
	    return this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 16777216;
	    ret._settledValueField = reason;
	    return this._promiseResolved(index, ret);
	};
	
	Promise.settle = function (promises) {
	    debug.deprecated(".settle()", ".reflect()");
	    return new SettledPromiseArray(promises).promise();
	};
	
	Promise.prototype.settle = function () {
	    return Promise.settle(this);
	};
	};


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = __webpack_require__(122);
	var RangeError = __webpack_require__(129).RangeError;
	var AggregateError = __webpack_require__(129).AggregateError;
	var isArray = util.isArray;
	var CANCELLATION = {};
	
	
	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);
	
	SomePromiseArray.prototype._init = function () {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(undefined, -5);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        this._reject(this._getRangeError(this.length()));
	    }
	};
	
	SomePromiseArray.prototype.init = function () {
	    this._initialized = true;
	    this._init();
	};
	
	SomePromiseArray.prototype.setUnwrap = function () {
	    this._unwrap = true;
	};
	
	SomePromiseArray.prototype.howMany = function () {
	    return this._howMany;
	};
	
	SomePromiseArray.prototype.setHowMany = function (count) {
	    this._howMany = count;
	};
	
	SomePromiseArray.prototype._promiseFulfilled = function (value) {
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	        return true;
	    }
	    return false;
	
	};
	SomePromiseArray.prototype._promiseRejected = function (reason) {
	    this._addRejected(reason);
	    return this._checkOutcome();
	};
	
	SomePromiseArray.prototype._promiseCancelled = function () {
	    if (this._values instanceof Promise || this._values == null) {
	        return this._cancel();
	    }
	    this._addRejected(CANCELLATION);
	    return this._checkOutcome();
	};
	
	SomePromiseArray.prototype._checkOutcome = function() {
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            if (this._values[i] !== CANCELLATION) {
	                e.push(this._values[i]);
	            }
	        }
	        if (e.length > 0) {
	            this._reject(e);
	        } else {
	            this._cancel();
	        }
	        return true;
	    }
	    return false;
	};
	
	SomePromiseArray.prototype._fulfilled = function () {
	    return this._totalResolved;
	};
	
	SomePromiseArray.prototype._rejected = function () {
	    return this._values.length - this.length();
	};
	
	SomePromiseArray.prototype._addRejected = function (reason) {
	    this._values.push(reason);
	};
	
	SomePromiseArray.prototype._addFulfilled = function (value) {
	    this._values[this._totalResolved++] = value;
	};
	
	SomePromiseArray.prototype._canPossiblyFulfill = function () {
	    return this.length() - this._rejected();
	};
	
	SomePromiseArray.prototype._getRangeError = function (count) {
	    var message = "Input array must contain at least " +
	            this._howMany + " items but contains only " + count + " items";
	    return new RangeError(message);
	};
	
	SomePromiseArray.prototype._resolveEmptyArray = function () {
	    this._reject(this._getRangeError(0));
	};
	
	function some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}
	
	Promise.some = function (promises, howMany) {
	    return some(promises, howMany);
	};
	
	Promise.prototype.some = function (howMany) {
	    return some(this, howMany);
	};
	
	Promise._SomePromiseArray = SomePromiseArray;
	};


/***/ }),
/* 155 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;
	
	Promise.prototype.filter = function (fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};
	
	Promise.filter = function (promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};


/***/ }),
/* 156 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;
	var PromiseAll = Promise.all;
	
	function promiseAllThis() {
	    return PromiseAll(this);
	}
	
	function PromiseMapSeries(promises, fn) {
	    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
	}
	
	Promise.prototype.each = function (fn) {
	    return PromiseReduce(this, fn, INTERNAL, 0)
	              ._then(promiseAllThis, undefined, undefined, this, undefined);
	};
	
	Promise.prototype.mapSeries = function (fn) {
	    return PromiseReduce(this, fn, INTERNAL, INTERNAL);
	};
	
	Promise.each = function (promises, fn) {
	    return PromiseReduce(promises, fn, INTERNAL, 0)
	              ._then(promiseAllThis, undefined, undefined, promises, undefined);
	};
	
	Promise.mapSeries = PromiseMapSeries;
	};
	


/***/ }),
/* 157 */
/***/ (function(module, exports) {

	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}
	
	Promise.any = function (promises) {
	    return any(promises);
	};
	
	Promise.prototype.any = function () {
	    return any(this);
	};
	
	};


/***/ }),
/* 158 */
/***/ (function(module, exports) {

	
	    //polyfill bind
	    if (!Function.prototype.bind) {
	        Function.prototype.bind = function(oThis) {
	            if (typeof this !== "function") {
	                // closest thing possible to the ECMAScript 5 internal IsCallable function
	                throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
	            }
	
	            var aArgs = Array.prototype.slice.call(arguments, 1),
	                fToBind = this,
	                fNOP = function() {},
	                fBound = function() {
	                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis || window,
	                        aArgs.concat(Array.prototype.slice.call(arguments)));
	                };
	
	            fNOP.prototype = this.prototype;
	            fBound.prototype = new fNOP();
	
	            return fBound;
	        };
	    }
	
	    //polyfill remove
	    if (!('remove' in Element.prototype)) {
	        Element.prototype.remove = function() {
	            if (this.parentNode) {
	                this.parentNode.removeChild(this);
	            }
	        };
	    }
	
	    if (!String.prototype.endsWith) {
	    String.prototype.endsWith = function(searchString, position) {
	        var subjectString = this.toString();
	        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
	            position = subjectString.length;
	        }
	        position -= searchString.length;
	        var lastIndex = subjectString.indexOf(searchString, position);
	        return lastIndex !== -1 && lastIndex === position;
	    };
	    }
	


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(160);
	
	var _zrender = __webpack_require__(65);
	
	var registerPainter = _zrender.registerPainter;
	
	var Painter = __webpack_require__(162);
	
	registerPainter('vml', Painter);

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	var env = __webpack_require__(49);
	
	var _vector = __webpack_require__(14);
	
	var applyTransform = _vector.applyTransform;
	
	var BoundingRect = __webpack_require__(26);
	
	var colorTool = __webpack_require__(19);
	
	var textContain = __webpack_require__(25);
	
	var textHelper = __webpack_require__(24);
	
	var RectText = __webpack_require__(23);
	
	var Displayable = __webpack_require__(7);
	
	var ZImage = __webpack_require__(44);
	
	var Text = __webpack_require__(45);
	
	var Path = __webpack_require__(6);
	
	var PathProxy = __webpack_require__(29);
	
	var Gradient = __webpack_require__(41);
	
	var vmlCore = __webpack_require__(161);
	
	// http://www.w3.org/TR/NOTE-VML
	// TODO Use proxy like svg instead of overwrite brush methods
	var CMD = PathProxy.CMD;
	var round = Math.round;
	var sqrt = Math.sqrt;
	var abs = Math.abs;
	var cos = Math.cos;
	var sin = Math.sin;
	var mathMax = Math.max;
	
	if (!env.canvasSupported) {
	  var comma = ',';
	  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';
	  var Z = 21600;
	  var Z2 = Z / 2;
	  var ZLEVEL_BASE = 100000;
	  var Z_BASE = 1000;
	
	  var initRootElStyle = function (el) {
	    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';
	    el.coordsize = Z + ',' + Z;
	    el.coordorigin = '0,0';
	  };
	
	  var encodeHtmlAttribute = function (s) {
	    return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
	  };
	
	  var rgb2Str = function (r, g, b) {
	    return 'rgb(' + [r, g, b].join(',') + ')';
	  };
	
	  var append = function (parent, child) {
	    if (child && parent && child.parentNode !== parent) {
	      parent.appendChild(child);
	    }
	  };
	
	  var remove = function (parent, child) {
	    if (child && parent && child.parentNode === parent) {
	      parent.removeChild(child);
	    }
	  };
	
	  var getZIndex = function (zlevel, z, z2) {
	    // z 的取值范围为 [0, 1000]
	    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
	  };
	
	  var parsePercent = function (value, maxValue) {
	    if (typeof value === 'string') {
	      if (value.lastIndexOf('%') >= 0) {
	        return parseFloat(value) / 100 * maxValue;
	      }
	
	      return parseFloat(value);
	    }
	
	    return value;
	  };
	  /***************************************************
	   * PATH
	   **************************************************/
	
	
	  var setColorAndOpacity = function (el, color, opacity) {
	    var colorArr = colorTool.parse(color);
	    opacity = +opacity;
	
	    if (isNaN(opacity)) {
	      opacity = 1;
	    }
	
	    if (colorArr) {
	      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
	      el.opacity = opacity * colorArr[3];
	    }
	  };
	
	  var getColorAndAlpha = function (color) {
	    var colorArr = colorTool.parse(color);
	    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];
	  };
	
	  var updateFillNode = function (el, style, zrEl) {
	    // TODO pattern
	    var fill = style.fill;
	
	    if (fill != null) {
	      // Modified from excanvas
	      if (fill instanceof Gradient) {
	        var gradientType;
	        var angle = 0;
	        var focus = [0, 0]; // additional offset
	
	        var shift = 0; // scale factor for offset
	
	        var expansion = 1;
	        var rect = zrEl.getBoundingRect();
	        var rectWidth = rect.width;
	        var rectHeight = rect.height;
	
	        if (fill.type === 'linear') {
	          gradientType = 'gradient';
	          var transform = zrEl.transform;
	          var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];
	
	          if (transform) {
	            applyTransform(p0, p0, transform);
	            applyTransform(p1, p1, transform);
	          }
	
	          var dx = p1[0] - p0[0];
	          var dy = p1[1] - p0[1];
	          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.
	
	          if (angle < 0) {
	            angle += 360;
	          } // Very small angles produce an unexpected result because they are
	          // converted to a scientific notation string.
	
	
	          if (angle < 1e-6) {
	            angle = 0;
	          }
	        } else {
	          gradientType = 'gradientradial';
	          var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	          var transform = zrEl.transform;
	          var scale = zrEl.scale;
	          var width = rectWidth;
	          var height = rectHeight;
	          focus = [// Percent in bounding rect
	          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];
	
	          if (transform) {
	            applyTransform(p0, p0, transform);
	          }
	
	          width /= scale[0] * Z;
	          height /= scale[1] * Z;
	          var dimension = mathMax(width, height);
	          shift = 2 * 0 / dimension;
	          expansion = 2 * fill.r / dimension - shift;
	        } // We need to sort the color stops in ascending order by offset,
	        // otherwise IE won't interpret it correctly.
	
	
	        var stops = fill.colorStops.slice();
	        stops.sort(function (cs1, cs2) {
	          return cs1.offset - cs2.offset;
	        });
	        var length = stops.length; // Color and alpha list of first and last stop
	
	        var colorAndAlphaList = [];
	        var colors = [];
	
	        for (var i = 0; i < length; i++) {
	          var stop = stops[i];
	          var colorAndAlpha = getColorAndAlpha(stop.color);
	          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);
	
	          if (i === 0 || i === length - 1) {
	            colorAndAlphaList.push(colorAndAlpha);
	          }
	        }
	
	        if (length >= 2) {
	          var color1 = colorAndAlphaList[0][0];
	          var color2 = colorAndAlphaList[1][0];
	          var opacity1 = colorAndAlphaList[0][1] * style.opacity;
	          var opacity2 = colorAndAlphaList[1][1] * style.opacity;
	          el.type = gradientType;
	          el.method = 'none';
	          el.focus = '100%';
	          el.angle = angle;
	          el.color = color1;
	          el.color2 = color2;
	          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2
	          // are reversed.
	
	          el.opacity = opacity2; // FIXME g_o_:opacity ?
	
	          el.opacity2 = opacity1;
	        }
	
	        if (gradientType === 'radial') {
	          el.focusposition = focus.join(',');
	        }
	      } else {
	        // FIXME Change from Gradient fill to color fill
	        setColorAndOpacity(el, fill, style.opacity);
	      }
	    }
	  };
	
	  var updateStrokeNode = function (el, style) {
	    // if (style.lineJoin != null) {
	    //     el.joinstyle = style.lineJoin;
	    // }
	    // if (style.miterLimit != null) {
	    //     el.miterlimit = style.miterLimit * Z;
	    // }
	    // if (style.lineCap != null) {
	    //     el.endcap = style.lineCap;
	    // }
	    if (style.lineDash != null) {
	      el.dashstyle = style.lineDash.join(' ');
	    }
	
	    if (style.stroke != null && !(style.stroke instanceof Gradient)) {
	      setColorAndOpacity(el, style.stroke, style.opacity);
	    }
	  };
	
	  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {
	    var isFill = type == 'fill';
	    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth
	
	    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {
	      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error
	
	      if (style[type] instanceof Gradient) {
	        remove(vmlEl, el);
	      }
	
	      if (!el) {
	        el = vmlCore.createNode(type);
	      }
	
	      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
	      append(vmlEl, el);
	    } else {
	      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';
	      remove(vmlEl, el);
	    }
	  };
	
	  var points = [[], [], []];
	
	  var pathDataToString = function (path, m) {
	    var M = CMD.M;
	    var C = CMD.C;
	    var L = CMD.L;
	    var A = CMD.A;
	    var Q = CMD.Q;
	    var str = [];
	    var nPoint;
	    var cmdStr;
	    var cmd;
	    var i;
	    var xi;
	    var yi;
	    var data = path.data;
	    var dataLength = path.len();
	
	    for (i = 0; i < dataLength;) {
	      cmd = data[i++];
	      cmdStr = '';
	      nPoint = 0;
	
	      switch (cmd) {
	        case M:
	          cmdStr = ' m ';
	          nPoint = 1;
	          xi = data[i++];
	          yi = data[i++];
	          points[0][0] = xi;
	          points[0][1] = yi;
	          break;
	
	        case L:
	          cmdStr = ' l ';
	          nPoint = 1;
	          xi = data[i++];
	          yi = data[i++];
	          points[0][0] = xi;
	          points[0][1] = yi;
	          break;
	
	        case Q:
	        case C:
	          cmdStr = ' c ';
	          nPoint = 3;
	          var x1 = data[i++];
	          var y1 = data[i++];
	          var x2 = data[i++];
	          var y2 = data[i++];
	          var x3;
	          var y3;
	
	          if (cmd === Q) {
	            // Convert quadratic to cubic using degree elevation
	            x3 = x2;
	            y3 = y2;
	            x2 = (x2 + 2 * x1) / 3;
	            y2 = (y2 + 2 * y1) / 3;
	            x1 = (xi + 2 * x1) / 3;
	            y1 = (yi + 2 * y1) / 3;
	          } else {
	            x3 = data[i++];
	            y3 = data[i++];
	          }
	
	          points[0][0] = x1;
	          points[0][1] = y1;
	          points[1][0] = x2;
	          points[1][1] = y2;
	          points[2][0] = x3;
	          points[2][1] = y3;
	          xi = x3;
	          yi = y3;
	          break;
	
	        case A:
	          var x = 0;
	          var y = 0;
	          var sx = 1;
	          var sy = 1;
	          var angle = 0;
	
	          if (m) {
	            // Extract SRT from matrix
	            x = m[4];
	            y = m[5];
	            sx = sqrt(m[0] * m[0] + m[1] * m[1]);
	            sy = sqrt(m[2] * m[2] + m[3] * m[3]);
	            angle = Math.atan2(-m[1] / sy, m[0] / sx);
	          }
	
	          var cx = data[i++];
	          var cy = data[i++];
	          var rx = data[i++];
	          var ry = data[i++];
	          var startAngle = data[i++] + angle;
	          var endAngle = data[i++] + startAngle + angle; // FIXME
	          // var psi = data[i++];
	
	          i++;
	          var clockwise = data[i++];
	          var x0 = cx + cos(startAngle) * rx;
	          var y0 = cy + sin(startAngle) * ry;
	          var x1 = cx + cos(endAngle) * rx;
	          var y1 = cy + sin(endAngle) * ry;
	          var type = clockwise ? ' wa ' : ' at ';
	
	          if (Math.abs(x0 - x1) < 1e-4) {
	            // IE won't render arches drawn counter clockwise if x0 == x1.
	            if (Math.abs(endAngle - startAngle) > 1e-2) {
	              // Offset x0 by 1/80 of a pixel. Use something
	              // that can be represented in binary
	              if (clockwise) {
	                x0 += 270 / Z;
	              }
	            } else {
	              // Avoid case draw full circle
	              if (Math.abs(y0 - cy) < 1e-4) {
	                if (clockwise && x0 < cx || !clockwise && x0 > cx) {
	                  y1 -= 270 / Z;
	                } else {
	                  y1 += 270 / Z;
	                }
	              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {
	                x1 += 270 / Z;
	              } else {
	                x1 -= 270 / Z;
	              }
	            }
	          }
	
	          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));
	          xi = x1;
	          yi = y1;
	          break;
	
	        case CMD.R:
	          var p0 = points[0];
	          var p1 = points[1]; // x0, y0
	
	          p0[0] = data[i++];
	          p0[1] = data[i++]; // x1, y1
	
	          p1[0] = p0[0] + data[i++];
	          p1[1] = p0[1] + data[i++];
	
	          if (m) {
	            applyTransform(p0, p0, m);
	            applyTransform(p1, p1, m);
	          }
	
	          p0[0] = round(p0[0] * Z - Z2);
	          p1[0] = round(p1[0] * Z - Z2);
	          p0[1] = round(p0[1] * Z - Z2);
	          p1[1] = round(p1[1] * Z - Z2);
	          str.push( // x0, y0
	          ' m ', p0[0], comma, p0[1], // x1, y0
	          ' l ', p1[0], comma, p0[1], // x1, y1
	          ' l ', p1[0], comma, p1[1], // x0, y1
	          ' l ', p0[0], comma, p1[1]);
	          break;
	
	        case CMD.Z:
	          // FIXME Update xi, yi
	          str.push(' x ');
	      }
	
	      if (nPoint > 0) {
	        str.push(cmdStr);
	
	        for (var k = 0; k < nPoint; k++) {
	          var p = points[k];
	          m && applyTransform(p, p, m); // 不 round 会非常慢
	
	          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');
	        }
	      }
	    }
	
	    return str.join('');
	  }; // Rewrite the original path method
	
	
	  Path.prototype.brushVML = function (vmlRoot) {
	    var style = this.style;
	    var vmlEl = this._vmlEl;
	
	    if (!vmlEl) {
	      vmlEl = vmlCore.createNode('shape');
	      initRootElStyle(vmlEl);
	      this._vmlEl = vmlEl;
	    }
	
	    updateFillAndStroke(vmlEl, 'fill', style, this);
	    updateFillAndStroke(vmlEl, 'stroke', style, this);
	    var m = this.transform;
	    var needTransform = m != null;
	    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];
	
	    if (strokeEl) {
	      var lineWidth = style.lineWidth; // Get the line scale.
	      // Determinant of this.m_ means how much the area is enlarged by the
	      // transformation. So its square root can be used as a scale factor
	      // for width.
	
	      if (needTransform && !style.strokeNoScale) {
	        var det = m[0] * m[3] - m[1] * m[2];
	        lineWidth *= sqrt(abs(det));
	      }
	
	      strokeEl.weight = lineWidth + 'px';
	    }
	
	    var path = this.path || (this.path = new PathProxy());
	
	    if (this.__dirtyPath) {
	      path.beginPath();
	      this.buildPath(path, this.shape);
	      path.toStatic();
	      this.__dirtyPath = false;
	    }
	
	    vmlEl.path = pathDataToString(path, this.transform);
	    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root
	
	    append(vmlRoot, vmlEl); // Text
	
	    if (style.text != null) {
	      this.drawRectText(vmlRoot, this.getBoundingRect());
	    } else {
	      this.removeRectText(vmlRoot);
	    }
	  };
	
	  Path.prototype.onRemove = function (vmlRoot) {
	    remove(vmlRoot, this._vmlEl);
	    this.removeRectText(vmlRoot);
	  };
	
	  Path.prototype.onAdd = function (vmlRoot) {
	    append(vmlRoot, this._vmlEl);
	    this.appendRectText(vmlRoot);
	  };
	  /***************************************************
	   * IMAGE
	   **************************************************/
	
	
	  var isImage = function (img) {
	    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错
	    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;
	  }; // Rewrite the original path method
	
	
	  ZImage.prototype.brushVML = function (vmlRoot) {
	    var style = this.style;
	    var image = style.image; // Image original width, height
	
	    var ow;
	    var oh;
	
	    if (isImage(image)) {
	      var src = image.src;
	
	      if (src === this._imageSrc) {
	        ow = this._imageWidth;
	        oh = this._imageHeight;
	      } else {
	        var imageRuntimeStyle = image.runtimeStyle;
	        var oldRuntimeWidth = imageRuntimeStyle.width;
	        var oldRuntimeHeight = imageRuntimeStyle.height;
	        imageRuntimeStyle.width = 'auto';
	        imageRuntimeStyle.height = 'auto'; // get the original size
	
	        ow = image.width;
	        oh = image.height; // and remove overides
	
	        imageRuntimeStyle.width = oldRuntimeWidth;
	        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src
	
	        this._imageSrc = src;
	        this._imageWidth = ow;
	        this._imageHeight = oh;
	      }
	
	      image = src;
	    } else {
	      if (image === this._imageSrc) {
	        ow = this._imageWidth;
	        oh = this._imageHeight;
	      }
	    }
	
	    if (!image) {
	      return;
	    }
	
	    var x = style.x || 0;
	    var y = style.y || 0;
	    var dw = style.width;
	    var dh = style.height;
	    var sw = style.sWidth;
	    var sh = style.sHeight;
	    var sx = style.sx || 0;
	    var sy = style.sy || 0;
	    var hasCrop = sw && sh;
	    var vmlEl = this._vmlEl;
	
	    if (!vmlEl) {
	      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。
	      // vmlEl = vmlCore.createNode('group');
	      vmlEl = vmlCore.doc.createElement('div');
	      initRootElStyle(vmlEl);
	      this._vmlEl = vmlEl;
	    }
	
	    var vmlElStyle = vmlEl.style;
	    var hasRotation = false;
	    var m;
	    var scaleX = 1;
	    var scaleY = 1;
	
	    if (this.transform) {
	      m = this.transform;
	      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
	      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
	      hasRotation = m[1] || m[2];
	    }
	
	    if (hasRotation) {
	      // If filters are necessary (rotation exists), create them
	      // filters are bog-slow, so only create them if abbsolutely necessary
	      // The following check doesn't account for skews (which don't exist
	      // in the canvas spec (yet) anyway.
	      // From excanvas
	      var p0 = [x, y];
	      var p1 = [x + dw, y];
	      var p2 = [x, y + dh];
	      var p3 = [x + dw, y + dh];
	      applyTransform(p0, p0, m);
	      applyTransform(p1, p1, m);
	      applyTransform(p2, p2, m);
	      applyTransform(p3, p3, m);
	      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
	      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
	      var transformFilter = [];
	      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));
	      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用
	
	      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';
	    } else {
	      if (m) {
	        x = x * scaleX + m[4];
	        y = y * scaleY + m[5];
	      }
	
	      vmlElStyle.filter = '';
	      vmlElStyle.left = round(x) + 'px';
	      vmlElStyle.top = round(y) + 'px';
	    }
	
	    var imageEl = this._imageEl;
	    var cropEl = this._cropEl;
	
	    if (!imageEl) {
	      imageEl = vmlCore.doc.createElement('div');
	      this._imageEl = imageEl;
	    }
	
	    var imageELStyle = imageEl.style;
	
	    if (hasCrop) {
	      // Needs know image original width and height
	      if (!(ow && oh)) {
	        var tmpImage = new Image();
	        var self = this;
	
	        tmpImage.onload = function () {
	          tmpImage.onload = null;
	          ow = tmpImage.width;
	          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize
	
	          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src
	
	          self._imageWidth = ow;
	          self._imageHeight = oh;
	          self._imageSrc = image;
	        };
	
	        tmpImage.src = image;
	      } else {
	        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
	      }
	
	      if (!cropEl) {
	        cropEl = vmlCore.doc.createElement('div');
	        cropEl.style.overflow = 'hidden';
	        this._cropEl = cropEl;
	      }
	
	      var cropElStyle = cropEl.style;
	      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
	      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
	      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';
	
	      if (!cropEl.parentNode) {
	        vmlEl.appendChild(cropEl);
	      }
	
	      if (imageEl.parentNode != cropEl) {
	        cropEl.appendChild(imageEl);
	      }
	    } else {
	      imageELStyle.width = round(scaleX * dw) + 'px';
	      imageELStyle.height = round(scaleY * dh) + 'px';
	      vmlEl.appendChild(imageEl);
	
	      if (cropEl && cropEl.parentNode) {
	        vmlEl.removeChild(cropEl);
	        this._cropEl = null;
	      }
	    }
	
	    var filterStr = '';
	    var alpha = style.opacity;
	
	    if (alpha < 1) {
	      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';
	    }
	
	    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';
	    imageELStyle.filter = filterStr;
	    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root
	
	    append(vmlRoot, vmlEl); // Text
	
	    if (style.text != null) {
	      this.drawRectText(vmlRoot, this.getBoundingRect());
	    }
	  };
	
	  ZImage.prototype.onRemove = function (vmlRoot) {
	    remove(vmlRoot, this._vmlEl);
	    this._vmlEl = null;
	    this._cropEl = null;
	    this._imageEl = null;
	    this.removeRectText(vmlRoot);
	  };
	
	  ZImage.prototype.onAdd = function (vmlRoot) {
	    append(vmlRoot, this._vmlEl);
	    this.appendRectText(vmlRoot);
	  };
	  /***************************************************
	   * TEXT
	   **************************************************/
	
	
	  var DEFAULT_STYLE_NORMAL = 'normal';
	  var fontStyleCache = {};
	  var fontStyleCacheCount = 0;
	  var MAX_FONT_CACHE_SIZE = 100;
	  var fontEl = document.createElement('div');
	
	  var getFontStyle = function (fontString) {
	    var fontStyle = fontStyleCache[fontString];
	
	    if (!fontStyle) {
	      // Clear cache
	      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
	        fontStyleCacheCount = 0;
	        fontStyleCache = {};
	      }
	
	      var style = fontEl.style;
	      var fontFamily;
	
	      try {
	        style.font = fontString;
	        fontFamily = style.fontFamily.split(',')[0];
	      } catch (e) {}
	
	      fontStyle = {
	        style: style.fontStyle || DEFAULT_STYLE_NORMAL,
	        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
	        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
	        size: parseFloat(style.fontSize || 12) | 0,
	        family: fontFamily || 'Microsoft YaHei'
	      };
	      fontStyleCache[fontString] = fontStyle;
	      fontStyleCacheCount++;
	    }
	
	    return fontStyle;
	  };
	
	  var textMeasureEl; // Overwrite measure text method
	
	  textContain.$override('measureText', function (text, textFont) {
	    var doc = vmlCore.doc;
	
	    if (!textMeasureEl) {
	      textMeasureEl = doc.createElement('div');
	      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';
	      vmlCore.doc.body.appendChild(textMeasureEl);
	    }
	
	    try {
	      textMeasureEl.style.font = textFont;
	    } catch (ex) {// Ignore failures to set to invalid font.
	    }
	
	    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.
	
	    textMeasureEl.appendChild(doc.createTextNode(text));
	    return {
	      width: textMeasureEl.offsetWidth
	    };
	  });
	  var tmpRect = new BoundingRect();
	
	  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {
	    var style = this.style; // Optimize, avoid normalize every time.
	
	    this.__dirty && textHelper.normalizeTextStyle(style, true);
	    var text = style.text; // Convert to string
	
	    text != null && (text += '');
	
	    if (!text) {
	      return;
	    } // Convert rich text to plain text. Rich text is not supported in
	    // IE8-, but tags in rich text template will be removed.
	
	
	    if (style.rich) {
	      var contentBlock = textContain.parseRichText(text, style);
	      text = [];
	
	      for (var i = 0; i < contentBlock.lines.length; i++) {
	        var tokens = contentBlock.lines[i].tokens;
	        var textLine = [];
	
	        for (var j = 0; j < tokens.length; j++) {
	          textLine.push(tokens[j].text);
	        }
	
	        text.push(textLine.join(''));
	      }
	
	      text = text.join('\n');
	    }
	
	    var x;
	    var y;
	    var align = style.textAlign;
	    var verticalAlign = style.textVerticalAlign;
	    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?
	
	    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px "' + fontStyle.family + '"';
	    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign); // Transform rect to view space
	
	    var m = this.transform; // Ignore transform for text in other element
	
	    if (m && !fromTextEl) {
	      tmpRect.copy(rect);
	      tmpRect.applyTransform(m);
	      rect = tmpRect;
	    }
	
	    if (!fromTextEl) {
	      var textPosition = style.textPosition;
	      var distance = style.textDistance; // Text position represented by coord
	
	      if (textPosition instanceof Array) {
	        x = rect.x + parsePercent(textPosition[0], rect.width);
	        y = rect.y + parsePercent(textPosition[1], rect.height);
	        align = align || 'left';
	      } else {
	        var res = textContain.adjustTextPositionOnRect(textPosition, rect, distance);
	        x = res.x;
	        y = res.y; // Default align and baseline when has textPosition
	
	        align = align || res.textAlign;
	        verticalAlign = verticalAlign || res.textVerticalAlign;
	      }
	    } else {
	      x = rect.x;
	      y = rect.y;
	    }
	
	    x = textContain.adjustTextX(x, textRect.width, align);
	    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'
	
	    y += textRect.height / 2; // var fontSize = fontStyle.size;
	    // 1.75 is an arbitrary number, as there is no info about the text baseline
	    // switch (baseline) {
	    // case 'hanging':
	    // case 'top':
	    //     y += fontSize / 1.75;
	    //     break;
	    //     case 'middle':
	    //         break;
	    //     default:
	    //     // case null:
	    //     // case 'alphabetic':
	    //     // case 'ideographic':
	    //     // case 'bottom':
	    //         y -= fontSize / 2.25;
	    //         break;
	    // }
	    // switch (align) {
	    //     case 'left':
	    //         break;
	    //     case 'center':
	    //         x -= textRect.width / 2;
	    //         break;
	    //     case 'right':
	    //         x -= textRect.width;
	    //         break;
	    // case 'end':
	    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';
	    // break;
	    // case 'start':
	    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';
	    // break;
	    // default:
	    //     align = 'left';
	    // }
	
	    var createNode = vmlCore.createNode;
	    var textVmlEl = this._textVmlEl;
	    var pathEl;
	    var textPathEl;
	    var skewEl;
	
	    if (!textVmlEl) {
	      textVmlEl = createNode('line');
	      pathEl = createNode('path');
	      textPathEl = createNode('textpath');
	      skewEl = createNode('skew'); // FIXME Why here is not cammel case
	      // Align 'center' seems wrong
	
	      textPathEl.style['v-text-align'] = 'left';
	      initRootElStyle(textVmlEl);
	      pathEl.textpathok = true;
	      textPathEl.on = true;
	      textVmlEl.from = '0 0';
	      textVmlEl.to = '1000 0.05';
	      append(textVmlEl, skewEl);
	      append(textVmlEl, pathEl);
	      append(textVmlEl, textPathEl);
	      this._textVmlEl = textVmlEl;
	    } else {
	      // 这里是在前面 appendChild 保证顺序的前提下
	      skewEl = textVmlEl.firstChild;
	      pathEl = skewEl.nextSibling;
	      textPathEl = pathEl.nextSibling;
	    }
	
	    var coords = [x, y];
	    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element
	
	    if (m && fromTextEl) {
	      applyTransform(coords, coords, m);
	      skewEl.on = true;
	      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position
	
	      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin
	
	      skewEl.origin = '0 0';
	      textVmlElStyle.left = '0px';
	      textVmlElStyle.top = '0px';
	    } else {
	      skewEl.on = false;
	      textVmlElStyle.left = round(x) + 'px';
	      textVmlElStyle.top = round(y) + 'px';
	    }
	
	    textPathEl.string = encodeHtmlAttribute(text); // TODO
	
	    try {
	      textPathEl.style.font = font;
	    } // Error font format
	    catch (e) {}
	
	    updateFillAndStroke(textVmlEl, 'fill', {
	      fill: style.textFill,
	      opacity: style.opacity
	    }, this);
	    updateFillAndStroke(textVmlEl, 'stroke', {
	      stroke: style.textStroke,
	      opacity: style.opacity,
	      lineDash: style.lineDash
	    }, this);
	    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root
	
	    append(vmlRoot, textVmlEl);
	  };
	
	  var removeRectText = function (vmlRoot) {
	    remove(vmlRoot, this._textVmlEl);
	    this._textVmlEl = null;
	  };
	
	  var appendRectText = function (vmlRoot) {
	    append(vmlRoot, this._textVmlEl);
	  };
	
	  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText
	
	  for (var i = 0; i < list.length; i++) {
	    var proto = list[i].prototype;
	    proto.drawRectText = drawRectText;
	    proto.removeRectText = removeRectText;
	    proto.appendRectText = appendRectText;
	  }
	
	  Text.prototype.brushVML = function (vmlRoot) {
	    var style = this.style;
	
	    if (style.text != null) {
	      this.drawRectText(vmlRoot, {
	        x: style.x || 0,
	        y: style.y || 0,
	        width: 0,
	        height: 0
	      }, this.getBoundingRect(), true);
	    } else {
	      this.removeRectText(vmlRoot);
	    }
	  };
	
	  Text.prototype.onRemove = function (vmlRoot) {
	    this.removeRectText(vmlRoot);
	  };
	
	  Text.prototype.onAdd = function (vmlRoot) {
	    this.appendRectText(vmlRoot);
	  };
	}

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	var env = __webpack_require__(49);
	
	var urn = 'urn:schemas-microsoft-com:vml';
	var win = typeof window === 'undefined' ? null : window;
	var vmlInited = false;
	var doc = win && win.document;
	
	function createNode(tagName) {
	  return doCreateNode(tagName);
	} // Avoid assign to an exported variable, for transforming to cjs.
	
	
	var doCreateNode;
	
	if (doc && !env.canvasSupported) {
	  try {
	    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);
	
	    doCreateNode = function (tagName) {
	      return doc.createElement('<zrvml:' + tagName + ' class="zrvml">');
	    };
	  } catch (e) {
	    doCreateNode = function (tagName) {
	      return doc.createElement('<' + tagName + ' xmlns="' + urn + '" class="zrvml">');
	    };
	  }
	} // From raphael
	
	
	function initVML() {
	  if (vmlInited || !doc) {
	    return;
	  }
	
	  vmlInited = true;
	  var styleSheets = doc.styleSheets;
	
	  if (styleSheets.length < 31) {
	    doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');
	  } else {
	    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
	    styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');
	  }
	}
	
	exports.doc = doc;
	exports.createNode = createNode;
	exports.initVML = initVML;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	var zrLog = __webpack_require__(21);
	
	var vmlCore = __webpack_require__(161);
	
	var _util = __webpack_require__(4);
	
	var each = _util.each;
	
	/**
	 * VML Painter.
	 *
	 * @module zrender/vml/Painter
	 */
	function parseInt10(val) {
	  return parseInt(val, 10);
	}
	/**
	 * @alias module:zrender/vml/Painter
	 */
	
	
	function VMLPainter(root, storage) {
	  vmlCore.initVML();
	  this.root = root;
	  this.storage = storage;
	  var vmlViewport = document.createElement('div');
	  var vmlRoot = document.createElement('div');
	  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';
	  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';
	  root.appendChild(vmlViewport);
	  this._vmlRoot = vmlRoot;
	  this._vmlViewport = vmlViewport;
	  this.resize(); // Modify storage
	
	  var oldDelFromStorage = storage.delFromStorage;
	  var oldAddToStorage = storage.addToStorage;
	
	  storage.delFromStorage = function (el) {
	    oldDelFromStorage.call(storage, el);
	
	    if (el) {
	      el.onRemove && el.onRemove(vmlRoot);
	    }
	  };
	
	  storage.addToStorage = function (el) {
	    // Displayable already has a vml node
	    el.onAdd && el.onAdd(vmlRoot);
	    oldAddToStorage.call(storage, el);
	  };
	
	  this._firstPaint = true;
	}
	
	VMLPainter.prototype = {
	  constructor: VMLPainter,
	  getType: function () {
	    return 'vml';
	  },
	
	  /**
	   * @return {HTMLDivElement}
	   */
	  getViewportRoot: function () {
	    return this._vmlViewport;
	  },
	  getViewportRootOffset: function () {
	    var viewportRoot = this.getViewportRoot();
	
	    if (viewportRoot) {
	      return {
	        offsetLeft: viewportRoot.offsetLeft || 0,
	        offsetTop: viewportRoot.offsetTop || 0
	      };
	    }
	  },
	
	  /**
	   * 刷新
	   */
	  refresh: function () {
	    var list = this.storage.getDisplayList(true, true);
	
	    this._paintList(list);
	  },
	  _paintList: function (list) {
	    var vmlRoot = this._vmlRoot;
	
	    for (var i = 0; i < list.length; i++) {
	      var el = list[i];
	
	      if (el.invisible || el.ignore) {
	        if (!el.__alreadyNotVisible) {
	          el.onRemove(vmlRoot);
	        } // Set as already invisible
	
	
	        el.__alreadyNotVisible = true;
	      } else {
	        if (el.__alreadyNotVisible) {
	          el.onAdd(vmlRoot);
	        }
	
	        el.__alreadyNotVisible = false;
	
	        if (el.__dirty) {
	          el.beforeBrush && el.beforeBrush();
	          (el.brushVML || el.brush).call(el, vmlRoot);
	          el.afterBrush && el.afterBrush();
	        }
	      }
	
	      el.__dirty = false;
	    }
	
	    if (this._firstPaint) {
	      // Detached from document at first time
	      // to avoid page refreshing too many times
	      // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变
	      this._vmlViewport.appendChild(vmlRoot);
	
	      this._firstPaint = false;
	    }
	  },
	  resize: function (width, height) {
	    var width = width == null ? this._getWidth() : width;
	    var height = height == null ? this._getHeight() : height;
	
	    if (this._width != width || this._height != height) {
	      this._width = width;
	      this._height = height;
	      var vmlViewportStyle = this._vmlViewport.style;
	      vmlViewportStyle.width = width + 'px';
	      vmlViewportStyle.height = height + 'px';
	    }
	  },
	  dispose: function () {
	    this.root.innerHTML = '';
	    this._vmlRoot = this._vmlViewport = this.storage = null;
	  },
	  getWidth: function () {
	    return this._width;
	  },
	  getHeight: function () {
	    return this._height;
	  },
	  clear: function () {
	    if (this._vmlViewport) {
	      this.root.removeChild(this._vmlViewport);
	    }
	  },
	  _getWidth: function () {
	    var root = this.root;
	    var stl = root.currentStyle;
	    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;
	  },
	  _getHeight: function () {
	    var root = this.root;
	    var stl = root.currentStyle;
	    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;
	  }
	}; // Not supported methods
	
	function createMethodNotSupport(method) {
	  return function () {
	    zrLog('In IE8.0 VML mode painter not support method "' + method + '"');
	  };
	} // Unsupported methods
	
	
	each(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {
	  VMLPainter.prototype[name] = createMethodNotSupport(name);
	});
	var _default = VMLPainter;
	module.exports = _default;

/***/ })
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA5NDA1YjgyMjczMmI0OTE2ZjgyYiIsIndlYnBhY2s6Ly8vLi9pbmRleC5icG1uLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvRmlzaFRvcG9CcG1uLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1N0eWxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS92ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vZWFzaW5nLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdG9vbC9jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvTFJVLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL21peGluL1JlY3RUZXh0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvY3VydmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2Jib3guanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL2xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL2N1YmljLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9xdWFkcmF0aWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL2FyYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vd2luZGluZ0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdHRlcm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi90b29sL3RyYW5zZm9ybVBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9maXhDbGlwV2l0aFNoYWRvdy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZW52LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aFNwbGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aEJlemllci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0xpbmVhckdyYWRpZW50LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvU3RhdGVzLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvRXh0ZW5zaW9uQXBpLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi96cmVuZGVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL1N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9QYWludGVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9kb20vSGFuZGxlclByb3h5LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9HZXN0dXJlTWdyLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvQnBtblV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTGluZVN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvQlBNTk5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Ob2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvY2xhenouanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9tb2RlbC9CUE1OTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZXZlbnQvU3RhcnRFdmVudE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2V2ZW50L0V2ZW50Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZXZlbnQvRW5kRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1VzZXJUYXNrTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvdGFzay9UYXNrTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvdGFzay9NYW51YWxUYXNrTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvdGFzay9TY3JpcHRUYXNrTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvdGFzay9NYWlsVGFza05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL3Rhc2svU2VydmljZVRhc2tOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1Ntc1Rhc2tOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9Db21tZW50Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZXZlbnQvYm91bmRhcnlldmVudC9DYXRjaFRpbWVyRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L0NhdGNoU2lnbmFsRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L1Rocm93U2lnbmFsRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9DYXRjaE1lc3NhZ2VFdmVudE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvSW5jbHVzaXZlR2F0ZXdheU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvR2F0ZXdheU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvRXhjbHVzaXZlR2F0ZXdheU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvUGFyYWxsZWxHYXRld2F5Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvU3ViUHJvY2Vzc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9CcG1uLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvSGFuZGxlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0VmZmVjdExpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdGlvblBvaW50LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9Hcm91cE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL0JwbW5PcGVyYXRpb25Ob2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9PcGVyYXRpb25Ob2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9JY29uT3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbWFuYWdlci9CcG1uQ29ubmVjdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0Nvbm5lY3Rpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTG9nLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9MaW5lT3BlcmF0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvR3VpZGVsaW5lcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvYmx1ZWJpcmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2VzNS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvYXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3NjaGVkdWxlLmpzIiwid2VicGFjazovLy8uL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3F1ZXVlLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3RoZW5hYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvcHJvbWlzZV9hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvZGVidWdnYWJpbGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvZmluYWxseS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvY2F0Y2hfZmlsdGVyLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9ub2RlYmFjay5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvbWV0aG9kLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9iaW5kLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9jYW5jZWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2RpcmVjdF9yZXNvbHZlLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9zeW5jaHJvbm91c19pbnNwZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9qb2luLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2NhbGxfZ2V0LmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS91c2luZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvdGltZXJzLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9nZW5lcmF0b3JzLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9ub2RlaWZ5LmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3Byb3BzLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9yYWNlLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2Uvc29tZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvZmlsdGVyLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9lYWNoLmpzIiwid2VicGFjazovLy8uL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9hbnkuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3ZtbC92bWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi92bWwvZ3JhcGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3ZtbC9jb3JlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdm1sL1BhaW50ZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFxRDtBQUNyRDtBQUNBLCtEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBcUQsYUFBYTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOzs7QUFHSDtBQUNBLFNBQVE7O0FBRVIsY0FBYSxlQUFlO0FBQzVCO0FBQ0EsSUFBRzs7O0FBR0gsMkJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBbUM7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCLFNBQVM7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1DQUFrQzs7QUFFbEM7O0FBRUE7QUFD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QTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNa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QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLDJCOzs7Ozs7QUN2VUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EscUJBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFH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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELDJCOzs7Ozs7QUN2Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsMkI7Ozs7OztBQ3JEQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNy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Q0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWUsYUFBYTtBQUM1QjtBQUNB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O0FBQ0E7O0FBRUE7Ozs7QUFJQSx3QkFBdUIsWUFBWTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7Ozs7Ozs7OztBQ241Q0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEI7QUFDMUIsMEJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DO0FBQ0EsOEM7QUFDQSxnQztBQUNBLHVDO0FBQ0Esd0M7QUFDQSxzQztBQUNBLDZCO0FBQ0EsOEI7QUFDQSxNO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLEtBQUssRTtBQUNwQixnQkFBZSxLQUFLLEU7QUFDcEIsZ0JBQWUsS0FBSyxFO0FBQ3BCLGtCO0FBQ0EsMkJBQTBCLEU7QUFDMUIsMEI7QUFDQSxzQjtBQUNBLHNDO0FBQ0EsK0Q7QUFDQSxvQjs7QUFFQTs7Ozs7Ozs7QUN0d0JBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFVBQVU7Ozs7Ozs7QUN2THRDO0FBQ0E7QUFDQTs7QUFFQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdC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RUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDLHFDQUFxQztBQUNyRSxpQ0FBZ0MsbUNBQW1DO0FBQ25FLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5REE7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O0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixTQUFTO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLHdCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EscUVBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQixNQUFLO0FBQ0w7QUFDQSxpQkFBZ0I7QUFDaEIsTUFBSztBQUNMO0FBQ0EsaUJBQWdCO0FBQ2hCLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE2QixjQUFjOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFxRCxFQUFFO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQix1QkFBdUI7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBeUMsUUFBUTtBQUNq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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbjVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxvQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7OztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLHNCQUFzQjtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsZ0NBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1QsMENBQXlDLDZDQUE2QyxpQkFBaUIsYUFBYSxTQUFTO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsNkJBQTZCO0FBQ3BEO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QyxhQUFhO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QyxlQUFlO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxlQUFlO0FBQzNELE1BQUs7QUFDTDtBQUNBLG1DQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsYUFBYTtBQUMxRCxNQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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O0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsU0FBUztBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGVBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyx5QkFBeUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ25KQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUM7Ozs7OztBQ1JBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEwQyxPQUFPLE1BQU0sVUFBVSxXQUFXO0FBQzVFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUF5Qyx3QkFBd0I7QUFDakU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCOztBQUUzQix1QkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFxRDs7QUFFckQ7QUFDQTtBQUNBLFlBQVc7QUFDWDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxtQ0FBa0M7O0FBRWxDO0FBQ0E7O0FBRUEsd0JBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE2RTs7QUFFN0U7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQjs7QUFFL0I7QUFDQSxxRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtFQUFpRTs7QUFFakUsNEJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FB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QyxPQUFPLE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQSxvQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7OztBQUdUO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0EsMkIiLCJmaWxlIjoiZmlzaFRvcG9CcG1uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZmlzaFRvcG9CcG1uXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImZpc2hUb3BvQnBtblwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA5NDA1YjgyMjczMmI0OTE2ZjgyYiIsIi8qKlxyXG4gKiBFeHBvcnQgZmlzaFRvcG8gYXMgQ29tbW9uSlMgbW9kdWxlXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9GaXNoVG9wb0JwbW4uanMnKTtcclxuLy/lhbzlrrlJRTgg5byV5YWlVk1MIOWmguaenOS4jemcgOimgeWFvOWuuUlFOOivt+WIoOmZpFxyXG5yZXF1aXJlKCd6cmVuZGVyL2xpYi92bWwvdm1sJyk7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2luZGV4LmJwbW4uanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEJQTU7lr7nosaFcclxuICogQGNsYXNzIGZpc2gudG9wby5GaXNoVG9wb0JwbW5cclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGNsaWNrXHJcbiAqIOiKgueCueaIluiAhee6v+auteeahGNsaWNr5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7YgZXZlbnQudGFyZ2V05Li655uu5qCH5a+56LGhIGV2ZW50LnRhcmdldC5tb2RlbOS4uuebruagh+WvueixoeeahOS4muWKoeaVsOaNrlxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICB0aGlzLmZpc2hUb3BvQnBtbi5vbihcImNsaWNrXCIsZnVuY3Rpb24oZSkge1xyXG4gICAgKiAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XHJcbiAgICAqICAgICAgICAgIGlmKEZpc2hUb3BvQnBtbi5CcG1uLmlzRmxvdyh0YXJnZXQpKSB7IC8v5Yik5pat57G75Z6LXHJcbiAgICAqICAgICAgICAgICAgICB2YXIgbGluZU5vZGUgPSBlLnRhcmdldDtcclxuICAgICogICAgICAgICAgICAgIHRoYXQuZmlzaFRvcG9CcG1uLmJpbmRMaW5lRGVsZXRlKGxpbmVOb2RlKTsgLy/nu5nnur/mrrXlop7liqDliKDpmaTlm77moIdcclxuICAgICogICAgICAgICAgICAgIC8vdG9kb1xyXG4gICAgKiAgICAgICAgICB9XHJcbiAgICAqICAgICAgfVxyXG4gICAgKi9cclxuXHJcbiAgIC8qKlxyXG4gICAgKiBAZXZlbnQgZGJsY2xpY2tcclxuICAgICog6IqC54K55oiW6ICF57q/5q6155qE5Y+M5Ye75LqL5Lu2XHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7YgZXZlbnQudGFyZ2V05Li655uu5qCH5a+56LGhIGV2ZW50LnRhcmdldC5tb2RlbOS4uuebruagh+WvueixoeeahOS4muWKoeaVsOaNrlxyXG4gICAgKlxyXG4gICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAqXHJcbiAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICogICAgICAgICAgLy/lj4zlh7vlvLnlh7roioLngrnlr7nlupTnmoRqc29uXHJcbiAgICAqICAgICAgICAgIHRoaXMuZmlzaFRvcG9CcG1uLm9uKFwiZGJsY2xpY2tcIixmdW5jdGlvbihlKSB7XHJcbiAgICAqICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XHJcbiAgICAqXHJcbiAgICAqICAgICAgICAgICAgICBpZihGaXNoVG9wb0JwbW4uQnBtbi5pc0Zsb3codGFyZ2V0KSkge1xyXG4gICAgKiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZGJsY2xpY2sgbGluZVwiKTtcclxuICAgICogICAgICAgICAgICAgIH1cclxuICAgICogICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAqICAgICAgICAgICAgICAgICAgdmFyIGpzb24gPSBub2RlTW9kZWwub3B0aW9uO1xyXG4gICAgKiAgICAgICAgICAgICAgICAgIGZpc2gucG9wdXBWaWV3KHtcclxuICAgICogICAgICAgICAgICAgICAgICAgICAgdXJsOiBcInZpZXdzL2RpYWxvZy9FeHBvcnRKc29uRGxnLmpzXCIsXHJcbiAgICAqICAgICAgICAgICAgICAgICAgICAgIHZpZXdPcHRpb246e2JwbW5Kc29uOkpTT04uc3RyaW5naWZ5KGpzb24sbnVsbCw0KX0sXHJcbiAgICAqICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihwb3B1cCx2aWV3KSB7XHJcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk9LXCIpO1xyXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24obXNnKSB7XHJcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInJldHVybiB2YWx1ZTogXCIgKyBtc2cpO1xyXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAqICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAqICAgICAgICAgICAgICB9XHJcbiAgICAqICAgICAgICAgIH0pO1xyXG4gICAgKi9cclxuXHJcbiAgIC8qKlxyXG4gICAgKiBAZXZlbnQgY3JlYXRlXHJcbiAgICAqIOiKgueCueS4jue6v+auteWIm+W7uuWujOavleeahOS6i+S7tlxyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2IGV2ZW50LnRhcmdldOS4uuebruagh+WvueixoSBldmVudC50YXJnZXQubW9kZWzkuLrnm67moIflr7nosaHnmoTkuJrliqHmlbDmja5cclxuICAgICpcclxuICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgKlxyXG4gICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAqICAgICAgICAgIHRoaXMuZmlzaFRvcG9CcG1uLm9uKFwiY3JlYXRlXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICogICAgICAgICAgICAgIGlmKEZpc2hUb3BvQnBtbi5CcG1uLmlzRmxvdyhlLnRhcmdldCkpIHtcclxuICAgICogICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGUudGFyZ2V0O1xyXG4gICAgKiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi6L+e57q/5Yib5bu65a6M5q+V77yM5LuOXCIgKyBsaW5lLnN0YXJ0Tm9kZS5tb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikgKyBcIiDoh7MgXCIgKyBsaW5lLmVuZE5vZGUubW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpKTtcclxuICAgICogICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAqICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBlLnRhcmdldDtcclxuICAgICogICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuiKgueCue+8mlwiICsgbm9kZS5tb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikgKyBcIiDliJvlu7rlrozmr5VcIik7XHJcbiAgICAqICAgICAgICAgICAgICB9XHJcbiAgICAqICAgICAgICAgIH0pO1xyXG4gICAgKi9cclxuXHJcbiAgIC8qKlxyXG4gICAgKiBAZXZlbnQgZGVsZXRlXHJcbiAgICAqIOiKgueCueS4jue6v+auteWIoOmZpOWujOavleeahOS6i+S7tlxyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2IGV2ZW50LnRhcmdldOS4uuebruagh+WvueixoSBldmVudC50YXJnZXQubW9kZWzkuLrnm67moIflr7nosaHnmoTkuJrliqHmlbDmja5cclxuICAgICpcclxuICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgKlxyXG4gICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAqICAgICAgICAgIC8v6IqC54K55Yig6Zmk5a6M5q+V5LqL5Lu2XHJcbiAgICAqICAgICAgICAgIHRoaXMuZmlzaFRvcG9CcG1uLm9uKFwiZGVsZXRlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAqICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuWIoOmZpOeahOaYr++8mlwiICsgZXZlbnQudGFyZ2V0KTtcclxuICAgICogICAgICAgICAgfSk7XHJcbiAgICAqL1xyXG5cclxuICAgXHJcbiAgICAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgICAgIHZhciBFeHRlbnNpb25BUEkgPSByZXF1aXJlKCcuL0V4dGVuc2lvbkFwaScpO1xyXG4gICAgICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9Qb2ludC5qc1wiKTtcclxuICAgICAgIHZhciBFdmVudGZ1bCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsJyk7XHJcbiAgICAgICB2YXIgenJlbmRlciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3pyZW5kZXInKTtcclxuICAgICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcycpO1xyXG4gICAgICAgdmFyIEJwbW5VdGlsID0gcmVxdWlyZShcIi4vQnBtblV0aWwuanNcIik7XHJcbiAgICAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1wiKTtcclxuICAgICAgIHZhciBCUE1OTW9kZWwgPSByZXF1aXJlKFwiLi9tb2RlbC9CUE1OTW9kZWwuanNcIik7XHJcbiAgICAgICB2YXIgQlBNTk5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL0JQTU5Ob2RlLmpzXCIpO1xyXG4gICAgICAgdmFyIEdyb3VwTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvR3JvdXBOb2RlLmpzXCIpO1xyXG4gICAgICAgdmFyIE9wZXJhdGlvbk5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL0JwbW5PcGVyYXRpb25Ob2RlLmpzXCIpO1xyXG4gICAgICAgdmFyIEJwbW5Db25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuL21hbmFnZXIvQnBtbkNvbm5lY3Rpb25NYW5hZ2VyLmpzXCIpO1xyXG4gICAgICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xyXG4gICAgICAgdmFyIExpbmVPcGVyYXRpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0xpbmVPcGVyYXRpb25NYW5hZ2VyLmpzXCIpO1xyXG4gICAgICAgdmFyIEd1aWRlbGluZXMgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvR3VpZGVsaW5lcy5qc1wiKTtcclxuICAgICAgIHZhciBwcm9taXNlID0gcmVxdWlyZShcImJsdWViaXJkXCIpO1xyXG4gICAgICAgdmFyIEJwbW4gPSByZXF1aXJlKFwiLi9CcG1uLmpzXCIpO1xyXG4gICAgICAgdmFyIGtleUNvZGUgPSB7RU5URVI6MTMsIEVTQ0FQRToyN307XHJcbiAgICAgICByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3BvbHlmaWxsLmpzXCIpO1xyXG4gICAgICAgQnBtblV0aWwucmVnaXN0ZXJCUE1OTm9kZSgpO1xyXG5cclxuICAgICAgIGZ1bmN0aW9uIEZpc2hUb3BvQnBtbihkb20sIG9wdHMpIHtcclxuICAgICAgICAgICB0aGlzLmlkO1xyXG4gICAgICAgICAgIHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgICAgdGhpcy5fZG9tID0gZG9tO1xyXG4gICAgICAgICAgIHRoaXMuX3pyID0genJlbmRlci5pbml0KGRvbSwge1xyXG4gICAgICAgICAgICAgICByZW5kZXJlcjogb3B0cy5yZW5kZXJlciB8fCAnY2FudmFzJyxcclxuICAgICAgICAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogb3B0cy5kZXZpY2VQaXhlbFJhdGlvXHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgdGhpcy5hbGxOb2RlcyA9IFtdOyAvL+WtmOaUvuaJgOacieiKgueCuVxyXG4gICAgICAgICAgIHRoaXMuc3ViUHJvY2Vzc05vZGUgPSBbXTsgIC8v5a2Y5pS+5a2Q6IqC54K5XHJcbiAgICAgICAgICAgdGhpcy5kb21BcnJheSA9IFtdOyAvL+WtmOaUvuiKgueCueeahOS9jee9ruS/oeaBr++8jOaLluWKqOeahOaXtuWAmeeUqOWIsFxyXG4gICAgICAgICAgIHRoaXMub3ZlcmxhcEFycmF5ID0gW107IC8vIOWtmOaUvuiKgueCueeahOS9jee9ruS/oeaBr++8jOWIpOaWremHjeWPoOeUqOWIsO+8jOmZpOWOu+S6huWtkOa1geeoi+mHjOmdoueahOiKgueCuVxyXG4gICAgICAgICAgIHRoaXMuc2VsZWN0ZWROb2RlID0gbnVsbDsgIC8v6YCJ5Lit55qE6IqC54K5XHJcbiAgICAgICAgICAgdGhpcy5pc05vZGUgPSBmYWxzZTtcclxuICAgICAgICAgICB0aGlzLm5vd1pvb20gPSAxO1xyXG4gICAgICAgICAgIHRoaXMucmVjdDsgIC8vIOWvuem9kOe6v+WSjOenu+WKqOahhuiKgueCuVxyXG4gICAgICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZTtcclxuICAgICAgICAgICB0aGlzLnN0ZXAgPSAwOy8v5YmN6L+b5ZCO6YCA6K6h5q2l5pWwXHJcbiAgICAgICAgICAgdGhpcy5zdGVwSnNvbiA9IFtdOy8v5a2Y5pS+5q+P5q2l55qEanNvblxyXG4gICAgICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XHJcbiAgICAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGVzID0gW107XHJcbiAgICAgICAgICAgdGhpcy5saW5lT3B0ID0ge307ICAvL+WIneWni+eahOe6v+autemFjee9ruS/oeaBr1xyXG4gICAgICAgICAgIHRoaXMuX2FwaSA9IG5ldyBFeHRlbnNpb25BUEkodGhpcyk7XHJcbiAgICAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7ICAvL+WtmOaUvuaJgOacieiKgueCueeahOi/nuaOpeeCuVxyXG4gICAgICAgICAgIHRoaXMuY29uQ29udHJvbHNHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7ICAvL+WtmOaUvuaJgOacieiKgueCueeahOaOp+WItueCuVxyXG4gICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAqIEBjZmcge0Jvb2xlYW59IGZvcmJpZEVkaXQg5piv5ZCm56aB55So57yW6L6R5Yqf6IO9XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgdGhpcy5mb3JiaWRFZGl0ID0gb3B0cy5mb3JiaWRFZGl0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdHMuZm9yYmlkRWRpdDtcclxuICAgICAgICAgICB0aGlzLm1vdXNlTW9kZSA9ICdkZWZhdWx0JywgICAgICAgICAgICAgICAgIC8v5b2T5YmN55S75biD5LiK6byg5qCH55qE5pON5L2c5qih5byP77yMZGVmYXVsdOS4uuato+W4uOeCueWHu+OAgeaLluaLveetieaTjeS9nO+8jGRyYWctc2VsZWN05Li65qGG6YCJ5pON5L2cXHJcbiAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBCcG1uQ29ubmVjdGlvbk1hbmFnZXIoKTtcclxuICAgICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyID0gbmV3IExpbmVPcGVyYXRpb25NYW5hZ2VyKHRoaXMuY29ubmVjdGlvbk1hbmFnZXIsdGhpcy5fYXBpKTtcclxuICAgICAgICAgICB0aGlzLm1vZGVsID0gbmV3IEJQTU5Nb2RlbCh7fSk7XHJcbiAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoQnBtbi5SRVNPVVJDRV9JRCwgdXRpbC5nZXRVVUlEKCkpO1xyXG4gICAgICAgICAgIHRoaXMubW9kZWwuc2V0KEJwbW4uQlBNTl9UWVBFLCBCcG1uLlRFTVBMQVRFKTtcclxuICAgICAgICAgICB0aGlzLmN1cnNvck1hcCA9IHtcclxuICAgICAgICAgICAgICAgdGw6ICdudy1yZXNpemUnLFxyXG4gICAgICAgICAgICAgICB0cjogJ25lLXJlc2l6ZScsXHJcbiAgICAgICAgICAgICAgIGJsOiAnc3ctcmVzaXplJyxcclxuICAgICAgICAgICAgICAgYnI6ICdzZS1yZXNpemUnLFxyXG4gICAgICAgICAgICAgICBtdHI6J3VybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJRQUFBQVVDQU1BQUFDNlYrMC9BQUFBWUZCTVZFVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFENlQraU5BQUFBSDNSU1RsTUE3c1VNb1lYbkVrWVl6YWFUalFpQVFDd2VCY0c3ZnZuVUxoMlpkak15NkZ6ZDd3QUFBTEpKUkVGVUdOTjFrRmtPd3pBSUJRSHZXL1k2U2JmYy81WTFsdHFvbGpJZjJCb2hCQThxVTA5NnhlVjVMLyt1Rkg0U3BzR0FHU0ttVGhDeU16NjRVZDM4VGUwbWVJcEhjVFAxbmRUS3ZxelNVdVFJTEZNUUpBVXdJbmdCTENkMFVySmhTUkdxekhIVTNGY0hCVk1va3F4UzM4WU5HUUxRYmhtZ1paMjNzVkVYblhWbVM0NjdGcTA4OTJTU0xhVzVTSHJOOXJ6OWJYdjlFSElCK0U5cGRNRzdZczQ4WjJjanhvN0ZMM2s4a1BJRTEzd0FtRVVJTzJNTDlZTUFBQUFBU1VWT1JLNUNZSUk9KSAxMCAxMCwgYXV0bydcclxuICAgICAgICAgICB9OyAvLyDoioLngrnmjqfliLbngrnpvKDmoIfkv6Hmga8o5LiK5bem77yM5LiK5Y+z77yM5LiL5bem77yM5LiL5Y+z77yM5peL6L2sKVxyXG4gICAgICAgICAgIHRoaXMuY3Vyc29yTWFwcyA9IFtcclxuICAgICAgICAgICAgICAgJ24tcmVzaXplJyxcclxuICAgICAgICAgICAgICAgJ25lLXJlc2l6ZScsXHJcbiAgICAgICAgICAgICAgICdlLXJlc2l6ZScsXHJcbiAgICAgICAgICAgICAgICdzZS1yZXNpemUnLFxyXG4gICAgICAgICAgICAgICAncy1yZXNpemUnLFxyXG4gICAgICAgICAgICAgICAnc3ctcmVzaXplJyxcclxuICAgICAgICAgICAgICAgJ3ctcmVzaXplJyxcclxuICAgICAgICAgICAgICAgJ253LXJlc2l6ZSdcclxuICAgICAgICAgICBdXHJcbiAgICAgICAgICAgdGhpcy5jdXJzb3JPZmZzZXQgPSB7XHJcbiAgICAgICAgICAgICAgIHRyOiAxLFxyXG4gICAgICAgICAgICAgICBicjogMyxcclxuICAgICAgICAgICAgICAgYmw6IDUsXHJcbiAgICAgICAgICAgICAgIHRsOiA3XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIEV2ZW50ZnVsLmNhbGwodGhpcyk7XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgdmFyIGZpc2hUb3BvUHJvdG8gPSBGaXNoVG9wb0JwbW4ucHJvdG90eXBlO1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICog6I635Y+WIGZpc2hUb3BvIOWunuS+i+WuueWZqOeahCBkb20g6IqC54K5XHJcbiAgICAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5nZXREb20gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9tO1xyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uZ2V0WnIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICByZXR1cm4gdGhpcy5fenI7XHJcbiAgICAgICB9O1xyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDojrflj5YgZmlzaFRvcG8g5a6e5L6L5a655Zmo55qE5a695bqm44CCXHJcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uZ2V0V2lkdGggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICByZXR1cm4gdGhpcy5fenIuZ2V0V2lkdGgoKTtcclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDojrflj5YgZmlzaFRvcG8g5a6e5L6L5a655Zmo55qE6auY5bqm44CCXHJcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuX3pyLmdldEhlaWdodCgpO1xyXG4gICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDlvZPliY3lrp7kvovmmK/lkKblt7Lnu4/ooqvph4rmlL7jgIJcclxuICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uaXNEaXNwb3NlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBEaXNwb3NlIGluc3RhbmNlXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgdGhpcy5fenIuZGlzcG9zZSgpO1xyXG5cclxuICAgICAgICAgICBpbnN0YW5jZXNbdGhpcy5pZF0gPSBudWxsO1xyXG4gICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDosIPmlbTlsLrlr7ggIOWcqOeql+WPo+Wkp+Wwj+WPkeeUn+aUueWPmOaXtumcgOimgeaJi+W3peiwg+eUqFxyXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIOWuveW6plxyXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCDpq5jluqZcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgdGhpcy5nZXREb20oKS5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcclxuICAgICAgICAgICB0aGlzLmdldERvbSgpLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XHJcbiAgICAgICAgICAgdGhpcy5fenIucmVzaXplKCk7XHJcbiAgICAgICAgICAgdGhpcy5fenIucmVtb3ZlKHRoaXMuZ3JvdXApO1xyXG4gICAgICAgICAgIHRoaXMuZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgICAgIGlmICh0aGlzLm9wdHMuc2hvd0dyaWRMaW5lID09IHRydWUgfHwgdGhpcy5vcHRzLnNob3dHcmlkTGluZSA9PSBcInRydWVcIikge1xyXG4gICAgICAgICAgICAgICB0aGlzLmdyaWRMaW5lKCk7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzLmdyb3VwKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKiBAcHJpdmF0ZSDliJ3lp4vljJYgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uaW5pdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgIHRoaXMuZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgICAgIGlmICh0aGlzLm9wdHMuc2hvd0dyaWRMaW5lID09IHRydWUgfHwgdGhpcy5vcHRzLnNob3dHcmlkTGluZSA9PSBcInRydWVcIikge1xyXG4gICAgICAgICAgICAgICB0aGlzLmdyaWRMaW5lKCk7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzLmdyb3VwKTtcclxuICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgIC8vbW91c2V1cCDkvJrlnKjlkITkuKpub2Rl5oiW57q/55qE54K55Ye75LqL5Lu25LmL5YmN5omn6KGMICDlnKjpgInkuK3oioLngrnmiJbnur/liY0g5YWI5riF56m66YCJ5Lit5pWI5p6cXHJcbiAgICAgICAgICAgdGhpcy5fenIub24oXCJtb3VzZXVwXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgLy8gMS4g5riF56m66IqC54K555qE6YCJ5Lit5pWI5p6cXHJcbiAgICAgICAgICAgICAgIC8vIHRoaXMuX3JlbW92ZU9wZXJhdGlvbk5vZGUoKTtcclxuICAgICAgICAgICAgICAgLy8gMi4g54K55Ye755qE57q/IO+8jOWImeebtOaOpei/lOWbnlxyXG4gICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBlLnRhcmdldDtcclxuICAgICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmNvbm5lY3RvciBpbnN0YW5jZW9mIENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY2xlYXJTZWxlY3RDb24oKTtcclxuICAgICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLl9pc0xpbmVPcGVyYXRpb25JY29uICYmIHNoYXBlLl9pc0xpbmVPcGVyYXRpb25JY29uID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgLy/mtL7lj5HkuI3mmK/oioLngrnmiJbnur8g55qE55S75biD54K55Ye75LqL5Lu2XHJcbiAgICAgICAgICAgdGhpcy5fenIub24oXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgIC8vIOWmguaenOeCueWHu+S6huaOp+WItueCue+8jOWImeS4jeS8muWPlua2iOmAieS4reeKtuaAgSjmjqfliLbngrnkuI3lnKjoioLngrnojIPlm7TlhoUpXHJcbiAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCB7fTtcclxuICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0YXJnZXQudHlwZTtcclxuICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdDb25uZWN0Q29udHJvbExpbmUnICYmIHR5cGUgIT09ICdDb25uZWN0Q29udHJvbCcpIHtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JDb250cm9sKCk7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVPcGVyYXRpb25Ob2RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmhpZGVBbGxMaW5lT3BlcmF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBlLnRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgIC8v54K55Ye755qE57q/XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUucGFyZW50ICYmIHNoYXBlLnBhcmVudC5yZXNvdXJjZUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiY2xpY2tcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcGkudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgICAgIHRoaXMuX3pyLm9uKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgIGlmICh0aGlzLm1vdXNlTW9kZSA9PT0gJ2RyYWctc2VsZWN0JyAmJiAoIWUudGFyZ2V0IHx8IChlLnRhcmdldCAmJiBlLnRhcmdldC50eXBlID09PSAnZ3JpZC1saW5lJykgfHwgKGUudGFyZ2V0ICYmIGUudGFyZ2V0Lm5hbWUgPT09ICdzdWJwcm9jZXNzLXJlY3QnKSkpIHtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdTZWxlY3QoZS50YXJnZXQsIGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgICAgIHRoaXMub24oJ2NvblBvaW50c0dyb3VwOmNsaWNrJywgZnVuY3Rpb24oYXJndW1lbnQpIHtcclxuICAgICAgICAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5iaW5kT3BlcmF0aW9uKGFyZ3VtZW50LmxpbmVOb2RlKTtcclxuICAgICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uX3JlbGVhc2VTZWxlY3ROb2RlID0gZnVuY3Rpb24gKGZsYWcpIHtcclxuICAgICAgICAgICBpZiAodGhpcy5kcmFnU2VsZWN0UmVjdCkge1xyXG4gICAgICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmRyYWdTZWxlY3RSZWN0LmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5uYW1lICE9PSBcIkdST1VQX1JFQ1RfTkFNRVwiO1xyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IHRoaXMuZHJhZ1NlbGVjdFJlY3QucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgIHZhciBzdGFydFkgPSB0aGlzLmRyYWdTZWxlY3RSZWN0LnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIG5vZGVYID0gQnBtbi5pc0Zsb3coaXRlbSkgPyAwIDogaXRlbS5nZXRSZWN0KCkueDtcclxuICAgICAgICAgICAgICAgICAgIHZhciBub2RlWSA9IEJwbW4uaXNGbG93KGl0ZW0pID8gMCA6IGl0ZW0uZ2V0UmVjdCgpLnk7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3RSZWN0LnJlbW92ZShpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLm9yaWdpblBhcmVudCAmJiAhZmxhZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3JpZ2luUGFyZW50LmFkZChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fenIuYWRkKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgaWYgKCFCcG1uLmlzRmxvdyhpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLm9yaWdpblBhcmVudCAmJiAhZmxhZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFBvc2l0aW9uKG5vZGVYK3N0YXJ0WC1CcG1uVXRpbC5wYXJlbnRYKGl0ZW0ub3JpZ2luUGFyZW50KSwgbm9kZVkrc3RhcnRZLUJwbW5VdGlsLnBhcmVudFkoaXRlbS5vcmlnaW5QYXJlbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFBvc2l0aW9uKG5vZGVYK3N0YXJ0WCwgbm9kZVkrc3RhcnRZKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZShpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLm9yaWdpblBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3JpZ2luUGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3RSZWN0Lm9mZihcIm1vdXNlZG93blwiKTtcclxuICAgICAgICAgICAgICAgdGhpcy5fenIucmVtb3ZlKHRoaXMuZHJhZ1NlbGVjdFJlY3QpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH1cclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLl9kcmFnU2VsZWN0ID0gZnVuY3Rpb24gKG5vZGUsIHgsIHkpIHtcclxuICAgICAgICAgICB0aGlzLl9yZWxlYXNlU2VsZWN0Tm9kZSgpOyAgLy/ov5jljp/pgInkuK3nmoToioLngrlcclxuICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3RSZWN0ID0gbmV3IEdyb3VwTm9kZSh7XHJcbiAgICAgICAgICAgICAgIHNoYXBlOnsgd2lkdGg6IDAsIGhlaWdodDogMH0sXHJcbiAgICAgICAgICAgICAgIHBvc2l0aW9uOlt4LCB5XSxcclxuICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgIGxpbmVEYXNoOlsyLDJdLFxyXG4gICAgICAgICAgICAgICAgICAgZmlsbDogXCJyZ2JhKDIzOSwyMjIsMjIxLDAuNylcIixcclxuICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJ3JnYmEoMCwgMCwgMCwgMSknXHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3RSZWN0LnR5cGUgPSBcImRyYWdTZWxlY3RcIjtcclxuICAgICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5kcmFnU2VsZWN0UmVjdCk7XHJcbiAgICAgICAgICAgdGhpcy5kcmFnU2VsZWN0UmVjdC5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICB0aGlzLm5ld0RyYWcodGhpcy5kcmFnU2VsZWN0UmVjdCwgZS5ldmVudC5jbGllbnRYLCBlLmV2ZW50LmNsaWVudFkpO1xyXG4gICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgdmFyIG1vdmVIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhldmVudC5vZmZzZXRYIC0geCkgPD0gMSAmJiBNYXRoLmFicyhldmVudC5vZmZzZXRZIC0geSkgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHZhciBwb3NYID0geCA8PSBldmVudC5vZmZzZXRYID8geCA6IGV2ZW50Lm9mZnNldFg7XHJcbiAgICAgICAgICAgICAgIHZhciBwb3NZID0geSA8PSBldmVudC5vZmZzZXRZID8geSA6IGV2ZW50Lm9mZnNldFk7XHJcbiAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IE1hdGguYWJzKGV2ZW50Lm9mZnNldFggLSB4KTtcclxuICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IE1hdGguYWJzKGV2ZW50Lm9mZnNldFkgLSB5KTtcclxuICAgICAgICAgICAgICAgdGhpcy5kcmFnU2VsZWN0UmVjdC5zZXRQcm9wZXJ0aWVzKHtzaGFwZToge3dpZHRoOndpZHRoLCBoZWlnaHQ6IGhlaWdodH0sIHBvc2l0aW9uOiBbcG9zWCwgcG9zWV19KTtcclxuICAgICAgICAgICB9LmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgdGhpcy5fenIub24oJ21vdXNlbW92ZScsIG1vdmVIYW5kbGVyKTtcclxuXHJcbiAgICAgICAgICAgdmFyIGVuZERyYWdIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3pyLm9mZignbW91c2Vtb3ZlJywgbW92ZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICB0aGlzLl96ci5vZmYoJ21vdXNldXAnLCBlbmREcmFnSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3pyLm9mZihcImdsb2JhbG91dFwiLCBlbmREcmFnSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhldmVudC5vZmZzZXRYIC0geCkgPD0gMSAmJiBNYXRoLmFicyhldmVudC5vZmZzZXRZIC0geSkgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3Mobm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlQ2xpY2tIYW5kbGVyKG5vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCdzZWxlY3ROb2RlJywge3RhcmdldDogbm9kZS5wYXJlbnR9KTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB2YXIgdHMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICB2YXIgc3RhcnRYID0gdGhpcy5kcmFnU2VsZWN0UmVjdC5wb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IHRoaXMuZHJhZ1NlbGVjdFJlY3QucG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZHJhZ1NlbGVjdFJlY3Qub3B0aW9ucy5zaGFwZS53aWR0aDtcclxuICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZHJhZ1NlbGVjdFJlY3Qub3B0aW9ucy5zaGFwZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgIHZhciBjbnQgPSAwO1xyXG4gICAgICAgICAgICAgICB0aGlzLmFsbE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gaXRlbS5nZXRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgIHZhciBub2RlSGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVggPSBpdGVtLnBhcmVudCA/IHJlY3QueCtCcG1uVXRpbC5wYXJlbnRYKGl0ZW0ucGFyZW50KSA6IHJlY3QueDtcclxuICAgICAgICAgICAgICAgICAgIHZhciBub2RlWSA9IGl0ZW0ucGFyZW50ID8gcmVjdC55K0JwbW5VdGlsLnBhcmVudFkoaXRlbS5wYXJlbnQpIDogcmVjdC55O1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKCgoQnBtbi5pc0V2ZW50KGl0ZW0pIHx8IEJwbW4uaXNHYXRld2F5KGl0ZW0pKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgIG5vZGVYLW5vZGVXaWR0aCA+PSBzdGFydFggJiYgbm9kZVktbm9kZVdpZHRoID49IHN0YXJ0WSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgIG5vZGVYK25vZGVXaWR0aCA8PSBzdGFydFgrd2lkdGggJiYgbm9kZVkrbm9kZVdpZHRoIDw9IHN0YXJ0WStoZWlnaHQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgKCEoQnBtbi5pc0V2ZW50KGl0ZW0pIHx8IEJwbW4uaXNHYXRld2F5KGl0ZW0pKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgIG5vZGVYLW5vZGVXaWR0aC8yID49IHN0YXJ0WCAmJiBub2RlWS1ub2RlSGVpZ2h0LzIgPj0gc3RhcnRZICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgbm9kZVgrbm9kZVdpZHRoLzIgPD0gc3RhcnRYK3dpZHRoICYmIG5vZGVZK25vZGVIZWlnaHQvMiA8PSBzdGFydFkraGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnNsb3RFdmVudCAmJiBpdGVtLnNsb3RFdmVudC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgaXRlbS5zbG90RXZlbnQubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90RXZlbnRQb3NpdGlvbjIgPSBbaXRlbS5zbG90RXZlbnRbbl0ucG9zaXRpb25bMF0gKyAobm9kZVgtc3RhcnRYKSAtIHpyVXRpbC5jbG9uZShpdGVtLnBvc2l0aW9uWzBdKSAtIGl0ZW0uZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLyAyLCBpdGVtLnNsb3RFdmVudFtuXS5wb3NpdGlvblsxXSArIChub2RlWS1zdGFydFkpIC0genJVdGlsLmNsb25lKGl0ZW0ucG9zaXRpb25bMV0pIC0gaXRlbS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2xvdEV2ZW50W25dLmF0dHIoXCJwb3NpdGlvblwiLCBzbG90RXZlbnRQb3NpdGlvbjIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZShpdGVtLnNsb3RFdmVudFtuXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3JpZ2luUGFyZW50ID0gaXRlbS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucGFyZW50LnJlbW92ZShpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0cy5fenIucmVtb3ZlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB0cy5kcmFnU2VsZWN0UmVjdC5hZGQoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdHMuc2VsZWN0ZWROb2Rlcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0UG9zaXRpb24obm9kZVgtc3RhcnRYLCBub2RlWS1zdGFydFkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGNudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgaWYgKCFjbnQpIHtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdFJlY3Qub2ZmKFwibW91c2Vkb3duXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5fenIucmVtb3ZlKHRoaXMuZHJhZ1NlbGVjdFJlY3QpO1xyXG4gICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnU2VsZWN0UmVjdC5jaGlsZE9mTmFtZShcIkdST1VQX1JFQ1RfTkFNRVwiKS5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IFwicmdiYSgwLDAsMCwwKVwiXHJcbiAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IHRzLmRyYWdTZWxlY3RSZWN0LmNoaWxkcmVuKCkuZmluZChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5pZCA9PT0gaXRlbS5zdGFydE5vZGUuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZE5vZGUgPSB0cy5kcmFnU2VsZWN0UmVjdC5jaGlsZHJlbigpLmZpbmQoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYuaWQgPT09IGl0ZW0uZW5kTm9kZS5pZDtcclxuICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnROb2RlICYmIGVuZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdHMuX3pyLnJlbW92ZShpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdHMuZHJhZ1NlbGVjdFJlY3QuYWRkKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0cy5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZShpdGVtLnN0YXJ0Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9LmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgdGhpcy5fenIub24oJ21vdXNldXAnLCBlbmREcmFnSGFuZGxlcik7XHJcbiAgICAgICAgICAgdGhpcy5fenIub24oXCJnbG9iYWxvdXRcIiwgZW5kRHJhZ0hhbmRsZXIpO1xyXG4gICAgICAgfVxyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICog5qC55o2u5Lyg6L+H5p2l55qE5YC8ICDorr7nva7oioLngrnmqKHlnotcclxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzaGFwZSAg6IqC54K55oiW57q/XHJcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uIOaooeWei+aVsOaNrlxyXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIOWuveW6pijku4XnlKjkuo7osIPmlbTnlLvluIPlpKflsI8pXHJcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IOmrmOW6pijku4XnlKjkuo7osIPmlbTnlLvluIPlpKflsI8pXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uc2V0U2hhcGVNb2RlbCA9IGZ1bmN0aW9uKHNoYXBlLCBvcHRpb24sIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICAgICBpZiAodGhpcy5mb3JiaWRFZGl0ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgaWYgKEJwbW4uaXNUZW1wbGF0ZShzaGFwZSkpIHtcclxuICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5tZXJnZU9wdGlvbihvcHRpb24pO1xyXG4gICAgICAgICAgICAgICBpZiAod2lkdGggPiAwICYmIGhlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfSBlbHNlIGlmIChCcG1uLmlzRmxvdyhzaGFwZSkpIHtcclxuICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zZXRNb2RlbChzaGFwZSwgb3B0aW9uKTtcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICBpZiAoc2hhcGUuYnBtbkluZm8ubmFtZS5pbmRleE9mKFwiVGFza1wiKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgIG9wdGlvbi5wcm9wZXJ0aWVzLnBvc2l0aW9uID0gJ2NlbnRlcic7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgaWYgKHNoYXBlLmJwbW5JbmZvLm5hbWUgPT09ICdDb21tZW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgb3B0aW9uLnByb3BlcnRpZXMucG9zaXRpb24gPSAnbGVmdCc7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgc2hhcGUuc2V0TW9kZWwob3B0aW9uKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICog6I635Y+W54i2XHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uX2dldFBhcmVudFpyID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgIHZhciBwYXJlbnRaciA9IG51bGw7XHJcbiAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgcGFyZW50WnIgPSBub2RlLnBhcmVudDtcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICBwYXJlbnRaciA9IHRoaXMuX3pyO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICByZXR1cm4gcGFyZW50WnI7XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDmuIXnqbrlvZPliY3lrp7kvovvvIzkvJrnp7vpmaTlrp7kvovkuK3miYDmnInnmoToioLngrnkuI7nur9cclxuICAgICAgICAqIEBtZXRob2QgY2xlYXJcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5jbGVhciA9IGZ1bmN0aW9uKGlzTm9Db3VudCkge1xyXG4gICAgICAgICAgIHRoaXMuYWxsTm9kZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgdGhpcy5zdWJQcm9jZXNzTm9kZSA9IFtdO1xyXG5cclxuICAgICAgICAgICB0aGlzLmRvbUFycmF5ID0gW107XHJcblxyXG4gICAgICAgICAgIHRoaXMub3ZlcmxhcEFycmF5ID0gW107XHJcblxyXG4gICAgICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvclBvaW50KCk7ICAvL+makOiXj+aJgOacieiKgueCueS4iueahOi/nuaOpeeCuVxyXG5cclxuICAgICAgICAgICB0aGlzLnNlbGVjdGVkTm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgdGhpcy5yZWN0ID0gbnVsbDtcclxuICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnMgPSBbXTtcclxuICAgICAgICAgICB0aGlzLl96ci5jbGVhcigpO1xyXG4gICAgICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzLmdyb3VwKTsgLy8g55S7572R5qC857q/ICDku6PnoIHmlL7ov5nmr5TovoPmgbblv4Mg5ZCO6Z2i5pS5XHJcbiAgICAgICAgICAgaWYgKGlzTm9Db3VudCAhPSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICog6K6+572u5piv5ZCm5pi+56S6572R57uc57q/XHJcbiAgICAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpc0ZvcmJpZGRlbiDmmK/lkKbmmL7npLrnvZHnu5znur9cclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5mb3JiaWRHcmlkTGluZSA9IGZ1bmN0aW9uKGlzRm9yYmlkZGVuKSB7XHJcbiAgICAgICAgICAgdGhpcy5vcHRzLnNob3dHcmlkTGluZSA9ICFpc0ZvcmJpZGRlbjtcclxuICAgICAgICAgICBpZiAoaXNGb3JiaWRkZW4gPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICB0aGlzLl96ci5yZW1vdmUodGhpcy5ncm91cCk7XHJcbiAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgdGhpcy5fenIucmVtb3ZlKHRoaXMuZ3JvdXApO1xyXG4gICAgICAgICAgICAgICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICAgICAgICAgdGhpcy5ncmlkTGluZSgwLjIpO1xyXG4gICAgICAgICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5ncm91cCk7XHJcblxyXG4gICAgICAgICAgIH1cclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDlr7zlh7pqc29uXHJcbiAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IGpzb27lrZfnrKbkuLJcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by50b0pzb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICByZXR1cm4gQnBtblV0aWwudG9Kc29uKHRoaXMubW9kZWwsIHRoaXMuYWxsTm9kZXMsIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycyk7XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICog5a+85YWlanNvblxyXG4gICAgICAgICogQHBhcmFtICB7c3RyaW5nfSBqc29uIGpzb27moLzlvI/nmoTlrZfnrKbkuLJcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5mcm9tSnNvbiA9IGZ1bmN0aW9uKGpzb24pIHtcclxuICAgICAgICAgICBCcG1uVXRpbC5mcm9tSnNvbih0aGlzLCBqc29uKTtcclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLy/og4zmma/nvZHmoLznur9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uZ3JpZExpbmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICB2YXIgcGl4ZWwgPSB0aGlzLm9wdHMuZ3JpZExpbmVTcGFjaW5nO1xyXG4gICAgICAgICAgIHZhciB3aWR0aExlbiA9IHBhcnNlSW50KHRoaXMuZ2V0V2lkdGgoKSAvIHBpeGVsKTtcclxuICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8PSB3aWR0aExlbjsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBsaW5lWCA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICB4MTogeCAqIHBpeGVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHkxOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHgyOiB4ICogcGl4ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgeTI6IHRoaXMuZ2V0SGVpZ2h0KClcclxuICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogKHggPT09IDAgfHwgKHggKyAxKSAlIDQgPT09IDAgfHwgIHggPT09IHdpZHRoTGVuIC0gMSkgPyAnI2RkZGRkZCcgOiAnI2RkZGRkZGI4J1xyXG4gICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgIHo6IC0xLFxyXG4gICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnXHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICBsaW5lWC50eXBlID0gXCJncmlkLWxpbmVcIjtcclxuICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQobGluZVgpO1xyXG4gICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgdmFyIGhlaWdodExlbiA9IHBhcnNlSW50KHRoaXMuZ2V0SGVpZ2h0KCkgLyBwaXhlbCwgcGl4ZWwpO1xyXG4gICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDw9IGhlaWdodExlbjsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBsaW5lWSA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICB4MTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICB5MTogeSAqIHBpeGVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHgyOiB0aGlzLmdldFdpZHRoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgeTI6IHkgKiBwaXhlbFxyXG4gICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAoeSA9PT0gMCB8fCAoeSArIDEpICUgNCA9PT0gMCB8fCB5ID09PSBoZWlnaHRMZW4gLSAxKSA/ICcjZGRkZGRkJyA6ICcjZGRkZGRkYjgnXHJcbiAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgejogLTEsXHJcbiAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIGxpbmVZLnR5cGUgPSBcImdyaWQtbGluZVwiO1xyXG4gICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChsaW5lWSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLl9yZW1vdmVPcGVyYXRpb25Ob2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgaWYgKHRoaXMub3BlcmF0aW9uTm9kZSkge1xyXG4gICAgICAgICAgICAgICB0aGlzLl96ci5yZW1vdmUodGhpcy5vcGVyYXRpb25Ob2RlKTtcclxuICAgICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlLmNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlID0gbnVsbDtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDpgJrov4fnlYzpnaLmi5bliqgg5aKe5Yqg6IqC54K5XHJcbiAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaXRlbVR5cGUg5Yib5bu66IqC54K555qE57G75Z6L77yI5bey5pyJ6aKE5a6a5LmJ57G75Z6L5YyF5ousU3RhcnROb25lRXZlbnTjgIFFbmROb25lRXZlbnTjgIFVc2VyVGFza+OAgU1hbnVhbFRhc2vjgIFTY3JpcHRUYXNr44CBTWFpbFRhc2vjgIFDYXRjaFRpbWVyRXZlbnTjgIFDYXRjaFNpZ25hbEV2ZW5044CBVGhyb3dTaWduYWxFdmVudOOAgUluY2x1c2l2ZUdhdGV3YXnjgIFFeGNsdXNpdmVHYXRld2F544CBUGFyYWxsZWxHYXRld2F544CBU3ViUHJvY2Vzc++8iVxyXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHggICAgICAgIOiKgueCueWIm+W7uueahHjlnZDmoIdcclxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgICAgICDoioLngrnliJvlu7rnmoR55Z2Q5qCHXHJcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyDpgInpoblcclxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5uYW1lXSDoioLngrnkuIvpnaLmmL7npLrlkI3np7BcclxuICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm9wZXJhdGlvbkljb25zXSDorr7nva7pgInkuK3oioLngrnml7Yg5pi+56S655qE5pON5L2c5bCP5Zu+5qCH77yMIOm7mOiupOaPkOS+m+S6hiDliKDpmaTjgIHnm7Tnur/jgIHmipjnur/jgIHmm7Lnur8056eN5Zu+5qCH77yM5Lmf5Y+v5Lul6Ieq5a6a5Zu+5qCHIGVnLlxyXG4gICAgICAgICogPHByZT5cclxuICAgICAgICAqICAgICAgICAgIG9wZXJhdGlvbkljb25zOiBbeyBuYW1lOiAnREVMJyB9LFxyXG4gICAgICAgICogICAgICAgICAgICAgIHsgbmFtZTogJ1NUUkFJR0hUJyB9LFxyXG4gICAgICAgICogICAgICAgICAgICAgIHsgbmFtZTogJ0pBR0dFRCcgfSxcclxuICAgICAgICAqICAgICAgICAgICAgICB7IG5hbWU6ICdDVVJWRScgfSxcclxuICAgICAgICAqICAgICAgICAgICAgICB7XHJcbiAgICAgICAgKiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiY3VzdG9tMVwiLFxyXG4gICAgICAgICogICAgICAgICAgICAgICAgICBpY29uUGF0aDogXCJpbWcvaG9zdC5wbmdcIixcclxuICAgICAgICAqICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKGUpIHsgYWxlcnQoZS5kYXRhLm5hbWUgKyBcIiBjbGlja2VkXCIpIH0gIC8vZS5ub2Rl5piv5b2T5YmN55qE6IqC54K5XHJcbiAgICAgICAgKiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICogICAgICAgICAgXVxyXG4gICAgICAgICogPC9wcmU+XHJcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlckRhdGEg55So5oi35Lyg6YCS55qE5Lia5Yqh5pWw5o2uXHJcbiAgICAgICAgKlxyXG4gICAgICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICAgICpcclxuICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAqICAgICAgZmlzaFRvcG8uYWRkTm9kZShpdGVtVHlwZSwgeCwgeSwge1xyXG4gICAgICAgICogICAgICAgICAgICAgICAgICAgICAgbmFtZTogaXRlbVR5cGUsICAgLy/oioLngrnnmoTlkI3np7BcclxuICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbkljb25zOlt7bmFtZTonREVMJ30seyBuYW1lOiAnU1RSQUlHSFQnIH0se25hbWU6J0pBR0dFRCd9LHsgbmFtZTogJ0NVUlZFJyB9XSxcclxuICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgIC8vIOWinuWKoOiKgueCueaTjeS9nOWbvuaghyDkuIrpnaLliIbliKvmmK9cIuWIoOmZpOOAgeebtOe6v+OAgeaKmOe6v+OAgeabsue6v1wi77yMXHJcbiAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAvLyDkuZ/lj6/ku6Xlop7liqDoh6rlrprlm77moIcg5aaCe25hbWU6IFwiY3VzdG9tMVwiLCBpY29uUGF0aDogXCJpbWcvaG9zdC5wbmdcIiwgY2FsbGJhY2s6IGZ1bmN0aW9uKGUpIHsgYWxlcnQoZS5kYXRhLm5hbWUgKyBcIiBjbGlja2VkXCIpIH19IC8vZS5ub2Rl5piv5b2T5YmN55qE6IqC54K5XHJcbiAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTp7YnVzaW5lc3NEYXRhOifmiJHmmK/kuJrliqHmlbDmja4s6YCa6L+HQnBtbi5nZXRVc2VyRGF0YeWPr+iOt+WPlid9XHJcbiAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAvLyDlop7liqDoioLngrnnmoToh6rlrprkuYnkuJrliqHvvIzlj6/ku6XpgJrov4dCcG1uLmdldFVzZXJEYXRhKG5vZGUp6I635Y+WXHJcbiAgICAgICAgKiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmFkZE5vZGUgPSBmdW5jdGlvbihpdGVtVHlwZSwgeCwgeSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAvL+WIpOaWreaYr+WQpuWcqOiMg+WbtOWGhVxyXG4gICAgICAgICAgIGlmICh4ID49IDAgJiYgeSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBtb2RlbCA9IG5ldyBCUE1OTW9kZWwoe30pO1xyXG4gICAgICAgICAgICAgICBtb2RlbC5zZXQoQnBtbi5CUE1OX1RZUEUsIGl0ZW1UeXBlKTtcclxuICAgICAgICAgICAgICAgbW9kZWwuc2V0KFwiYm91bmRzLnVwcGVyTGVmdFwiLCB7eDogeCwgeTogeX0pO1xyXG4gICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgbW9kZWwuc2V0KFwicHJvcGVydGllc1wiLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ2JlZm9yZUNyZWF0ZU5vZGUnLCB7dGFyZ2V0OiBudWxsfSwgbW9kZWwpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYXN5bmNBZGROb2RlQnlNb2RlbChtb2RlbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLy/mt7vliqDkuIDkuKrmtYHnqIvlm77niYfmrrVcclxuICAgICAgIGZpc2hUb3BvUHJvdG8uYWRkU2hhcGVzID0gZnVuY3Rpb24oY2hpbGRTaGFwZXMsIHgsIHkpIHtcclxuICAgICAgICAgICBpZiAoeCA8IDAgfHwgeSA8IDApIHtcclxuICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICAvL+WFiOaLv+WIsOiAgeeahOeUu+W4g2pzb27mlbDmja5cclxuICAgICAgICAgICB2YXIgY2xvbmVDaGlsZFNoYXBlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY2hpbGRTaGFwZXMpKTtcclxuICAgICAgICAgICB2YXIgY2FudmFzRGF0YSA9IHRoaXMudG9Kc29uKCk7XHJcbiAgICAgICAgICAgdmFyIG9sZENoaWxkU2hhcGVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjYW52YXNEYXRhLmNoaWxkU2hhcGVzKSk7XHJcblxyXG4gICAgICAgICAgIC8v6K6h566X5Ye66KaB5re75Yqgc2hhcGVz55qE5a696auYXHJcbiAgICAgICAgICAgdmFyIGFsbFVwcGVyTGVmdFggPSBbXSwgYWxsVXBwZXJMZWZ0WSA9IFtdLCBhbGxMb3dlclJpZ2h0WCA9IFtdLCBhbGxMb3dlclJpZ2h0WSA9IFtdO1xyXG4gICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVDaGlsZFNoYXBlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNsb25lQ2hpbGRTaGFwZXNbaV07XHJcbiAgICAgICAgICAgICAgIGlmIChub2RlLnN0ZW5jaWwudHlwZSAhPT0gQnBtbi5TRVFVRU5DRV9GTE9XKSB7XHJcbiAgICAgICAgICAgICAgICAgICBhbGxVcHBlckxlZnRYLnB1c2gobm9kZS5ib3VuZHMudXBwZXJMZWZ0LngpO1xyXG4gICAgICAgICAgICAgICAgICAgYWxsVXBwZXJMZWZ0WS5wdXNoKG5vZGUuYm91bmRzLnVwcGVyTGVmdC55KTtcclxuICAgICAgICAgICAgICAgICAgIGFsbExvd2VyUmlnaHRYLnB1c2gobm9kZS5ib3VuZHMubG93ZXJSaWdodC54KTtcclxuICAgICAgICAgICAgICAgICAgIGFsbExvd2VyUmlnaHRZLnB1c2gobm9kZS5ib3VuZHMubG93ZXJSaWdodC55KTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICB2YXIgbWluWCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIGFsbFVwcGVyTGVmdFgpO1xyXG4gICAgICAgICAgIHZhciBtaW5ZID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgYWxsVXBwZXJMZWZ0WSk7XHJcbiAgICAgICAgICAgdmFyIG1heFggPSBNYXRoLm1heC5hcHBseShNYXRoLCBhbGxMb3dlclJpZ2h0WCk7XHJcbiAgICAgICAgICAgdmFyIG1heFkgPSBNYXRoLm1heC5hcHBseShNYXRoLCBhbGxMb3dlclJpZ2h0WSk7XHJcbiAgICAgICAgICAgdmFyIHNoYXBlc1dpZHRoID0gbWF4WCAtIG1pblg7XHJcbiAgICAgICAgICAgdmFyIHNoYXBlc0hlaWdodCA9IG1heFkgLSBtaW5ZO1xyXG5cclxuICAgICAgICAgICAvL+WIpOaWreW+gOeUu+W4g+mHjOi/mOaYr+WtkOi/m+eoi+mHjOa3u+WKoHNoYXBlc1xyXG4gICAgICAgICAgIHZhciBpbnNlcnRQb3MgPSAnY2FudmFzJztcclxuICAgICAgICAgICBmdW5jdGlvbiBKdWRnZUluU3ViUHJvY2VzcyhzdWJQcm9jZXNzLCB4LCB5KSB7XHJcbiAgICAgICAgICAgICAgIGlmIChzdWJQcm9jZXNzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ViUHJvY2Vzcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmICh4ID4gQnBtblV0aWwucGFyZW50WChzdWJQcm9jZXNzW2ldKSAmJiB4IDwgQnBtblV0aWwucGFyZW50WChzdWJQcm9jZXNzW2ldKSArIHN1YlByb2Nlc3NbaV0uZ2V0UmVjdCgpLndpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHkgPiBCcG1uVXRpbC5wYXJlbnRZKHN1YlByb2Nlc3NbaV0pICYmIHkgPCBCcG1uVXRpbC5wYXJlbnRZKHN1YlByb2Nlc3NbaV0pICsgc3ViUHJvY2Vzc1tpXS5nZXRSZWN0KCkuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJQcm9jZXNzW2ldLmNoaWxkcmVuKCkgJiYgc3ViUHJvY2Vzc1tpXS5jaGlsZHJlbigpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTdWJQcm9jZXNzID0gc3ViUHJvY2Vzc1tpXS5jaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmJwbW5JbmZvICYmIGl0ZW0ubm9kZVR5cGUgPT09ICdTdWJQcm9jZXNzJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IEp1ZGdlSW5TdWJQcm9jZXNzKG5ld1N1YlByb2Nlc3MsIHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlIHx8IHN1YlByb2Nlc3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgdmFyIF9zdWJQcm9jZXNzID0gSnVkZ2VJblN1YlByb2Nlc3ModGhpcy5zdWJQcm9jZXNzTm9kZSwgeCwgeSk7XHJcbiAgICAgICAgICAgaWYgKF9zdWJQcm9jZXNzKSB7XHJcbiAgICAgICAgICAgICAgIGluc2VydFBvcyA9IF9zdWJQcm9jZXNzLnJlc291cmNlSWQ7XHJcbiAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAvL+iuoeeul+WHunNoYXBlc+mHjOavj+S4qnNoYXBl55qE5paw5L2N572u77yMIOW5tuaPkuWFpeWIsOeUu+W4g+aIluiAheafkOS4quWtkOi/m+eoi+eahGNoaWxkU2hhcGVz6YeMXHJcbiAgICAgICAgICAgdmFyIG5ld0NoaWxkU2hhcGVzID0gW107XHJcbiAgICAgICAgICAgaWYgKGluc2VydFBvcyA9PT0gJ2NhbnZhcycpIHtcclxuICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZUNoaWxkU2hhcGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGNsb25lQ2hpbGRTaGFwZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGVuY2lsLnR5cGUgIT09IEJwbW4uU0VRVUVOQ0VfRkxPVykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYm91bmRzLnVwcGVyTGVmdC54ID0gaXRlbS5ib3VuZHMudXBwZXJMZWZ0LnggLSBtaW5YICsgeDtcclxuICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmJvdW5kcy5sb3dlclJpZ2h0LnggPSBpdGVtLmJvdW5kcy5sb3dlclJpZ2h0LnggLSBtaW5YICsgeDtcclxuICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmJvdW5kcy51cHBlckxlZnQueSA9IGl0ZW0uYm91bmRzLnVwcGVyTGVmdC55IC0gbWluWSArIHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5ib3VuZHMubG93ZXJSaWdodC55ID0gaXRlbS5ib3VuZHMubG93ZXJSaWdodC55IC0gbWluWSArIHk7XHJcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uZG9ja2VycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIC8v55S75biD6YeM6L+Y5a2Y5Zyo5YW25LuW6IqC54K5XHJcbiAgICAgICAgICAgICAgIGlmIChvbGRDaGlsZFNoYXBlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9sZENoaWxkU2hhcGVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBvbGRDaGlsZFNoYXBlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGVuY2lsLnR5cGUgPT09IEJwbW4uU0VRVUVOQ0VfRkxPVykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRvY2tlcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmJvdW5kcy5sb3dlclJpZ2h0LnggPj0geCAmJiBub2RlLmJvdW5kcy5sb3dlclJpZ2h0LnkgPj0geSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLy/liKTmlq3pnIDopoHkv67mlLnkvY3nva7nmoToioLngrlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuYm91bmRzLnVwcGVyTGVmdC54IDw9IHggKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL+iKgueCueS9jee9ruWQkeS4i+enu+WKqFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ib3VuZHMudXBwZXJMZWZ0LnkgPSBub2RlLmJvdW5kcy51cHBlckxlZnQueSArIHNoYXBlc0hlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYm91bmRzLmxvd2VyUmlnaHQueSA9IG5vZGUuYm91bmRzLmxvd2VyUmlnaHQueSArIHNoYXBlc0hlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v6IqC54K55L2N572u5ZCR5Y+z56e75YqoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmJvdW5kcy51cHBlckxlZnQueCA9IG5vZGUuYm91bmRzLnVwcGVyTGVmdC54ICsgc2hhcGVzV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmJvdW5kcy5sb3dlclJpZ2h0LnggPSBub2RlLmJvdW5kcy5sb3dlclJpZ2h0LnggKyBzaGFwZXNXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBuZXdDaGlsZFNoYXBlcyA9IG9sZENoaWxkU2hhcGVzLmNvbmNhdChjbG9uZUNoaWxkU2hhcGVzKTtcclxuICAgICAgICAgICAgICAgY2FudmFzRGF0YS5jaGlsZFNoYXBlcyA9IG5ld0NoaWxkU2hhcGVzO1xyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgY2xvbmVDaGlsZFNoYXBlcy5sZW5ndGg7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBjbG9uZUNoaWxkU2hhcGVzW21dO1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uc3RlbmNpbC50eXBlICE9PSBCcG1uLlNFUVVFTkNFX0ZMT1cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmJvdW5kcy51cHBlckxlZnQueCA9IGl0ZW0uYm91bmRzLnVwcGVyTGVmdC54IC0gbWluWCArICh4IC0gQnBtblV0aWwucGFyZW50WChfc3ViUHJvY2VzcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYm91bmRzLmxvd2VyUmlnaHQueCA9IGl0ZW0uYm91bmRzLmxvd2VyUmlnaHQueCAtIG1pblggKyAoeCAtIEJwbW5VdGlsLnBhcmVudFgoX3N1YlByb2Nlc3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmJvdW5kcy51cHBlckxlZnQueSA9IGl0ZW0uYm91bmRzLnVwcGVyTGVmdC55IC0gbWluWSArICh5IC0gQnBtblV0aWwucGFyZW50WShfc3ViUHJvY2VzcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYm91bmRzLmxvd2VyUmlnaHQueSA9IGl0ZW0uYm91bmRzLmxvd2VyUmlnaHQueSAtIG1pblkgKyAoeSAtIEJwbW5VdGlsLnBhcmVudFkoX3N1YlByb2Nlc3MpKTtcclxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5kb2NrZXJzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdmFyIG5ld1gsIG5ld1k7XHJcbiAgICAgICAgICAgICAgIC8v5L+u5pS55omA5Zyo5a2Q6L+b56iL6IqC54K555qE5a696auY5ZKM5a6D55qE5L2N572u5L+h5oGvXHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgb2xkQ2hpbGRTaGFwZXMubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gb2xkQ2hpbGRTaGFwZXNbbl07XHJcbiAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5yZXNvdXJjZUlkID09PSBpbnNlcnRQb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBuZXdYID0gbm9kZS5ib3VuZHMudXBwZXJMZWZ0Lng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgbmV3WSA9IG5vZGUuYm91bmRzLnVwcGVyTGVmdC55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmJvdW5kcy5sb3dlclJpZ2h0LnggLSB4IDwgc2hhcGVzV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ib3VuZHMubG93ZXJSaWdodC54ID0gc2hhcGVzV2lkdGggKyB4ICsgMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmJvdW5kcy5sb3dlclJpZ2h0LnkgLSB5IDwgc2hhcGVzSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYm91bmRzLmxvd2VyUmlnaHQueSA9IHNoYXBlc0hlaWdodCArIHkgKyAxMDtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgLy/mj5LlhaXnmoTlrZDov5vnqIvoioLngrnph4znoa7kv53msqHmnInlhbbku5boioLngrnvvIzoi6XlrZjlnKjlhbbku5boioLngrnlsIbkvJrmuIXnqbpcclxuICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkU2hhcGVzID0gW10uY29uY2F0KGNsb25lQ2hpbGRTaGFwZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIC8v5pKR5byA5a2Q6L+b56iL6IqC54K55Y+v6IO95Lya5b2x5ZON5a6D5ZGo5Zu055qE6IqC54K577yM5Zug5q2k6ZyA6KaB5L+u5pS55ZGo5Zu06IqC54K555qE5L2N572u5L+h5oGvXHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb2xkQ2hpbGRTaGFwZXMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gb2xkQ2hpbGRTaGFwZXNba107XHJcbiAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5yZXNvdXJjZUlkID09PSBpbnNlcnRQb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnN0ZW5jaWwudHlwZSA9PT0gQnBtbi5TRVFVRU5DRV9GTE9XKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kb2NrZXJzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ib3VuZHMubG93ZXJSaWdodC54ID49IG5ld1ggJiYgbm9kZS5ib3VuZHMubG93ZXJSaWdodC55ID49IG5ld1kgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgLy/liKTmlq3pnIDopoHkv67mlLnkvY3nva7nmoToioLngrlcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ib3VuZHMudXBwZXJMZWZ0LnggPD0gbmV3WCApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLy/oioLngrnkvY3nva7lkJHkuIvnp7vliqhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ib3VuZHMudXBwZXJMZWZ0LnkgPSBub2RlLmJvdW5kcy51cHBlckxlZnQueSArIHNoYXBlc0hlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ib3VuZHMubG93ZXJSaWdodC55ID0gbm9kZS5ib3VuZHMubG93ZXJSaWdodC55ICsgc2hhcGVzSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v6IqC54K55L2N572u5ZCR5Y+z56e75YqoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYm91bmRzLnVwcGVyTGVmdC54ID0gbm9kZS5ib3VuZHMudXBwZXJMZWZ0LnggKyBzaGFwZXNXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ib3VuZHMubG93ZXJSaWdodC54ID0gbm9kZS5ib3VuZHMubG93ZXJSaWdodC54ICsgc2hhcGVzV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGNhbnZhc0RhdGEuY2hpbGRTaGFwZXMgPSBvbGRDaGlsZFNoYXBlcztcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgLy/ph43mlrDmuLLmn5PmlbTkuKrnlLvluINcclxuICAgICAgICAgICB0aGlzLmZyb21Kc29uKGNhbnZhc0RhdGEpO1xyXG4gICAgICAgICAgIHRoaXMuc3RlcENvdW50ZXIoKTtcclxuICAgICAgIH1cclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLl9KdWRnZU5vZGVJbldoaWNoU3ViUHJvY2VzcyA9IGZ1bmN0aW9uIChzdWJQcm9jZXNzLCBub2RlKSB7XHJcbiAgICAgICAgICAgaWYgKHN1YlByb2Nlc3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YlByb2Nlc3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgIEJwbW5VdGlsLnBhcmVudFgoc3ViUHJvY2Vzc1tpXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgQnBtblV0aWwucGFyZW50WShzdWJQcm9jZXNzW2ldKSxcclxuICAgICAgICAgICAgICAgICAgICAgICBzdWJQcm9jZXNzW2ldLmdldFJlY3QoKS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICBzdWJQcm9jZXNzW2ldLmdldFJlY3QoKS5oZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoYm91bmRpbmdSZWN0LmNvbnRhaW4obm9kZS54LCBub2RlLnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld05vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YlByb2Nlc3NbaV0uY2hpbGRyZW4oKSAmJiBzdWJQcm9jZXNzW2ldLmNoaWxkcmVuKCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U3ViUHJvY2VzcyA9IHN1YlByb2Nlc3NbaV0uY2hpbGRyZW4oKS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmJwbW5JbmZvICYmIGl0ZW0ubm9kZVR5cGUgPT09ICdTdWJQcm9jZXNzJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHRoaXMuX0p1ZGdlTm9kZUluV2hpY2hTdWJQcm9jZXNzKG5ld1N1YlByb2Nlc3MsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3Tm9kZSB8fCBzdWJQcm9jZXNzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDmoLnmja7mqKHlnovlop7liqDoioLngrko5ZCM5q2lKVxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IOWIm+W7uuWujOaIkOeahOiKgueCuVxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmFkZE5vZGVCeU1vZGVsID0gZnVuY3Rpb24obW9kZWwsIGlzRnJvbURyYWcsIGlzTm9Db3VudCkge1xyXG4gICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICB2YXIgU2hhcGUgPSBCUE1OTm9kZS5nZXRDbGFzcyhtb2RlbC5nZXQoQnBtbi5CUE1OX1RZUEUpKTtcclxuXHJcbiAgICAgICAgICAgaWYgKFNoYXBlKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBub2RlID0gbmV3IFNoYXBlKG1vZGVsLCB0aGlzLl9hcGkpO1xyXG4gICAgICAgICAgICAgICB2YXIgX3N1YlByb2Nlc3MgPSB0aGF0Ll9KdWRnZU5vZGVJbldoaWNoU3ViUHJvY2Vzcyh0aGF0LnN1YlByb2Nlc3NOb2RlLCB7eDogbm9kZS5nZXRSZWN0KCkueCwgeTogbm9kZS5nZXRSZWN0KCkueX0pO1xyXG4gICAgICAgICAgICAgICB0aGF0LmFkZE5vZGVUb1NoYXBlKG5vZGUsIGlzRnJvbURyYWcsIGlzTm9Db3VudCwgX3N1YlByb2Nlc3MpO1xyXG4gICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICog5qC55o2u5qih5Z6L5aKe5Yqg6IqC54K5KOW8guatpSlcclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICogQHJldHVybiB7T2JqZWN0fSDliJvlu7rlrozmiJDnmoToioLngrlcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5hc3luY0FkZE5vZGVCeU1vZGVsID0gZnVuY3Rpb24obW9kZWwsIGlzRnJvbURyYWcsIGlzTm9Db3VudCkge1xyXG4gICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICB2YXIgU2hhcGUgPSBCUE1OTm9kZS5nZXRDbGFzcyhtb2RlbC5nZXQoQnBtbi5CUE1OX1RZUEUpKTtcclxuXHJcbiAgICAgICAgICAgaWYgKFNoYXBlKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBub2RlID0gbmV3IFNoYXBlKG1vZGVsLCB0aGlzLl9hcGkpO1xyXG4gICAgICAgICAgICAgICB2YXIgX3N1YlByb2Nlc3MgPSB0aGF0Ll9KdWRnZU5vZGVJbldoaWNoU3ViUHJvY2Vzcyh0aGF0LnN1YlByb2Nlc3NOb2RlLCB7eDogbm9kZS5nZXRSZWN0KCkueCwgeTogbm9kZS5nZXRSZWN0KCkueX0pO1xyXG4gICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ2JlZm9yZUFkZE5vZGUnLCB7dGFyZ2V0OiBfc3ViUHJvY2Vzc30sIG5vZGUpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkTm9kZVRvU2hhcGUobm9kZSwgaXNGcm9tRHJhZywgaXNOb0NvdW50LCBfc3ViUHJvY2Vzcyk7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH07XHJcblxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5hZGROb2RlVG9TaGFwZSA9IGZ1bmN0aW9uIChub2RlLCBpc0Zyb21EcmFnLCBpc05vQ291bnQsIF9zdWJQcm9jZXNzKSB7XHJcbiAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgIHZhciBtZXNBcnJheTtcclxuICAgICAgICAgICBpZiAodGhhdC5zdWJQcm9jZXNzTm9kZS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICB0aGF0Ll96ci5hZGQobm9kZSk7XHJcbiAgICAgICAgICAgICAgIG1lc0FycmF5ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXHJcbiAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogW25vZGUuZ2V0UmVjdCgpLngsIG5vZGUuZ2V0UmVjdCgpLnldLFxyXG4gICAgICAgICAgICAgICAgICAgd2lkdGg6IG5vZGUuZ2V0UmVjdCgpLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmdldFJlY3QoKS5oZWlnaHRcclxuICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgaWYgKCFCcG1uLmlzU2xvdEV2ZW50KG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0Lm92ZXJsYXBBcnJheS5wdXNoKG1lc0FycmF5KTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIHRoYXQuX3pyLmFkZChub2RlKTtcclxuICAgICAgICAgICAgICAgbWVzQXJyYXkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcclxuICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbbm9kZS5nZXRSZWN0KCkueCwgbm9kZS5nZXRSZWN0KCkueV0sXHJcbiAgICAgICAgICAgICAgICAgICB3aWR0aDogbm9kZS5nZXRSZWN0KCkud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG5vZGUuZ2V0UmVjdCgpLmhlaWdodFxyXG4gICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICBpZiAoIUJwbW4uaXNTbG90RXZlbnQobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgIHRoYXQub3ZlcmxhcEFycmF5LnB1c2gobWVzQXJyYXkpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGlmIChpc0Zyb21EcmFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IDAsIG9mZnNldFkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKF9zdWJQcm9jZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zdWJQcm9jZXNzLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhfc3ViUHJvY2Vzcy5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFggPSBCcG1uVXRpbC5wYXJlbnRYKF9zdWJQcm9jZXNzLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFkgPSBCcG1uVXRpbC5wYXJlbnRZKF9zdWJQcm9jZXNzLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cE5vZGVQb3NpdGlvblggPSBfc3ViUHJvY2Vzcy5nZXRSZWN0KCkud2lkdGggLyAyICsgKG5vZGUuZ2V0UmVjdCgpLnggLSAoX3N1YlByb2Nlc3MuZ2V0UmVjdCgpLnggKyBvZmZzZXRYKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwTm9kZVBvc2l0aW9uWSA9IF9zdWJQcm9jZXNzLmdldFJlY3QoKS5oZWlnaHQgLyAyICsgKG5vZGUuZ2V0UmVjdCgpLnkgLSAoX3N1YlByb2Nlc3MuZ2V0UmVjdCgpLnkgKyBvZmZzZXRZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRQb3NpdGlvbihncm91cE5vZGVQb3NpdGlvblgsIGdyb3VwTm9kZVBvc2l0aW9uWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgX3N1YlByb2Nlc3MuYWRkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3pyLnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoYXQub3ZlcmxhcEFycmF5Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlkID09IHRoYXQub3ZlcmxhcEFycmF5W2pdLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm92ZXJsYXBBcnJheS5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgLy8yLuWmguaenOaYr+WtkOiKgueCuSDliJnliqDlhaXliLDlrZDoioLngrnmlbDnu4TkuK1cclxuICAgICAgICAgICBpZiAoQnBtbi5pc1N1YlByb2Nlc3Mobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgdGhhdC5zdWJQcm9jZXNzTm9kZS5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICB0aGF0LmFsbE5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgLy/mlL7lhaXoioLngrnkvY3nva7kv6Hmga8g55So5LqO5ouW5ou9XHJcbiAgICAgICAgICAgbWVzQXJyYXkucG9zaXRpb24gPSBbbm9kZS5nZXRSZWN0KCkueCwgbm9kZS5nZXRSZWN0KCkueV07XHJcbiAgICAgICAgICAgbWVzQXJyYXkucG9pbnRzID0gdGhhdC5fZ2V0Q29udHJvbHNPZk5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgbWVzQXJyYXkucm90YXRpb24gPSBub2RlLnJvdGF0aW9uO1xyXG4gICAgICAgICAgIHRoYXQuZG9tQXJyYXkucHVzaChtZXNBcnJheSk7XHJcblxyXG4gICAgICAgICAgIC8v5L6m5ZCs6IqC54K555qE5LqL5Lu2IOW5tuaKiuS6i+S7tue7meWPlua2iOaOiSDpmLLmraIg5aaC5p6c54i25piv5a2Q6IqC54K55L6m5ZCs5YiwXHJcbiAgICAgICAgICAgbm9kZS5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICBpZiAoISh0aGF0LmZvcmJpZEVkaXQgPT0gdHJ1ZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnR5cGUgPT09IFwiZHJhZ1NlbGVjdFwiKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgKHRoYXQubW91c2VNb2RlID09PSBcImRyYWctc2VsZWN0XCIgJiYgQnBtbi5pc1N1YlByb2Nlc3ModGhpcykpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgdGhhdC5uZXdEcmFnKHRoaXMsIGUuZXZlbnQuY2xpZW50WCwgZS5ldmVudC5jbGllbnRZKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAvL+WmguaenOmAieaLqeeahOaYr+S6i+S7tuiKgueCue+8jOWImeS4uuWFtuS7lnRhc2vnu5Hlrprmj5Lmp71cclxuICAgICAgICAgICAgICAgaWYgKEJwbW4uaXNTbG90RXZlbnQodGhpcykpIHtcclxuICAgICAgICAgICAgICAgICAgIHRoYXQuYmluZEV2ZW50Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGlmICh0aGF0Lm1vdXNlTW9kZSAhPT0gXCJkcmFnLXNlbGVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICBub2RlLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgdGhhdC5ub2RlQ2xpY2tIYW5kbGVyKHRoaXMpO1xyXG4gICAgICAgICAgICAgICB0aGF0Ll90cmlnZ2VyKCdzZWxlY3ROb2RlJywge3RhcmdldDogbm9kZX0pO1xyXG4gICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgLy/mt7vliqB0aXBcclxuICAgICAgICAgICBpZiAoQnBtbi5pc0FjdGl2aXR5KG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgIHRoYXQuY3JlYXRUaXAobm9kZSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIG5vZGUub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgIGlmICh0aGlzLmFsYXJtICYmIHRoaXMuYWxhcm0uaXNTaG93ID09IHRydWUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLmFsYXJtLnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuYWxhcm0uZWFjaENoaWxkKGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAvL+agueaNruWtl+WGheWuueabtOaUuXRpcOWkluahhueahOWkp+Wwj1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmFsYXJtLmNoaWxkT2ZOYW1lKFwiVGV4dFwiKTtcclxuICAgICAgICAgICAgICAgICAgIHZhciBncm91cFdpZHRoID0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCArIDQ7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBIZWlnaHQgPSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCArIDg7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgIFswLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICAgICBbZ3JvdXBXaWR0aCwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgW2dyb3VwV2lkdGgsIGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICBbZ3JvdXBXaWR0aCAvIDIgLSAzLCBncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgW2dyb3VwV2lkdGggLyAyLCBncm91cEhlaWdodCArIDNdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIFtncm91cFdpZHRoIC8gMiArIDMsIGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICBbMCwgZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIFswLCAwXVxyXG4gICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgIHZhciBQb2x5bGluZSA9IHRoaXMuYWxhcm0uY2hpbGRPZk5hbWUoXCJQb2x5bGluZVwiKTtcclxuICAgICAgICAgICAgICAgICAgIFBvbHlsaW5lLmF0dHIoXCJzaGFwZVwiLCB7cG9pbnRzOiBwb2ludHN9KTtcclxuICAgICAgICAgICAgICAgICAgIHZhciBncm91cFBvc2l0aW9uID0gW0JwbW5VdGlsLnBhcmVudFgobm9kZSkgKyBub2RlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC0gdGhpcy5hbGFybS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDIsIEJwbW5VdGlsLnBhcmVudFkobm9kZSkgLSB0aGlzLmFsYXJtLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAtIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5hbGFybS5hdHRyKFwicG9zaXRpb25cIiwgZ3JvdXBQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICBub2RlLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgIGlmICh0aGlzLmFsYXJtKSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLmFsYXJtLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuYWxhcm0uZWFjaENoaWxkKGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICBpZiAoaXNOb0NvdW50ICE9IHRydWUpIHtcclxuICAgICAgICAgICAgICAgdGhhdC5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICB0aGF0Ll90cmlnZ2VyKCdhZnRlckNyZWF0ZU5vZGUnLCB7dGFyZ2V0OiBub2RlfSk7XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDpgInkuK3lnLrmma/kuK3nmoTmn5DkuKroioLngrks5bm25LiU6Kem5Y+Rc2VsZWN0Tm9kZeS6i+S7tlxyXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUg5b6F6YCJ5Lit55qE6IqC54K55a+56LGhXHJcbiAgICAgICAgKiBAc2luY2UgVjIuMy4wXHJcbiAgICAgICAgKiAgKirkvb/nlKjojIPkvovvvJoqKlxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGZpc2hUb3BvLnNlbGVjdE5vZGUobm9kZSk7XHJcbiAgICAgICAgKi9cclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLnNlbGVjdE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgdGhpcy5ub2RlQ2xpY2tIYW5kbGVyKG5vZGUpO1xyXG4gICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCdzZWxlY3ROb2RlJywge3RhcmdldDogbm9kZX0pO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDmoLnmja5uYW1l6I635Y+W6IqC54K5XHJcbiAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUg5Zyo5Yib5bu66IqC54K55LitICBuYW1l5bGe5oCn6K6+572u55qE5YC8XHJcbiAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgbmFtZeWvueW6lOeahOiKgueCuVxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmNoaWxkT2ZOYW1lID0gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgIHZhciBhcnJSZXN1bHQgPSBbXTtcclxuICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsTm9kZXNbaV0ubW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpID09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgIGFyclJlc3VsdC5wdXNoKHRoaXMuYWxsTm9kZXNbaV0pO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGlmIChhcnJSZXN1bHQubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICByZXR1cm4gYXJyUmVzdWx0O1xyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIHJldHVybiBhcnJSZXN1bHRbMF07XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIOafpeaJvuWcuuaZr+S4reeahOWvueixoSAgIOS+i+WmgjogeOWdkOagh+Wkp+S6jjEwMOeahOiKgueCuSBmaW5kRWxlbWVudHMoZnVuY3Rpb24oZSl7IHJldHVybiBlLnBvc2l0aW9uWzBdID4gMTAwOyB9KTtcclxuICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYiAgICAgIOWbnuiwg+WHveaVsFxyXG4gICAgICAgICogQHBhcmFtICB7T2JqZWN0fSAgIGNvbnRleHQg5Zue6LCD5Ye95pWw5omn6KGM55qE5LiK5LiL5paHXHJcbiAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgIOi/lOWbnuafpeaJvuWIsOeahOWvueixoVxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmZpbmRFbGVtZW50cyA9IGZ1bmN0aW9uKGNiLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgdmFyIGNoaWxkcmVuTm9kZSA9IHRoaXMuYWxsTm9kZXM7XHJcbiAgICAgICAgICAgdmFyIGNoaWxkcmVuTGluZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycztcclxuICAgICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbk5vZGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5Ob2RlW2ldO1xyXG4gICAgICAgICAgICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBjaGlsZCwgaSkpIHtcclxuICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkcmVuTGluZS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICB2YXIgY2hpbGRMaW5lID0gY2hpbGRyZW5MaW5lW2pdO1xyXG4gICAgICAgICAgICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBjaGlsZExpbmUsIGopKSB7XHJcbiAgICAgICAgICAgICAgICAgICBhcnIucHVzaChjaGlsZExpbmUpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqIOagueaNruaooeWei+WinuWKoOe6v1xyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmFkZENvbm5lY3RvckJ5TW9kZWwgPSBmdW5jdGlvbihtb2RlbCwgcGFyZW50WnIpIHtcclxuICAgICAgICAgICAvL+aJvuWHuiBzdGFydE5vZGUg5LiOIGVuZE5vZGVcclxuICAgICAgICAgICB2YXIgc3RhcnROb2RlID0gbnVsbCxcclxuICAgICAgICAgICAgICAgZW5kTm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgenJVdGlsLmVhY2godGhpcy5hbGxOb2RlcywgZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAgICAvL3N0YXJ0Tm9kZTog5LuOYWxsTm9kZeS4reaJvuWHum91dGdvaW5n5Li6IOe6v+eahGlk55qE6LW35aeL6IqC54K5XHJcbiAgICAgICAgICAgICAgIHZhciBub2RlT3V0Z29pbmcgPSBub2RlLm1vZGVsLmdldChcIm91dGdvaW5nXCIpO1xyXG4gICAgICAgICAgICAgICBpZiAobm9kZU91dGdvaW5nLmluZGV4T2YobW9kZWwuZ2V0KFwicmVzb3VyY2VJZFwiKSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICBzdGFydE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIC8vZW5kTm9kZSA6IOS7jmFsbE5vZGXkuK3mib7lh7ogaWQg5Li657q/55qEb3V0Z29pbmfnmoTnu5PmnZ/oioLngrlcclxuICAgICAgICAgICAgICAgdmFyIGNvbm5lY3Rvck91dGdvaW5nID0gbW9kZWwuZ2V0KFwib3V0Z29pbmdcIik7XHJcbiAgICAgICAgICAgICAgIGlmIChjb25uZWN0b3JPdXRnb2luZy5pbmRleE9mKG5vZGUucmVzb3VyY2VJZCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICBlbmROb2RlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIGlmIChzdGFydE5vZGUgJiYgZW5kTm9kZSkge1xyXG4gICAgICAgICAgICAgICB2YXIgY29ubmVjdG9yID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JDcmVhdGVCeU9wdGlvbnMoc3RhcnROb2RlLCBlbmROb2RlLCB7bW9kZWw6IG1vZGVsLGlzRnJvbU1vZGVsOnRydWV9LCB0aGlzLl9hcGkpO1xyXG4gICAgICAgICAgICAgICBpZiAocGFyZW50WnIpIHtcclxuICAgICAgICAgICAgICAgICAgIHBhcmVudFpyLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgIHRoaXMuX3pyLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9yRm9yYmlkRWRpdCh0aGlzLmZvcmJpZEVkaXQpO1xyXG4gICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVDb25uZWN0b3JEcmFnRXZlbnRzKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgICAgIGNvbm5lY3Rvci5vbihcIm1vdXNlZG93blwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmlzRWRpdCA9ICF0aGlzLmZvcmJpZEVkaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAvLyDlj5bmtojoioLngrnnmoTpgInkuK1cclxuICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JDb250cm9sKCk7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVPcGVyYXRpb25Ob2RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLmlzTm9kZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgIH1cclxuXHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICog5Yib5bu66L+e57q/55qE5bCP5Zu+5qCH5pON5L2cXHJcbiAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IOWwj+Wbvuagh+eahOWQjeensFxyXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMg5bCP5Zu+5qCH6YCJ6aG5XHJcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaWNvbl0g5bCP5Zu+5qCH6Lev5b6EXHJcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGluZU5vZGVdIOe6v+auteWunuS+i1xyXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdIOeCueWHu+WQjueahOWbnuiwg1xyXG4gICAgICAgICpcclxuICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAqXHJcbiAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgKiAgICAgIGZpc2hUb3BvQnBtbi5hZGRJY29uKFwiaWNvbjFcIix7ICAvL+e6v+S4iuWbvuagh+eahOWQjeensFxyXG4gICAgICAgICogICAgICAgICAgICAgICAgICAgIGljb246XCJicG1uMi4wL2ljb25zL2FjdGl2aXR5L2xpc3QvbWFpbC5zZW5kLnBuZ1wiLCAvL+e6v+S4iuWbvuagh+eahOi3r+W+hFxyXG4gICAgICAgICogICAgICAgICAgICAgICAgICAgICBsaW5lTm9kZTpsaW5lTm9kZSwgIC8v57q/XHJcbiAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOmZ1bmN0aW9uKGxpbmVOb2RlKXsgIC8v5Zue6LCDXHJcbiAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoSlNPTi5zdHJpbmdpZnkobGluZU5vZGUpKVxyXG4gICAgICAgICogICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAqICAgICAgICAgICAgICAgICAgfSk7KlxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmFkZEljb24gPSBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcclxuICAgICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmFkZEljb24oa2V5LCBvcHRpb25zKTtcclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDliJvlu7rov57nur/nmoTpu5jorqTliKDpmaTmk43kvZxcclxuICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gbGluZU5vZGUg57q/XHJcbiAgICAgICAgKlxyXG4gICAgICAgICogICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAqXHJcbiAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgKiAgICAgIGZpc2hUb3BvQnBtbi5iaW5kTGluZURlbGV0ZShsaW5lTm9kZSk7XHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uYmluZExpbmVEZWxldGUgPSBmdW5jdGlvbihsaW5lTm9kZSxvcHRpb25zKSB7XHJcbiAgICAgICAgICAgLy/liJvlu7rliKDpmaRcclxuICAgICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmFkZERlbGV0ZUljb24obGluZU5vZGUsb3B0aW9ucyk7XHJcbiAgICAgICB9O1xyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICog6L+U5ZueIOi/nuWQkeivpeiKgueCueeahOiKgueCueaVsOe7hO+8mm5vZGVBcnJheVswXSAg5Lul5Y+K6K+l6IqC54K56L+e5ZCR55qE6IqC54K55pWw57uEIG5vZGVBcnJheVswXVxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmNoZWNrTGluZU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgdmFyIHN0YXJ0QXJyYXkgPSBbXSxcclxuICAgICAgICAgICAgICAgZW5kQXJyYXkgPSBbXTtcclxuICAgICAgICAgICB2YXIgbGluZUFycmF5ID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JzO1xyXG4gICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgaWYgKGxpbmVBcnJheVtpXS5zdGFydE5vZGUgPT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgZW5kQXJyYXkucHVzaChsaW5lQXJyYXlbaV0uZW5kTm9kZSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbkVuZCA9IGxpbmVBcnJheS5sZW5ndGg7IGogPCBsZW5FbmQ7IGorKykge1xyXG4gICAgICAgICAgICAgICBpZiAobGluZUFycmF5W2pdLmVuZE5vZGUgPT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgc3RhcnRBcnJheS5wdXNoKGxpbmVBcnJheVtqXS5zdGFydE5vZGUpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHJldHVybiBbc3RhcnRBcnJheSwgZW5kQXJyYXldO1xyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKiDorqHnrpflnKhzdWJwcm9jZXNz5YaF55qE6IqC54K555qE55yf5a6e5L2N572uXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uY2FsY3VsYXRlTm9kZVJlY3RJbkdyb3VwID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgIHZhciByZWN0ID0gdXRpbC5nZXRSZWN0KG5vZGUpO1xyXG4gICAgICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgcmVjdC5ib3VuZGluZ1JlY3QueCArPSBCcG1uVXRpbC5wYXJlbnRYKG5vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgICAgcmVjdC5ib3VuZGluZ1JlY3QueSArPSBCcG1uVXRpbC5wYXJlbnRZKG5vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgICAgcmVjdC54ICs9IEJwbW5VdGlsLnBhcmVudFgobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICByZWN0LnkgKz0gQnBtblV0aWwucGFyZW50WShub2RlLnBhcmVudCk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgIHJlY3Q6IHJlY3QsXHJcbiAgICAgICAgICAgICAgIHBhcmVudE5vZGU6IEJwbW5VdGlsLmdldFBhcmVudE5vZGUobm9kZSlcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICog5L6d5qyh5LuO6IqC54K56YCS5b2S6Iez5pyA5aSW5bGC55qEc3VicHJvY2Vzc++8jOiuoeeul+iKgueCueacgOe7iOeahOWMheWbtOebklxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmNhbGN1bGF0ZVJlY3QgPSBmdW5jdGlvbihub2RlLCBub2RlUmVjdCkge1xyXG4gICAgICAgICAgIGlmICghbm9kZVJlY3QpIHtcclxuICAgICAgICAgICAgICAgbm9kZVJlY3QgPSB0aGlzLmNhbGN1bGF0ZU5vZGVSZWN0SW5Hcm91cChub2RlKS5yZWN0O1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBpZiAoIW5vZGVSZWN0LnJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgIG5vZGVSZWN0LnJvdGF0aW9uID0gbm9kZS5yb3RhdGlvbjtcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICBub2RlUmVjdC5yb3RhdGlvbiArPSBub2RlLnJvdGF0aW9uO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICAvLyDlpoLmnpzniLboioLngrnml4vovazkuobvvIzpnIDopoHmm7TmlrDlrZDoioLngrnnmoTkuK3lv4PngrlcclxuICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3Mobm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IG5vZGUucGFyZW50LnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocm90YXRpb24pID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuY2FsY3VsYXRlTm9kZVJlY3RJbkdyb3VwKG5vZGUucGFyZW50KS5yZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHg6IG5vZGVSZWN0LngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgeTogbm9kZVJlY3QueVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgdmFyIG5Qb2ludCA9IHV0aWwuY2FsY3VsYXRlUG9pbnRzKHBvaW50LCBjZW50ZXIsIHJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgIG5vZGVSZWN0LnggPSBuUG9pbnQueDtcclxuICAgICAgICAgICAgICAgICAgIG5vZGVSZWN0LnkgPSBuUG9pbnQueTtcclxuICAgICAgICAgICAgICAgICAgIG5vZGVSZWN0LmJvdW5kaW5nUmVjdC54ID0gbm9kZVJlY3QueCAtIG5vZGVSZWN0LndpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgICAgIG5vZGVSZWN0LmJvdW5kaW5nUmVjdC55ID0gbm9kZVJlY3QueSAtIG5vZGVSZWN0LmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlUmVjdChub2RlLnBhcmVudCwgbm9kZVJlY3QpO1xyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIHJldHVybiBub2RlUmVjdDtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5jcmVhdGVDb25uZWN0b3JQb2ludCA9IGZ1bmN0aW9uKHBvaW50LCBwb3MsIGxpbmVUeXBlKSB7XHJcbiAgICAgICAgICAgdmFyIG1lID0gdGhpcztcclxuICAgICAgICAgICB2YXIgcG9pbnRJbnN0YW5jZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICBjeDogcG9pbnQueCxcclxuICAgICAgICAgICAgICAgICAgIGN5OiBwb2ludC55LFxyXG4gICAgICAgICAgICAgICAgICAgcjogNFxyXG4gICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgZmlsbDogJyNGRkZGMzMnLFxyXG4gICAgICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwMDAwJ1xyXG4gICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICB6IDogMixcclxuICAgICAgICAgICAgICAgY3Vyc29yOiAnY3Jvc3NoYWlyJyxcclxuICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICBsaW5lVHlwZTogbGluZVR5cGVcclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICBwb2ludEluc3RhbmNlLnR5cGUgPSAnQ29ubmVjdFBvaW50JztcclxuICAgICAgICAgICBwb2ludEluc3RhbmNlLnBvcyA9IHBvczsgICAgICAgICAgICAgICAgLy/orrDlvZXmmK/oioLngrnkuIrlk6rkuKrkvY3nva7nmoTov57mjqXngrlcclxuICAgICAgICAgICB2YXIgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2RyYWdzdGFydCcsICdkcmFnJywgJ2RyYWdlbmQnXTtcclxuICAgICAgICAgICB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24oZXZlTmFtZSkge1xyXG4gICAgICAgICAgICAgICBwb2ludEluc3RhbmNlLm9uKGV2ZU5hbWUsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiQ29ubmVjdFBvaW50OlwiICsgZXZlTmFtZTtcclxuICAgICAgICAgICAgICAgICAgIG1lLmNvblBvaW50c0dyb3VwLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIHRoaXMuY29uUG9pbnRzR3JvdXAuYWRkKHBvaW50SW5zdGFuY2UpO1xyXG4gICAgICAgfVxyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uaGlkZUNvbm5lY3RvclBvaW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cC5yZW1vdmVBbGwoKTsgIC8v6ZqQ6JeP5omA5pyJ6IqC54K55LiK55qE6L+e5o6l54K5XHJcbiAgICAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cC5vZmYoKTsgICAgICAgIC8v5riF56m65omA5pyJ5LqL5Lu2XHJcbiAgICAgICAgICAgdGhpcy5fenIucmVtb3ZlKHRoaXMuY29uUG9pbnRzR3JvdXApO1xyXG4gICAgICAgfVxyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uZmlsdGVyQ29ubmVjdFBvaW50ID0gZnVuY3Rpb24odGFyZ2V0Tm9kZXMsIGxpbmVUeXBlKSB7XHJcbiAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgIHZhciBub2RlcyA9IHRhcmdldE5vZGVzO1xyXG4gICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICB2YXIgY2FsY3VsYXRlUmVjdCA9IHRoYXQuY2FsY3VsYXRlUmVjdChpdGVtKTtcclxuICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RvclBvaW50ID0gdXRpbC5nZXRDb25uZWN0b3JQb2ludHMoY2FsY3VsYXRlUmVjdCwgeyByb3RhdGlvbjogY2FsY3VsYXRlUmVjdC5yb3RhdGlvbiB9KTtcclxuICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JQb2ludChjb25uZWN0b3JQb2ludC5sZWZ0LCBcImxlZnRcIiwgbGluZVR5cGUpO1xyXG4gICAgICAgICAgICAgICB0aGF0LmNyZWF0ZUNvbm5lY3RvclBvaW50KGNvbm5lY3RvclBvaW50LnJpZ2h0LCBcInJpZ2h0XCIsIGxpbmVUeXBlKTtcclxuICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JQb2ludChjb25uZWN0b3JQb2ludC50b3AsIFwidG9wXCIsIGxpbmVUeXBlKTtcclxuICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JQb2ludChjb25uZWN0b3JQb2ludC5ib3R0b20sIFwiYm90dG9tXCIsIGxpbmVUeXBlKTtcclxuICAgICAgICAgICB9KTtcclxuICAgICAgIH1cclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLnNob3dDb25uZWN0b3JQb2ludCA9IGZ1bmN0aW9uKGxpbmVUeXBlLCBsaW5lT3B0LCBpZkN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgICAgaWYgKGxpbmVPcHQpIHtcclxuICAgICAgICAgICAgICAgdGhpcy5saW5lT3B0ID0gbGluZU9wdDsgIC8v57yT5a2Y57q/5q6155qE6YWN572u5L+h5oGvXHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGlmIChsaW5lVHlwZSkge1xyXG4gICAgICAgICAgICAgICB0aGlzLmxpbmVUeXBlID0gbGluZVR5cGU7IC8vIOe8k+WtmOe6v+auteexu+Wei1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBpZiAoIXRoaXMubGluZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgdGhpcy5saW5lVHlwZSA9ICdqYWdnZWQnOyAvLyDnur/mrrXpu5jorqTmipjnur/nsbvlnotcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgaWYgKCFpZkN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgIGlmQ3VycmVudE5vZGUgPSBmYWxzZTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgdmFyIHRhcmdldE5vZGVzID0gaWZDdXJyZW50Tm9kZSA/IFt0aGF0LnNlbGVjdGVkTm9kZV0gOiB0aGF0LmFsbE5vZGVzO1xyXG4gICAgICAgICAgIC8vIOiuqeaJgOacieeUu+W4g+S4reeahOiKgueCuS/lvZPliY3oioLngrnmmL7npLrov57mjqXngrlcclxuICAgICAgICAgICB0aGlzLmZpbHRlckNvbm5lY3RQb2ludCh0YXJnZXROb2RlcywgdGhpcy5saW5lVHlwZSk7XHJcblxyXG4gICAgICAgICAgIGZ1bmN0aW9uIGZpbmRDb25uZWN0b3JOb2RlKHgsIHksIG9mZnNldCwgcG9zKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBub2RlLCBlbmRQb3MgPSBudWxsO1xyXG4gICAgICAgICAgICAgICB0aGF0LmFsbE5vZGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIGNhbGN1bGF0ZVJlY3QgPSB0aGF0LmNhbGN1bGF0ZVJlY3QoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9yUG9pbnQgPSB1dGlsLmdldENvbm5lY3RvclBvaW50cyhjYWxjdWxhdGVSZWN0LCB7IHJvdGF0aW9uOiBjYWxjdWxhdGVSZWN0LnJvdGF0aW9uIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKHBvcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjb25uZWN0b3JQb2ludFtwb3NdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbcG9zXS55IC0geSkgPD0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wibGVmdFwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wibGVmdFwiXS55IC0geSkgPD0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1widG9wXCJdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbXCJ0b3BcIl0ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3MgPSBcInRvcFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wicmlnaHRcIl0ueCAtIHgpIDw9IG9mZnNldCAmJiBNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInJpZ2h0XCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wiYm90dG9tXCJdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbXCJib3R0b21cIl0ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3MgPSBcImJvdHRvbVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcclxuICAgICAgICAgICAgICAgICAgIGVuZFBvczogZW5kUG9zXHJcbiAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHRoaXMuY29uUG9pbnRzR3JvdXAub24oXCJDb25uZWN0UG9pbnQ6ZHJhZ3N0YXJ0XCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgLy8g5aaC5p6c5piv5b2T5YmN6IqC54K55pi+56S66L+e5o6l54K577yM6ZyA6KaB5Zyo5ouW5Yqo5Ymq5aS05pe26K6p55S75biD5Lit55qE5YW25LuW6IqC54K55pi+56S66L+e5o6l54K5XHJcbiAgICAgICAgICAgICAgIGlmIChpZkN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0LmZpbHRlckNvbm5lY3RQb2ludCh0aGF0LmFsbE5vZGVzLCB0aGF0LmxpbmVUeXBlKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB2YXIgeCA9IGUuZXZlbnQub2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgdmFyIHkgPSBlLmV2ZW50Lm9mZnNldFk7XHJcbiAgICAgICAgICAgICAgIHZhciBhcnJvdyA9IGUuZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICB0aGF0LnN0YXJ0UG9zID0gYXJyb3cucG9zO1xyXG4gICAgICAgICAgICAgICB0aGF0LnNlbGVjdENvbm5Ob2RlID0gZmluZENvbm5lY3Rvck5vZGUoYXJyb3cuc2hhcGUuY3gsIGFycm93LnNoYXBlLmN5LCAwLCB0aGF0LnN0YXJ0UG9zKS5ub2RlO1xyXG4gICAgICAgICAgICAgICBhcnJvdy5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgIHRoYXQubGluZU9wZXJhdGlvbk1hbmFnZXIuaGlkZUFsbExpbmVPcGVyYXRpb24oKTtcclxuICAgICAgICAgICAgICAgdGhhdC5yZXZlcnNlQ29ubmVjdCA9IGZhbHNlOyAgIC8v5piv5ZCm5Y+N5ZCR6L+e57q/55qE5qCH6K+GXHJcbiAgICAgICAgICAgICAgIHRoYXQub3JpZ2luTm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcclxuICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlVGVtcENvbm5lY3Rvcih0aGF0LnNlbGVjdENvbm5Ob2RlLCBwb2ludCwgYXJyb3cubGluZVR5cGUsIHRoYXQuc3RhcnRQb3MpO1xyXG4gICAgICAgICAgICAgICB0aGF0Ll96ci5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwLm9uKFwiQ29ubmVjdFBvaW50OmRyYWdcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICB2YXIgYXJyb3cgPSBlLmV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgICAgdGhhdC5faGFuZGxlTGluZURyYWcoJ2RyYWcnLCBlLCBhcnJvdy5saW5lVHlwZSk7XHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cC5vbihcIkNvbm5lY3RQb2ludDpkcmFnZW5kXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgdmFyIGFycm93ID0gZS5ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgIHRoYXQuX2hhbmRsZUxpbmVEcmFnKCdkcmFnZW5kJywgZSwgYXJyb3cubGluZVR5cGUpO1xyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzLmNvblBvaW50c0dyb3VwKTtcclxuICAgICAgIH1cclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIOWkhOeQhui/nue6v+WSjOi/nuaOpeeCuWRyYWfkuovku7ZcclxuICAgICAgICAqIEBtZXRob2QgX2hhbmRsZUxpbmVEcmFnXHJcbiAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRyYWdUeXBlIGRyYWfnsbvlnotcclxuICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gZSAgIGV2ZW505LqL5Lu25a+56LGhXHJcbiAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGxpbmVUeXBlIOi/nue6v+exu+Wei1xyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLl9oYW5kbGVMaW5lRHJhZyA9IGZ1bmN0aW9uKGRyYWdUeXBlLCBlLCBsaW5lVHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciB4ID0gZS5ldmVudC5vZmZzZXRYO1xyXG4gICAgICAgICAgICB2YXIgeSA9IGUuZXZlbnQub2Zmc2V0WTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZmluZENvbm5lY3Rvck5vZGUoeCwgeSwgb2Zmc2V0LCBwb3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlLCBlbmRQb3MgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5hbGxOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FsY3VsYXRlUmVjdCA9IHRoYXQuY2FsY3VsYXRlUmVjdChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9yUG9pbnQgPSB1dGlsLmdldENvbm5lY3RvclBvaW50cyhjYWxjdWxhdGVSZWN0LCB7IHJvdGF0aW9uOiBjYWxjdWxhdGVSZWN0LnJvdGF0aW9uIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W3Bvc10ueCAtIHgpIDw9IG9mZnNldCAmJiBNYXRoLmFicyhjb25uZWN0b3JQb2ludFtwb3NdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wibGVmdFwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wibGVmdFwiXS55IC0geSkgPD0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1widG9wXCJdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbXCJ0b3BcIl0ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJ0b3BcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wicmlnaHRcIl0ueCAtIHgpIDw9IG9mZnNldCAmJiBNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInJpZ2h0XCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wiYm90dG9tXCJdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbXCJib3R0b21cIl0ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJib3R0b21cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kUG9zOiBlbmRQb3NcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xyXG4gICAgICAgICAgICBpZiAoZHJhZ1R5cGUgPT09ICdkcmFnJykge1xyXG4gICAgICAgICAgICBpZiAodGhhdC5yZXZlcnNlQ29ubmVjdCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5tYW5hZ2VSZXZlcnNlVGVtcENvbm5lY3Rvcihwb2ludCwgdGhhdC5zZWxlY3RDb25uTm9kZSwgbGluZVR5cGUsIHRoYXQuZW5kUG9zKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlVGVtcENvbm5lY3Rvcih0aGF0LnNlbGVjdENvbm5Ob2RlLCBwb2ludCwgbGluZVR5cGUsIHRoYXQuc3RhcnRQb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoYXQuY29uUG9pbnRzR3JvdXAuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICB2LmF0dHIoe3N0eWxlOntmaWxsOiBcIiNGRkZGMzNcIn0sc2NhbGU6WzEsMV0sb3JpZ2luOlt2LnNoYXBlLmN4LHYuc2hhcGUuY3ldLGN1cnNvcjonY3Jvc3NoYWlyJ30pO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHYuc2hhcGUuY3ggLSB4KSA8PSAxMCAmJiBNYXRoLmFicyh2LnNoYXBlLmN5IC0geSkgPD0gMTApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gZmluZENvbm5lY3Rvck5vZGUoeCwgeSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnJldmVyc2VDb25uZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlUmV2ZXJzZVRlbXBDb25uZWN0b3IocG9pbnQsIHRoYXQuc2VsZWN0Q29ubk5vZGUsIGxpbmVUeXBlLCB0aGF0LmVuZFBvcywgcmVzLmVuZFBvcywgcmVzLm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlVGVtcENvbm5lY3Rvcih0aGF0LnNlbGVjdENvbm5Ob2RlLCBwb2ludCwgbGluZVR5cGUsIHRoYXQuc3RhcnRQb3MsIHJlcy5lbmRQb3MsIHJlcy5ub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdi5hdHRyKHtzdHlsZTp7ZmlsbDogXCIjZmYwMDAwXCJ9LHNjYWxlOlsxLjUsMS41XSxvcmlnaW46W3Yuc2hhcGUuY3gsdi5zaGFwZS5jeV0sY3Vyc29yOidwb2ludGVyJ30pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkcmFnVHlwZSA9PT0gJ2RyYWdlbmQnKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSBmaW5kQ29ubmVjdG9yTm9kZSh4LCB5LCAxMCk7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gcmVzLm5vZGU7XHJcbiAgICAgICAgICAgIHZhciBzdGFydDtcclxuICAgICAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICAgICAgdmFyIGVuZFBvcyA9IHJlcy5lbmRQb3MgfHwgJ2xlZnQnO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRQb3M7XHJcbiAgICAgICAgICAgIHZhciBjYW5Db25uZWN0ID0gZmFsc2U7ICAgICAgIC8v5Lik5Liq6IqC54K55piv5ZCm5Y+v5Lul6L+e57q/55qE5qCH6K+GXHJcbiAgICAgICAgICAgIC8v5Yig6Zmk5Li05pe257q/XHJcbiAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIucmVtb3ZlVGVtcENvbm5lY3Rvcih0aGF0Ll96cik7XHJcbiAgICAgICAgICAgIGlmICh0aGF0LnNlbGVjdENvbm5Ob2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyh0aGF0LnNlbGVjdENvbm5Ob2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXROb2RlICYmIEJwbW4uaXNTbG90RXZlbnQodGhhdC5zZWxlY3RDb25uTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDlvZPliY3oioLngrnmmK/ovrnnlYzoioLngrnlj6/ov57nur9cclxuICAgICAgICAgICAgICAgICAgICBjYW5Db25uZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXROb2RlICYmIHRhcmdldE5vZGUucGFyZW50ICYmIEJwbW4uaXNTdWJQcm9jZXNzKHRhcmdldE5vZGUucGFyZW50KSAmJiB0YXJnZXROb2RlLnBhcmVudC5pZCA9PT0gdGhhdC5zZWxlY3RDb25uTm9kZS5wYXJlbnQuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDotbflp4voioLngrnpg73lnKjlkIzkuIDkuKrlrZDoioLngrnlhoXliJnlj6/ku6Xov57nur9cclxuICAgICAgICAgICAgICAgICAgICBjYW5Db25uZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXROb2RlICYmICF0YXJnZXROb2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbkNvbm5lY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUgJiYgdGFyZ2V0Tm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3ModGFyZ2V0Tm9kZS5wYXJlbnQpICYmIEJwbW4uaXNTbG90RXZlbnQodGFyZ2V0Tm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDnm67moIfoioLngrnmmK/ovrnnlYzoioLngrnlj6/ov57nur9cclxuICAgICAgICAgICAgICAgICAgICBjYW5Db25uZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLzIu5aaC5p6c5om+5Yiw55uu5qCH57uT54K5IOWImeeUu+e6v1xyXG4gICAgICAgICAgICBpZiAoY2FuQ29ubmVjdCAmJiAodGhhdC5zZWxlY3RDb25uTm9kZS5pZCAhPT0gdGFyZ2V0Tm9kZS5pZCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb25uZWN0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lVHlwZTogbGluZVR5cGVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZmluYWxPcHQgPSB1dGlsLm1lcmdlT3B0KGNvbm5lY3RPcHRpb25zLCB0aGF0LmxpbmVPcHQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGF0LnJldmVyc2VDb25uZWN0ID8gdGFyZ2V0Tm9kZSA6IHRoYXQuc2VsZWN0Q29ubk5vZGU7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGF0LnJldmVyc2VDb25uZWN0ID8gdGhhdC5zZWxlY3RDb25uTm9kZSA6IHRhcmdldE5vZGU7XHJcbiAgICAgICAgICAgICAgICBzdGFydFBvcyA9IHRoYXQucmV2ZXJzZUNvbm5lY3QgPyBlbmRQb3MgOiB0aGF0LnN0YXJ0UG9zO1xyXG4gICAgICAgICAgICAgICAgZW5kUG9zID0gdGhhdC5yZXZlcnNlQ29ubmVjdCA/IHRoYXQuZW5kUG9zIDogZW5kUG9zO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fY3JlYXRlQ29ubmVjdG9yQnlOb2RlcyhzdGFydCwgZW5kLCBmaW5hbE9wdCwgc3RhcnRQb3MsIGVuZFBvcyk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmhpZGVDb25uZWN0b3JQb2ludCgpOyAgICAgIC8v6ZqQ6JeP5omA5pyJ6IqC54K55LiK55qE6L+e5o6l54K5XHJcbiAgICAgICAgICAgICAgICB0aGF0LmhpZGVDb25uZWN0b3JDb250cm9sKCk7ICAgICAgLy/pmpDol4/miYDmnInoioLngrnkuIrnmoTmjqfliLbngrlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9yaWdpbk5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL+WmguaenOi/nue6v+Wksei0pe+8jOS4lOWOn+Wni+e6v+auteWtmOWcqO+8jOWImei/mOWOn+WOn+Wni+e6v+autVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhhdC5yZXZlcnNlQ29ubmVjdCA/IHRoYXQub3JpZ2luTm9kZSA6IHRoYXQuc2VsZWN0Q29ubk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gdGhhdC5yZXZlcnNlQ29ubmVjdCA/IHRoYXQuc2VsZWN0Q29ubk5vZGUgOiB0aGF0Lm9yaWdpbk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3MgPSB0aGF0LnJldmVyc2VDb25uZWN0ID8gdGhhdC5vcmlnaW5Qb3MgOiB0aGF0LnN0YXJ0UG9zO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IHRoYXQucmV2ZXJzZUNvbm5lY3QgPyB0aGF0LmVuZFBvcyA6IHRoYXQub3JpZ2luUG9zO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX2NyZWF0ZUNvbm5lY3RvckJ5Tm9kZXMoc3RhcnQsIGVuZCwgeyBzdHlsZTogdGhhdC5saW5lT3B0IH0sIHN0YXJ0UG9zLCBlbmRQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuaGlkZUNvbm5lY3RvclBvaW50KCk7ICAgICAgLy/pmpDol4/miYDmnInoioLngrnkuIrnmoTov57mjqXngrlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/ov5jljp/miYDmnInov57mjqXngrnnmoTpopzoibJcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmNvblBvaW50c0dyb3VwLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2LmF0dHIoe3N0eWxlOntmaWxsOiBcIiNGRkZGMzNcIn0sc2NhbGU6WzEsMV0sb3JpZ2luOlt2LnNoYXBlLmN4LHYuc2hhcGUuY3ldLGN1cnNvcjonY3Jvc3NoYWlyJ30pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZpc2hUb3BvUHJvdG8uc2hvd0Nvbm5lY3RvckNvbnRyb2wgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JDb250cm9sKCk7XHJcbiAgICAgICAgICAgIC8vIOiuqeW9k+WJjeiKgueCueaYvuekuuaOp+WItueCuVxyXG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlUmVjdCA9IHRoaXMuY2FsY3VsYXRlUmVjdCh0aGlzLnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0ge1xyXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuc2VsZWN0ZWROb2RlLmlkLFxyXG4gICAgICAgICAgICAgICAgcm90YXRpb246IGNhbGN1bGF0ZVJlY3Qucm90YXRpb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29ubmVjdG9yUG9pbnQgPSB1dGlsLmdldENvbm5lY3RvckNvbnRyb2xzKGNhbGN1bGF0ZVJlY3QsIG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5yZXR1cm5Db25uZWN0b3JDb250cm9sUGFyYW0odGhpcy5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICBpZiAocGFyYW1zLnNjYWxlYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JDb250cm9sKGNvbm5lY3RvclBvaW50LnRsLCBcInRsXCIsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JDb250cm9sKGNvbm5lY3RvclBvaW50LnRyLCBcInRyXCIsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JDb250cm9sKGNvbm5lY3RvclBvaW50LmJsLCBcImJsXCIsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVDb25uZWN0b3JDb250cm9sKGNvbm5lY3RvclBvaW50LmJyLCBcImJyXCIsIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMucm90YXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmNyZWF0ZUNvbm5lY3RvckNvbnRyb2woY29ubmVjdG9yUG9pbnQubXRyLCBcIm10clwiLCBub2RlKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuY3JlYXRlQ29ubmVjdG9yQ29udHJvbCh7IHRvcDogY29ubmVjdG9yUG9pbnQubXRyLCBib3R0b206IGNvbm5lY3RvclBvaW50LnRjIH0sIFwibXRyLHRjXCIsIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kQ29udHJvbE5vZGUgKGlkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmFsbE5vZGVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmlkID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5jb25Db250cm9sc0dyb3VwLm9uKFwiQ29ubmVjdENvbnRyb2w6ZHJhZ3N0YXJ0XCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIOmmluWFiOa4hemZpOWFtuS7luaJgOacieiKgueCueeahOaOp+WItueCueWSjOi/nuaOpeeCuVxyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IGUuZXZlbnQudGFyZ2V0LmN1cnNvcjtcclxuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBlLmV2ZW50LnRhcmdldC5wb3M7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zTWFwID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICd0bCc6ICdicicsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3RyJzogJ2JsJyxcclxuICAgICAgICAgICAgICAgICAgICAnYmwnOiAndHInLFxyXG4gICAgICAgICAgICAgICAgICAgICdicic6ICd0bCdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdENvbm5Ob2RlID0gZmluZENvbnRyb2xOb2RlKGUubm9kZUlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IgJiYgcG9zICE9PSAnbXRyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5Ob2RlID0gdGhhdC5jb25Db250cm9sc0dyb3VwLmNoaWxkcmVuKCkuZmluZChmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3MgPT09IHBvc01hcFtwb3NdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoYXQuY29uQ29udHJvbHNHcm91cC5jaGlsZHJlbigpLmZpbmQoZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zID09PSBwb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoYXQuc2VsZWN0Q29ubk5vZGUuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5vcHBvc2l0ZVNoYXBlID0genJVdGlsLmNsb25lKG9yaWdpbk5vZGUuc2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY3VycmVudFNoYXBlID0genJVdGlsLmNsb25lKGN1cnJlbnROb2RlLnNoYXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHpyVXRpbC5jbG9uZSh0aGF0LmNhbGN1bGF0ZVJlY3QodGhhdC5zZWxlY3RDb25uTm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWFnb25hbCA9IE1hdGguc3FydChNYXRoLnBvdyhyZWN0LndpZHRoLCAyKSArIE1hdGgucG93KHJlY3QuaGVpZ2h0LCAyKSk7Ly8g5a+56KeS57q/6ZW/5bqmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5kaWFnb25hbCA9IGRpYWdvbmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQub3JpZ2luUmVjdCA9IHpyVXRpbC5jbG9uZShyZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmlmUG9pbnRDZW50ZXIgPSBib3VuZGluZ1JlY3QueCA8IC0xOyAvLyDliKTmlq3kuK3lv4PngrnmmK/lkKblnKjoioLngrnkuK3lv4Mo5Y6f5b2i5Zyo5Lit5b+D77yM55+p5b2i5Zyo5bem5LiK6KeSKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIOenu+mZpG5vZGXpq5jkuq5cclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdENvbm5Ob2RlLnNlbGVjdFN0eWxlICYmIHRoYXQuX2FwaS5nZXRacigpLnJlbW92ZUhvdmVyKHRoYXQuc2VsZWN0Q29ubk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgR3VpZGVsaW5lcy5jcmVhdGVHdWlkZWxpbmVzKHRoYXQuX3pyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29uQ29udHJvbHNHcm91cC5vbihcIkNvbm5lY3RDb250cm9sOmRyYWdcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gdGhhdC5vcHRzLnNob3dHcmlkTGluZSA/IHRoYXQub3B0cy5ncmlkTGluZVNwYWNpbmcgOiAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IGUuZXZlbnQudGFyZ2V0LmN1cnNvcjtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRQb3MgPSBlLmV2ZW50LnRhcmdldC5wb3M7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSB0aGF0LnNlbGVjdENvbm5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSAoZS5ldmVudC5vZmZzZXRYIC0gdGhhdC5ncm91cC5wb3NpdGlvblswXSkgLyB0aGF0Lm5vd1pvb207XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IChlLmV2ZW50Lm9mZnNldFkgLSB0aGF0Lmdyb3VwLnBvc2l0aW9uWzFdKSAvIHRoYXQubm93Wm9vbTtcclxuICAgICAgICAgICAgICAgIHZhciByZWN0T3JpZ2luID0gdXRpbC5nZXRSZWN0KGN1cnJlbnROb2RlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRQb3MgPT09ICdtdHInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2VzcyhjdXJyZW50Tm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggLT0gQnBtblV0aWwucGFyZW50WChjdXJyZW50Tm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5IC09IEJwbW5VdGlsLnBhcmVudFkoY3VycmVudE5vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5peL6L2sXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBwYXJzZUludCgoKHggLWN1cnJlbnROb2RlLnBvc2l0aW9uWzBdKSAvIHBpeGVsKSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gcGFyc2VJbnQoKCh5IC1jdXJyZW50Tm9kZS5wb3NpdGlvblsxXSkgLyBwaXhlbCksIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcl94ID0gcGl4ZWwgKiBtO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByX3kgPSBwaXhlbCAqIG47XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHJlY3RPcmlnaW4ueCAtIGN1cnJlbnROb2RlLnBvc2l0aW9uWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiByZWN0T3JpZ2luLnkgLSBjdXJyZW50Tm9kZS5wb3NpdGlvblsxXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSBNYXRoLmF0YW4yKHJfeSwgcl94KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdGVkTm9kZS5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yaWdpbic6IFtvcmlnaW5zLngsIG9yaWdpbnMueV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdyb3RhdGlvbic6IC1yb3RhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWxjdWxhdGVSZWN0ID0gdGhhdC5jYWxjdWxhdGVSZWN0KHRoYXQuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9yUG9pbnQgPSB1dGlsLmdldENvbm5lY3RvclBvaW50cyhjYWxjdWxhdGVSZWN0LCB7IHJvdGF0aW9uOiBjYWxjdWxhdGVSZWN0LnJvdGF0aW9uIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sUG9pbnQgPSB1dGlsLmdldENvbm5lY3RvckNvbnRyb2xzKGNhbGN1bGF0ZVJlY3QsIHsgcm90YXRpb246IGNhbGN1bGF0ZVJlY3Qucm90YXRpb24gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6IqC54K56L+e57q/54K577yM5o6n5Yi254K55L2N572u5pu05pawXHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25Qb2ludHNHcm91cC5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IGl0ZW0ucG9zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnQ29ubmVjdFBvaW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRTaGFwZSh7IGN4OiBjb25uZWN0b3JQb2ludFtwb3NdLngsIGN5OiBjb25uZWN0b3JQb2ludFtwb3NdLnkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbkNvbnRyb2xzR3JvdXAuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBpdGVtLnBvcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ0Nvbm5lY3RDb250cm9sJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gJ210cicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHIoJ3Bvc2l0aW9uJywgWzAsIDBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHIoJ3JvdGF0aW9uJywgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNldFNoYXBlKHsgeDogY29udHJvbFBvaW50W3Bvc10ueCAtIDQsIHk6IGNvbnRyb2xQb2ludFtwb3NdLnkgLSA0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3JpZ2luJzogW2l0ZW0uc2hhcGUueCArIDQsIGl0ZW0uc2hhcGUueSArIDRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyb3RhdGlvbic6IC1yb3RhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSAnQ29ubmVjdENvbnRyb2xMaW5lJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRTaGFwZSh7IHgxOiBjb250cm9sUG9pbnQubXRyLngsIHgyOiBjb250cm9sUG9pbnQudGMueCwgeTE6IGNvbnRyb2xQb2ludC5tdHIueSwgeTI6IGNvbnRyb2xQb2ludC50Yy55IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOe8qeaUvijnvKnmlL7ngrnpnIDopoHnu5PlkIjml4vovazop5LluqborqHnrpcpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclBvaW50ID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoMCwgaGVpZ2h0MCwgZGlmZmVyZW5jZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yc1kgPSBbJ24tcmVzaXplJywgJ3MtcmVzaXplJ107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uT3JnID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAndGwnOiAnYnInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAndHInOiAnYmwnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmwnOiAndHInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnInOiAndGwnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVOb2RlcyA9IHRoYXQuY29uQ29udHJvbHNHcm91cC5jaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSAnQ29ubmVjdENvbnRyb2wnICYmIG5vZGUucG9zICE9PSAnbXRyJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q29udHJvbE5vZGUgPSBzY2FsZU5vZGVzLmZpbmQoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3MgPT09IHRhcmdldFBvcztcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPD0gOCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gODtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPD0gOCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gODtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3JzWS5pbmNsdWRlcyhjdXJzb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOiOt+WPlnnovbTmr5TkvovljbPlj69cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0WSA9IGN1cnJlbnRDb250cm9sTm9kZS5zaGFwZS55ICsgNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZmVyZW5jZSA9IE1hdGguYWJzKHkgLSB0aGF0Lm9wcG9zaXRlU2hhcGUueSAtIDQpIC0gTWF0aC5hYnMoc3RhcnRZIC0gdGhhdC5vcHBvc2l0ZVNoYXBlLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZmVyZW5jZSkgJSBwaXhlbCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZmVyZW5jZSA9IE1hdGgucm91bmQoZGlmZmVyZW5jZSAvIHBpeGVsKSAqIHBpeGVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdGlvID0gKE1hdGguYWJzKHN0YXJ0WSAtIHRoYXQub3Bwb3NpdGVTaGFwZS55KSArIGRpZmZlcmVuY2UpIC8gTWF0aC5hYnMoc3RhcnRZIC0gdGhhdC5vcHBvc2l0ZVNoYXBlLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOiOt+WPlnjovbTmr5TkvovljbPlj69cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IGN1cnJlbnRDb250cm9sTm9kZS5zaGFwZS54ICsgNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZmVyZW5jZSA9IE1hdGguYWJzKHggLSB0aGF0Lm9wcG9zaXRlU2hhcGUueCAtIDQpIC0gTWF0aC5hYnMoc3RhcnRYIC0gdGhhdC5vcHBvc2l0ZVNoYXBlLngpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlmZmVyZW5jZSkgJSBwaXhlbCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZmVyZW5jZSA9IE1hdGgucm91bmQoZGlmZmVyZW5jZSAvIHBpeGVsKSAqIHBpeGVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdGlvID0gKE1hdGguYWJzKHN0YXJ0WCAtIHRoYXQub3Bwb3NpdGVTaGFwZS54KSArIGRpZmZlcmVuY2UpIC8gTWF0aC5hYnMoc3RhcnRYIC0gdGhhdC5vcHBvc2l0ZVNoYXBlLngpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIS9eWzAtOV0rLj9bMC05XSovLnRlc3QocmF0aW8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdGlvID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUudXBkYXRlU2hhcGUocmF0aW8pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdFNjYWxlID0gdXRpbC5nZXRSZWN0KGN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBjZW50ZXJQb2ludCA9IHRoYXQuaWZQb2ludENlbnRlciA/IHsgeDogdGhhdC5vcmlnaW5SZWN0LngsIHk6IHRoYXQub3JpZ2luUmVjdC55IH0gOiB7IHg6IHRoYXQub3JpZ2luUmVjdC5ib3VuZGluZ1JlY3QueCwgeTogdGhhdC5vcmlnaW5SZWN0LmJvdW5kaW5nUmVjdC55IH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpYWdvbmFsTmV3ID0gTWF0aC5zcXJ0KE1hdGgucG93KHJlY3RTY2FsZS53aWR0aCwgMikgKyBNYXRoLnBvdyhyZWN0U2NhbGUuaGVpZ2h0LCAyKSk7Ly8g5a+56KeS57q/6ZW/5bqmXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjdXJzb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5LiKLOW3puS4ilxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduLXJlc2l6ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ253LXJlc2l6ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDAgPSAodGhhdC5vcHBvc2l0ZVNoYXBlLnggKyA0IC0gY2VudGVyUG9pbnQueCkgKiBkaWFnb25hbE5ldyAvIHRoYXQuZGlhZ29uYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQwID0gKHRoYXQub3Bwb3NpdGVTaGFwZS55ICsgNCAtIGNlbnRlclBvaW50LnkpICogZGlhZ29uYWxOZXcgLyB0aGF0LmRpYWdvbmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyLnB1c2godGhhdC5vcHBvc2l0ZVNoYXBlLnggLSB3aWR0aDAgKyA0LCB0aGF0Lm9wcG9zaXRlU2hhcGUueSAtIGhlaWdodDAgKyA0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlj7Ms5Y+z5LiKXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2UtcmVzaXplJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmUtcmVzaXplJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoMCA9IChjZW50ZXJQb2ludC54IC0gdGhhdC5vcHBvc2l0ZVNoYXBlLnggLSA0KSAqIGRpYWdvbmFsTmV3IC8gdGhhdC5kaWFnb25hbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDAgPSAodGhhdC5vcHBvc2l0ZVNoYXBlLnkgKyA0IC0gY2VudGVyUG9pbnQueSkgKiBkaWFnb25hbE5ldyAvIHRoYXQuZGlhZ29uYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXIucHVzaCh0aGF0Lm9wcG9zaXRlU2hhcGUueCArIHdpZHRoMCArIDQsIHRoYXQub3Bwb3NpdGVTaGFwZS55IC0gaGVpZ2h0MCArIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOS4i++8jOWPs+S4i1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzLXJlc2l6ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlLXJlc2l6ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDAgPSAoY2VudGVyUG9pbnQueCAtIHRoYXQub3Bwb3NpdGVTaGFwZS54IC0gNCkgKiBkaWFnb25hbE5ldyAvIHRoYXQuZGlhZ29uYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQwID0gKGNlbnRlclBvaW50LnkgLSB0aGF0Lm9wcG9zaXRlU2hhcGUueSAtIDQpICogZGlhZ29uYWxOZXcgLyB0aGF0LmRpYWdvbmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyLnB1c2godGhhdC5vcHBvc2l0ZVNoYXBlLnggKyB3aWR0aDAgKyA0LCB0aGF0Lm9wcG9zaXRlU2hhcGUueSArIGhlaWdodDAgKyA0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlt6Ys5bem5LiLXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ctcmVzaXplJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3ctcmVzaXplJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoMCA9ICh0aGF0Lm9wcG9zaXRlU2hhcGUueCArIDQgLSBjZW50ZXJQb2ludC54KSAqIGRpYWdvbmFsTmV3IC8gdGhhdC5kaWFnb25hbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDAgPSAoY2VudGVyUG9pbnQueSAtIHRoYXQub3Bwb3NpdGVTaGFwZS55IC0gNCkgKiBkaWFnb25hbE5ldyAvIHRoYXQuZGlhZ29uYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXIucHVzaCh0aGF0Lm9wcG9zaXRlU2hhcGUueCAtIHdpZHRoMCArIDQsIHRoYXQub3Bwb3NpdGVTaGFwZS55ICsgaGVpZ2h0MCArIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3MoY3VycmVudE5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50UmVjdCA9IHRoYXQuY2FsY3VsYXRlUmVjdChjdXJyZW50Tm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSB1dGlsLmNhbGN1bGF0ZVBvaW50cyhjZW50ZXIsIHBhcmVudFJlY3QsIC1wYXJlbnRSZWN0LnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyID0gW25ld1Bvc2l0aW9uWzBdIC0gcGFyZW50UmVjdC5ib3VuZGluZ1JlY3QueCwgbmV3UG9zaXRpb25bMV0gLSBwYXJlbnRSZWN0LmJvdW5kaW5nUmVjdC55XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5TY2FsZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogcmVjdFNjYWxlLnggLSBjZW50ZXJbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHJlY3RTY2FsZS55IC0gY2VudGVyWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9zaXRpb24nOiBjZW50ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmlnaW4nOiBbb3JpZ2luU2NhbGUueCwgb3JpZ2luU2NhbGUueV1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5q2k5pe26IqC54K55YyF5Zu055uS6ZyA6KaB6YeN5paw6K6h566XXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3ROb3cgPSB0aGF0LmNhbGN1bGF0ZVJlY3QoY3VycmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3JQb2ludFNjYWxlID0gdXRpbC5nZXRDb25uZWN0b3JQb2ludHMocmVjdE5vdywgeyByb3RhdGlvbjogcmVjdE5vdy5yb3RhdGlvbiB9KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbFBvaW50U2NhbGUgPSB1dGlsLmdldENvbm5lY3RvckNvbnRyb2xzKHJlY3ROb3csIHsgcm90YXRpb246IHJlY3ROb3cucm90YXRpb24gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25Db250cm9sc0dyb3VwLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBpdGVtLnBvcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gdGFyZ2V0UG9zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHIoJ3Bvc2l0aW9uJywgWzAsIDBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnQ29ubmVjdENvbnRyb2wnICYmIHBvcyAhPT0gcG9zaXRpb25PcmdbdGFyZ2V0UG9zXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRTaGFwZSh7IHg6IGNvbnRyb2xQb2ludFNjYWxlW3Bvc10ueCAtIDQsIHk6IGNvbnRyb2xQb2ludFNjYWxlW3Bvc10ueSAtIDQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHIoJ29yaWdpbicsIFtjb250cm9sUG9pbnRTY2FsZVtwb3NdLngsIGNvbnRyb2xQb2ludFNjYWxlW3Bvc10ueV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gJ0Nvbm5lY3RDb250cm9sTGluZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0U2hhcGUoeyB4MTogY29udHJvbFBvaW50U2NhbGUubXRyLngsIHgyOiBjb250cm9sUG9pbnRTY2FsZS50Yy54LCB5MTogY29udHJvbFBvaW50U2NhbGUubXRyLnksIHkyOiBjb250cm9sUG9pbnRTY2FsZS50Yy55IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY29uUG9pbnRzR3JvdXAuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IGl0ZW0ucG9zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnQ29ubmVjdFBvaW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRTaGFwZSh7IGN4OiBjb25uZWN0b3JQb2ludFNjYWxlW3Bvc10ueCwgY3k6IGNvbm5lY3RvclBvaW50U2NhbGVbcG9zXS55IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFJlY3QgPSB0aGF0LmNhbGN1bGF0ZVJlY3QodGhhdC5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5vcGVyYXRpb25Ob2RlLnJlZnJlc2hQb3N0aW9uKHRoYXQuc2VsZWN0ZWROb2RlLCBjdXJyZW50UmVjdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RlZE5vZGUuc2xvdEV2ZW50ICYmIHRoYXQuc2VsZWN0ZWROb2RlLnNsb3RFdmVudC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5pu05paw5LqL5Lu26IqC54K5XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51cGRhdGVTbG90RXZlbnQodGhhdC5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gMS41IOWIt+aWsOi/nue6v1xyXG4gICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZSh0aGF0LnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAvLyAxLjYg5Yi35paw5a+56b2Q57q/XHJcbiAgICAgICAgICAgICAgICBHdWlkZWxpbmVzLmp1ZGdlQWxpZ25tZW50KHRoYXQuc2VsZWN0ZWROb2RlLCBbY3VycmVudFJlY3QueCwgY3VycmVudFJlY3QueV0sIHRoYXQuZG9tQXJyYXksIHRoYXQuZ2V0V2lkdGgoKSwgdGhhdC5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmNvbkNvbnRyb2xzR3JvdXAub24oXCJDb25uZWN0Q29udHJvbDpkcmFnZW5kXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIOabtOaWsOiKgueCuXBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0UG9zID0gZS5ldmVudC50YXJnZXQucG9zO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGF0LnNlbGVjdENvbm5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gdGhhdC5vcHRzLnNob3dHcmlkTGluZSA/IHRoYXQub3B0cy5ncmlkTGluZVNwYWNpbmcgOiAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gbm9kZS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBub2RlLm9yaWdpbjtcclxuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uIG9yaWdpbuWPluaVtFxyXG4gICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RDb25uTm9kZS5hdHRyKCdwb3NpdGlvbicsIFtNYXRoLnJvdW5kKHBvc2l0aW9uWzBdIC8gcGl4ZWwpICogcGl4ZWwsIE1hdGgucm91bmQocG9zaXRpb25bMV0gLyBwaXhlbCkgKiBwaXhlbF0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0Q29ubk5vZGUuYXR0cignb3JpZ2luJywgW01hdGgucm91bmQob3JpZ2luWzBdIC8gcGl4ZWwpICogcGl4ZWwsIE1hdGgucm91bmQob3JpZ2luWzFdIC8gcGl4ZWwpICogcGl4ZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIOWuvemrmOWPluaVtFxyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFBvcyAhPT0gJ210cicpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZVNoYXBlKDEsIHRydWUsIHBpeGVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIOabtOaWsOS6i+S7tuiKgueCuVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc2xvdEV2ZW50ICYmIG5vZGUuc2xvdEV2ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVNsb3RFdmVudChub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIOabtOaWsGRvbUFycmF5XHJcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaCh0aGF0LmRvbUFycmF5LCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmlkID09PSBub2RlLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gdXRpbC5nZXRSZWN0KG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnJvdGF0aW9uID0gbm9kZS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5wb3NpdGlvbiA9IFtyZWN0LngsIHJlY3QueV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ud2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnBvaW50cyA9IHRoYXQuX2dldENvbnRyb2xzT2ZOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmRvbUFycmF5W2luZGV4XSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLm1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5pu05pawbW9kZWzvvIzmlK/mjIHluo/liJfljJYv5Y+N5bqP5YiX5YyWXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tb2RlbC5zZXQoXCJvcHRpb25zLnJvdGF0aW9uXCIsIG5vZGUucm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUubW9kZWwuc2V0KFwib3B0aW9ucy5vcmlnaW5cIiwgbm9kZS5vcmlnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IG5vZGUubW9kZWwub3B0aW9uLmVsZW1lbnRUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gJ0ltYWdlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1vZGVsLnNldChcIm9wdGlvbnMuc3R5bGVcIiwgbm9kZS5zdHlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tb2RlbC5zZXQoXCJvcHRpb25zLnNoYXBlXCIsIG5vZGUuc2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEd1aWRlbGluZXMucmVzZXRMaW5lcygpO1xyXG4gICAgICAgICAgICAgICAgLy8gMS40IOinpuWPkeeCueWHu1xyXG4gICAgICAgICAgICAgICAgdGhhdC5ub2RlQ2xpY2tIYW5kbGVyKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5vcHBvc2l0ZVNoYXBlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoYXQuY3VycmVudFNoYXBlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoYXQuZGlhZ29uYWwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5vcmlnaW5SZWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoYXQuaWZQb2ludENlbnRlciA9IG51bGw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5jb25Db250cm9sc0dyb3VwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5nZXRSb3RhdGVkQ29ybmVyQ3Vyc29yID0gZnVuY3Rpb24obm9kZSwgcG9zKSB7XHJcbiAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgIHZhciByb3RhdGlvbiA9IG5vZGUucm90YXRpb247XHJcbiAgICAgICAgICAgaWYgKHBvcyA9PT0gJ210cicpIHtcclxuICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuY3Vyc29yTWFwW3Bvc107XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGlmIChNYXRoLmFicyhyb3RhdGlvbikgPiAwKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IC1yb3RhdGlvbiAvIChNYXRoLlBJLzE4MCk7XHJcbiAgICAgICAgICAgICAgIHZhciBuID0gTWF0aC5yb3VuZCgoYW5nbGUgJSAzNjApIC8gNDUpO1xyXG4gICAgICAgICAgICAgICBpZiAobiA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgIG4gKz0gODsgLy8gZnVsbCBjaXJjbGUgYWhlYWRcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBuICs9IHRoYXQuY3Vyc29yT2Zmc2V0W3Bvc107XHJcbiAgICAgICAgICAgICAgIG4gJT0gODtcclxuICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuY3Vyc29yTWFwc1tuXTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgcmV0dXJuIHRoYXQuY3Vyc29yTWFwW3Bvc107XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5jcmVhdGVDb25uZWN0b3JDb250cm9sID0gZnVuY3Rpb24ocG9pbnQsIHBvcywgbm9kZSkge1xyXG4gICAgICAgICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICAgICAgICAgdmFyIHBvc0FyciA9IHBvcy5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgIGlmIChwb3NBcnIubGVuZ3RoIDwgMikge1xyXG4gICAgICAgICAgICAgICB2YXIgY29udHJvbEN1cnNvciA9IG1lLmdldFJvdGF0ZWRDb3JuZXJDdXJzb3Iobm9kZSwgcG9zKTtcclxuICAgICAgICAgICAgICAgdmFyIHBvaW50SW5zdGFuY2UgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgICAgICAgIHNoYXBlOntcclxuICAgICAgICAgICAgICAgICAgICAgICB4OiBwb2ludC54IC0gNCxcclxuICAgICAgICAgICAgICAgICAgICAgICB5OiBwb2ludC55IC0gNCxcclxuICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogOCxcclxuICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDhcclxuICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcclxuICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6JyMwMDAwMDAnXHJcbiAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgejogMixcclxuICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBub2RlLnJvdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgb3JpZ2luOiBbcG9pbnQueCwgcG9pbnQueV0sXHJcbiAgICAgICAgICAgICAgICAgICBjdXJzb3I6IGNvbnRyb2xDdXJzb3IsXHJcbiAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIHBvaW50SW5zdGFuY2UudHlwZSA9ICdDb25uZWN0Q29udHJvbCc7XHJcbiAgICAgICAgICAgICAgIHBvaW50SW5zdGFuY2UucG9zID0gcG9zOy8vIOiusOW9leaYr+iKgueCueS4iuWTquS4quS9jee9rueahOi/nuaOpeeCuVxyXG4gICAgICAgICAgICAgICB2YXIgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2RyYWdzdGFydCcsICdkcmFnJywgJ2RyYWdlbmQnXTtcclxuICAgICAgICAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgIHBvaW50SW5zdGFuY2Uub24oZXZlTmFtZSwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJDb25uZWN0Q29udHJvbDpcIiArIGV2ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLm5vZGVJZCA9IG5vZGUuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmN1cnNvciA9IGNvbnRyb2xDdXJzb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgbWUuY29uQ29udHJvbHNHcm91cC50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICB0aGlzLmNvbkNvbnRyb2xzR3JvdXAuYWRkKHBvaW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIC8vIOaXi+i9rOeCueS4juiKgueCueS5i+mXtOmcgOimgei/nue6v1xyXG4gICAgICAgICAgICAgICB2YXIgbGluZSA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICB4MTogcG9pbnQudG9wLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgeTE6IHBvaW50LnRvcC55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHgyOiBwb2ludC5ib3R0b20ueCxcclxuICAgICAgICAgICAgICAgICAgICAgICB5MjogcG9pbnQuYm90dG9tLnlcclxuICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMVxyXG4gICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgIHo6IDEsXHJcbiAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIGxpbmUudHlwZSA9ICdDb25uZWN0Q29udHJvbExpbmUnO1xyXG4gICAgICAgICAgICAgICBsaW5lLm5vZGVJZCA9IG5vZGUuaWQ7XHJcbiAgICAgICAgICAgICAgIHRoaXMuY29uQ29udHJvbHNHcm91cC5hZGQobGluZSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfVxyXG5cclxuICAgICAgIC8qKlxyXG5cdCAgICAgKiDojrflj5boioLngrnnmoTlm5vop5LlnZDmoIdcclxuXHQgICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlIFtkZXNjcmlwdGlvbl1cclxuXHQgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLl9nZXRDb250cm9sc09mTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgdmFyIGNhbGN1bGF0ZVJlY3QgPSB0aGlzLmNhbGN1bGF0ZVJlY3Qobm9kZSk7XHJcbiAgICAgICAgICAgdmFyIGNvbnRyb2xzID0gdXRpbC5nZXRDb25uZWN0b3JDb250cm9scyhjYWxjdWxhdGVSZWN0LCB7IHJvdGF0aW9uOiBjYWxjdWxhdGVSZWN0LnJvdGF0aW9uIH0pO1xyXG4gICAgICAgICAgIHBvaW50cyA9IFtjb250cm9scy50bCwgY29udHJvbHMudHIsIGNvbnRyb2xzLmJsLCBjb250cm9scy5icl07XHJcbiAgICAgICAgICAgcmV0dXJuIHBvaW50c1xyXG4gICAgICAgfVxyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8ucmV0dXJuQ29ubmVjdG9yQ29udHJvbFBhcmFtID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgIHZhciBzY2FsZUZsYWcgPSBmYWxzZTtcclxuICAgICAgICAgICB2YXIgcm90YXRlRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgIGlmICh0aGlzLm9wdHMuc2NhbGVhYmxlKSB7XHJcbiAgICAgICAgICAgICAgIHNjYWxlRmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGlmIChub2RlLm1vZGVsLmdldChcInByb3BlcnRpZXMuc2NhbGVhYmxlXCIpKSB7XHJcbiAgICAgICAgICAgICAgIHNjYWxlRmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgc2NhbGVGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGlmIChub2RlLnNjYWxlYWJsZSkge1xyXG4gICAgICAgICAgICAgICBzY2FsZUZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgIH0gZWxzZSBpZiAoIW5vZGUuc2NhbGVhYmxlICYmICFub2RlLm1vZGVsLmdldChcInByb3BlcnRpZXMuc2NhbGVhYmxlXCIpKSB7XHJcbiAgICAgICAgICAgICAgIHNjYWxlRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgaWYgKHRoaXMub3B0cy5yb3RhdGFibGUpIHtcclxuICAgICAgICAgICAgICAgcm90YXRlRmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGlmIChub2RlLm1vZGVsLmdldChcInByb3BlcnRpZXMucm90YXRhYmxlXCIpKSB7XHJcbiAgICAgICAgICAgICAgIHJvdGF0ZUZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIHJvdGF0ZUZsYWcgPSBmYWxzZTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgaWYgKG5vZGUucm90YXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgIHJvdGF0ZUZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgIH0gZWxzZSBpZiAoIW5vZGUucm90YXRhYmxlICYmICFub2RlLm1vZGVsLmdldChcInByb3BlcnRpZXMucm90YXRhYmxlXCIpKSB7XHJcbiAgICAgICAgICAgICAgIHJvdGF0ZUZsYWcgPSBmYWxzZTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgc2NhbGVhYmxlOiBzY2FsZUZsYWcsXHJcbiAgICAgICAgICAgICAgIHJvdGF0YWJsZTogcm90YXRlRmxhZ1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH1cclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmlmU2hvd0Nvbm5lY3RvclBvaW50ID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgIHZhciBjb25uZWN0YWJsZSA9IG5vZGUgJiYgdHlwZW9mIG5vZGUuY29ubmVjdGFibGUgPT09ICdib29sZWFuJyA/IG5vZGUuY29ubmVjdGFibGUgOiB0aGlzLm9wdHMuY29ubmVjdGFibGU7XHJcbiAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RhYmxlO1xyXG4gICAgICAgfVxyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uaGlkZUNvbm5lY3RvckNvbnRyb2wgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICB0aGlzLmNvbkNvbnRyb2xzR3JvdXAucmVtb3ZlQWxsKCk7ICAvL+makOiXj+aJgOacieiKgueCueS4iueahOi/nuaOpeeCuVxyXG4gICAgICAgICAgIHRoaXMuY29uQ29udHJvbHNHcm91cC5vZmYoKTsgICAgICAgIC8v5riF56m65omA5pyJ5LqL5Lu2XHJcbiAgICAgICAgICAgdGhpcy5fenIucmVtb3ZlKHRoaXMuY29uQ29udHJvbHNHcm91cCk7XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDngrnlh7vov57nur/mjInpkq7ml7bliJvlu7rpmaTpgInkuK3oioLngrnlpJblhbbkvZnoioLngrnovrnmoYbkuIrnmoTov57mjqXngrlcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5jcmVhdGVMaW5lQ29ubmVjdG9yUG9pbnQgPSBmdW5jdGlvbihwb2ludCwgcG9zLCBsaW5lVHlwZSkge1xyXG4gICAgICAgICAgIHZhciBwb2ludEluc3RhbmNlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgIGN4OiBwb2ludC54LFxyXG4gICAgICAgICAgICAgICAgICAgY3k6IHBvaW50LnksXHJcbiAgICAgICAgICAgICAgICAgICByOiA0XHJcbiAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICBmaWxsOiAnI0ZGRkYzMycsXHJcbiAgICAgICAgICAgICAgICAgICBzdHJva2U6JyMwMDAwMDAnXHJcbiAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgIHogOiA0LFxyXG4gICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgIGxpbmVUeXBlOiBsaW5lVHlwZVxyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIHBvaW50SW5zdGFuY2UudHlwZSA9ICdDb25uZWN0UG9pbnQnO1xyXG4gICAgICAgICAgIHBvaW50SW5zdGFuY2UucG9zID0gcG9zOyAgICAgICAgICAgICAgICAvL+iusOW9leaYr+iKgueCueS4iuWTquS4quS9jee9rueahOi/nuaOpeeCuVxyXG5cclxuICAgICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwLmFkZChwb2ludEluc3RhbmNlKTtcclxuICAgICAgIH1cclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKiDliJ3lp4vljJYg5pON5L2c55qE6Jma57q/5qGGXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uaW5pdE9wZXJhdGlvbk5vZGUgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZSA9IG5ldyBPcGVyYXRpb25Ob2RlKG5vZGUsIHRoaXMuX3pyLCB0aGlzLl9hcGksIHRoaXMuZm9yYmlkRWRpdCk7XHJcbiAgICAgICAgICAgZnVuY3Rpb24gZmluZENvbm5lY3Rvck5vZGUoeCwgeSwgb2Zmc2V0LCBwb3MpIHtcclxuICAgICAgICAgICAgICAgdmFyIG5vZGUsIGVuZFBvcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgIHRoYXQuYWxsTm9kZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgY2FuU2hvd1BvaW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdGhhdC5zZWxlY3RlZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RlZE5vZGUucGFyZW50ICYmIEJwbW4uaXNTdWJQcm9jZXNzKHRoYXQuc2VsZWN0ZWROb2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3MoaXRlbS5wYXJlbnQpICYmIGl0ZW0ucGFyZW50LmlkID09PSB0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQuaWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuU2hvd1BvaW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQnBtbi5pc1Nsb3RFdmVudCh0aGF0LnNlbGVjdGVkTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhblNob3dQb2ludCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpdGVtLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2VzcyhpdGVtLnBhcmVudCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5TaG93UG9pbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2VzcyhpdGVtLnBhcmVudCkgJiYgQnBtbi5pc1Nsb3RFdmVudChpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuU2hvd1BvaW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIGlmIChjYW5TaG93UG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhbE5vZGVDYWwgPSB0aGF0LmNhbGN1bGF0ZVJlY3QoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RvclBvaW50ID0gdXRpbC5nZXRDb25uZWN0b3JQb2ludHMocmVhbE5vZGVDYWwsIHsgcm90YXRpb246IHJlYWxOb2RlQ2FsLnJvdGF0aW9uIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W3Bvc10ueCAtIHgpIDw9IG9mZnNldCAmJiBNYXRoLmFicyhjb25uZWN0b3JQb2ludFtwb3NdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wibGVmdFwiXS54IC0geCkgPD0gb2Zmc2V0ICYmIE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wibGVmdFwiXS55IC0geSkgPD0gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1widG9wXCJdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbXCJ0b3BcIl0ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJ0b3BcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wicmlnaHRcIl0ueCAtIHgpIDw9IG9mZnNldCAmJiBNYXRoLmFicyhjb25uZWN0b3JQb2ludFtcInJpZ2h0XCJdLnkgLSB5KSA8PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGNvbm5lY3RvclBvaW50W1wiYm90dG9tXCJdLnggLSB4KSA8PSBvZmZzZXQgJiYgTWF0aC5hYnMoY29ubmVjdG9yUG9pbnRbXCJib3R0b21cIl0ueSAtIHkpIDw9IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gXCJib3R0b21cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICBlbmRQb3M6IGVuZFBvc1xyXG4gICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICAvLyDkvqblkKwg566t5aS0IOaLluaLveW8gOWni+S6i+S7tlxyXG4gICAgICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZS5vbihPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUdTVEFSVCwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICB0aGF0LmhpZGVDb25uZWN0b3JQb2ludCgpO1xyXG4gICAgICAgICAgICAgICB0aGF0LmZpbHRlckNvbm5lY3RQb2ludCh0aGF0LmFsbE5vZGVzLCBlLmV2ZW50LnRhcmdldC5saW5lVHlwZSk7XHJcbiAgICAgICAgICAgICAgIHRoYXQuX3pyLmFkZCh0aGF0LmNvblBvaW50c0dyb3VwKTtcclxuICAgICAgICAgICAgICAgdmFyIHggPSBlLmV2ZW50Lm9mZnNldFg7XHJcbiAgICAgICAgICAgICAgIHZhciB5ID0gZS5ldmVudC5vZmZzZXRZO1xyXG4gICAgICAgICAgICAgICAvL+aLluaLveW8gOWni+WFiOaKiiDnrq3lpLTlm77moIcg57uZ6ZqQ6JePXHJcbiAgICAgICAgICAgICAgIHZhciBhcnJvdyA9IGUuZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICBpZiAoZS5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0LmxpbmVPcHQgPSBlLmRhdGE7ICAvL+e8k+WtmOe6v+auteeahOmFjee9ruS/oeaBr1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGFycm93LmhpZGUoKTtcclxuICAgICAgICAgICAgICAgdmFyIHJFbmRQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcclxuICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlVGVtcENvbm5lY3Rvcih0aGF0LnNlbGVjdGVkTm9kZSwgckVuZFBvaW50LCBhcnJvdy5saW5lVHlwZSk7XHJcbiAgICAgICAgICAgICAgIHRoYXQuX3pyLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAvLyDkvqblkKwg566t5aS0IOaLluaLveS6i+S7tlxyXG4gICAgICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZS5vbihPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUcsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgdmFyIHggPSBlLmV2ZW50Lm9mZnNldFg7XHJcbiAgICAgICAgICAgICAgIHZhciB5ID0gZS5ldmVudC5vZmZzZXRZO1xyXG4gICAgICAgICAgICAgICB2YXIgckVuZFBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xyXG4gICAgICAgICAgICAgICB2YXIgYXJyb3cgPSBlLmV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5tYW5hZ2VUZW1wQ29ubmVjdG9yKHRoYXQuc2VsZWN0ZWROb2RlLCByRW5kUG9pbnQsIGFycm93LmxpbmVUeXBlKTtcclxuICAgICAgICAgICAgICAgdGhhdC5jb25Qb2ludHNHcm91cC5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgIHYuYXR0cih7c3R5bGU6e2ZpbGw6IFwiI0ZGRkYzM1wifSxzY2FsZTpbMSwxXSxvcmlnaW46W3Yuc2hhcGUuY3gsdi5zaGFwZS5jeV0sY3Vyc29yOidjcm9zc2hhaXInfSk7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModi5zaGFwZS5jeCAtIHgpIDw9IDEwICYmIE1hdGguYWJzKHYuc2hhcGUuY3kgLSB5KSA8PSAxMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBmaW5kQ29ubmVjdG9yTm9kZSh4LCB5LCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5tYW5hZ2VUZW1wQ29ubmVjdG9yKHRoYXQuc2VsZWN0ZWROb2RlLCByRW5kUG9pbnQsIGFycm93LmxpbmVUeXBlLCAncmlnaHQnLCByZXMuZW5kUG9zLCByZXMubm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdi5hdHRyKHtzdHlsZTp7ZmlsbDogXCIjZmYwMDAwXCJ9LHNjYWxlOlsxLjUsMS41XSxvcmlnaW46W3Yuc2hhcGUuY3gsdi5zaGFwZS5jeV0sY3Vyc29yOidwb2ludGVyJ30pO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAvL+S+puWQrCDnrq3lpLQg5ouW5ou957uT5p2f5LqL5Lu2IOeUu+e6v1xyXG4gICAgICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZS5vbihPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUdFTkQsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgdmFyIHggPSBlLmV2ZW50Lm9mZnNldFg7XHJcbiAgICAgICAgICAgICAgIHZhciB5ID0gZS5ldmVudC5vZmZzZXRZO1xyXG4gICAgICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgIC8v5ouW5ou957uT5p2f5YWI5oqKIOeureWktOWbvuaghyDnu5nmmL7npLpcclxuICAgICAgICAgICAgICAgdmFyIGFycm93ID0gZS5ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgIGFycm93LnNob3coKTtcclxuXHJcbiAgICAgICAgICAgICAgIHZhciByZXMgPSBmaW5kQ29ubmVjdG9yTm9kZSh4LCB5LCAxMCk7XHJcbiAgICAgICAgICAgICAgIHZhciBzdGFydDtcclxuICAgICAgICAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICAgICAgICAgdmFyIGVuZFBvcyA9IHJlcy5lbmRQb3MgfHwgJ2xlZnQnO1xyXG4gICAgICAgICAgICAgICB2YXIgc3RhcnRQb3M7XHJcbiAgICAgICAgICAgICAgIHZhciBjYW5Db25uZWN0ID0gZmFsc2U7ICAgICAgIC8v5Lik5Liq6IqC54K55piv5ZCm5Y+v5Lul6L+e57q/55qE5qCH6K+GXHJcbiAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSByZXMubm9kZTtcclxuICAgICAgICAgICAgICAgYXJyb3cgPSBlLmV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgICAgLy/liKDpmaTkuLTml7bnur9cclxuICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5yZW1vdmVUZW1wQ29ubmVjdG9yKHRoYXQuX3pyKTtcclxuICAgICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0ZWROb2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyh0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUgJiYgQnBtbi5pc1Nsb3RFdmVudCh0aGF0LnNlbGVjdGVkTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5b2T5YmN6IqC54K55piv6L6555WM6IqC54K55Y+v6L+e57q/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbkNvbm5lY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXROb2RlICYmIHRhcmdldE5vZGUucGFyZW50ICYmIEJwbW4uaXNTdWJQcm9jZXNzKHRhcmdldE5vZGUucGFyZW50KSAmJiB0YXJnZXROb2RlLnBhcmVudC5pZCA9PT0gdGhhdC5zZWxlY3RlZE5vZGUucGFyZW50LmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgLy8g6LW35aeL6IqC54K56YO95Zyo5ZCM5LiA5Liq5a2Q6IqC54K55YaF5YiZ5Y+v5Lul6L+e57q/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgY2FuQ29ubmVjdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSAmJiAhdGFyZ2V0Tm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBjYW5Db25uZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXROb2RlICYmIHRhcmdldE5vZGUucGFyZW50ICYmIEJwbW4uaXNTdWJQcm9jZXNzKHRhcmdldE5vZGUucGFyZW50KSAmJiBCcG1uLmlzU2xvdEV2ZW50KHRhcmdldE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgLy8g55uu5qCH6IqC54K55piv6L6555WM6IqC54K55Y+v6L+e57q/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgY2FuQ29ubmVjdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgLy8yLuWmguaenOaJvuWIsOebruagh+e7k+eCuSDliJnnlLvnur9cclxuICAgICAgICAgICAgICAgaWYgKGNhbkNvbm5lY3QgJiYgKHRoYXQuc2VsZWN0ZWROb2RlLmlkICE9PSB0YXJnZXROb2RlLmlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGF0LnNlbGVjdGVkTm9kZTtcclxuICAgICAgICAgICAgICAgICAgIGVuZCA9IHRhcmdldE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICBzdGFydFBvcyA9ICdyaWdodCc7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdE9wdGlvbnMgPSBlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVR5cGU6IGFycm93LmxpbmVUeXBlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0Ll9jcmVhdGVDb25uZWN0b3JCeU5vZGVzKHN0YXJ0LCBlbmQsIGNvbm5lY3RPcHRpb25zLCBzdGFydFBvcywgZW5kUG9zKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB0aGF0LmhpZGVDb25uZWN0b3JQb2ludCgpOyAgICAgIC8v6ZqQ6JeP5omA5pyJ6IqC54K55LiK55qE6L+e5o6l54K5XHJcbiAgICAgICAgICAgICAgIC8vIOi/nue6v+aIkOWKny/lpLHotKXvvIzlvZPliY3oioLngrnkvp3nhLbmmK/pgInkuK3nirbmgIHvvIzpnIDopoHph43mlrDorqHnrpfomZrnur/lkozlm77moIfkvY3nva5cclxuICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGF0LnNlbGVjdGVkTm9kZTtcclxuICAgICAgICAgICAgICAgdmFyIHNoYXBlUmVjdCA9IHRoYXQuY2FsY3VsYXRlUmVjdChub2RlKTtcclxuICAgICAgICAgICAgICAgLy8g5pi+56S65b2T5YmN6IqC54K555qE6L+e5o6l54K5XHJcbiAgICAgICAgICAgICAgIHRoYXQuc2hvd0Nvbm5lY3RvclBvaW50KHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgdGhhdC5vcGVyYXRpb25Ob2RlLnJlZnJlc2hQb3N0aW9uKG5vZGUsIHNoYXBlUmVjdCk7XHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgLy/liKDpmaTmjInpkq7ngrnlh7vkuovku7ZcclxuICAgICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oXCJPcGVyYXRpb25Ob2RlOmRlbGV0ZUNsaWNrXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICB0aGF0LnJlbW92ZU5vZGUodGhhdC5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIC8v5rOo6YeK5oyJ6ZKu54K55Ye75LqL5Lu2XHJcbiAgICAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlLm9uKFwiT3BlcmF0aW9uTm9kZTpjb21tZW50Q2xpY2tcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHRoYXQuc2VsZWN0ZWROb2RlO1xyXG4gICAgICAgICAgICAgICBpZiAoIXN0YXJ0Lmhhc0NvbW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBlbmRYLCBlbmRZO1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0LmJwbW5JbmZvLm5hbWUuaW5kZXhPZignRXZlbnQnKSAhPT0gLTEgfHwgc3RhcnQuYnBtbkluZm8ubmFtZS5pbmRleE9mKCdHYXRld2F5JykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZW5kWCA9IHN0YXJ0LnBvc2l0aW9uWzBdICsgNDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZW5kWSA9IHN0YXJ0LnBvc2l0aW9uWzFdIC0gODA7XHJcbiAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0Lm5vZGVUeXBlID09PSBcIlN1YlByb2Nlc3NcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGVuZFggPSBzdGFydC5wb3NpdGlvblswXSArIDIwMDtcclxuICAgICAgICAgICAgICAgICAgICAgICBlbmRZID0gc3RhcnQucG9zaXRpb25bMV0gLSA4MDtcclxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZW5kWCA9IHN0YXJ0LnBvc2l0aW9uWzBdICsgMTIwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGVuZFkgPSBzdGFydC5wb3NpdGlvblsxXSAtIDgwO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgdmFyIG1vZGVsID0gbmV3IEJQTU5Nb2RlbCh7fSk7XHJcbiAgICAgICAgICAgICAgICAgICBtb2RlbC5zZXQoQnBtbi5CUE1OX1RZUEUsICdDb21tZW50Jyk7XHJcbiAgICAgICAgICAgICAgICAgICBtb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0XCIsIHt4OiBlbmRYLCB5OiBlbmRZfSk7XHJcbiAgICAgICAgICAgICAgICAgICBtb2RlbC5zZXQoXCJwcm9wZXJ0aWVzXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImNvbW1lbnRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JY29uczogW3tuYW1lOidERUwnLCBjYWxsYmFjazogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydC5oYXNDb21tZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucmVtb3ZlKGVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfX1dXHJcbiAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSB0aGF0LmFkZE5vZGVCeU1vZGVsKG1vZGVsLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgIG1vZGVsID0gbmV3IEJQTU5Nb2RlbCh7fSk7XHJcbiAgICAgICAgICAgICAgICAgICBtb2RlbC5zZXQoXCJyZXNvdXJjZUlkXCIsIHV0aWwuZ2V0VVVJRCgpKTtcclxuICAgICAgICAgICAgICAgICAgIG1vZGVsLnNldChcInN0eWxlLmxpbmVUeXBlXCIsIFwic3RyYWlnaHRcIik7XHJcbiAgICAgICAgICAgICAgICAgICBtb2RlbC5zZXQoXCJzdHlsZS5saW5lRGFzaFwiLCBbM10pO1xyXG4gICAgICAgICAgICAgICAgICAgbW9kZWwuc2V0KFwic3R5bGUuc3Ryb2tlXCIsIFwiIzAwMFwiKTtcclxuICAgICAgICAgICAgICAgICAgIG1vZGVsLnNldChcInN5bWJvbC50eXBlXCIsIFwibm9uZVwiKTtcclxuICAgICAgICAgICAgICAgICAgIG1vZGVsLnNldChcInN0ZW5jaWwudHlwZVwiLCBcIlNlcXVlbmNlRmxvd1wiKTtcclxuICAgICAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3IgPSB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvckNyZWF0ZUJ5T3B0aW9ucyhzdGFydCwgZW5kLCB7bW9kZWw6IG1vZGVsfSwgdGhhdC5fYXBpKTtcclxuICAgICAgICAgICAgICAgICAgIHRoYXQuX3pyLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgc3RhcnQuaGFzQ29tbWVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5vcGVyYXRpb25Ob2RlKTtcclxuICAgICAgIH07XHJcblxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5maW5kTm9kZUNoaWxkSWRzID0gZnVuY3Rpb24gKG5vZGUsIGNoaWxkSWRzKSB7XHJcbiAgICAgICAgICAgY2hpbGRJZHMucHVzaChub2RlLmlkKTtcclxuICAgICAgICAgICBub2RlLmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmFsbE5vZGVzLmZpbmRJbmRleChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaWQgPT09IHYuaWRcclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIHJldHVybiBwb3MgIT09IC0xXHJcbiAgICAgICAgICAgfS5iaW5kKHRoaXMpKS5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHtcclxuICAgICAgICAgICAgICAgaWYgKEJwbW4uaXNTdWJQcm9jZXNzKHN1YikpIHtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZE5vZGVDaGlsZElkcyhzdWIsIGNoaWxkSWRzKTtcclxuICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgIGNoaWxkSWRzLnB1c2goc3ViLmlkKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDnp7vpmaTlnLrmma/kuK3nmoTmn5DkuKroioLngrlcclxuICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gc2VsZWN0ZWROb2RlIOW+heWIoOmZpOeahOiKgueCuVxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLnJlbW92ZSA9IGZpc2hUb3BvUHJvdG8ucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uKGRlbE5vZGUpIHtcclxuICAgICAgICAgICB2YXIgcGFyZW50WnIgPSB0aGlzLl9nZXRQYXJlbnRacihkZWxOb2RlKSwgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgIGlmIChkZWxOb2RlIGluc3RhbmNlb2YgQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJBc3luYygnYmVmb3JlRGVsZXRlTGluZScsIHt0YXJnZXQ6IGRlbE5vZGV9LCBkZWxOb2RlKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAvLyAxLjEg5Yig6Zmk57q/5q615LiK55qE5pON5L2c5Zu+5qCHXHJcbiAgICAgICAgICAgICAgICAgICAgICAgenJVdGlsLmVhY2goZGVsTm9kZS5pY29ucywgZnVuY3Rpb24obGluZU9wZXJhdGlvbkljb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50WnIucmVtb3ZlKGxpbmVPcGVyYXRpb25JY29uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIDEuMiDliKDpmaTlvZPliY3pgInkuK3nur/mrrVcclxuICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0aW9uTWFuYWdlci5kZWxldGVMaW5lKHBhcmVudFpyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdHJpZ2dlcignYWZ0ZXJEZWxldGVMaW5lJywge3RhcmdldDogZGVsTm9kZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0ZXBDb3VudGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJBc3luYygnYmVmb3JlRGVsZXRlTm9kZScsIHt0YXJnZXQ6IGRlbE5vZGV9LCBkZWxOb2RlKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRaci5yZW1vdmUoZGVsTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkSWRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJwbW4uaXNTdWJQcm9jZXNzKGRlbE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmZpbmROb2RlQ2hpbGRJZHMoZGVsTm9kZSwgY2hpbGRJZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSWRzLnB1c2goZGVsTm9kZS5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC8vMi7ku45hbGxOb2Rlc+aVsOe7hOS4reWIoOmZpFxyXG4gICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFsbE5vZGVzID0gX3RoaXMuYWxsTm9kZXMuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZElkcy5pbmRleE9mKHYuaWQpID09PSAtMVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRvbUFycmF5ID0gX3RoaXMuZG9tQXJyYXkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZElkcy5pbmRleE9mKHYuaWQpID09PSAtMVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgX3RoaXMub3ZlcmxhcEFycmF5Lmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxOb2RlLmlkID09IF90aGlzLm92ZXJsYXBBcnJheVtrXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub3ZlcmxhcEFycmF5LnNwbGljZShrLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoQnBtbi5pc1N1YlByb2Nlc3MoZGVsTm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBfdGhpcy5zdWJQcm9jZXNzTm9kZS5sZW5ndGg7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbE5vZGUuaWQgPT0gX3RoaXMuc3ViUHJvY2Vzc05vZGVbbV0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdWJQcm9jZXNzTm9kZS5zcGxpY2UobSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgLy8g5Yig6Zmk6IqC54K55pON5L2cXHJcbiAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZU9wZXJhdGlvbk5vZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAvLzMu5bCG5q2k6IqC54K55Lqk6IGU55qE57q/5Lmf5Yig6ZmkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdGlvbk1hbmFnZXIuZGVsZXRlU2VsZWN0Q29uKGRlbE5vZGUsIEJwbW4uaXNTbG90RXZlbnQoZGVsTm9kZSkgPyBfdGhpcy5fenIgOiBwYXJlbnRacik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgLy/lpoLmnpzliKDpmaToioLngrnmmK90YXNr6IqC54K577yM6ZyA6KaB5bCG5L6d6ZmE5a6D55qE5LqL5Lu26IqC54K55Yig6ZmkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJwbW4uaXNBY3Rpdml0eShkZWxOb2RlKSB8fCBCcG1uLmlzU3ViUHJvY2VzcyhkZWxOb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsTm9kZS5zbG90RXZlbnQgJiYgZGVsTm9kZS5zbG90RXZlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBkZWxOb2RlLnNsb3RFdmVudC5sZW5ndGg7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxOb2RlLnNsb3RFdmVudFttXS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJwbW4uaXNTdWJQcm9jZXNzKGRlbE5vZGUuc2xvdEV2ZW50W21dLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbE5vZGUuc2xvdEV2ZW50W21dLnBhcmVudC5yZW1vdmUoZGVsTm9kZS5zbG90RXZlbnRbbV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3pyLnJlbW92ZShkZWxOb2RlLnNsb3RFdmVudFttXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgX3RoaXMuYWxsTm9kZXMubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbE5vZGUuc2xvdEV2ZW50W21dLmlkID09IF90aGlzLmFsbE5vZGVzW25dLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hbGxOb2Rlcy5zcGxpY2UobiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBfdGhpcy5kb21BcnJheS5sZW5ndGg7IGErKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsTm9kZS5zbG90RXZlbnRbbV0uaWQgPT0gX3RoaXMuZG9tQXJyYXlbYV0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRvbUFycmF5LnNwbGljZShhLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAvLzQu5aaC5p6c5Yig6Zmk55qE5piv5LqL5Lu26IqC54K577yM6ZyA6KaB5bCG57uR5a6a5a6D55qEdGFza+iKgueCueeahOagh+ivhuWIoOmZpFxyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU2xvdEV2ZW50KGRlbE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgX3RoaXMuYWxsTm9kZXMubGVuZ3RoOyBiKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hbGxOb2Rlc1tiXS5pc0NhblNsb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYWxsTm9kZXNbYl0uc2xvdEV2ZW50ICYmIF90aGlzLmFsbE5vZGVzW2JdLnNsb3RFdmVudC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgX3RoaXMuYWxsTm9kZXNbYl0uc2xvdEV2ZW50Lmxlbmd0aDsgYysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsTm9kZS5pZCA9PSBfdGhpcy5hbGxOb2Rlc1tiXS5zbG90RXZlbnRbY10uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hbGxOb2Rlc1tiXS5zbG90RXZlbnQuc3BsaWNlKGMsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyKCdhZnRlckRlbGV0ZU5vZGUnLCB7dGFyZ2V0OiBkZWxOb2RlfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfTtcclxuICAgICAgIGZpc2hUb3BvUHJvdG8ucmVtb3ZlU2VsZWN0ZWROb2RlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE5vZGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICB2YXIgY2hpbGRzID0gdGhhdC5kcmFnU2VsZWN0UmVjdC5jaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIHYubmFtZSAhPT0gXCJHUk9VUF9SRUNUX05BTUVcIiAmJiAhQnBtbi5pc0Zsb3codik7XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICB2YXIgbGluZXMgPSB0aGF0LmRyYWdTZWxlY3RSZWN0LmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5uYW1lICE9PSBcIkdST1VQX1JFQ1RfTkFNRVwiICYmIEJwbW4uaXNGbG93KHYpO1xyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBzdGFydE5vZGUgPSBjaGlsZHMuZmluZChmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuaWQgPT09IHYuc3RhcnROb2RlLmlkXHJcbiAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgIHZhciBlbmROb2RlID0gY2hpbGRzLmZpbmQoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmlkID09PSB2LmVuZE5vZGUuaWRcclxuICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIGlmRXhpc3QgPSBsaW5lcy5maW5kSW5kZXgoZnVuY3Rpb24obGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLmlkID09PSB2LmlkXHJcbiAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgIGlmICgoc3RhcnROb2RlIHx8IGVuZE5vZGUpICYmIGlmRXhpc3QgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5yZW1vdmVMaW5lKHYsIHYucGFyZW50ID8gdi5wYXJlbnQgOiB0aGF0Ll96cik7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0LnJlbW92ZU5vZGUoaXRlbSk7XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkTm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgdGhpcy5kcmFnU2VsZWN0UmVjdC5vZmYoXCJtb3VzZWRvd25cIik7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3pyLnJlbW92ZSh0aGlzLmRyYWdTZWxlY3RSZWN0KTtcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICB0aGF0LnJlbW92ZU5vZGUodGhhdC5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH07XHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLl9jcmVhdGVDb25uZWN0b3JCeU5vZGVzID0gZnVuY3Rpb24oc3RhcnROb2RlLCBlbmROb2RlLCBsaW5lVHlwZSwgc3RhcnRQb3MsIGVuZFBvcykge1xyXG4gICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdiZWZvcmVDcmVhdGVMaW5lJywge3RhcmdldDogc3RhcnROb2RlfSwgW3N0YXJ0Tm9kZSwgZW5kTm9kZV0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICBpZiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9yID0gX3RoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9yQ3JlYXRlKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgbGluZVR5cGUsIF90aGlzLl9hcGksIHN0YXJ0UG9zLCBlbmRQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0Tm9kZS5wYXJlbnQgJiYgZW5kTm9kZS5wYXJlbnQgJiYgc3RhcnROb2RlLnBhcmVudC5yZXNvdXJjZUlkID09PSBlbmROb2RlLnBhcmVudC5yZXNvdXJjZUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZW5kTm9kZS5wYXJlbnQuYWRkKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl96ci5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvckZvcmJpZEVkaXQoKTtcclxuICAgICAgICAgICAgICAgICAgIF90aGlzLl9jcmVhdGVDb25uZWN0b3JEcmFnRXZlbnRzKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICBjb25uZWN0b3Iub24oXCJtb3VzZWRvd25cIiwgenJVdGlsLmJpbmQoZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIuaXNFZGl0ID0gIXRoaXMuZm9yYmlkRWRpdDtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzTm9kZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIOWPlua2iOiKgueCueeahOmAieS4rVxyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlQ29ubmVjdG9yQ29udHJvbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZU9wZXJhdGlvbk5vZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICB0aGlzLnNob3dDb25uZWN0b3JQb2ludChlLnRhcmdldC5zdHlsZS5saW5lVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICB9LCBfdGhpcykpO1xyXG4gICAgICAgICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXIoJ2FmdGVyQ3JlYXRlTGluZScsIHt0YXJnZXQ6IGNvbm5lY3Rvcn0pO1xyXG4gICAgICAgICAgICAgICAgICAgX3RoaXMuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9KVxyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLl9jcmVhdGVDb25uZWN0b3JEcmFnRXZlbnRzID0gZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgY29ubmVjdG9yLm9uKFwiZHJhZ3N0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGUuZXZlbnQub2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gZS5ldmVudC5vZmZzZXRZO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVUeXBlID0gb3B0LnN0eWxlLmxpbmVUeXBlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRvY2tlcnMgPSBvcHQuZG9ja2VycztcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydFBvaW50ID0gZG9ja2Vyc1swXTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRQb2ludCA9IGRvY2tlcnNbZG9ja2Vycy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydERpZmYgPSBNYXRoLmFicyh4IC0gc3RhcnRQb2ludC54KSArIE1hdGguYWJzKHkgLSBzdGFydFBvaW50LnkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZERpZmYgPSBNYXRoLmFicyh4IC0gZW5kUG9pbnQueCkgKyBNYXRoLmFicyh5IC0gZW5kUG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREaWZmID4gMTUgJiYgZW5kRGlmZiA+IDE1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zaG93Q29ubmVjdG9yUG9pbnQodW5kZWZpbmVkLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5yZXZlcnNlQ29ubmVjdCA9IGZhbHNlOyAgIC8v5piv5ZCm5Y+N5ZCR6L+e57q/55qE5qCH6K+GXHJcbiAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdENvbm5Ob2RlID0gY29ubmVjdG9yLnN0YXJ0Tm9kZTtcclxuICAgICAgICAgICAgICAgIHRoYXQubGluZU9wdCA9IG9wdC5zdHlsZTsgLy/nvJPlrZjnur/mrrXnmoTphY3nva7kv6Hmga9cclxuICAgICAgICAgICAgICAgIGlmIChlbmREaWZmIDw9IDE1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RDb25uTm9kZSA9IGNvbm5lY3Rvci5zdGFydE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zdGFydFBvcyA9IG9wdC5zdHlsZS5zUG9zO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQub3JpZ2luTm9kZSA9IHRoaXMuZW5kTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Lm9yaWdpblBvcyA9IG9wdC5zdHlsZS5lUG9zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RGlmZiA8PSAxNSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQucmV2ZXJzZUNvbm5lY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0Q29ubk5vZGUgPSBjb25uZWN0b3IuZW5kTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmVuZFBvcyA9IG9wdC5zdHlsZS5lUG9zO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQub3JpZ2luTm9kZSA9IHRoaXMuc3RhcnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQub3JpZ2luUG9zID0gb3B0LnN0eWxlLnNQb3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLmRlbGV0ZUJ5TGluZSh0aGlzLCB0aGF0Ll96cik7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9yTGluZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGF0LnJldmVyc2VDb25uZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yTGluZSA9IHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlUmV2ZXJzZVRlbXBDb25uZWN0b3IocG9pbnQsIHRoYXQuc2VsZWN0Q29ubk5vZGUsIGxpbmVUeXBlLCB0aGF0LmVuZFBvcyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvckxpbmUgPSB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLm1hbmFnZVRlbXBDb25uZWN0b3IodGhhdC5zZWxlY3RDb25uTm9kZSwgcG9pbnQsIGxpbmVUeXBlLCB0aGF0LnN0YXJ0UG9zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoYXQuX3pyLmFkZChjb25uZWN0b3JMaW5lKTtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3RvckxpbmUuc2V0U2VsZWN0ZWRTdHlsZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29ubmVjdG9yLm9uKFwiZHJhZ1wiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5faGFuZGxlTGluZURyYWcoJ2RyYWcnLCBlLCB0aGlzLm9wdC5zdHlsZS5saW5lVHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25uZWN0b3Iub24oXCJkcmFnZW5kXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9oYW5kbGVMaW5lRHJhZygnZHJhZ2VuZCcsIGUsIHRoaXMub3B0LnN0eWxlLmxpbmVUeXBlKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgICAgICAgICB0aGF0LmhpZGVDb25uZWN0b3JDb250cm9sKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgfVxyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uX3RyaWdnZXJBc3luYyA9IGZ1bmN0aW9uKHR5cGUsIGV2ZW50LCBkYXRhKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXIodHlwZSwgZXZlbnQsIGRhdGEsIHRydWUpO1xyXG4gICAgICAgfVxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5fdHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUsIGV2ZW50LCBkYXRhLCBhc3luYykge1xyXG4gICAgICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMub3B0c1t0eXBlXTtcclxuXHJcbiAgICAgICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCkgZGF0YSA9IHt9O1xyXG4gICAgICAgICAgIGlmIChldmVudCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICBldmVudCA9IHt0eXBlOnR5cGUsIHRhcmdldDp0aGlzfVxyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBldmVudC5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICB0aGlzLl9hcGkudHJpZ2dlcihldmVudC50eXBlLCBldmVudCk7XHJcbiAgICAgICAgICAgaWYgKGFzeW5jKSB7XHJcbiAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnJlc29sdmUoenJVdGlsLmlzRnVuY3Rpb24oY2FsbGJhY2spID8gY2FsbGJhY2suYXBwbHkodGhpcywgW2V2ZW50XS5jb25jYXQoZGF0YSkpIDogdHJ1ZSlcclxuICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gISh2YWx1ZSA9PT0gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgcmV0dXJuICEoenJVdGlsLmlzRnVuY3Rpb24oY2FsbGJhY2spICYmIGNhbGxiYWNrLmFwcGx5KHRoaXMsIFtldmVudF0uY29uY2F0KGRhdGEpKSA9PT0gZmFsc2UpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH1cclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgKiDpvKDmoIfngrnkuIsg5bCG5pON5L2c5qGGIOenu+WIsOWvueW6lOeahOiKgueCueS4ilxyXG4gICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBub2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8ubm9kZUNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGlmU2hvd1BvaW50ID0gbm9kZS50eXBlICE9PSAnZHJhZ1NlbGVjdCcgJiYgdGhpcy5pZlNob3dDb25uZWN0b3JQb2ludChub2RlKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LnR5cGUgPT09IFwiZHJhZ1NlbGVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZlNob3dQb2ludCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDEuIOmakOiXj+i/nue6v+eCuVxyXG4gICAgICAgICAgICB0aGlzLmhpZGVDb25uZWN0b3JQb2ludCgpO1xyXG4gICAgICAgICAgICAvLyAyLiDpmpDol4/mjqfliLbngrlcclxuICAgICAgICAgICAgdGhpcy5oaWRlQ29ubmVjdG9yQ29udHJvbCgpO1xyXG4gICAgICAgICAgICAvLyAzLiDpmpDol4/mk43kvZxub2RlXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZU9wZXJhdGlvbk5vZGUoKTtcclxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcignZWRpdE9wZXJhdGlvbkljb25zJywge3RhcmdldDogbm9kZX0sIG5vZGUub3BlcmF0aW9uSWNvbnMpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mb3JiaWRFZGl0ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGVSZWN0ID0gdGhpcy5jYWxjdWxhdGVSZWN0KG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMub3BlcmF0aW9uTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0T3BlcmF0aW9uTm9kZShub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlY3QgJiYgdGhpcy5yZWN0LmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwicmdiYSgwLCAwLCAwLCAxKVwiXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlmU2hvd1BvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyDmmL7npLrlvZPliY3oioLngrnnmoTov57mjqXngrlcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Nvbm5lY3RvclBvaW50KHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnJldHVybkNvbm5lY3RvckNvbnRyb2xQYXJhbShub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuc2NhbGVhYmxlIHx8IHBhcmFtcy5yb3RhdGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmmL7npLrlvZPliY3oioLngrnnmoTmjqfliLbngrlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dDb25uZWN0b3JDb250cm9sKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlLnJlZnJlc2hQb3N0aW9uKG5vZGUsIHNoYXBlUmVjdCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIOWIneWni+WMluiZmuahhuWvuem9kOe6v1xyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gbm9kZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNoYXBlTGlzdCBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uaW5pdFZpcnR1YWxMaW5lID0gZnVuY3Rpb24obm9kZSwgc2hhcGVMaXN0KSB7XHJcbiAgICAgICAgICAgR3VpZGVsaW5lcy5jcmVhdGVHdWlkZWxpbmVzKHRoaXMuX3pyKTtcclxuICAgICAgICAgICB0aGlzLnJlY3QgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSh7XHJcbiAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbc2hhcGVMaXN0LngsIHNoYXBlTGlzdC55XSxcclxuICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgIHBvaW50czogc2hhcGVMaXN0LnBvaW50c1xyXG4gICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgbGluZURhc2g6IFsyXVxyXG4gICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICByb3RhdGlvbjogbm9kZS5yb3RhdGlvbixcclxuICAgICAgICAgICAgICAgejogM1xyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzLnJlY3QpO1xyXG4gICAgICAgfTtcclxuICAgICAgIC8v57uR5a6a5LqL5Lu26IqC54K5XHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmJpbmRFdmVudE5vZGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAvL21vdXNlZG93bueahOaXtuWAmeS4uuavj+S4qnRhc2vliJvlu7rmj5Lmp71cclxuICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsTm9kZXNbaV0uaXNDYW5TbG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0U2xvdCh0aGlzLmFsbE5vZGVzW2ldKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICAvL21vdXNldXDnmoTml7blgJnliKDpmaTmj5Lmp71cclxuICAgICAgICAgICB0aGlzLl96ci5vbihcIm1vdXNldXBcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsTm9kZXNbaV0uaXNDYW5TbG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsTm9kZXNbaV0uc2xvdCAmJiB0aGlzLmFsbE5vZGVzW2ldLnNsb3QubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IHRoaXMuYWxsTm9kZXNbaV0uc2xvdC5sZW5ndGg7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGxOb2Rlc1tpXS5yZW1vdmUodGhpcy5hbGxOb2Rlc1tpXS5zbG90W21dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuXHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5jcmVhdFNsb3QgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgLy/nu5l0YXNr5Yib5bu6OOS4quaPkuanvVxyXG4gICAgICAgICAgIG5vZGUuc2xvdCA9IFtdO1xyXG4gICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHV0aWwuZ2V0U29sdFBvaW50cyhub2RlKTtcclxuICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xyXG4gICAgICAgICAgICAgICB2YXIgQ2lyY2xlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbltqXSxcclxuICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgcjogMTBcclxuICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICdyZ2JhKDAsMCwwLDAuNiknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCdcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIG5vZGUuc2xvdC5wdXNoKENpcmNsZSk7XHJcbiAgICAgICAgICAgICAgIG5vZGUuYWRkKENpcmNsZSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLnVwZGF0ZVNsb3RFdmVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICBpZiAobm9kZS5zbG90RXZlbnQgJiYgbm9kZS5zbG90RXZlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB1dGlsLmdldFNvbHRQb2ludHMobm9kZSk7XHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZS5zbG90RXZlbnQubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG5vZGUuc2xvdEV2ZW50W25dLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIHNsb3RFdmVudFBvc2l0aW9uMiA9IHBvc2l0aW9uW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgIGlmICghQnBtbi5pc1N1YlByb2Nlc3Mobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBzbG90RXZlbnRQb3NpdGlvbjIgPSBbcG9zaXRpb25baW5kZXhdWzBdICsgbm9kZS5wb3NpdGlvblswXSwgcG9zaXRpb25baW5kZXhdWzFdICsgbm9kZS5wb3NpdGlvblsxXV1cclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIG5vZGUuc2xvdEV2ZW50W25dLmF0dHIoXCJwb3NpdGlvblwiLCBzbG90RXZlbnRQb3NpdGlvbjIpO1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZShub2RlLnNsb3RFdmVudFtuXSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5fcG9zSW5XaGljaFN1YnByb2Nlc3MgPSBmdW5jdGlvbihjb250YWluZXJOb2Rlcywgbm9kZSkge1xyXG4gICAgICAgICAgIGlmIChjb250YWluZXJOb2Rlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGFpbmVyTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJOb2RlID0gY29udGFpbmVyTm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGNvbnRhaW5lck5vZGUuZ2V0UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIG5vZGVXaWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIG5vZGVYID0gQnBtblV0aWwucGFyZW50WChjb250YWluZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgIHZhciBub2RlWSA9IEJwbW5VdGlsLnBhcmVudFkoY29udGFpbmVyTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAobm9kZS54ID49IG5vZGVYICYmIG5vZGUueSA+PSBub2RlWSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgIG5vZGUueCtub2RlLndpZHRoIDw9IG5vZGVYK25vZGVXaWR0aCAmJiBub2RlLnkrbm9kZS5oZWlnaHQgPD0gbm9kZVkrbm9kZUhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXJOb2RlLmNoaWxkcmVuKCkgJiYgY29udGFpbmVyTm9kZS5jaGlsZHJlbigpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0NvbnRhaW5lciA9IGNvbnRhaW5lck5vZGUuY2hpbGRyZW4oKS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmJwbW5JbmZvICYmIGl0ZW0ubm9kZVR5cGUgPT09ICdTdWJQcm9jZXNzJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHRoaXMuX3Bvc0luV2hpY2hTdWJwcm9jZXNzKG5ld0NvbnRhaW5lciwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdOb2RlIHx8IGNvbnRhaW5lck5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5nZXREcmFnU2VsZWN0Q29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgIHZhciBMZWZ0VXBwZXJQb3NYID0gW107XHJcbiAgICAgICAgICAgdmFyIExlZnRVcHBlclBvc1kgPSBbXTtcclxuICAgICAgICAgICB2YXIgUmlnaHRMb3dlclBvc1ggPSBbXTtcclxuICAgICAgICAgICB2YXIgUmlnaHRMb3dlclBvc1kgPSBbXTtcclxuICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3RSZWN0LmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgIHJldHVybiB2Lm5hbWUgIT09IFwiR1JPVVBfUkVDVF9OQU1FXCIgJiYgIUJwbW4uaXNGbG93KHYpO1xyXG4gICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBpdGVtLmdldFJlY3QoKTtcclxuICAgICAgICAgICAgICAgdmFyIG5vZGVXaWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgIHZhciBub2RlSGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgIHZhciBub2RlWCA9IHJlY3QueDtcclxuICAgICAgICAgICAgICAgdmFyIG5vZGVZID0gcmVjdC55O1xyXG5cclxuICAgICAgICAgICAgICAgaWYgKEJwbW4uaXNFdmVudChpdGVtKSB8fCBCcG1uLmlzR2F0ZXdheShpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgTGVmdFVwcGVyUG9zWC5wdXNoKG5vZGVYIC0gbm9kZVdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgIExlZnRVcHBlclBvc1kucHVzaChub2RlWSAtIG5vZGVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgUmlnaHRMb3dlclBvc1gucHVzaChub2RlWCArIG5vZGVXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICBSaWdodExvd2VyUG9zWS5wdXNoKG5vZGVZICsgbm9kZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICBMZWZ0VXBwZXJQb3NYLnB1c2gobm9kZVggLSBub2RlV2lkdGgvMik7XHJcbiAgICAgICAgICAgICAgICAgICBMZWZ0VXBwZXJQb3NZLnB1c2gobm9kZVkgLSBub2RlSGVpZ2h0LzIpO1xyXG4gICAgICAgICAgICAgICAgICAgUmlnaHRMb3dlclBvc1gucHVzaChub2RlWCArIG5vZGVXaWR0aC8yKTtcclxuICAgICAgICAgICAgICAgICAgIFJpZ2h0TG93ZXJQb3NZLnB1c2gobm9kZVkgKyBub2RlSGVpZ2h0LzIpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgeDogTWF0aC5taW4uYXBwbHkoTWF0aCwgTGVmdFVwcGVyUG9zWCksXHJcbiAgICAgICAgICAgICAgIHk6IE1hdGgubWluLmFwcGx5KE1hdGgsIExlZnRVcHBlclBvc1kpLFxyXG4gICAgICAgICAgICAgICB3aWR0aDogTWF0aC5tYXguYXBwbHkoTWF0aCwgUmlnaHRMb3dlclBvc1gpIC0gTWF0aC5taW4uYXBwbHkoTWF0aCwgTGVmdFVwcGVyUG9zWCksXHJcbiAgICAgICAgICAgICAgIGhlaWdodDogbmV3SGVpZ2h0ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgUmlnaHRMb3dlclBvc1kpIC0gTWF0aC5taW4uYXBwbHkoTWF0aCwgTGVmdFVwcGVyUG9zWSlcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICogbW91c2Vkb3du5ZCOIOW8gOWni+aLluWKqFxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLm5ld0RyYWcgPSBmdW5jdGlvbihkb20sIHNYLCBzWSkge1xyXG4gICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICB0aGF0Ll9yZW1vdmVPcGVyYXRpb25Ob2RlKCk7XHJcbiAgICAgICAgICAgdGhhdC5oaWRlQ29ubmVjdG9yUG9pbnQoKTtcclxuICAgICAgICAgICB0aGF0LmhpZGVDb25uZWN0b3JDb250cm9sKCk7XHJcbiAgICAgICAgICAgdGhhdC5zZWxlY3RlZE5vZGUgPSBkb207XHJcbiAgICAgICAgICAgdGhhdC5pc05vZGUgPSB0cnVlO1xyXG4gICAgICAgICAgIHZhciBwaXhlbCA9IHRoaXMub3B0cy5zaG93R3JpZExpbmUgPyB0aGlzLm9wdHMuZ3JpZExpbmVTcGFjaW5nIDogMTtcclxuICAgICAgICAgICB2YXIgc2hhcGVMaXN0ID0gdGhpcy5jYWxjdWxhdGVSZWN0KGRvbSk7XHJcbiAgICAgICAgICAgdmFyIGRvbUFycmF5ID0gdGhhdC5kb21BcnJheTtcclxuICAgICAgICAgICAvL3pyZW5kZXLkuI3mlK/mjIHplK7nm5jkuovku7bvvIzlj6rog73kvqblkKxib2R55YWD57Sg5LiK55qE5LqGXHJcbiAgICAgICAgICAgZG9jdW1lbnQuYm9keS5vbmtleWRvd24gPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICB2YXIgZXYgPSBlIHx8IHdpbmRvdy5ldmVudDtcclxuICAgICAgICAgICAgICAgLy/liKTmlq0gZGVsZXRl5oyJ6ZSuXHJcbiAgICAgICAgICAgICAgIGlmIChldi5rZXljb2RlID09IDQ2IHx8IGV2LmNoYXJDb2RlID09IDQ2IHx8IGV2LndoaWNoID09IDQ2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAvLzEu5aaC5p6c5piv6IqC54K5LOenu+mZpOS6i+S7tizov5vooYzliKDpmaQgIOWmguaenOaYr+WtkOiKgueCuSDpgJrov4dwYXJlbnTliKDpmaRcclxuICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmlzTm9kZSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RlZE5vZGUub2ZmKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0ZWROb2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQnBtbi5pc1N1YlByb2Nlc3ModGhhdC5zZWxlY3RlZE5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RlZE5vZGUucGFyZW50LnJlbW92ZSh0aGF0LnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll96ci5yZW1vdmUodGhhdC5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAvLzIu5Yig6Zmk57u05oqk55qE6IqC54K55pWw57uEXHJcbiAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0LmFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnNlbGVjdGVkTm9kZS5pZCA9PSB0aGF0LmFsbE5vZGVzW2ldLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFsbE5vZGVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbUFycmF5Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnNlbGVjdGVkTm9kZS5pZCA9PSBkb21BcnJheVtqXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tQXJyYXkuc3BsaWNlKGosIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhhdC5vdmVybGFwQXJyYXkubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0ZWROb2RlLmlkID09IHRoYXQub3ZlcmxhcEFycmF5W2tdLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm92ZXJsYXBBcnJheS5zcGxpY2UoaywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgLy8zLuenu+WOu+aTjeS9nOahhlxyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9wZXJhdGlvbk5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fenIucmVtb3ZlKHRoYXQub3BlcmF0aW9uTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub3BlcmF0aW9uTm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC8vMy7liKDpmaTlr7nlupTnmoTnur9cclxuICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLmRlbGV0ZVNlbGVjdENvbih0aGF0LnNlbGVjdGVkTm9kZSwgdGhhdC5fenIpO1xyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy/lkKbliJnnm7TmjqXliKDpmaTnur9cclxuICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLmRlbGV0ZUxpbmUodGhhdC5fenIpO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgLy8gNC7liKDpmaTov57mjqXngrnlkozmjqfliLbngrlcclxuICAgICAgICAgICAgICAgICAgIHRoYXQuaGlkZUNvbm5lY3RvclBvaW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0LmhpZGVDb25uZWN0b3JDb250cm9sKCk7XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0LnN0ZXBDb3VudGVyKCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgIC8v5Yid5aeL5YyWIOWvuem9kOe6v1xyXG4gICAgICAgICAgIHZhciBzdGFydFgsIHN0YXJ0WSwgcmVjdFBvc2l0aW9uWCwgcmVjdFBvc2l0aW9uWTtcclxuICAgICAgICAgICBzdGFydFggPSBzWDtcclxuICAgICAgICAgICBzdGFydFkgPSBzWTtcclxuICAgICAgICAgICByZWN0UG9zaXRpb25YID0gc2hhcGVMaXN0Lng7XHJcbiAgICAgICAgICAgcmVjdFBvc2l0aW9uWSA9IHNoYXBlTGlzdC55O1xyXG4gICAgICAgICAgIGlmICghdGhhdC5yZWN0KSB7XHJcbiAgICAgICAgICAgICAgIHRoYXQuaW5pdFZpcnR1YWxMaW5lKGRvbSwgc2hhcGVMaXN0KTtcclxuICAgICAgICAgICAgICAgdGhhdC5yZWN0LmF0dHIoXCJwb3NpdGlvblwiLCBbcmVjdFBvc2l0aW9uWCwgcmVjdFBvc2l0aW9uWV0pO1xyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIHRoYXQucmVjdC5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogW3JlY3RQb3NpdGlvblgsIHJlY3RQb3NpdGlvblldLFxyXG4gICAgICAgICAgICAgICAgICAgXCJyb3RhdGlvblwiOiBzaGFwZUxpc3Qucm90YXRpb24gfHwgZG9tLnJvdGF0aW9uXHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICB0aGF0LnJlY3Quc2V0U2hhcGUoe3BvaW50czogc2hhcGVMaXN0LnBvaW50c30pO1xyXG4gICAgICAgICAgICAgICB0aGF0LnJlY3Quc2hvdygpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICB2YXIgbm93UmVjdFBvc2l0aW9uID0gW3JlY3RQb3NpdGlvblgsIHJlY3RQb3NpdGlvblldO1xyXG4gICAgICAgICAgIHZhciBub3dEcmFnUmVjdFBvc2l0aW9uLCBkcmFnUmVjdFBvc2l0aW9uWCwgZHJhZ1JlY3RQb3NpdGlvblksIGRyYWdSZWN0O1xyXG4gICAgICAgICAgIHZhciBkZ1JlY3QsIHN0YXJ0Q29udGFpbmVyO1xyXG4gICAgICAgICAgIGlmIChkb20udHlwZSA9PT0gXCJkcmFnU2VsZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgZHJhZ1JlY3QgPSB0aGlzLmdldERyYWdTZWxlY3RDb250YWluZXIoKTtcclxuICAgICAgICAgICAgICAgZHJhZ1JlY3RQb3NpdGlvblggPSBkcmFnUmVjdC54ICsgZHJhZ1JlY3Qud2lkdGgvMiArIHRoaXMuZHJhZ1NlbGVjdFJlY3QucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgIGRyYWdSZWN0UG9zaXRpb25ZID0gZHJhZ1JlY3QueSArIGRyYWdSZWN0LmhlaWdodC8yICsgdGhpcy5kcmFnU2VsZWN0UmVjdC5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgbm93RHJhZ1JlY3RQb3NpdGlvbiA9IFtkcmFnUmVjdFBvc2l0aW9uWCwgZHJhZ1JlY3RQb3NpdGlvblldO1xyXG5cclxuICAgICAgICAgICAgICAgZGdSZWN0ID0gdGhhdC5kcmFnU2VsZWN0UmVjdC5nZXRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gdGhhdC5fcG9zSW5XaGljaFN1YnByb2Nlc3ModGhhdC5zdWJQcm9jZXNzTm9kZSwge1xyXG4gICAgICAgICAgICAgICAgICAgeDogZGdSZWN0LnggLSBkZ1JlY3Qud2lkdGgvMixcclxuICAgICAgICAgICAgICAgICAgIHk6IGRnUmVjdC55IC0gZGdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICAgICAgICAgd2lkdGg6IGRnUmVjdC53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgIGhlaWdodDogZGdSZWN0LmhlaWdodFxyXG4gICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgIHZhciBpc0xhcCA9IDA7XHJcbiAgICAgICAgICAgdmFyIGlzTW92ZSA9IDA7XHJcbiAgICAgICAgICAgdmFyIG1vdmVGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgbW92ZURyYWcoZSk7XHJcbiAgICAgICAgICAgfTtcclxuICAgICAgICAgICB2YXIgdXBGdW5jdGlvbiA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgZW5kRHJhZyhlKTtcclxuICAgICAgICAgICB9O1xyXG4gICAgICAgICAgIHRoaXMuX3pyLm9uKCdtb3VzZW1vdmUnLCBtb3ZlRnVuY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAvL+W8gOWni+enu+WKqCzoioLngrnnp7vliqjml7blj5bmtojmiYDmnInoioLngrnnmoTpgInkuK3nirbmgIFcclxuICAgICAgICAgICBmdW5jdGlvbiBtb3ZlRHJhZyhlKSB7XHJcbiAgICAgICAgICAgICAgIC8v5LulMTDkuKrlg4/ntKDkuLrljZXkvY3ov5vooYznp7vliqhcclxuICAgICAgICAgICAgICAgdmFyIG1heFJlY3RQb3NpdGlvbiA9IFt0aGF0LmdldFdpZHRoKCkgLSAodGhhdC5yZWN0LnNoYXBlLnBvaW50c1sxXVswXSAtIHRoYXQucmVjdC5zaGFwZS5wb2ludHNbMF1bMF0pIC8gMiwgdGhhdC5nZXRIZWlnaHQoKSAtICh0aGF0LnJlY3Quc2hhcGUucG9pbnRzWzJdWzFdIC0gdGhhdC5yZWN0LnNoYXBlLnBvaW50c1sxXVsxXSkgLyAyXTtcclxuICAgICAgICAgICAgICAgdmFyIG1pblJlY3RQb3NpdGlvbiA9IFsodGhhdC5yZWN0LnNoYXBlLnBvaW50c1sxXVswXSAtIHRoYXQucmVjdC5zaGFwZS5wb2ludHNbMF1bMF0pIC8gMiwgKHRoYXQucmVjdC5zaGFwZS5wb2ludHNbMl1bMV0gLSB0aGF0LnJlY3Quc2hhcGUucG9pbnRzWzFdWzFdKSAvIDJdO1xyXG4gICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IE1hdGguYWJzKHBhcnNlSW50KChlLmV2ZW50LmNsaWVudFggLSBzdGFydFgpIC8gcGl4ZWwpKTsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpc01vdmUgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKGUuZXZlbnQuY2xpZW50WCAtIHN0YXJ0WCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBub3dSZWN0UG9zaXRpb25bMF0gPSByZWN0UG9zaXRpb25YIC0gcGl4ZWwgKiAobik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbS50eXBlID09PSBcImRyYWdTZWxlY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBub3dEcmFnUmVjdFBvc2l0aW9uWzBdID0gZHJhZ1JlY3RQb3NpdGlvblggLSBwaXhlbCAqIChuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIG5vd1JlY3RQb3NpdGlvblswXSA9IHJlY3RQb3NpdGlvblggKyBwaXhlbCAqIChuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tLnR5cGUgPT09IFwiZHJhZ1NlbGVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd0RyYWdSZWN0UG9zaXRpb25bMF0gPSBkcmFnUmVjdFBvc2l0aW9uWCArIHBpeGVsICogKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIGlmIChub3dSZWN0UG9zaXRpb25bMF0gPCBtaW5SZWN0UG9zaXRpb25bMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBub3dSZWN0UG9zaXRpb25bMF0gPSBtaW5SZWN0UG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICBpZiAobm93UmVjdFBvc2l0aW9uWzBdID4gbWF4UmVjdFBvc2l0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgbm93UmVjdFBvc2l0aW9uWzBdID0gbWF4UmVjdFBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgTWF0aC5hYnMocGFyc2VJbnQoKGUuZXZlbnQuY2xpZW50WSAtIHN0YXJ0WSkgLyBwaXhlbCkpOyBtKyspIHtcclxuICAgICAgICAgICAgICAgICAgIGlzTW92ZSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoZS5ldmVudC5jbGllbnRZIC0gc3RhcnRZIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIG5vd1JlY3RQb3NpdGlvblsxXSA9IHJlY3RQb3NpdGlvblkgLSBwaXhlbCAqIChtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tLnR5cGUgPT09IFwiZHJhZ1NlbGVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd0RyYWdSZWN0UG9zaXRpb25bMV0gPSBkcmFnUmVjdFBvc2l0aW9uWSAtIHBpeGVsICogKG0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgbm93UmVjdFBvc2l0aW9uWzFdID0gcmVjdFBvc2l0aW9uWSArIHBpeGVsICogKG0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChkb20udHlwZSA9PT0gXCJkcmFnU2VsZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93RHJhZ1JlY3RQb3NpdGlvblsxXSA9IGRyYWdSZWN0UG9zaXRpb25ZICsgcGl4ZWwgKiAobSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgaWYgKG5vd1JlY3RQb3NpdGlvblsxXSA8IG1pblJlY3RQb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIG5vd1JlY3RQb3NpdGlvblsxXSA9IG1pblJlY3RQb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIGlmIChub3dSZWN0UG9zaXRpb25bMV0gPiBtYXhSZWN0UG9zaXRpb25bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBub3dSZWN0UG9zaXRpb25bMV0gPSBtYXhSZWN0UG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdGhhdC5yZWN0LmF0dHIoJ3Bvc2l0aW9uJywgbm93UmVjdFBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlc3VsdFN1Y2Nlc3MoKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpc0xhcCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0LnJlY3QuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFwicmdiYSgwLCAwLCAwLCAxKVwiXHJcbiAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzdWx0RmFsc2UoKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpc0xhcCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0LnJlY3QuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFwicmdiYSgyNTUsIDAsIDAsIDEpXCJcclxuICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICBmdW5jdGlvbiBpc0NoaWxkKG5vZGUsIHN1Yk5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgIGlmIChzdWJOb2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJOb2RlLnBhcmVudC5pZCA9PT0gbm9kZS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNDaGlsZChub2RlLCBzdWJOb2RlLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lck5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICBpZiAoZG9tLnR5cGUgPT09IFwiZHJhZ1NlbGVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgc3ViTm9kZSA9IHRoYXQuX3Bvc0luV2hpY2hTdWJwcm9jZXNzKHRoYXQuc3ViUHJvY2Vzc05vZGUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB4OiBub3dEcmFnUmVjdFBvc2l0aW9uWzBdIC0gZHJhZ1JlY3Qud2lkdGgvMixcclxuICAgICAgICAgICAgICAgICAgICAgICB5OiBub3dEcmFnUmVjdFBvc2l0aW9uWzFdIC0gZHJhZ1JlY3QuaGVpZ2h0LzIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGRyYWdSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZHJhZ1JlY3QuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRDb250YWluZXIgPSB0aGF0Ll9KdWRnZU5vZGVJbldoaWNoU3ViUHJvY2Vzcyh0aGF0LnN1YlByb2Nlc3NOb2RlLCB7eDogZS5ldmVudC5vZmZzZXRYLCB5OiBlLmV2ZW50Lm9mZnNldFl9KTtcclxuICAgICAgICAgICAgICAgICAgIGlmICghc3RhcnRDb250YWluZXIgJiYgdGFyZ2V0Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0RmFsc2UoKTtcclxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgdGhhdC5yZXNldEJhY2tncm91bmQoKTtcclxuICAgICAgICAgICAgICAgICAgIGlmIChzdGFydENvbnRhaW5lciAmJiAhc3ViTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIC8v5pS55Y+Y55S75biD6aKc6ImyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXJOb2RlID0gJ3pyJztcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNldEJhY2tncm91bmQoXCIjYjZlM2Y1XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFsbE5vZGVzLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnBtbi5pc1N1YlByb2Nlc3Modik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViTm9kZSAmJiBzdWJOb2RlLmlkID09PSBpdGVtLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lck5vZGUgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGFydENvbnRhaW5lciB8fCAoc3RhcnRDb250YWluZXIgJiYgc3RhcnRDb250YWluZXIuaWQgIT09IGl0ZW0uaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYubmFtZSA9PT0gXCJzdWJwcm9jZXNzLXJlY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2LmluaXRTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbml0RmlsbCA9IHYuc3R5bGUuZmlsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LmF0dHIoXCJpbml0U3R5bGVcIiwgaW5pdEZpbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6JyNiNmUzZjUnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodi5uYW1lID09PSBcInN1YnByb2Nlc3MtcmVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdi5pbml0U3R5bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbml0RmlsbCA9IHYuc3R5bGUuZmlsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuYXR0cihcImluaXRTdHlsZVwiLCBpbml0RmlsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdi5pbml0U3R5bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IHYuaW5pdFN0eWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgR3VpZGVsaW5lcy5qdWRnZUFsaWdubWVudCh0aGF0LnNlbGVjdGVkTm9kZSwgbm93UmVjdFBvc2l0aW9uLCBkb21BcnJheSwgdGhhdC5nZXRXaWR0aCgpLCB0aGF0LmdldEhlaWdodCgpKTtcclxuICAgICAgICAgICAgICAgdmFyIHRhcmdldFN1YiA9IHRoYXQuX0p1ZGdlTm9kZUluV2hpY2hTdWJQcm9jZXNzKHRoYXQuc3ViUHJvY2Vzc05vZGUsIHt4OiBub3dSZWN0UG9zaXRpb25bMF0sIHk6IG5vd1JlY3RQb3NpdGlvblsxXX0pO1xyXG4gICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMCwgbGVuID0gdGhhdC5hbGxOb2Rlcy5sZW5ndGg7IGwgPCBsZW47IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIHBvc1gsIHBvc1k7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSB0aGF0LmFsbE5vZGVzW2xdO1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIHJlY3REb20gPSBjdXJyZW50Tm9kZS5nZXRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgY2FuQ29tcGFyZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICByZXN1bHRTdWNjZXNzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgaWYgKChjdXJyZW50Tm9kZS5pZCA9PT0gZG9tLmlkKSB8fCAoQnBtbi5pc1N1YlByb2Nlc3MoZG9tKSAmJiBpc0NoaWxkKGRvbSwgY3VycmVudE5vZGUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgdGhhdC5yZXNldEJhY2tncm91bmQoKTtcclxuICAgICAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU3ViUHJvY2VzcyhjdXJyZW50Tm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYubmFtZSA9PT0gXCJzdWJwcm9jZXNzLXJlY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2LmluaXRTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbml0RmlsbCA9IHYuc3R5bGUuZmlsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LmF0dHIoXCJpbml0U3R5bGVcIiwgaW5pdEZpbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdi5pbml0U3R5bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiB2LmluaXRTdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFN1YiAmJiB0YXJnZXRTdWIuaWQgPT09IGN1cnJlbnROb2RlLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29udGFpbmVyTm9kZSA9IGN1cnJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbS5wYXJlbnQgfHwgKGRvbS5wYXJlbnQgJiYgdGFyZ2V0U3ViLmlkICE9PSBkb20ucGFyZW50LmlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYubmFtZSA9PT0gXCJzdWJwcm9jZXNzLXJlY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXYuaW5pdFN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdEZpbGwgPSB2LnN0eWxlLmZpbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LmF0dHIoXCJpbml0U3R5bGVcIiwgaW5pdEZpbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6JyNiNmUzZjUnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgY2FuQ29tcGFyZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgaWYgKGRvbS5wYXJlbnQgJiYgIXRhcmdldFN1Yikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIC8v5pS55Y+Y55S75biD6aKc6ImyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXJOb2RlID0gJ3pyJztcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNldEJhY2tncm91bmQoXCIjYjZlM2Y1XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2VzcyhjdXJyZW50Tm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcG9zWCA9IHJlY3REb20ueCArIEJwbW5VdGlsLnBhcmVudFgoY3VycmVudE5vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICBwb3NZID0gcmVjdERvbS55ICsgQnBtblV0aWwucGFyZW50WShjdXJyZW50Tm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBwb3NYID0gcmVjdERvbS54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHBvc1kgPSByZWN0RG9tLnk7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoY2FuQ29tcGFyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFwZUxpc3Qud2lkdGggPiByZWN0RG9tLndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v56e75Yqo55qE5L2N572uIOWHj+WOu+W9k+WJjeiKgueCueeahOS9jee9riDlsI/kuo7mi5bmi73oioLngrnpq5jluqblj4rlrr3luqbkuIDljYrvvIwg5YiZ5pyJ6YeN5Y+gIOagh+e6olxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGVMaXN0LmhlaWdodCA+IHJlY3REb20uaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobm93UmVjdFBvc2l0aW9uWzBdIC0gcG9zWCkgPCAocmVjdERvbS53aWR0aCtzaGFwZUxpc3Qud2lkdGgpIC8gMiAmJiBNYXRoLmFicyhub3dSZWN0UG9zaXRpb25bMV0gLSBwb3NZKSA8IChyZWN0RG9tLmhlaWdodCtzaGFwZUxpc3QuaGVpZ2h0KSAvIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRGYWxzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobm93UmVjdFBvc2l0aW9uWzBdIC0gcG9zWCkgPCAocmVjdERvbS53aWR0aCtzaGFwZUxpc3Qud2lkdGgpIC8gMiAmJiBNYXRoLmFicyhub3dSZWN0UG9zaXRpb25bMV0gLSBwb3NZKSA8IChyZWN0RG9tLmhlaWdodCtzaGFwZUxpc3QuaGVpZ2h0KSAvIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRGYWxzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGVMaXN0LmhlaWdodCA+IHJlY3REb20uaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobm93UmVjdFBvc2l0aW9uWzBdIC0gcG9zWCkgPCAocmVjdERvbS53aWR0aCtzaGFwZUxpc3Qud2lkdGgpIC8gMiAmJiBNYXRoLmFicyhub3dSZWN0UG9zaXRpb25bMV0gLSBwb3NZKSA8IChyZWN0RG9tLmhlaWdodCtzaGFwZUxpc3QuaGVpZ2h0KSAvIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRGYWxzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobm93UmVjdFBvc2l0aW9uWzBdIC0gcG9zWCkgPCAocmVjdERvbS53aWR0aCtzaGFwZUxpc3Qud2lkdGgpIC8gMiAmJiBNYXRoLmFicyhub3dSZWN0UG9zaXRpb25bMV0gLSBwb3NZKSA8IChyZWN0RG9tLmhlaWdodCtzaGFwZUxpc3QuaGVpZ2h0KSAvIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRGYWxzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgIC8v5Yik5pat5LqL5Lu26IqC54K55piv5ZCm5Y+v5Lul5L6d6ZmE77yM5Y+v5Lul5L6d6ZmE5pi+56S657u/5qGGXHJcbiAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU2xvdEV2ZW50KGRvbSkpIHtcclxuICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmFsbE5vZGVzW2ldLmlzQ2FuU2xvdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5hbGxOb2Rlc1tpXS5zbG90ICYmIHRoYXQuYWxsTm9kZXNbaV0uc2xvdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHRoYXQuYWxsTm9kZXNbaV0uc2xvdC5sZW5ndGg7IGErKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90UG9zaXRpb24gPSBbdGhhdC5hbGxOb2Rlc1tpXS5zbG90W2FdLnBvc2l0aW9uWzBdICsgdGhhdC5hbGxOb2Rlc1tpXS5wb3NpdGlvblswXSwgdGhhdC5hbGxOb2Rlc1tpXS5zbG90W2FdLnBvc2l0aW9uWzFdICsgdGhhdC5hbGxOb2Rlc1tpXS5wb3NpdGlvblsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vd1JlY3RQb3NpdGlvblswXSA9PSBzbG90UG9zaXRpb25bMF0gJiYgbm93UmVjdFBvc2l0aW9uWzFdID09IHNsb3RQb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnJlY3QuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogXCJyZ2JhKDAsIDI1NSwgMCwgMSlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMYXAgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgIGZ1bmN0aW9uIGVuZERyYWcoKSB7XHJcbiAgICAgICAgICAgICAgIHRoYXQuX3pyLm9mZignbW91c2Vtb3ZlJywgbW92ZUZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgICAgdGhhdC5fenIub2ZmKCdtb3VzZXVwJywgdXBGdW5jdGlvbik7XHJcbiAgICAgICAgICAgICAgIHRoYXQuX3pyLm9mZignZ2xvYmFsb3V0JywgdXBGdW5jdGlvbik7XHJcbiAgICAgICAgICAgICAgIGlmIChkb20ucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICBkb20ucGFyZW50Lm9mZihcImdsb2JhbG91dFwiLCB1cEZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB0aGF0LnJlY3QuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICBHdWlkZWxpbmVzLnJlc2V0TGluZXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgIC8v5aSE55CG5Y2V5Ye75a2Q6IqC54K55YaF55qE5p+Q5LiA5Liq6IqC54K55pe277yM5b2T5YmN55qE5a655Zmo6IqC54K55LiN5Li66K+l5a2Q6IqC54K555qEYnVn77yI5Li6bnVsbO+8iVxyXG4gICAgICAgICAgICAgICBpZiAoIXRoYXQuY29udGFpbmVyTm9kZSAmJiBkb20ucGFyZW50ICYmIEJwbW4uaXNTdWJQcm9jZXNzKGRvbS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lck5vZGUgPSBkb20ucGFyZW50O1xyXG4gICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoYXQuY29udGFpbmVyTm9kZSA9PT0gJ3pyJykge1xyXG4gICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXJOb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB2YXIgcmVtb3ZlTGluZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICB2YXIgZ3JvdXBOb2RlUG9zaXRpb25YID0gbnVsbCwgZ3JvdXBOb2RlUG9zaXRpb25ZID0gbnVsbDtcclxuICAgICAgICAgICAgICAgaWYgKGlzTGFwID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmNvbnRhaW5lck5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAvLyDlsIblvZPliY3oioLngrnlkozniLboioLngrnmkYbmraPvvIzlho3orqHnrpflvZPliY3oioLngrnliLDniLboioLngrnkuKTovrnnmoTlnoLnm7Tot53nprtcclxuICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50UmVjdCA9IHRoYXQuY2FsY3VsYXRlUmVjdCh0aGF0LmNvbnRhaW5lck5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IC1wYXJlbnRSZWN0LnJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IG5vd1JlY3RQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocm90YXRpb24pID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQb3NpdGlvbiA9IHV0aWwuY2FsY3VsYXRlUG9pbnRzKG5vd1JlY3RQb3NpdGlvbiwgcGFyZW50UmVjdCwgcm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICBncm91cE5vZGVQb3NpdGlvblggPSBuZXdQb3NpdGlvblswXSAtIHBhcmVudFJlY3QuYm91bmRpbmdSZWN0Lng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBOb2RlUG9zaXRpb25ZID0gbmV3UG9zaXRpb25bMV0gLSBwYXJlbnRSZWN0LmJvdW5kaW5nUmVjdC55O1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgdmFyIHBvc1ggPSB0eXBlb2YgZ3JvdXBOb2RlUG9zaXRpb25YID09PSAnbnVtYmVyJyA/IGdyb3VwTm9kZVBvc2l0aW9uWCA6IG5vd1JlY3RQb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgIHZhciBwb3NZID0gdHlwZW9mIGdyb3VwTm9kZVBvc2l0aW9uWSA9PT0gJ251bWJlcicgPyBncm91cE5vZGVQb3NpdGlvblkgOiBub3dSZWN0UG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgICAgICAgICBkb20uc2V0UG9zaXRpb24ocG9zWCwgcG9zWSk7XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVNsb3RFdmVudChkb20pO1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuY29udGFpbmVyTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChkb20ucGFyZW50ICYmIHRoYXQuY29udGFpbmVyTm9kZS5pZCAhPT0gZG9tLnBhcmVudC5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkb20ucGFyZW50LnJlbW92ZShkb20pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lck5vZGUuYWRkKGRvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWRvbS5wYXJlbnQgJiYgZG9tLnR5cGUgIT09IFwiZHJhZ1NlbGVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3pyLnJlbW92ZShkb20pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lck5vZGUuYWRkKGRvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoYXQub3ZlcmxhcEFycmF5Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tLmlkID09IHRoYXQub3ZlcmxhcEFycmF5W2pdLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5vdmVybGFwQXJyYXkuc3BsaWNlKGosIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkb20udHlwZSA9PT0gXCJkcmFnU2VsZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhhdC5kcmFnU2VsZWN0UmVjdC5jaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYubmFtZSAhPT0gXCJHUk9VUF9SRUNUX05BTUVcIiAmJiAhQnBtbi5pc0Zsb3codik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSB0aGF0LmRyYWdTZWxlY3RSZWN0LmNoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5uYW1lICE9PSBcIkdST1VQX1JFQ1RfTkFNRVwiICYmIEJwbW4uaXNGbG93KHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnROb2RlID0gbm9kZXMuZmluZChmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuaWQgPT09IHYuc3RhcnROb2RlLmlkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmROb2RlID0gbm9kZXMuZmluZChmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuaWQgPT09IHYuZW5kTm9kZS5pZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWZFeGlzdCA9IGxpbmVzLmZpbmRJbmRleChmdW5jdGlvbihsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmUuaWQgPT09IHYuaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzdGFydE5vZGUgfHwgZW5kTm9kZSkgJiYgaWZFeGlzdCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlbW92ZUxpbmUodiwgdi5wYXJlbnQgPyB2LnBhcmVudCA6IHRoYXQuX3pyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZHJhZ1NlbGVjdFJlY3QucmVtb3ZlKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXJOb2RlLmFkZChsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHN0YXJ0Q29udGFpbmVyICYmIHN0YXJ0Q29udGFpbmVyLmlkID09PSB0aGF0LmNvbnRhaW5lck5vZGUuaWQgPyBkZ1JlY3Qud2lkdGggOiBkcmFnUmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHN0YXJ0Q29udGFpbmVyICYmIHN0YXJ0Q29udGFpbmVyLmlkID09PSB0aGF0LmNvbnRhaW5lck5vZGUuaWQgPyBkZ1JlY3QuaGVpZ2h0IDogZHJhZ1JlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVYID0gaXRlbS5nZXRSZWN0KCkueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlWSA9IGl0ZW0uZ2V0UmVjdCgpLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm93WCwgbm93WTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydENvbnRhaW5lciAmJiBzdGFydENvbnRhaW5lci5pZCA9PT0gdGhhdC5jb250YWluZXJOb2RlLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93WCA9IG5vd1JlY3RQb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dZID0gbm93UmVjdFBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dYID0gbm93RHJhZ1JlY3RQb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dZID0gbm93RHJhZ1JlY3RQb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRYID0gbm93WCAtIEJwbW5VdGlsLnBhcmVudFgodGhhdC5jb250YWluZXJOb2RlKSAtIHdpZHRoLzI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WSA9IG5vd1kgLSBCcG1uVXRpbC5wYXJlbnRZKHRoYXQuY29udGFpbmVyTm9kZSkgLSBoZWlnaHQvMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3N4ID0gbm9kZVggKyBvZmZzZXRYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvc3kgPSBub2RlWSArIG9mZnNldFk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zbG90RXZlbnQgJiYgaXRlbS5zbG90RXZlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgaXRlbS5zbG90RXZlbnQubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RFdmVudFBvc2l0aW9uMiA9IFtpdGVtLnNsb3RFdmVudFtuXS5wb3NpdGlvblswXSArIHBvc3ggLSB6clV0aWwuY2xvbmUoaXRlbS5wb3NpdGlvblswXSkgLSBpdGVtLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC8gMiwgaXRlbS5zbG90RXZlbnRbbl0ucG9zaXRpb25bMV0gKyBwb3N5IC0genJVdGlsLmNsb25lKGl0ZW0ucG9zaXRpb25bMV0pIC0gaXRlbS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zbG90RXZlbnRbbl0uYXR0cihcInBvc2l0aW9uXCIsIHNsb3RFdmVudFBvc2l0aW9uMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUoaXRlbS5zbG90RXZlbnRbbl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZHJhZ1NlbGVjdFJlY3QucmVtb3ZlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXJOb2RlLmFkZChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0UG9zaXRpb24ocG9zeCwgcG9zeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5vcmlnaW5QYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm9yaWdpblBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IHRoYXQub3ZlcmxhcEFycmF5Lmxlbmd0aDsgbSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uaWQgPT0gdGhhdC5vdmVybGFwQXJyYXlbbV0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5vdmVybGFwQXJyYXkuc3BsaWNlKG0sIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdGhhdC5kb21BcnJheS5sZW5ndGg7IG4rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmlkID09IHRoYXQuZG9tQXJyYXlbbl0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5kb21BcnJheVtuXS5wb3NpdGlvbiA9IFtub2RlWCArIChub3dEcmFnUmVjdFBvc2l0aW9uWzBdIC0gd2lkdGgvMiksIG5vZGVZICsgKG5vd0RyYWdSZWN0UG9zaXRpb25bMV0gLSBoZWlnaHQvMildO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUoaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5kcmFnU2VsZWN0UmVjdC5vZmYoXCJtb3VzZWRvd25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3pyLnJlbW92ZSh0aGF0LmRyYWdTZWxlY3RSZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb250YWluZXJOb2RlLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodi5uYW1lID09PSBcInN1YnByb2Nlc3MtcmVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXYuaW5pdFN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRGaWxsID0gdi5zdHlsZS5maWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuYXR0cihcImluaXRTdHlsZVwiLCBpbml0RmlsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiB2LmluaXRTdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IHYuaW5pdFN0eWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkb20ucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZG9tLnBhcmVudC5yZW1vdmUoZG9tKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll96ci5hZGQoZG9tKTtcclxuICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaW5lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUJwbW4uaXNTbG90RXZlbnQoZG9tKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm92ZXJsYXBBcnJheS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBkb20uaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogW25vd1JlY3RQb3NpdGlvblswXSwgbm93UmVjdFBvc2l0aW9uWzFdXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkb20uZ2V0UmVjdCgpLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBkb20uZ2V0UmVjdCgpLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoZG9tLnR5cGUgIT09IFwiZHJhZ1NlbGVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCB0aGF0LmRvbUFycmF5Lmxlbmd0aDsgYisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb20uaWQgPT0gdGhhdC5kb21BcnJheVtiXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5kb21BcnJheVtiXS5wb3NpdGlvbiA9IFtub3dSZWN0UG9zaXRpb25bMF0sIG5vd1JlY3RQb3NpdGlvblsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGF0LmNvbnRhaW5lck5vZGUgJiYgIWRvbS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGF0Lm92ZXJsYXBBcnJheS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbS5pZCA9PSB0aGF0Lm92ZXJsYXBBcnJheVtqXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub3ZlcmxhcEFycmF5W2pdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogZG9tLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogW25vd1JlY3RQb3NpdGlvblswXSwgbm93UmVjdFBvc2l0aW9uWzFdXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGRvbS5nZXRSZWN0KCkud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZG9tLmdldFJlY3QoKS5oZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhhdC5jb250YWluZXJOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcyA9IHRoYXQuZHJhZ1NlbGVjdFJlY3QuY2hpbGRyZW4oKS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYubmFtZSAhPT0gXCJHUk9VUF9SRUNUX05BTUVcIiAmJiAhQnBtbi5pc0Zsb3codik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gdGhhdC5kcmFnU2VsZWN0UmVjdC5jaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5uYW1lICE9PSBcIkdST1VQX1JFQ1RfTkFNRVwiICYmIEJwbW4uaXNGbG93KHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydE5vZGUgPSBjaGlsZHMuZmluZChmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5pZCA9PT0gdi5zdGFydE5vZGUuaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmROb2RlID0gY2hpbGRzLmZpbmQoZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuaWQgPT09IHYuZW5kTm9kZS5pZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlmRXhpc3QgPSBsaW5lcy5maW5kSW5kZXgoZnVuY3Rpb24obGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmUuaWQgPT09IHYuaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoc3RhcnROb2RlIHx8IGVuZE5vZGUpICYmIGlmRXhpc3QgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlbW92ZUxpbmUodiwgdi5wYXJlbnQgPyB2LnBhcmVudCA6IHRoYXQuX3pyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0V2lkdGggPSB0aGF0LmRyYWdTZWxlY3RSZWN0Lm9wdGlvbnMuc2hhcGUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3RIZWlnaHQgPSB0aGF0LmRyYWdTZWxlY3RSZWN0Lm9wdGlvbnMuc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gY2hpbGRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IG5vZGUuZ2V0UmVjdCgpLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gbm9kZS5nZXRSZWN0KCkueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCB0aGF0LmRvbUFycmF5Lmxlbmd0aDsgcCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PSB0aGF0LmRvbUFycmF5W3BdLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5kb21BcnJheVtwXS5wb3NpdGlvbiA9IFt4ICsgKG5vd1JlY3RQb3NpdGlvblswXSAtIHJlY3RXaWR0aC8yKSwgeSArIChub3dSZWN0UG9zaXRpb25bMV0gLSByZWN0SGVpZ2h0LzIpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBxID0gMDsgcSA8IHRoYXQub3ZlcmxhcEFycmF5Lmxlbmd0aDsgcSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PSB0aGF0Lm92ZXJsYXBBcnJheVtxXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub3ZlcmxhcEFycmF5W3FdLnBvc2l0aW9uID0gW3ggKyAobm93UmVjdFBvc2l0aW9uWzBdIC0gcmVjdFdpZHRoLzIpLCB5ICsgKG5vd1JlY3RQb3NpdGlvblsxXSAtIHJlY3RIZWlnaHQvMildO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9yZWxlYXNlU2VsZWN0Tm9kZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhhdC5jb250YWluZXJOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lck5vZGUuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYubmFtZSA9PT0gXCJzdWJwcm9jZXNzLXJlY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXYuaW5pdFN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdEZpbGwgPSB2LnN0eWxlLmZpbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LmF0dHIoXCJpbml0U3R5bGVcIiwgaW5pdEZpbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IHYuaW5pdFN0eWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiB2LmluaXRTdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB0aGF0LnJlc2V0QmFja2dyb3VuZCgpO1xyXG4gICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lck5vZGUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgaWYgKGlzTW92ZSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlTGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycy5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYuc3RhcnROb2RlLmlkID09PSBkb20uaWQgfHwgdi5lbmROb2RlLmlkID09PSBkb20uaWRcclxuICAgICAgICAgICAgICAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIucmVtb3ZlTGluZShpdGVtLCBpdGVtLnBhcmVudCA/IGl0ZW0ucGFyZW50IDogdGhhdC5fenIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUoZG9tKTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIHRoYXQubm9kZUNsaWNrSGFuZGxlcihkb20pO1xyXG4gICAgICAgICAgICAgICAgICAgdGhhdC5zdGVwQ291bnRlcigpO1xyXG4gICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAvL+WwhuS6i+S7tuiKgueCueS4jnRhc2voioLngrnnu5HlrprmiJbop6Pnu5FcclxuICAgICAgICAgICAgICAgaWYgKEJwbW4uaXNTbG90RXZlbnQoZG9tKSAmJiBpc0xhcCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgbmV3UmVjdFBvc2l0aW9uID0gW107XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoZG9tLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU3ViUHJvY2Vzcyhkb20ucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdSZWN0UG9zaXRpb25bMF0gPSBub3dSZWN0UG9zaXRpb25bMF0gLSBCcG1uVXRpbC5wYXJlbnRYKGRvbS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdSZWN0UG9zaXRpb25bMV0gPSBub3dSZWN0UG9zaXRpb25bMV0gLSBCcG1uVXRpbC5wYXJlbnRZKGRvbS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgbmV3UmVjdFBvc2l0aW9uID0gbm93UmVjdFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0LmFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuYWxsTm9kZXNbaV0uaXNDYW5TbG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmFsbE5vZGVzW2ldLnNsb3QgJiYgdGhhdC5hbGxOb2Rlc1tpXS5zbG90Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmJpbmQgPSB0cnVlLCBleGlzdCA9IGZhbHNlLCBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgdGhhdC5hbGxOb2Rlc1tpXS5zbG90Lmxlbmd0aDsgYysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RQb3NpdGlvbiA9IFt0aGF0LmFsbE5vZGVzW2ldLnNsb3RbY10ucG9zaXRpb25bMF0gKyB0aGF0LmFsbE5vZGVzW2ldLnBvc2l0aW9uWzBdLCB0aGF0LmFsbE5vZGVzW2ldLnNsb3RbY10ucG9zaXRpb25bMV0gKyB0aGF0LmFsbE5vZGVzW2ldLnBvc2l0aW9uWzFdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm93UmVjdFBvc2l0aW9uWzBdID09IHNsb3RQb3NpdGlvblswXSAmJiBub3dSZWN0UG9zaXRpb25bMV0gPT0gc2xvdFBvc2l0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuYmluZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhhdC5hbGxOb2Rlc1tpXS5zbG90RXZlbnQubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tLmlkID09IHRoYXQuYWxsTm9kZXNbaV0uc2xvdEV2ZW50W2tdLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hbGxOb2Rlc1tpXS5zbG90RXZlbnRba10uaW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuYmluZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hbGxOb2Rlc1tpXS5zbG90RXZlbnQuc3BsaWNlKGssIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdCAmJiAhdW5iaW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g5qCH6K6wc2xvdEV2ZW505LiObm9kZSBzbG905pWw57uE5YWz6IGUXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hbGxOb2Rlc1tpXS5zbG90RXZlbnQucHVzaChkb20pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleGlzdCAmJiB1bmJpbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZG9tLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICB0aGlzLl96ci5vbihcIm1vdXNldXBcIiwgdXBGdW5jdGlvbik7XHJcbiAgICAgICAgICAgdGhpcy5fenIub24oXCJnbG9iYWxvdXRcIiwgdXBGdW5jdGlvbik7XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uc2V0QmFja2dyb3VuZCA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgICAgIHRoaXMuenJCYWNrZ3JvdW5kID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5fenIuZ2V0V2lkdGgoKSxcclxuICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5fenIuZ2V0SGVpZ2h0KClcclxuICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgIGZpbGw6IGNvbG9yXHJcbiAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICAgICB6OiAtMVxyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzLnpyQmFja2dyb3VuZCk7XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgZmlzaFRvcG9Qcm90by5yZXNldEJhY2tncm91bmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgaWYgKHRoaXMuenJCYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3pyLnJlbW92ZSh0aGlzLnpyQmFja2dyb3VuZCk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfVxyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5jcmVhdFRpcCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAvL+WIm+W7unRhc2vlhoXlrrnnmoTmj5DnpLpcclxuICAgICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgICAgIGdyb3VwLmlzU2hvdyA9IGZhbHNlO1xyXG4gICAgICAgICAgIHZhciBuYW1lID0gbm9kZS5tb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikgfHwgXCJcIjtcclxuICAgICAgICAgICB2YXIgc2hvd05hbWU7XHJcbiAgICAgICAgICAgaWYgKG5hbWUubGVuZ3RoID4gNjQpIHtcclxuICAgICAgICAgICAgICAgc2hvd05hbWUgPSBuYW1lLnN1YnN0cigwLCA2NCkgKyAnLi4nO1xyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgIHNob3dOYW1lID0gbmFtZTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgdmFyIHRleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgIHRleHQ6IHNob3dOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxNnB4IE1pY3Jvc29mdCBZYUhlaScsXHJcbiAgICAgICAgICAgICAgICAgICBmaWxsOiBcIiMwMDAwMDBcIixcclxuICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogXCJ0b3BcIiAvL+WeguebtOWvuem9kFxyXG4gICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICBwb3NpdGlvbjogWzIsIDBdLFxyXG4gICAgICAgICAgICAgICB6OiAyXHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgdGV4dC5uYW1lID0gXCJUZXh0XCI7XHJcbiAgICAgICAgICAgZ3JvdXAuYWRkKHRleHQpO1xyXG4gICAgICAgICAgIHZhciBQb2x5bGluZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHtcclxuICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgIGZpbGw6ICcjZjlmOWY5JyxcclxuICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJyNiYmJiYmInXHJcbiAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgIHo6IDFcclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICBQb2x5bGluZS5uYW1lID0gXCJQb2x5bGluZVwiO1xyXG4gICAgICAgICAgIGdyb3VwLmFkZChQb2x5bGluZSk7XHJcbiAgICAgICAgICAgLy8gdmFyIGdyb3VwUG9zaXRpb24gPSBbbm9kZS5wb3NpdGlvblswXSAtIG5vZGUuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGgvMiAtIChncm91cC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtIDYpLCBub2RlLnBvc2l0aW9uWzFdLSBub2RlLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAvIDIgLSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLSAzXTtcclxuICAgICAgICAgICAvLyBncm91cC5hdHRyKFwicG9zaXRpb25cIiwgZ3JvdXBQb3NpdGlvbik7XHJcbiAgICAgICAgICAgdGhpcy5fenIuYWRkKGdyb3VwKTtcclxuICAgICAgICAgICBub2RlLmFsYXJtID0gZ3JvdXA7XHJcbiAgICAgICAgICAgZ3JvdXAuaGlkZSgpO1xyXG4gICAgICAgICAgIGdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICAgICBjaGlsZC5oaWRlKCk7XHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uc3RlcENvdW50ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICB0aGlzLnN0ZXBKc29uLnNwbGljZSh0aGlzLnN0ZXAsIHRoaXMuc3RlcEpzb24ubGVuZ3RoIC0gKHRoaXMuc3RlcCkpO1xyXG4gICAgICAgICAgIHRoaXMuc3RlcCArPSAxO1xyXG4gICAgICAgICAgIHZhciBqc29uID0gdGhpcy50b0pzb24oKTtcclxuICAgICAgICAgICB0aGlzLnN0ZXBKc29uLnB1c2goSlNPTi5zdHJpbmdpZnkoanNvbikpO1xyXG4gICAgICAgfTtcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIOaUvuWkp+aIluiAhee8qeWwj1xyXG4gICAgICAgICogQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gdHlwZSDlvZPkuLrlrZfnrKbkuLLml7YgXCJlbmxhcmdlXCLmlL7lpKcgIFwibmFycm93aW5nXCLnvKnlsI8gIOW9k+S4uuaVsOWAvOaXtiDnvKnmlL7nmoTmr5TkvosgIOW7uuiurjAuMy0xLjdcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by56clNjYWxlID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICAgICBpZiAodHlwZSA9PSBcIm5hcnJvd2luZ1wiKSB7XHJcbiAgICAgICAgICAgICAgIHZhciB6b29tRGVsdGExID0gLTAuMDc7XHJcbiAgICAgICAgICAgICAgIHRoaXMuem9vbSh6b29tRGVsdGExLCB0aGlzLl96ci5nZXRXaWR0aCgpIC8gMiwgdGhpcy5fenIuZ2V0SGVpZ2h0KCkgLyAyKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJlbmxhcmdlXCIpIHtcclxuICAgICAgICAgICAgICAgdmFyIHpvb21EZWx0YSA9IDAuMDc7XHJcbiAgICAgICAgICAgICAgIHRoaXMuem9vbSh6b29tRGVsdGEsIHRoaXMuX3pyLmdldFdpZHRoKCkgLyAyLCB0aGlzLl96ci5nZXRIZWlnaHQoKSAvIDIpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBpZiAoIWlzTmFOKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmdyb3VwO1xyXG4gICAgICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgem9vbVNjYWxlID0gdHlwZSAvIHRoaXMuX3pvb207XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLl96b29tID0gdHlwZTtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMubm93Wm9vbSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNjYWxlKHRoaXMuX3pyLmdldFdpZHRoKCkgLyAyLCB0aGlzLl96ci5nZXRIZWlnaHQoKSAvIDIsIHpvb21TY2FsZSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by56b29tID0gZnVuY3Rpb24gKHpvb21EZWx0YSwgem9vbVgsIHpvb21ZKSB7XHJcbiAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICB2YXIgbmV3Wm9vbSA9IHRoaXMuX3pvb20gPSB0aGlzLl96b29tIHx8IDE7XHJcbiAgICAgICAgICAgICAgIG5ld1pvb20gKz0gem9vbURlbHRhO1xyXG4gICAgICAgICAgICAgICBuZXdab29tID0gTnVtYmVyKG5ld1pvb20udG9GaXhlZCgyKSk7XHJcbiAgICAgICAgICAgICAgIHZhciB6b29tU2NhbGUgPSBuZXdab29tIC8gdGhpcy5fem9vbTtcclxuICAgICAgICAgICAgICAgaWYgKG5ld1pvb20gPiAxLjcgfHwgbmV3Wm9vbSA8IDAuMykge1xyXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3pvb20gPSBuZXdab29tO1xyXG4gICAgICAgICAgICAgICB0aGlzLm5vd1pvb20gPSBuZXdab29tO1xyXG4gICAgICAgICAgICAgICB0aGlzLnNldFNjYWxlKHpvb21YLCB6b29tWSwgem9vbVNjYWxlKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqL1xyXG4gICAgICAgZmlzaFRvcG9Qcm90by5zZXRTY2FsZSA9IGZ1bmN0aW9uICh6b29tWCwgem9vbVksIHpvb21TY2FsZSkge1xyXG4gICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmZpbmRFbGVtZW50cyhmdW5jdGlvbihlKXtyZXR1cm4gdHJ1ZTt9KTtcclxuICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5ncm91cDtcclxuICAgICAgICAgICBub2Rlcy5wdXNoKHRhcmdldCk7XHJcbiAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICB2YXIgcG9zID0gdi5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gdi5zY2FsZTtcclxuICAgICAgICAgICAgICAgc2NhbGVbMF0gKj0gem9vbVNjYWxlO1xyXG4gICAgICAgICAgICAgICBzY2FsZVsxXSAqPSB6b29tU2NhbGU7XHJcbiAgICAgICAgICAgICAgIHYuYXR0cihcInNjYWxlXCIsIFtzY2FsZVswXSwgc2NhbGVbMV1dKTtcclxuICAgICAgICAgICB9KTtcclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICog6IqC54K55LiK5paH5a2X57yW6L6RXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8ubm9kZUVkaXQgPSBmdW5jdGlvbiAodGhpc05vZGUpIHtcclxuICAgICAgICAgICB2YXIgbGluZVRleHQgPSB0aGlzTm9kZS5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICAgICBpZiAodGhpcy5mb3JiaWRFZGl0ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgdmFyIE9GRlNFVF9NVUxUSVBMRSA9IDAuNTU7IC8v5paH5pys5qGG5a695bqm44CB6auY5bqm55qE5YGP56e757O75pWwXHJcbiAgICAgICAgICAgdmFyIGlzTm90U2V0VGV4dCA9IGZhbHNlO1xyXG4gICAgICAgICAgIHZhciBub2RlUmVjdCA9IHV0aWwuZ2V0UmVjdCh0aGlzTm9kZSk7XHJcbiAgICAgICAgICAgdmFyIHRleHRhcmVhID0gdGhpcy5jcmVhdGVUZXh0QXJlYSgpO1xyXG4gICAgICAgICAgIHZhciBub2RlVGV4dCA9IHpyVXRpbC5jbG9uZSh0aGlzTm9kZS5tb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikpO1xyXG4gICAgICAgICAgIHZhciB0ZXh0UmVjdCA9ICh0aGlzTm9kZSBpbnN0YW5jZW9mIENvbm5lY3RvcikgJiYgbGluZVRleHQgPyB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QobGluZVRleHQuc3R5bGUudGV4dCwgXCIxMnB4XCIpIDogdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KG5vZGVUZXh0LCBcIjEycHhcIik7XHJcbiAgICAgICAgICAgdmFyIHRleHRhcmVhTWluV2lkdGggPSAwLjYgKiBub2RlUmVjdC53aWR0aDtcclxuICAgICAgICAgICB2YXIgdGV4dGFyZWFXaWR0aCA9ICh0ZXh0UmVjdC53aWR0aCA9PSAwID8gdGV4dGFyZWFNaW5XaWR0aCA6ICgodGhpc05vZGUgaW5zdGFuY2VvZiBDb25uZWN0b3IpICYmICh0ZXh0UmVjdC53aWR0aCA+IDYwKSA/IDEuMiAqIHRleHRSZWN0LndpZHRoIDogMiAqIHRleHRSZWN0LndpZHRoKSkgKiB0aGlzLm5vd1pvb207XHJcbiAgICAgICAgICAgdmFyIHRleHRhcmVhSGVpZ2h0ID0gKDIgKiB0ZXh0UmVjdC5oZWlnaHQgfHwgMjQpICogdGhpcy5ub3dab29tO1xyXG4gICAgICAgICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gdGV4dGFyZWFXaWR0aCArIFwicHhcIjtcclxuICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSB0ZXh0YXJlYUhlaWdodCArIFwicHhcIjtcclxuICAgICAgICAgICB2YXIgdGV4dGFyZWFNYXhXaWR0aCA9IDEuMiAqIG5vZGVSZWN0LndpZHRoICogdGhpcy5ub3dab29tO1xyXG4gICAgICAgICAgIHRleHRhcmVhLnN0eWxlLm1heFdpZHRoID0gdGV4dGFyZWFNYXhXaWR0aCArIFwicHhcIjtcclxuICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5saW5lSGVpZ2h0ID0gKDEuMiAqIHRleHRSZWN0LmxpbmVIZWlnaHQgfHwgMTQuNCkgKyBcInB4XCI7XHJcbiAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuYm9yZGVyID0gXCIxcHggZGFzaGVkICMyZTJlMmVcIjtcclxuICAgICAgICAgICB0ZXh0YXJlYS5pbm5lckhUTUwgPSB0aGlzTm9kZS5tb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIik7XHJcbiAgICAgICAgICAgdGhpcy5zZXRTaGFwZU1vZGVsKHRoaXNOb2RlLCB7cHJvcGVydGllczoge25hbWU6IFwiXCJ9fSk7XHJcbiAgICAgICAgICAgdGhpcy5fZG9tLmFwcGVuZENoaWxkKHRleHRhcmVhKTtcclxuICAgICAgICAgICB0aGlzLl9kb20uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XHJcbiAgICAgICAgICAgdmFyIG9mZmVzdEkgPSAxO1xyXG4gICAgICAgICAgIHZhciBvZmZlc3RQID0gMDtcclxuICAgICAgICAgICB2YXIgcG9zWCA9IDAsIHBvc1kgPSAwO1xyXG4gICAgICAgICAgIGlmICh0aGlzTm9kZSBpbnN0YW5jZW9mIENvbm5lY3Rvcikgey8v6L+e57q/XHJcbiAgICAgICAgICAgICAgIGlmICh0aGlzTm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3ModGhpc05vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgcG9zWCA9IEJwbW5VdGlsLnBhcmVudFgodGhpc05vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgIHBvc1kgPSBCcG1uVXRpbC5wYXJlbnRZKHRoaXNOb2RlLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgaWYgKGxpbmVUZXh0KSB7IC8v5pyJ5paH5pys5pe2XHJcbiAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS50b3AgPSAobGluZVRleHQucG9zaXRpb25bMV0gKyBwb3NZICsgdGV4dFJlY3QuaGVpZ2h0IC8gMiAtIHRleHRhcmVhSGVpZ2h0IC8gMikgKiB0aGlzLm5vd1pvb20gKyB0aGlzLmdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgLnBvc2l0aW9uWzFdICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUubGVmdCA9IChsaW5lVGV4dC5wb3NpdGlvblswXSArIHBvc1ggLSB0ZXh0YXJlYVdpZHRoIC8gMikgKiB0aGlzLm5vd1pvb20gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAucG9zaXRpb25bMF0gKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgbGluZU1pZGRsZVBvcyA9IHRoaXNOb2RlLm1pZGRsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUudG9wID0gKGxpbmVNaWRkbGVQb3NbMV0gKyBwb3NZICsgdGV4dFJlY3QuaGVpZ2h0IC8gMiAtIHRleHRhcmVhSGVpZ2h0IC8gMikgKiB0aGlzLm5vd1pvb20gKyB0aGlzLmdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgLnBvc2l0aW9uWzFdICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUubGVmdCA9IChsaW5lTWlkZGxlUG9zWzBdICsgcG9zWCAtIHRleHRhcmVhV2lkdGggLyAyKSAqIHRoaXMubm93Wm9vbSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cC5wb3NpdGlvblswXSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH0gZWxzZSB7IC8v6IqC54K5XHJcbiAgICAgICAgICAgICAgIGlmICh0aGlzTm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3ModGhpc05vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgcG9zWCA9IG5vZGVSZWN0LnggKyBCcG1uVXRpbC5wYXJlbnRYKHRoaXNOb2RlLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICBwb3NZID0gbm9kZVJlY3QueSArIEJwbW5VdGlsLnBhcmVudFkodGhpc05vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgIHBvc1ggPSBub2RlUmVjdC54O1xyXG4gICAgICAgICAgICAgICAgICAgcG9zWSA9IG5vZGVSZWN0Lnk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUudG9wID0gKHBvc1kgLSB0ZXh0YXJlYUhlaWdodCAvIDIgKyBvZmZlc3RQICogKG5vZGVSZWN0LmhlaWdodCAtIHRleHRSZWN0LmhlaWdodCAvXHJcbiAgICAgICAgICAgICAgICAgICAyKSkgKiB0aGlzLm5vd1pvb20gKyB0aGlzLmdyb3VwLnBvc2l0aW9uWzFdICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5sZWZ0ID0gKHBvc1ggLSBvZmZlc3RJICogKHRleHRhcmVhV2lkdGggPCB0ZXh0YXJlYU1heFdpZHRoID8gdGV4dGFyZWFXaWR0aCA6IHRleHRhcmVhTWF4V2lkdGgpIC8gMikgKiB0aGlzLm5vd1pvb20gK1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cC5wb3NpdGlvblswXSArIFwicHhcIjtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgdGV4dGFyZWEuZm9jdXMoKTtcclxuICAgICAgICAgICB0ZXh0YXJlYS5zZWxlY3QoKTtcclxuICAgICAgICAgICB0ZXh0YXJlYS5vbmtleXVwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IGtleUNvZGUuRVNDQVBFKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpc05vdFNldFRleHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgdGV4dGFyZWEuYmx1cigpO1xyXG4gICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRleHRhcmVhLnZhbHVlLCBcIjEycHhcIik7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0YXJlYVJlc2l6ZSh0ZXh0UmVjdCwgdGV4dGFyZWEsIHRleHRhcmVhLnN0eWxlLm1heFdpZHRoKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgdGV4dGFyZWEub25ibHVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgIGlmICghaXNOb3RTZXRUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuaGFuZGxlV3JhcCh0ZXh0YXJlYS52YWx1ZSwgdGV4dGFyZWEuc3R5bGUubWF4V2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTaGFwZU1vZGVsKHRoaXNOb2RlLCB7cHJvcGVydGllczoge25hbWU6IHRleHR9fSk7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCdhZnRlckVkaXROb2RlJywge3RhcmdldDogdGhpc05vZGV9KTtcclxuICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2hhcGVNb2RlbCh0aGlzTm9kZSwge3Byb3BlcnRpZXM6IHtuYW1lOiBub2RlVGV4dH19KTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB0ZXh0YXJlYS5yZW1vdmUoKTtcclxuICAgICAgICAgICB9LmJpbmQodGhpcyk7XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqIOWIm+W7uuaWh+acrOWfn1xyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLmNyZWF0ZVRleHRBcmVhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgIHZhciB0ZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcclxuICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5wYWRkaW5nID0gXCI2cHhcIjtcclxuICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5yZXNpemUgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS53aGl0ZVNwYWNlID0gXCJwcmVcIjtcclxuICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5saW5lSGVpZ2h0ID0gXCIxMjUlXCI7XHJcbiAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xyXG4gICAgICAgICAgIHRleHRhcmVhLnN0eWxlLmJvcmRlciA9IFwiMFwiO1xyXG4gICAgICAgICAgIHRleHRhcmVhLnNwZWxsY2hlY2sgPSBmYWxzZTtcclxuICAgICAgICAgICByZXR1cm4gdGV4dGFyZWE7XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqIOWkhOeQhnRleHRhcmVh6Ieq5Yqo5o2i6KGMXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvUHJvdG8uaGFuZGxlV3JhcCA9IGZ1bmN0aW9uICh2YWx1ZSwgd2lkdGgpIHtcclxuICAgICAgICAgICB2YXIgc3Bhbk5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgICAgICAgICBzcGFuTm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgICAgICBzcGFuTm9kZS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgICAgc3Bhbk5vZGUuc3R5bGUuYm9yZGVyID0gXCIwXCI7XHJcbiAgICAgICAgICAgc3Bhbk5vZGUuc3R5bGUucGFkZGluZyA9IFwiMFwiO1xyXG4gICAgICAgICAgIHNwYW5Ob2RlLnN0eWxlLmxlZnQgPSBcIjBcIjtcclxuICAgICAgICAgICBzcGFuTm9kZS5zdHlsZS50b3AgPSBcIjBcIjtcclxuICAgICAgICAgICB0aGlzLl9kb20uYXBwZW5kQ2hpbGQoc3Bhbk5vZGUpO1xyXG4gICAgICAgICAgIHZhciBjb250ZW50ID0gdmFsdWUuc3BsaXQoXCJcXG5cIik7XHJcbiAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XHJcbiAgICAgICAgICAgY29udGVudC5mb3JFYWNoKGZ1bmN0aW9uICh2YWwsIGkpIHtcclxuICAgICAgICAgICAgICAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgIGlmICh2YWxMZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgLy9yZXN1bHQgKz0gXCJcXG5cIjtcclxuICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgIHZhciBwcmUgPSBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgIGlubmVyVmFsLCB0ZW1wV2lkdGgsIGNvbldpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaW5uZXJJID0gMDsgaW5uZXJJIDwgdmFsTGVuZ3RoOyBpbm5lckkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlubmVyVmFsID0gdmFsLmNoYXJBdChpbm5lckkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHNwYW5Ob2RlLmlubmVySFRNTCA9IHNwYW5Ob2RlLmlubmVySFRNTCArIGlubmVyVmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHRlbXBXaWR0aCA9IHNwYW5Ob2RlLmNsaWVudFdpZHRoOyAvL+iOt+WPlua3u+WKoOWtl+espuWQjumakOiXj+Wfn+eahOWuveW6plxyXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbldpZHRoID0gTnVtYmVyKHdpZHRoLnN1YnN0cmluZygwLCB3aWR0aC5sZW5ndGggLSAyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBXaWR0aCA+IGNvbldpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBwcmU7IC8v5aaC5p6c6L+95Yqg5a2X56ym5ZCO6ZqQ6JeP5Z+f5a695bqm5aSn5LqOVGV4dEFyZWHlrr3luqbvvIzliJnooajmmI7or6XlrZfnrKbkuLrkuIvkuIDooYzlrZfnrKbvvIxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW5Ob2RlLmlubmVySFRNTCA9IGlubmVyVmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBwcmUgPSBpbm5lclZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlubmVySSA9PSB2YWxMZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBwcmUgKyBpbm5lclZhbDsgLy/mnIDlkI7kuIDkuKrlrZfnrKZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBjb250ZW50Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW5Ob2RlLmlubmVySFRNTCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlICs9IGlubmVyVmFsOyAvL+S+neasoei/veWKoOWIsHByZeWPmOmHj+S4rVxyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICB0aGlzLl9kb20ucmVtb3ZlQ2hpbGQoc3Bhbk5vZGUpO1xyXG4gICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICB9O1xyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAqIOaWh+acrOWfn+iHqumAguW6lOmrmOWuvVxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb1Byb3RvLl90ZXh0YXJlYVJlc2l6ZSA9IGZ1bmN0aW9uICh0ZXh0UmVjdCwgdGV4dGFyZWEsIHdpZHRoKSB7XHJcbiAgICAgICAgICAgdmFyIG1pbldpZHRoID0gMDtcclxuICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS53aWR0aCA9IDA7XHJcbiAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSAoMS4xICogdGV4dFJlY3Qud2lkdGgpICogdGhpcy5ub3dab29tICsgXCJweFwiO1xyXG4gICAgICAgICAgIGlmICh3aWR0aCA8IDYwKSB7XHJcbiAgICAgICAgICAgICAgIG1pbldpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgbWluV2lkdGggPSA2MFxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBpZiAodGV4dFJlY3Qud2lkdGggPD0gbWluV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSBtaW5XaWR0aCArIFwicHhcIjtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gXCIwcHhcIjtcclxuICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSB0ZXh0YXJlYS5zY3JvbGxIZWlnaHQgKyAncHgnO1xyXG4gICAgICAgICAgIGlmICh0ZXh0YXJlYS5zY3JvbGxIZWlnaHQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSBcIjEycHhcIjtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgenJVdGlsLm1peGluKEZpc2hUb3BvQnBtbiwgRXZlbnRmdWwpO1xyXG5cclxuICAgICAgIC8vIC0tLS0tLS0tLeWvueWkluaatOmcsmZpc2hUb3BvQnBtbi0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgdmFyIGlkQmFzZSA9IG5ldyBEYXRlKCkgLSAwO1xyXG4gICAgICAgdmFyIGluc3RhbmNlcyA9IHt9O1xyXG4gICAgICAgdmFyIERPTV9BVFRSSUJVVEVfS0VZID0gJ19maXNoVG9wb0JwbW5faW5zdGFuY2VfJztcclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIGZpc2hUb3BvQnBtbuWFqOWxgOWvueixoe+8jOWmguaenOaYr2FtZOaWueW8j+WKoOi9ve+8jOWImeebtOaOpei/lOWbnlxyXG4gICAgICAgICogQGNsYXNzIGZpc2hUb3BvQnBtblxyXG4gICAgICAgICogQHNpbmdsZXRvblxyXG4gICAgICAgICovXHJcbiAgICAgICB2YXIgZmlzaFRvcG9CcG1uID0ge1xyXG4gICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAqIOeJiOacrOWPt1xyXG4gICAgICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgdmVyc2lvbjogJzMuMi4wJyxcclxuICAgICAgICAgICBkZXBlbmRlbmNpZXM6IHtcclxuICAgICAgICAgICAgICAgenJlbmRlcjogJzMuMC40J1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDliJ3lp4vljJZkb23lhYPntKDkuLogYnBtbuWvueixoVxyXG4gICAgICAgICogQG1lbWJlciBmaXNoVG9wb0JwbW5cclxuICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbSAg5LiA5LiqZGl25YWD57SgXHJcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAg5Lyg6YCS55qE6YCJ6aG55Y+C5pWwXHJcbiAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnIG9yICd2bWwnXHJcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpbz0xXSByZXRpbmEg5bGP5bmV5LyY5YyWXHJcbiAgICAgICAgKiBAcmV0dXJuIHtmaXNoLnRvcG8uRmlzaFRvcG9CcG1ufVxyXG4gICAgICAgICovXHJcbiAgICAgICBmaXNoVG9wb0JwbW4uaW5pdCA9IGZ1bmN0aW9uKGRvbSwgb3B0cykge1xyXG4gICAgICAgICAgIGlmICghZG9tKSB7XHJcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5pdGlhbGl6ZSBmYWlsZWQ6IGludmFsaWQgZG9tLicpO1xyXG4gICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XHJcbiAgICAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgICAgIHpyVXRpbC5kZWZhdWx0cyhvcHRzLCB7XHJcbiAgICAgICAgICAgICAgIHR5cGU6IFwiYnBtblwiLFxyXG4gICAgICAgICAgICAgICBzaG93R3JpZExpbmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgIGdyaWRMaW5lU3BhY2luZzogMTAsXHJcbiAgICAgICAgICAgICAgIGJlZm9yZURlbGV0ZU5vZGU6IG51bGwsICAvL+WIoOmZpOiKgueCueS5i+WJjeeahOS6i+S7tlxyXG4gICAgICAgICAgICAgICBiZWZvcmVDcmVhdGVOb2RlOm51bGwsICAgLy/liJvlu7roioLngrnkuYvliY3nmoTkuovku7ZcclxuICAgICAgICAgICAgICAgYmVmb3JlRGVsZXRlTGluZTogbnVsbCwgIC8v5Yig6Zmk6L+e57q/5LmL5YmN55qE5LqL5Lu2XHJcbiAgICAgICAgICAgICAgIGJlZm9yZUNyZWF0ZUxpbmU6bnVsbCwgICAgLy/liJvlu7rov57nur/kuYvliY3nmoTkuovku7ZcclxuICAgICAgICAgICAgICAgY29ubmVjdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgIHNjYWxlYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgIHJvdGF0YWJsZTogZmFsc2VcclxuICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgdmFyIGZpc2hUb3BvQnBtbiA9IG5ldyBGaXNoVG9wb0JwbW4oZG9tLCBvcHRzKTtcclxuICAgICAgICAgICBmaXNoVG9wb0JwbW4uaW5pdCgpO1xyXG5cclxuICAgICAgICAgICBmaXNoVG9wb0JwbW4uaWQgPSAnZnRfJyArIGlkQmFzZSsrO1xyXG4gICAgICAgICAgIGluc3RhbmNlc1tmaXNoVG9wb0JwbW4uaWRdID0gZmlzaFRvcG9CcG1uO1xyXG5cclxuICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlICYmIGRvbS5zZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVksIGZpc2hUb3BvQnBtbi5pZCk7XHJcblxyXG4gICAgICAgICAgIHJldHVybiBmaXNoVG9wb0JwbW47XHJcbiAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAvKipcclxuICAgICAgICAqIOiOt+WPliBkb20g5a655Zmo5LiK55qE5a6e5L6L44CCXHJcbiAgICAgICAgKiBAbWVtYmVyIGZpc2hUb3BvQnBtblxyXG4gICAgICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGRvbSDkuIDkuKpkaXblhYPntKBcclxuICAgICAgICAqIEByZXR1cm4ge2Zpc2gudG9wby5GaXNoVG9wb0JwbW59XHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvQnBtbi5nZXRJbnN0YW5jZUJ5RG9tID0gZnVuY3Rpb24oZG9tKSB7XHJcbiAgICAgICAgICAgdmFyIGtleSA9IGRvbS5nZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVkpO1xyXG4gICAgICAgICAgIHJldHVybiBpbnN0YW5jZXNba2V5XTtcclxuICAgICAgIH07XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiDplIDmr4Hlrp7kvovvvIzlrp7kvovplIDmr4HlkI7ml6Dms5Xlho3ooqvkvb/nlKjjgIJcclxuICAgICAgICAqIEBtZW1iZXIgZmlzaFRvcG9CcG1uXHJcbiAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R8c3RyaW5nfSBjaGFydCBmaXNoVG9wb0JwbW7lrp7kvosg5oiWIGZpc2hUb3BvQnBtbueahGlkXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZpc2hUb3BvQnBtbi5kaXNwb3NlID0gZnVuY3Rpb24oY2hhcnQpIHtcclxuICAgICAgICAgICB2YXIgdG9wbztcclxuICAgICAgICAgICBpZiAoenJVdGlsLmlzRG9tKGNoYXJ0KSkge1xyXG4gICAgICAgICAgICAgICB0b3BvID0gZmlzaFRvcG9CcG1uLmdldEluc3RhbmNlQnlEb20oY2hhcnQpO1xyXG4gICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNoYXJ0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICB0b3BvID0gaW5zdGFuY2VzW2NoYXJ0XTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgaWYgKCh0b3BvIGluc3RhbmNlb2YgZmlzaFRvcG9CcG1uKSAmJiAhdG9wby5pc0Rpc3Bvc2VkKCkpIHtcclxuICAgICAgICAgICAgICAgdG9wby5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfTtcclxuICAgICAgIC8v5pq06Zyy5Ye65Y6755qE57G7IOaWueS+v+eUqOaIt+aJqeWxleWbvuWFg1xyXG4gICAgICAgZmlzaFRvcG9CcG1uLkJwbW4gPSBCcG1uO1xyXG4gICAgICAgZmlzaFRvcG9CcG1uLkJQTU5Ob2RlID0gQlBNTk5vZGU7XHJcbiAgICAgICBmaXNoVG9wb0JwbW4uZ3JhcGhpYyA9IGdyYXBoaWM7XHJcbiAgICAgICBmaXNoVG9wb0JwbW4uQm91bmRpbmdSZWN0ID0gQm91bmRpbmdSZWN0O1xyXG4gICAgICAgZmlzaFRvcG9CcG1uLkJQTU5Nb2RlbCA9IEJQTU5Nb2RlbDtcclxuXHJcbiAgICAgICBmaXNoVG9wb0JwbW4udXRpbCA9IHt9O1xyXG4gICAgICAgenJVdGlsLmVhY2goW1xyXG4gICAgICAgICAgICAgICAnbWFwJywgJ2VhY2gnLCAnZmlsdGVyJywgJ2luZGV4T2YnLCAnaW5oZXJpdHMnLFxyXG4gICAgICAgICAgICAgICAncmVkdWNlJywgJ2ZpbHRlcicsICdiaW5kJywgJ2N1cnJ5JywgJ2lzQXJyYXknLFxyXG4gICAgICAgICAgICAgICAnaXNTdHJpbmcnLCAnaXNPYmplY3QnLCAnaXNGdW5jdGlvbicsICdleHRlbmQnXHJcbiAgICAgICAgICAgXSxcclxuICAgICAgICAgICBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgICAgIGZpc2hUb3BvQnBtbi51dGlsW25hbWVdID0genJVdGlsW25hbWVdO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICk7XHJcbiAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZpc2hUb3BvQnBtbjtcclxuICAgXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9GaXNoVG9wb0JwbW4uanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIHZhciBwYXRoVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvcGF0aCcpO1xyXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcclxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoJyk7XHJcbiAgICB2YXIgY29sb3JUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvdG9vbC9jb2xvcicpO1xyXG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4Jyk7XHJcbiAgICB2YXIgdmVjdG9yID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcclxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQnKTtcclxuICAgIHZhciBEcmFnZ2FibGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUnKTtcclxuXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHt9O1xyXG4gICAgZ3JhcGhpYy5VdGlsID0genJVdGlsO1xyXG4gICAgZ3JhcGhpYy5Hcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xyXG5cclxuICAgIGdyYXBoaWMuSW1hZ2UgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5UZXh0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy50ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xyXG5cclxuICAgIGdyYXBoaWMuQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUnKTtcclxuXHJcbiAgICBncmFwaGljLlNlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5SaW5nID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Qb2x5Z29uID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Qb2x5bGluZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUnKTtcclxuXHJcbiAgICBncmFwaGljLlJlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QnKTtcclxuXHJcbiAgICBncmFwaGljLkxpbmUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUnKTtcclxuXHJcbiAgICBncmFwaGljLkJlemllckN1cnZlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZScpO1xyXG5cclxuICAgIGdyYXBoaWMuQXJjID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMnKTtcclxuXHJcbiAgICBncmFwaGljLkxpbmVhckdyYWRpZW50ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudCcpO1xyXG5cclxuICAgIGdyYXBoaWMuUmFkaWFsR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Cb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xyXG4gICAgZ3JhcGhpYy5TdGF0ZXMgPSByZXF1aXJlKFwienJlbmRlci9saWIvZ3JhcGhpYy9TdGF0ZXMuanNcIik7XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCBzaGFwZSB3aXRoIHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5leHRlbmRTaGFwZSA9IGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIFBhdGguZXh0ZW5kKG9wdHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZCBwYXRoXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuZXh0ZW5kUGF0aCA9IGZ1bmN0aW9uIChwYXRoRGF0YSwgb3B0cykge1xyXG4gICAgICAgIHJldHVybiBwYXRoVG9vbC5leHRlbmRGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBwYXRoIGVsZW1lbnQgZnJvbSBwYXRoIGRhdGEgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aERhdGFcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xheW91dD1jb3Zlcl0gJ2NlbnRlcicgb3IgJ2NvdmVyJ1xyXG4gICAgICovXHJcbiAgICBncmFwaGljLm1ha2VQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBvcHRzLCByZWN0LCBsYXlvdXQpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IHBhdGhUb29sLmNyZWF0ZUZyb21TdHJpbmcocGF0aERhdGEsIG9wdHMpO1xyXG4gICAgICAgIERyYWdnYWJsZS5jYWxsKHBhdGgpO1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIGlmIChyZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhc3BlY3QgPSBib3VuZGluZ1JlY3Qud2lkdGggLyBib3VuZGluZ1JlY3QuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCByZWN0IHRvIGNlbnRlciwga2VlcCB3aWR0aCAvIGhlaWdodCByYXRpby5cclxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3QuaGVpZ2h0ICogYXNwZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodDtcclxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA8PSByZWN0LndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHZhciBjeSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMjtcclxuXHJcbiAgICAgICAgICAgICAgICByZWN0LnggPSBjeCAtIHdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHJlY3QueSA9IGN5IC0gaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIHJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVBhdGgocGF0aCwgcmVjdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB6clV0aWwuaW5oZXJpdHMocGF0aCwgRHJhZ2dhYmxlKTtcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH07XHJcblxyXG4gICAgZ3JhcGhpYy5tZXJnZVBhdGggPSBwYXRoVG9vbC5tZXJnZVBhdGg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemUgYSBwYXRoIHRvIGZpdCB0aGUgcmVjdFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IHBhdGhcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMucmVzaXplUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCByZWN0KSB7XHJcbiAgICAgICAgaWYgKCFwYXRoLmFwcGx5VHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBwYXRoUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcblxyXG4gICAgICAgIHZhciBtID0gcGF0aFJlY3QuY2FsY3VsYXRlVHJhbnNmb3JtKHJlY3QpO1xyXG5cclxuICAgICAgICBwYXRoLmFwcGx5VHJhbnNmb3JtKG0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBsaW5lIGZvciBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc2hhcGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngxXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55MV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueDJdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnkyXVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zdHlsZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc3R5bGUubGluZVdpZHRoXVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBNb2RpZmllZCBwYXJhbVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lID0gZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgdmFyIHN1YlBpeGVsT3B0aW1pemUgPSBncmFwaGljLnN1YlBpeGVsT3B0aW1pemU7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gcGFyYW0uc2hhcGU7XHJcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHBhcmFtLnN0eWxlLmxpbmVXaWR0aDtcclxuXHJcbiAgICAgICAgaWYgKHJvdW5kKHNoYXBlLngxICogMikgPT09IHJvdW5kKHNoYXBlLngyICogMikpIHtcclxuICAgICAgICAgICAgc2hhcGUueDEgPSBzaGFwZS54MiA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueDEsIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb3VuZChzaGFwZS55MSAqIDIpID09PSByb3VuZChzaGFwZS55MiAqIDIpKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnkxID0gc2hhcGUueTIgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLnkxLCBsaW5lV2lkdGgsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyYW07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIHJlY3QgZm9yIGNhbnZhc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zaGFwZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueF1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUud2lkdGhdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLmhlaWdodF1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc3R5bGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnN0eWxlLmxpbmVXaWR0aF1cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdCA9IGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgIHZhciBzdWJQaXhlbE9wdGltaXplID0gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplO1xyXG4gICAgICAgIHZhciBzaGFwZSA9IHBhcmFtLnNoYXBlO1xyXG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XHJcbiAgICAgICAgdmFyIG9yaWdpblggPSBzaGFwZS54O1xyXG4gICAgICAgIHZhciBvcmlnaW5ZID0gc2hhcGUueTtcclxuICAgICAgICB2YXIgb3JpZ2luV2lkdGggPSBzaGFwZS53aWR0aDtcclxuICAgICAgICB2YXIgb3JpZ2luSGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgIHNoYXBlLnggPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLngsIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgc2hhcGUueSA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueSwgbGluZVdpZHRoLCB0cnVlKTtcclxuICAgICAgICBzaGFwZS53aWR0aCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICBzdWJQaXhlbE9wdGltaXplKG9yaWdpblggKyBvcmlnaW5XaWR0aCwgbGluZVdpZHRoLCBmYWxzZSkgLSBzaGFwZS54LFxyXG4gICAgICAgICAgICBvcmlnaW5XaWR0aCA9PT0gMCA/IDAgOiAxXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzaGFwZS5oZWlnaHQgPSBNYXRoLm1heChcclxuICAgICAgICAgICAgc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5ZICsgb3JpZ2luSGVpZ2h0LCBsaW5lV2lkdGgsIGZhbHNlKSAtIHNoYXBlLnksXHJcbiAgICAgICAgICAgIG9yaWdpbkhlaWdodCA9PT0gMCA/IDAgOiAxXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gcGFyYW07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIGZvciBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gQ29vcmRpbmF0ZSwgc3VjaCBhcyB4LCB5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIFNob3VsZCBiZSBub25uZWdhdGl2ZSBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcG9zaXRpdmVPck5lZ2F0aXZlIERlZmF1bHQgZmFsc2UgKG5lZ2F0aXZlKS5cclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gT3B0aW1pemVkIHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemUgPSBmdW5jdGlvbiAocG9zaXRpb24sIGxpbmVXaWR0aCwgcG9zaXRpdmVPck5lZ2F0aXZlKSB7XHJcbiAgICAgICAgLy8gQXNzdXJlIHRoYXQgKHBvc2l0aW9uICsgbGluZVdpZHRoIC8gMikgaXMgbmVhciBpbnRlZ2VyIGVkZ2UsXHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGxpbmUgd2lsbCBiZSBmdXp6eSBpbiBjYW52YXMuXHJcbiAgICAgICAgdmFyIGRvdWJsZWRQb3NpdGlvbiA9IHJvdW5kKHBvc2l0aW9uICogMik7XHJcbiAgICAgICAgcmV0dXJuIChkb3VibGVkUG9zaXRpb24gKyByb3VuZChsaW5lV2lkdGgpKSAlIDIgPT09IDBcclxuICAgICAgICAgICAgPyBkb3VibGVkUG9zaXRpb24gLyAyXHJcbiAgICAgICAgICAgIDogKGRvdWJsZWRQb3NpdGlvbiArIChwb3NpdGl2ZU9yTmVnYXRpdmUgPyAxIDogLTEpKSAvIDI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZG9TaW5nbGVFbnRlckhvdmVyKGVsKSB7XHJcbiAgICAgICAgaWYgKGVsLl9faXNIb3Zlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbC5fX2hvdmVyU3RsRGlydHkpIHtcclxuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IGVsLnN0eWxlLnN0cm9rZTtcclxuICAgICAgICAgICAgdmFyIGZpbGwgPSBlbC5zdHlsZS5maWxsO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGhvdmVyU3R5bGUgb24gbW91c2VvdmVyXHJcbiAgICAgICAgICAgIHZhciBob3ZlclN0eWxlID0gZWwuX19ob3ZlclN0bDtcclxuICAgICAgICAgICAgdmFyIGxpZnQgPSBjb2xvclRvb2wubGlmdDtcclxuICAgICAgICAgICAgaG92ZXJTdHlsZS5maWxsID0gaG92ZXJTdHlsZS5maWxsXHJcbiAgICAgICAgICAgICAgICB8fCAoZmlsbCAmJiAoZmlsbCBpbnN0YW5jZW9mIEdyYWRpZW50ID8gZmlsbCA6IGxpZnQoZmlsbCwgLTAuMSkpKTtcclxuICAgICAgICAgICAgaG92ZXJTdHlsZS5zdHJva2UgPSBob3ZlclN0eWxlLnN0cm9rZVxyXG4gICAgICAgICAgICAgICAgfHwgKHN0cm9rZSAmJiAoc3Ryb2tlIGluc3RhbmNlb2YgR3JhZGllbnQgPyBzdHJva2UgOiBsaWZ0KHN0cm9rZSwgLTAuMSkpKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBub3JtYWxTdHlsZSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGhvdmVyU3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChob3ZlclN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsU3R5bGVbbmFtZV0gPSBlbC5zdHlsZVtuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWwuX19ub3JtYWxTdGwgPSBub3JtYWxTdHlsZTtcclxuXHJcbiAgICAgICAgICAgIGVsLl9faG92ZXJTdGxEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbC5zZXRTdHlsZShlbC5fX2hvdmVyU3RsKTtcclxuICAgICAgICBlbC56MiArPSAxO1xyXG5cclxuICAgICAgICBlbC5fX2lzSG92ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRvU2luZ2xlTGVhdmVIb3ZlcihlbCkge1xyXG4gICAgICAgIGlmICghZWwuX19pc0hvdmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBub3JtYWxTdGwgPSBlbC5fX25vcm1hbFN0bDtcclxuICAgICAgICBub3JtYWxTdGwgJiYgZWwuc2V0U3R5bGUobm9ybWFsU3RsKTtcclxuICAgICAgICBlbC56MiAtPSAxO1xyXG5cclxuICAgICAgICBlbC5fX2lzSG92ZXIgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkb0VudGVySG92ZXIoZWwpIHtcclxuICAgICAgICAoZWwudHlwZSA9PT0gJ2dyb3VwJyB8fCBlbC50eXBlID09PSAnR3JvdXBOb2RlJylcclxuICAgICAgICAgICAgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9TaW5nbGVFbnRlckhvdmVyKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgOiBkb1NpbmdsZUVudGVySG92ZXIoZWwpO1xyXG4gICAgfVxyXG4gICAgZ3JhcGhpYy5kb0VudGVySG92ZXIgPSBkb0VudGVySG92ZXI7XHJcbiAgICBmdW5jdGlvbiBkb0xlYXZlSG92ZXIoZWwpIHtcclxuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXHJcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvU2luZ2xlTGVhdmVIb3ZlcihjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKTtcclxuICAgIH1cclxuICAgIGdyYXBoaWMuZG9MZWF2ZUhvdmVyID0gZG9MZWF2ZUhvdmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0bCkge1xyXG4gICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIHNlcGNpZmllZCBob3ZlclN0eWxlLCB0aGVuIHVzZSBpdCBpbnN0ZWFkIG9mIGdpdmVuIGhvdmVyU3R5bGVcclxuICAgICAgICAvLyBPZnRlbiB1c2VkIHdoZW4gaXRlbSBncm91cCBoYXMgYSBsYWJlbCBlbGVtZW50IGFuZCBpdCdzIGhvdmVyU3R5bGUgaXMgZGlmZmVyZW50XHJcbiAgICAgICAgZWwuX19ob3ZlclN0bCA9IGVsLmhvdmVyU3R5bGUgfHwgaG92ZXJTdGwgfHwge307XHJcbiAgICAgICAgZWwuX19ob3ZlclN0bERpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdyYXBoaWMuc2V0RWxlbWVudEhvdmVyU3RsID0gc2V0RWxlbWVudEhvdmVyU3RsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdmVyKCkge1xyXG4gICAgICAgIC8vIE9ubHkgaWYgZWxlbWVudCBpcyBub3QgaW4gZW1waGFzaXMgc3RhdHVzXHJcbiAgICAgICAgIXRoaXMuX19pc0VtcGhhc2lzICYmIGRvRW50ZXJIb3Zlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbkVsZW1lbnRNb3VzZU91dCgpIHtcclxuICAgICAgICAvLyBPbmx5IGlmIGVsZW1lbnQgaXMgbm90IGluIGVtcGhhc2lzIHN0YXR1c1xyXG4gICAgICAgICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0xlYXZlSG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZW50ZXJFbXBoYXNpcygpIHtcclxuICAgICAgICB0aGlzLl9faXNFbXBoYXNpcyA9IHRydWU7XHJcbiAgICAgICAgZG9FbnRlckhvdmVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGxlYXZlRW1waGFzaXMoKSB7XHJcbiAgICAgICAgdGhpcy5fX2lzRW1waGFzaXMgPSBmYWxzZTtcclxuICAgICAgICBkb0xlYXZlSG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgaG92ZXIgc3R5bGUgb2YgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtob3ZlclN0eWxlXVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnNldEhvdmVyU3R5bGUgPSBmdW5jdGlvbiAoZWwsIGhvdmVyU3R5bGUpIHtcclxuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXHJcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRIb3ZlclN0bChjaGlsZCwgaG92ZXJTdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0eWxlKTtcclxuICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgYm91bmQgaGFuZGxlcnNcclxuICAgICAgICBlbC5vbignbW91c2VvdmVyJywgb25FbGVtZW50TW91c2VPdmVyKVxyXG4gICAgICAgICAgLm9uKCdtb3VzZW91dCcsIG9uRWxlbWVudE1vdXNlT3V0KTtcclxuXHJcbiAgICAgICAgLy8gRW1waGFzaXMsIG5vcm1hbCBjYW4gYmUgdHJpZ2dlcmVkIG1hbnVhbGx5XHJcbiAgICAgICAgZWwub24oJ2VtcGhhc2lzJywgZW50ZXJFbXBoYXNpcylcclxuICAgICAgICAgIC5vbignbm9ybWFsJywgbGVhdmVFbXBoYXNpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChlbC5fX25vcm1hbFN0bCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5fX25vcm1hbFN0bC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLl9fbm9ybWFsU3RsW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGV4dCBvcHRpb24gaW4gdGhlIHN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBsYWJlbE1vZGVsXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHRTdHlsZSwgbGFiZWxNb2RlbCwgY29sb3IpIHtcclxuICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygncG9zaXRpb24nKSB8fCAnaW5zaWRlJztcclxuICAgICAgICB2YXIgbGFiZWxDb2xvciA9IGxhYmVsUG9zaXRpb24uaW5kZXhPZignaW5zaWRlJykgPj0gMCA/ICd3aGl0ZScgOiBjb2xvcjtcclxuICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBsYWJlbE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcclxuICAgICAgICB6clV0aWwuZXh0ZW5kKHRleHRTdHlsZSwge1xyXG4gICAgICAgICAgICB0ZXh0RGlzdGFuY2U6IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnZGlzdGFuY2UnKSB8fCA1LFxyXG4gICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxyXG4gICAgICAgICAgICB0ZXh0UG9zaXRpb246IGxhYmVsUG9zaXRpb24sXHJcbiAgICAgICAgICAgIHRleHRGaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBsYWJlbENvbG9yXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGFuaW1hdGVPclNldFByb3BzKGlzVXBkYXRlLCBlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgY2IpIHtcclxuICAgICAgICB2YXIgcG9zdGZpeCA9IGlzVXBkYXRlID8gJ1VwZGF0ZScgOiAnJztcclxuICAgICAgICB2YXIgZHVyYXRpb24gPSBhbmltYXRhYmxlTW9kZWxcclxuICAgICAgICAgICAgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkR1cmF0aW9uJyArIHBvc3RmaXgpO1xyXG4gICAgICAgIHZhciBhbmltYXRpb25FYXNpbmcgPSBhbmltYXRhYmxlTW9kZWxcclxuICAgICAgICAgICAgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkVhc2luZycgKyBwb3N0Zml4KTtcclxuXHJcbiAgICAgICAgYW5pbWF0YWJsZU1vZGVsICYmIGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb24nKVxyXG4gICAgICAgICAgICA/IGVsLmFuaW1hdGVUbyhwcm9wcywgZHVyYXRpb24sIGFuaW1hdGlvbkVhc2luZywgY2IpXHJcbiAgICAgICAgICAgIDogKGVsLmF0dHIocHJvcHMpLCBjYiAmJiBjYigpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy51cGRhdGVQcm9wcyA9IHpyVXRpbC5jdXJyeShhbmltYXRlT3JTZXRQcm9wcywgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0IGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5pbml0UHJvcHMgPSB6clV0aWwuY3VycnkoYW5pbWF0ZU9yU2V0UHJvcHMsIGZhbHNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0cmFuc2Zvcm0gbWF0cml4IG9mIHRhcmdldCAocGFyYW0gdGFyZ2V0KSxcclxuICAgICAqIGluIGNvb3JkaW5hdGUgb2YgaXRzIGFuY2VzdG9yIChwYXJhbSBhbmNlc3RvcilcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9IHRhcmdldFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSBhbmNlc3RvclxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIGFuY2VzdG9yKSB7XHJcbiAgICAgICAgdmFyIG1hdCA9IG1hdHJpeC5pZGVudGl0eShbXSk7XHJcblxyXG4gICAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBhbmNlc3Rvcikge1xyXG4gICAgICAgICAgICBtYXRyaXgubXVsKG1hdCwgdGFyZ2V0LmdldExvY2FsVHJhbnNmb3JtKCksIG1hdCk7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IHRyYW5zZm9ybSB0byBhbiB2ZXJ0ZXguXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZXJ0ZXggW3gsIHldXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxyXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFt4LCB5XVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKHZlcnRleCwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcclxuICAgICAgICBpZiAoaW52ZXJ0KSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IG1hdHJpeC5pbnZlcnQoW10sIHRyYW5zZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0oW10sIHZlcnRleCwgdHJhbnNmb3JtKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUcmFuc2Zvcm1lZCBkaXJlY3Rpb24uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMudHJhbnNmb3JtRGlyZWN0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcclxuXHJcbiAgICAgICAgLy8gUGljayBhIGJhc2UsIGVuc3VyZSB0aGF0IHRyYW5zZm9ybSByZXN1bHQgd2lsbCBub3QgYmUgKDAsIDApLlxyXG4gICAgICAgIHZhciBoQmFzZSA9ICh0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVswXSA9PT0gMClcclxuICAgICAgICAgICAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVswXSk7XHJcbiAgICAgICAgdmFyIHZCYXNlID0gKHRyYW5zZm9ybVs0XSA9PT0gMCB8fCB0cmFuc2Zvcm1bNV0gPT09IDAgfHwgdHJhbnNmb3JtWzJdID09PSAwKVxyXG4gICAgICAgICAgICA/IDEgOiBNYXRoLmFicygyICogdHJhbnNmb3JtWzRdIC8gdHJhbnNmb3JtWzJdKTtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRleCA9IFtcclxuICAgICAgICAgICAgZGlyZWN0aW9uID09PSAnbGVmdCcgPyAtaEJhc2UgOiBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyBoQmFzZSA6IDAsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3RvcCcgPyAtdkJhc2UgOiBkaXJlY3Rpb24gPT09ICdib3R0b20nID8gdkJhc2UgOiAwXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgdmVydGV4ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSh2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJ0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZlcnRleFswXSkgPiBNYXRoLmFicyh2ZXJ0ZXhbMV0pXHJcbiAgICAgICAgICAgID8gKHZlcnRleFswXSA+IDAgPyAncmlnaHQnIDogJ2xlZnQnKVxyXG4gICAgICAgICAgICA6ICh2ZXJ0ZXhbMV0gPiAwID8gJ2JvdHRvbScgOiAndG9wJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gZ3JhcGhpYztcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvdXRpbFxuICovXG4vLyDnlKjkuo7lpITnkIZtZXJnZeaXtuaXoOazlemBjeWOhkRhdGXnrYnlr7nosaHnmoTpl67pophcbnZhciBCVUlMVElOX09CSkVDVCA9IHtcbiAgJ1tvYmplY3QgRnVuY3Rpb25dJzogMSxcbiAgJ1tvYmplY3QgUmVnRXhwXSc6IDEsXG4gICdbb2JqZWN0IERhdGVdJzogMSxcbiAgJ1tvYmplY3QgRXJyb3JdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nOiAxLFxuICAvLyBGb3Igbm9kZS1jYW52YXNcbiAgJ1tvYmplY3QgSW1hZ2VdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzXSc6IDFcbn07XG52YXIgVFlQRURfQVJSQVkgPSB7XG4gICdbb2JqZWN0IEludDhBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50OEFycmF5XSc6IDEsXG4gICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc6IDEsXG4gICdbb2JqZWN0IEludDE2QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgVWludDE2QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgSW50MzJBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50MzJBcnJheV0nOiAxLFxuICAnW29iamVjdCBGbG9hdDMyQXJyYXldJzogMSxcbiAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc6IDFcbn07XG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgbmF0aXZlRm9yRWFjaCA9IGFycmF5UHJvdG8uZm9yRWFjaDtcbnZhciBuYXRpdmVGaWx0ZXIgPSBhcnJheVByb3RvLmZpbHRlcjtcbnZhciBuYXRpdmVTbGljZSA9IGFycmF5UHJvdG8uc2xpY2U7XG52YXIgbmF0aXZlTWFwID0gYXJyYXlQcm90by5tYXA7XG52YXIgbmF0aXZlUmVkdWNlID0gYXJyYXlQcm90by5yZWR1Y2U7IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cbnZhciBtZXRob2RzID0ge307XG5cbmZ1bmN0aW9uICRvdmVycmlkZShuYW1lLCBmbikge1xuICBtZXRob2RzW25hbWVdID0gZm47XG59XG4vKipcbiAqIFRob3NlIGRhdGEgdHlwZXMgY2FuIGJlIGNsb25lZDpcbiAqICAgICBQbGFpbiBvYmplY3QsIEFycmF5LCBUeXBlZEFycmF5LCBudW1iZXIsIHN0cmluZywgbnVsbCwgdW5kZWZpbmVkLlxuICogVGhvc2UgZGF0YSB0eXBlcyB3aWxsIGJlIGFzc2dpbmVkIHVzaW5nIHRoZSBvcmdpbmFsIGRhdGE6XG4gKiAgICAgQlVJTFRJTl9PQkpFQ1RcbiAqIEluc3RhbmNlIG9mIHVzZXIgZGVmaW5lZCBjbGFzcyB3aWxsIGJlIGNsb25lZCB0byBhIHBsYWluIG9iamVjdCwgd2l0aG91dFxuICogcHJvcGVydGllcyBpbiBwcm90b3R5cGUuXG4gKiBPdGhlciBkYXRhIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQgKG5vdCBzdXJlIHdoYXQgd2lsbCBoYXBwZW4pLlxuICpcbiAqIENhdXRpb246IGRvIG5vdCBzdXBwb3J0IGNsb25lIERhdGUsIGZvciBwZXJmb3JtYW5jZSBjb25zaWRlcmF0aW9uLlxuICogKFRoZXJlIG1pZ2h0IGJlIGEgbGFyZ2UgbnVtYmVyIG9mIGRhdGUgaW4gYHNlcmllcy5kYXRhYCkuXG4gKiBTbyBkYXRlIHNob3VsZCBub3QgYmUgbW9kaWZpZWQgaW4gYW5kIG91dCBvZiBlY2hhcnRzLlxuICpcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAcmV0dXJuIHsqfSBuZXdcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKHNvdXJjZSkge1xuICBpZiAoc291cmNlID09IG51bGwgfHwgdHlwZW9mIHNvdXJjZSAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gc291cmNlO1xuICB2YXIgdHlwZVN0ciA9IG9ialRvU3RyaW5nLmNhbGwoc291cmNlKTtcblxuICBpZiAodHlwZVN0ciA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gY2xvbmUoc291cmNlW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoVFlQRURfQVJSQVlbdHlwZVN0cl0pIHtcbiAgICB2YXIgQ3RvciA9IHNvdXJjZS5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChzb3VyY2UuY29uc3RydWN0b3IuZnJvbSkge1xuICAgICAgcmVzdWx0ID0gQ3Rvci5mcm9tKHNvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBDdG9yKHNvdXJjZS5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IGNsb25lKHNvdXJjZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFCVUlMVElOX09CSkVDVFt0eXBlU3RyXSAmJiAhaXNQcmltaXRpdmUoc291cmNlKSAmJiAhaXNEb20oc291cmNlKSkge1xuICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY2xvbmUoc291cmNlW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQHBhcmFtIHtib29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXVxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkge1xuICAvLyBXZSBzaG91bGQgZXNjYXBzZSB0aGF0IHNvdXJjZSBpcyBzdHJpbmdcbiAgLy8gYW5kIGVudGVyIGZvciAuLi4gaW4gLi4uXG4gIGlmICghaXNPYmplY3Qoc291cmNlKSB8fCAhaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiBvdmVyd3JpdGUgPyBjbG9uZShzb3VyY2UpIDogdGFyZ2V0O1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFyIHRhcmdldFByb3AgPSB0YXJnZXRba2V5XTtcbiAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XG5cbiAgICAgIGlmIChpc09iamVjdChzb3VyY2VQcm9wKSAmJiBpc09iamVjdCh0YXJnZXRQcm9wKSAmJiAhaXNBcnJheShzb3VyY2VQcm9wKSAmJiAhaXNBcnJheSh0YXJnZXRQcm9wKSAmJiAhaXNEb20oc291cmNlUHJvcCkgJiYgIWlzRG9tKHRhcmdldFByb3ApICYmICFpc0J1aWx0SW5PYmplY3Qoc291cmNlUHJvcCkgJiYgIWlzQnVpbHRJbk9iamVjdCh0YXJnZXRQcm9wKSAmJiAhaXNQcmltaXRpdmUoc291cmNlUHJvcCkgJiYgIWlzUHJpbWl0aXZlKHRhcmdldFByb3ApKSB7XG4gICAgICAgIC8vIOWmguaenOmcgOimgemAkuW9kuimhueblu+8jOWwsemAkuW9kuiwg+eUqG1lcmdlXG4gICAgICAgIG1lcmdlKHRhcmdldFByb3AsIHNvdXJjZVByb3AsIG92ZXJ3cml0ZSk7XG4gICAgICB9IGVsc2UgaWYgKG92ZXJ3cml0ZSB8fCAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIC8vIOWQpuWImeWPquWkhOeQhm92ZXJ3cml0ZeS4unRydWXvvIzmiJbogIXlnKjnm67moIflr7nosaHkuK3msqHmnInmraTlsZ7mgKfnmoTmg4XlhrVcbiAgICAgICAgLy8gTk9URe+8jOWcqCB0YXJnZXRba2V5XSDkuI3lrZjlnKjnmoTml7blgJnkuZ/mmK/nm7TmjqXopobnm5ZcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0QW5kU291cmNlcyBUaGUgZmlyc3QgaXRlbSBpcyB0YXJnZXQsIGFuZCB0aGUgcmVzdHMgYXJlIHNvdXJjZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAqIEByZXR1cm4geyp9IHRhcmdldFxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2VBbGwodGFyZ2V0QW5kU291cmNlcywgb3ZlcndyaXRlKSB7XG4gIHZhciByZXN1bHQgPSB0YXJnZXRBbmRTb3VyY2VzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0YXJnZXRBbmRTb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ID0gbWVyZ2UocmVzdWx0LCB0YXJnZXRBbmRTb3VyY2VzW2ldLCBvdmVyd3JpdGUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHBhcmFtIHsqfSB0YXJnZXRcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuLyoqXG4gKiBAcGFyYW0geyp9IHRhcmdldFxuICogQHBhcmFtIHsqfSBzb3VyY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJsYXk9ZmFsc2VdXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKi9cblxuXG5mdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChvdmVybGF5ID8gc291cmNlW2tleV0gIT0gbnVsbCA6IHRhcmdldFtrZXldID09IG51bGwpKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBjcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBtZXRob2RzLmNyZWF0ZUNhbnZhcygpO1xufTtcblxubWV0aG9kcy5jcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbn07IC8vIEZJWE1FXG5cblxudmFyIF9jdHg7XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGlmICghX2N0eCkge1xuICAgIC8vIFVzZSB1dGlsLmNyZWF0ZUNhbnZhcyBpbnN0ZWFkIG9mIGNyZWF0ZUNhbnZhc1xuICAgIC8vIGJlY2F1c2UgY3JlYXRlQ2FudmFzIG1heSBiZSBvdmVyd3JpdHRlbiBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRcbiAgICBfY3R4ID0gY3JlYXRlQ2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgfVxuXG4gIHJldHVybiBfY3R4O1xufVxuLyoqXG4gKiDmn6Xor6LmlbDnu4TkuK3lhYPntKDnmoRpbmRleFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgaWYgKGFycmF5KSB7XG4gICAgaWYgKGFycmF5LmluZGV4T2YpIHtcbiAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiDmnoTpgKDnsbvnu6fmib/lhbPns7tcbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGF6eiDmupDnsbtcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VDbGF6eiDln7rnsbtcbiAqL1xuXG5cbmZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcbiAgdmFyIGNsYXp6UHJvdG90eXBlID0gY2xhenoucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIEYoKSB7fVxuXG4gIEYucHJvdG90eXBlID0gYmFzZUNsYXp6LnByb3RvdHlwZTtcbiAgY2xhenoucHJvdG90eXBlID0gbmV3IEYoKTtcblxuICBmb3IgKHZhciBwcm9wIGluIGNsYXp6UHJvdG90eXBlKSB7XG4gICAgY2xhenoucHJvdG90eXBlW3Byb3BdID0gY2xhenpQcm90b3R5cGVbcHJvcF07XG4gIH1cblxuICBjbGF6ei5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjbGF6ejtcbiAgY2xhenouc3VwZXJDbGFzcyA9IGJhc2VDbGF6ejtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHNvcmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJsYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIG1peGluKHRhcmdldCwgc291cmNlLCBvdmVybGF5KSB7XG4gIHRhcmdldCA9ICdwcm90b3R5cGUnIGluIHRhcmdldCA/IHRhcmdldC5wcm90b3R5cGUgOiB0YXJnZXQ7XG4gIHNvdXJjZSA9ICdwcm90b3R5cGUnIGluIHNvdXJjZSA/IHNvdXJjZS5wcm90b3R5cGUgOiBzb3VyY2U7XG4gIGRlZmF1bHRzKHRhcmdldCwgc291cmNlLCBvdmVybGF5KTtcbn1cbi8qKlxuICogQ29uc2lkZXIgdHlwZWQgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fFR5cGVkQXJyYXl9IGRhdGFcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKGRhdGEpIHtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBkYXRhLmxlbmd0aCA9PSAnbnVtYmVyJztcbn1cbi8qKlxuICog5pWw57uE5oiW5a+56LGh6YGN5Y6GXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqL1xuXG5cbmZ1bmN0aW9uIGVhY2gob2JqLCBjYiwgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5mb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgb2JqLmZvckVhY2goY2IsIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIOaVsOe7hOaYoOWwhFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gbWFwKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmoubWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkge1xuICAgIHJldHVybiBvYmoubWFwKGNiLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gW21lbW9dXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiByZWR1Y2Uob2JqLCBjYiwgbWVtbywgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5yZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgcmV0dXJuIG9iai5yZWR1Y2UoY2IsIG1lbW8sIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1lbW8gPSBjYi5jYWxsKGNvbnRleHQsIG1lbW8sIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfVxufVxuLyoqXG4gKiDmlbDnu4Tov4fmu6RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbHRlcihvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLmZpbHRlciAmJiBvYmouZmlsdGVyID09PSBuYXRpdmVGaWx0ZXIpIHtcbiAgICByZXR1cm4gb2JqLmZpbHRlcihjYiwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG9ialtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXG4gKiDmlbDnu4Tpobnmn6Xmib5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cblxuZnVuY3Rpb24gZmluZChvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICByZXR1cm4gb2JqW2ldO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cblxuZnVuY3Rpb24gYmluZChmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9O1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1cnJ5KGZ1bmMpIHtcbiAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncy5jb25jYXQobmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH07XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8ICEhdmFsdWUgJiYgdHlwZSA9PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQnVpbHRJbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gISFCVUlMVElOX09CSkVDVFtvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0RvbSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS5vd25lckRvY3VtZW50ID09PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogV2hldGhlciBpcyBleGFjdGx5IE5hTi4gTm90aWNlIGlzTmFOKCdhJykgcmV0dXJucyB0cnVlLlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGVxTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG4vKipcbiAqIElmIHZhbHVlMSBpcyBub3QgbnVsbCwgdGhlbiByZXR1cm4gdmFsdWUxLCBvdGhlcndpc2UganVkZ2V0IHJlc3Qgb2YgdmFsdWVzLlxuICogTG93IHBlcmZvcm1hbmNlLlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHJldHVybiB7Kn0gRmluYWwgdmFsdWVcbiAqL1xuXG5cbmZ1bmN0aW9uIHJldHJpZXZlKHZhbHVlcykge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyaWV2ZTIodmFsdWUwLCB2YWx1ZTEpIHtcbiAgcmV0dXJuIHZhbHVlMCAhPSBudWxsID8gdmFsdWUwIDogdmFsdWUxO1xufVxuXG5mdW5jdGlvbiByZXRyaWV2ZTModmFsdWUwLCB2YWx1ZTEsIHZhbHVlMikge1xuICByZXR1cm4gdmFsdWUwICE9IG51bGwgPyB2YWx1ZTAgOiB2YWx1ZTEgIT0gbnVsbCA/IHZhbHVlMSA6IHZhbHVlMjtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGVuZEluZGV4XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIHNsaWNlKCkge1xuICByZXR1cm4gRnVuY3Rpb24uY2FsbC5hcHBseShuYXRpdmVTbGljZSwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogTm9ybWFsaXplIGNzcyBsaWtlZCBhcnJheSBjb25maWd1cmF0aW9uXG4gKiBlLmcuXG4gKiAgMyA9PiBbMywgMywgMywgM11cbiAqICBbNCwgMl0gPT4gWzQsIDIsIDQsIDJdXG4gKiAgWzQsIDMsIDJdID0+IFs0LCAzLCAyLCAzXVxuICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHZhbFxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVDc3NBcnJheSh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgdmFyIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIHZlcnRpY2FsIHwgaG9yaXpvbnRhbFxuICAgIHJldHVybiBbdmFsWzBdLCB2YWxbMV0sIHZhbFswXSwgdmFsWzFdXTtcbiAgfSBlbHNlIGlmIChsZW4gPT09IDMpIHtcbiAgICAvLyB0b3AgfCBob3Jpem9udGFsIHwgYm90dG9tXG4gICAgcmV0dXJuIFt2YWxbMF0sIHZhbFsxXSwgdmFsWzJdLCB2YWxbMV1dO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBwcmltaXRpdmVLZXkgPSAnX19lY19wcmltaXRpdmVfXyc7XG4vKipcbiAqIFNldCBhbiBvYmplY3QgYXMgcHJpbWl0aXZlIHRvIGJlIGlnbm9yZWQgdHJhdmVyc2luZyBjaGlsZHJlbiBpbiBjbG9uZSBvciBtZXJnZVxuICovXG5cbmZ1bmN0aW9uIHNldEFzUHJpbWl0aXZlKG9iaikge1xuICBvYmpbcHJpbWl0aXZlS2V5XSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICByZXR1cm4gb2JqW3ByaW1pdGl2ZUtleV07XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPbmx5IGFwcGx5IGBvd25Qcm9wZXJ0eWAuXG4gKi9cblxuXG5mdW5jdGlvbiBIYXNoTWFwKG9iaikge1xuICBvYmogJiYgZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gIH0sIHRoaXMpO1xufSAvLyBBZGQgcHJlZml4IHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZS5cblxuXG52YXIgSEFTSF9NQVBfUFJFRklYID0gJ19lY18nO1xudmFyIEhBU0hfTUFQX1BSRUZJWF9MRU5HVEggPSA0O1xuSGFzaE1hcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBIYXNoTWFwLFxuICAvLyBEbyBub3QgcHJvdmlkZSBgaGFzYCBtZXRob2QgdG8gYXZvaWQgZGVmaW5pbmcgd2hhdCBpcyBgaGFzYC5cbiAgLy8gKFdlIHVzdWFsbHkgdHJlYXQgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcyB0aGUgc2FtZSwgZGlmZmVyZW50XG4gIC8vIGZyb20gRVM2IE1hcCkuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV0gPSB2YWx1ZTsgLy8gQ29tcGFyaW5nIHdpdGggaW52b2NhdGlvbiBjaGFpbmluZywgYHJldHVybiB2YWx1ZWAgaXMgbW9yZSBjb21tb25seVxuICAgIC8vIHVzZWQgaW4gdGhpcyBjYXNlOiBgdmFyIHNvbWVWYWwgPSBtYXAuc2V0KCdhJywgZ2VuVmFsKCkpO2BcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgLy8gQWx0aG91Z2ggdXRpbC5lYWNoIGNhbiBiZSBwZXJmb3JtZWQgb24gdGhpcyBoYXNoTWFwIGRpcmVjdGx5LCB1c2VyXG4gIC8vIHNob3VsZCBub3QgdXNlIHRoZSBleHBvc2VkIGtleXMsIHdobyBhcmUgcHJlZml4ZWQuXG4gIGVhY2g6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGNvbnRleHQgIT09IHZvaWQgMCAmJiAoY2IgPSBiaW5kKGNiLCBjb250ZXh0KSk7XG5cbiAgICBmb3IgKHZhciBwcmVmaXhlZEtleSBpbiB0aGlzKSB7XG4gICAgICB0aGlzLmhhc093blByb3BlcnR5KHByZWZpeGVkS2V5KSAmJiBjYih0aGlzW3ByZWZpeGVkS2V5XSwgcHJlZml4ZWRLZXkuc2xpY2UoSEFTSF9NQVBfUFJFRklYX0xFTkdUSCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBpZiBwZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gIHJlbW92ZUtleTogZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hNYXAob2JqKSB7XG4gIHJldHVybiBuZXcgSGFzaE1hcChvYmopO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0cy4kb3ZlcnJpZGUgPSAkb3ZlcnJpZGU7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG5leHBvcnRzLm1lcmdlQWxsID0gbWVyZ2VBbGw7XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbmV4cG9ydHMuY3JlYXRlQ2FudmFzID0gY3JlYXRlQ2FudmFzO1xuZXhwb3J0cy5nZXRDb250ZXh0ID0gZ2V0Q29udGV4dDtcbmV4cG9ydHMuaW5kZXhPZiA9IGluZGV4T2Y7XG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5leHBvcnRzLm1peGluID0gbWl4aW47XG5leHBvcnRzLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG5leHBvcnRzLmVhY2ggPSBlYWNoO1xuZXhwb3J0cy5tYXAgPSBtYXA7XG5leHBvcnRzLnJlZHVjZSA9IHJlZHVjZTtcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuZXhwb3J0cy5maW5kID0gZmluZDtcbmV4cG9ydHMuYmluZCA9IGJpbmQ7XG5leHBvcnRzLmN1cnJ5ID0gY3Vycnk7XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNCdWlsdEluT2JqZWN0ID0gaXNCdWlsdEluT2JqZWN0O1xuZXhwb3J0cy5pc0RvbSA9IGlzRG9tO1xuZXhwb3J0cy5lcU5hTiA9IGVxTmFOO1xuZXhwb3J0cy5yZXRyaWV2ZSA9IHJldHJpZXZlO1xuZXhwb3J0cy5yZXRyaWV2ZTIgPSByZXRyaWV2ZTI7XG5leHBvcnRzLnJldHJpZXZlMyA9IHJldHJpZXZlMztcbmV4cG9ydHMuc2xpY2UgPSBzbGljZTtcbmV4cG9ydHMubm9ybWFsaXplQ3NzQXJyYXkgPSBub3JtYWxpemVDc3NBcnJheTtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy5zZXRBc1ByaW1pdGl2ZSA9IHNldEFzUHJpbWl0aXZlO1xuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuZXhwb3J0cy5jcmVhdGVIYXNoTWFwID0gY3JlYXRlSGFzaE1hcDtcbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL1BhdGhcIik7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciB0cmFuc2Zvcm1QYXRoID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtUGF0aFwiKTtcblxuLy8gY29tbWFuZCBjaGFyc1xudmFyIGNjID0gWydtJywgJ00nLCAnbCcsICdMJywgJ3YnLCAnVicsICdoJywgJ0gnLCAneicsICdaJywgJ2MnLCAnQycsICdxJywgJ1EnLCAndCcsICdUJywgJ3MnLCAnUycsICdhJywgJ0EnXTtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIFBJID0gTWF0aC5QSTtcblxudmFyIHZNYWcgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xufTtcblxudmFyIHZSYXRpbyA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodk1hZyh1KSAqIHZNYWcodikpO1xufTtcblxudmFyIHZBbmdsZSA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbn07XG5cbmZ1bmN0aW9uIHByb2Nlc3NBcmMoeDEsIHkxLCB4MiwgeTIsIGZhLCBmcywgcngsIHJ5LCBwc2lEZWcsIGNtZCwgcGF0aCkge1xuICB2YXIgcHNpID0gcHNpRGVnICogKFBJIC8gMTgwLjApO1xuICB2YXIgeHAgPSBtYXRoQ29zKHBzaSkgKiAoeDEgLSB4MikgLyAyLjAgKyBtYXRoU2luKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG4gIHZhciB5cCA9IC0xICogbWF0aFNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wICsgbWF0aENvcyhwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICB2YXIgbGFtYmRhID0geHAgKiB4cCAvIChyeCAqIHJ4KSArIHlwICogeXAgLyAocnkgKiByeSk7XG5cbiAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICByeCAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgIHJ5ICo9IG1hdGhTcXJ0KGxhbWJkYSk7XG4gIH1cblxuICB2YXIgZiA9IChmYSA9PT0gZnMgPyAtMSA6IDEpICogbWF0aFNxcnQoKHJ4ICogcnggKiAocnkgKiByeSkgLSByeCAqIHJ4ICogKHlwICogeXApIC0gcnkgKiByeSAqICh4cCAqIHhwKSkgLyAocnggKiByeCAqICh5cCAqIHlwKSArIHJ5ICogcnkgKiAoeHAgKiB4cCkpKSB8fCAwO1xuICB2YXIgY3hwID0gZiAqIHJ4ICogeXAgLyByeTtcbiAgdmFyIGN5cCA9IGYgKiAtcnkgKiB4cCAvIHJ4O1xuICB2YXIgY3ggPSAoeDEgKyB4MikgLyAyLjAgKyBtYXRoQ29zKHBzaSkgKiBjeHAgLSBtYXRoU2luKHBzaSkgKiBjeXA7XG4gIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMCArIG1hdGhTaW4ocHNpKSAqIGN4cCArIG1hdGhDb3MocHNpKSAqIGN5cDtcbiAgdmFyIHRoZXRhID0gdkFuZ2xlKFsxLCAwXSwgWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XSk7XG4gIHZhciB1ID0gWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIHYgPSBbKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIGRUaGV0YSA9IHZBbmdsZSh1LCB2KTtcblxuICBpZiAodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgZFRoZXRhID0gUEk7XG4gIH1cblxuICBpZiAodlJhdGlvKHUsIHYpID49IDEpIHtcbiAgICBkVGhldGEgPSAwO1xuICB9XG5cbiAgaWYgKGZzID09PSAwICYmIGRUaGV0YSA+IDApIHtcbiAgICBkVGhldGEgPSBkVGhldGEgLSAyICogUEk7XG4gIH1cblxuICBpZiAoZnMgPT09IDEgJiYgZFRoZXRhIDwgMCkge1xuICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBQSTtcbiAgfVxuXG4gIHBhdGguYWRkRGF0YShjbWQsIGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhkYXRhKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyBjb21tYW5kIHN0cmluZ1xuXG5cbiAgdmFyIGNzID0gZGF0YS5yZXBsYWNlKC8tL2csICcgLScpLnJlcGxhY2UoLyAgL2csICcgJykucmVwbGFjZSgvIC9nLCAnLCcpLnJlcGxhY2UoLywsL2csICcsJyk7XG4gIHZhciBuOyAvLyBjcmVhdGUgcGlwZXMgc28gdGhhdCB3ZSBjYW4gc3BsaXQgdGhlIGRhdGFcblxuICBmb3IgKG4gPSAwOyBuIDwgY2MubGVuZ3RoOyBuKyspIHtcbiAgICBjcyA9IGNzLnJlcGxhY2UobmV3IFJlZ0V4cChjY1tuXSwgJ2cnKSwgJ3wnICsgY2Nbbl0pO1xuICB9IC8vIGNyZWF0ZSBhcnJheVxuXG5cbiAgdmFyIGFyciA9IGNzLnNwbGl0KCd8Jyk7IC8vIGluaXQgY29udGV4dCBwb2ludFxuXG4gIHZhciBjcHggPSAwO1xuICB2YXIgY3B5ID0gMDtcbiAgdmFyIHBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gIHZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xuICB2YXIgcHJldkNtZDtcblxuICBmb3IgKG4gPSAxOyBuIDwgYXJyLmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIHN0ciA9IGFycltuXTtcbiAgICB2YXIgYyA9IHN0ci5jaGFyQXQoMCk7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIHAgPSBzdHIuc2xpY2UoMSkucmVwbGFjZSgvZSwtL2csICdlLScpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGNtZDtcblxuICAgIGlmIChwLmxlbmd0aCA+IDAgJiYgcFswXSA9PT0gJycpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBbaV0gPSBwYXJzZUZsb2F0KHBbaV0pO1xuICAgIH1cblxuICAgIHdoaWxlIChvZmYgPCBwLmxlbmd0aCAmJiAhaXNOYU4ocFtvZmZdKSkge1xuICAgICAgaWYgKGlzTmFOKHBbMF0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3RsUHR4O1xuICAgICAgdmFyIGN0bFB0eTtcbiAgICAgIHZhciByeDtcbiAgICAgIHZhciByeTtcbiAgICAgIHZhciBwc2k7XG4gICAgICB2YXIgZmE7XG4gICAgICB2YXIgZnM7XG4gICAgICB2YXIgeDEgPSBjcHg7XG4gICAgICB2YXIgeTEgPSBjcHk7IC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuXG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGMgPSAnbCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgIGMgPSAnTCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSk7XG4gICAgICAgICAgY3B4ID0gcFtvZmYgLSAyXTtcbiAgICAgICAgICBjcHkgPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSwgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5LCBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHkpO1xuICAgICAgICAgIGNweCArPSBwW29mZiAtIDJdO1xuICAgICAgICAgIGNweSArPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcblxuICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHgxID0gY3B4ICsgcFtvZmYrK107XG4gICAgICAgICAgeTEgPSBjcHkgKyBwW29mZisrXTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICB4MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHkxID0gcFtvZmYrK107XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgeDEgPSBwW29mZisrXSArIGNweDtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdICsgY3B5O1xuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG5cbiAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgcnkgPSBwW29mZisrXTtcbiAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGZzID0gcFtvZmYrK107XG4gICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYyA9PT0gJ3onIHx8IGMgPT09ICdaJykge1xuICAgICAgY21kID0gQ01ELlo7XG4gICAgICBwYXRoLmFkZERhdGEoY21kKTtcbiAgICB9XG5cbiAgICBwcmV2Q21kID0gY21kO1xuICB9XG5cbiAgcGF0aC50b1N0YXRpYygpO1xuICByZXR1cm4gcGF0aDtcbn0gLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykge1xuICB2YXIgcGF0aFByb3h5ID0gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhzdHIpO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHBhdGguc2V0RGF0YSkge1xuICAgICAgcGF0aC5zZXREYXRhKHBhdGhQcm94eS5kYXRhKTsgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG5cbiAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdHggPSBwYXRoO1xuICAgICAgcGF0aFByb3h5LnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgfVxuICB9O1xuXG4gIG9wdHMuYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobSkge1xuICAgIHRyYW5zZm9ybVBhdGgocGF0aFByb3h5LCBtKTtcbiAgICB0aGlzLmRpcnR5KHRydWUpO1xuICB9O1xuXG4gIHJldHVybiBvcHRzO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBQYXRoIG9iamVjdCBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRnJvbVN0cmluZyhzdHIsIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBQYXRoKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBQYXRoIGNsYXNzIGZyb20gcGF0aCBzdHJpbmcgZGF0YVxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPdGhlciBvcHRpb25zXG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmRGcm9tU3RyaW5nKHN0ciwgb3B0cykge1xuICByZXR1cm4gUGF0aC5leHRlbmQoY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSk7XG59XG4vKipcbiAqIE1lcmdlIG11bHRpcGxlIHBhdGhzXG4gKi9cbi8vIFRPRE8gQXBwbHkgdHJhbnNmb3JtXG4vLyBUT0RPIHN0cm9rZSBkYXNoXG4vLyBUT0RPIE9wdGltaXplIGRvdWJsZSBtZW1vcnkgY29zdCBwcm9ibGVtXG5cblxuZnVuY3Rpb24gbWVyZ2VQYXRoKHBhdGhFbHMsIG9wdHMpIHtcbiAgdmFyIHBhdGhMaXN0ID0gW107XG4gIHZhciBsZW4gPSBwYXRoRWxzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBhdGhFbCA9IHBhdGhFbHNbaV07XG5cbiAgICBpZiAoIXBhdGhFbC5wYXRoKSB7XG4gICAgICBwYXRoRWwuY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGhFbC5fX2RpcnR5UGF0aCkge1xuICAgICAgcGF0aEVsLmJ1aWxkUGF0aChwYXRoRWwucGF0aCwgcGF0aEVsLnNoYXBlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwYXRoTGlzdC5wdXNoKHBhdGhFbC5wYXRoKTtcbiAgfVxuXG4gIHZhciBwYXRoQnVuZGxlID0gbmV3IFBhdGgob3B0cyk7IC8vIE5lZWQgcGF0aCBwcm94eS5cblxuICBwYXRoQnVuZGxlLmNyZWF0ZVBhdGhQcm94eSgpO1xuXG4gIHBhdGhCdW5kbGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBwYXRoLmFwcGVuZFBhdGgocGF0aExpc3QpOyAvLyBTdmcgYW5kIHZtbCByZW5kZXJlciBkb24ndCBoYXZlIGNvbnRleHRcblxuICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHBhdGhCdW5kbGU7XG59XG5cbmV4cG9ydHMuY3JlYXRlRnJvbVN0cmluZyA9IGNyZWF0ZUZyb21TdHJpbmc7XG5leHBvcnRzLmV4dGVuZEZyb21TdHJpbmcgPSBleHRlbmRGcm9tU3RyaW5nO1xuZXhwb3J0cy5tZXJnZVBhdGggPSBtZXJnZVBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBwYXRoQ29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3BhdGhcIik7XG5cbnZhciBQYXR0ZXJuID0gcmVxdWlyZShcIi4vUGF0dGVyblwiKTtcblxudmFyIGdldENhbnZhc1BhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBhdGhQcm94eUZvckRyYXcgPSBuZXcgUGF0aFByb3h5KHRydWUpO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cblxuZnVuY3Rpb24gUGF0aChvcHRzKSB7XG4gIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqIEByZWFkT25seVxuICAgKi9cblxuICB0aGlzLnBhdGggPSBudWxsO1xufVxuXG5QYXRoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFBhdGgsXG4gIHR5cGU6ICdwYXRoJyxcbiAgX19kaXJ0eVBhdGg6IHRydWUsXG4gIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IDUsXG4gIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoIHx8IHBhdGhQcm94eUZvckRyYXc7XG4gICAgdmFyIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpO1xuICAgIHZhciBoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpO1xuICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcbiAgICB2YXIgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgIHZhciBoYXNGaWxsR3JhZGllbnQgPSBoYXNGaWxsICYmICEhZmlsbC5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNTdHJva2VHcmFkaWVudCA9IGhhc1N0cm9rZSAmJiAhIXN0cm9rZS5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNGaWxsUGF0dGVybiA9IGhhc0ZpbGwgJiYgISFmaWxsLmltYWdlO1xuICAgIHZhciBoYXNTdHJva2VQYXR0ZXJuID0gaGFzU3Ryb2tlICYmICEhc3Ryb2tlLmltYWdlO1xuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5KSB7XG4gICAgICB2YXIgcmVjdDsgLy8gVXBkYXRlIGdyYWRpZW50IGJlY2F1c2UgYm91bmRpbmcgcmVjdCBtYXkgY2hhbmdlZFxuXG4gICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgZmlsbCwgcmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICByZWN0ID0gcmVjdCB8fCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB0aGlzLl9zdHJva2VHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgc3Ryb2tlLCByZWN0KTtcbiAgICAgIH1cbiAgICB9IC8vIFVzZSB0aGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuXG5cbiAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAvLyBQRU5ESU5HIElmIG1heSBoYXZlIGFmZmVjdCB0aGUgc3RhdGVcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9maWxsR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNGaWxsUGF0dGVybikge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGdldENhbnZhc1BhdHRlcm4uY2FsbChmaWxsLCBjdHgpO1xuICAgIH1cblxuICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNTdHJva2VQYXR0ZXJuKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoc3Ryb2tlLCBjdHgpO1xuICAgIH1cblxuICAgIHZhciBsaW5lRGFzaCA9IHN0eWxlLmxpbmVEYXNoO1xuICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IHN0eWxlLmxpbmVEYXNoT2Zmc2V0O1xuICAgIHZhciBjdHhMaW5lRGFzaCA9ICEhY3R4LnNldExpbmVEYXNoOyAvLyBVcGRhdGUgcGF0aCBzeCwgc3lcblxuICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICBwYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7IC8vIFByb3h5IGNvbnRleHRcbiAgICAvLyBSZWJ1aWxkIHBhdGggaW4gZm9sbG93aW5nIDIgY2FzZXNcbiAgICAvLyAxLiBQYXRoIGlzIGRpcnR5XG4gICAgLy8gMi4gUGF0aCBuZWVkcyBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmVEYXNoIHN0cm9raW5nLlxuICAgIC8vICAgIEluIHRoaXMgY2FzZSwgbGluZURhc2ggaW5mb3JtYXRpb24gd2lsbCBub3QgYmUgc2F2ZWQgaW4gUGF0aFByb3h5XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCB8fCBsaW5lRGFzaCAmJiAhY3R4TGluZURhc2ggJiYgaGFzU3Ryb2tlKSB7XG4gICAgICBwYXRoLmJlZ2luUGF0aChjdHgpOyAvLyBTZXR0aW5nIGxpbmUgZGFzaCBiZWZvcmUgYnVpbGQgcGF0aFxuXG4gICAgICBpZiAobGluZURhc2ggJiYgIWN0eExpbmVEYXNoKSB7XG4gICAgICAgIHBhdGguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICBwYXRoLnNldExpbmVEYXNoT2Zmc2V0KGxpbmVEYXNoT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpOyAvLyBDbGVhciBwYXRoIGRpcnR5IGZsYWdcblxuICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcGxheSBwYXRoIGJ1aWxkaW5nXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLnBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICB9XG5cbiAgICBoYXNGaWxsICYmIHBhdGguZmlsbChjdHgpO1xuXG4gICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgfVxuXG4gICAgaGFzU3Ryb2tlICYmIHBhdGguc3Ryb2tlKGN0eCk7XG5cbiAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgIC8vIFBFTkRJTkdcbiAgICAgIC8vIFJlbW92ZSBsaW5lRGFzaFxuICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTsgLy8gRHJhdyByZWN0IHRleHRcblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgfVxuICB9LFxuICAvLyBXaGVuIGJ1bmRsaW5nIHBhdGgsIHNvbWUgc2hhcGUgbWF5IGRlY2lkZSBpZiB1c2UgbW92ZVRvIHRvIGJlZ2luIGEgbmV3IHN1YnBhdGggb3IgY2xvc2VQYXRoXG4gIC8vIExpa2UgaW4gY2lyY2xlXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGVDZmcsIGluQnVuZGxlKSB7fSxcbiAgY3JlYXRlUGF0aFByb3h5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICB9LFxuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuX3JlY3Q7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgbmVlZHNVcGRhdGVSZWN0ID0gIXJlY3Q7XG5cbiAgICBpZiAobmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcblxuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBwYXRoIG9uIGRlbWFuZC5cbiAgICAgICAgcGF0aCA9IHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWN0ID0gcmVjdDtcblxuICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgLy8gTmVlZHMgdXBkYXRlIHJlY3Qgd2l0aCBzdHJva2UgbGluZVdpZHRoIHdoZW5cbiAgICAgIC8vIDEuIEVsZW1lbnQgY2hhbmdlcyBzY2FsZSBvciBsaW5lV2lkdGhcbiAgICAgIC8vIDIuIFNoYXBlIGlzIGNoYW5nZWRcbiAgICAgIHZhciByZWN0V2l0aFN0cm9rZSA9IHRoaXMuX3JlY3RXaXRoU3Ryb2tlIHx8ICh0aGlzLl9yZWN0V2l0aFN0cm9rZSA9IHJlY3QuY2xvbmUoKSk7XG5cbiAgICAgIGlmICh0aGlzLl9fZGlydHkgfHwgbmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgIHJlY3RXaXRoU3Ryb2tlLmNvcHkocmVjdCk7IC8vIEZJWE1FIE11c3QgYWZ0ZXIgdXBkYXRlVHJhbnNmb3JtXG5cbiAgICAgICAgdmFyIHcgPSBzdHlsZS5saW5lV2lkdGg7IC8vIFBFTkRJTkcsIE1pbiBsaW5lIHdpZHRoIGlzIG5lZWRlZCB3aGVuIGxpbmUgaXMgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbFxuXG4gICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7IC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG5cbiAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICB3ID0gTWF0aC5tYXgodywgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkIHx8IDQpO1xuICAgICAgICB9IC8vIENvbnNpZGVyIGxpbmUgd2lkdGhcbiAgICAgICAgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG5cbiAgICAgICAgaWYgKGxpbmVTY2FsZSA+IDFlLTEwKSB7XG4gICAgICAgICAgcmVjdFdpdGhTdHJva2Uud2lkdGggKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS5oZWlnaHQgKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS54IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnkgLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmV0dXJuIHJlY3Qgd2l0aCBzdHJva2VcblxuXG4gICAgICByZXR1cm4gcmVjdFdpdGhTdHJva2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3Q7XG4gIH0sXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGxvY2FsUG9zID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgeCA9IGxvY2FsUG9zWzBdO1xuICAgIHkgPSBsb2NhbFBvc1sxXTtcblxuICAgIGlmIChyZWN0LmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMucGF0aC5kYXRhO1xuXG4gICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIGxpbmVTY2FsZSA9IHN0eWxlLnN0cm9rZU5vU2NhbGUgPyB0aGlzLmdldExpbmVTY2FsZSgpIDogMTsgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG4gICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgIC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG4gICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IE1hdGgubWF4KGxpbmVXaWR0aCwgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aENvbnRhaW4uY29udGFpblN0cm9rZShwYXRoRGF0YSwgbGluZVdpZHRoIC8gbGluZVNjYWxlLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhDb250YWluLmNvbnRhaW4ocGF0aERhdGEsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZGlydHlQYXRoXG4gICAqL1xuICBkaXJ0eTogZnVuY3Rpb24gKGRpcnR5UGF0aCkge1xuICAgIGlmIChkaXJ0eVBhdGggPT0gbnVsbCkge1xuICAgICAgZGlydHlQYXRoID0gdHJ1ZTtcbiAgICB9IC8vIE9ubHkgbWFyayBkaXJ0eSwgbm90IG1hcmsgY2xlYW5cblxuXG4gICAgaWYgKGRpcnR5UGF0aCkge1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7IC8vIFVzZWQgYXMgYSBjbGlwcGluZyBwYXRoXG5cbiAgICBpZiAodGhpcy5fX2NsaXBUYXJnZXQpIHtcbiAgICAgIHRoaXMuX19jbGlwVGFyZ2V0LmRpcnR5KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc2hhcGUnKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICovXG4gIGFuaW1hdGVTaGFwZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzaGFwZScsIGxvb3ApO1xuICB9LFxuICAvLyBPdmVyd3JpdGUgYXR0cktWXG4gIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAvLyBGSVhNRVxuICAgIGlmIChrZXkgPT09ICdzaGFwZScpIHtcbiAgICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IHRydWU7XG4gICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgRGlzcGxheWFibGUucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0U2hhcGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTsgLy8gUGF0aCBmcm9tIHN0cmluZyBtYXkgbm90IGhhdmUgc2hhcGVcblxuICAgIGlmIChzaGFwZSkge1xuICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChrZXkpKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgc2hhcGVbbmFtZV0gPSBrZXlbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZVtrZXldID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGlydHkodHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGdldExpbmVTY2FsZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07IC8vIEdldCB0aGUgbGluZSBzY2FsZS5cbiAgICAvLyBEZXRlcm1pbmFudCBvZiBgbWAgbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXG4gICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgIC8vIGZvciB3aWR0aC5cblxuICAgIHJldHVybiBtICYmIGFicyhtWzBdIC0gMSkgPiAxZS0xMCAmJiBhYnMobVszXSAtIDEpID4gMWUtMTAgPyBNYXRoLnNxcnQoYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pKSA6IDE7XG4gIH1cbn07XG4vKipcbiAqIOaJqeWxleS4gOS4qiBQYXRoIGVsZW1lbnQsIOavlOWmguaYn+W9ou+8jOWchuetieOAglxuICogRXh0ZW5kIGEgcGF0aCBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy50eXBlIFBhdGggdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuaW5pdCBJbml0aWFsaXplXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9wcy5idWlsZFBhdGggT3ZlcndyaXRlIGJ1aWxkUGF0aCBtZXRob2RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc3R5bGVdIEV4dGVuZGVkIGRlZmF1bHQgc3R5bGUgY29uZmlnXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnNoYXBlXSBFeHRlbmRlZCBkZWZhdWx0IHNoYXBlIGNvbmZpZ1xuICovXG5cblBhdGguZXh0ZW5kID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gIHZhciBTdWIgPSBmdW5jdGlvbiAob3B0cykge1xuICAgIFBhdGguY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgIGlmIChkZWZhdWx0cy5zdHlsZSkge1xuICAgICAgLy8gRXh0ZW5kIGRlZmF1bHQgc3R5bGVcbiAgICAgIHRoaXMuc3R5bGUuZXh0ZW5kRnJvbShkZWZhdWx0cy5zdHlsZSwgZmFsc2UpO1xuICAgIH0gLy8gRXh0ZW5kIGRlZmF1bHQgc2hhcGVcblxuXG4gICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xuXG4gICAgaWYgKGRlZmF1bHRTaGFwZSkge1xuICAgICAgdGhpcy5zaGFwZSA9IHRoaXMuc2hhcGUgfHwge307XG4gICAgICB2YXIgdGhpc1NoYXBlID0gdGhpcy5zaGFwZTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0U2hhcGUpIHtcbiAgICAgICAgaWYgKCF0aGlzU2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgZGVmYXVsdFNoYXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdGhpc1NoYXBlW25hbWVdID0gZGVmYXVsdFNoYXBlW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVmYXVsdHMuaW5pdCAmJiBkZWZhdWx0cy5pbml0LmNhbGwodGhpcywgb3B0cyk7XG4gIH07XG5cbiAgenJVdGlsLmluaGVyaXRzKFN1YiwgUGF0aCk7IC8vIEZJWE1FIOS4jeiDvSBleHRlbmQgcG9zaXRpb24sIHJvdGF0aW9uIOetieW8leeUqOWvueixoVxuXG4gIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAvLyBFeHRlbmRpbmcgcHJvdG90eXBlIHZhbHVlcyBhbmQgbWV0aG9kc1xuICAgIGlmIChuYW1lICE9PSAnc3R5bGUnICYmIG5hbWUgIT09ICdzaGFwZScpIHtcbiAgICAgIFN1Yi5wcm90b3R5cGVbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gU3ViO1xufTtcblxuenJVdGlsLmluaGVyaXRzKFBhdGgsIERpc3BsYXlhYmxlKTtcbnZhciBfZGVmYXVsdCA9IFBhdGg7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuL1N0eWxlXCIpO1xuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoXCIuLi9FbGVtZW50XCIpO1xuXG52YXIgUmVjdFRleHQgPSByZXF1aXJlKFwiLi9taXhpbi9SZWN0VGV4dFwiKTtcblxuLyoqXG4gKiDlj6/nu5jliLbnmoTlm77lvaLln7rnsbtcbiAqIEJhc2UgY2xhc3Mgb2YgYWxsIGRpc3BsYXlhYmxlIGdyYXBoaWMgb2JqZWN0c1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqL1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9FbGVtZW50XG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL21peGluL1JlY3RUZXh0XG4gKi9cbmZ1bmN0aW9uIERpc3BsYXlhYmxlKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTsgLy8gRXh0ZW5kIHByb3BlcnRpZXNcblxuICBmb3IgKHZhciBuYW1lIGluIG9wdHMpIHtcbiAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBuYW1lICE9PSAnc3R5bGUnKSB7XG4gICAgICB0aGlzW25hbWVdID0gb3B0c1tuYW1lXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfVxuICAgKi9cblxuXG4gIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob3B0cy5zdHlsZSwgdGhpcyk7XG4gIHRoaXMuX3JlY3QgPSBudWxsOyAvLyBTaGFwZXMgZm9yIGNhc2NhZGUgY2xpcHBpbmcuXG5cbiAgdGhpcy5fX2NsaXBQYXRocyA9IFtdOyAvLyBGSVhNRSBTdGF0ZWZ1bCBtdXN0IGJlIG1peGluZWQgYWZ0ZXIgc3R5bGUgaXMgc2V0dGVkXG4gIC8vIFN0YXRlZnVsLmNhbGwodGhpcywgb3B0cyk7XG59XG5cbkRpc3BsYXlhYmxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERpc3BsYXlhYmxlLFxuICB0eXBlOiAnZGlzcGxheWFibGUnLFxuXG4gIC8qKlxuICAgKiBEaXNwbGF5YWJsZSDmmK/lkKbkuLrohI/vvIxQYWludGVyIOS4reS8muagueaNruivpeagh+iusOWIpOaWreaYr+WQpumcgOimgeaYr+WQpumcgOimgemHjeaWsOe7mOWItlxuICAgKiBEaXJ0eSBmbGFnLiBGcm9tIHdoaWNoIHBhaW50ZXIgd2lsbCBkZXRlcm1pbmUgaWYgdGhpcyBkaXNwbGF5YWJsZSBvYmplY3QgbmVlZHMgYnJ1c2hcbiAgICogQG5hbWUgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNfX2RpcnR5XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgX19kaXJ0eTogdHJ1ZSxcblxuICAvKipcbiAgICog5Zu+5b2i5piv5ZCm5Y+v6KeB77yM5Li6dHJ1ZeaXtuS4jee7mOWItuWbvuW9ou+8jOS9huaYr+S7jeiDveinpuWPkem8oOagh+S6i+S7tlxuICAgKiBJZiBpZ25vcmUgZHJhd2luZyBvZiB0aGUgZGlzcGxheWFibGUgb2JqZWN0LiBNb3VzZSBldmVudCB3aWxsIHN0aWxsIGJlIHRyaWdnZXJlZFxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNpbnZpc2libGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpbnZpc2libGU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHo6IDAsXG5cbiAgLyoqXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgejI6IDAsXG5cbiAgLyoqXG4gICAqIHrlsYJsZXZlbO+8jOWGs+Wumue7mOeUu+WcqOWTquWxgmNhbnZhc+S4rVxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6bGV2ZWxcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgemxldmVsOiAwLFxuXG4gIC8qKlxuICAgKiDmmK/lkKblj6/mi5bmi71cbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJhZ2dhYmxlOiBmYWxzZSxcblxuICAvKipcbiAgICog5piv5ZCm5q2j5Zyo5ouW5ou9XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2RyYWdnYWJsZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRyYWdnaW5nOiBmYWxzZSxcblxuICAvKipcbiAgICog5piv5ZCm55u45bqU6byg5qCH5LqL5Lu2XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3NpbGVudFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIElmIGVuYWJsZSBjdWxsaW5nXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgY3VsbGluZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIE1vdXNlIGN1cnNvciB3aGVuIGhvdmVyZWRcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjY3Vyc29yXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBjdXJzb3I6ICdwb2ludGVyJyxcblxuICAvKipcbiAgICogSWYgaG92ZXIgYXJlYSBpcyBib3VuZGluZyByZWN0XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3JlY3RIb3ZlclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgcmVjdEhvdmVyOiBmYWxzZSxcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBlbGVtZW50IHByb2dyZXNzaXZlbHkgd2hlbiB0aGUgdmFsdWUgPj0gMCxcbiAgICogdXNlZnVsbCBmb3IgbGFyZ2UgZGF0YS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHByb2dyZXNzaXZlOiAtMSxcbiAgYmVmb3JlQnJ1c2g6IGZ1bmN0aW9uIChjdHgpIHt9LFxuICBhZnRlckJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcblxuICAvKipcbiAgICog5Zu+5b2i57uY5Yi25pa55rOVXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICovXG4gIC8vIEludGVyZmFjZVxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7fSxcblxuICAvKipcbiAgICog6I635Y+W5pyA5bCP5YyF5Zu055uSXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgLy8gSW50ZXJmYWNlXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge30sXG5cbiAgLyoqXG4gICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9ouS4ilxuICAgKiBJZiBkaXNwbGF5YWJsZSBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLnJlY3RDb250YWluKHgsIHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICovXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDliKTmlq3lnZDmoIcgeCwgeSDmmK/lkKblnKjlm77lvaLnmoTljIXlm7Tnm5LkuIpcbiAgICogSWYgYm91bmRpbmcgcmVjdCBvZiBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICByZWN0Q29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgY29vcmQgPSB0aGlzLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCh4LCB5KTtcbiAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgcmV0dXJuIHJlY3QuY29udGFpbihjb29yZFswXSwgY29vcmRbMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmoIforrDlm77lvaLlhYPntKDkuLrohI/vvIzlubbkuJTlnKjkuIvkuIDluKfph43nu5hcbiAgICogTWFyayBkaXNwbGF5YWJsZSBlbGVtZW50IGRpcnR5IGFuZCByZWZyZXNoIG5leHQgZnJhbWVcbiAgICovXG4gIGRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICog5Zu+5b2i5piv5ZCm5Lya6Kem5Y+R5LqL5Lu2XG4gICAqIElmIGRpc3BsYXlhYmxlIG9iamVjdCBiaW5kZWQgYW55IGV2ZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICAvLyBUT0RPLCDpgJrov4cgYmluZCDnu5HlrprnmoTkuovku7ZcbiAgLy8gaXNTaWxlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgLy8gICAgIHJldHVybiAhKFxuICAvLyAgICAgICAgIHRoaXMuaG92ZXJhYmxlIHx8IHRoaXMuZHJhZ2dhYmxlXG4gIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlbW92ZSB8fCB0aGlzLm9ubW91c2VvdmVyIHx8IHRoaXMub25tb3VzZW91dFxuICAvLyAgICAgICAgIHx8IHRoaXMub25tb3VzZWRvd24gfHwgdGhpcy5vbm1vdXNldXAgfHwgdGhpcy5vbmNsaWNrXG4gIC8vICAgICAgICAgfHwgdGhpcy5vbmRyYWdlbnRlciB8fCB0aGlzLm9uZHJhZ292ZXIgfHwgdGhpcy5vbmRyYWdsZWF2ZVxuICAvLyAgICAgICAgIHx8IHRoaXMub25kcm9wXG4gIC8vICAgICApO1xuICAvLyB9LFxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc3R5bGUnKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICovXG4gIGFuaW1hdGVTdHlsZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzdHlsZScsIGxvb3ApO1xuICB9LFxuICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSAhPT0gJ3N0eWxlJykge1xuICAgICAgRWxlbWVudC5wcm90b3R5cGUuYXR0cktWLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3R5bGUuc2V0KHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFN0eWxlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuc3R5bGUuc2V0KGtleSwgdmFsdWUpO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVc2UgZ2l2ZW4gc3R5bGUgb2JqZWN0XG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqXG4gICAqL1xuICB1c2VTdHlsZTogZnVuY3Rpb24gKG9iaikge1xuICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob2JqLCB0aGlzKTtcbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnpyVXRpbC5pbmhlcml0cyhEaXNwbGF5YWJsZSwgRWxlbWVudCk7XG56clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFJlY3RUZXh0KTsgLy8genJVdGlsLm1peGluKERpc3BsYXlhYmxlLCBTdGF0ZWZ1bCk7XG5cbnZhciBfZGVmYXVsdCA9IERpc3BsYXlhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU1RZTEVfQ09NTU9OX1BST1BTID0gW1snc2hhZG93Qmx1cicsIDBdLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLCBbJ2xpbmVDYXAnLCAnYnV0dCddLCBbJ2xpbmVKb2luJywgJ21pdGVyJ10sIFsnbWl0ZXJMaW1pdCcsIDEwXV07IC8vIHZhciBTSEFET1dfUFJPUFMgPSBTVFlMRV9DT01NT05fUFJPUFMuc2xpY2UoMCwgNCk7XG4vLyB2YXIgTElORV9QUk9QUyA9IFNUWUxFX0NPTU1PTl9QUk9QUy5zbGljZSg0KTtcblxudmFyIFN0eWxlID0gZnVuY3Rpb24gKG9wdHMsIGhvc3QpIHtcbiAgdGhpcy5leHRlbmRGcm9tKG9wdHMsIGZhbHNlKTtcbiAgdGhpcy5ob3N0ID0gaG9zdDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmVhckdyYWRpZW50KGN0eCwgb2JqLCByZWN0KSB7XG4gIHZhciB4ID0gb2JqLnggPT0gbnVsbCA/IDAgOiBvYmoueDtcbiAgdmFyIHgyID0gb2JqLngyID09IG51bGwgPyAxIDogb2JqLngyO1xuICB2YXIgeSA9IG9iai55ID09IG51bGwgPyAwIDogb2JqLnk7XG4gIHZhciB5MiA9IG9iai55MiA9PSBudWxsID8gMCA6IG9iai55MjtcblxuICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICB4ID0geCAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgeDIgPSB4MiAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgeSA9IHkgKiByZWN0LmhlaWdodCArIHJlY3QueTtcbiAgICB5MiA9IHkyICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gIH1cblxuICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeDIsIHkyKTtcbiAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSYWRpYWxHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIHZhciBtaW4gPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIHggPSBvYmoueCA9PSBudWxsID8gMC41IDogb2JqLng7XG4gIHZhciB5ID0gb2JqLnkgPT0gbnVsbCA/IDAuNSA6IG9iai55O1xuICB2YXIgciA9IG9iai5yID09IG51bGwgPyAwLjUgOiBvYmoucjtcblxuICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICB4ID0geCAqIHdpZHRoICsgcmVjdC54O1xuICAgIHkgPSB5ICogaGVpZ2h0ICsgcmVjdC55O1xuICAgIHIgPSByICogbWluO1xuICB9XG5cbiAgdmFyIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgsIHksIDAsIHgsIHksIHIpO1xuICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG59XG5cblN0eWxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFN0eWxlLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX1cbiAgICovXG4gIGhvc3Q6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmaWxsOiAnIzAwMCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdHJva2U6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBvcGFjaXR5OiAxLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBsaW5lRGFzaDogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGxpbmVEYXNoT2Zmc2V0OiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2hhZG93Qmx1cjogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNoYWRvd09mZnNldFg6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzaGFkb3dPZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbGluZVdpZHRoOiAxLFxuXG4gIC8qKlxuICAgKiBJZiBzdHJva2UgaWdub3JlIHNjYWxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc3Ryb2tlTm9TY2FsZTogZmFsc2UsXG4gIC8vIEJvdW5kaW5nIHJlY3QgdGV4dCBjb25maWd1cmF0aW9uXG4gIC8vIE5vdCBhZmZlY3RlZCBieSBlbGVtZW50IHRyYW5zZm9ybVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dDogbnVsbCxcblxuICAvKipcbiAgICogSWYgYGZvbnRTaXplYCBvciBgZm9udEZhbWlseWAgZXhpc3RzLCBgZm9udGAgd2lsbCBiZSByZXNldCBieVxuICAgKiBgZm9udFNpemVgLCBgZm9udFN0eWxlYCwgYGZvbnRXZWlnaHRgLCBgZm9udEZhbWlseWAuXG4gICAqIFNvIGRvIG5vdCB2aXNpdCBpdCBkaXJlY3RseSBpbiB1cHBlciBhcHBsaWNhdGlvbiAobGlrZSBlY2hhcnRzKSxcbiAgICogYnV0IHVzZSBgY29udGFpbi90ZXh0I21ha2VGb250YCBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udDogbnVsbCxcblxuICAvKipcbiAgICogVGhlIHNhbWUgYXMgZm9udC4gVXNlIGZvbnQgcGxlYXNlLlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEZvbnQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEl0IGhlbHBzIG1lcmdpbmcgcmVzcGVjdGl2ZWx5LCByYXRoZXIgdGhhbiBwYXJzaW5nIGFuIGVudGlyZSBmb250IHN0cmluZy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGZvbnRTdHlsZTogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udFdlaWdodDogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBTaG91bGQgYmUgMTIgYnV0IG5vdCAnMTJweCcuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBmb250U2l6ZTogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udEZhbWlseTogbnVsbCxcblxuICAvKipcbiAgICogUmVzZXJ2ZWQgZm9yIHNwZWNpYWwgZnVuY3RpbmFsaXR5LCBsaWtlICdocicuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0VGFnOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEZpbGw6ICcjMDAwJyxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRTdHJva2U6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0V2lkdGg6IG51bGwsXG5cbiAgLyoqXG4gICAqIE9ubHkgZm9yIHRleHRCYWNrZ3JvdW5kLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEhlaWdodDogbnVsbCxcblxuICAvKipcbiAgICogdGV4dFN0cm9rZSBtYXkgYmUgc2V0IGFzIHNvbWUgY29sb3IgYXMgYSBkZWZhdWx0XG4gICAqIHZhbHVlIGluIHVwcGVyIGFwcGxpY2Fpb24sIHdoZXJlIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAqIG9mIHRleHRTdHJva2VXaWR0aCBzaG91bGQgYmUgMCB0byBtYWtlIHN1cmUgdGhhdFxuICAgKiB1c2VyIGNhbiBjaG9vc2UgdG8gZG8gbm90IHVzZSB0ZXh0IHN0cm9rZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTdHJva2VXaWR0aDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRMaW5lSGVpZ2h0OiBudWxsLFxuXG4gIC8qKlxuICAgKiAnaW5zaWRlJywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSdcbiAgICogW3gsIHldXG4gICAqIEJhc2VkIG9uIHgsIHkgb2YgcmVjdC5cbiAgICogQHR5cGUge3N0cmluZ3xBcnJheS48bnVtYmVyPn1cbiAgICogQGRlZmF1bHQgJ2luc2lkZSdcbiAgICovXG4gIHRleHRQb3NpdGlvbjogJ2luc2lkZScsXG5cbiAgLyoqXG4gICAqIElmIG5vdCBzcGVjaWZpZWQsIHVzZSB0aGUgYm91bmRpbmdSZWN0IG9mIGEgYGRpc3BsYXlhYmxlYC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRleHRSZWN0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBbeCwgeV1cbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgdGV4dE9mZnNldDogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRBbGlnbjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRWZXJ0aWNhbEFsaWduOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dERpc3RhbmNlOiA1LFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFNoYWRvd0JsdXI6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0U2hhZG93T2Zmc2V0WDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTaGFkb3dPZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd0JsdXI6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm94U2hhZG93T2Zmc2V0WDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3hTaGFkb3dPZmZzZXRZOiAwLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRyYW5zZm9ybSB0ZXh0LlxuICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdHJhbnNmb3JtVGV4dDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFRleHQgcm90YXRlIGFyb3VuZCBwb3NpdGlvbiBvZiBQYXRoIG9yIEltYWdlXG4gICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnQgYW5kIHRyYW5zZm9ybVRleHQgaXMgZmFsc2UuXG4gICAqL1xuICB0ZXh0Um90YXRpb246IDAsXG5cbiAgLyoqXG4gICAqIFRleHQgb3JpZ2luIG9mIHRleHQgcm90YXRpb24sIGxpa2UgWzEwLCA0MF0uXG4gICAqIEJhc2VkIG9uIHgsIHkgb2YgcmVjdC5cbiAgICogVXNlZnVsIGluIGxhYmVsIHJvdGF0aW9uIG9mIGNpcmN1bGFyIHN5bWJvbC5cbiAgICogQnkgZGVmYXVsdCwgdGhpcyBvcmlnaW4gaXMgdGV4dFBvc2l0aW9uLlxuICAgKiBDYW4gYmUgJ2NlbnRlcicuXG4gICAqIEB0eXBlIHtzdHJpbmd8QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0ZXh0T3JpZ2luOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEJhY2tncm91bmRDb2xvcjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRCb3JkZXJDb2xvcjogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3JkZXJXaWR0aDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3JkZXJSYWRpdXM6IDAsXG5cbiAgLyoqXG4gICAqIENhbiBiZSBgMmAgb3IgYFsyLCA0XWAgb3IgYFsyLCAzLCA0LCA1XWBcbiAgICogQHR5cGUge251bWJlcnxBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHRleHRQYWRkaW5nOiBudWxsLFxuXG4gIC8qKlxuICAgKiBUZXh0IHN0eWxlcyBmb3IgcmljaCB0ZXh0LlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcmljaDogbnVsbCxcblxuICAvKipcbiAgICoge291dGVyV2lkdGgsIG91dGVySGVpZ2h0LCBlbGxpcHNpcywgcGxhY2Vob2xkZXJ9XG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB0cnVuY2F0ZTogbnVsbCxcblxuICAvKipcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9nbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGJsZW5kOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICBiaW5kOiBmdW5jdGlvbiAoY3R4LCBlbCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcztcbiAgICB2YXIgcHJldlN0eWxlID0gcHJldkVsICYmIHByZXZFbC5zdHlsZTtcbiAgICB2YXIgZmlyc3REcmF3ID0gIXByZXZTdHlsZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IFNUWUxFX0NPTU1PTl9QUk9QU1tpXTtcbiAgICAgIHZhciBzdHlsZU5hbWUgPSBwcm9wWzBdO1xuXG4gICAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlW3N0eWxlTmFtZV0gIT09IHByZXZTdHlsZVtzdHlsZU5hbWVdKSB7XG4gICAgICAgIC8vIEZJWE1FIEludmFsaWQgcHJvcGVydHkgdmFsdWUgd2lsbCBjYXVzZSBzdHlsZSBsZWFrIGZyb20gcHJldmlvdXMgZWxlbWVudC5cbiAgICAgICAgY3R4W3N0eWxlTmFtZV0gPSBzdHlsZVtzdHlsZU5hbWVdIHx8IHByb3BbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZS5maWxsICE9PSBwcmV2U3R5bGUuZmlsbCkge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmZpbGw7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZS5zdHJva2UgIT09IHByZXZTdHlsZS5zdHJva2UpIHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLnN0cm9rZTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlLm9wYWNpdHkgIT09IHByZXZTdHlsZS5vcGFjaXR5KSB7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdHlsZS5vcGFjaXR5ID09IG51bGwgPyAxIDogc3R5bGUub3BhY2l0eTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlLmJsZW5kICE9PSBwcmV2U3R5bGUuYmxlbmQpIHtcbiAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBzdHlsZS5ibGVuZCB8fCAnc291cmNlLW92ZXInO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aCAvICh0aGlzLnN0cm9rZU5vU2NhbGUgJiYgZWwgJiYgZWwuZ2V0TGluZVNjYWxlID8gZWwuZ2V0TGluZVNjYWxlKCkgOiAxKTtcbiAgICB9XG4gIH0sXG4gIGhhc0ZpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmlsbCA9IHRoaXMuZmlsbDtcbiAgICByZXR1cm4gZmlsbCAhPSBudWxsICYmIGZpbGwgIT09ICdub25lJztcbiAgfSxcbiAgaGFzU3Ryb2tlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0cm9rZSA9IHRoaXMuc3Ryb2tlO1xuICAgIHJldHVybiBzdHJva2UgIT0gbnVsbCAmJiBzdHJva2UgIT09ICdub25lJyAmJiB0aGlzLmxpbmVXaWR0aCA+IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dGVuZCBmcm9tIG90aGVyIHN0eWxlXG4gICAqIEBwYXJhbSB7enJlbmRlci9ncmFwaGljL1N0eWxlfSBvdGhlclN0eWxlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcndyaXRlIHRydWU6IG92ZXJ3cmlydGUgYW55IHdheS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2U6IG92ZXJ3cml0ZSBvbmx5IHdoZW4gIXRhcmdldC5oYXNPd25Qcm9wZXJ0eVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlcnM6IG92ZXJ3cml0ZSB3aGVuIHByb3BlcnR5IGlzIG5vdCBudWxsL3VuZGVmaW5lZC5cbiAgICovXG4gIGV4dGVuZEZyb206IGZ1bmN0aW9uIChvdGhlclN0eWxlLCBvdmVyd3JpdGUpIHtcbiAgICBpZiAob3RoZXJTdHlsZSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBvdGhlclN0eWxlKSB7XG4gICAgICAgIGlmIChvdGhlclN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpICYmIChvdmVyd3JpdGUgPT09IHRydWUgfHwgKG92ZXJ3cml0ZSA9PT0gZmFsc2UgPyAhdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA6IG90aGVyU3R5bGVbbmFtZV0gIT0gbnVsbCkpKSB7XG4gICAgICAgICAgdGhpc1tuYW1lXSA9IG90aGVyU3R5bGVbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJhdGNoIHNldHRpbmcgc3R5bGUgd2l0aCBhIGdpdmVuIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IG9ialxuICAgKiBAcGFyYW0geyp9IFtvYmpdXG4gICAqL1xuICBzZXQ6IGZ1bmN0aW9uIChvYmosIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzW29ial0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHRlbmRGcm9tKG9iaiwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZVxuICAgKiBAcmV0dXJuIHt6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld1N0eWxlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICBuZXdTdHlsZS5leHRlbmRGcm9tKHRoaXMsIHRydWUpO1xuICAgIHJldHVybiBuZXdTdHlsZTtcbiAgfSxcbiAgZ2V0R3JhZGllbnQ6IGZ1bmN0aW9uIChjdHgsIG9iaiwgcmVjdCkge1xuICAgIHZhciBtZXRob2QgPSBvYmoudHlwZSA9PT0gJ3JhZGlhbCcgPyBjcmVhdGVSYWRpYWxHcmFkaWVudCA6IGNyZWF0ZUxpbmVhckdyYWRpZW50O1xuICAgIHZhciBjYW52YXNHcmFkaWVudCA9IG1ldGhvZChjdHgsIG9iaiwgcmVjdCk7XG4gICAgdmFyIGNvbG9yU3RvcHMgPSBvYmouY29sb3JTdG9wcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JTdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2FudmFzR3JhZGllbnQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcHNbaV0ub2Zmc2V0LCBjb2xvclN0b3BzW2ldLmNvbG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gIH1cbn07XG52YXIgc3R5bGVQcm90byA9IFN0eWxlLnByb3RvdHlwZTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBTVFlMRV9DT01NT05fUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG5cbiAgaWYgKCEocHJvcFswXSBpbiBzdHlsZVByb3RvKSkge1xuICAgIHN0eWxlUHJvdG9bcHJvcFswXV0gPSBwcm9wWzFdO1xuICB9XG59IC8vIFByb3ZpZGUgZm9yIG90aGVyc1xuXG5cblN0eWxlLmdldEdyYWRpZW50ID0gc3R5bGVQcm90by5nZXRHcmFkaWVudDtcbnZhciBfZGVmYXVsdCA9IFN0eWxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9TdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ3VpZCA9IHJlcXVpcmUoXCIuL2NvcmUvZ3VpZFwiKTtcblxudmFyIEV2ZW50ZnVsID0gcmVxdWlyZShcIi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbnZhciBUcmFuc2Zvcm1hYmxlID0gcmVxdWlyZShcIi4vbWl4aW4vVHJhbnNmb3JtYWJsZVwiKTtcblxudmFyIEFuaW1hdGFibGUgPSByZXF1aXJlKFwiLi9taXhpbi9BbmltYXRhYmxlXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9FbGVtZW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9BbmltYXRhYmxlfVxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9XG4gKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWx9XG4gKi9cbnZhciBFbGVtZW50ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIFRyYW5zZm9ybWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgRXZlbnRmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbiAgQW5pbWF0YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAvKipcbiAgICog55S75biD5YWD57SgSURcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG5cbiAgdGhpcy5pZCA9IG9wdHMuaWQgfHwgZ3VpZCgpO1xufTtcblxuRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiDlhYPntKDnsbvlnotcbiAgICogRWxlbWVudCB0eXBlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0eXBlOiAnZWxlbWVudCcsXG5cbiAgLyoqXG4gICAqIOWFg+e0oOWQjeWtl1xuICAgKiBFbGVtZW50IG5hbWVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIG5hbWU6ICcnLFxuXG4gIC8qKlxuICAgKiBaUmVuZGVyIOWunuS+i+Wvueixoe+8jOS8muWcqCBlbGVtZW50IOa3u+WKoOWIsCB6cmVuZGVyIOWunuS+i+S4reWQjuiHquWKqOi1i+WAvFxuICAgKiBaUmVuZGVyIGluc3RhbmNlIHdpbGwgYmUgYXNzaWduZWQgd2hlbiBlbGVtZW50IGlzIGFzc29jaWF0ZWQgd2l0aCB6cmVuZGVyXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9FbGVtZW50I19fenJcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAqL1xuICBfX3pyOiBudWxsLFxuXG4gIC8qKlxuICAgKiDlm77lvaLmmK/lkKblv73nlaXvvIzkuLp0cnVl5pe25b+955Wl5Zu+5b2i55qE57uY5Yi25Lul5Y+K5LqL5Lu26Kem5Y+RXG4gICAqIElmIGlnbm9yZSBkcmF3aW5nIGFuZCBldmVudHMgb2YgdGhlIGVsZW1lbnQgb2JqZWN0XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9FbGVtZW50I2lnbm9yZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGlnbm9yZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIOeUqOS6juijgeWJqueahOi3r+W+hChzaGFwZSnvvIzmiYDmnIkgR3JvdXAg5YaF55qE6Lev5b6E5Zyo57uY5Yi25pe26YO95Lya6KKr6L+Z5Liq6Lev5b6E6KOB5YmqXG4gICAqIOivpei3r+W+hOS8mue7p+aJv+iiq+ijgeWHj+WvueixoeeahOWPmOaNolxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofVxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC8jY2xpcHBpbmctcmVnaW9uXG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgY2xpcFBhdGg6IG51bGwsXG5cbiAgLyoqXG4gICAqIERyaWZ0IGVsZW1lbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkeCBkeCBvbiB0aGUgZ2xvYmFsIHNwYWNlXG4gICAqIEBwYXJhbSAge251bWJlcn0gZHkgZHkgb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgKi9cbiAgZHJpZnQ6IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgZHkgPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICBkeCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIG0gPSB0aGlzLnRyYW5zZm9ybSA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICB9XG5cbiAgICBtWzRdICs9IGR4O1xuICAgIG1bNV0gKz0gZHk7XG4gICAgdGhpcy5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogSG9vayBiZWZvcmUgdXBkYXRlXG4gICAqL1xuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIC8qKlxuICAgKiBIb29rIGFmdGVyIHVwZGF0ZVxuICAgKi9cbiAgYWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZWFjaCBmcmFtZVxuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAqL1xuICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7fSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicgfHwga2V5ID09PSAnc2NhbGUnIHx8IGtleSA9PT0gJ29yaWdpbicpIHtcbiAgICAgIC8vIENvcHkgdGhlIGFycmF5XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXNba2V5XTtcblxuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgIHRhcmdldCA9IHRoaXNba2V5XSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0WzBdID0gdmFsdWVbMF07XG4gICAgICAgIHRhcmdldFsxXSA9IHZhbHVlWzFdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGVsZW1lbnRcbiAgICovXG4gIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlnbm9yZSA9IHRydWU7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGVsZW1lbnRcbiAgICovXG4gIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlnbm9yZSA9IGZhbHNlO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBhdHRyOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5hdHRyS1Yoa2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHRoaXMuYXR0cktWKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGNsaXBQYXRoXG4gICAqL1xuICBzZXRDbGlwUGF0aDogZnVuY3Rpb24gKGNsaXBQYXRoKSB7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuXG4gICAgaWYgKHpyKSB7XG4gICAgICBjbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgfSAvLyBSZW1vdmUgcHJldmlvdXMgY2xpcCBwYXRoXG5cblxuICAgIGlmICh0aGlzLmNsaXBQYXRoICYmIHRoaXMuY2xpcFBhdGggIT09IGNsaXBQYXRoKSB7XG4gICAgICB0aGlzLnJlbW92ZUNsaXBQYXRoKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGlwUGF0aCA9IGNsaXBQYXRoO1xuICAgIGNsaXBQYXRoLl9fenIgPSB6cjtcbiAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSB0aGlzO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKi9cbiAgcmVtb3ZlQ2xpcFBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoO1xuXG4gICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICBpZiAoY2xpcFBhdGguX196cikge1xuICAgICAgICBjbGlwUGF0aC5yZW1vdmVTZWxmRnJvbVpyKGNsaXBQYXRoLl9fenIpO1xuICAgICAgfVxuXG4gICAgICBjbGlwUGF0aC5fX3pyID0gbnVsbDtcbiAgICAgIGNsaXBQYXRoLl9fY2xpcFRhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLmNsaXBQYXRoID0gbnVsbDtcbiAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkIHNlbGYgZnJvbSB6cmVuZGVyIGluc3RhbmNlLlxuICAgKiBOb3QgcmVjdXJzaXZlbHkgYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgd2hlbiBlbGVtZW50IGFkZGVkIHRvIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICovXG4gIGFkZFNlbGZUb1pyOiBmdW5jdGlvbiAoenIpIHtcbiAgICB0aGlzLl9fenIgPSB6cjsgLy8g5re75Yqg5Yqo55S7XG5cbiAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG5cbiAgICBpZiAoYW5pbWF0b3JzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgdGhpcy5jbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgc2VsZiBmcm9tIHpyZW5kZXIgaW5zdGFuY2UuXG4gICAqIE5vdCByZWN1cnNpdmVseSBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGVsZW1lbnQgYWRkZWQgdG8gc3RvcmFnZS5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgKi9cbiAgcmVtb3ZlU2VsZkZyb21acjogZnVuY3Rpb24gKHpyKSB7XG4gICAgdGhpcy5fX3pyID0gbnVsbDsgLy8g56e76Zmk5Yqo55S7XG5cbiAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG5cbiAgICBpZiAoYW5pbWF0b3JzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB6ci5hbmltYXRpb24ucmVtb3ZlQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgdGhpcy5jbGlwUGF0aC5yZW1vdmVTZWxmRnJvbVpyKHpyKTtcbiAgICB9XG4gIH1cbn07XG56clV0aWwubWl4aW4oRWxlbWVudCwgQW5pbWF0YWJsZSk7XG56clV0aWwubWl4aW4oRWxlbWVudCwgVHJhbnNmb3JtYWJsZSk7XG56clV0aWwubWl4aW4oRWxlbWVudCwgRXZlbnRmdWwpO1xudmFyIF9kZWZhdWx0ID0gRWxlbWVudDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL0VsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiB6cmVuZGVyOiDnlJ/miJDllK/kuIBpZFxuICpcbiAqIEBhdXRob3IgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xudmFyIGlkU3RhcnQgPSAweDA5MDc7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICByZXR1cm4gaWRTdGFydCsrO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL2d1aWQuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog5LqL5Lu25omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbnZhciBhcnJ5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4vKipcbiAqIOS6i+S7tuWIhuWPkeWZqFxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgRXZlbnRmdWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuXyRoYW5kbGVycyA9IHt9O1xufTtcblxuRXZlbnRmdWwucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRXZlbnRmdWwsXG5cbiAgLyoqXG4gICAqIOWNleasoeinpuWPkee7keWumu+8jHRyaWdnZXLlkI7plIDmr4FcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOWTjeW6lOWHveaVsFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKi9cbiAgb25lOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICBpZiAoIWhhbmRsZXIgfHwgIWV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIV9oW2V2ZW50XSkge1xuICAgICAgX2hbZXZlbnRdID0gW107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChfaFtldmVudF1baV0uaCA9PT0gaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICBoOiBoYW5kbGVyLFxuICAgICAgb25lOiB0cnVlLFxuICAgICAgY3R4OiBjb250ZXh0IHx8IHRoaXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDnu5Hlrprkuovku7ZcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAqL1xuICBvbjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgIF9oW2V2ZW50XSA9IFtdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2hbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2hbZXZlbnRdLnB1c2goe1xuICAgICAgaDogaGFuZGxlcixcbiAgICAgIG9uZTogZmFsc2UsXG4gICAgICBjdHg6IGNvbnRleHQgfHwgdGhpc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOaYr+WQpue7keWumuS6huS6i+S7tlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBldmVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNTaWxlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcbiAgICByZXR1cm4gX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOino+e7keS6i+S7tlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXSDkuovku7blpITnkIblh73mlbBcbiAgICovXG4gIG9mZjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgaWYgKCFldmVudCkge1xuICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaWYgKF9oW2V2ZW50XSkge1xuICAgICAgICB2YXIgbmV3TGlzdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gX2hbZXZlbnRdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChfaFtldmVudF1baV1bJ2gnXSAhPSBoYW5kbGVyKSB7XG4gICAgICAgICAgICBuZXdMaXN0LnB1c2goX2hbZXZlbnRdW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfaFtldmVudF0gPSBuZXdMaXN0O1xuICAgICAgfVxuXG4gICAgICBpZiAoX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5LqL5Lu25YiG5Y+RXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodGhpcy5fJGhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgaWYgKGFyZ0xlbiA+IDMpIHtcbiAgICAgICAgYXJncyA9IGFycnlTbGljZS5jYWxsKGFyZ3MsIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnNbdHlwZV07XG4gICAgICB2YXIgbGVuID0gX2gubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgLy8gT3B0aW1pemUgYWR2aXNlIGZyb20gYmFja2JvbmVcbiAgICAgICAgc3dpdGNoIChhcmdMZW4pIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoX2hbaV1bJ2N0eCddKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoX2hbaV1bJ2N0eCddLCBhcmdzWzFdKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfaFtpXVsnaCddLmNhbGwoX2hbaV1bJ2N0eCddLCBhcmdzWzFdLCBhcmdzWzJdKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gaGF2ZSBtb3JlIHRoYW4gMiBnaXZlbiBhcmd1bWVudHNcbiAgICAgICAgICAgIF9oW2ldWydoJ10uYXBwbHkoX2hbaV1bJ2N0eCddLCBhcmdzKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2hbaV1bJ29uZSddKSB7XG4gICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgbGVuLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOW4puaciWNvbnRleHTnmoTkuovku7bliIblj5EsIOacgOWQjuS4gOS4quWPguaVsOaYr+S6i+S7tuWbnuiwg+eahGNvbnRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXG4gICAqL1xuICB0cmlnZ2VyV2l0aENvbnRleHQ6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHRoaXMuXyRoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGlmIChhcmdMZW4gPiA0KSB7XG4gICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgdmFyIGxlbiA9IF9oLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSwgYXJnc1syXSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICBfaFtpXVsnaCddLmFwcGx5KGN0eCwgYXJncyk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgIF9oLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59OyAvLyDlr7nosaHlj6/ku6XpgJrov4cgb254eHh4IOe7keWumuS6i+S7tlxuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmNsaWNrXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW92ZXJcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3V0XG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW1vdmVcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNld2hlZWxcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlZG93blxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V1cFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ1xuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ3N0YXJ0XG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnZW5kXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnZW50ZXJcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdsZWF2ZVxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ292ZXJcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyb3BcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG52YXIgX2RlZmF1bHQgPSBFdmVudGZ1bDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWF0cml4ID0gcmVxdWlyZShcIi4uL2NvcmUvbWF0cml4XCIpO1xuXG52YXIgdmVjdG9yID0gcmVxdWlyZShcIi4uL2NvcmUvdmVjdG9yXCIpO1xuXG4vKipcbiAqIOaPkOS+m+WPmOaNouaJqeWxlVxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgbUlkZW50aXR5ID0gbWF0cml4LmlkZW50aXR5O1xudmFyIEVQU0lMT04gPSA1ZS01O1xuXG5mdW5jdGlvbiBpc05vdEFyb3VuZFplcm8odmFsKSB7XG4gIHJldHVybiB2YWwgPiBFUFNJTE9OIHx8IHZhbCA8IC1FUFNJTE9OO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgVHJhbnNmb3JtYWJsZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9OyAvLyBJZiB0aGVyZSBhcmUgbm8gZ2l2ZW4gcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZVxuXG4gIGlmICghb3B0cy5wb3NpdGlvbikge1xuICAgIC8qKlxuICAgICAqIOW5s+enu1xuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAZGVmYXVsdCBbMCwgMF1cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gWzAsIDBdO1xuICB9XG5cbiAgaWYgKG9wdHMucm90YXRpb24gPT0gbnVsbCkge1xuICAgIC8qKlxuICAgICAqIOaXi+i9rFxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gIH1cblxuICBpZiAoIW9wdHMuc2NhbGUpIHtcbiAgICAvKipcbiAgICAgKiDnvKnmlL5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQGRlZmF1bHQgWzEsIDFdXG4gICAgICovXG4gICAgdGhpcy5zY2FsZSA9IFsxLCAxXTtcbiAgfVxuICAvKipcbiAgICog5peL6L2s5ZKM57yp5pS+55qE5Y6f54K5XG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cblxuXG4gIHRoaXMub3JpZ2luID0gdGhpcy5vcmlnaW4gfHwgbnVsbDtcbn07XG5cbnZhciB0cmFuc2Zvcm1hYmxlUHJvdG8gPSBUcmFuc2Zvcm1hYmxlLnByb3RvdHlwZTtcbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm0gPSBudWxsO1xuLyoqXG4gKiDliKTmlq3mmK/lkKbpnIDopoHmnInlnZDmoIflj5jmjaJcbiAqIOWmguaenOacieWdkOagh+WPmOaNoiwg5YiZ5LuOcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZeS7peWPiueItuiKgueCueeahHRyYW5zZm9ybeiuoeeul+WHuuiHqui6q+eahHRyYW5zZm9ybeefqemYtVxuICovXG5cbnRyYW5zZm9ybWFibGVQcm90by5uZWVkTG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc05vdEFyb3VuZFplcm8odGhpcy5yb3RhdGlvbikgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMucG9zaXRpb25bMF0pIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzFdKSB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVswXSAtIDEpIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnNjYWxlWzFdIC0gMSk7XG59O1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8udXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gIHZhciBwYXJlbnRIYXNUcmFuc2Zvcm0gPSBwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybTtcbiAgdmFyIG5lZWRMb2NhbFRyYW5zZm9ybSA9IHRoaXMubmVlZExvY2FsVHJhbnNmb3JtKCk7XG4gIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKCEobmVlZExvY2FsVHJhbnNmb3JtIHx8IHBhcmVudEhhc1RyYW5zZm9ybSkpIHtcbiAgICBtICYmIG1JZGVudGl0eShtKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBtID0gbSB8fCBtYXRyaXguY3JlYXRlKCk7XG5cbiAgaWYgKG5lZWRMb2NhbFRyYW5zZm9ybSkge1xuICAgIHRoaXMuZ2V0TG9jYWxUcmFuc2Zvcm0obSk7XG4gIH0gZWxzZSB7XG4gICAgbUlkZW50aXR5KG0pO1xuICB9IC8vIOW6lOeUqOeItuiKgueCueWPmOaNolxuXG5cbiAgaWYgKHBhcmVudEhhc1RyYW5zZm9ybSkge1xuICAgIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICAgIG1hdHJpeC5tdWwobSwgcGFyZW50LnRyYW5zZm9ybSwgbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdHJpeC5jb3B5KG0sIHBhcmVudC50cmFuc2Zvcm0pO1xuICAgIH1cbiAgfSAvLyDkv53lrZjov5nkuKrlj5jmjaLnn6npmLVcblxuXG4gIHRoaXMudHJhbnNmb3JtID0gbTtcbiAgdGhpcy5pbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybSB8fCBtYXRyaXguY3JlYXRlKCk7XG4gIG1hdHJpeC5pbnZlcnQodGhpcy5pbnZUcmFuc2Zvcm0sIG0pO1xufTtcblxudHJhbnNmb3JtYWJsZVByb3RvLmdldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgcmV0dXJuIFRyYW5zZm9ybWFibGUuZ2V0TG9jYWxUcmFuc2Zvcm0odGhpcywgbSk7XG59O1xuLyoqXG4gKiDlsIboh6rlt7HnmoR0cmFuc2Zvcm3lupTnlKjliLBjb250ZXh05LiKXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gKi9cblxuXG50cmFuc2Zvcm1hYmxlUHJvdG8uc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuXG4gIGlmIChtKSB7XG4gICAgY3R4LnNldFRyYW5zZm9ybShkcHIgKiBtWzBdLCBkcHIgKiBtWzFdLCBkcHIgKiBtWzJdLCBkcHIgKiBtWzNdLCBkcHIgKiBtWzRdLCBkcHIgKiBtWzVdKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbiAgfVxufTtcblxudHJhbnNmb3JtYWJsZVByb3RvLnJlc3RvcmVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xufTtcblxudmFyIHRtcFRyYW5zZm9ybSA9IFtdO1xuLyoqXG4gKiDliIbop6NgdHJhbnNmb3JtYOefqemYteWIsGBwb3NpdGlvbmAsIGByb3RhdGlvbmAsIGBzY2FsZWBcbiAqL1xuXG50cmFuc2Zvcm1hYmxlUHJvdG8uZGVjb21wb3NlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybSkge1xuICAgIC8vIEdldCBsb2NhbCB0cmFuc2Zvcm0gYW5kIGRlY29tcG9zZSB0aGVtIHRvIHBvc2l0aW9uLCBzY2FsZSwgcm90YXRpb25cbiAgICBtYXRyaXgubXVsKHRtcFRyYW5zZm9ybSwgcGFyZW50LmludlRyYW5zZm9ybSwgbSk7XG4gICAgbSA9IHRtcFRyYW5zZm9ybTtcbiAgfVxuXG4gIHZhciBzeCA9IG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV07XG4gIHZhciBzeSA9IG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM107XG4gIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cbiAgaWYgKGlzTm90QXJvdW5kWmVybyhzeCAtIDEpKSB7XG4gICAgc3ggPSBNYXRoLnNxcnQoc3gpO1xuICB9XG5cbiAgaWYgKGlzTm90QXJvdW5kWmVybyhzeSAtIDEpKSB7XG4gICAgc3kgPSBNYXRoLnNxcnQoc3kpO1xuICB9XG5cbiAgaWYgKG1bMF0gPCAwKSB7XG4gICAgc3ggPSAtc3g7XG4gIH1cblxuICBpZiAobVszXSA8IDApIHtcbiAgICBzeSA9IC1zeTtcbiAgfVxuXG4gIHBvc2l0aW9uWzBdID0gbVs0XTtcbiAgcG9zaXRpb25bMV0gPSBtWzVdO1xuICBzY2FsZVswXSA9IHN4O1xuICBzY2FsZVsxXSA9IHN5O1xuICB0aGlzLnJvdGF0aW9uID0gTWF0aC5hdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xufTtcbi8qKlxuICogR2V0IGdsb2JhbCBzY2FsZVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG50cmFuc2Zvcm1hYmxlUHJvdG8uZ2V0R2xvYmFsU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIFsxLCAxXTtcbiAgfVxuXG4gIHZhciBzeCA9IE1hdGguc3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgdmFyIHN5ID0gTWF0aC5zcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuXG4gIGlmIChtWzBdIDwgMCkge1xuICAgIHN4ID0gLXN4O1xuICB9XG5cbiAgaWYgKG1bM10gPCAwKSB7XG4gICAgc3kgPSAtc3k7XG4gIH1cblxuICByZXR1cm4gW3N4LCBzeV07XG59O1xuLyoqXG4gKiDlj5jmjaLlnZDmoIfkvY3nva7liLAgc2hhcGUg55qE5bGA6YOo5Z2Q5qCH56m66Ze0XG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHZhciB2MiA9IFt4LCB5XTtcbiAgdmFyIGludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtO1xuXG4gIGlmIChpbnZUcmFuc2Zvcm0pIHtcbiAgICB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0odjIsIHYyLCBpbnZUcmFuc2Zvcm0pO1xuICB9XG5cbiAgcmV0dXJuIHYyO1xufTtcbi8qKlxuICog5Y+Y5o2i5bGA6YOo5Z2Q5qCH5L2N572u5Yiw5YWo5bGA5Z2Q5qCH56m66Ze0XG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxudHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybUNvb3JkVG9HbG9iYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICB2YXIgdjIgPSBbeCwgeV07XG4gIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgdHJhbnNmb3JtKTtcbiAgfVxuXG4gIHJldHVybiB2Mjtcbn07XG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRhcmdldC5vcmlnaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXQucm90YXRpb25cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRhcmdldC5wb3NpdGlvblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW21dXG4gKi9cblxuXG5UcmFuc2Zvcm1hYmxlLmdldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKHRhcmdldCwgbSkge1xuICBtID0gbSB8fCBbXTtcbiAgbUlkZW50aXR5KG0pO1xuICB2YXIgb3JpZ2luID0gdGFyZ2V0Lm9yaWdpbjtcbiAgdmFyIHNjYWxlID0gdGFyZ2V0LnNjYWxlIHx8IFsxLCAxXTtcbiAgdmFyIHJvdGF0aW9uID0gdGFyZ2V0LnJvdGF0aW9uIHx8IDA7XG4gIHZhciBwb3NpdGlvbiA9IHRhcmdldC5wb3NpdGlvbiB8fCBbMCwgMF07XG5cbiAgaWYgKG9yaWdpbikge1xuICAgIC8vIFRyYW5zbGF0ZSB0byBvcmlnaW5cbiAgICBtWzRdIC09IG9yaWdpblswXTtcbiAgICBtWzVdIC09IG9yaWdpblsxXTtcbiAgfVxuXG4gIG1hdHJpeC5zY2FsZShtLCBtLCBzY2FsZSk7XG5cbiAgaWYgKHJvdGF0aW9uKSB7XG4gICAgbWF0cml4LnJvdGF0ZShtLCBtLCByb3RhdGlvbik7XG4gIH1cblxuICBpZiAob3JpZ2luKSB7XG4gICAgLy8gVHJhbnNsYXRlIGJhY2sgZnJvbSBvcmlnaW5cbiAgICBtWzRdICs9IG9yaWdpblswXTtcbiAgICBtWzVdICs9IG9yaWdpblsxXTtcbiAgfVxuXG4gIG1bNF0gKz0gcG9zaXRpb25bMF07XG4gIG1bNV0gKz0gcG9zaXRpb25bMV07XG4gIHJldHVybiBtO1xufTtcblxudmFyIF9kZWZhdWx0ID0gVHJhbnNmb3JtYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL21peGluL1RyYW5zZm9ybWFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogM3gy55+p6Zi15pON5L2c57G7XG4gKiBAZXhwb3J0cyB6cmVuZGVyL3Rvb2wvbWF0cml4XG4gKi9cbnZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IEFycmF5IDogRmxvYXQzMkFycmF5O1xuLyoqXG4gKiDliJvlu7rkuIDkuKrljZXkvY3nn6npmLVcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn1cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDYpO1xuICBpZGVudGl0eShvdXQpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDorr7nva7nn6npmLXkuLrljZXkvY3nn6npmLVcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlpI3liLbnn6npmLVcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgbSkge1xuICBvdXRbMF0gPSBtWzBdO1xuICBvdXRbMV0gPSBtWzFdO1xuICBvdXRbMl0gPSBtWzJdO1xuICBvdXRbM10gPSBtWzNdO1xuICBvdXRbNF0gPSBtWzRdO1xuICBvdXRbNV0gPSBtWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDnn6npmLXnm7jkuZhcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG0yXG4gKi9cblxuXG5mdW5jdGlvbiBtdWwob3V0LCBtMSwgbTIpIHtcbiAgLy8gQ29uc2lkZXIgbWF0cml4Lm11bChtLCBtMiwgbSk7XG4gIC8vIHdoZXJlIG91dCBpcyB0aGUgc2FtZSBhcyBtMi5cbiAgLy8gU28gdXNlIHRlbXAgdmFyaWFibGUgdG8gZXNjYXBlIGVycm9yLlxuICB2YXIgb3V0MCA9IG0xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdO1xuICB2YXIgb3V0MSA9IG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdO1xuICB2YXIgb3V0MiA9IG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdO1xuICB2YXIgb3V0MyA9IG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdO1xuICB2YXIgb3V0NCA9IG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF07XG4gIHZhciBvdXQ1ID0gbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XTtcbiAgb3V0WzBdID0gb3V0MDtcbiAgb3V0WzFdID0gb3V0MTtcbiAgb3V0WzJdID0gb3V0MjtcbiAgb3V0WzNdID0gb3V0MztcbiAgb3V0WzRdID0gb3V0NDtcbiAgb3V0WzVdID0gb3V0NTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5bmz56e75Y+Y5o2iXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XSArIHZbMF07XG4gIG91dFs1XSA9IGFbNV0gKyB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDml4vovazlj5jmjaJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkXG4gKi9cblxuXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgdmFyIGFhID0gYVswXTtcbiAgdmFyIGFjID0gYVsyXTtcbiAgdmFyIGF0eCA9IGFbNF07XG4gIHZhciBhYiA9IGFbMV07XG4gIHZhciBhZCA9IGFbM107XG4gIHZhciBhdHkgPSBhWzVdO1xuICB2YXIgc3QgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgY3QgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhYSAqIGN0ICsgYWIgKiBzdDtcbiAgb3V0WzFdID0gLWFhICogc3QgKyBhYiAqIGN0O1xuICBvdXRbMl0gPSBhYyAqIGN0ICsgYWQgKiBzdDtcbiAgb3V0WzNdID0gLWFjICogc3QgKyBjdCAqIGFkO1xuICBvdXRbNF0gPSBjdCAqIGF0eCArIHN0ICogYXR5O1xuICBvdXRbNV0gPSBjdCAqIGF0eSAtIHN0ICogYXR4O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDnvKnmlL7lj5jmjaJcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gdlxuICovXG5cblxuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciB2eCA9IHZbMF07XG4gIHZhciB2eSA9IHZbMV07XG4gIG91dFswXSA9IGFbMF0gKiB2eDtcbiAgb3V0WzFdID0gYVsxXSAqIHZ5O1xuICBvdXRbMl0gPSBhWzJdICogdng7XG4gIG91dFszXSA9IGFbM10gKiB2eTtcbiAgb3V0WzRdID0gYVs0XSAqIHZ4O1xuICBvdXRbNV0gPSBhWzVdICogdnk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaxgumAhuefqemYtVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqL1xuXG5cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGFhID0gYVswXTtcbiAgdmFyIGFjID0gYVsyXTtcbiAgdmFyIGF0eCA9IGFbNF07XG4gIHZhciBhYiA9IGFbMV07XG4gIHZhciBhZCA9IGFbM107XG4gIHZhciBhdHkgPSBhWzVdO1xuICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgb3V0WzJdID0gLWFjICogZGV0O1xuICBvdXRbM10gPSBhYSAqIGRldDtcbiAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMubXVsID0gbXVsO1xuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbmV4cG9ydHMuc2NhbGUgPSBzY2FsZTtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEFycmF5Q3RvciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gQXJyYXkgOiBGbG9hdDMyQXJyYXk7XG4vKipcbiAqIOWIm+W7uuS4gOS4quWQkemHj1xuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKHgsIHkpIHtcbiAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG5cbiAgaWYgKHggPT0gbnVsbCkge1xuICAgIHggPSAwO1xuICB9XG5cbiAgaWYgKHkgPT0gbnVsbCkge1xuICAgIHkgPSAwO1xuICB9XG5cbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5aSN5Yi25ZCR6YeP5pWw5o2uXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtWZWN0b3IyfVxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5YWL6ZqG5LiA5Liq5ZCR6YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZSh2KSB7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDIpO1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDorr7nva7lkJHph4/nmoTkuKTkuKrpoblcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge1ZlY3RvcjJ9IOe7k+aenFxuICovXG5cblxuZnVuY3Rpb24gc2V0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhO1xuICBvdXRbMV0gPSBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/nm7jliqBcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGQob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gKyB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP57yp5pS+5ZCO55u45YqgXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgdjEsIHYyLCBhKSB7XG4gIG91dFswXSA9IHYxWzBdICsgdjJbMF0gKiBhO1xuICBvdXRbMV0gPSB2MVsxXSArIHYyWzFdICogYTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP55u45YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gc3ViKG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdIC0gdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdIC0gdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+mVv+W6plxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBsZW4odikge1xuICByZXR1cm4gTWF0aC5zcXJ0KGxlblNxdWFyZSh2KSk7XG59XG5cbnZhciBsZW5ndGggPSBsZW47IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4vKipcbiAqIOWQkemHj+mVv+W6puW5s+aWuVxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gbGVuU3F1YXJlKHYpIHtcbiAgcmV0dXJuIHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV07XG59XG5cbnZhciBsZW5ndGhTcXVhcmUgPSBsZW5TcXVhcmU7XG4vKipcbiAqIOWQkemHj+S5mOazlVxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqL1xuXG5mdW5jdGlvbiBtdWwob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gKiB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gKiB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP6Zmk5rOVXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gZGl2KG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IHYxWzBdIC8gdjJbMF07XG4gIG91dFsxXSA9IHYxWzFdIC8gdjJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+eCueS5mFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gZG90KHYxLCB2Mikge1xuICByZXR1cm4gdjFbMF0gKiB2MlswXSArIHYxWzFdICogdjJbMV07XG59XG4vKipcbiAqIOWQkemHj+e8qeaUvlxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHBhcmFtIHtudW1iZXJ9IHNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgdiwgcykge1xuICBvdXRbMF0gPSB2WzBdICogcztcbiAgb3V0WzFdID0gdlsxXSAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+W9kuS4gOWMllxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgdikge1xuICB2YXIgZCA9IGxlbih2KTtcblxuICBpZiAoZCA9PT0gMCkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSB2WzBdIC8gZDtcbiAgICBvdXRbMV0gPSB2WzFdIC8gZDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOiuoeeul+WQkemHj+mXtOi3neemu1xuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gZGlzdGFuY2UodjEsIHYyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pICsgKHYxWzFdIC0gdjJbMV0pICogKHYxWzFdIC0gdjJbMV0pKTtcbn1cblxudmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxuICog5ZCR6YeP6Led56a75bmz5pa5XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gZGlzdGFuY2VTcXVhcmUodjEsIHYyKSB7XG4gIHJldHVybiAodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSkgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSk7XG59XG5cbnZhciBkaXN0U3F1YXJlID0gZGlzdGFuY2VTcXVhcmU7XG4vKipcbiAqIOaxgui0n+WQkemHj1xuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICovXG5cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIHYpIHtcbiAgb3V0WzBdID0gLXZbMF07XG4gIG91dFsxXSA9IC12WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmj5LlgLzkuKTkuKrngrlcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICovXG5cblxuZnVuY3Rpb24gbGVycChvdXQsIHYxLCB2MiwgdCkge1xuICBvdXRbMF0gPSB2MVswXSArIHQgKiAodjJbMF0gLSB2MVswXSk7XG4gIG91dFsxXSA9IHYxWzFdICsgdCAqICh2MlsxXSAtIHYxWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog55+p6Zi15bem5LmY5ZCR6YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG1cbiAqL1xuXG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKG91dCwgdiwgbSkge1xuICB2YXIgeCA9IHZbMF07XG4gIHZhciB5ID0gdlsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmsYLkuKTkuKrlkJHph4/mnIDlsI/lgLxcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBtaW4ob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4odjFbMF0sIHYyWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4odjFbMV0sIHYyWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5rGC5Lik5Liq5ZCR6YeP5pyA5aSn5YC8XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICovXG5cblxuZnVuY3Rpb24gbWF4KG91dCwgdjEsIHYyKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KHYxWzBdLCB2MlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KHYxWzFdLCB2MlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jb3B5ID0gY29weTtcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnNjYWxlQW5kQWRkID0gc2NhbGVBbmRBZGQ7XG5leHBvcnRzLnN1YiA9IHN1YjtcbmV4cG9ydHMubGVuID0gbGVuO1xuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLmxlblNxdWFyZSA9IGxlblNxdWFyZTtcbmV4cG9ydHMubGVuZ3RoU3F1YXJlID0gbGVuZ3RoU3F1YXJlO1xuZXhwb3J0cy5tdWwgPSBtdWw7XG5leHBvcnRzLmRpdiA9IGRpdjtcbmV4cG9ydHMuZG90ID0gZG90O1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5leHBvcnRzLmRpc3QgPSBkaXN0O1xuZXhwb3J0cy5kaXN0YW5jZVNxdWFyZSA9IGRpc3RhbmNlU3F1YXJlO1xuZXhwb3J0cy5kaXN0U3F1YXJlID0gZGlzdFNxdWFyZTtcbmV4cG9ydHMubmVnYXRlID0gbmVnYXRlO1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMuYXBwbHlUcmFuc2Zvcm0gPSBhcHBseVRyYW5zZm9ybTtcbmV4cG9ydHMubWluID0gbWluO1xuZXhwb3J0cy5tYXggPSBtYXg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQW5pbWF0b3IgPSByZXF1aXJlKFwiLi4vYW5pbWF0aW9uL0FuaW1hdG9yXCIpO1xuXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2NvcmUvbG9nXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaXNTdHJpbmcgPSBfdXRpbC5pc1N0cmluZztcbnZhciBpc0Z1bmN0aW9uID0gX3V0aWwuaXNGdW5jdGlvbjtcbnZhciBpc09iamVjdCA9IF91dGlsLmlzT2JqZWN0O1xudmFyIGlzQXJyYXlMaWtlID0gX3V0aWwuaXNBcnJheUxpa2U7XG52YXIgaW5kZXhPZiA9IF91dGlsLmluZGV4T2Y7XG5cbi8qKlxuICogQGFsaWFzIG1vZHVlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBBbmltYXRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3I+fVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIHRoaXMuYW5pbWF0b3JzID0gW107XG59O1xuXG5BbmltYXRhYmxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEFuaW1hdGFibGUsXG5cbiAgLyoqXG4gICAqIOWKqOeUu1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBmZXRjaCB2YWx1ZSBmcm9tIG9iamVjdCwgbGlrZSAnYS5iLmMnLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtsb29wXSBXaGV0aGVyIHRvIGxvb3AgYW5pbWF0aW9uLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqIEBleGFtcGxlOlxuICAgKiAgICAgZWwuYW5pbWF0ZSgnc3R5bGUnLCBmYWxzZSlcbiAgICogICAgICAgICAud2hlbigxMDAwLCB7eDogMTB9IClcbiAgICogICAgICAgICAuZG9uZShmdW5jdGlvbigpeyAvLyBBbmltYXRpb24gZG9uZSB9KVxuICAgKiAgICAgICAgIC5zdGFydCgpXG4gICAqL1xuICBhbmltYXRlOiBmdW5jdGlvbiAocGF0aCwgbG9vcCkge1xuICAgIHZhciB0YXJnZXQ7XG4gICAgdmFyIGFuaW1hdGluZ1NoYXBlID0gZmFsc2U7XG4gICAgdmFyIGVsID0gdGhpcztcbiAgICB2YXIgenIgPSB0aGlzLl9fenI7XG5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdmFyIHBhdGhTcGxpdHRlZCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgIHZhciBwcm9wID0gZWw7IC8vIElmIGFuaW1hdGluZyBzaGFwZVxuXG4gICAgICBhbmltYXRpbmdTaGFwZSA9IHBhdGhTcGxpdHRlZFswXSA9PT0gJ3NoYXBlJztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoU3BsaXR0ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghcHJvcCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcCA9IHByb3BbcGF0aFNwbGl0dGVkW2ldXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgdGFyZ2V0ID0gcHJvcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0ID0gZWw7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIGxvZygnUHJvcGVydHkgXCInICsgcGF0aCArICdcIiBpcyBub3QgZXhpc3RlZCBpbiBlbGVtZW50ICcgKyBlbC5pZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFuaW1hdG9ycyA9IGVsLmFuaW1hdG9ycztcbiAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IodGFyZ2V0LCBsb29wKTtcbiAgICBhbmltYXRvci5kdXJpbmcoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgZWwuZGlydHkoYW5pbWF0aW5nU2hhcGUpO1xuICAgIH0pLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gRklYTUUgQW5pbWF0b3Igd2lsbCBub3QgYmUgcmVtb3ZlZCBpZiB1c2UgYEFuaW1hdG9yI3N0b3BgIHRvIHN0b3AgYW5pbWF0aW9uXG4gICAgICBhbmltYXRvcnMuc3BsaWNlKGluZGV4T2YoYW5pbWF0b3JzLCBhbmltYXRvciksIDEpO1xuICAgIH0pO1xuICAgIGFuaW1hdG9ycy5wdXNoKGFuaW1hdG9yKTsgLy8gSWYgYW5pbWF0ZSBhZnRlciBhZGRlZCB0byB0aGUgenJlbmRlclxuXG4gICAgaWYgKHpyKSB7XG4gICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRvcjtcbiAgfSxcblxuICAvKipcbiAgICog5YGc5q2i5Yqo55S7XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZFRvTGFzdCBJZiBtb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICovXG4gIHN0b3BBbmltYXRpb246IGZ1bmN0aW9uIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgIHZhciBsZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYW5pbWF0b3JzW2ldLnN0b3AoZm9yd2FyZFRvTGFzdCk7XG4gICAgfVxuXG4gICAgYW5pbWF0b3JzLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhdXRpb246IHRoaXMgbWV0aG9kIHdpbGwgc3RvcCBwcmV2aW91cyBhbmltYXRpb24uXG4gICAqIFNvIGRvIG5vdCB1c2UgdGhpcyBtZXRob2QgdG8gb25lIGVsZW1lbnQgdHdpY2UgYmVmb3JlXG4gICAqIGFuaW1hdGlvbiBzdGFydHMsIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF0gVGltZSBpbiBtc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Vhc2luZz0nbGluZWFyJ11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmb3JjZUFuaW1hdGVdIFByZXZlbnQgc3RvcCBhbmltYXRpb24gYW5kIGNhbGxiYWNrXG4gICAqICAgICAgICBpbW1lZGllbnRseSB3aGVuIHRhcmdldCB2YWx1ZXMgYXJlIHRoZSBzYW1lIGFzIGN1cnJlbnQgdmFsdWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0sIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgKlxuICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zLCB3aXRoIGN1YmljT3V0IGVhc2luZ1xuICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICogICAgICBzaGFwZToge1xuICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAqICAgICAgfSxcbiAgICogICAgICBzdHlsZToge1xuICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgKiAgICAgIH1cbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0sIDEwMCwgMTAwLCAnY3ViaWNPdXQnLCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICovXG4gIC8vIFRPRE8gUmV0dXJuIGFuaW1hdGlvbiBrZXlcbiAgYW5pbWF0ZVRvOiBmdW5jdGlvbiAodGFyZ2V0LCB0aW1lLCBkZWxheSwgZWFzaW5nLCBjYWxsYmFjaywgZm9yY2VBbmltYXRlKSB7XG4gICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgaWYgKGlzU3RyaW5nKGRlbGF5KSkge1xuICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICBlYXNpbmcgPSBkZWxheTtcbiAgICAgIGRlbGF5ID0gMDtcbiAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGRlbGF5LCBjYWxsYmFjayk7XG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihlYXNpbmcpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgICBlYXNpbmcgPSAnbGluZWFyJztcbiAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgfSAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBjYWxsYmFjayk7XG4gICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGRlbGF5KSkge1xuICAgICAgICAgIGNhbGxiYWNrID0gZGVsYXk7XG4gICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQsIGNhbGxiYWNrKVxuICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRpbWUpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHRpbWU7XG4gICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgIH0gLy8gYW5pbWF0ZVRvKHRhcmdldClcbiAgICAgICAgICBlbHNlIGlmICghdGltZSkge1xuICAgICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgICAgfSAvLyBTdG9wIGFsbCBwcmV2aW91cyBhbmltYXRpb25zXG5cblxuICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuXG4gICAgdGhpcy5fYW5pbWF0ZVRvU2hhbGxvdygnJywgdGhpcywgdGFyZ2V0LCB0aW1lLCBkZWxheSk7IC8vIEFuaW1hdG9ycyBtYXkgYmUgcmVtb3ZlZCBpbW1lZGlhdGVseSBhZnRlciBzdGFydFxuICAgIC8vIGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gYW5pbWF0ZVxuXG5cbiAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnMuc2xpY2UoKTtcbiAgICB2YXIgY291bnQgPSBhbmltYXRvcnMubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIGNvdW50LS07XG5cbiAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9IC8vIE5vIGFuaW1hdG9ycy4gVGhpcyBzaG91bGQgYmUgY2hlY2tlZCBiZWZvcmUgYW5pbWF0b3JzW2ldLnN0YXJ0KCksXG4gICAgLy8gYmVjYXVzZSAnZG9uZScgbWF5IGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGlmIG5vIG5lZWQgdG8gYW5pbWF0ZS5cblxuXG4gICAgaWYgKCFjb3VudCkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9IC8vIFN0YXJ0IGFmdGVyIGFsbCBhbmltYXRvcnMgY3JlYXRlZFxuICAgIC8vIEluY2FzZSBhbnkgYW5pbWF0b3IgaXMgZG9uZSBpbW1lZGlhdGVseSB3aGVuIGFsbCBhbmltYXRpb24gcHJvcGVydGllcyBhcmUgbm90IGNoYW5nZWRcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFuaW1hdG9yc1tpXS5kb25lKGRvbmUpLnN0YXJ0KGVhc2luZywgZm9yY2VBbmltYXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoPScnXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2U9dGhpc1xuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT01MDBdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIC8vIEFuaW1hdGUgcG9zaXRpb25cbiAgICogIGVsLl9hbmltYXRlVG9TaGFsbG93KHtcbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0pXG4gICAqXG4gICAqICAvLyBBbmltYXRlIHNoYXBlLCBzdHlsZSBhbmQgcG9zaXRpb24gaW4gMTAwbXMsIGRlbGF5ZWQgMTAwbXNcbiAgICogIGVsLl9hbmltYXRlVG9TaGFsbG93KHtcbiAgICogICAgICBzaGFwZToge1xuICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAqICAgICAgfSxcbiAgICogICAgICBzdHlsZToge1xuICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgKiAgICAgIH1cbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0sIDEwMCwgMTAwKVxuICAgKi9cbiAgX2FuaW1hdGVUb1NoYWxsb3c6IGZ1bmN0aW9uIChwYXRoLCBzb3VyY2UsIHRhcmdldCwgdGltZSwgZGVsYXkpIHtcbiAgICB2YXIgb2JqU2hhbGxvdyA9IHt9O1xuICAgIHZhciBwcm9wZXJ0eUNvdW50ID0gMDtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gdGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc09iamVjdCh0YXJnZXRbbmFtZV0pICYmICFpc0FycmF5TGlrZSh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZVRvU2hhbGxvdyhwYXRoID8gcGF0aCArICcuJyArIG5hbWUgOiBuYW1lLCBzb3VyY2VbbmFtZV0sIHRhcmdldFtuYW1lXSwgdGltZSwgZGVsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9ialNoYWxsb3dbbmFtZV0gPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgcHJvcGVydHlDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIC8vIEF0dHIgZGlyZWN0bHkgaWYgbm90IGhhcyBwcm9wZXJ0eVxuICAgICAgICAvLyBGSVhNRSwgaWYgc29tZSBwcm9wZXJ0eSBub3QgbmVlZGVkIGZvciBlbGVtZW50ID9cbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgdGhpcy5hdHRyKG5hbWUsIHRhcmdldFtuYW1lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2hhcGUgb3Igc3R5bGVcbiAgICAgICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgICAgICBwcm9wc1twYXRoXSA9IHt9O1xuICAgICAgICAgIHByb3BzW3BhdGhdW25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgIHRoaXMuYXR0cihwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvcGVydHlDb3VudCA+IDApIHtcbiAgICAgIHRoaXMuYW5pbWF0ZShwYXRoLCBmYWxzZSkud2hlbih0aW1lID09IG51bGwgPyA1MDAgOiB0aW1lLCBvYmpTaGFsbG93KS5kZWxheShkZWxheSB8fCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEFuaW1hdGFibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQ2xpcCA9IHJlcXVpcmUoXCIuL0NsaXBcIik7XG5cbnZhciBjb2xvciA9IHJlcXVpcmUoXCIuLi90b29sL2NvbG9yXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaXNBcnJheUxpa2UgPSBfdXRpbC5pc0FycmF5TGlrZTtcblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvYW5pbWF0aW9uL0FuaW1hdG9yXG4gKi9cbnZhciBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBkZWZhdWx0R2V0dGVyKHRhcmdldCwga2V5KSB7XG4gIHJldHVybiB0YXJnZXRba2V5XTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFNldHRlcih0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbn1cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihwMCwgcDEsIHBlcmNlbnQpIHtcbiAgcmV0dXJuIChwMSAtIHAwKSAqIHBlcmNlbnQgKyBwMDtcbn1cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBwMFxuICogQHBhcmFtICB7c3RyaW5nfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVN0cmluZyhwMCwgcDEsIHBlcmNlbnQpIHtcbiAgcmV0dXJuIHBlcmNlbnQgPiAwLjUgPyBwMSA6IHAwO1xufVxuLyoqXG4gKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAqIEBwYXJhbSAge0FycmF5fSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICovXG5cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHBlcmNlbnQsIG91dCwgYXJyRGltKSB7XG4gIHZhciBsZW4gPSBwMC5sZW5ndGg7XG5cbiAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb3V0W2ldID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV0sIHAxW2ldLCBwZXJjZW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbjIgPSBsZW4gJiYgcDBbMF0ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgb3V0W2ldW2pdID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV1bal0sIHAxW2ldW2pdLCBwZXJjZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gYXJyMCBpcyBzb3VyY2UgYXJyYXksIGFycjEgaXMgdGFyZ2V0IGFycmF5LlxuLy8gRG8gc29tZSBwcmVwcm9jZXNzIHRvIGF2b2lkIGVycm9yIGhhcHBlbmVkIHdoZW4gaW50ZXJwb2xhdGluZyBmcm9tIGFycjAgdG8gYXJyMVxuXG5cbmZ1bmN0aW9uIGZpbGxBcnIoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gIHZhciBhcnIwTGVuID0gYXJyMC5sZW5ndGg7XG4gIHZhciBhcnIxTGVuID0gYXJyMS5sZW5ndGg7XG5cbiAgaWYgKGFycjBMZW4gIT09IGFycjFMZW4pIHtcbiAgICAvLyBGSVhNRSBOb3Qgd29yayBmb3IgVHlwZWRBcnJheVxuICAgIHZhciBpc1ByZXZpb3VzTGFyZ2VyID0gYXJyMExlbiA+IGFycjFMZW47XG5cbiAgICBpZiAoaXNQcmV2aW91c0xhcmdlcikge1xuICAgICAgLy8gQ3V0IHRoZSBwcmV2aW91c1xuICAgICAgYXJyMC5sZW5ndGggPSBhcnIxTGVuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaWxsIHRoZSBwcmV2aW91c1xuICAgICAgZm9yICh2YXIgaSA9IGFycjBMZW47IGkgPCBhcnIxTGVuOyBpKyspIHtcbiAgICAgICAgYXJyMC5wdXNoKGFyckRpbSA9PT0gMSA/IGFycjFbaV0gOiBhcnJheVNsaWNlLmNhbGwoYXJyMVtpXSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBIYW5kbGluZyBOYU4gdmFsdWVcblxuXG4gIHZhciBsZW4yID0gYXJyMFswXSAmJiBhcnIwWzBdLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycjAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgICBpZiAoaXNOYU4oYXJyMFtpXSkpIHtcbiAgICAgICAgYXJyMFtpXSA9IGFycjFbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgIGlmIChpc05hTihhcnIwW2ldW2pdKSkge1xuICAgICAgICAgIGFycjBbaV1bal0gPSBhcnIxW2ldW2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBwYXJhbSAge0FycmF5fSBhcnIwXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyMVxuICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5U2FtZShhcnIwLCBhcnIxLCBhcnJEaW0pIHtcbiAgaWYgKGFycjAgPT09IGFycjEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsZW4gPSBhcnIwLmxlbmd0aDtcblxuICBpZiAobGVuICE9PSBhcnIxLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXJyMFtpXSAhPT0gYXJyMVtpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsZW4yID0gYXJyMFswXS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICBpZiAoYXJyMFtpXVtqXSAhPT0gYXJyMVtpXVtqXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBhcnJheVxuICogQHBhcmFtICB7QXJyYXl9IHAwXG4gKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAqIEBwYXJhbSAge0FycmF5fSBwMlxuICogQHBhcmFtICB7QXJyYXl9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gKi9cblxuXG5mdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzLCBvdXQsIGFyckRpbSkge1xuICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuXG4gIGlmIChhcnJEaW0gPT0gMSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG91dFtpXSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdCwgdDIsIHQzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbjIgPSBwMFswXS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICBvdXRbaV1bal0gPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDBbaV1bal0sIHAxW2ldW2pdLCBwMltpXVtqXSwgcDNbaV1bal0sIHQsIHQyLCB0Myk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIENhdG11bGwgUm9tIGludGVycG9sYXRlIG51bWJlclxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHQyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHQzXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mykge1xuICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gIHZhciB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgcmV0dXJuICgyICogKHAxIC0gcDIpICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIChwMSAtIHAyKSAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XG59XG5cbmZ1bmN0aW9uIGNsb25lVmFsdWUodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICBpZiAoaXNBcnJheUxpa2UodmFsdWVbMF0pKSB7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmV0LnB1c2goYXJyYXlTbGljZS5jYWxsKHZhbHVlW2ldKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5U2xpY2UuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJnYmEyU3RyaW5nKHJnYmEpIHtcbiAgcmdiYVswXSA9IE1hdGguZmxvb3IocmdiYVswXSk7XG4gIHJnYmFbMV0gPSBNYXRoLmZsb29yKHJnYmFbMV0pO1xuICByZ2JhWzJdID0gTWF0aC5mbG9vcihyZ2JhWzJdKTtcbiAgcmV0dXJuICdyZ2JhKCcgKyByZ2JhLmpvaW4oJywnKSArICcpJztcbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlEaW0oa2V5ZnJhbWVzKSB7XG4gIHZhciBsYXN0VmFsdWUgPSBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnZhbHVlO1xuICByZXR1cm4gaXNBcnJheUxpa2UobGFzdFZhbHVlICYmIGxhc3RWYWx1ZVswXSkgPyAyIDogMTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHJhY2tDbGlwKGFuaW1hdG9yLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSwga2V5ZnJhbWVzLCBwcm9wTmFtZSwgZm9yY2VBbmltYXRlKSB7XG4gIHZhciBnZXR0ZXIgPSBhbmltYXRvci5fZ2V0dGVyO1xuICB2YXIgc2V0dGVyID0gYW5pbWF0b3IuX3NldHRlcjtcbiAgdmFyIHVzZVNwbGluZSA9IGVhc2luZyA9PT0gJ3NwbGluZSc7XG4gIHZhciB0cmFja0xlbiA9IGtleWZyYW1lcy5sZW5ndGg7XG5cbiAgaWYgKCF0cmFja0xlbikge1xuICAgIHJldHVybjtcbiAgfSAvLyBHdWVzcyBkYXRhIHR5cGVcblxuXG4gIHZhciBmaXJzdFZhbCA9IGtleWZyYW1lc1swXS52YWx1ZTtcbiAgdmFyIGlzVmFsdWVBcnJheSA9IGlzQXJyYXlMaWtlKGZpcnN0VmFsKTtcbiAgdmFyIGlzVmFsdWVDb2xvciA9IGZhbHNlO1xuICB2YXIgaXNWYWx1ZVN0cmluZyA9IGZhbHNlOyAvLyBGb3IgdmVydGljZXMgbW9ycGhpbmdcblxuICB2YXIgYXJyRGltID0gaXNWYWx1ZUFycmF5ID8gZ2V0QXJyYXlEaW0oa2V5ZnJhbWVzKSA6IDA7XG4gIHZhciB0cmFja01heFRpbWU7IC8vIFNvcnQga2V5ZnJhbWUgYXMgYXNjZW5kaW5nXG5cbiAga2V5ZnJhbWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuICB9KTtcbiAgdHJhY2tNYXhUaW1lID0ga2V5ZnJhbWVzW3RyYWNrTGVuIC0gMV0udGltZTsgLy8gUGVyY2VudHMgb2YgZWFjaCBrZXlmcmFtZVxuXG4gIHZhciBrZlBlcmNlbnRzID0gW107IC8vIFZhbHVlIG9mIGVhY2gga2V5ZnJhbWVcblxuICB2YXIga2ZWYWx1ZXMgPSBbXTtcbiAgdmFyIHByZXZWYWx1ZSA9IGtleWZyYW1lc1swXS52YWx1ZTtcbiAgdmFyIGlzQWxsVmFsdWVFcXVhbCA9IHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja0xlbjsgaSsrKSB7XG4gICAga2ZQZXJjZW50cy5wdXNoKGtleWZyYW1lc1tpXS50aW1lIC8gdHJhY2tNYXhUaW1lKTsgLy8gQXNzdW1lIHZhbHVlIGlzIGEgY29sb3Igd2hlbiBpdCBpcyBhIHN0cmluZ1xuXG4gICAgdmFyIHZhbHVlID0ga2V5ZnJhbWVzW2ldLnZhbHVlOyAvLyBDaGVjayBpZiB2YWx1ZSBpcyBlcXVhbCwgZGVlcCBjaGVjayBpZiB2YWx1ZSBpcyBhcnJheVxuXG4gICAgaWYgKCEoaXNWYWx1ZUFycmF5ICYmIGlzQXJyYXlTYW1lKHZhbHVlLCBwcmV2VmFsdWUsIGFyckRpbSkgfHwgIWlzVmFsdWVBcnJheSAmJiB2YWx1ZSA9PT0gcHJldlZhbHVlKSkge1xuICAgICAgaXNBbGxWYWx1ZUVxdWFsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJldlZhbHVlID0gdmFsdWU7IC8vIFRyeSBjb252ZXJ0aW5nIGEgc3RyaW5nIHRvIGEgY29sb3IgYXJyYXlcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBjb2xvckFycmF5ID0gY29sb3IucGFyc2UodmFsdWUpO1xuXG4gICAgICBpZiAoY29sb3JBcnJheSkge1xuICAgICAgICB2YWx1ZSA9IGNvbG9yQXJyYXk7XG4gICAgICAgIGlzVmFsdWVDb2xvciA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc1ZhbHVlU3RyaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBrZlZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIGlmICghZm9yY2VBbmltYXRlICYmIGlzQWxsVmFsdWVFcXVhbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSBrZlZhbHVlc1t0cmFja0xlbiAtIDFdOyAvLyBQb2x5ZmlsbCBhcnJheSBhbmQgTmFOIHZhbHVlXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja0xlbiAtIDE7IGkrKykge1xuICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgIGZpbGxBcnIoa2ZWYWx1ZXNbaV0sIGxhc3RWYWx1ZSwgYXJyRGltKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzTmFOKGtmVmFsdWVzW2ldKSAmJiAhaXNOYU4obGFzdFZhbHVlKSAmJiAhaXNWYWx1ZVN0cmluZyAmJiAhaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgIGtmVmFsdWVzW2ldID0gbGFzdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzVmFsdWVBcnJheSAmJiBmaWxsQXJyKGdldHRlcihhbmltYXRvci5fdGFyZ2V0LCBwcm9wTmFtZSksIGxhc3RWYWx1ZSwgYXJyRGltKTsgLy8gQ2FjaGUgdGhlIGtleSBvZiBsYXN0IGZyYW1lIHRvIHNwZWVkIHVwIHdoZW5cbiAgLy8gYW5pbWF0aW9uIHBsYXliYWNrIGlzIHNlcXVlbmN5XG5cbiAgdmFyIGxhc3RGcmFtZSA9IDA7XG4gIHZhciBsYXN0RnJhbWVQZXJjZW50ID0gMDtcbiAgdmFyIHN0YXJ0O1xuICB2YXIgdztcbiAgdmFyIHAwO1xuICB2YXIgcDE7XG4gIHZhciBwMjtcbiAgdmFyIHAzO1xuXG4gIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICB2YXIgcmdiYSA9IFswLCAwLCAwLCAwXTtcbiAgfVxuXG4gIHZhciBvbmZyYW1lID0gZnVuY3Rpb24gKHRhcmdldCwgcGVyY2VudCkge1xuICAgIC8vIEZpbmQgdGhlIHJhbmdlIGtleWZyYW1lc1xuICAgIC8vIGtmMS0tLS0ta2YyLS0tLS0tLS0tY3VycmVudC0tLS0tLS0ta2YzXG4gICAgLy8gZmluZCBrZjIgYW5kIGtmMyBhbmQgZG8gaW50ZXJwb2xhdGlvblxuICAgIHZhciBmcmFtZTsgLy8gSW4gdGhlIGVhc2luZyBmdW5jdGlvbiBsaWtlIGVsYXN0aWNPdXQsIHBlcmNlbnQgbWF5IGxlc3MgdGhhbiAwXG5cbiAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgIGZyYW1lID0gMDtcbiAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPCBsYXN0RnJhbWVQZXJjZW50KSB7XG4gICAgICAvLyBTdGFydCBmcm9tIG5leHQga2V5XG4gICAgICAvLyBQRU5ESU5HIHN0YXJ0IGZyb20gbGFzdEZyYW1lID9cbiAgICAgIHN0YXJ0ID0gTWF0aC5taW4obGFzdEZyYW1lICsgMSwgdHJhY2tMZW4gLSAxKTtcblxuICAgICAgZm9yIChmcmFtZSA9IHN0YXJ0OyBmcmFtZSA+PSAwOyBmcmFtZS0tKSB7XG4gICAgICAgIGlmIChrZlBlcmNlbnRzW2ZyYW1lXSA8PSBwZXJjZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUEVORElORyByZWFsbHkgbmVlZCB0byBkbyB0aGlzID9cblxuXG4gICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lLCB0cmFja0xlbiAtIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGZyYW1lID0gbGFzdEZyYW1lOyBmcmFtZSA8IHRyYWNrTGVuOyBmcmFtZSsrKSB7XG4gICAgICAgIGlmIChrZlBlcmNlbnRzW2ZyYW1lXSA+IHBlcmNlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lIC0gMSwgdHJhY2tMZW4gLSAyKTtcbiAgICB9XG5cbiAgICBsYXN0RnJhbWUgPSBmcmFtZTtcbiAgICBsYXN0RnJhbWVQZXJjZW50ID0gcGVyY2VudDtcbiAgICB2YXIgcmFuZ2UgPSBrZlBlcmNlbnRzW2ZyYW1lICsgMV0gLSBrZlBlcmNlbnRzW2ZyYW1lXTtcblxuICAgIGlmIChyYW5nZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB3ID0gKHBlcmNlbnQgLSBrZlBlcmNlbnRzW2ZyYW1lXSkgLyByYW5nZTtcbiAgICB9XG5cbiAgICBpZiAodXNlU3BsaW5lKSB7XG4gICAgICBwMSA9IGtmVmFsdWVzW2ZyYW1lXTtcbiAgICAgIHAwID0ga2ZWYWx1ZXNbZnJhbWUgPT09IDAgPyBmcmFtZSA6IGZyYW1lIC0gMV07XG4gICAgICBwMiA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAyID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAxXTtcbiAgICAgIHAzID0ga2ZWYWx1ZXNbZnJhbWUgPiB0cmFja0xlbiAtIDMgPyB0cmFja0xlbiAtIDEgOiBmcmFtZSArIDJdO1xuXG4gICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3LCBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksIGFyckRpbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsIHJnYmEsIDEpO1xuICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgIC8vIFN0cmluZyBpcyBzdGVwKDAuNSlcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcocDEsIHAyLCB3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgIGludGVycG9sYXRlQXJyYXkoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3LCBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksIGFyckRpbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgIGludGVycG9sYXRlQXJyYXkoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3LCByZ2JhLCAxKTtcbiAgICAgICAgICB2YWx1ZSA9IHJnYmEyU3RyaW5nKHJnYmEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAvLyBTdHJpbmcgaXMgc3RlcCgwLjUpXG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU3RyaW5nKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBpbnRlcnBvbGF0ZU51bWJlcihrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGVyKHRhcmdldCwgcHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGNsaXAgPSBuZXcgQ2xpcCh7XG4gICAgdGFyZ2V0OiBhbmltYXRvci5fdGFyZ2V0LFxuICAgIGxpZmU6IHRyYWNrTWF4VGltZSxcbiAgICBsb29wOiBhbmltYXRvci5fbG9vcCxcbiAgICBkZWxheTogYW5pbWF0b3IuX2RlbGF5LFxuICAgIG9uZnJhbWU6IG9uZnJhbWUsXG4gICAgb25kZXN0cm95OiBvbmVUcmFja0RvbmVcbiAgfSk7XG5cbiAgaWYgKGVhc2luZyAmJiBlYXNpbmcgIT09ICdzcGxpbmUnKSB7XG4gICAgY2xpcC5lYXNpbmcgPSBlYXNpbmc7XG4gIH1cblxuICByZXR1cm4gY2xpcDtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyXG4gKi9cblxuXG52YXIgQW5pbWF0b3IgPSBmdW5jdGlvbiAodGFyZ2V0LCBsb29wLCBnZXR0ZXIsIHNldHRlcikge1xuICB0aGlzLl90cmFja3MgPSB7fTtcbiAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLl9sb29wID0gbG9vcCB8fCBmYWxzZTtcbiAgdGhpcy5fZ2V0dGVyID0gZ2V0dGVyIHx8IGRlZmF1bHRHZXR0ZXI7XG4gIHRoaXMuX3NldHRlciA9IHNldHRlciB8fCBkZWZhdWx0U2V0dGVyO1xuICB0aGlzLl9jbGlwQ291bnQgPSAwO1xuICB0aGlzLl9kZWxheSA9IDA7XG4gIHRoaXMuX2RvbmVMaXN0ID0gW107XG4gIHRoaXMuX29uZnJhbWVMaXN0ID0gW107XG4gIHRoaXMuX2NsaXBMaXN0ID0gW107XG59O1xuXG5BbmltYXRvci5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiDorr7nva7liqjnlLvlhbPplK7luKdcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWFs+mUruW4p+aXtumXtO+8jOWNleS9jeaYr21zXG4gICAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMg5YWz6ZSu5bin55qE5bGe5oCn5YC877yMa2V5LXZhbHVl6KGo56S6XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIHdoZW46IGZ1bmN0aW9uICh0aW1lXG4gIC8qIG1zICovXG4gICwgcHJvcHMpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5fdHJhY2tzO1xuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYWNrc1twcm9wTmFtZV0pIHtcbiAgICAgICAgdHJhY2tzW3Byb3BOYW1lXSA9IFtdOyAvLyBJbnZhbGlkIHZhbHVlXG5cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0dGVyKHRoaXMuX3RhcmdldCwgcHJvcE5hbWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgLy8genJMb2coJ0ludmFsaWQgcHJvcGVydHkgJyArIHByb3BOYW1lKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBJZiB0aW1lIGlzIDBcbiAgICAgICAgLy8gIFRoZW4gcHJvcHMgaXMgZ2l2ZW4gaW5pdGlhbGl6ZSB2YWx1ZVxuICAgICAgICAvLyBFbHNlXG4gICAgICAgIC8vICBJbml0aWFsaXplIHZhbHVlIGZyb20gY3VycmVudCBwcm9wIHZhbHVlXG5cblxuICAgICAgICBpZiAodGltZSAhPT0gMCkge1xuICAgICAgICAgIHRyYWNrc1twcm9wTmFtZV0ucHVzaCh7XG4gICAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgICAgdmFsdWU6IGNsb25lVmFsdWUodmFsdWUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJhY2tzW3Byb3BOYW1lXS5wdXNoKHtcbiAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgdmFsdWU6IHByb3BzW3Byb3BOYW1lXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWKqOeUu+avj+S4gOW4p+eahOWbnuiwg+WHveaVsFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgZHVyaW5nOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9vbmZyYW1lTGlzdC5wdXNoKGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2NsaXBMaXN0W2ldLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgfSxcbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fY2xpcExpc3RbaV0ucmVzdW1lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gIH0sXG4gIGlzUGF1c2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcGF1c2VkO1xuICB9LFxuICBfZG9uZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ2xlYXIgYWxsIHRyYWNrc1xuICAgIHRoaXMuX3RyYWNrcyA9IHt9OyAvLyBDbGVhciBhbGwgY2xpcHNcblxuICAgIHRoaXMuX2NsaXBMaXN0Lmxlbmd0aCA9IDA7XG4gICAgdmFyIGRvbmVMaXN0ID0gdGhpcy5fZG9uZUxpc3Q7XG4gICAgdmFyIGxlbiA9IGRvbmVMaXN0Lmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRvbmVMaXN0W2ldLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDlvIDlp4vmiafooYzliqjnlLtcbiAgICogQHBhcmFtICB7c3RyaW5nfEZ1bmN0aW9ufSBbZWFzaW5nXVxuICAgKiAgICAgICAgIOWKqOeUu+e8k+WKqOWHveaVsO+8jOivpuingXtAbGluayBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vZWFzaW5nfVxuICAgKiBAcGFyYW0gIHtib29sZWFufSBmb3JjZUFuaW1hdGVcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgc3RhcnQ6IGZ1bmN0aW9uIChlYXNpbmcsIGZvcmNlQW5pbWF0ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2xpcENvdW50ID0gMDtcblxuICAgIHZhciBvbmVUcmFja0RvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGlwQ291bnQtLTtcblxuICAgICAgaWYgKCFjbGlwQ291bnQpIHtcbiAgICAgICAgc2VsZi5fZG9uZUNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsYXN0Q2xpcDtcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHRoaXMuX3RyYWNrcykge1xuICAgICAgaWYgKCF0aGlzLl90cmFja3MuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xpcCA9IGNyZWF0ZVRyYWNrQ2xpcCh0aGlzLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSwgdGhpcy5fdHJhY2tzW3Byb3BOYW1lXSwgcHJvcE5hbWUsIGZvcmNlQW5pbWF0ZSk7XG5cbiAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgIHRoaXMuX2NsaXBMaXN0LnB1c2goY2xpcCk7XG5cbiAgICAgICAgY2xpcENvdW50Kys7IC8vIElmIHN0YXJ0IGFmdGVyIGFkZGVkIHRvIGFuaW1hdGlvblxuXG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmFkZENsaXAoY2xpcCk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0Q2xpcCA9IGNsaXA7XG4gICAgICB9XG4gICAgfSAvLyBBZGQgZHVyaW5nIGNhbGxiYWNrIG9uIHRoZSBsYXN0IGNsaXBcblxuXG4gICAgaWYgKGxhc3RDbGlwKSB7XG4gICAgICB2YXIgb2xkT25GcmFtZSA9IGxhc3RDbGlwLm9uZnJhbWU7XG5cbiAgICAgIGxhc3RDbGlwLm9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgICAgIG9sZE9uRnJhbWUodGFyZ2V0LCBwZXJjZW50KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuX29uZnJhbWVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2VsZi5fb25mcmFtZUxpc3RbaV0odGFyZ2V0LCBwZXJjZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IC8vIFRoaXMgb3B0aW1pemF0aW9uIHdpbGwgaGVscCB0aGUgY2FzZSB0aGF0IGluIHRoZSB1cHBlciBhcHBsaWNhdGlvblxuICAgIC8vIHRoZSB2aWV3IG1heSBiZSByZWZyZXNoZWQgZnJlcXVlbnRseSwgd2hlcmUgYW5pbWF0aW9uIHdpbGwgYmVcbiAgICAvLyBjYWxsZWQgcmVwZWF0bHkgYnV0IG5vdGhpbmcgY2hhbmdlZC5cblxuXG4gICAgaWYgKCFjbGlwQ291bnQpIHtcbiAgICAgIHRoaXMuX2RvbmVDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlgZzmraLliqjnlLtcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgKi9cbiAgc3RvcDogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICB2YXIgY2xpcExpc3QgPSB0aGlzLl9jbGlwTGlzdDtcbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb247XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2xpcCA9IGNsaXBMaXN0W2ldO1xuXG4gICAgICBpZiAoZm9yd2FyZFRvTGFzdCkge1xuICAgICAgICAvLyBNb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICAgICAgY2xpcC5vbmZyYW1lKHRoaXMuX3RhcmdldCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucmVtb3ZlQ2xpcChjbGlwKTtcbiAgICB9XG5cbiAgICBjbGlwTGlzdC5sZW5ndGggPSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiDorr7nva7liqjnlLvlu7bov5/lvIDlp4vnmoTml7bpl7RcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWNleS9jW1zXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIGRlbGF5OiBmdW5jdGlvbiAodGltZSkge1xuICAgIHRoaXMuX2RlbGF5ID0gdGltZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5Yqo55S757uT5p2f55qE5Zue6LCDXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICBkb25lOiBmdW5jdGlvbiAoY2IpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRoaXMuX2RvbmVMaXN0LnB1c2goY2IpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXA+fVxuICAgKi9cbiAgZ2V0Q2xpcHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpcExpc3Q7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBBbmltYXRvcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVhc2luZ0Z1bmNzID0gcmVxdWlyZShcIi4vZWFzaW5nXCIpO1xuXG4vKipcbiAqIOWKqOeUu+S4u+aOp+WItuWZqFxuICogQGNvbmZpZyB0YXJnZXQg5Yqo55S75a+56LGh77yM5Y+v5Lul5piv5pWw57uE77yM5aaC5p6c5piv5pWw57uE55qE6K+d5Lya5om56YeP5YiG5Y+Rb25mcmFtZeetieS6i+S7tlxuICogQGNvbmZpZyBsaWZlKDEwMDApIOWKqOeUu+aXtumVv1xuICogQGNvbmZpZyBkZWxheSgwKSDliqjnlLvlu7bov5/ml7bpl7RcbiAqIEBjb25maWcgbG9vcCh0cnVlKVxuICogQGNvbmZpZyBnYXAoMCkg5b6q546v55qE6Ze06ZqU5pe26Ze0XG4gKiBAY29uZmlnIG9uZnJhbWVcbiAqIEBjb25maWcgZWFzaW5nKG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbmRlc3Ryb3kob3B0aW9uYWwpXG4gKiBAY29uZmlnIG9ucmVzdGFydChvcHRpb25hbClcbiAqXG4gKiBUT0RPIHBhdXNlXG4gKi9cbmZ1bmN0aW9uIENsaXAob3B0aW9ucykge1xuICB0aGlzLl90YXJnZXQgPSBvcHRpb25zLnRhcmdldDsgLy8g55Sf5ZG95ZGo5pyfXG5cbiAgdGhpcy5fbGlmZSA9IG9wdGlvbnMubGlmZSB8fCAxMDAwOyAvLyDlu7bml7ZcblxuICB0aGlzLl9kZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgMDsgLy8g5byA5aeL5pe26Ze0XG4gIC8vIHRoaXMuX3N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdGhpcy5fZGVsYXk7Ly8g5Y2V5L2N5q+r56eSXG5cbiAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTsgLy8g5piv5ZCm5b6q546vXG5cbiAgdGhpcy5sb29wID0gb3B0aW9ucy5sb29wID09IG51bGwgPyBmYWxzZSA6IG9wdGlvbnMubG9vcDtcbiAgdGhpcy5nYXAgPSBvcHRpb25zLmdhcCB8fCAwO1xuICB0aGlzLmVhc2luZyA9IG9wdGlvbnMuZWFzaW5nIHx8ICdMaW5lYXInO1xuICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWU7XG4gIHRoaXMub25kZXN0cm95ID0gb3B0aW9ucy5vbmRlc3Ryb3k7XG4gIHRoaXMub25yZXN0YXJ0ID0gb3B0aW9ucy5vbnJlc3RhcnQ7XG4gIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbn1cblxuQ2xpcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBDbGlwLFxuICBzdGVwOiBmdW5jdGlvbiAoZ2xvYmFsVGltZSwgZGVsdGFUaW1lKSB7XG4gICAgLy8gU2V0IHN0YXJ0VGltZSBvbiBmaXJzdCBzdGVwLCBvciBfc3RhcnRUaW1lIG1heSBoYXMgbWlsbGVzZWNvbmRzIGRpZmZlcmVudCBiZXR3ZWVuIGNsaXBzXG4gICAgLy8gUEVORElOR1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IGdsb2JhbFRpbWUgKyB0aGlzLl9kZWxheTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IGRlbHRhVGltZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGVyY2VudCA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fcGF1c2VkVGltZSkgLyB0aGlzLl9saWZlOyAvLyDov5jmsqHlvIDlp4tcblxuICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBlcmNlbnQgPSBNYXRoLm1pbihwZXJjZW50LCAxKTtcbiAgICB2YXIgZWFzaW5nID0gdGhpcy5lYXNpbmc7XG4gICAgdmFyIGVhc2luZ0Z1bmMgPSB0eXBlb2YgZWFzaW5nID09ICdzdHJpbmcnID8gZWFzaW5nRnVuY3NbZWFzaW5nXSA6IGVhc2luZztcbiAgICB2YXIgc2NoZWR1bGUgPSB0eXBlb2YgZWFzaW5nRnVuYyA9PT0gJ2Z1bmN0aW9uJyA/IGVhc2luZ0Z1bmMocGVyY2VudCkgOiBwZXJjZW50O1xuICAgIHRoaXMuZmlyZSgnZnJhbWUnLCBzY2hlZHVsZSk7IC8vIOe7k+adn1xuXG4gICAgaWYgKHBlcmNlbnQgPT0gMSkge1xuICAgICAgaWYgKHRoaXMubG9vcCkge1xuICAgICAgICB0aGlzLnJlc3RhcnQoZ2xvYmFsVGltZSk7IC8vIOmHjeaWsOW8gOWni+WRqOacn1xuICAgICAgICAvLyDmipvlh7rogIzkuI3mmK/nm7TmjqXosIPnlKjkuovku7bnm7TliLAgc3RhZ2UudXBkYXRlIOWQjuWGjee7n+S4gOiwg+eUqOi/meS6m+S6i+S7tlxuXG4gICAgICAgIHJldHVybiAncmVzdGFydCc7XG4gICAgICB9IC8vIOWKqOeUu+WujOaIkOWwhui/meS4quaOp+WItuWZqOagh+ivhuS4uuW+heWIoOmZpFxuICAgICAgLy8g5ZyoQW5pbWF0aW9uLnVwZGF0ZeS4rei/m+ihjOaJuemHj+WIoOmZpFxuXG5cbiAgICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAnZGVzdHJveSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHJlc3RhcnQ6IGZ1bmN0aW9uIChnbG9iYWxUaW1lKSB7XG4gICAgdmFyIHJlbWFpbmRlciA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fcGF1c2VkVGltZSkgJSB0aGlzLl9saWZlO1xuICAgIHRoaXMuX3N0YXJ0VGltZSA9IGdsb2JhbFRpbWUgLSByZW1haW5kZXIgKyB0aGlzLmdhcDtcbiAgICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcbiAgICB0aGlzLl9uZWVkc1JlbW92ZSA9IGZhbHNlO1xuICB9LFxuICBmaXJlOiBmdW5jdGlvbiAoZXZlbnRUeXBlLCBhcmcpIHtcbiAgICBldmVudFR5cGUgPSAnb24nICsgZXZlbnRUeXBlO1xuXG4gICAgaWYgKHRoaXNbZXZlbnRUeXBlXSkge1xuICAgICAgdGhpc1tldmVudFR5cGVdKHRoaXMuX3RhcmdldCwgYXJnKTtcbiAgICB9XG4gIH0sXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgfSxcbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBDbGlwO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog57yT5Yqo5Luj56CB5p2l6IeqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xlL3R3ZWVuLmpzL2Jsb2IvbWFzdGVyL3NyYy9Ud2Vlbi5qc1xuICogQHNlZSBodHRwOi8vc29sZS5naXRodWIuaW8vdHdlZW4uanMvZXhhbXBsZXMvMDNfZ3JhcGhzLmh0bWxcbiAqIEBleHBvcnRzIHpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ1xuICovXG52YXIgZWFzaW5nID0ge1xuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgbGluZWFyOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFkcmF0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YWRyYXRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqICgyIC0gayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YWRyYXRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogaztcbiAgICB9XG5cbiAgICByZXR1cm4gLTAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG4gIH0sXG4gIC8vIOS4ieasoeaWueeahOe8k+WKqO+8iHReM++8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjdWJpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGN1YmljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAtLWsgKiBrICogayArIDE7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGN1YmljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcbiAgfSxcbiAgLy8g5Zub5qyh5pa555qE57yT5Yqo77yIdF4077yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YXJ0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhcnRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMSAtIC0tayAqIGsgKiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhcnRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAtMC41ICogKChrIC09IDIpICogayAqIGsgKiBrIC0gMik7XG4gIH0sXG4gIC8vIOS6lOasoeaWueeahOe8k+WKqO+8iHReNe+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWludGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiBrICogayAqIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWludGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVpbnRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrICogaztcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKiBrICogayArIDIpO1xuICB9LFxuICAvLyDmraPlvKbmm7Lnur/nmoTnvJPliqjvvIhzaW4odCnvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgc2ludXNvaWRhbEluOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAxIC0gTWF0aC5jb3MoayAqIE1hdGguUEkgLyAyKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgc2ludXNvaWRhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gTWF0aC5zaW4oayAqIE1hdGguUEkgLyAyKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgc2ludXNvaWRhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gIH0sXG4gIC8vIOaMh+aVsOabsue6v+eahOe8k+WKqO+8iDJedO+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBleHBvbmVudGlhbEluOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrID09PSAwID8gMCA6IE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZXhwb25lbnRpYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgPT09IDEgPyAxIDogMSAtIE1hdGgucG93KDIsIC0xMCAqIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBleHBvbmVudGlhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAoayAtIDEpKSArIDIpO1xuICB9LFxuICAvLyDlnIblvaLmm7Lnur/nmoTnvJPliqjvvIhzcXJ0KDEtdF4yKe+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjaXJjdWxhckluOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBrICogayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGNpcmN1bGFyT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tayAqIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjaXJjdWxhckluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gayAqIGspIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIChrIC09IDIpICogaykgKyAxKTtcbiAgfSxcbiAgLy8g5Yib5bu657G75Ly85LqO5by557Cn5Zyo5YGc5q2i5YmN5p2l5Zue5oyv6I2h55qE5Yqo55S7XG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGVsYXN0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcztcbiAgICB2YXIgYSA9IDAuMTtcbiAgICB2YXIgcCA9IDAuNDtcblxuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICBhID0gMTtcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICB9XG5cbiAgICByZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZWxhc3RpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcztcbiAgICB2YXIgYSA9IDAuMTtcbiAgICB2YXIgcCA9IDAuNDtcblxuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICBhID0gMTtcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIGspICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDE7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGVsYXN0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcztcbiAgICB2YXIgYSA9IDAuMTtcbiAgICB2YXIgcCA9IDAuNDtcblxuICAgIGlmIChrID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICBhID0gMTtcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICB9XG5cbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gLTAuNSAqIChhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuICB9LFxuICAvLyDlnKjmn5DkuIDliqjnlLvlvIDlp4vmsr/mjIfnpLrnmoTot6/lvoTov5vooYzliqjnlLvlpITnkIbliY3nqI3nqI3mlLblm57or6XliqjnlLvnmoTnp7vliqhcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYmFja0luOiBmdW5jdGlvbiAoaykge1xuICAgIHZhciBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYmFja091dDogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIC0tayAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDE7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJhY2tJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcyA9IDEuNzAxNTggKiAxLjUyNTtcblxuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAoayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDIpO1xuICB9LFxuICAvLyDliJvlu7rlvLnot7PmlYjmnpxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYm91bmNlSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNpbmcuYm91bmNlT3V0KDEgLSBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYm91bmNlT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmIChrIDwgMSAvIDIuNzUpIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiBrICogaztcbiAgICB9IGVsc2UgaWYgKGsgPCAyIC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDEuNSAvIDIuNzUpICogayArIDAuNzU7XG4gICAgfSBlbHNlIGlmIChrIDwgMi41IC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDIuMjUgLyAyLjc1KSAqIGsgKyAwLjkzNzU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAyLjYyNSAvIDIuNzUpICogayArIDAuOTg0Mzc1O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgYm91bmNlSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgPCAwLjUpIHtcbiAgICAgIHJldHVybiBlYXNpbmcuYm91bmNlSW4oayAqIDIpICogMC41O1xuICAgIH1cblxuICAgIHJldHVybiBlYXNpbmcuYm91bmNlT3V0KGsgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBlYXNpbmc7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vZWFzaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTFJVID0gcmVxdWlyZShcIi4uL2NvcmUvTFJVXCIpO1xuXG52YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gICd0cmFuc3BhcmVudCc6IFswLCAwLCAwLCAwXSxcbiAgJ2FsaWNlYmx1ZSc6IFsyNDAsIDI0OCwgMjU1LCAxXSxcbiAgJ2FudGlxdWV3aGl0ZSc6IFsyNTAsIDIzNSwgMjE1LCAxXSxcbiAgJ2FxdWEnOiBbMCwgMjU1LCAyNTUsIDFdLFxuICAnYXF1YW1hcmluZSc6IFsxMjcsIDI1NSwgMjEyLCAxXSxcbiAgJ2F6dXJlJzogWzI0MCwgMjU1LCAyNTUsIDFdLFxuICAnYmVpZ2UnOiBbMjQ1LCAyNDUsIDIyMCwgMV0sXG4gICdiaXNxdWUnOiBbMjU1LCAyMjgsIDE5NiwgMV0sXG4gICdibGFjayc6IFswLCAwLCAwLCAxXSxcbiAgJ2JsYW5jaGVkYWxtb25kJzogWzI1NSwgMjM1LCAyMDUsIDFdLFxuICAnYmx1ZSc6IFswLCAwLCAyNTUsIDFdLFxuICAnYmx1ZXZpb2xldCc6IFsxMzgsIDQzLCAyMjYsIDFdLFxuICAnYnJvd24nOiBbMTY1LCA0MiwgNDIsIDFdLFxuICAnYnVybHl3b29kJzogWzIyMiwgMTg0LCAxMzUsIDFdLFxuICAnY2FkZXRibHVlJzogWzk1LCAxNTgsIDE2MCwgMV0sXG4gICdjaGFydHJldXNlJzogWzEyNywgMjU1LCAwLCAxXSxcbiAgJ2Nob2NvbGF0ZSc6IFsyMTAsIDEwNSwgMzAsIDFdLFxuICAnY29yYWwnOiBbMjU1LCAxMjcsIDgwLCAxXSxcbiAgJ2Nvcm5mbG93ZXJibHVlJzogWzEwMCwgMTQ5LCAyMzcsIDFdLFxuICAnY29ybnNpbGsnOiBbMjU1LCAyNDgsIDIyMCwgMV0sXG4gICdjcmltc29uJzogWzIyMCwgMjAsIDYwLCAxXSxcbiAgJ2N5YW4nOiBbMCwgMjU1LCAyNTUsIDFdLFxuICAnZGFya2JsdWUnOiBbMCwgMCwgMTM5LCAxXSxcbiAgJ2RhcmtjeWFuJzogWzAsIDEzOSwgMTM5LCAxXSxcbiAgJ2Rhcmtnb2xkZW5yb2QnOiBbMTg0LCAxMzQsIDExLCAxXSxcbiAgJ2RhcmtncmF5JzogWzE2OSwgMTY5LCAxNjksIDFdLFxuICAnZGFya2dyZWVuJzogWzAsIDEwMCwgMCwgMV0sXG4gICdkYXJrZ3JleSc6IFsxNjksIDE2OSwgMTY5LCAxXSxcbiAgJ2RhcmtraGFraSc6IFsxODksIDE4MywgMTA3LCAxXSxcbiAgJ2RhcmttYWdlbnRhJzogWzEzOSwgMCwgMTM5LCAxXSxcbiAgJ2RhcmtvbGl2ZWdyZWVuJzogWzg1LCAxMDcsIDQ3LCAxXSxcbiAgJ2RhcmtvcmFuZ2UnOiBbMjU1LCAxNDAsIDAsIDFdLFxuICAnZGFya29yY2hpZCc6IFsxNTMsIDUwLCAyMDQsIDFdLFxuICAnZGFya3JlZCc6IFsxMzksIDAsIDAsIDFdLFxuICAnZGFya3NhbG1vbic6IFsyMzMsIDE1MCwgMTIyLCAxXSxcbiAgJ2RhcmtzZWFncmVlbic6IFsxNDMsIDE4OCwgMTQzLCAxXSxcbiAgJ2RhcmtzbGF0ZWJsdWUnOiBbNzIsIDYxLCAxMzksIDFdLFxuICAnZGFya3NsYXRlZ3JheSc6IFs0NywgNzksIDc5LCAxXSxcbiAgJ2RhcmtzbGF0ZWdyZXknOiBbNDcsIDc5LCA3OSwgMV0sXG4gICdkYXJrdHVycXVvaXNlJzogWzAsIDIwNiwgMjA5LCAxXSxcbiAgJ2Rhcmt2aW9sZXQnOiBbMTQ4LCAwLCAyMTEsIDFdLFxuICAnZGVlcHBpbmsnOiBbMjU1LCAyMCwgMTQ3LCAxXSxcbiAgJ2RlZXBza3libHVlJzogWzAsIDE5MSwgMjU1LCAxXSxcbiAgJ2RpbWdyYXknOiBbMTA1LCAxMDUsIDEwNSwgMV0sXG4gICdkaW1ncmV5JzogWzEwNSwgMTA1LCAxMDUsIDFdLFxuICAnZG9kZ2VyYmx1ZSc6IFszMCwgMTQ0LCAyNTUsIDFdLFxuICAnZmlyZWJyaWNrJzogWzE3OCwgMzQsIDM0LCAxXSxcbiAgJ2Zsb3JhbHdoaXRlJzogWzI1NSwgMjUwLCAyNDAsIDFdLFxuICAnZm9yZXN0Z3JlZW4nOiBbMzQsIDEzOSwgMzQsIDFdLFxuICAnZnVjaHNpYSc6IFsyNTUsIDAsIDI1NSwgMV0sXG4gICdnYWluc2Jvcm8nOiBbMjIwLCAyMjAsIDIyMCwgMV0sXG4gICdnaG9zdHdoaXRlJzogWzI0OCwgMjQ4LCAyNTUsIDFdLFxuICAnZ29sZCc6IFsyNTUsIDIxNSwgMCwgMV0sXG4gICdnb2xkZW5yb2QnOiBbMjE4LCAxNjUsIDMyLCAxXSxcbiAgJ2dyYXknOiBbMTI4LCAxMjgsIDEyOCwgMV0sXG4gICdncmVlbic6IFswLCAxMjgsIDAsIDFdLFxuICAnZ3JlZW55ZWxsb3cnOiBbMTczLCAyNTUsIDQ3LCAxXSxcbiAgJ2dyZXknOiBbMTI4LCAxMjgsIDEyOCwgMV0sXG4gICdob25leWRldyc6IFsyNDAsIDI1NSwgMjQwLCAxXSxcbiAgJ2hvdHBpbmsnOiBbMjU1LCAxMDUsIDE4MCwgMV0sXG4gICdpbmRpYW5yZWQnOiBbMjA1LCA5MiwgOTIsIDFdLFxuICAnaW5kaWdvJzogWzc1LCAwLCAxMzAsIDFdLFxuICAnaXZvcnknOiBbMjU1LCAyNTUsIDI0MCwgMV0sXG4gICdraGFraSc6IFsyNDAsIDIzMCwgMTQwLCAxXSxcbiAgJ2xhdmVuZGVyJzogWzIzMCwgMjMwLCAyNTAsIDFdLFxuICAnbGF2ZW5kZXJibHVzaCc6IFsyNTUsIDI0MCwgMjQ1LCAxXSxcbiAgJ2xhd25ncmVlbic6IFsxMjQsIDI1MiwgMCwgMV0sXG4gICdsZW1vbmNoaWZmb24nOiBbMjU1LCAyNTAsIDIwNSwgMV0sXG4gICdsaWdodGJsdWUnOiBbMTczLCAyMTYsIDIzMCwgMV0sXG4gICdsaWdodGNvcmFsJzogWzI0MCwgMTI4LCAxMjgsIDFdLFxuICAnbGlnaHRjeWFuJzogWzIyNCwgMjU1LCAyNTUsIDFdLFxuICAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiBbMjUwLCAyNTAsIDIxMCwgMV0sXG4gICdsaWdodGdyYXknOiBbMjExLCAyMTEsIDIxMSwgMV0sXG4gICdsaWdodGdyZWVuJzogWzE0NCwgMjM4LCAxNDQsIDFdLFxuICAnbGlnaHRncmV5JzogWzIxMSwgMjExLCAyMTEsIDFdLFxuICAnbGlnaHRwaW5rJzogWzI1NSwgMTgyLCAxOTMsIDFdLFxuICAnbGlnaHRzYWxtb24nOiBbMjU1LCAxNjAsIDEyMiwgMV0sXG4gICdsaWdodHNlYWdyZWVuJzogWzMyLCAxNzgsIDE3MCwgMV0sXG4gICdsaWdodHNreWJsdWUnOiBbMTM1LCAyMDYsIDI1MCwgMV0sXG4gICdsaWdodHNsYXRlZ3JheSc6IFsxMTksIDEzNiwgMTUzLCAxXSxcbiAgJ2xpZ2h0c2xhdGVncmV5JzogWzExOSwgMTM2LCAxNTMsIDFdLFxuICAnbGlnaHRzdGVlbGJsdWUnOiBbMTc2LCAxOTYsIDIyMiwgMV0sXG4gICdsaWdodHllbGxvdyc6IFsyNTUsIDI1NSwgMjI0LCAxXSxcbiAgJ2xpbWUnOiBbMCwgMjU1LCAwLCAxXSxcbiAgJ2xpbWVncmVlbic6IFs1MCwgMjA1LCA1MCwgMV0sXG4gICdsaW5lbic6IFsyNTAsIDI0MCwgMjMwLCAxXSxcbiAgJ21hZ2VudGEnOiBbMjU1LCAwLCAyNTUsIDFdLFxuICAnbWFyb29uJzogWzEyOCwgMCwgMCwgMV0sXG4gICdtZWRpdW1hcXVhbWFyaW5lJzogWzEwMiwgMjA1LCAxNzAsIDFdLFxuICAnbWVkaXVtYmx1ZSc6IFswLCAwLCAyMDUsIDFdLFxuICAnbWVkaXVtb3JjaGlkJzogWzE4NiwgODUsIDIxMSwgMV0sXG4gICdtZWRpdW1wdXJwbGUnOiBbMTQ3LCAxMTIsIDIxOSwgMV0sXG4gICdtZWRpdW1zZWFncmVlbic6IFs2MCwgMTc5LCAxMTMsIDFdLFxuICAnbWVkaXVtc2xhdGVibHVlJzogWzEyMywgMTA0LCAyMzgsIDFdLFxuICAnbWVkaXVtc3ByaW5nZ3JlZW4nOiBbMCwgMjUwLCAxNTQsIDFdLFxuICAnbWVkaXVtdHVycXVvaXNlJzogWzcyLCAyMDksIDIwNCwgMV0sXG4gICdtZWRpdW12aW9sZXRyZWQnOiBbMTk5LCAyMSwgMTMzLCAxXSxcbiAgJ21pZG5pZ2h0Ymx1ZSc6IFsyNSwgMjUsIDExMiwgMV0sXG4gICdtaW50Y3JlYW0nOiBbMjQ1LCAyNTUsIDI1MCwgMV0sXG4gICdtaXN0eXJvc2UnOiBbMjU1LCAyMjgsIDIyNSwgMV0sXG4gICdtb2NjYXNpbic6IFsyNTUsIDIyOCwgMTgxLCAxXSxcbiAgJ25hdmFqb3doaXRlJzogWzI1NSwgMjIyLCAxNzMsIDFdLFxuICAnbmF2eSc6IFswLCAwLCAxMjgsIDFdLFxuICAnb2xkbGFjZSc6IFsyNTMsIDI0NSwgMjMwLCAxXSxcbiAgJ29saXZlJzogWzEyOCwgMTI4LCAwLCAxXSxcbiAgJ29saXZlZHJhYic6IFsxMDcsIDE0MiwgMzUsIDFdLFxuICAnb3JhbmdlJzogWzI1NSwgMTY1LCAwLCAxXSxcbiAgJ29yYW5nZXJlZCc6IFsyNTUsIDY5LCAwLCAxXSxcbiAgJ29yY2hpZCc6IFsyMTgsIDExMiwgMjE0LCAxXSxcbiAgJ3BhbGVnb2xkZW5yb2QnOiBbMjM4LCAyMzIsIDE3MCwgMV0sXG4gICdwYWxlZ3JlZW4nOiBbMTUyLCAyNTEsIDE1MiwgMV0sXG4gICdwYWxldHVycXVvaXNlJzogWzE3NSwgMjM4LCAyMzgsIDFdLFxuICAncGFsZXZpb2xldHJlZCc6IFsyMTksIDExMiwgMTQ3LCAxXSxcbiAgJ3BhcGF5YXdoaXAnOiBbMjU1LCAyMzksIDIxMywgMV0sXG4gICdwZWFjaHB1ZmYnOiBbMjU1LCAyMTgsIDE4NSwgMV0sXG4gICdwZXJ1JzogWzIwNSwgMTMzLCA2MywgMV0sXG4gICdwaW5rJzogWzI1NSwgMTkyLCAyMDMsIDFdLFxuICAncGx1bSc6IFsyMjEsIDE2MCwgMjIxLCAxXSxcbiAgJ3Bvd2RlcmJsdWUnOiBbMTc2LCAyMjQsIDIzMCwgMV0sXG4gICdwdXJwbGUnOiBbMTI4LCAwLCAxMjgsIDFdLFxuICAncmVkJzogWzI1NSwgMCwgMCwgMV0sXG4gICdyb3N5YnJvd24nOiBbMTg4LCAxNDMsIDE0MywgMV0sXG4gICdyb3lhbGJsdWUnOiBbNjUsIDEwNSwgMjI1LCAxXSxcbiAgJ3NhZGRsZWJyb3duJzogWzEzOSwgNjksIDE5LCAxXSxcbiAgJ3NhbG1vbic6IFsyNTAsIDEyOCwgMTE0LCAxXSxcbiAgJ3NhbmR5YnJvd24nOiBbMjQ0LCAxNjQsIDk2LCAxXSxcbiAgJ3NlYWdyZWVuJzogWzQ2LCAxMzksIDg3LCAxXSxcbiAgJ3NlYXNoZWxsJzogWzI1NSwgMjQ1LCAyMzgsIDFdLFxuICAnc2llbm5hJzogWzE2MCwgODIsIDQ1LCAxXSxcbiAgJ3NpbHZlcic6IFsxOTIsIDE5MiwgMTkyLCAxXSxcbiAgJ3NreWJsdWUnOiBbMTM1LCAyMDYsIDIzNSwgMV0sXG4gICdzbGF0ZWJsdWUnOiBbMTA2LCA5MCwgMjA1LCAxXSxcbiAgJ3NsYXRlZ3JheSc6IFsxMTIsIDEyOCwgMTQ0LCAxXSxcbiAgJ3NsYXRlZ3JleSc6IFsxMTIsIDEyOCwgMTQ0LCAxXSxcbiAgJ3Nub3cnOiBbMjU1LCAyNTAsIDI1MCwgMV0sXG4gICdzcHJpbmdncmVlbic6IFswLCAyNTUsIDEyNywgMV0sXG4gICdzdGVlbGJsdWUnOiBbNzAsIDEzMCwgMTgwLCAxXSxcbiAgJ3Rhbic6IFsyMTAsIDE4MCwgMTQwLCAxXSxcbiAgJ3RlYWwnOiBbMCwgMTI4LCAxMjgsIDFdLFxuICAndGhpc3RsZSc6IFsyMTYsIDE5MSwgMjE2LCAxXSxcbiAgJ3RvbWF0byc6IFsyNTUsIDk5LCA3MSwgMV0sXG4gICd0dXJxdW9pc2UnOiBbNjQsIDIyNCwgMjA4LCAxXSxcbiAgJ3Zpb2xldCc6IFsyMzgsIDEzMCwgMjM4LCAxXSxcbiAgJ3doZWF0JzogWzI0NSwgMjIyLCAxNzksIDFdLFxuICAnd2hpdGUnOiBbMjU1LCAyNTUsIDI1NSwgMV0sXG4gICd3aGl0ZXNtb2tlJzogWzI0NSwgMjQ1LCAyNDUsIDFdLFxuICAneWVsbG93JzogWzI1NSwgMjU1LCAwLCAxXSxcbiAgJ3llbGxvd2dyZWVuJzogWzE1NCwgMjA1LCA1MCwgMV1cbn07XG5cbmZ1bmN0aW9uIGNsYW1wQ3NzQnl0ZShpKSB7XG4gIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gIGkgPSBNYXRoLnJvdW5kKGkpOyAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cblxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wQ3NzQW5nbGUoaSkge1xuICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMzYwLlxuICBpID0gTWF0aC5yb3VuZChpKTsgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG5cbiAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAzNjAgPyAzNjAgOiBpO1xufVxuXG5mdW5jdGlvbiBjbGFtcENzc0Zsb2F0KGYpIHtcbiAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC5cbiAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ3NzSW50KHN0cikge1xuICAvLyBpbnQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgfVxuXG4gIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VJbnQoc3RyLCAxMCkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNzc0Zsb2F0KHN0cikge1xuICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgfVxuXG4gIHJldHVybiBjbGFtcENzc0Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkge1xuICBpZiAoaCA8IDApIHtcbiAgICBoICs9IDE7XG4gIH0gZWxzZSBpZiAoaCA+IDEpIHtcbiAgICBoIC09IDE7XG4gIH1cblxuICBpZiAoaCAqIDYgPCAxKSB7XG4gICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gIH1cblxuICBpZiAoaCAqIDIgPCAxKSB7XG4gICAgcmV0dXJuIG0yO1xuICB9XG5cbiAgaWYgKGggKiAzIDwgMikge1xuICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNjtcbiAgfVxuXG4gIHJldHVybiBtMTtcbn1cblxuZnVuY3Rpb24gbGVycE51bWJlcihhLCBiLCBwKSB7XG4gIHJldHVybiBhICsgKGIgLSBhKSAqIHA7XG59XG5cbmZ1bmN0aW9uIHNldFJnYmEob3V0LCByLCBnLCBiLCBhKSB7XG4gIG91dFswXSA9IHI7XG4gIG91dFsxXSA9IGc7XG4gIG91dFsyXSA9IGI7XG4gIG91dFszXSA9IGE7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGNvcHlSZ2JhKG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG52YXIgY29sb3JDYWNoZSA9IG5ldyBMUlUoMjApO1xudmFyIGxhc3RSZW1vdmVkQXJyID0gbnVsbDtcblxuZnVuY3Rpb24gcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycikge1xuICAvLyBSZXVzZSByZW1vdmVkIGFycmF5XG4gIGlmIChsYXN0UmVtb3ZlZEFycikge1xuICAgIGNvcHlSZ2JhKGxhc3RSZW1vdmVkQXJyLCByZ2JhQXJyKTtcbiAgfVxuXG4gIGxhc3RSZW1vdmVkQXJyID0gY29sb3JDYWNoZS5wdXQoY29sb3JTdHIsIGxhc3RSZW1vdmVkQXJyIHx8IHJnYmFBcnIuc2xpY2UoKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclN0clxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZShjb2xvclN0ciwgcmdiYUFycikge1xuICBpZiAoIWNvbG9yU3RyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmdiYUFyciA9IHJnYmFBcnIgfHwgW107XG4gIHZhciBjYWNoZWQgPSBjb2xvckNhY2hlLmdldChjb2xvclN0cik7XG5cbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjb3B5UmdiYShyZ2JhQXJyLCBjYWNoZWQpO1xuICB9IC8vIGNvbG9yU3RyIG1heSBiZSBub3Qgc3RyaW5nXG5cblxuICBjb2xvclN0ciA9IGNvbG9yU3RyICsgJyc7IC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxuXG4gIHZhciBzdHIgPSBjb2xvclN0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpOyAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG5cbiAgaWYgKHN0ciBpbiBrQ1NTQ29sb3JUYWJsZSkge1xuICAgIGNvcHlSZ2JhKHJnYmFBcnIsIGtDU1NDb2xvclRhYmxlW3N0cl0pO1xuICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgIHJldHVybiByZ2JhQXJyO1xuICB9IC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuXG5cbiAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7IC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkge1xuICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICByZXR1cm47IC8vIENvdmVycyBOYU4uXG4gICAgICB9XG5cbiAgICAgIHNldFJnYmEocmdiYUFyciwgKGl2ICYgMHhmMDApID4+IDQgfCAoaXYgJiAweGYwMCkgPj4gOCwgaXYgJiAweGYwIHwgKGl2ICYgMHhmMCkgPj4gNCwgaXYgJiAweGYgfCAoaXYgJiAweGYpIDw8IDQsIDEpO1xuICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICByZXR1cm4gcmdiYUFycjtcbiAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSB7XG4gICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgIHJldHVybjsgLy8gQ292ZXJzIE5hTi5cbiAgICAgIH1cblxuICAgICAgc2V0UmdiYShyZ2JhQXJyLCAoaXYgJiAweGZmMDAwMCkgPj4gMTYsIChpdiAmIDB4ZmYwMCkgPj4gOCwgaXYgJiAweGZmLCAxKTtcbiAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSxcbiAgICAgIGVwID0gc3RyLmluZGV4T2YoJyknKTtcblxuICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wICsgMSwgZXAgLSAob3AgKyAxKSkuc3BsaXQoJywnKTtcbiAgICB2YXIgYWxwaGEgPSAxOyAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuXG4gICAgc3dpdGNoIChmbmFtZSkge1xuICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhbHBoYSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuXG4gICAgICBjYXNlICdyZ2InOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCBwYXJzZUNzc0ludChwYXJhbXNbMF0pLCBwYXJzZUNzc0ludChwYXJhbXNbMV0pLCBwYXJzZUNzc0ludChwYXJhbXNbMl0pLCBhbHBoYSk7XG4gICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICByZXR1cm4gcmdiYUFycjtcblxuICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXNbM10gPSBwYXJzZUNzc0Zsb2F0KHBhcmFtc1szXSk7XG4gICAgICAgIGhzbGEycmdiYShwYXJhbXMsIHJnYmFBcnIpO1xuICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG5cbiAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBoc2xhMnJnYmEocGFyYW1zLCByZ2JhQXJyKTtcbiAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgIHJldHVybiByZ2JhQXJyO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgcmV0dXJuO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICovXG5cblxuZnVuY3Rpb24gaHNsYTJyZ2JhKGhzbGEsIHJnYmEpIHtcbiAgdmFyIGggPSAocGFyc2VGbG9hdChoc2xhWzBdKSAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjA7IC8vIDAgLi4gMVxuICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuXG4gIHZhciBzID0gcGFyc2VDc3NGbG9hdChoc2xhWzFdKTtcbiAgdmFyIGwgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMl0pO1xuICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgcmdiYSA9IHJnYmEgfHwgW107XG4gIHNldFJnYmEocmdiYSwgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCArIDEgLyAzKSAqIDI1NSksIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGgpICogMjU1KSwgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCAtIDEgLyAzKSAqIDI1NSksIDEpO1xuXG4gIGlmIChoc2xhLmxlbmd0aCA9PT0gNCkge1xuICAgIHJnYmFbM10gPSBoc2xhWzNdO1xuICB9XG5cbiAgcmV0dXJuIHJnYmE7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gKi9cblxuXG5mdW5jdGlvbiByZ2JhMmhzbGEocmdiYSkge1xuICBpZiAoIXJnYmEpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gUkdCIGZyb20gMCB0byAyNTVcblxuXG4gIHZhciBSID0gcmdiYVswXSAvIDI1NTtcbiAgdmFyIEcgPSByZ2JhWzFdIC8gMjU1O1xuICB2YXIgQiA9IHJnYmFbMl0gLyAyNTU7XG4gIHZhciB2TWluID0gTWF0aC5taW4oUiwgRywgQik7IC8vIE1pbi4gdmFsdWUgb2YgUkdCXG5cbiAgdmFyIHZNYXggPSBNYXRoLm1heChSLCBHLCBCKTsgLy8gTWF4LiB2YWx1ZSBvZiBSR0JcblxuICB2YXIgZGVsdGEgPSB2TWF4IC0gdk1pbjsgLy8gRGVsdGEgUkdCIHZhbHVlXG5cbiAgdmFyIEwgPSAodk1heCArIHZNaW4pIC8gMjtcbiAgdmFyIEg7XG4gIHZhciBTOyAvLyBIU0wgcmVzdWx0cyBmcm9tIDAgdG8gMVxuXG4gIGlmIChkZWx0YSA9PT0gMCkge1xuICAgIEggPSAwO1xuICAgIFMgPSAwO1xuICB9IGVsc2Uge1xuICAgIGlmIChMIDwgMC41KSB7XG4gICAgICBTID0gZGVsdGEgLyAodk1heCArIHZNaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBTID0gZGVsdGEgLyAoMiAtIHZNYXggLSB2TWluKTtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGFSID0gKCh2TWF4IC0gUikgLyA2ICsgZGVsdGEgLyAyKSAvIGRlbHRhO1xuICAgIHZhciBkZWx0YUcgPSAoKHZNYXggLSBHKSAvIDYgKyBkZWx0YSAvIDIpIC8gZGVsdGE7XG4gICAgdmFyIGRlbHRhQiA9ICgodk1heCAtIEIpIC8gNiArIGRlbHRhIC8gMikgLyBkZWx0YTtcblxuICAgIGlmIChSID09PSB2TWF4KSB7XG4gICAgICBIID0gZGVsdGFCIC0gZGVsdGFHO1xuICAgIH0gZWxzZSBpZiAoRyA9PT0gdk1heCkge1xuICAgICAgSCA9IDEgLyAzICsgZGVsdGFSIC0gZGVsdGFCO1xuICAgIH0gZWxzZSBpZiAoQiA9PT0gdk1heCkge1xuICAgICAgSCA9IDIgLyAzICsgZGVsdGFHIC0gZGVsdGFSO1xuICAgIH1cblxuICAgIGlmIChIIDwgMCkge1xuICAgICAgSCArPSAxO1xuICAgIH1cblxuICAgIGlmIChIID4gMSkge1xuICAgICAgSCAtPSAxO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoc2xhID0gW0ggKiAzNjAsIFMsIExdO1xuXG4gIGlmIChyZ2JhWzNdICE9IG51bGwpIHtcbiAgICBoc2xhLnB1c2gocmdiYVszXSk7XG4gIH1cblxuICByZXR1cm4gaHNsYTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiBsaWZ0KGNvbG9yLCBsZXZlbCkge1xuICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yQXJyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgY29sb3JBcnJbaV0gPSBjb2xvckFycltpXSAqICgxIC0gbGV2ZWwpIHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbG9yQXJyW2ldID0gKDI1NSAtIGNvbG9yQXJyW2ldKSAqIGxldmVsICsgY29sb3JBcnJbaV0gfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdpZnkoY29sb3JBcnIsIGNvbG9yQXJyLmxlbmd0aCA9PT0gNCA/ICdyZ2JhJyA6ICdyZ2InKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiB0b0hleChjb2xvcikge1xuICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yQXJyKSB7XG4gICAgcmV0dXJuICgoMSA8PCAyNCkgKyAoY29sb3JBcnJbMF0gPDwgMTYpICsgKGNvbG9yQXJyWzFdIDw8IDgpICsgK2NvbG9yQXJyWzJdKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gIH1cbn1cbi8qKlxuICogTWFwIHZhbHVlIHRvIGNvbG9yLiBGYXN0ZXIgdGhhbiBsZXJwIG1ldGhvZHMgYmVjYXVzZSBjb2xvciBpcyByZXByZXNlbnRlZCBieSByZ2JhIGFycmF5LlxuICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRWYWx1ZSBBIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gY29sb3JzIExpc3Qgb2YgcmdiYSBjb2xvciBhcnJheVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW291dF0gTWFwcGVkIGdiYSBjb2xvciBhcnJheVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IHdpbGwgYmUgbnVsbC91bmRlZmluZWQgaWYgaW5wdXQgaWxsZWdhbC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZhc3RMZXJwKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBvdXQpIHtcbiAgaWYgKCEoY29sb3JzICYmIGNvbG9ycy5sZW5ndGgpIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3V0ID0gb3V0IHx8IFtdO1xuICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgdmFyIGxlZnRDb2xvciA9IGNvbG9yc1tsZWZ0SW5kZXhdO1xuICB2YXIgcmlnaHRDb2xvciA9IGNvbG9yc1tyaWdodEluZGV4XTtcbiAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG4gIG91dFswXSA9IGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclswXSwgcmlnaHRDb2xvclswXSwgZHYpKTtcbiAgb3V0WzFdID0gY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzFdLCByaWdodENvbG9yWzFdLCBkdikpO1xuICBvdXRbMl0gPSBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSk7XG4gIG91dFszXSA9IGNsYW1wQ3NzRmxvYXQobGVycE51bWJlcihsZWZ0Q29sb3JbM10sIHJpZ2h0Q29sb3JbM10sIGR2KSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuXG52YXIgZmFzdE1hcFRvQ29sb3IgPSBmYXN0TGVycDtcbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRWYWx1ZSBBIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9ycyBDb2xvciBsaXN0LlxuICogQHBhcmFtIHtib29sZWFuPX0gZnVsbE91dHB1dCBEZWZhdWx0IGZhbHNlLlxuICogQHJldHVybiB7KHN0cmluZ3xPYmplY3QpfSBSZXN1bHQgY29sb3IuIElmIGZ1bGxPdXRwdXQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sb3I6IC4uLiwgbGVmdEluZGV4OiAuLi4sIHJpZ2h0SW5kZXg6IC4uLiwgdmFsdWU6IC4uLn0sXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICovXG5cbmZ1bmN0aW9uIGxlcnAobm9ybWFsaXplZFZhbHVlLCBjb2xvcnMsIGZ1bGxPdXRwdXQpIHtcbiAgaWYgKCEoY29sb3JzICYmIGNvbG9ycy5sZW5ndGgpIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gbm9ybWFsaXplZFZhbHVlICogKGNvbG9ycy5sZW5ndGggLSAxKTtcbiAgdmFyIGxlZnRJbmRleCA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gIHZhciBsZWZ0Q29sb3IgPSBwYXJzZShjb2xvcnNbbGVmdEluZGV4XSk7XG4gIHZhciByaWdodENvbG9yID0gcGFyc2UoY29sb3JzW3JpZ2h0SW5kZXhdKTtcbiAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG4gIHZhciBjb2xvciA9IHN0cmluZ2lmeShbY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpLCBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSksIGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKSwgY2xhbXBDc3NGbG9hdChsZXJwTnVtYmVyKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKV0sICdyZ2JhJyk7XG4gIHJldHVybiBmdWxsT3V0cHV0ID8ge1xuICAgIGNvbG9yOiBjb2xvcixcbiAgICBsZWZ0SW5kZXg6IGxlZnRJbmRleCxcbiAgICByaWdodEluZGV4OiByaWdodEluZGV4LFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9IDogY29sb3I7XG59XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuXG52YXIgbWFwVG9Db2xvciA9IGxlcnA7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHBhcmFtIHtudW1iZXI9fSBoIDAgfiAzNjAsIGlnbm9yZSB3aGVuIG51bGwuXG4gKiBAcGFyYW0ge251bWJlcj19IHMgMCB+IDEsIGlnbm9yZSB3aGVuIG51bGwuXG4gKiBAcGFyYW0ge251bWJlcj19IGwgMCB+IDEsIGlnbm9yZSB3aGVuIG51bGwuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuZnVuY3Rpb24gbW9kaWZ5SFNMKGNvbG9yLCBoLCBzLCBsKSB7XG4gIGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXG4gIGlmIChjb2xvcikge1xuICAgIGNvbG9yID0gcmdiYTJoc2xhKGNvbG9yKTtcbiAgICBoICE9IG51bGwgJiYgKGNvbG9yWzBdID0gY2xhbXBDc3NBbmdsZShoKSk7XG4gICAgcyAhPSBudWxsICYmIChjb2xvclsxXSA9IHBhcnNlQ3NzRmxvYXQocykpO1xuICAgIGwgIT0gbnVsbCAmJiAoY29sb3JbMl0gPSBwYXJzZUNzc0Zsb2F0KGwpKTtcbiAgICByZXR1cm4gc3RyaW5naWZ5KGhzbGEycmdiYShjb2xvciksICdyZ2JhJyk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge251bWJlcj19IGFscGhhIDAgfiAxXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiBtb2RpZnlBbHBoYShjb2xvciwgYWxwaGEpIHtcbiAgY29sb3IgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yICYmIGFscGhhICE9IG51bGwpIHtcbiAgICBjb2xvclszXSA9IGNsYW1wQ3NzRmxvYXQoYWxwaGEpO1xuICAgIHJldHVybiBzdHJpbmdpZnkoY29sb3IsICdyZ2JhJyk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyQ29sb3IgbGlrZSBbMTIsMzMsNDQsMC40XVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgJ3JnYmEnLCAnaHN2YScsIC4uLlxuICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHQgY29sb3IuIChJZiBpbnB1dCBpbGxlZ2FsLCByZXR1cm4gdW5kZWZpbmVkKS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnJDb2xvciwgdHlwZSkge1xuICBpZiAoIWFyckNvbG9yIHx8ICFhcnJDb2xvci5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29sb3JTdHIgPSBhcnJDb2xvclswXSArICcsJyArIGFyckNvbG9yWzFdICsgJywnICsgYXJyQ29sb3JbMl07XG5cbiAgaWYgKHR5cGUgPT09ICdyZ2JhJyB8fCB0eXBlID09PSAnaHN2YScgfHwgdHlwZSA9PT0gJ2hzbGEnKSB7XG4gICAgY29sb3JTdHIgKz0gJywnICsgYXJyQ29sb3JbM107XG4gIH1cblxuICByZXR1cm4gdHlwZSArICcoJyArIGNvbG9yU3RyICsgJyknO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLmxpZnQgPSBsaWZ0O1xuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuZXhwb3J0cy5mYXN0TGVycCA9IGZhc3RMZXJwO1xuZXhwb3J0cy5mYXN0TWFwVG9Db2xvciA9IGZhc3RNYXBUb0NvbG9yO1xuZXhwb3J0cy5sZXJwID0gbGVycDtcbmV4cG9ydHMubWFwVG9Db2xvciA9IG1hcFRvQ29sb3I7XG5leHBvcnRzLm1vZGlmeUhTTCA9IG1vZGlmeUhTTDtcbmV4cG9ydHMubW9kaWZ5QWxwaGEgPSBtb2RpZnlBbHBoYTtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBTaW1wbGUgTFJVIGNhY2hlIHVzZSBkb3VibHkgbGlua2VkIGxpc3Rcbi8vIEBtb2R1bGUgenJlbmRlci9jb3JlL0xSVVxuXG4vKipcbiAqIFNpbXBsZSBkb3VibGUgbGlua2VkIGxpc3QuIENvbXBhcmVkIHdpdGggYXJyYXksIGl0IGhhcyBPKDEpIHJlbW92ZSBvcGVyYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIExpbmtlZExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAqL1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cblxuICB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLl9sZW4gPSAwO1xufTtcblxudmFyIGxpbmtlZExpc3RQcm90byA9IExpbmtlZExpc3QucHJvdG90eXBlO1xuLyoqXG4gKiBJbnNlcnQgYSBuZXcgdmFsdWUgYXQgdGhlIHRhaWxcbiAqIEBwYXJhbSAge30gdmFsXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAqL1xuXG5saW5rZWRMaXN0UHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24gKHZhbCkge1xuICB2YXIgZW50cnkgPSBuZXcgRW50cnkodmFsKTtcbiAgdGhpcy5pbnNlcnRFbnRyeShlbnRyeSk7XG4gIHJldHVybiBlbnRyeTtcbn07XG4vKipcbiAqIEluc2VydCBhbiBlbnRyeSBhdCB0aGUgdGFpbFxuICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9IGVudHJ5XG4gKi9cblxuXG5saW5rZWRMaXN0UHJvdG8uaW5zZXJ0RW50cnkgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O1xuICAgIGVudHJ5LnByZXYgPSB0aGlzLnRhaWw7XG4gICAgZW50cnkubmV4dCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gIH1cblxuICB0aGlzLl9sZW4rKztcbn07XG4vKipcbiAqIFJlbW92ZSBlbnRyeS5cbiAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fSBlbnRyeVxuICovXG5cblxubGlua2VkTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICB2YXIgcHJldiA9IGVudHJ5LnByZXY7XG4gIHZhciBuZXh0ID0gZW50cnkubmV4dDtcblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IG5leHQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gSXMgaGVhZFxuICAgIHRoaXMuaGVhZCA9IG5leHQ7XG4gIH1cblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXY7XG4gIH0gZWxzZSB7XG4gICAgLy8gSXMgdGFpbFxuICAgIHRoaXMudGFpbCA9IHByZXY7XG4gIH1cblxuICBlbnRyeS5uZXh0ID0gZW50cnkucHJldiA9IG51bGw7XG4gIHRoaXMuX2xlbi0tO1xufTtcbi8qKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxubGlua2VkTGlzdFByb3RvLmxlbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xlbjtcbn07XG4vKipcbiAqIENsZWFyIGxpc3RcbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5fbGVuID0gMDtcbn07XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHt9IHZhbFxuICovXG5cblxudmFyIEVudHJ5ID0gZnVuY3Rpb24gKHZhbCkge1xuICAvKipcbiAgICogQHR5cGUge31cbiAgICovXG4gIHRoaXMudmFsdWUgPSB2YWw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAqL1xuXG4gIHRoaXMubmV4dDtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICovXG5cbiAgdGhpcy5wcmV2O1xufTtcbi8qKlxuICogTFJVIENhY2hlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9jb3JlL0xSVVxuICovXG5cblxudmFyIExSVSA9IGZ1bmN0aW9uIChtYXhTaXplKSB7XG4gIHRoaXMuX2xpc3QgPSBuZXcgTGlua2VkTGlzdCgpO1xuICB0aGlzLl9tYXAgPSB7fTtcbiAgdGhpcy5fbWF4U2l6ZSA9IG1heFNpemUgfHwgMTA7XG4gIHRoaXMuX2xhc3RSZW1vdmVkRW50cnkgPSBudWxsO1xufTtcblxudmFyIExSVVByb3RvID0gTFJVLnByb3RvdHlwZTtcbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSAge30gdmFsdWVcbiAqIEByZXR1cm4ge30gUmVtb3ZlZCB2YWx1ZVxuICovXG5cbkxSVVByb3RvLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgdmFyIHJlbW92ZWQgPSBudWxsO1xuXG4gIGlmIChtYXBba2V5XSA9PSBudWxsKSB7XG4gICAgdmFyIGxlbiA9IGxpc3QubGVuKCk7IC8vIFJldXNlIGxhc3QgcmVtb3ZlZCBlbnRyeVxuXG4gICAgdmFyIGVudHJ5ID0gdGhpcy5fbGFzdFJlbW92ZWRFbnRyeTtcblxuICAgIGlmIChsZW4gPj0gdGhpcy5fbWF4U2l6ZSAmJiBsZW4gPiAwKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWRcbiAgICAgIHZhciBsZWFzdFVzZWRFbnRyeSA9IGxpc3QuaGVhZDtcbiAgICAgIGxpc3QucmVtb3ZlKGxlYXN0VXNlZEVudHJ5KTtcbiAgICAgIGRlbGV0ZSBtYXBbbGVhc3RVc2VkRW50cnkua2V5XTtcbiAgICAgIHJlbW92ZWQgPSBsZWFzdFVzZWRFbnRyeS52YWx1ZTtcbiAgICAgIHRoaXMuX2xhc3RSZW1vdmVkRW50cnkgPSBsZWFzdFVzZWRFbnRyeTtcbiAgICB9XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudHJ5ID0gbmV3IEVudHJ5KHZhbHVlKTtcbiAgICB9XG5cbiAgICBlbnRyeS5rZXkgPSBrZXk7XG4gICAgbGlzdC5pbnNlcnRFbnRyeShlbnRyeSk7XG4gICAgbWFwW2tleV0gPSBlbnRyeTtcbiAgfVxuXG4gIHJldHVybiByZW1vdmVkO1xufTtcbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge31cbiAqL1xuXG5cbkxSVVByb3RvLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fbWFwW2tleV07XG4gIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcblxuICBpZiAoZW50cnkgIT0gbnVsbCkge1xuICAgIC8vIFB1dCB0aGUgbGF0ZXN0IHVzZWQgZW50cnkgaW4gdGhlIHRhaWxcbiAgICBpZiAoZW50cnkgIT09IGxpc3QudGFpbCkge1xuICAgICAgbGlzdC5yZW1vdmUoZW50cnkpO1xuICAgICAgbGlzdC5pbnNlcnRFbnRyeShlbnRyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICB9XG59O1xuLyoqXG4gKiBDbGVhciB0aGUgY2FjaGVcbiAqL1xuXG5cbkxSVVByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9saXN0LmNsZWFyKCk7XG5cbiAgdGhpcy5fbWFwID0ge307XG59O1xuXG52YXIgX2RlZmF1bHQgPSBMUlU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL0xSVS5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgZGVidWdNb2RlID0gX2NvbmZpZy5kZWJ1Z01vZGU7XG5cbnZhciBsb2cgPSBmdW5jdGlvbiAoKSB7fTtcblxuaWYgKGRlYnVnTW9kZSA9PT0gMSkge1xuICBsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihhcmd1bWVudHNba10pO1xuICAgIH1cbiAgfTtcbn0gZWxzZSBpZiAoZGVidWdNb2RlID4gMSkge1xuICBsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHMpIHtcbiAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50c1trXSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgX2RlZmF1bHQgPSBsb2c7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL2xvZy5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRwciA9IDE7IC8vIElmIGluIGJyb3dzZXIgZW52aXJvbm1lbnRcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGRwciA9IE1hdGgubWF4KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsIDEpO1xufVxuLyoqXG4gKiBjb25maWfpu5jorqTphY3nva7poblcbiAqIEBleHBvcnRzIHpyZW5kZXIvY29uZmlnXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqL1xuXG4vKipcbiAqIGRlYnVn5pel5b+X6YCJ6aG577yaY2F0Y2hCcnVzaEV4Y2VwdGlvbuS4unRydWXkuIvmnInmlYhcbiAqIDAgOiDkuI3nlJ/miJBkZWJ1Z+aVsOaNru+8jOWPkeW4g+eUqFxuICogMSA6IOW8guW4uOaKm+WHuu+8jOiwg+ivleeUqFxuICogMiA6IOaOp+WItuWPsOi+k+WHuu+8jOiwg+ivleeUqFxuICovXG5cblxudmFyIGRlYnVnTW9kZSA9IDA7IC8vIHJldGluYSDlsY/luZXkvJjljJZcblxudmFyIGRldmljZVBpeGVsUmF0aW8gPSBkcHI7XG5leHBvcnRzLmRlYnVnTW9kZSA9IGRlYnVnTW9kZTtcbmV4cG9ydHMuZGV2aWNlUGl4ZWxSYXRpbyA9IGRldmljZVBpeGVsUmF0aW87XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRleHRIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL3RleHRcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbi8qKlxuICogTWl4aW4gZm9yIGRyYXdpbmcgdGV4dCBpbiBhIGVsZW1lbnQgYm91bmRpbmcgcmVjdFxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1JlY3RUZXh0XG4gKi9cbnZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgpO1xuXG52YXIgUmVjdFRleHQgPSBmdW5jdGlvbiAoKSB7fTtcblxuUmVjdFRleHQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUmVjdFRleHQsXG5cbiAgLyoqXG4gICAqIERyYXcgdGV4dCBpbiBhIHJlY3Qgd2l0aCBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSAge09iamVjdH0gcmVjdCBEaXNwbGF5YWJsZSByZWN0XG4gICAqL1xuICBkcmF3UmVjdFRleHQ6IGZ1bmN0aW9uIChjdHgsIHJlY3QpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHJlY3QgPSBzdHlsZS50ZXh0UmVjdCB8fCByZWN0OyAvLyBPcHRpbWl6ZSwgYXZvaWQgbm9ybWFsaXplIGV2ZXJ5IHRpbWUuXG5cbiAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpO1xuICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDsgLy8gQ29udmVydCB0byBzdHJpbmdcblxuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgICBpZiAoIXRleHRIZWxwZXIubmVlZERyYXdUZXh0KHRleHQsIHN0eWxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRklYTUVcblxuXG4gICAgY3R4LnNhdmUoKTsgLy8gVHJhbnNmb3JtIHJlY3QgdG8gdmlldyBzcGFjZVxuXG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gICAgaWYgKCFzdHlsZS50cmFuc2Zvcm1UZXh0KSB7XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRtcFJlY3QuY29weShyZWN0KTtcbiAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgICAgICByZWN0ID0gdG1wUmVjdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICB9IC8vIHRyYW5zZm9ybVRleHQgYW5kIHRleHRSb3RhdGlvbiBjYW4gbm90IGJlIHVzZWQgYXQgdGhlIHNhbWUgdGltZS5cblxuXG4gICAgdGV4dEhlbHBlci5yZW5kZXJUZXh0KHRoaXMsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBSZWN0VGV4dDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3V0aWxcIik7XG5cbnZhciByZXRyaWV2ZTIgPSBfdXRpbC5yZXRyaWV2ZTI7XG52YXIgcmV0cmlldmUzID0gX3V0aWwucmV0cmlldmUzO1xudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xudmFyIG5vcm1hbGl6ZUNzc0FycmF5ID0gX3V0aWwubm9ybWFsaXplQ3NzQXJyYXk7XG52YXIgaXNTdHJpbmcgPSBfdXRpbC5pc1N0cmluZztcbnZhciBpc09iamVjdCA9IF91dGlsLmlzT2JqZWN0O1xuXG52YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwiLi4vLi4vY29udGFpbi90ZXh0XCIpO1xuXG52YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZShcIi4vcm91bmRSZWN0XCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi9pbWFnZVwiKTtcblxuLy8gVE9ETzogSGF2ZSBub3Qgc3VwcG9ydCAnc3RhcnQnLCAnZW5kJyB5ZXQuXG52YXIgVkFMSURfVEVYVF9BTElHTiA9IHtcbiAgbGVmdDogMSxcbiAgcmlnaHQ6IDEsXG4gIGNlbnRlcjogMVxufTtcbnZhciBWQUxJRF9URVhUX1ZFUlRJQ0FMX0FMSUdOID0ge1xuICB0b3A6IDEsXG4gIGJvdHRvbTogMSxcbiAgbWlkZGxlOiAxXG59O1xuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IHN0eWxlXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBUaGUgaW5wdXQgc3R5bGUuXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlKSB7XG4gIG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgZWFjaChzdHlsZS5yaWNoLCBub3JtYWxpemVTdHlsZSk7XG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUoc3R5bGUpIHtcbiAgaWYgKHN0eWxlKSB7XG4gICAgc3R5bGUuZm9udCA9IHRleHRDb250YWluLm1ha2VGb250KHN0eWxlKTtcbiAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgIHRleHRBbGlnbiA9PT0gJ21pZGRsZScgJiYgKHRleHRBbGlnbiA9ICdjZW50ZXInKTtcbiAgICBzdHlsZS50ZXh0QWxpZ24gPSB0ZXh0QWxpZ24gPT0gbnVsbCB8fCBWQUxJRF9URVhUX0FMSUdOW3RleHRBbGlnbl0gPyB0ZXh0QWxpZ24gOiAnbGVmdCc7IC8vIENvbXBhdGlibGUgd2l0aCB0ZXh0QmFzZWxpbmUuXG5cbiAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiB8fCBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgdGV4dFZlcnRpY2FsQWxpZ24gPT09ICdjZW50ZXInICYmICh0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnKTtcbiAgICBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiA9IHRleHRWZXJ0aWNhbEFsaWduID09IG51bGwgfHwgVkFMSURfVEVYVF9WRVJUSUNBTF9BTElHTlt0ZXh0VmVydGljYWxBbGlnbl0gPyB0ZXh0VmVydGljYWxBbGlnbiA6ICd0b3AnO1xuICAgIHZhciB0ZXh0UGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuXG4gICAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgICBzdHlsZS50ZXh0UGFkZGluZyA9IG5vcm1hbGl6ZUNzc0FycmF5KHN0eWxlLnRleHRQYWRkaW5nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gc3R5bGVcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFtyZWN0XSB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAqICAgICAgICAgICAgICAgICAgSWYgc2V0IGZhbHNlLCByZWN0IHRleHQgaXMgbm90IHVzZWQuXG4gKi9cblxuXG5mdW5jdGlvbiByZW5kZXJUZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCkge1xuICBzdHlsZS5yaWNoID8gcmVuZGVyUmljaFRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSA6IHJlbmRlclBsYWluVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJQbGFpblRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSB7XG4gIHZhciBmb250ID0gc2V0Q3R4KGN0eCwgJ2ZvbnQnLCBzdHlsZS5mb250IHx8IHRleHRDb250YWluLkRFRkFVTFRfRk9OVCk7XG4gIHZhciB0ZXh0UGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuICB2YXIgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrO1xuXG4gIGlmICghY29udGVudEJsb2NrIHx8IGhvc3RFbC5fX2RpcnR5KSB7XG4gICAgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrID0gdGV4dENvbnRhaW4ucGFyc2VQbGFpblRleHQodGV4dCwgZm9udCwgdGV4dFBhZGRpbmcsIHN0eWxlLnRydW5jYXRlKTtcbiAgfVxuXG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHRleHRMaW5lcyA9IGNvbnRlbnRCbG9jay5saW5lcztcbiAgdmFyIGxpbmVIZWlnaHQgPSBjb250ZW50QmxvY2subGluZUhlaWdodDtcbiAgdmFyIGJveFBvcyA9IGdldEJveFBvc2l0aW9uKG91dGVySGVpZ2h0LCBzdHlsZSwgcmVjdCk7XG4gIHZhciBiYXNlWCA9IGJveFBvcy5iYXNlWDtcbiAgdmFyIGJhc2VZID0gYm94UG9zLmJhc2VZO1xuICB2YXIgdGV4dEFsaWduID0gYm94UG9zLnRleHRBbGlnbjtcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gYm94UG9zLnRleHRWZXJ0aWNhbEFsaWduOyAvLyBPcmlnaW4gb2YgdGV4dFJvdGF0aW9uIHNob3VsZCBiZSB0aGUgYmFzZSBwb2ludCBvZiB0ZXh0IGRyYXdpbmcuXG5cbiAgYXBwbHlUZXh0Um90YXRpb24oY3R4LCBzdHlsZSwgcmVjdCwgYmFzZVgsIGJhc2VZKTtcbiAgdmFyIGJveFkgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WShiYXNlWSwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgdmFyIHRleHRYID0gYmFzZVg7XG4gIHZhciB0ZXh0WSA9IGJveFk7XG4gIHZhciBuZWVkRHJhd0JnID0gbmVlZERyYXdCYWNrZ3JvdW5kKHN0eWxlKTtcblxuICBpZiAobmVlZERyYXdCZyB8fCB0ZXh0UGFkZGluZykge1xuICAgIC8vIENvbnNpZGVyIHBlcmZvcm1hbmNlLCBkbyBub3QgY2FsbCBnZXRUZXh0V2lkdGggdXRpbCBuZWNlc3NhcnkuXG4gICAgdmFyIHRleHRXaWR0aCA9IHRleHRDb250YWluLmdldFdpZHRoKHRleHQsIGZvbnQpO1xuICAgIHZhciBvdXRlcldpZHRoID0gdGV4dFdpZHRoO1xuICAgIHRleHRQYWRkaW5nICYmIChvdXRlcldpZHRoICs9IHRleHRQYWRkaW5nWzFdICsgdGV4dFBhZGRpbmdbM10pO1xuICAgIHZhciBib3hYID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFgoYmFzZVgsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG4gICAgbmVlZERyYXdCZyAmJiBkcmF3QmFja2dyb3VuZChob3N0RWwsIGN0eCwgc3R5bGUsIGJveFgsIGJveFksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcblxuICAgIGlmICh0ZXh0UGFkZGluZykge1xuICAgICAgdGV4dFggPSBnZXRUZXh0WEZvclBhZGRpbmcoYmFzZVgsIHRleHRBbGlnbiwgdGV4dFBhZGRpbmcpO1xuICAgICAgdGV4dFkgKz0gdGV4dFBhZGRpbmdbMF07XG4gICAgfVxuICB9XG5cbiAgc2V0Q3R4KGN0eCwgJ3RleHRBbGlnbicsIHRleHRBbGlnbiB8fCAnbGVmdCcpOyAvLyBGb3JjZSBiYXNlbGluZSB0byBiZSBcIm1pZGRsZVwiLiBPdGhlcndpc2UsIGlmIHVzaW5nIFwidG9wXCIsIHRoZVxuICAvLyB0ZXh0IHdpbGwgb2Zmc2V0IGRvd253YXJkIGEgbGl0dGxlIGJpdCBpbiBmb250IFwiTWljcm9zb2Z0IFlhSGVpXCIuXG5cbiAgc2V0Q3R4KGN0eCwgJ3RleHRCYXNlbGluZScsICdtaWRkbGUnKTsgLy8gQWx3YXlzIHNldCBzaGFkb3dCbHVyIGFuZCBzaGFkb3dPZmZzZXQgdG8gYXZvaWQgbGVhayBmcm9tIGRpc3BsYXlhYmxlLlxuXG4gIHNldEN0eChjdHgsICdzaGFkb3dCbHVyJywgc3R5bGUudGV4dFNoYWRvd0JsdXIgfHwgMCk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dDb2xvcicsIHN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFgnLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WCB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFknLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSB8fCAwKTsgLy8gYHRleHRCYXNlbGluZWAgaXMgc2V0IGFzICdtaWRkbGUnLlxuXG4gIHRleHRZICs9IGxpbmVIZWlnaHQgLyAyO1xuICB2YXIgdGV4dFN0cm9rZVdpZHRoID0gc3R5bGUudGV4dFN0cm9rZVdpZHRoO1xuICB2YXIgdGV4dFN0cm9rZSA9IGdldFN0cm9rZShzdHlsZS50ZXh0U3Ryb2tlLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICB2YXIgdGV4dEZpbGwgPSBnZXRGaWxsKHN0eWxlLnRleHRGaWxsKTtcblxuICBpZiAodGV4dFN0cm9rZSkge1xuICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRTdHJva2UpO1xuICB9XG5cbiAgaWYgKHRleHRGaWxsKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2ZpbGxTdHlsZScsIHRleHRGaWxsKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gRmlsbCBhZnRlciBzdHJva2Ugc28gdGhlIG91dGxpbmUgd2lsbCBub3QgY292ZXIgdGhlIG1haW4gcGFydC5cbiAgICB0ZXh0U3Ryb2tlICYmIGN0eC5zdHJva2VUZXh0KHRleHRMaW5lc1tpXSwgdGV4dFgsIHRleHRZKTtcbiAgICB0ZXh0RmlsbCAmJiBjdHguZmlsbFRleHQodGV4dExpbmVzW2ldLCB0ZXh0WCwgdGV4dFkpO1xuICAgIHRleHRZICs9IGxpbmVIZWlnaHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyUmljaFRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2s7XG5cbiAgaWYgKCFjb250ZW50QmxvY2sgfHwgaG9zdEVsLl9fZGlydHkpIHtcbiAgICBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2sgPSB0ZXh0Q29udGFpbi5wYXJzZVJpY2hUZXh0KHRleHQsIHN0eWxlKTtcbiAgfVxuXG4gIGRyYXdSaWNoVGV4dChob3N0RWwsIGN0eCwgY29udGVudEJsb2NrLCBzdHlsZSwgcmVjdCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdSaWNoVGV4dChob3N0RWwsIGN0eCwgY29udGVudEJsb2NrLCBzdHlsZSwgcmVjdCkge1xuICB2YXIgY29udGVudFdpZHRoID0gY29udGVudEJsb2NrLndpZHRoO1xuICB2YXIgb3V0ZXJXaWR0aCA9IGNvbnRlbnRCbG9jay5vdXRlcldpZHRoO1xuICB2YXIgb3V0ZXJIZWlnaHQgPSBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQ7XG4gIHZhciB0ZXh0UGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuICB2YXIgYm94UG9zID0gZ2V0Qm94UG9zaXRpb24ob3V0ZXJIZWlnaHQsIHN0eWxlLCByZWN0KTtcbiAgdmFyIGJhc2VYID0gYm94UG9zLmJhc2VYO1xuICB2YXIgYmFzZVkgPSBib3hQb3MuYmFzZVk7XG4gIHZhciB0ZXh0QWxpZ24gPSBib3hQb3MudGV4dEFsaWduO1xuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBib3hQb3MudGV4dFZlcnRpY2FsQWxpZ247IC8vIE9yaWdpbiBvZiB0ZXh0Um90YXRpb24gc2hvdWxkIGJlIHRoZSBiYXNlIHBvaW50IG9mIHRleHQgZHJhd2luZy5cblxuICBhcHBseVRleHRSb3RhdGlvbihjdHgsIHN0eWxlLCByZWN0LCBiYXNlWCwgYmFzZVkpO1xuICB2YXIgYm94WCA9IHRleHRDb250YWluLmFkanVzdFRleHRYKGJhc2VYLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICB2YXIgYm94WSA9IHRleHRDb250YWluLmFkanVzdFRleHRZKGJhc2VZLCBvdXRlckhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pO1xuICB2YXIgeExlZnQgPSBib3hYO1xuICB2YXIgbGluZVRvcCA9IGJveFk7XG5cbiAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgeExlZnQgKz0gdGV4dFBhZGRpbmdbM107XG4gICAgbGluZVRvcCArPSB0ZXh0UGFkZGluZ1swXTtcbiAgfVxuXG4gIHZhciB4UmlnaHQgPSB4TGVmdCArIGNvbnRlbnRXaWR0aDtcbiAgbmVlZERyYXdCYWNrZ3JvdW5kKHN0eWxlKSAmJiBkcmF3QmFja2dyb3VuZChob3N0RWwsIGN0eCwgc3R5bGUsIGJveFgsIGJveFksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRCbG9jay5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gY29udGVudEJsb2NrLmxpbmVzW2ldO1xuICAgIHZhciB0b2tlbnMgPSBsaW5lLnRva2VucztcbiAgICB2YXIgdG9rZW5Db3VudCA9IHRva2Vucy5sZW5ndGg7XG4gICAgdmFyIGxpbmVIZWlnaHQgPSBsaW5lLmxpbmVIZWlnaHQ7XG4gICAgdmFyIHVzZWRXaWR0aCA9IGxpbmUud2lkdGg7XG4gICAgdmFyIGxlZnRJbmRleCA9IDA7XG4gICAgdmFyIGxpbmVYTGVmdCA9IHhMZWZ0O1xuICAgIHZhciBsaW5lWFJpZ2h0ID0geFJpZ2h0O1xuICAgIHZhciByaWdodEluZGV4ID0gdG9rZW5Db3VudCAtIDE7XG4gICAgdmFyIHRva2VuO1xuXG4gICAgd2hpbGUgKGxlZnRJbmRleCA8IHRva2VuQ291bnQgJiYgKHRva2VuID0gdG9rZW5zW2xlZnRJbmRleF0sICF0b2tlbi50ZXh0QWxpZ24gfHwgdG9rZW4udGV4dEFsaWduID09PSAnbGVmdCcpKSB7XG4gICAgICBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIGxpbmVYTGVmdCwgJ2xlZnQnKTtcbiAgICAgIHVzZWRXaWR0aCAtPSB0b2tlbi53aWR0aDtcbiAgICAgIGxpbmVYTGVmdCArPSB0b2tlbi53aWR0aDtcbiAgICAgIGxlZnRJbmRleCsrO1xuICAgIH1cblxuICAgIHdoaWxlIChyaWdodEluZGV4ID49IDAgJiYgKHRva2VuID0gdG9rZW5zW3JpZ2h0SW5kZXhdLCB0b2tlbi50ZXh0QWxpZ24gPT09ICdyaWdodCcpKSB7XG4gICAgICBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIGxpbmVYUmlnaHQsICdyaWdodCcpO1xuICAgICAgdXNlZFdpZHRoIC09IHRva2VuLndpZHRoO1xuICAgICAgbGluZVhSaWdodCAtPSB0b2tlbi53aWR0aDtcbiAgICAgIHJpZ2h0SW5kZXgtLTtcbiAgICB9IC8vIFRoZSBvdGhlciB0b2tlbnMgYXJlIHBsYWNlZCBhcyB0ZXh0QWxpZ24gJ2NlbnRlcicgaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlLlxuXG5cbiAgICBsaW5lWExlZnQgKz0gKGNvbnRlbnRXaWR0aCAtIChsaW5lWExlZnQgLSB4TGVmdCkgLSAoeFJpZ2h0IC0gbGluZVhSaWdodCkgLSB1c2VkV2lkdGgpIC8gMjtcblxuICAgIHdoaWxlIChsZWZ0SW5kZXggPD0gcmlnaHRJbmRleCkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbbGVmdEluZGV4XTsgLy8gQ29uc2lkZXIgd2lkdGggc3BlY2lmaWVkIGJ5IHVzZXIsIHVzZSAnY2VudGVyJyByYXRoZXIgdGhhbiAnbGVmdCcuXG5cbiAgICAgIHBsYWNlVG9rZW4oaG9zdEVsLCBjdHgsIHRva2VuLCBzdHlsZSwgbGluZUhlaWdodCwgbGluZVRvcCwgbGluZVhMZWZ0ICsgdG9rZW4ud2lkdGggLyAyLCAnY2VudGVyJyk7XG4gICAgICBsaW5lWExlZnQgKz0gdG9rZW4ud2lkdGg7XG4gICAgICBsZWZ0SW5kZXgrKztcbiAgICB9XG5cbiAgICBsaW5lVG9wICs9IGxpbmVIZWlnaHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUZXh0Um90YXRpb24oY3R4LCBzdHlsZSwgcmVjdCwgeCwgeSkge1xuICAvLyB0ZXh0Um90YXRpb24gb25seSBhcHBseSBpbiBSZWN0VGV4dC5cbiAgaWYgKHJlY3QgJiYgc3R5bGUudGV4dFJvdGF0aW9uKSB7XG4gICAgdmFyIG9yaWdpbiA9IHN0eWxlLnRleHRPcmlnaW47XG5cbiAgICBpZiAob3JpZ2luID09PSAnY2VudGVyJykge1xuICAgICAgeCA9IHJlY3Qud2lkdGggLyAyICsgcmVjdC54O1xuICAgICAgeSA9IHJlY3QuaGVpZ2h0IC8gMiArIHJlY3QueTtcbiAgICB9IGVsc2UgaWYgKG9yaWdpbikge1xuICAgICAgeCA9IG9yaWdpblswXSArIHJlY3QueDtcbiAgICAgIHkgPSBvcmlnaW5bMV0gKyByZWN0Lnk7XG4gICAgfVxuXG4gICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTsgLy8gUG9zaXRpdmU6IGFudGljbG9ja3dpc2VcblxuICAgIGN0eC5yb3RhdGUoLXN0eWxlLnRleHRSb3RhdGlvbik7XG4gICAgY3R4LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBsYWNlVG9rZW4oaG9zdEVsLCBjdHgsIHRva2VuLCBzdHlsZSwgbGluZUhlaWdodCwgbGluZVRvcCwgeCwgdGV4dEFsaWduKSB7XG4gIHZhciB0b2tlblN0eWxlID0gc3R5bGUucmljaFt0b2tlbi5zdHlsZU5hbWVdIHx8IHt9OyAvLyAnY3R4LnRleHRCYXNlbGluZScgaXMgYWx3YXlzIHNldCBhcyAnbWlkZGxlJywgZm9yIHNha2Ugb2ZcbiAgLy8gdGhlIGJpYXMgb2YgXCJNaWNyb3NvZnQgWWFIZWlcIi5cblxuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSB0b2tlbi50ZXh0VmVydGljYWxBbGlnbjtcbiAgdmFyIHkgPSBsaW5lVG9wICsgbGluZUhlaWdodCAvIDI7XG5cbiAgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAndG9wJykge1xuICAgIHkgPSBsaW5lVG9wICsgdG9rZW4uaGVpZ2h0IC8gMjtcbiAgfSBlbHNlIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5ID0gbGluZVRvcCArIGxpbmVIZWlnaHQgLSB0b2tlbi5oZWlnaHQgLyAyO1xuICB9XG5cbiAgIXRva2VuLmlzTGluZUhvbGRlciAmJiBuZWVkRHJhd0JhY2tncm91bmQodG9rZW5TdHlsZSkgJiYgZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHRva2VuU3R5bGUsIHRleHRBbGlnbiA9PT0gJ3JpZ2h0JyA/IHggLSB0b2tlbi53aWR0aCA6IHRleHRBbGlnbiA9PT0gJ2NlbnRlcicgPyB4IC0gdG9rZW4ud2lkdGggLyAyIDogeCwgeSAtIHRva2VuLmhlaWdodCAvIDIsIHRva2VuLndpZHRoLCB0b2tlbi5oZWlnaHQpO1xuICB2YXIgdGV4dFBhZGRpbmcgPSB0b2tlbi50ZXh0UGFkZGluZztcblxuICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICB4ID0gZ2V0VGV4dFhGb3JQYWRkaW5nKHgsIHRleHRBbGlnbiwgdGV4dFBhZGRpbmcpO1xuICAgIHkgLT0gdG9rZW4uaGVpZ2h0IC8gMiAtIHRleHRQYWRkaW5nWzJdIC0gdG9rZW4udGV4dEhlaWdodCAvIDI7XG4gIH1cblxuICBzZXRDdHgoY3R4LCAnc2hhZG93Qmx1cicsIHJldHJpZXZlMyh0b2tlblN0eWxlLnRleHRTaGFkb3dCbHVyLCBzdHlsZS50ZXh0U2hhZG93Qmx1ciwgMCkpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93Q29sb3InLCB0b2tlblN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCBzdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgJ3RyYW5zcGFyZW50Jyk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRYJywgcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dFNoYWRvd09mZnNldFgsIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRYLCAwKSk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRZJywgcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dFNoYWRvd09mZnNldFksIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZLCAwKSk7XG4gIHNldEN0eChjdHgsICd0ZXh0QWxpZ24nLCB0ZXh0QWxpZ24pOyAvLyBGb3JjZSBiYXNlbGluZSB0byBiZSBcIm1pZGRsZVwiLiBPdGhlcndpc2UsIGlmIHVzaW5nIFwidG9wXCIsIHRoZVxuICAvLyB0ZXh0IHdpbGwgb2Zmc2V0IGRvd253YXJkIGEgbGl0dGxlIGJpdCBpbiBmb250IFwiTWljcm9zb2Z0IFlhSGVpXCIuXG5cbiAgc2V0Q3R4KGN0eCwgJ3RleHRCYXNlbGluZScsICdtaWRkbGUnKTtcbiAgc2V0Q3R4KGN0eCwgJ2ZvbnQnLCB0b2tlbi5mb250IHx8IHRleHRDb250YWluLkRFRkFVTFRfRk9OVCk7XG4gIHZhciB0ZXh0U3Ryb2tlID0gZ2V0U3Ryb2tlKHRva2VuU3R5bGUudGV4dFN0cm9rZSB8fCBzdHlsZS50ZXh0U3Ryb2tlLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICB2YXIgdGV4dEZpbGwgPSBnZXRGaWxsKHRva2VuU3R5bGUudGV4dEZpbGwgfHwgc3R5bGUudGV4dEZpbGwpO1xuICB2YXIgdGV4dFN0cm9rZVdpZHRoID0gcmV0cmlldmUyKHRva2VuU3R5bGUudGV4dFN0cm9rZVdpZHRoLCBzdHlsZS50ZXh0U3Ryb2tlV2lkdGgpOyAvLyBGaWxsIGFmdGVyIHN0cm9rZSBzbyB0aGUgb3V0bGluZSB3aWxsIG5vdCBjb3ZlciB0aGUgbWFpbiBwYXJ0LlxuXG4gIGlmICh0ZXh0U3Ryb2tlKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2xpbmVXaWR0aCcsIHRleHRTdHJva2VXaWR0aCk7XG4gICAgc2V0Q3R4KGN0eCwgJ3N0cm9rZVN0eWxlJywgdGV4dFN0cm9rZSk7XG4gICAgY3R4LnN0cm9rZVRleHQodG9rZW4udGV4dCwgeCwgeSk7XG4gIH1cblxuICBpZiAodGV4dEZpbGwpIHtcbiAgICBzZXRDdHgoY3R4LCAnZmlsbFN0eWxlJywgdGV4dEZpbGwpO1xuICAgIGN0eC5maWxsVGV4dCh0b2tlbi50ZXh0LCB4LCB5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZWVkRHJhd0JhY2tncm91bmQoc3R5bGUpIHtcbiAgcmV0dXJuIHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHwgc3R5bGUudGV4dEJvcmRlcldpZHRoICYmIHN0eWxlLnRleHRCb3JkZXJDb2xvcjtcbn0gLy8gc3R5bGU6IHt0ZXh0QmFja2dyb3VuZENvbG9yLCB0ZXh0Qm9yZGVyV2lkdGgsIHRleHRCb3JkZXJDb2xvciwgdGV4dEJvcmRlclJhZGl1c31cbi8vIHNoYXBlOiB7eCwgeSwgd2lkdGgsIGhlaWdodH1cblxuXG5mdW5jdGlvbiBkcmF3QmFja2dyb3VuZChob3N0RWwsIGN0eCwgc3R5bGUsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHRleHRCYWNrZ3JvdW5kQ29sb3IgPSBzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yO1xuICB2YXIgdGV4dEJvcmRlcldpZHRoID0gc3R5bGUudGV4dEJvcmRlcldpZHRoO1xuICB2YXIgdGV4dEJvcmRlckNvbG9yID0gc3R5bGUudGV4dEJvcmRlckNvbG9yO1xuICB2YXIgaXNQbGFpbkJnID0gaXNTdHJpbmcodGV4dEJhY2tncm91bmRDb2xvcik7XG4gIHNldEN0eChjdHgsICdzaGFkb3dCbHVyJywgc3R5bGUudGV4dEJveFNoYWRvd0JsdXIgfHwgMCk7XG4gIHNldEN0eChjdHgsICdzaGFkb3dDb2xvcicsIHN0eWxlLnRleHRCb3hTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFgnLCBzdHlsZS50ZXh0Qm94U2hhZG93T2Zmc2V0WCB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFknLCBzdHlsZS50ZXh0Qm94U2hhZG93T2Zmc2V0WSB8fCAwKTtcblxuICBpZiAoaXNQbGFpbkJnIHx8IHRleHRCb3JkZXJXaWR0aCAmJiB0ZXh0Qm9yZGVyQ29sb3IpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgdmFyIHRleHRCb3JkZXJSYWRpdXMgPSBzdHlsZS50ZXh0Qm9yZGVyUmFkaXVzO1xuXG4gICAgaWYgKCF0ZXh0Qm9yZGVyUmFkaXVzKSB7XG4gICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91bmRSZWN0SGVscGVyLmJ1aWxkUGF0aChjdHgsIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgcjogdGV4dEJvcmRlclJhZGl1c1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICB9XG5cbiAgaWYgKGlzUGxhaW5CZykge1xuICAgIHNldEN0eChjdHgsICdmaWxsU3R5bGUnLCB0ZXh0QmFja2dyb3VuZENvbG9yKTtcbiAgICBjdHguZmlsbCgpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHRleHRCYWNrZ3JvdW5kQ29sb3IpKSB7XG4gICAgdmFyIGltYWdlID0gdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZTtcbiAgICBpbWFnZSA9IGltYWdlSGVscGVyLmNyZWF0ZU9yVXBkYXRlSW1hZ2UoaW1hZ2UsIG51bGwsIGhvc3RFbCwgb25CZ0ltYWdlTG9hZGVkLCB0ZXh0QmFja2dyb3VuZENvbG9yKTtcblxuICAgIGlmIChpbWFnZSAmJiBpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoaW1hZ2UpKSB7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH1cblxuICBpZiAodGV4dEJvcmRlcldpZHRoICYmIHRleHRCb3JkZXJDb2xvcikge1xuICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0Qm9yZGVyV2lkdGgpO1xuICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRCb3JkZXJDb2xvcik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQmdJbWFnZUxvYWRlZChpbWFnZSwgdGV4dEJhY2tncm91bmRDb2xvcikge1xuICAvLyBSZXBsYWNlIGltYWdlLCBzbyB0aGF0IGBjb250YWluL3RleHQuanMjcGFyc2VSaWNoVGV4dGBcbiAgLy8gd2lsbCBnZXQgY29ycmVjdCByZXN1bHQgaW4gbmV4dCB0aWNrLlxuICB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlID0gaW1hZ2U7XG59XG5cbmZ1bmN0aW9uIGdldEJveFBvc2l0aW9uKGJsb2NrSGVpaHQsIHN0eWxlLCByZWN0KSB7XG4gIHZhciBiYXNlWCA9IHN0eWxlLnggfHwgMDtcbiAgdmFyIGJhc2VZID0gc3R5bGUueSB8fCAwO1xuICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbjsgLy8gVGV4dCBwb3NpdGlvbiByZXByZXNlbnRlZCBieSBjb29yZFxuXG4gIGlmIChyZWN0KSB7XG4gICAgdmFyIHRleHRQb3NpdGlvbiA9IHN0eWxlLnRleHRQb3NpdGlvbjtcblxuICAgIGlmICh0ZXh0UG9zaXRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgLy8gUGVyY2VudFxuICAgICAgYmFzZVggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgIGJhc2VZID0gcmVjdC55ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblsxXSwgcmVjdC5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KHRleHRQb3NpdGlvbiwgcmVjdCwgc3R5bGUudGV4dERpc3RhbmNlKTtcbiAgICAgIGJhc2VYID0gcmVzLng7XG4gICAgICBiYXNlWSA9IHJlcy55OyAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cblxuICAgICAgdGV4dEFsaWduID0gdGV4dEFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IHRleHRWZXJ0aWNhbEFsaWduIHx8IHJlcy50ZXh0VmVydGljYWxBbGlnbjtcbiAgICB9IC8vIHRleHRPZmZzZXQgaXMgb25seSBzdXBwb3J0IGluIFJlY3RUZXh0LCBvdGhlcndpc2VcbiAgICAvLyB3ZSBoYXZlIHRvIGFkanVzdCBib3VuZGluZ1JlY3QgZm9yIHRleHRPZmZzZXQuXG5cblxuICAgIHZhciB0ZXh0T2Zmc2V0ID0gc3R5bGUudGV4dE9mZnNldDtcblxuICAgIGlmICh0ZXh0T2Zmc2V0KSB7XG4gICAgICBiYXNlWCArPSB0ZXh0T2Zmc2V0WzBdO1xuICAgICAgYmFzZVkgKz0gdGV4dE9mZnNldFsxXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhc2VYOiBiYXNlWCxcbiAgICBiYXNlWTogYmFzZVksXG4gICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNldEN0eChjdHgsIHByb3AsIHZhbHVlKSB7XG4gIC8vIEZJWE1FID8/PyBwZXJmb3JtYW5jZSB0cnlcbiAgLy8gaWYgKGN0eC5fX2N1cnJlbnRWYWx1ZXNbcHJvcF0gIT09IHZhbHVlKSB7XG4gIC8vIGN0eFtwcm9wXSA9IGN0eC5fX2N1cnJlbnRWYWx1ZXNbcHJvcF0gPSB2YWx1ZTtcbiAgY3R4W3Byb3BdID0gdmFsdWU7IC8vIH1cblxuICByZXR1cm4gY3R4W3Byb3BdO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cm9rZV0gSWYgc3BlY2lmaWVkLCBkbyBub3QgY2hlY2sgc3R5bGUudGV4dFN0cm9rZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGluZVdpZHRoXSBJZiBzcGVjaWZpZWQsIGRvIG5vdCBjaGVjayBzdHlsZS50ZXh0U3Ryb2tlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0eWxlXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTdHJva2Uoc3Ryb2tlLCBsaW5lV2lkdGgpIHtcbiAgcmV0dXJuIHN0cm9rZSA9PSBudWxsIHx8IGxpbmVXaWR0aCA8PSAwIHx8IHN0cm9rZSA9PT0gJ3RyYW5zcGFyZW50JyB8fCBzdHJva2UgPT09ICdub25lJyA/IG51bGwgLy8gVE9ETyBwYXR0ZXJuIGFuZCBncmFkaWVudD9cbiAgOiBzdHJva2UuaW1hZ2UgfHwgc3Ryb2tlLmNvbG9yU3RvcHMgPyAnIzAwMCcgOiBzdHJva2U7XG59XG5cbmZ1bmN0aW9uIGdldEZpbGwoZmlsbCkge1xuICByZXR1cm4gZmlsbCA9PSBudWxsIHx8IGZpbGwgPT09ICdub25lJyA/IG51bGwgLy8gVE9ETyBwYXR0ZXJuIGFuZCBncmFkaWVudD9cbiAgOiBmaWxsLmltYWdlIHx8IGZpbGwuY29sb3JTdG9wcyA/ICcjMDAwJyA6IGZpbGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGVyY2VudCh2YWx1ZSwgbWF4VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsdWUubGFzdEluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBtYXhWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldFRleHRYRm9yUGFkZGluZyh4LCB0ZXh0QWxpZ24sIHRleHRQYWRkaW5nKSB7XG4gIHJldHVybiB0ZXh0QWxpZ24gPT09ICdyaWdodCcgPyB4IC0gdGV4dFBhZGRpbmdbMV0gOiB0ZXh0QWxpZ24gPT09ICdjZW50ZXInID8geCArIHRleHRQYWRkaW5nWzNdIC8gMiAtIHRleHRQYWRkaW5nWzFdIC8gMiA6IHggKyB0ZXh0UGFkZGluZ1szXTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3R5bGV9IHN0eWxlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gbmVlZERyYXdUZXh0KHRleHQsIHN0eWxlKSB7XG4gIHJldHVybiB0ZXh0ICE9IG51bGwgJiYgKHRleHQgfHwgc3R5bGUudGV4dEJhY2tncm91bmRDb2xvciB8fCBzdHlsZS50ZXh0Qm9yZGVyV2lkdGggJiYgc3R5bGUudGV4dEJvcmRlckNvbG9yIHx8IHN0eWxlLnRleHRQYWRkaW5nKTtcbn1cblxuZXhwb3J0cy5ub3JtYWxpemVUZXh0U3R5bGUgPSBub3JtYWxpemVUZXh0U3R5bGU7XG5leHBvcnRzLnJlbmRlclRleHQgPSByZW5kZXJUZXh0O1xuZXhwb3J0cy5nZXRTdHJva2UgPSBnZXRTdHJva2U7XG5leHBvcnRzLmdldEZpbGwgPSBnZXRGaWxsO1xuZXhwb3J0cy5uZWVkRHJhd1RleHQgPSBuZWVkRHJhd1RleHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciBpbWFnZUhlbHBlciA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL2hlbHBlci9pbWFnZVwiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIGdldENvbnRleHQgPSBfdXRpbC5nZXRDb250ZXh0O1xudmFyIGV4dGVuZCA9IF91dGlsLmV4dGVuZDtcbnZhciByZXRyaWV2ZTIgPSBfdXRpbC5yZXRyaWV2ZTI7XG52YXIgcmV0cmlldmUzID0gX3V0aWwucmV0cmlldmUzO1xudmFyIHRleHRXaWR0aENhY2hlID0ge307XG52YXIgdGV4dFdpZHRoQ2FjaGVDb3VudGVyID0gMDtcbnZhciBURVhUX0NBQ0hFX01BWCA9IDUwMDA7XG52YXIgU1RZTEVfUkVHID0gL1xceyhbYS16QS1aMC05X10rKVxcfChbXn1dKilcXH0vZztcbnZhciBERUZBVUxUX0ZPTlQgPSAnMTJweCBzYW5zLXNlcmlmJzsgLy8gQXZvaWQgYXNzaWduIHRvIGFuIGV4cG9ydGVkIHZhcmlhYmxlLCBmb3IgdHJhbnNmb3JtaW5nIHRvIGNqcy5cblxudmFyIG1ldGhvZHMgPSB7fTtcblxuZnVuY3Rpb24gJG92ZXJyaWRlKG5hbWUsIGZuKSB7XG4gIG1ldGhvZHNbbmFtZV0gPSBmbjtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHdpZHRoXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRXaWR0aCh0ZXh0LCBmb250KSB7XG4gIGZvbnQgPSBmb250IHx8IERFRkFVTFRfRk9OVDtcbiAgdmFyIGtleSA9IHRleHQgKyAnOicgKyBmb250O1xuXG4gIGlmICh0ZXh0V2lkdGhDYWNoZVtrZXldKSB7XG4gICAgcmV0dXJuIHRleHRXaWR0aENhY2hlW2tleV07XG4gIH1cblxuICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuICB2YXIgd2lkdGggPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gdGV4dExpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIC8vIHRleHRDb250YWluLm1lYXN1cmVUZXh0IG1heSBiZSBvdmVycmlkZWQgaW4gU1ZHIG9yIFZNTFxuICAgIHdpZHRoID0gTWF0aC5tYXgobWVhc3VyZVRleHQodGV4dExpbmVzW2ldLCBmb250KS53aWR0aCwgd2lkdGgpO1xuICB9XG5cbiAgaWYgKHRleHRXaWR0aENhY2hlQ291bnRlciA+IFRFWFRfQ0FDSEVfTUFYKSB7XG4gICAgdGV4dFdpZHRoQ2FjaGVDb3VudGVyID0gMDtcbiAgICB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICB9XG5cbiAgdGV4dFdpZHRoQ2FjaGVDb3VudGVyKys7XG4gIHRleHRXaWR0aENhY2hlW2tleV0gPSB3aWR0aDtcbiAgcmV0dXJuIHdpZHRoO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dEFsaWduPSdsZWZ0J11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dFZlcnRpY2FsQWxpZ249J3RvcCddXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbdGV4dFBhZGRpbmddXG4gKiBAcGFyYW0ge09iamVjdH0gW3JpY2hdXG4gKiBAcGFyYW0ge09iamVjdH0gW3RydW5jYXRlXVxuICogQHJldHVybiB7T2JqZWN0fSB7eCwgeSwgd2lkdGgsIGhlaWdodCwgbGluZUhlaWdodH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nUmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgcmljaCwgdHJ1bmNhdGUpIHtcbiAgcmV0dXJuIHJpY2ggPyBnZXRSaWNoVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHJpY2gsIHRydW5jYXRlKSA6IGdldFBsYWluVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHRydW5jYXRlKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGxhaW5UZXh0UmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgdHJ1bmNhdGUpIHtcbiAgdmFyIGNvbnRlbnRCbG9jayA9IHBhcnNlUGxhaW5UZXh0KHRleHQsIGZvbnQsIHRleHRQYWRkaW5nLCB0cnVuY2F0ZSk7XG4gIHZhciBvdXRlcldpZHRoID0gZ2V0V2lkdGgodGV4dCwgZm9udCk7XG5cbiAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgb3V0ZXJXaWR0aCArPSB0ZXh0UGFkZGluZ1sxXSArIHRleHRQYWRkaW5nWzNdO1xuICB9XG5cbiAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICB2YXIgeCA9IGFkanVzdFRleHRYKDAsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG4gIHZhciB5ID0gYWRqdXN0VGV4dFkoMCwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHgsIHksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcbiAgcmVjdC5saW5lSGVpZ2h0ID0gY29udGVudEJsb2NrLmxpbmVIZWlnaHQ7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRSaWNoVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHJpY2gsIHRydW5jYXRlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSBwYXJzZVJpY2hUZXh0KHRleHQsIHtcbiAgICByaWNoOiByaWNoLFxuICAgIHRydW5jYXRlOiB0cnVuY2F0ZSxcbiAgICBmb250OiBmb250LFxuICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgIHRleHRQYWRkaW5nOiB0ZXh0UGFkZGluZ1xuICB9KTtcbiAgdmFyIG91dGVyV2lkdGggPSBjb250ZW50QmxvY2sub3V0ZXJXaWR0aDtcbiAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICB2YXIgeCA9IGFkanVzdFRleHRYKDAsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG4gIHZhciB5ID0gYWRqdXN0VGV4dFkoMCwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgb3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQpO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRBbGlnbj0nbGVmdCddXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFkanVzdGVkIHguXG4gKi9cblxuXG5mdW5jdGlvbiBhZGp1c3RUZXh0WCh4LCB3aWR0aCwgdGV4dEFsaWduKSB7XG4gIC8vIEZJWE1FIFJpZ2h0IHRvIGxlZnQgbGFuZ3VhZ2VcbiAgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gd2lkdGg7XG4gIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gd2lkdGggLyAyO1xuICB9XG5cbiAgcmV0dXJuIHg7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHRWZXJ0aWNhbEFsaWduPSd0b3AnXVxuICogQHJldHVybiB7bnVtYmVyfSBBZGp1c3RlZCB5LlxuICovXG5cblxuZnVuY3Rpb24gYWRqdXN0VGV4dFkoeSwgaGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbikge1xuICBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICdtaWRkbGUnKSB7XG4gICAgeSAtPSBoZWlnaHQgLyAyO1xuICB9IGVsc2UgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJykge1xuICAgIHkgLT0gaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3Rpcm5nfSB0ZXh0UG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHt4LCB5LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWdufVxuICovXG5cblxuZnVuY3Rpb24gYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KHRleHRQb3NpdGlvbiwgcmVjdCwgZGlzdGFuY2UpIHtcbiAgdmFyIHggPSByZWN0Lng7XG4gIHZhciB5ID0gcmVjdC55O1xuICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gJ3RvcCc7XG5cbiAgc3dpdGNoICh0ZXh0UG9zaXRpb24pIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHggLT0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgeCArPSBkaXN0YW5jZSArIHdpZHRoO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSAtPSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBoZWlnaHQgKyBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGUnOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZUxlZnQnOlxuICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZVJpZ2h0JzpcbiAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVUb3AnOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZUJvdHRvbSc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgKz0gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZVRvcExlZnQnOlxuICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZVRvcFJpZ2h0JzpcbiAgICAgIHggKz0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVCb3R0b21MZWZ0JzpcbiAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlQm90dG9tUmlnaHQnOlxuICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgeSArPSBoZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICB0ZXh0VmVydGljYWxBbGlnbjogdGV4dFZlcnRpY2FsQWxpZ25cbiAgfTtcbn1cbi8qKlxuICogU2hvdyBlbGxpcHNpcyBpZiBvdmVyZmxvdy5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSAge3N0cmluZ30gY29udGFpbmVyV2lkdGhcbiAqIEBwYXJhbSAge3N0cmluZ30gZm9udFxuICogQHBhcmFtICB7bnVtYmVyfSBbZWxsaXBzaXM9Jy4uLiddXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5tYXhJdGVyYXRpb25zPTNdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLm1pbkNoYXI9MF0gSWYgdHJ1bmNhdGUgcmVzdWx0IGFyZSBsZXNzXG4gKiAgICAgICAgICAgICAgICAgIHRoZW4gbWluQ2hhciwgZWxsaXBzaXMgd2lsbCBub3Qgc2hvdywgd2hpY2ggaXNcbiAqICAgICAgICAgICAgICAgICAgYmV0dGVyIGZvciB1c2VyIGhpbnQgaW4gc29tZSBjYXNlcy5cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMucGxhY2Vob2xkZXI9JyddIFdoZW4gYWxsIHRydW5jYXRlZCwgdXNlIHRoZSBwbGFjZWhvbGRlci5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIHRydW5jYXRlVGV4dCh0ZXh0LCBjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFjb250YWluZXJXaWR0aCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciB0ZXh0TGluZXMgPSAodGV4dCArICcnKS5zcGxpdCgnXFxuJyk7XG4gIG9wdGlvbnMgPSBwcmVwYXJlVHJ1bmNhdGVPcHRpb25zKGNvbnRhaW5lcldpZHRoLCBmb250LCBlbGxpcHNpcywgb3B0aW9ucyk7IC8vIEZJWE1FXG4gIC8vIEl0IGlzIG5vdCBhcHByb3ByaWF0ZSB0aGF0IGV2ZXJ5IGxpbmUgaGFzICcuLi4nIHdoZW4gdHJ1bmNhdGUgbXVsdGlwbGUgbGluZXMuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHRleHRMaW5lc1tpXSA9IHRydW5jYXRlU2luZ2xlTGluZSh0ZXh0TGluZXNbaV0sIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHRleHRMaW5lcy5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRydW5jYXRlT3B0aW9ucyhjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIG9wdGlvbnMuZm9udCA9IGZvbnQ7XG4gIHZhciBlbGxpcHNpcyA9IHJldHJpZXZlMihlbGxpcHNpcywgJy4uLicpO1xuICBvcHRpb25zLm1heEl0ZXJhdGlvbnMgPSByZXRyaWV2ZTIob3B0aW9ucy5tYXhJdGVyYXRpb25zLCAyKTtcbiAgdmFyIG1pbkNoYXIgPSBvcHRpb25zLm1pbkNoYXIgPSByZXRyaWV2ZTIob3B0aW9ucy5taW5DaGFyLCAwKTsgLy8gRklYTUVcbiAgLy8gT3RoZXIgbGFuZ3VhZ2VzP1xuXG4gIG9wdGlvbnMuY25DaGFyV2lkdGggPSBnZXRXaWR0aCgn5Zu9JywgZm9udCk7IC8vIEZJWE1FXG4gIC8vIENvbnNpZGVyIHByb3BvcnRpb25hbCBmb250P1xuXG4gIHZhciBhc2NDaGFyV2lkdGggPSBvcHRpb25zLmFzY0NoYXJXaWR0aCA9IGdldFdpZHRoKCdhJywgZm9udCk7XG4gIG9wdGlvbnMucGxhY2Vob2xkZXIgPSByZXRyaWV2ZTIob3B0aW9ucy5wbGFjZWhvbGRlciwgJycpOyAvLyBFeGFtcGxlIDE6IG1pbkNoYXI6IDMsIHRleHQ6ICdhc2RmenhjdicsIHRydW5jYXRlIHJlc3VsdDogJ2FzZGYnLCBidXQgbm90OiAnYS4uLicuXG4gIC8vIEV4YW1wbGUgMjogbWluQ2hhcjogMywgdGV4dDogJ+e7tOW6picsIHRydW5jYXRlIHJlc3VsdDogJ+e7tCcsIGJ1dCBub3Q6ICcuLi4nLlxuXG4gIHZhciBjb250ZW50V2lkdGggPSBjb250YWluZXJXaWR0aCA9IE1hdGgubWF4KDAsIGNvbnRhaW5lcldpZHRoIC0gMSk7IC8vIFJlc2VydmUgc29tZSBnYXAuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5DaGFyICYmIGNvbnRlbnRXaWR0aCA+PSBhc2NDaGFyV2lkdGg7IGkrKykge1xuICAgIGNvbnRlbnRXaWR0aCAtPSBhc2NDaGFyV2lkdGg7XG4gIH1cblxuICB2YXIgZWxsaXBzaXNXaWR0aCA9IGdldFdpZHRoKGVsbGlwc2lzKTtcblxuICBpZiAoZWxsaXBzaXNXaWR0aCA+IGNvbnRlbnRXaWR0aCkge1xuICAgIGVsbGlwc2lzID0gJyc7XG4gICAgZWxsaXBzaXNXaWR0aCA9IDA7XG4gIH1cblxuICBjb250ZW50V2lkdGggPSBjb250YWluZXJXaWR0aCAtIGVsbGlwc2lzV2lkdGg7XG4gIG9wdGlvbnMuZWxsaXBzaXMgPSBlbGxpcHNpcztcbiAgb3B0aW9ucy5lbGxpcHNpc1dpZHRoID0gZWxsaXBzaXNXaWR0aDtcbiAgb3B0aW9ucy5jb250ZW50V2lkdGggPSBjb250ZW50V2lkdGg7XG4gIG9wdGlvbnMuY29udGFpbmVyV2lkdGggPSBjb250YWluZXJXaWR0aDtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlU2luZ2xlTGluZSh0ZXh0TGluZSwgb3B0aW9ucykge1xuICB2YXIgY29udGFpbmVyV2lkdGggPSBvcHRpb25zLmNvbnRhaW5lcldpZHRoO1xuICB2YXIgZm9udCA9IG9wdGlvbnMuZm9udDtcbiAgdmFyIGNvbnRlbnRXaWR0aCA9IG9wdGlvbnMuY29udGVudFdpZHRoO1xuXG4gIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgbGluZVdpZHRoID0gZ2V0V2lkdGgodGV4dExpbmUsIGZvbnQpO1xuXG4gIGlmIChsaW5lV2lkdGggPD0gY29udGFpbmVyV2lkdGgpIHtcbiAgICByZXR1cm4gdGV4dExpbmU7XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDs7IGorKykge1xuICAgIGlmIChsaW5lV2lkdGggPD0gY29udGVudFdpZHRoIHx8IGogPj0gb3B0aW9ucy5tYXhJdGVyYXRpb25zKSB7XG4gICAgICB0ZXh0TGluZSArPSBvcHRpb25zLmVsbGlwc2lzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHN1Ykxlbmd0aCA9IGogPT09IDAgPyBlc3RpbWF0ZUxlbmd0aCh0ZXh0TGluZSwgY29udGVudFdpZHRoLCBvcHRpb25zLmFzY0NoYXJXaWR0aCwgb3B0aW9ucy5jbkNoYXJXaWR0aCkgOiBsaW5lV2lkdGggPiAwID8gTWF0aC5mbG9vcih0ZXh0TGluZS5sZW5ndGggKiBjb250ZW50V2lkdGggLyBsaW5lV2lkdGgpIDogMDtcbiAgICB0ZXh0TGluZSA9IHRleHRMaW5lLnN1YnN0cigwLCBzdWJMZW5ndGgpO1xuICAgIGxpbmVXaWR0aCA9IGdldFdpZHRoKHRleHRMaW5lLCBmb250KTtcbiAgfVxuXG4gIGlmICh0ZXh0TGluZSA9PT0gJycpIHtcbiAgICB0ZXh0TGluZSA9IG9wdGlvbnMucGxhY2Vob2xkZXI7XG4gIH1cblxuICByZXR1cm4gdGV4dExpbmU7XG59XG5cbmZ1bmN0aW9uIGVzdGltYXRlTGVuZ3RoKHRleHQsIGNvbnRlbnRXaWR0aCwgYXNjQ2hhcldpZHRoLCBjbkNoYXJXaWR0aCkge1xuICB2YXIgd2lkdGggPSAwO1xuICB2YXIgaSA9IDA7XG5cbiAgZm9yICh2YXIgbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBsZW4gJiYgd2lkdGggPCBjb250ZW50V2lkdGg7IGkrKykge1xuICAgIHZhciBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICB3aWR0aCArPSAwIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IDEyNyA/IGFzY0NoYXJXaWR0aCA6IGNuQ2hhcldpZHRoO1xuICB9XG5cbiAgcmV0dXJuIGk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcmV0dXJuIHtudW1iZXJ9IGxpbmUgaGVpZ2h0XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRMaW5lSGVpZ2h0KGZvbnQpIHtcbiAgLy8gRklYTUUgQSByb3VnaCBhcHByb2FjaC5cbiAgcmV0dXJuIGdldFdpZHRoKCflm70nLCBmb250KTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpZHRoXG4gKi9cblxuXG5mdW5jdGlvbiBtZWFzdXJlVGV4dCh0ZXh0LCBmb250KSB7XG4gIHJldHVybiBtZXRob2RzLm1lYXN1cmVUZXh0KHRleHQsIGZvbnQpO1xufSAvLyBBdm9pZCBhc3NpZ24gdG8gYW4gZXhwb3J0ZWQgdmFyaWFibGUsIGZvciB0cmFuc2Zvcm1pbmcgdG8gY2pzLlxuXG5cbm1ldGhvZHMubWVhc3VyZVRleHQgPSBmdW5jdGlvbiAodGV4dCwgZm9udCkge1xuICB2YXIgY3R4ID0gZ2V0Q29udGV4dCgpO1xuICBjdHguZm9udCA9IGZvbnQgfHwgREVGQVVMVF9GT05UO1xuICByZXR1cm4gY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xufTtcbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcGFyYW0ge09iamVjdH0gW3RydW5jYXRlXVxuICogQHJldHVybiB7T2JqZWN0fSBibG9jazoge2xpbmVIZWlnaHQsIGxpbmVzLCBoZWlnaHQsIG91dGVySGVpZ2h0fVxuICogIE5vdGljZTogZm9yIHBlcmZvcm1hbmNlLCBkbyBub3QgY2FsY3VsYXRlIG91dGVyV2lkdGggdXRpbCBuZWVkZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCBwYWRkaW5nLCB0cnVuY2F0ZSkge1xuICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuICB2YXIgbGluZUhlaWdodCA9IGdldExpbmVIZWlnaHQoZm9udCk7XG4gIHZhciBsaW5lcyA9IHRleHQgPyB0ZXh0LnNwbGl0KCdcXG4nKSA6IFtdO1xuICB2YXIgaGVpZ2h0ID0gbGluZXMubGVuZ3RoICogbGluZUhlaWdodDtcbiAgdmFyIG91dGVySGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIGlmIChwYWRkaW5nKSB7XG4gICAgb3V0ZXJIZWlnaHQgKz0gcGFkZGluZ1swXSArIHBhZGRpbmdbMl07XG4gIH1cblxuICBpZiAodGV4dCAmJiB0cnVuY2F0ZSkge1xuICAgIHZhciB0cnVuY091dGVySGVpZ2h0ID0gdHJ1bmNhdGUub3V0ZXJIZWlnaHQ7XG4gICAgdmFyIHRydW5jT3V0ZXJXaWR0aCA9IHRydW5jYXRlLm91dGVyV2lkdGg7XG5cbiAgICBpZiAodHJ1bmNPdXRlckhlaWdodCAhPSBudWxsICYmIG91dGVySGVpZ2h0ID4gdHJ1bmNPdXRlckhlaWdodCkge1xuICAgICAgdGV4dCA9ICcnO1xuICAgICAgbGluZXMgPSBbXTtcbiAgICB9IGVsc2UgaWYgKHRydW5jT3V0ZXJXaWR0aCAhPSBudWxsKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHByZXBhcmVUcnVuY2F0ZU9wdGlvbnModHJ1bmNPdXRlcldpZHRoIC0gKHBhZGRpbmcgPyBwYWRkaW5nWzFdICsgcGFkZGluZ1szXSA6IDApLCBmb250LCB0cnVuY2F0ZS5lbGxpcHNpcywge1xuICAgICAgICBtaW5DaGFyOiB0cnVuY2F0ZS5taW5DaGFyLFxuICAgICAgICBwbGFjZWhvbGRlcjogdHJ1bmNhdGUucGxhY2Vob2xkZXJcbiAgICAgIH0pOyAvLyBGSVhNRVxuICAgICAgLy8gSXQgaXMgbm90IGFwcHJvcHJpYXRlIHRoYXQgZXZlcnkgbGluZSBoYXMgJy4uLicgd2hlbiB0cnVuY2F0ZSBtdWx0aXBsZSBsaW5lcy5cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpbmVzW2ldID0gdHJ1bmNhdGVTaW5nbGVMaW5lKGxpbmVzW2ldLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxpbmVzOiBsaW5lcyxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBvdXRlckhlaWdodDogb3V0ZXJIZWlnaHQsXG4gICAgbGluZUhlaWdodDogbGluZUhlaWdodFxuICB9O1xufVxuLyoqXG4gKiBGb3IgZXhhbXBsZTogJ3NvbWUgdGV4dCB7YXxzb21lIHRleHR9b3RoZXIgdGV4dHtifHNvbWUgdGV4dH14eHh7Y3x9eHh4J1xuICogQWxzbyBjb25zaWRlciAnYmJiYnthfHh4eFxcbnp6en14eHh4XFxuYWFhYScuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICogQHJldHVybiB7T2JqZWN0fSBibG9ja1xuICoge1xuICogICAgICB3aWR0aCxcbiAqICAgICAgaGVpZ2h0LFxuICogICAgICBsaW5lczogW3tcbiAqICAgICAgICAgIGxpbmVIZWlnaHQsXG4gKiAgICAgICAgICB3aWR0aCxcbiAqICAgICAgICAgIHRva2VuczogW1t7XG4gKiAgICAgICAgICAgICAgc3R5bGVOYW1lLFxuICogICAgICAgICAgICAgIHRleHQsXG4gKiAgICAgICAgICAgICAgd2lkdGgsICAgICAgLy8gaW5jbHVkZSB0ZXh0UGFkZGluZ1xuICogICAgICAgICAgICAgIGhlaWdodCwgICAgIC8vIGluY2x1ZGUgdGV4dFBhZGRpbmdcbiAqICAgICAgICAgICAgICB0ZXh0V2lkdGgsIC8vIHB1cmUgdGV4dCB3aWR0aFxuICogICAgICAgICAgICAgIHRleHRIZWlnaHQsIC8vIHB1cmUgdGV4dCBoZWlnaHRcbiAqICAgICAgICAgICAgICBsaW5lSGVpaGd0LFxuICogICAgICAgICAgICAgIGZvbnQsXG4gKiAgICAgICAgICAgICAgdGV4dEFsaWduLFxuICogICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduXG4gKiAgICAgICAgICB9XSwgWy4uLl0sIC4uLl1cbiAqICAgICAgfSwgLi4uXVxuICogfVxuICogSWYgc3R5bGVOYW1lIGlzIHVuZGVmaW5lZCwgaXQgaXMgcGxhaW4gdGV4dC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlUmljaFRleHQodGV4dCwgc3R5bGUpIHtcbiAgdmFyIGNvbnRlbnRCbG9jayA9IHtcbiAgICBsaW5lczogW10sXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG4gIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgaWYgKCF0ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRlbnRCbG9jaztcbiAgfVxuXG4gIHZhciBsYXN0SW5kZXggPSBTVFlMRV9SRUcubGFzdEluZGV4ID0gMDtcbiAgdmFyIHJlc3VsdDtcblxuICB3aGlsZSAoKHJlc3VsdCA9IFNUWUxFX1JFRy5leGVjKHRleHQpKSAhPSBudWxsKSB7XG4gICAgdmFyIG1hdGNoZWRJbmRleCA9IHJlc3VsdC5pbmRleDtcblxuICAgIGlmIChtYXRjaGVkSW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHB1c2hUb2tlbnMoY29udGVudEJsb2NrLCB0ZXh0LnN1YnN0cmluZyhsYXN0SW5kZXgsIG1hdGNoZWRJbmRleCkpO1xuICAgIH1cblxuICAgIHB1c2hUb2tlbnMoY29udGVudEJsb2NrLCByZXN1bHRbMl0sIHJlc3VsdFsxXSk7XG4gICAgbGFzdEluZGV4ID0gU1RZTEVfUkVHLmxhc3RJbmRleDtcbiAgfVxuXG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHB1c2hUb2tlbnMoY29udGVudEJsb2NrLCB0ZXh0LnN1YnN0cmluZyhsYXN0SW5kZXgsIHRleHQubGVuZ3RoKSk7XG4gIH1cblxuICB2YXIgbGluZXMgPSBjb250ZW50QmxvY2subGluZXM7XG4gIHZhciBjb250ZW50SGVpZ2h0ID0gMDtcbiAgdmFyIGNvbnRlbnRXaWR0aCA9IDA7IC8vIEZvciBgdGV4dFdpZHRoOiAxMDAlYFxuXG4gIHZhciBwZW5kaW5nTGlzdCA9IFtdO1xuICB2YXIgc3RsUGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuICB2YXIgdHJ1bmNhdGUgPSBzdHlsZS50cnVuY2F0ZTtcbiAgdmFyIHRydW5jYXRlV2lkdGggPSB0cnVuY2F0ZSAmJiB0cnVuY2F0ZS5vdXRlcldpZHRoO1xuICB2YXIgdHJ1bmNhdGVIZWlnaHQgPSB0cnVuY2F0ZSAmJiB0cnVuY2F0ZS5vdXRlckhlaWdodDtcblxuICBpZiAoc3RsUGFkZGluZykge1xuICAgIHRydW5jYXRlV2lkdGggIT0gbnVsbCAmJiAodHJ1bmNhdGVXaWR0aCAtPSBzdGxQYWRkaW5nWzFdICsgc3RsUGFkZGluZ1szXSk7XG4gICAgdHJ1bmNhdGVIZWlnaHQgIT0gbnVsbCAmJiAodHJ1bmNhdGVIZWlnaHQgLT0gc3RsUGFkZGluZ1swXSArIHN0bFBhZGRpbmdbMl0pO1xuICB9IC8vIENhbGN1bGF0ZSBsYXlvdXQgaW5mbyBvZiB0b2tlbnMuXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICB2YXIgbGluZUhlaWdodCA9IDA7XG4gICAgdmFyIGxpbmVXaWR0aCA9IDA7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmUudG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgdG9rZW4gPSBsaW5lLnRva2Vuc1tqXTtcbiAgICAgIHZhciB0b2tlblN0eWxlID0gdG9rZW4uc3R5bGVOYW1lICYmIHN0eWxlLnJpY2hbdG9rZW4uc3R5bGVOYW1lXSB8fCB7fTsgLy8gdGV4dFBhZGRpbmcgc2hvdWxkIG5vdCBpbmhlcml0IGZyb20gc3R5bGUuXG5cbiAgICAgIHZhciB0ZXh0UGFkZGluZyA9IHRva2VuLnRleHRQYWRkaW5nID0gdG9rZW5TdHlsZS50ZXh0UGFkZGluZzsgLy8gdGV4dEZvbnQgaGFzIGJlZW4gYXNpZ25lZCB0byBmb250IGJ5IGBub3JtYWxpemVTdHlsZWAuXG5cbiAgICAgIHZhciBmb250ID0gdG9rZW4uZm9udCA9IHRva2VuU3R5bGUuZm9udCB8fCBzdHlsZS5mb250OyAvLyB0ZXh0SGVpZ2h0IGNhbiBiZSB1c2VkIHdoZW4gdGV4dFZlcnRpY2FsQWxpZ24gaXMgc3BlY2lmaWVkIGluIHRva2VuLlxuXG4gICAgICB2YXIgdG9rZW5IZWlnaHQgPSB0b2tlbi50ZXh0SGVpZ2h0ID0gcmV0cmlldmUyKCAvLyB0ZXh0SGVpZ2h0IHNob3VsZCBub3QgYmUgaW5oZXJpdGVkLCBjb25zaWRlciBpdCBjYW4gYmUgc3BlY2lmaWVkXG4gICAgICAvLyBhcyBib3ggaGVpZ2h0IG9mIHRoZSBibG9jay5cbiAgICAgIHRva2VuU3R5bGUudGV4dEhlaWdodCwgZ2V0TGluZUhlaWdodChmb250KSk7XG4gICAgICB0ZXh0UGFkZGluZyAmJiAodG9rZW5IZWlnaHQgKz0gdGV4dFBhZGRpbmdbMF0gKyB0ZXh0UGFkZGluZ1syXSk7XG4gICAgICB0b2tlbi5oZWlnaHQgPSB0b2tlbkhlaWdodDtcbiAgICAgIHRva2VuLmxpbmVIZWlnaHQgPSByZXRyaWV2ZTModG9rZW5TdHlsZS50ZXh0TGluZUhlaWdodCwgc3R5bGUudGV4dExpbmVIZWlnaHQsIHRva2VuSGVpZ2h0KTtcbiAgICAgIHRva2VuLnRleHRBbGlnbiA9IHRva2VuU3R5bGUgJiYgdG9rZW5TdHlsZS50ZXh0QWxpZ24gfHwgc3R5bGUudGV4dEFsaWduO1xuICAgICAgdG9rZW4udGV4dFZlcnRpY2FsQWxpZ24gPSB0b2tlblN0eWxlICYmIHRva2VuU3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gfHwgJ21pZGRsZSc7XG5cbiAgICAgIGlmICh0cnVuY2F0ZUhlaWdodCAhPSBudWxsICYmIGNvbnRlbnRIZWlnaHQgKyB0b2tlbi5saW5lSGVpZ2h0ID4gdHJ1bmNhdGVIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lczogW10sXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRva2VuLnRleHRXaWR0aCA9IGdldFdpZHRoKHRva2VuLnRleHQsIGZvbnQpO1xuICAgICAgdmFyIHRva2VuV2lkdGggPSB0b2tlblN0eWxlLnRleHRXaWR0aDtcbiAgICAgIHZhciB0b2tlbldpZHRoTm90U3BlY2lmaWVkID0gdG9rZW5XaWR0aCA9PSBudWxsIHx8IHRva2VuV2lkdGggPT09ICdhdXRvJzsgLy8gUGVyY2VudCB3aWR0aCwgY2FuIGJlIGAxMDAlYCwgY2FuIGJlIHVzZWQgaW4gZHJhd2luZyBzZXBhcmF0ZVxuICAgICAgLy8gbGluZSB3aGVuIGJveCB3aWR0aCBpcyBuZWVkZWQgdG8gYmUgYXV0by5cblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbldpZHRoID09PSAnc3RyaW5nJyAmJiB0b2tlbldpZHRoLmNoYXJBdCh0b2tlbldpZHRoLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgICAgdG9rZW4ucGVyY2VudFdpZHRoID0gdG9rZW5XaWR0aDtcbiAgICAgICAgcGVuZGluZ0xpc3QucHVzaCh0b2tlbik7XG4gICAgICAgIHRva2VuV2lkdGggPSAwOyAvLyBEbyBub3QgdHJ1bmNhdGUgaW4gdGhpcyBjYXNlLCBiZWNhdXNlIHRoZXJlIGlzIG5vIHVzZXIgY2FzZVxuICAgICAgICAvLyBhbmQgaXQgaXMgdG9vIGNvbXBsaWNhdGVkLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRva2VuV2lkdGhOb3RTcGVjaWZpZWQpIHtcbiAgICAgICAgICB0b2tlbldpZHRoID0gdG9rZW4udGV4dFdpZHRoOyAvLyBGSVhNRTogSWYgaW1hZ2UgaXMgbm90IGxvYWRlZCBhbmQgdGV4dFdpZHRoIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGxpbmdcbiAgICAgICAgICAvLyBgZ2V0Qm91bmRpbmdSZWN0KClgIHdpbGwgbm90IGdldCBjb3JyZWN0IHJlc3VsdC5cblxuICAgICAgICAgIHZhciB0ZXh0QmFja2dyb3VuZENvbG9yID0gdG9rZW5TdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgIHZhciBiZ0ltZyA9IHRleHRCYWNrZ3JvdW5kQ29sb3IgJiYgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZTsgLy8gVXNlIGNhc2VzOlxuICAgICAgICAgIC8vICgxKSBJZiBpbWFnZSBpcyBub3QgbG9hZGVkLCBpdCB3aWxsIGJlIGxvYWRlZCBhdCByZW5kZXIgcGhhc2UgYW5kIGNhbGxcbiAgICAgICAgICAvLyBgZGlydHkoKWAgYW5kIGB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlYCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGxvYWRlZFxuICAgICAgICAgIC8vIGltYWdlLCBhbmQgdGhlbiB0aGUgcmlnaHQgc2l6ZSB3aWxsIGJlIGNhbGN1bGF0ZWQgaGVyZSBhdCB0aGUgbmV4dCB0aWNrLlxuICAgICAgICAgIC8vIFNlZSBgZ3JhcGhpYy9oZWxwZXIvdGV4dC5qc2AuXG4gICAgICAgICAgLy8gKDIpIElmIGltYWdlIGxvYWRlZCwgYW5kIGB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlYCBpcyBpbWFnZSBzcmMgc3RyaW5nLFxuICAgICAgICAgIC8vIHVzZSBgaW1hZ2VIZWxwZXIuZmluZEV4aXN0SW1hZ2VgIHRvIGZpbmQgY2FjaGVkIGltYWdlLlxuICAgICAgICAgIC8vIGBpbWFnZUhlbHBlci5maW5kRXhpc3RJbWFnZWAgd2lsbCBhbHdheXMgYmUgY2FsbGVkIGhlcmUgYmVmb3JlXG4gICAgICAgICAgLy8gYGltYWdlSGVscGVyLmNyZWF0ZU9yVXBkYXRlSW1hZ2VgIGluIGBncmFwaGljL2hlbHBlci90ZXh0LmpzI3JlbmRlclJpY2hUZXh0YFxuICAgICAgICAgIC8vIHdoaWNoIGVuc3VyZXMgdGhhdCBpbWFnZSB3aWxsIG5vdCBiZSByZW5kZXJlZCBiZWZvcmUgY29ycmVjdCBzaXplIGNhbGN1YWx0ZWQuXG5cbiAgICAgICAgICBpZiAoYmdJbWcpIHtcbiAgICAgICAgICAgIGJnSW1nID0gaW1hZ2VIZWxwZXIuZmluZEV4aXN0SW1hZ2UoYmdJbWcpO1xuXG4gICAgICAgICAgICBpZiAoaW1hZ2VIZWxwZXIuaXNJbWFnZVJlYWR5KGJnSW1nKSkge1xuICAgICAgICAgICAgICB0b2tlbldpZHRoID0gTWF0aC5tYXgodG9rZW5XaWR0aCwgYmdJbWcud2lkdGggKiB0b2tlbkhlaWdodCAvIGJnSW1nLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhZGRpbmdXID0gdGV4dFBhZGRpbmcgPyB0ZXh0UGFkZGluZ1sxXSArIHRleHRQYWRkaW5nWzNdIDogMDtcbiAgICAgICAgdG9rZW5XaWR0aCArPSBwYWRkaW5nVztcbiAgICAgICAgdmFyIHJlbWlhblRydW5jV2lkdGggPSB0cnVuY2F0ZVdpZHRoICE9IG51bGwgPyB0cnVuY2F0ZVdpZHRoIC0gbGluZVdpZHRoIDogbnVsbDtcblxuICAgICAgICBpZiAocmVtaWFuVHJ1bmNXaWR0aCAhPSBudWxsICYmIHJlbWlhblRydW5jV2lkdGggPCB0b2tlbldpZHRoKSB7XG4gICAgICAgICAgaWYgKCF0b2tlbldpZHRoTm90U3BlY2lmaWVkIHx8IHJlbWlhblRydW5jV2lkdGggPCBwYWRkaW5nVykge1xuICAgICAgICAgICAgdG9rZW4udGV4dCA9ICcnO1xuICAgICAgICAgICAgdG9rZW4udGV4dFdpZHRoID0gdG9rZW5XaWR0aCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSB0cnVuY2F0ZVRleHQodG9rZW4udGV4dCwgcmVtaWFuVHJ1bmNXaWR0aCAtIHBhZGRpbmdXLCBmb250LCB0cnVuY2F0ZS5lbGxpcHNpcywge1xuICAgICAgICAgICAgICBtaW5DaGFyOiB0cnVuY2F0ZS5taW5DaGFyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRva2VuLnRleHRXaWR0aCA9IGdldFdpZHRoKHRva2VuLnRleHQsIGZvbnQpO1xuICAgICAgICAgICAgdG9rZW5XaWR0aCA9IHRva2VuLnRleHRXaWR0aCArIHBhZGRpbmdXO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaW5lV2lkdGggKz0gdG9rZW4ud2lkdGggPSB0b2tlbldpZHRoO1xuICAgICAgdG9rZW5TdHlsZSAmJiAobGluZUhlaWdodCA9IE1hdGgubWF4KGxpbmVIZWlnaHQsIHRva2VuLmxpbmVIZWlnaHQpKTtcbiAgICB9XG5cbiAgICBsaW5lLndpZHRoID0gbGluZVdpZHRoO1xuICAgIGxpbmUubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgY29udGVudEhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgIGNvbnRlbnRXaWR0aCA9IE1hdGgubWF4KGNvbnRlbnRXaWR0aCwgbGluZVdpZHRoKTtcbiAgfVxuXG4gIGNvbnRlbnRCbG9jay5vdXRlcldpZHRoID0gY29udGVudEJsb2NrLndpZHRoID0gcmV0cmlldmUyKHN0eWxlLnRleHRXaWR0aCwgY29udGVudFdpZHRoKTtcbiAgY29udGVudEJsb2NrLm91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLmhlaWdodCA9IHJldHJpZXZlMihzdHlsZS50ZXh0SGVpZ2h0LCBjb250ZW50SGVpZ2h0KTtcblxuICBpZiAoc3RsUGFkZGluZykge1xuICAgIGNvbnRlbnRCbG9jay5vdXRlcldpZHRoICs9IHN0bFBhZGRpbmdbMV0gKyBzdGxQYWRkaW5nWzNdO1xuICAgIGNvbnRlbnRCbG9jay5vdXRlckhlaWdodCArPSBzdGxQYWRkaW5nWzBdICsgc3RsUGFkZGluZ1syXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGVuZGluZ0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSBwZW5kaW5nTGlzdFtpXTtcbiAgICB2YXIgcGVyY2VudFdpZHRoID0gdG9rZW4ucGVyY2VudFdpZHRoOyAvLyBTaG91bGQgbm90IGJhc2Ugb24gb3V0ZXJXaWR0aCwgYmVjYXVzZSB0b2tlbiBjYW4gbm90IGJlIHBsYWNlZCBvdXQgb2YgcGFkZGluZy5cblxuICAgIHRva2VuLndpZHRoID0gcGFyc2VJbnQocGVyY2VudFdpZHRoLCAxMCkgLyAxMDAgKiBjb250ZW50V2lkdGg7XG4gIH1cblxuICByZXR1cm4gY29udGVudEJsb2NrO1xufVxuXG5mdW5jdGlvbiBwdXNoVG9rZW5zKGJsb2NrLCBzdHIsIHN0eWxlTmFtZSkge1xuICB2YXIgaXNFbXB0eVN0ciA9IHN0ciA9PT0gJyc7XG4gIHZhciBzdHJzID0gc3RyLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGxpbmVzID0gYmxvY2subGluZXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRleHQgPSBzdHJzW2ldO1xuICAgIHZhciB0b2tlbiA9IHtcbiAgICAgIHN0eWxlTmFtZTogc3R5bGVOYW1lLFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIGlzTGluZUhvbGRlcjogIXRleHQgJiYgIWlzRW1wdHlTdHJcbiAgICB9OyAvLyBUaGUgZmlyc3QgdG9rZW4gc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBsYXN0IGxpbmUuXG5cbiAgICBpZiAoIWkpIHtcbiAgICAgIHZhciB0b2tlbnMgPSAobGluZXNbbGluZXMubGVuZ3RoIC0gMV0gfHwgKGxpbmVzWzBdID0ge1xuICAgICAgICB0b2tlbnM6IFtdXG4gICAgICB9KSkudG9rZW5zOyAvLyBDb25zaWRlciBjYXNlczpcbiAgICAgIC8vICgxKSAnJy5zcGxpdCgnXFxuJykgPT4gWycnLCAnXFxuJywgJyddLCB0aGUgJycgYXQgdGhlIGZpcnN0IGl0ZW1cbiAgICAgIC8vICh3aGljaCBpcyBhIHBsYWNlaG9sZGVyKSBzaG91bGQgYmUgcmVwbGFjZWQgYnkgbmV3IHRva2VuLlxuICAgICAgLy8gKDIpIEEgaW1hZ2UgYmFja2FnZSwgd2hlcmUgdG9rZW4gbGlrZXMge2F8fS5cbiAgICAgIC8vICgzKSBBIHJlZHVuZGFudCAnJyB3aWxsIGFmZmVjdCB0ZXh0QWxpZ24gaW4gbGluZS5cbiAgICAgIC8vICg0KSB0b2tlbnMgd2l0aCB0aGUgc2FtZSB0cGxOYW1lIHNob3VsZCBub3QgYmUgbWVyZ2VkLCBiZWNhdXNlXG4gICAgICAvLyB0aGV5IHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gZGlmZmVyZW50IGJveCAod2l0aCBib3JkZXIgYW5kIHBhZGRpbmcpLlxuXG4gICAgICB2YXIgdG9rZW5zTGVuID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgIHRva2Vuc0xlbiA9PT0gMSAmJiB0b2tlbnNbMF0uaXNMaW5lSG9sZGVyID8gdG9rZW5zWzBdID0gdG9rZW4gOiAvLyBDb25zaWRlciB0ZXh0IGlzICcnLCBvbmx5IGluc2VydCB3aGVuIGl0IGlzIHRoZSBcImxpbmVIb2xkZXJcIiBvclxuICAgICAgLy8gXCJlbXB0eVN0clwiLiBPdGhlcndpc2UgYSByZWR1bmRhbnQgJycgd2lsbCBhZmZlY3QgdGV4dEFsaWduIGluIGxpbmUuXG4gICAgICAodGV4dCB8fCAhdG9rZW5zTGVuIHx8IGlzRW1wdHlTdHIpICYmIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICB9IC8vIE90aGVyIHRva2VucyBhbHdheXMgc3RhcnQgYSBuZXcgbGluZS5cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgJycsIGluc2VydCBpdCBhcyBhIHBsYWNlaG9sZGVyLlxuICAgICAgICBsaW5lcy5wdXNoKHtcbiAgICAgICAgICB0b2tlbnM6IFt0b2tlbl1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUZvbnQoc3R5bGUpIHtcbiAgLy8gRklYTUUgaW4gbm9kZS1jYW52YXMgZm9udFdlaWdodCBpcyBiZWZvcmUgZm9udFN0eWxlXG4gIC8vIFVzZSBgZm9udFNpemVgIGBmb250RmFtaWx5YCB0byBjaGVjayB3aGV0aGVyIGZvbnQgcHJvcGVydGllcyBhcmUgZGVmaW5lZC5cbiAgcmV0dXJuIChzdHlsZS5mb250U2l6ZSB8fCBzdHlsZS5mb250RmFtaWx5KSAmJiBbc3R5bGUuZm9udFN0eWxlLCBzdHlsZS5mb250V2VpZ2h0LCAoc3R5bGUuZm9udFNpemUgfHwgMTIpICsgJ3B4JywgLy8gSWYgZm9udCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLCBgZm9udEZhbWlseWAgc2hvdWxkIG5vdCBiZSBpZ25vcmVkLlxuICBzdHlsZS5mb250RmFtaWx5IHx8ICdzYW5zLXNlcmlmJ10uam9pbignICcpIHx8IHN0eWxlLnRleHRGb250IHx8IHN0eWxlLmZvbnQ7XG59XG5cbmV4cG9ydHMuREVGQVVMVF9GT05UID0gREVGQVVMVF9GT05UO1xuZXhwb3J0cy4kb3ZlcnJpZGUgPSAkb3ZlcnJpZGU7XG5leHBvcnRzLmdldFdpZHRoID0gZ2V0V2lkdGg7XG5leHBvcnRzLmdldEJvdW5kaW5nUmVjdCA9IGdldEJvdW5kaW5nUmVjdDtcbmV4cG9ydHMuYWRqdXN0VGV4dFggPSBhZGp1c3RUZXh0WDtcbmV4cG9ydHMuYWRqdXN0VGV4dFkgPSBhZGp1c3RUZXh0WTtcbmV4cG9ydHMuYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0ID0gYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0O1xuZXhwb3J0cy50cnVuY2F0ZVRleHQgPSB0cnVuY2F0ZVRleHQ7XG5leHBvcnRzLmdldExpbmVIZWlnaHQgPSBnZXRMaW5lSGVpZ2h0O1xuZXhwb3J0cy5tZWFzdXJlVGV4dCA9IG1lYXN1cmVUZXh0O1xuZXhwb3J0cy5wYXJzZVBsYWluVGV4dCA9IHBhcnNlUGxhaW5UZXh0O1xuZXhwb3J0cy5wYXJzZVJpY2hUZXh0ID0gcGFyc2VSaWNoVGV4dDtcbmV4cG9ydHMubWFrZUZvbnQgPSBtYWtlRm9udDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi90ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdmVjMiA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcblxudmFyIG1hdHJpeCA9IHJlcXVpcmUoXCIuL21hdHJpeFwiKTtcblxuLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAqL1xudmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdFxuICovXG5cbmZ1bmN0aW9uIEJvdW5kaW5nUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGlmICh3aWR0aCA8IDApIHtcbiAgICB4ID0geCArIHdpZHRoO1xuICAgIHdpZHRoID0gLXdpZHRoO1xuICB9XG5cbiAgaWYgKGhlaWdodCA8IDApIHtcbiAgICB5ID0geSArIGhlaWdodDtcbiAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuXG4gIHRoaXMueCA9IHg7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLnkgPSB5O1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59XG5cbkJvdW5kaW5nUmVjdC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBCb3VuZGluZ1JlY3QsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9IG90aGVyXG4gICAqL1xuICB1bmlvbjogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdmFyIHggPSBtYXRoTWluKG90aGVyLngsIHRoaXMueCk7XG4gICAgdmFyIHkgPSBtYXRoTWluKG90aGVyLnksIHRoaXMueSk7XG4gICAgdGhpcy53aWR0aCA9IG1hdGhNYXgob3RoZXIueCArIG90aGVyLndpZHRoLCB0aGlzLnggKyB0aGlzLndpZHRoKSAtIHg7XG4gICAgdGhpcy5oZWlnaHQgPSBtYXRoTWF4KG90aGVyLnkgKyBvdGhlci5oZWlnaHQsIHRoaXMueSArIHRoaXMuaGVpZ2h0KSAtIHk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtXG4gICAqIEBtZXRob2RzXG4gICAqL1xuICBhcHBseVRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsdCA9IFtdO1xuICAgIHZhciByYiA9IFtdO1xuICAgIHZhciBsYiA9IFtdO1xuICAgIHZhciBydCA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAobSkge1xuICAgICAgLy8gSW4gY2FzZSB1c2FnZSBsaWtlIHRoaXNcbiAgICAgIC8vIGVsLmdldEJvdW5kaW5nUmVjdCgpLmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSlcbiAgICAgIC8vIEFuZCBlbGVtZW50IGhhcyBubyB0cmFuc2Zvcm1cbiAgICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGx0WzBdID0gbGJbMF0gPSB0aGlzLng7XG4gICAgICBsdFsxXSA9IHJ0WzFdID0gdGhpcy55O1xuICAgICAgcmJbMF0gPSBydFswXSA9IHRoaXMueCArIHRoaXMud2lkdGg7XG4gICAgICByYlsxXSA9IGxiWzFdID0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKGx0LCBsdCwgbSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHJiLCByYiwgbSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKGxiLCBsYiwgbSk7XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHJ0LCBydCwgbSk7XG4gICAgICB0aGlzLnggPSBtYXRoTWluKGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgIHRoaXMueSA9IG1hdGhNaW4obHRbMV0sIHJiWzFdLCBsYlsxXSwgcnRbMV0pO1xuICAgICAgdmFyIG1heFggPSBtYXRoTWF4KGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgIHZhciBtYXhZID0gbWF0aE1heChsdFsxXSwgcmJbMV0sIGxiWzFdLCBydFsxXSk7XG4gICAgICB0aGlzLndpZHRoID0gbWF4WCAtIHRoaXMueDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gbWF4WSAtIHRoaXMueTtcbiAgICB9O1xuICB9KCksXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBtYXRyaXggb2YgdHJhbnNmb3JtaW5nIGZyb20gc2VsZiB0byB0YXJnZXQgcmVjdFxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gYlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIGNhbGN1bGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGIpIHtcbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIHN4ID0gYi53aWR0aCAvIGEud2lkdGg7XG4gICAgdmFyIHN5ID0gYi5oZWlnaHQgLyBhLmhlaWdodDtcbiAgICB2YXIgbSA9IG1hdHJpeC5jcmVhdGUoKTsgLy8g55+p6Zi15Y+z5LmYXG5cbiAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstYS54LCAtYS55XSk7XG4gICAgbWF0cml4LnNjYWxlKG0sIG0sIFtzeCwgc3ldKTtcbiAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFtiLngsIGIueV0pO1xuICAgIHJldHVybiBtO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyhtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdHxPYmplY3QpfSBiXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChiKSB7XG4gICAgaWYgKCFiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIEJvdW5kaW5nUmVjdCkpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZSBuZWdhdGl2ZSB3aWR0aC9oZWlnaHQuXG4gICAgICBiID0gQm91bmRpbmdSZWN0LmNyZWF0ZShiKTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGF4MCA9IGEueDtcbiAgICB2YXIgYXgxID0gYS54ICsgYS53aWR0aDtcbiAgICB2YXIgYXkwID0gYS55O1xuICAgIHZhciBheTEgPSBhLnkgKyBhLmhlaWdodDtcbiAgICB2YXIgYngwID0gYi54O1xuICAgIHZhciBieDEgPSBiLnggKyBiLndpZHRoO1xuICAgIHZhciBieTAgPSBiLnk7XG4gICAgdmFyIGJ5MSA9IGIueSArIGIuaGVpZ2h0O1xuICAgIHJldHVybiAhKGF4MSA8IGJ4MCB8fCBieDEgPCBheDAgfHwgYXkxIDwgYnkwIHx8IGJ5MSA8IGF5MCk7XG4gIH0sXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIHJlY3QgPSB0aGlzO1xuICAgIHJldHVybiB4ID49IHJlY3QueCAmJiB4IDw9IHJlY3QueCArIHJlY3Qud2lkdGggJiYgeSA+PSByZWN0LnkgJiYgeSA8PSByZWN0LnkgKyByZWN0LmhlaWdodDtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvcHkgZnJvbSBhbm90aGVyIHJlY3RcbiAgICovXG4gIGNvcHk6IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHRoaXMueCA9IG90aGVyLng7XG4gICAgdGhpcy55ID0gb3RoZXIueTtcbiAgICB0aGlzLndpZHRoID0gb3RoZXIud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBvdGhlci5oZWlnaHQ7XG4gIH0sXG4gIHBsYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHRoaXMueCxcbiAgICAgIHk6IHRoaXMueSxcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fG1vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSByZWN0XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC54XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC55XG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC53aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IHJlY3QuaGVpZ2h0XG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAqL1xuXG5Cb3VuZGluZ1JlY3QuY3JlYXRlID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IEJvdW5kaW5nUmVjdDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTFJVID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvTFJVXCIpO1xuXG52YXIgZ2xvYmFsSW1hZ2VDYWNoZSA9IG5ldyBMUlUoNTApO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gbmV3SW1hZ2VPclNyY1xuICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IGltYWdlXG4gKi9cblxuZnVuY3Rpb24gZmluZEV4aXN0SW1hZ2UobmV3SW1hZ2VPclNyYykge1xuICBpZiAodHlwZW9mIG5ld0ltYWdlT3JTcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGNhY2hlZEltZ09iaiA9IGdsb2JhbEltYWdlQ2FjaGUuZ2V0KG5ld0ltYWdlT3JTcmMpO1xuICAgIHJldHVybiBjYWNoZWRJbWdPYmogJiYgY2FjaGVkSW1nT2JqLmltYWdlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXdJbWFnZU9yU3JjO1xuICB9XG59XG4vKipcbiAqIENhdXRpb246IFVzZXIgc2hvdWxkIGNhY2hlIGxvYWRlZCBpbWFnZXMsIGJ1dCBub3QganVzdCBjb3VudCBvbiBMUlUuXG4gKiBDb25zaWRlciBpZiByZXF1aXJlZCBpbWFnZXMgbW9yZSB0aGFuIExSVSBzaXplLCB3aWxsIGRlYWQgbG9vcCBvY2N1cj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gbmV3SW1hZ2VPclNyY1xuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gaW1hZ2UgRXhpc3RlbnQgaW1hZ2UuXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IFtob3N0RWxdIEZvciBjYWxsaW5nIGBkaXJ0eWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIHBhcmFtczogKGltYWdlLCBjYlBheWxvYWQpXG4gKiBAcGFyYW0ge09iamVjdH0gW2NiUGF5bG9hZF0gUGF5bG9hZCBvbiBjYiBjYWxsaW5nLlxuICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IGltYWdlXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUltYWdlKG5ld0ltYWdlT3JTcmMsIGltYWdlLCBob3N0RWwsIGNiLCBjYlBheWxvYWQpIHtcbiAgaWYgKCFuZXdJbWFnZU9yU3JjKSB7XG4gICAgcmV0dXJuIGltYWdlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBuZXdJbWFnZU9yU3JjID09PSAnc3RyaW5nJykge1xuICAgIC8vIEltYWdlIHNob3VsZCBub3QgYmUgbG9hZGVkIHJlcGVhdGx5LlxuICAgIGlmIChpbWFnZSAmJiBpbWFnZS5fX3pySW1hZ2VTcmMgPT09IG5ld0ltYWdlT3JTcmMgfHwgIWhvc3RFbCkge1xuICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH0gLy8gT25seSB3aGVuIHRoZXJlIGlzIG5vIGV4aXN0ZW50IGltYWdlIG9yIGV4aXN0ZW50IGltYWdlIHNyY1xuICAgIC8vIGlzIGRpZmZlcmVudCwgdGhpcyBtZXRob2QgaXMgcmVzcG9uc2libGUgZm9yIGxvYWQuXG5cblxuICAgIHZhciBjYWNoZWRJbWdPYmogPSBnbG9iYWxJbWFnZUNhY2hlLmdldChuZXdJbWFnZU9yU3JjKTtcbiAgICB2YXIgcGVuZGluZ1dyYXAgPSB7XG4gICAgICBob3N0RWw6IGhvc3RFbCxcbiAgICAgIGNiOiBjYixcbiAgICAgIGNiUGF5bG9hZDogY2JQYXlsb2FkXG4gICAgfTtcblxuICAgIGlmIChjYWNoZWRJbWdPYmopIHtcbiAgICAgIGltYWdlID0gY2FjaGVkSW1nT2JqLmltYWdlO1xuICAgICAgIWlzSW1hZ2VSZWFkeShpbWFnZSkgJiYgY2FjaGVkSW1nT2JqLnBlbmRpbmcucHVzaChwZW5kaW5nV3JhcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICFpbWFnZSAmJiAoaW1hZ2UgPSBuZXcgSW1hZ2UoKSk7XG4gICAgICBpbWFnZS5vbmxvYWQgPSBpbWFnZU9uTG9hZDtcbiAgICAgIGdsb2JhbEltYWdlQ2FjaGUucHV0KG5ld0ltYWdlT3JTcmMsIGltYWdlLl9fY2FjaGVkSW1nT2JqID0ge1xuICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgIHBlbmRpbmc6IFtwZW5kaW5nV3JhcF1cbiAgICAgIH0pO1xuICAgICAgaW1hZ2Uuc3JjID0gaW1hZ2UuX196ckltYWdlU3JjID0gbmV3SW1hZ2VPclNyYztcbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH0gLy8gbmV3SW1hZ2VPclNyYyBpcyBhbiBIVE1MSW1hZ2VFbGVtZW50IG9yIEhUTUxDYW52YXNFbGVtZW50IG9yIENhbnZhc1xuICBlbHNlIHtcbiAgICAgIHJldHVybiBuZXdJbWFnZU9yU3JjO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW1hZ2VPbkxvYWQoKSB7XG4gIHZhciBjYWNoZWRJbWdPYmogPSB0aGlzLl9fY2FjaGVkSW1nT2JqO1xuICB0aGlzLm9ubG9hZCA9IHRoaXMuX19jYWNoZWRJbWdPYmogPSBudWxsO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FjaGVkSW1nT2JqLnBlbmRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGVuZGluZ1dyYXAgPSBjYWNoZWRJbWdPYmoucGVuZGluZ1tpXTtcbiAgICB2YXIgY2IgPSBwZW5kaW5nV3JhcC5jYjtcbiAgICBjYiAmJiBjYih0aGlzLCBwZW5kaW5nV3JhcC5jYlBheWxvYWQpO1xuICAgIHBlbmRpbmdXcmFwLmhvc3RFbC5kaXJ0eSgpO1xuICB9XG5cbiAgY2FjaGVkSW1nT2JqLnBlbmRpbmcubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gaXNJbWFnZVJlYWR5KGltYWdlKSB7XG4gIHJldHVybiBpbWFnZSAmJiBpbWFnZS53aWR0aCAmJiBpbWFnZS5oZWlnaHQ7XG59XG5cbmV4cG9ydHMuZmluZEV4aXN0SW1hZ2UgPSBmaW5kRXhpc3RJbWFnZTtcbmV4cG9ydHMuY3JlYXRlT3JVcGRhdGVJbWFnZSA9IGNyZWF0ZU9yVXBkYXRlSW1hZ2U7XG5leHBvcnRzLmlzSW1hZ2VSZWFkeSA9IGlzSW1hZ2VSZWFkeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvaW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIGJ1aWxkUGF0aChjdHgsIHNoYXBlKSB7XG4gIHZhciB4ID0gc2hhcGUueDtcbiAgdmFyIHkgPSBzaGFwZS55O1xuICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgdmFyIHIgPSBzaGFwZS5yO1xuICB2YXIgcjE7XG4gIHZhciByMjtcbiAgdmFyIHIzO1xuICB2YXIgcjQ7IC8vIENvbnZlcnQgd2lkdGggYW5kIGhlaWdodCB0byBwb3NpdGl2ZSBmb3IgYmV0dGVyIGJvcmRlclJhZGl1c1xuXG4gIGlmICh3aWR0aCA8IDApIHtcbiAgICB4ID0geCArIHdpZHRoO1xuICAgIHdpZHRoID0gLXdpZHRoO1xuICB9XG5cbiAgaWYgKGhlaWdodCA8IDApIHtcbiAgICB5ID0geSArIGhlaWdodDtcbiAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICB9XG5cbiAgaWYgKHR5cGVvZiByID09PSAnbnVtYmVyJykge1xuICAgIHIxID0gcjIgPSByMyA9IHI0ID0gcjtcbiAgfSBlbHNlIGlmIChyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBpZiAoci5sZW5ndGggPT09IDEpIHtcbiAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gclswXTtcbiAgICB9IGVsc2UgaWYgKHIubGVuZ3RoID09PSAyKSB7XG4gICAgICByMSA9IHIzID0gclswXTtcbiAgICAgIHIyID0gcjQgPSByWzFdO1xuICAgIH0gZWxzZSBpZiAoci5sZW5ndGggPT09IDMpIHtcbiAgICAgIHIxID0gclswXTtcbiAgICAgIHIyID0gcjQgPSByWzFdO1xuICAgICAgcjMgPSByWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICByMSA9IHJbMF07XG4gICAgICByMiA9IHJbMV07XG4gICAgICByMyA9IHJbMl07XG4gICAgICByNCA9IHJbM107XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHIxID0gcjIgPSByMyA9IHI0ID0gMDtcbiAgfVxuXG4gIHZhciB0b3RhbDtcblxuICBpZiAocjEgKyByMiA+IHdpZHRoKSB7XG4gICAgdG90YWwgPSByMSArIHIyO1xuICAgIHIxICo9IHdpZHRoIC8gdG90YWw7XG4gICAgcjIgKj0gd2lkdGggLyB0b3RhbDtcbiAgfVxuXG4gIGlmIChyMyArIHI0ID4gd2lkdGgpIHtcbiAgICB0b3RhbCA9IHIzICsgcjQ7XG4gICAgcjMgKj0gd2lkdGggLyB0b3RhbDtcbiAgICByNCAqPSB3aWR0aCAvIHRvdGFsO1xuICB9XG5cbiAgaWYgKHIyICsgcjMgPiBoZWlnaHQpIHtcbiAgICB0b3RhbCA9IHIyICsgcjM7XG4gICAgcjIgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgcjMgKj0gaGVpZ2h0IC8gdG90YWw7XG4gIH1cblxuICBpZiAocjEgKyByNCA+IGhlaWdodCkge1xuICAgIHRvdGFsID0gcjEgKyByNDtcbiAgICByMSAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICByNCAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgfVxuXG4gIGN0eC5tb3ZlVG8oeCArIHIxLCB5KTtcbiAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByMiwgeSk7XG4gIHIyICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcjIpO1xuICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHIzKTtcbiAgcjMgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByMywgeSArIGhlaWdodCk7XG4gIGN0eC5saW5lVG8oeCArIHI0LCB5ICsgaGVpZ2h0KTtcbiAgcjQgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHI0KTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgcjEpO1xuICByMSAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcjEsIHkpO1xufVxuXG5leHBvcnRzLmJ1aWxkUGF0aCA9IGJ1aWxkUGF0aDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcm91bmRSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY3VydmUgPSByZXF1aXJlKFwiLi9jdXJ2ZVwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciBiYm94ID0gcmVxdWlyZShcIi4vYmJveFwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuL0JvdW5kaW5nUmVjdFwiKTtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgZHByID0gX2NvbmZpZy5kZXZpY2VQaXhlbFJhdGlvO1xuXG4vKipcbiAqIFBhdGgg5Luj55CG77yM5Y+v5Lul5ZyoYGJ1aWxkUGF0aGDkuK3nlKjkuo7mm7/ku6NgY3R4YCwg5Lya5L+d5a2Y5q+P5LiqcGF0aOaTjeS9nOeahOWRveS7pOWIsHBhdGhDb21tYW5kc+WxnuaAp+S4rVxuICog5Y+v5Lul55So5LqOIGlzSW5zaWRlUGF0aCDliKTmlq3ku6Xlj4rojrflj5Zib3VuZGluZ1JlY3RcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAqIEBhdXRob3IgWWkgU2hlbiAoaHR0cDovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbi8vIFRPRE8gZ2V0VG90YWxMZW5ndGgsIGdldFBvaW50QXRMZW5ndGhcbnZhciBDTUQgPSB7XG4gIE06IDEsXG4gIEw6IDIsXG4gIEM6IDMsXG4gIFE6IDQsXG4gIEE6IDUsXG4gIFo6IDYsXG4gIC8vIFJlY3RcbiAgUjogN1xufTsgLy8gdmFyIENNRF9NRU1fU0laRSA9IHtcbi8vICAgICBNOiAzLFxuLy8gICAgIEw6IDMsXG4vLyAgICAgQzogNyxcbi8vICAgICBROiA1LFxuLy8gICAgIEE6IDksXG4vLyAgICAgUjogNSxcbi8vICAgICBaOiAxXG4vLyB9O1xuXG52YXIgbWluID0gW107XG52YXIgbWF4ID0gW107XG52YXIgbWluMiA9IFtdO1xudmFyIG1heDIgPSBbXTtcbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xudmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgbWF0aEFicyA9IE1hdGguYWJzO1xudmFyIGhhc1R5cGVkQXJyYXkgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9ICd1bmRlZmluZWQnO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBQYXRoUHJveHkgPSBmdW5jdGlvbiAobm90U2F2ZURhdGEpIHtcbiAgdGhpcy5fc2F2ZURhdGEgPSAhKG5vdFNhdmVEYXRhIHx8IGZhbHNlKTtcblxuICBpZiAodGhpcy5fc2F2ZURhdGEpIHtcbiAgICAvKipcbiAgICAgKiBQYXRoIGRhdGEuIFN0b3JlZCBhcyBmbGF0IGFycmF5XG4gICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICB9XG5cbiAgdGhpcy5fY3R4ID0gbnVsbDtcbn07XG4vKipcbiAqIOW/q+mAn+iuoeeul1BhdGjljIXlm7Tnm5LvvIjlubbkuI3mmK/mnIDlsI/ljIXlm7Tnm5LvvIlcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5cblBhdGhQcm94eS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoUHJveHksXG4gIF94aTogMCxcbiAgX3lpOiAwLFxuICBfeDA6IDAsXG4gIF95MDogMCxcbiAgLy8gVW5pdCB4LCBVbml0IHkuIFByb3ZpZGUgZm9yIGF2b2lkaW5nIGRyYXdpbmcgdGhhdCB0b28gc2hvcnQgbGluZSBzZWdtZW50XG4gIF91eDogMCxcbiAgX3V5OiAwLFxuICBfbGVuOiAwLFxuICBfbGluZURhc2g6IG51bGwsXG4gIF9kYXNoT2Zmc2V0OiAwLFxuICBfZGFzaElkeDogMCxcbiAgX2Rhc2hTdW06IDAsXG5cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgc2V0U2NhbGU6IGZ1bmN0aW9uIChzeCwgc3kpIHtcbiAgICB0aGlzLl91eCA9IG1hdGhBYnMoMSAvIGRwciAvIHN4KSB8fCAwO1xuICAgIHRoaXMuX3V5ID0gbWF0aEFicygxIC8gZHByIC8gc3kpIHx8IDA7XG4gIH0sXG4gIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3R4O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGJlZ2luUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICBjdHggJiYgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eCAmJiAodGhpcy5kcHIgPSBjdHguZHByKTsgLy8gUmVzZXRcblxuICAgIGlmICh0aGlzLl9zYXZlRGF0YSkge1xuICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGluZURhc2gpIHtcbiAgICAgIHRoaXMuX2xpbmVEYXNoID0gbnVsbDtcbiAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgbW92ZVRvOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuTSwgeCwgeSk7XG4gICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5tb3ZlVG8oeCwgeSk7IC8vIHgwLCB5MCwgeGksIHlpIOaYr+iusOW9leWcqCBfZGFzaGVkWFhYWFRvIOaWueazleS4reS9v+eUqFxuICAgIC8vIHhpLCB5aSDorrDlvZXlvZPliY3ngrksIHgwLCB5MCDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeWbnuWIsOi1t+Wni+eCueOAglxuICAgIC8vIOacieWPr+iDveWcqCBiZWdpblBhdGgg5LmL5ZCO55u05o6l6LCD55SoIGxpbmVUb++8jOi/meaXtuWAmSB4MCwgeTAg6ZyA6KaBXG4gICAgLy8g5ZyoIGxpbmVUbyDmlrnms5XkuK3orrDlvZXvvIzov5nph4zlhYjkuI3ogIPomZHov5nnp43mg4XlhrXvvIxkYXNoZWQgbGluZSDkuZ/lj6rlnKggSUUxMC0g5Lit5LiN5pSv5oyBXG5cbiAgICB0aGlzLl94MCA9IHg7XG4gICAgdGhpcy5feTAgPSB5O1xuICAgIHRoaXMuX3hpID0geDtcbiAgICB0aGlzLl95aSA9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBsaW5lVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGV4Y2VlZFVuaXQgPSBtYXRoQWJzKHggLSB0aGlzLl94aSkgPiB0aGlzLl91eCB8fCBtYXRoQWJzKHkgLSB0aGlzLl95aSkgPiB0aGlzLl91eSAvLyBGb3JjZSBkcmF3IHRoZSBmaXJzdCBzZWdtZW50XG4gICAgfHwgdGhpcy5fbGVuIDwgNTtcbiAgICB0aGlzLmFkZERhdGEoQ01ELkwsIHgsIHkpO1xuXG4gICAgaWYgKHRoaXMuX2N0eCAmJiBleGNlZWRVbml0KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZExpbmVUbyh4LCB5KSA6IHRoaXMuX2N0eC5saW5lVG8oeCwgeSk7XG4gICAgfVxuXG4gICAgaWYgKGV4Y2VlZFVuaXQpIHtcbiAgICAgIHRoaXMuX3hpID0geDtcbiAgICAgIHRoaXMuX3lpID0geTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxXG4gICAqIEBwYXJhbSAge251bWJlcn0geDJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgzXG4gICAqIEBwYXJhbSAge251bWJlcn0geTNcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuQywgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG5cbiAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZEJlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIDogdGhpcy5fY3R4LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgfVxuXG4gICAgdGhpcy5feGkgPSB4MztcbiAgICB0aGlzLl95aSA9IHkzO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5RLCB4MSwgeTEsIHgyLCB5Mik7XG5cbiAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZFF1YWRyYXRpY1RvKHgxLCB5MSwgeDIsIHkyKSA6IHRoaXMuX2N0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyKTtcbiAgICB9XG5cbiAgICB0aGlzLl94aSA9IHgyO1xuICAgIHRoaXMuX3lpID0geTI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0gY3hcbiAgICogQHBhcmFtICB7bnVtYmVyfSBjeVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBzdGFydEFuZ2xlXG4gICAqIEBwYXJhbSAge251bWJlcn0gZW5kQW5nbGVcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gYW50aWNsb2Nrd2lzZVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGFyYzogZnVuY3Rpb24gKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELkEsIGN4LCBjeSwgciwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlLCAwLCBhbnRpY2xvY2t3aXNlID8gMCA6IDEpO1xuICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHguYXJjKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpO1xuICAgIHRoaXMuX3hpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByICsgY3g7XG4gICAgdGhpcy5feWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHIgKyBjeDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gVE9ET1xuICBhcmNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICB0aGlzLl9jdHguYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIFRPRE9cbiAgcmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgdGhpcy5hZGREYXRhKENNRC5SLCB4LCB5LCB3LCBoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBjbG9zZVBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlopO1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgdmFyIHgwID0gdGhpcy5feDA7XG4gICAgdmFyIHkwID0gdGhpcy5feTA7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICB0aGlzLl9uZWVkc0Rhc2goKSAmJiB0aGlzLl9kYXNoZWRMaW5lVG8oeDAsIHkwKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICB0aGlzLl94aSA9IHgwO1xuICAgIHRoaXMuX3lpID0geTA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnRleHQg5LuO5aSW6YOo5Lyg5YWl77yM5Zug5Li65pyJ5Y+v6IO95pivIHJlYnVpbGRQYXRoIOWujOS5i+WQjuWGjSBmaWxs44CCXG4gICAqIHN0cm9rZSDlkIzmoLdcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGZpbGw6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICBjdHggJiYgY3R4LmZpbGwoKTtcbiAgICB0aGlzLnRvU3RhdGljKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBzdHJva2U6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICBjdHggJiYgY3R4LnN0cm9rZSgpO1xuICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgfSxcblxuICAvKipcbiAgICog5b+F6aG75Zyo5YW25a6D57uY5Yi25ZG95Luk5YmN6LCD55SoXG4gICAqIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgYWxsIG90aGVyIHBhdGggZHJhd2luZyBtZXRob2RzXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgc2V0TGluZURhc2g6IGZ1bmN0aW9uIChsaW5lRGFzaCkge1xuICAgIGlmIChsaW5lRGFzaCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB0aGlzLl9saW5lRGFzaCA9IGxpbmVEYXNoO1xuICAgICAgdGhpcy5fZGFzaElkeCA9IDA7XG4gICAgICB2YXIgbGluZURhc2hTdW0gPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVEYXNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpbmVEYXNoU3VtICs9IGxpbmVEYXNoW2ldO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kYXNoU3VtID0gbGluZURhc2hTdW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOW/hemhu+WcqOWFtuWug+e7mOWItuWRveS7pOWJjeiwg+eUqFxuICAgKiBNdXN0IGJlIGludm9rZWQgYmVmb3JlIGFsbCBvdGhlciBwYXRoIGRyYXdpbmcgbWV0aG9kc1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIHNldExpbmVEYXNoT2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgdGhpcy5fZGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGxlbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW47XG4gIH0sXG5cbiAgLyoqXG4gICAqIOebtOaOpeiuvue9riBQYXRoIOaVsOaNrlxuICAgKi9cbiAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAoISh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmxlbmd0aCA9PSBsZW4pICYmIGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLmRhdGFbaV0gPSBkYXRhW2ldO1xuICAgIH1cblxuICAgIHRoaXMuX2xlbiA9IGxlbjtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5a2Q6Lev5b6EXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl8QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5Pn0gcGF0aFxuICAgKi9cbiAgYXBwZW5kUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICBwYXRoID0gW3BhdGhdO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgYXBwZW5kU2l6ZSA9IDA7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX2xlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFwcGVuZFNpemUgKz0gcGF0aFtpXS5sZW4oKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVHlwZWRBcnJheSAmJiB0aGlzLmRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkob2Zmc2V0ICsgYXBwZW5kU2l6ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGFwcGVuZFBhdGhEYXRhID0gcGF0aFtpXS5kYXRhO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFwcGVuZFBhdGhEYXRhLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHRoaXMuZGF0YVtvZmZzZXQrK10gPSBhcHBlbmRQYXRoRGF0YVtrXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9sZW4gPSBvZmZzZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWhq+WFhSBQYXRoIOaVsOaNruOAglxuICAgKiDlsL3ph4/lpI3nlKjogIzkuI3nlLPmmI7mlrDnmoTmlbDnu4TjgILlpKfpg6jliIblm77lvaLph43nu5jnmoTmjIfku6TmlbDmja7plb/luqbpg73mmK/kuI3lj5jnmoTjgIJcbiAgICovXG4gIGFkZERhdGE6IGZ1bmN0aW9uIChjbWQpIHtcbiAgICBpZiAoIXRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICBpZiAodGhpcy5fbGVuICsgYXJndW1lbnRzLmxlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAvLyDlm6DkuLrkuYvliY3nmoTmlbDnu4Tlt7Lnu4/ovazmjaLmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5XG4gICAgICAvLyDmiYDku6XkuI3lpJ/nlKjml7bpnIDopoHmianlsZXkuIDkuKrmlrDnmoTliqjmgIHmlbDnu4RcbiAgICAgIHRoaXMuX2V4cGFuZERhdGEoKTtcblxuICAgICAgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YVt0aGlzLl9sZW4rK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5fcHJldkNtZCA9IGNtZDtcbiAgfSxcbiAgX2V4cGFuZERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBPbmx5IGlmIGRhdGEgaXMgRmxvYXQzMkFycmF5XG4gICAgaWYgKCEodGhpcy5kYXRhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xlbjsgaSsrKSB7XG4gICAgICAgIG5ld0RhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBuZWVkcyBqcyBpbXBsZW1lbnRlZCBkYXNoZWQgbGluZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX25lZWRzRGFzaDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9saW5lRGFzaDtcbiAgfSxcbiAgX2Rhc2hlZExpbmVUbzogZnVuY3Rpb24gKHgxLCB5MSkge1xuICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgIHZhciB5MCA9IHRoaXMuX3lpO1xuICAgIHZhciBkeCA9IHgxIC0geDA7XG4gICAgdmFyIGR5ID0geTEgLSB5MDtcbiAgICB2YXIgZGlzdCA9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB2YXIgeCA9IHgwO1xuICAgIHZhciB5ID0geTA7XG4gICAgdmFyIGRhc2g7XG4gICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgIHZhciBpZHg7XG4gICAgZHggLz0gZGlzdDtcbiAgICBkeSAvPSBkaXN0O1xuXG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgIH1cblxuICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgIHggLT0gb2Zmc2V0ICogZHg7XG4gICAgeSAtPSBvZmZzZXQgKiBkeTtcblxuICAgIHdoaWxlIChkeCA+IDAgJiYgeCA8PSB4MSB8fCBkeCA8IDAgJiYgeCA+PSB4MSB8fCBkeCA9PSAwICYmIChkeSA+IDAgJiYgeSA8PSB5MSB8fCBkeSA8IDAgJiYgeSA+PSB5MSkpIHtcbiAgICAgIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgICBkYXNoID0gbGluZURhc2hbaWR4XTtcbiAgICAgIHggKz0gZHggKiBkYXNoO1xuICAgICAgeSArPSBkeSAqIGRhc2g7XG4gICAgICB0aGlzLl9kYXNoSWR4ID0gKGlkeCArIDEpICUgbkRhc2g7IC8vIFNraXAgcG9zaXRpdmUgb2Zmc2V0XG5cbiAgICAgIGlmIChkeCA+IDAgJiYgeCA8IHgwIHx8IGR4IDwgMCAmJiB4ID4geDAgfHwgZHkgPiAwICYmIHkgPCB5MCB8fCBkeSA8IDAgJiYgeSA+IHkwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjdHhbaWR4ICUgMiA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKGR4ID49IDAgPyBtYXRoTWluKHgsIHgxKSA6IG1hdGhNYXgoeCwgeDEpLCBkeSA+PSAwID8gbWF0aE1pbih5LCB5MSkgOiBtYXRoTWF4KHksIHkxKSk7XG4gICAgfSAvLyBPZmZzZXQgZm9yIG5leHQgbGluZVRvXG5cblxuICAgIGR4ID0geCAtIHgxO1xuICAgIGR5ID0geSAtIHkxO1xuICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAtbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB9LFxuICAvLyBOb3QgYWNjdXJhdGUgZGFzaGVkIGxpbmUgdG9cbiAgX2Rhc2hlZEJlemllclRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgIHZhciB5MCA9IHRoaXMuX3lpO1xuICAgIHZhciB0O1xuICAgIHZhciBkeDtcbiAgICB2YXIgZHk7XG4gICAgdmFyIGN1YmljQXQgPSBjdXJ2ZS5jdWJpY0F0O1xuICAgIHZhciBiZXppZXJMZW4gPSAwO1xuICAgIHZhciBpZHggPSB0aGlzLl9kYXNoSWR4O1xuICAgIHZhciBuRGFzaCA9IGxpbmVEYXNoLmxlbmd0aDtcbiAgICB2YXIgeDtcbiAgICB2YXIgeTtcbiAgICB2YXIgdG1wTGVuID0gMDtcblxuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAvLyBDb252ZXJ0IHRvIHBvc2l0aXZlIG9mZnNldFxuICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICB9XG5cbiAgICBvZmZzZXQgJT0gZGFzaFN1bTsgLy8gQmV6aWVyIGFwcHJveCBsZW5ndGhcblxuICAgIGZvciAodCA9IDA7IHQgPCAxOyB0ICs9IDAuMSkge1xuICAgICAgZHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0ICsgMC4xKSAtIGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgZHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0ICsgMC4xKSAtIGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuICAgICAgYmV6aWVyTGVuICs9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9IC8vIEZpbmQgaWR4IGFmdGVyIGFkZCBvZmZzZXRcblxuXG4gICAgZm9yICg7IGlkeCA8IG5EYXNoOyBpZHgrKykge1xuICAgICAgdG1wTGVuICs9IGxpbmVEYXNoW2lkeF07XG5cbiAgICAgIGlmICh0bXBMZW4gPiBvZmZzZXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdCA9ICh0bXBMZW4gLSBvZmZzZXQpIC8gYmV6aWVyTGVuO1xuXG4gICAgd2hpbGUgKHQgPD0gMSkge1xuICAgICAgeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpOyAvLyBVc2UgbGluZSB0byBhcHByb3hpbWF0ZSBkYXNoZWQgYmV6aWVyXG4gICAgICAvLyBCYWQgcmVzdWx0IGlmIGRhc2ggaXMgbG9uZ1xuXG4gICAgICBpZHggJSAyID8gY3R4Lm1vdmVUbyh4LCB5KSA6IGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICB0ICs9IGxpbmVEYXNoW2lkeF0gLyBiZXppZXJMZW47XG4gICAgICBpZHggPSAoaWR4ICsgMSkgJSBuRGFzaDtcbiAgICB9IC8vIEZpbmlzaCB0aGUgbGFzdCBzZWdtZW50IGFuZCBjYWxjdWxhdGUgdGhlIG5ldyBvZmZzZXRcblxuXG4gICAgaWR4ICUgMiAhPT0gMCAmJiBjdHgubGluZVRvKHgzLCB5Myk7XG4gICAgZHggPSB4MyAtIHg7XG4gICAgZHkgPSB5MyAtIHk7XG4gICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIH0sXG4gIF9kYXNoZWRRdWFkcmF0aWNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgLy8gQ29udmVydCBxdWFkcmF0aWMgdG8gY3ViaWMgdXNpbmcgZGVncmVlIGVsZXZhdGlvblxuICAgIHZhciB4MyA9IHgyO1xuICAgIHZhciB5MyA9IHkyO1xuICAgIHgyID0gKHgyICsgMiAqIHgxKSAvIDM7XG4gICAgeTIgPSAoeTIgKyAyICogeTEpIC8gMztcbiAgICB4MSA9ICh0aGlzLl94aSArIDIgKiB4MSkgLyAzO1xuICAgIHkxID0gKHRoaXMuX3lpICsgMiAqIHkxKSAvIDM7XG5cbiAgICB0aGlzLl9kYXNoZWRCZXppZXJUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgfSxcblxuICAvKipcbiAgICog6L2s5oiQ6Z2Z5oCB55qEIEZsb2F0MzJBcnJheSDlh4/lsJHloIblhoXlrZjljaDnlKhcbiAgICogQ29udmVydCBkeW5hbWljIGFycmF5IHRvIHN0YXRpYyBGbG9hdDMyQXJyYXlcbiAgICovXG4gIHRvU3RhdGljOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBkYXRhLmxlbmd0aCA9IHRoaXMuX2xlbjtcblxuICAgICAgaWYgKGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgKi9cbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgbWluWzBdID0gbWluWzFdID0gbWluMlswXSA9IG1pbjJbMV0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIG1heFswXSA9IG1heFsxXSA9IG1heDJbMF0gPSBtYXgyWzFdID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIHhpID0gMDtcbiAgICB2YXIgeWkgPSAwO1xuICAgIHZhciB4MCA9IDA7XG4gICAgdmFyIHkwID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuXG4gICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgLy9cbiAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgeGkgPSBkYXRhW2ldO1xuICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuICAgICAgICB4MCA9IHhpO1xuICAgICAgICB5MCA9IHlpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgICAgLy8g5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnkvb/nlKhcbiAgICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgbWluMlswXSA9IHgwO1xuICAgICAgICAgIG1pbjJbMV0gPSB5MDtcbiAgICAgICAgICBtYXgyWzBdID0geDA7XG4gICAgICAgICAgbWF4MlsxXSA9IHkwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgYmJveC5mcm9tTGluZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgIGJib3guZnJvbUN1YmljKHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICBiYm94LmZyb21RdWFkcmF0aWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciBlbmRBbmdsZSA9IGRhdGFbaSsrXSArIHN0YXJ0QW5nbGU7IC8vIFRPRE8gQXJjIOaXi+i9rFxuXG4gICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgYW50aWNsb2Nrd2lzZSA9IDEgLSBkYXRhW2krK107XG5cbiAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAvLyDnm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICB4MCA9IG1hdGhDb3Moc3RhcnRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgeTAgPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBiYm94LmZyb21BcmMoY3gsIGN5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICB4aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICB5aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeTAgPSB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTsgLy8gVXNlIGZyb21MaW5lXG5cbiAgICAgICAgICBiYm94LmZyb21MaW5lKHgwLCB5MCwgeDAgKyB3aWR0aCwgeTAgKyBoZWlnaHQsIG1pbjIsIG1heDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBVbmlvblxuXG5cbiAgICAgIHZlYzIubWluKG1pbiwgbWluLCBtaW4yKTtcbiAgICAgIHZlYzIubWF4KG1heCwgbWF4LCBtYXgyKTtcbiAgICB9IC8vIE5vIGRhdGFcblxuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIG1pblswXSA9IG1pblsxXSA9IG1heFswXSA9IG1heFsxXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVidWlsZCBwYXRoIGZyb20gY3VycmVudCBkYXRhXG4gICAqIFJlYnVpbGQgcGF0aCB3aWxsIG5vdCBjb25zaWRlciBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmUgZGFzaC5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgcmVidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgZCA9IHRoaXMuZGF0YTtcbiAgICB2YXIgeDAsIHkwO1xuICAgIHZhciB4aSwgeWk7XG4gICAgdmFyIHgsIHk7XG4gICAgdmFyIHV4ID0gdGhpcy5fdXg7XG4gICAgdmFyIHV5ID0gdGhpcy5fdXk7XG4gICAgdmFyIGxlbiA9IHRoaXMuX2xlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgdmFyIGNtZCA9IGRbaSsrXTtcblxuICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgIC8vXG4gICAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICAgIHhpID0gZFtpXTtcbiAgICAgICAgeWkgPSBkW2kgKyAxXTtcbiAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgeTAgPSB5aTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICB4MCA9IHhpID0gZFtpKytdO1xuICAgICAgICAgIHkwID0geWkgPSBkW2krK107XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4aSwgeWkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgeCA9IGRbaSsrXTtcbiAgICAgICAgICB5ID0gZFtpKytdOyAvLyBOb3QgZHJhdyB0b28gc21hbGwgc2VnIGJldHdlZW5cblxuICAgICAgICAgIGlmIChtYXRoQWJzKHggLSB4aSkgPiB1eCB8fCBtYXRoQWJzKHkgLSB5aSkgPiB1eSB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgeGkgPSB4O1xuICAgICAgICAgICAgeWkgPSB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgeGkgPSBkW2kgLSAyXTtcbiAgICAgICAgICB5aSA9IGRbaSAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgIHlpID0gZFtpIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICB2YXIgY3ggPSBkW2krK107XG4gICAgICAgICAgdmFyIGN5ID0gZFtpKytdO1xuICAgICAgICAgIHZhciByeCA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgcnkgPSBkW2krK107XG4gICAgICAgICAgdmFyIHRoZXRhID0gZFtpKytdO1xuICAgICAgICAgIHZhciBkVGhldGEgPSBkW2krK107XG4gICAgICAgICAgdmFyIHBzaSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgZnMgPSBkW2krK107XG4gICAgICAgICAgdmFyIHIgPSByeCA+IHJ5ID8gcnggOiByeTtcbiAgICAgICAgICB2YXIgc2NhbGVYID0gcnggPiByeSA/IDEgOiByeCAvIHJ5O1xuICAgICAgICAgIHZhciBzY2FsZVkgPSByeCA+IHJ5ID8gcnkgLyByeCA6IDE7XG4gICAgICAgICAgdmFyIGlzRWxsaXBzZSA9IE1hdGguYWJzKHJ4IC0gcnkpID4gMWUtMztcbiAgICAgICAgICB2YXIgZW5kQW5nbGUgPSB0aGV0YSArIGRUaGV0YTtcblxuICAgICAgICAgIGlmIChpc0VsbGlwc2UpIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUocHNpKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmFyYyhjeCwgY3ksIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAvLyDnm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICB4MCA9IG1hdGhDb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgIHkwID0gbWF0aFNpbih0aGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgeDAgPSB4aSA9IGRbaV07XG4gICAgICAgICAgeTAgPSB5aSA9IGRbaSArIDFdO1xuICAgICAgICAgIGN0eC5yZWN0KGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICB5aSA9IHkwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblBhdGhQcm94eS5DTUQgPSBDTUQ7XG52YXIgX2RlZmF1bHQgPSBQYXRoUHJveHk7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciB2MkNyZWF0ZSA9IF92ZWN0b3IuY3JlYXRlO1xudmFyIHYyRGlzdFNxdWFyZSA9IF92ZWN0b3IuZGlzdFNxdWFyZTtcblxuLyoqXG4gKiDmm7Lnur/ovoXliqnmqKHlnZdcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2N1cnZlXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgbWF0aFBvdyA9IE1hdGgucG93O1xudmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIEVQU0lMT04gPSAxZS04O1xudmFyIEVQU0lMT05fTlVNRVJJQyA9IDFlLTQ7XG52YXIgVEhSRUVfU1FSVCA9IG1hdGhTcXJ0KDMpO1xudmFyIE9ORV9USElSRCA9IDEgLyAzOyAvLyDkuLTml7blj5jph49cblxudmFyIF92MCA9IHYyQ3JlYXRlKCk7XG5cbnZhciBfdjEgPSB2MkNyZWF0ZSgpO1xuXG52YXIgX3YyID0gdjJDcmVhdGUoKTtcblxuZnVuY3Rpb24gaXNBcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gLUVQU0lMT04gJiYgdmFsIDwgRVBTSUxPTjtcbn1cblxuZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5YC8XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY0F0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gIHZhciBvbmV0ID0gMSAtIHQ7XG4gIHJldHVybiBvbmV0ICogb25ldCAqIChvbmV0ICogcDAgKyAzICogdCAqIHAxKSArIHQgKiB0ICogKHQgKiBwMyArIDMgKiBvbmV0ICogcDIpO1xufVxuLyoqXG4gKiDorqHnrpfkuInmrKHotJ3loZ7lsJTlr7zmlbDlgLxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljRGVyaXZhdGl2ZUF0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gIHZhciBvbmV0ID0gMSAtIHQ7XG4gIHJldHVybiAzICogKCgocDEgLSBwMCkgKiBvbmV0ICsgMiAqIChwMiAtIHAxKSAqIHQpICogb25ldCArIChwMyAtIHAyKSAqIHQgKiB0KTtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5qC577yM5L2/55So55ub6YeR5YWs5byPXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmoLnmlbDnm65cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljUm9vdEF0KHAwLCBwMSwgcDIsIHAzLCB2YWwsIHJvb3RzKSB7XG4gIC8vIEV2YWx1YXRlIHJvb3RzIG9mIGN1YmljIGZ1bmN0aW9uc1xuICB2YXIgYSA9IHAzICsgMyAqIChwMSAtIHAyKSAtIHAwO1xuICB2YXIgYiA9IDMgKiAocDIgLSBwMSAqIDIgKyBwMCk7XG4gIHZhciBjID0gMyAqIChwMSAtIHAwKTtcbiAgdmFyIGQgPSBwMCAtIHZhbDtcbiAgdmFyIEEgPSBiICogYiAtIDMgKiBhICogYztcbiAgdmFyIEIgPSBiICogYyAtIDkgKiBhICogZDtcbiAgdmFyIEMgPSBjICogYyAtIDMgKiBiICogZDtcbiAgdmFyIG4gPSAwO1xuXG4gIGlmIChpc0Fyb3VuZFplcm8oQSkgJiYgaXNBcm91bmRaZXJvKEIpKSB7XG4gICAgaWYgKGlzQXJvdW5kWmVybyhiKSkge1xuICAgICAgcm9vdHNbMF0gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdDEgPSAtYyAvIGI7IC8vdDEsIHQyLCB0MywgYiBpcyBub3QgemVyb1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpc2MgPSBCICogQiAtIDQgKiBBICogQztcblxuICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgIHZhciBLID0gQiAvIEE7XG4gICAgICB2YXIgdDEgPSAtYiAvIGEgKyBLOyAvLyB0MSwgYSBpcyBub3QgemVyb1xuXG4gICAgICB2YXIgdDIgPSAtSyAvIDI7IC8vIHQyLCB0M1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICB2YXIgWTEgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgKyBkaXNjU3FydCk7XG4gICAgICB2YXIgWTIgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgLSBkaXNjU3FydCk7XG5cbiAgICAgIGlmIChZMSA8IDApIHtcbiAgICAgICAgWTEgPSAtbWF0aFBvdygtWTEsIE9ORV9USElSRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBZMSA9IG1hdGhQb3coWTEsIE9ORV9USElSRCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChZMiA8IDApIHtcbiAgICAgICAgWTIgPSAtbWF0aFBvdygtWTIsIE9ORV9USElSRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBZMiA9IG1hdGhQb3coWTIsIE9ORV9USElSRCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0MSA9ICgtYiAtIChZMSArIFkyKSkgLyAoMyAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIFQgPSAoMiAqIEEgKiBiIC0gMyAqIGEgKiBCKSAvICgyICogbWF0aFNxcnQoQSAqIEEgKiBBKSk7XG4gICAgICB2YXIgdGhldGEgPSBNYXRoLmFjb3MoVCkgLyAzO1xuICAgICAgdmFyIEFTcXJ0ID0gbWF0aFNxcnQoQSk7XG4gICAgICB2YXIgdG1wID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHQxID0gKC1iIC0gMiAqIEFTcXJ0ICogdG1wKSAvICgzICogYSk7XG4gICAgICB2YXIgdDIgPSAoLWIgKyBBU3FydCAqICh0bXAgKyBUSFJFRV9TUVJUICogTWF0aC5zaW4odGhldGEpKSkgLyAoMyAqIGEpO1xuICAgICAgdmFyIHQzID0gKC1iICsgQVNxcnQgKiAodG1wIC0gVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgfVxuXG4gICAgICBpZiAodDMgPj0gMCAmJiB0MyA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5p6B6ZmQ5YC855qE5L2N572uXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IGV4dHJlbWFcbiAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5pWw55uuXG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY0V4dHJlbWEocDAsIHAxLCBwMiwgcDMsIGV4dHJlbWEpIHtcbiAgdmFyIGIgPSA2ICogcDIgLSAxMiAqIHAxICsgNiAqIHAwO1xuICB2YXIgYSA9IDkgKiBwMSArIDMgKiBwMyAtIDMgKiBwMCAtIDkgKiBwMjtcbiAgdmFyIGMgPSAzICogcDEgLSAzICogcDA7XG4gIHZhciBuID0gMDtcblxuICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgdmFyIHQxID0gLWMgLyBiO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuXG4gICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgZXh0cmVtYVswXSA9IC1iIC8gKDIgKiBhKTtcbiAgICB9IGVsc2UgaWYgKGRpc2MgPiAwKSB7XG4gICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICB2YXIgdDIgPSAoLWIgLSBkaXNjU3FydCkgLyAoMiAqIGEpO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIGV4dHJlbWFbbisrXSA9IHQyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuO1xufVxuLyoqXG4gKiDnu4bliIbkuInmrKHotJ3loZ7lsJTmm7Lnur9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIGN1YmljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHAzLCB0LCBvdXQpIHtcbiAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgdmFyIHAxMiA9IChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgdmFyIHAyMyA9IChwMyAtIHAyKSAqIHQgKyBwMjtcbiAgdmFyIHAwMTIgPSAocDEyIC0gcDAxKSAqIHQgKyBwMDE7XG4gIHZhciBwMTIzID0gKHAyMyAtIHAxMikgKiB0ICsgcDEyO1xuICB2YXIgcDAxMjMgPSAocDEyMyAtIHAwMTIpICogdCArIHAwMTI7IC8vIFNlZzBcblxuICBvdXRbMF0gPSBwMDtcbiAgb3V0WzFdID0gcDAxO1xuICBvdXRbMl0gPSBwMDEyO1xuICBvdXRbM10gPSBwMDEyMzsgLy8gU2VnMVxuXG4gIG91dFs0XSA9IHAwMTIzO1xuICBvdXRbNV0gPSBwMTIzO1xuICBvdXRbNl0gPSBwMjM7XG4gIG91dFs3XSA9IHAzO1xufVxuLyoqXG4gKiDmipXlsITngrnliLDkuInmrKHotJ3loZ7lsJTmm7Lnur/kuIrvvIzov5Tlm57mipXlsITot53nprvjgIJcbiAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gKiBAcGFyYW0ge251bWJlcn0geTNcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW291dF0g5oqV5bCE54K5XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY1Byb2plY3RQb2ludCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHgsIHksIG91dCkge1xuICAvLyBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI3Byb2plY3Rpb25zXG4gIHZhciB0O1xuICB2YXIgaW50ZXJ2YWwgPSAwLjAwNTtcbiAgdmFyIGQgPSBJbmZpbml0eTtcbiAgdmFyIHByZXY7XG4gIHZhciBuZXh0O1xuICB2YXIgZDE7XG4gIHZhciBkMjtcbiAgX3YwWzBdID0geDtcbiAgX3YwWzFdID0geTsgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gIC8vIFBFTkRJTkdcblxuICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgIF92MVswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIF90KTtcbiAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBfdCk7XG4gICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuXG4gICAgaWYgKGQxIDwgZCkge1xuICAgICAgdCA9IF90O1xuICAgICAgZCA9IGQxO1xuICAgIH1cbiAgfVxuXG4gIGQgPSBJbmZpbml0eTsgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHByZXYgPSB0IC0gaW50ZXJ2YWw7XG4gICAgbmV4dCA9IHQgKyBpbnRlcnZhbDsgLy8gdCAtIGludGVydmFsXG5cbiAgICBfdjFbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBwcmV2KTtcbiAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBwcmV2KTtcbiAgICBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgdCA9IHByZXY7XG4gICAgICBkID0gZDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgX3YyWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgbmV4dCk7XG4gICAgICBfdjJbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBuZXh0KTtcbiAgICAgIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcblxuICAgICAgaWYgKG5leHQgPD0gMSAmJiBkMiA8IGQpIHtcbiAgICAgICAgdCA9IG5leHQ7XG4gICAgICAgIGQgPSBkMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVydmFsICo9IDAuNTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gdFxuXG5cbiAgaWYgKG91dCkge1xuICAgIG91dFswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgIG91dFsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuICB9IC8vIGNvbnNvbGUubG9nKGludGVydmFsLCBpKTtcblxuXG4gIHJldHVybiBtYXRoU3FydChkKTtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5YC8XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY0F0KHAwLCBwMSwgcDIsIHQpIHtcbiAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgcmV0dXJuIG9uZXQgKiAob25ldCAqIHAwICsgMiAqIHQgKiBwMSkgKyB0ICogdCAqIHAyO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlr7zmlbDlgLxcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljRGVyaXZhdGl2ZUF0KHAwLCBwMSwgcDIsIHQpIHtcbiAgcmV0dXJuIDIgKiAoKDEgLSB0KSAqIChwMSAtIHAwKSArIHQgKiAocDIgLSBwMSkpO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTmlrnnqIvmoLlcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IHJvb3RzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljUm9vdEF0KHAwLCBwMSwgcDIsIHZhbCwgcm9vdHMpIHtcbiAgdmFyIGEgPSBwMCAtIDIgKiBwMSArIHAyO1xuICB2YXIgYiA9IDIgKiAocDEgLSBwMCk7XG4gIHZhciBjID0gcDAgLSB2YWw7XG4gIHZhciBuID0gMDtcblxuICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgdmFyIHQxID0gLWMgLyBiO1xuXG4gICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcblxuICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgIHZhciB0MSA9IC1iIC8gKDIgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuO1xufVxuLyoqXG4gKiDorqHnrpfkuozmrKHotJ3loZ7lsJTmlrnnqIvmnoHpmZDlgLxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNFeHRyZW11bShwMCwgcDEsIHAyKSB7XG4gIHZhciBkaXZpZGVyID0gcDAgKyBwMiAtIDIgKiBwMTtcblxuICBpZiAoZGl2aWRlciA9PT0gMCkge1xuICAgIC8vIHAxIGlzIGNlbnRlciBvZiBwMCBhbmQgcDJcbiAgICByZXR1cm4gMC41O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAocDAgLSBwMSkgLyBkaXZpZGVyO1xuICB9XG59XG4vKipcbiAqIOe7huWIhuS6jOasoei0neWhnuWwlOabsue6v1xuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IG91dFxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHQsIG91dCkge1xuICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTsgLy8gU2VnMFxuXG4gIG91dFswXSA9IHAwO1xuICBvdXRbMV0gPSBwMDE7XG4gIG91dFsyXSA9IHAwMTI7IC8vIFNlZzFcblxuICBvdXRbM10gPSBwMDEyO1xuICBvdXRbNF0gPSBwMTI7XG4gIG91dFs1XSA9IHAyO1xufVxuLyoqXG4gKiDmipXlsITngrnliLDkuozmrKHotJ3loZ7lsJTmm7Lnur/kuIrvvIzov5Tlm57mipXlsITot53nprvjgIJcbiAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXQg5oqV5bCE54K5XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSwgb3V0KSB7XG4gIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgdmFyIHQ7XG4gIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICB2YXIgZCA9IEluZmluaXR5O1xuICBfdjBbMF0gPSB4O1xuICBfdjBbMV0gPSB5OyAvLyDlhYjnspfnlaXkvLDorqHkuIDkuIvlj6/og73nmoTmnIDlsI/ot53nprvnmoQgdCDlgLxcbiAgLy8gUEVORElOR1xuXG4gIGZvciAodmFyIF90ID0gMDsgX3QgPCAxOyBfdCArPSAwLjA1KSB7XG4gICAgX3YxWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgX3QpO1xuICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIF90KTtcbiAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuXG4gICAgaWYgKGQxIDwgZCkge1xuICAgICAgdCA9IF90O1xuICAgICAgZCA9IGQxO1xuICAgIH1cbiAgfVxuXG4gIGQgPSBJbmZpbml0eTsgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgIHZhciBuZXh0ID0gdCArIGludGVydmFsOyAvLyB0IC0gaW50ZXJ2YWxcblxuICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHByZXYpO1xuICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHByZXYpO1xuICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgdCA9IHByZXY7XG4gICAgICBkID0gZDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgX3YyWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgbmV4dCk7XG4gICAgICBfdjJbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBuZXh0KTtcbiAgICAgIHZhciBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG5cbiAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgIHQgPSBuZXh0O1xuICAgICAgICBkID0gZDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHRcblxuXG4gIGlmIChvdXQpIHtcbiAgICBvdXRbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0KTtcbiAgICBvdXRbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0KTtcbiAgfSAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG5cblxuICByZXR1cm4gbWF0aFNxcnQoZCk7XG59XG5cbmV4cG9ydHMuY3ViaWNBdCA9IGN1YmljQXQ7XG5leHBvcnRzLmN1YmljRGVyaXZhdGl2ZUF0ID0gY3ViaWNEZXJpdmF0aXZlQXQ7XG5leHBvcnRzLmN1YmljUm9vdEF0ID0gY3ViaWNSb290QXQ7XG5leHBvcnRzLmN1YmljRXh0cmVtYSA9IGN1YmljRXh0cmVtYTtcbmV4cG9ydHMuY3ViaWNTdWJkaXZpZGUgPSBjdWJpY1N1YmRpdmlkZTtcbmV4cG9ydHMuY3ViaWNQcm9qZWN0UG9pbnQgPSBjdWJpY1Byb2plY3RQb2ludDtcbmV4cG9ydHMucXVhZHJhdGljQXQgPSBxdWFkcmF0aWNBdDtcbmV4cG9ydHMucXVhZHJhdGljRGVyaXZhdGl2ZUF0ID0gcXVhZHJhdGljRGVyaXZhdGl2ZUF0O1xuZXhwb3J0cy5xdWFkcmF0aWNSb290QXQgPSBxdWFkcmF0aWNSb290QXQ7XG5leHBvcnRzLnF1YWRyYXRpY0V4dHJlbXVtID0gcXVhZHJhdGljRXh0cmVtdW07XG5leHBvcnRzLnF1YWRyYXRpY1N1YmRpdmlkZSA9IHF1YWRyYXRpY1N1YmRpdmlkZTtcbmV4cG9ydHMucXVhZHJhdGljUHJvamVjdFBvaW50ID0gcXVhZHJhdGljUHJvamVjdFBvaW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdmVjMiA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcblxudmFyIGN1cnZlID0gcmVxdWlyZShcIi4vY3VydmVcIik7XG5cbi8qKlxuICogQGF1dGhvciBZaSBTaGVuKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgbWF0aE1pbiA9IE1hdGgubWluO1xudmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIFBJMiA9IE1hdGguUEkgKiAyO1xudmFyIHN0YXJ0ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBlbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGV4dHJlbWl0eSA9IHZlYzIuY3JlYXRlKCk7XG4vKipcbiAqIOS7jumhtueCueaVsOe7hOS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9pbnRzIOmhtueCueaVsOe7hFxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICovXG5cbmZ1bmN0aW9uIGZyb21Qb2ludHMocG9pbnRzLCBtaW4sIG1heCkge1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwID0gcG9pbnRzWzBdO1xuICB2YXIgbGVmdCA9IHBbMF07XG4gIHZhciByaWdodCA9IHBbMF07XG4gIHZhciB0b3AgPSBwWzFdO1xuICB2YXIgYm90dG9tID0gcFsxXTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHAgPSBwb2ludHNbaV07XG4gICAgbGVmdCA9IG1hdGhNaW4obGVmdCwgcFswXSk7XG4gICAgcmlnaHQgPSBtYXRoTWF4KHJpZ2h0LCBwWzBdKTtcbiAgICB0b3AgPSBtYXRoTWluKHRvcCwgcFsxXSk7XG4gICAgYm90dG9tID0gbWF0aE1heChib3R0b20sIHBbMV0pO1xuICB9XG5cbiAgbWluWzBdID0gbGVmdDtcbiAgbWluWzFdID0gdG9wO1xuICBtYXhbMF0gPSByaWdodDtcbiAgbWF4WzFdID0gYm90dG9tO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geDBcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gKiBAcGFyYW0ge251bWJlcn0geTFcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tTGluZSh4MCwgeTAsIHgxLCB5MSwgbWluLCBtYXgpIHtcbiAgbWluWzBdID0gbWF0aE1pbih4MCwgeDEpO1xuICBtaW5bMV0gPSBtYXRoTWluKHkwLCB5MSk7XG4gIG1heFswXSA9IG1hdGhNYXgoeDAsIHgxKTtcbiAgbWF4WzFdID0gbWF0aE1heCh5MCwgeTEpO1xufVxuXG52YXIgeERpbSA9IFtdO1xudmFyIHlEaW0gPSBbXTtcbi8qKlxuICog5LuO5LiJ6Zi26LSd5aGe5bCU5puy57q/KHAwLCBwMSwgcDIsIHAzKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICovXG5cbmZ1bmN0aW9uIGZyb21DdWJpYyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbiwgbWF4KSB7XG4gIHZhciBjdWJpY0V4dHJlbWEgPSBjdXJ2ZS5jdWJpY0V4dHJlbWE7XG4gIHZhciBjdWJpY0F0ID0gY3VydmUuY3ViaWNBdDtcbiAgdmFyIGk7XG4gIHZhciBuID0gY3ViaWNFeHRyZW1hKHgwLCB4MSwgeDIsIHgzLCB4RGltKTtcbiAgbWluWzBdID0gSW5maW5pdHk7XG4gIG1pblsxXSA9IEluZmluaXR5O1xuICBtYXhbMF0gPSAtSW5maW5pdHk7XG4gIG1heFsxXSA9IC1JbmZpbml0eTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB4RGltW2ldKTtcbiAgICBtaW5bMF0gPSBtYXRoTWluKHgsIG1pblswXSk7XG4gICAgbWF4WzBdID0gbWF0aE1heCh4LCBtYXhbMF0pO1xuICB9XG5cbiAgbiA9IGN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgeURpbSk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgeURpbVtpXSk7XG4gICAgbWluWzFdID0gbWF0aE1pbih5LCBtaW5bMV0pO1xuICAgIG1heFsxXSA9IG1hdGhNYXgoeSwgbWF4WzFdKTtcbiAgfVxuXG4gIG1pblswXSA9IG1hdGhNaW4oeDAsIG1pblswXSk7XG4gIG1heFswXSA9IG1hdGhNYXgoeDAsIG1heFswXSk7XG4gIG1pblswXSA9IG1hdGhNaW4oeDMsIG1pblswXSk7XG4gIG1heFswXSA9IG1hdGhNYXgoeDMsIG1heFswXSk7XG4gIG1pblsxXSA9IG1hdGhNaW4oeTAsIG1pblsxXSk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTAsIG1heFsxXSk7XG4gIG1pblsxXSA9IG1hdGhNaW4oeTMsIG1pblsxXSk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTMsIG1heFsxXSk7XG59XG4vKipcbiAqIOS7juS6jOmYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tUXVhZHJhdGljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIG1pbiwgbWF4KSB7XG4gIHZhciBxdWFkcmF0aWNFeHRyZW11bSA9IGN1cnZlLnF1YWRyYXRpY0V4dHJlbXVtO1xuICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZS5xdWFkcmF0aWNBdDsgLy8gRmluZCBleHRyZW1pdGllcywgd2hlcmUgZGVyaXZhdGl2ZSBpbiB4IGRpbSBvciB5IGRpbSBpcyB6ZXJvXG5cbiAgdmFyIHR4ID0gbWF0aE1heChtYXRoTWluKHF1YWRyYXRpY0V4dHJlbXVtKHgwLCB4MSwgeDIpLCAxKSwgMCk7XG4gIHZhciB0eSA9IG1hdGhNYXgobWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh5MCwgeTEsIHkyKSwgMSksIDApO1xuICB2YXIgeCA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHR4KTtcbiAgdmFyIHkgPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0eSk7XG4gIG1pblswXSA9IG1hdGhNaW4oeDAsIHgyLCB4KTtcbiAgbWluWzFdID0gbWF0aE1pbih5MCwgeTIsIHkpO1xuICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MiwgeCk7XG4gIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkyLCB5KTtcbn1cbi8qKlxuICog5LuO5ZyG5byn5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICogQG1ldGhvZFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcGFyYW0ge251bWJlcn0gcnhcbiAqIEBwYXJhbSB7bnVtYmVyfSByeVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRBbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IGFudGljbG9ja3dpc2VcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gKi9cblxuXG5mdW5jdGlvbiBmcm9tQXJjKHgsIHksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIG1pbiwgbWF4KSB7XG4gIHZhciB2ZWMyTWluID0gdmVjMi5taW47XG4gIHZhciB2ZWMyTWF4ID0gdmVjMi5tYXg7XG4gIHZhciBkaWZmID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcblxuICBpZiAoZGlmZiAlIFBJMiA8IDFlLTQgJiYgZGlmZiA+IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIG1pblswXSA9IHggLSByeDtcbiAgICBtaW5bMV0gPSB5IC0gcnk7XG4gICAgbWF4WzBdID0geCArIHJ4O1xuICAgIG1heFsxXSA9IHkgKyByeTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGFydFswXSA9IG1hdGhDb3Moc3RhcnRBbmdsZSkgKiByeCArIHg7XG4gIHN0YXJ0WzFdID0gbWF0aFNpbihzdGFydEFuZ2xlKSAqIHJ5ICsgeTtcbiAgZW5kWzBdID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIHg7XG4gIGVuZFsxXSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyB5O1xuICB2ZWMyTWluKG1pbiwgc3RhcnQsIGVuZCk7XG4gIHZlYzJNYXgobWF4LCBzdGFydCwgZW5kKTsgLy8gVGhyZXNoIHRvIFswLCBNYXRoLlBJICogMl1cblxuICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSAlIFBJMjtcblxuICBpZiAoc3RhcnRBbmdsZSA8IDApIHtcbiAgICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSArIFBJMjtcbiAgfVxuXG4gIGVuZEFuZ2xlID0gZW5kQW5nbGUgJSBQSTI7XG5cbiAgaWYgKGVuZEFuZ2xlIDwgMCkge1xuICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgKyBQSTI7XG4gIH1cblxuICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlICYmICFhbnRpY2xvY2t3aXNlKSB7XG4gICAgZW5kQW5nbGUgKz0gUEkyO1xuICB9IGVsc2UgaWYgKHN0YXJ0QW5nbGUgPCBlbmRBbmdsZSAmJiBhbnRpY2xvY2t3aXNlKSB7XG4gICAgc3RhcnRBbmdsZSArPSBQSTI7XG4gIH1cblxuICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgIHZhciB0bXAgPSBlbmRBbmdsZTtcbiAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGU7XG4gICAgc3RhcnRBbmdsZSA9IHRtcDtcbiAgfSAvLyB2YXIgbnVtYmVyID0gMDtcbiAgLy8gdmFyIHN0ZXAgPSAoYW50aWNsb2Nrd2lzZSA/IC1NYXRoLlBJIDogTWF0aC5QSSkgLyAyO1xuXG5cbiAgZm9yICh2YXIgYW5nbGUgPSAwOyBhbmdsZSA8IGVuZEFuZ2xlOyBhbmdsZSArPSBNYXRoLlBJIC8gMikge1xuICAgIGlmIChhbmdsZSA+IHN0YXJ0QW5nbGUpIHtcbiAgICAgIGV4dHJlbWl0eVswXSA9IG1hdGhDb3MoYW5nbGUpICogcnggKyB4O1xuICAgICAgZXh0cmVtaXR5WzFdID0gbWF0aFNpbihhbmdsZSkgKiByeSArIHk7XG4gICAgICB2ZWMyTWluKG1pbiwgZXh0cmVtaXR5LCBtaW4pO1xuICAgICAgdmVjMk1heChtYXgsIGV4dHJlbWl0eSwgbWF4KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5mcm9tUG9pbnRzID0gZnJvbVBvaW50cztcbmV4cG9ydHMuZnJvbUxpbmUgPSBmcm9tTGluZTtcbmV4cG9ydHMuZnJvbUN1YmljID0gZnJvbUN1YmljO1xuZXhwb3J0cy5mcm9tUXVhZHJhdGljID0gZnJvbVF1YWRyYXRpYztcbmV4cG9ydHMuZnJvbUFyYyA9IGZyb21BcmM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvYmJveC5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BhdGhQcm94eVwiKTtcblxudmFyIGxpbmUgPSByZXF1aXJlKFwiLi9saW5lXCIpO1xuXG52YXIgY3ViaWMgPSByZXF1aXJlKFwiLi9jdWJpY1wiKTtcblxudmFyIHF1YWRyYXRpYyA9IHJlcXVpcmUoXCIuL3F1YWRyYXRpY1wiKTtcblxudmFyIGFyYyA9IHJlcXVpcmUoXCIuL2FyY1wiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIG5vcm1hbGl6ZVJhZGlhbiA9IF91dGlsLm5vcm1hbGl6ZVJhZGlhbjtcblxudmFyIGN1cnZlID0gcmVxdWlyZShcIi4uL2NvcmUvY3VydmVcIik7XG5cbnZhciB3aW5kaW5nTGluZSA9IHJlcXVpcmUoXCIuL3dpbmRpbmdMaW5lXCIpO1xuXG52YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbnZhciBFUFNJTE9OID0gMWUtNDtcblxuZnVuY3Rpb24gaXNBcm91bmRFcXVhbChhLCBiKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBFUFNJTE9OO1xufSAvLyDkuLTml7bmlbDnu4RcblxuXG52YXIgcm9vdHMgPSBbLTEsIC0xLCAtMV07XG52YXIgZXh0cmVtYSA9IFstMSwgLTFdO1xuXG5mdW5jdGlvbiBzd2FwRXh0cmVtYSgpIHtcbiAgdmFyIHRtcCA9IGV4dHJlbWFbMF07XG4gIGV4dHJlbWFbMF0gPSBleHRyZW1hWzFdO1xuICBleHRyZW1hWzFdID0gdG1wO1xufVxuXG5mdW5jdGlvbiB3aW5kaW5nQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5KSB7XG4gIC8vIFF1aWNrIHJlamVjdFxuICBpZiAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIgJiYgeSA+IHkzIHx8IHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyICYmIHkgPCB5Mykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIG5Sb290cyA9IGN1cnZlLmN1YmljUm9vdEF0KHkwLCB5MSwgeTIsIHkzLCB5LCByb290cyk7XG5cbiAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHZhciB3ID0gMDtcbiAgICB2YXIgbkV4dHJlbWEgPSAtMTtcbiAgICB2YXIgeTBfLCB5MV87XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHJvb3RzW2ldOyAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cblxuICAgICAgdmFyIHVuaXQgPSB0ID09PSAwIHx8IHQgPT09IDEgPyAwLjUgOiAxO1xuICAgICAgdmFyIHhfID0gY3VydmUuY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG5cbiAgICAgIGlmICh4XyA8IHgpIHtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobkV4dHJlbWEgPCAwKSB7XG4gICAgICAgIG5FeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hKHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hKTtcblxuICAgICAgICBpZiAoZXh0cmVtYVsxXSA8IGV4dHJlbWFbMF0gJiYgbkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgc3dhcEV4dHJlbWEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHkwXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMF0pO1xuXG4gICAgICAgIGlmIChuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICB5MV8gPSBjdXJ2ZS5jdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobkV4dHJlbWEgPT0gMikge1xuICAgICAgICAvLyDliIbmiJDkuInmrrXljZXosIPlh73mlbBcbiAgICAgICAgaWYgKHQgPCBleHRyZW1hWzBdKSB7XG4gICAgICAgICAgdyArPSB5MF8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgZXh0cmVtYVsxXSkge1xuICAgICAgICAgIHcgKz0geTFfIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0geTMgPCB5MV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIOWIhuaIkOS4pOauteWNleiwg+WHveaVsFxuICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICB3ICs9IHkwXyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0geTMgPCB5MF8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxufVxuXG5mdW5jdGlvbiB3aW5kaW5nUXVhZHJhdGljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgLy8gUXVpY2sgcmVqZWN0XG4gIGlmICh5ID4geTAgJiYgeSA+IHkxICYmIHkgPiB5MiB8fCB5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5Mikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIG5Sb290cyA9IGN1cnZlLnF1YWRyYXRpY1Jvb3RBdCh5MCwgeTEsIHkyLCB5LCByb290cyk7XG5cbiAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHZhciB0ID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5Mik7XG5cbiAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgdmFyIHcgPSAwO1xuICAgICAgdmFyIHlfID0gY3VydmUucXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJvb3RzOyBpKyspIHtcbiAgICAgICAgLy8gUmVtb3ZlIG9uZSBlbmRwb2ludC5cbiAgICAgICAgdmFyIHVuaXQgPSByb290c1tpXSA9PT0gMCB8fCByb290c1tpXSA9PT0gMSA/IDAuNSA6IDE7XG4gICAgICAgIHZhciB4XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHJvb3RzW2ldKTtcblxuICAgICAgICBpZiAoeF8gPCB4KSB7XG4gICAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm9vdHNbaV0gPCB0KSB7XG4gICAgICAgICAgdyArPSB5XyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0geTIgPCB5XyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIG9uZSBlbmRwb2ludC5cbiAgICAgIHZhciB1bml0ID0gcm9vdHNbMF0gPT09IDAgfHwgcm9vdHNbMF0gPT09IDEgPyAwLjUgOiAxO1xuICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbMF0pO1xuXG4gICAgICBpZiAoeF8gPCB4KSB7XG4gICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHkyIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgfVxuICB9XG59IC8vIFRPRE9cbi8vIEFyYyDml4vovaxcblxuXG5mdW5jdGlvbiB3aW5kaW5nQXJjKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHgsIHkpIHtcbiAgeSAtPSBjeTtcblxuICBpZiAoeSA+IHIgfHwgeSA8IC1yKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgdG1wID0gTWF0aC5zcXJ0KHIgKiByIC0geSAqIHkpO1xuICByb290c1swXSA9IC10bXA7XG4gIHJvb3RzWzFdID0gdG1wO1xuICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG5cbiAgaWYgKGRpZmYgPCAxZS00KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoZGlmZiAlIFBJMiA8IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIHN0YXJ0QW5nbGUgPSAwO1xuICAgIGVuZEFuZ2xlID0gUEkyO1xuICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuXG4gICAgaWYgKHggPj0gcm9vdHNbMF0gKyBjeCAmJiB4IDw9IHJvb3RzWzFdICsgY3gpIHtcbiAgICAgIHJldHVybiBkaXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4odG1wKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHN0YXJ0QW5nbGUpO1xuICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgfVxuXG4gIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICBlbmRBbmdsZSArPSBQSTI7XG4gIH1cblxuICB2YXIgdyA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICB2YXIgeF8gPSByb290c1tpXTtcblxuICAgIGlmICh4XyArIGN4ID4geCkge1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4Xyk7XG4gICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcblxuICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICBhbmdsZSA9IFBJMiArIGFuZ2xlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSA8PSBlbmRBbmdsZSB8fCBhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKSB7XG4gICAgICAgIGlmIChhbmdsZSA+IE1hdGguUEkgLyAyICYmIGFuZ2xlIDwgTWF0aC5QSSAqIDEuNSkge1xuICAgICAgICAgIGRpciA9IC1kaXI7XG4gICAgICAgIH1cblxuICAgICAgICB3ICs9IGRpcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdztcbn1cblxuZnVuY3Rpb24gY29udGFpblBhdGgoZGF0YSwgbGluZVdpZHRoLCBpc1N0cm9rZSwgeCwgeSkge1xuICB2YXIgdyA9IDA7XG4gIHZhciB4aSA9IDA7XG4gIHZhciB5aSA9IDA7XG4gIHZhciB4MCA9IDA7XG4gIHZhciB5MCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICB2YXIgY21kID0gZGF0YVtpKytdOyAvLyBCZWdpbiBhIG5ldyBzdWJwYXRoXG5cbiAgICBpZiAoY21kID09PSBDTUQuTSAmJiBpID4gMSkge1xuICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc3VicGF0aFxuICAgICAgaWYgKCFpc1N0cm9rZSkge1xuICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgIH0gLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAvLyBpZiAodyAhPT0gMCkge1xuICAgICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgICAgLy8gfVxuXG4gICAgfVxuXG4gICAgaWYgKGkgPT0gMSkge1xuICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgIC8vXG4gICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgeGkgPSBkYXRhW2ldO1xuICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcbiAgICAgIHgwID0geGk7XG4gICAgICB5MCA9IHlpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICBjYXNlIENNRC5NOlxuICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgIHhpID0geDA7XG4gICAgICAgIHlpID0geTA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5MOlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAobGluZS5jb250YWluU3Ryb2tlKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOT1RFIOWcqOesrOS4gOS4quWRveS7pOS4uiBMLCBDLCBRIOeahOaXtuWAmeS8muiuoeeul+WHuiBOYU5cbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5DOlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAoY3ViaWMuY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdDdWJpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5ROlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAocXVhZHJhdGljLmNvbnRhaW5TdHJva2UoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdRdWFkcmF0aWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5BOlxuICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgdGhldGEgPSBkYXRhW2krK107XG4gICAgICAgIHZhciBkVGhldGEgPSBkYXRhW2krK107IC8vIFRPRE8gQXJjIOaXi+i9rFxuXG4gICAgICAgIHZhciBwc2kgPSBkYXRhW2krK107XG4gICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHgxID0gTWF0aC5jb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgdmFyIHkxID0gTWF0aC5zaW4odGhldGEpICogcnkgKyBjeTsgLy8g5LiN5piv55u05o6l5L2/55SoIGFyYyDlkb3ku6RcblxuICAgICAgICBpZiAoaSA+IDEpIHtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgIHkwID0geTE7XG4gICAgICAgIH0gLy8genIg5L2/55Soc2NhbGXmnaXmqKHmi5/mpK3lnIYsIOi/memHjOS5n+WvuXjlgZrkuIDlrprnmoTnvKnmlL5cblxuXG4gICAgICAgIHZhciBfeCA9ICh4IC0gY3gpICogcnkgLyByeCArIGN4O1xuXG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChhcmMuY29udGFpblN0cm9rZShjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsIGxpbmVXaWR0aCwgX3gsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdyArPSB3aW5kaW5nQXJjKGN4LCBjeSwgcnksIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgYW50aWNsb2Nrd2lzZSwgX3gsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgeGkgPSBNYXRoLmNvcyh0aGV0YSArIGRUaGV0YSkgKiByeCArIGN4O1xuICAgICAgICB5aSA9IE1hdGguc2luKHRoZXRhICsgZFRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5SOlxuICAgICAgICB4MCA9IHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2krK107XG4gICAgICAgIHZhciB4MSA9IHgwICsgd2lkdGg7XG4gICAgICAgIHZhciB5MSA9IHkwICsgaGVpZ2h0O1xuXG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChsaW5lLmNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTAsIGxpbmVXaWR0aCwgeCwgeSkgfHwgbGluZS5jb250YWluU3Ryb2tlKHgxLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHx8IGxpbmUuY29udGFpblN0cm9rZSh4MSwgeTEsIHgwLCB5MSwgbGluZVdpZHRoLCB4LCB5KSB8fCBsaW5lLmNvbnRhaW5TdHJva2UoeDAsIHkxLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGSVhNRSBDbG9ja3dpc2UgP1xuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDEsIHkwLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDAsIHkxLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChsaW5lLmNvbnRhaW5TdHJva2UoeGksIHlpLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDbG9zZSBhIHN1YnBhdGhcbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTsgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgLy8gRklYTUUgc3VicGF0aHMgbWF5IG92ZXJsYXBcbiAgICAgICAgICAvLyBpZiAodyAhPT0gMCkge1xuICAgICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgIH1cblxuICAgICAgICB4aSA9IHgwO1xuICAgICAgICB5aSA9IHkwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoIWlzU3Ryb2tlICYmICFpc0Fyb3VuZEVxdWFsKHlpLCB5MCkpIHtcbiAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KSB8fCAwO1xuICB9XG5cbiAgcmV0dXJuIHcgIT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW4ocGF0aERhdGEsIHgsIHkpIHtcbiAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCAwLCBmYWxzZSwgeCwgeSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UocGF0aERhdGEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICByZXR1cm4gY29udGFpblBhdGgocGF0aERhdGEsIGxpbmVXaWR0aCwgdHJ1ZSwgeCwgeSk7XG59XG5cbmV4cG9ydHMuY29udGFpbiA9IGNvbnRhaW47XG5leHBvcnRzLmNvbnRhaW5TdHJva2UgPSBjb250YWluU3Ryb2tlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog57q/5q615YyF5ZCr5Yik5patXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgdmFyIF9hID0gMDtcbiAgdmFyIF9iID0geDA7IC8vIFF1aWNrIHJlamVjdFxuXG4gIGlmICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCB8fCB5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCB8fCB4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCB8fCB4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh4MCAhPT0geDEpIHtcbiAgICBfYSA9ICh5MCAtIHkxKSAvICh4MCAtIHgxKTtcbiAgICBfYiA9ICh4MCAqIHkxIC0geDEgKiB5MCkgLyAoeDAgLSB4MSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggLSB4MCkgPD0gX2wgLyAyO1xuICB9XG5cbiAgdmFyIHRtcCA9IF9hICogeCAtIHkgKyBfYjtcblxuICB2YXIgX3MgPSB0bXAgKiB0bXAgLyAoX2EgKiBfYSArIDEpO1xuXG4gIHJldHVybiBfcyA8PSBfbCAvIDIgKiBfbCAvIDI7XG59XG5cbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN1cnZlID0gcmVxdWlyZShcIi4uL2NvcmUvY3VydmVcIik7XG5cbi8qKlxuICog5LiJ5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4M1xuICogQHBhcmFtICB7bnVtYmVyfSAgeTNcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIGxpbmVXaWR0aCwgeCwgeSkge1xuICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIF9sID0gbGluZVdpZHRoOyAvLyBRdWljayByZWplY3RcblxuICBpZiAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wgJiYgeSA+IHkzICsgX2wgfHwgeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgJiYgeSA8IHkyIC0gX2wgJiYgeSA8IHkzIC0gX2wgfHwgeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wgJiYgeCA+IHgzICsgX2wgfHwgeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wgJiYgeCA8IHgzIC0gX2wpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZCA9IGN1cnZlLmN1YmljUHJvamVjdFBvaW50KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSwgbnVsbCk7XG4gIHJldHVybiBkIDw9IF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi9jdWJpYy5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9jdXJ2ZSA9IHJlcXVpcmUoXCIuLi9jb3JlL2N1cnZlXCIpO1xuXG52YXIgcXVhZHJhdGljUHJvamVjdFBvaW50ID0gX2N1cnZlLnF1YWRyYXRpY1Byb2plY3RQb2ludDtcblxuLyoqXG4gKiDkuozmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udGFpblN0cm9rZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbCA9IGxpbmVXaWR0aDsgLy8gUXVpY2sgcmVqZWN0XG5cbiAgaWYgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sIHx8IHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sIHx8IHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sICYmIHggPiB4MiArIF9sIHx8IHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGQgPSBxdWFkcmF0aWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSwgbnVsbCk7XG4gIHJldHVybiBkIDw9IF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvY29udGFpbi9xdWFkcmF0aWMuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBub3JtYWxpemVSYWRpYW4gPSBfdXRpbC5ub3JtYWxpemVSYWRpYW47XG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4vKipcbiAqIOWchuW8p+aPj+i+ueWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgY3hcbiAqIEBwYXJhbSAge251bWJlcn0gIGN5XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICByXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBzdGFydEFuZ2xlXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBlbmRBbmdsZVxuICogQHBhcmFtICB7Ym9vbGVhbn0gIGFudGljbG9ja3dpc2VcbiAqIEBwYXJhbSAge251bWJlcn0gbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gIHggLT0gY3g7XG4gIHkgLT0gY3k7XG4gIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gIGlmIChkIC0gX2wgPiByIHx8IGQgKyBfbCA8IHIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAlIFBJMiA8IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeCk7XG5cbiAgaWYgKGFuZ2xlIDwgMCkge1xuICAgIGFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHJldHVybiBhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlIHx8IGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGU7XG59XG5cbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhZGlhbihhbmdsZSkge1xuICBhbmdsZSAlPSBQSTI7XG5cbiAgaWYgKGFuZ2xlIDwgMCkge1xuICAgIGFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHJldHVybiBhbmdsZTtcbn1cblxuZXhwb3J0cy5ub3JtYWxpemVSYWRpYW4gPSBub3JtYWxpemVSYWRpYW47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gd2luZGluZ0xpbmUoeDAsIHkwLCB4MSwgeTEsIHgsIHkpIHtcbiAgaWYgKHkgPiB5MCAmJiB5ID4geTEgfHwgeSA8IHkwICYmIHkgPCB5MSkge1xuICAgIHJldHVybiAwO1xuICB9IC8vIElnbm9yZSBob3Jpem9udGFsIGxpbmVcblxuXG4gIGlmICh5MSA9PT0geTApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBkaXIgPSB5MSA8IHkwID8gMSA6IC0xO1xuICB2YXIgdCA9ICh5IC0geTApIC8gKHkxIC0geTApOyAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cblxuICBpZiAodCA9PT0gMSB8fCB0ID09PSAwKSB7XG4gICAgZGlyID0geTEgPCB5MCA/IDAuNSA6IC0wLjU7XG4gIH1cblxuICB2YXIgeF8gPSB0ICogKHgxIC0geDApICsgeDA7XG4gIHJldHVybiB4XyA+IHggPyBkaXIgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRpbmdMaW5lO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0dGVybiA9IGZ1bmN0aW9uIChpbWFnZSwgcmVwZWF0KSB7XG4gIC8vIFNob3VsZCBkbyBub3RoaW5nIG1vcmUgaW4gdGhpcyBjb25zdHJ1Y3Rvci4gQmVjYXVzZSBncmFkaWVudCBjYW4gYmVcbiAgLy8gZGVjbGFyZCBieSBgY29sb3I6IHtpbWFnZTogLi4ufWAsIHdoZXJlIHRoaXMgY29uc3RydWN0b3Igd2lsbCBub3QgYmUgY2FsbGVkLlxuICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gIHRoaXMucmVwZWF0ID0gcmVwZWF0OyAvLyBDYW4gYmUgY2xvbmVkXG5cbiAgdGhpcy50eXBlID0gJ3BhdHRlcm4nO1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybiA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRoaXMuaW1hZ2UsIHRoaXMucmVwZWF0IHx8ICdyZXBlYXQnKTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IFBhdHRlcm47XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdHRlcm4uanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgdjJBcHBseVRyYW5zZm9ybSA9IF92ZWN0b3IuYXBwbHlUcmFuc2Zvcm07XG52YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbnZhciBwb2ludHMgPSBbW10sIFtdLCBbXV07XG52YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgbWF0aEF0YW4yID0gTWF0aC5hdGFuMjtcblxuZnVuY3Rpb24gX2RlZmF1bHQocGF0aCwgbSkge1xuICB2YXIgZGF0YSA9IHBhdGguZGF0YTtcbiAgdmFyIGNtZDtcbiAgdmFyIG5Qb2ludDtcbiAgdmFyIGk7XG4gIHZhciBqO1xuICB2YXIgaztcbiAgdmFyIHA7XG4gIHZhciBNID0gQ01ELk07XG4gIHZhciBDID0gQ01ELkM7XG4gIHZhciBMID0gQ01ELkw7XG4gIHZhciBSID0gQ01ELlI7XG4gIHZhciBBID0gQ01ELkE7XG4gIHZhciBRID0gQ01ELlE7XG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICBjbWQgPSBkYXRhW2krK107XG4gICAgaiA9IGk7XG4gICAgblBvaW50ID0gMDtcblxuICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICBjYXNlIE06XG4gICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEw6XG4gICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEM6XG4gICAgICAgIG5Qb2ludCA9IDM7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFE6XG4gICAgICAgIG5Qb2ludCA9IDI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEE6XG4gICAgICAgIHZhciB4ID0gbVs0XTtcbiAgICAgICAgdmFyIHkgPSBtWzVdO1xuICAgICAgICB2YXIgc3ggPSBtYXRoU3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgICAgdmFyIHN5ID0gbWF0aFNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgIHZhciBhbmdsZSA9IG1hdGhBdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpOyAvLyBjeFxuXG4gICAgICAgIGRhdGFbaV0gKj0gc3g7XG4gICAgICAgIGRhdGFbaSsrXSArPSB4OyAvLyBjeVxuXG4gICAgICAgIGRhdGFbaV0gKj0gc3k7XG4gICAgICAgIGRhdGFbaSsrXSArPSB5OyAvLyBTY2FsZSByeCBhbmQgcnlcbiAgICAgICAgLy8gRklYTUUgQXNzdW1lIHBzaSBpcyAwIGhlcmVcblxuICAgICAgICBkYXRhW2krK10gKj0gc3g7XG4gICAgICAgIGRhdGFbaSsrXSAqPSBzeTsgLy8gU3RhcnQgYW5nbGVcblxuICAgICAgICBkYXRhW2krK10gKz0gYW5nbGU7IC8vIGVuZCBhbmdsZVxuXG4gICAgICAgIGRhdGFbaSsrXSArPSBhbmdsZTsgLy8gRklYTUUgcHNpXG5cbiAgICAgICAgaSArPSAyO1xuICAgICAgICBqID0gaTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUjpcbiAgICAgICAgLy8geDAsIHkwXG4gICAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICAgIHBbMV0gPSBkYXRhW2krK107XG4gICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMV07IC8vIHgxLCB5MVxuXG4gICAgICAgIHBbMF0gKz0gZGF0YVtpKytdO1xuICAgICAgICBwWzFdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICB9XG5cbiAgICBmb3IgKGsgPSAwOyBrIDwgblBvaW50OyBrKyspIHtcbiAgICAgIHZhciBwID0gcG9pbnRzW2tdO1xuICAgICAgcFswXSA9IGRhdGFbaSsrXTtcbiAgICAgIHBbMV0gPSBkYXRhW2krK107XG4gICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pOyAvLyBXcml0ZSBiYWNrXG5cbiAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi90b29sL3RyYW5zZm9ybVBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gY29sb3JTdG9wc1xuICovXG52YXIgR3JhZGllbnQgPSBmdW5jdGlvbiAoY29sb3JTdG9wcykge1xuICB0aGlzLmNvbG9yU3RvcHMgPSBjb2xvclN0b3BzIHx8IFtdO1xufTtcblxuR3JhZGllbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogR3JhZGllbnQsXG4gIGFkZENvbG9yU3RvcDogZnVuY3Rpb24gKG9mZnNldCwgY29sb3IpIHtcbiAgICB0aGlzLmNvbG9yU3RvcHMucHVzaCh7XG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIGNvbG9yOiBjb2xvclxuICAgIH0pO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gR3JhZGllbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUT0RPIERyYWdnYWJsZSBmb3IgZ3JvdXBcbi8vIEZJWE1FIERyYWdnYWJsZSBvbiBlbGVtZW50IHdoaWNoIGhhcyBwYXJlbnQgcm90YXRpb24gb3Igc2NhbGVcbmZ1bmN0aW9uIERyYWdnYWJsZSgpIHtcbiAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5fZHJhZ1N0YXJ0LCB0aGlzKTtcbiAgdGhpcy5vbignbW91c2Vtb3ZlJywgdGhpcy5fZHJhZywgdGhpcyk7XG4gIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgdGhpcy5vbignZ2xvYmFsb3V0JywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7IC8vIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAvLyB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG4gIC8vIHRoaXMuX3ggPSAwO1xuICAvLyB0aGlzLl95ID0gMDtcbn1cblxuRHJhZ2dhYmxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERyYWdnYWJsZSxcbiAgX2RyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSBlLnRhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCAmJiBkcmFnZ2luZ1RhcmdldC5kcmFnZ2FibGUpIHtcbiAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gZHJhZ2dpbmdUYXJnZXQ7XG4gICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB0aGlzLl94ID0gZS5vZmZzZXRYO1xuICAgICAgdGhpcy5feSA9IGUub2Zmc2V0WTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZ3N0YXJ0JywgZS5ldmVudCk7XG4gICAgfVxuICB9LFxuICBfZHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgdmFyIHggPSBlLm9mZnNldFg7XG4gICAgICB2YXIgeSA9IGUub2Zmc2V0WTtcbiAgICAgIHZhciBkeCA9IHggLSB0aGlzLl94O1xuICAgICAgdmFyIGR5ID0geSAtIHRoaXMuX3k7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJpZnQoZHgsIGR5LCBlKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZycsIGUuZXZlbnQpO1xuICAgICAgdmFyIGRyb3BUYXJnZXQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5LCBkcmFnZ2luZ1RhcmdldCkudGFyZ2V0O1xuICAgICAgdmFyIGxhc3REcm9wVGFyZ2V0ID0gdGhpcy5fZHJvcFRhcmdldDtcbiAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuXG4gICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgIT09IGRyb3BUYXJnZXQpIHtcbiAgICAgICAgaWYgKGxhc3REcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShsYXN0RHJvcFRhcmdldCwgZSksICdkcmFnbGVhdmUnLCBlLmV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcm9wVGFyZ2V0LCBlKSwgJ2RyYWdlbnRlcicsIGUuZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfZHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcblxuICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWdlbmQnLCBlLmV2ZW50KTtcblxuICAgIGlmICh0aGlzLl9kcm9wVGFyZ2V0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKHRoaXMuX2Ryb3BUYXJnZXQsIGUpLCAnZHJvcCcsIGUuZXZlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLl9kcm9wVGFyZ2V0ID0gbnVsbDtcbiAgfVxufTtcblxuZnVuY3Rpb24gcGFyYW0odGFyZ2V0LCBlKSB7XG4gIHJldHVybiB7XG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgdG9wVGFyZ2V0OiBlICYmIGUudG9wVGFyZ2V0XG4gIH07XG59XG5cbnZhciBfZGVmYXVsdCA9IERyYWdnYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZShcIi4uL0VsZW1lbnRcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbi8qKlxuICogR3JvdXDmmK/kuIDkuKrlrrnlmajvvIzlj6/ku6Xmj5LlhaXlrZDoioLngrnvvIxHcm91cOeahOWPmOaNouS5n+S8muiiq+W6lOeUqOWIsOWtkOiKgueCueS4ilxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvR3JvdXBcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIEdyb3VwID0gcmVxdWlyZSgnenJlbmRlci9jb250YWluZXIvR3JvdXAnKTtcbiAqICAgICB2YXIgQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9ncmFwaGljL3NoYXBlL0NpcmNsZScpO1xuICogICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gKiAgICAgZy5wb3NpdGlvblswXSA9IDEwMDtcbiAqICAgICBnLnBvc2l0aW9uWzFdID0gMTAwO1xuICogICAgIGcuYWRkKG5ldyBDaXJjbGUoe1xuICogICAgICAgICBzdHlsZToge1xuICogICAgICAgICAgICAgeDogMTAwLFxuICogICAgICAgICAgICAgeTogMTAwLFxuICogICAgICAgICAgICAgcjogMjAsXG4gKiAgICAgICAgIH1cbiAqICAgICB9KSk7XG4gKiAgICAgenIuYWRkKGcpO1xuICovXG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXBcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqL1xudmFyIEdyb3VwID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTtcblxuICBmb3IgKHZhciBrZXkgaW4gb3B0cykge1xuICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRoaXNba2V5XSA9IG9wdHNba2V5XTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICB0aGlzLl9fc3RvcmFnZSA9IG51bGw7XG4gIHRoaXMuX19kaXJ0eSA9IHRydWU7XG59O1xuXG5Hcm91cC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBHcm91cCxcbiAgaXNHcm91cDogdHJ1ZSxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHR5cGU6ICdncm91cCcsXG5cbiAgLyoqXG4gICAqIOaJgOacieWtkOWtmeWFg+e0oOaYr+WQpuWTjeW6lOm8oOagh+S6i+S7tlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvY29udGFpbmVyL0dyb3VwI3NpbGVudFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9FbGVtZW50Pn1cbiAgICovXG4gIGNoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLnNsaWNlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPluaMh+WumiBpbmRleCDnmoTlhL/lrZDoioLngrlcbiAgICogQHBhcmFtICB7bnVtYmVyfSBpZHhcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICovXG4gIGNoaWxkQXQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW5baWR4XTtcbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W5oyH5a6a5ZCN5a2X55qE5YS/5a2Q6IqC54K5XG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgKi9cbiAgY2hpbGRPZk5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5a2Q6IqC54K55Yiw5pyA5ZCOXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICovXG4gIGFkZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cbiAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5a2Q6IqC54K55ZyoIG5leHRTaWJsaW5nIOS5i+WJjVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gbmV4dFNpYmxpbmdcbiAgICovXG4gIGFkZEJlZm9yZTogZnVuY3Rpb24gKGNoaWxkLCBuZXh0U2libGluZykge1xuICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXMgJiYgbmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgIHZhciBpZHggPSBjaGlsZHJlbi5pbmRleE9mKG5leHRTaWJsaW5nKTtcblxuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDAsIGNoaWxkKTtcblxuICAgICAgICB0aGlzLl9kb0FkZChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9kb0FkZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY2hpbGQucGFyZW50LnJlbW92ZShjaGlsZCk7XG4gICAgfVxuXG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgIHZhciB6ciA9IHRoaXMuX196cjtcblxuICAgIGlmIChzdG9yYWdlICYmIHN0b3JhZ2UgIT09IGNoaWxkLl9fc3RvcmFnZSkge1xuICAgICAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBjaGlsZC5hZGRDaGlsZHJlblRvU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOenu+mZpOWtkOiKgueCuVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIHZhciBpZHggPSB6clV0aWwuaW5kZXhPZihjaGlsZHJlbiwgY2hpbGQpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xuICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG5cbiAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgenIgJiYgenIucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDnp7vpmaTmiYDmnInlrZDoioLngrlcbiAgICovXG4gIHJlbW92ZUFsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgdmFyIGNoaWxkO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDpgY3ljobmiYDmnInlrZDoioLngrlcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAqL1xuICBlYWNoQ2hpbGQ6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkLCBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5rex5bqm5LyY5YWI6YGN5Y6G5omA5pyJ5a2Q5a2Z6IqC54K5XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgKi9cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgY2IuY2FsbChjb250ZXh0LCBjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgIGNoaWxkLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkQ2hpbGRyZW5Ub1N0b3JhZ2U6IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICBzdG9yYWdlLmFkZFRvU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmFkZENoaWxkcmVuVG9TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICovXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKGluY2x1ZGVDaGlsZHJlbikge1xuICAgIC8vIFRPRE8gQ2FjaGluZ1xuICAgIHZhciByZWN0ID0gbnVsbDtcbiAgICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgdmFyIGNoaWxkcmVuID0gaW5jbHVkZUNoaWxkcmVuIHx8IHRoaXMuX2NoaWxkcmVuO1xuICAgIHZhciB0bXBNYXQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoY2hpbGQuaWdub3JlIHx8IGNoaWxkLmludmlzaWJsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkUmVjdCA9IGNoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGNoaWxkLmdldExvY2FsVHJhbnNmb3JtKHRtcE1hdCk7IC8vIFRPRE9cbiAgICAgIC8vIFRoZSBib3VuZGluZ1JlY3QgY2FjbHVhdGVkIGJ5IHRyYW5zZm9ybWluZyBvcmlnaW5hbFxuICAgICAgLy8gcmVjdCBtYXkgYmUgYmlnZ2VyIHRoYW4gdGhlIGFjdHVhbCBidW5kaW5nUmVjdCB3aGVuIHJvdGF0aW9uXG4gICAgICAvLyBpcyB1c2VkLiAoQ29uc2lkZXIgYSBjaXJjbGUgcm90YXRlZCBhZ2luc3QgaXRzIGNlbnRlciwgd2hlcmVcbiAgICAgIC8vIHRoZSBhY3R1YWwgYm91bmRpbmdSZWN0IHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGF0IG5vdCBiZVxuICAgICAgLy8gcm90YXRlZC4pIEJ1dCB3ZSBjYW4gbm90IGZpbmQgYmV0dGVyIGFwcHJvYWNoIHRvIGNhbGN1bGF0ZVxuICAgICAgLy8gYWN0dWFsIGJvdW5kaW5nUmVjdCB5ZXQsIGNvbnNpZGVyaW5nIHBlcmZvcm1hbmNlLlxuXG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRtcFJlY3QuY29weShjaGlsZFJlY3QpO1xuICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IHRtcFJlY3QuY2xvbmUoKTtcbiAgICAgICAgcmVjdC51bmlvbih0bXBSZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IGNoaWxkUmVjdC5jbG9uZSgpO1xuICAgICAgICByZWN0LnVuaW9uKGNoaWxkUmVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3QgfHwgdG1wUmVjdDtcbiAgfVxufTtcbnpyVXRpbC5pbmhlcml0cyhHcm91cCwgRWxlbWVudCk7XG52YXIgX2RlZmF1bHQgPSBHcm91cDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZShcIi4vRGlzcGxheWFibGVcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXIvaW1hZ2VcIik7XG5cbi8qKlxuICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5mdW5jdGlvbiBaSW1hZ2Uob3B0cykge1xuICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG5aSW1hZ2UucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogWkltYWdlLFxuICB0eXBlOiAnaW1hZ2UnLFxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgc3JjID0gc3R5bGUuaW1hZ2U7IC8vIE11c3QgYmluZCBlYWNoIHRpbWVcblxuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlID0gaW1hZ2VIZWxwZXIuY3JlYXRlT3JVcGRhdGVJbWFnZShzcmMsIHRoaXMuX2ltYWdlLCB0aGlzLCB0aGlzLm9ubG9hZCk7XG5cbiAgICBpZiAoIWltYWdlIHx8ICFpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoaW1hZ2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyDlm77niYflt7Lnu4/liqDovb3lrozmiJBcbiAgICAvLyBpZiAoaW1hZ2Uubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnSU1HJykge1xuICAgIC8vICAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSB7XG4gICAgLy8gICAgICAgICByZXR1cm47XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gICAgLy8gRWxzZSBpcyBjYW52YXNcblxuXG4gICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHN0eWxlLmhlaWdodDtcbiAgICB2YXIgYXNwZWN0ID0gaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQ7XG5cbiAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgLy8gS2VlcCBpbWFnZS9oZWlnaHQgcmF0aW9cbiAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0O1xuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwgJiYgd2lkdGggIT0gbnVsbCkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA9PSBudWxsICYmIGhlaWdodCA9PSBudWxsKSB7XG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIH0gLy8g6K6+572udHJhbnNmb3JtXG5cblxuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4IHx8IDA7XG4gICAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuc3ggJiYgc3R5bGUuc3kpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4O1xuICAgICAgdmFyIHN5ID0gc3R5bGUuc3k7XG4gICAgICB2YXIgc1dpZHRoID0gd2lkdGggLSBzeDtcbiAgICAgIHZhciBzSGVpZ2h0ID0gaGVpZ2h0IC0gc3k7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBzeCwgc3ksIHNXaWR0aCwgc0hlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpOyAvLyBEcmF3IHJlY3QgdGV4dFxuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICB9XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgIHRoaXMuX3JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHN0eWxlLnggfHwgMCwgc3R5bGUueSB8fCAwLCBzdHlsZS53aWR0aCB8fCAwLCBzdHlsZS5oZWlnaHQgfHwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XG52YXIgX2RlZmF1bHQgPSBaSW1hZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3RleHRcIik7XG5cbnZhciB0ZXh0SGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyL3RleHRcIik7XG5cbi8qKlxuICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9UZXh0XG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbnZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG59O1xuXG5UZXh0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRleHQsXG4gIHR5cGU6ICd0ZXh0JyxcbiAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7IC8vIFVzZSBwcm9wcyB3aXRoIHByZWZpeCAndGV4dCcuXG5cbiAgICBzdHlsZS5maWxsID0gc3R5bGUuc3Ryb2tlID0gc3R5bGUuc2hhZG93Qmx1ciA9IHN0eWxlLnNoYWRvd0NvbG9yID0gc3R5bGUuc2hhZG93T2Zmc2V0WCA9IHN0eWxlLnNoYWRvd09mZnNldFkgPSBudWxsO1xuICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDsgLy8gQ29udmVydCB0byBzdHJpbmdcblxuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7IC8vIEFsd2F5cyBiaW5kIHN0eWxlXG5cbiAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcblxuICAgIGlmICghdGV4dEhlbHBlci5uZWVkRHJhd1RleHQodGV4dCwgc3R5bGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICB0ZXh0SGVscGVyLnJlbmRlclRleHQodGhpcywgY3R4LCB0ZXh0LCBzdHlsZSk7XG4gICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7XG5cbiAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcbiAgICAgIHRleHQgIT0gbnVsbCA/IHRleHQgKz0gJycgOiB0ZXh0ID0gJyc7XG4gICAgICB2YXIgcmVjdCA9IHRleHRDb250YWluLmdldEJvdW5kaW5nUmVjdChzdHlsZS50ZXh0ICsgJycsIHN0eWxlLmZvbnQsIHN0eWxlLnRleHRBbGlnbiwgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24sIHN0eWxlLnRleHRQYWRkaW5nLCBzdHlsZS5yaWNoKTtcbiAgICAgIHJlY3QueCArPSBzdHlsZS54IHx8IDA7XG4gICAgICByZWN0LnkgKz0gc3R5bGUueSB8fCAwO1xuXG4gICAgICBpZiAodGV4dEhlbHBlci5nZXRTdHJva2Uoc3R5bGUudGV4dFN0cm9rZSwgc3R5bGUudGV4dFN0cm9rZVdpZHRoKSkge1xuICAgICAgICB2YXIgdyA9IHN0eWxlLnRleHRTdHJva2VXaWR0aDtcbiAgICAgICAgcmVjdC54IC09IHcgLyAyO1xuICAgICAgICByZWN0LnkgLT0gdyAvIDI7XG4gICAgICAgIHJlY3Qud2lkdGggKz0gdztcbiAgICAgICAgcmVjdC5oZWlnaHQgKz0gdztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoVGV4dCwgRGlzcGxheWFibGUpO1xudmFyIF9kZWZhdWx0ID0gVGV4dDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxuLyoqXG4gKiDlnIblvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9DaXJjbGVcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnY2lyY2xlJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByOiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUsIGluQnVuZGxlKSB7XG4gICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgLy8gQWx3YXlzIGRvIGl0IG1heSBoYXZlIHBlcmZvcm1lbmNlIGlzc3VlICggZmlsbCBtYXkgYmUgMnggbW9yZSBjb3N0KVxuICAgIGlmIChpbkJ1bmRsZSkge1xuICAgICAgY3R4Lm1vdmVUbyhzaGFwZS5jeCArIHNoYXBlLnIsIHNoYXBlLmN5KTtcbiAgICB9IC8vIGVsc2Uge1xuICAgIC8vICAgICBpZiAoY3R4LmFsbG9jYXRlICYmICFjdHguZGF0YS5sZW5ndGgpIHtcbiAgICAvLyAgICAgICAgIGN0eC5hbGxvY2F0ZShjdHguQ01EX01FTV9TSVpFLkEpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgIC8vIGN0eC5tb3ZlVG8oc2hhcGUuY3ggKyBzaGFwZS5yLCBzaGFwZS5jeSk7XG5cblxuICAgIGN0eC5hcmMoc2hhcGUuY3gsIHNoYXBlLmN5LCBzaGFwZS5yLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIGZpeENsaXBXaXRoU2hhZG93ID0gcmVxdWlyZShcIi4uL2hlbHBlci9maXhDbGlwV2l0aFNoYWRvd1wiKTtcblxuLyoqXG4gKiDmiYflvaJcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1NlY3RvclxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdzZWN0b3InLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHIwOiAwLFxuICAgIHI6IDAsXG4gICAgc3RhcnRBbmdsZTogMCxcbiAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXG4gICAgY2xvY2t3aXNlOiB0cnVlXG4gIH0sXG4gIGJydXNoOiBmaXhDbGlwV2l0aFNoYWRvdyhQYXRoLnByb3RvdHlwZS5icnVzaCksXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgdmFyIHIwID0gTWF0aC5tYXgoc2hhcGUucjAgfHwgMCwgMCk7XG4gICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgdmFyIGVuZEFuZ2xlID0gc2hhcGUuZW5kQW5nbGU7XG4gICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcbiAgICB2YXIgdW5pdFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICBjdHgubW92ZVRvKHVuaXRYICogcjAgKyB4LCB1bml0WSAqIHIwICsgeSk7XG4gICAgY3R4LmxpbmVUbyh1bml0WCAqIHIgKyB4LCB1bml0WSAqIHIgKyB5KTtcbiAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcbiAgICBjdHgubGluZVRvKE1hdGguY29zKGVuZEFuZ2xlKSAqIHIwICsgeCwgTWF0aC5zaW4oZW5kQW5nbGUpICogcjAgKyB5KTtcblxuICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgY3R4LmFyYyh4LCB5LCByMCwgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIGNsb2Nrd2lzZSk7XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBlbnYgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9lbnZcIik7XG5cbi8vIEZpeCB3ZWlyZCBidWcgaW4gc29tZSB2ZXJzaW9uIG9mIElFMTEgKGxpa2UgMTEuMC45NjAwLjE3OCoqKSxcbi8vIHdoZXJlIGV4Y2VwdGlvbiBcInVuZXhwZWN0ZWQgY2FsbCB0byBtZXRob2Qgb3IgcHJvcGVydHkgYWNjZXNzXCJcbi8vIG1pZ2h0IGJlIHRocm93biB3aGVuIGNhbGxpbmcgY3R4LmZpbGwgb3IgY3R4LnN0cm9rZSBhZnRlciBhIHBhdGhcbi8vIHdob3NlIGFyZWEgc2l6ZSBpcyB6ZXJvIGlzIGRyYXduIGFuZCBjdHguY2xpcCgpIGlzIGNhbGxlZCBhbmRcbi8vIHNoYWRvd0JsdXIgaXMgc2V0LiBTZWUgIzQ1NzIsICMzMTEyLCAjNTc3Ny5cbi8vIChlLmcuLFxuLy8gIGN0eC5tb3ZlVG8oMTAsIDEwKTtcbi8vICBjdHgubGluZVRvKDIwLCAxMCk7XG4vLyAgY3R4LmNsb3NlUGF0aCgpO1xuLy8gIGN0eC5jbGlwKCk7XG4vLyAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcbi8vICAuLi5cbi8vICBjdHguZmlsbCgpO1xuLy8gKVxudmFyIHNoYWRvd1RlbXAgPSBbWydzaGFkb3dCbHVyJywgMF0sIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLCBbJ3NoYWRvd09mZnNldFgnLCAwXSwgWydzaGFkb3dPZmZzZXRZJywgMF1dO1xuXG5mdW5jdGlvbiBfZGVmYXVsdChvcmlnbmFsQnJ1c2gpIHtcbiAgLy8gdmVyc2lvbiBzdHJpbmcgY2FuIGJlOiAnMTEuMCdcbiAgcmV0dXJuIGVudi5icm93c2VyLmllICYmIGVudi5icm93c2VyLnZlcnNpb24gPj0gMTEgPyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNsaXBQYXRocyA9IHRoaXMuX19jbGlwUGF0aHM7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgbW9kaWZpZWQ7XG5cbiAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgICAgIHZhciBzaGFwZSA9IGNsaXBQYXRoICYmIGNsaXBQYXRoLnNoYXBlO1xuICAgICAgICB2YXIgdHlwZSA9IGNsaXBQYXRoICYmIGNsaXBQYXRoLnR5cGU7XG5cbiAgICAgICAgaWYgKHNoYXBlICYmICh0eXBlID09PSAnc2VjdG9yJyAmJiBzaGFwZS5zdGFydEFuZ2xlID09PSBzaGFwZS5lbmRBbmdsZSB8fCB0eXBlID09PSAncmVjdCcgJiYgKCFzaGFwZS53aWR0aCB8fCAhc2hhcGUuaGVpZ2h0KSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIC8vIEl0IGlzIHNhdmUgdG8gcHV0IHNoYWRvd1RlbXAgc3RhdGljLCBiZWNhdXNlIHNoYWRvd1RlbXBcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgYWxsIG1vZGlmaWVkIGVhY2ggaXRlbSBicnVzaCBjYWxsZWQuXG4gICAgICAgICAgICBzaGFkb3dUZW1wW2pdWzJdID0gc3R5bGVbc2hhZG93VGVtcFtqXVswXV07XG4gICAgICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3JpZ25hbEJydXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhZG93VGVtcC5sZW5ndGg7IGorKykge1xuICAgICAgICBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXSA9IHNoYWRvd1RlbXBbal1bMl07XG4gICAgICB9XG4gICAgfVxuICB9IDogb3JpZ25hbEJydXNoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9maXhDbGlwV2l0aFNoYWRvdy5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBlY2hhcnRz6K6+5aSH546v5aKD6K+G5YirXG4gKlxuICogQGRlc2MgZWNoYXJ0c+WfuuS6jkNhbnZhc++8jOe6r0phdmFzY3JpcHTlm77ooajlupPvvIzmj5Dkvpvnm7Top4LvvIznlJ/liqjvvIzlj6/kuqTkupLvvIzlj6/kuKrmgKfljJblrprliLbnmoTmlbDmja7nu5/orqHlm77ooajjgIJcbiAqIEBhdXRob3IgZmlyZWRlW2ZpcmVkZUBmaXJlZGUudXNdXG4gKiBAZGVzYyB0aGFua3MgemVwdG8uXG4gKi9cbnZhciBlbnYgPSB7fTtcblxuaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIEluIG5vZGVcbiAgZW52ID0ge1xuICAgIGJyb3dzZXI6IHt9LFxuICAgIG9zOiB7fSxcbiAgICBub2RlOiB0cnVlLFxuICAgIC8vIEFzc3VtZSBjYW52YXMgaXMgc3VwcG9ydGVkXG4gICAgY2FudmFzU3VwcG9ydGVkOiB0cnVlLFxuICAgIHN2Z1N1cHBvcnRlZDogdHJ1ZVxuICB9O1xufSBlbHNlIHtcbiAgZW52ID0gZGV0ZWN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuXG52YXIgX2RlZmF1bHQgPSBlbnY7IC8vIFplcHRvLmpzXG4vLyAoYykgMjAxMC0yMDEzIFRob21hcyBGdWNoc1xuLy8gWmVwdG8uanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbmZ1bmN0aW9uIGRldGVjdCh1YSkge1xuICB2YXIgb3MgPSB7fTtcbiAgdmFyIGJyb3dzZXIgPSB7fTsgLy8gdmFyIHdlYmtpdCA9IHVhLm1hdGNoKC9XZWJba0tdaXRbXFwvXXswLDF9KFtcXGQuXSspLyk7XG4gIC8vIHZhciBhbmRyb2lkID0gdWEubWF0Y2goLyhBbmRyb2lkKTs/W1xcc1xcL10rKFtcXGQuXSspPy8pO1xuICAvLyB2YXIgaXBhZCA9IHVhLm1hdGNoKC8oaVBhZCkuKk9TXFxzKFtcXGRfXSspLyk7XG4gIC8vIHZhciBpcG9kID0gdWEubWF0Y2goLyhpUG9kKSguKk9TXFxzKFtcXGRfXSspKT8vKTtcbiAgLy8gdmFyIGlwaG9uZSA9ICFpcGFkICYmIHVhLm1hdGNoKC8oaVBob25lXFxzT1MpXFxzKFtcXGRfXSspLyk7XG4gIC8vIHZhciB3ZWJvcyA9IHVhLm1hdGNoKC8od2ViT1N8aHB3T1MpW1xcc1xcL10oW1xcZC5dKykvKTtcbiAgLy8gdmFyIHRvdWNocGFkID0gd2Vib3MgJiYgdWEubWF0Y2goL1RvdWNoUGFkLyk7XG4gIC8vIHZhciBraW5kbGUgPSB1YS5tYXRjaCgvS2luZGxlXFwvKFtcXGQuXSspLyk7XG4gIC8vIHZhciBzaWxrID0gdWEubWF0Y2goL1NpbGtcXC8oW1xcZC5fXSspLyk7XG4gIC8vIHZhciBibGFja2JlcnJ5ID0gdWEubWF0Y2goLyhCbGFja0JlcnJ5KS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgYmIxMCA9IHVhLm1hdGNoKC8oQkIxMCkuKlZlcnNpb25cXC8oW1xcZC5dKykvKTtcbiAgLy8gdmFyIHJpbXRhYmxldG9zID0gdWEubWF0Y2goLyhSSU1cXHNUYWJsZXRcXHNPUylcXHMoW1xcZC5dKykvKTtcbiAgLy8gdmFyIHBsYXlib29rID0gdWEubWF0Y2goL1BsYXlCb29rLyk7XG4gIC8vIHZhciBjaHJvbWUgPSB1YS5tYXRjaCgvQ2hyb21lXFwvKFtcXGQuXSspLykgfHwgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLyk7XG5cbiAgdmFyIGZpcmVmb3ggPSB1YS5tYXRjaCgvRmlyZWZveFxcLyhbXFxkLl0rKS8pOyAvLyB2YXIgc2FmYXJpID0gd2Via2l0ICYmIHVhLm1hdGNoKC9Nb2JpbGVcXC8vKSAmJiAhY2hyb21lO1xuICAvLyB2YXIgd2VidmlldyA9IHVhLm1hdGNoKC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpLykgJiYgIWNocm9tZTtcblxuICB2YXIgaWUgPSB1YS5tYXRjaCgvTVNJRVxccyhbXFxkLl0rKS8pIC8vIElFIDExIFRyaWRlbnQvNy4wOyBydjoxMS4wXG4gIHx8IHVhLm1hdGNoKC9UcmlkZW50XFwvLis/cnY6KChbXFxkLl0rKSkvKTtcbiAgdmFyIGVkZ2UgPSB1YS5tYXRjaCgvRWRnZVxcLyhbXFxkLl0rKS8pOyAvLyBJRSAxMiBhbmQgMTIrXG5cbiAgdmFyIHdlQ2hhdCA9IC9taWNyb21lc3Nlbmdlci9pLnRlc3QodWEpOyAvLyBUb2RvOiBjbGVhbiB0aGlzIHVwIHdpdGggYSBiZXR0ZXIgT1MvYnJvd3NlciBzZXBlcmF0aW9uOlxuICAvLyAtIGRpc2Nlcm4gKG1vcmUpIGJldHdlZW4gbXVsdGlwbGUgYnJvd3NlcnMgb24gYW5kcm9pZFxuICAvLyAtIGRlY2lkZSBpZiBraW5kbGUgZmlyZSBpbiBzaWxrIG1vZGUgaXMgYW5kcm9pZCBvciBub3RcbiAgLy8gLSBGaXJlZm94IG9uIEFuZHJvaWQgZG9lc24ndCBzcGVjaWZ5IHRoZSBBbmRyb2lkIHZlcnNpb25cbiAgLy8gLSBwb3NzaWJseSBkZXZpZGUgaW4gb3MsIGRldmljZSBhbmQgYnJvd3NlciBoYXNoZXNcbiAgLy8gaWYgKGJyb3dzZXIud2Via2l0ID0gISF3ZWJraXQpIGJyb3dzZXIudmVyc2lvbiA9IHdlYmtpdFsxXTtcbiAgLy8gaWYgKGFuZHJvaWQpIG9zLmFuZHJvaWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gYW5kcm9pZFsyXTtcbiAgLy8gaWYgKGlwaG9uZSAmJiAhaXBvZCkgb3MuaW9zID0gb3MuaXBob25lID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwaG9uZVsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gIC8vIGlmIChpcGFkKSBvcy5pb3MgPSBvcy5pcGFkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwYWRbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAvLyBpZiAoaXBvZCkgb3MuaW9zID0gb3MuaXBvZCA9IHRydWUsIG9zLnZlcnNpb24gPSBpcG9kWzNdID8gaXBvZFszXS5yZXBsYWNlKC9fL2csICcuJykgOiBudWxsO1xuICAvLyBpZiAod2Vib3MpIG9zLndlYm9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHdlYm9zWzJdO1xuICAvLyBpZiAodG91Y2hwYWQpIG9zLnRvdWNocGFkID0gdHJ1ZTtcbiAgLy8gaWYgKGJsYWNrYmVycnkpIG9zLmJsYWNrYmVycnkgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmxhY2tiZXJyeVsyXTtcbiAgLy8gaWYgKGJiMTApIG9zLmJiMTAgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmIxMFsyXTtcbiAgLy8gaWYgKHJpbXRhYmxldG9zKSBvcy5yaW10YWJsZXRvcyA9IHRydWUsIG9zLnZlcnNpb24gPSByaW10YWJsZXRvc1syXTtcbiAgLy8gaWYgKHBsYXlib29rKSBicm93c2VyLnBsYXlib29rID0gdHJ1ZTtcbiAgLy8gaWYgKGtpbmRsZSkgb3Mua2luZGxlID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGtpbmRsZVsxXTtcbiAgLy8gaWYgKHNpbGspIGJyb3dzZXIuc2lsayA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IHNpbGtbMV07XG4gIC8vIGlmICghc2lsayAmJiBvcy5hbmRyb2lkICYmIHVhLm1hdGNoKC9LaW5kbGUgRmlyZS8pKSBicm93c2VyLnNpbGsgPSB0cnVlO1xuICAvLyBpZiAoY2hyb21lKSBicm93c2VyLmNocm9tZSA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IGNocm9tZVsxXTtcblxuICBpZiAoZmlyZWZveCkge1xuICAgIGJyb3dzZXIuZmlyZWZveCA9IHRydWU7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gZmlyZWZveFsxXTtcbiAgfSAvLyBpZiAoc2FmYXJpICYmICh1YS5tYXRjaCgvU2FmYXJpLykgfHwgISFvcy5pb3MpKSBicm93c2VyLnNhZmFyaSA9IHRydWU7XG4gIC8vIGlmICh3ZWJ2aWV3KSBicm93c2VyLndlYnZpZXcgPSB0cnVlO1xuXG5cbiAgaWYgKGllKSB7XG4gICAgYnJvd3Nlci5pZSA9IHRydWU7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gaWVbMV07XG4gIH1cblxuICBpZiAoZWRnZSkge1xuICAgIGJyb3dzZXIuZWRnZSA9IHRydWU7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gZWRnZVsxXTtcbiAgfSAvLyBJdCBpcyBkaWZmaWN1bHQgdG8gZGV0ZWN0IFdlQ2hhdCBpbiBXaW4gUGhvbmUgcHJlY2lzZWx5LCBiZWNhdXNlIHVhIGNhblxuICAvLyBub3QgYmUgc2V0IG9uIHdpbiBwaG9uZS4gU28gd2UgZG8gbm90IGNvbnNpZGVyIFdpbiBQaG9uZS5cblxuXG4gIGlmICh3ZUNoYXQpIHtcbiAgICBicm93c2VyLndlQ2hhdCA9IHRydWU7XG4gIH0gLy8gb3MudGFibGV0ID0gISEoaXBhZCB8fCBwbGF5Ym9vayB8fCAoYW5kcm9pZCAmJiAhdWEubWF0Y2goL01vYmlsZS8pKSB8fFxuICAvLyAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL1RhYmxldC8pKSB8fCAoaWUgJiYgIXVhLm1hdGNoKC9QaG9uZS8pICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSk7XG4gIC8vIG9zLnBob25lICA9ICEhKCFvcy50YWJsZXQgJiYgIW9zLmlwb2QgJiYgKGFuZHJvaWQgfHwgaXBob25lIHx8IHdlYm9zIHx8XG4gIC8vICAgICAoY2hyb21lICYmIHVhLm1hdGNoKC9BbmRyb2lkLykpIHx8IChjaHJvbWUgJiYgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLykpIHx8XG4gIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvTW9iaWxlLykpIHx8IChpZSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpKTtcblxuXG4gIHJldHVybiB7XG4gICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICBvczogb3MsXG4gICAgbm9kZTogZmFsc2UsXG4gICAgLy8g5Y6f55SfY2FudmFz5pSv5oyB77yM5pS55p6B56uv54K55LqGXG4gICAgLy8gY2FudmFzU3VwcG9ydGVkIDogIShicm93c2VyLmllICYmIHBhcnNlRmxvYXQoYnJvd3Nlci52ZXJzaW9uKSA8IDkpXG4gICAgY2FudmFzU3VwcG9ydGVkOiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQsXG4gICAgc3ZnU3VwcG9ydGVkOiB0eXBlb2YgU1ZHUmVjdCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgLy8gQHNlZSA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80ODE3MDI5L3doYXRzLXRoZS1iZXN0LXdheS10by1kZXRlY3QtYS10b3VjaC1zY3JlZW4tZGV2aWNlLXVzaW5nLWphdmFzY3JpcHQ+XG4gICAgLy8gd29ya3Mgb24gbW9zdCBicm93c2Vyc1xuICAgIC8vIElFMTAvMTEgZG9lcyBub3Qgc3VwcG9ydCB0b3VjaCBldmVudCwgYW5kIE1TIEVkZ2Ugc3VwcG9ydHMgdGhlbSBidXQgbm90IGJ5XG4gICAgLy8gZGVmYXVsdCwgc28gd2UgZG9udCBjaGVjayBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgZm9yIHRoZW0gaGVyZS5cbiAgICB0b3VjaEV2ZW50c1N1cHBvcnRlZDogJ29udG91Y2hzdGFydCcgaW4gd2luZG93ICYmICFicm93c2VyLmllICYmICFicm93c2VyLmVkZ2UsXG4gICAgLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXBvaW50ZXIlMjBldmVudD4uXG4gICAgcG9pbnRlckV2ZW50c1N1cHBvcnRlZDogJ29ucG9pbnRlcmRvd24nIGluIHdpbmRvdyAvLyBGaXJlZm94IHN1cHBvcnRzIHBvaW50ZXIgYnV0IG5vdCBieSBkZWZhdWx0LCBvbmx5IE1TIGJyb3dzZXJzIGFyZSByZWxpYWJsZSBvbiBwb2ludGVyXG4gICAgLy8gZXZlbnRzIGN1cnJlbnRseS4gU28gd2UgZG9udCB1c2UgdGhhdCBvbiBvdGhlciBicm93c2VycyB1bmxlc3MgdGVzdGVkIHN1ZmZpY2llbnRseS5cbiAgICAvLyBBbHRob3VnaCBJRSAxMCBzdXBwb3J0cyBwb2ludGVyIGV2ZW50LCBpdCB1c2Ugb2xkIHN0eWxlIGFuZCBpcyBkaWZmZXJlbnQgZnJvbSB0aGVcbiAgICAvLyBzdGFuZGFyZC4gU28gd2UgZXhjbHVkZSB0aGF0LiAoSUUgMTAgaXMgaGFyZGx5IHVzZWQgb24gdG91Y2ggZGV2aWNlKVxuICAgICYmIChicm93c2VyLmVkZ2UgfHwgYnJvd3Nlci5pZSAmJiBicm93c2VyLnZlcnNpb24gPj0gMTEpXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvZW52LmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOWchueOr1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmluZ1xuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdyaW5nJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByOiAwLFxuICAgIHIwOiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgIGN0eC5tb3ZlVG8oeCArIHNoYXBlLnIsIHkpO1xuICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUuciwgMCwgUEkyLCBmYWxzZSk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUucjAsIHkpO1xuICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUucjAsIDAsIFBJMiwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciBwb2x5SGVscGVyID0gcmVxdWlyZShcIi4uL2hlbHBlci9wb2x5XCIpO1xuXG4vKipcbiAqIOWkmui+ueW9olxuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL1BvbHlnb25cbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAncG9seWdvbicsXG4gIHNoYXBlOiB7XG4gICAgcG9pbnRzOiBudWxsLFxuICAgIHNtb290aDogZmFsc2UsXG4gICAgc21vb3RoQ29uc3RyYWludDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBzbW9vdGhTcGxpbmUgPSByZXF1aXJlKFwiLi9zbW9vdGhTcGxpbmVcIik7XG5cbnZhciBzbW9vdGhCZXppZXIgPSByZXF1aXJlKFwiLi9zbW9vdGhCZXppZXJcIik7XG5cbmZ1bmN0aW9uIGJ1aWxkUGF0aChjdHgsIHNoYXBlLCBjbG9zZVBhdGgpIHtcbiAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgdmFyIHNtb290aCA9IHNoYXBlLnNtb290aDtcblxuICBpZiAocG9pbnRzICYmIHBvaW50cy5sZW5ndGggPj0gMikge1xuICAgIGlmIChzbW9vdGggJiYgc21vb3RoICE9PSAnc3BsaW5lJykge1xuICAgICAgdmFyIGNvbnRyb2xQb2ludHMgPSBzbW9vdGhCZXppZXIocG9pbnRzLCBzbW9vdGgsIGNsb3NlUGF0aCwgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG4gICAgICBjdHgubW92ZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTtcbiAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChjbG9zZVBhdGggPyBsZW4gOiBsZW4gLSAxKTsgaSsrKSB7XG4gICAgICAgIHZhciBjcDEgPSBjb250cm9sUG9pbnRzW2kgKiAyXTtcbiAgICAgICAgdmFyIGNwMiA9IGNvbnRyb2xQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNwMVswXSwgY3AxWzFdLCBjcDJbMF0sIGNwMlsxXSwgcFswXSwgcFsxXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzbW9vdGggPT09ICdzcGxpbmUnKSB7XG4gICAgICAgIHBvaW50cyA9IHNtb290aFNwbGluZShwb2ludHMsIGNsb3NlUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbaV1bMF0sIHBvaW50c1tpXVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2VQYXRoICYmIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxufVxuXG5leHBvcnRzLmJ1aWxkUGF0aCA9IGJ1aWxkUGF0aDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciB2MkRpc3RhbmNlID0gX3ZlY3Rvci5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYXRtdWxsLVJvbSBzcGxpbmUg5o+S5YC85oqY57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhTcGxpbmVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICogICAgICAgICBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mykge1xuICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gIHZhciB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgcmV0dXJuICgyICogKHAxIC0gcDIpICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIChwMSAtIHAyKSAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9zaGFwZS91dGlsL3Ntb290aFNwbGluZVxuICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIOe6v+autemhtueCueaVsOe7hFxuICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gX2RlZmF1bHQocG9pbnRzLCBpc0xvb3ApIHtcbiAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gIHZhciByZXQgPSBbXTtcbiAgdmFyIGRpc3RhbmNlID0gMDtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgZGlzdGFuY2UgKz0gdjJEaXN0YW5jZShwb2ludHNbaSAtIDFdLCBwb2ludHNbaV0pO1xuICB9XG5cbiAgdmFyIHNlZ3MgPSBkaXN0YW5jZSAvIDI7XG4gIHNlZ3MgPSBzZWdzIDwgbGVuID8gbGVuIDogc2VncztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ3M7IGkrKykge1xuICAgIHZhciBwb3MgPSBpIC8gKHNlZ3MgLSAxKSAqIChpc0xvb3AgPyBsZW4gOiBsZW4gLSAxKTtcbiAgICB2YXIgaWR4ID0gTWF0aC5mbG9vcihwb3MpO1xuICAgIHZhciB3ID0gcG9zIC0gaWR4O1xuICAgIHZhciBwMDtcbiAgICB2YXIgcDEgPSBwb2ludHNbaWR4ICUgbGVuXTtcbiAgICB2YXIgcDI7XG4gICAgdmFyIHAzO1xuXG4gICAgaWYgKCFpc0xvb3ApIHtcbiAgICAgIHAwID0gcG9pbnRzW2lkeCA9PT0gMCA/IGlkeCA6IGlkeCAtIDFdO1xuICAgICAgcDIgPSBwb2ludHNbaWR4ID4gbGVuIC0gMiA/IGxlbiAtIDEgOiBpZHggKyAxXTtcbiAgICAgIHAzID0gcG9pbnRzW2lkeCA+IGxlbiAtIDMgPyBsZW4gLSAxIDogaWR4ICsgMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAwID0gcG9pbnRzWyhpZHggLSAxICsgbGVuKSAlIGxlbl07XG4gICAgICBwMiA9IHBvaW50c1soaWR4ICsgMSkgJSBsZW5dO1xuICAgICAgcDMgPSBwb2ludHNbKGlkeCArIDIpICUgbGVuXTtcbiAgICB9XG5cbiAgICB2YXIgdzIgPSB3ICogdztcbiAgICB2YXIgdzMgPSB3ICogdzI7XG4gICAgcmV0LnB1c2goW2ludGVycG9sYXRlKHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdLCB3LCB3MiwgdzMpLCBpbnRlcnBvbGF0ZShwMFsxXSwgcDFbMV0sIHAyWzFdLCBwM1sxXSwgdywgdzIsIHczKV0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyTWluID0gX3ZlY3Rvci5taW47XG52YXIgdjJNYXggPSBfdmVjdG9yLm1heDtcbnZhciB2MlNjYWxlID0gX3ZlY3Rvci5zY2FsZTtcbnZhciB2MkRpc3RhbmNlID0gX3ZlY3Rvci5kaXN0YW5jZTtcbnZhciB2MkFkZCA9IF92ZWN0b3IuYWRkO1xudmFyIHYyQ2xvbmUgPSBfdmVjdG9yLmNsb25lO1xudmFyIHYyU3ViID0gX3ZlY3Rvci5zdWI7XG5cbi8qKlxuICog6LSd5aGe5bCU5bmz5ruR5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhCZXppZXJcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICogICAgICAgICBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIOe6v+autemhtueCueaVsOe7hFxuICogQHBhcmFtIHtudW1iZXJ9IHNtb290aCDlubPmu5HnrYnnuqcsIDAtMVxuICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbnN0cmFpbnQg5bCG6K6h566X5Ye65p2l55qE5o6n5Yi254K557qm5p2f5Zyo5LiA5Liq5YyF5Zu055uS5YaFXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOavlOWmgiBbWzAsIDBdLCBbMTAwLCAxMDBdXSwg6L+Z5Liq5YyF5Zu055uS5Lya5LiOXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOaVtOS4quaKmOe6v+eahOWMheWbtOebkuWBmuS4gOS4quW5tumbhueUqOadpee6puadn+aOp+WItueCueOAglxuICogQHBhcmFtIHtBcnJheX0g6K6h566X5Ye65p2l55qE5o6n5Yi254K55pWw57uEXG4gKi9cbmZ1bmN0aW9uIF9kZWZhdWx0KHBvaW50cywgc21vb3RoLCBpc0xvb3AsIGNvbnN0cmFpbnQpIHtcbiAgdmFyIGNwcyA9IFtdO1xuICB2YXIgdiA9IFtdO1xuICB2YXIgdjEgPSBbXTtcbiAgdmFyIHYyID0gW107XG4gIHZhciBwcmV2UG9pbnQ7XG4gIHZhciBuZXh0UG9pbnQ7XG4gIHZhciBtaW4sIG1heDtcblxuICBpZiAoY29uc3RyYWludCkge1xuICAgIG1pbiA9IFtJbmZpbml0eSwgSW5maW5pdHldO1xuICAgIG1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2Mk1pbihtaW4sIG1pbiwgcG9pbnRzW2ldKTtcbiAgICAgIHYyTWF4KG1heCwgbWF4LCBwb2ludHNbaV0pO1xuICAgIH0gLy8g5LiO5oyH5a6a55qE5YyF5Zu055uS5YGa5bm26ZuGXG5cblxuICAgIHYyTWluKG1pbiwgbWluLCBjb25zdHJhaW50WzBdKTtcbiAgICB2Mk1heChtYXgsIG1heCwgY29uc3RyYWludFsxXSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgaWYgKGlzTG9vcCkge1xuICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgPyBpIC0gMSA6IGxlbiAtIDFdO1xuICAgICAgbmV4dFBvaW50ID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgIGNwcy5wdXNoKHYyQ2xvbmUocG9pbnRzW2ldKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgLSAxXTtcbiAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2MlN1Yih2LCBuZXh0UG9pbnQsIHByZXZQb2ludCk7IC8vIHVzZSBkZWdyZWUgdG8gc2NhbGUgdGhlIGhhbmRsZSBsZW5ndGhcblxuICAgIHYyU2NhbGUodiwgdiwgc21vb3RoKTtcbiAgICB2YXIgZDAgPSB2MkRpc3RhbmNlKHBvaW50LCBwcmV2UG9pbnQpO1xuICAgIHZhciBkMSA9IHYyRGlzdGFuY2UocG9pbnQsIG5leHRQb2ludCk7XG4gICAgdmFyIHN1bSA9IGQwICsgZDE7XG5cbiAgICBpZiAoc3VtICE9PSAwKSB7XG4gICAgICBkMCAvPSBzdW07XG4gICAgICBkMSAvPSBzdW07XG4gICAgfVxuXG4gICAgdjJTY2FsZSh2MSwgdiwgLWQwKTtcbiAgICB2MlNjYWxlKHYyLCB2LCBkMSk7XG4gICAgdmFyIGNwMCA9IHYyQWRkKFtdLCBwb2ludCwgdjEpO1xuICAgIHZhciBjcDEgPSB2MkFkZChbXSwgcG9pbnQsIHYyKTtcblxuICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICB2Mk1heChjcDAsIGNwMCwgbWluKTtcbiAgICAgIHYyTWluKGNwMCwgY3AwLCBtYXgpO1xuICAgICAgdjJNYXgoY3AxLCBjcDEsIG1pbik7XG4gICAgICB2Mk1pbihjcDEsIGNwMSwgbWF4KTtcbiAgICB9XG5cbiAgICBjcHMucHVzaChjcDApO1xuICAgIGNwcy5wdXNoKGNwMSk7XG4gIH1cblxuICBpZiAoaXNMb29wKSB7XG4gICAgY3BzLnB1c2goY3BzLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIGNwcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvcG9seVwiKTtcblxuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZVxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdwb2x5bGluZScsXG4gIHNoYXBlOiB7XG4gICAgcG9pbnRzOiBudWxsLFxuICAgIHNtb290aDogZmFsc2UsXG4gICAgc21vb3RoQ29uc3RyYWludDogbnVsbFxuICB9LFxuICBzdHlsZToge1xuICAgIHN0cm9rZTogJyMwMDAnLFxuICAgIGZpbGw6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHBvbHlIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUsIGZhbHNlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciByb3VuZFJlY3RIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL3JvdW5kUmVjdFwiKTtcblxuLyoqXG4gKiDnn6nlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1JlY3RcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAncmVjdCcsXG4gIHNoYXBlOiB7XG4gICAgLy8g5bem5LiK44CB5Y+z5LiK44CB5Y+z5LiL44CB5bem5LiL6KeS55qE5Y2K5b6E5L6d5qyh5Li6cjHjgIFyMuOAgXIz44CBcjRcbiAgICAvLyBy57yp5YaZ5Li6MSAgICAgICAgIOebuOW9k+S6jiBbMSwgMSwgMSwgMV1cbiAgICAvLyBy57yp5YaZ5Li6WzFdICAgICAgIOebuOW9k+S6jiBbMSwgMSwgMSwgMV1cbiAgICAvLyBy57yp5YaZ5Li6WzEsIDJdICAgIOebuOW9k+S6jiBbMSwgMiwgMSwgMl1cbiAgICAvLyBy57yp5YaZ5Li6WzEsIDIsIDNdIOebuOW9k+S6jiBbMSwgMiwgMywgMl1cbiAgICByOiAwLFxuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcblxuICAgIGlmICghc2hhcGUucikge1xuICAgICAgY3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdW5kUmVjdEhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSk7XG4gICAgfVxuXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIHJldHVybjtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxuLyoqXG4gKiDnm7Tnur9cbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL0xpbmVcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnbGluZScsXG4gIHNoYXBlOiB7XG4gICAgLy8gU3RhcnQgcG9pbnRcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICAvLyBFbmQgcG9pbnRcbiAgICB4MjogMCxcbiAgICB5MjogMCxcbiAgICBwZXJjZW50OiAxXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHgxID0gc2hhcGUueDE7XG4gICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgdmFyIHkyID0gc2hhcGUueTI7XG4gICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xuXG4gICAgaWYgKHBlcmNlbnQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG5cbiAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgIHgyID0geDEgKiAoMSAtIHBlcmNlbnQpICsgeDIgKiBwZXJjZW50O1xuICAgICAgeTIgPSB5MSAqICgxIC0gcGVyY2VudCkgKyB5MiAqIHBlcmNlbnQ7XG4gICAgfVxuXG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICBwb2ludEF0OiBmdW5jdGlvbiAocCkge1xuICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgcmV0dXJuIFtzaGFwZS54MSAqICgxIC0gcCkgKyBzaGFwZS54MiAqIHAsIHNoYXBlLnkxICogKDEgLSBwKSArIHNoYXBlLnkyICogcF07XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciB2ZWMyID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgX2N1cnZlID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvY3VydmVcIik7XG5cbnZhciBxdWFkcmF0aWNTdWJkaXZpZGUgPSBfY3VydmUucXVhZHJhdGljU3ViZGl2aWRlO1xudmFyIGN1YmljU3ViZGl2aWRlID0gX2N1cnZlLmN1YmljU3ViZGl2aWRlO1xudmFyIHF1YWRyYXRpY0F0ID0gX2N1cnZlLnF1YWRyYXRpY0F0O1xudmFyIGN1YmljQXQgPSBfY3VydmUuY3ViaWNBdDtcbnZhciBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgPSBfY3VydmUucXVhZHJhdGljRGVyaXZhdGl2ZUF0O1xudmFyIGN1YmljRGVyaXZhdGl2ZUF0ID0gX2N1cnZlLmN1YmljRGVyaXZhdGl2ZUF0O1xuXG4vKipcbiAqIOi0neWhnuWwlOabsue6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL0JlemllckN1cnZlXG4gKi9cbnZhciBvdXQgPSBbXTtcblxuZnVuY3Rpb24gc29tZVZlY3RvckF0KHNoYXBlLCB0LCBpc1RhbmdlbnQpIHtcbiAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xuICB2YXIgY3B5MiA9IHNoYXBlLmNweTI7XG5cbiAgaWYgKGNweDIgPT09IG51bGwgfHwgY3B5MiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbKGlzVGFuZ2VudCA/IGN1YmljRGVyaXZhdGl2ZUF0IDogY3ViaWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLmNweDIsIHNoYXBlLngyLCB0KSwgKGlzVGFuZ2VudCA/IGN1YmljRGVyaXZhdGl2ZUF0IDogY3ViaWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLmNweTIsIHNoYXBlLnkyLCB0KV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFsoaXNUYW5nZW50ID8gcXVhZHJhdGljRGVyaXZhdGl2ZUF0IDogcXVhZHJhdGljQXQpKHNoYXBlLngxLCBzaGFwZS5jcHgxLCBzaGFwZS54MiwgdCksIChpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLnkyLCB0KV07XG4gIH1cbn1cblxudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnYmV6aWVyLWN1cnZlJyxcbiAgc2hhcGU6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB4MjogMCxcbiAgICB5MjogMCxcbiAgICBjcHgxOiAwLFxuICAgIGNweTE6IDAsXG4gICAgLy8gY3B4MjogMCxcbiAgICAvLyBjcHkyOiAwXG4gICAgLy8gQ3VydmUgc2hvdyBwZXJjZW50LCBmb3IgYW5pbWF0aW5nXG4gICAgcGVyY2VudDogMVxuICB9LFxuICBzdHlsZToge1xuICAgIHN0cm9rZTogJyMwMDAnLFxuICAgIGZpbGw6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4MSA9IHNoYXBlLngxO1xuICAgIHZhciB5MSA9IHNoYXBlLnkxO1xuICAgIHZhciB4MiA9IHNoYXBlLngyO1xuICAgIHZhciB5MiA9IHNoYXBlLnkyO1xuICAgIHZhciBjcHgxID0gc2hhcGUuY3B4MTtcbiAgICB2YXIgY3B5MSA9IHNoYXBlLmNweTE7XG4gICAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xuICAgIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcbiAgICB2YXIgcGVyY2VudCA9IHNoYXBlLnBlcmNlbnQ7XG5cbiAgICBpZiAocGVyY2VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblxuICAgIGlmIChjcHgyID09IG51bGwgfHwgY3B5MiA9PSBudWxsKSB7XG4gICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKHgxLCBjcHgxLCB4MiwgcGVyY2VudCwgb3V0KTtcbiAgICAgICAgY3B4MSA9IG91dFsxXTtcbiAgICAgICAgeDIgPSBvdXRbMl07XG4gICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZSh5MSwgY3B5MSwgeTIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgIHkyID0gb3V0WzJdO1xuICAgICAgfVxuXG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjcHgxLCBjcHkxLCB4MiwgeTIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgY3ViaWNTdWJkaXZpZGUoeDEsIGNweDEsIGNweDIsIHgyLCBwZXJjZW50LCBvdXQpO1xuICAgICAgICBjcHgxID0gb3V0WzFdO1xuICAgICAgICBjcHgyID0gb3V0WzJdO1xuICAgICAgICB4MiA9IG91dFszXTtcbiAgICAgICAgY3ViaWNTdWJkaXZpZGUoeTEsIGNweTEsIGNweTIsIHkyLCBwZXJjZW50LCBvdXQpO1xuICAgICAgICBjcHkxID0gb3V0WzFdO1xuICAgICAgICBjcHkyID0gb3V0WzJdO1xuICAgICAgICB5MiA9IG91dFszXTtcbiAgICAgIH1cblxuICAgICAgY3R4LmJlemllckN1cnZlVG8oY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgeDIsIHkyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBwb2ludCBhdCBwZXJjZW50XG4gICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHBvaW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHNvbWVWZWN0b3JBdCh0aGlzLnNoYXBlLCB0LCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0YW5nZW50IGF0IHBlcmNlbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgdGFuZ2VudEF0OiBmdW5jdGlvbiAodCkge1xuICAgIHZhciBwID0gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIHRydWUpO1xuICAgIHJldHVybiB2ZWMyLm5vcm1hbGl6ZShwLCBwKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5ZyG5bynXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9BcmNcbiAqL1xudmFyIF9kZWZhdWx0ID0gUGF0aC5leHRlbmQoe1xuICB0eXBlOiAnYXJjJyxcbiAgc2hhcGU6IHtcbiAgICBjeDogMCxcbiAgICBjeTogMCxcbiAgICByOiAwLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICB9LFxuICBzdHlsZToge1xuICAgIHN0cm9rZTogJyMwMDAnLFxuICAgIGZpbGw6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICB2YXIgciA9IE1hdGgubWF4KHNoYXBlLnIsIDApO1xuICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICB2YXIgY2xvY2t3aXNlID0gc2hhcGUuY2xvY2t3aXNlO1xuICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIHZhciB1bml0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC5tb3ZlVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0FyYy5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBHcmFkaWVudCA9IHJlcXVpcmUoXCIuL0dyYWRpZW50XCIpO1xuXG4vKipcbiAqIHgsIHksIHgyLCB5MiBhcmUgYWxsIHBlcmNlbnQgZnJvbSAwIHRvIDFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW3gyPTFdXG4gKiBAcGFyYW0ge251bWJlcn0gW3kyPTBdXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjb2xvclN0b3BzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxDb29yZD1mYWxzZV1cbiAqL1xudmFyIExpbmVhckdyYWRpZW50ID0gZnVuY3Rpb24gKHgsIHksIHgyLCB5MiwgY29sb3JTdG9wcywgZ2xvYmFsQ29vcmQpIHtcbiAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAvLyBkZWNsYXJkIGJ5IGBjb2xvcjoge3R5cGU6ICdsaW5lYXInLCBjb2xvclN0b3BzOiAuLi59YCwgd2hlcmVcbiAgLy8gdGhpcyBjb25zdHJ1Y3RvciB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gIHRoaXMueCA9IHggPT0gbnVsbCA/IDAgOiB4O1xuICB0aGlzLnkgPSB5ID09IG51bGwgPyAwIDogeTtcbiAgdGhpcy54MiA9IHgyID09IG51bGwgPyAxIDogeDI7XG4gIHRoaXMueTIgPSB5MiA9PSBudWxsID8gMCA6IHkyOyAvLyBDYW4gYmUgY2xvbmVkXG5cbiAgdGhpcy50eXBlID0gJ2xpbmVhcic7IC8vIElmIHVzZSBnbG9iYWwgY29vcmRcblxuICB0aGlzLmdsb2JhbCA9IGdsb2JhbENvb3JkIHx8IGZhbHNlO1xuICBHcmFkaWVudC5jYWxsKHRoaXMsIGNvbG9yU3RvcHMpO1xufTtcblxuTGluZWFyR3JhZGllbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTGluZWFyR3JhZGllbnRcbn07XG56clV0aWwuaW5oZXJpdHMoTGluZWFyR3JhZGllbnQsIEdyYWRpZW50KTtcbnZhciBfZGVmYXVsdCA9IExpbmVhckdyYWRpZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBHcmFkaWVudCA9IHJlcXVpcmUoXCIuL0dyYWRpZW50XCIpO1xuXG4vKipcbiAqIHgsIHksIHIgYXJlIGFsbCBwZXJjZW50IGZyb20gMCB0byAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MC41XVxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTAuNV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcj0wLjVdXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbY29sb3JTdG9wc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICovXG52YXIgUmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgciwgY29sb3JTdG9wcywgZ2xvYmFsQ29vcmQpIHtcbiAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAvLyBkZWNsYXJkIGJ5IGBjb2xvcjoge3R5cGU6ICdyYWRpYWwnLCBjb2xvclN0b3BzOiAuLi59YCwgd2hlcmVcbiAgLy8gdGhpcyBjb25zdHJ1Y3RvciB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gIHRoaXMueCA9IHggPT0gbnVsbCA/IDAuNSA6IHg7XG4gIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAuNSA6IHk7XG4gIHRoaXMuciA9IHIgPT0gbnVsbCA/IDAuNSA6IHI7IC8vIENhbiBiZSBjbG9uZWRcblxuICB0aGlzLnR5cGUgPSAncmFkaWFsJzsgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuXG4gIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG4gIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG59O1xuXG5SYWRpYWxHcmFkaWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBSYWRpYWxHcmFkaWVudFxufTtcbnpyVXRpbC5pbmhlcml0cyhSYWRpYWxHcmFkaWVudCwgR3JhZGllbnQpO1xudmFyIF9kZWZhdWx0ID0gUmFkaWFsR3JhZGllbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgenJVdGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vU3R5bGVcIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgdmVjMkNvcHkgPSBfdmVjdG9yLmNvcHk7XG5cbi8qKlxuICogU3RhdGVzIG1hY2hpbmUgZm9yIG1hbmFnaW5nIGdyYXBoaWMgc3RhdGVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJR3JhcGhpY1N0YXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3psZXZlbF1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbel1cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj59IHtwb3NpdGlvbn1cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVtYmVyfSB7cm90YXRpb259XG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSB7c2NhbGV9XG4gKiBAcHJvcGVydHkge09iamVjdH0gc3R5bGVcbiAqXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvbmVudGVyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvbmxlYXZlXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvbnRyYW5zaXRpb25cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPElHcmFwaGljU3RhdGVUcmFuc2l0aW9ufHN0cmluZz59IHRyYW5zaXRpb25cbiAqICAgICAgICAgICBUcmFuc2l0aW9uIG9iamVjdCBvciBhIHN0cmluZyBkZXNjcmlwdG9yIGxpa2UgJyogMzAgMCBMaW5lYXInXG4gKi9cbnZhciB0cmFuc2l0aW9uUHJvcGVydGllcyA9IFsncG9zaXRpb24nLCAncm90YXRpb24nLCAnc2NhbGUnLCAnc3R5bGUnLCAnc2hhcGUnXTtcbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvU3RhdGVzflRyYW5zaXRpb25PYmplY3RcbiAqL1xuXG52YXIgVHJhbnNpdGlvbk9iamVjdCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PSAnc3RyaW5nJykge1xuICAgIHRoaXMuX2Zyb21TdHIob3B0cyk7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIG9wdHMucHJvcGVydHkgJiYgKHRoaXMucHJvcGVydHkgPSBvcHRzLnByb3BlcnR5KTtcbiAgICBvcHRzLmR1cmF0aW9uICE9IG51bGwgJiYgKHRoaXMuZHVyYXRpb24gPSBvcHRzLmR1cmF0aW9uKTtcbiAgICBvcHRzLmVhc2luZyAmJiAodGhpcy5lYXNpbmcgPSBvcHRzLmVhc2luZyk7XG4gICAgb3B0cy5kZWxheSAmJiAodGhpcy5kZWxheSA9IG9wdHMuZGVsYXkpO1xuICB9XG5cbiAgaWYgKHRoaXMucHJvcGVydHkgIT09ICcqJykge1xuICAgIHRoaXMucHJvcGVydHkgPSB0aGlzLnByb3BlcnR5LnNwbGl0KCcsJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcm9wZXJ0eSA9IHRyYW5zaXRpb25Qcm9wZXJ0aWVzO1xuICB9XG59O1xuXG5UcmFuc2l0aW9uT2JqZWN0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zaXRpb25PYmplY3QsXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYWxsIHRyYW5zaXRpb24gcHJvcGVydGllcy4gU3BsaXR0ZWQgYnkgY29tbWEuIE11c3Qgbm90IGhhdmUgc3BhY2VzIGluIHRoZSBzdHJpbmcuXG4gICAqIGUuZy4gJ3Bvc2l0aW9uLHN0eWxlLmNvbG9yJy4gJyonIHdpbGwgbWF0Y2ggYWxsIHRoZSB2YWxpZCBwcm9wZXJ0aWVzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAqXG4gICAqL1xuICBwcm9wZXJ0eTogJyonLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnTGluZWFyJ1xuICAgKi9cbiAgZWFzaW5nOiAnTGluZWFyJyxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgJ251bWJlcidcbiAgICovXG4gIGR1cmF0aW9uOiA1MDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBkZWxheTogMCxcbiAgX2Zyb21TdHI6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgYXJyID0gc3RyLnNwbGl0KC9cXHMrL2cpO1xuICAgIHRoaXMucHJvcGVydHkgPSBhcnJbMF07XG4gICAgdGhpcy5kdXJhdGlvbiA9ICthcnJbMV07XG4gICAgdGhpcy5kZWxheSA9ICthcnJbMl07XG4gICAgdGhpcy5lYXNpbmcgPSBhcnJbM107XG4gIH1cbn07XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL1N0YXRlc1xuICovXG5cbnZhciBHcmFwaGljU3RhdGVzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMuX3N0YXRlcyA9IHt9O1xuICAvKipcbiAgICogVGFyZ2V0IGVsZW1lbnRcbiAgICogQHR5cGUge3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZXx6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICovXG5cbiAgdGhpcy5fZWwgPSBvcHRzLmVsO1xuICB0aGlzLl9zdWJTdGF0ZXMgPSBbXTtcbiAgdGhpcy5fdHJhbnNpdGlvbkFuaW1hdG9ycyA9IFtdO1xuXG4gIGlmIChvcHRzLmluaXRpYWxTdGF0ZSkge1xuICAgIHRoaXMuX2luaXRpYWxTdGF0ZSA9IG9wdHMuaW5pdGlhbFN0YXRlO1xuICB9XG5cbiAgdmFyIG9wdHNTdGF0ZXMgPSBvcHRzLnN0YXRlcztcblxuICBpZiAob3B0c1N0YXRlcykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gb3B0c1N0YXRlcykge1xuICAgICAgaWYgKG9wdHNTdGF0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gb3B0c1N0YXRlc1tuYW1lXTtcblxuICAgICAgICB0aGlzLl9hZGRTdGF0ZShuYW1lLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zZXRTdGF0ZSh0aGlzLl9pbml0aWFsU3RhdGUpO1xufTtcblxuR3JhcGhpY1N0YXRlcy5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBHcmFwaGljU3RhdGVzLFxuXG4gIC8qKlxuICAgKiBBbGwgb3RoZXIgc3RhdGUgd2lsbCBiZSBleHRlbmRlZCBmcm9tIGluaXRpYWwgc3RhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0aWFsU3RhdGU6ICdub3JtYWwnLFxuXG4gIC8qKlxuICAgKiBDdXJyZW50IHN0YXRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3VycmVudFN0YXRlOiAnJyxcbiAgZWw6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWw7XG4gIH0sXG4gIF9hZGRTdGF0ZTogZnVuY3Rpb24gKG5hbWUsIHN0YXRlKSB7XG4gICAgdGhpcy5fc3RhdGVzW25hbWVdID0gc3RhdGU7XG5cbiAgICBpZiAoc3RhdGUudHJhbnNpdGlvbikge1xuICAgICAgc3RhdGUudHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uT2JqZWN0KHN0YXRlLnRyYW5zaXRpb24pO1xuICAgIH0gLy8gRXh0ZW5kIGZyb20gaW5pdGlhbCBzdGF0ZVxuXG5cbiAgICBpZiAobmFtZSAhPT0gdGhpcy5faW5pdGlhbFN0YXRlKSB7XG4gICAgICB0aGlzLl9leHRlbmRGcm9tSW5pdGlhbChzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbCA9IHRoaXMuX2VsOyAvLyBzZXRTdGF0ZSDnmoTml7blgJnoh6rluKbnmoQgc3R5bGUg5ZKMIHNoYXBlIOmDveS8muiiq+ebtOaOpeimhuebllxuICAgICAgLy8g5omA5Lul6L+Z6L655YWI5oqK6Ieq5bim55qEIHN0eWxlIOWSjCBzaGFwZSDmianlsZXliLDliJ3lp4vnirbmgIHkuK1cblxuICAgICAgenJVdGlsLm1lcmdlKHN0YXRlLnN0eWxlLCBlbC5zdHlsZSwgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgaWYgKHN0YXRlLnNoYXBlKSB7XG4gICAgICAgIHpyVXRpbC5tZXJnZShzdGF0ZS5zaGFwZSwgZWwuc2hhcGUsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnNoYXBlID0genJVdGlsLmNsb25lKGVsLnNoYXBlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLl9zdGF0ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHRoaXMuX2V4dGVuZEZyb21Jbml0aWFsKHRoaXMuX3N0YXRlc1tuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIF9leHRlbmRGcm9tSW5pdGlhbDogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuX3N0YXRlc1t0aGlzLl9pbml0aWFsU3RhdGVdO1xuXG4gICAgaWYgKGluaXRpYWxTdGF0ZSAmJiBzdGF0ZSAhPT0gaW5pdGlhbFN0YXRlKSB7XG4gICAgICB6clV0aWwubWVyZ2Uoc3RhdGUsIGluaXRpYWxTdGF0ZSwgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgfSxcbiAgc2V0U3RhdGU6IGZ1bmN0aW9uIChuYW1lLCBzaWxlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gdGhpcy5fY3VycmVudFN0YXRlICYmICF0aGlzLnRyYW5zaXRpbmcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlc1tuYW1lXTtcblxuICAgIGlmIChzdGF0ZSkge1xuICAgICAgdGhpcy5fc3RvcFRyYW5zaXRpb24oKTtcblxuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdmFyIHByZXZTdGF0ZSA9IHRoaXMuX3N0YXRlc1t0aGlzLl9jdXJyZW50U3RhdGVdO1xuXG4gICAgICAgIGlmIChwcmV2U3RhdGUpIHtcbiAgICAgICAgICBwcmV2U3RhdGUub25sZWF2ZSAmJiBwcmV2U3RhdGUub25sZWF2ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUub25lbnRlciAmJiBzdGF0ZS5vbmVudGVyLmNhbGwodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IG5hbWU7XG5cbiAgICAgIGlmICh0aGlzLl9lbCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLl9lbDsgLy8gU2V0dGluZyBhdHRyaWJ1dGVzXG5cbiAgICAgICAgaWYgKHN0YXRlLnpsZXZlbCAhPSBudWxsKSB7XG4gICAgICAgICAgZWwuemxldmVsID0gc3RhdGUuemxldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLnogIT0gbnVsbCkge1xuICAgICAgICAgIGVsLnogPSBzdGF0ZS56O1xuICAgICAgICB9IC8vIFNSVFxuXG5cbiAgICAgICAgc3RhdGUucG9zaXRpb24gJiYgdmVjMkNvcHkoZWwucG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgc3RhdGUuc2NhbGUgJiYgdmVjMkNvcHkoZWwuc2NhbGUsIHN0YXRlLnNjYWxlKTtcblxuICAgICAgICBpZiAoc3RhdGUucm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIGVsLnJvdGF0aW9uID0gc3RhdGUucm90YXRpb247XG4gICAgICAgIH0gLy8gU3R5bGVcblxuXG4gICAgICAgIGlmIChzdGF0ZS5zdHlsZSkge1xuICAgICAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLl9zdGF0ZXNbdGhpcy5faW5pdGlhbFN0YXRlXTtcbiAgICAgICAgICBlbC5zdHlsZSA9IG5ldyBTdHlsZSgpO1xuXG4gICAgICAgICAgaWYgKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgZWwuc3R5bGUuZXh0ZW5kRnJvbShpbml0aWFsU3RhdGUuc3R5bGUsIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIC8vIE5vdCBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgbmFtZSAhPSB0aGlzLl9pbml0aWFsU3RhdGUgLy8gTm90IGNvcGllZCBmcm9tIGluaXRpYWwgc3RhdGUgaW4gX2V4dGVuZEZyb21Jbml0aWFsIG1ldGhvZFxuICAgICAgICAgICYmIGluaXRpYWxTdGF0ZS5zdHlsZSAhPT0gc3RhdGUuc3R5bGUpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmV4dGVuZEZyb20oc3RhdGUuc3R5bGUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZS5zaGFwZSkge1xuICAgICAgICAgIGVsLnNoYXBlID0genJVdGlsLmNsb25lKHN0YXRlLnNoYXBlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLmRpcnR5KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdWJTdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3N1YlN0YXRlcy5zZXRTdGF0ZShuYW1lKTtcbiAgICB9XG4gIH0sXG4gIGdldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZTtcbiAgfSxcbiAgdHJhbnNpdGlvblN0YXRlOiBmdW5jdGlvbiAodGFyZ2V0LCBkb25lKSB7XG4gICAgaWYgKHRhcmdldCA9PT0gdGhpcy5fY3VycmVudFN0YXRlICYmICF0aGlzLnRyYW5zaXRpbmcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlc1t0YXJnZXRdO1xuICAgIHZhciBzdHlsZVNoYXBlUmVnID0gLyRbc3R5bGV8c2hhcGVdXFwuLztcbiAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIEFuaW1hdGlvbiDljrvph41cblxuICAgIHZhciBwcm9wUGF0aE1hcCA9IHt9O1xuXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICBzZWxmLl9zdG9wVHJhbnNpdGlvbigpO1xuXG4gICAgICB2YXIgZWwgPSBzZWxmLl9lbDtcblxuICAgICAgaWYgKHN0YXRlLnRyYW5zaXRpb24gJiYgZWwgJiYgZWwuX196cikge1xuICAgICAgICAvLyBFbCBjYW4gYmUgYW5pbWF0ZWRcbiAgICAgICAgdmFyIHRyYW5zaXRpb25DZmcgPSBzdGF0ZS50cmFuc2l0aW9uO1xuICAgICAgICB2YXIgcHJvcGVydHkgPSB0cmFuc2l0aW9uQ2ZnLnByb3BlcnR5O1xuICAgICAgICB2YXIgYW5pbWF0aW5nQ291bnQgPSAwO1xuXG4gICAgICAgIHZhciBhbmltYXRpb25Eb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGFuaW1hdGluZ0NvdW50LS07XG5cbiAgICAgICAgICBpZiAoYW5pbWF0aW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHNlbGYuc2V0U3RhdGUodGFyZ2V0KTtcbiAgICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlbaV07IC8vIEFuaW1hdGluZyBhbGwgdGhlIHByb3BlcnRpZXMgaW4gc3R5bGUgb3Igc2hhcGVcblxuICAgICAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3N0eWxlJyB8fCBwcm9wTmFtZSA9PT0gJ3NoYXBlJykge1xuICAgICAgICAgICAgaWYgKHN0YXRlW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3RhdGVbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZVtwcm9wTmFtZV0uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBwcm9wTmFtZSArICcuJyArIGtleTtcblxuICAgICAgICAgICAgICAgIGlmIChwcm9wUGF0aE1hcFtwYXRoXSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJvcFBhdGhNYXBbcGF0aF0gPSAxO1xuICAgICAgICAgICAgICAgIGFuaW1hdGluZ0NvdW50ICs9IHNlbGYuX2FuaW1Qcm9wKHN0YXRlLCBwcm9wTmFtZSwga2V5LCB0cmFuc2l0aW9uQ2ZnLCBhbmltYXRpb25Eb25lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvcFBhdGhNYXBbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9wUGF0aE1hcFtwcm9wTmFtZV0gPSAxOyAvLyBBbmltYXRpbmcgcGFydGljdWxhciBwcm9wZXJ0eSBpbiBzdHlsZSBvciBzdHlsZVxuXG4gICAgICAgICAgICBpZiAocHJvcE5hbWUubWF0Y2goc3R5bGVTaGFwZVJlZykpIHtcbiAgICAgICAgICAgICAgLy8gcmVtb3ZlICdzdHlsZS4nLCAnc2hhcGUuJyBwcmVmaXhcbiAgICAgICAgICAgICAgdmFyIHN1YlByb3AgPSBwcm9wTmFtZS5zbGljZSgwLCA1KTtcbiAgICAgICAgICAgICAgcHJvcE5hbWUgPSBwcm9wTmFtZS5zbGljZSg2KTtcbiAgICAgICAgICAgICAgYW5pbWF0aW5nQ291bnQgKz0gc2VsZi5fYW5pbVByb3Aoc3RhdGUsIHN1YlByb3AsIHByb3BOYW1lLCB0cmFuc2l0aW9uQ2ZnLCBhbmltYXRpb25Eb25lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFuaW1hdGluZ0NvdW50ICs9IHNlbGYuX2FuaW1Qcm9wKHN0YXRlLCAnJywgcHJvcE5hbWUsIHRyYW5zaXRpb25DZmcsIGFuaW1hdGlvbkRvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBObyB0cmFuc2l0aW9uIHByb3BlcnRpZXNcblxuXG4gICAgICAgIGlmIChhbmltYXRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgIHNlbGYuc2V0U3RhdGUodGFyZ2V0KTtcbiAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5zZXRTdGF0ZSh0YXJnZXQpO1xuICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3ViU3RhdGVzID0gc2VsZi5fc3ViU3RhdGVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJTdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN1YlN0YXRlcy50cmFuc2l0aW9uU3RhdGUodGFyZ2V0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERvIHRyYW5zaXRpb24gYW5pbWF0aW9uIG9mIHBhcnRpY3VsYXIgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJQcm9wS2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zaXRpb25DZmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FuaW1Qcm9wOiBmdW5jdGlvbiAoc3RhdGUsIHN1YlByb3BLZXksIGtleSwgdHJhbnNpdGlvbkNmZywgZG9uZSkge1xuICAgIHZhciBlbCA9IHRoaXMuX2VsO1xuICAgIHZhciBzdGF0ZU9iaiA9IHN1YlByb3BLZXkgPyBzdGF0ZVtzdWJQcm9wS2V5XSA6IHN0YXRlO1xuICAgIHZhciBlbE9iaiA9IHN1YlByb3BLZXkgPyBlbFtzdWJQcm9wS2V5XSA6IGVsO1xuICAgIHZhciBhdmFpbGFibGVQcm9wID0gc3RhdGVPYmogJiYga2V5IGluIHN0YXRlT2JqICYmIGVsT2JqICYmIGtleSBpbiBlbE9iajtcbiAgICB2YXIgdHJhbnNpdGlvbkFuaW1hdG9ycyA9IHRoaXMuX3RyYW5zaXRpb25BbmltYXRvcnM7XG5cbiAgICBpZiAoYXZhaWxhYmxlUHJvcCkge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuXG4gICAgICBpZiAoc3RhdGVPYmpba2V5XSA9PT0gZWxPYmpba2V5XSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgb2JqW2tleV0gPSBzdGF0ZU9ialtrZXldO1xuICAgICAgdmFyIGFuaW1hdG9yID0gZWwuYW5pbWF0ZShzdWJQcm9wS2V5KS53aGVuKHRyYW5zaXRpb25DZmcuZHVyYXRpb24sIG9iaikuZGVsYXkodHJhbnNpdGlvbkNmZy5kZWFseSkuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHggPSB6clV0aWwuaW5kZXhPZih0cmFuc2l0aW9uQW5pbWF0b3JzLCAxKTtcblxuICAgICAgICBpZiAoaWR4ID4gMCkge1xuICAgICAgICAgIHRyYW5zaXRpb25BbmltYXRvcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBkb25lKCk7XG4gICAgICB9KS5zdGFydCh0cmFuc2l0aW9uQ2ZnLmVhc2luZyk7XG4gICAgICB0cmFuc2l0aW9uQW5pbWF0b3JzLnB1c2goYW5pbWF0b3IpO1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIF9zdG9wVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0cmFuc2l0aW9uQW5pbWF0b3JzID0gdGhpcy5fdHJhbnNpdGlvbkFuaW1hdG9ycztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNpdGlvbkFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJhbnNpdGlvbkFuaW1hdG9yc1tpXS5zdG9wKCk7XG4gICAgfVxuXG4gICAgdHJhbnNpdGlvbkFuaW1hdG9ycy5sZW5ndGggPSAwO1xuICB9LFxuICB0cmFuc2l0aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25BbmltYXRvcnMubGVuZ3RoID4gMDtcbiAgfSxcbiAgYWRkU3ViU3RhdGVzOiBmdW5jdGlvbiAoc3RhdGVzKSB7XG4gICAgdGhpcy5fc3ViU3RhdGVzLnB1c2goc3RhdGVzKTtcbiAgfSxcbiAgcmVtb3ZlU3ViU3RhdGVzOiBmdW5jdGlvbiAoc3RhdGVzKSB7XG4gICAgdmFyIGlkeCA9IHpyVXRpbC5pbmRleE9mKHRoaXMuX3N1YlN0YXRlcywgc3RhdGVzKTtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgdGhpcy5fc3ViU3RhdGVzLnNwbGljZShzdGF0ZXMsIDEpO1xuICAgIH1cbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEdyYXBoaWNTdGF0ZXM7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1N0YXRlcy5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIHZhciBhcGlMaXN0ID0gW1xyXG4gICAgICAgICdnZXREb20nLCAnZ2V0WnInLCAnZ2V0V2lkdGgnLCAnZ2V0SGVpZ2h0JywgJ2Rpc3BhdGNoQWN0aW9uJyxcclxuICAgICAgICAnb24nLCAnb2ZmJywgJ3RyaWdnZXInLCAnZ2V0RGF0YVVSTCcsICdnZXRDb25uZWN0ZWREYXRhVVJMJywgJ2dldE1vZGVsJywgJ2dldE9wdGlvbicsXHJcbiAgICAgICAgXCJyZW1vdmVcIiwgXCJfZ2V0UGFyZW50WnJcIlxyXG4gICAgXTtcclxuXHJcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25BUEkoaW5zdGFuY2UpIHtcclxuICAgICAgICB6clV0aWwuZWFjaChhcGlMaXN0LCBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzW25hbWVdID0genJVdGlsLmJpbmQoaW5zdGFuY2VbbmFtZV0sIGluc3RhbmNlKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV4dGVuc2lvbkFQSTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9FeHRlbnNpb25BcGkuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUG9pbnRcclxuICAgICAgKlxyXG4gICAgICAqXHJcbiAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICogQHRoaXMge1BvaW50fVxyXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgb2YgcG9pbnQuXHJcbiAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSBvZiBwb2ludC5cclxuICAgICAgKiBOb3RlOiBFdmVuIGlmIGl0IGlzIG5hbWVkIFBvaW50IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIG5hbWVkIERvdCBhcyBEb3QgaXMgY2xvc2VyXHJcbiAgICAgICogdGhlbiBQb2ludCBmcm9tIG1hdGggcGVyc3BlY3RpdmUuXHJcbiAgICAgICoqL1xyXG4gICAgZnVuY3Rpb24gUG9pbnQoeCwgeSl7XHJcbiAgICAgICAgLyoqVGhlIHggY29vcmRpbmF0ZSBvZiBwb2ludCovXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuXHJcbiAgICAgICAgLyoqVGhlIHkgY29vcmRpbmF0ZSBvZiBwb2ludCovXHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKkNyZWF0ZXMgYSB7UG9pbnR9IG91dCBvZiBKU09OIHBhcnNlZCBvYmplY3RcclxuICAgICAqQHBhcmFtIHtKU09OT2JqZWN0fSBvIC0gdGhlIEpTT04gcGFyc2VkIG9iamVjdFxyXG4gICAgICpAcmV0dXJuIHtQb2ludH0gYSBuZXdseSBjb25zdHJ1Y3RlZCBQb2ludFxyXG4gICAgICoqL1xyXG4gICAgUG9pbnQubG9hZCA9IGZ1bmN0aW9uKG8pe1xyXG4gICAgICAgIHZhciBuZXdQb2ludCA9IG5ldyBQb2ludChOdW1iZXIoby54KSwgTnVtYmVyKG8ueSkpO1xyXG4gICAgICAgIHJldHVybiBuZXdQb2ludDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKkNyZWF0ZXMgYW4gYXJyYXkgb2YgcG9pbnRzIGZyb20gYW4gYXJyYXkgb2Yge0pTT05PYmplY3R9c1xyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gdGhlIGFycmF5IG9mIEpTT05PYmplY3RzXHJcbiAgICAgKkByZXR1cm4gYW4ge0FycmF5fSBvZiB7UG9pbnR9c1xyXG4gICAgICoqL1xyXG4gICAgUG9pbnQubG9hZEFycmF5ID0gZnVuY3Rpb24odil7XHJcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPCB2Lmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2goUG9pbnQubG9hZCh2W2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdQb2ludHM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipDbG9uZXMgYW4gYXJyYXkgb2YgcG9pbnRzXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSB0aGUgYXJyYXkgb2Yge1BvaW50fXNcclxuICAgICAqQHJldHVybiBhbiB7QXJyYXl9IG9mIHtQb2ludH1zXHJcbiAgICAgKiovXHJcbiAgICBQb2ludC5jbG9uZUFycmF5ID0gZnVuY3Rpb24odil7XHJcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPCB2Lmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2godltpXS5jbG9uZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1BvaW50cztcclxuICAgIH07XHJcblxyXG4gICAgUG9pbnQucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yIDogUG9pbnQsXHJcblxyXG4gICAgICAgIHRyYW5zZm9ybTpmdW5jdGlvbihtYXRyaXgpe1xyXG4gICAgICAgICAgICB2YXIgb2xkWCA9IHRoaXMueDtcclxuICAgICAgICAgICAgdmFyIG9sZFkgPSB0aGlzLnk7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IG1hdHJpeFswXVswXSAqIG9sZFggKyBtYXRyaXhbMF1bMV0gKiBvbGRZICsgbWF0cml4WzBdWzJdO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBtYXRyaXhbMV1bMF0gKiBvbGRYICsgbWF0cml4WzFdWzFdICogb2xkWSArIG1hdHJpeFsxXVsyXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipUZXN0cyBpZiB0aGlzIHBvaW50IGlzIHNpbWlsYXIgdG8gb3RoZXIgcG9pbnRcclxuICAgICAgICAgKkBwYXJhbSB7UG9pbnR9IGFub3RoZXJQb2ludCAtIHRoZSBvdGhlciBwb2ludFxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBlcXVhbHM6ZnVuY3Rpb24oYW5vdGhlclBvaW50KXtcclxuICAgICAgICAgICAgaWYoISAoYW5vdGhlclBvaW50IGluc3RhbmNlb2YgUG9pbnQpICl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnggPT0gYW5vdGhlclBvaW50LngpXHJcbiAgICAgICAgICAgICYmICh0aGlzLnkgPT0gYW5vdGhlclBvaW50LnkpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqQ2xvbmUgY3VycmVudCBQb2ludFxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIG5ld1BvaW50ID0gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1BvaW50O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFkZDogZnVuY3Rpb24ocG9pbnQpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy54ICsgcG9pbnQueDtcclxuICAgICAgICAgICAgdGhpcy55ID0gdGhpcy55ICsgcG9pbnQueTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqVGVzdHMgdG8gc2VlIGlmIGEgcG9pbnQgKHgsIHkpIGlzIHdpdGhpbiBhIHJhbmdlIG9mIGN1cnJlbnQgUG9pbnRcclxuICAgICAgICAgKkBwYXJhbSB7TnVtZXJpY30geCAtIHRoZSB4IGNvb3JkaW5hdGUgb2YgdGVzdGVkIHBvaW50XHJcbiAgICAgICAgICpAcGFyYW0ge051bWVyaWN9IHkgLSB0aGUgeCBjb29yZGluYXRlIG9mIHRlc3RlZCBwb2ludFxyXG4gICAgICAgICAqQHBhcmFtIHtOdW1lcmljfSByYWRpdXMgLSB0aGUgcmFkaXVzIG9mIHRoZSB2aWNpbml0eVxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBuZWFyOmZ1bmN0aW9uKHgsIHksIHJhZGl1cyl7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLnggLSB4LCAyKSArIE1hdGgucG93KHRoaXMueSAtIHksIDIpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoZGlzdGFuY2UgPD0gcmFkaXVzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjb250YWluczogZnVuY3Rpb24oeCx5KXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCA9PSB4ICYmIHRoaXMueSA9PSB5O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRvU3RyaW5nOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiAnWycgKyB0aGlzLnggKyAnLCcgKyB0aGlzLnkgKyAnXSc7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0UG9pbnRzOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiBbdGhpc107XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Qb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGd1aWQgPSByZXF1aXJlKFwiLi9jb3JlL2d1aWRcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi9jb3JlL2VudlwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIEhhbmRsZXIgPSByZXF1aXJlKFwiLi9IYW5kbGVyXCIpO1xuXG52YXIgU3RvcmFnZSA9IHJlcXVpcmUoXCIuL1N0b3JhZ2VcIik7XG5cbnZhciBQYWludGVyID0gcmVxdWlyZShcIi4vUGFpbnRlclwiKTtcblxudmFyIEFuaW1hdGlvbiA9IHJlcXVpcmUoXCIuL2FuaW1hdGlvbi9BbmltYXRpb25cIik7XG5cbnZhciBIYW5kbGVyUHJveHkgPSByZXF1aXJlKFwiLi9kb20vSGFuZGxlclByb3h5XCIpO1xuXG4vKiFcbiogWlJlbmRlciwgYSBoaWdoIHBlcmZvcm1hbmNlIDJkIGRyYXdpbmcgbGlicmFyeS5cbipcbiogQ29weXJpZ2h0IChjKSAyMDEzLCBCYWlkdSBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIExJQ0VOU0VcbiogaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4qL1xudmFyIHVzZVZNTCA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xudmFyIHBhaW50ZXJDdG9ycyA9IHtcbiAgY2FudmFzOiBQYWludGVyXG59O1xudmFyIGluc3RhbmNlcyA9IHt9OyAvLyBaUmVuZGVy5a6e5L6LbWFw57Si5byVXG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuXG52YXIgdmVyc2lvbiA9ICczLjcuNCc7XG4vKipcbiAqIEluaXRpYWxpemluZyBhIHpyZW5kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLmhlaWdodF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICovXG5cbmZ1bmN0aW9uIGluaXQoZG9tLCBvcHRzKSB7XG4gIHZhciB6ciA9IG5ldyBaUmVuZGVyKGd1aWQoKSwgZG9tLCBvcHRzKTtcbiAgaW5zdGFuY2VzW3pyLmlkXSA9IHpyO1xuICByZXR1cm4genI7XG59XG4vKipcbiAqIERpc3Bvc2UgenJlbmRlciBpbnN0YW5jZVxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICovXG5cblxuZnVuY3Rpb24gZGlzcG9zZSh6cikge1xuICBpZiAoenIpIHtcbiAgICB6ci5kaXNwb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIga2V5IGluIGluc3RhbmNlcykge1xuICAgICAgaWYgKGluc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGluc3RhbmNlc1trZXldLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnN0YW5jZXMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuLyoqXG4gKiBHZXQgenJlbmRlciBpbnN0YW5jZSBieSBpZFxuICogQHBhcmFtIHtzdHJpbmd9IGlkIHpyZW5kZXIgaW5zdGFuY2UgaWRcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZShpZCkge1xuICByZXR1cm4gaW5zdGFuY2VzW2lkXTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJQYWludGVyKG5hbWUsIEN0b3IpIHtcbiAgcGFpbnRlckN0b3JzW25hbWVdID0gQ3Rvcjtcbn1cblxuZnVuY3Rpb24gZGVsSW5zdGFuY2UoaWQpIHtcbiAgZGVsZXRlIGluc3RhbmNlc1tpZF07XG59XG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9aUmVuZGVyXG4gKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9aUmVuZGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICovXG5cblxudmFyIFpSZW5kZXIgPSBmdW5jdGlvbiAoaWQsIGRvbSwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgLyoqXG4gICAqIEB0eXBlIHtIVE1MRG9tRWxlbWVudH1cbiAgICovXG5cbiAgdGhpcy5kb20gPSBkb207XG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cblxuICB0aGlzLmlkID0gaWQ7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpO1xuICB2YXIgcmVuZGVyZXJUeXBlID0gb3B0cy5yZW5kZXJlcjsgLy8gVE9ETyBXZWJHTFxuXG4gIGlmICh1c2VWTUwpIHtcbiAgICBpZiAoIXBhaW50ZXJDdG9ycy52bWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcmVxdWlyZSBcXCd6cmVuZGVyL3ZtbC92bWxcXCcgdG8gc3VwcG9ydCBJRTgnKTtcbiAgICB9XG5cbiAgICByZW5kZXJlclR5cGUgPSAndm1sJztcbiAgfSBlbHNlIGlmICghcmVuZGVyZXJUeXBlIHx8ICFwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXSkge1xuICAgIHJlbmRlcmVyVHlwZSA9ICdjYW52YXMnO1xuICB9XG5cbiAgdmFyIHBhaW50ZXIgPSBuZXcgcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0oZG9tLCBzdG9yYWdlLCBvcHRzKTtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdmFyIGhhbmRlclByb3h5ID0gIWVudi5ub2RlID8gbmV3IEhhbmRsZXJQcm94eShwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKSA6IG51bGw7XG4gIHRoaXMuaGFuZGxlciA9IG5ldyBIYW5kbGVyKHN0b3JhZ2UsIHBhaW50ZXIsIGhhbmRlclByb3h5LCBwYWludGVyLnJvb3QpO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb259XG4gICAqL1xuXG4gIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih7XG4gICAgc3RhZ2U6IHtcbiAgICAgIHVwZGF0ZTogenJVdGlsLmJpbmQodGhpcy5mbHVzaCwgdGhpcylcbiAgICB9XG4gIH0pO1xuICB0aGlzLmFuaW1hdGlvbi5zdGFydCgpO1xuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX25lZWRzUmVmcmVzaDsgLy8g5L+u5pS5IHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UsIOavj+asoeWIoOmZpOWFg+e0oOS5i+WJjeWIoOmZpOWKqOeUu1xuICAvLyBGSVhNRSDmnInngrl1Z2x5XG5cbiAgdmFyIG9sZERlbEZyb21TdG9yYWdlID0gc3RvcmFnZS5kZWxGcm9tU3RvcmFnZTtcbiAgdmFyIG9sZEFkZFRvU3RvcmFnZSA9IHN0b3JhZ2UuYWRkVG9TdG9yYWdlO1xuXG4gIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBvbGREZWxGcm9tU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgICBlbCAmJiBlbC5yZW1vdmVTZWxmRnJvbVpyKHNlbGYpO1xuICB9O1xuXG4gIHN0b3JhZ2UuYWRkVG9TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgb2xkQWRkVG9TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuICAgIGVsLmFkZFNlbGZUb1pyKHNlbGYpO1xuICB9O1xufTtcblxuWlJlbmRlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBaUmVuZGVyLFxuXG4gIC8qKlxuICAgKiDojrflj5blrp7kvovllK/kuIDmoIfor4ZcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0SWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5YWD57SgXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uIChlbCkge1xuICAgIHRoaXMuc3RvcmFnZS5hZGRSb290KGVsKTtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiDliKDpmaTlhYPntKBcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoZWwpO1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoYW5nZSBjb25maWd1cmF0aW9uIG9mIGxheWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6TGV2ZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5jbGVhckNvbG9yPTBdIENsZWFyIGNvbG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIElmIGVuYWJsZSBtb3Rpb24gYmx1clxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddIE1vdGlvbiBibHVyIGZhY3Rvci4gTGFyZ2VyIHZhbHVlIGNhdXNlIGxvbmdlciB0cmFpbGVyXG4gICovXG4gIGNvbmZpZ0xheWVyOiBmdW5jdGlvbiAoekxldmVsLCBjb25maWcpIHtcbiAgICB0aGlzLnBhaW50ZXIuY29uZmlnTGF5ZXIoekxldmVsLCBjb25maWcpO1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGFpbnQgdGhlIGNhbnZhcyBpbW1lZGlhdGVseVxuICAgKi9cbiAgcmVmcmVzaEltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdmFyIHN0YXJ0ID0gbmV3IERhdGUoKTtcbiAgICAvLyBDbGVhciBuZWVkc1JlZnJlc2ggYWhlYWQgdG8gYXZvaWQgc29tZXRoaW5nIHdyb25nIGhhcHBlbnMgaW4gcmVmcmVzaFxuICAgIC8vIE9yIGl0IHdpbGwgY2F1c2UgenJlbmRlciByZWZyZXNoZXMgYWdhaW4gYW5kIGFnYWluLlxuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgIHRoaXMucGFpbnRlci5yZWZyZXNoKCk7XG4gICAgLyoqXG4gICAgICogQXZvaWQgdHJpZ2dlciB6ci5yZWZyZXNoIGluIEVsZW1lbnQjYmVmb3JlVXBkYXRlIGhvb2tcbiAgICAgKi9cblxuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlOyAvLyB2YXIgZW5kID0gbmV3IERhdGUoKTtcbiAgICAvLyB2YXIgbG9nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZycpO1xuICAgIC8vIGlmIChsb2cpIHtcbiAgICAvLyAgICAgbG9nLmlubmVySFRNTCA9IGxvZy5pbm5lckhUTUwgKyAnPGJyPicgKyAoZW5kIC0gc3RhcnQpO1xuICAgIC8vIH1cbiAgfSxcblxuICAvKipcbiAgICogTWFyayBhbmQgcmVwYWludCB0aGUgY2FudmFzIGluIHRoZSBuZXh0IGZyYW1lIG9mIGJyb3dzZXJcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFsbCByZWZyZXNoXG4gICAqL1xuICBmbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2gpIHtcbiAgICAgIHRoaXMucmVmcmVzaEltbWVkaWF0ZWx5KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyKSB7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgZWxlbWVudCB0byBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICovXG4gIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5hZGRIb3Zlcikge1xuICAgICAgdGhpcy5wYWludGVyLmFkZEhvdmVyKGVsLCBzdHlsZSk7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWRkIGVsZW1lbnQgZnJvbSBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICh0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIpIHtcbiAgICAgIHRoaXMucGFpbnRlci5yZW1vdmVIb3ZlcihlbCk7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGhvdmVyIGVsZW1lbnRzIGluIGhvdmVyIGxheWVyXG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5jbGVhckhvdmVyKSB7XG4gICAgICB0aGlzLnBhaW50ZXIuY2xlYXJIb3ZlcigpO1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggaG92ZXIgaW4gbmV4dCBmcmFtZVxuICAgKi9cbiAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGhvdmVyIGltbWVkaWF0ZWx5XG4gICAqL1xuICByZWZyZXNoSG92ZXJJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gZmFsc2U7XG4gICAgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlciAmJiB0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2l6ZSB0aGUgY2FudmFzLlxuICAgKiBTaG91bGQgYmUgaW52b2tlZCB3aGVuIGNvbnRhaW5lciBzaXplIGlzIGNoYW5nZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMucGFpbnRlci5yZXNpemUob3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuICAgIHRoaXMuaGFuZGxlci5yZXNpemUoKTtcbiAgfSxcblxuICAvKipcbiAgICogU3RvcCBhbmQgY2xlYXIgYWxsIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgKi9cbiAgY2xlYXJBbmltYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbi5jbGVhcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY29udGFpbmVyIHdpZHRoXG4gICAqL1xuICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNvbnRhaW5lciBoZWlnaHRcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9ydCB0aGUgY2FudmFzIGFzIEJhc2U2NCBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtiYWNrZ3JvdW5kQ29sb3I9JyNmZmYnXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2U2NCBVUkxcbiAgICovXG4gIC8vIHRvRGF0YVVSTDogZnVuY3Rpb24odHlwZSwgYmFja2dyb3VuZENvbG9yKSB7XG4gIC8vICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFJlbmRlcmVkQ2FudmFzKHtcbiAgLy8gICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAvLyAgICAgfSkudG9EYXRhVVJMKHR5cGUpO1xuICAvLyB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0aW5nIGEgcGF0aCB0byBpbWFnZS5cbiAgICogSXQgaGFzIG11Y2ggYmV0dGVyIHBlcmZvcm1hbmNlIG9mIGRyYXdpbmcgaW1hZ2UgcmF0aGVyIHRoYW4gZHJhd2luZyBhIHZlY3RvciBwYXRoLlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gZVxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgKi9cbiAgcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uIChlLCBkcHIpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludGVyLnBhdGhUb0ltYWdlKGUsIGRwcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IGN1cnNvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgKi9cbiAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgIHRoaXMuaGFuZGxlci5zZXRDdXJzb3JTdHlsZShjdXJzb3JTdHlsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmQgaG92ZXJlZCBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge09iamVjdH0ge3RhcmdldCwgdG9wVGFyZ2V0fVxuICAgKi9cbiAgZmluZEhvdmVyOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZmluZEhvdmVyKHgsIHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCaW5kIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudEhhbmRsZXIgSGFuZGxlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQgb2JqZWN0XG4gICAqL1xuICBvbjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdGhpcy5oYW5kbGVyLm9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogVW5iaW5kIGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXZlbnRIYW5kbGVyXSBIYW5kbGVyIGZ1bmN0aW9uXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgIHRoaXMuaGFuZGxlci5vZmYoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGV2ZW50IG1hbnVhbGx5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgIHRoaXMuaGFuZGxlci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgb2JqZWN0cyBhbmQgdGhlIGNhbnZhcy5cbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoKTtcbiAgICB0aGlzLnBhaW50ZXIuY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcG9zZSBzZWxmLlxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uLnN0b3AoKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5zdG9yYWdlLmRpc3Bvc2UoKTtcbiAgICB0aGlzLnBhaW50ZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gICAgdGhpcy5hbmltYXRpb24gPSB0aGlzLnN0b3JhZ2UgPSB0aGlzLnBhaW50ZXIgPSB0aGlzLmhhbmRsZXIgPSBudWxsO1xuICAgIGRlbEluc3RhbmNlKHRoaXMuaWQpO1xuICB9XG59O1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmRpc3Bvc2UgPSBkaXNwb3NlO1xuZXhwb3J0cy5nZXRJbnN0YW5jZSA9IGdldEluc3RhbmNlO1xuZXhwb3J0cy5yZWdpc3RlclBhaW50ZXIgPSByZWdpc3RlclBhaW50ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3pyZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB1dGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG52YXIgdmVjMiA9IHJlcXVpcmUoXCIuL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgRHJhZ2dhYmxlID0gcmVxdWlyZShcIi4vbWl4aW4vRHJhZ2dhYmxlXCIpO1xuXG52YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwiLi9taXhpbi9FdmVudGZ1bFwiKTtcblxuLyoqXG4gKiBIYW5kbGVyXG4gKiBAbW9kdWxlIHpyZW5kZXIvSGFuZGxlclxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiAgICAgICAgIHBpc3NhbmcgKHNoZW55aS45MTRAZ21haWwuY29tKVxuICovXG52YXIgU0lMRU5UID0gJ3NpbGVudCc7XG5cbmZ1bmN0aW9uIG1ha2VFdmVudFBhY2tldChldmVUeXBlLCB0YXJnZXRJbmZvLCBldmVudCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV2ZVR5cGUsXG4gICAgZXZlbnQ6IGV2ZW50LFxuICAgIC8vIHRhcmdldCBjYW4gb25seSBiZSBhbiBlbGVtZW50IHRoYXQgaXMgbm90IHNpbGVudC5cbiAgICB0YXJnZXQ6IHRhcmdldEluZm8udGFyZ2V0LFxuICAgIC8vIHRvcFRhcmdldCBjYW4gYmUgYSBzaWxlbnQgZWxlbWVudC5cbiAgICB0b3BUYXJnZXQ6IHRhcmdldEluZm8udG9wVGFyZ2V0LFxuICAgIGNhbmNlbEJ1YmJsZTogZmFsc2UsXG4gICAgb2Zmc2V0WDogZXZlbnQuenJYLFxuICAgIG9mZnNldFk6IGV2ZW50LnpyWSxcbiAgICBnZXN0dXJlRXZlbnQ6IGV2ZW50Lmdlc3R1cmVFdmVudCxcbiAgICBwaW5jaFg6IGV2ZW50LnBpbmNoWCxcbiAgICBwaW5jaFk6IGV2ZW50LnBpbmNoWSxcbiAgICBwaW5jaFNjYWxlOiBldmVudC5waW5jaFNjYWxlLFxuICAgIHdoZWVsRGVsdGE6IGV2ZW50LnpyRGVsdGEsXG4gICAgenJCeVRvdWNoOiBldmVudC56ckJ5VG91Y2gsXG4gICAgd2hpY2g6IGV2ZW50LndoaWNoXG4gIH07XG59XG5cbmZ1bmN0aW9uIEVtcHR5UHJveHkoKSB7fVxuXG5FbXB0eVByb3h5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBoYW5kbGVyTmFtZXMgPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J107XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9IYW5kbGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2UgU3RvcmFnZSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvUGFpbnRlcn0gcGFpbnRlciBQYWludGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9kb20vSGFuZGxlclByb3h5fSBwcm94eSBIYW5kbGVyUHJveHkgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYWludGVyUm9vdCBwYWludGVyLnJvb3QgKG5vdCBwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKS5cbiAqL1xuXG52YXIgSGFuZGxlciA9IGZ1bmN0aW9uIChzdG9yYWdlLCBwYWludGVyLCBwcm94eSwgcGFpbnRlclJvb3QpIHtcbiAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdGhpcy5wYWludGVyUm9vdCA9IHBhaW50ZXJSb290O1xuICBwcm94eSA9IHByb3h5IHx8IG5ldyBFbXB0eVByb3h5KCk7XG4gIC8qKlxuICAgKiBQcm94eSBvZiBldmVudC4gY2FuIGJlIERvbSwgV2ViR0xTdXJmYWNlLCBldGMuXG4gICAqL1xuXG4gIHRoaXMucHJveHkgPSBwcm94eTsgLy8gQXR0YWNoIGhhbmRsZXJcblxuICBwcm94eS5oYW5kbGVyID0gdGhpcztcbiAgLyoqXG4gICAqIHt0YXJnZXQsIHRvcFRhcmdldCwgeCwgeX1cbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgdGhpcy5faG92ZXJlZCA9IHt9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0RhdGV9XG4gICAqL1xuXG4gIHRoaXMuX2xhc3RUb3VjaE1vbWVudDtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuX2xhc3RYO1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5fbGFzdFk7XG4gIERyYWdnYWJsZS5jYWxsKHRoaXMpO1xuICB1dGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHByb3h5Lm9uICYmIHByb3h5Lm9uKG5hbWUsIHRoaXNbbmFtZV0sIHRoaXMpO1xuICB9LCB0aGlzKTtcbn07XG5cbkhhbmRsZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFuZGxlcixcbiAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgeCA9IGV2ZW50LnpyWDtcbiAgICB2YXIgeSA9IGV2ZW50LnpyWTtcbiAgICB2YXIgbGFzdEhvdmVyZWQgPSB0aGlzLl9ob3ZlcmVkO1xuICAgIHZhciBsYXN0SG92ZXJlZFRhcmdldCA9IGxhc3RIb3ZlcmVkLnRhcmdldDsgLy8gSWYgbGFzdEhvdmVyZWRUYXJnZXQgaXMgcmVtb3ZlZCBmcm9tIHpyIChkZXRlY3RlZCBieSAnX196cicpIGJ5IHNvbWUgQVBJIGNhbGxcbiAgICAvLyAobGlrZSAnc2V0T3B0aW9uJyBvciAnZGlzcGF0Y2hBY3Rpb24nKSBpbiBldmVudCBoYW5kbGVycywgd2Ugc2hvdWxkIGZpbmRcbiAgICAvLyBsYXN0SG92ZXJlZCBhZ2FpbiBoZXJlLiBPdGhlcndpc2UgJ21vdXNlb3V0JyBjYW4gbm90IGJlIHRyaWdnZXJlZCBub3JtYWxseS5cbiAgICAvLyBTZWUgIzYxOTguXG5cbiAgICBpZiAobGFzdEhvdmVyZWRUYXJnZXQgJiYgIWxhc3RIb3ZlcmVkVGFyZ2V0Ll9fenIpIHtcbiAgICAgIGxhc3RIb3ZlcmVkID0gdGhpcy5maW5kSG92ZXIobGFzdEhvdmVyZWQueCwgbGFzdEhvdmVyZWQueSk7XG4gICAgICBsYXN0SG92ZXJlZFRhcmdldCA9IGxhc3RIb3ZlcmVkLnRhcmdldDtcbiAgICB9XG5cbiAgICB2YXIgaG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5KTtcbiAgICB2YXIgaG92ZXJlZFRhcmdldCA9IGhvdmVyZWQudGFyZ2V0O1xuICAgIHZhciBwcm94eSA9IHRoaXMucHJveHk7XG4gICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihob3ZlcmVkVGFyZ2V0ID8gaG92ZXJlZFRhcmdldC5jdXJzb3IgOiAnZGVmYXVsdCcpOyAvLyBNb3VzZSBvdXQgb24gcHJldmlvdXMgaG92ZXJlZCBlbGVtZW50XG5cbiAgICBpZiAobGFzdEhvdmVyZWRUYXJnZXQgJiYgaG92ZXJlZFRhcmdldCAhPT0gbGFzdEhvdmVyZWRUYXJnZXQpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQobGFzdEhvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTtcbiAgICB9IC8vIE1vdXNlIG1vdmluZyBvbiBvbmUgZWxlbWVudFxuXG5cbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW1vdmUnLCBldmVudCk7IC8vIE1vdXNlIG92ZXIgb24gYSBuZXcgZWxlbWVudFxuXG4gICAgaWYgKGhvdmVyZWRUYXJnZXQgJiYgaG92ZXJlZFRhcmdldCAhPT0gbGFzdEhvdmVyZWRUYXJnZXQpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgJ21vdXNlb3ZlcicsIGV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHRoaXMuX2hvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTsgLy8gVGhlcmUgbWlnaHQgYmUgc29tZSBkb21zIGNyZWF0ZWQgYnkgdXBwZXIgbGF5ZXIgYXBwbGljYXRpb25cbiAgICAvLyBhdCB0aGUgc2FtZSBsZXZlbCBvZiBwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpIChlLmcuLCB0b29sdGlwXG4gICAgLy8gZG9tIGNyZWF0ZWQgYnkgZWNoYXJ0cyksIHdoZXJlICdnbG9iYWxvdXQnIGV2ZW50IHNob3VsZCBub3RcbiAgICAvLyBiZSB0cmlnZ2VyZWQgd2hlbiBtb3VzZSBlbnRlcnMgdGhlc2UgZG9tcy4gKEJ1dCAnbW91c2VvdXQnXG4gICAgLy8gc2hvdWxkIGJlIHRyaWdnZXJlZCBhdCB0aGUgb3JpZ2luYWwgaG92ZXJlZCBlbGVtZW50IGFzIHVzdWFsKS5cblxuICAgIHZhciBlbGVtZW50ID0gZXZlbnQudG9FbGVtZW50IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgdmFyIGlubmVyRG9tO1xuXG4gICAgZG8ge1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIH0gd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPSA5ICYmICEoaW5uZXJEb20gPSBlbGVtZW50ID09PSB0aGlzLnBhaW50ZXJSb290KSk7XG5cbiAgICAhaW5uZXJEb20gJiYgdGhpcy50cmlnZ2VyKCdnbG9iYWxvdXQnLCB7XG4gICAgICBldmVudDogZXZlbnRcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVzaXplXG4gICAqL1xuICByZXNpemU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuX2hvdmVyZWQgPSB7fTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2ggZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnRBcmdzXG4gICAqL1xuICBkaXNwYXRjaDogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcmdzKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB0aGlzW2V2ZW50TmFtZV07XG4gICAgaGFuZGxlciAmJiBoYW5kbGVyLmNhbGwodGhpcywgZXZlbnRBcmdzKTtcbiAgfSxcblxuICAvKipcbiAgICogRGlzcG9zZVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJveHkuZGlzcG9zZSgpO1xuICAgIHRoaXMuc3RvcmFnZSA9IHRoaXMucHJveHkgPSB0aGlzLnBhaW50ZXIgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiDorr7nva7pu5jorqTnmoRjdXJzb3Igc3R5bGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JTdHlsZT0nZGVmYXVsdCddIOS+i+WmgiBjcm9zc2hhaXJcbiAgICovXG4gIHNldEN1cnNvclN0eWxlOiBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgIHByb3h5LnNldEN1cnNvciAmJiBwcm94eS5zZXRDdXJzb3IoY3Vyc29yU3R5bGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDkuovku7bliIblj5Hku6PnkIZcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldEluZm8ge3RhcmdldCwgdG9wVGFyZ2V0fSDnm67moIflm77lvaLlhYPntKBcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSDkuovku7blkI3np7BcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tuWvueixoVxuICAgKi9cbiAgZGlzcGF0Y2hUb0VsZW1lbnQ6IGZ1bmN0aW9uICh0YXJnZXRJbmZvLCBldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgdGFyZ2V0SW5mbyA9IHRhcmdldEluZm8gfHwge307XG4gICAgdmFyIGVsID0gdGFyZ2V0SW5mby50YXJnZXQ7XG5cbiAgICBpZiAoZWwgJiYgZWwuc2lsZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50SGFuZGxlciA9ICdvbicgKyBldmVudE5hbWU7XG4gICAgdmFyIGV2ZW50UGFja2V0ID0gbWFrZUV2ZW50UGFja2V0KGV2ZW50TmFtZSwgdGFyZ2V0SW5mbywgZXZlbnQpO1xuXG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBlbFtldmVudEhhbmRsZXJdICYmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUgPSBlbFtldmVudEhhbmRsZXJdLmNhbGwoZWwsIGV2ZW50UGFja2V0KSk7XG4gICAgICBlbC50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgZWwgPSBlbC5wYXJlbnQ7XG5cbiAgICAgIGlmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgIC8vIOWGkuazoeWIsOmhtue6pyB6cmVuZGVyIOWvueixoVxuICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpOyAvLyDliIblj5Hkuovku7bliLDnlKjmiLfoh6rlrprkuYnlsYJcbiAgICAgIC8vIOeUqOaIt+acieWPr+iDveWcqOWFqOWxgCBjbGljayDkuovku7bkuK0gZGlzcG9zZe+8jOaJgOS7pemcgOimgeWIpOaWreS4iyBwYWludGVyIOaYr+WQpuWtmOWcqFxuXG4gICAgICB0aGlzLnBhaW50ZXIgJiYgdGhpcy5wYWludGVyLmVhY2hPdGhlckxheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBpZiAodHlwZW9mIGxheWVyW2V2ZW50SGFuZGxlcl0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGxheWVyW2V2ZW50SGFuZGxlcl0uY2FsbChsYXllciwgZXZlbnRQYWNrZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxheWVyLnRyaWdnZXIpIHtcbiAgICAgICAgICBsYXllci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX0gZXhjbHVkZVxuICAgKiBAcmV0dXJuIHttb2RlbDp6cmVuZGVyL0VsZW1lbnR9XG4gICAqIEBtZXRob2RcbiAgICovXG4gIGZpbmRIb3ZlcjogZnVuY3Rpb24gKHgsIHksIGV4Y2x1ZGUpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpO1xuICAgIHZhciBvdXQgPSB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGhvdmVyQ2hlY2tSZXN1bHQ7XG5cbiAgICAgIGlmIChsaXN0W2ldICE9PSBleGNsdWRlIC8vIGdldERpc3BsYXlMaXN0IG1heSBpbmNsdWRlIGlnbm9yZWQgaXRlbSBpbiBWTUwgbW9kZVxuICAgICAgJiYgIWxpc3RbaV0uaWdub3JlICYmIChob3ZlckNoZWNrUmVzdWx0ID0gaXNIb3ZlcihsaXN0W2ldLCB4LCB5KSkpIHtcbiAgICAgICAgIW91dC50b3BUYXJnZXQgJiYgKG91dC50b3BUYXJnZXQgPSBsaXN0W2ldKTtcblxuICAgICAgICBpZiAoaG92ZXJDaGVja1Jlc3VsdCAhPT0gU0lMRU5UKSB7XG4gICAgICAgICAgb3V0LnRhcmdldCA9IGxpc3RbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG59OyAvLyBDb21tb24gaGFuZGxlcnNcblxudXRpbC5lYWNoKFsnY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2V3aGVlbCcsICdkYmxjbGljaycsICdjb250ZXh0bWVudSddLCBmdW5jdGlvbiAobmFtZSkge1xuICBIYW5kbGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIEZpbmQgaG92ZXIgYWdhaW4gdG8gYXZvaWQgY2xpY2sgZXZlbnQgaXMgZGlzcGF0Y2hlZCBtYW51YWxseS4gT3IgY2xpY2sgaXMgdHJpZ2dlcmVkIHdpdGhvdXQgbW91c2VvdmVyXG4gICAgdmFyIGhvdmVyZWQgPSB0aGlzLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSk7XG4gICAgdmFyIGhvdmVyZWRUYXJnZXQgPSBob3ZlcmVkLnRhcmdldDtcblxuICAgIGlmIChuYW1lID09PSAnbW91c2Vkb3duJykge1xuICAgICAgdGhpcy5fZG93bkVsID0gaG92ZXJlZFRhcmdldDtcbiAgICAgIHRoaXMuX2Rvd25Qb2ludCA9IFtldmVudC56clgsIGV2ZW50LnpyWV07IC8vIEluIGNhc2UgY2xpY2sgdHJpZ2dlcmVkIGJlZm9yZSBtb3VzZXVwXG5cbiAgICAgIHRoaXMuX3VwRWwgPSBob3ZlcmVkVGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ21vc3VldXAnKSB7XG4gICAgICB0aGlzLl91cEVsID0gaG92ZXJlZFRhcmdldDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgIGlmICh0aGlzLl9kb3duRWwgIT09IHRoaXMuX3VwRWwgLy8gT3JpZ2luYWwgY2xpY2sgZXZlbnQgaXMgdHJpZ2dlcmVkIG9uIHRoZSB3aG9sZSBjYW52YXMgZWxlbWVudCxcbiAgICAgIC8vIGluY2x1ZGluZyB0aGUgY2FzZSB0aGF0IGBtb3VzZWRvd25gIC0gYG1vdXNlbW92ZWAgLSBgbW91c2V1cGAsXG4gICAgICAvLyB3aGljaCBzaG91bGQgYmUgZmlsdGVyZWQsIG90aGVyd2lzZSBpdCB3aWxsIGJyaW5nIHRyb3VibGUgdG9cbiAgICAgIC8vIHBhbiBhbmQgem9vbS5cbiAgICAgIHx8ICF0aGlzLl9kb3duUG9pbnQgLy8gQXJiaXRyYXJ5IHZhbHVlXG4gICAgICB8fCB2ZWMyLmRpc3QodGhpcy5fZG93blBvaW50LCBbZXZlbnQuenJYLCBldmVudC56clldKSA+IDQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb3duUG9pbnQgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgbmFtZSwgZXZlbnQpO1xuICB9O1xufSk7XG5cbmZ1bmN0aW9uIGlzSG92ZXIoZGlzcGxheWFibGUsIHgsIHkpIHtcbiAgaWYgKGRpc3BsYXlhYmxlW2Rpc3BsYXlhYmxlLnJlY3RIb3ZlciA/ICdyZWN0Q29udGFpbicgOiAnY29udGFpbiddKHgsIHkpKSB7XG4gICAgdmFyIGVsID0gZGlzcGxheWFibGU7XG4gICAgdmFyIGlzU2lsZW50O1xuXG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICAvLyBJZiBjbGlwcGVkIGJ5IGFuY2VzdG9yLlxuICAgICAgLy8gRklYTUU6IElmIGNsaXBQYXRoIGhhcyBuZWl0aGVyIHN0cm9rZSBub3IgZmlsbCxcbiAgICAgIC8vIGVsLmNsaXBQYXRoLmNvbnRhaW4oeCwgeSkgd2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlLlxuICAgICAgaWYgKGVsLmNsaXBQYXRoICYmICFlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsLnNpbGVudCkge1xuICAgICAgICBpc1NpbGVudCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGVsID0gZWwucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBpc1NpbGVudCA/IFNJTEVOVCA6IHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnV0aWwubWl4aW4oSGFuZGxlciwgRXZlbnRmdWwpO1xudXRpbC5taXhpbihIYW5kbGVyLCBEcmFnZ2FibGUpO1xudmFyIF9kZWZhdWx0ID0gSGFuZGxlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL0hhbmRsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB1dGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4vY29yZS9lbnZcIik7XG5cbnZhciBHcm91cCA9IHJlcXVpcmUoXCIuL2NvbnRhaW5lci9Hcm91cFwiKTtcblxudmFyIHRpbXNvcnQgPSByZXF1aXJlKFwiLi9jb3JlL3RpbXNvcnRcIik7XG5cbi8qKlxuICogU3RvcmFnZeWGheWuueS7k+W6k+aooeWdl1xuICogQG1vZHVsZSB6cmVuZGVyL1N0b3JhZ2VcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogQGF1dGhvciBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZy8pXG4gKi9cbi8vIFVzZSB0aW1zb3J0IGJlY2F1c2UgaW4gbW9zdCBjYXNlIGVsZW1lbnRzIGFyZSBwYXJ0aWFsbHkgc29ydGVkXG4vLyBodHRwczovL2pzZmlkZGxlLm5ldC9waXNzYW5nL2pyNHg3bWRtLzgvXG5mdW5jdGlvbiBzaGFwZUNvbXBhcmVGdW5jKGEsIGIpIHtcbiAgaWYgKGEuemxldmVsID09PSBiLnpsZXZlbCkge1xuICAgIGlmIChhLnogPT09IGIueikge1xuICAgICAgLy8gaWYgKGEuejIgPT09IGIuejIpIHtcbiAgICAgIC8vICAgICAvLyBGSVhNRSBTbG93IGhhcyByZW5kZXJpZHggY29tcGFyZVxuICAgICAgLy8gICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjA4ODM0MjEvc29ydGluZy1pbi1qYXZhc2NyaXB0LXNob3VsZC1ldmVyeS1jb21wYXJlLWZ1bmN0aW9uLWhhdmUtYS1yZXR1cm4tMC1zdGF0ZW1lbnRcbiAgICAgIC8vICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdjgvdjgvYmxvYi80N2NjZTU0NGEzMWVkNTU3N2ZmZTI5NjNmNjdhY2I0MTQ0ZWUwMjMyL3NyYy9qcy9hcnJheS5qcyNMMTAxMlxuICAgICAgLy8gICAgIHJldHVybiBhLl9fcmVuZGVyaWR4IC0gYi5fX3JlbmRlcmlkeDtcbiAgICAgIC8vIH1cbiAgICAgIHJldHVybiBhLnoyIC0gYi56MjtcbiAgICB9XG5cbiAgICByZXR1cm4gYS56IC0gYi56O1xuICB9XG5cbiAgcmV0dXJuIGEuemxldmVsIC0gYi56bGV2ZWw7XG59XG4vKipcbiAqIOWGheWuueS7k+W6kyAoTSlcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9TdG9yYWdlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBTdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgdGhpcy5fcm9vdHMgPSBbXTtcbiAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcbiAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xufTtcblxuU3RvcmFnZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTdG9yYWdlLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICpcbiAgICovXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9yb290c1tpXS50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDov5Tlm57miYDmnInlm77lvaLnmoTnu5jliLbpmJ/liJdcbiAgICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlPWZhbHNlXSDmmK/lkKblnKjov5Tlm57liY3mm7TmlrDor6XmlbDnu4RcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUlnbm9yZT1mYWxzZV0g5piv5ZCm5YyF5ZCrIGlnbm9yZSDnmoTmlbDnu4QsIOWcqCB1cGRhdGUg5Li6IHRydWUg55qE5pe25YCZ5pyJ5pWIXG4gICAqXG4gICAqIOivpuingXtAbGluayBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5TGlzdH1cbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGU+fVxuICAgKi9cbiAgZ2V0RGlzcGxheUxpc3Q6IGZ1bmN0aW9uICh1cGRhdGUsIGluY2x1ZGVJZ25vcmUpIHtcbiAgICBpbmNsdWRlSWdub3JlID0gaW5jbHVkZUlnbm9yZSB8fCBmYWxzZTtcblxuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlRGlzcGxheUxpc3QoaW5jbHVkZUlnbm9yZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXlMaXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiDmm7TmlrDlm77lvaLnmoTnu5jliLbpmJ/liJfjgIJcbiAgICog5q+P5qyh57uY5Yi25YmN6YO95Lya6LCD55So77yM6K+l5pa55rOV5Lya5YWI5rex5bqm5LyY5YWI6YGN5Y6G5pW05Liq5qCR77yM5pu05paw5omA5pyJR3JvdXDlkoxTaGFwZeeahOWPmOaNouW5tuS4lOaKiuaJgOacieWPr+ingeeahFNoYXBl5L+d5a2Y5Yiw5pWw57uE5Lit77yMXG4gICAqIOacgOWQjuagueaNrue7mOWItueahOS8mOWFiOe6p++8iHpsZXZlbCA+IHogPiDmj5LlhaXpobrluo/vvInmjpLluo/lvpfliLDnu5jliLbpmJ/liJdcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUlnbm9yZT1mYWxzZV0g5piv5ZCm5YyF5ZCrIGlnbm9yZSDnmoTmlbDnu4RcbiAgICovXG4gIHVwZGF0ZURpc3BsYXlMaXN0OiBmdW5jdGlvbiAoaW5jbHVkZUlnbm9yZSkge1xuICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICB2YXIgcm9vdHMgPSB0aGlzLl9yb290cztcbiAgICB2YXIgZGlzcGxheUxpc3QgPSB0aGlzLl9kaXNwbGF5TGlzdDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb290cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5fdXBkYXRlQW5kQWRkRGlzcGxheWFibGUocm9vdHNbaV0sIG51bGwsIGluY2x1ZGVJZ25vcmUpO1xuICAgIH1cblxuICAgIGRpc3BsYXlMaXN0Lmxlbmd0aCA9IHRoaXMuX2Rpc3BsYXlMaXN0TGVuOyAvLyBmb3IgKHZhciBpID0gMCwgbGVuID0gZGlzcGxheUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyAgICAgZGlzcGxheUxpc3RbaV0uX19yZW5kZXJpZHggPSBpO1xuICAgIC8vIH1cbiAgICAvLyBkaXNwbGF5TGlzdC5zb3J0KHNoYXBlQ29tcGFyZUZ1bmMpO1xuXG4gICAgZW52LmNhbnZhc1N1cHBvcnRlZCAmJiB0aW1zb3J0KGRpc3BsYXlMaXN0LCBzaGFwZUNvbXBhcmVGdW5jKTtcbiAgfSxcbiAgX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlOiBmdW5jdGlvbiAoZWwsIGNsaXBQYXRocywgaW5jbHVkZUlnbm9yZSkge1xuICAgIGlmIChlbC5pZ25vcmUgJiYgIWluY2x1ZGVJZ25vcmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbC5iZWZvcmVVcGRhdGUoKTtcblxuICAgIGlmIChlbC5fX2RpcnR5KSB7XG4gICAgICBlbC51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBlbC5hZnRlclVwZGF0ZSgpO1xuICAgIHZhciB1c2VyU2V0Q2xpcFBhdGggPSBlbC5jbGlwUGF0aDtcblxuICAgIGlmICh1c2VyU2V0Q2xpcFBhdGgpIHtcbiAgICAgIC8vIEZJWE1FIOaViOeOh+W9seWTjVxuICAgICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICBjbGlwUGF0aHMgPSBjbGlwUGF0aHMuc2xpY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaXBQYXRocyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudENsaXBQYXRoID0gdXNlclNldENsaXBQYXRoO1xuICAgICAgdmFyIHBhcmVudENsaXBQYXRoID0gZWw7IC8vIFJlY3Vyc2l2ZWx5IGFkZCBjbGlwIHBhdGhcblxuICAgICAgd2hpbGUgKGN1cnJlbnRDbGlwUGF0aCkge1xuICAgICAgICAvLyBjbGlwUGF0aCDnmoTlj5jmjaLmmK/ln7rkuo7kvb/nlKjov5nkuKogY2xpcFBhdGgg55qE5YWD57SgXG4gICAgICAgIGN1cnJlbnRDbGlwUGF0aC5wYXJlbnQgPSBwYXJlbnRDbGlwUGF0aDtcbiAgICAgICAgY3VycmVudENsaXBQYXRoLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICBjbGlwUGF0aHMucHVzaChjdXJyZW50Q2xpcFBhdGgpO1xuICAgICAgICBwYXJlbnRDbGlwUGF0aCA9IGN1cnJlbnRDbGlwUGF0aDtcbiAgICAgICAgY3VycmVudENsaXBQYXRoID0gY3VycmVudENsaXBQYXRoLmNsaXBQYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbC5pc0dyb3VwKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5fY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07IC8vIEZvcmNlIHRvIG1hcmsgYXMgZGlydHkgaWYgZ3JvdXAgaXMgZGlydHlcbiAgICAgICAgLy8gRklYTUUgX19kaXJ0eVBhdGggP1xuXG4gICAgICAgIGlmIChlbC5fX2RpcnR5KSB7XG4gICAgICAgICAgY2hpbGQuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShjaGlsZCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKTtcbiAgICAgIH0gLy8gTWFyayBncm91cCBjbGVhbiBoZXJlXG5cblxuICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5fX2NsaXBQYXRocyA9IGNsaXBQYXRocztcbiAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0W3RoaXMuX2Rpc3BsYXlMaXN0TGVuKytdID0gZWw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKeWIsOagueiKgueCuVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAqL1xuICBhZGRSb290OiBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwuX19zdG9yYWdlID09PSB0aGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgIGVsLmFkZENoaWxkcmVuVG9TdG9yYWdlKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuYWRkVG9TdG9yYWdlKGVsKTtcblxuICAgIHRoaXMuX3Jvb3RzLnB1c2goZWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDliKDpmaTmjIflrprnmoTlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKVxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2VsXSDlpoLmnpzkuLrnqbrmuIXnqbrmlbTkuKpTdG9yYWdlXG4gICAqL1xuICBkZWxSb290OiBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwgPT0gbnVsbCkge1xuICAgICAgLy8g5LiN5oyH5a6aZWzmuIXnqbpcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290c1tpXTtcblxuICAgICAgICBpZiAocm9vdCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgcm9vdC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Jvb3RzID0gW107XG4gICAgICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmRlbFJvb3QoZWxbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9yb290cywgZWwpO1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICB0aGlzLmRlbEZyb21TdG9yYWdlKGVsKTtcblxuICAgICAgdGhpcy5fcm9vdHMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGVsLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2UodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBhZGRUb1N0b3JhZ2U6IGZ1bmN0aW9uIChlbCkge1xuICAgIGVsLl9fc3RvcmFnZSA9IHRoaXM7XG4gICAgZWwuZGlydHkoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkZWxGcm9tU3RvcmFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5fX3N0b3JhZ2UgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmuIXnqbrlubbkuJTph4rmlL5TdG9yYWdlXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVuZGVyTGlzdCA9IHRoaXMuX3Jvb3RzID0gbnVsbDtcbiAgfSxcbiAgZGlzcGxheWFibGVTb3J0RnVuYzogc2hhcGVDb21wYXJlRnVuY1xufTtcbnZhciBfZGVmYXVsdCA9IFN0b3JhZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9TdG9yYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbXppY2NhcmQvbm9kZS10aW1zb3J0XG52YXIgREVGQVVMVF9NSU5fTUVSR0UgPSAzMjtcbnZhciBERUZBVUxUX01JTl9HQUxMT1BJTkcgPSA3O1xudmFyIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIID0gMjU2O1xuXG5mdW5jdGlvbiBtaW5SdW5MZW5ndGgobikge1xuICB2YXIgciA9IDA7XG5cbiAgd2hpbGUgKG4gPj0gREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICByIHw9IG4gJiAxO1xuICAgIG4gPj49IDE7XG4gIH1cblxuICByZXR1cm4gbiArIHI7XG59XG5cbmZ1bmN0aW9uIG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSkge1xuICB2YXIgcnVuSGkgPSBsbyArIDE7XG5cbiAgaWYgKHJ1bkhpID09PSBoaSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgaWYgKGNvbXBhcmUoYXJyYXlbcnVuSGkrK10sIGFycmF5W2xvXSkgPCAwKSB7XG4gICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pIDwgMCkge1xuICAgICAgcnVuSGkrKztcbiAgICB9XG5cbiAgICByZXZlcnNlUnVuKGFycmF5LCBsbywgcnVuSGkpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA+PSAwKSB7XG4gICAgICBydW5IaSsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydW5IaSAtIGxvO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlUnVuKGFycmF5LCBsbywgaGkpIHtcbiAgaGktLTtcblxuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciB0ID0gYXJyYXlbbG9dO1xuICAgIGFycmF5W2xvKytdID0gYXJyYXlbaGldO1xuICAgIGFycmF5W2hpLS1dID0gdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIHN0YXJ0LCBjb21wYXJlKSB7XG4gIGlmIChzdGFydCA9PT0gbG8pIHtcbiAgICBzdGFydCsrO1xuICB9XG5cbiAgZm9yICg7IHN0YXJ0IDwgaGk7IHN0YXJ0KyspIHtcbiAgICB2YXIgcGl2b3QgPSBhcnJheVtzdGFydF07XG4gICAgdmFyIGxlZnQgPSBsbztcbiAgICB2YXIgcmlnaHQgPSBzdGFydDtcbiAgICB2YXIgbWlkO1xuXG4gICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgbWlkID0gbGVmdCArIHJpZ2h0ID4+PiAxO1xuXG4gICAgICBpZiAoY29tcGFyZShwaXZvdCwgYXJyYXlbbWlkXSkgPCAwKSB7XG4gICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG4gPSBzdGFydCAtIGxlZnQ7XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgYXJyYXlbbGVmdCArIDNdID0gYXJyYXlbbGVmdCArIDJdO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIGFycmF5W2xlZnQgKyAyXSA9IGFycmF5W2xlZnQgKyAxXTtcblxuICAgICAgY2FzZSAxOlxuICAgICAgICBhcnJheVtsZWZ0ICsgMV0gPSBhcnJheVtsZWZ0XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgIGFycmF5W2xlZnQgKyBuXSA9IGFycmF5W2xlZnQgKyBuIC0gMV07XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhcnJheVtsZWZ0XSA9IHBpdm90O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdhbGxvcExlZnQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgdmFyIG1heE9mZnNldCA9IDA7XG4gIHZhciBvZmZzZXQgPSAxO1xuXG4gIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA+IDApIHtcbiAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgfVxuXG4gICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgIG9mZnNldCArPSBoaW50O1xuICB9IGVsc2Uge1xuICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8PSAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gIH1cblxuICBsYXN0T2Zmc2V0Kys7XG5cbiAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPiAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IG07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gZ2FsbG9wUmlnaHQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgdmFyIG1heE9mZnNldCA9IDA7XG4gIHZhciBvZmZzZXQgPSAxO1xuXG4gIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA8IDApIHtcbiAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPCAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgIGxhc3RPZmZzZXQgPSBoaW50IC0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gIH0gZWxzZSB7XG4gICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPj0gMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICB9XG5cbiAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgb2Zmc2V0ICs9IGhpbnQ7XG4gIH1cblxuICBsYXN0T2Zmc2V0Kys7XG5cbiAgd2hpbGUgKGxhc3RPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPCAwKSB7XG4gICAgICBvZmZzZXQgPSBtO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gVGltU29ydChhcnJheSwgY29tcGFyZSkge1xuICB2YXIgbWluR2FsbG9wID0gREVGQVVMVF9NSU5fR0FMTE9QSU5HO1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHRtcFN0b3JhZ2VMZW5ndGggPSBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSDtcbiAgdmFyIHN0YWNrTGVuZ3RoID0gMDtcbiAgdmFyIHJ1blN0YXJ0O1xuICB2YXIgcnVuTGVuZ3RoO1xuICB2YXIgc3RhY2tTaXplID0gMDtcbiAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPCAyICogREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEgpIHtcbiAgICB0bXBTdG9yYWdlTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuICB9XG5cbiAgdmFyIHRtcCA9IFtdO1xuICBzdGFja0xlbmd0aCA9IGxlbmd0aCA8IDEyMCA/IDUgOiBsZW5ndGggPCAxNTQyID8gMTAgOiBsZW5ndGggPCAxMTkxNTEgPyAxOSA6IDQwO1xuICBydW5TdGFydCA9IFtdO1xuICBydW5MZW5ndGggPSBbXTtcblxuICBmdW5jdGlvbiBwdXNoUnVuKF9ydW5TdGFydCwgX3J1bkxlbmd0aCkge1xuICAgIHJ1blN0YXJ0W3N0YWNrU2l6ZV0gPSBfcnVuU3RhcnQ7XG4gICAgcnVuTGVuZ3RoW3N0YWNrU2l6ZV0gPSBfcnVuTGVuZ3RoO1xuICAgIHN0YWNrU2l6ZSArPSAxO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VSdW5zKCkge1xuICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgIGlmIChuID49IDEgJiYgcnVuTGVuZ3RoW24gLSAxXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiArIDFdIHx8IG4gPj0gMiAmJiBydW5MZW5ndGhbbiAtIDJdIDw9IHJ1bkxlbmd0aFtuXSArIHJ1bkxlbmd0aFtuIC0gMV0pIHtcbiAgICAgICAgaWYgKHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJ1bkxlbmd0aFtuXSA+IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG1lcmdlQXQobik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yY2VNZXJnZVJ1bnMoKSB7XG4gICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgIHZhciBuID0gc3RhY2tTaXplIC0gMjtcblxuICAgICAgaWYgKG4gPiAwICYmIHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgIG4tLTtcbiAgICAgIH1cblxuICAgICAgbWVyZ2VBdChuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUF0KGkpIHtcbiAgICB2YXIgc3RhcnQxID0gcnVuU3RhcnRbaV07XG4gICAgdmFyIGxlbmd0aDEgPSBydW5MZW5ndGhbaV07XG4gICAgdmFyIHN0YXJ0MiA9IHJ1blN0YXJ0W2kgKyAxXTtcbiAgICB2YXIgbGVuZ3RoMiA9IHJ1bkxlbmd0aFtpICsgMV07XG4gICAgcnVuTGVuZ3RoW2ldID0gbGVuZ3RoMSArIGxlbmd0aDI7XG5cbiAgICBpZiAoaSA9PT0gc3RhY2tTaXplIC0gMykge1xuICAgICAgcnVuU3RhcnRbaSArIDFdID0gcnVuU3RhcnRbaSArIDJdO1xuICAgICAgcnVuTGVuZ3RoW2kgKyAxXSA9IHJ1bkxlbmd0aFtpICsgMl07XG4gICAgfVxuXG4gICAgc3RhY2tTaXplLS07XG4gICAgdmFyIGsgPSBnYWxsb3BSaWdodChhcnJheVtzdGFydDJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcbiAgICBzdGFydDEgKz0gaztcbiAgICBsZW5ndGgxIC09IGs7XG5cbiAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxlbmd0aDIgPSBnYWxsb3BMZWZ0KGFycmF5W3N0YXJ0MSArIGxlbmd0aDEgLSAxXSwgYXJyYXksIHN0YXJ0MiwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMSA8PSBsZW5ndGgyKSB7XG4gICAgICBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDEgKyBpXTtcbiAgICB9XG5cbiAgICB2YXIgY3Vyc29yMSA9IDA7XG4gICAgdmFyIGN1cnNvcjIgPSBzdGFydDI7XG4gICAgdmFyIGRlc3QgPSBzdGFydDE7XG4gICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICB9XG5cbiAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX21pbkdhbGxvcCA9IG1pbkdhbGxvcDtcbiAgICB2YXIgY291bnQxLCBjb3VudDIsIGV4aXQ7XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgY291bnQxID0gMDtcbiAgICAgIGNvdW50MiA9IDA7XG4gICAgICBleGl0ID0gZmFsc2U7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbY3Vyc29yMl0sIHRtcFtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG4gICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgY291bnQxID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcbiAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICBjb3VudDIgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkbyB7XG4gICAgICAgIGNvdW50MSA9IGdhbGxvcFJpZ2h0KGFycmF5W2N1cnNvcjJdLCB0bXAsIGN1cnNvcjEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQxOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVzdCArPSBjb3VudDE7XG4gICAgICAgICAgY3Vyc29yMSArPSBjb3VudDE7XG4gICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG5cbiAgICAgICAgICBpZiAobGVuZ3RoMSA8PSAxKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvdW50MiA9IGdhbGxvcExlZnQodG1wW2N1cnNvcjFdLCBhcnJheSwgY3Vyc29yMiwgbGVuZ3RoMiwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc3QgKz0gY291bnQyO1xuICAgICAgICAgIGN1cnNvcjIgKz0gY291bnQyO1xuICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIF9taW5HYWxsb3AtLTtcbiAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICB9XG5cbiAgICAgIF9taW5HYWxsb3AgKz0gMjtcbiAgICB9XG5cbiAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuICAgIG1pbkdhbGxvcCA8IDEgJiYgKG1pbkdhbGxvcCA9IDEpO1xuXG4gICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgfVxuXG4gICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgfSBlbHNlIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUxvdyBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VIaWdoKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQyICsgaV07XG4gICAgfVxuXG4gICAgdmFyIGN1cnNvcjEgPSBzdGFydDEgKyBsZW5ndGgxIC0gMTtcbiAgICB2YXIgY3Vyc29yMiA9IGxlbmd0aDIgLSAxO1xuICAgIHZhciBkZXN0ID0gc3RhcnQyICsgbGVuZ3RoMiAtIDE7XG4gICAgdmFyIGN1c3RvbUN1cnNvciA9IDA7XG4gICAgdmFyIGN1c3RvbURlc3QgPSAwO1xuICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIGNvdW50MSA9IDA7XG4gICAgICB2YXIgY291bnQyID0gMDtcbiAgICAgIHZhciBleGl0ID0gZmFsc2U7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGNvbXBhcmUodG1wW2N1cnNvcjJdLCBhcnJheVtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG4gICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgY291bnQyID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcbiAgICAgICAgICBjb3VudDIrKztcbiAgICAgICAgICBjb3VudDEgPSAwO1xuXG4gICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkbyB7XG4gICAgICAgIGNvdW50MSA9IGxlbmd0aDEgLSBnYWxsb3BSaWdodCh0bXBbY3Vyc29yMl0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIGxlbmd0aDEgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgZGVzdCAtPSBjb3VudDE7XG4gICAgICAgICAgY3Vyc29yMSAtPSBjb3VudDE7XG4gICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG4gICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgZm9yIChpID0gY291bnQxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb3VudDIgPSBsZW5ndGgyIC0gZ2FsbG9wTGVmdChhcnJheVtjdXJzb3IxXSwgdG1wLCAwLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgIGRlc3QgLT0gY291bnQyO1xuICAgICAgICAgIGN1cnNvcjIgLT0gY291bnQyO1xuICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IyICsgMTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gdG1wW2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW5ndGgyIDw9IDEpIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgX21pbkdhbGxvcC0tO1xuICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChfbWluR2FsbG9wIDwgMCkge1xuICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgIH1cblxuICAgICAgX21pbkdhbGxvcCArPSAyO1xuICAgIH1cblxuICAgIG1pbkdhbGxvcCA9IF9taW5HYWxsb3A7XG5cbiAgICBpZiAobWluR2FsbG9wIDwgMSkge1xuICAgICAgbWluR2FsbG9wID0gMTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgfSBlbHNlIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUhpZ2ggcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5tZXJnZVJ1bnMgPSBtZXJnZVJ1bnM7XG4gIHRoaXMuZm9yY2VNZXJnZVJ1bnMgPSBmb3JjZU1lcmdlUnVucztcbiAgdGhpcy5wdXNoUnVuID0gcHVzaFJ1bjtcbn1cblxuZnVuY3Rpb24gc29ydChhcnJheSwgY29tcGFyZSwgbG8sIGhpKSB7XG4gIGlmICghbG8pIHtcbiAgICBsbyA9IDA7XG4gIH1cblxuICBpZiAoIWhpKSB7XG4gICAgaGkgPSBhcnJheS5sZW5ndGg7XG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gaGkgLSBsbztcblxuICBpZiAocmVtYWluaW5nIDwgMikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBydW5MZW5ndGggPSAwO1xuXG4gIGlmIChyZW1haW5pbmcgPCBERUZBVUxUX01JTl9NRVJHRSkge1xuICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG4gICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRzID0gbmV3IFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpO1xuICB2YXIgbWluUnVuID0gbWluUnVuTGVuZ3RoKHJlbWFpbmluZyk7XG5cbiAgZG8ge1xuICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG5cbiAgICBpZiAocnVuTGVuZ3RoIDwgbWluUnVuKSB7XG4gICAgICB2YXIgZm9yY2UgPSByZW1haW5pbmc7XG5cbiAgICAgIGlmIChmb3JjZSA+IG1pblJ1bikge1xuICAgICAgICBmb3JjZSA9IG1pblJ1bjtcbiAgICAgIH1cblxuICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGxvICsgZm9yY2UsIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgIHJ1bkxlbmd0aCA9IGZvcmNlO1xuICAgIH1cblxuICAgIHRzLnB1c2hSdW4obG8sIHJ1bkxlbmd0aCk7XG4gICAgdHMubWVyZ2VSdW5zKCk7XG4gICAgcmVtYWluaW5nIC09IHJ1bkxlbmd0aDtcbiAgICBsbyArPSBydW5MZW5ndGg7XG4gIH0gd2hpbGUgKHJlbWFpbmluZyAhPT0gMCk7XG5cbiAgdHMuZm9yY2VNZXJnZVJ1bnMoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL3RpbXNvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IF9jb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBsb2cgPSByZXF1aXJlKFwiLi9jb3JlL2xvZ1wiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgdGltc29ydCA9IHJlcXVpcmUoXCIuL2NvcmUvdGltc29ydFwiKTtcblxudmFyIExheWVyID0gcmVxdWlyZShcIi4vTGF5ZXJcIik7XG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKFwiLi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpO1xuXG52YXIgSW1hZ2UgPSByZXF1aXJlKFwiLi9ncmFwaGljL0ltYWdlXCIpO1xuXG4vKipcbiAqIERlZmF1bHQgY2FudmFzIHBhaW50ZXJcbiAqIEBtb2R1bGUgenJlbmRlci9QYWludGVyXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBQRU5ESUdOXG4vLyBMYXllciBleGNlZWRzIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgbWF5IGhhdmUgc29tZSBwcm9ibGVtIHdoZW4gZmx1c2ggZGlyZWN0bHkgc2Vjb25kIHRpbWUuXG4vL1xuLy8gTWF4aW11bSBwcm9ncmVzc2l2ZSBsYXllci4gV2hlbiBleGNlZWRpbmcgdGhpcyBudW1iZXIuIEFsbCBlbGVtZW50cyB3aWxsIGJlIGRyYXdlZCBpbiB0aGUgbGFzdCBsYXllci5cbnZhciBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSID0gNTtcblxuZnVuY3Rpb24gcGFyc2VJbnQxMCh2YWwpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0xheWVyVmFsaWQobGF5ZXIpIHtcbiAgaWYgKCFsYXllcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBsYXllci5yZXNpemUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGxheWVyLnJlZnJlc2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcHJlUHJvY2Vzc0xheWVyKGxheWVyKSB7XG4gIGxheWVyLl9fdW51c2VkQ291bnQrKztcbn1cblxuZnVuY3Rpb24gcG9zdFByb2Nlc3NMYXllcihsYXllcikge1xuICBpZiAobGF5ZXIuX191bnVzZWRDb3VudCA9PSAxKSB7XG4gICAgbGF5ZXIuY2xlYXIoKTtcbiAgfVxufVxuXG52YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG52YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuXG5mdW5jdGlvbiBpc0Rpc3BsYXlhYmxlQ3VsbGVkKGVsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHRtcFJlY3QuY29weShlbC5nZXRCb3VuZGluZ1JlY3QoKSk7XG5cbiAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcbiAgfVxuXG4gIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gIHZpZXdSZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgcmV0dXJuICF0bXBSZWN0LmludGVyc2VjdCh2aWV3UmVjdCk7XG59XG5cbmZ1bmN0aW9uIGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgcHJldkNsaXBQYXRocykge1xuICBpZiAoY2xpcFBhdGhzID09IHByZXZDbGlwUGF0aHMpIHtcbiAgICAvLyBDYW4gYm90aCBiZSBudWxsIG9yIHVuZGVmaW5lZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghY2xpcFBhdGhzIHx8ICFwcmV2Q2xpcFBhdGhzIHx8IGNsaXBQYXRocy5sZW5ndGggIT09IHByZXZDbGlwUGF0aHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgY2xpcFBhdGguc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGNsaXBQYXRoLmJ1aWxkUGF0aChjdHgsIGNsaXBQYXRoLnNoYXBlKTtcbiAgICBjdHguY2xpcCgpOyAvLyBUcmFuc2Zvcm0gYmFja1xuXG4gICAgY2xpcFBhdGgucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3Qod2lkdGgsIGhlaWdodCkge1xuICB2YXIgZG9tUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvLyBkb21Sb290Lm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8g6YG/5YWN6aG16Z2i6YCJ5Lit55qE5bC05bCsXG5cbiAgZG9tUm9vdC5zdHlsZS5jc3NUZXh0ID0gWydwb3NpdGlvbjpyZWxhdGl2ZScsICdvdmVyZmxvdzpoaWRkZW4nLCAnd2lkdGg6JyArIHdpZHRoICsgJ3B4JywgJ2hlaWdodDonICsgaGVpZ2h0ICsgJ3B4JywgJ3BhZGRpbmc6MCcsICdtYXJnaW46MCcsICdib3JkZXItd2lkdGg6MCddLmpvaW4oJzsnKSArICc7JztcbiAgcmV0dXJuIGRvbVJvb3Q7XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9QYWludGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJvb3Qg57uY5Zu+5a655ZmoXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cblxuXG52YXIgUGFpbnRlciA9IGZ1bmN0aW9uIChyb290LCBzdG9yYWdlLCBvcHRzKSB7XG4gIHRoaXMudHlwZSA9ICdjYW52YXMnOyAvLyBJbiBub2RlIGVudmlyb25tZW50IHVzaW5nIG5vZGUtY2FudmFzXG5cbiAgdmFyIHNpbmdsZUNhbnZhcyA9ICFyb290Lm5vZGVOYW1lIC8vIEluIG5vZGUgP1xuICB8fCByb290Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdDQU5WQVMnO1xuICB0aGlzLl9vcHRzID0gb3B0cyA9IHV0aWwuZXh0ZW5kKHt9LCBvcHRzIHx8IHt9KTtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuZHByID0gb3B0cy5kZXZpY2VQaXhlbFJhdGlvIHx8IGRldmljZVBpeGVsUmF0aW87XG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fc2luZ2xlQ2FudmFzID0gc2luZ2xlQ2FudmFzO1xuICAvKipcbiAgICog57uY5Zu+5a655ZmoXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICovXG5cbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdmFyIHJvb3RTdHlsZSA9IHJvb3Quc3R5bGU7XG5cbiAgaWYgKHJvb3RTdHlsZSkge1xuICAgIHJvb3RTdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAndHJhbnNwYXJlbnQnO1xuICAgIHJvb3RTdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID0gcm9vdFN0eWxlWyd1c2VyLXNlbGVjdCddID0gcm9vdFN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcbiAgICByb290LmlubmVySFRNTCA9ICcnO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX1cbiAgICovXG5cblxuICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAvKipcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3QgPSBbXTtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnpyZW5kZXIvTGF5ZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzID0ge307XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdD59XG4gICAqIEB0eXBlIHtwcml2YXRlfVxuICAgKi9cblxuICB0aGlzLl9sYXllckNvbmZpZyA9IHt9O1xuXG4gIGlmICghc2luZ2xlQ2FudmFzKSB7XG4gICAgdGhpcy5fd2lkdGggPSB0aGlzLl9nZXRTaXplKDApO1xuICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290ID0gY3JlYXRlUm9vdCh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICByb290LmFwcGVuZENoaWxkKGRvbVJvb3QpO1xuICB9IGVsc2Uge1xuICAgIGlmIChvcHRzLndpZHRoICE9IG51bGwpIHtcbiAgICAgIHJvb3Qud2lkdGggPSBvcHRzLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICByb290LmhlaWdodCA9IG9wdHMuaGVpZ2h0O1xuICAgIH0gLy8gVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0IGRpcmVjdGx5XG5cblxuICAgIHZhciB3aWR0aCA9IHJvb3Qud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0OyAvLyBDcmVhdGUgbGF5ZXIgaWYgb25seSBvbmUgZ2l2ZW4gY2FudmFzXG4gICAgLy8gRGV2aWNlIHBpeGVsIHJhdGlvIGlzIGZpeGVkIHRvIDEgYmVjYXVzZSBnaXZlbiBjYW52YXMgaGFzIGl0cyBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuXG4gICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290LCB0aGlzLCAxKTtcbiAgICBtYWluTGF5ZXIuaW5pdENvbnRleHQoKTsgLy8gRklYTUUgVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgLy8gbWFpbkxheWVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGxheWVyc1swXSA9IG1haW5MYXllcjtcbiAgICB6bGV2ZWxMaXN0LnB1c2goMCk7XG4gICAgdGhpcy5fZG9tUm9vdCA9IHJvb3Q7XG4gIH0gLy8gTGF5ZXJzIGZvciBwcm9ncmVzc2l2ZSByZW5kZXJpbmdcblxuXG4gIHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzID0gW107XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX2hvdmVybGF5ZXI7XG4gIHRoaXMuX2hvdmVyRWxlbWVudHMgPSBbXTtcbn07XG5cblBhaW50ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGFpbnRlcixcbiAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnY2FudmFzJztcbiAgfSxcblxuICAvKipcbiAgICogSWYgcGFpbnRlciB1c2UgYSBzaW5nbGUgY2FudmFzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1NpbmdsZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zaW5nbGVDYW52YXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvbVJvb3Q7XG4gIH0sXG4gIGdldFZpZXdwb3J0Um9vdE9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aWV3cG9ydFJvb3QgPSB0aGlzLmdldFZpZXdwb3J0Um9vdCgpO1xuXG4gICAgaWYgKHZpZXdwb3J0Um9vdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0TGVmdDogdmlld3BvcnRSb290Lm9mZnNldExlZnQgfHwgMCxcbiAgICAgICAgb2Zmc2V0VG9wOiB2aWV3cG9ydFJvb3Qub2Zmc2V0VG9wIHx8IDBcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDliLfmlrBcbiAgICogQHBhcmFtIHtib29sZWFufSBbcGFpbnRBbGw9ZmFsc2VdIOW8uuWItue7mOWItuaJgOaciWRpc3BsYXlhYmxlXG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiAocGFpbnRBbGwpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG5cbiAgICB0aGlzLl9wYWludExpc3QobGlzdCwgcGFpbnRBbGwpOyAvLyBQYWludCBjdXN0dW0gbGF5ZXJzXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuXG4gICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fICYmIGxheWVyLnJlZnJlc2gpIHtcbiAgICAgICAgbGF5ZXIucmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG5cbiAgICBpZiAodGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zdGFydFByb2dlc3NpdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkSG92ZXI6IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSkge1xuICAgIGlmIChlbC5fX2hvdmVyTWlyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsTWlycm9yID0gbmV3IGVsLmNvbnN0cnVjdG9yKHtcbiAgICAgIHN0eWxlOiBlbC5zdHlsZSxcbiAgICAgIHNoYXBlOiBlbC5zaGFwZVxuICAgIH0pO1xuICAgIGVsTWlycm9yLl9fZnJvbSA9IGVsO1xuICAgIGVsLl9faG92ZXJNaXIgPSBlbE1pcnJvcjtcbiAgICBlbE1pcnJvci5zZXRTdHlsZShob3ZlclN0eWxlKTtcblxuICAgIHRoaXMuX2hvdmVyRWxlbWVudHMucHVzaChlbE1pcnJvcik7XG4gIH0sXG4gIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgZWxNaXJyb3IgPSBlbC5fX2hvdmVyTWlyO1xuICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKGhvdmVyRWxlbWVudHMsIGVsTWlycm9yKTtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG5cbiAgICBlbC5fX2hvdmVyTWlyID0gbnVsbDtcbiAgfSxcbiAgY2xlYXJIb3ZlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3ZlckVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZnJvbSA9IGhvdmVyRWxlbWVudHNbaV0uX19mcm9tO1xuXG4gICAgICBpZiAoZnJvbSkge1xuICAgICAgICBmcm9tLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhvdmVyRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgfSxcbiAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgIHZhciBsZW4gPSBob3ZlckVsZW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaG92ZXJMYXllciA9IHRoaXMuX2hvdmVybGF5ZXI7XG4gICAgaG92ZXJMYXllciAmJiBob3ZlckxheWVyLmNsZWFyKCk7XG5cbiAgICBpZiAoIWxlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbXNvcnQoaG92ZXJFbGVtZW50cywgdGhpcy5zdG9yYWdlLmRpc3BsYXlhYmxlU29ydEZ1bmMpOyAvLyBVc2UgYSBleHRyZWFtIGxhcmdlIHpsZXZlbFxuICAgIC8vIEZJWE1FP1xuXG4gICAgaWYgKCFob3ZlckxheWVyKSB7XG4gICAgICBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllciA9IHRoaXMuZ2V0TGF5ZXIoMWU1KTtcbiAgICB9XG5cbiAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICBob3ZlckxheWVyLmN0eC5zYXZlKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgIHZhciBlbCA9IGhvdmVyRWxlbWVudHNbaV07XG4gICAgICB2YXIgb3JpZ2luYWxFbCA9IGVsLl9fZnJvbTsgLy8gT3JpZ2luYWwgZWwgaXMgcmVtb3ZlZFxuICAgICAgLy8gUEVORElOR1xuXG4gICAgICBpZiAoIShvcmlnaW5hbEVsICYmIG9yaWdpbmFsRWwuX196cikpIHtcbiAgICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIG9yaWdpbmFsRWwuX19ob3Zlck1pciA9IG51bGw7XG4gICAgICAgIGxlbi0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaSsrOyAvLyBVc2UgdHJhbnNmb3JtXG4gICAgICAvLyBGSVhNRSBzdHlsZSBhbmQgc2hhcGUgP1xuXG4gICAgICBpZiAoIW9yaWdpbmFsRWwuaW52aXNpYmxlKSB7XG4gICAgICAgIGVsLnRyYW5zZm9ybSA9IG9yaWdpbmFsRWwudHJhbnNmb3JtO1xuICAgICAgICBlbC5pbnZUcmFuc2Zvcm0gPSBvcmlnaW5hbEVsLmludlRyYW5zZm9ybTtcbiAgICAgICAgZWwuX19jbGlwUGF0aHMgPSBvcmlnaW5hbEVsLl9fY2xpcFBhdGhzOyAvLyBlbC5cblxuICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGhvdmVyTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBob3ZlckxheWVyLmN0eC5yZXN0b3JlKCk7XG4gIH0sXG4gIF9zdGFydFByb2dlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIXNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVXNlIGEgdG9rZW4gdG8gc3RvcCBwcm9ncmVzcyBzdGVwcyB0cmlnZ2VyZWQgYnlcbiAgICAvLyBwcmV2aW91cyB6ci5yZWZyZXNoIGNhbGxpbmcuXG5cblxuICAgIHZhciB0b2tlbiA9IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSArbmV3IERhdGUoKTtcbiAgICBzZWxmLl9wcm9ncmVzcysrO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcblxuICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICAvLyBJbiBjYXNlIHJlZnJlc2hlZCBvciBkaXNwb3NlZFxuICAgICAgaWYgKHRva2VuID09PSBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuICYmIHNlbGYuc3RvcmFnZSkge1xuICAgICAgICBzZWxmLl9kb1BhaW50TGlzdChzZWxmLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKSk7XG5cbiAgICAgICAgaWYgKHNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgIHNlbGYuX3Byb2dyZXNzKys7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2NsZWFyUHJvZ3Jlc3NpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVRva2VuID0gLTE7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSAwO1xuICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBsYXllci5fX2RpcnR5ICYmIGxheWVyLmNsZWFyKCk7XG4gICAgfSk7XG4gIH0sXG4gIF9wYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBwYWludEFsbCkge1xuICAgIGlmIChwYWludEFsbCA9PSBudWxsKSB7XG4gICAgICBwYWludEFsbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUxheWVyU3RhdHVzKGxpc3QpO1xuXG4gICAgdGhpcy5fY2xlYXJQcm9ncmVzc2l2ZSgpO1xuXG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHByZVByb2Nlc3NMYXllcik7XG5cbiAgICB0aGlzLl9kb1BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocG9zdFByb2Nlc3NMYXllcik7XG4gIH0sXG4gIF9kb1BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QsIHBhaW50QWxsKSB7XG4gICAgdmFyIGN1cnJlbnRMYXllcjtcbiAgICB2YXIgY3VycmVudFpMZXZlbDtcbiAgICB2YXIgY3R4OyAvLyB2YXIgaW52VHJhbnNmb3JtID0gW107XG5cbiAgICB2YXIgc2NvcGU7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJJZHggPSAwO1xuICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcbiAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgIHZhciBsYXllclByb2dyZXNzO1xuICAgIHZhciBmcmFtZSA9IHRoaXMuX3Byb2dyZXNzO1xuXG4gICAgZnVuY3Rpb24gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGxheWVyKSB7XG4gICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDA7IC8vIEF2b2lkIGxheWVyIGRvbid0IGNsZWFyIGluIG5leHQgcHJvZ3Jlc3NpdmUgZnJhbWVcblxuICAgICAgY3VycmVudExheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UobGF5ZXIuZG9tLCAwLCAwLCB3aWR0aCAqIGRwciwgaGVpZ2h0ICogZHByKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgIHZhciBlbFpMZXZlbCA9IHRoaXMuX3NpbmdsZUNhbnZhcyA/IDAgOiBlbC56bGV2ZWw7XG4gICAgICB2YXIgZWxGcmFtZSA9IGVsLl9fZnJhbWU7IC8vIEZsdXNoIGF0IGN1cnJlbnQgY29udGV4dFxuICAgICAgLy8gUEVORElOR1xuXG4gICAgICBpZiAoZWxGcmFtZSA8IDAgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgfSAvLyBDaGFuZ2UgZHJhdyBsYXllclxuXG5cbiAgICAgIGlmIChjdXJyZW50WkxldmVsICE9PSBlbFpMZXZlbCkge1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSAvLyBSZXNldCBzY29wZVxuXG5cbiAgICAgICAgc2NvcGUgPSB7fTsgLy8gT25seSAwIHpsZXZlbCBpZiBvbmx5IGhhcyBvbmUgY2FudmFzXG5cbiAgICAgICAgY3VycmVudFpMZXZlbCA9IGVsWkxldmVsO1xuICAgICAgICBjdXJyZW50TGF5ZXIgPSB0aGlzLmdldExheWVyKGN1cnJlbnRaTGV2ZWwpO1xuXG4gICAgICAgIGlmICghY3VycmVudExheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgICAgbG9nKCdaTGV2ZWwgJyArIGN1cnJlbnRaTGV2ZWwgKyAnIGhhcyBiZWVuIHVzZWQgYnkgdW5rb3duIGxheWVyICcgKyBjdXJyZW50TGF5ZXIuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4ID0gY3VycmVudExheWVyLmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTsgLy8gUmVzZXQgdGhlIGNvdW50XG5cbiAgICAgICAgY3VycmVudExheWVyLl9fdW51c2VkQ291bnQgPSAwO1xuXG4gICAgICAgIGlmIChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBwYWludEFsbCkge1xuICAgICAgICAgIGN1cnJlbnRMYXllci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsRnJhbWUgPj0gMCkge1xuICAgICAgICAvLyBQcm9ncmVzc2l2ZSBsYXllciBjaGFuZ2VkXG4gICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzW01hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJJZHgrKywgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiAtIDEpXTtcbiAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlID0ge307XG5cbiAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcyA+IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIC8vIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICAvLyBRdWljayBqdW1wIGFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50c1xuICAgICAgICAgICAgLy8gQWxsIHByb2dyZXNzaXZlIGVsZW1lbnQgYXJlIG5vdCBkaXJ0eSwganVtcCBvdmVyIGFuZCBmbHVzaCBkaXJlY3RseVxuICAgICAgICAgICAgaSA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgLSAxOyAvLyBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IG51bGw7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxheWVyUHJvZ3Jlc3MgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzO1xuXG4gICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAvLyBLZWVwIHJlbmRlcmluZ1xuICAgICAgICAgICAgZnJhbWUgPSBsYXllclByb2dyZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPSBmcmFtZSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxGcmFtZSA9PT0gZnJhbWUpIHtcbiAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLCB0cnVlLCBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5yZW5kZXJTY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudExheWVyLCBwYWludEFsbCwgc2NvcGUpO1xuICAgICAgfVxuXG4gICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgIH0gLy8gUmVzdG9yZSB0aGUgbGFzdExheWVyIGN0eFxuXG5cbiAgICBjdHggJiYgY3R4LnJlc3RvcmUoKTsgLy8gSWYgc3RpbGwgaGFzIGNsaXBwaW5nIHN0YXRlXG4gICAgLy8gaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgIC8vICAgICBjdHgucmVzdG9yZSgpO1xuICAgIC8vIH1cblxuICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IGZhbHNlO1xuICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBpZiAobGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBsYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH0sXG4gIF9kb1BhaW50RWw6IGZ1bmN0aW9uIChlbCwgY3VycmVudExheWVyLCBmb3JjZVBhaW50LCBzY29wZSkge1xuICAgIHZhciBjdHggPSBjdXJyZW50TGF5ZXIuY3R4O1xuICAgIHZhciBtID0gZWwudHJhbnNmb3JtO1xuXG4gICAgaWYgKChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBmb3JjZVBhaW50KSAmJiAvLyBJZ25vcmUgaW52aXNpYmxlIGVsZW1lbnRcbiAgICAhZWwuaW52aXNpYmxlIC8vIElnbm9yZSB0cmFuc3BhcmVudCBlbGVtZW50XG4gICAgJiYgZWwuc3R5bGUub3BhY2l0eSAhPT0gMCAvLyBJZ25vcmUgc2NhbGUgMCBlbGVtZW50LCBpbiBzb21lIGVudmlyb25tZW50IGxpa2Ugbm9kZS1jYW52YXNcbiAgICAvLyBEcmF3IGEgc2NhbGUgMCBlbGVtZW50IGNhbiBjYXVzZSBhbGwgZm9sbG93aW5nIGRyYXcgd3JvbmdcbiAgICAvLyBBbmQgc2V0VHJhbnNmb3JtIHdpdGggc2NhbGUgMCB3aWxsIGNhdXNlIHNldCBiYWNrIHRyYW5zZm9ybSBmYWlsZWQuXG4gICAgJiYgIShtICYmICFtWzBdICYmICFtWzNdKSAvLyBJZ25vcmUgY3VsbGVkIGVsZW1lbnRcbiAgICAmJiAhKGVsLmN1bGxpbmcgJiYgaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpKSB7XG4gICAgICB2YXIgY2xpcFBhdGhzID0gZWwuX19jbGlwUGF0aHM7IC8vIE9wdGltaXplIHdoZW4gY2xpcHBpbmcgb24gZ3JvdXAgd2l0aCBzZXZlcmFsIGVsZW1lbnRzXG5cbiAgICAgIGlmIChzY29wZS5wcmV2Q2xpcExheWVyICE9PSBjdXJyZW50TGF5ZXIgfHwgaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBzY29wZS5wcmV2RWxDbGlwUGF0aHMpKSB7XG4gICAgICAgIC8vIElmIGhhcyBwcmV2aW91cyBjbGlwcGluZyBzdGF0ZSwgcmVzdG9yZSBmcm9tIGl0XG4gICAgICAgIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IHNjb3BlLnByZXZFbENsaXBQYXRocyA9IG51bGw7IC8vIFJlc2V0IHByZXZFbCBzaW5jZSBjb250ZXh0IGhhcyBiZWVuIHJlc3RvcmVkXG5cbiAgICAgICAgICBzY29wZS5wcmV2RWwgPSBudWxsO1xuICAgICAgICB9IC8vIE5ldyBjbGlwcGluZyBzdGF0ZVxuXG5cbiAgICAgICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgZG9DbGlwKGNsaXBQYXRocywgY3R4KTtcbiAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyID0gY3VycmVudExheWVyO1xuICAgICAgICAgIHNjb3BlLnByZXZFbENsaXBQYXRocyA9IGNsaXBQYXRocztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaChjdHgpO1xuICAgICAgZWwuYnJ1c2goY3R4LCBzY29wZS5wcmV2RWwgfHwgbnVsbCk7XG4gICAgICBzY29wZS5wcmV2RWwgPSBlbDtcbiAgICAgIGVsLmFmdGVyQnJ1c2ggJiYgZWwuYWZ0ZXJCcnVzaChjdHgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6I635Y+WIHpsZXZlbCDmiYDlnKjlsYLvvIzlpoLmnpzkuI3lrZjlnKjliJnkvJrliJvlu7rkuIDkuKrmlrDnmoTlsYJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICovXG4gIGdldExheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXTtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBsYXllclxuICAgICAgbGF5ZXIgPSBuZXcgTGF5ZXIoJ3pyXycgKyB6bGV2ZWwsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgIGxheWVyLl9fYnVpbHRpbl9fID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5zZXJ0TGF5ZXIoemxldmVsLCBsYXllcik7IC8vIENvbnRleHQgaXMgY3JlYXRlZCBhZnRlciBkb20gaW5zZXJ0ZWQgdG8gZG9jdW1lbnRcbiAgICAgIC8vIE9yIGV4Y2FudmFzIHdpbGwgZ2V0IDBweCBjbGllbnRXaWR0aCBhbmQgY2xpZW50SGVpZ2h0XG5cbiAgICAgIGxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVyO1xuICB9LFxuICBpbnNlcnRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgbGF5ZXIpIHtcbiAgICB2YXIgbGF5ZXJzTWFwID0gdGhpcy5fbGF5ZXJzO1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGVuID0gemxldmVsTGlzdC5sZW5ndGg7XG4gICAgdmFyIHByZXZMYXllciA9IG51bGw7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG5cbiAgICBpZiAobGF5ZXJzTWFwW3psZXZlbF0pIHtcbiAgICAgIGxvZygnWkxldmVsICcgKyB6bGV2ZWwgKyAnIGhhcyBiZWVuIHVzZWQgYWxyZWFkeScpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ2hlY2sgaWYgaXMgYSB2YWxpZCBsYXllclxuXG5cbiAgICBpZiAoIWlzTGF5ZXJWYWxpZChsYXllcikpIHtcbiAgICAgIGxvZygnTGF5ZXIgb2YgemxldmVsICcgKyB6bGV2ZWwgKyAnIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW4gPiAwICYmIHpsZXZlbCA+IHpsZXZlbExpc3RbMF0pIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKHpsZXZlbExpc3RbaV0gPCB6bGV2ZWwgJiYgemxldmVsTGlzdFtpICsgMV0gPiB6bGV2ZWwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2TGF5ZXIgPSBsYXllcnNNYXBbemxldmVsTGlzdFtpXV07XG4gICAgfVxuXG4gICAgemxldmVsTGlzdC5zcGxpY2UoaSArIDEsIDAsIHpsZXZlbCk7XG4gICAgbGF5ZXJzTWFwW3psZXZlbF0gPSBsYXllcjsgLy8gVml0dWFsIGxheWVyIHdpbGwgbm90IGRpcmVjdGx5IHNob3cgb24gdGhlIHNjcmVlbi5cbiAgICAvLyAoSXQgY2FuIGJlIGEgV2ViR0wgbGF5ZXIgYW5kIGFzc2lnbmVkIHRvIGEgWkltYWdlIGVsZW1lbnQpXG4gICAgLy8gQnV0IGl0IHN0aWxsIHVuZGVyIG1hbmFnZW1lbnQgb2YgenJlbmRlci5cblxuICAgIGlmICghbGF5ZXIudmlydHVhbCkge1xuICAgICAgaWYgKHByZXZMYXllcikge1xuICAgICAgICB2YXIgcHJldkRvbSA9IHByZXZMYXllci5kb207XG5cbiAgICAgICAgaWYgKHByZXZEb20ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBkb21Sb290Lmluc2VydEJlZm9yZShsYXllci5kb20sIHByZXZEb20ubmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRvbVJvb3QuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKGxheWVyLmRvbSwgZG9tUm9vdC5maXJzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBsYXllclxuICBlYWNoTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgejtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW3pdLCB6KTtcbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBidWlsZGluIGxheWVyXG4gIGVhY2hCdWlsdGluTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGF5ZXI7XG4gICAgdmFyIHo7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcblxuICAgICAgaWYgKGxheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgbGF5ZXIsIHopO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gSXRlcmF0ZSBlYWNoIG90aGVyIGxheWVyIGV4Y2VwdCBidWlsZGluIGxheWVyXG4gIGVhY2hPdGhlckxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdmFyIGxheWVyO1xuICAgIHZhciB6O1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG5cbiAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmiYDmnInlt7LliJvlu7rnmoTlsYJcbiAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvTGF5ZXI+fSBbcHJldkxheWVyXVxuICAgKi9cbiAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xheWVycztcbiAgfSxcbiAgX3VwZGF0ZUxheWVyU3RhdHVzOiBmdW5jdGlvbiAobGlzdCkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJzID0gdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnM7XG4gICAgdmFyIGVsQ291bnRzTGFzdEZyYW1lID0ge307XG4gICAgdmFyIHByb2dyZXNzaXZlRWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICBlbENvdW50c0xhc3RGcmFtZVt6XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICBsYXllci5lbENvdW50ID0gMDtcbiAgICAgIGxheWVyLl9fZGlydHkgPSBmYWxzZTtcbiAgICB9KTtcbiAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gPSBsYXllci5lbENvdW50O1xuICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICBsYXllci5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfSk7XG4gICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJDb3VudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyO1xuICAgIHZhciBsYXN0UHJvZ3Jlc3NpdmVLZXk7XG4gICAgdmFyIGZyYW1lQ291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgIHZhciB6bGV2ZWwgPSB0aGlzLl9zaW5nbGVDYW52YXMgPyAwIDogZWwuemxldmVsO1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW3psZXZlbF07XG4gICAgICB2YXIgZWxQcm9ncmVzcyA9IGVsLnByb2dyZXNzaXZlO1xuXG4gICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuZWxDb3VudCsrO1xuICAgICAgICBsYXllci5fX2RpcnR5ID0gbGF5ZXIuX19kaXJ0eSB8fCBlbC5fX2RpcnR5O1xuICAgICAgfSAvLy8vLy8vIFVwZGF0ZSBwcm9ncmVzc2l2ZVxuXG5cbiAgICAgIGlmIChlbFByb2dyZXNzID49IDApIHtcbiAgICAgICAgLy8gRml4IHdyb25nIHByb2dyZXNzaXZlIHNlcXVlbmNlIHByb2JsZW0uXG4gICAgICAgIGlmIChsYXN0UHJvZ3Jlc3NpdmVLZXkgIT09IGVsUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBsYXN0UHJvZ3Jlc3NpdmVLZXkgPSBlbFByb2dyZXNzO1xuICAgICAgICAgIGZyYW1lQ291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZSA9IGZyYW1lQ291bnQgLSAxO1xuXG4gICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSk7XG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdO1xuXG4gICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdID0gbmV3IExheWVyKCdwcm9ncmVzc2l2ZScsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5ID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSB8fCBlbC5fX2RpcnR5O1xuICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5lbENvdW50Kys7XG4gICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSBNYXRoLm1heChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzLCBlbEZyYW1lKTtcblxuICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgICAgLy8gU2hvdWxkIGtlZXAgcmVuZGVyaW5nIHRoaXMgIGxheWVyIGJlY2F1c2UgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGlzIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICBsYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuX19mcmFtZSA9IC0xO1xuXG4gICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgPSBpO1xuICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgcHJvZ3Jlc3NpdmVMYXllckNvdW50Kys7XG4gICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICB9IC8vIOWxguS4reeahOWFg+e0oOaVsOmHj+acieWPkeeUn+WPmOWMllxuXG5cbiAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICBpZiAoZWxDb3VudHNMYXN0RnJhbWVbel0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHJvZ3Jlc3NpdmVMYXllcnMubGVuZ3RoID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSKTtcbiAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICBpZiAocHJvZ3Jlc3NpdmVFbENvdW50c0xhc3RGcmFtZVtpZHhdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgIGVsLl9fZGlydHkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobGF5ZXIuX19kaXJ0eSkge1xuICAgICAgICBsYXllci5fX3Byb2dyZXNzID0gMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICog5riF6ZmkaG92ZXLlsYLlpJbmiYDmnInlhoXlrrlcbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHRoaXMuX2NsZWFyTGF5ZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfY2xlYXJMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgbGF5ZXIuY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICog5L+u5pS55oyH5a6aemxldmVs55qE57uY5Yi25Y+C5pWwXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6bGV2ZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyDphY3nva7lr7nosaFcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSDmr4/mrKHmuIXnqbrnlLvluIPnmoTpopzoibJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0g5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxhc3RGcmFtZUFscGhhPTAuN11cbiAgICogICAgICAgICAgICAgICAgIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAqL1xuICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdmFyIGxheWVyQ29uZmlnID0gdGhpcy5fbGF5ZXJDb25maWc7XG5cbiAgICAgIGlmICghbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIGxheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWwg5bGC5omA5Zyo55qEemxldmVsXG4gICAqL1xuICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuXG4gICAgaWYgKCFsYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxheWVyLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxheWVyLmRvbSk7XG4gICAgZGVsZXRlIGxheWVyc1t6bGV2ZWxdO1xuICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgfSxcblxuICAvKipcbiAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAqL1xuICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290OyAvLyBGSVhNRSBXaHkgP1xuXG4gICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBTYXZlIGlucHV0IHcvaFxuXG4gICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgIHdpZHRoICE9IG51bGwgJiYgKG9wdHMud2lkdGggPSB3aWR0aCk7XG4gICAgaGVpZ2h0ICE9IG51bGwgJiYgKG9wdHMuaGVpZ2h0ID0gaGVpZ2h0KTtcbiAgICB3aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgaGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSgxKTtcbiAgICBkb21Sb290LnN0eWxlLmRpc3BsYXkgPSAnJzsgLy8g5LyY5YyW5rKh5pyJ5a6e6ZmF5pS55Y+Y55qEcmVzaXplXG5cbiAgICBpZiAodGhpcy5fd2lkdGggIT0gd2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMuX2hlaWdodCkge1xuICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIGRvbVJvb3Quc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXllcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJlZnJlc2godHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4hemZpOWNleeLrOeahOS4gOS4quWxglxuICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAqL1xuICBjbGVhckxheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG5cbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDph4rmlL5cbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG4gICAgdGhpcy5yb290ID0gdGhpcy5zdG9yYWdlID0gdGhpcy5fZG9tUm9vdCA9IHRoaXMuX2xheWVycyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMucGl4ZWxSYXRpb11cbiAgICovXG4gIGdldFJlbmRlcmVkQ2FudmFzOiBmdW5jdGlvbiAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXS5kb207XG4gICAgfVxuXG4gICAgdmFyIGltYWdlTGF5ZXIgPSBuZXcgTGF5ZXIoJ2ltYWdlJywgdGhpcywgb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZHByKTtcbiAgICBpbWFnZUxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgaW1hZ2VMYXllci5jbGVhckNvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgaW1hZ2VMYXllci5jbGVhcigpO1xuICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcbiAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICB2YXIgemxldmVsO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGZpbmRBbmREcmF3T3RoZXJMYXllcihzbWFsbGVyLCBsYXJnZXIpIHtcbiAgICAgIHZhciB6bGV2ZWxMaXN0ID0gc2VsZi5femxldmVsTGlzdDtcblxuICAgICAgaWYgKHNtYWxsZXIgPT0gbnVsbCkge1xuICAgICAgICBzbWFsbGVyID0gLUluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICB2YXIgaW50ZXJtZWRpYXRlTGF5ZXI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgIHZhciBsYXllciA9IHNlbGYuX2xheWVyc1t6XTtcblxuICAgICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fICYmIHogPiBzbWFsbGVyICYmIHogPCBsYXJnZXIpIHtcbiAgICAgICAgICBpbnRlcm1lZGlhdGVMYXllciA9IGxheWVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnRlcm1lZGlhdGVMYXllciAmJiBpbnRlcm1lZGlhdGVMYXllci5yZW5kZXJUb0NhbnZhcykge1xuICAgICAgICBpbWFnZUxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgIGludGVybWVkaWF0ZUxheWVyLnJlbmRlclRvQ2FudmFzKGltYWdlTGF5ZXIuY3R4KTtcbiAgICAgICAgaW1hZ2VMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbCA9IGRpc3BsYXlMaXN0W2ldO1xuXG4gICAgICBpZiAoZWwuemxldmVsICE9PSB6bGV2ZWwpIHtcbiAgICAgICAgZmluZEFuZERyYXdPdGhlckxheWVyKHpsZXZlbCwgZWwuemxldmVsKTtcbiAgICAgICAgemxldmVsID0gZWwuemxldmVsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGltYWdlTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICB9XG5cbiAgICBmaW5kQW5kRHJhd090aGVyTGF5ZXIoemxldmVsLCBJbmZpbml0eSk7XG4gICAgcmV0dXJuIGltYWdlTGF5ZXIuZG9tO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/lrr3luqZcbiAgICovXG4gIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/pq5jluqZcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH0sXG4gIF9nZXRTaXplOiBmdW5jdGlvbiAod2hJZHgpIHtcbiAgICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gICAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXVt3aElkeF07XG4gICAgdmFyIGN3aCA9IFsnY2xpZW50V2lkdGgnLCAnY2xpZW50SGVpZ2h0J11bd2hJZHhdO1xuICAgIHZhciBwbHQgPSBbJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdUb3AnXVt3aElkeF07XG4gICAgdmFyIHByYiA9IFsncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nXVt3aElkeF07XG5cbiAgICBpZiAob3B0c1t3aF0gIT0gbnVsbCAmJiBvcHRzW3doXSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChvcHRzW3doXSk7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7IC8vIElFOCBkb2VzIG5vdCBzdXBwb3J0IGdldENvbXB1dGVkU3R5bGUsIGJ1dCBpdCB1c2UgVk1MLlxuXG4gICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUocm9vdCk7XG4gICAgcmV0dXJuIChyb290W2N3aF0gfHwgcGFyc2VJbnQxMChzdGxbd2hdKSB8fCBwYXJzZUludDEwKHJvb3Quc3R5bGVbd2hdKSkgLSAocGFyc2VJbnQxMChzdGxbcGx0XSkgfHwgMCkgLSAocGFyc2VJbnQxMChzdGxbcHJiXSkgfHwgMCkgfCAwO1xuICB9LFxuICBwYXRoVG9JbWFnZTogZnVuY3Rpb24gKHBhdGgsIGRwcikge1xuICAgIGRwciA9IGRwciB8fCB0aGlzLmRwcjtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB2YXIgc3R5bGUgPSBwYXRoLnN0eWxlO1xuICAgIHZhciBzaGFkb3dCbHVyU2l6ZSA9IHN0eWxlLnNoYWRvd0JsdXI7XG4gICAgdmFyIHNoYWRvd09mZnNldFggPSBzdHlsZS5zaGFkb3dPZmZzZXRYO1xuICAgIHZhciBzaGFkb3dPZmZzZXRZID0gc3R5bGUuc2hhZG93T2Zmc2V0WTtcbiAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUuaGFzU3Ryb2tlKCkgPyBzdHlsZS5saW5lV2lkdGggOiAwO1xuICAgIHZhciBsZWZ0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFggKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHJpZ2h0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgc2hhZG93T2Zmc2V0WCArIHNoYWRvd0JsdXJTaXplKTtcbiAgICB2YXIgdG9wTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIGJvdHRvbU1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIHNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aCArIGxlZnRNYXJnaW4gKyByaWdodE1hcmdpbjtcbiAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyB0b3BNYXJnaW4gKyBib3R0b21NYXJnaW47XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcbiAgICBjdHguc2NhbGUoZHByLCBkcHIpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgY3R4LmRwciA9IGRwcjtcbiAgICB2YXIgcGF0aFRyYW5zZm9ybSA9IHtcbiAgICAgIHBvc2l0aW9uOiBwYXRoLnBvc2l0aW9uLFxuICAgICAgcm90YXRpb246IHBhdGgucm90YXRpb24sXG4gICAgICBzY2FsZTogcGF0aC5zY2FsZVxuICAgIH07XG4gICAgcGF0aC5wb3NpdGlvbiA9IFtsZWZ0TWFyZ2luIC0gcmVjdC54LCB0b3BNYXJnaW4gLSByZWN0LnldO1xuICAgIHBhdGgucm90YXRpb24gPSAwO1xuICAgIHBhdGguc2NhbGUgPSBbMSwgMV07XG4gICAgcGF0aC51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgIGlmIChwYXRoKSB7XG4gICAgICBwYXRoLmJydXNoKGN0eCk7XG4gICAgfVxuXG4gICAgdmFyIEltYWdlU2hhcGUgPSBJbWFnZTtcbiAgICB2YXIgaW1nU2hhcGUgPSBuZXcgSW1hZ2VTaGFwZSh7XG4gICAgICBzdHlsZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBpbWFnZTogY2FudmFzXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGF0aFRyYW5zZm9ybS5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICBpbWdTaGFwZS5wb3NpdGlvbiA9IHBhdGgucG9zaXRpb24gPSBwYXRoVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIH1cblxuICAgIGlmIChwYXRoVHJhbnNmb3JtLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgIGltZ1NoYXBlLnJvdGF0aW9uID0gcGF0aC5yb3RhdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucm90YXRpb247XG4gICAgfVxuXG4gICAgaWYgKHBhdGhUcmFuc2Zvcm0uc2NhbGUgIT0gbnVsbCkge1xuICAgICAgaW1nU2hhcGUuc2NhbGUgPSBwYXRoLnNjYWxlID0gcGF0aFRyYW5zZm9ybS5zY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1nU2hhcGU7XG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBQYWludGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvUGFpbnRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IF9jb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcblxudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vZ3JhcGhpYy9TdHlsZVwiKTtcblxudmFyIFBhdHRlcm4gPSByZXF1aXJlKFwiLi9ncmFwaGljL1BhdHRlcm5cIik7XG5cbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL0xheWVyXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiDliJvlu7pkb21cbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBkb20gaWQg5b6F55SoXG4gKiBAcGFyYW0ge1BhaW50ZXJ9IHBhaW50ZXIgcGFpbnRlciBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRG9tKGlkLCBwYWludGVyLCBkcHIpIHtcbiAgdmFyIG5ld0RvbSA9IHV0aWwuY3JlYXRlQ2FudmFzKCk7XG4gIHZhciB3aWR0aCA9IHBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgdmFyIGhlaWdodCA9IHBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gIHZhciBuZXdEb21TdHlsZSA9IG5ld0RvbS5zdHlsZTsgLy8g5rKhYXBwZW5k5ZGi77yM6K+35Y6f6LCF5oiR6L+Z5qC35YaZ77yM5riF5pmwflxuXG4gIG5ld0RvbVN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgbmV3RG9tU3R5bGUubGVmdCA9IDA7XG4gIG5ld0RvbVN0eWxlLnRvcCA9IDA7XG4gIG5ld0RvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBuZXdEb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICBuZXdEb20ud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgbmV3RG9tLmhlaWdodCA9IGhlaWdodCAqIGRwcjsgLy8gaWTkuI3kvZzkuLrntKLlvJXnlKjvvIzpgb/lhY3lj6/og73pgKDmiJDnmoTph43lkI3vvIzlrprkuYnkuLrnp4HmnInlsZ7mgKdcblxuICBuZXdEb20uc2V0QXR0cmlidXRlKCdkYXRhLXpyLWRvbS1pZCcsIGlkKTtcbiAgcmV0dXJuIG5ld0RvbTtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0xheWVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9QYWludGVyfSBwYWludGVyXG4gKiBAcGFyYW0ge251bWJlcn0gW2Rwcl1cbiAqL1xuXG5cbnZhciBMYXllciA9IGZ1bmN0aW9uIChpZCwgcGFpbnRlciwgZHByKSB7XG4gIHZhciBkb207XG4gIGRwciA9IGRwciB8fCBkZXZpY2VQaXhlbFJhdGlvO1xuXG4gIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgZG9tID0gY3JlYXRlRG9tKGlkLCBwYWludGVyLCBkcHIpO1xuICB9IC8vIE5vdCB1c2luZyBpc0RvbSBiZWNhdXNlIGluIG5vZGUgaXQgd2lsbCByZXR1cm4gZmFsc2VcbiAgZWxzZSBpZiAodXRpbC5pc09iamVjdChpZCkpIHtcbiAgICAgIGRvbSA9IGlkO1xuICAgICAgaWQgPSBkb20uaWQ7XG4gICAgfVxuXG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5kb20gPSBkb207XG4gIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcblxuICBpZiAoZG9tU3R5bGUpIHtcbiAgICAvLyBOb3QgaW4gbm9kZVxuICAgIGRvbS5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuXG4gICAgZG9tU3R5bGVbJy13ZWJraXQtdXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICBkb21TdHlsZVsndXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICBkb21TdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSAnbm9uZSc7XG4gICAgZG9tU3R5bGVbJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvciddID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgIGRvbVN0eWxlWydwYWRkaW5nJ10gPSAwO1xuICAgIGRvbVN0eWxlWydtYXJnaW4nXSA9IDA7XG4gICAgZG9tU3R5bGVbJ2JvcmRlci13aWR0aCddID0gMDtcbiAgfVxuXG4gIHRoaXMuZG9tQmFjayA9IG51bGw7XG4gIHRoaXMuY3R4QmFjayA9IG51bGw7XG4gIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG4gIHRoaXMuY29uZmlnID0gbnVsbDsgLy8gQ29uZmlnc1xuXG4gIC8qKlxuICAgKiDmr4/mrKHmuIXnqbrnlLvluIPnmoTpopzoibJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cblxuICB0aGlzLmNsZWFyQ29sb3IgPSAwO1xuICAvKipcbiAgICog5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cblxuICB0aGlzLm1vdGlvbkJsdXIgPSBmYWxzZTtcbiAgLyoqXG4gICAqIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDAuN1xuICAgKi9cblxuICB0aGlzLmxhc3RGcmFtZUFscGhhID0gMC43O1xuICAvKipcbiAgICogTGF5ZXIgZHByXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuZHByID0gZHByO1xufTtcblxuTGF5ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTGF5ZXIsXG4gIGVsQ291bnQ6IDAsXG4gIF9fZGlydHk6IHRydWUsXG4gIGluaXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdHggPSB0aGlzLmRvbS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY3R4Ll9fY3VycmVudFZhbHVlcyA9IHt9O1xuICAgIHRoaXMuY3R4LmRwciA9IHRoaXMuZHByO1xuICB9LFxuICBjcmVhdGVCYWNrQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRwciA9IHRoaXMuZHByO1xuICAgIHRoaXMuZG9tQmFjayA9IGNyZWF0ZURvbSgnYmFjay0nICsgdGhpcy5pZCwgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgIHRoaXMuY3R4QmFjayA9IHRoaXMuZG9tQmFjay5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY3R4QmFjay5fX2N1cnJlbnRWYWx1ZXMgPSB7fTtcblxuICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZHByID0gdGhpcy5kcHI7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICBkb21TdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBkb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIGRvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICAgIGRvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICBpZiAoZG9tQmFjaykge1xuICAgICAgZG9tQmFjay53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgZG9tQmFjay5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5riF56m66K+l5bGC55S75biDXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJBbGwgQ2xlYXIgYWxsIHdpdGggb3V0IG1vdGlvbiBibHVyXG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKGNsZWFyQWxsKSB7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICB2YXIgd2lkdGggPSBkb20ud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGRvbS5oZWlnaHQ7XG4gICAgdmFyIGNsZWFyQ29sb3IgPSB0aGlzLmNsZWFyQ29sb3I7XG4gICAgdmFyIGhhdmVNb3Rpb25CTHVyID0gdGhpcy5tb3Rpb25CbHVyICYmICFjbGVhckFsbDtcbiAgICB2YXIgbGFzdEZyYW1lQWxwaGEgPSB0aGlzLmxhc3RGcmFtZUFscGhhO1xuICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgIGlmIChoYXZlTW90aW9uQkx1cikge1xuICAgICAgaWYgKCF0aGlzLmRvbUJhY2spIHtcbiAgICAgICAgdGhpcy5jcmVhdGVCYWNrQnVmZmVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4QmFjay5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgICB0aGlzLmN0eEJhY2suZHJhd0ltYWdlKGRvbSwgMCwgMCwgd2lkdGggLyBkcHIsIGhlaWdodCAvIGRwcik7XG4gICAgfVxuXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGlmIChjbGVhckNvbG9yKSB7XG4gICAgICB2YXIgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuOyAvLyBHcmFkaWVudFxuXG4gICAgICBpZiAoY2xlYXJDb2xvci5jb2xvclN0b3BzKSB7XG4gICAgICAgIC8vIENhY2hlIGNhbnZhcyBncmFkaWVudFxuICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgfHwgU3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBjbGVhckNvbG9yLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgY2xlYXJDb2xvci5fX2NhbnZhc0dyYWRpZW50ID0gY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuO1xuICAgICAgfSAvLyBQYXR0ZXJuXG4gICAgICBlbHNlIGlmIChjbGVhckNvbG9yLmltYWdlKSB7XG4gICAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybi5jYWxsKGNsZWFyQ29sb3IsIGN0eCk7XG4gICAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gfHwgY2xlYXJDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgaWYgKGhhdmVNb3Rpb25CTHVyKSB7XG4gICAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBsYXN0RnJhbWVBbHBoYTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoZG9tQmFjaywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IExheWVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34venJlbmRlci9saWIvTGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZGVmYXVsdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvenJlbmRlci9pc3N1ZXMvMTg5I2lzc3VlY29tbWVudC0yMjQ5MTk4MDlcbndpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkgfHwgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgc2V0VGltZW91dChmdW5jLCAxNik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBfZXZlbnQgPSByZXF1aXJlKFwiLi4vY29yZS9ldmVudFwiKTtcblxudmFyIERpc3BhdGNoZXIgPSBfZXZlbnQuRGlzcGF0Y2hlcjtcblxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoXCIuL3JlcXVlc3RBbmltYXRpb25GcmFtZVwiKTtcblxudmFyIEFuaW1hdG9yID0gcmVxdWlyZShcIi4vQW5pbWF0b3JcIik7XG5cbi8qKlxuICog5Yqo55S75Li757G7LCDosIPluqblkoznrqHnkIbmiYDmnInliqjnlLvmjqfliLblmahcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG4vLyBUT0RPIEFkZGl0aXZlIGFuaW1hdGlvblxuLy8gaHR0cDovL2lvc290ZXJpYy5jb20vYWRkaXRpdmUtYW5pbWF0aW9ucy1hbmltYXRld2l0aGR1cmF0aW9uLWluLWlvcy04L1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3ZpZGVvcy93d2RjMjAxNC8jMjM2XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSVpSZW5kZXJTdGFnZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXBkYXRlXG4gKi9cblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbmZyYW1lXVxuICogQHBhcmFtIHtJWlJlbmRlclN0YWdlfSBbb3B0aW9ucy5zdGFnZV1cbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oKTtcbiAqICAgICB2YXIgb2JqID0ge1xuICogICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgIHk6IDEwMFxuICogICAgIH07XG4gKiAgICAgYW5pbWF0aW9uLmFuaW1hdGUobm9kZS5wb3NpdGlvbilcbiAqICAgICAgICAgLndoZW4oMTAwMCwge1xuICogICAgICAgICAgICAgeDogNTAwLFxuICogICAgICAgICAgICAgeTogNTAwXG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIC53aGVuKDIwMDAsIHtcbiAqICAgICAgICAgICAgIHg6IDEwMCxcbiAqICAgICAgICAgICAgIHk6IDEwMFxuICogICAgICAgICB9KVxuICogICAgICAgICAuc3RhcnQoJ3NwbGluZScpO1xuICovXG52YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuc3RhZ2UgPSBvcHRpb25zLnN0YWdlIHx8IHt9O1xuXG4gIHRoaXMub25mcmFtZSA9IG9wdGlvbnMub25mcmFtZSB8fCBmdW5jdGlvbiAoKSB7fTsgLy8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG5cblxuICB0aGlzLl9jbGlwcyA9IFtdO1xuICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gIHRoaXMuX3RpbWU7XG4gIHRoaXMuX3BhdXNlZFRpbWU7XG4gIHRoaXMuX3BhdXNlU3RhcnQ7XG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICBEaXNwYXRjaGVyLmNhbGwodGhpcyk7XG59O1xuXG5BbmltYXRpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQW5pbWF0aW9uLFxuXG4gIC8qKlxuICAgKiDmt7vliqAgY2xpcFxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAqL1xuICBhZGRDbGlwOiBmdW5jdGlvbiAoY2xpcCkge1xuICAgIHRoaXMuX2NsaXBzLnB1c2goY2xpcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoCBhbmltYXRvclxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICovXG4gIGFkZEFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICBhbmltYXRvci5hbmltYXRpb24gPSB0aGlzO1xuICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFkZENsaXAoY2xpcHNbaV0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXB9IGNsaXBcbiAgICovXG4gIHJlbW92ZUNsaXA6IGZ1bmN0aW9uIChjbGlwKSB7XG4gICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9jbGlwcywgY2xpcCk7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuX2NsaXBzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfSBhbmltYXRvclxuICAgKi9cbiAgcmVtb3ZlQW5pbWF0b3I6IGZ1bmN0aW9uIChhbmltYXRvcikge1xuICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlbW92ZUNsaXAoY2xpcHNbaV0pO1xuICAgIH1cblxuICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IG51bGw7XG4gIH0sXG4gIF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fcGF1c2VkVGltZTtcblxuICAgIHZhciBkZWx0YSA9IHRpbWUgLSB0aGlzLl90aW1lO1xuICAgIHZhciBjbGlwcyA9IHRoaXMuX2NsaXBzO1xuICAgIHZhciBsZW4gPSBjbGlwcy5sZW5ndGg7XG4gICAgdmFyIGRlZmVycmVkRXZlbnRzID0gW107XG4gICAgdmFyIGRlZmVycmVkQ2xpcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjbGlwID0gY2xpcHNbaV07XG4gICAgICB2YXIgZSA9IGNsaXAuc3RlcCh0aW1lLCBkZWx0YSk7IC8vIFRocm93IG91dCB0aGUgZXZlbnRzIG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyXG4gICAgICAvLyBzdGFnZS51cGRhdGUsIGxpa2UgZGVzdHJveVxuXG4gICAgICBpZiAoZSkge1xuICAgICAgICBkZWZlcnJlZEV2ZW50cy5wdXNoKGUpO1xuICAgICAgICBkZWZlcnJlZENsaXBzLnB1c2goY2xpcCk7XG4gICAgICB9XG4gICAgfSAvLyBSZW1vdmUgdGhlIGZpbmlzaGVkIGNsaXBcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICBpZiAoY2xpcHNbaV0uX25lZWRzUmVtb3ZlKSB7XG4gICAgICAgIGNsaXBzW2ldID0gY2xpcHNbbGVuIC0gMV07XG4gICAgICAgIGNsaXBzLnBvcCgpO1xuICAgICAgICBsZW4tLTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZW4gPSBkZWZlcnJlZEV2ZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZWZlcnJlZENsaXBzW2ldLmZpcmUoZGVmZXJyZWRFdmVudHNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHRoaXMub25mcmFtZShkZWx0YSk7XG4gICAgdGhpcy50cmlnZ2VyKCdmcmFtZScsIGRlbHRhKTtcblxuICAgIGlmICh0aGlzLnN0YWdlLnVwZGF0ZSkge1xuICAgICAgdGhpcy5zdGFnZS51cGRhdGUoKTtcbiAgICB9XG4gIH0sXG4gIF9zdGFydExvb3A6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgaWYgKHNlbGYuX3J1bm5pbmcpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICAhc2VsZi5fcGF1c2VkICYmIHNlbGYuX3VwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgfSxcblxuICAvKipcbiAgICog5byA5aeL6L+Q6KGM5Yqo55S7XG4gICAqL1xuICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcblxuICAgIHRoaXMuX3N0YXJ0TG9vcCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlgZzmraLov5DooYzliqjnlLtcbiAgICovXG4gIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhdXNlXG4gICAqL1xuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzdW1lXG4gICAqL1xuICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fcGF1c2VTdGFydDtcbiAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5riF6Zmk5omA5pyJ5Yqo55S754mH5q61XG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NsaXBzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWvueS4gOS4quebruagh+WIm+W7uuS4gOS4qmFuaW1hdG9y5a+56LGh77yM5Y+v5Lul5oyH5a6a55uu5qCH5Lit55qE5bGe5oCn5L2/55So5Yqo55S7XG4gICAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5sb29wPWZhbHNlXSDmmK/lkKblvqrnjq/mkq3mlL7liqjnlLtcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLmdldHRlcj1udWxsXVxuICAgKiAgICAgICAgIOWmguaenOaMh+WummdldHRlcuWHveaVsO+8jOS8mumAmui/h2dldHRlcuWHveaVsOWPluWxnuaAp+WAvFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29wdGlvbnMuc2V0dGVyPW51bGxdXG4gICAqICAgICAgICAg5aaC5p6c5oyH5a6ac2V0dGVy5Ye95pWw77yM5Lya6YCa6L+Hc2V0dGVy5Ye95pWw6K6+572u5bGe5oCn5YC8XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25+QW5pbWF0b3J9XG4gICAqL1xuICAvLyBUT0RPIEdhcFxuICBhbmltYXRlOiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKHRhcmdldCwgb3B0aW9ucy5sb29wLCBvcHRpb25zLmdldHRlciwgb3B0aW9ucy5zZXR0ZXIpO1xuICAgIHRoaXMuYWRkQW5pbWF0b3IoYW5pbWF0b3IpO1xuICAgIHJldHVybiBhbmltYXRvcjtcbiAgfVxufTtcbnV0aWwubWl4aW4oQW5pbWF0aW9uLCBEaXNwYXRjaGVyKTtcbnZhciBfZGVmYXVsdCA9IEFuaW1hdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuLi9taXhpbi9FdmVudGZ1bFwiKTtcblxuZXhwb3J0cy5EaXNwYXRjaGVyID0gRXZlbnRmdWw7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi9lbnZcIik7XG5cbi8qKlxuICog5LqL5Lu26L6F5Yqp57G7XG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9ldmVudFxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKi9cbnZhciBpc0RvbUxldmVsMiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICEhd2luZG93LmFkZEV2ZW50TGlzdGVuZXI7XG52YXIgTU9VU0VfRVZFTlRfUkVHID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svO1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpIHtcbiAgLy8gQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKSBkb24ndCBoYXZlIGdldEJvdW5kaW5nUmVjdFxuICByZXR1cm4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID8gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDBcbiAgfTtcbn0gLy8gYGNhbGN1bGF0ZWAgaXMgb3B0aW9uYWwsIGRlZmF1bHQgZmFsc2VcblxuXG5mdW5jdGlvbiBjbGllbnRUb0xvY2FsKGVsLCBlLCBvdXQsIGNhbGN1bGF0ZSkge1xuICBvdXQgPSBvdXQgfHwge307IC8vIEFjY29yZGluZyB0byB0aGUgVzNDIFdvcmtpbmcgRHJhZnQsIG9mZnNldFggYW5kIG9mZnNldFkgc2hvdWxkIGJlIHJlbGF0aXZlXG4gIC8vIHRvIHRoZSBwYWRkaW5nIGVkZ2Ugb2YgdGhlIHRhcmdldCBlbGVtZW50LiBUaGUgb25seSBicm93c2VyIHVzaW5nIHRoaXMgY29udmVudGlvblxuICAvLyBpcyBJRS4gV2Via2l0IHVzZXMgdGhlIGJvcmRlciBlZGdlLCBPcGVyYSB1c2VzIHRoZSBjb250ZW50IGVkZ2UsIGFuZCBGaXJlRm94IGRvZXNcbiAgLy8gbm90IHN1cHBvcnQgdGhlIHByb3BlcnRpZXMuXG4gIC8vIChzZWUgaHR0cDovL3d3dy5qYWNrbG1vb3JlLmNvbS9ub3Rlcy9tb3VzZS1wb3NpdGlvbi8pXG4gIC8vIEluIHpyIHBhaW50ZXIuZG9tLCBwYWRkaW5nIGVkZ2UgZXF1YWxzIHRvIGJvcmRlciBlZGdlLlxuICAvLyBGSVhNRVxuICAvLyBXaGVuIG1vdXNlbW92ZSBldmVudCB0cmlnZ2VyZWQgb24gZWMgdG9vbHRpcCwgdGFyZ2V0IGlzIG5vdCB6ciBwYWludGVyLmRvbSwgYW5kXG4gIC8vIG9mZnNldFgvWSBpcyByZWxhdGl2ZSB0byBlLnRhcmdldCwgd2hlcmUgdGhlIGNhbGN1bGF0aW9uIG9mIHpyWC9ZIHZpYSBvZmZzZXRYL1lcbiAgLy8gaXMgdG9vIGNvbXBsZXguIFNvIGNzcy10cmFuc2Zyb20gZG9udCBzdXBwb3J0IGluIHRoaXMgY2FzZSB0ZW1wb3JhcmlseS5cblxuICBpZiAoY2FsY3VsYXRlIHx8ICFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCk7XG4gIH0gLy8gQ2F1dGlvbjogSW4gRmlyZUZveCwgbGF5ZXJYL2xheWVyWSBNb3VzZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgY2xvc2VzdCBwb3NpdGlvbmVkXG4gIC8vIGFuY2VzdG9yIGVsZW1lbnQsIHNvIHdlIHNob3VsZCBtYWtlIHN1cmUgZWwgaXMgcG9zaXRpb25lZCAoZS5nLiwgbm90IHBvc2l0aW9uOnN0YXRpYykuXG4gIC8vIEJUVzEsIFdlYmtpdCBkb24ndCByZXR1cm4gdGhlIHNhbWUgcmVzdWx0cyBhcyBGRiBpbiBub24tc2ltcGxlIGNhc2VzIChsaWtlIGFkZFxuICAvLyB6b29tLWZhY3Rvciwgb3ZlcmZsb3cgLyBvcGFjaXR5IGxheWVycywgdHJhbnNmb3JtcyAuLi4pXG4gIC8vIEJUVzIsIChldi5vZmZzZXRZIHx8IGV2LnBhZ2VZIC0gJChldi50YXJnZXQpLm9mZnNldCgpLnRvcCkgaXMgbm90IGNvcnJlY3QgaW4gcHJlc2VydmUtM2QuXG4gIC8vIDxodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvODUyMyNjb21tZW50OjE0PlxuICAvLyBCVFczLCBJbiBmZiwgb2Zmc2V0WC9vZmZzZXRZIGlzIGFsd2F5cyAwLlxuICBlbHNlIGlmIChlbnYuYnJvd3Nlci5maXJlZm94ICYmIGUubGF5ZXJYICE9IG51bGwgJiYgZS5sYXllclggIT09IGUub2Zmc2V0WCkge1xuICAgICAgb3V0LnpyWCA9IGUubGF5ZXJYO1xuICAgICAgb3V0LnpyWSA9IGUubGF5ZXJZO1xuICAgIH0gLy8gRm9yIElFNissIGNocm9tZSwgc2FmYXJpLCBvcGVyYS4gKFdoZW4gd2lsbCBmZiBzdXBwb3J0IG9mZnNldFg/KVxuICAgIGVsc2UgaWYgKGUub2Zmc2V0WCAhPSBudWxsKSB7XG4gICAgICAgIG91dC56clggPSBlLm9mZnNldFg7XG4gICAgICAgIG91dC56clkgPSBlLm9mZnNldFk7XG4gICAgICB9IC8vIEZvciBzb21lIG90aGVyIGRldmljZSwgZS5nLiwgSU9TIHNhZmFyaS5cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpO1xuICAgICAgICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCkge1xuICAvLyBUaGlzIHdlbGwta25vd24gbWV0aG9kIGJlbG93IGRvZXMgbm90IHN1cHBvcnQgY3NzIHRyYW5zZm9ybS5cbiAgdmFyIGJveCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCk7XG4gIG91dC56clggPSBlLmNsaWVudFggLSBib3gubGVmdDtcbiAgb3V0LnpyWSA9IGUuY2xpZW50WSAtIGJveC50b3A7XG59XG4vKipcbiAqIOWmguaenOWtmOWcqOesrOS4ieaWueW1jOWFpeeahOS4gOS6m2RvbeinpuWPkeeahOS6i+S7tu+8jOaIlnRvdWNo5LqL5Lu277yM6ZyA6KaB6L2s5o2i5LiA5LiL5LqL5Lu25Z2Q5qCHLlxuICogYGNhbGN1bGF0ZWAgaXMgb3B0aW9uYWwsIGRlZmF1bHQgZmFsc2UuXG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudChlbCwgZSwgY2FsY3VsYXRlKSB7XG4gIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICBpZiAoZS56clggIT0gbnVsbCkge1xuICAgIHJldHVybiBlO1xuICB9XG5cbiAgdmFyIGV2ZW50VHlwZSA9IGUudHlwZTtcbiAgdmFyIGlzVG91Y2ggPSBldmVudFR5cGUgJiYgZXZlbnRUeXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMDtcblxuICBpZiAoIWlzVG91Y2gpIHtcbiAgICBjbGllbnRUb0xvY2FsKGVsLCBlLCBlLCBjYWxjdWxhdGUpO1xuICAgIGUuenJEZWx0YSA9IGUud2hlZWxEZWx0YSA/IGUud2hlZWxEZWx0YSAvIDEyMCA6IC0oZS5kZXRhaWwgfHwgMCkgLyAzO1xuICB9IGVsc2Uge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50VHlwZSAhPSAndG91Y2hlbmQnID8gZS50YXJnZXRUb3VjaGVzWzBdIDogZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICB0b3VjaCAmJiBjbGllbnRUb0xvY2FsKGVsLCB0b3VjaCwgZSwgY2FsY3VsYXRlKTtcbiAgfSAvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0OyBvdGhlcndpc2U6IDA7XG4gIC8vIFNlZSBqUXVlcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuICAvLyBJZiBlLndoaWNoIGhhcyBiZWVuIGRlZmluZWQsIGlmIG1heSBiZSByZWFkb25seSxcbiAgLy8gc2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC93aGljaFxuXG5cbiAgdmFyIGJ1dHRvbiA9IGUuYnV0dG9uO1xuXG4gIGlmIChlLndoaWNoID09IG51bGwgJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgTU9VU0VfRVZFTlRfUkVHLnRlc3QoZS50eXBlKSkge1xuICAgIGUud2hpY2ggPSBidXR0b24gJiAxID8gMSA6IGJ1dHRvbiAmIDIgPyAzIDogYnV0dG9uICYgNCA/IDIgOiAwO1xuICB9XG5cbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgbmFtZSwgaGFuZGxlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaGFuZGxlcikge1xuICBpZiAoaXNEb21MZXZlbDIpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIGVsLmRldGFjaEV2ZW50KCdvbicgKyBuYW1lLCBoYW5kbGVyKTtcbiAgfVxufVxuLyoqXG4gKiBwcmV2ZW50RGVmYXVsdCBhbmQgc3RvcFByb3BhZ2F0aW9uLlxuICogTm90aWNlOiBkbyBub3QgZG8gdGhhdCBpbiB6cmVuZGVyLiBVcHBlciBhcHBsaWNhdGlvblxuICogZG8gdGhhdCBpZiBuZWNlc3NhcnkuXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvZXZlbnRcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7RXZlbnR9IGUgOiBldmVudOWvueixoVxuICovXG5cblxudmFyIHN0b3AgPSBpc0RvbUxldmVsMiA/IGZ1bmN0aW9uIChlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xufSA6IGZ1bmN0aW9uIChlKSB7XG4gIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xufTtcblxuZnVuY3Rpb24gbm90TGVmdE1vdXNlKGUpIHtcbiAgLy8gSWYgZS53aGljaCBpcyB1bmRlZmluZWQsIGNvbnNpZGVyZWQgYXMgbGVmdCBtb3VzZSBldmVudC5cbiAgcmV0dXJuIGUud2hpY2ggPiAxO1xufSAvLyDlgZrlkJHkuIrlhbzlrrlcblxuXG5leHBvcnRzLmNsaWVudFRvTG9jYWwgPSBjbGllbnRUb0xvY2FsO1xuZXhwb3J0cy5ub3JtYWxpemVFdmVudCA9IG5vcm1hbGl6ZUV2ZW50O1xuZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcbmV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLnN0b3AgPSBzdG9wO1xuZXhwb3J0cy5ub3RMZWZ0TW91c2UgPSBub3RMZWZ0TW91c2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZXZlbnQgPSByZXF1aXJlKFwiLi4vY29yZS9ldmVudFwiKTtcblxudmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBfZXZlbnQuYWRkRXZlbnRMaXN0ZW5lcjtcbnZhciByZW1vdmVFdmVudExpc3RlbmVyID0gX2V2ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXI7XG52YXIgbm9ybWFsaXplRXZlbnQgPSBfZXZlbnQubm9ybWFsaXplRXZlbnQ7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwiLi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi4vY29yZS9lbnZcIik7XG5cbnZhciBHZXN0dXJlTWdyID0gcmVxdWlyZShcIi4uL2NvcmUvR2VzdHVyZU1nclwiKTtcblxudmFyIFRPVUNIX0NMSUNLX0RFTEFZID0gMzAwO1xudmFyIG1vdXNlSGFuZGxlck5hbWVzID0gWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JywgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdjb250ZXh0bWVudSddO1xudmFyIHRvdWNoSGFuZGxlck5hbWVzID0gWyd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSddO1xudmFyIHBvaW50ZXJFdmVudE5hbWVzID0ge1xuICBwb2ludGVyZG93bjogMSxcbiAgcG9pbnRlcnVwOiAxLFxuICBwb2ludGVybW92ZTogMSxcbiAgcG9pbnRlcm91dDogMVxufTtcbnZhciBwb2ludGVySGFuZGxlck5hbWVzID0genJVdGlsLm1hcChtb3VzZUhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIG5tID0gbmFtZS5yZXBsYWNlKCdtb3VzZScsICdwb2ludGVyJyk7XG4gIHJldHVybiBwb2ludGVyRXZlbnROYW1lc1tubV0gPyBubSA6IG5hbWU7XG59KTtcblxuZnVuY3Rpb24gZXZlbnROYW1lRml4KG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUgPT09ICdtb3VzZXdoZWVsJyAmJiBlbnYuYnJvd3Nlci5maXJlZm94ID8gJ0RPTU1vdXNlU2Nyb2xsJyA6IG5hbWU7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NHZXN0dXJlKHByb3h5LCBldmVudCwgc3RhZ2UpIHtcbiAgdmFyIGdlc3R1cmVNZ3IgPSBwcm94eS5fZ2VzdHVyZU1ncjtcbiAgc3RhZ2UgPT09ICdzdGFydCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuICB2YXIgZ2VzdHVyZUluZm8gPSBnZXN0dXJlTWdyLnJlY29nbml6ZShldmVudCwgcHJveHkuaGFuZGxlci5maW5kSG92ZXIoZXZlbnQuenJYLCBldmVudC56clksIG51bGwpLnRhcmdldCwgcHJveHkuZG9tKTtcbiAgc3RhZ2UgPT09ICdlbmQnICYmIGdlc3R1cmVNZ3IuY2xlYXIoKTsgLy8gRG8gbm90IGRvIGFueSBwcmV2ZW50RGVmYXVsdCBoZXJlLiBVcHBlciBhcHBsaWNhdGlvbiBkbyB0aGF0IGlmIG5lY2Vzc2FyeS5cblxuICBpZiAoZ2VzdHVyZUluZm8pIHtcbiAgICB2YXIgdHlwZSA9IGdlc3R1cmVJbmZvLnR5cGU7XG4gICAgZXZlbnQuZ2VzdHVyZUV2ZW50ID0gdHlwZTtcbiAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KHtcbiAgICAgIHRhcmdldDogZ2VzdHVyZUluZm8udGFyZ2V0XG4gICAgfSwgdHlwZSwgZ2VzdHVyZUluZm8uZXZlbnQpO1xuICB9XG59IC8vIGZ1bmN0aW9uIG9uTVNHZXN0dXJlQ2hhbmdlKHByb3h5LCBldmVudCkge1xuLy8gICAgIGlmIChldmVudC50cmFuc2xhdGlvblggfHwgZXZlbnQudHJhbnNsYXRpb25ZKSB7XG4vLyAgICAgICAgIC8vIG1vdXNlbW92ZSBpcyBjYXJyaWVkIGJ5IE1TR2VzdHVyZSB0byByZWR1Y2UgdGhlIHNlbnNpdGl2aXR5LlxuLy8gICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGV2ZW50LnRhcmdldCwgJ21vdXNlbW92ZScsIGV2ZW50KTtcbi8vICAgICB9XG4vLyAgICAgaWYgKGV2ZW50LnNjYWxlICE9PSAxKSB7XG4vLyAgICAgICAgIGV2ZW50LnBpbmNoWCA9IGV2ZW50Lm9mZnNldFg7XG4vLyAgICAgICAgIGV2ZW50LnBpbmNoWSA9IGV2ZW50Lm9mZnNldFk7XG4vLyAgICAgICAgIGV2ZW50LnBpbmNoU2NhbGUgPSBldmVudC5zY2FsZTtcbi8vICAgICAgICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudChldmVudC50YXJnZXQsICdwaW5jaCcsIGV2ZW50KTtcbi8vICAgICB9XG4vLyB9XG5cbi8qKlxuICogUHJldmVudCBtb3VzZSBldmVudCBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgYWZ0ZXIgVG91Y2ggRXZlbnRzIGFjdGlvblxuICogQHNlZSA8aHR0cHM6Ly9naXRodWIuY29tL2RlbHRha29zaC9oYW5kanMvYmxvYi9tYXN0ZXIvc3JjL2hhbmQuYmFzZS5qcz5cbiAqIDEuIE1vYmlsZSBicm93c2VycyBkaXNwYXRjaCBtb3VzZSBldmVudHMgMzAwbXMgYWZ0ZXIgdG91Y2hlbmQuXG4gKiAyLiBDaHJvbWUgZm9yIEFuZHJvaWQgZGlzcGF0Y2ggbW91c2Vkb3duIGZvciBsb25nLXRvdWNoIGFib3V0IDY1MG1zXG4gKiBSZXN1bHQ6IEJsb2NraW5nIE1vdXNlIEV2ZW50cyBmb3IgNzAwbXMuXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRUb3VjaFRpbWVyKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLl90b3VjaGluZyA9IHRydWU7XG4gIGNsZWFyVGltZW91dChpbnN0YW5jZS5fdG91Y2hUaW1lcik7XG4gIGluc3RhbmNlLl90b3VjaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaW5zdGFuY2UuX3RvdWNoaW5nID0gZmFsc2U7XG4gIH0sIDcwMCk7XG59XG5cbnZhciBkb21IYW5kbGVycyA9IHtcbiAgLyoqXG4gICAqIE1vdXNlIG1vdmUgaGFuZGxlclxuICAgKiBAaW5uZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuICAgIHRoaXMudHJpZ2dlcignbW91c2Vtb3ZlJywgZXZlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3VzZSBvdXQgaGFuZGxlclxuICAgKiBAaW5uZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldDtcblxuICAgIGlmIChlbGVtZW50ICE9IHRoaXMuZG9tKSB7XG4gICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9IDkpIHtcbiAgICAgICAgLy8g5b+955Wl5YyF5ZCr5Zyocm9vdOS4reeahGRvbeW8lei1t+eahG1vdXNlT3V0XG4gICAgICAgIGlmIChlbGVtZW50ID09PSB0aGlzLmRvbSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VyKCdtb3VzZW91dCcsIGV2ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogVG91Y2jlvIDlp4vlk43lupTlh73mlbBcbiAgICogQGlubmVyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICB0b3VjaHN0YXJ0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBEZWZhdWx0IG1vdXNlIGJlaGF2aW91ciBzaG91bGQgbm90IGJlIGRpc2FibGVkIGhlcmUuXG4gICAgLy8gRm9yIGV4YW1wbGUsIHBhZ2UgbWF5IG5lZWRzIHRvIGJlIHNsaWRlZC5cbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7IC8vIE1hcmsgdG91Y2gsIHdoaWNoIGlzIHVzZWZ1bCBpbiBkaXN0aW5ndWlzaCB0b3VjaCBhbmRcbiAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cblxuICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG4gICAgdGhpcy5fbGFzdFRvdWNoTW9tZW50ID0gbmV3IERhdGUoKTtcbiAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ3N0YXJ0Jyk7IC8vIEluIHRvdWNoIGRldmljZSwgdHJpZ2dlciBgbW91c2Vtb3ZlYChgbW91c2VvdmVyYCkgc2hvdWxkXG4gICAgLy8gYmUgdHJpZ2dlcmVkLCBhbmQgbXVzdCBiZWZvcmUgYG1vdXNlZG93bmAgdHJpZ2dlcmVkLlxuXG4gICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIGRvbUhhbmRsZXJzLm1vdXNlZG93bi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb3VjaOenu+WKqOWTjeW6lOWHveaVsFxuICAgKiBAaW5uZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpOyAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG5cbiAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnY2hhbmdlJyk7IC8vIE1vdXNlIG1vdmUgc2hvdWxkIGFsd2F5cyBiZSB0cmlnZ2VyZWQgbm8gbWF0dGVyIHdoZXRoZXJcbiAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LCBiZWNhdXNlIG1vdXNlIG1vdmUgYW5kIHBpbmNoIG1heVxuICAgIC8vIGJlIHVzZWQgYXQgdGhlIHNhbWUgdGltZS5cblxuICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb3VjaOe7k+adn+WTjeW6lOWHveaVsFxuICAgKiBAaW5uZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIHRvdWNoZW5kOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7IC8vIE1hcmsgdG91Y2gsIHdoaWNoIGlzIHVzZWZ1bCBpbiBkaXN0aW5ndWlzaCB0b3VjaCBhbmRcbiAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cblxuICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG4gICAgcHJvY2Vzc0dlc3R1cmUodGhpcywgZXZlbnQsICdlbmQnKTtcbiAgICBkb21IYW5kbGVycy5tb3VzZXVwLmNhbGwodGhpcywgZXZlbnQpOyAvLyBEbyBub3QgdHJpZ2dlciBgbW91c2VvdXRgIGhlcmUsIGluIHNwaXRlIG9mIGBtb3VzZW1vdmVgKGBtb3VzZW92ZXJgKSBpc1xuICAgIC8vIHRyaWdnZXJlZCBpbiBgdG91Y2hzdGFydGAuIFRoaXMgc2VlbXMgdG8gYmUgaWxsb2dpY2FsLCBidXQgYnkgdGhpcyBtZWNoYW5pc20sXG4gICAgLy8gd2UgY2FuIGNvbnZlbmllbnRseSBpbXBsZW1lbnQgXCJob3ZlciBzdHlsZVwiIGluIGJvdGggUEMgYW5kIHRvdWNoIGRldmljZSBqdXN0XG4gICAgLy8gYnkgbGlzdGVuaW5nIHRvIGBtb3VzZW92ZXJgIHRvIGFkZCBcImhvdmVyIHN0eWxlXCIgYW5kIGxpc3RlbmluZyB0byBgbW91c2VvdXRgXG4gICAgLy8gdG8gcmVtb3ZlIFwiaG92ZXIgc3R5bGVcIiBvbiBhbiBlbGVtZW50LCB3aXRob3V0IGFueSBhZGRpdGlvbmFsIGNvZGUgZm9yXG4gICAgLy8gY29tcGF0aWJpbGl0eS4gKGBtb3VzZW91dGAgd2lsbCBub3QgYmUgdHJpZ2dlcmVkIGluIGB0b3VjaGVuZGAsIHNvIFwiaG92ZXJcbiAgICAvLyBzdHlsZVwiIHdpbGwgcmVtYWluIGZvciB1c2VyIHZpZXcpXG4gICAgLy8gY2xpY2sgZXZlbnQgc2hvdWxkIGFsd2F5cyBiZSB0cmlnZ2VyZWQgbm8gbWF0dGVyIHdoZXRoZXJcbiAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LiBTeXN0ZW0gY2xpY2sgY2FuIG5vdCBiZSBwcmV2ZW50ZWQuXG5cbiAgICBpZiAoK25ldyBEYXRlKCkgLSB0aGlzLl9sYXN0VG91Y2hNb21lbnQgPCBUT1VDSF9DTElDS19ERUxBWSkge1xuICAgICAgZG9tSGFuZGxlcnMuY2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuXG4gICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgfSxcbiAgcG9pbnRlcmRvd246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGRvbUhhbmRsZXJzLm1vdXNlZG93bi5jYWxsKHRoaXMsIGV2ZW50KTsgLy8gaWYgKHVzZU1TR3Vlc3R1cmUodGhpcywgZXZlbnQpKSB7XG4gICAgLy8gICAgIHRoaXMuX21zR2VzdHVyZS5hZGRQb2ludGVyKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgLy8gfVxuICB9LFxuICBwb2ludGVybW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gRklYTUVcbiAgICAvLyBwb2ludGVybW92ZSBpcyBzbyBzZW5zaXRpdmUgdGhhdCBpdCBhbHdheXMgdHJpZ2dlcmVkIHdoZW5cbiAgICAvLyB0YXAoY2xpY2spIG9uIHRvdWNoIHNjcmVlbiwgd2hpY2ggYWZmZWN0IHNvbWUganVkZ2VtZW50IGluXG4gICAgLy8gdXBwZXIgYXBwbGljYXRpb24uIFNvLCB3ZSBkb250IHN1cHBvcnQgbW91c2Vtb3ZlIG9uIE1TIHRvdWNoXG4gICAgLy8gZGV2aWNlIHlldC5cbiAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIHBvaW50ZXJ1cDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZG9tSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfSxcbiAgcG9pbnRlcm91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gcG9pbnRlcm91dCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRhcCBvbiB0b3VjaCBzY3JlZW5cbiAgICAvLyAoSUUxMSsvRWRnZSBvbiBNUyBTdXJmYWNlKSBhZnRlciBjbGljayBldmVudCB0cmlnZ2VyZWQsXG4gICAgLy8gd2hpY2ggaXMgaW5jb25zaXN0ZW50IHdpdGggdGhlIG1vdXNvdXQgYmVoYXZpb3Igd2UgZGVmaW5lZFxuICAgIC8vIGluIHRvdWNoZW5kLiBTbyB3ZSB1bmlmeSB0aGVtLlxuICAgIC8vIChjaGVjayBkb21IYW5kbGVycy50b3VjaGVuZCBmb3IgZGV0YWlsZWQgZXhwbGFuYXRpb24pXG4gICAgaWYgKCFpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpKSB7XG4gICAgICBkb21IYW5kbGVycy5tb3VzZW91dC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzUG9pbnRlckZyb21Ub3VjaChldmVudCkge1xuICB2YXIgcG9pbnRlclR5cGUgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgcmV0dXJuIHBvaW50ZXJUeXBlID09PSAncGVuJyB8fCBwb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcbn0gLy8gZnVuY3Rpb24gdXNlTVNHdWVzdHVyZShoYW5kbGVyUHJveHksIGV2ZW50KSB7XG4vLyAgICAgcmV0dXJuIGlzUG9pbnRlckZyb21Ub3VjaChldmVudCkgJiYgISFoYW5kbGVyUHJveHkuX21zR2VzdHVyZTtcbi8vIH1cbi8vIENvbW1vbiBoYW5kbGVyc1xuXG5cbnpyVXRpbC5lYWNoKFsnY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2V3aGVlbCcsICdkYmxjbGljaycsICdjb250ZXh0bWVudSddLCBmdW5jdGlvbiAobmFtZSkge1xuICBkb21IYW5kbGVyc1tuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICB0aGlzLnRyaWdnZXIobmFtZSwgZXZlbnQpO1xuICB9O1xufSk7XG4vKipcbiAqIOS4uuaOp+WItuexu+WunuS+i+WIneWni+WMlmRvbSDkuovku7blpITnkIblh73mlbBcbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvSGFuZGxlcn0gaW5zdGFuY2Ug5o6n5Yi257G75a6e5L6LXG4gKi9cblxuZnVuY3Rpb24gaW5pdERvbUhhbmRsZXIoaW5zdGFuY2UpIHtcbiAgenJVdGlsLmVhY2godG91Y2hIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdID0genJVdGlsLmJpbmQoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgfSk7XG4gIHpyVXRpbC5lYWNoKHBvaW50ZXJIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdID0genJVdGlsLmJpbmQoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgfSk7XG4gIHpyVXRpbC5lYWNoKG1vdXNlSGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IG1ha2VNb3VzZUhhbmRsZXIoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gbWFrZU1vdXNlSGFuZGxlcihmbiwgaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGluc3RhbmNlLl90b3VjaGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbi5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIEhhbmRsZXJEb21Qcm94eShkb20pIHtcbiAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcbiAgdGhpcy5kb20gPSBkb207XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG5cbiAgdGhpcy5fdG91Y2hpbmcgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMuX3RvdWNoVGltZXI7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9HZXN0dXJlTWdyfVxuICAgKi9cblxuICB0aGlzLl9nZXN0dXJlTWdyID0gbmV3IEdlc3R1cmVNZ3IoKTtcbiAgdGhpcy5faGFuZGxlcnMgPSB7fTtcbiAgaW5pdERvbUhhbmRsZXIodGhpcyk7XG5cbiAgaWYgKGVudi5wb2ludGVyRXZlbnRzU3VwcG9ydGVkKSB7XG4gICAgLy8gT25seSBJRTExKy9FZGdlXG4gICAgLy8gMS4gT24gZGV2aWNlcyB0aGF0IGJvdGggZW5hYmxlIHRvdWNoIGFuZCBtb3VzZSAoZS5nLiwgTVMgU3VyZmFjZSBhbmQgbGVub3ZvIFgyNDApLFxuICAgIC8vIElFMTErL0VkZ2UgZG8gbm90IHRyaWdnZXIgdG91Y2ggZXZlbnQsIGJ1dCB0cmlnZ2VyIHBvaW50ZXIgZXZlbnQgYW5kIG1vdXNlIGV2ZW50XG4gICAgLy8gYXQgdGhlIHNhbWUgdGltZS5cbiAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBpdCBwcm9iYWJsZWx5IG9ubHkgdHJpZ2dlciBtb3VzZWRvd24gYnV0IG5vIG1vdXNldXAgd2hlbiB0YXAgb25cbiAgICAvLyBzY3JlZW4sIHdoaWNoIGRvIG5vdCBvY2N1cnMgaW4gcG9pbnRlciBldmVudC5cbiAgICAvLyBTbyB3ZSB1c2UgcG9pbnRlciBldmVudCB0byBib3RoIGRldGVjdCB0b3VjaCBnZXN0dXJlIGFuZCBtb3VzZSBiZWhhdmlvci5cbiAgICBtb3VudEhhbmRsZXJzKHBvaW50ZXJIYW5kbGVyTmFtZXMsIHRoaXMpOyAvLyBGSVhNRVxuICAgIC8vIE5vdGU6IE1TIEdlc3R1cmUgcmVxdWlyZSBDU1MgdG91Y2gtYWN0aW9uIHNldC4gQnV0IHRvdWNoLWFjdGlvbiBpcyBub3QgcmVsaWFibGUsXG4gICAgLy8gd2hpY2ggZG9lcyBub3QgcHJldmVudCBkZWZ1YXVsdCBiZWhhdmlvciBvY2Nhc2lvbmFsbHkgKHdoaWNoIG1heSBjYXVzZSB2aWV3IHBvcnRcbiAgICAvLyB6b29tZWQgaW4gYnV0IHVzZSBjYW4gbm90IHpvb20gaXQgYmFjaykuIEFuZCBldmVudC5wcmV2ZW50RGVmYXVsdCgpIGRvZXMgbm90IHdvcmsuXG4gICAgLy8gU28gd2UgaGF2ZSB0byBub3QgdG8gdXNlIE1TR2VzdHVyZSBhbmQgbm90IHRvIHN1cHBvcnQgdG91Y2htb3ZlIGFuZCBwaW5jaCBvbiBNU1xuICAgIC8vIHRvdWNoIHNjcmVlbi4gQW5kIHdlIG9ubHkgc3VwcG9ydCBjbGljayBiZWhhdmlvciBvbiBNUyB0b3VjaCBzY3JlZW4gbm93LlxuICAgIC8vIE1TIEdlc3R1cmUgRXZlbnQgaXMgb25seSBzdXBwb3J0ZWQgb24gSUUxMSsvRWRnZSBhbmQgb24gV2luZG93cyA4Ky5cbiAgICAvLyBXZSBkb250IHN1cHBvcnQgdG91Y2ggb24gSUUgb24gd2luNy5cbiAgICAvLyBTZWUgPGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDModj12cy44NSkuYXNweD5cbiAgICAvLyBpZiAodHlwZW9mIE1TR2VzdHVyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICAgICAodGhpcy5fbXNHZXN0dXJlID0gbmV3IE1TR2VzdHVyZSgpKS50YXJnZXQgPSBkb207IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIC8vICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignTVNHZXN0dXJlQ2hhbmdlJywgb25NU0dlc3R1cmVDaGFuZ2UpO1xuICAgIC8vIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW52LnRvdWNoRXZlbnRzU3VwcG9ydGVkKSB7XG4gICAgICBtb3VudEhhbmRsZXJzKHRvdWNoSGFuZGxlck5hbWVzLCB0aGlzKTsgLy8gSGFuZGxlciBvZiAnbW91c2VvdXQnIGV2ZW50IGlzIG5lZWRlZCBpbiB0b3VjaCBtb2RlLCB3aGljaCB3aWxsIGJlIG1vdW50ZWQgYmVsb3cuXG4gICAgICAvLyBhZGRFdmVudExpc3RlbmVyKHJvb3QsICdtb3VzZW91dCcsIHRoaXMuX21vdXNlb3V0SGFuZGxlcik7XG4gICAgfSAvLyAxLiBDb25zaWRlcmluZyBzb21lIGRldmljZXMgdGhhdCBib3RoIGVuYWJsZSB0b3VjaCBhbmQgbW91c2UgZXZlbnQgKGxpa2Ugb24gTVMgU3VyZmFjZVxuICAgIC8vIGFuZCBsZW5vdm8gWDI0MCwgQHNlZSAjMjM1MCksIHdlIG1ha2UgbW91c2UgZXZlbnQgYmUgYWx3YXlzIGxpc3RlbmVkLCBvdGhlcndpc2VcbiAgICAvLyBtb3VzZSBldmVudCBjYW4gbm90IGJlIGhhbmRsZSBpbiB0aG9zZSBkZXZpY2VzLlxuICAgIC8vIDIuIE9uIE1TIFN1cmZhY2UsIENocm9tZSB3aWxsIHRyaWdnZXIgYm90aCB0b3VjaCBldmVudCBhbmQgbW91c2UgZXZlbnQuIEhvdyB0byBwcmV2ZW50XG4gICAgLy8gbW91c2VldmVudCBhZnRlciB0b3VjaCBldmVudCB0cmlnZ2VyZWQsIHNlZSBgc2V0VG91Y2hUaW1lcmAuXG5cblxuICAgIG1vdW50SGFuZGxlcnMobW91c2VIYW5kbGVyTmFtZXMsIHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRIYW5kbGVycyhoYW5kbGVyTmFtZXMsIGluc3RhbmNlKSB7XG4gICAgenJVdGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihkb20sIGV2ZW50TmFtZUZpeChuYW1lKSwgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdKTtcbiAgICB9LCBpbnN0YW5jZSk7XG4gIH1cbn1cblxudmFyIGhhbmRsZXJEb21Qcm94eVByb3RvID0gSGFuZGxlckRvbVByb3h5LnByb3RvdHlwZTtcblxuaGFuZGxlckRvbVByb3h5UHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhhbmRsZXJOYW1lcyA9IG1vdXNlSGFuZGxlck5hbWVzLmNvbmNhdCh0b3VjaEhhbmRsZXJOYW1lcyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IGhhbmRsZXJOYW1lc1tpXTtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuZG9tLCBldmVudE5hbWVGaXgobmFtZSksIHRoaXMuX2hhbmRsZXJzW25hbWVdKTtcbiAgfVxufTtcblxuaGFuZGxlckRvbVByb3h5UHJvdG8uc2V0Q3Vyc29yID0gZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gIHRoaXMuZG9tLnN0eWxlLmN1cnNvciA9IGN1cnNvclN0eWxlIHx8ICdkZWZhdWx0Jztcbn07XG5cbnpyVXRpbC5taXhpbihIYW5kbGVyRG9tUHJveHksIEV2ZW50ZnVsKTtcbnZhciBfZGVmYXVsdCA9IEhhbmRsZXJEb21Qcm94eTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBldmVudFV0aWwgPSByZXF1aXJlKFwiLi9ldmVudFwiKTtcblxuLyoqXG4gKiBPbmx5IGltcGxlbWVudHMgbmVlZGVkIGdlc3R1cmVzIGZvciBtb2JpbGUuXG4gKi9cbnZhciBHZXN0dXJlTWdyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgKi9cbiAgdGhpcy5fdHJhY2sgPSBbXTtcbn07XG5cbkdlc3R1cmVNZ3IucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogR2VzdHVyZU1ncixcbiAgcmVjb2duaXplOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCwgcm9vdCkge1xuICAgIHRoaXMuX2RvVHJhY2soZXZlbnQsIHRhcmdldCwgcm9vdCk7XG5cbiAgICByZXR1cm4gdGhpcy5fcmVjb2duaXplKGV2ZW50KTtcbiAgfSxcbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl90cmFjay5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfZG9UcmFjazogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XG5cbiAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2tJdGVtID0ge1xuICAgICAgcG9pbnRzOiBbXSxcbiAgICAgIHRvdWNoZXM6IFtdLFxuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBldmVudDogZXZlbnRcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRvdWNoZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG4gICAgICB2YXIgcG9zID0gZXZlbnRVdGlsLmNsaWVudFRvTG9jYWwocm9vdCwgdG91Y2gsIHt9KTtcbiAgICAgIHRyYWNrSXRlbS5wb2ludHMucHVzaChbcG9zLnpyWCwgcG9zLnpyWV0pO1xuICAgICAgdHJhY2tJdGVtLnRvdWNoZXMucHVzaCh0b3VjaCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdHJhY2sucHVzaCh0cmFja0l0ZW0pO1xuICB9LFxuICBfcmVjb2duaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcmVjb2duaXplcnMpIHtcbiAgICAgIGlmIChyZWNvZ25pemVycy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IHJlY29nbml6ZXJzW2V2ZW50TmFtZV0odGhpcy5fdHJhY2ssIGV2ZW50KTtcblxuICAgICAgICBpZiAoZ2VzdHVyZUluZm8pIHtcbiAgICAgICAgICByZXR1cm4gZ2VzdHVyZUluZm87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRpc3QocG9pbnRQYWlyKSB7XG4gIHZhciBkeCA9IHBvaW50UGFpclsxXVswXSAtIHBvaW50UGFpclswXVswXTtcbiAgdmFyIGR5ID0gcG9pbnRQYWlyWzFdWzFdIC0gcG9pbnRQYWlyWzBdWzFdO1xuICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbn1cblxuZnVuY3Rpb24gY2VudGVyKHBvaW50UGFpcikge1xuICByZXR1cm4gWyhwb2ludFBhaXJbMF1bMF0gKyBwb2ludFBhaXJbMV1bMF0pIC8gMiwgKHBvaW50UGFpclswXVsxXSArIHBvaW50UGFpclsxXVsxXSkgLyAyXTtcbn1cblxudmFyIHJlY29nbml6ZXJzID0ge1xuICBwaW5jaDogZnVuY3Rpb24gKHRyYWNrLCBldmVudCkge1xuICAgIHZhciB0cmFja0xlbiA9IHRyYWNrLmxlbmd0aDtcblxuICAgIGlmICghdHJhY2tMZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGluY2hFbmQgPSAodHJhY2tbdHJhY2tMZW4gLSAxXSB8fCB7fSkucG9pbnRzO1xuICAgIHZhciBwaW5jaFByZSA9ICh0cmFja1t0cmFja0xlbiAtIDJdIHx8IHt9KS5wb2ludHMgfHwgcGluY2hFbmQ7XG5cbiAgICBpZiAocGluY2hQcmUgJiYgcGluY2hQcmUubGVuZ3RoID4gMSAmJiBwaW5jaEVuZCAmJiBwaW5jaEVuZC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgcGluY2hTY2FsZSA9IGRpc3QocGluY2hFbmQpIC8gZGlzdChwaW5jaFByZSk7XG4gICAgICAhaXNGaW5pdGUocGluY2hTY2FsZSkgJiYgKHBpbmNoU2NhbGUgPSAxKTtcbiAgICAgIGV2ZW50LnBpbmNoU2NhbGUgPSBwaW5jaFNjYWxlO1xuICAgICAgdmFyIHBpbmNoQ2VudGVyID0gY2VudGVyKHBpbmNoRW5kKTtcbiAgICAgIGV2ZW50LnBpbmNoWCA9IHBpbmNoQ2VudGVyWzBdO1xuICAgICAgZXZlbnQucGluY2hZID0gcGluY2hDZW50ZXJbMV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAncGluY2gnLFxuICAgICAgICB0YXJnZXQ6IHRyYWNrWzBdLnRhcmdldCxcbiAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBPbmx5IHBpbmNoIGN1cnJlbnRseS5cblxufTtcbnZhciBfZGVmYXVsdCA9IEdlc3R1cmVNZ3I7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKi9cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1wiKTtcclxuICAgIHZhciBCUE1OTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvQlBNTk5vZGUuanNcIik7XHJcbiAgICB2YXIgQlBNTk1vZGVsID0gcmVxdWlyZShcIi4vbW9kZWwvQlBNTk1vZGVsLmpzXCIpO1xyXG4gICAgdmFyIFN0YXJ0RXZlbnROb2RlID0gcmVxdWlyZShcIi4vbm9kZS9ldmVudC9TdGFydEV2ZW50Tm9kZVwiKTtcclxuICAgIHZhciBFbmRFdmVudE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL2V2ZW50L0VuZEV2ZW50Tm9kZVwiKTtcclxuICAgIHZhciBVc2VyVGFza05vZGUgPSByZXF1aXJlKFwiLi9ub2RlL3Rhc2svVXNlclRhc2tOb2RlXCIpO1xyXG4gICAgdmFyIE1hbnVhbFRhc2tOb2RlID0gcmVxdWlyZShcIi4vbm9kZS90YXNrL01hbnVhbFRhc2tOb2RlXCIpO1xyXG4gICAgdmFyIFNjcmlwdFRhc2tOb2RlID0gcmVxdWlyZShcIi4vbm9kZS90YXNrL1NjcmlwdFRhc2tOb2RlXCIpO1xyXG4gICAgdmFyIE1haWxUYXNrTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvdGFzay9NYWlsVGFza05vZGVcIik7XHJcbiAgICB2YXIgU2VydmljZVRhc2tOb2RlID0gcmVxdWlyZShcIi4vbm9kZS90YXNrL1NlcnZpY2VUYXNrTm9kZVwiKTtcclxuICAgIHZhciBTbXNUYXNrTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvdGFzay9TbXNUYXNrTm9kZVwiKTtcclxuICAgIHZhciBDb21tZW50Tm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvQ29tbWVudE5vZGVcIik7XHJcbiAgICB2YXIgQ2F0Y2hUaW1lckV2ZW50Tm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvZXZlbnQvYm91bmRhcnlldmVudC9DYXRjaFRpbWVyRXZlbnROb2RlXCIpO1xyXG4gICAgdmFyIENhdGNoU2lnbmFsRXZlbnROb2RlID0gcmVxdWlyZShcIi4vbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L0NhdGNoU2lnbmFsRXZlbnROb2RlXCIpO1xyXG4gICAgdmFyIFRocm93U2lnbmFsRXZlbnROb2RlID0gcmVxdWlyZShcIi4vbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L1Rocm93U2lnbmFsRXZlbnROb2RlXCIpO1xyXG4gICAgdmFyIENhdGNoTWVzc2FnZUV2ZW50Tm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvZXZlbnQvQ2F0Y2hNZXNzYWdlRXZlbnROb2RlXCIpO1xyXG4gICAgdmFyIEluY2x1c2l2ZUdhdGV3YXlOb2RlID0gcmVxdWlyZShcIi4vbm9kZS9nYXRld2F5L0luY2x1c2l2ZUdhdGV3YXlOb2RlXCIpO1xyXG4gICAgdmFyIEV4Y2x1c2l2ZUdhdGV3YXlOb2RlID0gcmVxdWlyZShcIi4vbm9kZS9nYXRld2F5L0V4Y2x1c2l2ZUdhdGV3YXlOb2RlXCIpO1xyXG4gICAgdmFyIFBhcmFsbGVsR2F0ZXdheU5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL2dhdGV3YXkvUGFyYWxsZWxHYXRld2F5Tm9kZVwiKTtcclxuICAgIHZhciBTdWJQcmNlc3NOb2RlID0gcmVxdWlyZShcIi4vbm9kZS9TdWJQcm9jZXNzTm9kZVwiKTtcclxuICAgIHZhciBCcG1uID0gcmVxdWlyZShcIi4vQnBtbi5qc1wiKTtcclxuICAgIC8qKlxyXG4gICAgICog5qC55o2u57uT54K55pWw57uEIOWvvOWHukpTT07moLzlvI/nmoTmlbDmja5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBub2RlcyDnu5PngrnmlbDnu4RcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBicG1uTW9kZWwgYnBtbueahG1vZGVsXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25uZWN0b3JzIOaJgOaciei/nue6v1xyXG4gICAgICogQHJldHVybiB7SlNPTn0gSlNPTuagvOW8j+eahOaVsOaNrlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0pzb24oYnBtbk1vZGVsLCBub2RlcywgY29ubmVjdG9ycykge1xyXG4gICAgICAgIHZhciBqc29uQXJyID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAvL+WOu+aOieWtkOa1geeoi+mHjOmdoueahOiKgueCuVxyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3Mobm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggbm9kZSAmJiBub2RlLnRvSlNPTikge1xyXG4gICAgICAgICAgICAgICAganNvbkFyci5wdXNoKG5vZGUudG9KU09OKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5aKe5Yqg57q/XHJcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGNvbm5lY3RvcnMubGVuZ3RoO2orKyl7XHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3IgPSBjb25uZWN0b3JzW2pdO1xyXG4gICAgICAgICAgICAvL+WOu+aOieWtkOa1geeoi+mHjOmdoueahOe6v+autVxyXG4gICAgICAgICAgICBpZiAoY29ubmVjdG9yLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhjb25uZWN0b3IucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIGNvbm5lY3RvciAmJiBjb25uZWN0b3IudG9KU09OKSB7XHJcbiAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2goY29ubmVjdG9yLnRvSlNPTigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBicG1uTW9kZWwuc2V0KFwiY2hpbGRTaGFwZXNcIiwganNvbkFycik7XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gYnBtbk1vZGVsLm9wdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNriBKU09OIOeUn+aIkOiKgueCuVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBmaXNoVG9wb0JwbW4gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBqc29uICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tSnNvbihmaXNoVG9wb0JwbW4sIGpzb24pIHtcclxuICAgICAgICAvLyAxLua4heepuueUu+W4g1xyXG4gICAgICAgIGZpc2hUb3BvQnBtbi5jbGVhcih0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gMi7lhYjliJvlu7roioLngrkgIOmBjeWOhuW9oueKtiDojrflj5bmqKHlnotcclxuICAgICAgICB2YXIgYnBtbk1vZGVsID0gbmV3IEJQTU5Nb2RlbChqc29uKTtcclxuXHJcbiAgICAgICAgZmlzaFRvcG9CcG1uLm1vZGVsID0gYnBtbk1vZGVsO1xyXG5cclxuICAgICAgICB2YXIgYnBtbldpZHRoID0gYnBtbk1vZGVsLmdldChcInByb3BlcnRpZXMud2lkdGhcIik7XHJcbiAgICAgICAgdmFyIGJwbW5IZWlnaHQgPSBicG1uTW9kZWwuZ2V0KFwicHJvcGVydGllcy5oZWlnaHRcIik7XHJcbiAgICAgICAgaWYgKGJwbW5XaWR0aCA+IDAgJiYgYnBtbkhlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgZmlzaFRvcG9CcG1uLnJlc2l6ZShicG1uV2lkdGgsYnBtbkhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGxvb3BBZGRTdWJOb2RlKG5vZGUsIG1vZGVsKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBCcG1uLlNVQl9QUk9DRVNTKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ViU2hhcGVzID0gbW9kZWwuZ2V0KFwiY2hpbGRTaGFwZXNcIik7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1YlNoYXBlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJNb2RlbCA9IG5ldyBCUE1OTW9kZWwoc3ViU2hhcGVzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihCcG1uLmlzRmxvd01vZGVsKHN1Yk1vZGVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXNoVG9wb0JwbW4uYWRkQ29ubmVjdG9yQnlNb2RlbChzdWJNb2RlbCwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1cGVyVXBwZXJMZWZ0ID0gbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YlVwcGVyTGVmdCA9IHN1Yk1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJMb3dlclJpZ2h0ID0gc3ViTW9kZWwuZ2V0KFwiYm91bmRzLmxvd2VyUmlnaHRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGVsLnNldChcImJvdW5kcy51cHBlckxlZnRcIiwgeyB4OiBzdWJVcHBlckxlZnQueCArIHN1cGVyVXBwZXJMZWZ0LngsIHk6IHN1YlVwcGVyTGVmdC55ICsgc3VwZXJVcHBlckxlZnQueSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZWwuc2V0KFwiYm91bmRzLmxvd2VyUmlnaHRcIiwgeyB4OiBzdWJMb3dlclJpZ2h0LnggKyBzdXBlclVwcGVyTGVmdC54LCB5OiBzdWJMb3dlclJpZ2h0LnkgKyBzdXBlclVwcGVyTGVmdC55IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ViTm9kZSA9IGZpc2hUb3BvQnBtbi5hZGROb2RlQnlNb2RlbChzdWJNb2RlbCx0cnVlLHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb29wQWRkU3ViTm9kZShzdWJOb2RlLCBzdWJNb2RlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjaGlsZFNoYXBlcyA9IGJwbW5Nb2RlbC5nZXQoXCJjaGlsZFNoYXBlc1wiKTtcclxuICAgICAgICB2YXIgY29ubmVjdG9ycyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRTaGFwZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gY2hpbGRTaGFwZXNbaV07XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gc2hhcGUuc3RlbmNpbC50eXBlO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gQnBtbi5TRVFVRU5DRV9GTE9XKSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3JzLnB1c2goc2hhcGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGVsID0gbmV3IEJQTU5Nb2RlbChzaGFwZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3JlYXRlZE5vZGUgPSBmaXNoVG9wb0JwbW4uYWRkTm9kZUJ5TW9kZWwobW9kZWwsZmFsc2UsdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBsb29wQWRkU3ViTm9kZShjcmVhdGVkTm9kZSwgbW9kZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuIOWGjeWIm+W7uue6v1xyXG4gICAgICAgIGZvcih2YXIgayA9IDAsIGxlbiA9IGNvbm5lY3RvcnMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcclxuICAgICAgICAgICAgdmFyIG1vZGVsTGluZSA9IG5ldyBCUE1OTW9kZWwoY29ubmVjdG9yc1trXSk7IC8vIHNoYXBlXHJcbiAgICAgICAgICAgIGZpc2hUb3BvQnBtbi5hZGRDb25uZWN0b3JCeU1vZGVsKG1vZGVsTGluZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyA0LuWIm+W7uuS6i+S7tuaPkuanvVxyXG4gICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgY2hpbGRTaGFwZXMubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkU2hhcGVzW21dLnByb3BlcnRpZXMuc2xvdEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIG4gPSAwO24gPCBjaGlsZFNoYXBlc1ttXS5wcm9wZXJ0aWVzLnNsb3RFdmVudC5sZW5ndGg7IG4rKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluZE5vZGVCeUlkKGZpc2hUb3BvQnBtbixjaGlsZFNoYXBlc1ttXS5yZXNvdXJjZUlkKS5zbG90RXZlbnQucHVzaChmaW5kTm9kZUJ5SWQoZmlzaFRvcG9CcG1uLGNoaWxkU2hhcGVzW21dLnByb3BlcnRpZXMuc2xvdEV2ZW50W25dKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2uaWTlnKhmaXNoVG9wb0JwbW7kuK3mn6Xmib5cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZmlzaFRvcG9CcG1uICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGVJZCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZpbmROb2RlQnlJZChmaXNoVG9wb0JwbW4sIG5vZGVJZCkge1xyXG4gICAgICAgIHZhciBub2RlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBmaXNoVG9wb0JwbW4uYWxsTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYgKGZpc2hUb3BvQnBtbi5hbGxOb2Rlc1tpXS5tb2RlbC5nZXQoXCJyZXNvdXJjZUlkXCIpID09IG5vZGVJZCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IGZpc2hUb3BvQnBtbi5hbGxOb2Rlc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyQlBNTk5vZGUgKCkge1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoU3RhcnRFdmVudE5vZGUsIFwiU3RhcnROb25lRXZlbnRcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhFbmRFdmVudE5vZGUsIFwiRW5kTm9uZUV2ZW50XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoVXNlclRhc2tOb2RlLCBcIlVzZXJUYXNrXCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoTWFudWFsVGFza05vZGUsIFwiTWFudWFsVGFza1wiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKFNjcmlwdFRhc2tOb2RlLCBcIlNjcmlwdFRhc2tcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhNYWlsVGFza05vZGUsIFwiTWFpbFRhc2tcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhTZXJ2aWNlVGFza05vZGUsIFwiU2VydmljZVRhc2tcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhTbXNUYXNrTm9kZSwgXCJTbXNUYXNrXCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoQ29tbWVudE5vZGUsIFwiQ29tbWVudFwiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKENhdGNoVGltZXJFdmVudE5vZGUsIFwiQ2F0Y2hUaW1lckV2ZW50XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoQ2F0Y2hNZXNzYWdlRXZlbnROb2RlLCBcIkNhdGNoTWVzc2FnZUV2ZW50XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoQ2F0Y2hTaWduYWxFdmVudE5vZGUsIFwiQ2F0Y2hTaWduYWxFdmVudFwiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKFRocm93U2lnbmFsRXZlbnROb2RlLCBcIlRocm93U2lnbmFsRXZlbnRcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhJbmNsdXNpdmVHYXRld2F5Tm9kZSwgXCJJbmNsdXNpdmVHYXRld2F5XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoRXhjbHVzaXZlR2F0ZXdheU5vZGUsIFwiRXhjbHVzaXZlR2F0ZXdheVwiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKFBhcmFsbGVsR2F0ZXdheU5vZGUsIFwiUGFyYWxsZWxHYXRld2F5XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoU3ViUHJjZXNzTm9kZSwgXCJTdWJQcm9jZXNzXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcmVudFgobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zaXRpb25bMF0gKyBwYXJlbnRYKG5vZGUucGFyZW50KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzBdXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcmVudFkobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zaXRpb25bMV0gKyBwYXJlbnRZKG5vZGUucGFyZW50KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzFdXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldFBhcmVudE5vZGUobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0hvdmVyKG5vZGUsIHgsIHkpIHtcclxuICAgICAgICB2YXIgY3ggLCBjeTtcclxuICAgICAgICBpZihub2RlLnBhcmVudCl7XHJcbiAgICAgICAgICAgIGlmKEJwbW4uaXNTdWJQcm9jZXNzKG5vZGUucGFyZW50KSl7XHJcbiAgICAgICAgICAgICAgICBjeCA9IHggLSBwYXJlbnRYKG5vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgICAgIGN5ID0geSAtIHBhcmVudFkobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucmVjdENvbnRhaW4oY3gsIGN5KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnJlY3RDb250YWluKHgsIHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZpbmRIb3ZlcihsaXN0LCB4LCB5LCBleGNsdWRlcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMCA7IGktLSkge1xyXG4gICAgICAgICAgICBpZiAoaXNFeGNsdWRlKGV4Y2x1ZGVzLGxpc3RbaV0pIC8vbGlzdFtpXSAhPT0gZXhjbHVkZVxyXG4gICAgICAgICAgICAgLy8gZ2V0RGlzcGxheUxpc3QgbWF5IGluY2x1ZGUgaWdub3JlZCBpdGVtIGluIFZNTCBtb2RlXHJcbiAgICAgICAgICAgICAmJiAhbGlzdFtpXS5pZ25vcmVcclxuICAgICAgICAgICAgICYmIGlzSG92ZXIobGlzdFtpXSwgeCwgeSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0W2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBpc0V4Y2x1ZGUoZXhjbHVkZXMsIG5vZGUpIHtcclxuICAgICAgICByZXR1cm4genJVdGlsLmluZGV4T2YoZXhjbHVkZXMsbm9kZSkgPT0gLTE7XHJcbiAgICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIHZhciBCcG1uVXRpbCA9IHtcclxuICAgICAgICB0b0pzb246IHRvSnNvbixcclxuICAgICAgICBmcm9tSnNvbjogZnJvbUpzb24sXHJcbiAgICAgICAgcmVnaXN0ZXJCUE1OTm9kZTogcmVnaXN0ZXJCUE1OTm9kZSxcclxuICAgICAgICBmaW5kSG92ZXI6IGZpbmRIb3ZlcixcclxuICAgICAgICBwYXJlbnRYOiBwYXJlbnRYLFxyXG4gICAgICAgIHBhcmVudFk6IHBhcmVudFksXHJcbiAgICAgICAgZ2V0UGFyZW50Tm9kZTogZ2V0UGFyZW50Tm9kZSxcclxuICAgICAgICBnZXRVVUlEOiB1dGlsLmdldFVVSURcclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJwbW5VdGlsO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL0JwbW5VdGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5bel5YW35pa55rOV57G7XHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4vUG9pbnQuanNcIik7XHJcbiAgICB2YXIgTGluZSA9IHJlcXVpcmUoXCIuL0xpbmVTdHJ1Y3QuanNcIik7XHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIC8qKlxyXG4gICAgICog5p6E6YCg57G757un5om/5YWz57O7XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xhenog5rqQ57G7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlQ2xhenog5Z+657G7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcclxuICAgICAgICB2YXIgY2xhenpQcm90b3R5cGUgPSBjbGF6ei5wcm90b3R5cGU7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxyXG4gICAgICAgIEYucHJvdG90eXBlID0gYmFzZUNsYXp6LnByb3RvdHlwZTtcclxuICAgICAgICBjbGF6ei5wcm90b3R5cGUgPSBuZXcgRigpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGNsYXp6UHJvdG90eXBlKSB7XHJcbiAgICAgICAgICAgIGNsYXp6LnByb3RvdHlwZVtwcm9wXSA9IGNsYXp6UHJvdG90eXBlW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGF6ei5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjbGF6ejtcclxuICAgICAgICBjbGF6ei5zdXBlckNsYXNzID0gYmFzZUNsYXp6O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFVVSUQoKSB7XHJcbiAgICAgICAgdmFyIGNoYXJzID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Jy5zcGxpdCgnJyksXHJcbiAgICAgICAgICAgIHV1aWQgPSBuZXcgQXJyYXkoMzYpLFxyXG4gICAgICAgICAgICBybmQgPSAwLFxyXG4gICAgICAgICAgICByO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzY7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA9PSA4IHx8IGkgPT0gMTMgfHwgaSA9PSAxOCB8fCBpID09IDIzKSB7XHJcbiAgICAgICAgICAgICAgICB1dWlkW2ldID0gJy0nO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT0gMTQpIHtcclxuICAgICAgICAgICAgICAgIHV1aWRbaV0gPSAnNCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocm5kIDw9IDB4MDIpIHJuZCA9IDB4MjAwMDAwMCArIChNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwKSB8IDA7XHJcbiAgICAgICAgICAgICAgICByID0gcm5kICYgMHhmO1xyXG4gICAgICAgICAgICAgICAgcm5kID0gcm5kID4+IDQ7XHJcbiAgICAgICAgICAgICAgICB1dWlkW2ldID0gY2hhcnNbKGkgPT0gMTkpID8gKHIgJiAweDMpIHwgMHg4IDogcl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwic2lkLVwiICsgdXVpZC5qb2luKCcnKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorqHnrpfkuKTngrnkuYvpl7TnmoTot53nprtcclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDEgLSBmaXJzdCB7UG9pbnR9XHJcbiAgICAgKkBwYXJhbSB7UG9pbnR9IHAyIC0gc2Vjb25kIHtQb2ludH1cclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRob3NlIDIgcG9pbnRzLiBJdCBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBkaXN0YW5jZShwMSwgcDIpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHAxLnggLSBwMi54LCAyKSArIE1hdGgucG93KHAxLnkgLSBwMi55LCAyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDov5Tlm57kuIDmnaHmipjnur8g5pyA6ZW/55qE5Lik5Liq54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHBvaW50cyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldE1heExpbmVMZW5ndGgocG9pbnRzKSB7XHJcbiAgICAgICAgdmFyIG0gPSBkaXN0YW5jZShwb2ludHNbMF0sIHBvaW50c1sxXSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtwb2ludHNbMF0sIHBvaW50c1sxXV07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAobSA8IGRpc3RhbmNlKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSkpIHtcclxuICAgICAgICAgICAgICAgIG0gPSBkaXN0YW5jZShwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbcG9pbnRzW2ldLCBwb2ludHNbaSArIDFdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipSZXR1cm5zIHRoZSBsZW5ndGggb2YgYSBQb2x5bGluZSB0aGF0IHdvdWxkIGJlIGNyZWF0ZWQgd2l0aCBhIHNldCBvZiBwb2ludHNcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIGFuIHtBcnJheX0gb2Yge1BvaW50c31cclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIGEgcG9zaXRpdmUgbnVtYmVyIGVxdWFsIHdpdGggdG90YWwgbGVuZ3RoKi9cclxuICAgIGZ1bmN0aW9uIGdldFBvbHlsaW5lTGVuZ3RoKHYpIHtcclxuICAgICAgICB2YXIgbCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBsICs9IGRpc3RhbmNlKHZbaV0sIHZbaSArIDFdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBsO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipSZXR1cm5zIHRoZSBtYXggb2YgYSB2ZWN0b3JcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIHZlY3RvciBvZiB7TnVtYmVyfXNcclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIHRoZSBtYXhpbXVtIG51bWJlciBmcm9tIHRoZSB2ZWN0b3Igb3IgTmFOIGlmIHZlY3RvciBpcyBlbXB0eVxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gbWF4KHYpIHtcclxuICAgICAgICBpZiAodi5sZW5naHQgPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBtID0gdlswXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobSA8IHZbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gdltpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipSZXR1cm5zIHRoZSBtaW4gb2YgYSB2ZWN0b3JcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIHZlY3RvciBvZiB7TnVtYmVyfXNcclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIHRoZSBtaW5pbXVtIG51bWJlciBmcm9tIHRoZSB2ZWN0b3Igb3IgTmFOIGlmIHZlY3RvciBpcyBlbXB0eVxyXG4gICAgICpAYXV0aG9yIGFsZXhAc2NyaXB0b2lkLmNvbVxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gbWluKHYpIHtcclxuICAgICAgICBpZiAodi5sZW5naHQgPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBtID0gdlswXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobSA+IHZbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gdltpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yik5patIOeCueaVsOe7hCDmmK/lkKbmraPkuqTnm7Tnur/ot6/lvoRcclxuICAgICAqVGVzdHMgaWYgYSB2ZWN0b3Igb2YgcG9pbnRzIGlzIGFuIG9ydGhvZ29uYWwgcGF0aCAobW92aW5nIGluIG11bHRpcGxlcyBvZiA5MCBkZWdyZWVzKVxyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gYW4ge0FycmF5fSBvZiB7UG9pbnR9c1xyXG4gICAgICpAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgcGF0aCBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBvcnRob2dvbmFsUGF0aCh2KSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh2W2ldLnggIT0gdltpICsgMV0ueCAmJiB2W2ldLnkgIT0gdltpICsgMV0ueSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlRlc3QgdG8gc2VlIGlmIDIge0xpbmV9cyBpbnRlcnNlY3RzLiBUaGV5IGFyZSBjb25zaWRlcmVkIGZpbml0ZSBzZWdtZW50c1xyXG4gICAgICphbmQgbm90IHRoZSBpbmZpbml0ZSBsaW5lcyBmcm9tIGdlb21ldHJ5XHJcbiAgICAgKkBwYXJhbSB7TGluZX0gbDEgLSBmaXN0IGxpbmUvc2VnbWVudFxyXG4gICAgICpAcGFyYW0ge0xpbmV9IGwyIC0gbGFzdCBsaW5lL3NlZ21lbnRcclxuICAgICAqQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSAtIGlmIHRoZSBsaW5lcyBpbnRlcnNlY3Qgb3IgZmFsc2UgaWYgbm90XHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBsaW5lSW50ZXJzZWN0c0xpbmUobDEsIGwyKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIHR3byB2ZXJ0aWNhbCBsaW5lc1xyXG4gICAgICAgIGlmIChsMS5zdGFydFBvaW50LnggPT0gbDEuZW5kUG9pbnQueCAmJiBsMi5zdGFydFBvaW50LnggPT0gbDIuZW5kUG9pbnQueCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbDEuc3RhcnRQb2ludC54ID09IGwyLnN0YXJ0UG9pbnQueCA/IC8vIGlmICdpbmZpbml0ZSAnbGluZXMgZG8gY29pbmNpZGUsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGNoZWNrIHNlZ21lbnQgYm91bmRzIGZvciBvdmVybGFwcGluZ1xyXG4gICAgICAgICAgICAgICAgbDEuY29udGFpbnMobDIuc3RhcnRQb2ludC54LCBsMi5zdGFydFBvaW50LnkpIHx8XHJcbiAgICAgICAgICAgICAgICBsMS5jb250YWlucyhsMi5lbmRQb2ludC54LCBsMi5lbmRQb2ludC55KSA6XHJcbiAgICAgICAgICAgICAgICAvLyBsaW5lcyBhcmUgcGFyYWxlbFxyXG4gICAgICAgICAgICAgICAgZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIG9uZSBsaW5lIGlzIHZlcnRpY2FsLCBhbmQgYW5vdGhlciBsaW5lIGlzIG5vdCB2ZXJ0aWNhbFxyXG4gICAgICAgIGVsc2UgaWYgKGwxLnN0YXJ0UG9pbnQueCA9PSBsMS5lbmRQb2ludC54IHx8IGwyLnN0YXJ0UG9pbnQueCA9PSBsMi5lbmRQb2ludC54KSB7XHJcbiAgICAgICAgICAgIC8vIGxldCBhc3N1bWUgbDIgaXMgdmVydGljYWwsIG90aGVyd2lzZSBleGNoYW5nZSB0aGVtXHJcbiAgICAgICAgICAgIGlmIChsMS5zdGFydFBvaW50LnggPT0gbDEuZW5kUG9pbnQueCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGwgPSBsMTtcclxuICAgICAgICAgICAgICAgIGwxID0gbDI7XHJcbiAgICAgICAgICAgICAgICBsMiA9IGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZmluZGluZyBpbnRlcnNlY3Rpb24gb2YgJ2luZmluaXRlJyBsaW5lc1xyXG4gICAgICAgICAgICAvLyBlcXVhdGlvbiBvZiB0aGUgZmlyc3QgbGluZSBpcyB5ID0gYXggKyBiLCBzZWNvbmQ6IHggPSBjXHJcbiAgICAgICAgICAgIHZhciBhID0gKGwxLmVuZFBvaW50LnkgLSBsMS5zdGFydFBvaW50LnkpIC8gKGwxLmVuZFBvaW50LnggLSBsMS5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgYiA9IGwxLnN0YXJ0UG9pbnQueSAtIGEgKiBsMS5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgIHZhciB4MCA9IGwyLnN0YXJ0UG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIHkwID0gYSAqIHgwICsgYjtcclxuICAgICAgICAgICAgcmV0dXJuIGwxLmNvbnRhaW5zKHgwLCB5MCkgJiYgbDIuY29udGFpbnMoeDAsIHkwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIG5vcm1hbCBjYXNlIC0gYm90aCBsaW5lcyBhcmUgbm90IHZlcnRpY2FsXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vbGluZSBlcXVhdGlvbiBpcyA6IHkgPSBhKnggKyBiLCBiID0geSAtIGEgKiB4XHJcbiAgICAgICAgICAgIHZhciBhMSA9IChsMS5lbmRQb2ludC55IC0gbDEuc3RhcnRQb2ludC55KSAvIChsMS5lbmRQb2ludC54IC0gbDEuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgdmFyIGIxID0gbDEuc3RhcnRQb2ludC55IC0gYTEgKiBsMS5zdGFydFBvaW50Lng7XHJcblxyXG4gICAgICAgICAgICB2YXIgYTIgPSAobDIuZW5kUG9pbnQueSAtIGwyLnN0YXJ0UG9pbnQueSkgLyAobDIuZW5kUG9pbnQueCAtIGwyLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciBiMiA9IGwyLnN0YXJ0UG9pbnQueSAtIGEyICogbDIuc3RhcnRQb2ludC54O1xyXG5cclxuICAgICAgICAgICAgaWYgKGExID09IGEyKSB7IC8vcGFyYWxlbCBsaW5lc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIxID09IGIyID9cclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgY29pbmNpZGUgbGluZXMsIGNoZWNrIGZvciBzZWdtZW50IGJvdW5kcyBvdmVybGFwcGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGwxLmNvbnRhaW5zKGwyLnN0YXJ0UG9pbnQueCwgbDIuc3RhcnRQb2ludC55KSB8fCBsMS5jb250YWlucyhsMi5lbmRQb2ludC54LCBsMi5lbmRQb2ludC55KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGNvaW5jaWRlIHBhcmFsZWwgbGluZXMgaGF2ZSBubyBjaGFuY2UgdG8gaW50ZXJzZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vdXN1YWwgY2FzZSAtIG5vbiBwYXJhbGVsLCB0aGUgJ2luZmluaXRlJyBsaW5lcyBpbnRlcnNlY3RzLi4ud2Ugb25seSBuZWVkIHRvIGtub3cgaWYgaW5zaWRlIHRoZSBzZWdtZW50XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIGlmIG9uZSBvZiB0aGUgbGluZXMgYXJlIHZlcnRpY2FsLCB0aGVuIHgwIGlzIGVxdWFsIHRvIHRoZWlyIHgsXHJcbiAgICAgICAgICAgICAgICAgKiBvdGhlcndpc2U6XHJcbiAgICAgICAgICAgICAgICAgKiB5MSA9IGExICogeCArIGIxXHJcbiAgICAgICAgICAgICAgICAgKiB5MiA9IGEyICogeCArIGIyXHJcbiAgICAgICAgICAgICAgICAgKiA9PiB4MCA9IChiMiAtIGIxKSAvIChhMSAtIGEyKVxyXG4gICAgICAgICAgICAgICAgICogPT4geTAgPSBhMSAqIHgwICsgYjFcclxuICAgICAgICAgICAgICAgICAqKi9cclxuICAgICAgICAgICAgICAgIHgwID0gKGIyIC0gYjEpIC8gKGExIC0gYTIpO1xyXG4gICAgICAgICAgICAgICAgeTAgPSBhMSAqIHgwICsgYjE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbDEuY29udGFpbnMoeDAsIHkwKSAmJiBsMi5jb250YWlucyh4MCwgeTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqVGVzdHMgaWYgYSBhIHBvbHlsaW5lIGRlZmluZWQgYnkgYSBzZXQgb2YgcG9pbnRzIGludGVyc2VjdHMgYSByZWN0YW5nbGVcclxuICAgICAqQHBhcmFtIHtBcnJheX0gcG9pbnRzIC0gYW5kIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqQHBhcmFtIHtBcnJheX0gYm91bmRzIC0gdGhlIGJvdW5kcyBvZiB0aGUgcmVjdGFuZ2xlIGRlZmluZWQgYnkgKHgxLCB5MSwgeDIsIHkyKVxyXG4gICAgICpAcGFyYW0ge0Jvb2xlYW59IGNsb3NlZFBvbHlsaW5lIC0gaW5jYXNlIHBvbHlsaW5lIGlzIGNsb3NlZCBmaWd1cmUgdGhlbiB0cnVlLCBlbHNlIGZhbHNlXHJcbiAgICAgKlxyXG4gICAgICpAcmV0dXJuIHRydWUgLSBpZiBsaW5lIGludGVyc2VjdHMgdGhlIHJlY3RhbmdsZSwgZmFsc2UgLSBpZiBub3RcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIHBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZShwb2ludHMsIGJvdW5kcywgY2xvc2VkUG9seWxpbmUpIHtcclxuXHJcblxyXG4gICAgICAgIC8vZ2V0IHRoZSA0IGxpbmVzL3NlZ21lbnRzIHJlcHJlc2VudGVkIGJ5IHRoZSBib3VuZHNcclxuICAgICAgICB2YXIgbGluZXMgPSBbXTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1sxXSksIG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1sxXSkpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1sxXSksIG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1szXSkpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1szXSksIG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1szXSkpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1szXSksIG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1sxXSkpKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBwb2ludHMubGVuZ3RoIC0gMTsgaysrKSB7XHJcbiAgICAgICAgICAgIC8vY3JlYXRlIGEgbGluZSBvdXQgb2YgZWFjaCAyIGNvbnNlY3V0aXZlIHBvaW50c1xyXG4gICAgICAgICAgICB2YXIgdGVtcExpbmUgPSBuZXcgTGluZShwb2ludHNba10sIHBvaW50c1trICsgMV0pO1xyXG5cclxuICAgICAgICAgICAgLy9zZWUgaWYgdGhhdCBsaW5lIGludGVyc2VjdCBhbnkgb2YgdGhlIGxpbmUgb24gYm91bmRzIGJvcmRlclxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZUludGVyc2VjdHNMaW5lKHRlbXBMaW5lLCBsaW5lc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jaGVjayB0aGUgY2xvc2VkIGZpZ3VyZSAtIHRoYXQgaXMgbGFzdCBwb2ludCBjb25uZWN0ZWQgdG8gdGhlIGZpcnN0XHJcbiAgICAgICAgaWYgKGNsb3NlZFBvbHlsaW5lKSB7XHJcbiAgICAgICAgICAgIC8vY3JlYXRlIGEgbGluZSBvdXQgb2YgZWFjaCAyIGNvbnNlY3V0aXZlIHBvaW50c1xyXG4gICAgICAgICAgICB2YXIgdGVtcExpbmUxID0gbmV3IExpbmUocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSwgcG9pbnRzWzBdKTtcclxuXHJcbiAgICAgICAgICAgIC8vc2VlIGlmIHRoYXQgbGluZSBpbnRlcnNlY3QgYW55IG9mIHRoZSBsaW5lIG9uIGJvdW5kcyBib3JkZXJcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVJbnRlcnNlY3RzTGluZSh0ZW1wTGluZTEsIGxpbmVzW2pdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorqHnrpfot6/lvoTnmoTliIbmlbBcclxuICAgICAqIFNjb3JlIGEgb3J0b2dvbmFsIHBhdGggbWFkZSBvdXQgb2YgUG9pbnRzXHJcbiAgICAgKkl0ZXJhdGVzIG92ZXIgYSBzZXQgb2YgcG9pbnRzIChtaW5pbXVtIDMpXHJcbiAgICAgKkZvciBlYWNoIDMgcG9pbnRzIChpLCBpKzEsIGkrMikgOlxyXG4gICAgICogIC0gaWYgdGhlIDNyZCBvbmUgaXMgYWZ0ZXIgdGhlIDJuZCBvbiB0aGUgc2FtZSBsaW5lIHdlIGFkZCArMVxyXG4gICAgICogIC0gaWYgdGhlIDNyZCBpcyB1cCBvciBkb3duIHJlbGF0ZWQgdG8gdGhlIDJuZCB3ZSBkbyBub3QgZG8gYW55dGhpbmcgKzBcclxuICAgICAqICAtIGlmIHRoZSAzcmQgZ29lcyBiYWNrIHdlIGltZWRpYXRlbGx5IHJldHVybiAtMVxyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gYW4gYXJyYXkgb2Yge1BvaW50fXNcclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIC0xIGlmIHRoZSBwYXRoIGlzIHdyb25nIChnb2VzIGJhY2spIG9yIHNvbWV0aGluZyA+PSAwIGlmIGlzIGZpbmVcclxuICAgICAqICBUaGUgYmlnZ2VyIHRoZSBudW1iZXIgdGhlIHNtb290aCB0aGUgcGF0aCBpc1xyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gc2NvcmVQYXRoKHYpIHtcclxuICAgICAgICBpZiAodi5sZW5ndGggPD0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2NvcmUgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdi5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHZbaSAtIDFdLnggPT0gdltpXS54ICYmIHZbaV0ueCA9PSB2W2kgKyAxXS54KSB7IC8vb24gdGhlIHNhbWUgdmVydGljYWxcclxuICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueSAtIHZbaV0ueSkgPT0gc2lnbnVtKHZbaV0ueSAtIHZbaSAtIDFdLnkpKSB7IC8vc2FtZSBkaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBzY29yZSsrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9nb2luZyBiYWNrIC0gbm8gZ29vZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2W2kgLSAxXS55ID09IHZbaV0ueSAmJiB2W2ldLnkgPT0gdltpICsgMV0ueSkgeyAvL29uIHRoZSBzYW1lIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueCAtIHZbaV0ueCkgPT0gc2lnbnVtKHZbaV0ueCAtIHZbaSAtIDFdLngpKSB7IC8vc2FtZSBkaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBzY29yZSsrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9nb2luZyBiYWNrIC0gbm8gZ29vZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHsgLy9ub3Qgb24gc2FtZSB2ZXJ0aWNhbCBub3IgaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgc2NvcmUtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNjb3JlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6L+U5Zue5pWw5a2X56ym5Y+377yIKyAtKVxyXG4gICAgICogUmV0dXJucyB0aGUgc2lnbiBvZiBhIG51bWJlclxyXG4gICAgICpAcGFyYW0ge051bWJlcn0geCAtIHRoZSBudW1iZXJcclxuICAgICAqQHJldHVybnMge051bWJlcn1cclxuICAgICAqQHNlZSA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaWduX2Z1bmN0aW9uXCI+aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaWduX2Z1bmN0aW9uPC9hPlxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gc2lnbnVtKHgpIHtcclxuICAgICAgICBpZiAoeCA+IDApXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIGVsc2UgaWYgKHggPCAwKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIpOaWrSDngrnmlbDnu4Qg5piv5LiN5piv5pyJ5pWI6Lev5b6E77yI5rKh5pyJ5Zue6Lev77yJXHJcbiAgICAgKlRlc3RzIGlmIGEgdmVjdG9yIG9mIHBvaW50cyBpcyBhIHZhbGlkIHBhdGggKG5vdCBnb2luZyBiYWNrKVxyXG4gICAgICpUaGVyZSBhcmUgYSBmZXcgcHJvYmxlbXMgaGVyZS4gSWYgeW91IGhhdmUgcDEsIHAyLCBwMyBhbmQgcDQgYW5kIHAyID0gcDMgeW91IG5lZWQgdG8gaWdub3JlIHRoYXRcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIGFuIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIHBhdGggaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gZm9yd2FyZFBhdGgodikge1xyXG4gICAgICAgIGlmICh2Lmxlbmd0aCA8PSAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aCAtIDI7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodltpXS54ID09IHZbaSArIDFdLnggJiYgdltpICsgMV0ueCA9PSB2W2kgKyAyXS54KSB7IC8vb24gdGhlIHNhbWUgdmVydGljYWxcclxuICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueSAtIHZbaV0ueSkgIT0gMCkgeyAvL3Rlc3Qgb25seSB3ZSBoYXZlIGEgcHJvZ3Jlc3NpbmcgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueSAtIHZbaV0ueSkgPT0gLTEgKiBzaWdudW0odltpICsgMl0ueSAtIHZbaSArIDFdLnkpKSB7IC8vZ29pbmcgYmFjayAoaWdub3JlIHplcm8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodltpXS55ID09IHZbaSArIDFdLnkgJiYgdltpICsgMV0ueSA9PSB2W2kgKyAyXS55KSB7IC8vb24gdGhlIHNhbWUgaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS54IC0gdltpXS54KSAhPSAwKSB7IC8vdGVzdCBvbmx5IHdlIGhhdmUgYSBwcm9ncmVzc2luZyBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS54IC0gdltpXS54KSA9PSAtMSAqIHNpZ251bSh2W2kgKyAyXS54IC0gdltpICsgMV0ueCkpIHsgLy9nb2luZyBiYWNrIChpZ25vcmUgemVybylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlsIZbeDowLHk6MF3ovazljJbkuLpbMCwgMF0gIOe7mXpyZW5kZXLkvb/nlKhcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcG9pbnRzIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gaXNSZXZlcnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0cmFzbGF0ZVBvaW50cyhwb2ludHMsIGlzUmV2ZXJ0KSB7XHJcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IFtdO1xyXG4gICAgICAgIGlmIChpc1JldmVydCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2gobmV3IFBvaW50KHBvaW50WzBdLCBwb2ludFsxXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdQb2ludHM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2ludDEgPSBwb2ludHNbal07XHJcbiAgICAgICAgICAgICAgICBuZXdQb2ludHMucHVzaChbcG9pbnQxLngsIHBvaW50MS55XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ld1BvaW50cztcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByb3RhdGlvbk1hdHJpeChhbmdsZSkge1xyXG4gICAgICAgIHZhciBtUmV0dXJuID0gW1xyXG4gICAgICAgICAgICBbTWF0aC5jb3MoYW5nbGUpLCAtTWF0aC5zaW4oYW5nbGUpLCAwXSxcclxuICAgICAgICAgICAgW01hdGguc2luKGFuZ2xlKSwgTWF0aC5jb3MoYW5nbGUpLCAwXSxcclxuICAgICAgICAgICAgWzAsIDAsIDFdXHJcbiAgICAgICAgXTtcclxuICAgICAgICByZXR1cm4gbVJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0cmFuc2xhdGlvbk1hdHJpeChkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbMSwgMCwgZHhdLFxyXG4gICAgICAgICAgICBbMCwgMSwgZHldLFxyXG4gICAgICAgICAgICBbMCwgMCwgMV1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNjYWxlTWF0cml4KHN4LCBzeSkge1xyXG4gICAgICAgIGlmIChzeSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN5ID0gc3g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFtzeCwgMCwgMF0sXHJcbiAgICAgICAgICAgIFswLCBzeSwgMF0sXHJcbiAgICAgICAgICAgIFswLCAwLCAxXVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEl0IHdpbGwgcmV0dXJuIHRoZSBlbmQgcG9pbnQgb2YgYSBsaW5lIG9uIGEgZ2l2ZW4gYW5nbGUgKGNsb2Nrd2lzZSkuXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBzdGFydFBvaW50IC0gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gdGhlIGxlbmd0aCBvZiB0aGUgbGluZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIC0gdGhlIGFuZ2xlIG9mIHRoZSBsaW5lIGluIHJhZGlhbnNcclxuICAgICAqIEByZXR1cm4ge1BvaW50fSAtIHRoZSBlbmRQb2ludCBvZiB0aGUgbGluZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRFbmRQb2ludChzdGFydFBvaW50LCBsZW5ndGgsIGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIGVuZFBvaW50ID0gc3RhcnRQb2ludC5jbG9uZSgpO1xyXG4gICAgICAgIGVuZFBvaW50LnRyYW5zZm9ybSh0cmFuc2xhdGlvbk1hdHJpeCgtc3RhcnRQb2ludC54LCAtc3RhcnRQb2ludC55KSk7XHJcbiAgICAgICAgZW5kUG9pbnQueSAtPSBsZW5ndGg7XHJcbiAgICAgICAgZW5kUG9pbnQudHJhbnNmb3JtKHJvdGF0aW9uTWF0cml4KGFuZ2xlKSk7XHJcbiAgICAgICAgZW5kUG9pbnQudHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KHN0YXJ0UG9pbnQueCwgc3RhcnRQb2ludC55KSk7XHJcbiAgICAgICAgcmV0dXJuIGVuZFBvaW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W6I635Y+W5Lik5Liq5Zu+5b2i55qE5aSW6Z2i5Zub5Liq6L+e5o6l54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHJlY3QgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldENvbm5lY3RvclBvaW50cyhyZWN0LCBub2RlKSB7XHJcbiAgICAgICAgbm9kZSA9IG5vZGUgfHwge307XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHpyVXRpbC5jbG9uZShyZWN0LmJvdW5kaW5nUmVjdCB8fCByZWN0KTtcclxuICAgICAgICB2YXIgcm90YXRpb24gPSBub2RlLnJvdGF0aW9uO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSB7XHJcbiAgICAgICAgICAgIGxlZnQ6IG5ldyBQb2ludChib3VuZGluZ1JlY3QueCwgYm91bmRpbmdSZWN0LnkgKyBib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMiksIC8v55+p5b2iIOW3puS4reeahOS9jee9rlxyXG4gICAgICAgICAgICB0b3A6IG5ldyBQb2ludChib3VuZGluZ1JlY3QueCArIGJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC55KSwgLy/nn6nlvaIg5LiK5Lit55qE5L2N572uXHJcbiAgICAgICAgICAgIHJpZ2h0OiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC55ICsgYm91bmRpbmdSZWN0LmhlaWdodCAvIDIpLCAvL+efqeW9oiDlj7PkuK3nmoTkvY3nva5cclxuICAgICAgICAgICAgYm90dG9tOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGggLyAyLCBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQpLCAvL+efqeW9oiDkuIvkuK3nmoTkvY3nva5cclxuICAgICAgICAgICAgY2VudGVyOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGggLyAyLCBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyKSAvL+S4remXtOS9jee9rlxyXG5cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhub2RlKS5sZW5ndGggPiAwICYmIE1hdGguYWJzKHJvdGF0aW9uKSA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHJlY3ROZXcgPSByZWN0LmJvdW5kaW5nUmVjdCA/IHJlY3QgOiBnZXRSZWN0KG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0geyB4OiByZWN0TmV3LngsIHk6IHJlY3ROZXcueSB9OyAvLyDkuK3lv4PngrlcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMocG9pbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcG9pbnRzW2tleV07XHJcbiAgICAgICAgICAgICAgICB2YXIgeDAgPSBjZW50ZXIueCAtIHZhbHVlLng7XHJcbiAgICAgICAgICAgICAgICB2YXIgeTAgPSBjZW50ZXIueSAtIHZhbHVlLnk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oLXJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcygtcm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uX25feCA9IGNlbnRlci54IC0gKHgwICogY29zIC0geTAgKiBzaW4pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uX25feSA9IGNlbnRlci55IC0gKHgwICogc2luICsgeTAgKiBjb3MpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzW2tleV0ueCA9IHBvc2l0aW9uX25feDtcclxuICAgICAgICAgICAgICAgIHBvaW50c1trZXldLnkgPSBwb3NpdGlvbl9uX3k7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W6IqC54K55aSW6Z2i5Zub5Liq5o6n5Yi254K55ZKM5peL6L2s54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0Q29ubmVjdG9yQ29udHJvbHMocmVjdCwgbm9kZSkge1xyXG4gICAgICAgIG5vZGUgPSBub2RlIHx8IHt9O1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB6clV0aWwuY2xvbmUocmVjdC5ib3VuZGluZ1JlY3QpO1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IG5vZGUucm90YXRpb247XHJcbiAgICAgICAgdmFyIGNvbnRyb2xzID0ge1xyXG4gICAgICAgICAgICB0bDogbmV3IFBvaW50KGJvdW5kaW5nUmVjdC54LCBib3VuZGluZ1JlY3QueSksIC8v55+p5b2iIOW3puS4iuinkuS9jee9rlxyXG4gICAgICAgICAgICB0YzogbmV3IFBvaW50KGJvdW5kaW5nUmVjdC54ICsgYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LnkgLSA0KSwgLy/nn6nlvaIg5LiK5Lit5L2N572uXHJcbiAgICAgICAgICAgIHRyOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC55KSwgLy/nn6nlvaIg5Y+z5LiK6KeS5L2N572uXHJcbiAgICAgICAgICAgIGJsOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LngsIGJvdW5kaW5nUmVjdC55ICsgYm91bmRpbmdSZWN0LmhlaWdodCksIC8v55+p5b2iIOW3puS4i+inklxyXG4gICAgICAgICAgICBicjogbmV3IFBvaW50KGJvdW5kaW5nUmVjdC54ICsgYm91bmRpbmdSZWN0LndpZHRoLCBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQpLCAvL+efqeW9oiDlj7PkuIvop5LkvY3nva5cclxuICAgICAgICAgICAgbXRyOiBuZXcgUG9pbnQoYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGggLyAyLCBib3VuZGluZ1JlY3QueSAtIDIwKSAvLyDml4vovazngrnkvY3nva5cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhub2RlKS5sZW5ndGggPiAwICYmIE1hdGguYWJzKHJvdGF0aW9uKSA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHJlY3ROZXcgPSByZWN0O1xyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0geyB4OiByZWN0TmV3LngsIHk6IHJlY3ROZXcueSB9OyAvLyDkuK3lv4PngrlcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udHJvbHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjb250cm9sc1trZXldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHgwID0gY2VudGVyLnggLSB2YWx1ZS54O1xyXG4gICAgICAgICAgICAgICAgdmFyIHkwID0gY2VudGVyLnkgLSB2YWx1ZS55O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKC1yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoLXJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbl9uX3ggPSBjZW50ZXIueCAtICh4MCAqIGNvcyAtIHkwICogc2luKTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbl9uX3kgPSBjZW50ZXIueSAtICh4MCAqIHNpbiArIHkwICogY29zKTtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xzW2tleV0ueCA9IHBvc2l0aW9uX25feDtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xzW2tleV0ueSA9IHBvc2l0aW9uX25feTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250cm9scztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruS4reW/g+eCueWSjOaXi+i9rOW8p+W6pu+8jOiuoeeul+aXi+i9rOWQjueahOeCueWdkOagh1xyXG4gICAgICogQHBhcmFtICB7W29iamVjdHxhcnJheV19IHBvaW50cyBb5Y6f5Z2Q5qCHXVxyXG4gICAgICogQHBhcmFtICB7W29iamVjdF19ICAgICAgIGNlbnRlciBb5Lit5b+D54K5XVxyXG4gICAgICogQHBhcmFtICB7W251bWJlcl19ICAgICAgIHJvdGF0aW9uIFvml4vovazlvKfluqZdXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVQb2ludHMocG9pbnRzLCBjZW50ZXIsIHJvdGF0aW9uKSB7XHJcbiAgICAgICAgdmFyIHggPSBBcnJheS5pc0FycmF5KHBvaW50cykgPyBwb2ludHNbMF0gOiBwb2ludHMueDtcclxuICAgICAgICB2YXIgeSA9IEFycmF5LmlzQXJyYXkocG9pbnRzKSA/IHBvaW50c1sxXSA6IHBvaW50cy55O1xyXG4gICAgICAgIHZhciB4MCA9IGNlbnRlci54IC0geDtcclxuICAgICAgICB2YXIgeTAgPSBjZW50ZXIueSAtIHk7XHJcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKC1yb3RhdGlvbik7XHJcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKC1yb3RhdGlvbik7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uX25feCA9IGNlbnRlci54IC0gKHgwICogY29zIC0geTAgKiBzaW4pO1xyXG4gICAgICAgIHZhciBwb3NpdGlvbl9uX3kgPSBjZW50ZXIueSAtICh4MCAqIHNpbiArIHkwICogY29zKTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2ludHMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbcG9zaXRpb25fbl94LCBwb3NpdGlvbl9uX3ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBwb3NpdGlvbl9uX3gsXHJcbiAgICAgICAgICAgIHk6IHBvc2l0aW9uX25feVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluiOt+WPluS4pOS4quWbvuW9oueahOWklumdouWbm+S4qui/nuaOpeeCuVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFNvbHRQb2ludHMobm9kZSkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIC8vdG9wXHJcbiAgICAgICAgICAgIFtNYXRoLnJvdW5kKG5vZGUuZ2V0UmVjdCgpLndpZHRoIC8gMyAvMTApKjEwLCAwIF0sXHJcbiAgICAgICAgICAgIFtNYXRoLnJvdW5kKDIqbm9kZS5nZXRSZWN0KCkud2lkdGggLyAzIC8xMCkqMTAsIDAgXSxcclxuICAgICAgICAgICAgLy9yaWdodFxyXG4gICAgICAgICAgICBbbm9kZS5nZXRSZWN0KCkud2lkdGgsIE1hdGgucm91bmQobm9kZS5nZXRSZWN0KCkuaGVpZ2h0IC8gMyAvMTApKjEwIF0sXHJcbiAgICAgICAgICAgIFtub2RlLmdldFJlY3QoKS53aWR0aCwgTWF0aC5yb3VuZCgyKm5vZGUuZ2V0UmVjdCgpLmhlaWdodCAvIDMgLzEwKSoxMCBdLFxyXG4gICAgICAgICAgICAvL2JvdHRvbVxyXG4gICAgICAgICAgICBbTWF0aC5yb3VuZChub2RlLmdldFJlY3QoKS53aWR0aCAvIDMgLzEwKSoxMCwgbm9kZS5nZXRSZWN0KCkuaGVpZ2h0IF0sXHJcbiAgICAgICAgICAgIFtNYXRoLnJvdW5kKDIqbm9kZS5nZXRSZWN0KCkud2lkdGggLyAzIC8xMCkqMTAsIG5vZGUuZ2V0UmVjdCgpLmhlaWdodCBdLFxyXG4gICAgICAgICAgICAvL2xlZnRcclxuICAgICAgICAgICAgWzAsIE1hdGgucm91bmQobm9kZS5nZXRSZWN0KCkuaGVpZ2h0IC8gMyAvMTApKjEwIF0sXHJcbiAgICAgICAgICAgIFswLCBNYXRoLnJvdW5kKDIqbm9kZS5nZXRSZWN0KCkuaGVpZ2h0IC8gMyAvMTApKjEwIF1cclxuXHJcbiAgICAgICAgXVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6h566XIHAxIHAy5Lik54K55omA6L+e5o6l55qE55u057q/55qE6KeS5bqmXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHAxIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcDIgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRhbmdlbnRSb3RhdGlvbihwMSwgcDIpIHtcclxuICAgICAgICByZXR1cm4gLU1hdGguUEkgLyAyIC0gTWF0aC5hdGFuMihcclxuICAgICAgICAgICAgcDIueSAtIHAxLnksIHAyLnggLSBwMS54XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIpOaWrTPngrnmmK/lkKblnKjkuIDmnaHnm7Tnur/kuIpcclxuICAgICAqIFRlc3RzIGlmIDMgcG9pbnRzIGFyZSBjb2xpbmlhciB3aXRoIG1hdHJpeCBkZXRlcm1pbmFudHMuXHJcbiAgICAgKiBJZiB0aGUgZGV0ZXJtaW5hdCBvZiBtYXRyaXhcclxuICAgICAqIC8gICAgICAgICBcXFxyXG4gICAgICogfCB4MSB5MSAxIHxcclxuICAgICAqIHwgeDIgeTIgMSB8XHJcbiAgICAgKiB8IHgzIHkzIDEgfFxyXG4gICAgICogXFwgICAgICAgICAvXHJcbiAgICAgKiBpcyB6ZXJvIGl0IG1lYW5zIHRoYXQgdGhlIHBvaW50cyBhcmUgY29saW5lYXJcclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDEgLSBmaXJzdCBwb2ludFxyXG4gICAgICpAcGFyYW0ge1BvaW50fSBwMiAtIHNlY29uZCBwb2ludFxyXG4gICAgICpAcGFyYW0ge1BvaW50fSBwMyAtIHRoaXJkIHBvaW50XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzc2lvblxyXG4gICAgICpAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgY29saW5pYXIgYW5kIGZhbHNlIGlmIG5vdFxyXG4gICAgICpAYXV0aG9yIEFsZXhcclxuICAgICAqQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RldGVybWluYW50XHJcbiAgICAgKkBzZWUgaHR0cHM6Ly9wZW9wbGUucmljaGxhbmQuZWR1L2phbWVzL2xlY3R1cmUvbTExNi9tYXRyaWNlcy9hcHBsaWNhdGlvbnMuaHRtbFxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gY29sbGluZWFyaXR5KHAxLCBwMiwgcDMsIHByZWNpc3Npb24pIHtcclxuICAgICAgICB2YXIgZGV0ZXJtaW5hbnQgPSAocDEueCAqIHAyLnkgKyBwMS55ICogcDMueCArIHAyLnggKiBwMy55KSAtIChwMi55ICogcDMueCArIHAxLnkgKiBwMi54ICsgcDEueCAqIHAzLnkpO1xyXG5cclxuICAgICAgICBpZiAocHJlY2lzc2lvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoZGV0ZXJtaW5hbnQpIDw9IHByZWNpc3Npb247XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRldGVybWluYW50ID09PSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlm5voiI3kupTlhaUg5L+d5a2YZGVjaW1hbHPnmoTlsI/mlbBcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGVuaGFuY2VkUm91bmQobnVtYmVyLCBkZWNpbWFscykge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIE1hdGgucG93KDEwLCBkZWNpbWFscykpIC8gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluS4pOeCueS5i+mXtOeahOmVv+W6plxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gZ2V0TGVuZ3RoKHN0YXJ0UG9pbnQsIGVuZFBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhzdGFydFBvaW50LnggLSBlbmRQb2ludC54LCAyKSArIE1hdGgucG93KHN0YXJ0UG9pbnQueSAtIGVuZFBvaW50LnksIDIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluinkuW6plxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBjZW50ZXJQb2ludCAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBvdXRzaWRlUG9pbnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSByb3VuZCAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRBbmdsZShjZW50ZXJQb2ludCwgb3V0c2lkZVBvaW50LCByb3VuZCkge1xyXG4gICAgICAgIGNlbnRlclBvaW50LnggPSBlbmhhbmNlZFJvdW5kKGNlbnRlclBvaW50LngsIDUpO1xyXG4gICAgICAgIGNlbnRlclBvaW50LnkgPSBlbmhhbmNlZFJvdW5kKGNlbnRlclBvaW50LnksIDUpO1xyXG4gICAgICAgIG91dHNpZGVQb2ludC54ID0gZW5oYW5jZWRSb3VuZChvdXRzaWRlUG9pbnQueCwgNSk7XHJcbiAgICAgICAgb3V0c2lkZVBvaW50LnkgPSBlbmhhbmNlZFJvdW5kKG91dHNpZGVQb2ludC55LCA1KTtcclxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4oKG91dHNpZGVQb2ludC54IC0gY2VudGVyUG9pbnQueCkgLyAob3V0c2lkZVBvaW50LnkgLSBjZW50ZXJQb2ludC55KSk7XHJcbiAgICAgICAgYW5nbGUgPSAtYW5nbGU7XHJcblxyXG4gICAgICAgIC8vZW5kQW5nbGUrPTkwO1xyXG4gICAgICAgIGlmIChvdXRzaWRlUG9pbnQueCA+PSBjZW50ZXJQb2ludC54ICYmIG91dHNpZGVQb2ludC55ID49IGNlbnRlclBvaW50LnkpIHtcclxuICAgICAgICAgICAgYW5nbGUgKz0gTWF0aC5QSTtcclxuICAgICAgICB9IGVsc2UgaWYgKG91dHNpZGVQb2ludC54IDw9IGNlbnRlclBvaW50LnggJiYgb3V0c2lkZVBvaW50LnkgPj0gY2VudGVyUG9pbnQueSkge1xyXG4gICAgICAgICAgICBhbmdsZSArPSBNYXRoLlBJO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3V0c2lkZVBvaW50LnggPD0gY2VudGVyUG9pbnQueCAmJiBvdXRzaWRlUG9pbnQueSA8PSBjZW50ZXJQb2ludC55KSB7XHJcbiAgICAgICAgICAgIGFuZ2xlICs9IE1hdGguUEkgKiAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoYW5nbGUgPj0gTWF0aC5QSSAqIDIpIHtcclxuICAgICAgICAgICAgYW5nbGUgLT0gTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc05hTihhbmdsZSkpIHsgLy9OYW5cclxuICAgICAgICAgICAgYW5nbGUgPSAwOyAvL3dlIGFyZSBhdCBjZW50ZXIgcG9pbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb3VuZCkge1xyXG4gICAgICAgICAgICBhbmdsZSA9IE1hdGgucm91bmQoYW5nbGUgLyByb3VuZCkgKiByb3VuZFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYW5nbGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bniLboioLngrnnmoRwb3NpdGlvblswXVxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBub2RlICBb6IqC54K5XVxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwYXJlbnRLZXkgW+WIpOaWreaYr+WQpuacieaMh+WumueItuiKgueCueeahGtleSzlr7nkuo5ncm91cOaYr3R5cGXvvJvlr7nkuo5zdWJwcm9jZXNz5pivbm9kZVR5cGVdXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBhcmVudFZhbHVlICBb5Yik5pat5piv5ZCm5pyJ5oyH5a6a54i26IqC54K555qEdmFsdWUs5a+55LqOZ3JvdXDmmK9Hcm91cE5vZGXvvJvlr7nkuo5zdWJwcm9jZXNz5pivU3ViUHJvY2Vzc11cclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgIOeItuiKgueCueeahHBvc2l0aW9uWzBdXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFBhcmVudFgobm9kZSwgcGFyZW50S2V5LCBwYXJlbnRWYWx1ZSkge1xyXG4gICAgICAgIGlmICghcGFyZW50S2V5KSB7XHJcbiAgICAgICAgICAgIHBhcmVudEtleSA9ICd0eXBlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwYXJlbnRWYWx1ZSkge1xyXG4gICAgICAgICAgICBwYXJlbnRWYWx1ZSA9ICdHcm91cE5vZGUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnRbcGFyZW50S2V5XSA9PT0gcGFyZW50VmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zaXRpb25bMF0gKyBnZXRQYXJlbnRYKG5vZGUucGFyZW50KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzBdXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W54i26IqC54K555qEcG9zaXRpb25bMV1cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gbm9kZSAgW+iKgueCuV1cclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gcGFyZW50S2V5IFvliKTmlq3mmK/lkKbmnInmjIflrprniLboioLngrnnmoRrZXks5a+55LqOZ3JvdXDmmK90eXBl77yb5a+55LqOc3VicHJvY2Vzc+aYr25vZGVUeXBlXVxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwYXJlbnRWYWx1ZSAgW+WIpOaWreaYr+WQpuacieaMh+WumueItuiKgueCueeahHZhbHVlLOWvueS6jmdyb3Vw5pivR3JvdXBOb2Rl77yb5a+55LqOc3VicHJvY2Vzc+aYr1N1YlByb2Nlc3NdXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICAgICDniLboioLngrnnmoRwb3NpdGlvblsxXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRQYXJlbnRZKG5vZGUsIHBhcmVudEtleSwgcGFyZW50VmFsdWUpIHtcclxuICAgICAgICBpZiAoIXBhcmVudEtleSkge1xyXG4gICAgICAgICAgICBwYXJlbnRLZXkgPSAndHlwZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcGFyZW50VmFsdWUpIHtcclxuICAgICAgICAgICAgcGFyZW50VmFsdWUgPSAnR3JvdXBOb2RlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50W3BhcmVudEtleV0gPT09IHBhcmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzFdICsgZ2V0UGFyZW50WShub2RlLnBhcmVudClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblsxXVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRSZWN0KG5vZGUsIGlzQ2FsY1BhcmVudCkge1xyXG4gICAgICAgIHZhciBjbGlwUGF0aCA9IG5vZGUuY2xpcFBhdGg7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuXHQgICAgICAgIC8vIOiKgueCueijgeWJquWQju+8jOS7peijgeWJquiKgueCueWMheWbtOebkuS4uuWHhlxyXG5cdCAgICAgICAgaWYgKGNsaXBQYXRoKSB7XHJcblx0ICAgICAgICAgICAgcmVjdCA9IGNsaXBQYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG5cdCAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0genJVdGlsLmNsb25lKHJlY3QpO1xyXG5cdCAgICAgICAgLy/liJvlu7rmnIDlsI/ljIXlm7Tnm5LomZrnur9cclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSAoYm91bmRpbmdSZWN0LnggPj0gLTEgJiYgYm91bmRpbmdSZWN0LnggPD0gMCkgPyBOdW1iZXIoYm91bmRpbmdSZWN0LndpZHRoKSArIE51bWJlcihib3VuZGluZ1JlY3QueCkgKiAyIDogTnVtYmVyKGJvdW5kaW5nUmVjdC53aWR0aCk7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSAoYm91bmRpbmdSZWN0LnkgPj0gLTEgJiYgYm91bmRpbmdSZWN0LnkgPD0gMCkgPyBOdW1iZXIoYm91bmRpbmdSZWN0LmhlaWdodCkgKyBOdW1iZXIoYm91bmRpbmdSZWN0LnkpICogMiA6IE51bWJlcihib3VuZGluZ1JlY3QuaGVpZ2h0KTtcclxuXHQgICAgICAgIHBvaW50c1swXSA9IFstYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgLWJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuXHQgICAgICAgIHBvaW50c1sxXSA9IFtib3VuZGluZ1JlY3Qud2lkdGggLyAyLCAtYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG5cdCAgICAgICAgcG9pbnRzWzJdID0gW2JvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuXHQgICAgICAgIHBvaW50c1szXSA9IFstYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG5cdCAgICAgICAgcG9pbnRzWzRdID0gWy1ib3VuZGluZ1JlY3Qud2lkdGggLyAyLCAtYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG5cclxuXHQgICAgICAgIHZhciBwb3NpdGlvblggPSBub2RlLnBvc2l0aW9uWzBdO1xyXG5cdCAgICAgICAgdmFyIHBvc2l0aW9uWSA9IG5vZGUucG9zaXRpb25bMV07XHJcblx0ICAgICAgICAvL+i/memHjOimgeW+queOr+WIpOaWreS4gOaKiiDmnInmsqHmnInniLboioLngrkg5bm25LiU54i26IqC54K55LiN5piv5qC56IqC54K5IOeEtuWQjui/m+ihjOebuOWKoFxyXG5cdCAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIGlzQ2FsY1BhcmVudCkge1xyXG5cdCAgICAgICAgICAgIGlmIChub2RlLnBhcmVudC50eXBlID09PSAnR3JvdXBOb2RlJyB8fCBub2RlLnBhcmVudC5ub2RlVHlwZSA9PT0gJ1N1YlByb2Nlc3MnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHBvc2l0aW9uWCArPSBnZXRQYXJlbnRYKG5vZGUucGFyZW50KTtcclxuXHQgICAgICAgICAgICAgICAgcG9zaXRpb25ZICs9IGdldFBhcmVudFkobm9kZS5wYXJlbnQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHJcblx0ICAgICAgICB2YXIgYm91bmRSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChcclxuICAgICAgICAgICAgICAgICAgICAoYm91bmRpbmdSZWN0LnggPj0gLTEgJiYgYm91bmRpbmdSZWN0LnggPD0gMCkgPyBOdW1iZXIocG9zaXRpb25YKSA6IE51bWJlcihwb3NpdGlvblggKyBib3VuZGluZ1JlY3QueCksICAgLy/ms6g6IOWboOS6i+S7tuS4uuWchuW9oiAg5omA5LulIHggeSDkuLrlnIblv4PnmoTkvY3nva4gIOWMheWbtOefqeW9ouimgeWHj+WOu+WuveW6puS4gOWNilxyXG5cdCAgICAgICAgICAgICAgICAoYm91bmRpbmdSZWN0LnkgPj0gLTEgJiYgYm91bmRpbmdSZWN0LnkgPD0gMCkgPyBOdW1iZXIocG9zaXRpb25ZKSA6IE51bWJlcihwb3NpdGlvblkgKyBib3VuZGluZ1JlY3QueSksXHJcblx0ICAgICAgICAgICAgICAgIE51bWJlcih3aWR0aCksXHJcblx0ICAgICAgICAgICAgICAgIE51bWJlcihoZWlnaHQpXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cdCAgICAgICAgLy/kuK3lv4PngrlcclxuXHQgICAgICAgIHZhciBjeCA9IE51bWJlcihwb3NpdGlvblgpICsgTnVtYmVyKGJvdW5kaW5nUmVjdC53aWR0aCkgLyAyICsgTnVtYmVyKGJvdW5kaW5nUmVjdC54KTtcclxuXHQgICAgICAgIHZhciBjeSA9IE51bWJlcihwb3NpdGlvblkpICsgTnVtYmVyKGJvdW5kaW5nUmVjdC5oZWlnaHQpIC8gMiArIE51bWJlcihib3VuZGluZ1JlY3QueSk7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHg6IE51bWJlcihjeCksXHJcblx0ICAgICAgICAgICAgeTogTnVtYmVyKGN5KSxcclxuXHQgICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcblx0ICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcblx0ICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcblx0ICAgICAgICAgICAgYm91bmRpbmdSZWN0OiBib3VuZFJlY3RcclxuXHQgICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIFN0YWNrZWRNYXAgPSB7XHJcbiAgICAgICAgY3JlYXRlTmV3OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHN0YWNrID0gW107XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYWRkOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycktleSA9IHRoaXMuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyS2V5LnB1c2godmFsdWUpXHJcblxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIOiOt+WPlui1t+Wni+eCueaciW9mZnNldOmXtOmalOeahGFycktleVxyXG4gICAgICAgICAgICAgICAgZ2V0c2ltaWxhcjogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleUFyciA9IGtleS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUtleUFyciA9IGl0ZW0ua2V5LnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtS2V5QXJyWzBdLmluZGV4T2Yoa2V5QXJyWzBdKSA+IC0xICYmIGl0ZW1LZXlBcnJbMV0uaW5kZXhPZihrZXlBcnJbMV0pID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY29uY2F0KGl0ZW0udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goeyBrZXk6IGtleSwgdmFsdWU6IHZhbHVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gc3RhY2tbaV0ua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tbaV0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy/lpoLmnpzmsqHmnInmib7liLDnmoTor53vvIzliJnliJvlu7rkuIDkuKrmlrDnmoTmlbDnu4RcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAga2V5czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChzdGFja1tpXS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0b3A6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gc3RhY2tbaV0ua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNwbGljZShpZHgsIDEpWzBdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uKGtleSwgaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJLZXkgPSB0aGlzLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHpyVXRpbC5pbmRleE9mKGFycktleSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyS2V5LnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZVRvcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSAxLCAxKVswXTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFjay5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnNwbGljZSgwLCBzdGFjay5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcmFuZG9tQ29sb3IoKSB7XHJcbiAgICAgICAgdmFyIGFyckhleCA9IFtcIjBcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIl0sXHJcbiAgICAgICAgICAgIHN0ckhleCA9IFwiI1wiLFxyXG4gICAgICAgICAgICBpbmRleDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xyXG4gICAgICAgICAgICBpbmRleCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDE1KTtcclxuICAgICAgICAgICAgc3RySGV4ICs9IGFyckhleFtpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHJIZXg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbGxpbmVhclJlZHVjdGlvbiAodikge1xyXG4gICAgICAgIHZhciByID0gW107XHJcblxyXG4gICAgICAgIGlmKHYubGVuZ3RoIDwgMyl7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5jbG9uZUFycmF5KHYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgci5wdXNoKCB2WzBdLmNsb25lKCkgKTtcclxuICAgICAgICBmb3IodmFyIGk9MTsgaSA8IHYubGVuZ3RoLTE7IGkrKyl7XHJcbiAgICAgICAgICAgIGlmKCAodltpLTFdLnggPT0gdltpXS54ICYmIHZbaV0ueCA9PSB2W2krMV0ueCkgIHx8ICAodltpLTFdLnkgPT0gdltpXS55ICYmIHZbaV0ueSA9PSB2W2krMV0ueSkgKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgci5wdXNoKCB2W2ldLmNsb25lKCkgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByLnB1c2goIHZbdi5sZW5ndGgtMV0uY2xvbmUoKSApO1xyXG5cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcclxuICAgIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cclxuICAgIHZhciB0ZW1wbGF0ZVNldHRpbmdzID0ge1xyXG4gICAgICAgIGV2YWx1YXRlOiAvPCUoW1xcc1xcU10rPyklPi9nLFxyXG4gICAgICAgIGludGVycG9sYXRlOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcclxuICAgICAgICBlc2NhcGU6IC88JS0oW1xcc1xcU10rPyklPi9nXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cclxuICAgIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcclxuICAgIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxyXG4gICAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XHJcblxyXG4gICAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcclxuICAgIC8vIHN0cmluZyBsaXRlcmFsLlxyXG4gICAgdmFyIGVzY2FwZXMgPSB7XHJcbiAgICAgICAgXCInXCI6IFwiJ1wiLFxyXG4gICAgICAgICdcXFxcJzogJ1xcXFwnLFxyXG4gICAgICAgICdcXHInOiAncicsXHJcbiAgICAgICAgJ1xcbic6ICduJyxcclxuICAgICAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXHJcbiAgICAgICAgJ1xcdTIwMjknOiAndTIwMjknXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xyXG5cclxuICAgIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXHJcbiAgICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXHJcbiAgICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cclxuICAgIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cclxuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xyXG4gICAgICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XHJcbiAgICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcclxuICAgICAgICBzZXR0aW5ncyA9IHpyVXRpbC5kZWZhdWx0cyhzZXR0aW5ncywgdGVtcGxhdGVTZXR0aW5ncywgdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxyXG4gICAgICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcclxuICAgICAgICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXHJcbiAgICAgICAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXHJcbiAgICAgICAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcclxuICAgICAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XHJcblxyXG4gICAgICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcclxuICAgICAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVyLCBlc2NhcGVDaGFyKTtcclxuICAgICAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBpZiAoZXNjYXBlKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcclxuXHJcbiAgICAgICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cclxuICAgICAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xyXG5cclxuICAgICAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXHJcbiAgICAgICAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXHJcbiAgICAgICAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsIHNvdXJjZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cclxuICAgICAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcclxuICAgICAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XHJcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXlMaWtlKG9iaikgJiYgKHpyVXRpbC5pc0FycmF5KG9iaikgfHwgenJVdGlsLmlzU3RyaW5nKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lcmdlT3B0KHRhcmdldCwgc291cmNlLCBvdmVyd3JpdGUsIGV4Y2x1ZGUpIHtcclxuICAgICAgICAvLyBXZSBzaG91bGQgZXNjYXBzZSB0aGF0IHNvdXJjZSBpcyBzdHJpbmdcclxuICAgICAgICAvLyBhbmQgZW50ZXIgZm9yIC4uLiBpbiAuLi5cclxuICAgICAgICBpZiAoIXpyVXRpbC5pc09iamVjdChzb3VyY2UpIHx8ICF6clV0aWwuaXNPYmplY3QodGFyZ2V0KSkge1xyXG4gICAgICAgICAgcmV0dXJuIG92ZXJ3cml0ZSA/IHpyVXRpbC5jbG9uZShzb3VyY2UpIDogdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xyXG4gICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRQcm9wID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XHJcblxyXG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KHNvdXJjZVByb3ApICYmIHpyVXRpbC5pc09iamVjdCh0YXJnZXRQcm9wKSAmJiAhenJVdGlsLmlzQXJyYXkoc291cmNlUHJvcCkgJiYgIXpyVXRpbC5pc0FycmF5KHRhcmdldFByb3ApICYmICF6clV0aWwuaXNEb20oc291cmNlUHJvcCkgJiYgIXpyVXRpbC5pc0RvbSh0YXJnZXRQcm9wKSAmJiAhenJVdGlsLmlzQnVpbHRJbk9iamVjdChzb3VyY2VQcm9wKSAmJiAhenJVdGlsLmlzQnVpbHRJbk9iamVjdCh0YXJnZXRQcm9wKSAmJiAhenJVdGlsLmlzUHJpbWl0aXZlKHNvdXJjZVByb3ApICYmICF6clV0aWwuaXNQcmltaXRpdmUodGFyZ2V0UHJvcCkpIHtcclxuICAgICAgICAgICAgICAvLyDlpoLmnpzpnIDopoHpgJLlvZLopobnm5bvvIzlsLHpgJLlvZLosIPnlKhtZXJnZVxyXG4gICAgICAgICAgICAgIG1lcmdlT3B0KHRhcmdldFByb3AsIHNvdXJjZVByb3AsIG92ZXJ3cml0ZSwgZXhjbHVkZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3ZlcndyaXRlIHx8ICEoa2V5IGluIHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAvLyDlkKbliJnlj6rlpITnkIZvdmVyd3JpdGXkuLp0cnVl77yM5oiW6ICF5Zyo55uu5qCH5a+56LGh5Lit5rKh5pyJ5q2k5bGe5oCn55qE5oOF5Ya1XHJcbiAgICAgICAgICAgICAgLy8gTk9URe+8jOWcqCB0YXJnZXRba2V5XSDkuI3lrZjlnKjnmoTml7blgJnkuZ/mmK/nm7TmjqXopobnm5ZcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IGV4Y2x1ZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHpyVXRpbC5jbG9uZShzb3VyY2Vba2V5XSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIENsYXNzKCkge31cclxuICAgIENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uKHByb3RvKSB7XHJcbiAgICAgICAgdmFyIGJhc2UgPSBmdW5jdGlvbigpIHt9LFxyXG4gICAgICAgICAgICBtZW1iZXIsXHJcbiAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgICAgICBzdWJjbGFzcyA9IHByb3RvICYmIHByb3RvLmluaXQgPyBwcm90by5pbml0IDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmbjtcclxuXHJcbiAgICAgICAgYmFzZS5wcm90b3R5cGUgPSB0aGF0LnByb3RvdHlwZTtcclxuICAgICAgICBmbiA9IHN1YmNsYXNzLmZuID0gc3ViY2xhc3MucHJvdG90eXBlID0gbmV3IGJhc2UoKTtcclxuXHJcbiAgICAgICAgZm9yIChtZW1iZXIgaW4gcHJvdG8pIHtcclxuICAgICAgICAgICAgaWYgKHByb3RvW21lbWJlcl0gIT0gbnVsbCAmJiBwcm90b1ttZW1iZXJdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1lcmdlIG9iamVjdCBtZW1iZXJzXHJcbiAgICAgICAgICAgICAgICBmblttZW1iZXJdID0genJVdGlsLm1lcmdlQWxsKFt7fSwgYmFzZS5wcm90b3R5cGVbbWVtYmVyXSwgcHJvdG9bbWVtYmVyXV0sdHJ1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmblttZW1iZXJdID0gcHJvdG9bbWVtYmVyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm4uY29uc3RydWN0b3IgPSBzdWJjbGFzcztcclxuICAgICAgICBzdWJjbGFzcy5leHRlbmQgPSB0aGF0LmV4dGVuZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN1YmNsYXNzO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBpbmhlcml0czogaW5oZXJpdHMsXHJcbiAgICAgICAgZ2V0VVVJRDogZ2V0VVVJRCxcclxuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXHJcbiAgICAgICAgZ2V0UG9seWxpbmVMZW5ndGg6IGdldFBvbHlsaW5lTGVuZ3RoLFxyXG4gICAgICAgIG1heDogbWF4LFxyXG4gICAgICAgIG1pbjogbWluLFxyXG4gICAgICAgIGlzRW1wdHk6IGlzRW1wdHksXHJcbiAgICAgICAgbWVyZ2VPcHQ6IG1lcmdlT3B0LFxyXG4gICAgICAgIG9ydGhvZ29uYWxQYXRoOiBvcnRob2dvbmFsUGF0aCxcclxuICAgICAgICBwb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGU6IHBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZSxcclxuICAgICAgICBzY29yZVBhdGg6IHNjb3JlUGF0aCxcclxuICAgICAgICBmb3J3YXJkUGF0aDogZm9yd2FyZFBhdGgsXHJcbiAgICAgICAgdHJhc2xhdGVQb2ludHM6IHRyYXNsYXRlUG9pbnRzLFxyXG4gICAgICAgIGdldEVuZFBvaW50OiBnZXRFbmRQb2ludCxcclxuICAgICAgICBnZXRDb25uZWN0b3JQb2ludHM6IGdldENvbm5lY3RvclBvaW50cyxcclxuICAgICAgICBnZXRDb25uZWN0b3JDb250cm9sczogZ2V0Q29ubmVjdG9yQ29udHJvbHMsXHJcbiAgICAgICAgY2FsY3VsYXRlUG9pbnRzOiBjYWxjdWxhdGVQb2ludHMsXHJcbiAgICAgICAgdGFuZ2VudFJvdGF0aW9uOiB0YW5nZW50Um90YXRpb24sXHJcbiAgICAgICAgY29sbGluZWFyaXR5OiBjb2xsaW5lYXJpdHksXHJcbiAgICAgICAgdHJhbnNsYXRpb25NYXRyaXg6IHRyYW5zbGF0aW9uTWF0cml4LFxyXG4gICAgICAgIHNjYWxlTWF0cml4OiBzY2FsZU1hdHJpeCxcclxuICAgICAgICByb3VuZDogZW5oYW5jZWRSb3VuZCxcclxuICAgICAgICBnZXRMZW5ndGg6IGdldExlbmd0aCxcclxuICAgICAgICBnZXRBbmdsZTogZ2V0QW5nbGUsXHJcbiAgICAgICAgZ2V0UGFyZW50WDogZ2V0UGFyZW50WCxcclxuICAgICAgICBnZXRQYXJlbnRZOiBnZXRQYXJlbnRZLFxyXG4gICAgICAgIGdldFJlY3Q6IGdldFJlY3QsXHJcbiAgICAgICAgU3RhY2tlZE1hcDogU3RhY2tlZE1hcCxcclxuICAgICAgICBnZXRNYXhMaW5lTGVuZ3RoOiBnZXRNYXhMaW5lTGVuZ3RoLFxyXG4gICAgICAgIHJhbmRvbUNvbG9yOiByYW5kb21Db2xvcixcclxuICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICAgICAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxyXG4gICAgICAgIGdldFNvbHRQb2ludHM6Z2V0U29sdFBvaW50cyxcclxuICAgICAgICBjb2xsaW5lYXJSZWR1Y3Rpb246IGNvbGxpbmVhclJlZHVjdGlvbixcclxuICAgICAgICBDbGFzczpDbGFzc1xyXG4gICAgfTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHJcbiAgICAvKipcclxuICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgTGluZS4gQSBMaW5lIGlzIGFjdHVhbGx5IGEgc2VnbWVudCBhbmQgbm90IGEgcHVyZVxyXG4gICAgICAqIGdlb21ldHJpY2FsIExpbmVcclxuICAgICAgKlxyXG4gICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAqIEB0aGlzIHtMaW5lfVxyXG4gICAgICAqIEBwYXJhbSB7UG9pbnR9IHN0YXJ0UG9pbnQgLSBzdGFydGluZyBwb2ludCBvZiB0aGUgbGluZVxyXG4gICAgICAqIEBwYXJhbSB7UG9pbnR9IGVuZFBvaW50IC0gdGhlIGVuZGluZyBwb2ludCBvZiB0aGUgbGluZVxyXG4gICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIExpbmUoc3RhcnRQb2ludCwgZW5kUG9pbnQpe1xyXG4gICAgICAgIC8qKlN0YXJ0aW5nIHtAbGluayBQb2ludH0gb2YgdGhlIGxpbmUqL1xyXG4gICAgICAgIHRoaXMuc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQ7XHJcblxyXG4gICAgICAgIC8qKkVuZGluZyB7QGxpbmsgUG9pbnR9IG9mIHRoZSBsaW5lKi9cclxuICAgICAgICB0aGlzLmVuZFBvaW50ID0gZW5kUG9pbnQ7XHJcblxyXG4gICAgICAgIC8qKlNlcmlhbGl6YXRpb24gdHlwZSovXHJcbiAgICAgICAgdGhpcy5vVHlwZSA9ICdMaW5lJzsgLy9vYmplY3QgdHlwZSB1c2VkIGZvciBKU09OIGRlc2VyaWFsaXphdGlvblxyXG4gICAgfVxyXG5cclxuICAgIC8qKkNyZWF0ZXMgYSB7TGluZX0gb3V0IG9mIEpTT04gcGFyc2VkIG9iamVjdFxyXG4gICAgICpAcGFyYW0ge0pTT05PYmplY3R9IG8gLSB0aGUgSlNPTiBwYXJzZWQgb2JqZWN0XHJcbiAgICAgKkByZXR1cm4ge0xpbmV9IGEgbmV3bHkgY29uc3RydWN0ZWQgTGluZVxyXG4gICAgICoqL1xyXG4gICAgTGluZS5sb2FkID0gZnVuY3Rpb24obyl7XHJcbiAgICAgICAgdmFyIG5ld0xpbmUgPSBuZXcgTGluZShcclxuICAgICAgICAgICAgUG9pbnQubG9hZChvLnN0YXJ0UG9pbnQpLFxyXG4gICAgICAgICAgICBQb2ludC5sb2FkKG8uZW5kUG9pbnQpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld0xpbmU7XHJcbiAgICB9O1xyXG5cclxuICAgIExpbmUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnRydWN0b3I6IExpbmUsXHJcblxyXG5cclxuXHJcbiAgICAgICAgY2xvbmU6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBMaW5lKHRoaXMuc3RhcnRQb2ludC5jbG9uZSgpLCB0aGlzLmVuZFBvaW50LmNsb25lKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGVxdWFsczpmdW5jdGlvbihhbm90aGVyTGluZSl7XHJcbiAgICAgICAgICAgIGlmKCFhbm90aGVyTGluZSBpbnN0YW5jZW9mIExpbmUpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UG9pbnQuZXF1YWxzKGFub3RoZXJMaW5lLnN0YXJ0UG9pbnQpXHJcbiAgICAgICAgICAgICYmIHRoaXMuZW5kUG9pbnQuZXF1YWxzKGFub3RoZXJMaW5lLmVuZFBvaW50KVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKiBUZXN0cyB0byBzZWUgaWYgYSBwb2ludCBiZWxvbmdzIHRvIHRoaXMgbGluZSAobm90IGFzIGluZmluaXRlIGxpbmUgYnV0IG1vcmUgbGlrZSBhIHNlZ21lbnQpXHJcbiAgICAgICAgICogQWxnb3JpdGhtOiBDb21wdXRlIGxpbmUncyBlcXVhdGlvbiBhbmQgc2VlIGlmICh4LCB5KSB2ZXJpZmllcyBpdC5cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIHRoZSBYIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSB0aGUgWSBjb29yZGluYXRlc1xyXG4gICAgICAgICAqKi9cclxuICAgICAgICBjb250YWluczogZnVuY3Rpb24oeCwgeSl7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgcmVjdGFuZ2xlIGJvdW5kcyBvZiB0aGUgc2VnbWVudFxyXG4gICAgICAgICAgICBpZiAoTWF0aC5taW4odGhpcy5zdGFydFBvaW50LngsIHRoaXMuZW5kUG9pbnQueCkgPD0geFxyXG4gICAgICAgICAgICAgICAgJiYgeCA8PSBNYXRoLm1heCh0aGlzLnN0YXJ0UG9pbnQueCwgdGhpcy5lbmRQb2ludC54KVxyXG4gICAgICAgICAgICAgICAgJiYgTWF0aC5taW4odGhpcy5zdGFydFBvaW50LnksIHRoaXMuZW5kUG9pbnQueSkgPD0geVxyXG4gICAgICAgICAgICAgICAgJiYgeSA8PSBNYXRoLm1heCh0aGlzLnN0YXJ0UG9pbnQueSwgdGhpcy5lbmRQb2ludC55KSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciB2ZXJ0aWNhbCBsaW5lXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydFBvaW50LnggPT0gdGhpcy5lbmRQb2ludC54KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggPT0gdGhpcy5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyB1c3VhbCAobm90IHZlcnRpY2FsKSBsaW5lIGNhbiBiZSByZXByZXNlbnRlZCBhcyB5ID0gYSAqIHggKyBiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSAodGhpcy5lbmRQb2ludC55IC0gdGhpcy5zdGFydFBvaW50LnkpIC8gKHRoaXMuZW5kUG9pbnQueCAtIHRoaXMuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMuc3RhcnRQb2ludC55IC0gYSAqIHRoaXMuc3RhcnRQb2ludC54O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5ID09IGEgKiB4ICsgYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICpTZWUgaWYgd2UgYXJlIG5lYXIgYSB7TGluZX0gYnkgYSBjZXJ0YWluIHJhZGl1cyAoYWxzbyBpbmNsdWRlcyB0aGUgZXh0cmVtaXRpZXMgaW50byBjb21wdXRhdGlvbilcclxuICAgICAgICAgKkBwYXJhbSB7TnVtYmVyfSB4IC0gdGhlIHggY29vcmRpbmF0ZXNcclxuICAgICAgICAgKkBwYXJhbSB7TnVtYmVyfSB5IC0gdGhlIHkgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKkBwYXJhbSB7TnVtYmVyfSByYWRpdXMgLSB0aGUgcmFkaXVzIHRvIHNlYXJjaCBmb3JcclxuICAgICAgICAgKkBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lXHJcbiAgICAgICAgICpAc2VlIFwiTWF0aGVtYXRpY3MgZm9yIENvbXB1dGVyIEdyYXBoaWNzLCAybmQgRWQuLCBieSBKb2huIFZpY2UsIHBhZ2UgMjI3XCJcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgbmVhcjpmdW5jdGlvbih4LHkscmFkaXVzKXtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuZW5kUG9pbnQueCA9PT0gdGhpcy5zdGFydFBvaW50LngpeyAvL1ZlcnRpY2FsIGxpbmUsIHNvIHRoZSB2aWNpbml0eSBhcmVhIGlzIGEgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCAodGhpcy5zdGFydFBvaW50LnktcmFkaXVzPD15ICYmIHRoaXMuZW5kUG9pbnQueStyYWRpdXM+PXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICh0aGlzLmVuZFBvaW50LnktcmFkaXVzPD15ICYmIHRoaXMuc3RhcnRQb2ludC55K3JhZGl1cz49eSkpXHJcbiAgICAgICAgICAgICAgICAmJiB4ID4gdGhpcy5zdGFydFBvaW50LnggLSByYWRpdXMgJiYgeCA8IHRoaXMuc3RhcnRQb2ludC54ICsgcmFkaXVzIDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5zdGFydFBvaW50LnkgPT09IHRoaXMuZW5kUG9pbnQueSl7IC8vSG9yaXpvbnRhbCBsaW5lLCBzbyB0aGUgdmljaW5pdHkgYXJlYSBpcyBhIHJlY3RhbmdsZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICggKHRoaXMuc3RhcnRQb2ludC54IC0gcmFkaXVzPD14ICYmIHRoaXMuZW5kUG9pbnQueCtyYWRpdXM+PXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICh0aGlzLmVuZFBvaW50LngtcmFkaXVzPD14ICYmIHRoaXMuc3RhcnRQb2ludC54K3JhZGl1cz49eCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHk+dGhpcy5zdGFydFBvaW50LnktcmFkaXVzICYmIHk8dGhpcy5zdGFydFBvaW50LnkrcmFkaXVzIDtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBzdGFydFggPSBNYXRoLm1pbih0aGlzLmVuZFBvaW50LngsdGhpcy5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gTWF0aC5taW4odGhpcy5lbmRQb2ludC55LHRoaXMuc3RhcnRQb2ludC55KTtcclxuICAgICAgICAgICAgdmFyIGVuZFggPSBNYXRoLm1heCh0aGlzLmVuZFBvaW50LngsdGhpcy5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgZW5kWSA9IE1hdGgubWF4KHRoaXMuZW5kUG9pbnQueSx0aGlzLnN0YXJ0UG9pbnQueSk7XHJcblxyXG4gICAgICAgICAgICAvKldlIHdpbGwgY29tcHV0ZSB0aGUgZGlzdGFuY2UgZnJvbSBwb2ludCB0byB0aGUgbGluZVxyXG4gICAgICAgICAgICAgKiBieSB1c2luZyB0aGUgYWxnb3JpdGhtIGZyb21cclxuICAgICAgICAgICAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lXHJcbiAgICAgICAgICAgICAqICovXHJcblxyXG4gICAgICAgICAgICAvL0ZpcnN0IHdlIG5lZWQgdG8gZmluZCBhLGIsYyBvZiB0aGUgbGluZSBlcXVhdGlvbiBheCArIGJ5ICsgYyA9IDBcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmVuZFBvaW50LnkgLSB0aGlzLnN0YXJ0UG9pbnQueTtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLnN0YXJ0UG9pbnQueCAtIHRoaXMuZW5kUG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIGMgPSAtKHRoaXMuc3RhcnRQb2ludC54ICogdGhpcy5lbmRQb2ludC55IC0gdGhpcy5lbmRQb2ludC54ICogdGhpcy5zdGFydFBvaW50LnkpO1xyXG5cclxuICAgICAgICAgICAgLy9TZWNvbmRseSB3ZSBnZXQgdGhlIGRpc3RhbmNlIFwiTWF0aGVtYXRpY3MgZm9yIENvbXB1dGVyIEdyYXBoaWNzLCAybmQgRWQuLCBieSBKb2huIFZpY2UsIHBhZ2UgMjI3XCJcclxuICAgICAgICAgICAgdmFyIGQgPSBNYXRoLmFicyggKGEqeCArIGIqeSArIGMpIC8gTWF0aC5zcXJ0KE1hdGgucG93KGEsMikgKyBNYXRoLnBvdyhiLDIpKSApO1xyXG5cclxuICAgICAgICAgICAgLy9UaGlyZGx5IHdlIGdldCBjb29yZGluYXRlcyBvZiBjbG9zZXN0IGxpbmUncyBwb2ludCB0byB0YXJnZXQgcG9pbnRcclxuICAgICAgICAgICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RhbmNlX2Zyb21fYV9wb2ludF90b19hX2xpbmUjQ2FydGVzaWFuX2Nvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIHZhciBjbG9zZXN0WCA9IChiICogKGIqeCAtIGEqeSkgLSBhKmMpIC8gKCBNYXRoLnBvdyhhLDIpICsgTWF0aC5wb3coYiwyKSApO1xyXG4gICAgICAgICAgICB2YXIgY2xvc2VzdFkgPSAoYSAqICgtYip4ICsgYSp5KSAtIGIqYykgLyAoIE1hdGgucG93KGEsMikgKyBNYXRoLnBvdyhiLDIpICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgciA9ICggZCA8PSByYWRpdXMgJiYgZW5kWD49Y2xvc2VzdFggJiYgY2xvc2VzdFg+PXN0YXJ0WCAmJiBlbmRZPj1jbG9zZXN0WSAmJiBjbG9zZXN0WT49c3RhcnRZICkgLy90aGUgcHJvamVjdGlvbiBvZiB0aGUgcG9pbnQgZmFsbHMgSU5TSURFIG9mIHRoZSBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICB8fCB0aGlzLnN0YXJ0UG9pbnQubmVhcih4LHkscmFkaXVzKSB8fCB0aGlzLmVuZFBvaW50Lm5lYXIoeCx5LHJhZGl1cyk7IC8vdGhlIHByb2plY3Rpb24gb2YgdGhlIHBvaW50IGZhbGxzIE9VVFNJREUgb2YgdGhlIHNlZ21lbnRcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAgcjtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgYXJyYXkgZWFjaCB0aW1lLCBvciB3ZSB3aWxsIGFmZmVjdCB0aGUgYWN0dWFsIHNoYXBlKi9cclxuICAgICAgICBnZXRQb2ludHM6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh0aGlzLnN0YXJ0UG9pbnQpO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh0aGlzLmVuZFBvaW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipSZXR1cm4gdGhlIHtQb2ludH0gY29ycmVzcG9uZGluZyB0aGUgdCBjZXJ0YWluIHQgdmFsdWVcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gdCB0aGUgdmFsdWUgb2YgcGFyYW1ldGVyIHQsIHdoZXJlIHQgaW4gWzAsMV0sIHQgaXMgbGlrZSBhIHBlcmNlbnQqL1xyXG4gICAgICAgIGdldFBvaW50OiBmdW5jdGlvbih0KXtcclxuICAgICAgICAgICAgdmFyIFhwID0gdCAqICh0aGlzLmVuZFBvaW50LnggLSB0aGlzLnN0YXJ0UG9pbnQueCkgKyB0aGlzLnN0YXJ0UG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIFlwID0gdCAqICh0aGlzLmVuZFBvaW50LnkgLSB0aGlzLnN0YXJ0UG9pbnQueSkgKyB0aGlzLnN0YXJ0UG9pbnQueTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWHAsIFlwKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyAvKipcclxuICAgICAgICAvLyAgKiBSZXR1cm5zIHRoZSBtaWRkbGUgb2YgdGhlIGxpbmVcclxuICAgICAgICAvLyAgKiBAcmV0dXJuIHtQb2ludH0gdGhlIG1pZGRsZSBwb2ludFxyXG4gICAgICAgIC8vICAqICovXHJcbiAgICAgICAgLy8gZ2V0TWlkZGxlIDogZnVuY3Rpb24oKXtcclxuICAgICAgICAvLyAgICAgcmV0dXJuIFV0aWwuZ2V0TWlkZGxlKHRoaXMuc3RhcnRQb2ludCwgdGhpcy5lbmRQb2ludCk7XHJcbiAgICAgICAgLy8gfSxcclxuXHJcblxyXG4gICAgICAgIC8vIGdldExlbmd0aCA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgLy8gICAgIHJldHVybiBVdGlsLmdldExlbmd0aCh0aGlzLnN0YXJ0UG9pbnQsIHRoaXMuZW5kUG9pbnQpO1xyXG4gICAgICAgIC8vIH0sXHJcblxyXG4gICAgICAgIC8vIC8qKlxyXG4gICAgICAgIC8vICAqR2V0IGJvdW5kcyBmb3IgdGhpcyBsaW5lXHJcbiAgICAgICAgLy8gICpAYXV0aG9yIEFsZXggR2hlb3JnaGl1IDxhbGV4QHNjcmlwdG9pZC5jb20+XHJcbiAgICAgICAgLy8gICoqL1xyXG4gICAgICAgIC8vIGdldEJvdW5kczpmdW5jdGlvbigpe1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gVXRpbC5nZXRCb3VuZHModGhpcy5nZXRQb2ludHMoKSk7XHJcbiAgICAgICAgLy8gfSxcclxuXHJcbiAgICAgICAgLyoqU3RyaW5nIHJlcHJlc2VudGF0aW9uKi9cclxuICAgICAgICB0b1N0cmluZzpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gJ2xpbmUoJyArIHRoaXMuc3RhcnRQb2ludCArICcsJyArIHRoaXMuZW5kUG9pbnQgKyAnKSc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gTGluZTtcclxuXHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTGluZVN0cnVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEJQTU7oioLngrnnsbsgIOaJgOacieeahEJQTU7lvaLnirbpg73nu6fmib/kuI7lroPvvIznlKjmiLfoh6rlrprkuYnoioLngrnlj6/ku6Xnu6fmib/lroPlubbms6jlhozljbPlj6/kvb/nlKhcclxuICogQGNsYXNzIGZpc2gudG9wby5GaXNoVG9wb0JwbW4uQlBNTk5vZGVcclxuICovXHJcblxyXG5cclxuXHR2YXIgTm9kZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvTm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblx0dmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2NsYXp6Jyk7XHJcblx0Ly/liJvlu7pOb2Rl57G7IOaJgOacieW9oueKtumDvee7p+aJv05vZGVcclxuXHRmdW5jdGlvbiBCUE1OTm9kZShtb2RlbCwgYXBpKSB7XHJcblx0XHROb2RlLmNhbGwodGhpcyk7XHJcblx0XHR0aGlzLm1vZGVsID0gbW9kZWw7XHJcblx0XHR0aGlzLm9wdGlvbnMgPVxyXG5cdFx0e1xyXG5cdFx0XHRvdXRsaW5lOiB7XHJcblx0XHRcdFx0ZW5hYmxlOiB0cnVlLCAvLyDmmK/lkKbmnInlpJbmoYZcclxuXHRcdFx0XHRyYWRpdXM6IHRydWUsIC8vIOaYr+WQpuWchuinklxyXG5cdFx0XHRcdGluaXRWaXNpYmxlOiBmYWxzZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHR0ZXh0OiB7XHJcblx0XHRcdFx0Y29sb3I6ICcjMDAwMDAwJywgLy8g5paH5pys6aKc6ImyXHJcblx0XHRcdFx0bGluZUhlaWdodDogMjQgLy8g5paH5pys6KGM6auYXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IC0xLCBuYW1lOlwiQlBNTkRpYWdyYW1cIiwgZGlzcGxheU5hbWU6XCJUYXNrXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuXHRcdHZhciByZXNvdXJjZUlkID0gbW9kZWwuZ2V0KFwicmVzb3VyY2VJZFwiKTtcclxuXHRcdGlmKHJlc291cmNlSWQgJiYgcmVzb3VyY2VJZCAhPSBcIlwiKSB7XHJcblx0XHRcdHRoaXMucmVzb3VyY2VJZCA9IHJlc291cmNlSWQ7XHJcblx0XHR9XHJcblxyXG4gICAgICAgIC8v5Yik5pat5piv5ZCm5pyJb3BlcmF0aW9uTm9kZVxyXG4gICAgICAgIHZhciBwcm9wID0gbW9kZWwuZ2V0KFwicHJvcGVydGllc1wiKTtcclxuICAgICAgICBpZiAocHJvcC5vcGVyYXRpb25JY29ucykge1xyXG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbkljb25zID0gcHJvcC5vcGVyYXRpb25JY29ucztcclxuICAgICAgICB9XHJcblx0XHR0aGlzLmluaXRFdmVudChhcGkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiB1dGY4TGVuZ3RoKHN0cikge1xyXG4gICAgICAgIHZhciBtID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikubWF0Y2goLyVbODlBQmFiXS9nKTtcclxuICAgICAgICByZXR1cm4gc3RyLmxlbmd0aCArIChtID8gbS5sZW5ndGggOiAwKTtcclxuICAgIH1cclxuXHJcbiAgICBCUE1OTm9kZS5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24oYXBpKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnZGJsY2xpY2snLCAnY2xpY2snXTsvLydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnXHJcblxyXG5cclxuICAgICAgICB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24gKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhhdC5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xyXG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuXHQgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG5cdCAgICAgICAgICAgIHBhcmFtcy50eXBlID0gZXZlTmFtZTtcclxuXHQgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhhdDtcclxuXHQgICAgICAgICAgICBhcGkudHJpZ2dlcihldmVOYW1lLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5blvZPliY3oioLngrnnmoTljIXlm7Tlkowg55u45YWz5Y+C5pWwXHJcbiAgICAgKiBAcmV0dXJucyB7e3g6TnVtYmVyLCB5Ok51bWJlciwgd2lkdGg6TnVtYmVyLCBoZWlnaHQ6TnVtYmVyLCBwb2ludHM6QXJyYXksIGJvdW5kaW5nUmVjdDpPYmplY3R9fVxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gcmV0dXJuLngg5b2T5YmN6IqC54K555qE5Lit5b+D54K5eOWAvFxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gcmV0dXJuLnkg5b2T5YmN6IqC54K555qE5Lit5b+D54K5eeWAvFxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gcmV0dXJuLndpZHRoIOW9k+WJjeiKgueCueeahOWuveW6plxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gcmV0dXJuLmhlaWdodCDlvZPliY3oioLngrnnmoTpq5jluqZcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcmV0dXJuLnBvaW50cyDlvZPliY3oioLngrnnmoTljIXlm7TlkowgW+W3puS4iuinkuWdkOagh++8jOWPs+S4iuinkuWdkOagh++8jOWPs+S4i+inkuWdkOagh++8jOWPs+S4i+inkuWdkOagh10g55So5LqO6IqC54K56YCJ5Lit5pe25YyF5Zu06Jma57q/5qGGXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZXR1cm4uYm91bmRpbmdSZWN0IOW9k+WJjeiKgueCueeahOWMheWbtOefqeW9olxyXG4gICAgICovXHJcbiAgICBCUE1OTm9kZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOi/lOWbnuW9k+WJjeiKgueCueeahOWMheWbtOefqeW9olxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSDlvZPliY3oioLngrnnmoTljIXlm7Tnn6nlvaIgIOS4gOiIrOS4jeWMheaLrOS4i+mdoueahOaWh+Wtl1xyXG4gICAgICovXHJcbiAgICBCUE1OTm9kZS5wcm90b3R5cGUuZ2V0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u5Zu+5YWD55qE5L2N572uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCB45Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB55Z2Q5qCHXHJcbiAgICAgKi9cclxuICAgIEJQTU5Ob2RlLnByb3RvdHlwZS5zZXRQb3NpdGlvbiAgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOafpeeci+W9k+WJjeiKgueCueaYr+WQpiDljIXmi6x4ICx5IOWdkOagh1xyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB4IHjlnZDmoIdcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0geSB55Z2Q5qCHXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgIOaYr+WQpuWcqOiMg+WbtOWGhVxyXG4gICAgICovXHJcbiAgICBCUE1OTm9kZS5wcm90b3R5cGUucmVjdENvbnRhaW4gPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICBcdHZhciByZWN0ID0gdGhpcy5nZXRSZWN0KCk7XHJcbiAgICAgICAgcmV0dXJuIHJlY3QuYm91bmRpbmdSZWN0LmNvbnRhaW4oeCx5KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDov5Tlm55qc29u5a+56LGhXHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGpzb27lr7nosaFcclxuICAgICAqL1xyXG5cdEJQTU5Ob2RlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMubW9kZWwuc2V0KFwicmVzb3VyY2VJZFwiLCB0aGlzLnJlc291cmNlSWQpO1xyXG5cdFx0dGhpcy5tb2RlbC5zZXQoXCJwcm9wZXJ0aWVzLnR5cGVcIiwgdGhpcy5icG1uSW5mby50eXBlKTtcclxuXHRcdHRoaXMubW9kZWwuc2V0KFwic3RlbmNpbC50eXBlXCIsIHRoaXMuYnBtbkluZm8ubmFtZSk7ICAvL3N0ZW5jaWwuaWRcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc2xvdEV2ZW50ICYmIHRoaXMuc2xvdEV2ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGFyclNsb3RFdmVudCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5zbG90RXZlbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGFyclNsb3RFdmVudC5wdXNoKHRoaXMuc2xvdEV2ZW50W2ldLnJlc291cmNlSWQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJwcm9wZXJ0aWVzLnNsb3RFdmVudFwiLCBhcnJTbG90RXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInByb3BlcnRpZXMudHlwZVwiLCB0aGlzLmJwbW5JbmZvLnR5cGUpO1xyXG5cclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0UmVjdCgpLmJvdW5kaW5nUmVjdDtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImJvdW5kcy51cHBlckxlZnQueFwiLCBwYXJzZUludChyZWN0LngpKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImJvdW5kcy51cHBlckxlZnQueVwiLCBwYXJzZUludChyZWN0LnkpKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImJvdW5kcy5sb3dlclJpZ2h0LnhcIiwgcGFyc2VJbnQocmVjdC54ICsgcmVjdC53aWR0aCkpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLmxvd2VyUmlnaHQueVwiLCBwYXJzZUludChyZWN0LnkgKyByZWN0LmhlaWdodCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMubW9kZWwub3B0aW9uO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOagueaNruWxnuaAp+iuvue9ruaooeWei+aVsOaNrlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbiDmqKHlnovmlbDmja5cclxuICAgICAqL1xyXG4gICAgQlBNTk5vZGUucHJvdG90eXBlLnNldE1vZGVsID0gZnVuY3Rpb24ob3B0aW9uKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLCBwb3M7XHJcbiAgICAgICAgdmFyIG9yaWdpblRleHQgPSB0aGlzLm1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKTtcclxuICAgICAgICB0aGlzLm1vZGVsLm1lcmdlT3B0aW9uKG9wdGlvbik7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudFgobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQubm9kZVR5cGUgPT0gXCJTdWJQcm9jZXNzXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzBdICsgcGFyZW50WChub2RlLnBhcmVudClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzBdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBmdW5jdGlvbiBwYXJlbnRZKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50Lm5vZGVUeXBlID09IFwiU3ViUHJvY2Vzc1wiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblsxXSArIHBhcmVudFkobm9kZS5wYXJlbnQpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvblsxXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZighb3B0aW9uLnByb3BlcnRpZXMubmFtZSAmJiBvcHRpb24ucHJvcGVydGllcy5uYW1lICE9ICcnICYmIG9wdGlvbi5wcm9wZXJ0aWVzLm5hbWUgIT0gJzAnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYob3JpZ2luVGV4dCAhPSBvcHRpb24ucHJvcGVydGllcy5uYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IHRoaXMuY2hpbGRPZk5hbWUoXCJUaXRsZVwiKTtcclxuICAgICAgICAgICAgdmFyIG5hbWVCeXRlTGVuZ3RoID0gdXRmOExlbmd0aChvcHRpb24ucHJvcGVydGllcy5uYW1lKTtcclxuICAgICAgICAgICAgdmFyIHNob3dOYW1lO1xyXG4gICAgICAgICAgICBpZihuYW1lQnl0ZUxlbmd0aCA+IDE1KXtcclxuICAgICAgICAgICAgICAgIHNob3dOYW1lID0gb3B0aW9uLnByb3BlcnRpZXMubmFtZS5zdWJzdHIoMCw2KSsnLi4nO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5hbGFybSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGFybS5pc1Nob3cgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHNob3dOYW1lID0gb3B0aW9uLnByb3BlcnRpZXMubmFtZTtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuYWxhcm0pe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxhcm0uaXNTaG93ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRpdGxlLmF0dHIoXCJzdHlsZVwiLHt0ZXh0OnNob3dOYW1lfSk7XHJcbiAgICAgICAgICAgIHBvcyA9IG9wdGlvbi5wcm9wZXJ0aWVzLnBvc2l0aW9uID8gb3B0aW9uLnByb3BlcnRpZXMucG9zaXRpb24gOiAnaW5pdCc7XHJcbiAgICAgICAgICAgIHRoYXQucmVmcmVzaFRleHQocG9zKTtcclxuICAgICAgICAgICBpZih0aGlzLmFsYXJtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG9wdGlvbi5wcm9wZXJ0aWVzLm5hbWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuYWxhcm0uY2hpbGRPZk5hbWUoXCJUZXh0XCIpO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5hdHRyKFwic3R5bGVcIix7dGV4dDpuYW1lfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBXaWR0aCA9IHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGgrNDtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cEhlaWdodCA9IHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0Kzg7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIFswLDBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLDBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICBbZ3JvdXBXaWR0aC0zLGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICBbZ3JvdXBXaWR0aC02LGdyb3VwSGVpZ2h0KzNdLFxyXG4gICAgICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLTksZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgIFswLGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICBbMCwwXVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIHZhciBQb2x5bGluZSA9IHRoaXMuYWxhcm0uY2hpbGRPZk5hbWUoXCJQb2x5bGluZVwiKTtcclxuICAgICAgICAgICAgICAgIFBvbHlsaW5lLmF0dHIoXCJzaGFwZVwiLHtwb2ludHM6cG9pbnRzfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zWCA9IHBhcmVudFgodGhpcyksIHBvc1kgPSBwYXJlbnRZKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwUG9zaXRpb24gPSBbcG9zWCArIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLSAodGhpcy5hbGFybS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aC02KSwgcG9zWSAtIHRoaXMuYWxhcm0uZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC0gM107XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsYXJtLmF0dHIoXCJwb3NpdGlvblwiLGdyb3VwUG9zaXRpb24pO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcblx0enJVdGlsLmluaGVyaXRzKEJQTU5Ob2RlLE5vZGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5rOo5YaMQlBNTuiKgueCueeahOexu++8jOWPquacieazqOWGjOi/h+WQju+8jOaJjeiDveWcqEJQTU7nvJbovpHlmajkuK3mt7vliqBcclxuICAgICAqIEBtZXRob2QgcmVnaXN0ZXJDbGFzc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IENsYXp6IOe7p+aJv+S6hkJQTU5Ob2Rl55qE5a6e546w57G7XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50VHlwZSDms6jlhoznsbvnmoTlkI3np7BcclxuICAgICAqXHJcbiAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhDdXN0b21Ob2RlLCBcIkN1c3RvbU5vZGVcIik7XHJcbiAgICAgKi9cclxuXHRjbGF6elV0aWwuZW5hYmxlQ2xhc3NNYW5hZ2VtZW50KEJQTU5Ob2RlLCB7XHJcbiAgICAgICAgcmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlXHJcbiAgICB9KTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IEJQTU5Ob2RlO1xyXG5cclxuXHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9CUE1OTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4vZ3JhcGhpYycpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpXHJcbiAgICAvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZSAg5YyF5ousZnJvbUpTT04gdG9KU09OXHJcbiAgICBmdW5jdGlvbiBOb2RlKCkge1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VJZCA9IHV0aWwuZ2V0VVVJRCgpOyAvLyDnlJ/miJDoioLngrlJRFxyXG4gICAgICAgIGdyYXBoaWMuR3JvdXAuY2FsbCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUseeItuexu+WunueOsFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlLHniLbnsbvlrp7njrBcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0ganNvbiBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24oanNvbikge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkcmF3VGV4dFxyXG4gICAgICogQGRlc2NyaXB0aW9uIOeUu+S4gOS4quaWh+acrFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS5kcmF3VGV4dCA9IGZ1bmN0aW9uKG5hbWUsIGNvbG9yLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciB0ZXh0TmFtZSA9IHRoaXMuYnBtbkluZm8ubmFtZSwgeCwgeTtcclxuICAgICAgICBpZihuYW1lICE9IG51bGwpe1xyXG4gICAgICAgICAgICB0ZXh0TmFtZSA9IG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0TmFtZSxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvciA/IGNvbG9yIDogdGhpcy5vcHRpb25zLnRleHQuY29sb3IsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzEycHggTWljcm9zb2Z0IFlhSGVpJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6bGV2ZWw6IDIwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy/mloflrZfnu5jliLbnmoTkvY3nva4gXHJcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA/IHBvc2l0aW9uIDogJ2luaXQnO1xyXG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcclxuICAgICAgICAgICAgLy/oioLngrnkuIvmlrnlsYXkuK3kvY3nva5cclxuICAgICAgICAgICAgY2FzZSAnaW5pdCc6IFxyXG4gICAgICAgICAgICAgICAgLy94ID0g5Lit5b+D54K5LnggLSDotbflp4vkvY3nva4ueCAtIOaWh+Wtl+WuveW6pueahOS4gOWNilxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0UmVjdCgpLnggLSB0aGlzLnBvc2l0aW9uWzBdIC0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAvL3kgPSDkuK3lv4PngrkueSAtIOi1t+Wni+S9jee9ri55ICsg5YGP56e75YC877yINu+8iVxyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2V0UmVjdCgpLnkgLSB0aGlzLnBvc2l0aW9uWzFdICsgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyICsgNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvL+iKgueCueWGhemDqOWxheS4reS9jee9rlxyXG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0UmVjdCgpLnggLSB0aGlzLnBvc2l0aW9uWzBdIC0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRSZWN0KCkueSAtIHRoaXMucG9zaXRpb25bMV0gLSA2O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIC8v6IqC54K55YaF6YOo5bGF5bem5L2N572uXHJcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOiBcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLmdldFJlY3QoKS54IC0gdGhpcy5wb3NpdGlvblswXSAtIHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggKyA2O1xyXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2V0UmVjdCgpLnkgLSB0aGlzLnBvc2l0aW9uWzFdIC0gNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OiBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dC5hdHRyKFwic3R5bGVcIiwgeyB4OiB4LCB5OiB5IH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgICAgIHJlY3Q6IHRleHQuZ2V0Qm91bmRpbmdSZWN0KClcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogcmVmcmVzaFRleHRcclxuICAgICAqIEBkZXNjcmlwdGlvbiDliLfmlrDmlofmnKxcclxuICAgICAqL1xyXG4gICAgTm9kZS5wcm90b3R5cGUucmVmcmVzaFRleHQgPSBmdW5jdGlvbihwb3MpIHtcclxuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJUaXRsZVwiKSwgeCwgeTtcclxuICAgICAgICBwb3MgPSBwb3MgPyBwb3MgOiAnaW5pdCc7XHJcbiAgICAgICAgc3dpdGNoIChwb3MpIHtcclxuICAgICAgICAgICAgY2FzZSAnaW5pdCc6IFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0UmVjdCgpLnggLSB0aGlzLnBvc2l0aW9uWzBdIC0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRSZWN0KCkueSAtIHRoaXMucG9zaXRpb25bMV0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAvIDIgKyA2O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5nZXRSZWN0KCkueCAtIHRoaXMucG9zaXRpb25bMF0gLSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLmdldFJlY3QoKS55IC0gdGhpcy5wb3NpdGlvblsxXSAtIDY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICB4ID0gMjtcclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLmdldFJlY3QoKS55IC0gdGhpcy5wb3NpdGlvblsxXSAtIDY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDogYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHQuYXR0cihcInN0eWxlXCIsIHsgeDogeCwgeTogeSB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOeUseeItuexu+WunueOsFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgZ3JhcGhpYy5VdGlsLmluaGVyaXRzKE5vZGUsIGdyYXBoaWMuR3JvdXApO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHJcbiAgICB2YXIgY2xhenogPSB7fTtcclxuXHJcbiAgICB2YXIgVFlQRV9ERUxJTUlURVIgPSAnLic7XHJcbiAgICB2YXIgSVNfQ09OVEFJTkVSID0gJ19fX0ZUX19DT01QT05FTlRfX0NPTlRBSU5FUl9fXyc7XHJcbiAgICAvKipcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgdmFyIHBhcnNlQ2xhc3NUeXBlID0gY2xhenoucGFyc2VDbGFzc1R5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgIHZhciByZXQgPSB7bWFpbjogJycsIHN1YjogJyd9O1xyXG4gICAgICAgIGlmIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBjb21wb25lbnRUeXBlLnNwbGl0KFRZUEVfREVMSU1JVEVSKTtcclxuICAgICAgICAgICAgcmV0Lm1haW4gPSBjb21wb25lbnRUeXBlWzBdIHx8ICcnO1xyXG4gICAgICAgICAgICByZXQuc3ViID0gY29tcG9uZW50VHlwZVsxXSB8fCAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwdWJsaWMgIOebuOavlCDnm7TmjqXnlKh6clV0aWwuaW5oZXJpdHMg5aW95aSE5pivICDlj6/ku6Xnm7TmjqXosIPnlKjniLbnsbvnmoTmnoTpgKDlh73mlbBcclxuICAgICAqL1xyXG4gICAgY2xhenouZW5hYmxlQ2xhc3NFeHRlbmQgPSBmdW5jdGlvbiAoUm9vdENsYXNzLCBwcmVDb25zdHJ1Y3QpIHtcclxuICAgICAgICBSb290Q2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3RvKSB7XHJcbiAgICAgICAgICAgIHZhciBFeHRlbmRlZENsYXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcHJlQ29uc3RydWN0ICYmIHByZUNvbnN0cnVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgUm9vdENsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB6clV0aWwuZXh0ZW5kKEV4dGVuZGVkQ2xhc3MucHJvdG90eXBlLCBwcm90byk7XHJcblxyXG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLmV4dGVuZCA9IHRoaXMuZXh0ZW5kO1xyXG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLnN1cGVyQ2FsbCA9IHN1cGVyQ2FsbDtcclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckFwcGx5ID0gc3VwZXJBcHBseTtcclxuICAgICAgICAgICAgenJVdGlsLmluaGVyaXRzKEV4dGVuZGVkQ2xhc3MsIHRoaXMpO1xyXG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLnN1cGVyQ2xhc3MgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIEV4dGVuZGVkQ2xhc3M7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gc3VwZXJDYWxsIHNob3VsZCBoYXZlIGNsYXNzIGluZm8sIHdoaWNoIGNhbiBub3QgYmUgZmV0Y2ggZnJvbSAndGhpcycuXHJcbiAgICAvLyBDb25zaWRlciB0aGlzIGNhc2U6XHJcbiAgICAvLyBjbGFzcyBBIGhhcyBtZXRob2QgZixcclxuICAgIC8vIGNsYXNzIEIgaW5oZXJpdHMgY2xhc3MgQSwgb3ZlcnJpZGVzIG1ldGhvZCBmLCBmIGNhbGwgc3VwZXJBcHBseSgnZicpLFxyXG4gICAgLy8gY2xhc3MgQyBpbmhlcml0cyBjbGFzcyBCLCBkbyBub3Qgb3ZlcnJpZGVzIG1ldGhvZCBmLFxyXG4gICAgLy8gdGhlbiB3aGVuIG1ldGhvZCBvZiBjbGFzcyBDIGlzIGNhbGxlZCwgZGVhZCBsb29wIG9jY3VyZWQuXHJcbiAgICBmdW5jdGlvbiBzdXBlckNhbGwoY29udGV4dCwgbWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHZhciBhcmdzID0genJVdGlsLnNsaWNlKGFyZ3VtZW50cywgMik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3VwZXJBcHBseShjb250ZXh0LCBtZXRob2ROYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW50aXR5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWdpc3RlcldoZW5FeHRlbmRdXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGNsYXp6LmVuYWJsZUNsYXNzTWFuYWdlbWVudCA9IGZ1bmN0aW9uIChlbnRpdHksIG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29tcG9uZW50IG1vZGVsIGNsYXNzZXNcclxuICAgICAgICAgKiBrZXk6IGNvbXBvbmVudFR5cGUsXHJcbiAgICAgICAgICogdmFsdWU6XHJcbiAgICAgICAgICogICAgIGNvbXBvbmVudENsYXNzLCB3aGVuIGNvbXBvbmVudFR5cGUgaXMgJ3h4eCdcclxuICAgICAgICAgKiAgICAgb3IgT2JqZWN0LjxzdWJLZXksIGNvbXBvbmVudENsYXNzPiwgd2hlbiBjb21wb25lbnRUeXBlIGlzICd4eHgueXknXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgc3RvcmFnZSA9IHt9O1xyXG5cclxuICAgICAgICBlbnRpdHkucmVnaXN0ZXJDbGFzcyA9IGZ1bmN0aW9uIChDbGF6eiwgY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50VHlwZS5zdWIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5bey57uP5rOo5YaM6L+H5LqG77yM55u05o6l6L+U5ZueXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dID0gQ2xheno7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnRUeXBlLnN1YiAhPT0gSVNfQ09OVEFJTkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG1ha2VDb250YWluZXIoY29tcG9uZW50VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyW2NvbXBvbmVudFR5cGUuc3ViXSA9IENsYXp6O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBDbGF6ejtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZU1haW4sIHN1YlR5cGUsIHRocm93V2hlbk5vdEZvdW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBDbGF6eiA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZU1haW5dO1xyXG5cclxuICAgICAgICAgICAgaWYgKENsYXp6ICYmIENsYXp6W0lTX0NPTlRBSU5FUl0pIHtcclxuICAgICAgICAgICAgICAgIENsYXp6ID0gc3ViVHlwZSA/IENsYXp6W3N1YlR5cGVdIDogbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRocm93V2hlbk5vdEZvdW5kICYmICFDbGF6eikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICdDb21wb25lbnQgJyArIGNvbXBvbmVudFR5cGVNYWluICsgJy4nICsgKHN1YlR5cGUgfHwgJycpICsgJyBub3QgZXhpc3RzLiBMb2FkIGl0IGZpcnN0LidcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBDbGF6ejtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkuZ2V0Q2xhc3Nlc0J5TWFpblR5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgIHZhciBvYmogPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XHJcblxyXG4gICAgICAgICAgICBpZiAob2JqICYmIG9ialtJU19DT05UQUlORVJdKSB7XHJcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChvYmosIGZ1bmN0aW9uIChvLCB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gSVNfQ09OVEFJTkVSICYmIHJlc3VsdC5wdXNoKG8pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmopO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGVudGl0eS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIC8vIEp1c3QgY29uc2lkZXIgY29tcG9uZW50VHlwZS5tYWluLlxyXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybiAhIXN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gTGlrZSBbJ2FhJywgJ2JiJ10sIGJ1dCBjYW4gbm90IGJlIFsnYWEueHgnXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVudGl0eS5nZXRBbGxDbGFzc01haW5UeXBlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGVzID0gW107XHJcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHN0b3JhZ2UsIGZ1bmN0aW9uIChvYmosIHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2godHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgYSBtYWluIHR5cGUgaXMgY29udGFpbmVyIGFuZCBoYXMgc3ViIHR5cGVzXHJcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSAgY29tcG9uZW50VHlwZVxyXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW50aXR5Lmhhc1N1YlR5cGVzID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIG9ialtJU19DT05UQUlORVJdO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGVudGl0eS5wYXJzZUNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBtYWtlQ29udGFpbmVyKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcclxuICAgICAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lcltJU19DT05UQUlORVJdKSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl0gPSB7fTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcltJU19DT05UQUlORVJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMucmVnaXN0ZXJXaGVuRXh0ZW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEV4dGVuZCA9IGVudGl0eS5leHRlbmQ7XHJcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEV4dGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBFeHRlbmRlZENsYXNzID0gb3JpZ2luYWxFeHRlbmQuY2FsbCh0aGlzLCBwcm90byk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudGl0eS5yZWdpc3RlckNsYXNzKEV4dGVuZGVkQ2xhc3MsIHByb3RvLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjbGF6ejtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9jbGF6ei5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEJQTU4gbW9kZWxcclxuICpcclxuICovXHJcblxyXG5cclxuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9tb2RlbCcpO1xyXG4gICAgdmFyIEJQTU5Nb2RlbCA9IE1vZGVsLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdCUE1OJyxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XHJcbiAgICAgICAgICAgIHJlc291cmNlSWQ6IFwiXCIsICAvL+i1hOa6kElEXHJcblxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAtMSwgIC8v57G75Z6LXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBudWxsLCAvL+WQjeensFxyXG4gICAgICAgICAgICAgICAgbm90ZXM6IFwiXCIsICAvL+Wkh+azqFxyXG4gICAgICAgICAgICAgICAgLy9ubzogXCJcIlxyXG4gICAgICAgICAgICAgICAgZXh0UHJvcGVydGllczoge30gIC8v5omp5bGV5bGe5oCnXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzdGVuY2lsOiB7dHlwZTogXCJCUE1ORGlhZ3JhbVwifSxcclxuXHJcbiAgICAgICAgICAgIGNoaWxkU2hhcGVzOiBbXSwgICAgLy/lrZDlvaLnirZcclxuXHJcbiAgICAgICAgICAgIG91dGdvaW5nOiBbXSwgIC8vIOS4i+S4gOS4quimgei/nuaOpeeahOW9oueKtlxyXG5cclxuICAgICAgICAgICAgYm91bmRzOiB7XHJcbiAgICAgICAgICAgICAgICB1cHBlckxlZnQ6IHt4OjAsIHk6MH0sICAvL+W3puS4iuinkuWdkOagh1xyXG4gICAgICAgICAgICAgICAgbG93ZXJSaWdodDoge3g6MCwgeTowfSAvL+WPs+S4i+inkuWdkOagh1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJQTU5Nb2RlbDtcclxuXHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbW9kZWwvQlBNTk1vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog6IqC54K5562J55qE5qih5Z6LXHJcbiAqIOmHjOmdouWtmOeahOaVsOaNrueUqOadpeWkhOeQhuW6j+WIl+WMluWSjOWPjeW6j+WIl+WMllxyXG4gKiBAY2xhc3MgZmlzaC50b3BvLm1vZGVsXHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi9jbGF6eicpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1vZGVsKG9wdGlvbiwgcGFyZW50TW9kZWwsICBleHRyYU9wdCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50TW9kZWwgPSBwYXJlbnRNb2RlbDtcclxuICAgICAgICB0aGlzLm9wdGlvbiA9IG9wdGlvbjtcclxuXHJcbiAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxyXG4gICAgICAgIGlmICh0aGlzLmluaXQpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KG9wdGlvbiwgcGFyZW50TW9kZWwsICBleHRyYU9wdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBNb2RlbC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBNb2RlbCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTW9kZWwg55qE5Yid5aeL5YyW5Ye95pWwXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGlzLmdldERlZmF1bHRPcHRpb24oKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0RGVmYXVsdE9wdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ19fZGVmYXVsdE9wdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0TGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIENsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBDbGFzcy5wcm90b3R5cGUuZGVmYXVsdE9wdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBvcHQgJiYgb3B0TGlzdC5wdXNoKG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBDbGFzcy5zdXBlckNsYXNzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0T3B0aW9uID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb3B0TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb24gPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbiwgb3B0TGlzdFtpXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGVmYXVsdE9wdGlvbiA9IGRlZmF1bHRPcHRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kZWZhdWx0T3B0aW9uO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICAgICAgenJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBvcHRpb24sIHRydWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPlm1vZGVs55qE5p+Q5Liq5bGe5oCn55qE5YC8XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggbW9kZWzkuK3nmoTlsZ7mgKdcclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAgICAgbm9kZS5tb2RlbC5nZXQoXCJvcHRpb25zLnRleHRcIik7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAocGF0aCwgaWdub3JlUGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghcGF0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5vcHRpb247XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRNb2RlbCA9IHRoaXMucGFyZW50TW9kZWw7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gb2JqIGNvdWxkIGJlIG51bWJlci9zdHJpbmcvLi4uIChsaWtlIDApXHJcbiAgICAgICAgICAgICAgICBvYmogPSAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSA/IG9ialtwYXRoW2ldXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2JqID09IG51bGwgJiYgcGFyZW50TW9kZWwgJiYgIWlnbm9yZVBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgb2JqID0gcGFyZW50TW9kZWwuZ2V0KHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6K6+572ubW9kZWznmoTmn5DkuKrlsZ7mgKfnmoTlgLxcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBtb2RlbOS4reeahOWxnuaAp1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSDmiYDpnIDopoHorr7nva7nmoTlgLxcclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAgICAgbm9kZS5tb2RlbC5zZXQoXCJvcHRpb25zLnRleHRcIixcIuS+i+WtkFwiKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXRoLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5vcHRpb247XHJcblxyXG4gICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKFwiLlwiKSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgb2JqW3BhdGhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRBcnJheSAgPSBwYXRoLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGZpZWxkQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRSZWYgPSBvYmo7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGROYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkQXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudFJlZltmaWVsZE5hbWVdID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlZltmaWVsZE5hbWVdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZWYgPSBjdXJyZW50UmVmW2ZpZWxkTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSBmaWVsZEFycmF5W24tMV07XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVmW2ZpZWxkTmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0U2hhbGxvdzogZnVuY3Rpb24gKGtleSwgaWdub3JlUGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IG9wdGlvbiAmJiBvcHRpb25ba2V5XTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudE1vZGVsID0gdGhpcy5wYXJlbnRNb2RlbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsICYmIHBhcmVudE1vZGVsICYmICFpZ25vcmVQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IHBhcmVudE1vZGVsLmdldFNoYWxsb3coa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0TW9kZWw6IGZ1bmN0aW9uIChwYXRoLCBwYXJlbnRNb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXQocGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciB0aGlzUGFyZW50TW9kZWwgPSB0aGlzLnBhcmVudE1vZGVsO1xyXG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoXHJcbiAgICAgICAgICAgICAgICBvYmosIHBhcmVudE1vZGVsIHx8ICh0aGlzUGFyZW50TW9kZWwgJiYgdGhpc1BhcmVudE1vZGVsLmdldE1vZGVsKHBhdGgpKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kZWw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICrmuIXnqbptb2RlbOeahG9wdGlvblxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb24gPT0gbnVsbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge30sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIEN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoenJVdGlsLmNsb25lKHRoaXMub3B0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFbmFibGUgTW9kZWwuZXh0ZW5kLlxyXG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKE1vZGVsKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHR2YXIgRXZlbnROb2RlID0gcmVxdWlyZShcIi4vRXZlbnROb2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG5cclxuXHRmdW5jdGlvbiBTdGFydEV2ZW50Tm9kZShtb2RlbCwgYXBpKSB7XHJcblx0XHRFdmVudE5vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMjA7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAyOSwgbmFtZTpcIlN0YXJ0Tm9uZUV2ZW50XCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcblx0fVxyXG5cclxuICAgIFN0YXJ0RXZlbnROb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciBjaXJjbGUgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgIHI6IHRoaXMuaXRlbVNpemVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaXJjbGUubmFtZSA9IFwiQ2lyY2xlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQoY2lyY2xlKTtcclxuICAgICAgICB2YXIgY2lyY2xlMSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZS0yXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejoyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlMS5uYW1lID0gXCJDaXJjbGUxXCI7XHJcbiAgICAgICAgdGhpcy5hZGQoY2lyY2xlMSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikgKyB0aGlzLml0ZW1TaXplLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIikgKyB0aGlzLml0ZW1TaXplXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAgICAgICAgdGl0bGUudGV4dC5uYW1lID0gXCJUaXRsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHRpdGxlLnRleHQpO1xyXG5cclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhTdGFydEV2ZW50Tm9kZSwgRXZlbnROb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IFN0YXJ0RXZlbnROb2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZXZlbnQvU3RhcnRFdmVudE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4gICAgdmFyIEJQTU5Ob2RlID0gcmVxdWlyZShcIi4uL0JQTU5Ob2RlXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcbiAgICAvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZSAg5YyF5ousZnJvbUpTT04gdG9KU09OXHJcbiAgICAvL1xyXG4gICAgZnVuY3Rpb24gRXZlbnROb2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIEJQTU5Ob2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5icG1uSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTpcIkV2ZW50Tm9kZVwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBFdmVudE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIEV2ZW50Tm9kZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGJvZHkuLi5cclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHpyVXRpbC5jbG9uZShyZWN0KTtcclxuICAgICAgICAvLyDlj5bmlbRcclxuICAgICAgICBib3VuZGluZ1JlY3QueCA9IHBhcnNlSW50KGJvdW5kaW5nUmVjdC54LCAxMCk7XHJcbiAgICAgICAgYm91bmRpbmdSZWN0LnkgPSBwYXJzZUludChib3VuZGluZ1JlY3QueSwgMTApO1xyXG4gICAgICAgIGJvdW5kaW5nUmVjdC53aWR0aCA9IHBhcnNlSW50KGJvdW5kaW5nUmVjdC53aWR0aCwgMTApO1xyXG4gICAgICAgIGJvdW5kaW5nUmVjdC5oZWlnaHQgPSBwYXJzZUludChib3VuZGluZ1JlY3QuaGVpZ2h0LCAxMCk7XHJcbiAgICAgICAgLy/liJvlu7rmnIDlsI/ljIXlm7Tnm5LomZrnur9cclxuICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgcG9pbnRzWzBdID1bLWJvdW5kaW5nUmVjdC53aWR0aC8yLC1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1sxXSA9W2JvdW5kaW5nUmVjdC53aWR0aC8yLC1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1syXSA9W2JvdW5kaW5nUmVjdC53aWR0aC8yLGJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzNdID1bLWJvdW5kaW5nUmVjdC53aWR0aC8yLGJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzRdID1bLWJvdW5kaW5nUmVjdC53aWR0aC8yLC1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG5cclxuICAgICAgICAvL+azqDog5Zug5LqL5Lu25Li65ZyG5b2iICDmiYDku6UgeCB5IOS4uuWchuW/g+eahOS9jee9riAg5YyF5Zu055+p5b2i6KaB5YeP5Y675a695bqm5LiA5Y2KXHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSAtIGJvdW5kaW5nUmVjdC53aWR0aC8yICxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdIC0gYm91bmRpbmdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nUmVjdC53aWR0aCwgYm91bmRpbmdSZWN0LmhlaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogdGhpcy5wb3NpdGlvblswXSxcclxuICAgICAgICAgICAgeTogdGhpcy5wb3NpdGlvblsxXSxcclxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ1JlY3QuaGVpZ2h0LFxyXG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICAgICAgYm91bmRpbmdSZWN0OiBib3VuZFJlY3RcclxuICAgICAgICB9O1xyXG5cclxuICAgIH07XHJcbiAgICBFdmVudE5vZGUucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocFgscFkpIHtcclxuICAgICAgICAvLyBib2R5Li4uXHJcbiAgICAgICAgdGhpcy5hdHRyKCdwb3NpdGlvbicsW3BYLHBZXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEV2ZW50Tm9kZS5wcm90b3R5cGUuZ2V0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IHRoaXMuY2hpbGRPZk5hbWUoXCJDaXJjbGVcIik7XHJcbiAgICAgICAgcmV0dXJuIGNpcmNsZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgIH07XHJcblxyXG4gICAgRXZlbnROb2RlLnByb3RvdHlwZS51cGRhdGVTaGFwZSA9IGZ1bmN0aW9uKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IHRoaXMuY2hpbGRPZk5hbWUoXCJDaXJjbGVcIik7XHJcbiAgICAgICAgdmFyIGNpcmNsZTEgPSB0aGlzLmNoaWxkT2ZOYW1lKFwiQ2lyY2xlMVwiKTtcclxuICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gY2lyY2xlLnNoYXBlO1xyXG4gICAgICAgIHZhciBzaGFwZTEgPSBjaXJjbGUxLnNoYXBlO1xyXG4gICAgICAgIHZhciBuZXdSID0gTnVtYmVyKHNoYXBlLnIgKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICB2YXIgbmV3UjEgPSBOdW1iZXIoc2hhcGUxLnIgKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICBuZXdSID0gcGFyc2VJbnQobmV3UiwgMTApO1xyXG4gICAgICAgICAgICBuZXdSMSA9IHBhcnNlSW50KG5ld1IxLCAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNpcmNsZS5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgIHI6IG5ld1JcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaXJjbGUxLnNldFNoYXBlKHtcclxuICAgICAgICAgICAgcjogbmV3UjFcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhFdmVudE5vZGUsQlBNTk5vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudE5vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9FdmVudE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cdHZhciBFdmVudE5vZGUgPSByZXF1aXJlKFwiLi9FdmVudE5vZGVcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcblxyXG5cdGZ1bmN0aW9uIEVuZEV2ZW50Tm9kZShtb2RlbCwgYXBpKSB7XHJcbiAgICAgICAgRXZlbnROb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMjA7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAzMSwgbmFtZTpcIkVuZE5vbmVFdmVudFwiIH07XHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBFbmRFdmVudE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyMwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNpcmNsZS5uYW1lID0gXCJDaXJjbGVcIjtcclxuICAgICAgICB0aGlzLmFkZChjaXJjbGUpO1xyXG4gICAgICAgIHZhciBjaXJjbGUxID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgICAgICByOiB0aGlzLml0ZW1TaXplLTVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaXJjbGUxLm5hbWUgPSBcIkNpcmNsZTFcIjtcclxuICAgICAgICB0aGlzLmFkZChjaXJjbGUxKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSArIHRoaXMuaXRlbVNpemUsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKSArIHRoaXMuaXRlbVNpemVdO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcblxyXG4gICAgfTtcclxuXHJcblx0enJVdGlsLmluaGVyaXRzKEVuZEV2ZW50Tm9kZSwgRXZlbnROb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IEVuZEV2ZW50Tm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2V2ZW50L0VuZEV2ZW50Tm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcblx0dmFyIFRhc2tOb2RlID0gcmVxdWlyZShcIi4vVGFza05vZGUuanNcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbi8qKlxyXG4gKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBtaW5pbXVtU2l6ZT1cIjg1IDU1XCIgaWQ9XCJzaWQtOEExQ0RBMjEtOUNEMC00OEVDLUI0OUQtNjQ0NzRFRURFRjZEXCIgdGl0bGU9XCJVc2VyIHRhc2tcIj5cclxuICogICA8cmVjdCBpZD1cInNpZC04QTFDREEyMS05Q0QwLTQ4RUMtQjQ5RC02NDQ3NEVFREVGNkR0ZXh0X2ZyYW1lXCIgYW5jaG9ycz1cImJvdHRvbSB0b3AgcmlnaHQgbGVmdFwiIHg9XCIxLjAwMDAwMDA1OTgzNzc1NVwiIHk9XCIxLjAxNjIwMjQ5MjRcIiB3aWR0aD1cIjcyXCIgaGVpZ2h0PVwiMjIuMDAwMDAwMDAwMDAwMDA0XCIgcng9XCI3XCIgcnk9XCI3XCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiPlxyXG4gKiAgIDwvcmVjdD5cclxuICogICA8cmVjdCBpZD1cInNpZC04QTFDREEyMS05Q0QwLTQ4RUMtQjQ5RC02NDQ3NEVFREVGNkRiZ19mcmFtZVwiIHJlc2l6ZT1cInZlcnRpY2FsIGhvcml6b250YWxcIiB4PVwiNS45ODM3NzU0OWUtOFwiIHk9XCIwLjAxNjIwMjQ5MjRcIiB3aWR0aD1cIjg1XCIgaGVpZ2h0PVwiNTVcIiByeD1cIjdcIiByeT1cIjdcIiBzdHJva2U9XCIjYmJiYmJiXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCIjZjlmOWY5XCI+XHJcbiAqICAgPC9yZWN0PlxyXG4gKiAgIDxyZWN0IHhtbG5zOm9yeXg9XCJodHRwOi8vd3d3LmIzbW4ub3JnL29yeXhcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgaWQ9XCJzaWQtOEExQ0RBMjEtOUNEMC00OEVDLUI0OUQtNjQ0NzRFRURFRjZEYXJlYV9zdGF0ZVwiIGFuY2hvcnM9XCJib3R0b21cIiB4PVwiNS45ODM3NzU0OWUtOFwiIHk9XCI0NS4wMTYyMDI0OTI0XCIgd2lkdGg9XCI4NVwiIGhlaWdodD1cIjEwXCIgcng9XCIxMFwiIHJ5PVwiMTBcIiByZXNpemU9XCJob3Jpem9udGFsXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiIHN0eWxlPVwiXCI+XHJcbiAqICAgPC9yZWN0PlxyXG4gKiAgIDx0ZXh0IHhtbG5zOm9yeXg9XCJodHRwOi8vd3d3LmIzbW4ub3JnL29yeXhcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZm9udC1zaXplPVwiMTJcIiBpZD1cInNpZC04QTFDREEyMS05Q0QwLTQ4RUMtQjQ5RC02NDQ3NEVFREVGNkR0ZXh0X25hbWVcIiB4PVwiNTJcIiB5PVwiMzVcIiBhbGlnbj1cIm1pZGRsZSBjZW50ZXJcIiBmaXR0b2VsZW09XCJ0ZXh0X2ZyYW1lXCIgc3Ryb2tlPVwiIzM3M2U0OFwiIHN0cm9rZS13aWR0aD1cIjBwdFwiIGxldHRlci1zcGFjaW5nPVwiLTAuMDFweFwiIHRyYW5zZm9ybT1cInJvdGF0ZSgwIDUyIDM1KVwiIG9yeXg6Zm9udFNpemU9XCIxMlwiIHRleHQtYW5jaG9yPVwibWlkZGxlXCI+XHJcbiAqICAgICAgIDx0c3BhbiB4PVwiNTJcIiB5PVwiMzVcIiBkeT1cIjVcIj5UYXNrXHJcbiAqICAgICAgIDwvdHNwYW4+XHJcbiAqICAgPC90ZXh0PlxyXG4gKiAgIDxnIGlkPVwic2lkLThBMUNEQTIxLTlDRDAtNDhFQy1CNDlELTY0NDc0RUVERUY2RHVzZXJUYXNrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDUuMDAwMDAwLCA1LjAwMDAwMClcIiBmaWxsPVwiIzQ5OTBFMlwiPlxyXG4gKiAgICAgICA8cGF0aCBhbmNob3JzPVwidG9wIGxlZnRcIiBkPVwiIE00LjY4OTc1NDc0OTgzNzc1NSAwLjc1NDc0OTcyMTQwMDAwMDEgIEMzLjEyNDkwODYzOTgzNzc1NSAxLjUwOTQ5OTQ0MjQgMi41MzY5MDI5ODk4Mzc3NTUgMi44MzU5NDA0NTI0IDMuMDM4ODUzMjk5ODM3NzU0NyA1LjM4NzgxOTQ3MjM5OTk5OTUgIEMzLjU0MDgwMzU5OTgzNzc1NSA3LjkzOTY5ODUwMjQgNC4yNTY4NTQzNzk4Mzc3NTYgNy45NzI5MjE4MTI0IDQuNjg5NzU0NzQ5ODM3NzU1IDguOTIwNzYyNTkyNCAgQzUuMTIyNjU1MTE5ODM3NzU1IDkuODY4NjAzMzcyMzk5OTk5IDQuODM0MDU0ODg5ODM3NzU1NiAxMC42NzA2MjI0OTI0IDMuODIzOTUzODc5ODM3NzU0NiAxMS4xMDgwODc0OTI0ICBDMi44MTM4NTI4Nzk4Mzc3NTUgMTEuNTQ1NTUyNDkyNCAxLjE5Njc1NTA5NDk5OTk5OTllLTcgMTIuODU3OTQ3MzkyNCA1Ljk4Mzc3NTQ5ZS04IDEzLjU4NzA1NTY5MjQgIEMwIDE0LjMxNjE2Mzk5MjQgMS4yMjY1NTEyODk4Mzc3NTUgMTQuMjQzMjUzMDkyNCAyLjMwODgwMjM2OTgzNzc1NDcgMTQuMjQzMjUzMDkyNCAgQzMuMzkxMDUzNDQ5ODM3NzU1IDE0LjI0MzI1MzA5MjQgOS4wOTA5MDkxNDk4Mzc3NTUgMTQuMjQzMjUzMDkyNCA5LjA5MDkwOTE0OTgzNzc1NSAxNC4yNDMyNTMwOTI0ICBMOS4xNjMwNTkyMTk4Mzc3NTQgMC41MjM3NzA0ODA0MDAwMDAxICBDOS4xNjMwNTkyMTk4Mzc3NTQgMC41MjM3NzA0ODA0MDAwMDAxIDYuMjU0NjAwODU5ODM3NzU2IDAgNC42ODk3NTQ3NDk4Mzc3NTUgMC43NTQ3NDk3MjE0MDAwMDAxICB6XCIgaWQ9XCJzaWQtOEExQ0RBMjEtOUNEMC00OEVDLUI0OUQtNjQ0NzRFRURFRjZEUGF0aC0xNFwiPlxyXG4gKiAgICAgICA8L3BhdGg+XHJcbiAqICAgICAgIDxwYXRoIGFuY2hvcnM9XCJ0b3AgbGVmdFwiIGQ9XCIgTTkuNTk1OTU5NjU5ODM3NzU3IDAuNzU0NzQ5NzIxNDAwMDAwMSAgQzExLjE2MDgwNTc1OTgzNzc1MyAxLjUwOTQ5OTQ0MjQgMTEuNTc2NTE3ODU5ODM3NzU0IDIuNzQ2NjU0NjgyNCAxMS4wNzQ1Njc1NTk4Mzc3NTcgNS4yOTg1MzM3MDIzOTk5OTkgIEMxMC41NzI2MTcyNTk4Mzc3NTYgNy44NTA0MTI3MzI0IDEwLjAyODg2MDA1OTgzNzc1NCA3Ljk3MjkyMTgxMjQgOS41OTU5NTk2NTk4Mzc3NTcgOC45MjA3NjI1OTI0ICBDOS4xNjMwNTkyNzk4Mzc3NTMgOS44Njg2MDMzNzIzOTk5OTkgOS40NTE2NTk1MTk4Mzc3NTQgMTAuNjcwNjIyNDkyNCAxMC40NjE3NjA1NTk4Mzc3NTcgMTEuMTA4MDg3NDkyNCAgQzExLjQ3MTg2MTU1OTgzNzc1NSAxMS41NDU1NTI0OTI0IDE0LjI4NTcxNDI1OTgzNzc1NSAxMi44NTc5NDczOTI0IDE0LjI4NTcxNDM1OTgzNzc1NyAxMy41ODcwNTU2OTI0ICBDMTQuMjg1NzE0MzU5ODM3NzU3IDE0LjMxNjE2Mzk5MjQgMTMuMDU5MTYzMTU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgMTEuOTc2OTEyMDU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEMxMC44OTQ2NjA5NTk4Mzc3NTQgMTQuMjQzMjUzMDkyNCA2LjM0OTIwNjQwOTgzNzc1NSAxNC4yNDMyNTMwOTI0IDYuMzQ5MjA2NDA5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEw2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgIEM2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgOC4wMzExMTM1NDk4Mzc3NTUgMCA5LjU5NTk1OTY1OTgzNzc1NyAwLjc1NDc0OTcyMTQwMDAwMDEgIHpcIiBpZD1cInNpZC04QTFDREEyMS05Q0QwLTQ4RUMtQjQ5RC02NDQ3NEVFREVGNkRQYXRoLTE0LUNvcHlcIj5cclxuICogICAgICAgPC9wYXRoPlxyXG4gKiAgIDwvZz5cclxuICogPC9nPlxyXG4gKi9cclxuXHJcbiAgICBmdW5jdGlvbiBVc2VyVGFza05vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgVGFza05vZGUuY2FsbCh0aGlzLG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNpemUgPSB7d2lkdGg6MTAwLCBoZWlnaHQ6NjB9O1xyXG4gICAgICAgIHRoaXMuaWNvblBhdGggPSBcIk03NjUuNTczNzQxIDcxOC40ODk4ODhjLTE0Ljk5OTYyMi0xMTIuNjU5ODczLTExOS42NzE1NjctMTk2LjQzODk3NC0yMzcuNzc2NDUyLTE5Ni40Mzg5NzQtMTE4LjkxMjI3MyAwLTIyMC41MTQyOTkgODUuMjc3MjIyLTIzOC4yMDMxNyAxOTguNzcwMDY2LTExLjg0MDY3NiA3Ni4wNzE1NTkgNTQuNTg1MTk5IDcxLjMyNjQ4OSA1NC41ODUxOTkgNzEuMzI2NDg5bDM2MC43MzQ4NzggMEM3MDQuOTEzMTczIDc5Mi4xNDg0OTEgNzc2LjYwODA1MiA4MDEuMzY0Mzg3IDc2NS41NzM3NDEgNzE4LjQ4OTg4OHpNNjkwLjI0OTE5NSAzNjUuNzE4Mzc5YzAgODkuOTExNzc2LTcyLjg4OTA3NyAxNjIuODEwMDYzLTE2Mi43OTY3NiAxNjIuODEwMDYzLTg5LjkwODcwNiAwLTE2Mi43OTc3ODMtNzIuODk4Mjg3LTE2Mi43OTc3ODMtMTYyLjgxMDA2MyAwLTg5LjkxNjg5MiA3Mi44ODkwNzctMTYyLjgwNTk3IDE2Mi43OTc3ODMtMTYyLjgwNTk3QzYxNy4zNjAxMTggMjAyLjkxMjQwOSA2OTAuMjQ5MTk1IDI3NS44MDE0ODcgNjkwLjI0OTE5NSAzNjUuNzE4Mzc5elwiO1xyXG4gICAgICAgIHRoaXMuYnBtbkluZm8gPSB7dHlwZTogMCwgbmFtZTpcIlVzZXJUYXNrXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgVXNlclRhc2tOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB5OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWN0U2l6ZS53aWR0aC0xLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlY3RTaXplLmhlaWdodC0xLFxyXG4gICAgICAgICAgICAgICAgcjogN1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlY3QubmFtZSA9IFwiUmVjdFwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHJlY3QpO1xyXG5cclxuICAgICAgICB2YXIgaWNvblJlY3QgPSB7eDo1LCB5OiA1LCB3aWR0aDogMTUsIGhlaWdodDoxNX07XHJcbiAgICAgICAgdmFyIHBhdGhJY29uID0gZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoLCB7c3R5bGU6IHtmaWxsOiAnI2ZmZicsIHN0cm9rZTogJyMwMDAnfSx6OjJ9LCBpY29uUmVjdCk7XHJcbiAgICAgICAgdGhpcy5hZGQocGF0aEljb24pO1xyXG4gICAgICAgLy8gdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoMiwge3N0eWxlOiB7ZmlsbDogJyM0OTkwRTInfX0sIHJlY3QsXCJjZW50ZXJcIikpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAgW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSwgJycsICdjZW50ZXInKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhVc2VyVGFza05vZGUsVGFza05vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gVXNlclRhc2tOb2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvdGFzay9Vc2VyVGFza05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cdHZhciBCUE1OTm9kZSA9IHJlcXVpcmUoXCIuLi9CUE1OTm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMnKTtcclxuXHQvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZVxyXG5cdC8vXHJcblx0ZnVuY3Rpb24gVGFza05vZGUobW9kZWwsIGFwaSkge1xyXG5cclxuXHRcdEJQTU5Ob2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IC0xLCBuYW1lOlwiVGFza05vZGVcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB0aGlzLnNsb3QgPSBbXTtcclxuICAgICAgICB0aGlzLnNsb3RFdmVudCA9IFtdO1xyXG4gICAgICAgIHRoaXMuaXNDYW5TbG90ID0gdHJ1ZTsgIC8v55So5LqO5o6n5Yi25pys6IqC54K55piv5ZCm5Y+v5Lul6KKr5o+S5qe9XHJcblx0fVxyXG5cclxuICAgIFRhc2tOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIFRhc2tOb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB6clV0aWwuY2xvbmUocmVjdCk7XHJcbiAgICAgICAgLy8g5Y+W5pW0XHJcbiAgICAgICAgYm91bmRpbmdSZWN0LnggPSBwYXJzZUludChib3VuZGluZ1JlY3QueCwgMTApO1xyXG4gICAgICAgIGJvdW5kaW5nUmVjdC55ID0gcGFyc2VJbnQoYm91bmRpbmdSZWN0LnksIDEwKTtcclxuICAgICAgICBib3VuZGluZ1JlY3Qud2lkdGggPSBwYXJzZUludChib3VuZGluZ1JlY3Qud2lkdGgsIDEwKTtcclxuICAgICAgICBib3VuZGluZ1JlY3QuaGVpZ2h0ID0gcGFyc2VJbnQoYm91bmRpbmdSZWN0LmhlaWdodCwgMTApO1xyXG4gICAgICAgIC8v5Yib5bu65pyA5bCP5YyF5Zu055uS6Jma57q/XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgIHBvaW50c1swXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMV0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMl0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1szXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1s0XSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuXHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMucG9zaXRpb25bMF0rYm91bmRpbmdSZWN0LndpZHRoLzIsXHJcbiAgICAgICAgICAgIHk6IHRoaXMucG9zaXRpb25bMV0rYm91bmRpbmdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxyXG4gICAgICAgICAgICBib3VuZGluZ1JlY3Q6IGJvdW5kUmVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIFRhc2tOb2RlLnByb3RvdHlwZS5nZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJSZWN0XCIpO1xyXG4gICAgICAgIHJldHVybiByZWN0LmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBUYXNrTm9kZS5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbihwWCxwWSkge1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIHRoaXMuYXR0cigncG9zaXRpb24nLFtwWC1ib3VuZGluZ1JlY3Qud2lkdGgvMixwWS1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIFRhc2tOb2RlLnByb3RvdHlwZS51cGRhdGVTaGFwZSA9IGZ1bmN0aW9uKHJhdGlvLCBpZlBhcnNlKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNoaWxkT2ZOYW1lKFwiUmVjdFwiKTtcclxuICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gcmVjdC5zaGFwZTtcclxuICAgICAgICB2YXIgbmV3VyA9IE51bWJlcihzaGFwZS53aWR0aCAqIHNjYWxlUmF0aW8pO1xyXG4gICAgICAgIHZhciBuZXdIID0gTnVtYmVyKG5ld1cgKiBzaGFwZS5oZWlnaHQgLyBzaGFwZS53aWR0aCk7XHJcbiAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgbmV3VyA9IHBhcnNlSW50KG5ld1csIDEwKTtcclxuICAgICAgICAgICAgbmV3SCA9IHBhcnNlSW50KG5ld0gsIDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVjdC5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgIHdpZHRoOiBuZXdXLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IG5ld0hcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlZnJlc2hUZXh0KCk7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoVGFza05vZGUsQlBNTk5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gVGFza05vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1Rhc2tOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL01hbnVhbFRhc2voioLngrlcclxuXHJcblx0dmFyIFRhc2tOb2RlID0gcmVxdWlyZShcIi4vVGFza05vZGUuanNcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbi8qKlxyXG4gKlxyXG4gKiAgPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgbWluaW11bVNpemU9XCI4MiA0MlwiIGlkPVwic2lkLUE5NTQ1MjI0LTRDQUUtNDUwRC04OTNELTEyQ0ZBN0U2ODgyNVwiIHRpdGxlPVwiTWFudWFsIHRhc2tcIj5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUE5NTQ1MjI0LTRDQUUtNDUwRC04OTNELTEyQ0ZBN0U2ODgyNXRleHRfZnJhbWVcIiBhbmNob3JzPVwiYm90dG9tIHRvcCByaWdodCBsZWZ0XCIgeD1cIjFcIiB5PVwiMVwiIHdpZHRoPVwiNzRcIiBoZWlnaHQ9XCIzOVwiIHJ4PVwiMTBcIiByeT1cIjEwXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiPjwvcmVjdD5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUE5NTQ1MjI0LTRDQUUtNDUwRC04OTNELTEyQ0ZBN0U2ODgyNWJnX2ZyYW1lXCIgcmVzaXplPVwidmVydGljYWwgaG9yaXpvbnRhbFwiIHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiNDBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHN0cm9rZT1cIiNiYmJiYmJcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIiNmOWY5ZjlcIj48L3JlY3Q+XHJcbiAqICAgICA8cmVjdCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGlkPVwic2lkLUE5NTQ1MjI0LTRDQUUtNDUwRC04OTNELTEyQ0ZBN0U2ODgyNWFyZWFfc3RhdGVcIiBhbmNob3JzPVwiYm90dG9tXCIgeD1cIjBcIiB5PVwiMzBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiMTBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHJlc2l6ZT1cImhvcml6b250YWxcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMFwiIGZpbGw9XCJub25lXCIgc3R5bGU9XCJcIj48L3JlY3Q+XHJcbiAqICAgICA8dGV4dCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZvbnQtc2l6ZT1cIjEyXCIgaWQ9XCJzaWQtQTk1NDUyMjQtNENBRS00NTBELTg5M0QtMTJDRkE3RTY4ODI1dGV4dF9uYW1lXCIgeD1cIjQzXCIgeT1cIjI0XCIgYWxpZ249XCJtaWRkbGUgY2VudGVyXCIgZml0dG9lbGVtPVwidGV4dF9mcmFtZVwiIHN0cm9rZT1cIiMzNzNlNDhcIiBzdHJva2Utd2lkdGg9XCIwcHRcIiBsZXR0ZXItc3BhY2luZz1cIi0wLjAxcHhcIiB0cmFuc2Zvcm09XCJyb3RhdGUoMCA0MyAyNClcIiBvcnl4OmZvbnRTaXplPVwiMTJcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPjx0c3BhbiB4PVwiNDNcIiB5PVwiMjRcIiBkeT1cIjVcIj5UYXNrPC90c3Bhbj48L3RleHQ+XHJcbiAqICAgICA8ZyBpZD1cInNpZC1BOTU0NTIyNC00Q0FFLTQ1MEQtODkzRC0xMkNGQTdFNjg4MjVtYW51YWxUYXNrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDMsMSkgc2NhbGUoMC44KVwiPlxyXG4gKiAgICAgPHBhdGggYW5jaG9ycz1cInRvcCBsZWZ0XCIgc3R5bGU9XCJmaWxsOiNkMWI1NzU7c3Ryb2tlPW5vbmVcIiBkPVwibSAxNyw5LjMyOTAzMjYgYyAtMC4wMDY5LDAuNTUxMjQ2MSAtMC40NTUxNjYsMS4wNDU1ODk0IC0wLjk0MDc3OCwxLjAzNzY2MDQgbCAtNS43OTI3NDYsMCBjIDAuMDA1MywwLjExOTM4MSAwLjAwMjYsMC4yMzcxMDcgMC4wMDYxLDAuMzU1OTY1IGwgNS4xNTQ5MTgsMCBjIDAuNDgyMDMyLC0wLjAwOTYgMC45MjU1MjksMC40OTA1MSAwLjkxOTUyNSwxLjAzNzU3NCAtMC4wMDc4LDAuNTM3MTI4IC0wLjQ0NjI4MywxLjAxNzUzMSAtMC45MTk1MjEsMS4wMDc2ODMgbCAtNS4yNDUyNzMsMCBjIC0wLjAxNTA3LDAuMTA0NDg0IC0wLjAzMzg5LDAuMjA0MDgxIC0wLjA1MzE2LDAuMzAxNTkxIGwgMi42MzAxNzUsMCBjIDAuNDU0MTM3LC0wLjAwOTYgMC44NzIxMTIsMC40NjE3NTQgMC44NjYzODYsMC45NzcxODYgQyAxMy42MTk1MjYsMTQuNTU0MTA2IDEzLjIwNjI5MywxNS4wMDk0OTggMTIuNzU5MjQsMTUgTCAzLjc3NTMwNTQsMTUgQyAzLjYwNDU4MTIsMTUgMy40MzM1NTIsMTQuOTQ0MjMgMy4yOTE2MzYzLDE0LjgzNzEzNiBjIC0wLjAwMTc0LDAgLTAuMDA0MzYsMCAtMC4wMDYwOSwwIEMgMS43MjEyMDM1LDE0LjM2NzgwMSAwLjk5OTk4MjU1LDExLjQ1ODY0MSAxLDExLjQ1ODY0MSBMIDEsNy40NTg4MzkzIGMgMCwwIDAuNjYyMzE0NCwtMS4zMTYzMzMgMS44MzkwNTgzLC0yLjA4NzI1ODQgMS4xNzY3NjE0LC0wLjc3MTE4NjggNi44MDUzMzU4LC0yLjQwNDk3IDcuMjU4Nzg0NywtMi44MDUyOTAxIDAuNDUzNDg0LC0wLjQwMDMyIDEuNjYwMjEzLDEuNDg1OTk0MiAwLjA0Nzc1LDIuNDAxMDQ4NyBDIDguNTMzMjMxNSw1Ljg4MjM5NCA4LjUwNzM1MSw1Ljc5OTYxMTMgOC40MzcwMjkyLDUuNzkzNjg1OSBsIDYuMzU2OTc0OCwtMC4wMDg3MSBjIDAuNDk3MDQ2LC0wLjAwOTU4IDAuOTUyMjczLDAuNTA5NzY3NiAwLjk0NjEyLDEuMDczODIzMiAtMC4wMDUzLDAuNTU2MTI2IC0wLjQ1NjE3NiwxLjA1NjY1NjYgLTAuOTQ2MTIsMS4wNDk2ODU0IGwgLTQuNzI0MzUsMCBjIDAuMDEzMDcsMC4xMTQ5Mzc0IDAuMDI0NCwwLjIyODEzMTkgMC4wMzcyMSwwLjM0OTg2NjEgbCA1Ljk1MjE5NSwwIGMgMC40OTQ1MTcsLTAuMDA4NzEgMC45NDc5MDYsMC41MDY2MzA1IDAuOTQwNzk1LDEuMDY3OTg0OCB6XCIgaWQ9XCJzaWQtQTk1NDUyMjQtNENBRS00NTBELTg5M0QtMTJDRkE3RTY4ODI1X3NpZC1BOTU0NTIyNC00Q0FFLTQ1MEQtODkzRC0xMkNGQTdFNjg4MjVfMTdcIj48L3BhdGg+XHJcbiAqICAgICA8L2c+XHJcbiAqIDwvZz5cclxuICovXHJcbiAgICBmdW5jdGlvbiBNYW51YWxUYXNrTm9kZShtb2RlbCxhcGkpIHtcclxuICAgICAgICBUYXNrTm9kZS5jYWxsKHRoaXMsbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2l6ZSA9IHt3aWR0aDoxMDAsIGhlaWdodDo2MH07XHJcbiAgICAgICAgdGhpcy5pY29uUGF0aCA9IFwibSAxNyw5LjMyOTAzMjYgYyAtMC4wMDY5LDAuNTUxMjQ2MSAtMC40NTUxNjYsMS4wNDU1ODk0IC0wLjk0MDc3OCwxLjAzNzY2MDQgbCAtNS43OTI3NDYsMCBjIDAuMDA1MywwLjExOTM4MSAwLjAwMjYsMC4yMzcxMDcgMC4wMDYxLDAuMzU1OTY1IGwgNS4xNTQ5MTgsMCBjIDAuNDgyMDMyLC0wLjAwOTYgMC45MjU1MjksMC40OTA1MSAwLjkxOTUyNSwxLjAzNzU3NCAtMC4wMDc4LDAuNTM3MTI4IC0wLjQ0NjI4MywxLjAxNzUzMSAtMC45MTk1MjEsMS4wMDc2ODMgbCAtNS4yNDUyNzMsMCBjIC0wLjAxNTA3LDAuMTA0NDg0IC0wLjAzMzg5LDAuMjA0MDgxIC0wLjA1MzE2LDAuMzAxNTkxIGwgMi42MzAxNzUsMCBjIDAuNDU0MTM3LC0wLjAwOTYgMC44NzIxMTIsMC40NjE3NTQgMC44NjYzODYsMC45NzcxODYgQyAxMy42MTk1MjYsMTQuNTU0MTA2IDEzLjIwNjI5MywxNS4wMDk0OTggMTIuNzU5MjQsMTUgTCAzLjc3NTMwNTQsMTUgQyAzLjYwNDU4MTIsMTUgMy40MzM1NTIsMTQuOTQ0MjMgMy4yOTE2MzYzLDE0LjgzNzEzNiBjIC0wLjAwMTc0LDAgLTAuMDA0MzYsMCAtMC4wMDYwOSwwIEMgMS43MjEyMDM1LDE0LjM2NzgwMSAwLjk5OTk4MjU1LDExLjQ1ODY0MSAxLDExLjQ1ODY0MSBMIDEsNy40NTg4MzkzIGMgMCwwIDAuNjYyMzE0NCwtMS4zMTYzMzMgMS44MzkwNTgzLC0yLjA4NzI1ODQgMS4xNzY3NjE0LC0wLjc3MTE4NjggNi44MDUzMzU4LC0yLjQwNDk3IDcuMjU4Nzg0NywtMi44MDUyOTAxIDAuNDUzNDg0LC0wLjQwMDMyIDEuNjYwMjEzLDEuNDg1OTk0MiAwLjA0Nzc1LDIuNDAxMDQ4NyBDIDguNTMzMjMxNSw1Ljg4MjM5NCA4LjUwNzM1MSw1Ljc5OTYxMTMgOC40MzcwMjkyLDUuNzkzNjg1OSBsIDYuMzU2OTc0OCwtMC4wMDg3MSBjIDAuNDk3MDQ2LC0wLjAwOTU4IDAuOTUyMjczLDAuNTA5NzY3NiAwLjk0NjEyLDEuMDczODIzMiAtMC4wMDUzLDAuNTU2MTI2IC0wLjQ1NjE3NiwxLjA1NjY1NjYgLTAuOTQ2MTIsMS4wNDk2ODU0IGwgLTQuNzI0MzUsMCBjIDAuMDEzMDcsMC4xMTQ5Mzc0IDAuMDI0NCwwLjIyODEzMTkgMC4wMzcyMSwwLjM0OTg2NjEgbCA1Ljk1MjE5NSwwIGMgMC40OTQ1MTcsLTAuMDA4NzEgMC45NDc5MDYsMC41MDY2MzA1IDAuOTQwNzk1LDEuMDY3OTg0OCB6XCI7XHJcbiAgICAgIC8vICB0aGlzLmljb25QYXRoMiA9IFwiTTkuNTk1OTU5NjU5ODM3NzU3IDAuNzU0NzQ5NzIxNDAwMDAwMSAgQzExLjE2MDgwNTc1OTgzNzc1MyAxLjUwOTQ5OTQ0MjQgMTEuNTc2NTE3ODU5ODM3NzU0IDIuNzQ2NjU0NjgyNCAxMS4wNzQ1Njc1NTk4Mzc3NTcgNS4yOTg1MzM3MDIzOTk5OTkgIEMxMC41NzI2MTcyNTk4Mzc3NTYgNy44NTA0MTI3MzI0IDEwLjAyODg2MDA1OTgzNzc1NCA3Ljk3MjkyMTgxMjQgOS41OTU5NTk2NTk4Mzc3NTcgOC45MjA3NjI1OTI0ICBDOS4xNjMwNTkyNzk4Mzc3NTMgOS44Njg2MDMzNzIzOTk5OTkgOS40NTE2NTk1MTk4Mzc3NTQgMTAuNjcwNjIyNDkyNCAxMC40NjE3NjA1NTk4Mzc3NTcgMTEuMTA4MDg3NDkyNCAgQzExLjQ3MTg2MTU1OTgzNzc1NSAxMS41NDU1NTI0OTI0IDE0LjI4NTcxNDI1OTgzNzc1NSAxMi44NTc5NDczOTI0IDE0LjI4NTcxNDM1OTgzNzc1NyAxMy41ODcwNTU2OTI0ICBDMTQuMjg1NzE0MzU5ODM3NzU3IDE0LjMxNjE2Mzk5MjQgMTMuMDU5MTYzMTU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgMTEuOTc2OTEyMDU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEMxMC44OTQ2NjA5NTk4Mzc3NTQgMTQuMjQzMjUzMDkyNCA2LjM0OTIwNjQwOTgzNzc1NSAxNC4yNDMyNTMwOTI0IDYuMzQ5MjA2NDA5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEw2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgIEM2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgOC4wMzExMTM1NDk4Mzc3NTUgMCA5LjU5NTk1OTY1OTgzNzc1NyAwLjc1NDc0OTcyMTQwMDAwMDEgIHpcIjtcclxuICAgICAgICB0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDQsIG5hbWU6XCJNYW51YWxUYXNrXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgTWFudWFsVGFza05vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IDAuNSxcclxuICAgICAgICAgICAgICAgIHk6IDAuNSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLnJlY3RTaXplLndpZHRoLTEsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMucmVjdFNpemUuaGVpZ2h0LTEsXHJcbiAgICAgICAgICAgICAgICByOiA3XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcblxyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmZmYnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejoyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVjdC5uYW1lID0gXCJSZWN0XCI7XHJcbiAgICAgICAgdGhpcy5hZGQocmVjdCk7XHJcblxyXG4gICAgICAgIHZhciBpY29ucmVjdCA9IHt4OjUsIHk6IDUsIHdpZHRoOiAxNSwgaGVpZ2h0OjE1fTtcclxuICAgICAgICB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMuaWNvblBhdGgsIHtzdHlsZToge2ZpbGw6ICcjZmZmJywgc3Ryb2tlOiAnIzAwMCd9LHo6Mn0sIGljb25yZWN0KSk7XHJcblxyXG4gICAgICAgLy8gdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoMiwge3N0eWxlOiB7ZmlsbDogJyM0OTkwRTInfX0sIHJlY3QsXCJjZW50ZXJcIikpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAgW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSwgJycsICdjZW50ZXInKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoTWFudWFsVGFza05vZGUsVGFza05vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gTWFudWFsVGFza05vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL01hbnVhbFRhc2tOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL1NjcmlwdFRhc2voioLngrlcclxuXHJcblx0dmFyIFRhc2tOb2RlID0gcmVxdWlyZShcIi4vVGFza05vZGUuanNcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbi8qKlxyXG4gKlxyXG4gKiAgPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgbWluaW11bVNpemU9XCI4MiA0MlwiIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RFwiIHRpdGxlPVwiU2NyaXB0IHRhc2tcIj5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RHRleHRfZnJhbWVcIiBhbmNob3JzPVwiYm90dG9tIHRvcCByaWdodCBsZWZ0XCIgeD1cIjFcIiB5PVwiMVwiIHdpZHRoPVwiNzRcIiBoZWlnaHQ9XCIzOVwiIHJ4PVwiMTBcIiByeT1cIjEwXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiPjwvcmVjdD5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RGJnX2ZyYW1lXCIgcmVzaXplPVwidmVydGljYWwgaG9yaXpvbnRhbFwiIHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiNDBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHN0cm9rZT1cIiNiYmJiYmJcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIiNmOWY5ZjlcIj48L3JlY3Q+XHJcbiAqICAgICA8cmVjdCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RGFyZWFfc3RhdGVcIiBhbmNob3JzPVwiYm90dG9tXCIgeD1cIjBcIiB5PVwiMzBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiMTBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHJlc2l6ZT1cImhvcml6b250YWxcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMFwiIGZpbGw9XCJub25lXCIgc3R5bGU9XCJcIj48L3JlY3Q+XHJcbiAqICAgICA8dGV4dCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZvbnQtc2l6ZT1cIjEyXCIgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEdGV4dF9uYW1lXCIgeD1cIjQzXCIgeT1cIjI0XCIgYWxpZ249XCJtaWRkbGUgY2VudGVyXCIgZml0dG9lbGVtPVwidGV4dF9mcmFtZVwiIHN0cm9rZT1cIiMzNzNlNDhcIiBzdHJva2Utd2lkdGg9XCIwcHRcIiBsZXR0ZXItc3BhY2luZz1cIi0wLjAxcHhcIiB0cmFuc2Zvcm09XCJyb3RhdGUoMCA0MyAyNClcIiBvcnl4OmZvbnRTaXplPVwiMTJcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPjx0c3BhbiB4PVwiNDNcIiB5PVwiMjRcIiBkeT1cIjVcIj5UYXNrPC90c3Bhbj48L3RleHQ+XHJcbiAqICAgICA8ZyBpZD1cInNpZC1CODNERkE5RS0wMDY2LTQwMzItQTlFOC1BN0ZGMTlDMUFCNURzY3JpcHRUYXNrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDIsMikgc2NhbGUoMC44KVwiPlxyXG4gKiAgICAgPHBhdGggYW5jaG9ycz1cInRvcCBsZWZ0XCIgZD1cIm0gNSwyIDAsMC4wOTQgYyAwLjIzNzA2LDAuMDY0IDAuNTMxODksMC4xNjQ1IDAuODEyNSwwLjM3NSAwLjU1ODIsMC40MTg2IDEuMDUxMDksMS4yMjggMS4xNTYyNSwyLjUzMTIgbCA4LjAzMTI1LDAgMSwwIDEsMCBjIDAsLTMgLTIsLTMgLTIsLTMgbCAtMTAsMCB6IE0gNCwzIDQsMTMgMiwxMyBjIDAsMyAyLDMgMiwzIGwgOSwwIGMgMCwwIDIsMCAyLC0zIEwgMTUsNiA2LDYgNiw1LjUgQyA2LDQuMTExMSA1LjU1OTUsMy41MjkgNS4xODc1LDMuMjUgNC44MTU1LDIuOTcxIDQuNSwzIDQuNSwzIEwgNCwzIHpcIiBzdHlsZT1cImZpbGw6IzcyYTdkMDtzdHJva2U6bm9uZVwiIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RF9zaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEXzE3XCI+PC9wYXRoPlxyXG4gKiAgICAgPC9nPlxyXG4gKiA8L2c+XHJcbiAqL1xyXG4gICAgZnVuY3Rpb24gU2NyaXB0VGFza05vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgVGFza05vZGUuY2FsbCh0aGlzLG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNpemUgPSB7d2lkdGg6MTAwLCBoZWlnaHQ6NjB9O1xyXG4gICAgICAgIHRoaXMuaWNvblBhdGggPSBcIm0gNSwyIDAsMC4wOTQgYyAwLjIzNzA2LDAuMDY0IDAuNTMxODksMC4xNjQ1IDAuODEyNSwwLjM3NSAwLjU1ODIsMC40MTg2IDEuMDUxMDksMS4yMjggMS4xNTYyNSwyLjUzMTIgbCA4LjAzMTI1LDAgMSwwIDEsMCBjIDAsLTMgLTIsLTMgLTIsLTMgbCAtMTAsMCB6IE0gNCwzIDQsMTMgMiwxMyBjIDAsMyAyLDMgMiwzIGwgOSwwIGMgMCwwIDIsMCAyLC0zIEwgMTUsNiA2LDYgNiw1LjUgQyA2LDQuMTExMSA1LjU1OTUsMy41MjkgNS4xODc1LDMuMjUgNC44MTU1LDIuOTcxIDQuNSwzIDQuNSwzIEwgNCwzIHpcIjtcclxuICAgICAgLy8gIHRoaXMuaWNvblBhdGgyID0gXCJNOS41OTU5NTk2NTk4Mzc3NTcgMC43NTQ3NDk3MjE0MDAwMDAxICBDMTEuMTYwODA1NzU5ODM3NzUzIDEuNTA5NDk5NDQyNCAxMS41NzY1MTc4NTk4Mzc3NTQgMi43NDY2NTQ2ODI0IDExLjA3NDU2NzU1OTgzNzc1NyA1LjI5ODUzMzcwMjM5OTk5OSAgQzEwLjU3MjYxNzI1OTgzNzc1NiA3Ljg1MDQxMjczMjQgMTAuMDI4ODYwMDU5ODM3NzU0IDcuOTcyOTIxODEyNCA5LjU5NTk1OTY1OTgzNzc1NyA4LjkyMDc2MjU5MjQgIEM5LjE2MzA1OTI3OTgzNzc1MyA5Ljg2ODYwMzM3MjM5OTk5OSA5LjQ1MTY1OTUxOTgzNzc1NCAxMC42NzA2MjI0OTI0IDEwLjQ2MTc2MDU1OTgzNzc1NyAxMS4xMDgwODc0OTI0ICBDMTEuNDcxODYxNTU5ODM3NzU1IDExLjU0NTU1MjQ5MjQgMTQuMjg1NzE0MjU5ODM3NzU1IDEyLjg1Nzk0NzM5MjQgMTQuMjg1NzE0MzU5ODM3NzU3IDEzLjU4NzA1NTY5MjQgIEMxNC4yODU3MTQzNTk4Mzc3NTcgMTQuMzE2MTYzOTkyNCAxMy4wNTkxNjMxNTk4Mzc3NTUgMTQuMjQzMjUzMDkyNCAxMS45NzY5MTIwNTk4Mzc3NTUgMTQuMjQzMjUzMDkyNCAgQzEwLjg5NDY2MDk1OTgzNzc1NCAxNC4yNDMyNTMwOTI0IDYuMzQ5MjA2NDA5ODM3NzU1IDE0LjI0MzI1MzA5MjQgNi4zNDkyMDY0MDk4Mzc3NTUgMTQuMjQzMjUzMDkyNCAgTDYuMTUyMDYxOTY5ODM3NzU1IDAuNDI5OTI2MjY5NCAgQzYuMTUyMDYxOTY5ODM3NzU1IDAuNDI5OTI2MjY5NCA4LjAzMTExMzU0OTgzNzc1NSAwIDkuNTk1OTU5NjU5ODM3NzU3IDAuNzU0NzQ5NzIxNDAwMDAwMSAgelwiO1xyXG4gICAgICAgIHRoaXMuYnBtbkluZm8gPSB7dHlwZTogNywgbmFtZTpcIlNjcmlwdFRhc2tcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG4gICAgICAgIHRoaXMucmVuZGVyKG1vZGVsKTtcclxuICAgIH1cclxuXHJcbiAgICBTY3JpcHRUYXNrTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgeDogMC41LFxyXG4gICAgICAgICAgICAgICAgeTogMC41LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMucmVjdFNpemUud2lkdGgtMSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZWN0U2l6ZS5oZWlnaHQtMSxcclxuICAgICAgICAgICAgICAgIHI6IDdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZicsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICByZWN0Lm5hbWUgPSBcIlJlY3RcIjtcclxuICAgICAgICB0aGlzLmFkZChyZWN0KTtcclxuXHJcbiAgICAgICAgdmFyIGljb25yZWN0ID0ge3g6NSwgeTogNSwgd2lkdGg6IDE1LCBoZWlnaHQ6MTV9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5pY29uUGF0aCwge3N0eWxlOiB7ZmlsbDogJyNmZmYnLCBzdHJva2U6ICcjMDAwJ30sejoyfSwgaWNvbnJlY3QpKTtcclxuXHJcbiAgICAgICAvLyB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMuaWNvblBhdGgyLCB7c3R5bGU6IHtmaWxsOiAnIzQ5OTBFMid9fSwgcmVjdCxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIildO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpLCAnJywgJ2NlbnRlcicpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhTY3JpcHRUYXNrTm9kZSxUYXNrTm9kZSk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBTY3JpcHRUYXNrTm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL3Rhc2svU2NyaXB0VGFza05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vTWFpbFRhc2voioLngrlcclxuXHJcblx0dmFyIFRhc2tOb2RlID0gcmVxdWlyZShcIi4vVGFza05vZGUuanNcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbi8qKlxyXG4gKlxyXG4gKiAgPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgbWluaW11bVNpemU9XCI4MiA0MlwiIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RFwiIHRpdGxlPVwiU2NyaXB0IHRhc2tcIj5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RHRleHRfZnJhbWVcIiBhbmNob3JzPVwiYm90dG9tIHRvcCByaWdodCBsZWZ0XCIgeD1cIjFcIiB5PVwiMVwiIHdpZHRoPVwiNzRcIiBoZWlnaHQ9XCIzOVwiIHJ4PVwiMTBcIiByeT1cIjEwXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiPjwvcmVjdD5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RGJnX2ZyYW1lXCIgcmVzaXplPVwidmVydGljYWwgaG9yaXpvbnRhbFwiIHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiNDBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHN0cm9rZT1cIiNiYmJiYmJcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIiNmOWY5ZjlcIj48L3JlY3Q+XHJcbiAqICAgICA8cmVjdCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RGFyZWFfc3RhdGVcIiBhbmNob3JzPVwiYm90dG9tXCIgeD1cIjBcIiB5PVwiMzBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiMTBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHJlc2l6ZT1cImhvcml6b250YWxcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMFwiIGZpbGw9XCJub25lXCIgc3R5bGU9XCJcIj48L3JlY3Q+XHJcbiAqICAgICA8dGV4dCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZvbnQtc2l6ZT1cIjEyXCIgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEdGV4dF9uYW1lXCIgeD1cIjQzXCIgeT1cIjI0XCIgYWxpZ249XCJtaWRkbGUgY2VudGVyXCIgZml0dG9lbGVtPVwidGV4dF9mcmFtZVwiIHN0cm9rZT1cIiMzNzNlNDhcIiBzdHJva2Utd2lkdGg9XCIwcHRcIiBsZXR0ZXItc3BhY2luZz1cIi0wLjAxcHhcIiB0cmFuc2Zvcm09XCJyb3RhdGUoMCA0MyAyNClcIiBvcnl4OmZvbnRTaXplPVwiMTJcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPjx0c3BhbiB4PVwiNDNcIiB5PVwiMjRcIiBkeT1cIjVcIj5UYXNrPC90c3Bhbj48L3RleHQ+XHJcbiAqICAgICA8ZyBpZD1cInNpZC1CODNERkE5RS0wMDY2LTQwMzItQTlFOC1BN0ZGMTlDMUFCNURzY3JpcHRUYXNrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDIsMikgc2NhbGUoMC44KVwiPlxyXG4gKiAgICAgICAgPHBhdGggYW5jaG9ycz1cInRvcCBsZWZ0XCIgZD1cIk0wLjMzMjYzODkzNiwxLjE3MzkxMzA0IEw4Ljk4MTI1MTI2LDYuNjUyMTczOTFcIiBpZD1cInNpZC0wOUI5N0M1RS1CRUE4LTQwQTItOUYyMi0zMDY0QTI3NDVEQkVMaW5lXCIgc3Ryb2tlPVwiI0ZGRkZGRlwiIHN0cm9rZS1saW5lY2FwPVwic3F1YXJlXCI+PC9wYXRoPlxyXG4gKiAgICAgICAgPHBhdGggYW5jaG9ycz1cInRvcCBsZWZ0XCIgZD1cIk0xNy41NTAwMzAyLDEuMTczOTEzMDQgTDguOTAxNDE3OTIsNi42NTIxNzM5MVwiIGlkPVwic2lkLTA5Qjk3QzVFLUJFQTgtNDBBMi05RjIyLTMwNjRBMjc0NURCRUxpbmUtQ29weS00XCIgc3Ryb2tlPVwiI0ZGRkZGRlwiIHN0cm9rZS1saW5lY2FwPVwic3F1YXJlXCI+PC9wYXRoPlxyXG4gKlx0ICAgPC9nPlxyXG4gKiA8L2c+XHJcbiAqL1xyXG4gICAgZnVuY3Rpb24gTWFpbFRhc2tOb2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIFRhc2tOb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnJlY3RTaXplID0ge3dpZHRoOjEwMCwgaGVpZ2h0OjYwfTtcclxuICAgICAgICB0aGlzLmljb25QYXRoID0gXCJNNDkuMDEzLDUxLjAwM2MxLjg0NywxLjMwMyw3LjQxNCw1LjE3NCwxNi43MDIsMTEuNjFTODIuMTE4LDc0LjAwNSw4Ny4wNjEsNzcuNDhjMC41NDMsMC4zODEsMS42OTcsMS4yMDksMy40NjIsMi40ODVjMS43NjUsMS4yNzcsMy4yMzIsMi4zMSw0LjM5OSwzLjA5N2MxLjE2OCwwLjc4NywyLjU4LDEuNjcsNC4yMzcsMi42NDdjMS42NTcsMC45NzcsMy4yMTksMS43MTEsNC42ODUsMi4xOThjMS40NjcsMC40OSwyLjgyNSwwLjczMyw0LjA3NCwwLjczM0gxMDhoMC4wODJjMS4yNDksMCwyLjYwNy0wLjI0Myw0LjA3NC0wLjczM2MxLjQ2Ni0wLjQ4NywzLjAyOS0xLjIyMiw0LjY4NS0yLjE5OGMxLjY1Ni0wLjk3OCwzLjA2OC0xLjg2LDQuMjM2LTIuNjQ3czIuNjM0LTEuODIsNC4zOTktMy4wOTdzMi45Mi0yLjEwNCwzLjQ2My0yLjQ4NWM0Ljk5Ni0zLjQ3NiwxNy43MDctMTIuMzAyLDM4LjEyOS0yNi40NzljMy45NjUtMi43NjksNy4yNzctNi4xMSw5LjkzOS0xMC4wMjFDMTc5LjY3LDM3LjA3MSwxODEsMzIuOTcsMTgxLDI4LjY3OWMwLTMuNTg1LTEuMjkxLTYuNjU0LTMuODcxLTkuMjA3Yy0yLjU4LTIuNTUzLTUuNjM2LTMuODI5LTkuMTY1LTMuODI5SDQ4LjAzNWMtNC4xODIsMC03LjQsMS40MTItOS42NTQsNC4yMzZDMzYuMTI3LDIyLjcwNCwzNSwyNi4yMzUsMzUsMzAuNDcxYzAsMy40MjIsMS40OTQsNy4xMyw0LjQ4MSwxMS4xMjJTNDUuNjQ2LDQ4LjcyMiw0OS4wMTMsNTEuMDAzeiBNMTcyLjg1Miw1OS43MmMtMTcuODE0LDEyLjA1Ny0zMS4zNCwyMS40MjctNDAuNTcyLDI4LjEwOGMtMy4wOTYsMi4yODEtNS42MDgsNC4wNjEtNy41MzcsNS4zMzZjLTEuOTI4LDEuMjc3LTQuNDk0LDIuNTgtNy42OTksMy45MTFjLTMuMjA0LDEuMzMxLTYuMTkxLDEuOTk2LTguOTYxLDEuOTk2SDEwOGgtMC4wODJjLTIuNzcsMC01Ljc1OC0wLjY2NS04Ljk2Mi0xLjk5NnMtNS43NzEtMi42MzQtNy42OTktMy45MTFjLTEuOTI4LTEuMjc1LTQuNDQtMy4wNTUtNy41MzYtNS4zMzZjLTcuMzMzLTUuMzc3LTIwLjgzLTE0Ljc0Ny00MC40OTItMjguMTA4Yy0zLjA5Ni0yLjA2My01LjgzOS00LjQyNy04LjIyOS03LjA4OHY2NC42ODhjMCwzLjU4NiwxLjI3Niw2LjY1NCwzLjgyOSw5LjIwN2MyLjU1MywyLjU1NCw1LjYyMiwzLjgzLDkuMjA3LDMuODNoMTE5LjkyOWMzLjU4NCwwLDYuNjUzLTEuMjc2LDkuMjA2LTMuODNjMi41NTQtMi41NTQsMy44MjktNS42MjEsMy44MjktOS4yMDdWNTIuNjMyQzE3OC42NjQsNTUuMjM4LDE3NS45NDksNTcuNjAyLDE3Mi44NTIsNTkuNzJ6XCI7XHJcbiAgICAgIC8vICB0aGlzLmljb25QYXRoMiA9IFwiTTkuNTk1OTU5NjU5ODM3NzU3IDAuNzU0NzQ5NzIxNDAwMDAwMSAgQzExLjE2MDgwNTc1OTgzNzc1MyAxLjUwOTQ5OTQ0MjQgMTEuNTc2NTE3ODU5ODM3NzU0IDIuNzQ2NjU0NjgyNCAxMS4wNzQ1Njc1NTk4Mzc3NTcgNS4yOTg1MzM3MDIzOTk5OTkgIEMxMC41NzI2MTcyNTk4Mzc3NTYgNy44NTA0MTI3MzI0IDEwLjAyODg2MDA1OTgzNzc1NCA3Ljk3MjkyMTgxMjQgOS41OTU5NTk2NTk4Mzc3NTcgOC45MjA3NjI1OTI0ICBDOS4xNjMwNTkyNzk4Mzc3NTMgOS44Njg2MDMzNzIzOTk5OTkgOS40NTE2NTk1MTk4Mzc3NTQgMTAuNjcwNjIyNDkyNCAxMC40NjE3NjA1NTk4Mzc3NTcgMTEuMTA4MDg3NDkyNCAgQzExLjQ3MTg2MTU1OTgzNzc1NSAxMS41NDU1NTI0OTI0IDE0LjI4NTcxNDI1OTgzNzc1NSAxMi44NTc5NDczOTI0IDE0LjI4NTcxNDM1OTgzNzc1NyAxMy41ODcwNTU2OTI0ICBDMTQuMjg1NzE0MzU5ODM3NzU3IDE0LjMxNjE2Mzk5MjQgMTMuMDU5MTYzMTU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgMTEuOTc2OTEyMDU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEMxMC44OTQ2NjA5NTk4Mzc3NTQgMTQuMjQzMjUzMDkyNCA2LjM0OTIwNjQwOTgzNzc1NSAxNC4yNDMyNTMwOTI0IDYuMzQ5MjA2NDA5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEw2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgIEM2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgOC4wMzExMTM1NDk4Mzc3NTUgMCA5LjU5NTk1OTY1OTgzNzc1NyAwLjc1NDc0OTcyMTQwMDAwMDEgIHpcIjtcclxuICAgICAgICB0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDgsIG5hbWU6XCJNYWlsVGFza1wiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIE1haWxUYXNrTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgeDogMC41LFxyXG4gICAgICAgICAgICAgICAgeTogMC41LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMucmVjdFNpemUud2lkdGgtMSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZWN0U2l6ZS5oZWlnaHQtMSxcclxuICAgICAgICAgICAgICAgIHI6IDdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZicsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICByZWN0Lm5hbWUgPSBcIlJlY3RcIjtcclxuICAgICAgICB0aGlzLmFkZChyZWN0KTtcclxuXHJcbiAgICAgICAgdmFyIGljb25yZWN0ID0ge3g6NSwgeTogNSwgd2lkdGg6IDE1LCBoZWlnaHQ6MTV9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5pY29uUGF0aCwge3N0eWxlOiB7ZmlsbDogJyNmZmYnLCBzdHJva2U6ICcjMDAwJ30sejoyfSwgaWNvbnJlY3QpKTtcclxuXHJcbiAgICAgICAvLyB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMuaWNvblBhdGgyLCB7c3R5bGU6IHtmaWxsOiAnIzQ5OTBFMid9fSwgcmVjdCxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIildO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpLCAnJywgJ2NlbnRlcicpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhNYWlsVGFza05vZGUsVGFza05vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gTWFpbFRhc2tOb2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvdGFzay9NYWlsVGFza05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cdHZhciBUYXNrTm9kZSA9IHJlcXVpcmUoXCIuL1Rhc2tOb2RlLmpzXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBTZXJ2aWNlVGFza05vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgVGFza05vZGUuY2FsbCh0aGlzLG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNpemUgPSB7d2lkdGg6MTAwLCBoZWlnaHQ6NjB9O1xyXG4gICAgICAgIHRoaXMuaWNvblBhdGggPSBcIk04OTEuODQgNDEwLjA3MmMtOC45MzYtMzMuNDgtMjIuMTkyLTY1LjIzMi0zOS4xOTItOTQuNTg0bDc0LjUxMi0xMTIuNC0xMDYuMjcyLTEwNi4xODQtMTEyLjM0NCA3NC40NTZjLTI5LjM4NC0xNi45NDQtNjEuMTQ0LTMwLjI1Ni05NC42NDgtMzkuMkw1ODcuMDggMGwtMTUwLjE2IDAtMjYuODE2IDEzMi4xNmMtMzMuNTA0IDguOTQ0LTY1LjI2NCAyMi4yNTYtOTQuNjQ4IDM5LjJsLTExMi40LTc0LjQ1Nkw5Ni44MzIgMjAzLjA4bDc0LjUyIDExMi40Yy0xNyAyOS4zNTItMzAuMjU2IDYxLjExMi0zOS4yIDk0LjY0OEwwIDQzNi44ODhsMCAxNTAuMTkyIDEzMi4xNiAyNi44MjRjOC45NDQgMzMuNTA0IDIyLjE5MiA2NS4yNjQgMzkuMiA5NC42NDhsLTc0LjUyIDExMi40MDggMTA2LjIxNiAxMDYuMTUyIDExMi40LTc0LjQ1NmMyOS4zODQgMTYuOTM2IDYxLjE0NCAzMC4yNTYgOTQuNjQ4IDM5LjE5Mkw0MzYuOTIgMTAyNGwxNTAuMTYgMCAyNi44MjQtMTMyLjE2YzMzLjUwNC04LjkzNiA2NS4yNjQtMjIuMjU2IDk0LjY0OC0zOS4xOTJsMTEyLjM0NCA3NC40NTYgMTA2LjI3Mi0xMDYuMTUyLTc0LjUxMi0xMTIuNDA4YzE3LTI5LjM4NCAzMC4yNTYtNjEuMTQ0IDM5LjE5Mi05NC42NDhMMTAyNCA1ODcuMDggMTAyNCA0MzYuODg4IDg5MS44NCA0MTAuMDcyIDg5MS44NCA0MTAuMDcyek02ODkuOCA1MTJjMCA5OC4xNTItNzkuNTg0IDE3Ny44LTE3Ny44IDE3Ny44UzMzNC4yMDggNjEwLjE1MiAzMzQuMjA4IDUxMmMwLTk4LjE3NiA3OS41ODQtMTc3Ljc5MiAxNzcuNzkyLTE3Ny43OTJTNjg5LjggNDEzLjgyNCA2ODkuOCA1MTJ6XCI7XHJcbiAgICAgICAgdGhpcy5icG1uSW5mbyA9IHt0eXBlOiAxMiwgbmFtZTpcIlNlcnZpY2VUYXNrXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgU2VydmljZVRhc2tOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB5OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWN0U2l6ZS53aWR0aC0xLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlY3RTaXplLmhlaWdodC0xLFxyXG4gICAgICAgICAgICAgICAgcjogN1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlY3QubmFtZSA9IFwiUmVjdFwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHJlY3QpO1xyXG5cclxuICAgICAgICB2YXIgaWNvbnJlY3QgPSB7eDo1LCB5OiA1LCB3aWR0aDogMTUsIGhlaWdodDoxNX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoLCB7c3R5bGU6IHtmaWxsOiAnI2ZmZicsIHN0cm9rZTogJyMwMDAnfSx6OjJ9LCBpY29ucmVjdCkpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAgW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSwgJycsICdjZW50ZXInKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoU2VydmljZVRhc2tOb2RlLFRhc2tOb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2VUYXNrTm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL3Rhc2svU2VydmljZVRhc2tOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHR2YXIgVGFza05vZGUgPSByZXF1aXJlKFwiLi9UYXNrTm9kZS5qc1wiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gU21zVGFza05vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgVGFza05vZGUuY2FsbCh0aGlzLG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNpemUgPSB7d2lkdGg6MTAwLCBoZWlnaHQ6NjB9O1xyXG4gICAgICAgIHRoaXMuaWNvblBhdGggPSBcIk05NTkuOTA3Nzc1IDQzOS44OTQ3NzVjMCAxOTUuMTQwMzk5LTIwMC42MDc5MjQgMzUyLjkwOTY1NS00NDcuOTY0NTY4IDM1Mi45MDk2NTUtMjEuNzYxNjMgMC00My4wODMyMzgtMS4yMDM0MDgtNjQuMDgwNDU3LTMuNDk5NzA3LTQxLjU1NTQ0MS00LjcwMTA2OS0xMDkuODk3OTY5IDEyMS42MDE1MjItMzAwLjgyODQ4NiAxNDcuNTE3Nzc1IDEwMC4xNjQyODEtMTE3Ljk5MjMyMSAxMDYuNzI3NzY3LTIwNi40ODU3OTUgNzQuMjUwMDc0LTIyOC4zMDE2NTlDMTI1LjA1MzY0NiA2NDMuNzgyMzk2IDY0LjA5MTIwMiA1NDcuNTUzNzUxIDY0LjA5MTIwMiA0MzkuODk0Nzc1YzAtMTk0Ljc1NzY4MiAyMDAuNjA3OTI0LTM1Mi43MTcyNzQgNDQ3Ljg1MjAwNC0zNTIuNzE3Mjc0Qzc1OS4yOTk4NTEgODcuMTc3NTAyIDk1OS45MDc3NzUgMjQ1LjEzNjA3IDk1OS45MDc3NzUgNDM5Ljg5NDc3NXpcIjtcclxuICAgICAgICB0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDExLCBuYW1lOlwiU21zVGFza1wiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIFNtc1Rhc2tOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB5OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWN0U2l6ZS53aWR0aC0xLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlY3RTaXplLmhlaWdodC0xLFxyXG4gICAgICAgICAgICAgICAgcjogN1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlY3QubmFtZSA9IFwiUmVjdFwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHJlY3QpO1xyXG5cclxuICAgICAgICB2YXIgaWNvbnJlY3QgPSB7eDo1LCB5OiA1LCB3aWR0aDogMTUsIGhlaWdodDoxNX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoLCB7c3R5bGU6IHtmaWxsOiAnI2ZmZicsIHN0cm9rZTogJyMwMDAnfSx6OjJ9LCBpY29ucmVjdCkpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAgW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSwgJycsICdjZW50ZXInKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoU21zVGFza05vZGUsVGFza05vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gU21zVGFza05vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1Ntc1Rhc2tOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHR2YXIgQlBNTk5vZGUgPSByZXF1aXJlKFwiLi9CUE1OTm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIGltYWdlVXJsID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUlBQUFBQ0FDQVlBQUFERFBtSExBQUFESUVsRVFWUjRYdTJYd1UzRFVCUUVYL3BCYVlwRzZJS2lPRVljS1lBR3VJWWpJa0k0VWp6eFJKNmN2LzZ1WjBlMmNwaCt1eVp3MlBYVDkvQ1RBRHVYSUFFU1lKSEF5K0tKOVE5OHpzenIrdGQyNHlXQmE5NEE1dzJ3bldibXVFSHU3aUlUWUhlVC8zN2dCRWlBUlFKOUFoWVJQZTZCM2dDUHU5MHF6Uk5nRll5UGU4bXRBanpOelB2alBuN05FMkRuRGlSQUFpd1MrTzlmUUorQVJYenVBNzBCM1B2ZzdSSUFSK3dPU0FEM1BuaTdCTUFSdXdNU3dMMFAzaTRCY01UdWdBUnc3NE8zU3dBY3NUc2dBZHo3NE8wU0FFZnNEa2dBOXo1NHV3VEFFYnNERXNDOUQ5NHVBWERFN29BRWNPK0R0MHNBSExFN0lBSGMrK0R0RWdCSDdBNUlBUGMrZUxzRXdCRzdBeExBdlEvZUxnRnd4TzZBQkhEdmc3ZExBQnl4T3lBQjNQdmc3UklBUit3T1NBRDNQbmk3Qk1BUnV3TVN3TDBQM2k0QmNNVHVnQVJ3NzRPM1N3QWNzVHNnQWR6NzRPMFNBRWZzRGtnQTl6NTR1d1RBRWJzREVzQzlEOTR1QVhERTdvQUVjTytEdDBzQUhMRTdJQUhjKytEdEVnQkg3QTVJQVBjK2VMc0V3Qkc3QXhMQXZRL2VMZ0Z3eE82QUJIRHZnN2RMQUJ5eE95QUIzUHZnN1JJQVIrd09TQUQzUG5pN0JNQVJ1d01Td0wwUDNpNEJjTVR1Z0FSdzc0TzNTd0Fjc1RzZ0Fkejc0TzBTQUVmc0RrZ0E5ejU0dXdUQUVic0RFc0M5RDk0dUFYREU3b0FFY08rRHQwc0FITEU3SUFIYysrRHRFZ0JIN0E1SUFQYytlTHNFd0JHN0F4TEF2US9lTGdGd3hPNkFCSER2ZzdkTEFCeXhPeUFCM1B2ZzdSSUFSK3dPU0FEM1BuaTdCTUFSdXdNU3dMMFAzaTRCY01UdWdBUnc3NE8zU3dBY3NUc2dBZHo3NE8wU0FFZnNEa2dBOXo1NHV3VEFFYnNERXNDOUQ5NHVBWERFN29BRWNPK0R0MHNBSExFN0lBSGMrK0R0RWdCSDdBNUlBUGMrZUxzRXdCRzdBeExBdlEvZUxnRnd4TzZBQkhEdmc3ZExBQnl4T3lBQjNQdmc3UklBUit3T1NBRDNQbmk3Qk1BUnV3TVN3TDBQM2k0QmNNVHVnRnNGZUp1WkwrQVJQMmJtR2JpM0t5OEkzQ29BQmZRME0wZnE4dTc5SVpBQU83Y2hBUkpna2NCNThjVDZCL29Fck0vMHp4dDdBOXdKdERVbUFhekwzS25YTlFMY3FVb3hXeEJJZ0Myb2l6SVRRRFRHRmxVU1lBdnFvc3h2U2JueWdjYzd3RHNBQUFBQVNVVk9SSzVDWUlJPVwiO1xyXG5cclxuICAgIGZ1bmN0aW9uIENvbW1lbnROb2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIEJQTU5Ob2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5icG1uSW5mbyA9IHt0eXBlOiAyMSwgbmFtZTpcIkNvbW1lbnRcIiB9O1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgQ29tbWVudE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogNDBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejoyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVjdC5uYW1lID0gXCJSZWN0XCI7XHJcbiAgICAgICAgdGhpcy5hZGQocmVjdCk7XHJcbiAgICAgICAgdmFyIGxpbmUgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcclxuICAgICAgICAgICAgc2hhcGU6IHt4MTowLCAgeTE6MCwgeDI6MTAsIHkyOjB9LFxyXG4gICAgICAgICAgICBzdHlsZToge2xpbmVXaWR0aDoxLCBzdHJva2U6IFwiIzAwMFwifVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWRkKGxpbmUpO1xyXG4gICAgICAgIHZhciBsaW5lMSA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICBzaGFwZToge3gxOjAsICB5MTowLCB4MjowLCB5Mjo0MH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7bGluZVdpZHRoOjEsIHN0cm9rZTogXCIjMDAwXCJ9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hZGQobGluZTEpO1xyXG4gICAgICAgIHZhciBsaW5lMiA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICBzaGFwZToge3gxOjAsICB5MTo0MCwgeDI6MTAsIHkyOjQwfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtsaW5lV2lkdGg6MSwgc3Ryb2tlOiBcIiMwMDBcIn1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZChsaW5lMik7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIildO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpLCAnJywgJ2xlZnQnKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuICAgIENvbW1lbnROb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24oanNvbikge1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0genJVdGlsLmNsb25lKHJlY3QpO1xyXG4gICAgICAgIC8vIOWPluaVtFxyXG4gICAgICAgIGJvdW5kaW5nUmVjdC54ID0gcGFyc2VJbnQoYm91bmRpbmdSZWN0LngsIDEwKTtcclxuICAgICAgICBib3VuZGluZ1JlY3QueSA9IHBhcnNlSW50KGJvdW5kaW5nUmVjdC55LCAxMCk7XHJcbiAgICAgICAgYm91bmRpbmdSZWN0LndpZHRoID0gcGFyc2VJbnQoYm91bmRpbmdSZWN0LndpZHRoLCAxMCk7XHJcbiAgICAgICAgYm91bmRpbmdSZWN0LmhlaWdodCA9IHBhcnNlSW50KGJvdW5kaW5nUmVjdC5oZWlnaHQsIDEwKTtcclxuICAgICAgICAvL+WIm+W7uuacgOWwj+WMheWbtOebkuiZmue6v1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICBwb2ludHNbMF0gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzFdID1bYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzJdID1bYm91bmRpbmdSZWN0LndpZHRoLzIsYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbM10gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbNF0gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcblxyXG4gICAgICAgIHZhciBib3VuZFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHRoaXMucG9zaXRpb25bMF0gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdSZWN0LndpZHRoLCBib3VuZGluZ1JlY3QuaGVpZ2h0KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB0aGlzLnBvc2l0aW9uWzBdK2JvdW5kaW5nUmVjdC53aWR0aC8yLFxyXG4gICAgICAgICAgICB5OiB0aGlzLnBvc2l0aW9uWzFdK2JvdW5kaW5nUmVjdC5oZWlnaHQvMixcclxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ1JlY3QuaGVpZ2h0LFxyXG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICAgICAgYm91bmRpbmdSZWN0OiBib3VuZFJlY3RcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIENvbW1lbnROb2RlLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHBYLHBZKSB7XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgdGhpcy5hdHRyKCdwb3NpdGlvbicsW3BYLWJvdW5kaW5nUmVjdC53aWR0aC8yLHBZLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBDb21tZW50Tm9kZS5wcm90b3R5cGUuZ2V0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNoaWxkT2ZOYW1lKFwiUmVjdFwiKTtcclxuICAgICAgICByZXR1cm4gcmVjdC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgIH07XHJcblxyXG4gICAgQ29tbWVudE5vZGUucHJvdG90eXBlLnVwZGF0ZVNoYXBlID0gZnVuY3Rpb24ocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJSZWN0XCIpO1xyXG4gICAgICAgIHZhciBzY2FsZVJhdGlvID0gTnVtYmVyKHJhdGlvKTtcclxuICAgICAgICB2YXIgc2hhcGUgPSByZWN0LnNoYXBlO1xyXG4gICAgICAgIHZhciBuZXdXID0gTnVtYmVyKHNoYXBlLndpZHRoICogc2NhbGVSYXRpbyk7XHJcbiAgICAgICAgdmFyIG5ld0ggPSBOdW1iZXIobmV3VyAqIHNoYXBlLmhlaWdodCAvIHNoYXBlLndpZHRoKTtcclxuICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICBuZXdXID0gcGFyc2VJbnQobmV3VywgMTApO1xyXG4gICAgICAgICAgICBuZXdIID0gcGFyc2VJbnQobmV3SCwgMTApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWN0LnNldFNoYXBlKHtcclxuICAgICAgICAgICAgd2lkdGg6IG5ld1csXHJcbiAgICAgICAgICAgIGhlaWdodDogbmV3SFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcblx0enJVdGlsLmluaGVyaXRzKENvbW1lbnROb2RlLCBCUE1OTm9kZSk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBDb21tZW50Tm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL0NvbW1lbnROb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL+i+ueeVjOS6i+S7ti0tLeaNleiOt+WumuaXtuWZqOS6i+S7tuiKgueCuVxyXG5cclxuXHR2YXIgRXZlbnROb2RlID0gcmVxdWlyZShcIi4uL0V2ZW50Tm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBpZD1cInNpZC1GRjBBREZDMC1EM0VDLTQyMzctQUQxNi1BMzYyNzNEMUZFNkRcIiB0aXRsZT1cIlN0YXJ0IGV2ZW50XCI+XHJcbiAqICAgIDxjaXJjbGUgaWQ9XCJzaWQtRjhERkJEQUQtMjg1Mi00QTlBLTg0RTktQTY1OTQzQTA5NjJCYmdfZnJhbWVcIiBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxNVwiIHN0cm9rZT1cIiM1ODU4NThcIiBmaWxsPVwiI2ZmZmZmZlwiIHN0cm9rZS13aWR0aD1cIjFcIiBzdHlsZT1cInN0cm9rZS1kYXNoYXJyYXk6IDUuNSwgM1wiPjwvY2lyY2xlPlxyXG4gKiAgICA8Y2lyY2xlIGlkPVwic2lkLUY4REZCREFELTI4NTItNEE5QS04NEU5LUE2NTk0M0EwOTYyQmZyYW1lMl9ub25faW50ZXJydXB0aW5nXCIgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMTJcIiBzdHJva2U9XCIjNTg1ODU4XCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxXCIgc3R5bGU9XCJzdHJva2UtZGFzaGFycmF5OiA0LjUsIDNcIj48L2NpcmNsZT5cclxuICogICAgPGNpcmNsZSBpZD1cInNpZC1GOERGQkRBRC0yODUyLTRBOUEtODRFOS1BNjU5NDNBMDk2MkJmcmFtZVwiIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjE1XCIgc3Ryb2tlPVwiIzU4NTg1OFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMVwiPjwvY2lyY2xlPlxyXG4gKiAgICA8Y2lyY2xlIGlkPVwic2lkLUY4REZCREFELTI4NTItNEE5QS04NEU5LUE2NTk0M0EwOTYyQmZyYW1lMlwiIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjEyXCIgc3Ryb2tlPVwiIzU4NTg1OFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMVwiPjwvY2lyY2xlPlxyXG4gKiAgICA8cGF0aCBpZD1cInNpZC1GOERGQkRBRC0yODUyLTRBOUEtODRFOS1BNjU5NDNBMDk2MkJwYXRoMVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg2LDYpXCIgZD1cIk0gMTAgMCBDIDQuNDc3MTUyNSAwIDAgNC40NzcxNTI1IDAgMTAgQyAwIDE1LjUyMjg0NyA0LjQ3NzE1MjUgMjAgMTAgMjAgQyAxNS41MjI4NDcgMjAgMjAgMTUuNTIyODQ3IDIwIDEwIEMgMjAgNC40NzcxNTI1IDE1LjUyMjg0NyAxLjE4NDIzNzllLTE1IDEwIDAgeiBNIDkuMDkzNzUgMS4wMzEyNSBDIDkuMjI5MjE2NCAxLjAxNzQ5MjYgOS4zNjI4MjUgMS4wMzg5MzExIDkuNSAxLjAzMTI1IEwgOS41IDMuNSBMIDEwLjUgMy41IEwgMTAuNSAxLjAzMTI1IEMgMTUuMDYzNTI2IDEuMjg2NzgzMSAxOC43MTMyMTcgNC45MzY0NzM4IDE4Ljk2ODc1IDkuNSBMIDE2LjUgOS41IEwgMTYuNSAxMC41IEwgMTguOTY4NzUgMTAuNSBDIDE4LjcxMzIxNyAxNS4wNjM1MjYgMTUuMDYzNTI2IDE4LjcxMzIxNyAxMC41IDE4Ljk2ODc1IEwgMTAuNSAxNi41IEwgOS41IDE2LjUgTCA5LjUgMTguOTY4NzUgQyA0LjkzNjQ3MzggMTguNzEzMjE3IDEuMjg2NzgzMSAxNS4wNjM1MjYgMS4wMzEyNSAxMC41IEwgMy41IDEwLjUgTCAzLjUgOS41IEwgMS4wMzEyNSA5LjUgQyAxLjI3OTEwMiA1LjA3MzY0ODggNC43MjI1MzI2IDEuNDc1MTcxMyA5LjA5Mzc1IDEuMDMxMjUgeiBNIDkuNSA1IEwgOS41IDguMDYyNSBDIDguNjM3MzAwNyA4LjI4NDQ2MjcgOCA5LjA2ODAxOTUgOCAxMCBDIDggMTEuMTA0NTY5IDguODk1NDMwNSAxMiAxMCAxMiBDIDEwLjkzMTk4MSAxMiAxMS43MTU1MzcgMTEuMzYyNjk5IDExLjkzNzUgMTAuNSBMIDE0IDEwLjUgTCAxNCA5LjUgTCAxMS45Mzc1IDkuNSBDIDExLjc1NjY0MiA4Ljc5NzA1OTkgMTEuMjAyOTQgOC4yNDMzNTg1IDEwLjUgOC4wNjI1IEwgMTAuNSA1IEwgOS41IDUgeiBcIiBmaWxsPVwiIzU4NTg1OFwiIHN0cm9rZT1cIm5vbmVcIj48L3BhdGg+XHJcbiAqIDwvZz5cclxuICovXHJcblxyXG5cdGZ1bmN0aW9uIENhdGNoVGltZXJFdmVudE5vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0RXZlbnROb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SWNvbiA9ICdNIDEwIDAgQyA0LjQ3NzE1MjUgMCAwIDQuNDc3MTUyNSAwIDEwIEMgMCAxNS41MjI4NDcgNC40NzcxNTI1IDIwIDEwIDIwIEMgMTUuNTIyODQ3IDIwIDIwIDE1LjUyMjg0NyAyMCAxMCBDIDIwIDQuNDc3MTUyNSAxNS41MjI4NDcgMS4xODQyMzc5ZS0xNSAxMCAwIHogTSA5LjA5Mzc1IDEuMDMxMjUgQyA5LjIyOTIxNjQgMS4wMTc0OTI2IDkuMzYyODI1IDEuMDM4OTMxMSA5LjUgMS4wMzEyNSBMIDkuNSAzLjUgTCAxMC41IDMuNSBMIDEwLjUgMS4wMzEyNSBDIDE1LjA2MzUyNiAxLjI4Njc4MzEgMTguNzEzMjE3IDQuOTM2NDczOCAxOC45Njg3NSA5LjUgTCAxNi41IDkuNSBMIDE2LjUgMTAuNSBMIDE4Ljk2ODc1IDEwLjUgQyAxOC43MTMyMTcgMTUuMDYzNTI2IDE1LjA2MzUyNiAxOC43MTMyMTcgMTAuNSAxOC45Njg3NSBMIDEwLjUgMTYuNSBMIDkuNSAxNi41IEwgOS41IDE4Ljk2ODc1IEMgNC45MzY0NzM4IDE4LjcxMzIxNyAxLjI4Njc4MzEgMTUuMDYzNTI2IDEuMDMxMjUgMTAuNSBMIDMuNSAxMC41IEwgMy41IDkuNSBMIDEuMDMxMjUgOS41IEMgMS4yNzkxMDIgNS4wNzM2NDg4IDQuNzIyNTMyNiAxLjQ3NTE3MTMgOS4wOTM3NSAxLjAzMTI1IHogTSA5LjUgNSBMIDkuNSA4LjA2MjUgQyA4LjYzNzMwMDcgOC4yODQ0NjI3IDggOS4wNjgwMTk1IDggMTAgQyA4IDExLjEwNDU2OSA4Ljg5NTQzMDUgMTIgMTAgMTIgQyAxMC45MzE5ODEgMTIgMTEuNzE1NTM3IDExLjM2MjY5OSAxMS45Mzc1IDEwLjUgTCAxNCAxMC41IEwgMTQgOS41IEwgMTEuOTM3NSA5LjUgQyAxMS43NTY2NDIgOC43OTcwNTk5IDExLjIwMjk0IDguMjQzMzU4NSAxMC41IDguMDYyNSBMIDEwLjUgNSBMIDkuNSA1IHonO1xyXG4gICAgICAgIHRoaXMuaXRlbVNpemUgPSAxMDtcclxuXHRcdHRoaXMuYnBtbkluZm8gPSB7dHlwZTogNDMsIG5hbWU6XCJDYXRjaFRpbWVyRXZlbnRcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG4gICAgICAgIHRoaXMucmVuZGVyKG1vZGVsKTtcclxuXHR9XHJcblxyXG4gICAgQ2F0Y2hUaW1lckV2ZW50Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuXHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZS0wLjVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTonIzAwMCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejozXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlLm5hbWUgPSBcIkNpcmNsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZSk7XHJcbiAgICAgICAgdmFyIGNpcmNsZTEgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgIHI6IHRoaXMuaXRlbVNpemUtM1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjNcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaXJjbGUxLm5hbWUgPSBcIkNpcmNsZTFcIjtcclxuICAgICAgICB0aGlzLmFkZChjaXJjbGUxKTtcclxuXHJcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZSs2O1xyXG4gICAgICAgIHZhciByZWN0ID0ge3g6LWl0ZW1TaXplLzIsIHk6IC1pdGVtU2l6ZS8yLCB3aWR0aDogaXRlbVNpemUsIGhlaWdodDppdGVtU2l6ZX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLnN0YXJ0SWNvbiwge3N0eWxlOiB7c3Ryb2tlOicjMDAwJ30sejozfSwgcmVjdCxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikrdGhpcy5pdGVtU2l6ZSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKSt0aGlzLml0ZW1TaXplXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAgICAgICAgdGl0bGUudGV4dC5uYW1lID0gXCJUaXRsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHRpdGxlLnRleHQpO1xyXG4gICAgICAgIHRoaXMueiA9IDM7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoQ2F0Y2hUaW1lckV2ZW50Tm9kZSwgRXZlbnROb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IENhdGNoVGltZXJFdmVudE5vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L0NhdGNoVGltZXJFdmVudE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8v6L6555WM5LqL5Lu2LS0t5o2V6I635L+h5Y+36YeP5LqL5Lu2XHJcblxyXG5cdHZhciBFdmVudE5vZGUgPSByZXF1aXJlKFwiLi4vRXZlbnROb2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIDxnIHBvaW50ZXItZXZlbnRzPVwiZmlsbFwiIGlkPVwic2lkLUZGMEFERkMwLUQzRUMtNDIzNy1BRDE2LUEzNjI3M0QxRkU2RFwiIHRpdGxlPVwiU3RhcnQgZXZlbnRcIj5cclxuICogICAgPGNpcmNsZSBpZD1cInNpZC1GOERGQkRBRC0yODUyLTRBOUEtODRFOS1BNjU5NDNBMDk2MkJiZ19mcmFtZVwiIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjE1XCIgc3Ryb2tlPVwiIzU4NTg1OFwiIGZpbGw9XCIjZmZmZmZmXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIHN0eWxlPVwic3Ryb2tlLWRhc2hhcnJheTogNS41LCAzXCI+PC9jaXJjbGU+XHJcbiAqICAgIDxjaXJjbGUgaWQ9XCJzaWQtRjhERkJEQUQtMjg1Mi00QTlBLTg0RTktQTY1OTQzQTA5NjJCZnJhbWUyX25vbl9pbnRlcnJ1cHRpbmdcIiBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxMlwiIHN0cm9rZT1cIiM1ODU4NThcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjFcIiBzdHlsZT1cInN0cm9rZS1kYXNoYXJyYXk6IDQuNSwgM1wiPjwvY2lyY2xlPlxyXG4gKiAgICA8cGF0aCBpZD1cInNpZC0zQ0MzMzkyNC03M0YzLTREMTMtQTJBOS0wMjQyNTMwNjgwREVzaWduYWxDYXRjaGluZ1wiIHN0cm9rZT1cIiM1ODU4NThcIiBkPVwiIE03LjcxMjQ5NzEgMjAuMjQ3MzQyICBMMjIuMzMzMzM0IDIwLjI0NzM0MiAgTDE1LjAyMjkxNTAwMDAwMDAwMSA3LjU3NTk1MTIwMDAwMDAwMSAgTDcuNzEyNDk3MSAyMC4yNDczNDIgIHpcIiBzdHlsZT1cImZpbGw6bm9uZTtzdHJva2Utd2lkdGg6MS40O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lXCI+PC9wYXRoPlxyXG4gKiA8L2c+XHJcbiAqL1xyXG5cclxuXHRmdW5jdGlvbiBDYXRjaFNpZ25hbEV2ZW50Tm9kZShtb2RlbCwgYXBpKSB7XHJcblx0XHRFdmVudE5vZGUuY2FsbCh0aGlzLG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJY29uID0gJ003LjcxMjQ5NzEgMjAuMjQ3MzQyICBMMjIuMzMzMzM0IDIwLjI0NzM0MiAgTDE1LjAyMjkxNTAwMDAwMDAwMSA3LjU3NTk1MTIwMDAwMDAwMSAgTDcuNzEyNDk3MSAyMC4yNDczNDIgIHonO1xyXG4gICAgICAgIHRoaXMuaXRlbVNpemUgPSAxMDtcclxuXHRcdHRoaXMuYnBtbkluZm8gPSB7dHlwZTogNzIsIG5hbWU6XCJDYXRjaFNpZ25hbEV2ZW50XCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcblx0fVxyXG5cclxuICAgIENhdGNoU2lnbmFsRXZlbnROb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG5cclxuICAgICAgICB2YXIgY2lyY2xlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgICAgICByOiB0aGlzLml0ZW1TaXplLTAuNVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjNcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaXJjbGUubmFtZSA9IFwiQ2lyY2xlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQoY2lyY2xlKTtcclxuICAgICAgICB2YXIgY2lyY2xlMSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZS0zXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZmZmZicsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6JyMwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6M1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNpcmNsZTEubmFtZSA9IFwiQ2lyY2xlMVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZTEpO1xyXG5cclxuICAgICAgICB2YXIgaXRlbVNpemUgPSB0aGlzLml0ZW1TaXplO1xyXG4gICAgICAgIHZhciByZWN0ID0ge3g6LWl0ZW1TaXplLzIsIHk6IC1pdGVtU2l6ZS8yLTIsIHdpZHRoOiBpdGVtU2l6ZSwgaGVpZ2h0Oml0ZW1TaXplfTtcclxuICAgICAgICB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMuc3RhcnRJY29uLCB7c3R5bGU6IHtzdHJva2U6JyMwMDAnLGZpbGw6JyNmZmZmZmYnfSx6OjN9LCByZWN0LFwiY2VudGVyXCIpKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSt0aGlzLml0ZW1TaXplICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpK3RoaXMuaXRlbVNpemVdO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICAgICAgdGhpcy56ID0gMztcclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhDYXRjaFNpZ25hbEV2ZW50Tm9kZSwgRXZlbnROb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IENhdGNoU2lnbmFsRXZlbnROb2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZXZlbnQvYm91bmRhcnlldmVudC9DYXRjaFNpZ25hbEV2ZW50Tm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy/ovrnnlYzkuovku7YtLS1UaHJvd1NpZ25hbEV2ZW506IqC54K5XHJcblxyXG5cdHZhciBFdmVudE5vZGUgPSByZXF1aXJlKFwiLi4vRXZlbnROb2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIDxnIHBvaW50ZXItZXZlbnRzPVwiZmlsbFwiIGlkPVwic2lkLUZGMEFERkMwLUQzRUMtNDIzNy1BRDE2LUEzNjI3M0QxRkU2RFwiIHRpdGxlPVwiU3RhcnQgZXZlbnRcIj5cclxuICogICAgPGNpcmNsZSBpZD1cInNpZC1GOERGQkRBRC0yODUyLTRBOUEtODRFOS1BNjU5NDNBMDk2MkJiZ19mcmFtZVwiIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjE1XCIgc3Ryb2tlPVwiIzU4NTg1OFwiIGZpbGw9XCIjZmZmZmZmXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIHN0eWxlPVwic3Ryb2tlLWRhc2hhcnJheTogNS41LCAzXCI+PC9jaXJjbGU+XHJcbiAqICAgIDxjaXJjbGUgaWQ9XCJzaWQtRjhERkJEQUQtMjg1Mi00QTlBLTg0RTktQTY1OTQzQTA5NjJCZnJhbWUyX25vbl9pbnRlcnJ1cHRpbmdcIiBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxMlwiIHN0cm9rZT1cIiM1ODU4NThcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjFcIiBzdHlsZT1cInN0cm9rZS1kYXNoYXJyYXk6IDQuNSwgM1wiPjwvY2lyY2xlPlxyXG4gKiAgICA8cGF0aCBpZD1cInNpZC0zQ0MzMzkyNC03M0YzLTREMTMtQTJBOS0wMjQyNTMwNjgwREVzaWduYWxDYXRjaGluZ1wiIHN0cm9rZT1cIiM1ODU4NThcIiBkPVwiIE03LjcxMjQ5NzEgMjAuMjQ3MzQyICBMMjIuMzMzMzM0IDIwLjI0NzM0MiAgTDE1LjAyMjkxNTAwMDAwMDAwMSA3LjU3NTk1MTIwMDAwMDAwMSAgTDcuNzEyNDk3MSAyMC4yNDczNDIgIHpcIiBzdHlsZT1cImZpbGw6bm9uZTtzdHJva2Utd2lkdGg6MS40O3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lXCI+PC9wYXRoPlxyXG4gKiA8L2c+XHJcbiAqL1xyXG5cclxuXHRmdW5jdGlvbiBUaHJvd1NpZ25hbEV2ZW50Tm9kZShtb2RlbCwgYXBpKSB7XHJcblx0XHRFdmVudE5vZGUuY2FsbCh0aGlzLG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJY29uID0gJ003LjcxMjQ5NzEgMjAuMjQ3MzQyICBMMjIuMzMzMzM0IDIwLjI0NzM0MiAgTDE1LjAyMjkxNTAwMDAwMDAwMSA3LjU3NTk1MTIwMDAwMDAwMSAgTDcuNzEyNDk3MSAyMC4yNDczNDIgIHonO1xyXG4gICAgICAgIHRoaXMuaXRlbVNpemUgPSAxMDtcclxuXHRcdHRoaXMuYnBtbkluZm8gPSB7dHlwZTogNzUsIG5hbWU6XCJUaHJvd1NpZ25hbEV2ZW50XCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcblx0fVxyXG5cclxuICAgIFRocm93U2lnbmFsRXZlbnROb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciBjaXJjbGUgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgIHI6IHRoaXMuaXRlbVNpemUtMC41XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZmZmZicsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6JyMwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6M1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNpcmNsZS5uYW1lID0gXCJDaXJjbGVcIjtcclxuICAgICAgICB0aGlzLmFkZChjaXJjbGUpO1xyXG4gICAgICAgIHZhciBjaXJjbGUxID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgICAgICByOiB0aGlzLml0ZW1TaXplLTNcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTonIzAwMCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejozXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlMS5uYW1lID0gXCJDaXJjbGUxXCI7XHJcbiAgICAgICAgdGhpcy5hZGQoY2lyY2xlMSk7XHJcblxyXG4gICAgICAgIHZhciBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemU7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB7eDotaXRlbVNpemUvMiwgeTogLWl0ZW1TaXplLzItMiwgd2lkdGg6IGl0ZW1TaXplLCBoZWlnaHQ6aXRlbVNpemV9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5zdGFydEljb24sIHtzdHlsZToge3N0cm9rZTonIzAwMCcsZmlsbDonIzAwMDAwMCd9LHo6M30sIHJlY3QsXCJjZW50ZXJcIikpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpK3RoaXMuaXRlbVNpemUgLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIikrdGhpcy5pdGVtU2l6ZV07XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5kcmF3VGV4dChtb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgICAgICB0aGlzLnogPSAzO1xyXG4gICAgfTtcclxuXHJcblx0enJVdGlsLmluaGVyaXRzKFRocm93U2lnbmFsRXZlbnROb2RlLCBFdmVudE5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gVGhyb3dTaWduYWxFdmVudE5vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L1Rocm93U2lnbmFsRXZlbnROb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL+i+ueeVjOS6i+S7ti0tLeaNleiOt+WumuaXtuWZqOS6i+S7tuiKgueCuVxyXG5cclxuXHR2YXIgRXZlbnROb2RlID0gcmVxdWlyZShcIi4vRXZlbnROb2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG5cclxuXHRmdW5jdGlvbiBDYXRjaE1lc3NhZ2VFdmVudE5vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0RXZlbnROb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SWNvbiA9IFwiTTY2NC4zNTY1NzEgNjMzLjM0NGwtNTAuNzk3NzE0IDAgMjI4LjgyNzQyOSAxNDYuOTgwNTcxTDE4MS42MTM3MTQgNzgwLjMyNDU3MWwyMjguODI3NDI5LTE0Ni45ODA1NzEtNTAuODM0Mjg2IDAtMjAzLjE5MDg1NyAxMzAuNDUwMjg2TDE1Ni40MTYgMzU5LjA5NDg1N2wzNTkuMDIxNzE0IDI0Mi41NzgyODYgMzUyLjE0NjI4Ni0yMzUuMzAwNTcxIDAgMzk3LjQ1ODI4Nkw2NjQuMzU2NTcxIDYzMy4zNDR6TTE1Ni40MTYgMjk5LjkyMjI4NiAxNTYuNDE2IDI0My42NzU0MjlsNzExLjE2OCAwIDAgNzEuMzE0Mjg2LTM1MS4zNzgyODYgMjIyLjE3MTQyOUwxNTYuNDE2IDI5OS45MjIyODZ6XCI7XHJcbiAgICAgICAgdGhpcy5pdGVtU2l6ZSA9IDIwO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAxMDAsIG5hbWU6XCJDYXRjaE1lc3NhZ2VFdmVudFwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBDYXRjaE1lc3NhZ2VFdmVudE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaXJjbGUubmFtZSA9IFwiQ2lyY2xlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQoY2lyY2xlKTtcclxuICAgICAgICB2YXIgY2lyY2xlMSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZS0zXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZmZmZicsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6JyMwMDAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNpcmNsZTEubmFtZSA9IFwiQ2lyY2xlMVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZTEpO1xyXG5cclxuICAgICAgICB2YXIgaXRlbVNpemUgPSB0aGlzLml0ZW1TaXplO1xyXG4gICAgICAgIHZhciByZWN0ID0ge3g6LWl0ZW1TaXplLzIsIHk6IC1pdGVtU2l6ZS8yLCB3aWR0aDogaXRlbVNpemUsIGhlaWdodDppdGVtU2l6ZX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLnN0YXJ0SWNvbiwge3N0eWxlOiB7c3Ryb2tlOicjZmZmJ30sejoyfSwgcmVjdCxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikrdGhpcy5pdGVtU2l6ZSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKSt0aGlzLml0ZW1TaXplXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAgICAgICAgdGl0bGUudGV4dC5uYW1lID0gXCJUaXRsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHRpdGxlLnRleHQpO1xyXG4gICAgfTtcclxuXHJcblx0enJVdGlsLmluaGVyaXRzKENhdGNoTWVzc2FnZUV2ZW50Tm9kZSwgRXZlbnROb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IENhdGNoTWVzc2FnZUV2ZW50Tm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2V2ZW50L0NhdGNoTWVzc2FnZUV2ZW50Tm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy9JbmNsdXNpdmVHYXRlV2F56IqC54K5XHJcblxyXG5cdHZhciBHYXRld2F5Tm9kZSA9IHJlcXVpcmUoXCIuL0dhdGV3YXlOb2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIDxnIHBvaW50ZXItZXZlbnRzPVwiZmlsbFwiIGlkPVwic2lkLUZGMEFERkMwLUQzRUMtNDIzNy1BRDE2LUEzNjI3M0QxRkU2RFwiIHRpdGxlPVwiU3RhcnQgZXZlbnRcIj5cclxuICogICAgPHBhdGggZD1cIiBNMCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMCAgTDM5LjAxMjc4Nzk2NCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMzkuMDEyNzg3OTY0ICBMMCAxOS41MDYzOTM5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgelwiIGlkPVwic2lkLTZEMEU5M0RBLTBFMEItNDdGMC1BRjg1LTNGMzIzMDM2NzY1MVJlY3RhbmdsZS0xXCIgZmlsbD1cIiNGNkE2MjNcIj48L3BhdGg+XHJcbiAqICAgIDxwYXRoIGQ9XCIgTTE5Ljg1MTIyMTU2NCAyNy43ODIyNTYwNjQwMDAwMDIgIEMyNC4yMzE0MTA5NjQgMjcuNzgyMjU2MDY0MDAwMDAyIDI3Ljc4MjI1NjA2NDAwMDAwMiAyNC4yMzE0MTA5NjQgMjcuNzgyMjU2MDY0MDAwMDAyIDE5Ljg1MTIyMTU2NCAgQzI3Ljc4MjI1NjA2NDAwMDAwMiAxNS40NzEwMzIxNjM5OTk5OTkgMjQuMjMxNDEwOTY0IDExLjkyMDE4NzA2Mzk5OTk5OSAxOS44NTEyMjE1NjQgMTEuOTIwMTg3MDYzOTk5OTk5ICBDMTUuNDcxMDMyMTYzOTk5OTk5IDExLjkyMDE4NzA2Mzk5OTk5OSAxMS45MjAxODcwNjM5OTk5OTkgMTUuNDcxMDMyMTYzOTk5OTk5IDExLjkyMDE4NzA2Mzk5OTk5OSAxOS44NTEyMjE1NjQgIEMxMS45MjAxODcwNjM5OTk5OTkgMjQuMjMxNDEwOTY0IDE1LjQ3MTAzMjE2Mzk5OTk5OSAyNy43ODIyNTYwNjQwMDAwMDIgMTkuODUxMjIxNTY0IDI3Ljc4MjI1NjA2NDAwMDAwMiAgelwiIGlkPVwic2lkLTZEMEU5M0RBLTBFMEItNDdGMC1BRjg1LTNGMzIzMDM2NzY1MU92YWwtNFwiIGZpbGw9XCIjRkZGRkZGXCI+PC9wYXRoPlxyXG4gKiA8L2c+XHJcbiAqL1xyXG5cclxuXHRmdW5jdGlvbiBJbmNsdXNpdmVHYXRld2F5Tm9kZShtb2RlbCwgYXBpKSB7XHJcblx0XHRHYXRld2F5Tm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJY29uID0gJ00wIDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAwICBMMzkuMDEyNzg3OTY0IDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAzOS4wMTI3ODc5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgTDAgMTkuNTA2MzkzOTY0ICB6JztcclxuICAgICAgICB0aGlzLm5leHRJY29uID0gJ001MDcuNzM4MyA0OS40NjM4NjdDMzI3LjM4OTU3IDQ4Ljg2NTA1NSAxNTQuMzM3MDQ1IDE2NS4zOTcyMzUgODUuODg3Njk1IDMzMi4wOTU3MDUgMTMuODI4MjggNDk3LjE3MTg3NSA1MS4yNjkyMSA3MDIuMjM3NiAxNzcuMzE4MzYgODMwLjk4MTQ1IDI5OC41NTAyIDk2MS40Nzc0IDQ5OC4yOTI5NyAxMDA5LjM3NDcgNjY1LjU3ODEgOTQ4LjMxNzQgODM4Ljk0OCA4ODkuMjgwNjUgOTY2LjkzOTkgNzE5LjAyMDU1IDk3My44OTc0NSA1MzUuNzcxNSA5ODUuNTY3MTUgMzU1LjcwNjE0NSA4NzkuNjI5OCAxNzYuMDYwODI1IDcxNy40MjA5IDk3LjYyNSA2NTMuOTAzNjUgNjUuOTI3OTc1IDU4Mi45NzQ2NSA0OS4zOTg1MDkgNTEyIDQ5LjUgNTEwLjU3OTA1IDQ5LjQ4MDcyOCA1MDkuMTU4MzUgNDkuNDY4NTgyIDUwNy43MzgzIDQ5LjQ2Mzg2N3pNNTIwLjQxNDA1IDk5LjQ1MDE5NUM2OTYuOTUwMyAxMDAuNDE5MzE1IDg2My4yMTY0IDIyOC4xMjk1MyA5MDguODczMDUgMzk4Ljk2NDg0NSA5NTcuMzg4MSA1NjIuNDE4NjUgODkxLjc2NjIgNzUxLjY2NzYgNzUwLjkxOTkgODQ4LjQ3NzU1IDYwNC42MTM2NSA5NTYuMDE0NzUgMzg3LjY0OTYzIDk0OC4yMzQ0NSAyNDkuNDg4MjggODMwLjM5OTQgMTEwLjI4MTI1IDcxOS40MDk0NSA2MC40NTIzNjUgNTE0LjExMTY1IDEzMS44NzUgMzUxLjMwODU5NSAxOTMuNzc4NzMgMjAwLjgwMjQzIDM0OS4xNjg5MSA5Ny41ODk0MSA1MTIgOTkuNSA1MTQuODA2OSA5OS40NTExODUgNTE3LjYxMTkgOTkuNDM0ODEgNTIwLjQxNDA1IDk5LjQ1MDE5NXonO1xyXG4gICAgICAgIHRoaXMuaXRlbVNpemUgPSAyMDtcclxuXHRcdHRoaXMuYnBtbkluZm8gPSB7dHlwZTogMjAsIG5hbWU6XCJJbmNsdXNpdmVHYXRld2F5XCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcblx0fVxyXG5cclxuICAgIEluY2x1c2l2ZUdhdGV3YXlOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemUqMjtcclxuICAgICAgICB2YXIgcmVjdCA9IHt4Oi1pdGVtU2l6ZS8yLCB5OiAtaXRlbVNpemUvMiwgd2lkdGg6IGl0ZW1TaXplLCBoZWlnaHQ6aXRlbVNpemV9O1xyXG4gICAgICAgIHZhciBwYXRoID0gZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLnN0YXJ0SWNvbiwge3N0eWxlOiB7c3Ryb2tlOiAnIzAwMCcsIGZpbGw6ICcjZmZmJ30sejoyfSwgcmVjdCxcImNlbnRlclwiKTtcclxuICAgICAgICBwYXRoLm5hbWUgPSAnUGF0aCc7XHJcbiAgICAgICAgdGhpcy5hZGQocGF0aCk7XHJcbiAgICAgICAgdmFyIGl0ZW1TaXplMSA9IHRoaXMuaXRlbVNpemU7XHJcbiAgICAgICAgdmFyIHJlY3QxID0ge3g6LWl0ZW1TaXplMS8yLCB5OiAtaXRlbVNpemUxLzIsIHdpZHRoOiBpdGVtU2l6ZTEsIGhlaWdodDppdGVtU2l6ZTF9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5uZXh0SWNvbiwge3N0eWxlOiB7c3Ryb2tlOiAnIzAwMCd9LHo6Mn0sIHJlY3QxLFwiY2VudGVyXCIpKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKStpdGVtU2l6ZTEgLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIikraXRlbVNpemUxXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAgICAgICAgdGl0bGUudGV4dC5uYW1lID0gXCJUaXRsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHRpdGxlLnRleHQpO1xyXG4gICAgfTtcclxuXHJcblx0enJVdGlsLmluaGVyaXRzKEluY2x1c2l2ZUdhdGV3YXlOb2RlLCBHYXRld2F5Tm9kZSk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBJbmNsdXNpdmVHYXRld2F5Tm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvSW5jbHVzaXZlR2F0ZXdheU5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8v5omA5pyJR2F0ZVdheeiKgueCueeahOWfuuexu1xyXG5cclxuICAgIHZhciBCUE1OTm9kZSA9IHJlcXVpcmUoXCIuLi9CUE1OTm9kZVwiKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcbiAgICAvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZSAg5YyF5ousZnJvbUpTT04gdG9KU09OXHJcbiAgICAvL1xyXG4gICAgZnVuY3Rpb24gR2F0ZXdheU5vZGUobW9kZWwsIGFwaSkge1xyXG4gICAgICAgIEJQTU5Ob2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5icG1uSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTpcIkdhdGV3YXlOb2RlXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICB9XHJcblxyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHpyVXRpbC5jbG9uZShyZWN0KTtcclxuICAgICAgICAvLyDlj5bmlbRcclxuICAgICAgICBib3VuZGluZ1JlY3QueCA9IHBhcnNlSW50KGJvdW5kaW5nUmVjdC54LCAxMCk7XHJcbiAgICAgICAgYm91bmRpbmdSZWN0LnkgPSBwYXJzZUludChib3VuZGluZ1JlY3QueSwgMTApO1xyXG4gICAgICAgIGJvdW5kaW5nUmVjdC53aWR0aCA9IHBhcnNlSW50KGJvdW5kaW5nUmVjdC53aWR0aCwgMTApO1xyXG4gICAgICAgIGJvdW5kaW5nUmVjdC5oZWlnaHQgPSBwYXJzZUludChib3VuZGluZ1JlY3QuaGVpZ2h0LCAxMCk7XHJcbiAgICAgICAgLy/liJvlu7rmnIDlsI/ljIXlm7Tnm5LomZrnur9cclxuICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgcG9pbnRzWzBdID1bLWJvdW5kaW5nUmVjdC53aWR0aC8yLC1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1sxXSA9W2JvdW5kaW5nUmVjdC53aWR0aC8yLC1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1syXSA9W2JvdW5kaW5nUmVjdC53aWR0aC8yLGJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzNdID1bLWJvdW5kaW5nUmVjdC53aWR0aC8yLGJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzRdID1bLWJvdW5kaW5nUmVjdC53aWR0aC8yLC1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHZhciBib3VuZFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHRoaXMucG9zaXRpb25bMF0gLSBib3VuZGluZ1JlY3Qud2lkdGgvMiAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSAtIGJvdW5kaW5nUmVjdC5oZWlnaHQvMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMucG9zaXRpb25bMF0sXHJcbiAgICAgICAgICAgIHk6IHRoaXMucG9zaXRpb25bMV0sXHJcbiAgICAgICAgICAgIHdpZHRoOiBib3VuZGluZ1JlY3Qud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogYm91bmRpbmdSZWN0LmhlaWdodCxcclxuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgICAgIGJvdW5kaW5nUmVjdDogYm91bmRSZWN0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9O1xyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocFgscFkpIHtcclxuICAgICAgICAvLyBib2R5Li4uXHJcbiAgICAgICAgdGhpcy5hdHRyKCdwb3NpdGlvbicsW3BYLHBZXSk7XHJcbiAgICB9O1xyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5jaGlsZE9mTmFtZShcIlBhdGhcIik7XHJcbiAgICAgICAgcmV0dXJuIHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICB9O1xyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLnVwZGF0ZVNoYXBlID0gZnVuY3Rpb24ocmF0aW8sIGlmUGFyc2UpIHtcclxuICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgdmFyIGdldEJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLmNoaWxkT2ZOYW1lKFwiUGF0aFwiKTtcclxuICAgICAgICB2YXIgd2lkdGggPSBnZXRCb3VuZGluZ1JlY3Qud2lkdGggKiBzY2FsZVJhdGlvO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBnZXRCb3VuZGluZ1JlY3QuaGVpZ2h0ICogc2NhbGVSYXRpbztcclxuICAgICAgICBpZiAoaWZQYXJzZSkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHdpZHRoLCAxMCk7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IHBhcnNlSW50KGhlaWdodCwgMTApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVjdCA9IHt4Oi13aWR0aC8yLCB5OiAtaGVpZ2h0LzIsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OmhlaWdodH07XHJcbiAgICAgICAgZ3JhcGhpYy5yZXNpemVQYXRoKHBhdGgsIHJlY3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoR2F0ZXdheU5vZGUsQlBNTk5vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHYXRld2F5Tm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvR2F0ZXdheU5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL0V4Y2x1c2l2ZUdhdGVXYXnoioLngrlcclxuXHJcblx0dmFyIEdhdGV3YXlOb2RlID0gcmVxdWlyZShcIi4vR2F0ZXdheU5vZGVcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcblxyXG4vKipcclxuICogPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgaWQ9XCJzaWQtRkYwQURGQzAtRDNFQy00MjM3LUFEMTYtQTM2MjczRDFGRTZEXCIgdGl0bGU9XCJTdGFydCBldmVudFwiPlxyXG4gKiAgICA8cGF0aCBkPVwiIE0wIDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAwICBMMzkuMDEyNzg3OTY0IDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAzOS4wMTI3ODc5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgTDAgMTkuNTA2MzkzOTY0ICB6XCIgaWQ9XCJzaWQtNkQwRTkzREEtMEUwQi00N0YwLUFGODUtM0YzMjMwMzY3NjUxUmVjdGFuZ2xlLTFcIiBmaWxsPVwiI0Y2QTYyM1wiPjwvcGF0aD5cclxuICogICAgPHBhdGggZD1cIiBNOC4yNzU4NjIwNjkgMTEuOTY1NTE3MjY5MDAwMDAxICBMMS40OTk5OTk5OTkgMTEuOTY1NTE3MjY5MDAwMDAxICBMMCAxMS45NjU1MTcyNjkwMDAwMDEgIEwwIDguOTY1NTE3MjM5ICBMMS40OTk5OTk5OTkgOC45NjU1MTcyMzkgIEw4LjI3NTg2MjA2OSA4Ljk2NTUxNzIzOSAgTDguMjc1ODYyMDY5IDEuNDk5OTk5OTk5ICBMOC4yNzU4NjIwNjkgMCAgTDExLjI3NTg2MjA2OSAwICBMMTEuMjc1ODYyMDY5IDEuNDk5OTk5OTk5ICBMMTEuMjc1ODYyMDY5IDguOTY1NTE3MjM5ICBMMTguNzQxMzc5MjY5IDguOTY1NTE3MjM5ICBMMjAuMjQxMzc5MjY5IDguOTY1NTE3MjM5ICBMMjAuMjQxMzc5MjY5IDExLjk2NTUxNzI2OTAwMDAwMSAgTDE4Ljc0MTM3OTI2OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwxMS4yNzU4NjIwNjkgMTEuOTY1NTE3MjY5MDAwMDAxICBMMTEuMjc1ODYyMDY5IDE4Ljc0MTM3OTI2OSAgTDExLjI3NTg2MjA2OSAyMC4yNDEzNzkyNjkgIEw4LjI3NTg2MjA2OSAyMC4yNDEzNzkyNjkgIEw4LjI3NTg2MjA2OSAxOC43NDEzNzkyNjkgIEw4LjI3NTg2MjA2OSAxMS45NjU1MTcyNjkwMDAwMDEgIHpcIiBpZD1cInNpZC0xQjg4RDJERi1BMDhGLTQ4MzctOTFGMi05MUY2N0FDQUIyOUFMaW5lLUNvcHlcIj48L3BhdGg+XHJcbiAqIDwvZz5cclxuICovXHJcblxyXG5cdGZ1bmN0aW9uIEV4Y2x1c2l2ZUdhdGV3YXlOb2RlKG1vZGVsLCBhcGkpIHtcclxuXHRcdEdhdGV3YXlOb2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5zdGFydEljb24gPSAnTTAgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDAgIEwzOS4wMTI3ODc5NjQgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDM5LjAxMjc4Nzk2NCAgTDAgMTkuNTA2MzkzOTY0ICBMMCAxOS41MDYzOTM5NjQgIHonO1xyXG4gICAgICAgIHRoaXMubmV4dEljb24gPSAnTTE5LjkwNDEyOTA2NDAwMDAwMyAxNy42NzY5OTM5NjQwMDAwMDUgIEwyNC45OTc0NTc4NjQwMDAwMDUgMTIuNTgzNjY0ODY0MDAwMDAzICBMMjYuMDU4MTE4MDY0MDAwMDA2IDExLjUyMzAwNDY2NDAwMDAwMiAgTDI4LjE3OTQzODQ2NCAxMy42NDQzMjQ5NjQwMDAwMDMgIEwyNy4xMTg3NzgyNjQgMTQuNzA0OTg1MTY0MDAwMDAyICBMMjIuMDI1NDQ5MzY0MDAwMDA0IDE5Ljc5ODMxNDM2NCAgTDI3LjExODc3ODI2NCAyNC44OTE2NDM0NjQwMDAwMDUgIEwyOC4xNzk0Mzg0NjQgMjUuOTUyMzAzNjY0MDAwMDA2ICBMMjYuMDU4MTE4MDY0MDAwMDA2IDI4LjA3MzYyMzk2NDAwMDAwMyAgTDI0Ljk5NzQ1Nzg2NDAwMDAwNSAyNy4wMTI5NjM3NjQwMDAwMDYgIEwxOS45MDQxMjkwNjQwMDAwMDMgMjEuOTE5NjM0NzY0ICBMMTQuODEwODAwMTY0MDAwMDAzIDI3LjAxMjk2Mzc2NDAwMDAwNiAgTDEzLjc1MDE0MDA2NDAwMDAwMiAyOC4wNzM2MjM5NjQwMDAwMDMgIEwxMS42Mjg4MTk2NjQwMDAwMDMgMjUuOTUyMzAzNjY0MDAwMDA2ICBMMTIuNjg5NDc5NzY0MDAwMDAzIDI0Ljg5MTY0MzQ2NDAwMDAwNSAgTDE3Ljc4MjgwODc2NDAwMDAwMiAxOS43OTgzMTQzNjQgIEwxMi42ODk0Nzk3NjQwMDAwMDMgMTQuNzA0OTg1MTY0MDAwMDAyICBMMTEuNjI4ODE5NjY0MDAwMDAzIDEzLjY0NDMyNDk2NDAwMDAwMyAgTDEzLjc1MDE0MDA2NDAwMDAwMiAxMS41MjMwMDQ2NjQwMDAwMDIgIEwxNC44MTA4MDAxNjQwMDAwMDMgMTIuNTgzNjY0ODY0MDAwMDAzICBMMTkuOTA0MTI5MDY0MDAwMDAzIDE3LjY3Njk5Mzk2NDAwMDAwNSAgeic7XHJcbiAgICAgICAgdGhpcy5pdGVtU2l6ZSA9IDIwO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAxNywgbmFtZTpcIkV4Y2x1c2l2ZUdhdGV3YXlcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG4gICAgICAgIHRoaXMucmVuZGVyKG1vZGVsKTtcclxuXHR9XHJcblxyXG4gICAgRXhjbHVzaXZlR2F0ZXdheU5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZSoyO1xyXG4gICAgICAgIHZhciByZWN0ID0ge3g6LWl0ZW1TaXplLzIsIHk6IC1pdGVtU2l6ZS8yLCB3aWR0aDogaXRlbVNpemUsIGhlaWdodDppdGVtU2l6ZX07XHJcbiAgICAgICAgdmFyIHBhdGggPSBncmFwaGljLm1ha2VQYXRoKHRoaXMuc3RhcnRJY29uLCB7c3R5bGU6IHtzdHJva2U6ICcjMDAwJywgZmlsbDogJyNmZmYnfSx6OjJ9LCByZWN0LFwiY2VudGVyXCIpO1xyXG4gICAgICAgIHBhdGgubmFtZSA9ICdQYXRoJztcclxuICAgICAgICB0aGlzLmFkZChwYXRoKTtcclxuICAgICAgICB2YXIgaXRlbVNpemUxID0gdGhpcy5pdGVtU2l6ZTtcclxuICAgICAgICB2YXIgcmVjdDEgPSB7eDotaXRlbVNpemUxLzIsIHk6IC1pdGVtU2l6ZTEvMiwgd2lkdGg6IGl0ZW1TaXplMSwgaGVpZ2h0Oml0ZW1TaXplMX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLm5leHRJY29uLCB7c3R5bGU6IHtzdHJva2U6ICcjMDAwJ30sejoyfSwgcmVjdDEsXCJjZW50ZXJcIikpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpK2l0ZW1TaXplMSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKStpdGVtU2l6ZTFdO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoRXhjbHVzaXZlR2F0ZXdheU5vZGUsIEdhdGV3YXlOb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IEV4Y2x1c2l2ZUdhdGV3YXlOb2RlO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZ2F0ZXdheS9FeGNsdXNpdmVHYXRld2F5Tm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vUGFyYWxsZWxHYXRlV2F56IqC54K5XHJcblxyXG5cdHZhciBHYXRld2F5Tm9kZSA9IHJlcXVpcmUoXCIuL0dhdGV3YXlOb2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIDxnIHBvaW50ZXItZXZlbnRzPVwiZmlsbFwiIGlkPVwic2lkLUZGMEFERkMwLUQzRUMtNDIzNy1BRDE2LUEzNjI3M0QxRkU2RFwiIHRpdGxlPVwiU3RhcnQgZXZlbnRcIj5cclxuICogICAgPHBhdGggZD1cIiBNMCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMCAgTDM5LjAxMjc4Nzk2NCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMzkuMDEyNzg3OTY0ICBMMCAxOS41MDYzOTM5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgelwiIGlkPVwic2lkLTZEMEU5M0RBLTBFMEItNDdGMC1BRjg1LTNGMzIzMDM2NzY1MVJlY3RhbmdsZS0xXCIgZmlsbD1cIiNGNkE2MjNcIj48L3BhdGg+XHJcbiAqICAgIDxwYXRoIGQ9XCIgTTE5LjkwNDEyOTA2NDAwMDAwMyAxNy42NzY5OTM5NjQwMDAwMDUgIEwyNC45OTc0NTc4NjQwMDAwMDUgMTIuNTgzNjY0ODY0MDAwMDAzICBMMjYuMDU4MTE4MDY0MDAwMDA2IDExLjUyMzAwNDY2NDAwMDAwMiAgTDI4LjE3OTQzODQ2NCAxMy42NDQzMjQ5NjQwMDAwMDMgIEwyNy4xMTg3NzgyNjQgMTQuNzA0OTg1MTY0MDAwMDAyICBMMjIuMDI1NDQ5MzY0MDAwMDA0IDE5Ljc5ODMxNDM2NCAgTDI3LjExODc3ODI2NCAyNC44OTE2NDM0NjQwMDAwMDUgIEwyOC4xNzk0Mzg0NjQgMjUuOTUyMzAzNjY0MDAwMDA2ICBMMjYuMDU4MTE4MDY0MDAwMDA2IDI4LjA3MzYyMzk2NDAwMDAwMyAgTDI0Ljk5NzQ1Nzg2NDAwMDAwNSAyNy4wMTI5NjM3NjQwMDAwMDYgIEwxOS45MDQxMjkwNjQwMDAwMDMgMjEuOTE5NjM0NzY0ICBMMTQuODEwODAwMTY0MDAwMDAzIDI3LjAxMjk2Mzc2NDAwMDAwNiAgTDEzLjc1MDE0MDA2NDAwMDAwMiAyOC4wNzM2MjM5NjQwMDAwMDMgIEwxMS42Mjg4MTk2NjQwMDAwMDMgMjUuOTUyMzAzNjY0MDAwMDA2ICBMMTIuNjg5NDc5NzY0MDAwMDAzIDI0Ljg5MTY0MzQ2NDAwMDAwNSAgTDE3Ljc4MjgwODc2NDAwMDAwMiAxOS43OTgzMTQzNjQgIEwxMi42ODk0Nzk3NjQwMDAwMDMgMTQuNzA0OTg1MTY0MDAwMDAyICBMMTEuNjI4ODE5NjY0MDAwMDAzIDEzLjY0NDMyNDk2NDAwMDAwMyAgTDEzLjc1MDE0MDA2NDAwMDAwMiAxMS41MjMwMDQ2NjQwMDAwMDIgIEwxNC44MTA4MDAxNjQwMDAwMDMgMTIuNTgzNjY0ODY0MDAwMDAzICBMMTkuOTA0MTI5MDY0MDAwMDAzIDE3LjY3Njk5Mzk2NDAwMDAwNSAgelwiIGlkPVwic2lkLThGQ0Q2QzAxLUI5NzMtNEM5Qy1BOTBCLTNEMkFERkM3NTIxN0xpbmVcIiBmaWxsPVwiI0ZGRkZGRlwiPjwvcGF0aD5cclxuICogPC9nPlxyXG4gKi9cclxuXHJcblx0ZnVuY3Rpb24gUGFyYWxsZWxHYXRld2F5Tm9kZShtb2RlbCwgYXBpKSB7XHJcblx0XHRHYXRld2F5Tm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJY29uID0gJ00wIDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAwICBMMzkuMDEyNzg3OTY0IDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAzOS4wMTI3ODc5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgTDAgMTkuNTA2MzkzOTY0ICB6JztcclxuICAgICAgICB0aGlzLm5leHRJY29uID0gJ004LjI3NTg2MjA2OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwxLjQ5OTk5OTk5OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwwIDExLjk2NTUxNzI2OTAwMDAwMSAgTDAgOC45NjU1MTcyMzkgIEwxLjQ5OTk5OTk5OSA4Ljk2NTUxNzIzOSAgTDguMjc1ODYyMDY5IDguOTY1NTE3MjM5ICBMOC4yNzU4NjIwNjkgMS40OTk5OTk5OTkgIEw4LjI3NTg2MjA2OSAwICBMMTEuMjc1ODYyMDY5IDAgIEwxMS4yNzU4NjIwNjkgMS40OTk5OTk5OTkgIEwxMS4yNzU4NjIwNjkgOC45NjU1MTcyMzkgIEwxOC43NDEzNzkyNjkgOC45NjU1MTcyMzkgIEwyMC4yNDEzNzkyNjkgOC45NjU1MTcyMzkgIEwyMC4yNDEzNzkyNjkgMTEuOTY1NTE3MjY5MDAwMDAxICBMMTguNzQxMzc5MjY5IDExLjk2NTUxNzI2OTAwMDAwMSAgTDExLjI3NTg2MjA2OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwxMS4yNzU4NjIwNjkgMTguNzQxMzc5MjY5ICBMMTEuMjc1ODYyMDY5IDIwLjI0MTM3OTI2OSAgTDguMjc1ODYyMDY5IDIwLjI0MTM3OTI2OSAgTDguMjc1ODYyMDY5IDE4Ljc0MTM3OTI2OSAgTDguMjc1ODYyMDY5IDExLjk2NTUxNzI2OTAwMDAwMSAgeic7XHJcbiAgICAgICAgdGhpcy5pdGVtU2l6ZSA9IDIwO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAyMCwgbmFtZTpcIlBhcmFsbGVsR2F0ZXdheVwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBQYXJhbGxlbEdhdGV3YXlOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemUqMjtcclxuICAgICAgICB2YXIgcmVjdCA9IHt4Oi1pdGVtU2l6ZS8yLCB5OiAtaXRlbVNpemUvMiwgd2lkdGg6IGl0ZW1TaXplLCBoZWlnaHQ6aXRlbVNpemV9O1xyXG4gICAgICAgIHZhciBwYXRoID0gZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLnN0YXJ0SWNvbiwge3N0eWxlOiB7c3Ryb2tlOiAnIzAwMCcsIGZpbGw6ICcjZmZmJ30sejoyfSwgcmVjdCxcImNlbnRlclwiKTtcclxuICAgICAgICBwYXRoLm5hbWUgPSAnUGF0aCc7XHJcbiAgICAgICAgdGhpcy5hZGQocGF0aCk7XHJcbiAgICAgICAgdmFyIGl0ZW1TaXplMSA9IHRoaXMuaXRlbVNpemU7XHJcbiAgICAgICAgdmFyIHJlY3QxID0ge3g6LWl0ZW1TaXplMS8yLCB5OiAtaXRlbVNpemUxLzIsIHdpZHRoOiBpdGVtU2l6ZTEsIGhlaWdodDppdGVtU2l6ZTF9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5uZXh0SWNvbiwge3N0eWxlOiB7c3Ryb2tlOiAnIzAwMCd9LHo6Mn0sIHJlY3QxLFwiY2VudGVyXCIpKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKStpdGVtU2l6ZTEgLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIikraXRlbVNpemUxXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAgICAgICAgdGl0bGUudGV4dC5uYW1lID0gXCJUaXRsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHRpdGxlLnRleHQpO1xyXG4gICAgfTtcclxuXHJcblx0enJVdGlsLmluaGVyaXRzKFBhcmFsbGVsR2F0ZXdheU5vZGUsIEdhdGV3YXlOb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IFBhcmFsbGVsR2F0ZXdheU5vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9nYXRld2F5L1BhcmFsbGVsR2F0ZXdheU5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL+WtkOa1geeoi1xyXG5cclxuICAgIHZhciBCcG1uID0gcmVxdWlyZShcIi4uL0JwbW4uanNcIik7XHJcblx0dmFyIEJQTU5Ob2RlID0gcmVxdWlyZShcIi4vQlBNTk5vZGVcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcblx0Ly/liJvlu7pOb2Rl57G7IOaJgOacieW9oueKtumDvee7p+aJv05vZGVcclxuXHQvL1xyXG5cdGZ1bmN0aW9uIFN1YlByb2Nlc3NOb2RlKG1vZGVsLCBhcGkpIHtcclxuXHJcblx0XHRCUE1OTm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTpcIlN1YlByb2Nlc3NcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB0aGlzLnNsb3QgPSBbXTtcclxuICAgICAgICB0aGlzLnNsb3RFdmVudCA9IFtdO1xyXG4gICAgICAgIHRoaXMuaXNDYW5TbG90ID0gdHJ1ZTtcclxuICAgICAgICB2YXIgd2lkdGgsaGVpZ2h0O1xyXG4gICAgICAgIHdpZHRoID0gbW9kZWwuZ2V0KFwiYm91bmRzLmxvd2VyUmlnaHQueFwiKS1tb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIik7XHJcbiAgICAgICAgaGVpZ2h0ID0gbW9kZWwuZ2V0KFwiYm91bmRzLmxvd2VyUmlnaHQueVwiKS1tb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIik7XHJcbiAgICAgICAgaWYoIXdpZHRoIHx8IHdpZHRoIDw9IDApe1xyXG4gICAgICAgICAgICB3aWR0aCA9IDE2MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoIWhlaWdodCB8fCBoZWlnaHQgPD0gMCl7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IDEwMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVjdFNpemUgPSB7d2lkdGg6d2lkdGgsIGhlaWdodDpoZWlnaHR9O1xyXG4gICAgICAgIHRoaXMucmVuZGVyKG1vZGVsKTtcclxuXHR9XHJcblxyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbihhcGkpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydkYmxjbGljaycsICdjbGljayddOy8vJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCdcclxuXHJcblxyXG4gICAgICAgIHpyVXRpbC5lYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbiAoZXZlTmFtZSkge1xyXG4gICAgICAgICAgICB0aGF0Lm9uKGV2ZU5hbWUsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBlLnRhcmdldDtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnBhcmVudCAmJiAgY3VycmVudC5wYXJlbnQgaW5zdGFuY2VvZiBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IGV2ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhhdDtcclxuICAgICAgICAgICAgICAgIGFwaS50cmlnZ2VyKGV2ZU5hbWUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgU3ViUHJvY2Vzc05vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICBcdHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB5OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWN0U2l6ZS53aWR0aC0xLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlY3RTaXplLmhlaWdodC0xLFxyXG4gICAgICAgICAgICAgICAgcjogN1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmOWY5ZjknLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnI2JiYmJiYidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejowXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmVjdC5uYW1lID0gXCJzdWJwcm9jZXNzLXJlY3RcIjtcclxuICAgICAgICB0aGlzLmFkZChyZWN0KTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gIFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiksIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5kcmF3VGV4dChtb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gYm9keS4uLlxyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0genJVdGlsLmNsb25lKHJlY3QpO1xyXG4gICAgICAgIC8vIOWPluaVtFxyXG4gICAgICAgIGJvdW5kaW5nUmVjdC54ID0gcGFyc2VJbnQoYm91bmRpbmdSZWN0LngsIDEwKTtcclxuICAgICAgICBib3VuZGluZ1JlY3QueSA9IHBhcnNlSW50KGJvdW5kaW5nUmVjdC55LCAxMCk7XHJcbiAgICAgICAgYm91bmRpbmdSZWN0LndpZHRoID0gcGFyc2VJbnQoYm91bmRpbmdSZWN0LndpZHRoLCAxMCk7XHJcbiAgICAgICAgYm91bmRpbmdSZWN0LmhlaWdodCA9IHBhcnNlSW50KGJvdW5kaW5nUmVjdC5oZWlnaHQsIDEwKTtcclxuICAgICAgICAvL+WIm+W7uuacgOWwj+WMheWbtOebkuiZmue6v1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICBwb2ludHNbMF0gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzFdID1bYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzJdID1bYm91bmRpbmdSZWN0LndpZHRoLzIsYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbM10gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbNF0gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcblxyXG4gICAgICAgIHZhciBib3VuZFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHRoaXMucG9zaXRpb25bMF0gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdSZWN0LndpZHRoLCBib3VuZGluZ1JlY3QuaGVpZ2h0KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB0aGlzLnBvc2l0aW9uWzBdK2JvdW5kaW5nUmVjdC53aWR0aC8yLFxyXG4gICAgICAgICAgICB5OiB0aGlzLnBvc2l0aW9uWzFdK2JvdW5kaW5nUmVjdC5oZWlnaHQvMixcclxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ1JlY3QuaGVpZ2h0LFxyXG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICAgICAgYm91bmRpbmdSZWN0OiBib3VuZFJlY3RcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBTdWJQcm9jZXNzTm9kZS5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbihwWCxwWSkge1xyXG4gICAgICAgIC8vIGJvZHkuLi5cclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICB0aGlzLmF0dHIoJ3Bvc2l0aW9uJyxbcFgtYm91bmRpbmdSZWN0LndpZHRoLzIscFktYm91bmRpbmdSZWN0LmhlaWdodC8yXSk7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgU3ViUHJvY2Vzc05vZGUucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbihvcHQpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJzdWJwcm9jZXNzLXJlY3RcIik7XHJcbiAgICAgICAgcmVjdC5zZXRTaGFwZShvcHQuc2hhcGUpO1xyXG4gICAgICAgIHRoaXMuYXR0cigncG9zaXRpb24nLG9wdC5wb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoVGV4dCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTdWJQcm9jZXNzTm9kZS5wcm90b3R5cGUuZ2V0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNoaWxkT2ZOYW1lKFwic3VicHJvY2Vzcy1yZWN0XCIpO1xyXG4gICAgICAgIHJldHVybiByZWN0LmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTdWJQcm9jZXNzTm9kZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJyZXNvdXJjZUlkXCIsIHRoaXMucmVzb3VyY2VJZCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJwcm9wZXJ0aWVzLnR5cGVcIiwgdGhpcy5icG1uSW5mby50eXBlKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0ZW5jaWwudHlwZVwiLCB0aGlzLmJwbW5JbmZvLm5hbWUpOyAgLy9zdGVuY2lsLmlkXHJcbiAgICAgICAgaWYgKHRoaXMuc2xvdEV2ZW50ICYmIHRoaXMuc2xvdEV2ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGFyclNsb3RFdmVudCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5zbG90RXZlbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGFyclNsb3RFdmVudC5wdXNoKHRoaXMuc2xvdEV2ZW50W2ldLnJlc291cmNlSWQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJwcm9wZXJ0aWVzLnNsb3RFdmVudFwiLCBhcnJTbG90RXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdmFyIHJlY3QgPSB0aGlzLmdldFJlY3QoKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiwgcmVjdC54KTtcclxuICAgICAgICAgICAgLy8gdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIiwgcmVjdC55KTtcclxuICAgICAgICAgICAgLy8gdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC54XCIsIHJlY3QueCArIHJlY3QuYm91bmRpbmdSZWN0LndpZHRoKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC55XCIsIHJlY3QueSArIHJlY3QuYm91bmRpbmdSZWN0LmhlaWdodCk7XHJcbiAgICAgICAgZnVuY3Rpb24gcGFyZW50WChub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gbm9kZS5nZXRSZWN0KCkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3Mobm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdC54ICsgcGFyZW50WChub2RlLnBhcmVudClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0LnhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcGFyZW50WShub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gbm9kZS5nZXRSZWN0KCkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3Mobm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdC55ICsgcGFyZW50WShub2RlLnBhcmVudClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0LnlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldFJlY3QoKS5ib3VuZGluZ1JlY3Q7XHJcblxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIsIHBhcnNlSW50KHJlY3QueCkpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIsIHBhcnNlSW50KHJlY3QueSkpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLmxvd2VyUmlnaHQueFwiLCBwYXJzZUludChyZWN0LnggKyByZWN0LndpZHRoKSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC55XCIsIHBhcnNlSW50KHJlY3QueSArIHJlY3QuaGVpZ2h0KSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgLy8g5Yqg5YWl5a2Q5rWB56iL55qEIOiKgueCuVxyXG4gICAgICAgIHZhciBhcnJDaGlsZFNoYXBlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uKGNoaWxkKXtcclxuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQlBNTk5vZGUgfHwgY2hpbGQgaW5zdGFuY2VvZiBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGFyckNoaWxkU2hhcGVzLnB1c2goY2hpbGQudG9KU09OKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJjaGlsZFNoYXBlc1wiLCBhcnJDaGlsZFNoYXBlcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwub3B0aW9uO1xyXG4gICAgfTtcclxuXHJcbiAgICBTdWJQcm9jZXNzTm9kZS5wcm90b3R5cGUudXBkYXRlU2hhcGUgPSBmdW5jdGlvbihyYXRpbywgaWZQYXJzZSwgcGl4ZWwpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJzdWJwcm9jZXNzLXJlY3RcIik7XHJcbiAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBOdW1iZXIocmF0aW8pO1xyXG4gICAgICAgIHZhciBzaGFwZSA9IHJlY3Quc2hhcGU7XHJcbiAgICAgICAgdmFyIG5ld1cgPSBOdW1iZXIoc2hhcGUud2lkdGggKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICB2YXIgbmV3SCA9IE51bWJlcihuZXdXICogc2hhcGUuaGVpZ2h0IC8gc2hhcGUud2lkdGgpO1xyXG4gICAgICAgIGlmIChpZlBhcnNlKSB7XHJcbiAgICAgICAgICAgIHZhciB3ID0gTWF0aC5yb3VuZChuZXdXIC8gMiAvIHBpeGVsKSAqIHBpeGVsO1xyXG4gICAgICAgICAgICB2YXIgaCA9IE1hdGgucm91bmQobmV3SCAvIDIgLyBwaXhlbCkgKiBwaXhlbDtcclxuICAgICAgICAgICAgbmV3VyA9IHcgKiAyIC0gMTtcclxuICAgICAgICAgICAgbmV3SCA9IGggKiAyIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVjdC5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgIHdpZHRoOiBuZXdXLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IG5ld0hcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlZnJlc2hUZXh0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5ub2RlVHlwZSA9IFwiU3ViUHJvY2Vzc1wiO1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoU3ViUHJvY2Vzc05vZGUsQlBNTk5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gU3ViUHJvY2Vzc05vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9TdWJQcm9jZXNzTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBCUE1O6Z2Z5oCB5pa55rOV57G7XHJcbiAqIEBjbGFzcyBmaXNoLnRvcG8uRmlzaFRvcG9CcG1uLkJwbW5cclxuICovXHJcblxyXG5cdHZhciBCcG1uID0ge1xyXG5cdFx0QlBNTl9UWVBFOlwic3RlbmNpbC50eXBlXCIsXHJcblx0XHRCUE1OX1NDUklQVF9UQVNLOiBcIlNjcmlwdFRhc2tcIixcclxuXHRcdEJQTU5fRVZFTlRfU1VCX1BST0NFU1M6IFwiU3ViUHJvY2Vzc1Rhc2tcIixcclxuXHRcdEJQTU5fVEFTSzpcIlRhc2tcIixcclxuXHRcdFRFTVBMQVRFOiBcIkJQTU5EaWFncmFtXCIsXHJcblx0XHRSRVNPVVJDRV9JRDogXCJyZXNvdXJjZUlkXCIsXHJcblx0XHRTRVFVRU5DRV9GTE9XOiBcIlNlcXVlbmNlRmxvd1wiLFxyXG5cdFx0U1VCX1BST0NFU1M6IFwiU3ViUHJvY2Vzc1wiLFxyXG5cdFx0VVNFUl9EQVRBOiBcInByb3BlcnRpZXMudXNlckRhdGFcIixcclxuXHJcblx0XHRTVEFSVF9FVkVOVDogXCJTdGFydE5vbmVFdmVudFwiLFxyXG5cdFx0RU5EX0VWRU5UOiBcIkVuZE5vbmVFdmVudFwiLFxyXG5cdFx0VVNFUl9UQVNLOiBcIlVzZXJUYXNrXCIsXHJcblx0XHRNQU5VQUxfVEFTSzogXCJNYW51YWxUYXNrXCIsXHJcblx0XHRTQ1JJUFRfVEFTSzogXCJTY3JpcHRUYXNrXCIsXHJcblx0XHRNQUlMX1RBU0s6IFwiTWFpbFRhc2tcIixcclxuXHRcdFNFUlZJQ0VfVEFTSzogXCJTZXJ2aWNlVGFza1wiLFxyXG5cdFx0U01TX1RBU0s6IFwiU21zVGFza1wiLFxyXG5cdFx0Q09NTUVOVDogXCJDb21tZW50XCIsXHJcblx0XHRDQVRDSF9USU1FUl9FVkVOVDogXCJDYXRjaFRpbWVyRXZlbnRcIixcclxuXHRcdENBVENIX1NJR05BTF9FVkVOVDogXCJDYXRjaFNpZ25hbEV2ZW50XCIsXHJcblx0XHRUSFJPV19TSUdOQUxfRVZFTlQ6IFwiVGhyb3dTaWduYWxFdmVudFwiLFxyXG5cdFx0Q0FUQ0hfTUVTU0FHRV9FVkVOVDogXCJDYXRjaE1lc3NhZ2VFdmVudFwiLFxyXG5cdFx0SU5DTFVTSVZFX0dBVEVXQVk6IFwiSW5jbHVzaXZlR2F0ZXdheVwiLFxyXG5cdFx0RVhDTFVTSVZFX0dBVEVXQVk6IFwiRXhjbHVzaXZlR2F0ZXdheVwiLFxyXG5cdFx0UEFSQUxMRUxfR0FURVdBWTogXCJQYXJhbGxlbEdhdGV3YXlcIixcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOWIpOaWreiKgueCueaYr+WQpiBCUE1O5qih5p2/IOexu+Wei1xyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG5cdFx0ICovXHJcblx0XHRpc1RlbXBsYXRlOiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuIGJwbW50eXBlID09PSBCcG1uLlRFTVBMQVRFO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOWIpOaWreiKgueCueaYr+WQpiBBY3Rpdml0eSDnsbvlnotcclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gIG5vZGUg6ZyA6KaB5Yik5pat57G75Z6L55qE6IqC54K5XHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuXHRcdCAqL1xyXG5cdFx0aXNBY3Rpdml0eTogZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR2YXIgYnBtbnR5cGUgPSBub2RlLm1vZGVsLmdldChCcG1uLkJQTU5fVFlQRSk7XHJcblx0XHRcdHJldHVybiAoYnBtbnR5cGUuaW5kZXhPZihcIlRhc2tcIikgIT0gLTEgfHwgYnBtbnR5cGUgPT09IEJwbW4uQ09NTUVOVCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog5Yik5pat6IqC54K55piv5ZCmIOWtkOa1geeoiyDnsbvlnotcclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gIG5vZGUg6ZyA6KaB5Yik5pat57G75Z6L55qE6IqC54K5XHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuXHRcdCAqL1xyXG5cdFx0aXNTdWJQcm9jZXNzOiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubm9kZVR5cGU7XHJcblx0XHRcdHJldHVybiAgYnBtbnR5cGUgPT0gQnBtbi5TVUJfUFJPQ0VTU1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOWIpOaWreiKgueCueaYr+WQpiDnvZHlhbMg57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcblx0XHQgKi9cclxuXHRcdGlzR2F0ZXdheTogZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR2YXIgYnBtbnR5cGUgPSBub2RlLm1vZGVsLmdldChCcG1uLkJQTU5fVFlQRSk7XHJcblx0XHRcdHJldHVybiBicG1udHlwZS5pbmRleE9mKFwiR2F0ZXdheVwiKSAhPSAtMTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiDliKTmlq3oioLngrnmmK/lkKYg57q/5q61IOexu+Wei1xyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG5cdFx0ICovXHJcblx0XHRpc0Zsb3c6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dmFyIGJwbW50eXBlID0gbm9kZS5tb2RlbC5nZXQoQnBtbi5CUE1OX1RZUEUpO1xyXG5cdFx0XHRyZXR1cm4gYnBtbnR5cGUgPT09IEJwbW4uU0VRVUVOQ0VfRkxPVztcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICog5Yik5pat5qih5Z6L5piv5ZCmIOe6v+autSDnsbvlnotcclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gIG1vZGVsIOmcgOimgeWIpOaWreexu+Wei+eahOaooeWei1xyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcblx0XHQgKi9cclxuXHRcdGlzRmxvd01vZGVsOiBmdW5jdGlvbihtb2RlbCkge1xyXG5cdFx0XHR2YXIgYnBtbnR5cGUgPSBtb2RlbC5nZXQoQnBtbi5CUE1OX1RZUEUpO1xyXG5cdFx0XHRyZXR1cm4gYnBtbnR5cGUgPT09IEJwbW4uU0VRVUVOQ0VfRkxPVztcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiDliKTmlq3oioLngrnmmK/lkKYg5LqL5Lu2IOexu+Wei1xyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG5cdFx0ICovXHJcblx0XHRpc0V2ZW50OiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuIGJwbW50eXBlLmluZGV4T2YoXCJFdmVudFwiKSAhPSAtMTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiDliKTmlq3oioLngrnmmK/lkKYg5o+S57Of5LqL5Lu2IOexu+Wei1xyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG5cdFx0ICovXHJcblx0XHRpc1Nsb3RFdmVudDogZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR2YXIgYnBtbnR5cGUgPSBub2RlLm1vZGVsLmdldChCcG1uLkJQTU5fVFlQRSk7XHJcblx0XHRcdHJldHVybiBicG1udHlwZSA9PSBCcG1uLkNBVENIX1RJTUVSX0VWRU5UIHx8IGJwbW50eXBlID09IEJwbW4uQ0FUQ0hfU0lHTkFMX0VWRU5UIHx8IGJwbW50eXBlID09IEJwbW4uVEhST1dfU0lHTkFMX0VWRU5UO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOWIpOaWreiKgueCueaYr+WQpiDms6jph4og57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcblx0XHQgKi9cclxuXHRcdGlzQ29tbWVudDogZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR2YXIgYnBtbnR5cGUgPSBub2RlLm1vZGVsLmdldChCcG1uLkJQTU5fVFlQRSk7XHJcblx0XHRcdHJldHVybiBicG1udHlwZSA9PT0gQnBtbi5DT01NRU5UO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOiOt+WPluW9k+WJjeiKgueCueeahOexu+Wei1xyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gICAgICDoioLngrnnmoTnsbvlnotcclxuXHRcdCAqL1xyXG5cdFx0Z2V0VHlwZTogZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR2YXIgYnBtbnR5cGUgPSBub2RlLm1vZGVsLmdldChCcG1uLkJQTU5fVFlQRSk7XHJcblx0XHRcdHJldHVybiBicG1udHlwZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiDov5Tlm57lvZPliY3oioLngrnnmoTmoLflvI/pgInpoblcclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gIG5vZGUg6ZyA6KaB5Yik5pat57G75Z6L55qE6IqC54K5XHJcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAg5qC35byP5a+56LGhXHJcblx0XHQgKi9cclxuXHRcdGdldFN0eWxlOiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHJldHVybiBub2RlLm1vZGVsLm9wdGlvbi5zdHlsZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiDov5Tlm57lvZPliY3oioLngrnnmoTlsZ7mgKfpgInpoblcclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gIG5vZGUg6ZyA6KaB5Yik5pat57G75Z6L55qE6IqC54K5XHJcblx0XHQgKiBAcmV0dXJuICB7T2JqZWN0fSAgICAgIOWxnuaAp+WvueixoVxyXG5cdFx0ICovXHJcblx0XHRnZXRQcm9wOiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHJldHVybiBub2RlLm1vZGVsLm9wdGlvbi5wcm9wZXJ0aWVzO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOiOt+WPlueUqOaIt+iHquWumuS5ieeahOaVsOaNrlxyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gICDnlKjmiLfoh6rlrprkuYnnmoTmlbDmja5cclxuXHRcdCAqL1xyXG5cdFx0Z2V0VXNlckRhdGE6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dmFyIG1vZGVsID0gbm9kZS5tb2RlbDtcclxuXHRcdFx0cmV0dXJuIG1vZGVsLmdldChCcG1uLlVTRVJfREFUQSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog6K6+572u55So5oi355qE6Ieq5a6a5LmJ5pWw5o2uXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHVzZXJEYXRhIOeUqOaIt+eahOiHquWumuS5ieaVsOaNrlxyXG5cdFx0ICovXHJcblx0XHRzZXRVc2VyRGF0YTogZnVuY3Rpb24obm9kZSwgdXNlckRhdGEpIHtcclxuXHRcdFx0dmFyIG1vZGVsID0gbm9kZS5tb2RlbDtcclxuXHRcdFx0bW9kZWwuc2V0KEJwbW4uVVNFUl9EQVRBLCB1c2VyRGF0YSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBCcG1uO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL0JwbW4uanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog6L+e5o6l57q/XHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC5qc1wiKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgTm9kZSA9IHJlcXVpcmUoXCIuLi9Ob2RlLmpzXCIpO1xyXG4gICAgdmFyIHN5bWJvbFV0aWwgPSByZXF1aXJlKFwiLi9TeW1ib2wuanNcIik7XHJcbiAgICB2YXIgSGFuZGxlID0gcmVxdWlyZShcIi4vSGFuZGxlLmpzXCIpO1xyXG4gICAgdmFyIEVmZmVjdExpbmUgPSByZXF1aXJlKFwiLi9FZmZlY3RMaW5lLmpzXCIpO1xyXG4gICAgdmFyIENvbm5lY3Rpb25Qb2ludCA9IHJlcXVpcmUoXCIuL0Nvbm5lY3Rpb25Qb2ludC5qc1wiKTtcclxuICAgIHZhciBQb2ludCA9IHJlcXVpcmUoXCIuLi9Qb2ludC5qc1wiKTtcclxuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoXCIuLi9tb2RlbC5qc1wiKTtcclxuXHJcbiAgICBDb25uZWN0b3IuVFlQRV9TVFJBSUdIVCA9ICdzdHJhaWdodCc7XHJcbiAgICBDb25uZWN0b3IuVFlQRV9KQUdHRUQgPSAnamFnZ2VkJztcclxuICAgIENvbm5lY3Rvci5UWVBFX0NVUlZFID0gJ2N1cnZlJztcclxuICAgIENvbm5lY3Rvci5UWVBFX0NIQUlOID0gJ2NoYWluJztcclxuICAgIENvbm5lY3Rvci5SQURJVVMgPSAzO1xyXG4gICAgQ29ubmVjdG9yLlNUQVJUX05PREUgPSBcInN0YXJ0Tm9kZVwiO1xyXG4gICAgQ29ubmVjdG9yLkVORF9OT0RFID0gXCJlbmROb2RlXCI7XHJcbiAgICBDb25uZWN0b3IuTEVGVCA9IFwibGVmdFwiO1xyXG4gICAgQ29ubmVjdG9yLlJJR0hUID0gXCJyaWdodFwiO1xyXG4gICAgQ29ubmVjdG9yLlRPUCA9IFwidG9wXCI7XHJcbiAgICBDb25uZWN0b3IuQk9UVE9NID0gXCJib3R0b21cIjtcclxuICAgIENvbm5lY3Rvci5CT1RUT00gPSBcImJvdHRvbVwiO1xyXG4gICAgQ29ubmVjdG9yLlNFUEVSQVRPUiA9IFwiLVwiO1xyXG4gICAgQ29ubmVjdG9yLk5PUk1BTF9DT0xPUiA9IFwiIzAwMFwiO1xyXG4gICAgQ29ubmVjdG9yLlNFTEVDVEVEX0NPTE9SID0gJyM3NEI3RTAnO1xyXG4gICAgQ29ubmVjdG9yLkNISUxEX05BTUUgPSBbJ2xpbmVUZXh0JywgJ2xpbmVJbWFnZSddO1xyXG4gICAgLyoqXHJcbiAgICAgKiDmnoTpgKDlh73mlbBcclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBvcHRpb25zIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQ29ubmVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBOb2RlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vcHQgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLm9wdC5tb2RlbCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlSWQgPSB0aGlzLm9wdC5tb2RlbC5nZXQoXCJyZXNvdXJjZUlkXCIpO1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gdGhpcy5vcHQubW9kZWw7XHJcbiAgICAgICAgICAgIHRoaXMub3B0ID0gdGhpcy5vcHQubW9kZWwub3B0aW9uO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VJZCA9IFV0aWwuZ2V0VVVJRCgpOyAvLyDnlJ/miJDoioLngrlJRFxyXG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gbmV3IE1vZGVsKHt9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBzeW1ib2w6IHsgdHlwZTogXCJhcnJvd1wiLCBzaXplOiAxMCwgY29sb3I6IENvbm5lY3Rvci5OT1JNQUxfQ09MT1IsIGJvdGg6ZmFsc2UsIG9mZnNldDowIH0sIC8v566t5aS0ICDlj6/pgInlgLzkuLrvvJogJ2NpcmNsZScsICdyZWN0JywgJ3JvdW5kUmVjdCcsICd0cmlhbmdsZScsICdkaWFtb25kJywgJ3BpbicsICdhcnJvdydcclxuICAgICAgICAgICAgc3R5bGU6IHsgbGluZVdpZHRoOiAxLCBzdHJva2U6IENvbm5lY3Rvci5OT1JNQUxfQ09MT1IsIGxpbmVUeXBlOiBDb25uZWN0b3IuVFlQRV9TVFJBSUdIVCB9LCAvL+agt+W8j1xyXG4gICAgICAgICAgICBob3ZlclN0eWxlOiB7IGxpbmVXaWR0aDogMiwgc3Ryb2tlOiBDb25uZWN0b3IuU0VMRUNURURfQ09MT1IgfSwgLy/np7vkuIrljrvnmoTmoLflvI9cclxuICAgICAgICAgICAgYXJyb3dIb3ZlclN0eWxlOiB7IGZpbGw6IENvbm5lY3Rvci5TRUxFQ1RFRF9DT0xPUn0sXHJcbiAgICAgICAgICAgIHNoYXBlOiB7IHBvaW50czogbnVsbCwgc21vb3RoOiBmYWxzZSwgc21vb3RoQ29uc3RyYWludDogbnVsbCB9LCAvL+W9oueKtlxyXG4gICAgICAgICAgICBwb3NpdGlvbjogeyBzdGFydFBvczpudWxsLCBlbmRQb3M6bnVsbCwgIC8v5oyH5a6a57q/5q616LW35aeL5LiO57uI5q2iIOWcqOiKgueCueeahOS7gOS5iOS9jee9riDpu5jorqTlgLzkuLonbGVmdCxyaWdodCcgIOWPr+WPluWAvOWbm+S4quaWueWQkXRvcCxib3R0b20sbGVmdCxyaWdodCDmlrnlkJHlj6/liqDlgY/np7vph4/lpoLlpoIgXCJsZWZ0KzEwLHRvcFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OlswLDBdLCAgLy8g6LW35aeL57q/5q6156a76IqC54K555qE5YGP56e7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE9mZnNldDpbMCwwXSwgICAgLy8g57uI5q2i57q/5q6156a76IqC54K555qE5YGP56e7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZURpc3RhbmNlOlszMCwzMF0sIC8vIOesrOS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOacgOWQjuS4gOadoeaKmOe6v+eahOmVv+W6plxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6bnVsbCAgICAvL+S4jeS9v+eUqOiHquWKqOiuoeeulyDmjIflrprov57nur/nmoTmipjngrnkvY3nva7mlbDnu4TvvIzpppblsL7lj6/ku6Xkvb/nlKhsZWZ0LHJpZ2h0LHRvcCxib3R0b21cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhdXRvQ2hhbmdlUG9zaXRpb246IGZhbHNlLFxyXG4gICAgICAgICAgICB0ZXh0Q29udGV4dE1lbnU6IG51bGwsXHJcbiAgICAgICAgICAgIGlzRWRpdDogdHJ1ZSwgLy/mmK/lkKblj6/nvJbovpFcclxuICAgICAgICAgICAgdGV4dDoge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogbnVsbCxcclxuICAgICAgICAgICAgICAgIHRleHRGaWxsOiAnIzAwMDAwMCcsIC8vIOaWh+acrOminOiJslxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxMnB4IE1pY3Jvc29mdCBZYUhlaScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0UG9zOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgICAgIHRleHRSb3RhdGVhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGltYWdlOiB7XHJcbiAgICAgICAgICAgICAgICBpbWFnZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA1MCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogNTAsXHJcbiAgICAgICAgICAgICAgICAvLyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIC8vIGltYWdlOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBRHdBQUFBeUNBWUFBQUFBOXJnQ0FBQUVaa2xFUVZSb1ErMmFYWWdiVlJUSHovOG11d1NKV1B4NHNGZ29hQlVyV29yVUw4U0s5VUdoRkN0MlVSUmhRYWk2dUxEWnlSMERoVGFJWnUvTlpQZE5yWUw0aGFLbGZsRHdvU2dVVktyWUloUmFQN0I5MklidGcxSmZJcXpablJ5NXkwUm14MlIzTXFsSlpwTjVuRG5uM3Yvdm5udm5udnNCYXZCb3JhOEhjRnV0VnR2UzZIc3Z2eE5DbkFkd2lwblBaTFBadjRKYUVYeWh0UzRTa2RYTFVDRzF6UW9oOWxtVzlaN2ZmaG13MW5xV2lEYUVMREFXWnN5Y3QyMzdRRjNzdjhCYTYrK0k2TTVZVUxRdThqNHA1ZGZHYlFsWUtYVUF3UDdXeTRtTnh5OEFiamRqdWc3OElZREhmZkxMelB5U2JkdHZ4QWJKRStvNHptYlhkVWVDQVJSQzNHRloxZzkxWU5NQ04vcmdEa2twUitJR1c5ZXJ0ZDVKUkVjQytrZWxsRzh2QVd1dDJmOHhPTkRqQ042TWFRQnNvam1JY0F6NzlLQkxld25JWUF6MzBoZ3VGb3U3bVhrVGdOK0ZFTE9UazVOZmhSMWRzZXZTV3V1UGlXaFBBUEJUS2VXallhQmpCYXlVT21GU3dTWmd6MHNwWDFzTk9qYkFUYktrWlh6SlpQS3FUQ1p6Y1NYbzJBQXJwU1lCT0N2QkFMZ3JtODErdnlhQWk4WGlLRE8vdFJLTUVPSm15N0orWGhQQXBWSnBoK3U2WHphREFmQnJwVkxaa3MvbjV6c09QRE16czI1aFlXRWpNLzloMjNaNXRSOUoyTzlhNjArSWFIY2orMFFpOFdDWTZlbVNqT0ZDb1hDL0VHSVBnSHVJYUNNUnJmT0pPazFFUjRub09ETWZiN2NCdE5iUEVkR3J2dkxudkRYNjYyRWFyaTFncFZRV2dKa1R0NFdwekV0ZUN1bDArcFd4c2JGS1dKK2czZlQwOUpXdTYyNWk1b3VwVkdwMmZIejg3N0JsUlFiV1doZUk2TVd3RmZudEFQd0k0Q25Mc3M1RThXL0hweDNnWlpzREVVU2NGa0tNZEJyNmtnRXo4MjhBUGdkd2VIRng4Y0w4L1B4Y09wM2VXcXZWSGdid1VKT2R6OE5TeXNjaU5GWmtsOGpBM283bWRxL21vcFR5aTFXbUEyazJRb00yQUo3TlpyTUhJeE8wNkJnWnVNVjZsc3kxMWs4VDBUc0IzM0l5bWR5ZXlXVE9SU216VlorT0FudlFKc29tMnY3bkF5bmxrNjJLajJMZmNXREhjYTZ1MVdyZkVORk5mc0hNL0xKdDIvdWlRTFRpMDNGZ0w4clBFTkdiUWFITXZDRk1ZbElvRkxZSkljd3k4VllBbXdGOFMwUW5tZm1VbFBMc0t2K1NobHZQLy9zV2o5YmE1TVU3R29pN1YwcHBBUDd6VEUxTm1aT0RKd0E4c2dMVVI4enMyTFo5b3BGTlZ5SnNoQ2lsZHBscHJJbHdrNFllTldlNnJ1dVdoUkFQTVBNb2dHdENkdDhxRVRtdTZ6cTVYTzVQdjAvWGdMMnViZkxmdlNFaG9wajlSRVQ3cFpTSDZzNWRCZmFnVFpSM1JhQ1pNd3NTQU9lWTJTeFk3aWFpNnhxVk16UTB0SDVpWXVLQ1YxOTN4bkNnbXpYOGlUVnBoTFBNL1A3dzhQREJPb1F2ZWk4dzh6aUFHL3krOVJQQ25nRTJRbnpIbVNiVnZLVUI3R2NBM3ExVUtrZnkrZnhpc3g3aHJhUU11Sm5yTHlPaVl3QjIxdTkxZEwxTE54S3VsTG84bVV4ZVc2MVcxeWNTaWZPcFZLcmN5aExRbEZrcWxiWldxOVVyY3JuY3NaNzVhVVVZdDIyNzlHU0UyNlphb1lBQjhPQXd6ZGM5MXZ5QnVGS3F2eTYxS0tYNjd0cFNmMTFNODFLeC9ybDY2TXRSKytkeXFRKzZmNjRQKzZEWDdBWHhmd0FOdmZGZ1djQ3lqQUFBQUFCSlJVNUVya0pnZ2c9PVwiLFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC8vIHdpZHRoOjUwLFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC8vIGhlaWdodDo1MFxyXG4gICAgICAgICAgICAgICAgLy8gfSxcclxuICAgICAgICAgICAgICAgIGltYWdlUG9zOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgICAgIGltYWdlUm90YXRlYWJsZTogdHJ1ZSAvLyDlm77niYfmmK/lkKbot5/pmo/nur/mrrXml4vovaxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejogMFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gVXRpbC5tZXJnZU9wdChkZWZhdWx0T3B0aW9ucywgdGhpcy5vcHQsIHRydWUsICd0ZXh0Q29udGV4dE1lbnUnKTtcclxuICAgICAgICB0aGlzLmhhbmRsZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICB0aGlzLnN0YXJ0Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbmROb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxpbmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZSA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgdGhpcy5pY29ucyA9IFtdOyAvLyDnlKjkuo7lrZjlgqjnur/mrrXkuIrpnaLnmoTmk43kvZzlm77moIdcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAqIOWIm+W7uui/nue6v+iKgueCuVxyXG4gICAgICogQHBhcmFtICB7W09iamVjdF19IG9wdGlvbnMgW+iKgueCueWPguaVsF1cclxuICAgICAqIEBwYXJhbSAge1tTdHJpbmddfSB0eXBlIFvoioLngrnnsbvlnotdICd0ZXh0JyAnaW1hZ2UnXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY3JlYXRlTGluZU5vZGUgPSBmdW5jdGlvbihvcHRpb25zLCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciB0ZXh0ID0gbnVsbDtcclxuICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgdHlwZSA9ICd0ZXh0JztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5vZGVOYW1lID0genJVdGlsLmZpbmQoQ29ubmVjdG9yLkNISUxEX05BTUUsIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKS5pbmRleE9mKHR5cGUpID4gLTE7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KG9wdGlvbnNbdHlwZV0pICYmIHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DSEFJTikge1xyXG4gICAgICAgICAgICBvcHRpb25zW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gdGhhdC5kcmF3VGV4dChub2RlTmFtZStcIi1cIitpLCB2LCAwLCAwLCB0eXBlKTtcclxuICAgICAgICAgICAgICAgIGlmICh6clV0aWwuaXNTdHJpbmcodikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqW3R5cGVdID0gdjtcclxuICAgICAgICAgICAgICAgICAgICBvYmpbdHlwZSsnSWQnXSA9IGNvbnRlbnQudGV4dC5pZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Lm9wdGlvbnNbdHlwZV1bdHlwZV1baV0gPSBvYmo7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQub3B0aW9uc1t0eXBlXVt0eXBlXVtpXS50ZXh0SWQgPSBjb250ZW50LnRleHQuaWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGF0LmFkZChjb250ZW50LnRleHQpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVOb2RlQ29udGV4dE1lbnUoY29udGVudC50ZXh0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGV4dCA9IHRoaXMuZHJhd1RleHQobm9kZU5hbWUsIG9wdGlvbnMsIDAsIDAsIHR5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZCh0ZXh0LnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGV4dCkge1xyXG4gICAgICAgICAgICB0aGF0LmNyZWF0ZU5vZGVDb250ZXh0TWVudSh0ZXh0LnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmlmTGluZU5vZGVSb3RhdGVhYmxlID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICB0eXBlID0gJ3RleHQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUKSB7XHJcbiAgICAgICAgICAgIGlmICgodHlwZSA9PT0gJ3RleHQnICYmIHRoaXMub3B0aW9ucy50ZXh0LnRleHRSb3RhdGVhYmxlKSB8fCAodHlwZSA9PT0gJ2ltYWdlJyAmJiB0aGlzLm9wdGlvbnMuaW1hZ2UuaW1hZ2VSb3RhdGVhYmxlKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOabtOaWsOi/nue6v+eahOaWh+Wtly/lm77niYfoioLngrlcclxuICAgICAqIEBwYXJhbSAge1tPYmplY3RdfSBsaW5lTm9kZSBb6IqC54K5XVxyXG4gICAgICogQHBhcmFtICB7W09iamVjdF19IG9wdGlvbnMgW+iKgueCueWPguaVsF1cclxuICAgICAqIEBwYXJhbSAge1tTdHJpbmddfSB0eXBlIFvoioLngrnnsbvlnotdICd0ZXh0JyAnaW1hZ2UnXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUucmVmcmVzaExpbmVOb2RlID0gZnVuY3Rpb24obGluZU5vZGUsIG9wdGlvbnMsIHR5cGUpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGxpbmVOb2RlQXJyID0gW10sIG5vZGVOYW1lID0gQ29ubmVjdG9yLkNISUxEX05BTUVbMF07XHJcbiAgICAgICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSAndGV4dCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGVOYW1lID0genJVdGlsLmZpbmQoQ29ubmVjdG9yLkNISUxEX05BTUUsIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKS5pbmRleE9mKHR5cGUpID4gLTE7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DSEFJTiAmJiB6clV0aWwuaXNBcnJheShvcHRpb25zW3R5cGVdKSkge1xyXG4gICAgICAgICAgICBvcHRpb25zW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVOb2RlQXJyLnB1c2goc2VsZi5jaGlsZE9mTmFtZShub2RlTmFtZSsnLScraSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFsaW5lTm9kZSAmJiBvcHRpb25zW3R5cGVdKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5kcmF3VGV4dChub2RlTmFtZSwgb3B0aW9ucywgMCwgMCwgdHlwZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRleHQudGV4dCk7XHJcbiAgICAgICAgICAgIGxpbmVOb2RlID0gdGhpcy5jaGlsZE9mTmFtZShub2RlTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaW5lTm9kZUFyci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBjbnQgPSBsaW5lTm9kZUFyci5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHRoaXMudHVybmluZ1BvaW50c1sxXS54IC0gdGhpcy50dXJuaW5nUG9pbnRzWzBdLngsXHJcbiAgICAgICAgICAgICAgICBnYXAgPSBwYXJzZUludChkaXN0YW5jZS9jbnQpLFxyXG4gICAgICAgICAgICAgICAgcG9zID0gLShnYXApICogcGFyc2VJbnQoY250LzIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxpbmVOb2RlQXJyLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXh0UG9pbnQgPSBzZWxmLmdldFRleHRQb3N0aW9uKG9wdGlvbnMsIHYpLCB3YXkgPSAnJztcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmF0ZSA9IHNlbGYuZ2V0VGV4dFJvdGF0aW9uKHRleHRQb2ludCwgdik7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocmF0ZSkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByYXRlID0gMDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2F5ID0gcmF0ZSA+IDAgPyAncGx1cycgOiAnbWludXMnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmF0ZSA9IE1hdGguYWJzKHJhdGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlZyA9ICgxODAqcmF0ZSkvTWF0aC5QSTtcclxuICAgICAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IG51bGwsIGxlbmd0aCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5zZXRTdHlsZShcInRleHRcIiwgenJVdGlsLmlzU3RyaW5nKG9wdGlvbnNbdHlwZV1baV0pID8gb3B0aW9uc1t0eXBlXVtpXSA6IG9wdGlvbnNbdHlwZV1baV0udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5pu05paw5paH5a2X55+p5b2i5YyF5Zu055uSXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRCb3VuZGluZ1JlY3QgPSBzZWxmLmdldFRleHRCb3VuZGluZ1JlY3Qodi5zdHlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0ZXh0Qm91bmRpbmdSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRleHRCb3VuZGluZ1JlY3QuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHdheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gZGVnID4gOTAgPyAoKGRlZy00NSkqTWF0aC5QSSkvMTgwIDogKCg0NStkZWcpKk1hdGguUEkpLzE4MDtcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbiA9IHdheSA9PT0gJ21pbnVzJyA/IC0ocm90YXRpb24pIDogcm90YXRpb247XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gKDQ1Kk1hdGguUEkpLzE4MFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdi5hdHRyKCdyb3RhdGlvbicsIHJvdGF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVnID09PSA5MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRQb2ludFsxXSAtPSBwb3M7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRQb2ludFswXSArPSBwb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhdGUgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gTWF0aC50YW4oZGVnKk1hdGguUEkvMTgwKSpwb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9pbnRbMV0gLT0gd2F5ID09PSAncGx1cycgPyBsZW5ndGggOiAtKGxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9pbnRbMV0gKz0gd2F5ID09PSAncGx1cycgPyAtKGxlbmd0aCkgOiAobGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2LmF0dHIoXCJwb3NpdGlvblwiLCB0ZXh0UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgcG9zICs9IGdhcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaW5lTm9kZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lTm9kZS5zZXRTdHlsZShcInRleHRcIiwgb3B0aW9uc1t0eXBlXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dFJlY3QgPSB0aGlzLmdldFRleHRCb3VuZGluZ1JlY3Qob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBsaW5lTm9kZS5zZXRTaGFwZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRleHRSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGV4dFJlY3QuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGV4dFBvaW50ID0gdGhpcy5nZXRUZXh0UG9zdGlvbihvcHRpb25zLCBsaW5lTm9kZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlmTGluZU5vZGVSb3RhdGVhYmxlKHR5cGUpKSB7IC8vIzE4N1xyXG4gICAgICAgICAgICAgICAgbGluZU5vZGUuYXR0cigncm90YXRpb24nLCB0aGlzLmdldFRleHRSb3RhdGlvbih0ZXh0UG9pbnQsIGxpbmVOb2RlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGluZU5vZGUuYXR0cihcInBvc2l0aW9uXCIsIHRleHRQb2ludCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmHjeaWsOeUu+e6v++8jOWmguaenOS8oOepuuWImeagueaNrnR1cm5pbmdQb2ludHMg6YeN5paw55S757q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHBvaW50cyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKGFyclBvaW50cykge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBpZiAoYXJyUG9pbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHVybmluZ1BvaW50cyA9IGFyclBvaW50cztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/lsIZbeDowLHk6MF3ovazljJbkuLpbMCwgMF0gIOe7mXpyZW5kZXLkvb/nlKhcclxuICAgICAgICB2YXIgcG9pbnRzID0gVXRpbC50cmFzbGF0ZVBvaW50cyh0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG5cclxuICAgICAgICBpZiAoKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkgJiYgKHBvaW50cy5sZW5ndGggPiAyKSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGlmeUN1cnZlKHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lLmF0dHIoJ3NoYXBlJywgeyBwb2ludHM6IHBvaW50cyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOabtOaWsOe6v+auteaWh+Wtly/lm77niYfoioLngrlcclxuICAgICAgICBDb25uZWN0b3IuQ0hJTERfTkFNRS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGxpbmVOb2RlID0gdGhhdC5jaGlsZE9mTmFtZShuYW1lKTtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBuYW1lID09PSBDb25uZWN0b3IuQ0hJTERfTkFNRVswXSA/ICd0ZXh0JyA6ICdpbWFnZSc7XHJcbiAgICAgICAgICAgIHRoYXQucmVmcmVzaExpbmVOb2RlKGxpbmVOb2RlLCB0aGF0Lm9wdGlvbnNbdHlwZV0sIHR5cGUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnJlZnJlc2hGcm9tVG9TeW1ib2wocG9pbnRzKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2hIYW5kbGVzKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rnur/kuIroioLngrnnmoTlj7Plh7vnm5HlkKxcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmNyZWF0ZU5vZGVDb250ZXh0TWVudSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUgJiYgdGhpcy5vcHQudGV4dENvbnRleHRNZW51KSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0Q29udGV4dE1lbnUgPSB0aGlzLm9wdC50ZXh0Q29udGV4dE1lbnU7XHJcbiAgICAgICAgICAgIG5vZGUub24oXCJjb250ZXh0bWVudVwiLGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGUuZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGUuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29udGV4dE1lbnUuYnVpbGRNZW51KGUuZXZlbnQsdGhpcyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDmuLLmn5NcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAvLzEu5Yib5bu6566t5aS0XHJcbiAgICAgICAgdGhpcy5yZW5kZXJGcm9tVG9TeW1ib2woKTtcclxuXHJcbiAgICAgICAgLy8yLuWIm+W7uue6v1xyXG4gICAgICAgIHRoaXMuY3VydmVMaW5lID0gbmV3IGdyYXBoaWMuQmV6aWVyQ3VydmUoe1xyXG4gICAgICAgICAgICAvL3Bvc2l0aW9uOiB0aGlzLm9wdGlvbnMucG9zaXRpb24sXHJcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLm9wdGlvbnMuc3R5bGUsXHJcbiAgICAgICAgICAgIHo6IHRoaXMub3B0aW9ucy56XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5ncm91cEN1cnZlLmFkZCh0aGlzLmN1cnZlTGluZSk7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5ncm91cEN1cnZlKTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLmNvblBvaW50c0dyb3VwKTtcclxuICAgICAgICB0aGlzLnBvbHlMaW5lID0gbmV3IGdyYXBoaWMuUG9seWxpbmUoe1xyXG4gICAgICAgICAgICAvL3Bvc2l0aW9uOiB0aGlzLm9wdGlvbnMucG9zaXRpb24sXHJcbiAgICAgICAgICAgIHNoYXBlOiB0aGlzLm9wdGlvbnMuc2hhcGUsXHJcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLm9wdGlvbnMuc3R5bGUsXHJcbiAgICAgICAgICAgIHo6IHRoaXMub3B0aW9ucy56XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5wb2x5TGluZSk7XHJcblxyXG4gICAgICAgIGlmICgodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmUgPSB0aGlzLmdyb3VwQ3VydmU7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlSG92ZXJTdHlsZSh0aGlzLmN1cnZlTGluZSk7XHJcbiAgICAgICAgICAgIHRoaXMucG9seUxpbmUuaGlkZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZSA9IHRoaXMucG9seUxpbmU7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlSG92ZXJTdHlsZSh0aGlzLnBvbHlMaW5lKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJ2ZUxpbmUuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8zLuS+puWQrOe6v+S6i+S7tlxyXG4gICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnZGJsY2xpY2snLCAnY2xpY2snXTsgLy8nY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0J1xyXG4gICAgICAgIHpyVXRpbC5lYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbihldmVOYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZS5vbihldmVOYW1lLCB6clV0aWwuYmluZChmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcIkNvbm5lY3RvcjpcIiArIGV2ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhhdDtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNFZGl0ID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgICAgICB0aGF0LnNldFNlbGVjdGVkU3R5bGUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYW5kbGVzLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoYXBlU2V0SGFuZGxlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9LCB0aGlzKSk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgIC8vNC7liJvlu7rnur/kuIrmlofmnKxcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRleHQudGV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUxpbmVOb2RlKHRoaXMub3B0aW9ucy50ZXh0LCAndGV4dCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAvLyA1LuWIm+W7uue6v+S4iuWbvueJh+iKgueCuVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2UuaW1hZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVMaW5lTm9kZSh0aGlzLm9wdGlvbnMuaW1hZ2UsICdpbWFnZScpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZW5kZXJGcm9tVG9TeW1ib2wgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jcmVhdGVTeW1ib2woJ3RvU3ltYm9sJywgdGhpcy5vcHRpb25zKTsgLy9hcnJvdyx0cmlhbmdsZVxyXG4gICAgICAgIGlmIChzeW1ib2xUbykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZChzeW1ib2xUbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5aaC5p6c5Y+M5ZCR566t5aS0IOWImeWGjeWIm+W7uummlueureWktFxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3ltYm9sLmJvdGgpIHtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbEZyb20gPSB0aGlzLmNyZWF0ZVN5bWJvbCgnZnJvbVN5bWJvbCcsIHRoaXMub3B0aW9ucyk7IC8vYXJyb3csdHJpYW5nbGVcclxuICAgICAgICAgICAgaWYgKHN5bWJvbEZyb20pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHN5bWJvbEZyb20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUucmVmcmVzaEZyb21Ub1N5bWJvbCA9IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICAgIHZhciBzeW1ib2xUbyA9IHRoaXMuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XHJcbiAgICAgICAgdmFyIHN5bWJvbEZyb20gPSB0aGlzLmNoaWxkT2ZOYW1lKCdmcm9tU3ltYm9sJyk7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gW10sIG9mZnNldCA9IHRoaXMub3B0aW9ucy5zeW1ib2wub2Zmc2V0O1xyXG4gICAgICAgIGlmIChzeW1ib2xUbykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVmZmVjdCAmJiB0aGlzLm9wdGlvbnMuZWZmZWN0LnNob3cpIHtcclxuICAgICAgICAgICAgICAgIG5ldyBFZmZlY3RMaW5lKHN5bWJvbFRvLCB0aGlzLm9wdGlvbnMsIHRoaXMuZ3JvdXBDdXJ2ZSwgdGhpcy5wb2x5TGluZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlICE9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHZlYzIuZGlzdGFuY2UocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSBkaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHZlYzIubGVycChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IC8gZGlzdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdwb3NpdGlvbicsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFRvLmF0dHIoJ3JvdGF0aW9uJywgVXRpbC50YW5nZW50Um90YXRpb24odGhpcy50dXJuaW5nUG9pbnRzW3RoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAyXSwgdGhpcy50dXJuaW5nUG9pbnRzW3RoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3ltYm9sRnJvbSkge1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHBvaW50c1swXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSAhPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZUZyb20gPSB2ZWMyLmRpc3RhbmNlKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gZGlzdGFuY2VGcm9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB2ZWMyLmxlcnAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtdLCBwb2ludHNbMF0sIHBvaW50c1sxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IC8gZGlzdGFuY2VGcm9tKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb2ludHNbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3ltYm9sRnJvbS5hdHRyKCdwb3NpdGlvbicsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgc3ltYm9sRnJvbS5hdHRyKCdyb3RhdGlvbicsIFV0aWwudGFuZ2VudFJvdGF0aW9uKHRoaXMudHVybmluZ1BvaW50c1sxXSwgdGhpcy50dXJuaW5nUG9pbnRzWzBdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva5zdHlsZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMg5qC35byP5a+56LGhXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5vdFNhdmVNb2RlbCDorr7nva7moLflvI/mmK/lkKbkv53lrZjliLDmqKHlnovkuK0s6buY6K6k5pivZmFsc2VcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uKG9wdGlvbnMsbm90U2F2ZU1vZGVsKSB7XHJcbiAgICAgICAgdmFyIGxpbmVPcHQgPSB7fTtcclxuICAgICAgICB2YXIgc3ltYm9sVG8gPSBudWxsO1xyXG4gICAgICAgIHZhciBub3RMaW5lS2V5cyA9IFsndGV4dCcsICdpbWFnZScsICdzeW1ib2wnXTtcclxuICAgICAgICAvLyBpZiAob3B0aW9ucy5jb2xvcikge1xyXG4gICAgICAgIC8vICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgLy8gICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGN1cnZlKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgY3VydmUuYXR0cihcInN0eWxlXCIsIHsgc3Ryb2tlOiBvcHRpb25zLmNvbG9yIH0pO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUoY3VydmUsIHsgc3Ryb2tlOiBvcHRpb25zLmNvbG9yIH0pO1xyXG4gICAgICAgIC8vICAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gICAgICAgICB0aGlzLnBvbHlMaW5lLmF0dHIoXCJzdHlsZVwiLCB7IHN0cm9rZTogb3B0aW9ucy5jb2xvciB9KTtcclxuICAgICAgICAvLyAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUodGhpcy5wb2x5TGluZSwgeyBzdHJva2U6IG9wdGlvbnMuY29sb3IgfSk7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyAgICAgc3ltYm9sVG8gPSB0aGlzLmNoaWxkT2ZOYW1lKCd0b1N5bWJvbCcpO1xyXG4gICAgICAgIC8vICAgICBpZiAoc3ltYm9sVG8pIHtcclxuICAgICAgICAvLyAgICAgICAgIHN5bWJvbFRvLmF0dHIoXCJzdHlsZVwiLCB7IGZpbGw6IG9wdGlvbnMuY29sb3IgfSk7XHJcbiAgICAgICAgLy8gICAgICAgICBncmFwaGljLnNldE5vcm1hbFN0eWxlKHN5bWJvbFRvLCB7IGZpbGw6IG9wdGlvbnMuY29sb3IgfSk7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyAgICAgaWYoIW5vdFNhdmVNb2RlbCkge1xyXG4gICAgICAgIC8vICAgICAgICAgdGhpcy5vcHRpb25zLnN0eWxlLnN0cm9rZSA9IG9wdGlvbnMuY29sb3I7XHJcbiAgICAgICAgLy8gICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuc3R5bGUuc3Ryb2tlXCIsIG9wdGlvbnMuY29sb3IpO1xyXG4gICAgICAgIC8vICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLnN5bWJvbC5jb2xvclwiLCBvcHRpb25zLmNvbG9yKTtcclxuICAgICAgICAvLyAgICAgICAgIHRoaXMub3B0aW9ucy5zeW1ib2wuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy50ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBsaW5lVGV4dCA9IHRoaXMuY2hpbGRPZk5hbWUoQ29ubmVjdG9yLkNISUxEX05BTUVbMF0pO1xyXG4gICAgICAgICAgICAvL+W8gOWni+ayoeacieWIm+W7uuaWh+acrO+8jOWQjuadpeS8oOi/m+adpXRleHTkuobvvIzpnIDopoHlhYjliJvlu7rmlofmnKxcclxuICAgICAgICAgICAgaWYgKCFsaW5lVGV4dCAmJiBvcHRpb25zLnRleHQudGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmRyYXdUZXh0KENvbm5lY3Rvci5DSElMRF9OQU1FWzBdLCBvcHRpb25zLnRleHQsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQodGV4dC50ZXh0KTtcclxuICAgICAgICAgICAgICAgIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZShDb25uZWN0b3IuQ0hJTERfTkFNRVswXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRleHQudGV4dCB8fCBvcHRpb25zLnRleHQudGV4dCA9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lVGV4dC5zZXRTdHlsZShcInRleHRcIiwgb3B0aW9ucy50ZXh0LnRleHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRleHQudGV4dCA9IG9wdGlvbnMudGV4dC50ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ZXh0UG9pbnQgPSB0aGlzLmdldFRleHRQb3N0aW9uKG9wdGlvbnMudGV4dCk7XHJcbiAgICAgICAgICAgIGxpbmVUZXh0LmF0dHIoXCJwb3NpdGlvblwiLCB0ZXh0UG9pbnQpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50ZXh0LnRleHRQb3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0LnRleHRQb3MgPSBvcHRpb25zLnRleHQudGV4dFBvcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50ZXh0Lm9mZnNldCkgeyAvLyMxODdcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0Lm9mZnNldCA9IG9wdGlvbnMudGV4dC5vZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRleHQuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVUZXh0LmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZpbGw6IG9wdGlvbnMudGV4dC5jb2xvclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC50ZXh0RmlsbCA9IG9wdGlvbnMudGV4dC5jb2xvcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGV4dC50ZXh0Rm9udCkge1xyXG4gICAgICAgICAgICAgICAgbGluZVRleHQuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDpvcHRpb25zLnRleHQudGV4dEZvbnRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRleHQudGV4dEZvbnQgPSBvcHRpb25zLnRleHQudGV4dEZvbnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRleHQudGV4dEZpbGwpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVUZXh0LmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZpbGw6IG9wdGlvbnMudGV4dC50ZXh0RmlsbFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC50ZXh0RmlsbCA9IG9wdGlvbnMudGV4dC50ZXh0RmlsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMudGV4dFwiLCBvcHRpb25zLnRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaW1hZ2UpIHtcclxuICAgICAgICAgICAgdmFyIGxpbmVJbWFnZSA9IHRoaXMuY2hpbGRPZk5hbWUoQ29ubmVjdG9yLkNISUxEX05BTUVbMV0pO1xyXG4gICAgICAgICAgICAvL+W8gOWni+ayoeacieWIm+W7uuWbvueJh++8jOWQjuadpeS8oOi/m+adpWltYWdl5LqG77yM6ZyA6KaB5YWI5Yib5bu65Zu+54mHXHJcbiAgICAgICAgICAgIGlmICghbGluZUltYWdlICYmIG9wdGlvbnMuaW1hZ2UuaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IHRoaXMuZHJhd1RleHQoQ29ubmVjdG9yLkNISUxEX05BTUVbMV0sIG9wdGlvbnMuaW1hZ2UsIDAsIDAsICdpbWFnZScpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoaW1hZ2UudGV4dCk7XHJcbiAgICAgICAgICAgICAgICBsaW5lSW1hZ2UgPSB0aGlzLmNoaWxkT2ZOYW1lKENvbm5lY3Rvci5DSElMRF9OQU1FWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW1hZ2VQb2ludCA9IHRoaXMuZ2V0VGV4dFBvc3Rpb24ob3B0aW9ucy5pbWFnZSwgbGluZUltYWdlKTtcclxuICAgICAgICAgICAgbGluZUltYWdlLmF0dHIoXCJwb3NpdGlvblwiLCBpbWFnZVBvaW50KTtcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5pbWFnZVtrZXldID0gb3B0aW9uc1trZXldO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbWFnZS5vZmZzZXQpIHsgLy8jMTg3XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaW1hZ2Uub2Zmc2V0ID0gb3B0aW9ucy5pbWFnZS5vZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLmltYWdlXCIsIG9wdGlvbnMuaW1hZ2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN5bWJvbC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3ltYm9sLnR5cGUgPSBvcHRpb25zLnN5bWJvbC50eXBlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLnN5bWJvbC50eXBlXCIsIG9wdGlvbnMuc3ltYm9sLnR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN5bWJvbC5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3ltYm9sLnNpemUgPSBvcHRpb25zLnN5bWJvbC5zaXplO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLnN5bWJvbC5zaXplXCIsIG9wdGlvbnMuc3ltYm9sLnNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN5bWJvbC5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN5bWJvbC5jb2xvciA9IG9wdGlvbnMuc3ltYm9sLmNvbG9yO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLnN5bWJvbC5jb2xvclwiLCBvcHRpb25zLnN5bWJvbC5jb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3ltYm9sLnopIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zeW1ib2wueiA9IG9wdGlvbnMuc3ltYm9sLno7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuc3ltYm9sLnpcIiwgb3B0aW9ucy5zeW1ib2wueik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICAgICAgaWYgKHN5bWJvbFRvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShzeW1ib2xUbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHRoaXMuY3JlYXRlU3ltYm9sKFwidG9TeW1ib2xcIiwgdGhpcy5tb2RlbC5nZXQoXCJvcHRpb25zXCIpKVxyXG4gICAgICAgICAgICBpZiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChzeW1ib2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChub3RMaW5lS2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lT3B0W2tleV0gPSBvcHRpb25zW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkobGluZU9wdCkgIT09ICd7fScpIHtcclxuICAgICAgICAgICAgaWYgKGxpbmVPcHQuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVPcHQuc3Ryb2tlID0gbGluZU9wdC5jb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGluZU9wdC5zdHJva2UpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVPcHQuY29sb3IgPSBsaW5lT3B0LnN0cm9rZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGN1cnZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VydmUuYXR0cihcInN0eWxlXCIsIGxpbmVPcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUoY3VydmUsIGxpbmVPcHQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvbHlMaW5lLmF0dHIoXCJzdHlsZVwiLCBsaW5lT3B0KTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUodGhpcy5wb2x5TGluZSwgbGluZU9wdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3ltYm9sVG8gPSB0aGlzLmNoaWxkT2ZOYW1lKCd0b1N5bWJvbCcpO1xyXG4gICAgICAgICAgICBpZiAoc3ltYm9sVG8gJiYgbGluZU9wdC5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sVG8uYXR0cihcInN0eWxlXCIsIHsgZmlsbDogbGluZU9wdC5jb2xvciB9KTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUoc3ltYm9sVG8sIHsgZmlsbDogbGluZU9wdC5jb2xvciB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZighbm90U2F2ZU1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhsaW5lT3B0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zdHlsZVtrZXldID0gbGluZU9wdFtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zdHlsZVwiKyBrZXksIGxpbmVPcHRba2V5XSk7XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVPcHQuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3ltYm9sLmNvbG9yID0gbGluZU9wdC5jb2xvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7pgInkuK1zdHlsZVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnNldFNlbGVjdGVkU3R5bGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyDpgInkuK3nmoTov57nur/lsYLnuqfmmK/mnIDpq5jnmoRcclxuICAgICAgICB2YXIgc3ltYm9sVG87XHJcbiAgICAgICAgdGhpcy5zZXRTdHlsZSh0aGlzLm9wdGlvbnMuaG92ZXJTdHlsZSwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGN1cnZlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJ2ZS5hdHRyKFwielwiLCB0aGlzLm9wdGlvbnMueiArIDIpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9seUxpbmUuYXR0cigneicsIHRoaXMub3B0aW9ucy56ICsgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICBpZiAoc3ltYm9sVG8pIHtcclxuICAgICAgICAgICAgc3ltYm9sVG8uYXR0cihcInpcIiwgdGhpcy5vcHRpb25zLnogKyAyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u5Y+W5raI6YCJ5Litc3R5bGVcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZW1vdmVTZWxlY3RlZFN0eWxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbFRvO1xyXG4gICAgICAgIHRoaXMuc2V0U3R5bGUoe2NvbG9yOnRoaXMub3B0aW9ucy5zdHlsZS5zdHJva2UsbGluZVdpZHRoOnRoaXMub3B0aW9ucy5zdHlsZS5saW5lV2lkdGh9LHRydWUpO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpIHtcclxuICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlLmVhY2hDaGlsZChmdW5jdGlvbihjdXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgY3VydmUuYXR0cihcInpcIiwgdGhpcy5vcHRpb25zLnopO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9seUxpbmUuYXR0cigneicsIHRoaXMub3B0aW9ucy56KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3ltYm9sVG8gPSB0aGlzLmNoaWxkT2ZOYW1lKCd0b1N5bWJvbCcpO1xyXG4gICAgICAgIGlmIChzeW1ib2xUbykge1xyXG4gICAgICAgICAgICBzeW1ib2xUby5hdHRyKFwielwiLCB0aGlzLm9wdGlvbnMueik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPlue6v+auteiKgueCueeahOS9jee9rlxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSB0ZXh0IHt0ZXh0OicnLCBjb2xvcjonJywgdGV4dFBvczonJ31cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICB7eCx5fVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmdldFRleHRQb3N0aW9uID0gZnVuY3Rpb24odGV4dCwgbm9kZSkge1xyXG4gICAgICAgIHZhciB0ZXh0UG9zdGlvbiA9IFtdO1xyXG4gICAgICAgIHZhciB0ZXh0UmVjdCA9IHRleHQuaW1hZ2UgJiYgbm9kZSA/IG5vZGUuZ2V0Qm91bmRpbmdSZWN0KCkgOiB0aGlzLmdldFRleHRCb3VuZGluZ1JlY3QodGV4dCk7XHJcbiAgICAgICAgdmFyIHRleHRXaWR0aCA9IHRleHRSZWN0LndpZHRoO1xyXG4gICAgICAgIHZhciB0ZXh0SGVpZ2h0ID0gdGV4dFJlY3QuaGVpZ2h0IHx8IDEyO1xyXG4gICAgICAgIHZhciBwb3M7XHJcbiAgICAgICAgaWYgKHRleHQgJiYgKHRleHQudGV4dFBvcyB8fCB0ZXh0LmltYWdlUG9zKSkge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGV4dC5vZmZzZXQgfHwgMDtcclxuICAgICAgICAgICAgdmFyIGFyck9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcG9zID0gdGV4dC50ZXh0UG9zIHx8IHRleHQuaW1hZ2VQb3M7XHJcbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkob2Zmc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgYXJyT2Zmc2V0ID0gW29mZnNldCwgMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBvaW50c09yaWdpbiA9IFV0aWwuZ2V0TWF4TGluZUxlbmd0aChbdGhpcy50dXJuaW5nUG9pbnRzW3RoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAyXSwgdGhpcy50dXJuaW5nUG9pbnRzW3RoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxXV0pO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW10sIGJlaXppZXJQb2ludHMgPVtdO1xyXG4gICAgICAgICAgICAgIHZhciBhbmdsZSA9IFV0aWwuZ2V0QW5nbGUocG9pbnRzT3JpZ2luWzBdLCBwb2ludHNPcmlnaW5bMV0pO1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoLCBuZXdQb2ludDtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkge1xyXG4gICAgICAgICAgICAgICAgYmVpemllclBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzRnJvbUN1cnZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9pbnRzT3JpZ2luLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1Db3B5ID0gbmV3IFBvaW50KGl0ZW0ueCwgcG9pbnRzT3JpZ2luWzFdLnggPj0gcG9pbnRzT3JpZ2luWzBdLnggPyBpdGVtLnkgLSB0ZXh0SGVpZ2h0IC8gMiA6IGl0ZW0ueSArIHRleHRIZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGl0ZW1Db3B5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHN3aXRjaChwb3MpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09PSBDb25uZWN0b3IuVFlQRV9TVFJBSUdIVCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBhcnJPZmZzZXRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BvaW50ID0gVXRpbC5nZXRFbmRQb2ludChwb2ludHNbMF0sIGxlbmd0aCwgYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFtuZXdQb2ludC54LCBuZXdQb2ludC55ICsgYXJyT2Zmc2V0WzFdXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFt0aGlzLnR1cm5pbmdQb2ludHNbMF0ueCAtIHRleHRXaWR0aCAvIDIgKyBhcnJPZmZzZXRbMF0sIHRoaXMudHVybmluZ1BvaW50c1swXS55ICsgYXJyT2Zmc2V0WzFdIC0gdGV4dEhlaWdodCAvIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PT0gQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQgJiYgIXRoaXMub3B0aW9ucy50ZXh0LnRleHRSb3RhdGVhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IFV0aWwuZGlzdGFuY2UocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQb2ludCA9IFV0aWwuZ2V0RW5kUG9pbnQocG9pbnRzWzBdLCBsZW5ndGgsIGFuZ2xlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFBvc3Rpb24gPSBbbmV3UG9pbnQueCAgLSB0ZXh0V2lkdGggKyBhcnJPZmZzZXRbMF0sIG5ld1BvaW50LnkgKyBhcnJPZmZzZXRbMV1dO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IFV0aWwuZGlzdGFuY2UocG9pbnRzWzBdLCBwb2ludHNbMV0pIC0gdGV4dFdpZHRoICsgYXJyT2Zmc2V0WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQb2ludCA9IFV0aWwuZ2V0RW5kUG9pbnQocG9pbnRzWzBdLCBsZW5ndGgsIGFuZ2xlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFBvc3Rpb24gPSBbbmV3UG9pbnQueCwgbmV3UG9pbnQueSArIGFyck9mZnNldFsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWlkUG9pbnQgPSB0aGlzLm1pZGRsZSh0ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pZkxpbmVOb2RlUm90YXRlYWJsZSh0ZXh0LmltYWdlID8gJ2ltYWdlJyA6ICd0ZXh0JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm90YXRlID0gdGhpcy5nZXRUZXh0Um90YXRpb24odGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uQmVmb3JlID0gW21pZFBvaW50WzBdIC0gdGV4dFdpZHRoIC8gMiwgbWlkUG9pbnRbMV0gLSB0ZXh0SGVpZ2h0IC8gMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFBvc3Rpb24gPSBVdGlsLmNhbGN1bGF0ZVBvaW50cyhwb3NpdGlvbkJlZm9yZSwge3g6IG1pZFBvaW50WzBdLCB5OiBtaWRQb2ludFsxXX0sIHJvdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5puy57q/55qE5paH5a2XcG9zaXRpb27ljZXni6zorqHnrpdcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWl6aWVyUG9pbnRzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyID0gYXJyLmNvbmNhdChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IE1hdGgucm91bmQoYXJyLmxlbmd0aCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFthcnJbaW5kZXhdLnggLSB0ZXh0V2lkdGggLyAyLCBhcnJbaW5kZXhdLnkgLXRleHRIZWlnaHQgLyAyXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFttaWRQb2ludFswXSArIGFyck9mZnNldFswXSwgbWlkUG9pbnRbMV0gKyBhcnJPZmZzZXRbMV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlICE9PSBDb25uZWN0b3IuVFlQRV9DSEFJTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFBvc3Rpb24gPSBbdGV4dFBvc3Rpb25bMF0gLSB0ZXh0V2lkdGggLyAyLCB0ZXh0UG9zdGlvblsxXSAtIHRleHRIZWlnaHQgLyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMubWlkZGxlKHRleHQpO1xyXG4gICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFtwb3NpdGlvblswXSAtIHRleHRXaWR0aCAvIDIsIHBvc2l0aW9uWzFdXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0UG9zdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bnur/mrrXnmoTml4vovazop5LluqZcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdGV4dFBvc3Rpb24ge3gseX1cclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAg6KeS5bqm5YC8XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0VGV4dFJvdGF0aW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIC8v6K6h566X5Ye65p6B5Z2Q5qCH55qE6KeS5bqmXHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFV0aWwuZ2V0TWF4TGluZUxlbmd0aCh0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgIHZhciBtaWRQb2ludCA9IHRoaXMubWlkZGxlKG9wdGlvbnMpO1xyXG4gICAgICAgIHZhciBhbmdsZSA9IC1NYXRoLmF0YW4yKHBvaW50c1sxXS55IC0gbWlkUG9pbnRbMV0sIHBvaW50c1sxXS54IC0gbWlkUG9pbnRbMF0pOyAvLyxNYXRoLlBJLzJcclxuICAgICAgICByZXR1cm4gYW5nbGU7XHJcbiAgICB9O1xyXG5cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY3JlYXRlSG92ZXJTdHlsZSA9IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3ZlclN0eWxlICYmIHRoaXMub3B0aW9ucy5pc0VkaXQpIHtcclxuICAgICAgICAgICAgZ3JhcGhpYy5zZXRFbGVtZW50SG92ZXJTdGwoZWwsIHRoaXMub3B0aW9ucy5ob3ZlclN0eWxlKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzeW1ib2xUbyA9IHRoaXMuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XHJcbiAgICAgICAgICAgIGlmIChzeW1ib2xUbykgeyBncmFwaGljLnNldEVsZW1lbnRIb3ZlclN0bChzeW1ib2xUbywgdGhpcy5vcHRpb25zLmFycm93SG92ZXJTdHlsZSk7IH1cclxuXHJcbiAgICAgICAgICAgIGVsLm9uKCdtb3VzZW92ZXInLCB6clV0aWwuYmluZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWMuZG9FbnRlckhvdmVyKGVsKTtcclxuICAgICAgICAgICAgICAgIGlmIChzeW1ib2xUbykgeyBncmFwaGljLmRvRW50ZXJIb3ZlcihzeW1ib2xUbyk7IH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaGljLmRvRW50ZXJIb3ZlcihsaW5lKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCB0aGlzKSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCB6clV0aWwuYmluZChmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRQb2ludCA9IHRoaXMudHVybmluZ1BvaW50c1swXTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRQb2ludCA9IHRoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnREaWZmID0gTWF0aC5hYnMoZS5ldmVudC5vZmZzZXRYIC0gc3RhcnRQb2ludC54KSArIE1hdGguYWJzKGUuZXZlbnQub2Zmc2V0WSAtIHN0YXJ0UG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kRGlmZiA9IE1hdGguYWJzKGUuZXZlbnQub2Zmc2V0WCAtIGVuZFBvaW50LngpICsgTWF0aC5hYnMoZS5ldmVudC5vZmZzZXRZIC0gZW5kUG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREaWZmIDw9IDE1IHx8IGVuZERpZmYgPD0gMTUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5jdXJzb3IgPSAnbW92ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuY3Vyc29yID0gJ3BvaW50ZXInO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLmRyYWdnYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0aGlzKSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIHpyVXRpbC5iaW5kKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpYy5kb0xlYXZlSG92ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbFRvKSB7IGdyYXBoaWMuZG9MZWF2ZUhvdmVyKHN5bWJvbFRvKTsgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlLmVhY2hDaGlsZChmdW5jdGlvbihsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5kb0xlYXZlSG92ZXIobGluZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgdGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uk5vZGXnmoTov57mjqXngrlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY3JlYXRlQWxsY29ubmVjdGlvblBvaW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcywgdGhpcy50dXJuaW5nUG9pbnRzWzBdLmNsb25lKCksIENvbm5lY3Rpb25Qb2ludC5UWVBFX0NPTk5FQ1RPUik7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcywgdGhpcy50dXJuaW5nUG9pbnRzW3RoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxXS5jbG9uZSgpLCBDb25uZWN0aW9uUG9pbnQuVFlQRV9DT05ORUNUT1IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uui/nuaOpeeCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc2hhcGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwb2ludCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHR5cGUgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSA9IGZ1bmN0aW9uKHNoYXBlLCBwb2ludCwgdHlwZSkge1xyXG4gICAgICAgIHZhciBjb25Qb2ludCA9IG5ldyBDb25uZWN0aW9uUG9pbnQodGhpcywgcG9pbnQsIHR5cGUsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cC5hZGQoY29uUG9pbnQuc2hhcGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOa4heepuuaOp+WItueCuVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY2xlYXJIYW5kbGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhhbmRsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhpcy5oYW5kbGVzW2ldLmhhbmRsZVNoYXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oYW5kbGVzID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuY29uUG9pbnRzR3JvdXApIHtcclxuICAgICAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cC5yZW1vdmVBbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mgaLlpI3ljp/mnaXnmoTpopzoibJcclxuICAgICAgICB0aGlzLnJlbW92ZVNlbGVjdGVkU3R5bGUoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmm7TmlrDmjqfliLbngrlcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnJlZnJlc2hIYW5kbGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMudHVybmluZ1BvaW50cztcclxuICAgICAgICB2YXIgYmVpemllclBvaW50cyA9IFtdO1xyXG4gICAgICAgIHZhciB4LCB5LCB0eXBlO1xyXG4gICAgICAgIGlmICh0aGlzLmhhbmRsZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDojrflj5bmm7Lnur/nmoTot6/lvoTngrnpm4blkIhcclxuICAgICAgICAgICAgICAgIGJlaXppZXJQb2ludHMgPSB0aGlzLmdldFBvaW50c0Zyb21DdXJ2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmhhbmRsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBhc3NvY2lhdGVkUG9pbnQgPSB0aGlzLmhhbmRsZXNbaV0uYXNzb2NpYXRlZFBvaW50O1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHRoaXMuaGFuZGxlc1tpXS50eXBlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcG9pbnRzLmZpbmRJbmRleChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ueCA9PSBhc3NvY2lhdGVkUG9pbnQueCAmJiBpdGVtLnkgPT0gYXNzb2NpYXRlZFBvaW50Lnk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSAnaCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHBvaW50c1tpbmRleCAtIDFdLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSAocG9pbnRzW2luZGV4IC0gMV0ueSArIHBvaW50c1tpbmRleF0ueSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSAndicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IChwb2ludHNbaW5kZXggLSAxXS54ICsgcG9pbnRzW2luZGV4XS54KSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbaW5kZXggLSAxXS55O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFICYmIGJlaXppZXJQb2ludHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmVpemllclBvaW50ID0genJVdGlsLmZpbmQoYmVpemllclBvaW50c1tpbmRleCAtIDJdLCBmdW5jdGlvbihwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnaCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkVmFsdWUgPSBNYXRoLmFicyhwb2ludC55IC0geSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRWYWx1ZSA9IE1hdGguYWJzKHBvaW50LnggLSB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkVmFsdWUgPCAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlaXppZXJQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGJlaXppZXJQb2ludC54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGJlaXppZXJQb2ludC55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlc1tpXS51cGRhdGUoeCwgeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rmi4bnur8g57q/5pat55qE5o6n5Yi254K5XHJcbiAgICAgKiDmm7Lnur/mjqfliLbngrnkvY3nva7orqHnrpfnsr7noa5cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnNoYXBlU2V0SGFuZGxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMudHVybmluZ1BvaW50cztcclxuICAgICAgICAvLyDojrflj5bmm7Lnur/nmoTot6/lvoTngrnpm4blkIhcclxuICAgICAgICB2YXIgYmVpemllclBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzRnJvbUN1cnZlKCk7XHJcbiAgICAgICAgdmFyIHR5cGU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoIC0gMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBoO1xyXG4gICAgICAgICAgICB2YXIgeCwgeTtcclxuICAgICAgICAgICAgLy/mmK/lkKblnKjkuIDmnaHnur/kuIpcclxuICAgICAgICAgICAgdmFyIGlzQ29sbGluZWFpdHlGaXJzdCA9IFV0aWwuY29sbGluZWFyaXR5KHBvaW50c1tpIC0gMV0sIHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSk7XHJcbiAgICAgICAgICAgIHZhciBpc0NvbGxpbmVhaXR5U2Vjb25kID0gVXRpbC5jb2xsaW5lYXJpdHkocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdLCBwb2ludHNbaSArIDJdKTtcclxuICAgICAgICAgICAgaWYgKCghaXNDb2xsaW5lYWl0eUZpcnN0ICYmICghaXNDb2xsaW5lYWl0eVNlY29uZCB8fCBwb2ludHNbaSArIDFdLmVxdWFscyhwb2ludHNbaSArIDJdKSkpIHx8ICgoIWlzQ29sbGluZWFpdHlGaXJzdCB8fCBwb2ludHNbaSAtIDFdLmVxdWFscyhwb2ludHNbaV0pKSAmJiAhaXNDb2xsaW5lYWl0eVNlY29uZCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRzW2ldLnggPT09IHBvaW50c1tpICsgMV0ueCkgeyAvL3NhbWUgdmVydGljYWxcclxuICAgICAgICAgICAgICAgICAgICB4ID0gcG9pbnRzW2ldLng7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IChwb2ludHNbaV0ueSArIHBvaW50c1tpICsgMV0ueSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnaCc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50c1tpXS55ID09PSBwb2ludHNbaSArIDFdLnkpIHsgLy8gc2FtZSBob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IChwb2ludHNbaV0ueCArIHBvaW50c1tpICsgMV0ueCkgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbaV0ueTtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ3YnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHggJiYgeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUgJiYgYmVpemllclBvaW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZWl6aWVyUG9pbnQgPSB6clV0aWwuZmluZChiZWl6aWVyUG9pbnRzW2kgLSAxXSwgZnVuY3Rpb24ocG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2gnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZFZhbHVlID0gTWF0aC5hYnMocG9pbnQueSAtIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkVmFsdWUgPSBNYXRoLmFicyhwb2ludC54IC0geCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZFZhbHVlIDwgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZWl6aWVyUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBiZWl6aWVyUG9pbnQueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBiZWl6aWVyUG9pbnQueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBoID0gbmV3IEhhbmRsZSh0eXBlLCB4LCB5LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBoLmFzc29jaWF0ZWRQb2ludCA9IHBvaW50c1tpICsgMV07IC8vIOi/nue6v+aOp+WItueCueS4jnRoaXMudHVybmluZ1BvaW50c+WFs+iBlFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChoLmhhbmRsZVNoYXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXMucHVzaChoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uueureWktFxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBuYW1lICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gb3B0aW9ucyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmNyZWF0ZVN5bWJvbCA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgc3ltYm9sVHlwZSA9IG9wdGlvbnMuc3ltYm9sLnR5cGU7XHJcbiAgICAgICAgdmFyIHN5bWJvbFNpemUgPSBvcHRpb25zLnN5bWJvbC5zaXplO1xyXG4gICAgICAgIGlmIChzeW1ib2xUeXBlID09PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShzeW1ib2xTaXplKSkge1xyXG4gICAgICAgICAgICBzeW1ib2xTaXplID0gW3N5bWJvbFNpemUsIHN5bWJvbFNpemVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHN5bWJvbFpJbmRleCA9IG9wdGlvbnMuejtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc3ltYm9sLnopIHsgc3ltYm9sWkluZGV4ID0gb3B0aW9ucy5zeW1ib2wueiB9XHJcblxyXG4gICAgICAgIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woXHJcbiAgICAgICAgICAgIHN5bWJvbFR5cGUsIC1zeW1ib2xTaXplWzBdIC8gMiwgLXN5bWJvbFNpemVbMV0gLyAyLFxyXG4gICAgICAgICAgICBzeW1ib2xTaXplWzBdLCBzeW1ib2xTaXplWzFdLCBzeW1ib2xaSW5kZXgsIG9wdGlvbnMuc3ltYm9sLmNvbG9yXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzeW1ib2xQYXRoLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICByZXR1cm4gc3ltYm9sUGF0aDtcclxuICAgIH07XHJcblxyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24obmFtZSwgY29udGVudCkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOe7mOWItue6v+auteS4iueahOaWh+acrFxyXG4gICAgICog55So55+p5b2i5Luj5pu/5paH5pysXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNvbnRlbnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBuYW1lIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0geCAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHkgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBjb2xvciAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZHJhd1RleHQgPSBmdW5jdGlvbihuYW1lLCBjb250ZW50LCB4LCB5LCB0eXBlKSB7XHJcbiAgICAgICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSAndGV4dCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcHQgPSB6clV0aWwuaXNTdHJpbmcoY29udGVudCkgPyAodHlwZSA9PT0gJ3RleHQnID8ge3RleHQ6Y29udGVudCwgeDp4LCB5Onl9IDoge2ltYWdlOmNvbnRlbnQsIHg6eCwgeTp5fSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogenJVdGlsLmRlZmF1bHRzKHt4OngsIHk6eX0sIGNvbnRlbnQsIHRydWUpO1xyXG5cclxuICAgICAgICB2YXIgdGV4dFN0eWxlID0genJVdGlsLmRlZmF1bHRzKHpyVXRpbC5jbG9uZSh0aGlzLm9wdGlvbnMudGV4dCksIG9wdCwgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIG5vZGU7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xyXG4gICAgICAgICAgICB2YXIgdGV4dEJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0VGV4dEJvdW5kaW5nUmVjdCh0ZXh0U3R5bGUpO1xyXG4gICAgICAgICAgICB0ZXh0U3R5bGUgPSB6clV0aWwuZGVmYXVsdHModGV4dFN0eWxlLCB7IGZpbGw6ICcjRjlGOUY5JywgdHJhbnNmb3JtVGV4dDogdHJ1ZSB9LCB0cnVlKTtcclxuICAgICAgICAgICAgbm9kZSA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHsgd2lkdGg6IHRleHRCb3VuZGluZ1JlY3Qud2lkdGgsIGhlaWdodDogdGV4dEJvdW5kaW5nUmVjdC5oZWlnaHQgfSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB0ZXh0U3R5bGUsXHJcbiAgICAgICAgICAgICAgICB6bGV2ZWw6IDIwLFxyXG4gICAgICAgICAgICAgICAgbmFtZSA6IG5hbWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdMaW5rSW1hZ2UnLFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHRleHRTdHlsZSxcclxuICAgICAgICAgICAgICAgIHpsZXZlbDogMjAsXHJcbiAgICAgICAgICAgICAgICBuYW1lIDogbmFtZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGV4dDogbm9kZSxcclxuICAgICAgICAgICAgcmVjdDogbm9kZS5nZXRCb3VuZGluZ1JlY3QoKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgIC8qKlxyXG4gICAgICog6I635Y+W57q/5q615paH5pys5YyF5Zu055uSXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNvbnRlbnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5nZXRUZXh0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24odGV4dCkge1xyXG4gICAgICAgIHZhciB0ZXh0UmVjdCA9IGdyYXBoaWMudGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRleHQudGV4dCwgdGV4dC50ZXh0Rm9udCk7XHJcbiAgICAgICAgdmFyIHRleHRXaWR0aCA9IGdyYXBoaWMudGV4dENvbnRhaW4uZ2V0V2lkdGgodGV4dC50ZXh0LCB0ZXh0LnRleHRGb250KTtcclxuICAgICAgICB2YXIgdGV4dEhlaWdodCA9IHRleHRSZWN0LmhlaWdodCB8fCAxMjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB3aWR0aDogdGV4dFdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRleHRIZWlnaHRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W57q/5q6155qE5Lit6Ze05YC8XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IHRleHRcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5taWRkbGUgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9TVFJBSUdIVCB8fCB0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ0hBSU4pIHtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFV0aWwuZ2V0TWF4TGluZUxlbmd0aCh0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgICAgICAvL+WmguaenOaYr+axgue6v+auteS4iueahOaWh+Wtl+eahOS4remXtOWAvFxyXG4gICAgICAgICAgICAvLyBpZih0ZXh0KSB7XHJcbiAgICAgICAgICAgIC8vICAgICAvL+WPluWHuuWtl+eahOmVv+W6pu+8jOiuoeeul+inkuW6pu+8jFxyXG4gICAgICAgICAgICAvLyAgICAgdmFyIHRleHRXaWR0aCA9IGdyYXBoaWMudGV4dENvbnRhaW4uZ2V0V2lkdGgodGV4dC50ZXh0LCB0ZXh0LnRleHRGb250KTtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBhbmdsZSA9IFV0aWwuZ2V0QW5nbGUocG9pbnRzWzBdLHBvaW50c1sxXSk7XHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgbGVuZ3RoID0gIFV0aWwuZGlzdGFuY2UocG9pbnRzWzBdLHBvaW50c1sxXSkvMiAtIHRleHRXaWR0aC8yO1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIG5ld1BvaW50ID0gVXRpbC5nZXRFbmRQb2ludChwb2ludHNbMF0sIGxlbmd0aCwgYW5nbGUpO1xyXG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuIFtuZXdQb2ludC54LCBuZXdQb2ludC55XTtcclxuICAgICAgICAgICAgLy8gfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBtaWRkbGVYID0gKHBvaW50c1swXS54ICsgcG9pbnRzWzFdLngpLzI7XHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgbWlkZGxlWSA9IChwb2ludHNbMF0ueSArIHBvaW50c1sxXS55KSAvMjtcclxuICAgICAgICAgICAgLy8gICAgIHJldHVybiBbbWlkZGxlWCwgbWlkZGxlWV07XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgdmFyIG1pZGRsZVggPSAocG9pbnRzWzBdLnggKyBwb2ludHNbMV0ueCkgLyAyO1xyXG4gICAgICAgICAgICB2YXIgbWlkZGxlWSA9IChwb2ludHNbMF0ueSArIHBvaW50c1sxXS55KSAvIDI7XHJcbiAgICAgICAgICAgIHJldHVybiBbbWlkZGxlWCwgbWlkZGxlWV07XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfSkFHR0VEKSB7XHJcblxyXG4gICAgICAgICAgICAvL2ZpbmQgdG90YWwgZGlzdGFuY2VcclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gdGhpcy5nZXRMZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgIC8vZmluZCBiZXR3ZWVuIHdoYXQgdHVybmluZyBwb2ludHMgdGhlIGhhbGYgZGlzdGFuY2UgaXNcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIHZhciBlbGxhcHNlZERpc3RhbmNlID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IFV0aWwuZ2V0TGVuZ3RoKHRoaXMudHVybmluZ1BvaW50c1tpXSwgdGhpcy50dXJuaW5nUG9pbnRzW2kgKyAxXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxsYXBzZWREaXN0YW5jZSArIHNlZ21lbnQgPCBkaXN0YW5jZSAvIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGxhcHNlZERpc3RhbmNlICs9IHNlZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3dlIGhhdmUgdGhlIG1pZGRsZSBkaXN0YW5jZSBzb21ld2hlcmUgYmV0d2VlbiBpKG5kZXgpIGFuZCBpKG5kZXgpKzFcclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWlzc2luZ0Rpc3RhbmNlID0gZGlzdGFuY2UgLyAyIC0gZWxsYXBzZWREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGlmIChVdGlsLnJvdW5kKHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueCwgMykgPT0gVXRpbC5yb3VuZCh0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXggKyAxXS54LCAzKSkgeyAvL3ZlcnRpY2FsIHNlZ21lbnQgKHNhbWUgeClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueCwgTWF0aC5taW4odGhpcy50dXJuaW5nUG9pbnRzW2luZGV4XS55LCB0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXggKyAxXS55KSArIG1pc3NpbmdEaXN0YW5jZV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFV0aWwucm91bmQodGhpcy50dXJuaW5nUG9pbnRzW2luZGV4XS55LCAzKSA9PSBVdGlsLnJvdW5kKHRoaXMudHVybmluZ1BvaW50c1tpbmRleCArIDFdLnksIDMpKSB7IC8vaG9yaXpvbnRhbCBzZWdtZW50IChzYW1lIHkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtNYXRoLm1pbih0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLngsIHRoaXMudHVybmluZ1BvaW50c1tpbmRleCArIDFdLngpICsgbWlzc2luZ0Rpc3RhbmNlLCB0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLnldO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ29ubmVjdG9yOm1pZGRsZSgpIC0gdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIFwiICsgdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4XSArIFwiIFwiICsgdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0gKyBcIiBuciBvZiBwb2ludHMgXCIgKyB0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkge1xyXG4gICAgICAgICAgICB2YXIgdCA9IDAuNTtcclxuICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmdldExlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHdhbGtlZCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCAtIDE7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdhbGtlZCArIFV0aWwuZGlzdGFuY2UodGhpcy50dXJuaW5nUG9pbnRzW2pdLCB0aGlzLnR1cm5pbmdQb2ludHNbaiArIDFdKSA+IGwgKiB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgd2Fsa2VkICs9IFV0aWwuZGlzdGFuY2UodGhpcy50dXJuaW5nUG9pbnRzW2pdLCB0aGlzLnR1cm5pbmdQb2ludHNbaiArIDFdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3QgPSBsICogdCAtIHdhbGtlZDtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRTZWdtZW50TGVuZ3RoID0gVXRpbC5kaXN0YW5jZSh0aGlzLnR1cm5pbmdQb2ludHNbal0sIHRoaXMudHVybmluZ1BvaW50c1tqICsgMV0pO1xyXG5cclxuICAgICAgICAgICAgLy9maW5kIHRoZSBwb3NpdGlvbi9yYXRpb24gb2YgdGhlIG1pZGRsZSBvZiBQb2x5bGluZSBvbiBjdXJyZW50IHNlZ21lbnRcclxuICAgICAgICAgICAgdmFyIHNlZ21lbnRQZXJjZW50ID0gcmVzdCAvIGN1cnJlbnRTZWdtZW50TGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgdmFyIFhwID0gc2VnbWVudFBlcmNlbnQgKiAodGhpcy50dXJuaW5nUG9pbnRzW2ogKyAxXS54IC0gdGhpcy50dXJuaW5nUG9pbnRzW2pdLngpICsgdGhpcy50dXJuaW5nUG9pbnRzW2pdLng7XHJcbiAgICAgICAgICAgIHZhciBZcCA9IHNlZ21lbnRQZXJjZW50ICogKHRoaXMudHVybmluZ1BvaW50c1tqICsgMV0ueSAtIHRoaXMudHVybmluZ1BvaW50c1tqXS55KSArIHRoaXMudHVybmluZ1BvaW50c1tqXS55O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtYcCwgWXBdO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGZpbmQgdG90YWwgZGlzdGFuY2VcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vZmluZCB0b3RhbCBkaXN0YW5jZVxyXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IFV0aWwuZ2V0TGVuZ3RoKHRoaXMudHVybmluZ1BvaW50c1tpXSwgdGhpcy50dXJuaW5nUG9pbnRzW2kgKyAxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaXN0YW5jZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDovaxKU09O5a+56LGhIGJwbW7kvb/nlKhcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInJlc291cmNlSWRcIiwgdGhpcy5yZXNvdXJjZUlkKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInByb3BlcnRpZXMudHlwZVwiLCAxNCk7XHJcblxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIsIHRoaXMucG9zaXRpb25bMF0pO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIsIHRoaXMucG9zaXRpb25bMV0pO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLmxvd2VyUmlnaHQueFwiLCBwYXJzZUludCh0aGlzLnBvc2l0aW9uWzBdICsgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCkpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLmxvd2VyUmlnaHQueVwiLCBwYXJzZUludCh0aGlzLnBvc2l0aW9uWzFdICsgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQpKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0eWxlLnNQb3NcIiwgdGhpcy5vcHRpb25zLnBvc2l0aW9uLnN0YXJ0UG9zKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0eWxlLmVQb3NcIiwgdGhpcy5vcHRpb25zLnBvc2l0aW9uLmVuZFBvcyk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJzdHlsZS5saW5lRGFzaFwiLCB0aGlzLm9wdGlvbnMuc3R5bGUubGluZURhc2gpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwic3R5bGUuc3Ryb2tlXCIsIHRoaXMub3B0aW9ucy5zdHlsZS5zdHJva2UpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwic3ltYm9sLnR5cGVcIiwgdGhpcy5vcHRpb25zLnN5bWJvbC50eXBlKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImRvY2tlcnNcIiwgdGhpcy50dXJuaW5nUG9pbnRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5vcHRpb247XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVmcmVzaE1vZGVsICBmbG935b2T5bqP5YiX5YyW55qE5pe25YCZ6LCD55SoIOabtOaWsOe6v+auteeahOS9jee9riDlj4rnur/kuIrnmoRpY29uc1xyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUucmVmcmVzaE1vZGVsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zXCIsIHpyVXRpbC5jbG9uZSh0aGlzLm9wdGlvbnMpKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuZG9ja2Vyc1wiLCB0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgIHZhciBpY29ucyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pY29ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaWNvbk5vZGUgPSB0aGlzLmljb25zW2ldO1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gW2ljb25Ob2RlLmtleSwge1xyXG4gICAgICAgICAgICAgICAgaWNvbjogaWNvbk5vZGUuc3R5bGUuaW1hZ2UsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogaWNvbk5vZGUuc3R5bGUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGljb25Ob2RlLnN0eWxlLmhlaWdodFxyXG4gICAgICAgICAgICB9XTtcclxuICAgICAgICAgICAgaWNvbnMucHVzaChvcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImljb25zXCIsIGljb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDosIPmlbTmm7Lnur/nmoTlvaLnirZcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBwb2ludHMg54K55pWw57uEXHJcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLm1vZGlmeUN1cnZlID0gZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgICAgICAgdmFyIHNvbCA9IHRoaXMuZ2V0Q3VydmVQb2ludChwb2ludHMpO1xyXG5cclxuICAgICAgICAvLyAxLiDlpoLmnpzmm7Lnur/nmoTmlbDph48g5q+U5pWw6YeP55qE5Lit5pWw6YeP6KaB5bCRIOWImeWIoOmZpOWkmuS9meeahOe6v+autVxyXG4gICAgICAgIHZhciB3aWxsRGVsQ3VydmVzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IHNvbC5sZW5ndGgsIGNudEN1cnZlID0gdGhpcy5ncm91cEN1cnZlLmNoaWxkQ291bnQoKTsgaiA8IGNudEN1cnZlOyBqKyspIHtcclxuICAgICAgICAgICAgd2lsbERlbEN1cnZlcy5wdXNoKHRoaXMuZ3JvdXBDdXJ2ZS5jaGlsZEF0KGopKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgenJVdGlsLmVhY2god2lsbERlbEN1cnZlcywgZnVuY3Rpb24oY3VydmUpIHtcclxuICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlLnJlbW92ZShjdXJ2ZSk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgLy8gMi4g6YGN5Y6G5puy57q/ICAg5aaC5p6c5a2Y5Zyo5YiZ55u05o6l6K6+572u5b2i54q277yM5ZCm5YiZ5Yib5bu6XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb2wubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdyb3VwQ3VydmUuY2hpbGRBdChpKTtcclxuICAgICAgICAgICAgaWYgKGxpbmUpIHtcclxuICAgICAgICAgICAgICAgIGxpbmUuYXR0cignc2hhcGUnLCBzb2xbaV0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cmUgPSBuZXcgZ3JhcGhpYy5CZXppZXJDdXJ2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbjogdGhpcy5vcHRpb25zLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB0aGlzLm9wdGlvbnMuc3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHNvbFtpXSxcclxuICAgICAgICAgICAgICAgICAgICB6OiB0aGlzLm9wdGlvbnMuelxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuYWRkKGN1cmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVIb3ZlclN0eWxlKGN1cmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjIOiOt+WPlueCue+8jOi/memHjOWPr+S7peiuvue9rueCueeahOS4quaVsFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bSDngrnkuKrmlbBcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHAxIOeCueWdkOagh1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gcDIg54K55Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwMyDngrnlnZDmoIdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHA0IOeCueWdkOagh1xyXG4gICAgICog5aaC5p6c5Y+C5pWw5pivIG51bSwgcDEsIHAyIOS4uuS4gOmYtui0neWhnuWwlFxyXG4gICAgICog5aaC5p6c5Y+C5pWw5pivIG51bSwgcDEsIGMxLCBwMiDkuLrkuozpmLbotJ3loZ7lsJRcclxuICAgICAqIOWmguaenOWPguaVsOaYryBudW0sIHAxLCBjMSwgYzIsIHAyIOS4uuS4iemYtui0neWhnuWwlFxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmdldEJlemllclBvaW50cyA9IGZ1bmN0aW9uKHBvaW50LCBudW0pIHtcclxuICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgdmFyIGZ1bmMgPSBudWxsO1xyXG4gICAgICAgIHZhciBzdGFydCA9IHBvaW50LnN0YXJ0O1xyXG4gICAgICAgIHZhciBjcDEgPSBwb2ludC5jcDE7XHJcbiAgICAgICAgdmFyIGNwMiA9IHBvaW50LmNwMjtcclxuICAgICAgICB2YXIgZW5kID0gcG9pbnQuZW5kO1xyXG4gICAgICAgIGlmICghbnVtIHx8IG51bSA8PSA1MCkge1xyXG4gICAgICAgICAgICBudW0gPSA1MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjcDEgJiYgIWNwMikge1xyXG4gICAgICAgICAgICBmdW5jID0gdGhpcy5vbmVCZXppZXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjcDEgJiYgIWNwMikge1xyXG4gICAgICAgICAgICBmdW5jID0gdGhpcy50d29CZXppZXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjcDEgJiYgY3AyKSB7XHJcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnRocmVlQmV6aWVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGZ1bmMoaSAvIG51bSwgc3RhcnQsIGNwMSwgY3AyLCBlbmQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcG9pbnRzLnB1c2goZW5kKTtcclxuICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjIOS4gOmYtui0neWhnuWwlFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQg5b2T5YmN55m+5YiG5q+UXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCDotbfngrnlnZDmoIdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVuZCDnu4jngrnlnZDmoIdcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5vbmVCZXppZXIgPSBmdW5jdGlvbih0LCBzdGFydCwgY3AxLCBjcDIsIGVuZCkge1xyXG4gICAgICAgIHZhciB4MSA9IHN0YXJ0LngxO1xyXG4gICAgICAgIHZhciB5MSA9IHN0YXJ0LnkxO1xyXG4gICAgICAgIHZhciB4MiA9IGVuZC54MjtcclxuICAgICAgICB2YXIgeTIgPSBlbmQueTI7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogeDEgKyAoeDIgLSB4MSkgKiB0LFxyXG4gICAgICAgICAgICB5OiB5MSArICh5MiAtIHkxKSAqIHRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2Mg5LqM6Zi26LSd5aGe5bCUXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCDlvZPliY3nmb7liIbmr5RcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IOi1t+eCueWdkOagh1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZW5kIOe7iOeCueWdkOagh1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gY3AxIOaOp+WItueCuVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnR3b0JlemllciA9IGZ1bmN0aW9uKHQsIHN0YXJ0LCBjcDEsIGNwMiwgZW5kKSB7XHJcbiAgICAgICAgdmFyIHgxID0gc3RhcnQueDE7XHJcbiAgICAgICAgdmFyIHkxID0gc3RhcnQueTE7XHJcbiAgICAgICAgdmFyIHgyID0gZW5kLngyO1xyXG4gICAgICAgIHZhciB5MiA9IGVuZC55MjtcclxuICAgICAgICB2YXIgY3B4MSA9IGNwMS5jcHgxO1xyXG4gICAgICAgIHZhciBjcHkxID0gY3AxLmNweTE7XHJcbiAgICAgICAgdmFyIHggPSAoMSAtIHQpICogKDEgLSB0KSAqIHgxICsgMiAqIHQgKiAoMSAtIHQpICogY3B4MSArIHQgKiB0ICogeDI7XHJcbiAgICAgICAgdmFyIHkgPSAoMSAtIHQpICogKDEgLSB0KSAqIHkxICsgMiAqIHQgKiAoMSAtIHQpICogY3B5MSArIHQgKiB0ICogeTI7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogeVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzYyDkuInpmLbotJ3loZ7lsJRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IOW9k+WJjeeZvuWIhuavlFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQg6LW354K55Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbmQg57uI54K55Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjcDEg5o6n5Yi254K5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjcDIg5o6n5Yi254K5XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUudGhyZWVCZXppZXIgPSBmdW5jdGlvbih0LCBzdGFydCwgY3AxLCBjcDIsIGVuZCkge1xyXG4gICAgICAgIHZhciB4MSA9IHN0YXJ0LngxO1xyXG4gICAgICAgIHZhciB5MSA9IHN0YXJ0LnkxO1xyXG4gICAgICAgIHZhciB4MiA9IGVuZC54MjtcclxuICAgICAgICB2YXIgeTIgPSBlbmQueTI7XHJcbiAgICAgICAgdmFyIGNweDEgPSBjcDEuY3B4MTtcclxuICAgICAgICB2YXIgY3B5MSA9IGNwMS5jcHkxO1xyXG4gICAgICAgIHZhciBjcHgyID0gY3AyLmNweDI7XHJcbiAgICAgICAgdmFyIGNweTIgPSBjcDIuY3B5MjtcclxuICAgICAgICB2YXIgeCA9XHJcbiAgICAgICAgICAgIHgxICogKDEgLSB0KSAqICgxIC0gdCkgKiAoMSAtIHQpICtcclxuICAgICAgICAgICAgMyAqIGNweDEgKiB0ICogKDEgLSB0KSAqICgxIC0gdCkgK1xyXG4gICAgICAgICAgICAzICogY3B4MiAqIHQgKiB0ICogKDEgLSB0KSArXHJcbiAgICAgICAgICAgIHgyICogdCAqIHQgKiB0O1xyXG4gICAgICAgIHZhciB5ID1cclxuICAgICAgICAgICAgeTEgKiAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCkgK1xyXG4gICAgICAgICAgICAzICogY3B5MSAqIHQgKiAoMSAtIHQpICogKDEgLSB0KSArXHJcbiAgICAgICAgICAgIDMgKiBjcHkyICogdCAqIHQgKiAoMSAtIHQpICtcclxuICAgICAgICAgICAgeTIgKiB0ICogdCAqIHQ7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogeVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bmm7Lnur/kuIrnmoTngrnovajov7lcclxuICAgICAqIEByZXR1cm4ge2FycmF5fVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmdldFBvaW50c0Zyb21DdXJ2ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgcGVyY2VudCA9IDA7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMudHVybmluZ1BvaW50cztcclxuICAgICAgICB2YXIgbWF4TWluUG9pbnRzID0gVXRpbC5nZXRNYXhMaW5lTGVuZ3RoKHBvaW50cyk7XHJcbiAgICAgICAgdmFyIGJlaXppZXJQb2ludHMgPSBbXTtcclxuICAgICAgICBwZXJjZW50ID0gcGFyc2VJbnQobWF4TWluUG9pbnRzWzBdLnggLSBtYXhNaW5Qb2ludHNbMV0ueCk7XHJcbiAgICAgICAgaWYgKCh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpICYmIChwb2ludHMubGVuZ3RoID4gMikpIHtcclxuICAgICAgICAgICAgdmFyIHNvbHMgPSB0aGlzLnRyYW5zZm9ybUN1cnZlUG9pbnQodGhpcy5nZXRDdXJ2ZVBvaW50KHBvaW50cykpO1xyXG4gICAgICAgICAgICBpZiAoc29scy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBzb2xzLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJlaXppZXJQb2ludHMucHVzaCh0aGF0LmdldEJlemllclBvaW50cyhpdGVtLCBwZXJjZW50KSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiZWl6aWVyUG9pbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2u5Lyg5YWl55qE54K55pWw57uE6L2s5o2i5oiQ6ZyA6KaB55qE57G75Z6LXHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gc29sIOeCueaVsOe7hFxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnRyYW5zZm9ybUN1cnZlUG9pbnQgPSBmdW5jdGlvbihzb2wpIHtcclxuICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgc29sLmZvckVhY2goZnVuY3Rpb24ocG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIHBvaW50UGFyYW0gPSB7fTtcclxuICAgICAgICAgICAgaWYgKHBvaW50LngxICYmIHBvaW50LnkxKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludFBhcmFtLnN0YXJ0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHgxOiBwb2ludC54MSxcclxuICAgICAgICAgICAgICAgICAgICB5MTogcG9pbnQueTFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9pbnQuY3B4MSAmJiBwb2ludC5jcHkxKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludFBhcmFtLmNwMSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjcHgxOiBwb2ludC5jcHgxLFxyXG4gICAgICAgICAgICAgICAgICAgIGNweTE6IHBvaW50LmNweTFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9pbnQuY3B4MiAmJiBwb2ludC5jcHkyKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludFBhcmFtLmNwMiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjcHgyOiBwb2ludC5jcHgyLFxyXG4gICAgICAgICAgICAgICAgICAgIGNweTI6IHBvaW50LmNweTJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9pbnQueDIgJiYgcG9pbnQueTIpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50UGFyYW0uZW5kID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHgyOiBwb2ludC54MixcclxuICAgICAgICAgICAgICAgICAgICB5MjogcG9pbnQueTJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb2ludHMucHVzaChwb2ludFBhcmFtKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2u5Lyg5YWl55qE54K55pWw57uE6K6h566X5puy57q/55qE54K5XHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gUCDngrnmlbDnu4RcclxuICAgICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgIOabsue6v+eahOeCueaVsOe7hFxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmdldEN1cnZlUG9pbnQgPSBmdW5jdGlvbihQKSB7XHJcbiAgICAgICAgdmFyIG4gPSBQLmxlbmd0aDtcclxuICAgICAgICB2YXIgc29sID0gW107XHJcbiAgICAgICAgaWYgKG4gPT09IDMpIHtcclxuICAgICAgICAgICAgc29sLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgeDE6IFBbMF0ueCxcclxuICAgICAgICAgICAgICAgIHkxOiBQWzBdLnksXHJcbiAgICAgICAgICAgICAgICBjcHgxOiBQWzFdLngsXHJcbiAgICAgICAgICAgICAgICBjcHkxOiBQWzFdLnksXHJcbiAgICAgICAgICAgICAgICB4MjogUFsyXS54LFxyXG4gICAgICAgICAgICAgICAgeTI6IFBbMl0ueVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHNvbDtcclxuICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDQpIHtcclxuICAgICAgICAgICAgc29sLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgeDE6IFBbMF0ueCxcclxuICAgICAgICAgICAgICAgIHkxOiBQWzBdLnksXHJcbiAgICAgICAgICAgICAgICBjcHgxOiBQWzFdLngsXHJcbiAgICAgICAgICAgICAgICBjcHkxOiBQWzFdLnksXHJcbiAgICAgICAgICAgICAgICBjcHgyOiBQWzJdLngsXHJcbiAgICAgICAgICAgICAgICBjcHkyOiBQWzJdLnksXHJcbiAgICAgICAgICAgICAgICB4MjogUFszXS54LFxyXG4gICAgICAgICAgICAgICAgeTI6IFBbM10ueVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHNvbDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipDb21wdXRlcyB0aGUgc3VtIGJldHdlZW4gdHdvIHBvaW50XHJcbiAgICAgICAgICpAcGFyYW0gcDEgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcGFyYW0gcDIgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcmV0dXJuIHtQb2ludH0gdGhlIHN1bSBvZiBpbml0aWFsIHBvaW50c1xyXG4gICAgICAgICAqKi9cclxuICAgICAgICBmdW5jdGlvbiBzdW0ocDEsIHAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocDEueCArIHAyLngsIHAxLnkgKyBwMi55KTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvKipDb21wdXRlcyB0aGUgZGl2aXNpb24gb2YgYSB7UG9pbnR9IGJ5IGEgbnVtYmVyXHJcbiAgICAgICAgICpAcGFyYW0gcCAtIHtQb2ludH1cclxuICAgICAgICAgKkBwYXJhbSBuciAtIHtOdW1iZXJ9XHJcbiAgICAgICAgICpAcmV0dXJuIHtQb2ludH1cclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZnVuY3Rpb24gZGl2aWRlKHAsIG5yKSB7XHJcbiAgICAgICAgICAgIGlmIChuciA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkRpdmlzaW9uIGJ5IHplcm8gbm90IGFsbG93ZWQgKHlldCA6KSBcIiArIHRoaXMuY2FsbGVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocC54IC8gbnIsIHAueSAvIG5yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKkNvbXB1dGVzIHRoZSBtdWx0aXBsaWNhdGlvbiBvZiBhIHtQb2ludH0gYnkgYSBudW1iZXJcclxuICAgICAgICAgKkBwYXJhbSBwIC0ge1BvaW50fVxyXG4gICAgICAgICAqQHBhcmFtIG5yIC0ge051bWJlcn1cclxuICAgICAgICAgKkByZXR1cm4ge1BvaW50fVxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBmdW5jdGlvbiBtdWx0aXBseShwLCBucikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHAueCAqIG5yLCBwLnkgKiBucik7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqSSBkbyBub3QgZ2V0IHdoeSBmaXJzdCA0IG11c3QgYmUgMCBhbmQgbGFzdCAzIG9mIHNhbWUgdmFsdWUuLi4uLlxyXG4gICAgICAgICAqYnV0IG90aGVyd2lzZSB3ZSB3aWxsIGdldCBkaXZpc2lvbiBieSB6ZXJvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGsgPSBbMCwgMCwgMF07XHJcblxyXG4gICAgICAgIHZhciBqO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPD0gbiAtIDM7IGorKykge1xyXG4gICAgICAgICAgICBrLnB1c2goaik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBrLnB1c2gobiAtIDMsIG4gLSAzKTtcclxuXHJcblxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBuIC0gMzsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vcTEgLSBjb21wdXRlIHN0YXJ0IHBvaW50XHJcbiAgICAgICAgICAgIHZhciBxMSA9IGRpdmlkZShzdW0obXVsdGlwbHkoUFtpXSwga1tpICsgNF0gLSBrW2kgKyAyXSksIG11bHRpcGx5KFBbaSArIDFdLCBrW2kgKyAyXSAtIGtbaSArIDFdKSksIGtbaSArIDRdIC0ga1tpICsgMV0pO1xyXG5cclxuICAgICAgICAgICAgLy9xMCAtIGNvbXB1dGUgMXN0IGNvbnRyb2xsIHBvaW50XHJcbiAgICAgICAgICAgIHZhciBxXzAxID0gKGtbaSArIDNdIC0ga1tpICsgMl0pIC8gKGtbaSArIDNdIC0ga1tpICsgMV0pO1xyXG4gICAgICAgICAgICB2YXIgcV8wMiA9IGRpdmlkZShzdW0obXVsdGlwbHkoUFtpIC0gMV0sIGtbaSArIDNdIC0ga1tpICsgMl0pLCBtdWx0aXBseShQW2ldLCBrW2kgKyAyXSAtIGtbaV0pKSwga1tpICsgM10gLSBrW2ldKTtcclxuICAgICAgICAgICAgdmFyIHFfMDMgPSBtdWx0aXBseShxMSwgKGtbaSArIDJdIC0ga1tpICsgMV0pIC8gKGtbaSArIDNdIC0ga1tpICsgMV0pKTtcclxuICAgICAgICAgICAgdmFyIHEwID0gc3VtKG11bHRpcGx5KHFfMDIsIHFfMDEpLCBxXzAzKTtcclxuXHJcbiAgICAgICAgICAgIC8vcTIgLSBjb21wdXRlIDJuZCBjb250cm9sbCBwb2ludFxyXG4gICAgICAgICAgICB2YXIgcTIgPSBkaXZpZGUoc3VtKG11bHRpcGx5KFBbaV0sIGtbaSArIDRdIC0ga1tpICsgM10pLCBtdWx0aXBseShQW2kgKyAxXSwga1tpICsgM10gLSBrW2kgKyAxXSkpLCBrW2kgKyA0XSAtIGtbaSArIDFdKTtcclxuXHJcbiAgICAgICAgICAgIC8vcTMgLSBjb21wdXRlIGVuZCBwb2ludFxyXG4gICAgICAgICAgICB2YXIgcV8zMSA9IChrW2kgKyAzXSAtIGtbaSArIDJdKSAvIChrW2kgKyA0XSAtIGtbaSArIDJdKTtcclxuICAgICAgICAgICAgdmFyIHFfMzIgPSBkaXZpZGUoc3VtKG11bHRpcGx5KFBbaSArIDFdLCBrW2kgKyA1XSAtIGtbaSArIDNdKSwgbXVsdGlwbHkoUFtpICsgMl0sIGtbaSArIDNdIC0ga1tpICsgMl0pKSwga1tpICsgNV0gLSBrW2kgKyAyXSk7XHJcbiAgICAgICAgICAgIHZhciBxXzMzID0gbXVsdGlwbHkocTIsIChrW2kgKyA0XSAtIGtbaSArIDNdKSAvIChrW2kgKyA0XSAtIGtbaSArIDJdKSk7XHJcbiAgICAgICAgICAgIHZhciBxMyA9IHN1bShtdWx0aXBseShxXzMyLCBxXzMxKSwgcV8zMyk7XHJcblxyXG4gICAgICAgICAgICAvL3N0b3JlIHNvbHV0aW9uXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIHNvbC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHgxOiBxMC54LFxyXG4gICAgICAgICAgICAgICAgeTE6IHEwLnksXHJcbiAgICAgICAgICAgICAgICBjcHgxOiBxMS54LFxyXG4gICAgICAgICAgICAgICAgY3B5MTogcTEueSxcclxuICAgICAgICAgICAgICAgIGNweDI6IHEyLngsXHJcbiAgICAgICAgICAgICAgICBjcHkyOiBxMi55LFxyXG4gICAgICAgICAgICAgICAgeDI6IHEzLngsXHJcbiAgICAgICAgICAgICAgICB5MjogcTMueVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzb2w7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBVdGlsLmluaGVyaXRzKENvbm5lY3RvciwgTm9kZSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0b3I7XHJcblxyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBTeW1ib2wgZmFjdG9yeVxyXG5cclxuXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uL2dyYXBoaWMnKTtcclxuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlhbmdsZSBzaGFwZVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUcmlhbmdsZSA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG4gICAgICAgIHR5cGU6ICd0cmlhbmdsZScsXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgY3ggPSBzaGFwZS5jeDtcclxuICAgICAgICAgICAgdmFyIGN5ID0gc2hhcGUuY3k7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIHBhdGgubW92ZVRvKGN4LCBjeSAtIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4ICsgd2lkdGgsIGN5ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggLSB3aWR0aCwgY3kgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEaWFtb25kIHNoYXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIERpYW1vbmQgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcclxuICAgICAgICB0eXBlOiAnZGlhbW9uZCcsXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgY3ggPSBzaGFwZS5jeDtcclxuICAgICAgICAgICAgdmFyIGN5ID0gc2hhcGUuY3k7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIHBhdGgubW92ZVRvKGN4LCBjeSAtIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4ICsgd2lkdGgsIGN5KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3gsIGN5ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggLSB3aWR0aCwgY3kpO1xyXG4gICAgICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGluIHNoYXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFBpbiA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG4gICAgICAgIHR5cGU6ICdwaW4nLFxyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIC8vIHgsIHkgb24gdGhlIGN1c3BcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55O1xyXG4gICAgICAgICAgICB2YXIgdyA9IHNoYXBlLndpZHRoIC8gNSAqIDM7XHJcbiAgICAgICAgICAgIC8vIEhlaWdodCBtdXN0IGJlIGxhcmdlciB0aGFuIHdpZHRoXHJcbiAgICAgICAgICAgIHZhciBoID0gTWF0aC5tYXgodywgc2hhcGUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIHIgPSB3IC8gMjtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc3Qgb24geSB3aXRoIHRhbmdlbnQgcG9pbnQgYW5kIGNpcmNsZSBjZW50ZXJcclxuICAgICAgICAgICAgdmFyIGR5ID0gciAqIHIgLyAoaCAtIHIpO1xyXG4gICAgICAgICAgICB2YXIgY3kgPSB5IC0gaCArIHIgKyBkeTtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hc2luKGR5IC8gcik7XHJcbiAgICAgICAgICAgIC8vIERpc3Qgb24geCB3aXRoIHRhbmdlbnQgcG9pbnQgYW5kIGNpcmNsZSBjZW50ZXJcclxuICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5jb3MoYW5nbGUpICogcjtcclxuXHJcbiAgICAgICAgICAgIHZhciB0YW5YID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgdGFuWSA9IE1hdGguY29zKGFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIHBhdGguYXJjKFxyXG4gICAgICAgICAgICAgICAgeCwgY3ksIHIsXHJcbiAgICAgICAgICAgICAgICBNYXRoLlBJIC0gYW5nbGUsXHJcbiAgICAgICAgICAgICAgICBNYXRoLlBJICogMiArIGFuZ2xlXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY3BMZW4gPSByICogMC42O1xyXG4gICAgICAgICAgICB2YXIgY3BMZW4yID0gciAqIDAuNztcclxuICAgICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKFxyXG4gICAgICAgICAgICAgICAgeCArIGR4IC0gdGFuWCAqIGNwTGVuLCBjeSArIGR5ICsgdGFuWSAqIGNwTGVuLFxyXG4gICAgICAgICAgICAgICAgeCwgeSAtIGNwTGVuMixcclxuICAgICAgICAgICAgICAgIHgsIHlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKFxyXG4gICAgICAgICAgICAgICAgeCwgeSAtIGNwTGVuMixcclxuICAgICAgICAgICAgICAgIHggLSBkeCArIHRhblggKiBjcExlbiwgY3kgKyBkeSArIHRhblkgKiBjcExlbixcclxuICAgICAgICAgICAgICAgIHggLSBkeCwgY3kgKyBkeVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyb3cgc2hhcGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgQXJyb3cgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ2Fycm93JyxcclxuXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55O1xyXG4gICAgICAgICAgICB2YXIgZHggPSB3aWR0aCAvIDMgKiAyO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBkeCwgeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSArIGhlaWdodCAvIDQgKiAzKTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0gZHgsIHkgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgb2YgcGF0aCBjb250cnVjdG9yc1xyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGg+fVxyXG4gICAgICovXHJcbiAgICB2YXIgc3ltYm9sQ3RvcnMgPSB7XHJcbiAgICAgICAgbGluZTogZ3JhcGhpYy5MaW5lLFxyXG5cclxuICAgICAgICByZWN0OiBncmFwaGljLlJlY3QsXHJcblxyXG4gICAgICAgIHJvdW5kUmVjdDogZ3JhcGhpYy5SZWN0LFxyXG5cclxuICAgICAgICBzcXVhcmU6IGdyYXBoaWMuUmVjdCxcclxuXHJcbiAgICAgICAgY2lyY2xlOiBncmFwaGljLkNpcmNsZSxcclxuXHJcbiAgICAgICAgZGlhbW9uZDogRGlhbW9uZCxcclxuXHJcbiAgICAgICAgcGluOiBQaW4sXHJcblxyXG4gICAgICAgIGFycm93OiBBcnJvdyxcclxuXHJcbiAgICAgICAgdHJpYW5nbGU6IFRyaWFuZ2xlXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzeW1ib2xTaGFwZU1ha2VycyA9IHtcclxuXHJcbiAgICAgICAgbGluZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIC8vIEZJWE1FXHJcbiAgICAgICAgICAgIHNoYXBlLngxID0geDtcclxuICAgICAgICAgICAgc2hhcGUueTEgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLngyID0geCArIHc7XHJcbiAgICAgICAgICAgIHNoYXBlLnkyID0geSArIGggLyAyO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geDtcclxuICAgICAgICAgICAgc2hhcGUueSA9IHk7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByb3VuZFJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geDtcclxuICAgICAgICAgICAgc2hhcGUueSA9IHk7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICAgICAgc2hhcGUuciA9IE1hdGgubWluKHcsIGgpIC8gNDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzcXVhcmU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKHcsIGgpO1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geDtcclxuICAgICAgICAgICAgc2hhcGUueSA9IHk7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gc2l6ZTtcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gc2l6ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjaXJjbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICAvLyBQdXQgY2lyY2xlIGluIHRoZSBjZW50ZXIgb2Ygc3F1YXJlXHJcbiAgICAgICAgICAgIHNoYXBlLmN4ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcclxuICAgICAgICAgICAgc2hhcGUuciA9IE1hdGgubWluKHcsIGgpIC8gMjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkaWFtb25kOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcGluOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgc2hhcGUueCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUueSA9IHkgKyBoIC8gMjtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFycm93OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgc2hhcGUueCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUueSA9IHkgKyBoIC8gMjtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRyaWFuZ2xlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgc3ltYm9sQnVpbGRQcm94aWVzID0ge307XHJcbiAgICBmb3IgKHZhciBuYW1lIGluIHN5bWJvbEN0b3JzKSB7XHJcbiAgICAgICAgc3ltYm9sQnVpbGRQcm94aWVzW25hbWVdID0gbmV3IHN5bWJvbEN0b3JzW25hbWVdKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIFN5bWJvbCA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG5cclxuICAgICAgICB0eXBlOiAnc3ltYm9sJyxcclxuXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgc3ltYm9sVHlwZTogJycsXHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICAvLyBGSVhNRVxyXG4gICAgICAgICAgICBpZiAoc2hhcGUuc3ltYm9sVHlwZSA9PT0gJ3BpbicgJiYgc3R5bGUudGV4dFBvc2l0aW9uID09PSAnaW5zaWRlJykge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dFBvc2l0aW9uID0gWyc1MCUnLCAnNDAlJ107XHJcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICAgICAgICAgIHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBzeW1ib2xUeXBlID0gc2hhcGUuc3ltYm9sVHlwZTtcclxuICAgICAgICAgICAgdmFyIHByb3h5U3ltYm9sID0gc3ltYm9sQnVpbGRQcm94aWVzW3N5bWJvbFR5cGVdO1xyXG4gICAgICAgICAgICBpZiAoc2hhcGUuc3ltYm9sVHlwZSAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb3h5U3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCByZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sVHlwZSA9ICdyZWN0JztcclxuICAgICAgICAgICAgICAgICAgICBwcm94eVN5bWJvbCA9IHN5bWJvbEJ1aWxkUHJveGllc1tzeW1ib2xUeXBlXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN5bWJvbFNoYXBlTWFrZXJzW3N5bWJvbFR5cGVdKFxyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlLngsIHNoYXBlLnksIHNoYXBlLndpZHRoLCBzaGFwZS5oZWlnaHQsIHByb3h5U3ltYm9sLnNoYXBlXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgcHJveHlTeW1ib2wuYnVpbGRQYXRoKGN0eCwgcHJveHlTeW1ib2wuc2hhcGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gUHJvdmlkZSBzZXRDb2xvciBoZWxwZXIgbWV0aG9kIHRvIGF2b2lkIGRldGVybWluZSBpZiBzZXQgdGhlIGZpbGwgb3Igc3Ryb2tlIG91dHNpZGVcclxuICAgIHZhciBzeW1ib2xQYXRoU2V0Q29sb3IgPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAnaW1hZ2UnKSB7XHJcbiAgICAgICAgICAgIHZhciBzeW1ib2xTdHlsZSA9IHRoaXMuc3R5bGU7XHJcbiAgICAgICAgICAgIHZhciBzeW1ib2xTaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIGlmIChzeW1ib2xTaGFwZSAmJiBzeW1ib2xTaGFwZS5zeW1ib2xUeXBlID09PSAnbGluZScpIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX19pc0VtcHR5QnJ1c2gpIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuZmlsbCA9ICcjZmZmJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEZJWE1FIOWIpOaWreWbvuW9oum7mOiupOaYr+Whq+WFhei/mOaYr+aPj+i+ue+8jOS9v+eUqCBvbmx5U3Ryb2tlID9cclxuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLmZpbGwgJiYgKHN5bWJvbFN0eWxlLmZpbGwgPSBjb2xvcik7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5zdHJva2UgJiYgKHN5bWJvbFN0eWxlLnN0cm9rZSA9IGNvbG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRpcnR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgYSBzeW1ib2wgZWxlbWVudCB3aXRoIGdpdmVuIHN5bWJvbCBjb25maWd1cmF0aW9uOiBzaGFwZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3JcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sVHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gd1xyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBjcmVhdGVTeW1ib2w6IGZ1bmN0aW9uIChzeW1ib2xUeXBlLCB4LCB5LCB3LCBoLCB6LCBjb2xvcikge1xyXG4gICAgICAgICAgICB2YXIgaXNFbXB0eSA9IHN5bWJvbFR5cGUuaW5kZXhPZignZW1wdHknKSA9PT0gMDtcclxuICAgICAgICAgICAgaWYgKGlzRW1wdHkpIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFR5cGUgPSBzeW1ib2xUeXBlLnN1YnN0cig1LCAxKS50b0xvd2VyQ2FzZSgpICsgc3ltYm9sVHlwZS5zdWJzdHIoNik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN5bWJvbFBhdGg7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3ltYm9sVHlwZS5pbmRleE9mKCdpbWFnZTovLycpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xQYXRoID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBzeW1ib2xUeXBlLnNsaWNlKDgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB6OiB6XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzeW1ib2xUeXBlLmluZGV4T2YoJ3BhdGg6Ly8nKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sUGF0aCA9IGdyYXBoaWMubWFrZVBhdGgoc3ltYm9sVHlwZS5zbGljZSg3KSwge3o6IHosIHJlY3RIb3ZlcjogdHJ1ZX0sIG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgdywgaCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sUGF0aCA9IG5ldyBTeW1ib2woe1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbFR5cGU6IHN5bWJvbFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHo6IHpcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xQYXRoLl9faXNFbXB0eUJydXNoID0gaXNFbXB0eTtcclxuXHJcbiAgICAgICAgICAgIHN5bWJvbFBhdGguc2V0Q29sb3IgPSBzeW1ib2xQYXRoU2V0Q29sb3I7XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xQYXRoLnNldENvbG9yKGNvbG9yKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xQYXRoO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzeW1ib2xVdGlsO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9TeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog55S75Y+l5p+EXHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XHJcbiAgICBmdW5jdGlvbiBIYW5kbGUodHlwZSwgeCwgeSwgY29ubmVjdG9yKXtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG5cclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcclxuXHJcbiAgICAgICAgdGhpcy5oYW5kbGVTaGFwZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogeCxcclxuICAgICAgICAgICAgICAgIGN5OiB5LFxyXG4gICAgICAgICAgICAgICAgcjogSGFuZGxlLlJBRElVU1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IFwicmdiKDAsMjU1LDApXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6XCJyZ2IoMCwwLDApXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgemxldmVsIDogY29ubmVjdG9yLm9wdGlvbnMueiArIDIsICAvL+iKgueCuVrkuLoxIOe6v+auteS4ujA7XHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTp0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGlzLmhhbmRsZVNoYXBlLm9uKFwiZHJhZ1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHRoYXQuYWN0aW9uQ29ubmVjdG9yKGUub2Zmc2V0WCxlLm9mZnNldFkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgLy8gcmV0dXJuIHRoaXMuY2lyY2xlO1xyXG4gICAgfVxyXG5cclxuICAgIEhhbmRsZS5SQURJVVMgPSA0O1xyXG5cclxuICAgIEhhbmRsZS5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yIDogSGFuZGxlLFxyXG5cclxuICAgICAgICBlcXVhbHMgOiBmdW5jdGlvbihhbm90aGVySGFuZGxlKXtcclxuICAgICAgICAgICAgaWYoIWFub3RoZXJIYW5kbGUgaW5zdGFuY2VvZiBIYW5kbGUpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IGFub3RoZXJIYW5kbGUudHlwZVxyXG4gICAgICAgICAgICAmJiB0aGlzLnggPT0gYW5vdGhlckhhbmRsZS54XHJcbiAgICAgICAgICAgICYmIHRoaXMueSA9PSBhbm90aGVySGFuZGxlLnlcclxuICAgICAgICAgICAgJiYgdGhpcy52aXNpYmxlID09IGFub3RoZXJIYW5kbGUudmlzaWJsZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTaGFwZS5hdHRyKCdwb3NpdGlvbicsIFswLCAwXSk7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2hhcGUuc2V0U2hhcGUoe1xyXG4gICAgICAgICAgICAgICAgY3g6IHgsXHJcbiAgICAgICAgICAgICAgICBjeTogeVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDnp7vliqjlj6Xmn4RcclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5ld1ggW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbmV3WSBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKi9cclxuICAgICAgICBhY3Rpb25Db25uZWN0b3I6IGZ1bmN0aW9uKG5ld1gsIG5ld1kpe1xyXG4gICAgICAgICAgICBzd2l0Y2godGhpcy50eXBlKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmib7lh7rkuKTkuKrovazmipjngrnvvIjlj6/np7vliqjlj6Xmn4TlnKjov5nkuKTkuKrovazmipjngrnkuK3pl7TvvIlcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50cy5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXNzb2NpYXRlZFBvaW50ICYmIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueCA9PSB0aGlzLmFzc29jaWF0ZWRQb2ludC54ICYmIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueSA9PSB0aGlzLmFzc29jaWF0ZWRQb2ludC55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueSA9PSB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueSA9PSB0aGlzLnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGgubWluKHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueCwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLngpIDw9IHRoaXMueFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5tYXgodGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54LCB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueCkgPj0gdGhpcy54KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhWSA9IG5ld1kgLSB0aGlzLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uTWF0cml4ID0gVXRpbC50cmFuc2xhdGlvbk1hdHJpeCgwLCBkZWx0YVkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2luZGV4LTFdLnRyYW5zZm9ybSh0cmFuc2xhdGlvbk1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpbmRleF0udHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5yZWZyZXNoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmib7lh7rkuKTkuKrovazmipjngrnvvIjlj6/np7vliqjlj6Xmn4TlnKjov5nkuKTkuKrovazmipjngrnkuK3pl7TvvIlcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50cy5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXNzb2NpYXRlZFBvaW50ICYmIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueCA9PSB0aGlzLmFzc29jaWF0ZWRQb2ludC54ICYmIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueSA9PSB0aGlzLmFzc29jaWF0ZWRQb2ludC55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueCA9PSB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueCA9PSB0aGlzLnhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGgubWluKHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueSwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLnkpIDw9IHRoaXMueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5tYXgodGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS55LCB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueSkgPj0gdGhpcy55KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YVggPSBuZXdYLXRoaXMueDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRpb25NYXRyaXggPSBVdGlsLnRyYW5zbGF0aW9uTWF0cml4KGRlbHRhWCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpbmRleC0xXS50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaW5kZXhdLnRyYW5zZm9ybSh0cmFuc2xhdGlvbk1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IucmVmcmVzaCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIC8vLiB0aGlzLnNoYXBlLnVwZGF0ZU1pZGRsZVRleHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW5kbGU7XHJcblxyXG5cclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvSGFuZGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOi/nue6v+WKqOaAgeaViOaenFxyXG4gKiBAYXV0aG9yIG1pYW8uY3VuemhpXHJcbiAqL1xyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcclxuICAgIHZhciBjdXJ2ZVV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2N1cnZlJyk7XHJcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoJy4vU3ltYm9sLmpzJyk7XHJcblxyXG4gICAgZnVuY3Rpb24gRWZmZWN0TGluZShzeW1ib2wsIG9wdGlvbnMsIGdyb3VwQ3VydmUsIHBvbHlMaW5lKSB7XHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLl9sYXN0RnJhbWVQZXJjZW50ID0gMDtcclxuICAgICAgICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcclxuICAgICAgICB0aGlzLmdyb3VwQ3VydmUgPSBncm91cEN1cnZlO1xyXG4gICAgICAgIHRoaXMuaW5pdFN5bWJvbChvcHRpb25zLCBwb2x5TGluZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgRWZmZWN0TGluZVByb3RvID0gRWZmZWN0TGluZS5wcm90b3R5cGU7XHJcblxyXG4gICAgRWZmZWN0TGluZVByb3RvLmluaXRTeW1ib2wgPSBmdW5jdGlvbihvcHRpb25zLCBwb2x5TGluZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGlzLnN5bWJvbC56MiA9IDEwMDtcclxuICAgICAgICB0aGlzLnN5bWJvbC5jdWxsaW5nID0gdHJ1ZTtcclxuICAgICAgICB2YXIgcGVyaW9kID0gb3B0aW9ucy5lZmZlY3QucGVyaW9kICogMTAwMDtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX3QgPSAwO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLnN0b3BBbmltYXRpb24oKTtcclxuICAgICAgICBpZiAoKG9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gXCJjdXJ2ZVwiKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ncm91cEN1cnZlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBwZXJpb2QgPSBwZXJpb2QgLyB0aGlzLmdyb3VwQ3VydmUuX2NoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZUFuaW1hdGUodGhpcy5ncm91cEN1cnZlLl9jaGlsZHJlblswXSwgaSwgcGVyaW9kKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN5bWJvbC5hbmltYXRlKCcnLCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgLndoZW4ocGVyaW9kLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgX190OiAxXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmRlbGF5KDApXHJcbiAgICAgICAgICAgICAgICAuZHVyaW5nKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlU3ltYm9sUG9zaXRpb25Qb2x5bGluZSgpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5zdGFydCgpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEFuaW1hdGlvblBvaW50c1BvbHlsaW5lKHBvbHlMaW5lLnNoYXBlLnBvaW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgRWZmZWN0TGluZVByb3RvLmdyb3VwQ3VydmVBbmltYXRlID0gZnVuY3Rpb24oY3VydmVMaW5lLCBpLCBwZXJpb2QpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGN1cnZlTGluZSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY3VydmVMaW5lID0gdGhpcy5ncm91cEN1cnZlLl9jaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwb2ludHM7XHJcbiAgICAgICAgdmFyIHBvcyA9IGN1cnZlTGluZS5zaGFwZTtcclxuICAgICAgICBwb2ludHMgPSBbXHJcbiAgICAgICAgICAgIFtwb3MueDEsIHBvcy55MV0sXHJcbiAgICAgICAgICAgIFtwb3MueDIsIHBvcy55Ml0sXHJcbiAgICAgICAgICAgIFtwb3MuY3B4MSwgcG9zLmNweTFdLFxyXG4gICAgICAgICAgICBbcG9zLmNweDIsIHBvcy5jcHkyXVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5zZXRBbmltYXRpb25Qb2ludHNCZXppZXJDdXJ2ZShwb2ludHMpO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLmFuaW1hdGUoJycpXHJcbiAgICAgICAgICAgIC53aGVuKHBlcmlvZCwge1xyXG4gICAgICAgICAgICAgICAgX190OiAxXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5kZWxheSgwKVxyXG4gICAgICAgICAgICAuZHVyaW5nKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC51cGRhdGVTeW1ib2xQb3NpdGlvbkJlemllckN1cnZlKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5kb25lKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zeW1ib2wuX190ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoYXQuZ3JvdXBDdXJ2ZUFuaW1hdGUodGhhdC5ncm91cEN1cnZlLl9jaGlsZHJlbltpICsgMV0sIGkgKyAxLCBwZXJpb2QpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3RhcnQoKTtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8uc2V0QW5pbWF0aW9uUG9pbnRzQmV6aWVyQ3VydmUgPSBmdW5jdGlvbihwb2ludHMpIHtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX3AxID0gcG9pbnRzWzBdO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fcDIgPSBwb2ludHNbMV07XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX19jcDEgPSBwb2ludHNbMl0gfHwgW1xyXG4gICAgICAgICAgICAocG9pbnRzWzBdWzBdICsgcG9pbnRzWzFdWzBdKSAvIDIsXHJcbiAgICAgICAgICAgIChwb2ludHNbMF1bMV0gKyBwb2ludHNbMV1bMV0pIC8gMlxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX19jcDIgPSBwb2ludHNbM107XHJcbiAgICB9O1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by51cGRhdGVTeW1ib2xQb3NpdGlvbkJlemllckN1cnZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHAxID0gdGhpcy5zeW1ib2wuX19wMTtcclxuICAgICAgICB2YXIgcDIgPSB0aGlzLnN5bWJvbC5fX3AyO1xyXG4gICAgICAgIHZhciBjcDEgPSB0aGlzLnN5bWJvbC5fX2NwMTtcclxuICAgICAgICB2YXIgY3AyID0gdGhpcy5zeW1ib2wuX19jcDI7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLnN5bWJvbC5fX3Q7XHJcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuc3ltYm9sLnBvc2l0aW9uO1xyXG4gICAgICAgIHZhciB0eCwgdHk7XHJcbiAgICAgICAgaWYgKGNwMlswXSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIGN1YmljQXQgPSBjdXJ2ZVV0aWwuY3ViaWNBdDtcclxuICAgICAgICAgICAgdmFyIGN1YmljRGVyaXZhdGl2ZUF0ID0gY3VydmVVdGlsLmN1YmljRGVyaXZhdGl2ZUF0O1xyXG4gICAgICAgICAgICBwb3NbMF0gPSBjdWJpY0F0KHAxWzBdLCBjcDFbMF0sIGNwMlswXSwgcDJbMF0sIHQpO1xyXG4gICAgICAgICAgICBwb3NbMV0gPSBjdWJpY0F0KHAxWzFdLCBjcDFbMV0sIGNwMlsxXSwgcDJbMV0sIHQpO1xyXG4gICAgICAgICAgICAvLyBUYW5nZW50XHJcbiAgICAgICAgICAgIHR4ID0gY3ViaWNEZXJpdmF0aXZlQXQocDFbMF0sIGNwMVswXSwgY3AyWzBdLCBwMlswXSwgdCk7XHJcbiAgICAgICAgICAgIHR5ID0gY3ViaWNEZXJpdmF0aXZlQXQocDFbMV0sIGNwMVsxXSwgY3AyWzFdLCBwMlsxXSwgdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHF1YWRyYXRpY0F0ID0gY3VydmVVdGlsLnF1YWRyYXRpY0F0O1xyXG4gICAgICAgICAgICB2YXIgcXVhZHJhdGljRGVyaXZhdGl2ZUF0ID0gY3VydmVVdGlsLnF1YWRyYXRpY0Rlcml2YXRpdmVBdDtcclxuICAgICAgICAgICAgcG9zWzBdID0gcXVhZHJhdGljQXQocDFbMF0sIGNwMVswXSwgcDJbMF0sIHQpO1xyXG4gICAgICAgICAgICBwb3NbMV0gPSBxdWFkcmF0aWNBdChwMVsxXSwgY3AxWzFdLCBwMlsxXSwgdCk7XHJcbiAgICAgICAgICAgIC8vIFRhbmdlbnRcclxuICAgICAgICAgICAgdHggPSBxdWFkcmF0aWNEZXJpdmF0aXZlQXQocDFbMF0sIGNwMVswXSwgcDJbMF0sIHQpO1xyXG4gICAgICAgICAgICB0eSA9IHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMVsxXSwgY3AxWzFdLCBwMlsxXSwgdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3ltYm9sLnJvdGF0aW9uID0gLU1hdGguYXRhbjIodHksIHR4KSAtIE1hdGguUEkgLyAyO1xyXG5cclxuICAgICAgICB0aGlzLnN5bWJvbC5pZ25vcmUgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgRWZmZWN0TGluZVByb3RvLnNldEFuaW1hdGlvblBvaW50c1BvbHlsaW5lID0gZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xyXG4gICAgICAgIHZhciBhY2NMZW5BcnIgPSBbMF07XHJcbiAgICAgICAgdmFyIGxlbiA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHAxID0gcG9pbnRzW2kgLSAxXTtcclxuICAgICAgICAgICAgdmFyIHAyID0gcG9pbnRzW2ldO1xyXG4gICAgICAgICAgICBsZW4gKz0gdmVjMi5kaXN0KHAxLCBwMik7XHJcbiAgICAgICAgICAgIGFjY0xlbkFyci5wdXNoKGxlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhY2NMZW5BcnIubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgYWNjTGVuQXJyW2pdIC89IGxlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fb2Zmc2V0cyA9IGFjY0xlbkFycjtcclxuICAgICAgICB0aGlzLl9sZW5ndGggPSBsZW47XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX2xhc3RGcmFtZSA9IDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX19sYXN0RnJhbWVQZXJjZW50ID0gMDtcclxuICAgIH07XHJcblxyXG4gICAgRWZmZWN0TGluZVByb3RvLnVwZGF0ZVN5bWJvbFBvc2l0aW9uUG9seWxpbmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXMuc3ltYm9sLl9fdDtcclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5fcG9pbnRzO1xyXG4gICAgICAgIHZhciBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcclxuICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKCFvZmZzZXRzKSB7XHJcbiAgICAgICAgICAgIC8vIEhhcyBsZW5ndGggMFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbGFzdEZyYW1lID0gdGhpcy5fbGFzdEZyYW1lO1xyXG4gICAgICAgIHZhciBmcmFtZTtcclxuXHJcbiAgICAgICAgaWYgKHQgPCB0aGlzLl9sYXN0RnJhbWVQZXJjZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFN0YXJ0IGZyb20gdGhlIG5leHQgZnJhbWVcclxuICAgICAgICAgICAgLy8gUEVORElORyBzdGFydCBmcm9tIGxhc3RGcmFtZSA/XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IE1hdGgubWluKGxhc3RGcmFtZSArIDEsIGxlbiAtIDEpO1xyXG4gICAgICAgICAgICBmb3IgKGZyYW1lID0gc3RhcnQ7IGZyYW1lID49IDA7IGZyYW1lLS0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRzW2ZyYW1lXSA8PSB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUEVORElORyByZWFsbHkgbmVlZCB0byBkbyB0aGlzID9cclxuICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSwgbGVuIC0gMik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZnJhbWUgPSBsYXN0RnJhbWU7IGZyYW1lIDwgbGVuOyBmcmFtZSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0c1tmcmFtZV0gPiB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSAtIDEsIGxlbiAtIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2ZWMyLmxlcnAoXHJcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sLnBvc2l0aW9uLCBwb2ludHNbZnJhbWVdLCBwb2ludHNbZnJhbWUgKyAxXSxcclxuICAgICAgICAgICAgKHQgLSBvZmZzZXRzW2ZyYW1lXSkgLyAob2Zmc2V0c1tmcmFtZSArIDFdIC0gb2Zmc2V0c1tmcmFtZV0pXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gZnJhbWU7XHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGVyY2VudCA9IHQ7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gLU1hdGguYXRhbjIocG9pbnRzW2ZyYW1lICsgMV1bMV0gLSBwb2ludHNbZnJhbWVdWzFdLCBwb2ludHNbZnJhbWUgKyAxXVswXSAtIHBvaW50c1tmcmFtZV1bMF0pO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLnJvdGF0aW9uID0gYW5nbGUgLSBNYXRoLlBJIC8gMjtcclxuICAgICAgICB0aGlzLnN5bWJvbC5pZ25vcmUgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEVmZmVjdExpbmU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0VmZmVjdExpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5o6n5Yi254K5XHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25Qb2ludChjb25uZWN0b3IsIHBvaW50LCB0eXBlLCBvcHRpb25zKXtcclxuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcclxuXHJcbiAgICAgICAgdGhpcy5wb2ludCA9IHBvaW50LmNsb25lKCk7XHJcblxyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgICAgIHRoaXMuY29sb3IgPSBDb25uZWN0aW9uUG9pbnQuTk9STUFMX0NPTE9SO1xyXG5cclxuICAgICAgICB0aGlzLm9UeXBlID0gJ0Nvbm5lY3Rpb25Qb2ludCc7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IHRoaXMucG9pbnQueCxcclxuICAgICAgICAgICAgICAgIGN5OiB0aGlzLnBvaW50LnksXHJcbiAgICAgICAgICAgICAgICByOiBDb25uZWN0aW9uUG9pbnQuUkFESVVTXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogdGhpcy5jb2xvcixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTonIzAwMDAwMCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgeiA6IG9wdGlvbnMueiArIDIgIC8v6IqC54K5WuS4ujEg57q/5q615Li6MDtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnNoYXBlLnR5cGUgPSAgdGhpcy50eXBlO1xyXG5cclxuICAgICAgICB0aGlzLnNoYXBlLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcclxuICAgICAgICAvL3JldHVybiB0aGlzLmNpcmNsZTtcclxuICAgIH1cclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQuTk9STUFMX0NPTE9SID0gXCIjRkZGRjMzXCI7IC8veWVsbG93LlxyXG5cclxuICAgIENvbm5lY3Rpb25Qb2ludC5PVkVSX0NPTE9SID0gXCIjRkY5OTAwXCI7IC8vb3JhbmdlXHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LkNPTk5FQ1RFRF9DT0xPUiA9IFwiI2ZmMDAwMFwiOyAvL3JlZFxyXG5cclxuICAgIENvbm5lY3Rpb25Qb2ludC5SQURJVVMgPSA0O1xyXG5cclxuICAgIENvbm5lY3Rpb25Qb2ludC5UWVBFX0ZJR1VSRSA9ICdmaWd1cmUnO1xyXG5cclxuICAgIENvbm5lY3Rpb25Qb2ludC5UWVBFX0NPTk5FQ1RPUiA9ICdjb25uZWN0b3InO1xyXG5cclxuICAgIENvbm5lY3Rpb25Qb2ludC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yIDogQ29ubmVjdGlvblBvaW50LFxyXG5cclxuICAgICAgICBlcXVhbHMgOiBmdW5jdGlvbihhbm90aGVyQ29ubmVjdGlvblBvaW50KXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9pbnQuZXF1YWxzKGFub3RoZXJDb25uZWN0aW9uUG9pbnQucG9pbnQpXHJcbiAgICAgICAgICAgICYmIHRoaXMuY29ubmVjdG9yID09IGFub3RoZXJDb25uZWN0aW9uUG9pbnQuY29ubmVjdG9yXHJcbiAgICAgICAgICAgICYmIHRoaXMudHlwZSA9PSBhbm90aGVyQ29ubmVjdGlvblBvaW50LnR5cGVcclxuICAgICAgICAgICAgJiYgdGhpcy5jb2xvciA9PSBhbm90aGVyQ29ubmVjdGlvblBvaW50LmNvbG9yXHJcbiAgICAgICAgICAgICYmIHRoaXMucmFkaXVzID09IGFub3RoZXJDb25uZWN0aW9uUG9pbnQucmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvblBvaW50O1xyXG5cclxuXHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rpb25Qb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDnu4TvvIwg57uE5Lit5YWD57Sg55qE5Z2Q5qCH6YO95piv55u45a+55LqO6L+Z5Liq57uE55qEPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuR3JvdXBOb2RlXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBncm91cDEgPSBuZXcgbm9kZS5Hcm91cCh7XHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNTBdXHJcbiAqICAgICAgIH0pO1xyXG4gKlxyXG4gKiAgICAgICB2YXIgcmVjdDEgPSBuZXcgbm9kZS5SZWN0KHtcclxuICogICAgICAgICAgIHNoYXBlOnt3aWR0aDoxMjAsaGVpZ2h0OjMwfSxcclxuICogICAgICAgICAgIHN0eWxlOnt0ZXh0Olwi5qCH6aKYXCIsIGZpbGw6XCIjRkZCOTBGXCIsc3Ryb2tlOlwiI2JiYmJiYlwifSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOlswLDBdLFxyXG4gKiAgICAgICAgICAgc2VsZWN0YWJsZTpmYWxzZVxyXG4gKiAgICAgICB9KTtcclxuICpcclxuICogICAgICAgdmFyIHJlY3QyID0gbmV3IG5vZGUuUmVjdCh7XHJcbiAqICAgICAgICAgICBzaGFwZTp7d2lkdGg6MTIwLGhlaWdodDo2MH0sXHJcbiAqICAgICAgICAgICBzdHlsZTp7dGV4dDpcIuWGheWuuVwiLCBmaWxsOlwiI0ZGRkZGRlwiLHN0cm9rZTpcIiNiYmJiYmJcIn0sXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbMCwzMF0sXHJcbiAqICAgICAgICAgICBzZWxlY3RhYmxlOmZhbHNlXHJcbiAqICAgICAgIH0pO1xyXG4gKlxyXG4gKiAgICAgICBncm91cDEuYWRkKHJlY3QxKTtcclxuICogICAgICAgZ3JvdXAxLmFkZChyZWN0Mik7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChncm91cDEpO1xyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9tb2RlbC5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcblxyXG4gICAgZnVuY3Rpb24gR3JvdXBOb2RlKG9wdHMpIHtcclxuICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoe30pO1xyXG5cdFx0aWYgKCFvcHRzLmlkKSB7XHJcblx0XHRcdG9wdHMuaWQgPSB1dGlsLmdldFVVSUQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdHMuc3R5bGUgJiYgb3B0cy5zdHlsZS50ZXh0TGluZUhlaWdodCAhPT0gMCAmJiAhb3B0cy5zdHlsZS5yaWNoKSB7IC8vIzE3MFxyXG4gICAgICAgICAgICBvcHRzLnN0eWxlLnJpY2ggPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbW9kZWwuc2V0KFwiZWxlbWVudFR5cGVcIiwgXCJHcm91cE5vZGVcIik7XHJcbiAgICAgICAgaWYgKG9wdHMuc3R5bGUgJiYgb3B0cy5zdHlsZS5ob3N0KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRzLnN0eWxlLmhvc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1vZGVsLnNldChcIm9wdGlvbnNcIiwgenJVdGlsLmNsb25lKG9wdHMpKTtcclxuICAgICAgICBpZiAoXCJkcmFnZ2FibGVcIiBpbiBvcHRzKSB7XHJcbiAgICAgICAgICAgIG9wdHMuaXNkcmFnZ2FibGUgPSBvcHRzLmRyYWdnYWJsZTtcclxuICAgICAgICAgICAgZGVsZXRlIG9wdHMuZHJhZ2dhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9wdHMueikge1xyXG4gICAgICAgICAgICBvcHRzLnogPSAxOyAvL+iKgueCuem7mOiupOS4ujHvvIznur/mrrUwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQob3B0cy5ob3ZlckFuaW1hdGlvbikpIHtcclxuICAgICAgICAgICAgb3B0cy5ob3ZlckFuaW1hdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQob3B0cy5zZWxlY3RhYmxlKSkge1xyXG4gICAgICAgICAgICBvcHRzLnNlbGVjdGFibGUgPSB0cnVlOyAgLy/pu5jorqTlj6/ku6XpgInkuK1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIGdyYXBoaWMuR3JvdXAuY2FsbCh0aGlzLCBvcHRzKTtcclxuXHJcbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDUsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDUsXHJcbiAgICAgICAgICAgICAgICByOiA1XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAncmdiYSgwLDAsMCwwKScsLy8nI2Y5ZjlmOScsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICdyZ2JhKDAsMCwwLDApJy8vJyNiYmJiYmInXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBbMCwgMF1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHpyVXRpbC5tZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0cywgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5vcHRpb25zKTtcclxuICAgIH1cclxuICAgIEdyb3VwTm9kZS5SRUNUX05BTUUgPSBcIkdST1VQX1JFQ1RfTkFNRVwiO1xyXG4gICAgR3JvdXBOb2RlLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogR3JvdXBOb2RlLFxyXG4gICAgICAgIHR5cGU6IFwiR3JvdXBOb2RlXCIsXHJcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAobW9kZWwpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiBtb2RlbC5zaGFwZSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiBtb2RlbC5zdHlsZSxcclxuICAgICAgICAgICAgICAgIC8vc2lsZW50OnRydWUsIC8v5Yqg5LiK5ZCOIOaLluWKqCDnu4TkuK3msqHmnInlrZDlhYPntKDnmoTlnLDmlrkg5peg5rOV5omL5Yqo5LqGXHJcbiAgICAgICAgICAgICAgICB6OiAzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZWN0Lm5hbWUgPSBHcm91cE5vZGUuUkVDVF9OQU1FO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChyZWN0KTtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG1vZGVsLnBvc2l0aW9uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVjdENvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gdXRpbC5nZXRSZWN0KHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVjdC5ib3VuZGluZ1JlY3QuY29udGFpbih4LCB5KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2FwaSAmJiB0aGlzLl9hcGkuX2FkZEdyb3VwTm9kZSh0aGlzLGNoaWxkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOmBjeWOhue7hOS4reavj+S4gOS4quWtkOiKgueCuVxyXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYiDlm57osIPlh73mlbBjYlxyXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gY29udGV4dCAgIOS4iuS4i+aWh2NvbnRleHRcclxuICAgICAgICAgKi9cclxuICAgICAgICBlYWNoOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5hbWUgIT0gR3JvdXBOb2RlLlJFQ1RfTkFNRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldFJlY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0genJVdGlsLmNsb25lKHJlY3QpO1xyXG4gICAgICAgICAgICAvLyDlj5bmlbRcclxuICAgICAgICAgICAgYm91bmRpbmdSZWN0LnggPSBwYXJzZUludChib3VuZGluZ1JlY3QueCwgMTApO1xyXG4gICAgICAgICAgICBib3VuZGluZ1JlY3QueSA9IHBhcnNlSW50KGJvdW5kaW5nUmVjdC55LCAxMCk7XHJcbiAgICAgICAgICAgIGJvdW5kaW5nUmVjdC53aWR0aCA9IHBhcnNlSW50KGJvdW5kaW5nUmVjdC53aWR0aCwgMTApO1xyXG4gICAgICAgICAgICBib3VuZGluZ1JlY3QuaGVpZ2h0ID0gcGFyc2VJbnQoYm91bmRpbmdSZWN0LmhlaWdodCwgMTApO1xyXG4gICAgICAgICAgICAvL+WIm+W7uuacgOWwj+WMheWbtOebkuiZmue6v1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIHBvaW50c1swXSA9IFstYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgLWJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICAgICAgcG9pbnRzWzFdID0gW2JvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgICAgIHBvaW50c1syXSA9IFtib3VuZGluZ1JlY3Qud2lkdGggLyAyLCBib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgICAgIHBvaW50c1szXSA9IFstYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG4gICAgICAgICAgICBwb2ludHNbNF0gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcblxyXG4gICAgICAgICAgICB2YXIgYm91bmRSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCh0aGlzLnBvc2l0aW9uWzBdLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSxcclxuICAgICAgICAgICAgICAgIGJvdW5kaW5nUmVjdC53aWR0aCwgYm91bmRpbmdSZWN0LmhlaWdodCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiB0aGlzLnBvc2l0aW9uWzBdICsgYm91bmRpbmdSZWN0LndpZHRoIC8gMixcclxuICAgICAgICAgICAgICAgIHk6IHRoaXMucG9zaXRpb25bMV0gKyBib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMixcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBib3VuZGluZ1JlY3Qud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICAgICAgICAgIGJvdW5kaW5nUmVjdDogYm91bmRSZWN0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uKHBYLHBZKSB7XHJcbiAgICAgICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHIoJ3Bvc2l0aW9uJyxbcFgtYm91bmRpbmdSZWN0LndpZHRoLzIscFktYm91bmRpbmdSZWN0LmhlaWdodC8yXSk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldFByb3BlcnRpZXM6IGZ1bmN0aW9uIChvcHQpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNoaWxkT2ZOYW1lKEdyb3VwTm9kZS5SRUNUX05BTUUpO1xyXG4gICAgICAgICAgICByZWN0LnNldFNoYXBlKG9wdC5zaGFwZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cigncG9zaXRpb24nLCBvcHQucG9zaXRpb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdXBkYXRlU2hhcGU6IGZ1bmN0aW9uIChyYXRpbywgaWZQYXJzZSkge1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVSYXRpbyA9IE51bWJlcihyYXRpbyk7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMub3B0aW9ucy5zaGFwZTtcclxuICAgICAgICAgICAgdmFyIG5ld1cgPSBOdW1iZXIoc2hhcGUud2lkdGggKiBzY2FsZVJhdGlvKTtcclxuICAgICAgICAgICAgdmFyIG5ld0ggPSBOdW1iZXIobmV3VyAqIHNoYXBlLmhlaWdodCAvIHNoYXBlLndpZHRoKTtcclxuICAgICAgICAgICAgaWYgKGlmUGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIG5ld1cgPSBwYXJzZUludChuZXdXLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBuZXdIID0gcGFyc2VJbnQobmV3SCwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOaMieavlOS+i+e8qeaUvlxyXG4gICAgICAgICAgICB0aGlzLnNldFByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbmV3VyxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG5ld0hcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIOabtOaWsOe7hOWGheiKgueCuVxyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB2LnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKHYubmFtZSAhPT0gR3JvdXBOb2RlLlJFQ1RfTkFNRSAmJiAhKHYgaW5zdGFuY2VvZiBDb25uZWN0b3IpICYmIHYudHlwZSAhPT0gJ1pQYXRoJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOavj+S4quiKgueCueeahHBvc2l0aW9u5pu05pawXHJcbiAgICAgICAgICAgICAgICAgICAgdi51cGRhdGVTaGFwZShyYXRpbywgaWZQYXJzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5hdHRyKCdwb3NpdGlvbicsIFtwb3NpdGlvblswXSAqIHNjYWxlUmF0aW8sIHBvc2l0aW9uWzFdICogc2NhbGVSYXRpb10pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHYucmVjdDtcclxuICAgICAgICAgICAgICAgICAgICByZWN0LmhlaWdodCA9IHJlY3QuaGVpZ2h0ICogc2NhbGVSYXRpbztcclxuICAgICAgICAgICAgICAgICAgICByZWN0LndpZHRoID0gcmVjdC53aWR0aCAqIHNjYWxlUmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgdi5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFtwb3NpdGlvblswXSAqIHNjYWxlUmF0aW8sIHBvc2l0aW9uWzFdICogc2NhbGVSYXRpb10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Q6IHJlY3RcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhHcm91cE5vZGUsIGdyYXBoaWMuR3JvdXApO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHcm91cE5vZGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL0dyb3VwTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDpgInkuK3oioLngrnlkI7vvIzlh7rnjrDnmoTmk43kvZzmoYblj4rmjInpkq5cclxuICovXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJwbW4gPSByZXF1aXJlKFwiLi4vQnBtbi5qc1wiKTtcclxuICAgIHZhciBCcG1uVXRpbCA9IHJlcXVpcmUoXCIuLi9CcG1uVXRpbC5qc1wiKTtcclxuICAgIHZhciBPcGVyYXRpb25Ob2RlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL09wZXJhdGlvbk5vZGUuanNcIik7XHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1wiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBCcG1uT3BlcmF0aW9uTm9kZShub2RlLCB6ciwgZm9yYmlkRWRpdCkge1xyXG4gICAgICAgIE9wZXJhdGlvbk5vZGUuY2FsbCh0aGlzLCBub2RlLCB6ciwgZm9yYmlkRWRpdCk7XHJcbiAgICB9XHJcblxyXG4gICAgQnBtbk9wZXJhdGlvbk5vZGUucHJvdG90eXBlLnJlZnJlc2hQb3NpdGlvbk90aGVyID0gZnVuY3Rpb24obm9kZSxub2RlUmVjdCkge1xyXG5cclxuICAgICAgICAvLyDorqHnrpfmlbTkuKrnmoTkvY3nva5cclxuICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKEJwbW4uaXNTdWJQcm9jZXNzKG5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyKFwicG9zaXRpb25cIiwgW25vZGVSZWN0LnggKyBCcG1uVXRpbC5wYXJlbnRYKG5vZGUucGFyZW50KSwgbm9kZVJlY3QueSArIEJwbW5VdGlsLnBhcmVudFkobm9kZS5wYXJlbnQpXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cihcInBvc2l0aW9uXCIsIFtub2RlUmVjdC54LCBub2RlUmVjdC55XSlcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBCcG1uT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVmcmVzaFBvc3Rpb24gPSBmdW5jdGlvbihub2RlLCBub2RlUmVjdCkge1xyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgbm9kZVJlY3QueCAtPSBCcG1uVXRpbC5wYXJlbnRYKG5vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgbm9kZVJlY3QueSAtPSBCcG1uVXRpbC5wYXJlbnRZKG5vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgbm9kZVJlY3QuYm91bmRpbmdSZWN0LnggPSBub2RlUmVjdC5ib3VuZGluZ1JlY3QueCAtIEJwbW5VdGlsLnBhcmVudFgobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICBub2RlUmVjdC5ib3VuZGluZ1JlY3QueSA9IG5vZGVSZWN0LmJvdW5kaW5nUmVjdC55IC0gQnBtblV0aWwucGFyZW50WShub2RlLnBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB2YXIgcmJQb2ludCA9IHpyVXRpbC5jbG9uZShub2RlUmVjdC5wb2ludHNbMl0pOyAvL+WPluWPs+S4i+inkuWdkOagh1xyXG4gICAgICAgIHZhciByb3RhdGlvbiA9IG5vZGVSZWN0LnJvdGF0aW9uIHx8IG5vZGUucm90YXRpb247XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gcm90YXRpb24gLyAoTWF0aC5QSS8xODApO1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhyb3RhdGlvbikgPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3JDb250cm9scyA9IFV0aWwuZ2V0Q29ubmVjdG9yQ29udHJvbHMobm9kZVJlY3QsIG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgYnJDb250cm9sID0gY29ubmVjdG9yQ29udHJvbHMuYnI7XHJcbiAgICAgICAgICAgIHJiUG9pbnQgPSBbYnJDb250cm9sLnggLSBub2RlUmVjdC54LCAgYnJDb250cm9sLnkgLSBub2RlUmVjdC55XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8xLuWumuS9jeiZmuahhlxyXG4gICAgICAgIGlmICh0aGlzLnZpcnR1YWxSZWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbFJlY3Quc2V0U2hhcGUoeyBwb2ludHM6IG5vZGVSZWN0LnBvaW50cyB9KTtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsUmVjdC5hdHRyKCdyb3RhdGlvbicsIHJvdGF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8yLuWumuS9jeavj+S4quWwj+Wbvuagh1xyXG4gICAgICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uKG5vZGVJdGVtKSB7XHJcbiAgICAgICAgICAgIGlmICghbm9kZUl0ZW0uaXNTZWxmQ29tcHV0ZVBvcykge1xyXG4gICAgICAgICAgICAgICAgLy8gOHB45piv56ys5LiA5Liq5pON5L2c5oyJ6ZKu5Zu+5qCH55qE6Led56a7IOmdoOWkqui/keS4jeWlveeciyAgICAyMHB45piv5q+P5Liq5Zu+5qCH55qE6Ze06ZqUICAxMHB45piv5Zu+5qCH5ZCR5YGP55qE6Led56a7XHJcbiAgICAgICAgICAgICAgICBub2RlSXRlbS5hdHRyKFwicG9zaXRpb25cIiwgW2FuZ2xlID49IDAgPyByYlBvaW50WzBdICsgOCArIChpKysgKiAyMCkgOiByYlBvaW50WzBdIC0gMjAgLSAoaSsrICogMjApLCByYlBvaW50WzFdIC0gMTBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbk90aGVyKG5vZGUsbm9kZVJlY3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICBCcG1uT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHRU5EID0gXCJPcGVyYXRpb25Ob2RlOmRyYWdlbmRBcnJvd1wiO1xyXG4gICAgQnBtbk9wZXJhdGlvbk5vZGUuQVJST1dfRFJBRyA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnQXJyb3dcIjtcclxuICAgIEJwbW5PcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUdTVEFSVCA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnc3RhcnRBcnJvd1wiO1xyXG4gICAgQnBtbk9wZXJhdGlvbk5vZGUuREVMRVRFX0NMSUNLID0gXCJPcGVyYXRpb25Ob2RlOmRlbGV0ZUNsaWNrXCI7XHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKEJwbW5PcGVyYXRpb25Ob2RlLCBPcGVyYXRpb25Ob2RlKTtcclxuXHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCcG1uT3BlcmF0aW9uTm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL0JwbW5PcGVyYXRpb25Ob2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOmAieS4reiKgueCueWQju+8jOWHuueOsOeahOaTjeS9nOahhuWPiuaMiemSrlxyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuICAgIHZhciBOb2RlID0gcmVxdWlyZShcIi4uL05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xyXG4gICAgdmFyIGljb24gPSByZXF1aXJlKCcuL0ljb25PcGVyYXRpb24nKTtcclxuICAgIHZhciBzeW1ib2xVdGlsID0gcmVxdWlyZSgnLi4vc2hhcGVzL1N5bWJvbCcpO1xyXG4gICAgZnVuY3Rpb24gT3BlcmF0aW9uTm9kZShub2RlLCB6ciwgYXBpLGZvcmJpZEVkaXQpIHtcclxuICAgICAgICBOb2RlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLnpyID0genI7XHJcbiAgICAgICAgdGhpcy5mb3JiaWRFZGl0ID0gZm9yYmlkRWRpdDtcclxuICAgICAgICB0aGlzLl9hcGkgPSBhcGk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvL+S6i+S7tlxyXG4gICAgT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHRU5EID0gXCJPcGVyYXRpb25Ob2RlOmRyYWdlbmRBcnJvd1wiO1xyXG4gICAgT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHID0gXCJPcGVyYXRpb25Ob2RlOmRyYWdBcnJvd1wiO1xyXG4gICAgT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHU1RBUlQgPSBcIk9wZXJhdGlvbk5vZGU6ZHJhZ3N0YXJ0QXJyb3dcIjtcclxuICAgIE9wZXJhdGlvbk5vZGUuREVMRVRFX0NMSUNLID0gXCJPcGVyYXRpb25Ob2RlOmRlbGV0ZUNsaWNrXCI7XHJcbiAgICBPcGVyYXRpb25Ob2RlLkRFTCA9IFwiREVMXCI7XHJcbiAgICBPcGVyYXRpb25Ob2RlLkNPTU1FTlRfQ0xJQ0sgPSBcIk9wZXJhdGlvbk5vZGU6Y29tbWVudENsaWNrXCI7XHJcbiAgICBPcGVyYXRpb25Ob2RlLkNPTU1FTlQgPSBcIkNPTU1FTlRcIjtcclxuICAgICAgICAvL+WGhee9ruaTjeS9nOWbvuagh+eahOWbvuWDj1xyXG4gICAgT3BlcmF0aW9uTm9kZS5vcGljb25zID0ge1xyXG4gICAgICAgIFNUUkFJR0hUOiBpY29uLlNUUkFJR0hUX1NWRyxcclxuICAgICAgICBKQUdHRUQ6IGljb24uSkFHR0VEX1NWRyxcclxuICAgICAgICBDVVJWRTogaWNvbi5DVVJWRV9TVkcsXHJcbiAgICAgICAgREVMOiBpY29uLkRFTF9TVkcsXHJcbiAgICAgICAgQ09NTUVOVDogaWNvbi5DT01NRU5UX1NWR1xyXG4gICAgfTtcclxuXHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckJhc2UoKTtcclxuICAgICAgICBpZiAoIXRoaXMuZm9yYmlkRWRpdCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck90aGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5yZW5kZXJCYXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVPcGVyYXRpb24oKTtcclxuICAgIH07XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUuY3JlYXRlT3BlcmF0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG1lID0gdGhpcztcclxuICAgICAgICB2YXIgaWZTaG93Tm9kZU9wZXJhdGlvbkljb25zID0gdGhpcy5ub2RlLm9wZXJhdGlvbkljb25zO1xyXG4gICAgICAgIGlmICh0aGlzLm5vZGUucGFyZW50ICYmIHRoaXMubm9kZS5wYXJlbnQudHlwZSA9PT0gJ2RyYWdTZWxlY3QnKSB7XHJcbiAgICAgICAgICAgIGlmU2hvd05vZGVPcGVyYXRpb25JY29ucyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMubm9kZS5zZWxlY3RTdHlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxSZWN0ID0gbmV3IGdyYXBoaWMuUG9seWxpbmUoeyBzdHlsZTogeyBsaW5lRGFzaDogWzJdIH0gfSk7XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbFJlY3QuaXNTZWxmQ29tcHV0ZVBvcyA9IHRydWU7ICAvLyDoh6rlt7HorqHnrpfkvY3nva5cclxuICAgICAgICAgICAgdGhpcy5hZGQodGhpcy52aXJ0dWFsUmVjdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgIGlmICh0aGlzLm5vZGUudHlwZSA9PT0gJ1pQYXRoJykgeyAgLy9hZGRIb3ZlcumcgOimgeS7juWug+iHqui6q+eahOaehOmAoOWHveaVsOS4reWIm+W7uuOAgjEuUGFpbnRlcuS4rWFkZEhvdmVy5rqQ56CB5piv5qC55o2uc2hhcGXkuI5zdHlsZeWIm+W7uiAyLnBhdGjkuK3nmoTmnoTpgKDlh73mlbDmmK/ov5Tlm57lj6bkuIDkuKrlhYPntKBcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5fekNsb25lU3R5bGUgPSB0aGlzLm5vZGUuc3R5bGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICB0aGlzLm5vZGUuc2V0U3R5bGUodGhpcy5ub2RlLnNlbGVjdFN0eWxlKTtcclxuICAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLm5vZGUuc2V0T3JDYW5jZWxTZWxlY3RTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLnNldE9yQ2FuY2VsU2VsZWN0U3R5bGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBpLmdldFpyKCkuYWRkSG92ZXIodGhpcy5ub2RlLCB0aGlzLm5vZGUuc2VsZWN0U3R5bGUpO1xyXG4gICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpZlNob3dOb2RlT3BlcmF0aW9uSWNvbnMpIHtcclxuICAgICAgICAgICAgenJVdGlsLmVhY2godGhpcy5ub2RlLm9wZXJhdGlvbkljb25zLCBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAvL+ajgOafpeaYr+WQpuaYr+WGhee9ruWbvuagh1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wSWNvbkluc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBvcGVyYXRpb25JY29uID0gT3BlcmF0aW9uTm9kZS5vcGljb25zW2l0ZW0ubmFtZS50b1VwcGVyQ2FzZSgpICsgXCJcIl1cclxuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb25JY29uKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvcmJpZEVkaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5oaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5uYW1lID09IE9wZXJhdGlvbk5vZGUuREVMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5Z6D5Zy+5qG2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlID0gZ3JhcGhpYy5tYWtlUGF0aChvcGVyYXRpb25JY29uLCB7IHN0eWxlOiB7IGZpbGw6ICcjYWFhYWFjJyB9LHo6bWUubm9kZS56KzEscmVjdEhvdmVyOiB0cnVlIH0sIHsgeDogMCwgeTogMCwgd2lkdGg6IDEwLCBoZWlnaHQ6IDE1IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5jYWxsYmFjayl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUubm9kZSA9IG1lLm5vZGU7ICAvLyDlsIbmiYDpmYTnmoToioLngrnkuZ/kvKDpgJLlh7rljrtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNhbGxiYWNrKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gT3BlcmF0aW9uTm9kZS5ERUxFVEVfQ0xJQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLm5hbWUgPT0gT3BlcmF0aW9uTm9kZS5DT01NRU5UKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMTYsIGhlaWdodDogMTYgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2UgPSBncmFwaGljLm1ha2VQYXRoKG9wZXJhdGlvbkljb24sIHsgc3R5bGU6IHsgZmlsbDogJyNhYWFhYWMnIH0sIHo6bWUubm9kZS56KzIsIHJlY3RIb3ZlcjogdHJ1ZSB9LCByZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IE9wZXJhdGlvbk5vZGUuQ09NTUVOVF9DTElDSztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0T3RoZXIgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAxNSwgaGVpZ2h0OiAxNSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZSA9IGdyYXBoaWMubWFrZVBhdGgob3BlcmF0aW9uSWNvbiwgeyBzdHlsZTogeyBmaWxsOiAnI2FhYWFhYycgfSxkcmFnZ2FibGU6dHJ1ZSx6Om1lLm5vZGUueisyLGxpbmVUeXBlOiBDb25uZWN0b3JbXCJUWVBFX1wiICsgaXRlbS5uYW1lLnRvVXBwZXJDYXNlKCldLHJlY3RIb3ZlcjogdHJ1ZSB9LCByZWN0T3RoZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2RyYWdzdGFydCcsICdkcmFnJywgJ2RyYWdlbmQnXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlLm9uKGV2ZU5hbWUsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZGF0YSA9IGl0ZW0ub3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJPcGVyYXRpb25Ob2RlOlwiICsgZXZlTmFtZSArIFwiQXJyb3dcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woaXRlbS5pY29uUGF0aCwgMCwgMCwgaXRlbS53aWR0aCB8fCAxNSwgaXRlbS5oZWlnaHQgfHwgMTUsIG1lLm5vZGUueisxLCBpdGVtLmNvbG9yfHwnIzAwMCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGEgPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLm5vZGUgPSBtZS5ub2RlOyAgLy8g5bCG5omA6ZmE55qE6IqC54K55Lmf5Lyg6YCS5Ye65Y67XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNhbGxiYWNrKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IHtldmVudDplLCB0eXBlOlwiT3BlcmF0aW9uTm9kZTpcIiArIGl0ZW0ubmFtZSArIFwiQ2xpY2tcIn07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLl9hcGkudHJpZ2dlcihwYXJhbS50eXBlLCBwYXJhbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZS5uYW1lID0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgbWUuYWRkKG9wSWNvbkluc3RhbmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5yZWZyZXNoUG9zdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIG5vZGVSZWN0KSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciByYlBvaW50ID0genJVdGlsLmNsb25lKG5vZGVSZWN0LnBvaW50c1syXSk7IC8v5Y+W5Y+z5LiL6KeS5Z2Q5qCHXHJcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gbm9kZS5yb3RhdGlvbjtcclxuICAgICAgICB2YXIgYW5nbGUgPSByb3RhdGlvbiAvIChNYXRoLlBJLzE4MCk7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHJvdGF0aW9uKSA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RvckNvbnRyb2xzID0gVXRpbC5nZXRDb25uZWN0b3JDb250cm9scyhub2RlUmVjdCwgbm9kZSk7XHJcbiAgICAgICAgICAgIHZhciBickNvbnRyb2wgPSBjb25uZWN0b3JDb250cm9scy5icjtcclxuICAgICAgICAgICAgcmJQb2ludCA9IFtickNvbnRyb2wueCAtIG5vZGVSZWN0LngsICBickNvbnRyb2wueSAtIG5vZGVSZWN0LnldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLzEu5a6a5L2N6Jma5qGGXHJcbiAgICAgICAgaWYgKHRoaXMudmlydHVhbFJlY3QpIHtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsUmVjdC5zZXRTaGFwZSh7IHBvaW50czogbm9kZVJlY3QucG9pbnRzIH0pO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQuY2hpbGREcmFnZ2FibGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlydHVhbFJlY3QuYXR0cigneicsIG5vZGUucGFyZW50LnogKyAxKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbFJlY3QuYXR0cigncm90YXRpb24nLCByb3RhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vMi7lrprkvY3mr4/kuKrlsI/lm77moIdcclxuICAgICAgICB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbihub2RlSXRlbSkge1xyXG4gICAgICAgICAgICBpZiAoIW5vZGVJdGVtLmlzU2VsZkNvbXB1dGVQb3MpIHtcclxuICAgICAgICAgICAgICAgIC8vIDhweOaYr+esrOS4gOS4quaTjeS9nOaMiemSruWbvuagh+eahOi3neemuyDpnaDlpKrov5HkuI3lpb3nnIsgICAgMjBweOaYr+avj+S4quWbvuagh+eahOmXtOmalCAgMTBweOaYr+Wbvuagh+WQkeWBj+eahOi3neemu1xyXG4gICAgICAgICAgICAgICAgbm9kZUl0ZW0uYXR0cihcInBvc2l0aW9uXCIsIFthbmdsZSA+PSAwID8gcmJQb2ludFswXSArIDggKyAoaSsrICogMjApIDogcmJQb2ludFswXSAtIDIwIC0gKGkrKyAqIDIwKSwgcmJQb2ludFsxXSAtIDEwXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWZyZXNoUG9zaXRpb25PdGhlcihub2RlLG5vZGVSZWN0KTtcclxuICAgIH07XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVuZGVyT3RoZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAvL+eVmee7meaJqeWxleS9v+eUqFxyXG4gICAgfTtcclxuICAgIE9wZXJhdGlvbk5vZGUucHJvdG90eXBlLnJlZnJlc2hQb3NpdGlvbk90aGVyID0gZnVuY3Rpb24obm9kZSxub2RlUmVjdCkge1xyXG4gICAgICAgIC8v55WZ57uZ5omp5bGV5L2/55SoXHJcbiAgICAgICAgLy8zLuWumuS9jeaVtOS4qm9wZXJhdGlvbk5vZGVcclxuICAgICAgICBpZiAoKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LmlzQmcgJiYgbm9kZS5wYXJlbnQuaXNCZyA9PSB0cnVlKSB8fCAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJHcm91cE5vZGVcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5hdHRyKFwicG9zaXRpb25cIiwgW25vZGVSZWN0LngsIG5vZGVSZWN0LnldKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlU2hhcGVYID0gbm9kZS5zaGFwZT8gbm9kZS5zaGFwZS54OjA7XHJcbiAgICAgICAgICAgIHZhciBub2RlU2FocGVZID0gbm9kZS5zaGFwZT8gbm9kZS5zaGFwZS55OjA7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cihcInBvc2l0aW9uXCIsIFtub2RlUmVjdC54ICsgbm9kZS5wYXJlbnQucG9zaXRpb25bMF0rbm9kZVNoYXBlWCwgbm9kZVJlY3QueSArIG5vZGUucGFyZW50LnBvc2l0aW9uWzFdK25vZGVTYWhwZVldKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmKHRoaXMubm9kZS5zZWxlY3RTdHlsZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ub2RlLnR5cGUgPT09ICdaUGF0aCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5zZXRTdHlsZSh0aGlzLm5vZGUuX3pDbG9uZVN0eWxlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMubm9kZS5zZXRPckNhbmNlbFNlbGVjdFN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUuc2V0T3JDYW5jZWxTZWxlY3RTdHlsZShmYWxzZSk7XHJcbiAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBpLmdldFpyKCkucmVtb3ZlSG92ZXIodGhpcy5ub2RlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhPcGVyYXRpb25Ob2RlLCBOb2RlKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gT3BlcmF0aW9uTm9kZTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL09wZXJhdGlvbk5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5pON5L2c5Zu+5qCH57G7XHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG5cclxuICAgIHZhciBJY29uT3BlcmF0aW9uID0ge1xyXG4gICAgICAgIFNUUkFJR0hUX1NWRzogJ005MzcuMzUzODQ2IDcyNC42NzY5MjNDODgyLjIxNTM4NSA2NjkuNTM4NDYyIDc5NS41NjkyMzEgNjYxLjY2MTUzOCA3MzIuNTUzODQ2IDcwMS4wNDYxNTRMMzYyLjMzODQ2MiAzMzAuODMwNzY5QzQwMS43MjMwNzcgMjY3LjgxNTM4NSAzOTMuODQ2MTU0IDE4MS4xNjkyMzEgMzM4LjcwNzY5MiAxMjYuMDMwNzY5IDI2Ny44MTUzODUgNTUuMTM4NDYyIDE2NS40MTUzODUgNTUuMTM4NDYyIDk0LjUyMzA3NyAxMjYuMDMwNzY5IDIzLjYzMDc2OSAxOTYuOTIzMDc3IDIzLjYzMDc2OSAyOTkuMzIzMDc3IDk0LjUyMzA3NyAzNzAuMjE1Mzg1IDE0OS42NjE1MzggNDI1LjM1Mzg0NiAyMzYuMzA3NjkyIDQzMy4yMzA3NjkgMjk5LjMyMzA3NyAzOTMuODQ2MTU0TDY2OS41Mzg0NjIgNzY0LjA2MTUzOEM2MzAuMTUzODQ2IDgyNy4wNzY5MjMgNjM4LjAzMDc2OSA5MTMuNzIzMDc3IDY5My4xNjkyMzEgOTY4Ljg2MTUzOCA3NjQuMDYxNTM4IDEwMzkuNzUzODQ2IDg2Ni40NjE1MzggMTAzOS43NTM4NDYgOTM3LjM1Mzg0NiA5NjguODYxNTM4IDEwMDAuMzY5MjMxIDg5Ny45NjkyMzEgMTAwMC4zNjkyMzEgNzk1LjU2OTIzMSA5MzcuMzUzODQ2IDcyNC42NzY5MjNMOTM3LjM1Mzg0NiA3MjQuNjc2OTIzWk0yNzUuNjkyMzA4IDMwNy4yQzI0NC4xODQ2MTUgMzM4LjcwNzY5MiAxODkuMDQ2MTU0IDMzOC43MDc2OTIgMTU3LjUzODQ2MiAzMDcuMiAxMjYuMDMwNzY5IDI3NS42OTIzMDggMTI2LjAzMDc2OSAyMjAuNTUzODQ2IDE1Ny41Mzg0NjIgMTg5LjA0NjE1NCAxODkuMDQ2MTU0IDE1Ny41Mzg0NjIgMjQ0LjE4NDYxNSAxNTcuNTM4NDYyIDI3NS42OTIzMDggMTg5LjA0NjE1NCAzMDcuMiAyMjAuNTUzODQ2IDMwNy4yIDI2Ny44MTUzODUgMjc1LjY5MjMwOCAzMDcuMkwyNzUuNjkyMzA4IDMwNy4yWk04NzQuMzM4NDYyIDkxMy43MjMwNzdDODQyLjgzMDc2OSA5NDUuMjMwNzY5IDc4Ny42OTIzMDggOTQ1LjIzMDc2OSA3NTYuMTg0NjE1IDkxMy43MjMwNzcgNzI0LjY3NjkyMyA4ODIuMjE1Mzg1IDcyNC42NzY5MjMgODI3LjA3NjkyMyA3NTYuMTg0NjE1IDc5NS41NjkyMzEgNzg3LjY5MjMwOCA3NjQuMDYxNTM4IDg0Mi44MzA3NjkgNzY0LjA2MTUzOCA4NzQuMzM4NDYyIDc5NS41NjkyMzEgOTA1Ljg0NjE1NCA4MjcuMDc2OTIzIDkwNS44NDYxNTQgODc0LjMzODQ2MiA4NzQuMzM4NDYyIDkxMy43MjMwNzdMODc0LjMzODQ2MiA5MTMuNzIzMDc3WicsXHJcbiAgICAgICAgSkFHR0VEX1NWRzogJ00yMDQuOCA4MTkuMmwtNTEuMi0xMDIuNCAyMDQuOC0zMDcuMiA1MS4yIDEwMi40LTIwNC44IDMwNy4yek00MDkuNiA1MTJsNTEuMi0xMDIuNCAxNTMuNiAyMDQuOC01MS4yIDEwMi40LTE1My42LTIwNC44ek04MTkuMiAyMDQuOGw1MS4yIDEwMi40LTIwNC44IDQwOS42LTUxLjItMTAyLjQgMjA0LjgtNDA5LjZ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTTE1My42IDcxNi44Yy04Ny4wNCAwLTE1My42IDY2LjU2LTE1My42IDE1My42czY2LjU2IDE1My42IDE1My42IDE1My42IDE1My42LTY2LjU2IDE1My42LTE1My42LTY2LjU2LTE1My42LTE1My42LTE1My42eiBtNTEuMiAyMDQuOEgxMDIuNHYtMTAyLjRoMTAyLjR2MTAyLjR6TTQwOS42IDIwNC44QzMyMi41NiAyMDQuOCAyNTYgMjcxLjM2IDI1NiAzNTguNHM2Ni41NiAxNTMuNiAxNTMuNiAxNTMuNiAxNTMuNi02Ni41NiAxNTMuNi0xNTMuNi02Ni41Ni0xNTMuNi0xNTMuNi0xNTMuNnogbTUxLjIgMjA0LjhIMzU4LjRWMzA3LjJoMTAyLjR2MTAyLjR6TTYxNC40IDYxNC40Yy04Ny4wNCAwLTE1My42IDY2LjU2LTE1My42IDE1My42czY2LjU2IDE1My42IDE1My42IDE1My42IDE1My42LTY2LjU2IDE1My42LTE1My42LTY2LjU2LTE1My42LTE1My42LTE1My42eiBtNTEuMiAyMDQuOGgtMTAyLjR2LTEwMi40aDEwMi40djEwMi40ek04NzAuNCAwYy04Ny4wNCAwLTE1My42IDY2LjU2LTE1My42IDE1My42czY2LjU2IDE1My42IDE1My42IDE1My42IDE1My42LTY2LjU2IDE1My42LTE1My42LTY2LjU2LTE1My42LTE1My42LTE1My42eiBtNTEuMiAyMDQuOGgtMTAyLjRWMTAyLjRoMTAyLjR2MTAyLjR6JyxcclxuICAgICAgICBDVVJWRV9TVkc6ICdNMTAxNC4yODUwMzkgODI0LjAyNDIzNGwtMTQ1LjE2ODQyOC0xNDQuMzcyMDVjLTEyLjk2OTU5My0xMi44NTU4MjUtMzcuNTQzNTU5LTE0LjUwNTQ2Ni00NC41OTcxOTcgMi4zMzIyNTItMS44NzcxNzggNC41NTA3MzQtMi4yNzUzNjcgMTcuMTc5MDIyLTIuMjc1MzY4IDE3LjE3OTAyMnY5Ny41NTYzNjlIMzMwLjkzNTM4M2ExMTguMzE5MDk1IDExOC4zMTkwOTUgMCAwIDEtMTE4LjU0NjYzMi0xMTcuOTIwOTA1QTExOC4zMTkwOTUgMTE4LjMxOTA5NSAwIDAgMSAzMzAuOTkyMjY3IDU2MC44NzgwMTZoNDQ1LjUxNjg5OWMxMjEuNTYxNDkzIDAgMjIwLjQyNjE5OC05OC4zNTI3NDcgMjIwLjQyNjE5OC0yMTkuMjMxNjNzLTk4Ljg2NDcwNS0yMTkuMTc0NzQ2LTIyMC40MjYxOTgtMjE5LjE3NDc0NkgzNDAuNDkxOTI1QTE3NC4yMzYyNDQgMTc0LjIzNjI0NCAwIDAgMCAxNzQuMTA1Njk4IDAgMTczLjc4MTE3IDE3My43ODExNyAwIDAgMCAwLjA0MDEwNyAxNzMuMDk4NTZhMTczLjc4MTE3IDE3My43ODExNyAwIDAgMCAxNzQuMDY1NTkxIDE3My4wOTg1NiAxNzQuMjM2MjQ0IDE3NC4yMzYyNDQgMCAwIDAgMTY2LjM4NjIyNy0xMjIuNDcxNjM5aDQzNi4wMTcyNDFjNjUuNDE2ODA3IDAgMTE4LjYwMzUxNiA1Mi45MDIyODggMTE4LjYwMzUxNSAxMTcuOTIwOTA1QTExOC4zMTkwOTUgMTE4LjMxOTA5NSAwIDAgMSA3NzYuNTA5MTY2IDQ1OS42MjQxNzZIMzMwLjk5MjI2N2MtMTIxLjUwNDYwOSAwLTIyMC4zNjkzMTQgOTguMzUyNzQ3LTIyMC4zNjkzMTQgMjE5LjIzMTYzczk4Ljg2NDcwNSAyMTkuMTc0NzQ2IDIyMC4zNjkzMTQgMjE5LjE3NDc0Nmg0OTEuMTk0ODk1djkyLjU1MDU2MXMwIDE0LjIyMTA0NSAyLjMzMjI1MiAxOS43OTU2OTVjNy4wNTM2MzggMTYuODk0NjAyIDMxLjYyNzYwNCAxNy41NzcyMTIgNDQuNTk3MTk3IDQuNjY0NTAybDE0NS4xMTE1NDMtMTQ0LjMxNTE2NWEzMi44NzkwNTYgMzIuODc5MDU2IDAgMCAwIDAtNDYuNjQ1MDI3ek0xNzQuMTA1Njk4IDI0NC45NDMyOGMtMzkuODE4OTI2IDAtNzIuMjQyOTA5LTMyLjI1MzMzLTcyLjI0MjkwOS03MS44NDQ3MnMzMi40MjM5ODMtNzEuNzg3ODM1IDcyLjI0MjkwOS03MS43ODc4MzVjMzkuODE4OTI2IDAgNzIuMTg2MDI1IDMyLjE5NjQ0NiA3Mi4xODYwMjUgNzEuNzg3ODM1IDAgMzkuNTkxMzg5LTMyLjQyMzk4MyA3MS43ODc4MzUtNzIuMjQyOTA5IDcxLjc4NzgzNnonLFxyXG4gICAgICAgIERFTF9TVkc6ICdNOTgwLjk5MiAyNTZoLTg0Ljk5MnY2ODMuMDA4YzAgNDcuMTA0LTM3Ljg4OCA4NC45OTItODQuOTkyIDg0Ljk5MkgyMTIuOTkyYy00Ny4xMDQgMC04NC45OTItMzcuODg4LTg0Ljk5Mi04NC45OTJWMjU2SDQzLjAwOEMxOS40NTYgMjU2IDAgMjM2LjU0NCAwIDIxMi45OTJjMC0yMy41NTIgMTkuNDU2LTQzLjAwOCA0My4wMDgtNDMuMDA4SDI1NlY4NC45OTJDMjU2IDM3Ljg4OCAyOTMuODg4IDAgMzQwLjk5MiAwaDM0MC45OTJDNzMwLjExMiAwIDc2OCAzNy44ODggNzY4IDg0Ljk5MnY4NC45OTJoMjE0LjAxNmMyMy41NTIgMCA0My4wMDggMTkuNDU2IDQzLjAwOCA0My4wMDgtMS4wMjQgMjMuNTUyLTIwLjQ4IDQzLjAwOC00NC4wMzIgNDMuMDA4ek02ODMuMDA4IDg0Ljk5MkgzNDAuOTkydjg0Ljk5MmgzNDAuOTkyVjg0Ljk5MnpNMjEyLjk5MiA5MzkuMDA4aDU5Ni45OTJWMjU2SDIxMi45OTJ2NjgzLjAwOHogbTE3MS4wMDgtNDcwLjAxNnYyNTZjMCAyMy41NTItMTkuNDU2IDQzLjAwOC00My4wMDggNDMuMDA4LTIzLjU1MiAwLTQzLjAwOC0xOS40NTYtNDMuMDA4LTQzLjAwOHYtMjU2YzAtMjMuNTUyIDE5LjQ1Ni00My4wMDggNDMuMDA4LTQzLjAwOCAyMy41NTIgMS4wMjQgNDMuMDA4IDE5LjQ1NiA0My4wMDggNDMuMDA4ek01MTIgNDI3LjAwOGMyMy41NTIgMCA0My4wMDggMTkuNDU2IDQzLjAwOCA0My4wMDh2MjU2YzAgMjMuNTUyLTE5LjQ1NiA0My4wMDgtNDMuMDA4IDQzLjAwOC0yMy41NTIgMC00My4wMDgtMTkuNDU2LTQzLjAwOC00My4wMDh2LTI1NmMwLTI0LjU3NiAxOS40NTYtNDMuMDA4IDQzLjAwOC00My4wMDh6IG0xNzEuMDA4IDBjMjMuNTUyIDAgNDMuMDA4IDE5LjQ1NiA0My4wMDggNDMuMDA4djI1NmMwIDIzLjU1Mi0xOS40NTYgNDMuMDA4LTQzLjAwOCA0My4wMDgtMjMuNTUyIDAtNDMuMDA4LTE5LjQ1Ni00My4wMDgtNDMuMDA4di0yNTZjMC0yNC41NzYgMTkuNDU2LTQzLjAwOCA0My4wMDgtNDMuMDA4eicsXHJcbiAgICAgICAgQ09NTUVOVF9TVkc6ICdNMjA5LjkyIDE1Mi4wNjRsNTcyLjQxNiAxLjUzNmMxMi44IDAgMjMuMDQgMTAuMjQgMjMuMDQgMjMuMDR2MjM3LjU2OGMwIDEyLjggMTAuMjQgMjMuMDQgMjMuMDQgMjMuMDRzMjMuMDQtMTAuMjQgMjMuMDQtMjMuMDRWMTI1LjQ0YzAtMTIuOC0xMC4yNC0yMy4wNC0yMy4wNC0yMy4wNEgxNTguNzJjLTEyLjggMC0yMy4wNCAxMC4yNC0yMy4wNCAyMy4wNHY3NzMuMTJjMCAxMi44IDEwLjI0IDIzLjA0IDIzLjA0IDIzLjA0aDIzNi4wMzJjMTIuOCAwIDIzLjA0LTEwLjI0IDIzLjA0LTIzLjA0cy0xMC4yNC0yMi41MjgtMjIuNTI4LTIzLjA0bC0xODUuODU2LTEuNTM2Yy0xMi44IDAtMjIuNTI4LTEwLjI0LTIyLjUyOC0yMy4wNFYxNzQuNTkyYzAtMTIuMjg4IDEwLjI0LTIyLjUyOCAyMy4wNC0yMi41Mjh6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNMjY4LjggNTcwLjM2OGgxNTkuMjMyYzEzLjMxMiAwIDI0LjA2NCAxMC43NTIgMjQuNTc2IDI0LjA2NHYyLjU2YzAgMTMuMzEyLTEwLjc1MiAyNC41NzYtMjQuNTc2IDI0LjU3NkgyNjguOGMtMTMuMzEyIDAtMjQuMDY0LTEwLjc1Mi0yNC41NzYtMjQuMDY0di0yLjU2YzAuNTEyLTEzLjMxMiAxMS4yNjQtMjQuNTc2IDI0LjU3Ni0yNC41NzZ6IG0wLTMxMi4zMmg0NDEuMzQ0YzEzLjMxMiAwIDI0LjU3NiAxMC43NTIgMjQuNTc2IDI0LjU3NnYyLjU2YzAgMTMuMzEyLTEwLjc1MiAyNC41NzYtMjQuNTc2IDI0LjU3NkgyNjguOGMtMTMuMzEyIDAtMjQuNTc2LTEwLjc1Mi0yNC41NzYtMjQuNTc2di0yLjU2YzAuNTEyLTEzLjMxMiAxMS4yNjQtMjQuNTc2IDI0LjU3Ni0yNC41NzZ6IG0wLjUxMiAxNTUuNjQ4aDI2OS4zMTJjMTMuMzEyIDAgMjQuNTc2IDEwLjc1MiAyNC41NzYgMjQuMDY0djIuNTZjMCAxMy4zMTItMTAuNzUyIDI0LjU3Ni0yNC41NzYgMjQuNTc2SDI2OS4zMTJjLTEzLjMxMiAwLTI0LjU3Ni0xMC43NTItMjQuNTc2LTI0LjA2NHYtMi41NmMwLTEzLjgyNCAxMC43NTItMjQuNTc2IDI0LjU3Ni0yNC41NzZ6IG00NzEuMDQgMTMuMzEybC0yNDYuNzg0IDMzOS40NTZjLTEuNTM2IDIuNTYtMi41NiA1LjYzMi0yLjU2IDguNzA0bC0xLjUzNiAxMzIuMDk2YzAgOS43MjggOS43MjggMTYuODk2IDE4Ljk0NCAxNC4zMzZsMTIyLjg4LTM3Ljg4OGMzLjA3Mi0xLjAyNCA1LjYzMi0zLjA3MiA3LjY4LTUuNjMybDI0Ni43ODQtMzM4Ljk0NGM0LjYwOC02LjE0NCAzLjU4NC0xNS4zNi0yLjU2LTE5Ljk2OGwtMTIxLjM0NC05NC43MmMtNy4xNjgtNS42MzItMTYuODk2LTQuMDk2LTIxLjUwNCAyLjU2eiBtMjMuMDQgNjcuNTg0bDUxLjIgMzkuOTM2YzIuMDQ4IDEuNTM2IDIuNTYgNS4xMiAxLjAyNCA3LjE2OGwtMjYuMTEyIDM1Ljg0Yy0xLjUzNiAyLjU2LTUuMTIgMy4wNzItNy42OCAxLjAyNGwtNTEuNzEyLTM4LjkxMmMtMi4wNDgtMS41MzYtMi41Ni00LjYwOC0xLjAyNC03LjE2OGwyNi42MjQtMzcuMzc2YzIuMDQ4LTEuNTM2IDUuNjMyLTIuMDQ4IDcuNjgtMC41MTJ6IG0tMTY1Ljg4OCAzNDEuNTA0bC0zNS4zMjggMTAuNzUyYy05LjIxNiAzLjA3Mi0xOC45NDQtNC4wOTYtMTguOTQ0LTEzLjgyNGwwLjUxMi00MC45NmMwLTMuMDcyIDEuMDI0LTYuMTQ0IDIuNTYtOC43MDRsMTM3LjIxNi0xODcuOTA0YzEuNTM2LTIuNTYgNS4xMi0yLjU2IDcuMTY4LTEuMDI0bDUxLjIgMzguNGMyLjU2IDIuMDQ4IDMuMDcyIDUuMTIgMS4wMjQgNy42OGwtMTM3LjcyOCAxODkuOTUyYy0yLjA0OCAyLjU2LTQuNjA4IDQuNjA4LTcuNjggNS42MzJ6JyxcclxuICAgICAgICBDSEFOR0VfTElORV9UWVBFX1NWRzogJ00xMDA4IDMzNS4yIDEwMDggMzM1LjJsLTE2MCAxNDQgMCAwYy04LjggOC0yMCAxMi44LTMyIDEyLjgtMjYuNCAwLTQ4LTIxLjYtNDgtNDggMC0xNC40IDYuNC0yNi40IDE2LTM1LjJsMCAwIDY3LjItNjBMNTYwIDM0OC44YzAgMCAwIDAgMCAwTDQ2NCAzNDguOGwwIDBMMzUyIDM0OC44IDQ4IDM0OC44Yy0yNi40IDAtNDgtMjEuNi00OC00OCAwLTI2LjQgMjEuNi00OCA0OC00OGwxMjQuOCAwIDAgMEw0MTYgMjUyLjhsMCAwIDIwOCAwIDAgMCAyMjcuMiAwTDc4NCAxOTJsMCAwYy05LjYtOC44LTE2LTIxLjYtMTYtMzUuMiAwLTI2LjQgMjEuNi00OCA0OC00OCAxMiAwIDIzLjIgNC44IDMyIDEyLjhsMCAwIDE2MCAxNDQgMCAwYzkuNiA4LjggMTYgMjEuNiAxNiAzNS4yQzEwMjQgMzE0LjQgMTAxNy42IDMyNi40IDEwMDggMzM1LjJ6TTE2IDY4MC44IDE2IDY4MC44bDE2MC0xNDQgMCAwYzguOC04IDIwLTEyLjggMzItMTIuOCAyNi40IDAgNDggMjEuNiA0OCA0OCAwIDE0LjQtNi40IDI2LjQtMTYgMzUuMmwwIDAtNjcuMiA2MEw0MDAgNjY3LjJsMCAwIDIwOCAwIDAgMCAyNDMuMiAwIDAgMEw5NzYgNjY3LjJjMjYuNCAwIDQ4IDIxLjYgNDggNDggMCAyNi40LTIxLjYgNDgtNDggNDhMNjcyIDc2My4yIDU2MCA3NjMuMmMwIDAgMCAwIDAgMEw0NjQgNzYzLjJsMCAwTDE3Mi44IDc2My4yIDI0MCA4MjRsMCAwYzkuNiA4LjggMTYgMjEuNiAxNiAzNS4yIDAgMjYuNC0yMS42IDQ4LTQ4IDQ4LTEyIDAtMjMuMi00LjgtMzItMTIuOGwwIDBMMTYgNzUybDAgMGMtOS42LTguOC0xNi0yMS42LTE2LTM1LjJDMCA3MDEuNiA2LjQgNjg5LjYgMTYgNjgwLjh6J1xyXG4gICAgfVxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBJY29uT3BlcmF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9JY29uT3BlcmF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIGJwbW7ov57nur/nrqHnkIbnsbtcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvQ29ubmVjdGlvbk1hbmFnZXIuanNcIik7XHJcbiAgICB2YXIgQlBNTk1vZGVsID0gcmVxdWlyZShcIi4uL21vZGVsL0JQTU5Nb2RlbC5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgUG9pbnQgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcblxyXG4gICAgZnVuY3Rpb24gQnBtbkNvbm5lY3Rpb25NYW5hZ2VyKCkge1xyXG4gICAgICAgIENvbm5lY3Rpb25NYW5hZ2VyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsVHlwZSA9IFwiU2VxdWVuY2VGbG93XCI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uui/nue6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFydE5vZGUgW+W8gOWni+iKgueCuV1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZW5kTm9kZSAgIFvnu5PmnZ/oioLngrldXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHR5cGUgICAgICBb57G75Z6LXVxyXG4gICAgICogQHBhcmFtIHtbdHlwZV19IFthcGldIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgIFvov5Tlm57ov57nur9dXHJcbiAgICAgKi9cclxuICAgIEJwbW5Db25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdG9yQ3JlYXRlID0gZnVuY3Rpb24oc3RhcnROb2RlLCBlbmROb2RlLCBzdHlsZSwgYXBpLCBzdGFydFBvcywgZW5kUG9zKSB7XHJcbiAgICAgICAgdmFyIG1vZGVsID0gbmV3IEJQTU5Nb2RlbCh7fSk7XHJcbiAgICAgICAgbW9kZWwuc2V0KFwicmVzb3VyY2VJZFwiLCB1dGlsLmdldFVVSUQoKSk7XHJcbiAgICAgICAgbW9kZWwuc2V0KFwic3R5bGVcIiwgc3R5bGUuc3R5bGUpO1xyXG4gICAgICAgIG1vZGVsLnNldChcInN0ZW5jaWwudHlwZVwiLCB0aGlzLnN0ZW5jaWxUeXBlKTtcclxuICAgICAgICBzdGFydFBvcyAmJiBtb2RlbC5zZXQoXCJzdHlsZS5zUG9zXCIsIHN0YXJ0UG9zKTtcclxuICAgICAgICBlbmRQb3MgJiYgbW9kZWwuc2V0KFwic3R5bGUuZVBvc1wiLCBlbmRQb3MpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0b3JDcmVhdGVCeU9wdGlvbnMoc3RhcnROb2RlLCBlbmROb2RlLCB7IG1vZGVsOiBtb2RlbCwgaXNFZGl0OiB0cnVlLCBzdHlsZTogc3R5bGV9LCBhcGkpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNrm9wZXRpb25zLm1vZGVsIOWPjeW6j+WIl+WMlue6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFydE5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBlbmROb2RlICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBvcHRpb25zICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBhcGkgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBCcG1uQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3RvckNyZWF0ZUJ5T3B0aW9ucyA9IGZ1bmN0aW9uKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgb3B0aW9ucywgYXBpKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBtb2RlbCA9IG9wdGlvbnMubW9kZWw7XHJcbiAgICAgICAgbW9kZWwub3B0aW9uLnRleHQgPSB7XHJcbiAgICAgICAgICAgIHRleHQ6IG1vZGVsLm9wdGlvbi5wcm9wZXJ0aWVzLm5hbWVcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0aW9ucy50ZXh0ID0ge1xyXG4gICAgICAgICAgICB0ZXh0OiBtb2RlbC5vcHRpb24ucHJvcGVydGllcy5uYW1lXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbm5lY3Rvci5zdGFydE5vZGUgPSBzdGFydE5vZGU7XHJcbiAgICAgICAgY29ubmVjdG9yLmVuZE5vZGUgPSBlbmROb2RlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3RvcnMucHVzaChjb25uZWN0b3IpO1xyXG5cclxuICAgICAgICAvL+WIpOaWreS4gOS4i3NQb3MsZVBvc1xyXG4gICAgICAgIGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uLnN0YXJ0UG9zID0gbW9kZWwuZ2V0KFwic3R5bGUuc1Bvc1wiKTtcclxuICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbi5lbmRQb3MgPSBtb2RlbC5nZXQoXCJzdHlsZS5lUG9zXCIpO1xyXG5cclxuICAgICAgICAvL+WIpOaWreS4gOS4iyBtb2RlbOmHjOacieayoeaciWRvY2tlcnPvvIzlpoLmnpzmnInliJnosIPnlKjmnoTpgKBwb2ludOaVsOe7hCAg5oiW6ICF6LCD55SocmVmcmVzaENvbm5lY3Rvcuiuoeeul+WmguS9leeUu+e6v1xyXG4gICAgICAgIHZhciBkb2NrZXJzID0gbW9kZWwuZ2V0KFwiZG9ja2Vyc1wiKTtcclxuICAgICAgICBpZiAoZG9ja2VycyAmJiBkb2NrZXJzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBQb2ludC5sb2FkQXJyYXkoZG9ja2Vycyk7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5yZWZyZXNoKHBvaW50cyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ubmVjdG9yKGNvbm5lY3RvciwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25uZWN0b3IuY29uUG9pbnRzR3JvdXAub24oXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciBhcnJTcGxpdCA9IGUudGFyZ2V0LnR5cGUuc3BsaXQoQ29ubmVjdG9yLlNFUEVSQVRPUik7XHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3IgPSBlLnRhcmdldC5jb25uZWN0b3I7XHJcbiAgICAgICAgICAgIGlmIChhcnJTcGxpdFswXSA9PT0gQ29ubmVjdG9yLlNUQVJUX05PREUpIHtcclxuICAgICAgICAgICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbi5zdGFydFBvcyA9IGFyclNwbGl0WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyclNwbGl0WzBdID09PSBDb25uZWN0b3IuRU5EX05PREUpIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uLmVuZFBvcyA9IGFyclNwbGl0WzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoYXQucmVmcmVzaENvbm5lY3Rvcihjb25uZWN0b3IsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiY29uUG9pbnRzR3JvdXA6Y2xpY2tcIjtcclxuICAgICAgICAgICAgcGFyYW1zLmxpbmVOb2RlID0gdGhhdC5zZWxDb25uZWN0b3I7XHJcbiAgICAgICAgICAgIGFwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydkYmxjbGljaycsICdjbGljayddO1xyXG4gICAgICAgIHpyVXRpbC5lYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbihldmVOYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5vbihcIkNvbm5lY3RvcjpcIiArIGV2ZU5hbWUsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGUudGFyZ2V0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGF0LnNlbENvbm5lY3RvciAhPT0gc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbENvbm5lY3RvciAmJiB0aGF0LnJlZnJlc2hDb25uZWN0b3IodGhhdC5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsQ29ubmVjdG9yID0gc2VsZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gZXZlTmFtZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGF0LnNlbENvbm5lY3RvcjtcclxuICAgICAgICAgICAgICAgIGFwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIW9wdGlvbnMuaXNGcm9tTW9kZWwpIHtcclxuICAgICAgICAgICAgLy8xLuiuvue9rui1t+Wni+iKgueCueeahG91dGdvaW5n5pWw57uEIOS4uue6v+auteeahElEXHJcbiAgICAgICAgICAgIHZhciBzdGFydE5vZGVPdXRnb2luZyA9IHN0YXJ0Tm9kZS5tb2RlbC5nZXQoXCJvdXRnb2luZ1wiKTtcclxuICAgICAgICAgICAgc3RhcnROb2RlT3V0Z29pbmcucHVzaChjb25uZWN0b3IucmVzb3VyY2VJZCk7XHJcbiAgICAgICAgICAgIC8vMi7orr7nva7nur/mrrXnmoRvdXRnb2luZ+aVsOe7hCDkuLrnu5PmnZ/oioLngrnnmoRJRFxyXG4gICAgICAgICAgICB2YXIgY29ubmVjdG9yT3V0Z29pbmcgPSBjb25uZWN0b3IubW9kZWwuZ2V0KFwib3V0Z29pbmdcIik7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rvck91dGdvaW5nLnB1c2goZW5kTm9kZS5yZXNvdXJjZUlkKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u57q/5q6155qE5qih5Z6L5pWw5o2uICAo57G75Z6LIOaWh+WtlylcclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBjb25uZWN0b3IgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtIHtbdHlwZV19IG9wdGlvbiAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIEJwbW5Db25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0TW9kZWwgPSBmdW5jdGlvbihjb25uZWN0b3IsIG9wdGlvbikge1xyXG4gICAgICAgIHZhciBvcmlnaW5OYW1lID0gY29ubmVjdG9yLm9wdGlvbnMudGV4dC50ZXh0O1xyXG4gICAgICAgIGNvbm5lY3Rvci5vcHRpb25zLnRleHQudGV4dCA9IG9wdGlvbi5wcm9wZXJ0aWVzLm5hbWU7XHJcbiAgICAgICAgY29ubmVjdG9yLm1vZGVsLm1lcmdlT3B0aW9uKG9wdGlvbik7XHJcbiAgICAgICAgLy/mloflrZfkuI3kuIDoh7Tml7ZcclxuICAgICAgICBpZiAob3JpZ2luTmFtZSAhPSBvcHRpb24ucHJvcGVydGllcy5uYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbm5lY3Rvcihjb25uZWN0b3IsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5Yig6Zmk5oyH5a6a55qE57q/XHJcbiAgICAgKiBAcGFyYW0gY29ubmVjdG9yIOassuWIoOmZpOeahOi/nue6v1xyXG4gICAgICogQHBhcmFtIF96ciB6clxyXG4gICAgICovXHJcbiAgICBCcG1uQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZUJ5TGluZSA9IGZ1bmN0aW9uIChjb25uZWN0b3IsX3pyKSB7XHJcbiAgICAgICAgLy8xLuWwhue6vyDmiYDogZTnmoRzdGFydE5vZGXnmoRvdXRnb2luZ+aVsOaNruWIoOmZpFxyXG4gICAgICAgIGlmKGNvbm5lY3Rvci5zdGFydE5vZGUpe1xyXG4gICAgICAgICAgICB2YXIgc3RhcnROb2RlT3V0Z29pbmcgPSBjb25uZWN0b3Iuc3RhcnROb2RlLm1vZGVsLmdldChcIm91dGdvaW5nXCIpO1xyXG4gICAgICAgICAgICBpbmRleCA9IHpyVXRpbC5pbmRleE9mKHN0YXJ0Tm9kZU91dGdvaW5nLCBjb25uZWN0b3IucmVzb3VyY2VJZCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnROb2RlT3V0Z29pbmcuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yTWFwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5nZXRUd29Ob2RlSWQoY29ubmVjdG9yLnN0YXJ0Tm9kZSwgY29ubmVjdG9yLmVuZE5vZGUsIGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yTWFwLnJlbW92ZUl0ZW0oa2V5LCBjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8yLuS7jl96cuS4iuWIoOmZpFxyXG4gICAgICAgIF96ci5yZW1vdmUoY29ubmVjdG9yKTtcclxuXHJcblxyXG4gICAgICAgIC8vMy7ku47nur/mlbDmja7kuK3liKDpmaRcclxuICAgICAgICB2YXIgaW5kZXggPSB6clV0aWwuaW5kZXhPZih0aGlzLmNvbm5lY3RvcnMsIGNvbm5lY3Rvcik7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zZWxDb25uZWN0b3IgPT09IGNvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLnNlbENvbm5lY3RvciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDliLfmlrDov57mjqXnur9cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbm9kZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBCcG1uQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlZnJlc2hMaW5lQnlOb2RlID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvbm5lY3RvcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yc1tpXS5zdGFydE5vZGUgPT0gbm9kZSB8fCB0aGlzLmNvbm5lY3RvcnNbaV0uZW5kTm9kZSA9PSBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25uZWN0b3IodGhpcy5jb25uZWN0b3JzW2ldLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoQnBtbkNvbm5lY3Rpb25NYW5hZ2VyLCBDb25uZWN0aW9uTWFuYWdlcik7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCcG1uQ29ubmVjdGlvbk1hbmFnZXI7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbWFuYWdlci9CcG1uQ29ubmVjdGlvbk1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog6L+e57q/566h55CG57G7XHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XHJcbiAgICB2YXIgUG9pbnQgPSByZXF1aXJlKFwiLi4vUG9pbnQuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgTG9nID0gcmVxdWlyZShcIi4uL0xvZy5qc1wiKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHJcbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uTWFuYWdlcigpIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3RvcnMgPSBbXTsgLy/lvZPliY3nlLvluIPmiYDmnInnmoTnur/mrrVcclxuICAgICAgICB0aGlzLnNlbENvbm5lY3RvciA9IG51bGw7IC8v5b2T5YmN6YCJ5Lit55qE57q/5q61XHJcbiAgICAgICAgdGhpcy50ZW1wQ29ubmVjdG9yID0gbnVsbDsgLy/kuLTml7bnur/mrrVcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuvue9rue6v+eahOS4jeWPr+e8lui+kVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBmb3JiaWRFZGl0IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0b3JGb3JiaWRFZGl0ID0gZnVuY3Rpb24gKGZvcmJpZEVkaXQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29ubmVjdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnNbaV0ub3B0aW9ucy5pc0VkaXQgPSAhZm9yYmlkRWRpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvcmJpZEVkaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVDb25uZWN0b3JFdmVudExpc3RlbmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog56e76Zmk57q/5p2h55uR5ZCs5LqL5Lu2XHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVDb25uZWN0b3JFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RvcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnMuZm9yRWFjaChmdW5jdGlvbihjb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5wb2x5TGluZS5vZmYoJ21vdXNlb3ZlcicpO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLnBvbHlMaW5lLm9mZignbW91c2Vtb3ZlJyk7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IucG9seUxpbmUub2ZmKCdtb3VzZW91dCcpO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLmN1cnZlTGluZS5vZmYoJ21vdXNlb3ZlcicpO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLmN1cnZlTGluZS5vZmYoJ21vdXNlbW92ZScpO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLmN1cnZlTGluZS5vZmYoJ21vdXNlb3V0Jyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmuIXnqbrov57mjqXnur/kuIrnmoTosIPmlbTkvY3nva7mjInpkq5cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xlYXJTZWxlY3RDb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsQ29ubmVjdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ubmVjdG9yKHRoaXMuc2VsQ29ubmVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWIoOmZpOWSjOiKgueCueebuOWFs+iBlOeahOi/nuaOpee6v1xyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVTZWxlY3RDb24gPSBmdW5jdGlvbiAobm9kZSwgX3pyKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbm5lY3RvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yc1tpXS5zdGFydE5vZGUgPT0gbm9kZSB8fCB0aGlzLmNvbm5lY3RvcnNbaV0uZW5kTm9kZSA9PSBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAvLzEu5bCG57q/IOaJgOiBlOeahHN0YXJ0Tm9kZeeahG91dGdvaW5n5pWw5o2u5Yig6ZmkXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnROb2RlT3V0Z29pbmcgPSB0aGlzLmNvbm5lY3RvcnNbaV0uc3RhcnROb2RlLm1vZGVsLmdldChcIm91dGdvaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0genJVdGlsLmluZGV4T2Yoc3RhcnROb2RlT3V0Z29pbmcsIHRoaXMuY29ubmVjdG9yc1tpXS5yZXNvdXJjZUlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZU91dGdvaW5nLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLzIu5LuOX3py5LiK5Yig6ZmkXHJcbiAgICAgICAgICAgICAgICBfenIucmVtb3ZlKHRoaXMuY29ubmVjdG9yc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxDb25uZWN0b3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUxpbmUgPSBmdW5jdGlvbiAobGluZSwgenIpIHtcclxuICAgICAgICB0aGlzLnNlbENvbm5lY3RvciA9IGxpbmU7XHJcbiAgICAgICAgdGhpcy5kZWxldGVMaW5lKHpyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5Yig6Zmk6YCJ5a6a55qE57q/XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZUxpbmUgPSBmdW5jdGlvbiAoX3pyKSB7XHJcbiAgICAgICAgLy8xLuWwhue6vyDmiYDogZTnmoRzdGFydE5vZGXnmoRvdXRnb2luZ+aVsOaNruWIoOmZpFxyXG4gICAgICAgIGlmKHRoaXMuc2VsQ29ubmVjdG9yLnN0YXJ0Tm9kZSl7XHJcbiAgICAgICAgICAgIHZhciBzdGFydE5vZGVPdXRnb2luZyA9IHRoaXMuc2VsQ29ubmVjdG9yLnN0YXJ0Tm9kZS5tb2RlbC5nZXQoXCJvdXRnb2luZ1wiKTtcclxuICAgICAgICAgICAgaW5kZXggPSB6clV0aWwuaW5kZXhPZihzdGFydE5vZGVPdXRnb2luZywgdGhpcy5zZWxDb25uZWN0b3IucmVzb3VyY2VJZCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnROb2RlT3V0Z29pbmcuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yTWFwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5nZXRUd29Ob2RlSWQodGhpcy5zZWxDb25uZWN0b3Iuc3RhcnROb2RlLCB0aGlzLnNlbENvbm5lY3Rvci5lbmROb2RlLCB0aGlzLnNlbENvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yTWFwLnJlbW92ZUl0ZW0oa2V5LCB0aGlzLnNlbENvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLzIu5LuOX3py5LiK5Yig6ZmkXHJcbiAgICAgICAgX3pyLnJlbW92ZSh0aGlzLnNlbENvbm5lY3Rvcik7XHJcblxyXG5cclxuICAgICAgICAvLzMu5LuO57q/5pWw5o2u5Lit5Yig6ZmkXHJcbiAgICAgICAgdmFyIGluZGV4ID0genJVdGlsLmluZGV4T2YodGhpcy5jb25uZWN0b3JzLCB0aGlzLnNlbENvbm5lY3Rvcik7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbENvbm5lY3RvciA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDph43mlrDnlLvnur9cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gY29ubmVjdG9yICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZm9yY2VcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlZnJlc2hDb25uZWN0b3IgPSBmdW5jdGlvbiAoY29ubmVjdG9yLCBmb3JjZSkge1xyXG4gICAgICAgIC8vIOWPquaciemcgOimgeW8uuWItuWIt+aWsCAg5oiW6ICFIOi/nue6v+S4uuepuu+8iDwyKeaXtiDmiY3ov5vooYzph43mlrDorqHnrpfph43nu5hcclxuICAgICAgICBpZiAoZm9yY2UgfHwgKCFjb25uZWN0b3IudHVybmluZ1BvaW50cykgfHwgKGNvbm5lY3Rvci50dXJuaW5nUG9pbnRzLmxlbmd0aCA8IDIpKSB7XHJcbiAgICAgICAgICAgIGlmIChjb25uZWN0b3IubW9kZWwgJiYgY29ubmVjdG9yLm1vZGVsLmdldChcInN0eWxlLmxpbmVUeXBlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9IGNvbm5lY3Rvci5tb2RlbC5nZXQoXCJzdHlsZS5saW5lVHlwZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXJyU3RhcnRFbmRQb2ludCA9IHRoaXMuZ2V0U3RhcnRFbmRQb2ludChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB2YXIgZXNjYXBlRGlzdGFuY2UgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24gJiYgY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24uZXNjYXBlRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIGVzY2FwZURpc3RhbmNlID0gY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24uZXNjYXBlRGlzdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNvbHV0aW9ucyA9IHRoaXMuY29ubmVjdG9yMlBvaW50cyhjb25uZWN0b3Iub3B0aW9ucy5zdHlsZS5saW5lVHlwZSwgYXJyU3RhcnRFbmRQb2ludFswXSxcclxuICAgICAgICAgICAgICAgIGFyclN0YXJ0RW5kUG9pbnRbMV0sXHJcbiAgICAgICAgICAgICAgICBhcnJTdGFydEVuZFBvaW50WzJdLCBhcnJTdGFydEVuZFBvaW50WzNdLCBlc2NhcGVEaXN0YW5jZSk7IC8vIFRZUEVfU1RSQUlHSFQgVFlQRV9KQUdHRURcclxuXHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5yZWZyZXNoKHNvbHV0aW9uc1swXVsyXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25uZWN0b3IuY2xlYXJIYW5kbGVzKCk7IC8v5riF56m6aGFuZGxlXHJcbiAgICB9XHJcblxyXG5cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRTdGFydEVuZFBvaW50ID0gZnVuY3Rpb24gKGNvbm5lY3Rvcikge1xyXG4gICAgICAgIHZhciBzdGFydE5vZGUgPSBjb25uZWN0b3Iuc3RhcnROb2RlO1xyXG4gICAgICAgIHZhciBlbmROb2RlID0gY29ubmVjdG9yLmVuZE5vZGU7XHJcbiAgICAgICAgdmFyIGlzTm90SW5TYW1lR3JvdXAgPSB0cnVlO1xyXG4gICAgICAgIGlzTm90SW5TYW1lR3JvdXAgPSBzdGFydE5vZGUucGFyZW50ICE9PSBlbmROb2RlLnBhcmVudDtcclxuXHJcbiAgICAgICAgdmFyIHNSZWN0ID0gVXRpbC5nZXRSZWN0KHN0YXJ0Tm9kZSwgaXNOb3RJblNhbWVHcm91cCkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgIHZhciBzQm91bmRzID0gW051bWJlcihzUmVjdC54KSwgTnVtYmVyKHNSZWN0LnkpLCBOdW1iZXIoc1JlY3QueCkgKyBOdW1iZXIoc1JlY3Qud2lkdGgpLCBOdW1iZXIoXHJcbiAgICAgICAgICAgIHNSZWN0LnkpICsgTnVtYmVyKHNSZWN0LmhlaWdodCldO1xyXG5cclxuICAgICAgICB2YXIgZVJlY3QgPSBVdGlsLmdldFJlY3QoZW5kTm9kZSwgaXNOb3RJblNhbWVHcm91cCkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgIHZhciBlQm91bmRzID0gW051bWJlcihlUmVjdC54KSwgTnVtYmVyKGVSZWN0LnkpLCBOdW1iZXIoZVJlY3QueCkgKyBOdW1iZXIoZVJlY3Qud2lkdGgpLCBOdW1iZXIoXHJcbiAgICAgICAgICAgIGVSZWN0LnkpICsgTnVtYmVyKGVSZWN0LmhlaWdodCldO1xyXG5cclxuXHJcbiAgICAgICAgdmFyIHNDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKHNSZWN0LCBzdGFydE5vZGUpO1xyXG4gICAgICAgIHZhciBlQ29ubmVjdG9yUG9pbnQgPSBVdGlsLmdldENvbm5lY3RvclBvaW50cyhlUmVjdCwgZW5kTm9kZSk7XHJcblxyXG4gICAgICAgIC8v5Yik5pat5aaC5p6c5rKh5pyJ5oyH5a6a5L2N572u55qE6K+dLCDliKTmlq3lvIDlp4voioLngrnlnKjnu5PmnZ/nu5Pmnpzlt6bovrnliJnph4fnlKggcmlnaHQtbGVmdCDlkKbliJnph4fnlKhsZWZ0LXJpZ2h0XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb247XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uLmRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgcG9zQXJyID0gcG9zaXRpb24uZGlyZWN0aW9uLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0UG9zID0gcG9zQXJyWzBdO1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5lbmRQb3MgPSBwb3NBcnJbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcG9zaXRpb24uc3RhcnRQb3MgfHwgIXBvc2l0aW9uLmVuZFBvcykge1xyXG4gICAgICAgICAgICBpZiAoc1JlY3QueCA8IGVSZWN0LngpIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0UG9zID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uZW5kUG9zID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5zdGFydFBvcyA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uZW5kUG9zID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydFBvaW50ID0gdGhpcy5jYWxjUG9pbnRFeHByZXNzaW9uKHBvc2l0aW9uLnN0YXJ0UG9zLCBzQ29ubmVjdG9yUG9pbnQpO1xyXG4gICAgICAgIHZhciBlbmRQb2ludCA9IHRoaXMuY2FsY1BvaW50RXhwcmVzc2lvbihwb3NpdGlvbi5lbmRQb3MsIGVDb25uZWN0b3JQb2ludCk7XHJcbiAgICAgICAgc3RhcnRQb2ludC5hZGQobmV3IFBvaW50KHBvc2l0aW9uLnN0YXJ0T2Zmc2V0WzBdLCBwb3NpdGlvbi5zdGFydE9mZnNldFsxXSkpO1xyXG4gICAgICAgIGVuZFBvaW50LmFkZChuZXcgUG9pbnQocG9zaXRpb24uZW5kT2Zmc2V0WzBdLCBwb3NpdGlvbi5lbmRPZmZzZXRbMV0pKTtcclxuICAgICAgICByZXR1cm4gW3N0YXJ0UG9pbnQsIGVuZFBvaW50LCBzQm91bmRzLCBlQm91bmRzXTtcclxuICAgIH1cclxuXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2FsY1BvaW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChwb3MsIHBvaW50KSB7XHJcbiAgICAgICAgdmFyIHZhcmlhYmxlID0ge1xyXG4gICAgICAgICAgICB0b3A6IHBvaW50LnRvcC54LFxyXG4gICAgICAgICAgICBsZWZ0OiBwb2ludC5sZWZ0LnksXHJcbiAgICAgICAgICAgIHJpZ2h0OiBwb2ludC5yaWdodC55LFxyXG4gICAgICAgICAgICBib3R0b206IHBvaW50LmJvdHRvbS54LFxyXG4gICAgICAgICAgICBjZW50ZXI6IHBvaW50LmNlbnRlci54XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBcIjwlIHByaW50KFwiICsgcG9zICsgXCIpICU+XCI7XHJcbiAgICAgICAgdmFyIHZhbCA9IHBhcnNlSW50KFV0aWwudGVtcGxhdGUoZXhwcmVzc2lvbikodmFyaWFibGUpKTtcclxuICAgICAgICBpZiAocG9zLmluZGV4T2YoXCJ0b3BcIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh2YWwsIHBvaW50LnRvcC55KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwibGVmdFwiKSAhPSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHBvaW50LmxlZnQueCwgdmFsKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwicmlnaHRcIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwb2ludC5yaWdodC54LCB2YWwpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocG9zLmluZGV4T2YoXCJib3R0b21cIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh2YWwsIHBvaW50LmJvdHRvbS55KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwiY2VudGVyXCIpICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodmFsLCBwb2ludC5ib3R0b20ueSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicG9z5Y+C5pWw6ZSZ6K+vXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uuaIluS/ruaUueS4tOaXtue6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFydE5vZGUgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSByRW5kUG9pbnQgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBsaW5lVHlwZSAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFydFBvcyAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUubWFuYWdlVGVtcENvbm5lY3RvciA9IGZ1bmN0aW9uIChzdGFydE5vZGUsIHJFbmRQb2ludCwgbGluZVR5cGUsIHN0YXJ0UG9zLCBlbmRQb3MsIGVuZE5vZGUpIHtcclxuICAgICAgICB2YXIgZVJlY3QgPSBudWxsO1xyXG4gICAgICAgIHZhciBlQm91bmRzID0gbnVsbDtcclxuICAgICAgICB2YXIgc1JlY3QgPSBVdGlsLmdldFJlY3Qoc3RhcnROb2RlLCB0cnVlKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgdmFyIHNCb3VuZHMgPSBbTnVtYmVyKHNSZWN0LngpLCBOdW1iZXIoc1JlY3QueSksIE51bWJlcihzUmVjdC54KSArIE51bWJlcihzUmVjdC53aWR0aCksIE51bWJlcihcclxuICAgICAgICAgICAgc1JlY3QueSkgKyBOdW1iZXIoc1JlY3QuaGVpZ2h0KV07XHJcblxyXG4gICAgICAgIHZhciBzQ29ubmVjdG9yUG9pbnQgPSBVdGlsLmdldENvbm5lY3RvclBvaW50cyhzUmVjdCwgc3RhcnROb2RlKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnRlbXBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy50ZW1wQ29ubmVjdG9yID0gbmV3IENvbm5lY3Rvcih7XHJcbiAgICAgICAgICAgICAgICBpc0VkaXQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lVHlwZTogbGluZVR5cGVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gdGhpcy50ZW1wQ29ubmVjdG9yO1xyXG4gICAgICAgIC8v5Yik5pat5aaC5p6c5rKh5pyJ5oyH5a6a5L2N572u55qE6K+dLCDliKTmlq3lvIDlp4voioLngrnlnKjnu5PmnZ/nu5Pmnpzlt6bovrnliJnph4fnlKggcmlnaHQtbGVmdCDlkKbliJnph4fnlKhsZWZ0LXJpZ2h0XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb247XHJcbiAgICAgICAgcG9zaXRpb24uc3RhcnRQb3MgPSBzdGFydFBvcyA/IHN0YXJ0UG9zIDogKHNSZWN0LnggPCByRW5kUG9pbnQueCA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTtcclxuICAgICAgICBwb3NpdGlvbi5lbmRQb3MgPSBlbmRQb3MgPyBlbmRQb3MgOiAoc1JlY3QueCA8IHJFbmRQb2ludC54ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpO1xyXG5cclxuICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9IGxpbmVUeXBlO1xyXG4gICAgICAgIGlmIChlbmROb2RlKSB7XHJcbiAgICAgICAgICAgIGVSZWN0ID0gVXRpbC5nZXRSZWN0KGVuZE5vZGUsIHRydWUpLmJvdW5kaW5nUmVjdDtcclxuICAgICAgICAgICAgZUJvdW5kcyA9IFtOdW1iZXIoZVJlY3QueCksIE51bWJlcihlUmVjdC55KSwgTnVtYmVyKGVSZWN0LngpICsgTnVtYmVyKGVSZWN0LndpZHRoKSwgTnVtYmVyKFxyXG4gICAgICAgICAgICAgICAgZVJlY3QueSkgKyBOdW1iZXIoZVJlY3QuaGVpZ2h0KV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzb2x1dGlvbnMgPSB0aGlzLmNvbm5lY3RvcjJQb2ludHMobGluZVR5cGUsIHNDb25uZWN0b3JQb2ludFtwb3NpdGlvbi5zdGFydFBvc10sIHJFbmRQb2ludCxcclxuICAgICAgICAgICAgc0JvdW5kcywgZUJvdW5kcyk7IC8vIFRZUEVfU1RSQUlHSFQgVFlQRV9KQUdHRURcclxuXHJcbiAgICAgICAgY29ubmVjdG9yLnJlZnJlc2goc29sdXRpb25zWzBdWzJdKTtcclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu65oiW5L+u5pS55Li05pe25Y+N6L2s57q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHN0YXJ0UG9pbnQgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZW5kTm9kZSAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBsaW5lVHlwZSAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGVuZFBvcyAgICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUubWFuYWdlUmV2ZXJzZVRlbXBDb25uZWN0b3IgPSBmdW5jdGlvbiAoc3RhcnRQb2ludCwgZW5kTm9kZSwgbGluZVR5cGUsIGVuZFBvcywgc3RhcnRQb3MsIHN0YXJ0Tm9kZSkge1xyXG4gICAgICAgIHZhciBzUmVjdCA9IG51bGw7XHJcbiAgICAgICAgdmFyIHNCb3VuZHMgPSBudWxsO1xyXG4gICAgICAgIHZhciBlUmVjdCA9IFV0aWwuZ2V0UmVjdChlbmROb2RlLCB0cnVlKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgdmFyIGVCb3VuZHMgPSBbTnVtYmVyKGVSZWN0LngpLCBOdW1iZXIoZVJlY3QueSksIE51bWJlcihlUmVjdC54KSArIE51bWJlcihlUmVjdC53aWR0aCksIE51bWJlcihlUmVjdC55KSArIE51bWJlcihlUmVjdC5oZWlnaHQpXTtcclxuICAgICAgICB2YXIgZUNvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoZVJlY3QsIGVuZE5vZGUpO1xyXG4gICAgICAgIGlmICghdGhpcy50ZW1wQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGVtcENvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Ioe1xyXG4gICAgICAgICAgICAgICAgaXNFZGl0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZVR5cGU6IGxpbmVUeXBlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gdGhpcy50ZW1wQ29ubmVjdG9yO1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uO1xyXG4gICAgICAgIHBvc2l0aW9uLmVuZFBvcyA9IGVuZFBvcyA/IGVuZFBvcyA6IChlUmVjdC54IDwgc3RhcnRQb2ludC54ID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpO1xyXG4gICAgICAgIHBvc2l0aW9uLnN0YXJ0UG9zID0gc3RhcnRQb3MgPyBzdGFydFBvcyA6IChlUmVjdC54IDwgc3RhcnRQb2ludC54ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpO1xyXG5cclxuICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9IGxpbmVUeXBlO1xyXG4gICAgICAgIGlmIChzdGFydE5vZGUpIHtcclxuICAgICAgICAgICAgc1JlY3QgPSBVdGlsLmdldFJlY3Qoc3RhcnROb2RlLCB0cnVlKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgICAgIHNCb3VuZHMgPSBbTnVtYmVyKHNSZWN0LngpLCBOdW1iZXIoc1JlY3QueSksIE51bWJlcihzUmVjdC54KSArIE51bWJlcihzUmVjdC53aWR0aCksIE51bWJlcihcclxuICAgICAgICAgICAgc1JlY3QueSkgKyBOdW1iZXIoc1JlY3QuaGVpZ2h0KV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzb2x1dGlvbnMgPSB0aGlzLmNvbm5lY3RvcjJQb2ludHMobGluZVR5cGUsIHN0YXJ0UG9pbnQsIGVDb25uZWN0b3JQb2ludFtwb3NpdGlvbi5lbmRQb3NdLFxyXG4gICAgICAgICAgICBzQm91bmRzLCBlQm91bmRzKTsgLy8gVFlQRV9TVFJBSUdIVCBUWVBFX0pBR0dFRFxyXG5cclxuICAgICAgICBjb25uZWN0b3IucmVmcmVzaChzb2x1dGlvbnNbMF1bMl0pO1xyXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKDpmaTkuLTml7bnur9cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0genIgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlVGVtcENvbm5lY3RvciA9IGZ1bmN0aW9uICh6cikge1xyXG4gICAgICAgIGlmICh0aGlzLnRlbXBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgenIucmVtb3ZlKHRoaXMudGVtcENvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgIHRoaXMudGVtcENvbm5lY3RvciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOeul+WHuiDkuKTkuKroioLngrkg5oyH5a6a5Lik5Liq54K55aaC5L2V6IGU57q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHR5cGUgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFydFBvaW50IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZW5kUG9pbnQgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHNCb3VuZHMgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBlQm91bmRzICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0b3IyUG9pbnRzID0gZnVuY3Rpb24gKHR5cGUsIHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBzQm91bmRzLCBlQm91bmRzLFxyXG4gICAgICAgIGVzY2FwZURpc3RhbmNlKSB7XHJcbiAgICAgICAgdmFyIGZpZ3VyZUVzY2FwZURpc3RhbmNlID0gWzMwLCAzMF07XHJcbiAgICAgICAgaWYgKGVzY2FwZURpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoZXNjYXBlRGlzdGFuY2UpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWd1cmVFc2NhcGVEaXN0YW5jZSA9IFtlc2NhcGVEaXN0YW5jZSwgZXNjYXBlRGlzdGFuY2VdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmlndXJlRXNjYXBlRGlzdGFuY2UgPSBlc2NhcGVEaXN0YW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTG9nLmdyb3VwKFwiY29ubmVjdGlvbk1hbmFnZXI6IGNvbm5lY3RvcjJQb2ludHNcIik7XHJcblxyXG5cclxuICAgICAgICBMb2cuaW5mbyhcIkNvbm5lY3Rpb25NYW5hZ2VyOiBjb25uZWN0b3IyUG9pbnRzIChcIiArIHR5cGUgKyBcIiwgXCIgKyBzdGFydFBvaW50ICsgXCIsIFwiICsgZW5kUG9pbnQgK1xyXG4gICAgICAgICAgICBcIiwgXCIgKyBzQm91bmRzICsgXCIsIFwiICsgZUJvdW5kcyArICcpJyk7XHJcbiAgICAgICAgdmFyIHNvbHV0aW9ucyA9IFtdO1xyXG5cclxuXHJcblxyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIENvbm5lY3Rvci5UWVBFX0NIQUlOOlxyXG5cclxuICAgICAgICAgICAgY2FzZSBDb25uZWN0b3IuVFlQRV9TVFJBSUdIVDogLy/nm7Tnur9cclxuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBbc3RhcnRQb2ludC5jbG9uZSgpLCBlbmRQb2ludC5jbG9uZSgpXTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnc3RyYWlnaHQnLCAnc3RyYWlnaHQnLCBwb2ludHNdKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb25uZWN0b3IuVFlQRV9DVVJWRTogLy/mm7Lnur9cclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29ubmVjdG9yLlRZUEVfSkFHR0VEOiAvL+aKmOe6v1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0RXhpdFBvaW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRFeGl0UG9pbnQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZmluZCBzdGFydCBleGl0IHBvaW50ICDlr7vmib7lvIDlp4vlh7rlj6NcclxuICAgICAgICAgICAgICAgIGlmIChzQm91bmRzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG90ZW50aWFsRXhpdHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoc3RhcnRQb2ludC54LCBzQm91bmRzWzFdIC0gZmlndXJlRXNjYXBlRGlzdGFuY2VbMF0pKTsgLy9ub3J0aCDljJdcclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChzQm91bmRzWzJdICsgZmlndXJlRXNjYXBlRGlzdGFuY2VbMF0sIHN0YXJ0UG9pbnQueSkpOyAvL2Vhc3QgIOS4nFxyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KHN0YXJ0UG9pbnQueCwgc0JvdW5kc1szXSArIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzBdKSk7IC8vc291dGggIOWNl1xyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KHNCb3VuZHNbMF0gLSBmaWd1cmVFc2NhcGVEaXN0YW5jZVswXSwgc3RhcnRQb2ludC55KSk7IC8vd2VzdCAg6KW/XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcGljayBjbG9zZXN0IGV4aXQgcG9pbnQgIOWvu+aJvuS4jiBzdGFydFBvaW50IOacgOmdoOi/keeahOWHuuWPo+eCuVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RXhpdFBvaW50ID0gcG90ZW50aWFsRXhpdHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb3RlbnRpYWxFeGl0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5kaXN0YW5jZShzdGFydFBvaW50LCBwb3RlbnRpYWxFeGl0c1tpXSkgPCBVdGlsLmRpc3RhbmNlKHN0YXJ0UG9pbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRFeGl0UG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEV4aXRQb2ludCA9IHBvdGVudGlhbEV4aXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgZW5kIGV4aXQgcG9pbnQgIOWvu+aJvue7k+adn+WHuuWPo1xyXG4gICAgICAgICAgICAgICAgaWYgKGVCb3VuZHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3RlbnRpYWxFeGl0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChlbmRQb2ludC54LCBlQm91bmRzWzFdIC0gZmlndXJlRXNjYXBlRGlzdGFuY2VbMV0pKTsgLy9ub3J0aFxyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KGVCb3VuZHNbMl0gKyBmaWd1cmVFc2NhcGVEaXN0YW5jZVsxXSwgZW5kUG9pbnQueSkpOyAvL2Vhc3RcclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChlbmRQb2ludC54LCBlQm91bmRzWzNdICsgZmlndXJlRXNjYXBlRGlzdGFuY2VbMV0pKTsgLy9zb3V0aFxyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KGVCb3VuZHNbMF0gLSBmaWd1cmVFc2NhcGVEaXN0YW5jZVsxXSwgZW5kUG9pbnQueSkpOyAvL3dlc3RcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9waWNrIGNsb3Nlc3QgZXhpdCBwb2ludCAg5a+75om+5LiOIGVuZFBvaW50IOacgOmdoOi/keeahOWHuuWPo+eCuVxyXG4gICAgICAgICAgICAgICAgICAgIGVuZEV4aXRQb2ludCA9IHBvdGVudGlhbEV4aXRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG90ZW50aWFsRXhpdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWwuZGlzdGFuY2UoZW5kUG9pbnQsIHBvdGVudGlhbEV4aXRzW2ldKSA8IFV0aWwuZGlzdGFuY2UoZW5kUG9pbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRXhpdFBvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRXhpdFBvaW50ID0gcG90ZW50aWFsRXhpdHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9CYXNpYyBzb2x1dGlvbiDmnIDln7rmnKznmoTop6PlhrPmlrnmoYggICDkuLrlhbbku5bop6PlhrPmlrnmoYjlgZrlh4blpIdcclxuICAgICAgICAgICAgICAgIHZhciBzID0gW3N0YXJ0UG9pbnRdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdhcEluZGV4ID0gMDsgLy90aGUgaW5kZXggb2YgdGhlIGdhcCAod2hlcmUgZG8gd2UgbmVlZCB0byBpbnNlcnQgbmV3IHBvaW50cykgRE8gTk9UIENIQU5HRSBJVFxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RXhpdFBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5wdXNoKHN0YXJ0RXhpdFBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICBnYXBJbmRleCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kRXhpdFBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5wdXNoKGVuZEV4aXRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzLnB1c2goZW5kUG9pbnQpO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9TTyAtIG5vIGFkZGl0aW9uYWwgcG9pbnRzICAgICBTMCDop6PlhrPmlrnmoYgg5LiN5re75Yqg5Lu75L2V54K5ICDln7rmnKzkuI3kvJrooqvph4fnlKhcclxuICAgICAgICAgICAgICAgIHZhciBzMCA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MwJywgJ3MwJywgczBdKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vUzEgICBTMSDop6PlhrPmlrnmoYggIOWPquacieS4gOS4quaKmOeCuVxyXG4gICAgICAgICAgICAgICAgdmFyIHMxID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2ZpcnN0IHZhcmlhbnQgICDnrKzkuIDkuKrlj5jkvZMgczEgczFfMeaWueahiCAg5oqY57q/54K55ZyoIHN0YXJ0RXhpdFBvaW5055qEWCDkuI4gZW5kRXhpdFBvaW5055qEIFnkvY3nva5cclxuICAgICAgICAgICAgICAgIHZhciBzMV8xID0gUG9pbnQuY2xvbmVBcnJheShzMSk7XHJcbiAgICAgICAgICAgICAgICBzMV8xLnNwbGljZShnYXBJbmRleCArIDEsIDAsIG5ldyBQb2ludChzMV8xW2dhcEluZGV4XS54LCBzMV8xW2dhcEluZGV4ICsgMV0ueSkpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMScsICdzMV8xJywgczFfMV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vc2Vjb25kIHZhcmlhbnQgIOesrOS6jOWPmOS9kyBzMSBzMS0y5pa55qGIICDmipjnur/ngrnlnKggZW5kRXhpdFBvaW5055qEWCDkuI4gIHN0YXJ0RXhpdFBvaW5055qEWeS9jee9rlxyXG4gICAgICAgICAgICAgICAgdmFyIHMxXzIgPSBQb2ludC5jbG9uZUFycmF5KHMxKTtcclxuICAgICAgICAgICAgICAgIHMxXzIuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgbmV3IFBvaW50KHMxXzJbZ2FwSW5kZXggKyAxXS54LCBzMV8yW2dhcEluZGV4XS55KSk7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MxJywgJ3MxXzInLCBzMV8yXSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vUzIgIFMyIOino+WGs+aWueahiCAg5re75Yqg5Lik5Liq5oqY54K5XHJcblxyXG4gICAgICAgICAgICAgICAgLy9WYXJpYW50IEkgICBzMl8x5pa55qGIXHJcbiAgICAgICAgICAgICAgICB2YXIgczJfMSA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfMV8xID0gbmV3IFBvaW50KChzMl8xW2dhcEluZGV4XS54ICsgczJfMVtnYXBJbmRleCArIDFdLngpIC8gMiwgczJfMVtnYXBJbmRleF0ueSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfMV8yID0gbmV3IFBvaW50KChzMl8xW2dhcEluZGV4XS54ICsgczJfMVtnYXBJbmRleCArIDFdLngpIC8gMiwgczJfMVtnYXBJbmRleCArIDFdLnkpO1xyXG4gICAgICAgICAgICAgICAgczJfMS5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBzMl8xXzEsIHMyXzFfMik7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MyJywgJ3MyXzEnLCBzMl8xXSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vVmFyaWFudCBJSSAgczJfMeaWueahiCAgMeaKmOe6v+eCuSB4OiBzdGFydEV4aXRQb2ludOeahFgg5L2N572uIHk6IHN0YXJ0RXhpdFBvaW5055qEeStlbmRFeGl0UG9pbnTnmoR5LzJcclxuICAgICAgICAgICAgICAgIC8vMeaKmOe6v+eCuSB4OmVuZEV4aXRQb2ludOeahHggIHk6c3RhcnRFeGl0UG9pbnTnmoR5K2VuZEV4aXRQb2ludOeahHkvMlxyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzIgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzJfMSA9IG5ldyBQb2ludChzMl8yW2dhcEluZGV4XS54LCAoczJfMltnYXBJbmRleF0ueSArIHMyXzJbZ2FwSW5kZXggKyAxXS55KSAvIDIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzJfMiA9IG5ldyBQb2ludChzMl8yW2dhcEluZGV4ICsgMV0ueCwgKHMyXzJbZ2FwSW5kZXhdLnkgKyBzMl8yW2dhcEluZGV4ICsgMV0ueSkgLyAyKTtcclxuICAgICAgICAgICAgICAgIHMyXzIuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfMl8xLCBzMl8yXzIpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl8yJywgczJfMl0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgSUlJXHJcbiAgICAgICAgICAgICAgICB2YXIgczJfMyA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIGFtb3VudCAoc3RvcmVkIGluIGRlbHRhKSBvZiBwaXhlbHMgd2UgbmVlZCB0byBtb3ZlIHJpZ2h0IHNvIG5vIGludGVyc2VjdGlvbiB3aXRoIGEgZmlndXJlIHdpbGwgYmUgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgLy8hU2VlOiAgL2RvY3VtZW50cy9zcGVjcy9jb25uZWN0ZWRfZmlndXJlc19kZWx0YXMuanBnIGZpbGVcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZWFzdEV4aXRzID0gW3MyXzNbZ2FwSW5kZXhdLnggKyAyMCwgczJfM1tnYXBJbmRleCArIDFdLnggKyAyMF07IC8vYWRkIHBvaW50cyBYIGNvb3JkaW5hdGVzIHRvIGJlIGFibGUgdG8gZ2VuZXJhdGUgVmFyaWFudCBJSUkgZXZlbiBpbiB0aGUgYWJzZW5jZSBvZiBmaWd1cmVzIDpwXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBlYXN0RXhpdHMucHVzaChzQm91bmRzWzJdICsgMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWFzdEV4aXRzLnB1c2goZUJvdW5kc1syXSArIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZWFzdEV4aXQgPSBVdGlsLm1heChlYXN0RXhpdHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzNfMSA9IG5ldyBQb2ludChlYXN0RXhpdCwgczJfM1tnYXBJbmRleF0ueSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfM18yID0gbmV3IFBvaW50KGVhc3RFeGl0LCBzMl8zW2dhcEluZGV4ICsgMV0ueSk7XHJcbiAgICAgICAgICAgICAgICBzMl8zLnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzNfMSwgczJfM18yKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfMycsIHMyXzNdKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9WYXJpYW50IElWICBzMl805pa55qGIXHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNCA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIGFtb3VudCAoc3RvcmVkIGluIGRlbHRhKSBvZiBwaXhlbHMgd2UgbmVlZCB0byBtb3ZlIHVwIHNvIG5vIGludGVyc2VjdGlvbiB3aXRoIGEgZmlndXJlIHdpbGwgYmUgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgLy8hU2VlOiAgL2RvY3VtZW50cy9zcGVjcy9jb25uZWN0ZWRfZmlndXJlc19kZWx0YXMuanBnIGZpbGVcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbm9ydGhFeGl0cyA9IFtzMl80W2dhcEluZGV4XS55IC0gMjAsIHMyXzRbZ2FwSW5kZXggKyAxXS55IC0gMjBdOyAvL2FkZCBwb2ludHMgeSBjb29yZGluYXRlcyB0byBiZSBhYmxlIHRvIGdlbmVyYXRlIFZhcmlhbnQgSUlJIGV2ZW4gaW4gdGhlIGFic2VuY2Ugb2YgZmlndXJlcyA6cFxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ydGhFeGl0cy5wdXNoKHNCb3VuZHNbMV0gLSAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBub3J0aEV4aXRzLnB1c2goZUJvdW5kc1sxXSAtIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbm9ydGhFeGl0ID0gVXRpbC5taW4obm9ydGhFeGl0cyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNF8xID0gbmV3IFBvaW50KHMyXzRbZ2FwSW5kZXhdLngsIG5vcnRoRXhpdCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNF8yID0gbmV3IFBvaW50KHMyXzRbZ2FwSW5kZXggKyAxXS54LCBub3J0aEV4aXQpO1xyXG4gICAgICAgICAgICAgICAgczJfNC5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBzMl80XzEsIHMyXzRfMik7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MyJywgJ3MyXzQnLCBzMl80XSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vVmFyaWFudCBWXHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNSA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIGFtb3VudCAoc3RvcmVkIGluIGRlbHRhKSBvZiBwaXhlbHMgd2UgbmVlZCB0byBtb3ZlIGxlZnQgc28gbm8gaW50ZXJzZWN0aW9uIHdpdGggYSBmaWd1cmUgd2lsbCBiZSBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAvLyFTZWU6ICAvZG9jdW1lbnRzL3NwZWNzL2Nvbm5lY3RlZF9maWd1cmVzX2RlbHRhcy5qcGcgZmlsZVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB3ZXN0RXhpdHMgPSBbczJfNVtnYXBJbmRleF0ueCAtIDIwLCBzMl81W2dhcEluZGV4ICsgMV0ueCAtIDIwXTsgLy9hZGQgcG9pbnRzIHggY29vcmRpbmF0ZXMgdG8gYmUgYWJsZSB0byBnZW5lcmF0ZSBWYXJpYW50IElJSSBldmVuIGluIHRoZSBhYnNlbmNlIG9mIGZpZ3VyZXMgOnBcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdlc3RFeGl0cy5wdXNoKHNCb3VuZHNbMF0gLSAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB3ZXN0RXhpdHMucHVzaChlQm91bmRzWzBdIC0gMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB3ZXN0RXhpdCA9IFV0aWwubWluKHdlc3RFeGl0cyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNV8xID0gbmV3IFBvaW50KHdlc3RFeGl0LCBzMl81W2dhcEluZGV4XS55KTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl81XzIgPSBuZXcgUG9pbnQod2VzdEV4aXQsIHMyXzVbZ2FwSW5kZXggKyAxXS55KTtcclxuICAgICAgICAgICAgICAgIHMyXzUuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfNV8xLCBzMl81XzIpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl81JywgczJfNV0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgVklcclxuICAgICAgICAgICAgICAgIHZhciBzMl82ID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICAgICAgICAgIC8vZmluZCB0aGUgYW1vdW50IChzdG9yZWQgaW4gZGVsdGEpIG9mIHBpeGVscyB3ZSBuZWVkIHRvIG1vdmUgZG93biBzbyBubyBpbnRlcnNlY3Rpb24gd2l0aCBhIGZpZ3VyZSB3aWxsIGJlIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIC8vIVNlZTogIC9kb2N1bWVudHMvc3BlY3MvY29ubmVjdGVkX2ZpZ3VyZXNfZGVsdGFzLmpwZyBmaWxlXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNvdXRoRXhpdHMgPSBbczJfNltnYXBJbmRleF0ueSArIDIwLCBzMl82W2dhcEluZGV4ICsgMV0ueSArIDIwXTsgLy9hZGQgcG9pbnRzIHkgY29vcmRpbmF0ZXMgdG8gYmUgYWJsZSB0byBnZW5lcmF0ZSBWYXJpYW50IElJSSBldmVuIGluIHRoZSBhYnNlbmNlIG9mIGZpZ3VyZXMgOnBcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvdXRoRXhpdHMucHVzaChzQm91bmRzWzNdICsgMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc291dGhFeGl0cy5wdXNoKGVCb3VuZHNbM10gKyAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNvdXRoRXhpdCA9IFV0aWwubWF4KHNvdXRoRXhpdHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzZfMSA9IG5ldyBQb2ludChzMl82W2dhcEluZGV4XS54LCBzb3V0aEV4aXQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzZfMiA9IG5ldyBQb2ludChzMl82W2dhcEluZGV4ICsgMV0ueCwgc291dGhFeGl0KTtcclxuICAgICAgICAgICAgICAgIHMyXzYuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfNl8xLCBzMl82XzIpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl82JywgczJfNl0pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9GSUxURVIgc29sdXRpb25zXHJcblxyXG4gICAgICAgICAgICAgICAgLypBbGdvcml0aG1cclxuICAgICAgICAgICAgICAgICAqIDAuIHNvbHV0aW9ucyBhcmUgb3JkZXJlZCBmcm9tIG1pbmltbXVuIG5yIG9mIHBvaW50cyB0byBtYXhpbXVtID46KVxyXG4gICAgICAgICAgICAgICAgICogMS4gcmVtb3ZlIGFsbCBzb2x1dGlvbnMgdGhhdCBhcmUgbm90IG9ydGhvZ29uYWwgKG1haW5seSBzMCBzb2x1dGlvbilcclxuICAgICAgICAgICAgICAgICAqIDIuIHJlbW92ZSBhbGwgc29sdXRpb25zIHRoYXQgZ28gYmFja3dhcmQgKHdlIHdpbGwgbm90IG5lZWQgdGhlbSBldmVyKVxyXG4gICAgICAgICAgICAgICAgICogMy4gcmVtb3ZlIGFsbCBzb2x1dGlvbnMgd2l0aCBpbnRlcnNlY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgKiA0LiBwaWNrIGZpcnN0IGNsYXNzIG9mIHNvbHV0aW9ucyB3aXRoIHNhbWUgbnIgb2YgcG9pbnRzIChleDogMilcclxuICAgICAgICAgICAgICAgICAqIDUuIHBpY2sgdGhlIGZpcnN0IHNvbHV0aW9uIHdpdGggOTAgZGVncmVlIGFuZ2xlcyAobGVzcyB0dXJuYXJvdW5kcylcclxuICAgICAgICAgICAgICAgICAqIChub3QgaW50ZXJlc3RldGVkKSBzb3J0IGJ5IGxlbmd0aCA6cFxyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgLy8xLiBmaWx0ZXIgbm9uIG9ydG9nb25hbCBzb2x1dGlvbnMg5Yig6Zmk5LiN5piv5q2j5Lqk55u057q/55qE5pa55qGIXHJcbiAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIkZpbHRlciBvcnRob2dvbmFsIHNvbHV0aW9ucy4gSW5pdGlhbCBudW1iZXIgb2Ygc29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHZhciBvcnRob2dvbmFsU29sdXRpb24gPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgc29sdXRpb25zLmxlbmd0aDsgbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gc29sdXRpb25zW2xdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlsLm9ydGhvZ29uYWxQYXRoKHNvbHV0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcnRob2dvbmFsU29sdXRpb24ucHVzaChzb2x1dGlvbnNbbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IG9ydGhvZ29uYWxTb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiXFxuXFx0T3J0aG9nb25hbFNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8yLiBmaWx0ZXIgYmFja3dhcmQgc29sdXRpb25zICDov4fmu6Qg5YCS6YCA55qE5pa55qGIXHJcbiAgICAgICAgICAgICAgICAvL2RvIG5vdCBhbGxvdyBzdGFydCBhbmQgZW5kIHBvaW50cyB0byBjb2luY2lkZSAtIGlnbm9yZSB0aGVtXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRQb2ludC5lcXVhbHMoZW5kUG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiU3RhcnQgYW5kIGVuZCBwb2ludCBjb2luY2lkZS4uLnNraXAgYmFja3dhcmQgc29sdXRpb24uIEkgdGhpbmsgd2Ugd2lsbCBqdXN0IGZhbGwgb24gczAgOilcIlxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiRmlsdGVyIGJhY2t3YXJkIHNvbHV0aW9ucy4gSW5pdGlhbCBudW1iZXIgb2Ygc29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZm9yd2FyZFNvbHV0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBzb2x1dGlvbnMubGVuZ3RoOyBsKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gc29sdXRpb25zW2xdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5mb3J3YXJkUGF0aChzb2x1dGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmRTb2x1dGlvbnMucHVzaChzb2x1dGlvbnNbbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHRlbXAgKyBcIlxcblxcdFwiICsgc29sdXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zID0gZm9yd2FyZFNvbHV0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIlxcblxcdCBGb3J3YXJkU29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc29sdXRpb25zLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiRGlzY2FyZGVkIHNvbHV0aW9uczogXCIgKyB0ZW1wKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vMy4gRmlsdGVyIG5vbiBpbnRlcnNlY3Rpbmcgc29sdXRpb25zICDljrvpmaTmsqHmnInkuqTpm4YoKeeahOaWueahiFxyXG4gICAgICAgICAgICAgICAgTG9nLmluZm8oXCJGaWx0ZXIgbm9uIGludGVyc2VjdGluZyBzb2x1dGlvbnMuIEluaXRpYWwgbnVtYmVyIG9mIHNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9uSW50ZXJzZWN0aW9uU29sdXRpb25zID0gW11cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgc29sdXRpb25zLmxlbmd0aDsgbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gc29sdXRpb25zW2xdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vTG9nLmluZm8oXCJTb2x1dGlvbiBpZD0gXCIgKyBzb2x1dGlvbnNbbF1bMV0gKyAnIG5yIHBvaW50cyA9ICcgKyBzb2x1dGlvbi5sZW5ndGggKyBcIiwgcG9pbnRzID0gXCIgKyBzb2x1dGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5uZXJMaW5lcyA9IHNvbHV0aW9uLnNsaWNlKCk7IC8vanVzdCBhIHNoYWxsb3cgY29weVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKklmIGFueSBib3VuZHMganVzdCB0cmltIHRoZSBzb2x1dGlvbi4gU28gd2UgYXZvaWQgdGhlIHN0cmFuZ2UgY2FzZSB3aGVuIGEgY29ubmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqc3RhcnRlcyBmcm9tIGEgcG9pbnQgb24gYSBmaWd1cmUgYW5kIGVuZHMgaW5zaWRlIG9mIHRoZSBzYW1lIGZpZ3VyZSwgYnV0IG5vdCBvbiBhIGNvbm5lY3Rpb24gcG9pbnQqL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlQm91bmRzIHx8IHNCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pMG5uZXJMaW5lcyA9IGlubmVyTGluZXMuc2xpY2UoMCwgaW5uZXJMaW5lcy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJMaW5lcyA9IGlubmVyTGluZXMuc2xpY2UoMSwgaW5uZXJMaW5lcy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9Mb2cuaW5mbyhcIlxcdCBlQm91bmRzIHByZXNlbnQsaW5uZXJMaW5lcyBuci4gcG9pbnRzID0gXCIgKyBpbm5lckxpbmVzLmxlbmd0aCArIFwiLCBwb2ludHMgPSBcIiArIGlubmVyTGluZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL25vdyB0ZXN0IGZvciBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3QgPSBpbnRlcnNlY3QgfHwgVXRpbC5wb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGUoaW5uZXJMaW5lcywgc0JvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdCA9IGludGVyc2VjdCB8fCBVdGlsLnBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZShpbm5lckxpbmVzLCBlQm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW50ZXJzZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vbkludGVyc2VjdGlvblNvbHV0aW9ucy5wdXNoKHNvbHV0aW9uc1tsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vSWYgYWxsIHNvbHV0aW9ucyBpbnRlcnNlY3QgdGhhbiB0aGlzIGlzIGRlc3RpbnkgIDopIGFuZCBqdXN0IGlnbm9yZSB0aGUgaW50ZXJzZWN0aW9uIGZpbHRlclxyXG4gICAgICAgICAgICAgICAgaWYgKG5vbkludGVyc2VjdGlvblNvbHV0aW9ucy5sZW5ndGggIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVhc2lnbiB0byBzb2x1dGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBub25JbnRlcnNlY3Rpb25Tb2x1dGlvbnM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgTG9nLmluZm8oXCJcXG5cXHQgbm9uSW50ZXJzZWN0aW9uU29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy80LiBnZXQgZmlyc3QgY2xhc3Mgb2Ygc29sdXRpb25zIHdpdGggc2FtZSBuciBvZiBwb2ludHMg6YCJ5oup5LiO56ys5LiA5Liq5pa55qGI54K55pWw5LiA5qC35aSa55qE5pa55qGI77yI5Zug5Li656ys5LiA5Liq5pa55qGI54K55pWw5pyA5bCR77yJXHJcbiAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIkdldCBmaXJzdCBjbGFzcyBvZiBzb2x1dGlvbnMgd2l0aCBzYW1lIG5yIG9mIHBvaW50c1wiKTtcclxuICAgICAgICAgICAgICAgIGlmIChzb2x1dGlvbnMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIlRoaXMgaXMgbm90IHBvc3NpYmxlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBmaXJzdFNvbHV0aW9uID0gc29sdXRpb25zWzBdWzJdOyAvL3BpY2sgZmlyc3Qgc29sdXRpb25cclxuICAgICAgICAgICAgICAgIHZhciBuck9mUG9pbnRzID0gZmlyc3RTb2x1dGlvbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2FtZU5yUG9pbnRzU29sdXRpb24gPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHNvbHV0aW9ucy5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc29sdXRpb24ubGVuZ3RoID09IG5yT2ZQb2ludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtZU5yUG9pbnRzU29sdXRpb24ucHVzaChzb2x1dGlvbnNbbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBzYW1lTnJQb2ludHNTb2x1dGlvbjtcclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvKjUuICDorqHnrpfot6/lvoTliIbmlbAg77yM5Y+W5pyA5YiG5pWw6auY55qEXHJcbiAgICAgICAgICAgICAgICAgUGljayB0aGUgZmlyc3Qgc29sdXRpb24gd2l0aCA5MCBkZWdyZWUgYW5nbGVzIChsZXNzIHR1cm5hcm91bmRzKVxyXG4gICAgICAgICAgICAgICAgICppbiBjYXNlIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBzb2x1dGlvbiBpbiBvdXIgY2xhc3NcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTG9nLmluZm8oXCJwaWNrIHRoZSBmaXJzdCBzb2x1dGlvbiB3aXRoIDkwIGRlZ3JlZSBhbmdsZXMgKGxlc3MgdHVybmFyb3VuZHMpXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvbEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgc29sdXRpb25zLmxlbmd0aDsgbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gc29sdXRpb25zW2xdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlsLnNjb3JlUGF0aChzb2x1dGlvbnNbc29sSW5kZXhdWzJdKSA8IFV0aWwuc2NvcmVQYXRoKHNvbHV0aW9uc1tsXVsyXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29sSW5kZXggPSBsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IFtzb2x1dGlvbnNbc29sSW5kZXhdXTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1NNT09USElORyBjdXJ2ZVxyXG4gICAgICAgIGlmICh0eXBlID09PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkge1xyXG4gICAgICAgICAgICB0aGlzLnNtb290aEN1cnZlKHNvbHV0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vRU5EIFNNT09USElORyBjdXJ2ZVxyXG5cclxuICAgICAgICBMb2cuZ3JvdXBFbmQoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNvbHV0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc21vb3RoQ3VydmUgPSBmdW5jdGlvbiAoc29sdXRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbiA9IDM7XHJcblxyXG4gICAgICAgIHN3aXRjaCAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIC8vZG8gbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDE6IC8vYWRkIGludGVybWVkaWF0ZSBwb2ludHNcclxuICAgICAgICAgICAgICAgIC8vQWRkIHRoZSBtaWRkbGUgcG9pbnQgZm9yIHN0YXJ0IGFuZCBlbmQgc2VnbWVudCBzbyB0aGF0IHdlIFwiZm9yY2VcIiB0aGVcclxuICAgICAgICAgICAgICAgIC8vY3VydmUgdG8gYm90aCBjb21lIFwicGVycGVuZGljdWxhclwiIG9uIGJvdW5kcyBhbmQgYWxzbyBtYWtlIHRoZSBjdXJ2ZVxyXG4gICAgICAgICAgICAgICAgLy9cImZsZWVcIiBtb3JlIGZyb20gYm91bmRzIChvbiBleGl0KVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzb2x1dGlvbnMubGVuZ3RoOyBzKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc29sVHVybmluZ1BvaW50cyA9IHNvbHV0aW9uc1tzXVsyXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9maXJzdCBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGExID0gc29sVHVybmluZ1BvaW50c1swXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYTIgPSBzb2xUdXJuaW5nUG9pbnRzWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydE1pZGRsZVBvaW50ID0gVXRpbC5nZXRNaWRkbGUoYTEsIGEyKTtcclxuICAgICAgICAgICAgICAgICAgICBzb2xUdXJuaW5nUG9pbnRzLnNwbGljZSgxLCAwLCBzdGFydE1pZGRsZVBvaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9sYXN0IHNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYTMgPSBzb2xUdXJuaW5nUG9pbnRzW3NvbFR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMl07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGE0ID0gc29sVHVybmluZ1BvaW50c1tzb2xUdXJuaW5nUG9pbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRNaWRkbGVQb2ludCA9IFV0aWwuZ2V0TWlkZGxlKGEzLCBhNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc29sVHVybmluZ1BvaW50cy5zcGxpY2Uoc29sVHVybmluZ1BvaW50cy5sZW5ndGggLSAxLCAwLCBlbmRNaWRkbGVQb2ludCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMjogLy9yZW1vdmUgcG9pbnRzXHJcblxyXG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2goc29sdXRpb25zLCBmdW5jdGlvbihzb2x1dGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2xUeXBlID0gc29sdXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbFR5cGUgPT0gJ3MxJyB8fCBzb2xUeXBlID09ICdzMicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbFR1cm5pbmdQb2ludHMgPSBzb2x1dGlvblsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29sVHVybmluZ1BvaW50cy5zcGxpY2UoMSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbFR1cm5pbmdQb2ludHMuc3BsaWNlKHNvbFR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIC8qcmVtb3ZlIGNvbGluZWFyIHBvaW50IGZvciBzMSBhcyBpdCBzZWVtcyB0aGF0IG1vcmUgY29saW5lYXIgcG9pbnRzIGRvIG5vdCBsb29rIGdvb2RcclxuICAgICAgICAgICAgICAgICAqIG9uIG9yZ2FuaWMgc29sdXRpb25zID46RCovXHJcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChzb2x1dGlvbnMsIGZ1bmN0aW9uKHNvbHV0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbFR5cGUgPSBzb2x1dGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc29sVHlwZSA9PSAnczEnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2xUdXJuaW5nUG9pbnRzID0gc29sdXRpb25bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWR1Y2VkU29sdXRpb24gPSBVdGlsLmNvbGxpbmVhclJlZHVjdGlvbihzb2xUdXJuaW5nUG9pbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29sdXRpb25bMl0gPSByZWR1Y2VkU29sdXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IC8vZW5kIHN3aXRjaFxyXG5cclxuICAgIH1cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9Db25uZWN0aW9uTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDml6Xlv5fnsbtcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIExvZyAgPSB7XHJcbiAgICAgICAgTE9HX0xFVkVMX05PTkUgIDogMCxcclxuXHJcbiAgICAgICAgTE9HX0xFVkVMX0RFQlVHIDogMSxcclxuXHJcbiAgICAgICAgTE9HX0xFVkVMX0lORk8gOiAyLFxyXG5cclxuICAgICAgICBMT0dfTEVWRUxfRVJST1IgOiAzLFxyXG5cclxuICAgICAgICBsZXZlbCA6IHRoaXMuTE9HX0xFVkVMX0VSUk9SLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIGxlc3MgaW1wb3J0YW50IG9mIGFsbCBtZXNzYWdlc1xyXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgLSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWRcclxuICAgICAgICAqKi9cclxuICAgICAgICBkZWJ1ZzogZnVuY3Rpb24gKG1lc3NhZ2Upe1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5sZXZlbCA8PSB0aGlzLkxPR19MRVZFTF9ERUJVRyl7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pbiBGRiBpcyBkZWJ1Z1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlLmRlYnVnID09ICdmdW5jdGlvbicpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNley8vVE9ETzogaW4gSUUgaXMgbG9nXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRoZSBjb21tb25seSB1c2VkIGxvZyBtZXNzYWdlXHJcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZFxyXG4gICAgICAgICoqL1xyXG4gICAgICAgIGluZm8gOiBmdW5jdGlvbiAobWVzc2FnZSl7XHJcbiAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxldmVsIDw9IHRoaXMuTE9HX0xFVkVMX0lORk8pe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIHdvcnNlIGtpbmQgb2YgbWVzc2FnZS4gVXN1YWxseSBhIGNyYXNoXHJcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZFxyXG4gICAgICAgICoqL1xyXG4gICAgICAgIGVycm9yIDogZnVuY3Rpb24gKG1lc3NhZ2Upe1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5sZXZlbCA8PSB0aGlzLkxPR19MRVZFTF9FUlJPUil7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqU3RhcnQgZ3JvdXBpbmcgdGhlIGxvZyBtZXNzYWdlc1xyXG4gICAgICAgICAqQHBhcmFtIHtTdHJpbmd9IHRpdGxlIC0gdGhlIHRpdGxlIG9mIHRoZSBncm91cFxyXG4gICAgICAgICAqQHNlZSA8YSBocmVmPVwiaHR0cDovL2dldGZpcmVidWcuY29tL2xvZ2dpbmdcIj5odHRwOi8vZ2V0ZmlyZWJ1Zy5jb20vbG9nZ2luZzwvYT5cclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZ3JvdXAgOiBmdW5jdGlvbih0aXRsZSl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubGV2ZWwgPD0gdGhpcy5MT0dfTEVWRUxfSU5GTyl7IC8vaWdub3JlIGdyb3VwIGlmIGxldmVsIG5vdCBkZWJ1ZyBvciBpbmZvXHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpeyAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqSWYgd2UgZG8gbm90IHRlc3QgZm9yIGdyb3VwKCkgZnVuY3Rpb24geW91IHdpbGwgZ2V0IGFuIGVycm9yIGluIE9wZXJhXHJcbiAgICAgICAgICAgICAgICAgICAgICphcyBPcGVyYSBoYXMgaXQncyBvd24gY29uc29sZS4uLndoaWNoIGRvZXMgbm90IGhhdmUgYSBncm91cCgpIGZ1bmN0aW9uKi9cclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZS5ncm91cCA9PT0gJ2Z1bmN0aW9uJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXAodGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKkVuZHMgY3VycmVudCBtZXNzYWdlIGdyb3VwaW5nKi9cclxuICAgICAgICBncm91cEVuZCA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubGV2ZWwgPD0gdGhpcy5MT0dfTEVWRUxfSU5GTyl7IC8vaWdub3JlIGdyb3VwIGlmIGxldmVsIG5vdCBkZWJ1ZyBvciBpbmZvXHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKklmIHdlIGRvIG5vdCB0ZXN0IGZvciBncm91cEVuZCgpIGZ1bmN0aW9uIHlvdSB3aWxsIGdldCBhbiBlcnJvciBpbiBPcGVyYVxyXG4gICAgICAgICAgICAgICAgICAgICAqYXMgT3BlcmEgaGFzIGl0J3Mgb3duIGNvbnNvbGUuLi53aGljaCBkb2VzIG5vdCBoYXZlIGEgZ3JvdXAoKSBmdW5jdGlvbiovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUuZ3JvdXBFbmQgPT09ICdmdW5jdGlvbicpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy9Mb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX0RFQlVHOyBcclxuICAgIExvZy5sZXZlbCA9IExvZy5MT0dfTEVWRUxfRVJST1I7IFxyXG4gICAgLy9Mb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX0VSUk9SO1xyXG4gICAgLy9Mb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX05PTkU7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExvZztcclxuICAgIFxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTG9nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOi/nue6v+aTjeS9nOexu1xyXG4gKiBAYXV0aG9yIG1pYW8uY3VuemhpXHJcbiAqL1xyXG5cclxuICAgIHZhciBzeW1ib2xVdGlsID0gcmVxdWlyZSgnLi4vc2hhcGVzL1N5bWJvbCcpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGljb24gPSByZXF1aXJlKCcuL0ljb25PcGVyYXRpb24nKTtcclxuICAgIGZ1bmN0aW9uIExpbmVPcGVyYXRpb25NYW5hZ2VyKGNvbm5lY3Rpb25NYW5hZ2VyLCBhcGkpIHtcclxuICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25zID0gW10sXHJcbiAgICAgICAgdGhpcy5pc0VkaXQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBjb25uZWN0aW9uTWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9hcGkgPSBhcGk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5hZGRJY29uKGtleSwgb3B0aW9ucyk7XHJcbiAgICAgKi9cclxuICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLnByb3RvdHlwZS5hZGRJY29uID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgLy/liKTmlq3mmK/lsI/lm77moIflkKblrZjlnKgg77yM5a2Y5Zyo5YiZ55u05o6l6L+U5ZueXHJcbiAgICAgICAgdmFyIGxpbmVPcGVyYXRpb25JY29uID0genJVdGlsLmZpbmQob3B0aW9ucy5saW5lTm9kZS5pY29ucywgZnVuY3Rpb24oaWNvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gaWNvbi5rZXkgPT09IGtleTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGxpbmVPcGVyYXRpb25JY29uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmluZE9wZXJhdGlvbihvcHRpb25zLmxpbmVOb2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgdmFyIGxpbmVPcGVyYXRpb24gPSB0aGlzLmNyZWF0T3BlcmF0aW9uKGtleSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwaS5fZ2V0UGFyZW50WnIoKS5hZGQobGluZU9wZXJhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuYmluZE9wZXJhdGlvbihvcHRpb25zLmxpbmVOb2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGxpbmVPcGVyYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5wcm90b3R5cGUuY3JlYXRPcGVyYXRpb24gPSBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgbGluZU9wZXJhdGlvbiA9IHN5bWJvbFV0aWwuY3JlYXRlU3ltYm9sKG9wdGlvbnMuaWNvblBhdGgsIDAsIDAsIG9wdGlvbnMud2lkdGggfHwgMTUsIG9wdGlvbnMuaGVpZ2h0IHx8IDE1LCAwLCBvcHRpb25zLmNvbG9yfHwnI2FhYWFhYycpO1xyXG4gICAgICAgIGxpbmVPcGVyYXRpb24ua2V5ID0ga2V5O1xyXG4gICAgICAgIGxpbmVPcGVyYXRpb24uX3dpZHRoID0gIG9wdGlvbnMud2lkdGggfHwgMTU7ICAvLyBwYXRo5oOF5Ya15LiL5peg5rOV6K6h566XXHJcbiAgICAgICAgbGluZU9wZXJhdGlvbi5faXNMaW5lT3BlcmF0aW9uSWNvbiA9IHRydWU7XHJcbiAgICAgICAgbGluZU9wZXJhdGlvbi5oaWRlKCk7XHJcbiAgICAgICAgb3B0aW9ucy5saW5lTm9kZS5pY29ucy5wdXNoKGxpbmVPcGVyYXRpb24pO1xyXG4gICAgICAgIHRoaXMubGluZU9wZXJhdGlvbnMucHVzaChsaW5lT3BlcmF0aW9uKTtcclxuXHJcbiAgICAgICAgLy/lsI/lm77moIcg54K55Ye75LqL5Lu2ICDlpoLmnpzmnInlm57osIPliJnosIPnlKjlm57osIPvvIzlkKbliJnmtL7lj5Hkuovku7ZcclxuICAgICAgICBsaW5lT3BlcmF0aW9uLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEgPSBvcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQubGluZU5vZGUgPSBvcHRpb25zLmxpbmVOb2RlO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhldmVudCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBldmVudDtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJjbGlja1wiO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmVsZW1lbnRUeXBlID0gXCJMaW5lT3BlcmF0aW9uSWNvblwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBpLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIHJldHVybiBsaW5lT3BlcmF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6h566X5bCP5Zu+5qCH55qE5L2N572u77yM5bm25pi+56S6XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNvbm5lY3RvciBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLnByb3RvdHlwZS5iaW5kT3BlcmF0aW9uID0gZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gcGFyZW50WChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC5ub2RlVHlwZSA9PSBcIlN1YlByb2Nlc3NcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zaXRpb25bMF0gKyBwYXJlbnRYKG5vZGUucGFyZW50KVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucG9zaXRpb25bMF1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudFkobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQubm9kZVR5cGUgPT0gXCJTdWJQcm9jZXNzXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzFdICsgcGFyZW50WShub2RlLnBhcmVudClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uWzFdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzRWRpdCA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwb2ludFBvc2l0aW9uID0gY29ubmVjdG9yLm1pZGRsZSgpLCBwb3NYLCBwb3NZO1xyXG4gICAgICAgIGlmIChjb25uZWN0b3IucGFyZW50ICYmIGNvbm5lY3Rvci5wYXJlbnQubm9kZVR5cGUgPT0gXCJTdWJQcm9jZXNzXCIpIHtcclxuICAgICAgICAgICAgcG9zWCA9IHBvaW50UG9zaXRpb25bMF0gKyBwYXJlbnRYKGNvbm5lY3Rvci5wYXJlbnQpO1xyXG4gICAgICAgICAgICBwb3NZID0gcG9pbnRQb3NpdGlvblsxXSArIHBhcmVudFkoY29ubmVjdG9yLnBhcmVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcG9zWCA9IHBvaW50UG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgIHBvc1kgPSBwb2ludFBvc2l0aW9uWzFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGFyckxlbmd0aCA9IHpyVXRpbC5tYXAoY29ubmVjdG9yLmljb25zLCBmdW5jdGlvbihpY29uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpY29uLl93aWR0aDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIHRvdGFsTGVuZ3RoID0genJVdGlsLnJlZHVjZShhcnJMZW5ndGgsIGZ1bmN0aW9uKHByZXZpb3VzVmFsdWUsY3VycmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlICsgY3VycmVudFZhbHVlICsgMTA7XHJcbiAgICAgICAgfSwgMCApO1xyXG5cclxuICAgICAgICB6clV0aWwuZWFjaChjb25uZWN0b3IuaWNvbnMsIGZ1bmN0aW9uKGljb24sIGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3JQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaW5kZXg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yUG9zaXRpb24gKz0gYXJyTGVuZ3RoW2tdICsgMTA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWNvbi5hdHRyKFwicG9zaXRpb25cIiwgW3Bvc1ggKyBjb25uZWN0b3JQb3NpdGlvbiAtIHRvdGFsTGVuZ3RoIC8gMiwgcG9zWSArIDVdKTtcclxuICAgICAgICAgICAgaWNvbi5zaG93KCk7XHJcbiAgICAgICAgICAgIGljb24uYXR0YWNoTGluZSA9IGNvbm5lY3RvcjtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLnByb3RvdHlwZS5oaWRlQWxsTGluZU9wZXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHpyVXRpbC5lYWNoKHRoaXMubGluZU9wZXJhdGlvbnMsIGZ1bmN0aW9uKGxpbmVPcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgbGluZU9wZXJhdGlvbi5oaWRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgTGluZU9wZXJhdGlvbk1hbmFnZXIucHJvdG90eXBlLmFkZERlbGV0ZUljb24gPSBmdW5jdGlvbihsaW5lTm9kZSxvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB6clV0aWwuZGVmYXVsdHMoe1xyXG4gICAgICAgICAgICBpY29uUGF0aDogJ3BhdGg6Ly8nICsgaWNvbi5ERUxfU1ZHLFxyXG4gICAgICAgICAgICB3aWR0aDogMTIsXHJcbiAgICAgICAgICAgIGhlaWdodDogMTQsXHJcbiAgICAgICAgICAgIGxpbmVOb2RlOiBsaW5lTm9kZSxcclxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaS5yZW1vdmUoZS50YXJnZXQuYXR0YWNoTGluZSk7Ly90aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnNlbENvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgIH0sIG9wdGlvbnMsdHJ1ZSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkSWNvbihcImRlbGV0ZVwiLCBvcHRzKTtcclxuICAgIH1cclxuXHJcbiAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5wcm90b3R5cGUuYWRkQ2hhbmdlTGluZVR5cGVJY29uID0gZnVuY3Rpb24obGluZU5vZGUsb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHRzID0genJVdGlsLmRlZmF1bHRzKHtcclxuICAgICAgICAgICAgaWNvblBhdGg6ICdwYXRoOi8vJyArIGljb24uQ0hBTkdFX0xJTkVfVFlQRV9TVkcsXHJcbiAgICAgICAgICAgIHdpZHRoOiAxNSxcclxuICAgICAgICAgICAgaGVpZ2h0OiAxNSxcclxuICAgICAgICAgICAgbGluZU5vZGU6IGxpbmVOb2RlLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBpLmNoYW5nZVNlbGVjdENvbm5lY3RvclR5cGUoKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICAgICAgfSwgb3B0aW9ucyx0cnVlKTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRJY29uKFwiY2hhbmdlXCIsIG9wdHMpXHJcbiAgICB9XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaW5lT3BlcmF0aW9uTWFuYWdlcjtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0xpbmVPcGVyYXRpb25NYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOi+heWKqee6v+aTjeS9nOexu1xyXG4gKiBAYXV0aG9yIG1pYW8uY3VuemhpXHJcbiAqL1xyXG5cclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIHZpcnR1YWxYTmFtZXMgPSBbJ3ZpcnR1YWxYVG9wJywgJ3ZpcnR1YWxYQ2VudGVyJywgJ3ZpcnR1YWxYQm90dG9tJ107XHJcbiAgICB2YXIgdmlydHVhbFlOYW1lcyA9IFsndmlydHVhbFlMZWZ0JywgJ3ZpcnR1YWxZQ2VudGVyJywgJ3ZpcnR1YWxZUmlnaHQnXTtcclxuXHJcbiAgICB2YXIgR3VpZGVsaW5lcyA9IHtcclxuICAgICAgICB2aXJ0dWFsWExpbmVzOiBbXSxcclxuICAgICAgICB2aXJ0dWFsWUxpbmVzOiBbXSxcclxuICAgICAgICBjcmVhdGVMaW5lOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgdmlydHVhbExpbmUgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiM1NjkzZjc4Y1wiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgejogMyxcclxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB2aXJ0dWFsTGluZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNyZWF0ZUd1aWRlbGluZXM6IGZ1bmN0aW9uICh6cikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy52aXJ0dWFsWExpbmVzLmxlbmd0aCA8IDMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlydHVhbFhMaW5lcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy/liJvlu7p46L206Jma57q/XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4TGluZSA9IHRoaXMuY3JlYXRlTGluZSh2aXJ0dWFsWE5hbWVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpcnR1YWxYTGluZXMucHVzaCh4TGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgenIuYWRkKHhMaW5lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy52aXJ0dWFsWUxpbmVzLmxlbmd0aCA8IDMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlydHVhbFlMaW5lcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy/liJvlu7pZ6L206Jma57q/XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB5TGluZSA9IHRoaXMuY3JlYXRlTGluZSh2aXJ0dWFsWU5hbWVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpcnR1YWxZTGluZXMucHVzaCh5TGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgenIuYWRkKHlMaW5lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlc2V0TGluZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgenJVdGlsLmVhY2godGhpcy52aXJ0dWFsWExpbmVzLCBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtLmF0dHIoXCJzaGFwZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDI6IDBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgenJVdGlsLmVhY2godGhpcy52aXJ0dWFsWUxpbmVzLCBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtLmF0dHIoXCJzaGFwZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgeTI6IDBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc3RvcnlMaW5lczogZnVuY3Rpb24oenIpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCB0aGlzLnZpcnR1YWxYTGluZXMubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICAgICAgICAgIHpyLnJlbW92ZSh0aGlzLnZpcnR1YWxYTGluZXNbbV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdGhpcy52aXJ0dWFsWUxpbmVzLmxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICB6ci5yZW1vdmUodGhpcy52aXJ0dWFsWUxpbmVzW25dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxYTGluZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsWUxpbmVzID0gW107XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRNaW5NYXg6IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICAgICAgIHZhciBtaW5YID0gcG9pbnRzWzBdLngsXHJcbiAgICAgICAgICAgICAgIG1pblkgPSBwb2ludHNbMF0ueSxcclxuICAgICAgICAgICAgICAgbWF4WCA9IHBvaW50c1swXS54LFxyXG4gICAgICAgICAgICAgICBtYXhZID0gcG9pbnRzWzBdLnk7XHJcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHBvaW50cywgZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pblggPiBpdGVtLngpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5YID0gaXRlbS54O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1pblkgPiBpdGVtLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0gaXRlbS55O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1heFggPCBpdGVtLngpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhYID0gaXRlbS54O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1heFkgPCBpdGVtLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhZID0gaXRlbS55O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG1pblg6IG1pblgsXHJcbiAgICAgICAgICAgICAgICBtaW5ZOiBtaW5ZLFxyXG4gICAgICAgICAgICAgICAgbWF4WDogbWF4WCxcclxuICAgICAgICAgICAgICAgIG1heFk6IG1heFlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAganVkZ2VBbGlnbm1lbnQ6IGZ1bmN0aW9uIChzZWxlY3RlZE5vZGUsIG5vd1JlY3RQb3NpdGlvbiwgZG9tQXJyYXksIG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgcm90YXRpb24gPSBzZWxlY3RlZE5vZGUucm90YXRpb247XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXREb20gPSB6clV0aWwuZmluZChkb21BcnJheSwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmlkID09IHNlbGVjdGVkTm9kZS5pZDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0RG9tKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRhcmdldERvbS5wb2ludHM7XHJcbiAgICAgICAgICAgIHZhciBlbmRQb2ludEN1cnJlbnQgPSB7fTtcclxuICAgICAgICAgICAgcG9pbnRzWzBdLnggPSBub3dSZWN0UG9zaXRpb25bMF0gLSB0YXJnZXREb20ud2lkdGggLyAyO1xyXG4gICAgICAgICAgICBwb2ludHNbMF0ueSA9IG5vd1JlY3RQb3NpdGlvblsxXSAtIHRhcmdldERvbS5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBwb2ludHNbMV0ueCA9IG5vd1JlY3RQb3NpdGlvblswXSArIHRhcmdldERvbS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIHBvaW50c1sxXS55ID0gbm93UmVjdFBvc2l0aW9uWzFdIC0gdGFyZ2V0RG9tLmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIHBvaW50c1syXS54ID0gbm93UmVjdFBvc2l0aW9uWzBdIC0gdGFyZ2V0RG9tLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgcG9pbnRzWzJdLnkgPSBub3dSZWN0UG9zaXRpb25bMV0gKyB0YXJnZXREb20uaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgcG9pbnRzWzNdLnggPSBub3dSZWN0UG9zaXRpb25bMF0gKyB0YXJnZXREb20ud2lkdGggLyAyO1xyXG4gICAgICAgICAgICBwb2ludHNbM10ueSA9IG5vd1JlY3RQb3NpdGlvblsxXSArIHRhcmdldERvbS5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMocm90YXRpb24pID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1BvaW50cyA9IFtdXHJcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChwb2ludHMsIGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BvaW50ID0gdXRpbC5jYWxjdWxhdGVQb2ludHMocG9pbnQsIHsgeDogbm93UmVjdFBvc2l0aW9uWzBdLCB5OiBub3dSZWN0UG9zaXRpb25bMV0gfSwgcm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQobmV3UG9pbnQueCwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gcGFyc2VJbnQobmV3UG9pbnQueSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKHt4OiB4LCB5OiB5fSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGVuZFBvaW50Q3VycmVudCA9IHRoaXMuZ2V0TWluTWF4KG5ld1BvaW50cyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbmRQb2ludEN1cnJlbnQgPSB0aGlzLmdldE1pbk1heChwb2ludHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOmHjee9rlxyXG4gICAgICAgICAgICB0aGlzLnJlc2V0TGluZXMoKTtcclxuICAgICAgICAgICAgenJVdGlsLmVhY2goZG9tQXJyYXksIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pZCAhPSB0YXJnZXREb20uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRQb2ludHMgPSB0aGF0LmdldE1pbk1heChpdGVtLnBvaW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaG9yaXpvbnRhbFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyDmnIDpobbpg6jmsLTlubPlr7npvZBcclxuICAgICAgICAgICAgICAgICAgICAvLyDlvZPliY3mnIDpobbpg6jkuI7nm67moIfkuK3ngrnmsLTlubPlr7npvZBcclxuICAgICAgICAgICAgICAgICAgICAvLyDlvZPliY3mnIDpobbpg6jkuI7nm67moIfmnIDlupXpg6jmsLTlubPlr7npvZBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGVuZFBvaW50Q3VycmVudC5taW5ZID09IGVuZFBvaW50cy5taW5ZKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAoZW5kUG9pbnRDdXJyZW50Lm1pblkgPT0gcG9zaXRpb25bMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IChlbmRQb2ludEN1cnJlbnQubWluWSA9PSBlbmRQb2ludHMubWF4WSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC52aXJ0dWFsWExpbmVzWzBdLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFswLCBlbmRQb2ludEN1cnJlbnQubWluWV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyOiBtYXhXaWR0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5Lit54K55rC05bmz5a+56b2QXHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5b2T5YmN5Lit54K55LiO55uu5qCH5pyA6aG26YOo5rC05bmz5a+56b2QXHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5b2T5YmN5Lit54K55LiO55uu5qCH5pyA5bqV6YOo5rC05bmz5a+56b2QXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChub3dSZWN0UG9zaXRpb25bMV0gPT0gcG9zaXRpb25bMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IChub3dSZWN0UG9zaXRpb25bMV0gPT0gZW5kUG9pbnRzLm1pblkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IChub3dSZWN0UG9zaXRpb25bMV0gPT0gZW5kUG9pbnRzLm1heFkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudmlydHVhbFhMaW5lc1sxXS5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbMCwgbm93UmVjdFBvc2l0aW9uWzFdXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDI6IG1heFdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyDmnIDlupXpg6jmsLTlubPlr7npvZBcclxuICAgICAgICAgICAgICAgICAgICAvLyDlvZPliY3mnIDlupXpg6jkuI7nm67moIfkuK3ngrnmsLTlubPlr7npvZBcclxuICAgICAgICAgICAgICAgICAgICAvLyDlvZPliY3mnIDlupXpg6jkuI7nm67moIfmnIDpobbpg6jmsLTlubPlr7npvZBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGVuZFBvaW50Q3VycmVudC5tYXhZID09IGVuZFBvaW50cy5tYXhZKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAoZW5kUG9pbnRDdXJyZW50Lm1heFkgPT0gcG9zaXRpb25bMV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IChlbmRQb2ludEN1cnJlbnQubWF4WSA9PSBlbmRQb2ludHMubWluWSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC52aXJ0dWFsWExpbmVzWzJdLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFswLCBlbmRQb2ludEN1cnJlbnQubWF4WV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyOiBtYXhXaWR0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdmVydGljYWxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5pyA5bem5L6n5Z6C55u05a+56b2QXHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5b2T5YmN5pyA5bem5L6n5LiO55uu5qCH5Lit54K55Z6C55u05a+56b2QXHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5b2T5YmN5pyA5bem5L6n5LiO55uu5qCH5pyA5Y+z5L6n5Z6C55u05a+56b2QXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChlbmRQb2ludEN1cnJlbnQubWluWCA9PSBlbmRQb2ludHMubWluWClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGVuZFBvaW50Q3VycmVudC5taW5YID09IHBvc2l0aW9uWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAoZW5kUG9pbnRDdXJyZW50Lm1pblggPT0gZW5kUG9pbnRzLm1heFgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudmlydHVhbFlMaW5lc1swXS5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbZW5kUG9pbnRDdXJyZW50Lm1pblgsIDBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MjogbWF4SGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyDkuK3ngrnlnoLnm7Tlr7npvZBcclxuICAgICAgICAgICAgICAgICAgICAvLyDlvZPliY3kuK3ngrnkuI7nm67moIfmnIDlt6bkvqflnoLnm7Tlr7npvZBcclxuICAgICAgICAgICAgICAgICAgICAvLyDlvZPliY3kuK3ngrnkuI7nm67moIfmnIDlj7PkvqflnoLnm7Tlr7npvZBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKG5vd1JlY3RQb3NpdGlvblswXSA9PSBwb3NpdGlvblswXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKG5vd1JlY3RQb3NpdGlvblswXSA9PSBlbmRQb2ludHMubWluWClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKG5vd1JlY3RQb3NpdGlvblswXSA9PSBlbmRQb2ludHMubWF4WCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC52aXJ0dWFsWUxpbmVzWzFdLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFtub3dSZWN0UG9zaXRpb25bMF0sIDBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MjogbWF4SGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyDmnIDlj7PkvqflnoLnm7Tlr7npvZBcclxuICAgICAgICAgICAgICAgICAgICAvLyDlvZPliY3mnIDlj7PkvqfkuI7nm67moIfkuK3ngrnlnoLnm7Tlr7npvZBcclxuICAgICAgICAgICAgICAgICAgICAvLyDlvZPliY3mnIDlj7PkvqfkuI7nm67moIfmnIDlt6bkvqflnoLnm7Tlr7npvZBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGVuZFBvaW50Q3VycmVudC5tYXhYID09IGVuZFBvaW50cy5tYXhYKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAoZW5kUG9pbnRDdXJyZW50Lm1heFggPT0gcG9zaXRpb25bMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IChlbmRQb2ludEN1cnJlbnQubWF4WCA9PSBlbmRQb2ludHMubWluWCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC52aXJ0dWFsWUxpbmVzWzJdLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFtlbmRQb2ludEN1cnJlbnQubWF4WCwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyOiBtYXhIZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gR3VpZGVsaW5lcztcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0d1aWRlbGluZXMuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBvbGQ7XG5pZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIpIG9sZCA9IFByb21pc2U7XG5mdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgIHRyeSB7IGlmIChQcm9taXNlID09PSBibHVlYmlyZCkgUHJvbWlzZSA9IG9sZDsgfVxuICAgIGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBibHVlYmlyZDtcbn1cbnZhciBibHVlYmlyZCA9IHJlcXVpcmUoXCIuL3Byb21pc2VcIikoKTtcbmJsdWViaXJkLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xubW9kdWxlLmV4cG9ydHMgPSBibHVlYmlyZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2JsdWViaXJkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xudmFyIG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiY2lyY3VsYXIgcHJvbWlzZSByZXNvbHV0aW9uIGNoYWluXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbn07XG52YXIgcmVmbGVjdEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UuUHJvbWlzZUluc3BlY3Rpb24odGhpcy5fdGFyZ2V0KCkpO1xufTtcbnZhciBhcGlSZWplY3Rpb24gPSBmdW5jdGlvbihtc2cpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihtc2cpKTtcbn07XG5mdW5jdGlvbiBQcm94eWFibGUoKSB7fVxudmFyIFVOREVGSU5FRF9CSU5ESU5HID0ge307XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBnZXREb21haW47XG5pZiAodXRpbC5pc05vZGUpIHtcbiAgICBnZXREb21haW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJldCA9IHByb2Nlc3MuZG9tYWluO1xuICAgICAgICBpZiAocmV0ID09PSB1bmRlZmluZWQpIHJldCA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgZ2V0RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG51dGlsLm5vdEVudW1lcmFibGVQcm9wKFByb21pc2UsIFwiX2dldERvbWFpblwiLCBnZXREb21haW4pO1xuXG52YXIgZXM1ID0gcmVxdWlyZShcIi4vZXM1XCIpO1xudmFyIEFzeW5jID0gcmVxdWlyZShcIi4vYXN5bmNcIik7XG52YXIgYXN5bmMgPSBuZXcgQXN5bmMoKTtcbmVzNS5kZWZpbmVQcm9wZXJ0eShQcm9taXNlLCBcIl9hc3luY1wiLCB7dmFsdWU6IGFzeW5jfSk7XG52YXIgZXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIFR5cGVFcnJvciA9IFByb21pc2UuVHlwZUVycm9yID0gZXJyb3JzLlR5cGVFcnJvcjtcblByb21pc2UuUmFuZ2VFcnJvciA9IGVycm9ycy5SYW5nZUVycm9yO1xudmFyIENhbmNlbGxhdGlvbkVycm9yID0gUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvciA9IGVycm9ycy5DYW5jZWxsYXRpb25FcnJvcjtcblByb21pc2UuVGltZW91dEVycm9yID0gZXJyb3JzLlRpbWVvdXRFcnJvcjtcblByb21pc2UuT3BlcmF0aW9uYWxFcnJvciA9IGVycm9ycy5PcGVyYXRpb25hbEVycm9yO1xuUHJvbWlzZS5SZWplY3Rpb25FcnJvciA9IGVycm9ycy5PcGVyYXRpb25hbEVycm9yO1xuUHJvbWlzZS5BZ2dyZWdhdGVFcnJvciA9IGVycm9ycy5BZ2dyZWdhdGVFcnJvcjtcbnZhciBJTlRFUk5BTCA9IGZ1bmN0aW9uKCl7fTtcbnZhciBBUFBMWSA9IHt9O1xudmFyIE5FWFRfRklMVEVSID0ge307XG52YXIgdHJ5Q29udmVydFRvUHJvbWlzZSA9IHJlcXVpcmUoXCIuL3RoZW5hYmxlc1wiKShQcm9taXNlLCBJTlRFUk5BTCk7XG52YXIgUHJvbWlzZUFycmF5ID1cbiAgICByZXF1aXJlKFwiLi9wcm9taXNlX2FycmF5XCIpKFByb21pc2UsIElOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbiwgUHJveHlhYmxlKTtcbnZhciBDb250ZXh0ID0gcmVxdWlyZShcIi4vY29udGV4dFwiKShQcm9taXNlKTtcbiAvKmpzaGludCB1bnVzZWQ6ZmFsc2UqL1xudmFyIGNyZWF0ZUNvbnRleHQgPSBDb250ZXh0LmNyZWF0ZTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoXCIuL2RlYnVnZ2FiaWxpdHlcIikoUHJvbWlzZSwgQ29udGV4dCk7XG52YXIgQ2FwdHVyZWRUcmFjZSA9IGRlYnVnLkNhcHR1cmVkVHJhY2U7XG52YXIgUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dCA9XG4gICAgcmVxdWlyZShcIi4vZmluYWxseVwiKShQcm9taXNlLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBORVhUX0ZJTFRFUik7XG52YXIgY2F0Y2hGaWx0ZXIgPSByZXF1aXJlKFwiLi9jYXRjaF9maWx0ZXJcIikoTkVYVF9GSUxURVIpO1xudmFyIG5vZGViYWNrRm9yUHJvbWlzZSA9IHJlcXVpcmUoXCIuL25vZGViYWNrXCIpO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG5mdW5jdGlvbiBjaGVjayhzZWxmLCBleGVjdXRvcikge1xuICAgIGlmIChzZWxmID09IG51bGwgfHwgc2VsZi5jb25zdHJ1Y3RvciAhPT0gUHJvbWlzZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidGhlIHByb21pc2UgY29uc3RydWN0b3IgY2Fubm90IGJlIGludm9rZWQgZGlyZWN0bHlcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGV4ZWN1dG9yKSk7XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBpZiAoZXhlY3V0b3IgIT09IElOVEVSTkFMKSB7XG4gICAgICAgIGNoZWNrKHRoaXMsIGV4ZWN1dG9yKTtcbiAgICB9XG4gICAgdGhpcy5fYml0RmllbGQgPSAwO1xuICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcHJvbWlzZTAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVjZWl2ZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Jlc29sdmVGcm9tRXhlY3V0b3IoZXhlY3V0b3IpO1xuICAgIHRoaXMuX3Byb21pc2VDcmVhdGVkKCk7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZUNyZWF0ZWRcIiwgdGhpcyk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgUHJvbWlzZV1cIjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmNhdWdodCA9IFByb21pc2UucHJvdG90eXBlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMSkge1xuICAgICAgICB2YXIgY2F0Y2hJbnN0YW5jZXMgPSBuZXcgQXJyYXkobGVuIC0gMSksXG4gICAgICAgICAgICBqID0gMCwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7ICsraSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAodXRpbC5pc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgICAgIGNhdGNoSW5zdGFuY2VzW2orK10gPSBpdGVtO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiQ2F0Y2ggc3RhdGVtZW50IHByZWRpY2F0ZTogXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImV4cGVjdGluZyBhbiBvYmplY3QgYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoaXRlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoSW5zdGFuY2VzLmxlbmd0aCA9IGo7XG4gICAgICAgIGZuID0gYXJndW1lbnRzW2ldO1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgY2F0Y2hGaWx0ZXIoY2F0Y2hJbnN0YW5jZXMsIGZuLCB0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBmbik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yZWZsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl90aGVuKHJlZmxlY3RIYW5kbGVyLFxuICAgICAgICByZWZsZWN0SGFuZGxlciwgdW5kZWZpbmVkLCB0aGlzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChkaWRGdWxmaWxsLCBkaWRSZWplY3QpIHtcbiAgICBpZiAoZGVidWcud2FybmluZ3MoKSAmJiBhcmd1bWVudHMubGVuZ3RoID4gMCAmJlxuICAgICAgICB0eXBlb2YgZGlkRnVsZmlsbCAhPT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiBkaWRSZWplY3QgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgbXNnID0gXCIudGhlbigpIG9ubHkgYWNjZXB0cyBmdW5jdGlvbnMgYnV0IHdhcyBwYXNzZWQ6IFwiICtcbiAgICAgICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKGRpZEZ1bGZpbGwpO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIG1zZyArPSBcIiwgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGRpZFJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2Fybihtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGhlbihkaWRGdWxmaWxsLCBkaWRSZWplY3QsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChkaWRGdWxmaWxsLCBkaWRSZWplY3QpIHtcbiAgICB2YXIgcHJvbWlzZSA9XG4gICAgICAgIHRoaXMuX3RoZW4oZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICBwcm9taXNlLl9zZXRJc0ZpbmFsKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zcHJlYWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFsbCgpLl90aGVuKGZuLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgQVBQTFksIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJldCA9IHtcbiAgICAgICAgaXNGdWxmaWxsZWQ6IGZhbHNlLFxuICAgICAgICBpc1JlamVjdGVkOiBmYWxzZSxcbiAgICAgICAgZnVsZmlsbG1lbnRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICByZWplY3Rpb25SZWFzb246IHVuZGVmaW5lZFxuICAgIH07XG4gICAgaWYgKHRoaXMuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICByZXQuZnVsZmlsbG1lbnRWYWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgcmV0LmlzRnVsZmlsbGVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIHJldC5yZWplY3Rpb25SZWFzb24gPSB0aGlzLnJlYXNvbigpO1xuICAgICAgICByZXQuaXNSZWplY3RlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3dhcm4oXCIuYWxsKCkgd2FzIHBhc3NlZCBhcmd1bWVudHMgYnV0IGl0IGRvZXMgbm90IHRha2UgYW55XCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2VBcnJheSh0aGlzKS5wcm9taXNlKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiB0aGlzLmNhdWdodCh1dGlsLm9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uLCBmbik7XG59O1xuXG5Qcm9taXNlLmdldE5ld0xpYnJhcnlDb3B5ID0gbW9kdWxlLmV4cG9ydHM7XG5cblByb21pc2UuaXMgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIFByb21pc2U7XG59O1xuXG5Qcm9taXNlLmZyb21Ob2RlID0gUHJvbWlzZS5mcm9tQ2FsbGJhY2sgPSBmdW5jdGlvbihmbikge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHZhciBtdWx0aUFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/ICEhT2JqZWN0KGFyZ3VtZW50c1sxXSkubXVsdGlBcmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKGZuKShub2RlYmFja0ZvclByb21pc2UocmV0LCBtdWx0aUFyZ3MpKTtcbiAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICByZXQuX3JlamVjdENhbGxiYWNrKHJlc3VsdC5lLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKCFyZXQuX2lzRmF0ZVNlYWxlZCgpKSByZXQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZUFycmF5KHByb21pc2VzKS5wcm9taXNlKCk7XG59O1xuXG5Qcm9taXNlLmNhc3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJldCA9IHRyeUNvbnZlcnRUb1Byb21pc2Uob2JqKTtcbiAgICBpZiAoIShyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgcmV0Ll9zZXRGdWxmaWxsZWQoKTtcbiAgICAgICAgcmV0Ll9yZWplY3Rpb25IYW5kbGVyMCA9IG9iajtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucmVzb2x2ZSA9IFByb21pc2UuZnVsZmlsbGVkID0gUHJvbWlzZS5jYXN0O1xuXG5Qcm9taXNlLnJlamVjdCA9IFByb21pc2UucmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgcmV0Ll9yZWplY3RDYWxsYmFjayhyZWFzb24sIHRydWUpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnNldFNjaGVkdWxlciA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICByZXR1cm4gYXN5bmMuc2V0U2NoZWR1bGVyKGZuKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl90aGVuID0gZnVuY3Rpb24gKFxuICAgIGRpZEZ1bGZpbGwsXG4gICAgZGlkUmVqZWN0LFxuICAgIF8sICAgIHJlY2VpdmVyLFxuICAgIGludGVybmFsRGF0YVxuKSB7XG4gICAgdmFyIGhhdmVJbnRlcm5hbERhdGEgPSBpbnRlcm5hbERhdGEgIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgcHJvbWlzZSA9IGhhdmVJbnRlcm5hbERhdGEgPyBpbnRlcm5hbERhdGEgOiBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCgpO1xuICAgIHZhciBiaXRGaWVsZCA9IHRhcmdldC5fYml0RmllbGQ7XG5cbiAgICBpZiAoIWhhdmVJbnRlcm5hbERhdGEpIHtcbiAgICAgICAgcHJvbWlzZS5fcHJvcGFnYXRlRnJvbSh0aGlzLCAzKTtcbiAgICAgICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICgodGhpcy5fYml0RmllbGQgJiAyMDk3MTUyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIGlmICghKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlciA9IHRoaXMuX2JvdW5kVmFsdWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0YXJnZXQgPT09IHRoaXMgPyB1bmRlZmluZWQgOiB0aGlzLl9ib3VuZFRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VDaGFpbmVkXCIsIHRoaXMsIHByb21pc2UpO1xuICAgIH1cblxuICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICBpZiAoISgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgIHZhciBoYW5kbGVyLCB2YWx1ZSwgc2V0dGxlciA9IHRhcmdldC5fc2V0dGxlUHJvbWlzZUN0eDtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRhcmdldC5fcmVqZWN0aW9uSGFuZGxlcjA7XG4gICAgICAgICAgICBoYW5kbGVyID0gZGlkRnVsZmlsbDtcbiAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0YXJnZXQuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgICAgICAgICBoYW5kbGVyID0gZGlkUmVqZWN0O1xuICAgICAgICAgICAgdGFyZ2V0Ll91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXR0bGVyID0gdGFyZ2V0Ll9zZXR0bGVQcm9taXNlTGF0ZUNhbmNlbGxhdGlvbk9ic2VydmVyO1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoXCJsYXRlIGNhbmNlbGxhdGlvbiBvYnNlcnZlclwiKTtcbiAgICAgICAgICAgIHRhcmdldC5fYXR0YWNoRXh0cmFUcmFjZSh2YWx1ZSk7XG4gICAgICAgICAgICBoYW5kbGVyID0gZGlkUmVqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMuaW52b2tlKHNldHRsZXIsIHRhcmdldCwge1xuICAgICAgICAgICAgaGFuZGxlcjogZG9tYWluID09PSBudWxsID8gaGFuZGxlclxuICAgICAgICAgICAgICAgIDogKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgaGFuZGxlcikpLFxuICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcbiAgICAgICAgICAgIHJlY2VpdmVyOiByZWNlaXZlcixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXQuX2FkZENhbGxiYWNrcyhkaWRGdWxmaWxsLCBkaWRSZWplY3QsIHByb21pc2UsIHJlY2VpdmVyLCBkb21haW4pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2xlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYml0RmllbGQgJiA2NTUzNTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0ZhdGVTZWFsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDExNzUwNjA0OCkgIT09IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGb2xsb3dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDY3MTA4ODY0KSA9PT0gNjcxMDg4NjQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0TGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gKHRoaXMuX2JpdEZpZWxkICYgLTY1NTM2KSB8XG4gICAgICAgIChsZW4gJiA2NTUzNSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0RnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAzMzU1NDQzMjtcbiAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlRnVsZmlsbGVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFJlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxNjc3NzIxNjtcbiAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlUmVqZWN0ZWRcIiwgdGhpcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0Rm9sbG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA2NzEwODg2NDtcbiAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlUmVzb2x2ZWRcIiwgdGhpcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0SXNGaW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNDE5NDMwNDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA0MTk0MzA0KSA+IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH42NTUzNik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDY1NTM2O1xuICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VDYW5jZWxsZWRcIiwgdGhpcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0V2lsbEJlQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDgzODg2MDg7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0QXN5bmNHdWFyYW50ZWVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGFzeW5jLmhhc0N1c3RvbVNjaGVkdWxlcigpKSByZXR1cm47XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDEzNDIxNzcyODtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWNlaXZlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIHJldCA9IGluZGV4ID09PSAwID8gdGhpcy5fcmVjZWl2ZXIwIDogdGhpc1tcbiAgICAgICAgICAgIGluZGV4ICogNCAtIDQgKyAzXTtcbiAgICBpZiAocmV0ID09PSBVTkRFRklORURfQklORElORykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAocmV0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5faXNCb3VuZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZFZhbHVlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcHJvbWlzZUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgMl07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZnVsZmlsbG1lbnRIYW5kbGVyQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpc1tcbiAgICAgICAgICAgIGluZGV4ICogNCAtIDQgKyAwXTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWplY3Rpb25IYW5kbGVyQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpc1tcbiAgICAgICAgICAgIGluZGV4ICogNCAtIDQgKyAxXTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9ib3VuZFZhbHVlID0gZnVuY3Rpb24oKSB7fTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX21pZ3JhdGVDYWxsYmFjazAgPSBmdW5jdGlvbiAoZm9sbG93ZXIpIHtcbiAgICB2YXIgYml0RmllbGQgPSBmb2xsb3dlci5fYml0RmllbGQ7XG4gICAgdmFyIGZ1bGZpbGwgPSBmb2xsb3dlci5fZnVsZmlsbG1lbnRIYW5kbGVyMDtcbiAgICB2YXIgcmVqZWN0ID0gZm9sbG93ZXIuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgIHZhciBwcm9taXNlID0gZm9sbG93ZXIuX3Byb21pc2UwO1xuICAgIHZhciByZWNlaXZlciA9IGZvbGxvd2VyLl9yZWNlaXZlckF0KDApO1xuICAgIGlmIChyZWNlaXZlciA9PT0gdW5kZWZpbmVkKSByZWNlaXZlciA9IFVOREVGSU5FRF9CSU5ESU5HO1xuICAgIHRoaXMuX2FkZENhbGxiYWNrcyhmdWxmaWxsLCByZWplY3QsIHByb21pc2UsIHJlY2VpdmVyLCBudWxsKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9taWdyYXRlQ2FsbGJhY2tBdCA9IGZ1bmN0aW9uIChmb2xsb3dlciwgaW5kZXgpIHtcbiAgICB2YXIgZnVsZmlsbCA9IGZvbGxvd2VyLl9mdWxmaWxsbWVudEhhbmRsZXJBdChpbmRleCk7XG4gICAgdmFyIHJlamVjdCA9IGZvbGxvd2VyLl9yZWplY3Rpb25IYW5kbGVyQXQoaW5kZXgpO1xuICAgIHZhciBwcm9taXNlID0gZm9sbG93ZXIuX3Byb21pc2VBdChpbmRleCk7XG4gICAgdmFyIHJlY2VpdmVyID0gZm9sbG93ZXIuX3JlY2VpdmVyQXQoaW5kZXgpO1xuICAgIGlmIChyZWNlaXZlciA9PT0gdW5kZWZpbmVkKSByZWNlaXZlciA9IFVOREVGSU5FRF9CSU5ESU5HO1xuICAgIHRoaXMuX2FkZENhbGxiYWNrcyhmdWxmaWxsLCByZWplY3QsIHByb21pc2UsIHJlY2VpdmVyLCBudWxsKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9hZGRDYWxsYmFja3MgPSBmdW5jdGlvbiAoXG4gICAgZnVsZmlsbCxcbiAgICByZWplY3QsXG4gICAgcHJvbWlzZSxcbiAgICByZWNlaXZlcixcbiAgICBkb21haW5cbikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX2xlbmd0aCgpO1xuXG4gICAgaWYgKGluZGV4ID49IDY1NTM1IC0gNCkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX3NldExlbmd0aCgwKTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgdGhpcy5fcHJvbWlzZTAgPSBwcm9taXNlO1xuICAgICAgICB0aGlzLl9yZWNlaXZlcjAgPSByZWNlaXZlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmdWxmaWxsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjAgPVxuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gbnVsbCA/IGZ1bGZpbGwgOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmdWxmaWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJlamVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCA9XG4gICAgICAgICAgICAgICAgZG9tYWluID09PSBudWxsID8gcmVqZWN0IDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBiYXNlID0gaW5kZXggKiA0IC0gNDtcbiAgICAgICAgdGhpc1tiYXNlICsgMl0gPSBwcm9taXNlO1xuICAgICAgICB0aGlzW2Jhc2UgKyAzXSA9IHJlY2VpdmVyO1xuICAgICAgICBpZiAodHlwZW9mIGZ1bGZpbGwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpc1tiYXNlICsgMF0gPVxuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gbnVsbCA/IGZ1bGZpbGwgOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmdWxmaWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJlamVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzW2Jhc2UgKyAxXSA9XG4gICAgICAgICAgICAgICAgZG9tYWluID09PSBudWxsID8gcmVqZWN0IDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zZXRMZW5ndGgoaW5kZXggKyAxKTtcbiAgICByZXR1cm4gaW5kZXg7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcHJveHkgPSBmdW5jdGlvbiAocHJveHlhYmxlLCBhcmcpIHtcbiAgICB0aGlzLl9hZGRDYWxsYmFja3ModW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZywgcHJveHlhYmxlLCBudWxsKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXNvbHZlQ2FsbGJhY2sgPSBmdW5jdGlvbih2YWx1ZSwgc2hvdWxkQmluZCkge1xuICAgIGlmICgoKHRoaXMuX2JpdEZpZWxkICYgMTE3NTA2MDQ4KSAhPT0gMCkpIHJldHVybjtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMpXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWplY3RDYWxsYmFjayhtYWtlU2VsZlJlc29sdXRpb25FcnJvcigpLCBmYWxzZSk7XG4gICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodmFsdWUsIHRoaXMpO1xuICAgIGlmICghKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpKSByZXR1cm4gdGhpcy5fZnVsZmlsbCh2YWx1ZSk7XG5cbiAgICBpZiAoc2hvdWxkQmluZCkgdGhpcy5fcHJvcGFnYXRlRnJvbShtYXliZVByb21pc2UsIDIpO1xuXG4gICAgdmFyIHByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuXG4gICAgaWYgKHByb21pc2UgPT09IHRoaXMpIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLl9sZW5ndGgoKTtcbiAgICAgICAgaWYgKGxlbiA+IDApIHByb21pc2UuX21pZ3JhdGVDYWxsYmFjazAodGhpcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHByb21pc2UuX21pZ3JhdGVDYWxsYmFja0F0KHRoaXMsIGkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEZvbGxvd2luZygpO1xuICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgICAgIHRoaXMuX3NldEZvbGxvd2VlKHByb21pc2UpO1xuICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgdGhpcy5fZnVsZmlsbChwcm9taXNlLl92YWx1ZSgpKTtcbiAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdChwcm9taXNlLl9yZWFzb24oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlYXNvbiA9IG5ldyBDYW5jZWxsYXRpb25FcnJvcihcImxhdGUgY2FuY2VsbGF0aW9uIG9ic2VydmVyXCIpO1xuICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHJlYXNvbik7XG4gICAgICAgIHRoaXMuX3JlamVjdChyZWFzb24pO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWplY3RDYWxsYmFjayA9XG5mdW5jdGlvbihyZWFzb24sIHN5bmNocm9ub3VzLCBpZ25vcmVOb25FcnJvcldhcm5pbmdzKSB7XG4gICAgdmFyIHRyYWNlID0gdXRpbC5lbnN1cmVFcnJvck9iamVjdChyZWFzb24pO1xuICAgIHZhciBoYXNTdGFjayA9IHRyYWNlID09PSByZWFzb247XG4gICAgaWYgKCFoYXNTdGFjayAmJiAhaWdub3JlTm9uRXJyb3JXYXJuaW5ncyAmJiBkZWJ1Zy53YXJuaW5ncygpKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJhIHByb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBub24tZXJyb3I6IFwiICtcbiAgICAgICAgICAgIHV0aWwuY2xhc3NTdHJpbmcocmVhc29uKTtcbiAgICAgICAgdGhpcy5fd2FybihtZXNzYWdlLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5fYXR0YWNoRXh0cmFUcmFjZSh0cmFjZSwgc3luY2hyb25vdXMgPyBoYXNTdGFjayA6IGZhbHNlKTtcbiAgICB0aGlzLl9yZWplY3QocmVhc29uKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXNvbHZlRnJvbUV4ZWN1dG9yID0gZnVuY3Rpb24gKGV4ZWN1dG9yKSB7XG4gICAgaWYgKGV4ZWN1dG9yID09PSBJTlRFUk5BTCkgcmV0dXJuO1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB0aGlzLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHRoaXMuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICB2YXIgciA9IHRoaXMuX2V4ZWN1dGUoZXhlY3V0b3IsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZWFzb24sIHN5bmNocm9ub3VzKTtcbiAgICB9KTtcbiAgICBzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgIHRoaXMuX3BvcENvbnRleHQoKTtcblxuICAgIGlmIChyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2sociwgdHJ1ZSk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlciA9IGZ1bmN0aW9uIChcbiAgICBoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUsIHByb21pc2Vcbikge1xuICAgIHZhciBiaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgNjU1MzYpICE9PSAwKSkgcmV0dXJuO1xuICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHg7XG4gICAgaWYgKHJlY2VpdmVyID09PSBBUFBMWSkge1xuICAgICAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZS5sZW5ndGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHggPSBlcnJvck9iajtcbiAgICAgICAgICAgIHguZSA9IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgLnNwcmVhZCgpIGEgbm9uLWFycmF5OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0gdHJ5Q2F0Y2goaGFuZGxlcikuYXBwbHkodGhpcy5fYm91bmRWYWx1ZSgpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdHJ5Q2F0Y2goaGFuZGxlcikuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuICAgIH1cbiAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgYml0RmllbGQgPSBwcm9taXNlLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDY1NTM2KSAhPT0gMCkpIHJldHVybjtcblxuICAgIGlmICh4ID09PSBORVhUX0ZJTFRFUikge1xuICAgICAgICBwcm9taXNlLl9yZWplY3QodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoeCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2soeC5lLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKHgsIHByb21pc2VDcmVhdGVkLCBcIlwiLCAgcHJvbWlzZSwgdGhpcyk7XG4gICAgICAgIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh4KTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdGFyZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJldCA9IHRoaXM7XG4gICAgd2hpbGUgKHJldC5faXNGb2xsb3dpbmcoKSkgcmV0ID0gcmV0Ll9mb2xsb3dlZSgpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZm9sbG93ZWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0Rm9sbG93ZWUgPSBmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPSBwcm9taXNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZVByb21pc2UgPSBmdW5jdGlvbihwcm9taXNlLCBoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUpIHtcbiAgICB2YXIgaXNQcm9taXNlID0gcHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2U7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgdmFyIGFzeW5jR3VhcmFudGVlZCA9ICgoYml0RmllbGQgJiAxMzQyMTc3MjgpICE9PSAwKTtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDY1NTM2KSAhPT0gMCkpIHtcbiAgICAgICAgaWYgKGlzUHJvbWlzZSkgcHJvbWlzZS5faW52b2tlSW50ZXJuYWxPbkNhbmNlbCgpO1xuXG4gICAgICAgIGlmIChyZWNlaXZlciBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQgJiZcbiAgICAgICAgICAgIHJlY2VpdmVyLmlzRmluYWxseUhhbmRsZXIoKSkge1xuICAgICAgICAgICAgcmVjZWl2ZXIuY2FuY2VsUHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgICAgICBpZiAodHJ5Q2F0Y2goaGFuZGxlcikuY2FsbChyZWNlaXZlciwgdmFsdWUpID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdChlcnJvck9iai5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID09PSByZWZsZWN0SGFuZGxlcikge1xuICAgICAgICAgICAgcHJvbWlzZS5fZnVsZmlsbChyZWZsZWN0SGFuZGxlci5jYWxsKHJlY2VpdmVyKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVjZWl2ZXIgaW5zdGFuY2VvZiBQcm94eWFibGUpIHtcbiAgICAgICAgICAgIHJlY2VpdmVyLl9wcm9taXNlQ2FuY2VsbGVkKHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZSB8fCBwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZUFycmF5KSB7XG4gICAgICAgICAgICBwcm9taXNlLl9jYW5jZWwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY2VpdmVyLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghaXNQcm9taXNlKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwocmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhc3luY0d1YXJhbnRlZWQpIHByb21pc2UuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZUZyb21IYW5kbGVyKGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlY2VpdmVyIGluc3RhbmNlb2YgUHJveHlhYmxlKSB7XG4gICAgICAgIGlmICghcmVjZWl2ZXIuX2lzUmVzb2x2ZWQoKSkge1xuICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIuX3Byb21pc2VGdWxmaWxsZWQodmFsdWUsIHByb21pc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlci5fcHJvbWlzZVJlamVjdGVkKHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKSB7XG4gICAgICAgIGlmIChhc3luY0d1YXJhbnRlZWQpIHByb21pc2UuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlTGF0ZUNhbmNlbGxhdGlvbk9ic2VydmVyID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgdmFyIGhhbmRsZXIgPSBjdHguaGFuZGxlcjtcbiAgICB2YXIgcHJvbWlzZSA9IGN0eC5wcm9taXNlO1xuICAgIHZhciByZWNlaXZlciA9IGN0eC5yZWNlaXZlcjtcbiAgICB2YXIgdmFsdWUgPSBjdHgudmFsdWU7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKCEocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwocmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlcihoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlLl9yZWplY3QodmFsdWUpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlQ3R4ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgdGhpcy5fc2V0dGxlUHJvbWlzZShjdHgucHJvbWlzZSwgY3R4LmhhbmRsZXIsIGN0eC5yZWNlaXZlciwgY3R4LnZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlMCA9IGZ1bmN0aW9uKGhhbmRsZXIsIHZhbHVlLCBiaXRGaWVsZCkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZTA7XG4gICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcmVjZWl2ZXJBdCgwKTtcbiAgICB0aGlzLl9wcm9taXNlMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZWNlaXZlcjAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2V0dGxlUHJvbWlzZShwcm9taXNlLCBoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgdmFyIGJhc2UgPSBpbmRleCAqIDQgLSA0O1xuICAgIHRoaXNbYmFzZSArIDJdID1cbiAgICB0aGlzW2Jhc2UgKyAzXSA9XG4gICAgdGhpc1tiYXNlICsgMF0gPVxuICAgIHRoaXNbYmFzZSArIDFdID0gdW5kZWZpbmVkO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDExNzUwNjA0OCkgPj4+IDE2KSkgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcykge1xuICAgICAgICB2YXIgZXJyID0gbWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IoKTtcbiAgICAgICAgdGhpcy5fYXR0YWNoRXh0cmFUcmFjZShlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0KGVycik7XG4gICAgfVxuICAgIHRoaXMuX3NldEZ1bGZpbGxlZCgpO1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gdmFsdWU7XG5cbiAgICBpZiAoKGJpdEZpZWxkICYgNjU1MzUpID4gMCkge1xuICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDEzNDIxNzcyOCkgIT09IDApKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXN5bmMuc2V0dGxlUHJvbWlzZXModGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgMTE3NTA2MDQ4KSA+Pj4gMTYpKSByZXR1cm47XG4gICAgdGhpcy5fc2V0UmVqZWN0ZWQoKTtcbiAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gcmVhc29uO1xuXG4gICAgaWYgKHRoaXMuX2lzRmluYWwoKSkge1xuICAgICAgICByZXR1cm4gYXN5bmMuZmF0YWxFcnJvcihyZWFzb24sIHV0aWwuaXNOb2RlKTtcbiAgICB9XG5cbiAgICBpZiAoKGJpdEZpZWxkICYgNjU1MzUpID4gMCkge1xuICAgICAgICBhc3luYy5zZXR0bGVQcm9taXNlcyh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lbnN1cmVQb3NzaWJsZVJlamVjdGlvbkhhbmRsZWQoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZnVsZmlsbFByb21pc2VzID0gZnVuY3Rpb24gKGxlbiwgdmFsdWUpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyQXQoaSk7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZUF0KGkpO1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzLl9yZWNlaXZlckF0KGkpO1xuICAgICAgICB0aGlzLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXgoaSk7XG4gICAgICAgIHRoaXMuX3NldHRsZVByb21pc2UocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0UHJvbWlzZXMgPSBmdW5jdGlvbiAobGVuLCByZWFzb24pIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5fcmVqZWN0aW9uSGFuZGxlckF0KGkpO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2VBdChpKTtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcmVjZWl2ZXJBdChpKTtcbiAgICAgICAgdGhpcy5fY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4KGkpO1xuICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlKHByb21pc2UsIGhhbmRsZXIsIHJlY2VpdmVyLCByZWFzb24pO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICB2YXIgbGVuID0gKGJpdEZpZWxkICYgNjU1MzUpO1xuXG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAxNjg0Mjc1MikgIT09IDApKSB7XG4gICAgICAgICAgICB2YXIgcmVhc29uID0gdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMDtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2UwKHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwLCByZWFzb24sIGJpdEZpZWxkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdFByb21pc2VzKGxlbiwgcmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZTAodGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCwgdmFsdWUsIGJpdEZpZWxkKTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGZpbGxQcm9taXNlcyhsZW4sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgfVxuICAgIHRoaXMuX2NsZWFyQ2FuY2VsbGF0aW9uRGF0YSgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZWRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjA7XG4gICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBkZWZlclJlc29sdmUodikge3RoaXMucHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHYpO31cbmZ1bmN0aW9uIGRlZmVyUmVqZWN0KHYpIHt0aGlzLnByb21pc2UuX3JlamVjdENhbGxiYWNrKHYsIGZhbHNlKTt9XG5cblByb21pc2UuZGVmZXIgPSBQcm9taXNlLnBlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiUHJvbWlzZS5kZWZlclwiLCBcIm5ldyBQcm9taXNlXCIpO1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgIHJlc29sdmU6IGRlZmVyUmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiBkZWZlclJlamVjdFxuICAgIH07XG59O1xuXG51dGlsLm5vdEVudW1lcmFibGVQcm9wKFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgIFwiX21ha2VTZWxmUmVzb2x1dGlvbkVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgIG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKTtcblxucmVxdWlyZShcIi4vbWV0aG9kXCIpKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24sXG4gICAgZGVidWcpO1xucmVxdWlyZShcIi4vYmluZFwiKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgZGVidWcpO1xucmVxdWlyZShcIi4vY2FuY2VsXCIpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCBkZWJ1Zyk7XG5yZXF1aXJlKFwiLi9kaXJlY3RfcmVzb2x2ZVwiKShQcm9taXNlKTtcbnJlcXVpcmUoXCIuL3N5bmNocm9ub3VzX2luc3BlY3Rpb25cIikoUHJvbWlzZSk7XG5yZXF1aXJlKFwiLi9qb2luXCIpKFxuICAgIFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwsIGFzeW5jLCBnZXREb21haW4pO1xuUHJvbWlzZS5Qcm9taXNlID0gUHJvbWlzZTtcblByb21pc2UudmVyc2lvbiA9IFwiMy41LjBcIjtcbnJlcXVpcmUoJy4vbWFwLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBkZWJ1Zyk7XG5yZXF1aXJlKCcuL2NhbGxfZ2V0LmpzJykoUHJvbWlzZSk7XG5yZXF1aXJlKCcuL3VzaW5nLmpzJykoUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBjcmVhdGVDb250ZXh0LCBJTlRFUk5BTCwgZGVidWcpO1xucmVxdWlyZSgnLi90aW1lcnMuanMnKShQcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpO1xucmVxdWlyZSgnLi9nZW5lcmF0b3JzLmpzJykoUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgUHJveHlhYmxlLCBkZWJ1Zyk7XG5yZXF1aXJlKCcuL25vZGVpZnkuanMnKShQcm9taXNlKTtcbnJlcXVpcmUoJy4vcHJvbWlzaWZ5LmpzJykoUHJvbWlzZSwgSU5URVJOQUwpO1xucmVxdWlyZSgnLi9wcm9wcy5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKTtcbnJlcXVpcmUoJy4vcmFjZS5qcycpKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pO1xucmVxdWlyZSgnLi9yZWR1Y2UuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKTtcbnJlcXVpcmUoJy4vc2V0dGxlLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBkZWJ1Zyk7XG5yZXF1aXJlKCcuL3NvbWUuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbik7XG5yZXF1aXJlKCcuL2ZpbHRlci5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcbnJlcXVpcmUoJy4vZWFjaC5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcbnJlcXVpcmUoJy4vYW55LmpzJykoUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICB1dGlsLnRvRmFzdFByb3BlcnRpZXMoUHJvbWlzZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKFByb21pc2UucHJvdG90eXBlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZ1bmN0aW9uIGZpbGxUeXBlcyh2YWx1ZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgdmFyIHAgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX2Z1bGZpbGxtZW50SGFuZGxlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9yZWplY3Rpb25IYW5kbGVyMCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcC5fcHJvbWlzZTAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX3JlY2VpdmVyMCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAvLyBDb21wbGV0ZSBzbGFjayB0cmFja2luZywgb3B0IG91dCBvZiBmaWVsZC10eXBlIHRyYWNraW5nIGFuZCAgICAgICAgICAgXG4gICAgLy8gc3RhYmlsaXplIG1hcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh7YTogMX0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoe2I6IDJ9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHtjOiAzfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcygxKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoZnVuY3Rpb24oKXt9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHVuZGVmaW5lZCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyhmYWxzZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMobmV3IFByb21pc2UoSU5URVJOQUwpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZGVidWcuc2V0Qm91bmRzKEFzeW5jLmZpcnN0TGluZUVycm9yLCB1dGlsLmxhc3RMaW5lRXJyb3IpOyAgICAgICAgICAgICAgIFxuICAgIHJldHVybiBQcm9taXNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3Byb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGVzNSA9IHJlcXVpcmUoXCIuL2VzNVwiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJ1bmRlZmluZWRcIjtcblxudmFyIGVycm9yT2JqID0ge2U6IHt9fTtcbnZhciB0cnlDYXRjaFRhcmdldDtcbnZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOlxuICAgIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOlxuICAgIHRoaXMgIT09IHVuZGVmaW5lZCA/IHRoaXMgOiBudWxsO1xuXG5mdW5jdGlvbiB0cnlDYXRjaGVyKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0cnlDYXRjaFRhcmdldDtcbiAgICAgICAgdHJ5Q2F0Y2hUYXJnZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeUNhdGNoKGZuKSB7XG4gICAgdHJ5Q2F0Y2hUYXJnZXQgPSBmbjtcbiAgICByZXR1cm4gdHJ5Q2F0Y2hlcjtcbn1cblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24oQ2hpbGQsIFBhcmVudCkge1xuICAgIHZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgICBmdW5jdGlvbiBUKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gQ2hpbGQ7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IkID0gUGFyZW50O1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gUGFyZW50LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgaWYgKGhhc1Byb3AuY2FsbChQYXJlbnQucHJvdG90eXBlLCBwcm9wZXJ0eU5hbWUpICYmXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lLmNoYXJBdChwcm9wZXJ0eU5hbWUubGVuZ3RoLTEpICE9PSBcIiRcIlxuICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZSArIFwiJFwiXSA9IFBhcmVudC5wcm90b3R5cGVbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBULnByb3RvdHlwZSA9IFBhcmVudC5wcm90b3R5cGU7XG4gICAgQ2hpbGQucHJvdG90eXBlID0gbmV3IFQoKTtcbiAgICByZXR1cm4gQ2hpbGQucHJvdG90eXBlO1xufTtcblxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UgfHxcbiAgICAgICAgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiO1xuXG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gbWF5YmVXcmFwQXNFcnJvcihtYXliZUVycm9yKSB7XG4gICAgaWYgKCFpc1ByaW1pdGl2ZShtYXliZUVycm9yKSkgcmV0dXJuIG1heWJlRXJyb3I7XG5cbiAgICByZXR1cm4gbmV3IEVycm9yKHNhZmVUb1N0cmluZyhtYXliZUVycm9yKSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhBcHBlbmRlZCh0YXJnZXQsIGFwcGVuZGVlKSB7XG4gICAgdmFyIGxlbiA9IHRhcmdldC5sZW5ndGg7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgcmV0W2ldID0gdGFyZ2V0W2ldO1xuICAgIH1cbiAgICByZXRbaV0gPSBhcHBlbmRlZTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQob2JqLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChlczUuaXNFUzUpIHtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcblxuICAgICAgICBpZiAoZGVzYyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQgPT0gbnVsbCAmJiBkZXNjLnNldCA9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8gZGVzYy52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSA/IG9ialtrZXldIDogdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbm90RW51bWVyYWJsZVByb3Aob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChpc1ByaW1pdGl2ZShvYmopKSByZXR1cm4gb2JqO1xuICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfTtcbiAgICBlczUuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiB0aHJvd2VyKHIpIHtcbiAgICB0aHJvdyByO1xufVxuXG52YXIgaW5oZXJpdGVkRGF0YUtleXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4Y2x1ZGVkUHJvdG90eXBlcyA9IFtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGVcbiAgICBdO1xuXG4gICAgdmFyIGlzRXhjbHVkZWRQcm90byA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4Y2x1ZGVkUHJvdG90eXBlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkUHJvdG90eXBlc1tpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBpZiAoZXM1LmlzRVM1KSB7XG4gICAgICAgIHZhciBnZXRLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgIHZhciB2aXNpdGVkS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB3aGlsZSAob2JqICE9IG51bGwgJiYgIWlzRXhjbHVkZWRQcm90byhvYmopKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXM7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAga2V5cyA9IGdldEtleXMob2JqKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRLZXlzW2tleV0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MgIT0gbnVsbCAmJiBkZXNjLmdldCA9PSBudWxsICYmIGRlc2Muc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqID0gZXM1LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmIChpc0V4Y2x1ZGVkUHJvdG8ob2JqKSkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICAgICAgICAvKmpzaGludCBmb3JpbjpmYWxzZSAqL1xuICAgICAgICAgICAgZW51bWVyYXRpb246IGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUHJvcC5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhjbHVkZWRQcm90b3R5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzUHJvcC5jYWxsKGV4Y2x1ZGVkUHJvdG90eXBlc1tpXSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGVudW1lcmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICB9XG5cbn0pKCk7XG5cbnZhciB0aGlzQXNzaWdubWVudFBhdHRlcm4gPSAvdGhpc1xccypcXC5cXHMqXFxTK1xccyo9LztcbmZ1bmN0aW9uIGlzQ2xhc3MoZm4pIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gZXM1Lm5hbWVzKGZuLnByb3RvdHlwZSk7XG5cbiAgICAgICAgICAgIHZhciBoYXNNZXRob2RzID0gZXM1LmlzRVM1ICYmIGtleXMubGVuZ3RoID4gMTtcbiAgICAgICAgICAgIHZhciBoYXNNZXRob2RzT3RoZXJUaGFuQ29uc3RydWN0b3IgPSBrZXlzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAhKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09IFwiY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgICB2YXIgaGFzVGhpc0Fzc2lnbm1lbnRBbmRTdGF0aWNNZXRob2RzID1cbiAgICAgICAgICAgICAgICB0aGlzQXNzaWdubWVudFBhdHRlcm4udGVzdChmbiArIFwiXCIpICYmIGVzNS5uYW1lcyhmbikubGVuZ3RoID4gMDtcblxuICAgICAgICAgICAgaWYgKGhhc01ldGhvZHMgfHwgaGFzTWV0aG9kc090aGVyVGhhbkNvbnN0cnVjdG9yIHx8XG4gICAgICAgICAgICAgICAgaGFzVGhpc0Fzc2lnbm1lbnRBbmRTdGF0aWNNZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9GYXN0UHJvcGVydGllcyhvYmopIHtcbiAgICAvKmpzaGludCAtVzAyNywtVzA1NSwtVzAzMSovXG4gICAgZnVuY3Rpb24gRmFrZUNvbnN0cnVjdG9yKCkge31cbiAgICBGYWtlQ29uc3RydWN0b3IucHJvdG90eXBlID0gb2JqO1xuICAgIHZhciBsID0gODtcbiAgICB3aGlsZSAobC0tKSBuZXcgRmFrZUNvbnN0cnVjdG9yKCk7XG4gICAgcmV0dXJuIG9iajtcbiAgICBldmFsKG9iaik7XG59XG5cbnZhciByaWRlbnQgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbmZ1bmN0aW9uIGlzSWRlbnRpZmllcihzdHIpIHtcbiAgICByZXR1cm4gcmlkZW50LnRlc3Qoc3RyKTtcbn1cblxuZnVuY3Rpb24gZmlsbGVkUmFuZ2UoY291bnQsIHByZWZpeCwgc3VmZml4KSB7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgcmV0W2ldID0gcHJlZml4ICsgaSArIHN1ZmZpeDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2FmZVRvU3RyaW5nKG9iaikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvYmogKyBcIlwiO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFwiW25vIHN0cmluZyByZXByZXNlbnRhdGlvbl1cIjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJlxuICAgICAgICAgICB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgIHR5cGVvZiBvYmoubWVzc2FnZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICB0eXBlb2Ygb2JqLm5hbWUgPT09IFwic3RyaW5nXCI7XG59XG5cbmZ1bmN0aW9uIG1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AoZSwgXCJpc09wZXJhdGlvbmFsXCIsIHRydWUpO1xuICAgIH1cbiAgICBjYXRjaChpZ25vcmUpIHt9XG59XG5cbmZ1bmN0aW9uIG9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uKGUpIHtcbiAgICBpZiAoZSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICgoZSBpbnN0YW5jZW9mIEVycm9yW1wiX19CbHVlYmlyZEVycm9yVHlwZXNfX1wiXS5PcGVyYXRpb25hbEVycm9yKSB8fFxuICAgICAgICBlW1wiaXNPcGVyYXRpb25hbFwiXSA9PT0gdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGNhbkF0dGFjaFRyYWNlKG9iaikge1xuICAgIHJldHVybiBpc0Vycm9yKG9iaikgJiYgZXM1LnByb3BlcnR5SXNXcml0YWJsZShvYmosIFwic3RhY2tcIik7XG59XG5cbnZhciBlbnN1cmVFcnJvck9iamVjdCA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAoIShcInN0YWNrXCIgaW4gbmV3IEVycm9yKCkpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNhbkF0dGFjaFRyYWNlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHt0aHJvdyBuZXcgRXJyb3Ioc2FmZVRvU3RyaW5nKHZhbHVlKSk7fVxuICAgICAgICAgICAgY2F0Y2goZXJyKSB7cmV0dXJuIGVycjt9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY2FuQXR0YWNoVHJhY2UodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKHNhZmVUb1N0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9O1xuICAgIH1cbn0pKCk7XG5cbmZ1bmN0aW9uIGNsYXNzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5cbmZ1bmN0aW9uIGNvcHlEZXNjcmlwdG9ycyhmcm9tLCB0bywgZmlsdGVyKSB7XG4gICAgdmFyIGtleXMgPSBlczUubmFtZXMoZnJvbSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoZmlsdGVyKGtleSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZXM1LmRlZmluZVByb3BlcnR5KHRvLCBrZXksIGVzNS5nZXREZXNjcmlwdG9yKGZyb20sIGtleSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgYXNBcnJheSA9IGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoZXM1LmlzQXJyYXkodikpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgdmFyIEFycmF5RnJvbSA9IHR5cGVvZiBBcnJheS5mcm9tID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHYpO1xuICAgIH0gOiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgdmFyIGl0ID0gdltTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIHZhciBpdFJlc3VsdDtcbiAgICAgICAgd2hpbGUgKCEoKGl0UmVzdWx0ID0gaXQubmV4dCgpKS5kb25lKSkge1xuICAgICAgICAgICAgcmV0LnB1c2goaXRSZXN1bHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIGFzQXJyYXkgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIGlmIChlczUuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0gZWxzZSBpZiAodiAhPSBudWxsICYmIHR5cGVvZiB2W1N5bWJvbC5pdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5RnJvbSh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuXG52YXIgaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgY2xhc3NTdHJpbmcocHJvY2VzcykudG9Mb3dlckNhc2UoKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCI7XG5cbnZhciBoYXNFbnZWYXJpYWJsZXMgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLmVudiAhPT0gXCJ1bmRlZmluZWRcIjtcblxuZnVuY3Rpb24gZW52KGtleSkge1xuICAgIHJldHVybiBoYXNFbnZWYXJpYWJsZXMgPyBwcm9jZXNzLmVudltrZXldIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBnZXROYXRpdmVQcm9taXNlKCkge1xuICAgIGlmICh0eXBlb2YgUHJvbWlzZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKCl7fSk7XG4gICAgICAgICAgICBpZiAoe30udG9TdHJpbmcuY2FsbChwcm9taXNlKSA9PT0gXCJbb2JqZWN0IFByb21pc2VdXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRvbWFpbkJpbmQoc2VsZiwgY2IpIHtcbiAgICByZXR1cm4gc2VsZi5iaW5kKGNiKTtcbn1cblxudmFyIHJldCA9IHtcbiAgICBpc0NsYXNzOiBpc0NsYXNzLFxuICAgIGlzSWRlbnRpZmllcjogaXNJZGVudGlmaWVyLFxuICAgIGluaGVyaXRlZERhdGFLZXlzOiBpbmhlcml0ZWREYXRhS2V5cyxcbiAgICBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQ6IGdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdCxcbiAgICB0aHJvd2VyOiB0aHJvd2VyLFxuICAgIGlzQXJyYXk6IGVzNS5pc0FycmF5LFxuICAgIGFzQXJyYXk6IGFzQXJyYXksXG4gICAgbm90RW51bWVyYWJsZVByb3A6IG5vdEVudW1lcmFibGVQcm9wLFxuICAgIGlzUHJpbWl0aXZlOiBpc1ByaW1pdGl2ZSxcbiAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgaXNFcnJvcjogaXNFcnJvcixcbiAgICBjYW5FdmFsdWF0ZTogY2FuRXZhbHVhdGUsXG4gICAgZXJyb3JPYmo6IGVycm9yT2JqLFxuICAgIHRyeUNhdGNoOiB0cnlDYXRjaCxcbiAgICBpbmhlcml0czogaW5oZXJpdHMsXG4gICAgd2l0aEFwcGVuZGVkOiB3aXRoQXBwZW5kZWQsXG4gICAgbWF5YmVXcmFwQXNFcnJvcjogbWF5YmVXcmFwQXNFcnJvcixcbiAgICB0b0Zhc3RQcm9wZXJ0aWVzOiB0b0Zhc3RQcm9wZXJ0aWVzLFxuICAgIGZpbGxlZFJhbmdlOiBmaWxsZWRSYW5nZSxcbiAgICB0b1N0cmluZzogc2FmZVRvU3RyaW5nLFxuICAgIGNhbkF0dGFjaFRyYWNlOiBjYW5BdHRhY2hUcmFjZSxcbiAgICBlbnN1cmVFcnJvck9iamVjdDogZW5zdXJlRXJyb3JPYmplY3QsXG4gICAgb3JpZ2luYXRlc0Zyb21SZWplY3Rpb246IG9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uLFxuICAgIG1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbjogbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uLFxuICAgIGNsYXNzU3RyaW5nOiBjbGFzc1N0cmluZyxcbiAgICBjb3B5RGVzY3JpcHRvcnM6IGNvcHlEZXNjcmlwdG9ycyxcbiAgICBoYXNEZXZUb29sczogdHlwZW9mIGNocm9tZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjaHJvbWUgJiZcbiAgICAgICAgICAgICAgICAgdHlwZW9mIGNocm9tZS5sb2FkVGltZXMgPT09IFwiZnVuY3Rpb25cIixcbiAgICBpc05vZGU6IGlzTm9kZSxcbiAgICBoYXNFbnZWYXJpYWJsZXM6IGhhc0VudlZhcmlhYmxlcyxcbiAgICBlbnY6IGVudixcbiAgICBnbG9iYWw6IGdsb2JhbE9iamVjdCxcbiAgICBnZXROYXRpdmVQcm9taXNlOiBnZXROYXRpdmVQcm9taXNlLFxuICAgIGRvbWFpbkJpbmQ6IGRvbWFpbkJpbmRcbn07XG5yZXQuaXNSZWNlbnROb2RlID0gcmV0LmlzTm9kZSAmJiAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoXCIuXCIpLm1hcChOdW1iZXIpO1xuICAgIHJldHVybiAodmVyc2lvblswXSA9PT0gMCAmJiB2ZXJzaW9uWzFdID4gMTApIHx8ICh2ZXJzaW9uWzBdID4gMCk7XG59KSgpO1xuXG5pZiAocmV0LmlzTm9kZSkgcmV0LnRvRmFzdFByb3BlcnRpZXMocHJvY2Vzcyk7XG5cbnRyeSB7dGhyb3cgbmV3IEVycm9yKCk7IH0gY2F0Y2ggKGUpIHtyZXQubGFzdExpbmVFcnJvciA9IGU7fVxubW9kdWxlLmV4cG9ydHMgPSByZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzRVM1ID0gKGZ1bmN0aW9uKCl7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMgPT09IHVuZGVmaW5lZDtcbn0pKCk7XG5cbmlmIChpc0VTNSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBmcmVlemU6IE9iamVjdC5mcmVlemUsXG4gICAgICAgIGRlZmluZVByb3BlcnR5OiBPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gICAgICAgIGdldERlc2NyaXB0b3I6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgICAgIGtleXM6IE9iamVjdC5rZXlzLFxuICAgICAgICBuYW1lczogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsXG4gICAgICAgIGdldFByb3RvdHlwZU9mOiBPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gICAgICAgIGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG4gICAgICAgIGlzRVM1OiBpc0VTNSxcbiAgICAgICAgcHJvcGVydHlJc1dyaXRhYmxlOiBmdW5jdGlvbihvYmosIHByb3ApIHtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApO1xuICAgICAgICAgICAgcmV0dXJuICEhKCFkZXNjcmlwdG9yIHx8IGRlc2NyaXB0b3Iud3JpdGFibGUgfHwgZGVzY3JpcHRvci5zZXQpO1xuICAgICAgICB9XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgdmFyIGhhcyA9IHt9Lmhhc093blByb3BlcnR5O1xuICAgIHZhciBzdHIgPSB7fS50b1N0cmluZztcbiAgICB2YXIgcHJvdG8gPSB7fS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgICB2YXIgT2JqZWN0S2V5cyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG8pIHtcbiAgICAgICAgICAgIGlmIChoYXMuY2FsbChvLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICB2YXIgT2JqZWN0R2V0RGVzY3JpcHRvciA9IGZ1bmN0aW9uKG8sIGtleSkge1xuICAgICAgICByZXR1cm4ge3ZhbHVlOiBvW2tleV19O1xuICAgIH07XG5cbiAgICB2YXIgT2JqZWN0RGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAobywga2V5LCBkZXNjKSB7XG4gICAgICAgIG9ba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG5cbiAgICB2YXIgT2JqZWN0RnJlZXplID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICB2YXIgT2JqZWN0R2V0UHJvdG90eXBlT2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KG9iaikuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIEFycmF5SXNBcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpc0FycmF5OiBBcnJheUlzQXJyYXksXG4gICAgICAgIGtleXM6IE9iamVjdEtleXMsXG4gICAgICAgIG5hbWVzOiBPYmplY3RLZXlzLFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eTogT2JqZWN0RGVmaW5lUHJvcGVydHksXG4gICAgICAgIGdldERlc2NyaXB0b3I6IE9iamVjdEdldERlc2NyaXB0b3IsXG4gICAgICAgIGZyZWV6ZTogT2JqZWN0RnJlZXplLFxuICAgICAgICBnZXRQcm90b3R5cGVPZjogT2JqZWN0R2V0UHJvdG90eXBlT2YsXG4gICAgICAgIGlzRVM1OiBpc0VTNSxcbiAgICAgICAgcHJvcGVydHlJc1dyaXRhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2VzNS5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGZpcnN0TGluZUVycm9yO1xudHJ5IHt0aHJvdyBuZXcgRXJyb3IoKTsgfSBjYXRjaCAoZSkge2ZpcnN0TGluZUVycm9yID0gZTt9XG52YXIgc2NoZWR1bGUgPSByZXF1aXJlKFwiLi9zY2hlZHVsZVwiKTtcbnZhciBRdWV1ZSA9IHJlcXVpcmUoXCIuL3F1ZXVlXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG5mdW5jdGlvbiBBc3luYygpIHtcbiAgICB0aGlzLl9jdXN0b21TY2hlZHVsZXIgPSBmYWxzZTtcbiAgICB0aGlzLl9pc1RpY2tVc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fbGF0ZVF1ZXVlID0gbmV3IFF1ZXVlKDE2KTtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZSA9IG5ldyBRdWV1ZSgxNik7XG4gICAgdGhpcy5faGF2ZURyYWluZWRRdWV1ZXMgPSBmYWxzZTtcbiAgICB0aGlzLl90cmFtcG9saW5lRW5hYmxlZCA9IHRydWU7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZHJhaW5RdWV1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2RyYWluUXVldWVzKCk7XG4gICAgfTtcbiAgICB0aGlzLl9zY2hlZHVsZSA9IHNjaGVkdWxlO1xufVxuXG5Bc3luYy5wcm90b3R5cGUuc2V0U2NoZWR1bGVyID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgcHJldiA9IHRoaXMuX3NjaGVkdWxlO1xuICAgIHRoaXMuX3NjaGVkdWxlID0gZm47XG4gICAgdGhpcy5fY3VzdG9tU2NoZWR1bGVyID0gdHJ1ZTtcbiAgICByZXR1cm4gcHJldjtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5oYXNDdXN0b21TY2hlZHVsZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VzdG9tU2NoZWR1bGVyO1xufTtcblxuQXN5bmMucHJvdG90eXBlLmVuYWJsZVRyYW1wb2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl90cmFtcG9saW5lRW5hYmxlZCA9IHRydWU7XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuZGlzYWJsZVRyYW1wb2xpbmVJZk5lY2Vzc2FyeSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh1dGlsLmhhc0RldlRvb2xzKSB7XG4gICAgICAgIHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLmhhdmVJdGVtc1F1ZXVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNUaWNrVXNlZCB8fCB0aGlzLl9oYXZlRHJhaW5lZFF1ZXVlcztcbn07XG5cblxuQXN5bmMucHJvdG90eXBlLmZhdGFsRXJyb3IgPSBmdW5jdGlvbihlLCBpc05vZGUpIHtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKFwiRmF0YWwgXCIgKyAoZSBpbnN0YW5jZW9mIEVycm9yID8gZS5zdGFjayA6IGUpICtcbiAgICAgICAgICAgIFwiXFxuXCIpO1xuICAgICAgICBwcm9jZXNzLmV4aXQoMik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aHJvd0xhdGVyKGUpO1xuICAgIH1cbn07XG5cbkFzeW5jLnByb3RvdHlwZS50aHJvd0xhdGVyID0gZnVuY3Rpb24oZm4sIGFyZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGFyZyA9IGZuO1xuICAgICAgICBmbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgYXJnOyB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZuKGFyZyk7XG4gICAgICAgIH0sIDApO1xuICAgIH0gZWxzZSB0cnkge1xuICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZuKGFyZyk7XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXN5bmMgc2NoZWR1bGVyIGF2YWlsYWJsZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gQXN5bmNJbnZva2VMYXRlcihmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHRoaXMuX2xhdGVRdWV1ZS5wdXNoKGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn1cblxuZnVuY3Rpb24gQXN5bmNJbnZva2UoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZS5wdXNoKGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn1cblxuZnVuY3Rpb24gQXN5bmNTZXR0bGVQcm9taXNlcyhwcm9taXNlKSB7XG4gICAgdGhpcy5fbm9ybWFsUXVldWUuX3B1c2hPbmUocHJvbWlzZSk7XG4gICAgdGhpcy5fcXVldWVUaWNrKCk7XG59XG5cbmlmICghdXRpbC5oYXNEZXZUb29scykge1xuICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2VMYXRlciA9IEFzeW5jSW52b2tlTGF0ZXI7XG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZSA9IEFzeW5jSW52b2tlO1xuICAgIEFzeW5jLnByb3RvdHlwZS5zZXR0bGVQcm9taXNlcyA9IEFzeW5jU2V0dGxlUHJvbWlzZXM7XG59IGVsc2Uge1xuICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2VMYXRlciA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgICAgICBpZiAodGhpcy5fdHJhbXBvbGluZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIEFzeW5jSW52b2tlTGF0ZXIuY2FsbCh0aGlzLCBmbiwgcmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBBc3luYy5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFtcG9saW5lRW5hYmxlZCkge1xuICAgICAgICAgICAgQXN5bmNJbnZva2UuY2FsbCh0aGlzLCBmbiwgcmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQXN5bmMucHJvdG90eXBlLnNldHRsZVByb21pc2VzID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgICBpZiAodGhpcy5fdHJhbXBvbGluZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIEFzeW5jU2V0dGxlUHJvbWlzZXMuY2FsbCh0aGlzLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3NldHRsZVByb21pc2VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbkFzeW5jLnByb3RvdHlwZS5fZHJhaW5RdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCgpID4gMCkge1xuICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZuLl9zZXR0bGVQcm9taXNlcygpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY2VpdmVyID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdmFyIGFyZyA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLl9kcmFpblF1ZXVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9kcmFpblF1ZXVlKHRoaXMuX25vcm1hbFF1ZXVlKTtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuX2hhdmVEcmFpbmVkUXVldWVzID0gdHJ1ZTtcbiAgICB0aGlzLl9kcmFpblF1ZXVlKHRoaXMuX2xhdGVRdWV1ZSk7XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuX3F1ZXVlVGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2lzVGlja1VzZWQpIHtcbiAgICAgICAgdGhpcy5faXNUaWNrVXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuZHJhaW5RdWV1ZXMpO1xuICAgIH1cbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faXNUaWNrVXNlZCA9IGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3luYztcbm1vZHVsZS5leHBvcnRzLmZpcnN0TGluZUVycm9yID0gZmlyc3RMaW5lRXJyb3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9hc3luYy5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHNjaGVkdWxlO1xudmFyIG5vQXN5bmNTY2hlZHVsZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhc3luYyBzY2hlZHVsZXIgYXZhaWxhYmxlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbn07XG52YXIgTmF0aXZlUHJvbWlzZSA9IHV0aWwuZ2V0TmF0aXZlUHJvbWlzZSgpO1xuaWYgKHV0aWwuaXNOb2RlICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIEdsb2JhbFNldEltbWVkaWF0ZSA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIFByb2Nlc3NOZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgc2NoZWR1bGUgPSB1dGlsLmlzUmVjZW50Tm9kZVxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24oZm4pIHsgR2xvYmFsU2V0SW1tZWRpYXRlLmNhbGwoZ2xvYmFsLCBmbik7IH1cbiAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uKGZuKSB7IFByb2Nlc3NOZXh0VGljay5jYWxsKHByb2Nlc3MsIGZuKTsgfTtcbn0gZWxzZSBpZiAodHlwZW9mIE5hdGl2ZVByb21pc2UgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICB0eXBlb2YgTmF0aXZlUHJvbWlzZS5yZXNvbHZlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgbmF0aXZlUHJvbWlzZSA9IE5hdGl2ZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIHNjaGVkdWxlID0gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgbmF0aXZlUHJvbWlzZS50aGVuKGZuKTtcbiAgICB9O1xufSBlbHNlIGlmICgodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09IFwidW5kZWZpbmVkXCIpICYmXG4gICAgICAgICAgISh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB3aW5kb3cubmF2aWdhdG9yICYmXG4gICAgICAgICAgICAod2luZG93Lm5hdmlnYXRvci5zdGFuZGFsb25lIHx8IHdpbmRvdy5jb3Jkb3ZhKSkpIHtcbiAgICBzY2hlZHVsZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciBvcHRzID0ge2F0dHJpYnV0ZXM6IHRydWV9O1xuICAgICAgICB2YXIgdG9nZ2xlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBkaXYyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG8yID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkaXYuY2xhc3NMaXN0LnRvZ2dsZShcImZvb1wiKTtcbiAgICAgICAgICAgIHRvZ2dsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgbzIub2JzZXJ2ZShkaXYyLCBvcHRzKTtcblxuICAgICAgICB2YXIgc2NoZWR1bGVUb2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0b2dnbGVTY2hlZHVsZWQpIHJldHVybjtcbiAgICAgICAgICAgIHRvZ2dsZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICBkaXYyLmNsYXNzTGlzdC50b2dnbGUoXCJmb29cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNjaGVkdWxlKGZuKSB7XG4gICAgICAgICAgICB2YXIgbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG8uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG8ub2JzZXJ2ZShkaXYsIG9wdHMpO1xuICAgICAgICAgICAgc2NoZWR1bGVUb2dnbGUoKTtcbiAgICAgICAgfTtcbiAgICB9KSgpO1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICB9O1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0VGltZW91dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHNjaGVkdWxlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59IGVsc2Uge1xuICAgIHNjaGVkdWxlID0gbm9Bc3luY1NjaGVkdWxlcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gc2NoZWR1bGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9zY2hlZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gYXJyYXlNb3ZlKHNyYywgc3JjSW5kZXgsIGRzdCwgZHN0SW5kZXgsIGxlbikge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgZHN0W2ogKyBkc3RJbmRleF0gPSBzcmNbaiArIHNyY0luZGV4XTtcbiAgICAgICAgc3JjW2ogKyBzcmNJbmRleF0gPSB2b2lkIDA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBRdWV1ZShjYXBhY2l0eSkge1xuICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcm9udCA9IDA7XG59XG5cblF1ZXVlLnByb3RvdHlwZS5fd2lsbEJlT3ZlckNhcGFjaXR5ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FwYWNpdHkgPCBzaXplO1xufTtcblxuUXVldWUucHJvdG90eXBlLl9wdXNoT25lID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgIHRoaXMuX2NoZWNrQ2FwYWNpdHkobGVuZ3RoICsgMSk7XG4gICAgdmFyIGkgPSAodGhpcy5fZnJvbnQgKyBsZW5ndGgpICYgKHRoaXMuX2NhcGFjaXR5IC0gMSk7XG4gICAgdGhpc1tpXSA9IGFyZztcbiAgICB0aGlzLl9sZW5ndGggPSBsZW5ndGggKyAxO1xufTtcblxuUXVldWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKSArIDM7XG4gICAgaWYgKHRoaXMuX3dpbGxCZU92ZXJDYXBhY2l0eShsZW5ndGgpKSB7XG4gICAgICAgIHRoaXMuX3B1c2hPbmUoZm4pO1xuICAgICAgICB0aGlzLl9wdXNoT25lKHJlY2VpdmVyKTtcbiAgICAgICAgdGhpcy5fcHVzaE9uZShhcmcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBqID0gdGhpcy5fZnJvbnQgKyBsZW5ndGggLSAzO1xuICAgIHRoaXMuX2NoZWNrQ2FwYWNpdHkobGVuZ3RoKTtcbiAgICB2YXIgd3JhcE1hc2sgPSB0aGlzLl9jYXBhY2l0eSAtIDE7XG4gICAgdGhpc1soaiArIDApICYgd3JhcE1hc2tdID0gZm47XG4gICAgdGhpc1soaiArIDEpICYgd3JhcE1hc2tdID0gcmVjZWl2ZXI7XG4gICAgdGhpc1soaiArIDIpICYgd3JhcE1hc2tdID0gYXJnO1xuICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnJvbnQgPSB0aGlzLl9mcm9udCxcbiAgICAgICAgcmV0ID0gdGhpc1tmcm9udF07XG5cbiAgICB0aGlzW2Zyb250XSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mcm9udCA9IChmcm9udCArIDEpICYgKHRoaXMuX2NhcGFjaXR5IC0gMSk7XG4gICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fY2hlY2tDYXBhY2l0eSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgaWYgKHRoaXMuX2NhcGFjaXR5IDwgc2l6ZSkge1xuICAgICAgICB0aGlzLl9yZXNpemVUbyh0aGlzLl9jYXBhY2l0eSA8PCAxKTtcbiAgICB9XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX3Jlc2l6ZVRvID0gZnVuY3Rpb24gKGNhcGFjaXR5KSB7XG4gICAgdmFyIG9sZENhcGFjaXR5ID0gdGhpcy5fY2FwYWNpdHk7XG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB2YXIgZnJvbnQgPSB0aGlzLl9mcm9udDtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoO1xuICAgIHZhciBtb3ZlSXRlbXNDb3VudCA9IChmcm9udCArIGxlbmd0aCkgJiAob2xkQ2FwYWNpdHkgLSAxKTtcbiAgICBhcnJheU1vdmUodGhpcywgMCwgdGhpcywgb2xkQ2FwYWNpdHksIG1vdmVJdGVtc0NvdW50KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUXVldWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9xdWV1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGVzNSA9IHJlcXVpcmUoXCIuL2VzNVwiKTtcbnZhciBPYmplY3RmcmVlemUgPSBlczUuZnJlZXplO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGluaGVyaXRzID0gdXRpbC5pbmhlcml0cztcbnZhciBub3RFbnVtZXJhYmxlUHJvcCA9IHV0aWwubm90RW51bWVyYWJsZVByb3A7XG5cbmZ1bmN0aW9uIHN1YkVycm9yKG5hbWVQcm9wZXJ0eSwgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICBmdW5jdGlvbiBTdWJFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdWJFcnJvcikpIHJldHVybiBuZXcgU3ViRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogZGVmYXVsdE1lc3NhZ2UpO1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm5hbWVcIiwgbmFtZVByb3BlcnR5KTtcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5oZXJpdHMoU3ViRXJyb3IsIEVycm9yKTtcbiAgICByZXR1cm4gU3ViRXJyb3I7XG59XG5cbnZhciBfVHlwZUVycm9yLCBfUmFuZ2VFcnJvcjtcbnZhciBXYXJuaW5nID0gc3ViRXJyb3IoXCJXYXJuaW5nXCIsIFwid2FybmluZ1wiKTtcbnZhciBDYW5jZWxsYXRpb25FcnJvciA9IHN1YkVycm9yKFwiQ2FuY2VsbGF0aW9uRXJyb3JcIiwgXCJjYW5jZWxsYXRpb24gZXJyb3JcIik7XG52YXIgVGltZW91dEVycm9yID0gc3ViRXJyb3IoXCJUaW1lb3V0RXJyb3JcIiwgXCJ0aW1lb3V0IGVycm9yXCIpO1xudmFyIEFnZ3JlZ2F0ZUVycm9yID0gc3ViRXJyb3IoXCJBZ2dyZWdhdGVFcnJvclwiLCBcImFnZ3JlZ2F0ZSBlcnJvclwiKTtcbnRyeSB7XG4gICAgX1R5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICBfUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG59IGNhdGNoKGUpIHtcbiAgICBfVHlwZUVycm9yID0gc3ViRXJyb3IoXCJUeXBlRXJyb3JcIiwgXCJ0eXBlIGVycm9yXCIpO1xuICAgIF9SYW5nZUVycm9yID0gc3ViRXJyb3IoXCJSYW5nZUVycm9yXCIsIFwicmFuZ2UgZXJyb3JcIik7XG59XG5cbnZhciBtZXRob2RzID0gKFwiam9pbiBwb3AgcHVzaCBzaGlmdCB1bnNoaWZ0IHNsaWNlIGZpbHRlciBmb3JFYWNoIHNvbWUgXCIgK1xuICAgIFwiZXZlcnkgbWFwIGluZGV4T2YgbGFzdEluZGV4T2YgcmVkdWNlIHJlZHVjZVJpZ2h0IHNvcnQgcmV2ZXJzZVwiKS5zcGxpdChcIiBcIik7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0eXBlb2YgQXJyYXkucHJvdG90eXBlW21ldGhvZHNbaV1dID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgQWdncmVnYXRlRXJyb3IucHJvdG90eXBlW21ldGhvZHNbaV1dID0gQXJyYXkucHJvdG90eXBlW21ldGhvZHNbaV1dO1xuICAgIH1cbn1cblxuZXM1LmRlZmluZVByb3BlcnR5KEFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgIHZhbHVlOiAwLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxufSk7XG5BZ2dyZWdhdGVFcnJvci5wcm90b3R5cGVbXCJpc09wZXJhdGlvbmFsXCJdID0gdHJ1ZTtcbnZhciBsZXZlbCA9IDA7XG5BZ2dyZWdhdGVFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5kZW50ID0gQXJyYXkobGV2ZWwgKiA0ICsgMSkuam9pbihcIiBcIik7XG4gICAgdmFyIHJldCA9IFwiXFxuXCIgKyBpbmRlbnQgKyBcIkFnZ3JlZ2F0ZUVycm9yIG9mOlwiICsgXCJcXG5cIjtcbiAgICBsZXZlbCsrO1xuICAgIGluZGVudCA9IEFycmF5KGxldmVsICogNCArIDEpLmpvaW4oXCIgXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc3RyID0gdGhpc1tpXSA9PT0gdGhpcyA/IFwiW0NpcmN1bGFyIEFnZ3JlZ2F0ZUVycm9yXVwiIDogdGhpc1tpXSArIFwiXCI7XG4gICAgICAgIHZhciBsaW5lcyA9IHN0ci5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgbGluZXNbal0gPSBpbmRlbnQgKyBsaW5lc1tqXTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICByZXQgKz0gc3RyICsgXCJcXG5cIjtcbiAgICB9XG4gICAgbGV2ZWwtLTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gT3BlcmF0aW9uYWxFcnJvcihtZXNzYWdlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE9wZXJhdGlvbmFsRXJyb3IpKVxuICAgICAgICByZXR1cm4gbmV3IE9wZXJhdGlvbmFsRXJyb3IobWVzc2FnZSk7XG4gICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJuYW1lXCIsIFwiT3BlcmF0aW9uYWxFcnJvclwiKTtcbiAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIiwgbWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IG1lc3NhZ2U7XG4gICAgdGhpc1tcImlzT3BlcmF0aW9uYWxcIl0gPSB0cnVlO1xuXG4gICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIiwgbWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJzdGFja1wiLCBtZXNzYWdlLnN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cblxufVxuaW5oZXJpdHMoT3BlcmF0aW9uYWxFcnJvciwgRXJyb3IpO1xuXG52YXIgZXJyb3JUeXBlcyA9IEVycm9yW1wiX19CbHVlYmlyZEVycm9yVHlwZXNfX1wiXTtcbmlmICghZXJyb3JUeXBlcykge1xuICAgIGVycm9yVHlwZXMgPSBPYmplY3RmcmVlemUoe1xuICAgICAgICBDYW5jZWxsYXRpb25FcnJvcjogQ2FuY2VsbGF0aW9uRXJyb3IsXG4gICAgICAgIFRpbWVvdXRFcnJvcjogVGltZW91dEVycm9yLFxuICAgICAgICBPcGVyYXRpb25hbEVycm9yOiBPcGVyYXRpb25hbEVycm9yLFxuICAgICAgICBSZWplY3Rpb25FcnJvcjogT3BlcmF0aW9uYWxFcnJvcixcbiAgICAgICAgQWdncmVnYXRlRXJyb3I6IEFnZ3JlZ2F0ZUVycm9yXG4gICAgfSk7XG4gICAgZXM1LmRlZmluZVByb3BlcnR5KEVycm9yLCBcIl9fQmx1ZWJpcmRFcnJvclR5cGVzX19cIiwge1xuICAgICAgICB2YWx1ZTogZXJyb3JUeXBlcyxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBFcnJvcjogRXJyb3IsXG4gICAgVHlwZUVycm9yOiBfVHlwZUVycm9yLFxuICAgIFJhbmdlRXJyb3I6IF9SYW5nZUVycm9yLFxuICAgIENhbmNlbGxhdGlvbkVycm9yOiBlcnJvclR5cGVzLkNhbmNlbGxhdGlvbkVycm9yLFxuICAgIE9wZXJhdGlvbmFsRXJyb3I6IGVycm9yVHlwZXMuT3BlcmF0aW9uYWxFcnJvcixcbiAgICBUaW1lb3V0RXJyb3I6IGVycm9yVHlwZXMuVGltZW91dEVycm9yLFxuICAgIEFnZ3JlZ2F0ZUVycm9yOiBlcnJvclR5cGVzLkFnZ3JlZ2F0ZUVycm9yLFxuICAgIFdhcm5pbmc6IFdhcm5pbmdcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9lcnJvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgaXNPYmplY3QgPSB1dGlsLmlzT2JqZWN0O1xuXG5mdW5jdGlvbiB0cnlDb252ZXJ0VG9Qcm9taXNlKG9iaiwgY29udGV4dCkge1xuICAgIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gb2JqO1xuICAgICAgICB2YXIgdGhlbiA9IGdldFRoZW4ob2JqKTtcbiAgICAgICAgaWYgKHRoZW4gPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciByZXQgPSBQcm9taXNlLnJlamVjdCh0aGVuLmUpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKGlzQW55Qmx1ZWJpcmRQcm9taXNlKG9iaikpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgIG9iai5fdGhlbihcbiAgICAgICAgICAgICAgICAgICAgcmV0Ll9mdWxmaWxsLFxuICAgICAgICAgICAgICAgICAgICByZXQuX3JlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICByZXQsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZG9UaGVuYWJsZShvYmosIHRoZW4sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGRvR2V0VGhlbihvYmopIHtcbiAgICByZXR1cm4gb2JqLnRoZW47XG59XG5cbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRvR2V0VGhlbihvYmopO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JPYmouZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICB9XG59XG5cbnZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBpc0FueUJsdWViaXJkUHJvbWlzZShvYmopIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gaGFzUHJvcC5jYWxsKG9iaiwgXCJfcHJvbWlzZTBcIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkb1RoZW5hYmxlKHgsIHRoZW4sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICB2YXIgcmV0ID0gcHJvbWlzZTtcbiAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcHVzaENvbnRleHQoKTtcbiAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wb3BDb250ZXh0KCk7XG4gICAgdmFyIHN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICB2YXIgcmVzdWx0ID0gdXRpbC50cnlDYXRjaCh0aGVuKS5jYWxsKHgsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgc3luY2hyb25vdXMgPSBmYWxzZTtcblxuICAgIGlmIChwcm9taXNlICYmIHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVzdWx0LmUsIHRydWUsIHRydWUpO1xuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIGlmICghcHJvbWlzZSkgcmV0dXJuO1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgICAgIGlmICghcHJvbWlzZSkgcmV0dXJuO1xuICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZWFzb24sIHN5bmNocm9ub3VzLCB0cnVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbnJldHVybiB0cnlDb252ZXJ0VG9Qcm9taXNlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3RoZW5hYmxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICBhcGlSZWplY3Rpb24sIFByb3h5YWJsZSkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG5cbmZ1bmN0aW9uIHRvUmVzb2x1dGlvblZhbHVlKHZhbCkge1xuICAgIHN3aXRjaCh2YWwpIHtcbiAgICBjYXNlIC0yOiByZXR1cm4gW107XG4gICAgY2FzZSAtMzogcmV0dXJuIHt9O1xuICAgIGNhc2UgLTY6IHJldHVybiBuZXcgTWFwKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBQcm9taXNlQXJyYXkodmFsdWVzKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UuX3Byb3BhZ2F0ZUZyb20odmFsdWVzLCAzKTtcbiAgICB9XG4gICAgcHJvbWlzZS5fc2V0T25DYW5jZWwodGhpcyk7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fdG90YWxSZXNvbHZlZCA9IDA7XG4gICAgdGhpcy5faW5pdCh1bmRlZmluZWQsIC0yKTtcbn1cbnV0aWwuaW5oZXJpdHMoUHJvbWlzZUFycmF5LCBQcm94eWFibGUpO1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoXywgcmVzb2x2ZVZhbHVlSWZFbXB0eSkge1xuICAgIHZhciB2YWx1ZXMgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXMuX3ZhbHVlcywgdGhpcy5fcHJvbWlzZSk7XG4gICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFsdWVzID0gdmFsdWVzLl90YXJnZXQoKTtcbiAgICAgICAgdmFyIGJpdEZpZWxkID0gdmFsdWVzLl9iaXRGaWVsZDtcbiAgICAgICAgO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXMuX3RoZW4oXG4gICAgICAgICAgICAgICAgaW5pdCxcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZVZhbHVlSWZFbXB0eVxuICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuX3ZhbHVlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWplY3QodmFsdWVzLl9yZWFzb24oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsdWVzID0gdXRpbC5hc0FycmF5KHZhbHVlcyk7XG4gICAgaWYgKHZhbHVlcyA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgZXJyID0gYXBpUmVqZWN0aW9uKFxuICAgICAgICAgICAgXCJleHBlY3RpbmcgYW4gYXJyYXkgb3IgYW4gaXRlcmFibGUgb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKHZhbHVlcykpLnJlYXNvbigpO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9yZWplY3RDYWxsYmFjayhlcnIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChyZXNvbHZlVmFsdWVJZkVtcHR5ID09PSAtNSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5QXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodG9SZXNvbHV0aW9uVmFsdWUocmVzb2x2ZVZhbHVlSWZFbXB0eSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXRlcmF0ZSh2YWx1ZXMpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faXRlcmF0ZSA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgIHZhciBsZW4gPSB0aGlzLmdldEFjdHVhbExlbmd0aCh2YWx1ZXMubGVuZ3RoKTtcbiAgICB0aGlzLl9sZW5ndGggPSBsZW47XG4gICAgdGhpcy5fdmFsdWVzID0gdGhpcy5zaG91bGRDb3B5VmFsdWVzKCkgPyBuZXcgQXJyYXkobGVuKSA6IHRoaXMuX3ZhbHVlcztcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcHJvbWlzZTtcbiAgICB2YXIgaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgIHZhciBiaXRGaWVsZCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZXNbaV0sIHJlc3VsdCk7XG5cbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICBiaXRGaWVsZCA9IG1heWJlUHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiaXRGaWVsZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgaWYgKGJpdEZpZWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGJpdEZpZWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3Byb3h5KHRoaXMsIGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpXSA9IG1heWJlUHJvbWlzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZChtYXliZVByb21pc2UuX3ZhbHVlKCksIGkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlUmVqZWN0ZWQobWF5YmVQcm9taXNlLl9yZWFzb24oKSwgaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlQ2FuY2VsbGVkKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRoaXMuX3Byb21pc2VGdWxmaWxsZWQobWF5YmVQcm9taXNlLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzUmVzb2x2ZWQpIHJlc3VsdC5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pc1Jlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMgPT09IG51bGw7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2NhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkgfHwgIXRoaXMuX3Byb21pc2UuX2lzQ2FuY2VsbGFibGUoKSkgcmV0dXJuO1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fY2FuY2VsKCk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZWFzb24sIGZhbHNlKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgIHZhciB0b3RhbFJlc29sdmVkID0gKyt0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgIGlmICh0b3RhbFJlc29sdmVkID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5fdG90YWxSZXNvbHZlZCsrO1xuICAgIHRoaXMuX3JlamVjdChyZWFzb24pO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSkgcmV0dXJuO1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFsdWVzLmNhbmNlbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW2ldIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlc1tpXS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuZ2V0QWN0dWFsTGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xuICAgIHJldHVybiBsZW47XG59O1xuXG5yZXR1cm4gUHJvbWlzZUFycmF5O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3Byb21pc2VfYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIGxvbmdTdGFja1RyYWNlcyA9IGZhbHNlO1xudmFyIGNvbnRleHRTdGFjayA9IFtdO1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcHJvbWlzZUNyZWF0ZWQgPSBmdW5jdGlvbigpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gZnVuY3Rpb24oKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9wb3BDb250ZXh0ID0gZnVuY3Rpb24oKSB7cmV0dXJuIG51bGw7fTtcblByb21pc2UuX3BlZWtDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3BlZWtDb250ZXh0ID0gZnVuY3Rpb24oKSB7fTtcblxuZnVuY3Rpb24gQ29udGV4dCgpIHtcbiAgICB0aGlzLl90cmFjZSA9IG5ldyBDb250ZXh0LkNhcHR1cmVkVHJhY2UocGVla0NvbnRleHQoKSk7XG59XG5Db250ZXh0LnByb3RvdHlwZS5fcHVzaENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3RyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fdHJhY2UuX3Byb21pc2VDcmVhdGVkID0gbnVsbDtcbiAgICAgICAgY29udGV4dFN0YWNrLnB1c2godGhpcy5fdHJhY2UpO1xuICAgIH1cbn07XG5cbkNvbnRleHQucHJvdG90eXBlLl9wb3BDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl90cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB0cmFjZSA9IGNvbnRleHRTdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHJldCA9IHRyYWNlLl9wcm9taXNlQ3JlYXRlZDtcbiAgICAgICAgdHJhY2UuX3Byb21pc2VDcmVhdGVkID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KCkge1xuICAgIGlmIChsb25nU3RhY2tUcmFjZXMpIHJldHVybiBuZXcgQ29udGV4dCgpO1xufVxuXG5mdW5jdGlvbiBwZWVrQ29udGV4dCgpIHtcbiAgICB2YXIgbGFzdEluZGV4ID0gY29udGV4dFN0YWNrLmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3RJbmRleCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0U3RhY2tbbGFzdEluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbkNvbnRleHQuQ2FwdHVyZWRUcmFjZSA9IG51bGw7XG5Db250ZXh0LmNyZWF0ZSA9IGNyZWF0ZUNvbnRleHQ7XG5Db250ZXh0LmRlYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHt9O1xuQ29udGV4dC5hY3RpdmF0ZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBQcm9taXNlX3B1c2hDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0O1xuICAgIHZhciBQcm9taXNlX3BvcENvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcG9wQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9QZWVrQ29udGV4dCA9IFByb21pc2UuX3BlZWtDb250ZXh0O1xuICAgIHZhciBQcm9taXNlX3BlZWtDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3BlZWtDb250ZXh0O1xuICAgIHZhciBQcm9taXNlX3Byb21pc2VDcmVhdGVkID0gUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkO1xuICAgIENvbnRleHQuZGVhY3RpdmF0ZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcHVzaENvbnRleHQgPSBQcm9taXNlX3B1c2hDb250ZXh0O1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IFByb21pc2VfcG9wQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5fcGVla0NvbnRleHQgPSBQcm9taXNlX1BlZWtDb250ZXh0O1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcGVla0NvbnRleHQgPSBQcm9taXNlX3BlZWtDb250ZXh0O1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcHJvbWlzZUNyZWF0ZWQgPSBQcm9taXNlX3Byb21pc2VDcmVhdGVkO1xuICAgICAgICBsb25nU3RhY2tUcmFjZXMgPSBmYWxzZTtcbiAgICB9O1xuICAgIGxvbmdTdGFja1RyYWNlcyA9IHRydWU7XG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gQ29udGV4dC5wcm90b3R5cGUuX3B1c2hDb250ZXh0O1xuICAgIFByb21pc2UucHJvdG90eXBlLl9wb3BDb250ZXh0ID0gQ29udGV4dC5wcm90b3R5cGUuX3BvcENvbnRleHQ7XG4gICAgUHJvbWlzZS5fcGVla0NvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcGVla0NvbnRleHQgPSBwZWVrQ29udGV4dDtcbiAgICBQcm9taXNlLnByb3RvdHlwZS5fcHJvbWlzZUNyZWF0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX3BlZWtDb250ZXh0KCk7XG4gICAgICAgIGlmIChjdHggJiYgY3R4Ll9wcm9taXNlQ3JlYXRlZCA9PSBudWxsKSBjdHguX3Byb21pc2VDcmVhdGVkID0gdGhpcztcbiAgICB9O1xufTtcbnJldHVybiBDb250ZXh0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2NvbnRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgQ29udGV4dCkge1xudmFyIGdldERvbWFpbiA9IFByb21pc2UuX2dldERvbWFpbjtcbnZhciBhc3luYyA9IFByb21pc2UuX2FzeW5jO1xudmFyIFdhcm5pbmcgPSByZXF1aXJlKFwiLi9lcnJvcnNcIikuV2FybmluZztcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBjYW5BdHRhY2hUcmFjZSA9IHV0aWwuY2FuQXR0YWNoVHJhY2U7XG52YXIgdW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZDtcbnZhciBwb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbjtcbnZhciBibHVlYmlyZEZyYW1lUGF0dGVybiA9XG4gICAgL1tcXFxcXFwvXWJsdWViaXJkW1xcXFxcXC9danNbXFxcXFxcL10ocmVsZWFzZXxkZWJ1Z3xpbnN0cnVtZW50ZWQpLztcbnZhciBub2RlRnJhbWVQYXR0ZXJuID0gL1xcKCg/OnRpbWVyc1xcLmpzKTpcXGQrOlxcZCtcXCkvO1xudmFyIHBhcnNlTGluZVBhdHRlcm4gPSAvW1xcLzxcXChdKC4rPyk6KFxcZCspOihcXGQrKVxcKT9cXHMqJC87XG52YXIgc3RhY2tGcmFtZVBhdHRlcm4gPSBudWxsO1xudmFyIGZvcm1hdFN0YWNrID0gbnVsbDtcbnZhciBpbmRlbnRTdGFja0ZyYW1lcyA9IGZhbHNlO1xudmFyIHByaW50V2FybmluZztcbnZhciBkZWJ1Z2dpbmcgPSAhISh1dGlsLmVudihcIkJMVUVCSVJEX0RFQlVHXCIpICE9IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChmYWxzZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuZW52KFwiQkxVRUJJUkRfREVCVUdcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmVudihcIk5PREVfRU5WXCIpID09PSBcImRldmVsb3BtZW50XCIpKTtcblxudmFyIHdhcm5pbmdzID0gISEodXRpbC5lbnYoXCJCTFVFQklSRF9XQVJOSU5HU1wiKSAhPSAwICYmXG4gICAgKGRlYnVnZ2luZyB8fCB1dGlsLmVudihcIkJMVUVCSVJEX1dBUk5JTkdTXCIpKSk7XG5cbnZhciBsb25nU3RhY2tUcmFjZXMgPSAhISh1dGlsLmVudihcIkJMVUVCSVJEX0xPTkdfU1RBQ0tfVFJBQ0VTXCIpICE9IDAgJiZcbiAgICAoZGVidWdnaW5nIHx8IHV0aWwuZW52KFwiQkxVRUJJUkRfTE9OR19TVEFDS19UUkFDRVNcIikpKTtcblxudmFyIHdGb3Jnb3R0ZW5SZXR1cm4gPSB1dGlsLmVudihcIkJMVUVCSVJEX1dfRk9SR09UVEVOX1JFVFVSTlwiKSAhPSAwICYmXG4gICAgKHdhcm5pbmdzIHx8ICEhdXRpbC5lbnYoXCJCTFVFQklSRF9XX0ZPUkdPVFRFTl9SRVRVUk5cIikpO1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgdGFyZ2V0Ll9iaXRGaWVsZCA9ICgodGFyZ2V0Ll9iaXRGaWVsZCAmICh+MTA0ODU3NikpIHxcbiAgICAgICAgICAgICAgICAgICAgICA1MjQyODgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Vuc3VyZVBvc3NpYmxlUmVqZWN0aW9uSGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoKHRoaXMuX2JpdEZpZWxkICYgNTI0Mjg4KSAhPT0gMCkgcmV0dXJuO1xuICAgIHRoaXMuX3NldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgYXN5bmMuaW52b2tlTGF0ZXIodGhpcy5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uLCB0aGlzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbklzSGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmaXJlUmVqZWN0aW9uRXZlbnQoXCJyZWplY3Rpb25IYW5kbGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCwgdW5kZWZpbmVkLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRSZXR1cm5lZE5vblVuZGVmaW5lZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAyNjg0MzU0NTY7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmV0dXJuZWROb25VbmRlZmluZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMjY4NDM1NDU2KSAhPT0gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2lzUmVqZWN0aW9uVW5oYW5kbGVkKCkpIHtcbiAgICAgICAgdmFyIHJlYXNvbiA9IHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xuICAgICAgICB0aGlzLl9zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkKCk7XG4gICAgICAgIGZpcmVSZWplY3Rpb25FdmVudChcInVuaGFuZGxlZFJlamVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiwgcmVhc29uLCB0aGlzKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMjYyMTQ0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH4yNjIxNDQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzVW5oYW5kbGVkUmVqZWN0aW9uTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDI2MjE0NCkgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFJlamVjdGlvbklzVW5oYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxMDQ4NTc2O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MTA0ODU3Nik7XG4gICAgaWYgKHRoaXMuX2lzVW5oYW5kbGVkUmVqZWN0aW9uTm90aWZpZWQoKSkge1xuICAgICAgICB0aGlzLl91bnNldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQoKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uSXNIYW5kbGVkKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzUmVqZWN0aW9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxMDQ4NTc2KSA+IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fd2FybiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHNob3VsZFVzZU93blRyYWNlLCBwcm9taXNlKSB7XG4gICAgcmV0dXJuIHdhcm4obWVzc2FnZSwgc2hvdWxkVXNlT3duVHJhY2UsIHByb21pc2UgfHwgdGhpcyk7XG59O1xuXG5Qcm9taXNlLm9uUG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgcG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24gPVxuICAgICAgICB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIiA/IChkb21haW4gPT09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xufTtcblxuUHJvbWlzZS5vblVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgdW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCA9XG4gICAgICAgIHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiID8gKGRvbWFpbiA9PT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG59O1xuXG52YXIgZGlzYWJsZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uKCkge307XG5Qcm9taXNlLmxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXN5bmMuaGF2ZUl0ZW1zUXVldWVkKCkgJiYgIWNvbmZpZy5sb25nU3RhY2tUcmFjZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuYWJsZSBsb25nIHN0YWNrIHRyYWNlcyBhZnRlciBwcm9taXNlcyBoYXZlIGJlZW4gY3JlYXRlZFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIGlmICghY29uZmlnLmxvbmdTdGFja1RyYWNlcyAmJiBsb25nU3RhY2tUcmFjZXNJc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgIHZhciBQcm9taXNlX2NhcHR1cmVTdGFja1RyYWNlID0gUHJvbWlzZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlO1xuICAgICAgICB2YXIgUHJvbWlzZV9hdHRhY2hFeHRyYVRyYWNlID0gUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2U7XG4gICAgICAgIGNvbmZpZy5sb25nU3RhY2tUcmFjZXMgPSB0cnVlO1xuICAgICAgICBkaXNhYmxlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoYXN5bmMuaGF2ZUl0ZW1zUXVldWVkKCkgJiYgIWNvbmZpZy5sb25nU3RhY2tUcmFjZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5hYmxlIGxvbmcgc3RhY2sgdHJhY2VzIGFmdGVyIHByb21pc2VzIGhhdmUgYmVlbiBjcmVhdGVkXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZSA9IFByb21pc2VfY2FwdHVyZVN0YWNrVHJhY2U7XG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZSA9IFByb21pc2VfYXR0YWNoRXh0cmFUcmFjZTtcbiAgICAgICAgICAgIENvbnRleHQuZGVhY3RpdmF0ZUxvbmdTdGFja1RyYWNlcygpO1xuICAgICAgICAgICAgYXN5bmMuZW5hYmxlVHJhbXBvbGluZSgpO1xuICAgICAgICAgICAgY29uZmlnLmxvbmdTdGFja1RyYWNlcyA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2UgPSBsb25nU3RhY2tUcmFjZXNDYXB0dXJlU3RhY2tUcmFjZTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2UgPSBsb25nU3RhY2tUcmFjZXNBdHRhY2hFeHRyYVRyYWNlO1xuICAgICAgICBDb250ZXh0LmFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzKCk7XG4gICAgICAgIGFzeW5jLmRpc2FibGVUcmFtcG9saW5lSWZOZWNlc3NhcnkoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLmhhc0xvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29uZmlnLmxvbmdTdGFja1RyYWNlcyAmJiBsb25nU3RhY2tUcmFjZXNJc1N1cHBvcnRlZCgpO1xufTtcblxudmFyIGZpcmVEb21FdmVudCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQobmFtZS50b0xvd2VyQ2FzZSgpLCB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZG9tRXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICB1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkb21FdmVudCA9IG5ldyBFdmVudChuYW1lLnRvTG93ZXJDYXNlKCksIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRvbUV2ZW50LmRldGFpbCA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiAhdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChkb21FdmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChcInRlc3Rpbmd0aGVldmVudFwiLCBmYWxzZSwgdHJ1ZSwge30pO1xuICAgICAgICAgICAgdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgICAgIGRvbUV2ZW50LmluaXRDdXN0b21FdmVudChuYW1lLnRvTG93ZXJDYXNlKCksIGZhbHNlLCB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGRvbUV2ZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59KSgpO1xuXG52YXIgZmlyZUdsb2JhbEV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmICh1dGlsLmlzTm9kZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbWl0LmFwcGx5KHByb2Nlc3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF1dGlsLmdsb2JhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gXCJvblwiICsgbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IHV0aWwuZ2xvYmFsW21ldGhvZE5hbWVdO1xuICAgICAgICAgICAgaWYgKCFtZXRob2QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG1ldGhvZC5hcHBseSh1dGlsLmdsb2JhbCwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH1cbn0pKCk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0KG5hbWUsIHByb21pc2UpIHtcbiAgICByZXR1cm4ge3Byb21pc2U6IHByb21pc2V9O1xufVxuXG52YXIgZXZlbnRUb09iamVjdEdlbmVyYXRvciA9IHtcbiAgICBwcm9taXNlQ3JlYXRlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgcHJvbWlzZUZ1bGZpbGxlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgcHJvbWlzZVJlamVjdGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICBwcm9taXNlUmVzb2x2ZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgIHByb21pc2VDYW5jZWxsZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgIHByb21pc2VDaGFpbmVkOiBmdW5jdGlvbihuYW1lLCBwcm9taXNlLCBjaGlsZCkge1xuICAgICAgICByZXR1cm4ge3Byb21pc2U6IHByb21pc2UsIGNoaWxkOiBjaGlsZH07XG4gICAgfSxcbiAgICB3YXJuaW5nOiBmdW5jdGlvbihuYW1lLCB3YXJuaW5nKSB7XG4gICAgICAgIHJldHVybiB7d2FybmluZzogd2FybmluZ307XG4gICAgfSxcbiAgICB1bmhhbmRsZWRSZWplY3Rpb246IGZ1bmN0aW9uIChuYW1lLCByZWFzb24sIHByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHtyZWFzb246IHJlYXNvbiwgcHJvbWlzZTogcHJvbWlzZX07XG4gICAgfSxcbiAgICByZWplY3Rpb25IYW5kbGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdFxufTtcblxudmFyIGFjdGl2ZUZpcmVFdmVudCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGdsb2JhbEV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBnbG9iYWxFdmVudEZpcmVkID0gZmlyZUdsb2JhbEV2ZW50LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUpO1xuICAgICAgICBnbG9iYWxFdmVudEZpcmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgZG9tRXZlbnRGaXJlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGRvbUV2ZW50RmlyZWQgPSBmaXJlRG9tRXZlbnQobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUb09iamVjdEdlbmVyYXRvcltuYW1lXS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIoZSk7XG4gICAgICAgIGRvbUV2ZW50RmlyZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBkb21FdmVudEZpcmVkIHx8IGdsb2JhbEV2ZW50RmlyZWQ7XG59O1xuXG5Qcm9taXNlLmNvbmZpZyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICBvcHRzID0gT2JqZWN0KG9wdHMpO1xuICAgIGlmIChcImxvbmdTdGFja1RyYWNlc1wiIGluIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMubG9uZ1N0YWNrVHJhY2VzKSB7XG4gICAgICAgICAgICBQcm9taXNlLmxvbmdTdGFja1RyYWNlcygpO1xuICAgICAgICB9IGVsc2UgaWYgKCFvcHRzLmxvbmdTdGFja1RyYWNlcyAmJiBQcm9taXNlLmhhc0xvbmdTdGFja1RyYWNlcygpKSB7XG4gICAgICAgICAgICBkaXNhYmxlTG9uZ1N0YWNrVHJhY2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKFwid2FybmluZ3NcIiBpbiBvcHRzKSB7XG4gICAgICAgIHZhciB3YXJuaW5nc09wdGlvbiA9IG9wdHMud2FybmluZ3M7XG4gICAgICAgIGNvbmZpZy53YXJuaW5ncyA9ICEhd2FybmluZ3NPcHRpb247XG4gICAgICAgIHdGb3Jnb3R0ZW5SZXR1cm4gPSBjb25maWcud2FybmluZ3M7XG5cbiAgICAgICAgaWYgKHV0aWwuaXNPYmplY3Qod2FybmluZ3NPcHRpb24pKSB7XG4gICAgICAgICAgICBpZiAoXCJ3Rm9yZ290dGVuUmV0dXJuXCIgaW4gd2FybmluZ3NPcHRpb24pIHtcbiAgICAgICAgICAgICAgICB3Rm9yZ290dGVuUmV0dXJuID0gISF3YXJuaW5nc09wdGlvbi53Rm9yZ290dGVuUmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChcImNhbmNlbGxhdGlvblwiIGluIG9wdHMgJiYgb3B0cy5jYW5jZWxsYXRpb24gJiYgIWNvbmZpZy5jYW5jZWxsYXRpb24pIHtcbiAgICAgICAgaWYgKGFzeW5jLmhhdmVJdGVtc1F1ZXVlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJjYW5ub3QgZW5hYmxlIGNhbmNlbGxhdGlvbiBhZnRlciBwcm9taXNlcyBhcmUgaW4gdXNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9jbGVhckNhbmNlbGxhdGlvbkRhdGEgPVxuICAgICAgICAgICAgY2FuY2VsbGF0aW9uQ2xlYXJDYW5jZWxsYXRpb25EYXRhO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcHJvcGFnYXRlRnJvbSA9IGNhbmNlbGxhdGlvblByb3BhZ2F0ZUZyb207XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9vbkNhbmNlbCA9IGNhbmNlbGxhdGlvbk9uQ2FuY2VsO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fc2V0T25DYW5jZWwgPSBjYW5jZWxsYXRpb25TZXRPbkNhbmNlbDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrID1cbiAgICAgICAgICAgIGNhbmNlbGxhdGlvbkF0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZXhlY3V0ZSA9IGNhbmNlbGxhdGlvbkV4ZWN1dGU7XG4gICAgICAgIHByb3BhZ2F0ZUZyb21GdW5jdGlvbiA9IGNhbmNlbGxhdGlvblByb3BhZ2F0ZUZyb207XG4gICAgICAgIGNvbmZpZy5jYW5jZWxsYXRpb24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoXCJtb25pdG9yaW5nXCIgaW4gb3B0cykge1xuICAgICAgICBpZiAob3B0cy5tb25pdG9yaW5nICYmICFjb25maWcubW9uaXRvcmluZykge1xuICAgICAgICAgICAgY29uZmlnLm1vbml0b3JpbmcgPSB0cnVlO1xuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2ZpcmVFdmVudCA9IGFjdGl2ZUZpcmVFdmVudDtcbiAgICAgICAgfSBlbHNlIGlmICghb3B0cy5tb25pdG9yaW5nICYmIGNvbmZpZy5tb25pdG9yaW5nKSB7XG4gICAgICAgICAgICBjb25maWcubW9uaXRvcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2ZpcmVFdmVudCA9IGRlZmF1bHRGaXJlRXZlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2U7XG59O1xuXG5mdW5jdGlvbiBkZWZhdWx0RmlyZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cblxuUHJvbWlzZS5wcm90b3R5cGUuX2ZpcmVFdmVudCA9IGRlZmF1bHRGaXJlRXZlbnQ7XG5Qcm9taXNlLnByb3RvdHlwZS5fZXhlY3V0ZSA9IGZ1bmN0aW9uKGV4ZWN1dG9yLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICB0cnkge1xuICAgICAgICBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxufTtcblByb21pc2UucHJvdG90eXBlLl9vbkNhbmNlbCA9IGZ1bmN0aW9uICgpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX3NldE9uQ2FuY2VsID0gZnVuY3Rpb24gKGhhbmRsZXIpIHsgOyB9O1xuUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24ob25DYW5jZWwpIHtcbiAgICA7XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZSA9IGZ1bmN0aW9uICgpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX2NsZWFyQ2FuY2VsbGF0aW9uRGF0YSA9IGZ1bmN0aW9uKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fcHJvcGFnYXRlRnJvbSA9IGZ1bmN0aW9uIChwYXJlbnQsIGZsYWdzKSB7XG4gICAgO1xuICAgIDtcbn07XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvbkV4ZWN1dGUoZXhlY3V0b3IsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgICBleGVjdXRvcihyZXNvbHZlLCByZWplY3QsIGZ1bmN0aW9uKG9uQ2FuY2VsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uQ2FuY2VsICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib25DYW5jZWwgbXVzdCBiZSBhIGZ1bmN0aW9uLCBnb3Q6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwudG9TdHJpbmcob25DYW5jZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKG9uQ2FuY2VsKTtcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvbkF0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKG9uQ2FuY2VsKSB7XG4gICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxhYmxlKCkpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIHByZXZpb3VzT25DYW5jZWwgPSB0aGlzLl9vbkNhbmNlbCgpO1xuICAgIGlmIChwcmV2aW91c09uQ2FuY2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNBcnJheShwcmV2aW91c09uQ2FuY2VsKSkge1xuICAgICAgICAgICAgcHJldmlvdXNPbkNhbmNlbC5wdXNoKG9uQ2FuY2VsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldE9uQ2FuY2VsKFtwcmV2aW91c09uQ2FuY2VsLCBvbkNhbmNlbF0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0T25DYW5jZWwob25DYW5jZWwpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uT25DYW5jZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uQ2FuY2VsRmllbGQ7XG59XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvblNldE9uQ2FuY2VsKG9uQ2FuY2VsKSB7XG4gICAgdGhpcy5fb25DYW5jZWxGaWVsZCA9IG9uQ2FuY2VsO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25DbGVhckNhbmNlbGxhdGlvbkRhdGEoKSB7XG4gICAgdGhpcy5fY2FuY2VsbGF0aW9uUGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29uQ2FuY2VsRmllbGQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvblByb3BhZ2F0ZUZyb20ocGFyZW50LCBmbGFncykge1xuICAgIGlmICgoZmxhZ3MgJiAxKSAhPT0gMCkge1xuICAgICAgICB0aGlzLl9jYW5jZWxsYXRpb25QYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHZhciBicmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gcGFyZW50Ll9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsO1xuICAgICAgICBpZiAoYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBicmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPSBicmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsICsgMTtcbiAgICB9XG4gICAgaWYgKChmbGFncyAmIDIpICE9PSAwICYmIHBhcmVudC5faXNCb3VuZCgpKSB7XG4gICAgICAgIHRoaXMuX3NldEJvdW5kVG8ocGFyZW50Ll9ib3VuZFRvKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRpbmdQcm9wYWdhdGVGcm9tKHBhcmVudCwgZmxhZ3MpIHtcbiAgICBpZiAoKGZsYWdzICYgMikgIT09IDAgJiYgcGFyZW50Ll9pc0JvdW5kKCkpIHtcbiAgICAgICAgdGhpcy5fc2V0Qm91bmRUbyhwYXJlbnQuX2JvdW5kVG8pO1xuICAgIH1cbn1cbnZhciBwcm9wYWdhdGVGcm9tRnVuY3Rpb24gPSBiaW5kaW5nUHJvcGFnYXRlRnJvbTtcblxuZnVuY3Rpb24gYm91bmRWYWx1ZUZ1bmN0aW9uKCkge1xuICAgIHZhciByZXQgPSB0aGlzLl9ib3VuZFRvO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgaWYgKHJldC5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldC52YWx1ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGxvbmdTdGFja1RyYWNlc0NhcHR1cmVTdGFja1RyYWNlKCkge1xuICAgIHRoaXMuX3RyYWNlID0gbmV3IENhcHR1cmVkVHJhY2UodGhpcy5fcGVla0NvbnRleHQoKSk7XG59XG5cbmZ1bmN0aW9uIGxvbmdTdGFja1RyYWNlc0F0dGFjaEV4dHJhVHJhY2UoZXJyb3IsIGlnbm9yZVNlbGYpIHtcbiAgICBpZiAoY2FuQXR0YWNoVHJhY2UoZXJyb3IpKSB7XG4gICAgICAgIHZhciB0cmFjZSA9IHRoaXMuX3RyYWNlO1xuICAgICAgICBpZiAodHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGlnbm9yZVNlbGYpIHRyYWNlID0gdHJhY2UuX3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJhY2UuYXR0YWNoRXh0cmFUcmFjZShlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWVycm9yLl9fc3RhY2tDbGVhbmVkX18pIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZVN0YWNrQW5kTWVzc2FnZShlcnJvcik7XG4gICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKGVycm9yLCBcInN0YWNrXCIsXG4gICAgICAgICAgICAgICAgcGFyc2VkLm1lc3NhZ2UgKyBcIlxcblwiICsgcGFyc2VkLnN0YWNrLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJfX3N0YWNrQ2xlYW5lZF9fXCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ZvcmdvdHRlblJldHVybnMocmV0dXJuVmFsdWUsIHByb21pc2VDcmVhdGVkLCBuYW1lLCBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCkge1xuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gdW5kZWZpbmVkICYmIHByb21pc2VDcmVhdGVkICE9PSBudWxsICYmXG4gICAgICAgIHdGb3Jnb3R0ZW5SZXR1cm4pIHtcbiAgICAgICAgaWYgKHBhcmVudCAhPT0gdW5kZWZpbmVkICYmIHBhcmVudC5fcmV0dXJuZWROb25VbmRlZmluZWQoKSkgcmV0dXJuO1xuICAgICAgICBpZiAoKHByb21pc2UuX2JpdEZpZWxkICYgNjU1MzUpID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgaWYgKG5hbWUpIG5hbWUgPSBuYW1lICsgXCIgXCI7XG4gICAgICAgIHZhciBoYW5kbGVyTGluZSA9IFwiXCI7XG4gICAgICAgIHZhciBjcmVhdG9yTGluZSA9IFwiXCI7XG4gICAgICAgIGlmIChwcm9taXNlQ3JlYXRlZC5fdHJhY2UpIHtcbiAgICAgICAgICAgIHZhciB0cmFjZUxpbmVzID0gcHJvbWlzZUNyZWF0ZWQuX3RyYWNlLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gY2xlYW5TdGFjayh0cmFjZUxpbmVzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc3RhY2tbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlRnJhbWVQYXR0ZXJuLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVNYXRjaGVzID0gbGluZS5tYXRjaChwYXJzZUxpbmVQYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVNYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyTGluZSAgPSBcImF0IFwiICsgbGluZU1hdGNoZXNbMV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiOlwiICsgbGluZU1hdGNoZXNbMl0gKyBcIjpcIiArIGxpbmVNYXRjaGVzWzNdICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFVzZXJMaW5lID0gc3RhY2tbMF07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFjZUxpbmVzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNlTGluZXNbaV0gPT09IGZpcnN0VXNlckxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0b3JMaW5lID0gXCJcXG5cIiArIHRyYWNlTGluZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbXNnID0gXCJhIHByb21pc2Ugd2FzIGNyZWF0ZWQgaW4gYSBcIiArIG5hbWUgK1xuICAgICAgICAgICAgXCJoYW5kbGVyIFwiICsgaGFuZGxlckxpbmUgKyBcImJ1dCB3YXMgbm90IHJldHVybmVkIGZyb20gaXQsIFwiICtcbiAgICAgICAgICAgIFwic2VlIGh0dHA6Ly9nb28uZ2wvclJxTVV3XCIgK1xuICAgICAgICAgICAgY3JlYXRvckxpbmU7XG4gICAgICAgIHByb21pc2UuX3dhcm4obXNnLCB0cnVlLCBwcm9taXNlQ3JlYXRlZCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZXByZWNhdGVkKG5hbWUsIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBuYW1lICtcbiAgICAgICAgXCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXCI7XG4gICAgaWYgKHJlcGxhY2VtZW50KSBtZXNzYWdlICs9IFwiIFVzZSBcIiArIHJlcGxhY2VtZW50ICsgXCIgaW5zdGVhZC5cIjtcbiAgICByZXR1cm4gd2FybihtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gd2FybihtZXNzYWdlLCBzaG91bGRVc2VPd25UcmFjZSwgcHJvbWlzZSkge1xuICAgIGlmICghY29uZmlnLndhcm5pbmdzKSByZXR1cm47XG4gICAgdmFyIHdhcm5pbmcgPSBuZXcgV2FybmluZyhtZXNzYWdlKTtcbiAgICB2YXIgY3R4O1xuICAgIGlmIChzaG91bGRVc2VPd25UcmFjZSkge1xuICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHdhcm5pbmcpO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLmxvbmdTdGFja1RyYWNlcyAmJiAoY3R4ID0gUHJvbWlzZS5fcGVla0NvbnRleHQoKSkpIHtcbiAgICAgICAgY3R4LmF0dGFjaEV4dHJhVHJhY2Uod2FybmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlU3RhY2tBbmRNZXNzYWdlKHdhcm5pbmcpO1xuICAgICAgICB3YXJuaW5nLnN0YWNrID0gcGFyc2VkLm1lc3NhZ2UgKyBcIlxcblwiICsgcGFyc2VkLnN0YWNrLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuXG4gICAgaWYgKCFhY3RpdmVGaXJlRXZlbnQoXCJ3YXJuaW5nXCIsIHdhcm5pbmcpKSB7XG4gICAgICAgIGZvcm1hdEFuZExvZ0Vycm9yKHdhcm5pbmcsIFwiXCIsIHRydWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVjb25zdHJ1Y3RTdGFjayhtZXNzYWdlLCBzdGFja3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgc3RhY2tzW2ldLnB1c2goXCJGcm9tIHByZXZpb3VzIGV2ZW50OlwiKTtcbiAgICAgICAgc3RhY2tzW2ldID0gc3RhY2tzW2ldLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIGlmIChpIDwgc3RhY2tzLmxlbmd0aCkge1xuICAgICAgICBzdGFja3NbaV0gPSBzdGFja3NbaV0uam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2tzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZU9yRW1wdHlKdW1wcyhzdGFja3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoc3RhY2tzW2ldLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgKChpICsgMSA8IHN0YWNrcy5sZW5ndGgpICYmIHN0YWNrc1tpXVswXSA9PT0gc3RhY2tzW2krMV1bMF0pKSB7XG4gICAgICAgICAgICBzdGFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVDb21tb25Sb290cyhzdGFja3MpIHtcbiAgICB2YXIgY3VycmVudCA9IHN0YWNrc1swXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHN0YWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcHJldiA9IHN0YWNrc1tpXTtcbiAgICAgICAgdmFyIGN1cnJlbnRMYXN0SW5kZXggPSBjdXJyZW50Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBjdXJyZW50TGFzdExpbmUgPSBjdXJyZW50W2N1cnJlbnRMYXN0SW5kZXhdO1xuICAgICAgICB2YXIgY29tbW9uUm9vdE1lZXRQb2ludCA9IC0xO1xuXG4gICAgICAgIGZvciAodmFyIGogPSBwcmV2Lmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICBpZiAocHJldltqXSA9PT0gY3VycmVudExhc3RMaW5lKSB7XG4gICAgICAgICAgICAgICAgY29tbW9uUm9vdE1lZXRQb2ludCA9IGo7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gY29tbW9uUm9vdE1lZXRQb2ludDsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gcHJldltqXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50W2N1cnJlbnRMYXN0SW5kZXhdID09PSBsaW5lKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5wb3AoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGFzdEluZGV4LS07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBwcmV2O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5TdGFjayhzdGFjaykge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gc3RhY2tbaV07XG4gICAgICAgIHZhciBpc1RyYWNlTGluZSA9IFwiICAgIChObyBzdGFjayB0cmFjZSlcIiA9PT0gbGluZSB8fFxuICAgICAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4udGVzdChsaW5lKTtcbiAgICAgICAgdmFyIGlzSW50ZXJuYWxGcmFtZSA9IGlzVHJhY2VMaW5lICYmIHNob3VsZElnbm9yZShsaW5lKTtcbiAgICAgICAgaWYgKGlzVHJhY2VMaW5lICYmICFpc0ludGVybmFsRnJhbWUpIHtcbiAgICAgICAgICAgIGlmIChpbmRlbnRTdGFja0ZyYW1lcyAmJiBsaW5lLmNoYXJBdCgwKSAhPT0gXCIgXCIpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gXCIgICAgXCIgKyBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0LnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc3RhY2tGcmFtZXNBc0FycmF5KGVycm9yKSB7XG4gICAgdmFyIHN0YWNrID0gZXJyb3Iuc3RhY2sucmVwbGFjZSgvXFxzKyQvZywgXCJcIikuc3BsaXQoXCJcXG5cIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IHN0YWNrW2ldO1xuICAgICAgICBpZiAoXCIgICAgKE5vIHN0YWNrIHRyYWNlKVwiID09PSBsaW5lIHx8IHN0YWNrRnJhbWVQYXR0ZXJuLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpID4gMCAmJiBlcnJvci5uYW1lICE9IFwiU3ludGF4RXJyb3JcIikge1xuICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKGkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2s7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RhY2tBbmRNZXNzYWdlKGVycm9yKSB7XG4gICAgdmFyIHN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgdmFyIG1lc3NhZ2UgPSBlcnJvci50b1N0cmluZygpO1xuICAgIHN0YWNrID0gdHlwZW9mIHN0YWNrID09PSBcInN0cmluZ1wiICYmIHN0YWNrLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICA/IHN0YWNrRnJhbWVzQXNBcnJheShlcnJvcikgOiBbXCIgICAgKE5vIHN0YWNrIHRyYWNlKVwiXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBzdGFjazogZXJyb3IubmFtZSA9PSBcIlN5bnRheEVycm9yXCIgPyBzdGFjayA6IGNsZWFuU3RhY2soc3RhY2spXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0QW5kTG9nRXJyb3IoZXJyb3IsIHRpdGxlLCBpc1NvZnQpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2U7XG4gICAgICAgIGlmICh1dGlsLmlzT2JqZWN0KGVycm9yKSkge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgICAgICAgICBtZXNzYWdlID0gdGl0bGUgKyBmb3JtYXRTdGFjayhzdGFjaywgZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRpdGxlICsgU3RyaW5nKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByaW50V2FybmluZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcobWVzc2FnZSwgaXNTb2Z0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29uc29sZS5sb2cgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUubG9nID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlyZVJlamVjdGlvbkV2ZW50KG5hbWUsIGxvY2FsSGFuZGxlciwgcmVhc29uLCBwcm9taXNlKSB7XG4gICAgdmFyIGxvY2FsRXZlbnRGaXJlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxvY2FsRXZlbnRGaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJyZWplY3Rpb25IYW5kbGVkXCIpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEhhbmRsZXIocHJvbWlzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvY2FsSGFuZGxlcihyZWFzb24sIHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUpO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSBcInVuaGFuZGxlZFJlamVjdGlvblwiKSB7XG4gICAgICAgIGlmICghYWN0aXZlRmlyZUV2ZW50KG5hbWUsIHJlYXNvbiwgcHJvbWlzZSkgJiYgIWxvY2FsRXZlbnRGaXJlZCkge1xuICAgICAgICAgICAgZm9ybWF0QW5kTG9nRXJyb3IocmVhc29uLCBcIlVuaGFuZGxlZCByZWplY3Rpb24gXCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlRmlyZUV2ZW50KG5hbWUsIHByb21pc2UpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0Tm9uRXJyb3Iob2JqKSB7XG4gICAgdmFyIHN0cjtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHN0ciA9IFwiW2Z1bmN0aW9uIFwiICtcbiAgICAgICAgICAgIChvYmoubmFtZSB8fCBcImFub255bW91c1wiKSArXG4gICAgICAgICAgICBcIl1cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBvYmogJiYgdHlwZW9mIG9iai50b1N0cmluZyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IG9iai50b1N0cmluZygpIDogdXRpbC50b1N0cmluZyhvYmopO1xuICAgICAgICB2YXIgcnVzZWxlc3NUb1N0cmluZyA9IC9cXFtvYmplY3QgW2EtekEtWjAtOSRfXStcXF0vO1xuICAgICAgICBpZiAocnVzZWxlc3NUb1N0cmluZy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1N0ciA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgICAgICAgICAgICAgc3RyID0gbmV3U3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2goZSkge1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN0ciA9IFwiKGVtcHR5IGFycmF5KVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoXCIoPFwiICsgc25pcChzdHIpICsgXCI+LCBubyBzdGFjayB0cmFjZSlcIik7XG59XG5cbmZ1bmN0aW9uIHNuaXAoc3RyKSB7XG4gICAgdmFyIG1heENoYXJzID0gNDE7XG4gICAgaWYgKHN0ci5sZW5ndGggPCBtYXhDaGFycykge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBtYXhDaGFycyAtIDMpICsgXCIuLi5cIjtcbn1cblxuZnVuY3Rpb24gbG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG52YXIgc2hvdWxkSWdub3JlID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcbnZhciBwYXJzZUxpbmVJbmZvUmVnZXggPSAvW1xcLzxcXChdKFteOlxcL10rKTooXFxkKyk6KD86XFxkKylcXCk/XFxzKiQvO1xuZnVuY3Rpb24gcGFyc2VMaW5lSW5mbyhsaW5lKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBsaW5lLm1hdGNoKHBhcnNlTGluZUluZm9SZWdleCk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpbGVOYW1lOiBtYXRjaGVzWzFdLFxuICAgICAgICAgICAgbGluZTogcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRCb3VuZHMoZmlyc3RMaW5lRXJyb3IsIGxhc3RMaW5lRXJyb3IpIHtcbiAgICBpZiAoIWxvbmdTdGFja1RyYWNlc0lzU3VwcG9ydGVkKCkpIHJldHVybjtcbiAgICB2YXIgZmlyc3RTdGFja0xpbmVzID0gZmlyc3RMaW5lRXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgdmFyIGxhc3RTdGFja0xpbmVzID0gbGFzdExpbmVFcnJvci5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICB2YXIgZmlyc3RJbmRleCA9IC0xO1xuICAgIHZhciBsYXN0SW5kZXggPSAtMTtcbiAgICB2YXIgZmlyc3RGaWxlTmFtZTtcbiAgICB2YXIgbGFzdEZpbGVOYW1lO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3RTdGFja0xpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUxpbmVJbmZvKGZpcnN0U3RhY2tMaW5lc1tpXSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGZpcnN0RmlsZU5hbWUgPSByZXN1bHQuZmlsZU5hbWU7XG4gICAgICAgICAgICBmaXJzdEluZGV4ID0gcmVzdWx0LmxpbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RTdGFja0xpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUxpbmVJbmZvKGxhc3RTdGFja0xpbmVzW2ldKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgbGFzdEZpbGVOYW1lID0gcmVzdWx0LmZpbGVOYW1lO1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gcmVzdWx0LmxpbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmlyc3RJbmRleCA8IDAgfHwgbGFzdEluZGV4IDwgMCB8fCAhZmlyc3RGaWxlTmFtZSB8fCAhbGFzdEZpbGVOYW1lIHx8XG4gICAgICAgIGZpcnN0RmlsZU5hbWUgIT09IGxhc3RGaWxlTmFtZSB8fCBmaXJzdEluZGV4ID49IGxhc3RJbmRleCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2hvdWxkSWdub3JlID0gZnVuY3Rpb24obGluZSkge1xuICAgICAgICBpZiAoYmx1ZWJpcmRGcmFtZVBhdHRlcm4udGVzdChsaW5lKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBpbmZvID0gcGFyc2VMaW5lSW5mbyhsaW5lKTtcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgIGlmIChpbmZvLmZpbGVOYW1lID09PSBmaXJzdEZpbGVOYW1lICYmXG4gICAgICAgICAgICAgICAgKGZpcnN0SW5kZXggPD0gaW5mby5saW5lICYmIGluZm8ubGluZSA8PSBsYXN0SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIENhcHR1cmVkVHJhY2UocGFyZW50KSB7XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuX3Byb21pc2VzQ3JlYXRlZCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuX2xlbmd0aCA9IDEgKyAocGFyZW50ID09PSB1bmRlZmluZWQgPyAwIDogcGFyZW50Ll9sZW5ndGgpO1xuICAgIGNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENhcHR1cmVkVHJhY2UpO1xuICAgIGlmIChsZW5ndGggPiAzMikgdGhpcy51bmN5Y2xlKCk7XG59XG51dGlsLmluaGVyaXRzKENhcHR1cmVkVHJhY2UsIEVycm9yKTtcbkNvbnRleHQuQ2FwdHVyZWRUcmFjZSA9IENhcHR1cmVkVHJhY2U7XG5cbkNhcHR1cmVkVHJhY2UucHJvdG90eXBlLnVuY3ljbGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCAyKSByZXR1cm47XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIHN0YWNrVG9JbmRleCA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG5vZGUgPSB0aGlzOyBub2RlICE9PSB1bmRlZmluZWQ7ICsraSkge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5fcGFyZW50O1xuICAgIH1cbiAgICBsZW5ndGggPSB0aGlzLl9sZW5ndGggPSBpO1xuICAgIGZvciAodmFyIGkgPSBsZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgc3RhY2sgPSBub2Rlc1tpXS5zdGFjaztcbiAgICAgICAgaWYgKHN0YWNrVG9JbmRleFtzdGFja10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhY2tUb0luZGV4W3N0YWNrXSA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY3VycmVudFN0YWNrID0gbm9kZXNbaV0uc3RhY2s7XG4gICAgICAgIHZhciBpbmRleCA9IHN0YWNrVG9JbmRleFtjdXJyZW50U3RhY2tdO1xuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpbmRleCAhPT0gaSkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIG5vZGVzW2luZGV4IC0gMV0uX3BhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBub2Rlc1tpbmRleCAtIDFdLl9sZW5ndGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXNbaV0uX3BhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG5vZGVzW2ldLl9sZW5ndGggPSAxO1xuICAgICAgICAgICAgdmFyIGN5Y2xlRWRnZU5vZGUgPSBpID4gMCA/IG5vZGVzW2kgLSAxXSA6IHRoaXM7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQgPSBub2Rlc1tpbmRleCArIDFdO1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudC51bmN5Y2xlKCk7XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fbGVuZ3RoID1cbiAgICAgICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50Ll9sZW5ndGggKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fbGVuZ3RoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdXJyZW50Q2hpbGRMZW5ndGggPSBjeWNsZUVkZ2VOb2RlLl9sZW5ndGggKyAxO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgLSAyOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgICAgIG5vZGVzW2pdLl9sZW5ndGggPSBjdXJyZW50Q2hpbGRMZW5ndGg7XG4gICAgICAgICAgICAgICAgY3VycmVudENoaWxkTGVuZ3RoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5DYXB0dXJlZFRyYWNlLnByb3RvdHlwZS5hdHRhY2hFeHRyYVRyYWNlID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IuX19zdGFja0NsZWFuZWRfXykgcmV0dXJuO1xuICAgIHRoaXMudW5jeWNsZSgpO1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZVN0YWNrQW5kTWVzc2FnZShlcnJvcik7XG4gICAgdmFyIG1lc3NhZ2UgPSBwYXJzZWQubWVzc2FnZTtcbiAgICB2YXIgc3RhY2tzID0gW3BhcnNlZC5zdGFja107XG5cbiAgICB2YXIgdHJhY2UgPSB0aGlzO1xuICAgIHdoaWxlICh0cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0YWNrcy5wdXNoKGNsZWFuU3RhY2sodHJhY2Uuc3RhY2suc3BsaXQoXCJcXG5cIikpKTtcbiAgICAgICAgdHJhY2UgPSB0cmFjZS5fcGFyZW50O1xuICAgIH1cbiAgICByZW1vdmVDb21tb25Sb290cyhzdGFja3MpO1xuICAgIHJlbW92ZUR1cGxpY2F0ZU9yRW1wdHlKdW1wcyhzdGFja3MpO1xuICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwic3RhY2tcIiwgcmVjb25zdHJ1Y3RTdGFjayhtZXNzYWdlLCBzdGFja3MpKTtcbiAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKGVycm9yLCBcIl9fc3RhY2tDbGVhbmVkX19cIiwgdHJ1ZSk7XG59O1xuXG52YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSAoZnVuY3Rpb24gc3RhY2tEZXRlY3Rpb24oKSB7XG4gICAgdmFyIHY4c3RhY2tGcmFtZVBhdHRlcm4gPSAvXlxccyphdFxccyovO1xuICAgIHZhciB2OHN0YWNrRm9ybWF0dGVyID0gZnVuY3Rpb24oc3RhY2ssIGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhY2sgPT09IFwic3RyaW5nXCIpIHJldHVybiBzdGFjaztcblxuICAgICAgICBpZiAoZXJyb3IubmFtZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvci50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXROb25FcnJvcihlcnJvcik7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCArPSA2O1xuICAgICAgICBzdGFja0ZyYW1lUGF0dGVybiA9IHY4c3RhY2tGcmFtZVBhdHRlcm47XG4gICAgICAgIGZvcm1hdFN0YWNrID0gdjhzdGFja0Zvcm1hdHRlcjtcbiAgICAgICAgdmFyIGNhcHR1cmVTdGFja1RyYWNlID0gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U7XG5cbiAgICAgICAgc2hvdWxkSWdub3JlID0gZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJsdWViaXJkRnJhbWVQYXR0ZXJuLnRlc3QobGluZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyZWNlaXZlciwgaWdub3JlVW50aWwpIHtcbiAgICAgICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCArPSA2O1xuICAgICAgICAgICAgY2FwdHVyZVN0YWNrVHJhY2UocmVjZWl2ZXIsIGlnbm9yZVVudGlsKTtcbiAgICAgICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCAtPSA2O1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG5cbiAgICBpZiAodHlwZW9mIGVyci5zdGFjayA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICBlcnIuc3RhY2suc3BsaXQoXCJcXG5cIilbMF0uaW5kZXhPZihcInN0YWNrRGV0ZWN0aW9uQFwiKSA+PSAwKSB7XG4gICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuID0gL0AvO1xuICAgICAgICBmb3JtYXRTdGFjayA9IHY4c3RhY2tGb3JtYXR0ZXI7XG4gICAgICAgIGluZGVudFN0YWNrRnJhbWVzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNhcHR1cmVTdGFja1RyYWNlKG8pIHtcbiAgICAgICAgICAgIG8uc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgaGFzU3RhY2tBZnRlclRocm93O1xuICAgIHRyeSB7IHRocm93IG5ldyBFcnJvcigpOyB9XG4gICAgY2F0Y2goZSkge1xuICAgICAgICBoYXNTdGFja0FmdGVyVGhyb3cgPSAoXCJzdGFja1wiIGluIGUpO1xuICAgIH1cbiAgICBpZiAoIShcInN0YWNrXCIgaW4gZXJyKSAmJiBoYXNTdGFja0FmdGVyVGhyb3cgJiZcbiAgICAgICAgdHlwZW9mIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzdGFja0ZyYW1lUGF0dGVybiA9IHY4c3RhY2tGcmFtZVBhdHRlcm47XG4gICAgICAgIGZvcm1hdFN0YWNrID0gdjhzdGFja0Zvcm1hdHRlcjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNhcHR1cmVTdGFja1RyYWNlKG8pIHtcbiAgICAgICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCArPSA2O1xuICAgICAgICAgICAgdHJ5IHsgdGhyb3cgbmV3IEVycm9yKCk7IH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHsgby5zdGFjayA9IGUuc3RhY2s7IH1cbiAgICAgICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCAtPSA2O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZvcm1hdFN0YWNrID0gZnVuY3Rpb24oc3RhY2ssIGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhY2sgPT09IFwic3RyaW5nXCIpIHJldHVybiBzdGFjaztcblxuICAgICAgICBpZiAoKHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgdHlwZW9mIGVycm9yID09PSBcImZ1bmN0aW9uXCIpICYmXG4gICAgICAgICAgICBlcnJvci5uYW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE5vbkVycm9yKGVycm9yKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIG51bGw7XG5cbn0pKFtdKTtcblxuaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLndhcm4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfTtcbiAgICBpZiAodXRpbC5pc05vZGUgJiYgcHJvY2Vzcy5zdGRlcnIuaXNUVFkpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24obWVzc2FnZSwgaXNTb2Z0KSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBpc1NvZnQgPyBcIlxcdTAwMWJbMzNtXCIgOiBcIlxcdTAwMWJbMzFtXCI7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oY29sb3IgKyBtZXNzYWdlICsgXCJcXHUwMDFiWzBtXFxuXCIpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIXV0aWwuaXNOb2RlICYmIHR5cGVvZiAobmV3IEVycm9yKCkuc3RhY2spID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGlzU29mdCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiJWNcIiArIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NvZnQgPyBcImNvbG9yOiBkYXJrb3JhbmdlXCIgOiBcImNvbG9yOiByZWRcIik7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG52YXIgY29uZmlnID0ge1xuICAgIHdhcm5pbmdzOiB3YXJuaW5ncyxcbiAgICBsb25nU3RhY2tUcmFjZXM6IGZhbHNlLFxuICAgIGNhbmNlbGxhdGlvbjogZmFsc2UsXG4gICAgbW9uaXRvcmluZzogZmFsc2Vcbn07XG5cbmlmIChsb25nU3RhY2tUcmFjZXMpIFByb21pc2UubG9uZ1N0YWNrVHJhY2VzKCk7XG5cbnJldHVybiB7XG4gICAgbG9uZ1N0YWNrVHJhY2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5sb25nU3RhY2tUcmFjZXM7XG4gICAgfSxcbiAgICB3YXJuaW5nczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25maWcud2FybmluZ3M7XG4gICAgfSxcbiAgICBjYW5jZWxsYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLmNhbmNlbGxhdGlvbjtcbiAgICB9LFxuICAgIG1vbml0b3Jpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLm1vbml0b3Jpbmc7XG4gICAgfSxcbiAgICBwcm9wYWdhdGVGcm9tRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcHJvcGFnYXRlRnJvbUZ1bmN0aW9uO1xuICAgIH0sXG4gICAgYm91bmRWYWx1ZUZ1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kVmFsdWVGdW5jdGlvbjtcbiAgICB9LFxuICAgIGNoZWNrRm9yZ290dGVuUmV0dXJuczogY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zLFxuICAgIHNldEJvdW5kczogc2V0Qm91bmRzLFxuICAgIHdhcm46IHdhcm4sXG4gICAgZGVwcmVjYXRlZDogZGVwcmVjYXRlZCxcbiAgICBDYXB0dXJlZFRyYWNlOiBDYXB0dXJlZFRyYWNlLFxuICAgIGZpcmVEb21FdmVudDogZmlyZURvbUV2ZW50LFxuICAgIGZpcmVHbG9iYWxFdmVudDogZmlyZUdsb2JhbEV2ZW50XG59O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2RlYnVnZ2FiaWxpdHkuanNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgTkVYVF9GSUxURVIpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBDYW5jZWxsYXRpb25FcnJvciA9IFByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3I7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIGNhdGNoRmlsdGVyID0gcmVxdWlyZShcIi4vY2F0Y2hfZmlsdGVyXCIpKE5FWFRfRklMVEVSKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dChwcm9taXNlLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdGhpcy5jYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbmNlbFByb21pc2UgPSBudWxsO1xufVxuXG5QYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0LnByb3RvdHlwZS5pc0ZpbmFsbHlIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gMDtcbn07XG5cbmZ1bmN0aW9uIEZpbmFsbHlIYW5kbGVyQ2FuY2VsUmVhY3Rpb24oZmluYWxseUhhbmRsZXIpIHtcbiAgICB0aGlzLmZpbmFsbHlIYW5kbGVyID0gZmluYWxseUhhbmRsZXI7XG59XG5cbkZpbmFsbHlIYW5kbGVyQ2FuY2VsUmVhY3Rpb24ucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBjaGVja0NhbmNlbCh0aGlzLmZpbmFsbHlIYW5kbGVyKTtcbn07XG5cbmZ1bmN0aW9uIGNoZWNrQ2FuY2VsKGN0eCwgcmVhc29uKSB7XG4gICAgaWYgKGN0eC5jYW5jZWxQcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjdHguY2FuY2VsUHJvbWlzZS5fcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguY2FuY2VsUHJvbWlzZS5fY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNhbmNlbFByb21pc2UgPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzdWNjZWVkKCkge1xuICAgIHJldHVybiBmaW5hbGx5SGFuZGxlci5jYWxsKHRoaXMsIHRoaXMucHJvbWlzZS5fdGFyZ2V0KCkuX3NldHRsZWRWYWx1ZSgpKTtcbn1cbmZ1bmN0aW9uIGZhaWwocmVhc29uKSB7XG4gICAgaWYgKGNoZWNrQ2FuY2VsKHRoaXMsIHJlYXNvbikpIHJldHVybjtcbiAgICBlcnJvck9iai5lID0gcmVhc29uO1xuICAgIHJldHVybiBlcnJvck9iajtcbn1cbmZ1bmN0aW9uIGZpbmFsbHlIYW5kbGVyKHJlYXNvbk9yVmFsdWUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcbiAgICB2YXIgaGFuZGxlciA9IHRoaXMuaGFuZGxlcjtcblxuICAgIGlmICghdGhpcy5jYWxsZWQpIHtcbiAgICAgICAgdGhpcy5jYWxsZWQgPSB0cnVlO1xuICAgICAgICB2YXIgcmV0ID0gdGhpcy5pc0ZpbmFsbHlIYW5kbGVyKClcbiAgICAgICAgICAgID8gaGFuZGxlci5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSlcbiAgICAgICAgICAgIDogaGFuZGxlci5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSwgcmVhc29uT3JWYWx1ZSk7XG4gICAgICAgIGlmIChyZXQgPT09IE5FWFRfRklMVEVSKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9IGVsc2UgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9zZXRSZXR1cm5lZE5vblVuZGVmaW5lZCgpO1xuICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmV0LCBwcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FuY2VsUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UuX2lzQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWFzb24gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBDYW5jZWxsYXRpb25FcnJvcihcImxhdGUgY2FuY2VsbGF0aW9uIG9ic2VydmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JPYmouZSA9IHJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXliZVByb21pc2UuaXNQZW5kaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEZpbmFsbHlIYW5kbGVyQ2FuY2VsUmVhY3Rpb24odGhpcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXliZVByb21pc2UuX3RoZW4oXG4gICAgICAgICAgICAgICAgICAgIHN1Y2NlZWQsIGZhaWwsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9taXNlLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICBjaGVja0NhbmNlbCh0aGlzKTtcbiAgICAgICAgZXJyb3JPYmouZSA9IHJlYXNvbk9yVmFsdWU7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjaGVja0NhbmNlbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlYXNvbk9yVmFsdWU7XG4gICAgfVxufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5fcGFzc1Rocm91Z2ggPSBmdW5jdGlvbihoYW5kbGVyLCB0eXBlLCBzdWNjZXNzLCBmYWlsKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0aGlzLnRoZW4oKTtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihzdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIGZhaWwsXG4gICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgIG5ldyBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0KHRoaXMsIHR5cGUsIGhhbmRsZXIpLFxuICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5sYXN0bHkgPVxuUHJvbWlzZS5wcm90b3R5cGVbXCJmaW5hbGx5XCJdID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFzc1Rocm91Z2goaGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseUhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHlIYW5kbGVyKTtcbn07XG5cblxuUHJvbWlzZS5wcm90b3R5cGUudGFwID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFzc1Rocm91Z2goaGFuZGxlciwgMSwgZmluYWxseUhhbmRsZXIpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGFwQ2F0Y2ggPSBmdW5jdGlvbiAoaGFuZGxlck9yUHJlZGljYXRlKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobGVuID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChoYW5kbGVyT3JQcmVkaWNhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseUhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICB2YXIgY2F0Y2hJbnN0YW5jZXMgPSBuZXcgQXJyYXkobGVuIC0gMSksXG4gICAgICAgICAgICBqID0gMCwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7ICsraSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAodXRpbC5pc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgICAgIGNhdGNoSW5zdGFuY2VzW2orK10gPSBpdGVtO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJ0YXBDYXRjaCBzdGF0ZW1lbnQgcHJlZGljYXRlOiBcIlxuICAgICAgICAgICAgICAgICAgICArIFwiZXhwZWN0aW5nIGFuIG9iamVjdCBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhpdGVtKVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoSW5zdGFuY2VzLmxlbmd0aCA9IGo7XG4gICAgICAgIHZhciBoYW5kbGVyID0gYXJndW1lbnRzW2ldO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFzc1Rocm91Z2goY2F0Y2hGaWx0ZXIoY2F0Y2hJbnN0YW5jZXMsIGhhbmRsZXIsIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHlIYW5kbGVyKTtcbiAgICB9XG5cbn07XG5cbnJldHVybiBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2ZpbmFsbHkuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkVYVF9GSUxURVIpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZShcIi4vZXM1XCIpLmtleXM7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuZnVuY3Rpb24gY2F0Y2hGaWx0ZXIoaW5zdGFuY2VzLCBjYiwgcHJvbWlzZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBib3VuZFRvID0gcHJvbWlzZS5fYm91bmRWYWx1ZSgpO1xuICAgICAgICBwcmVkaWNhdGVMb29wOiBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpbnN0YW5jZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSBFcnJvciB8fFxuICAgICAgICAgICAgICAgIChpdGVtICE9IG51bGwgJiYgaXRlbS5wcm90b3R5cGUgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeUNhdGNoKGNiKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzUHJlZGljYXRlID0gdHJ5Q2F0Y2goaXRlbSkuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1ByZWRpY2F0ZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNQcmVkaWNhdGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzUHJlZGljYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlDYXRjaChjYikuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNPYmplY3QoZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IGdldEtleXMoaXRlbSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVtrZXldICE9IGVba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgcHJlZGljYXRlTG9vcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ5Q2F0Y2goY2IpLmNhbGwoYm91bmRUbywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5FWFRfRklMVEVSO1xuICAgIH07XG59XG5cbnJldHVybiBjYXRjaEZpbHRlcjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9jYXRjaF9maWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBtYXliZVdyYXBBc0Vycm9yID0gdXRpbC5tYXliZVdyYXBBc0Vycm9yO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciBPcGVyYXRpb25hbEVycm9yID0gZXJyb3JzLk9wZXJhdGlvbmFsRXJyb3I7XG52YXIgZXM1ID0gcmVxdWlyZShcIi4vZXM1XCIpO1xuXG5mdW5jdGlvbiBpc1VudHlwZWRFcnJvcihvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgZXM1LmdldFByb3RvdHlwZU9mKG9iaikgPT09IEVycm9yLnByb3RvdHlwZTtcbn1cblxudmFyIHJFcnJvcktleSA9IC9eKD86bmFtZXxtZXNzYWdlfHN0YWNrfGNhdXNlKSQvO1xuZnVuY3Rpb24gd3JhcEFzT3BlcmF0aW9uYWxFcnJvcihvYmopIHtcbiAgICB2YXIgcmV0O1xuICAgIGlmIChpc1VudHlwZWRFcnJvcihvYmopKSB7XG4gICAgICAgIHJldCA9IG5ldyBPcGVyYXRpb25hbEVycm9yKG9iaik7XG4gICAgICAgIHJldC5uYW1lID0gb2JqLm5hbWU7XG4gICAgICAgIHJldC5tZXNzYWdlID0gb2JqLm1lc3NhZ2U7XG4gICAgICAgIHJldC5zdGFjayA9IG9iai5zdGFjaztcbiAgICAgICAgdmFyIGtleXMgPSBlczUua2V5cyhvYmopO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFyRXJyb3JLZXkudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICB1dGlsLm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihvYmopO1xuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlLCBtdWx0aUFyZ3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXJyLCB2YWx1ZSkge1xuICAgICAgICBpZiAocHJvbWlzZSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZCA9IHdyYXBBc09wZXJhdGlvbmFsRXJyb3IobWF5YmVXcmFwQXNFcnJvcihlcnIpKTtcbiAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2Uod3JhcHBlZCk7XG4gICAgICAgICAgICBwcm9taXNlLl9yZWplY3Qod3JhcHBlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW11bHRpQXJncykge1xuICAgICAgICAgICAgcHJvbWlzZS5fZnVsZmlsbCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgJF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBhcmdzID0gbmV3IEFycmF5KE1hdGgubWF4KCRfbGVuIC0gMSwgMCkpOyBmb3IodmFyICRfaSA9IDE7ICRfaSA8ICRfbGVuOyArKyRfaSkge2FyZ3NbJF9pIC0gMV0gPSBhcmd1bWVudHNbJF9pXTt9O1xuICAgICAgICAgICAgcHJvbWlzZS5fZnVsZmlsbChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGViYWNrRm9yUHJvbWlzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL25vZGViYWNrLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9XG5mdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCBkZWJ1Zykge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcblxuUHJvbWlzZS5tZXRob2QgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFByb21pc2UuVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICByZXQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRyeUNhdGNoKGZuKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSByZXQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKFxuICAgICAgICAgICAgdmFsdWUsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UubWV0aG9kXCIsIHJldCk7XG4gICAgICAgIHJldC5fcmVzb2x2ZUZyb21TeW5jVmFsdWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59O1xuXG5Qcm9taXNlLmF0dGVtcHQgPSBQcm9taXNlW1widHJ5XCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICByZXQuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiY2FsbGluZyBQcm9taXNlLnRyeSB3aXRoIG1vcmUgdGhhbiAxIGFyZ3VtZW50XCIpO1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgY3R4ID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB2YWx1ZSA9IHV0aWwuaXNBcnJheShhcmcpID8gdHJ5Q2F0Y2goZm4pLmFwcGx5KGN0eCwgYXJnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ5Q2F0Y2goZm4pLmNhbGwoY3R4LCBhcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdHJ5Q2F0Y2goZm4pKCk7XG4gICAgfVxuICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHJldC5fcG9wQ29udGV4dCgpO1xuICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgdmFsdWUsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UudHJ5XCIsIHJldCk7XG4gICAgcmV0Ll9yZXNvbHZlRnJvbVN5bmNWYWx1ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXNvbHZlRnJvbVN5bmNWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdXRpbC5lcnJvck9iaikge1xuICAgICAgICB0aGlzLl9yZWplY3RDYWxsYmFjayh2YWx1ZS5lLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlLCB0cnVlKTtcbiAgICB9XG59O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL21ldGhvZC5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgZGVidWcpIHtcbnZhciBjYWxsZWRCaW5kID0gZmFsc2U7XG52YXIgcmVqZWN0VGhpcyA9IGZ1bmN0aW9uKF8sIGUpIHtcbiAgICB0aGlzLl9yZWplY3QoZSk7XG59O1xuXG52YXIgdGFyZ2V0UmVqZWN0ZWQgPSBmdW5jdGlvbihlLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5wcm9taXNlUmVqZWN0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICBjb250ZXh0LmJpbmRpbmdQcm9taXNlLl90aGVuKHJlamVjdFRoaXMsIHJlamVjdFRoaXMsIG51bGwsIHRoaXMsIGUpO1xufTtcblxudmFyIGJpbmRpbmdSZXNvbHZlZCA9IGZ1bmN0aW9uKHRoaXNBcmcsIGNvbnRleHQpIHtcbiAgICBpZiAoKCh0aGlzLl9iaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUNhbGxiYWNrKGNvbnRleHQudGFyZ2V0KTtcbiAgICB9XG59O1xuXG52YXIgYmluZGluZ1JlamVjdGVkID0gZnVuY3Rpb24oZSwgY29udGV4dCkge1xuICAgIGlmICghY29udGV4dC5wcm9taXNlUmVqZWN0aW9uUXVldWVkKSB0aGlzLl9yZWplY3QoZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICBpZiAoIWNhbGxlZEJpbmQpIHtcbiAgICAgICAgY2FsbGVkQmluZCA9IHRydWU7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tID0gZGVidWcucHJvcGFnYXRlRnJvbUZ1bmN0aW9uKCk7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9ib3VuZFZhbHVlID0gZGVidWcuYm91bmRWYWx1ZUZ1bmN0aW9uKCk7XG4gICAgfVxuICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXNBcmcpO1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9wcm9wYWdhdGVGcm9tKHRoaXMsIDEpO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICByZXQuX3NldEJvdW5kVG8obWF5YmVQcm9taXNlKTtcbiAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgIHByb21pc2VSZWplY3Rpb25RdWV1ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJvbWlzZTogcmV0LFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBiaW5kaW5nUHJvbWlzZTogbWF5YmVQcm9taXNlXG4gICAgICAgIH07XG4gICAgICAgIHRhcmdldC5fdGhlbihJTlRFUk5BTCwgdGFyZ2V0UmVqZWN0ZWQsIHVuZGVmaW5lZCwgcmV0LCBjb250ZXh0KTtcbiAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKFxuICAgICAgICAgICAgYmluZGluZ1Jlc29sdmVkLCBiaW5kaW5nUmVqZWN0ZWQsIHVuZGVmaW5lZCwgcmV0LCBjb250ZXh0KTtcbiAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbChtYXliZVByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5fcmVzb2x2ZUNhbGxiYWNrKHRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0Qm91bmRUbyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDIwOTcxNTI7XG4gICAgICAgIHRoaXMuX2JvdW5kVG8gPSBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MjA5NzE1Mik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzQm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDIwOTcxNTIpID09PSAyMDk3MTUyO1xufTtcblxuUHJvbWlzZS5iaW5kID0gZnVuY3Rpb24gKHRoaXNBcmcsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkuYmluZCh0aGlzQXJnKTtcbn07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvYmluZC5qc1xuLy8gbW9kdWxlIGlkID0gMTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgZGVidWcpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIGFzeW5jID0gUHJvbWlzZS5fYXN5bmM7XG5cblByb21pc2UucHJvdG90eXBlW1wiYnJlYWtcIl0gPSBQcm9taXNlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWRlYnVnLmNhbmNlbGxhdGlvbigpKSByZXR1cm4gdGhpcy5fd2FybihcImNhbmNlbGxhdGlvbiBpcyBkaXNhYmxlZFwiKTtcblxuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgY2hpbGQgPSBwcm9taXNlO1xuICAgIHdoaWxlIChwcm9taXNlLl9pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgaWYgKCFwcm9taXNlLl9jYW5jZWxCeShjaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5faXNGb2xsb3dpbmcoKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLl9mb2xsb3dlZSgpLmNhbmNlbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5fY2FuY2VsQnJhbmNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IHByb21pc2UuX2NhbmNlbGxhdGlvblBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCA9PSBudWxsIHx8ICFwYXJlbnQuX2lzQ2FuY2VsbGFibGUoKSkge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2lzRm9sbG93aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9mb2xsb3dlZSgpLmNhbmNlbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9jYW5jZWxCcmFuY2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faXNGb2xsb3dpbmcoKSkgcHJvbWlzZS5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgIHByb21pc2UuX3NldFdpbGxCZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgY2hpbGQgPSBwcm9taXNlO1xuICAgICAgICAgICAgcHJvbWlzZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9icmFuY2hIYXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsLS07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZW5vdWdoQnJhbmNoZXNIYXZlQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsIDw9IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsQnkgPSBmdW5jdGlvbihjYW5jZWxsZXIpIHtcbiAgICBpZiAoY2FuY2VsbGVyID09PSB0aGlzKSB7XG4gICAgICAgIHRoaXMuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPSAwO1xuICAgICAgICB0aGlzLl9pbnZva2VPbkNhbmNlbCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9icmFuY2hIYXNDYW5jZWxsZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnZva2VPbkNhbmNlbCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NhbmNlbEJyYW5jaGVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCgpKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2lzQ2FuY2VsbGFibGUoKSkgcmV0dXJuO1xuICAgIHRoaXMuX3NldENhbmNlbGxlZCgpO1xuICAgIGFzeW5jLmludm9rZSh0aGlzLl9jYW5jZWxQcm9taXNlcywgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWxQcm9taXNlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9sZW5ndGgoKSA+IDApIHRoaXMuX3NldHRsZVByb21pc2VzKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRPbkNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX29uQ2FuY2VsRmllbGQgPSB1bmRlZmluZWQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNDYW5jZWxsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGVuZGluZygpICYmICF0aGlzLl9pc0NhbmNlbGxlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNDYW5jZWxsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGVuZGluZygpICYmICF0aGlzLmlzQ2FuY2VsbGVkKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZG9JbnZva2VPbkNhbmNlbCA9IGZ1bmN0aW9uKG9uQ2FuY2VsQ2FsbGJhY2ssIGludGVybmFsT25seSkge1xuICAgIGlmICh1dGlsLmlzQXJyYXkob25DYW5jZWxDYWxsYmFjaykpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbkNhbmNlbENhbGxiYWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLl9kb0ludm9rZU9uQ2FuY2VsKG9uQ2FuY2VsQ2FsbGJhY2tbaV0sIGludGVybmFsT25seSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9uQ2FuY2VsQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIG9uQ2FuY2VsQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbE9ubHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRyeUNhdGNoKG9uQ2FuY2VsQ2FsbGJhY2spLmNhbGwodGhpcy5fYm91bmRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAoZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0YWNoRXh0cmFUcmFjZShlLmUpO1xuICAgICAgICAgICAgICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUuZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25DYW5jZWxDYWxsYmFjay5fcmVzdWx0Q2FuY2VsbGVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ludm9rZU9uQ2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uQ2FuY2VsQ2FsbGJhY2sgPSB0aGlzLl9vbkNhbmNlbCgpO1xuICAgIHRoaXMuX3Vuc2V0T25DYW5jZWwoKTtcbiAgICBhc3luYy5pbnZva2UodGhpcy5fZG9JbnZva2VPbkNhbmNlbCwgdGhpcywgb25DYW5jZWxDYWxsYmFjayk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faW52b2tlSW50ZXJuYWxPbkNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgdGhpcy5fZG9JbnZva2VPbkNhbmNlbCh0aGlzLl9vbkNhbmNlbCgpLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fdW5zZXRPbkNhbmNlbCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNhbmNlbCgpO1xufTtcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2NhbmNlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG5mdW5jdGlvbiByZXR1cm5lcigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn1cbmZ1bmN0aW9uIHRocm93ZXIoKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG59XG5cblByb21pc2UucHJvdG90eXBlW1wicmV0dXJuXCJdID1cblByb21pc2UucHJvdG90eXBlLnRoZW5SZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB2YWx1ZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgcmV0dXJuZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7dmFsdWU6IHZhbHVlfSwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlW1widGhyb3dcIl0gPVxuUHJvbWlzZS5wcm90b3R5cGUudGhlblRocm93ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICB0aHJvd2VyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge3JlYXNvbjogcmVhc29ufSwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmNhdGNoVGhyb3cgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgdGhyb3dlciwgdW5kZWZpbmVkLCB7cmVhc29uOiByZWFzb259LCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVhc29uID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCkge3Rocm93IF9yZWFzb247fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2F1Z2h0KHJlYXNvbiwgaGFuZGxlcik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hSZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHZhbHVlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgcmV0dXJuZXIsIHVuZGVmaW5lZCwge3ZhbHVlOiB2YWx1ZX0sIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF92YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKF92YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIF92YWx1ZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHtyZXR1cm4gX3ZhbHVlO307XG4gICAgICAgIHJldHVybiB0aGlzLmNhdWdodCh2YWx1ZSwgaGFuZGxlcik7XG4gICAgfVxufTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9kaXJlY3RfcmVzb2x2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG5mdW5jdGlvbiBQcm9taXNlSW5zcGVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKHByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkID0gcHJvbWlzZS5faXNGYXRlU2VhbGVkKClcbiAgICAgICAgICAgID8gcHJvbWlzZS5fc2V0dGxlZFZhbHVlKCkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IDA7XG4gICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLl9zZXR0bGVkVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlRmllbGQ7XG59O1xuXG52YXIgdmFsdWUgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBnZXQgZnVsZmlsbG1lbnQgdmFsdWUgb2YgYSBub24tZnVsZmlsbGVkIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG52YXIgcmVhc29uID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmVycm9yID1cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5yZWFzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IGdldCByZWplY3Rpb24gcmVhc29uIG9mIGEgbm9uLXJlamVjdGVkIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG52YXIgaXNGdWxmaWxsZWQgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwO1xufTtcblxudmFyIGlzUmVqZWN0ZWQgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwO1xufTtcblxudmFyIGlzUGVuZGluZyA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMDtcbn07XG5cbnZhciBpc1Jlc29sdmVkID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDUwMzMxNjQ4KSAhPT0gMDtcbn07XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA4NDU0MTQ0KSAhPT0gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9faXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNjU1MzYpID09PSA2NTUzNjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXQoKS5fX2lzQ2FuY2VsbGVkKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fdGFyZ2V0KCkuX2JpdEZpZWxkICYgODQ1NDE0NCkgIT09IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNQZW5kaW5nLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc1JlamVjdGVkLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNGdWxmaWxsZWQuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1Jlc29sdmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzUmVzb2x2ZWQuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZS5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnJlYXNvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB0YXJnZXQuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICByZXR1cm4gcmVhc29uLmNhbGwodGFyZ2V0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl92YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWFzb24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xufTtcblxuUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbiA9IFByb21pc2VJbnNwZWN0aW9uO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3N5bmNocm9ub3VzX2luc3BlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbmZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwsIGFzeW5jLFxuICAgICAgICAgZ2V0RG9tYWluKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgcmVqZWN0O1xuXG5pZiAoIWZhbHNlKSB7XG5pZiAoY2FuRXZhbHVhdGUpIHtcbiAgICB2YXIgdGhlbkNhbGxiYWNrID0gZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwidmFsdWVcIiwgXCJob2xkZXJcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBob2xkZXIucEluZGV4ID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBob2xkZXIuY2hlY2tGdWxmaWxsbWVudCh0aGlzKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIi5yZXBsYWNlKC9JbmRleC9nLCBpKSk7XG4gICAgfTtcblxuICAgIHZhciBwcm9taXNlU2V0dGVyID0gZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwicHJvbWlzZVwiLCBcImhvbGRlclwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBob2xkZXIucEluZGV4ID0gcHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIi5yZXBsYWNlKC9JbmRleC9nLCBpKSk7XG4gICAgfTtcblxuICAgIHZhciBnZW5lcmF0ZUhvbGRlckNsYXNzID0gZnVuY3Rpb24odG90YWwpIHtcbiAgICAgICAgdmFyIHByb3BzID0gbmV3IEFycmF5KHRvdGFsKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcHJvcHNbaV0gPSBcInRoaXMucFwiICsgKGkrMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFzc2lnbm1lbnQgPSBwcm9wcy5qb2luKFwiID0gXCIpICsgXCIgPSBudWxsO1wiO1xuICAgICAgICB2YXIgY2FuY2VsbGF0aW9uQ29kZT0gXCJ2YXIgcHJvbWlzZTtcXG5cIiArIHByb3BzLm1hcChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UgPSBcIiArIHByb3AgKyBcIjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuY2FuY2VsKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIjtcbiAgICAgICAgfSkuam9pbihcIlxcblwiKTtcbiAgICAgICAgdmFyIHBhc3NlZEFyZ3VtZW50cyA9IHByb3BzLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdmFyIG5hbWUgPSBcIkhvbGRlciRcIiArIHRvdGFsO1xuXG5cbiAgICAgICAgdmFyIGNvZGUgPSBcInJldHVybiBmdW5jdGlvbih0cnlDYXRjaCwgZXJyb3JPYmosIFByb21pc2UsIGFzeW5jKSB7ICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBmdW5jdGlvbiBbVGhlTmFtZV0oZm4pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgW1RoZVByb3BlcnRpZXNdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdGhpcy5mbiA9IGZuOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdGhpcy5hc3luY05lZWRlZCA9IHRydWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdGhpcy5ub3cgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbVGhlTmFtZV0ucHJvdG90eXBlLl9jYWxsRnVuY3Rpb24gPSBmdW5jdGlvbihwcm9taXNlKSB7ICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKHRoaXMuZm4pKFtUaGVQYXNzZWRBcmd1bWVudHNdKTsgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcG9wQ29udGV4dCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJldC5lLCBmYWxzZSk7ICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayhyZXQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbVGhlTmFtZV0ucHJvdG90eXBlLmNoZWNrRnVsZmlsbG1lbnQgPSBmdW5jdGlvbihwcm9taXNlKSB7ICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdmFyIG5vdyA9ICsrdGhpcy5ub3c7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgaWYgKG5vdyA9PT0gW1RoZVRvdGFsXSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFzeW5jTmVlZGVkKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3luYy5pbnZva2UodGhpcy5fY2FsbEZ1bmN0aW9uLCB0aGlzLCBwcm9taXNlKTsgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsRnVuY3Rpb24ocHJvbWlzZSk7ICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbVGhlTmFtZV0ucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHsgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgW0NhbmNlbGxhdGlvbkNvZGVdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICByZXR1cm4gW1RoZU5hbWVdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIH0odHJ5Q2F0Y2gsIGVycm9yT2JqLCBQcm9taXNlLCBhc3luYyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiO1xuXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL1xcW1RoZU5hbWVcXF0vZywgbmFtZSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtUaGVUb3RhbFxcXS9nLCB0b3RhbClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtUaGVQYXNzZWRBcmd1bWVudHNcXF0vZywgcGFzc2VkQXJndW1lbnRzKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcW1RoZVByb3BlcnRpZXNcXF0vZywgYXNzaWdubWVudClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtDYW5jZWxsYXRpb25Db2RlXFxdL2csIGNhbmNlbGxhdGlvbkNvZGUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJ0cnlDYXRjaFwiLCBcImVycm9yT2JqXCIsIFwiUHJvbWlzZVwiLCBcImFzeW5jXCIsIGNvZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAodHJ5Q2F0Y2gsIGVycm9yT2JqLCBQcm9taXNlLCBhc3luYyk7XG4gICAgfTtcblxuICAgIHZhciBob2xkZXJDbGFzc2VzID0gW107XG4gICAgdmFyIHRoZW5DYWxsYmFja3MgPSBbXTtcbiAgICB2YXIgcHJvbWlzZVNldHRlcnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgICAgIGhvbGRlckNsYXNzZXMucHVzaChnZW5lcmF0ZUhvbGRlckNsYXNzKGkgKyAxKSk7XG4gICAgICAgIHRoZW5DYWxsYmFja3MucHVzaCh0aGVuQ2FsbGJhY2soaSArIDEpKTtcbiAgICAgICAgcHJvbWlzZVNldHRlcnMucHVzaChwcm9taXNlU2V0dGVyKGkgKyAxKSk7XG4gICAgfVxuXG4gICAgcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICB0aGlzLl9yZWplY3QocmVhc29uKTtcbiAgICB9O1xufX1cblxuUHJvbWlzZS5qb2luID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYXN0ID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGZuO1xuICAgIGlmIChsYXN0ID4gMCAmJiB0eXBlb2YgYXJndW1lbnRzW2xhc3RdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZm4gPSBhcmd1bWVudHNbbGFzdF07XG4gICAgICAgIGlmICghZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChsYXN0IDw9IDggJiYgY2FuRXZhbHVhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgSG9sZGVyQ2xhc3MgPSBob2xkZXJDbGFzc2VzW2xhc3QgLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgaG9sZGVyID0gbmV3IEhvbGRlckNsYXNzKGZuKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhlbkNhbGxiYWNrcztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKGFyZ3VtZW50c1tpXSwgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKGNhbGxiYWNrc1tpXSwgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHJldCwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlU2V0dGVyc1tpXShtYXliZVByb21pc2UsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmFzeW5jTmVlZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwocmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdmFsdWUoKSwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHJldCwgbWF5YmVQcm9taXNlLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXQuX2lzRmF0ZVNlYWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIuYXN5bmNOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuZm4gPSB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBob2xkZXIuZm4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldC5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldC5fc2V0T25DYW5jZWwoaG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgJF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBhcmdzID0gbmV3IEFycmF5KCRfbGVuKTsgZm9yKHZhciAkX2kgPSAwOyAkX2kgPCAkX2xlbjsgKyskX2kpIHthcmdzWyRfaV0gPSBhcmd1bWVudHNbJF9pXTt9O1xuICAgIGlmIChmbikgYXJncy5wb3AoKTtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VBcnJheShhcmdzKS5wcm9taXNlKCk7XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyByZXQuc3ByZWFkKGZuKSA6IHJldDtcbn07XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9qb2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2VBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVqZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcpIHtcbnZhciBnZXREb21haW4gPSBQcm9taXNlLl9nZXREb21haW47XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciBhc3luYyA9IFByb21pc2UuX2FzeW5jO1xuXG5mdW5jdGlvbiBNYXBwaW5nUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgbGltaXQsIF9maWx0ZXIpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJChwcm9taXNlcyk7XG4gICAgdGhpcy5fcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBkb21haW4gPT09IG51bGwgPyBmbiA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZuKTtcbiAgICB0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXMgPSBfZmlsdGVyID09PSBJTlRFUk5BTFxuICAgICAgICA/IG5ldyBBcnJheSh0aGlzLmxlbmd0aCgpKVxuICAgICAgICA6IG51bGw7XG4gICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICB0aGlzLl9pbkZsaWdodCA9IDA7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICBhc3luYy5pbnZva2UodGhpcy5fYXN5bmNJbml0LCB0aGlzLCB1bmRlZmluZWQpO1xufVxudXRpbC5pbmhlcml0cyhNYXBwaW5nUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fYXN5bmNJbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faW5pdCQodW5kZWZpbmVkLCAtMik7XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5fdmFsdWVzO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgIHZhciBwcmVzZXJ2ZWRWYWx1ZXMgPSB0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXM7XG4gICAgdmFyIGxpbWl0ID0gdGhpcy5fbGltaXQ7XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gKGluZGV4ICogLTEpIC0gMTtcbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICBpZiAobGltaXQgPj0gMSkge1xuICAgICAgICAgICAgdGhpcy5faW5GbGlnaHQtLTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWluUXVldWUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxpbWl0ID49IDEgJiYgdGhpcy5faW5GbGlnaHQgPj0gbGltaXQpIHtcbiAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVzZXJ2ZWRWYWx1ZXMgIT09IG51bGwpIHByZXNlcnZlZFZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2U7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrO1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBwcm9taXNlLl9ib3VuZFZhbHVlKCk7XG4gICAgICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciByZXQgPSB0cnlDYXRjaChjYWxsYmFjaykuY2FsbChyZWNlaXZlciwgdmFsdWUsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIHByb21pc2VDcmVhdGVkLFxuICAgICAgICAgICAgcHJlc2VydmVkVmFsdWVzICE9PSBudWxsID8gXCJQcm9taXNlLmZpbHRlclwiIDogXCJQcm9taXNlLm1hcFwiLFxuICAgICAgICAgICAgcHJvbWlzZVxuICAgICAgICApO1xuICAgICAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KHJldC5lKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmV0LCB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0ID49IDEpIHRoaXMuX2luRmxpZ2h0Kys7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2luZGV4XSA9IG1heWJlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3Byb3h5KHRoaXMsIChpbmRleCArIDEpICogLTEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBtYXliZVByb21pc2UuX3ZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0KG1heWJlUHJvbWlzZS5fcmVhc29uKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gcmV0O1xuICAgIH1cbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHByZXNlcnZlZFZhbHVlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyKHZhbHVlcywgcHJlc2VydmVkVmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2RyYWluUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgdmFyIGxpbWl0ID0gdGhpcy5fbGltaXQ7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCAmJiB0aGlzLl9pbkZsaWdodCA8IGxpbWl0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICAgICAgdmFyIGluZGV4ID0gcXVldWUucG9wKCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2VGdWxmaWxsZWQodmFsdWVzW2luZGV4XSwgaW5kZXgpO1xuICAgIH1cbn07XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9maWx0ZXIgPSBmdW5jdGlvbiAoYm9vbGVhbnMsIHZhbHVlcykge1xuICAgIHZhciBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHZhciByZXQgPSBuZXcgQXJyYXkobGVuKTtcbiAgICB2YXIgaiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpZiAoYm9vbGVhbnNbaV0pIHJldFtqKytdID0gdmFsdWVzW2ldO1xuICAgIH1cbiAgICByZXQubGVuZ3RoID0gajtcbiAgICB0aGlzLl9yZXNvbHZlKHJldCk7XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5wcmVzZXJ2ZWRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXNlcnZlZFZhbHVlcztcbn07XG5cbmZ1bmN0aW9uIG1hcChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuXG4gICAgdmFyIGxpbWl0ID0gMDtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29uY3VycmVuY3kgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUeXBlRXJyb3IoXCInY29uY3VycmVuY3knIG11c3QgYmUgYSBudW1iZXIgYnV0IGl0IGlzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY2xhc3NTdHJpbmcob3B0aW9ucy5jb25jdXJyZW5jeSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbWl0ID0gb3B0aW9ucy5jb25jdXJyZW5jeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCBidXQgaXQgaXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKG9wdGlvbnMpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGltaXQgPSB0eXBlb2YgbGltaXQgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgaXNGaW5pdGUobGltaXQpICYmIGxpbWl0ID49IDEgPyBsaW1pdCA6IDA7XG4gICAgcmV0dXJuIG5ldyBNYXBwaW5nUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgbGltaXQsIF9maWx0ZXIpLnByb21pc2UoKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1hcCh0aGlzLCBmbiwgb3B0aW9ucywgbnVsbCk7XG59O1xuXG5Qcm9taXNlLm1hcCA9IGZ1bmN0aW9uIChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpIHtcbiAgICByZXR1cm4gbWFwKHByb21pc2VzLCBmbiwgb3B0aW9ucywgX2ZpbHRlcik7XG59O1xuXG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjciA9IE9iamVjdC5jcmVhdGU7XG5pZiAoY3IpIHtcbiAgICB2YXIgY2FsbGVyQ2FjaGUgPSBjcihudWxsKTtcbiAgICB2YXIgZ2V0dGVyQ2FjaGUgPSBjcihudWxsKTtcbiAgICBjYWxsZXJDYWNoZVtcIiBzaXplXCJdID0gZ2V0dGVyQ2FjaGVbXCIgc2l6ZVwiXSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGNhbkV2YWx1YXRlID0gdXRpbC5jYW5FdmFsdWF0ZTtcbnZhciBpc0lkZW50aWZpZXIgPSB1dGlsLmlzSWRlbnRpZmllcjtcblxudmFyIGdldE1ldGhvZENhbGxlcjtcbnZhciBnZXRHZXR0ZXI7XG5pZiAoIWZhbHNlKSB7XG52YXIgbWFrZU1ldGhvZENhbGxlciA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcImVuc3VyZU1ldGhvZFwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBlbnN1cmVNZXRob2Qob2JqLCAnbWV0aG9kTmFtZScpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBzd2l0Y2gobGVuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSk7ICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSwgdGhpc1sxXSk7ICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSwgdGhpc1sxXSwgdGhpc1syXSk7ICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmoubWV0aG9kTmFtZS5hcHBseShvYmosIHRoaXMpOyAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoL21ldGhvZE5hbWUvZywgbWV0aG9kTmFtZSkpKGVuc3VyZU1ldGhvZCk7XG59O1xuXG52YXIgbWFrZUdldHRlciA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwib2JqXCIsIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgcmV0dXJuIG9iai5wcm9wZXJ0eU5hbWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgXCIucmVwbGFjZShcInByb3BlcnR5TmFtZVwiLCBwcm9wZXJ0eU5hbWUpKTtcbn07XG5cbnZhciBnZXRDb21waWxlZCA9IGZ1bmN0aW9uKG5hbWUsIGNvbXBpbGVyLCBjYWNoZSkge1xuICAgIHZhciByZXQgPSBjYWNoZVtuYW1lXTtcbiAgICBpZiAodHlwZW9mIHJldCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXQgPSBjb21waWxlcihuYW1lKTtcbiAgICAgICAgY2FjaGVbbmFtZV0gPSByZXQ7XG4gICAgICAgIGNhY2hlW1wiIHNpemVcIl0rKztcbiAgICAgICAgaWYgKGNhY2hlW1wiIHNpemVcIl0gPiA1MTIpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY2FjaGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkgZGVsZXRlIGNhY2hlW2tleXNbaV1dO1xuICAgICAgICAgICAgY2FjaGVbXCIgc2l6ZVwiXSA9IGtleXMubGVuZ3RoIC0gMjU2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5nZXRNZXRob2RDYWxsZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGdldENvbXBpbGVkKG5hbWUsIG1ha2VNZXRob2RDYWxsZXIsIGNhbGxlckNhY2hlKTtcbn07XG5cbmdldEdldHRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gZ2V0Q29tcGlsZWQobmFtZSwgbWFrZUdldHRlciwgZ2V0dGVyQ2FjaGUpO1xufTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgIHZhciBmbjtcbiAgICBpZiAob2JqICE9IG51bGwpIGZuID0gb2JqW21ldGhvZE5hbWVdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiT2JqZWN0IFwiICsgdXRpbC5jbGFzc1N0cmluZyhvYmopICsgXCIgaGFzIG5vIG1ldGhvZCAnXCIgK1xuICAgICAgICAgICAgdXRpbC50b1N0cmluZyhtZXRob2ROYW1lKSArIFwiJ1wiO1xuICAgICAgICB0aHJvdyBuZXcgUHJvbWlzZS5UeXBlRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gY2FsbGVyKG9iaikge1xuICAgIHZhciBtZXRob2ROYW1lID0gdGhpcy5wb3AoKTtcbiAgICB2YXIgZm4gPSBlbnN1cmVNZXRob2Qob2JqLCBtZXRob2ROYW1lKTtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCB0aGlzKTtcbn1cblByb21pc2UucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHZhciAkX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIGFyZ3MgPSBuZXcgQXJyYXkoTWF0aC5tYXgoJF9sZW4gLSAxLCAwKSk7IGZvcih2YXIgJF9pID0gMTsgJF9pIDwgJF9sZW47ICsrJF9pKSB7YXJnc1skX2kgLSAxXSA9IGFyZ3VtZW50c1skX2ldO307XG4gICAgaWYgKCFmYWxzZSkge1xuICAgICAgICBpZiAoY2FuRXZhbHVhdGUpIHtcbiAgICAgICAgICAgIHZhciBtYXliZUNhbGxlciA9IGdldE1ldGhvZENhbGxlcihtZXRob2ROYW1lKTtcbiAgICAgICAgICAgIGlmIChtYXliZUNhbGxlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICAgICAgICAgICAgICBtYXliZUNhbGxlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZ3MsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXJncy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgIHJldHVybiB0aGlzLl90aGVuKGNhbGxlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZ3MsIHVuZGVmaW5lZCk7XG59O1xuXG5mdW5jdGlvbiBuYW1lZEdldHRlcihvYmopIHtcbiAgICByZXR1cm4gb2JqW3RoaXNdO1xufVxuZnVuY3Rpb24gaW5kZXhlZEdldHRlcihvYmopIHtcbiAgICB2YXIgaW5kZXggPSArdGhpcztcbiAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IE1hdGgubWF4KDAsIGluZGV4ICsgb2JqLmxlbmd0aCk7XG4gICAgcmV0dXJuIG9ialtpbmRleF07XG59XG5Qcm9taXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgdmFyIGlzSW5kZXggPSAodHlwZW9mIHByb3BlcnR5TmFtZSA9PT0gXCJudW1iZXJcIik7XG4gICAgdmFyIGdldHRlcjtcbiAgICBpZiAoIWlzSW5kZXgpIHtcbiAgICAgICAgaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgICAgICAgICB2YXIgbWF5YmVHZXR0ZXIgPSBnZXRHZXR0ZXIocHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGdldHRlciA9IG1heWJlR2V0dGVyICE9PSBudWxsID8gbWF5YmVHZXR0ZXIgOiBuYW1lZEdldHRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldHRlciA9IG5hbWVkR2V0dGVyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0dGVyID0gaW5kZXhlZEdldHRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oZ2V0dGVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcHJvcGVydHlOYW1lLCB1bmRlZmluZWQpO1xufTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9jYWxsX2dldC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgIGNyZWF0ZUNvbnRleHQsIElOVEVSTkFMLCBkZWJ1Zykge1xuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbiAgICB2YXIgVHlwZUVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpLlR5cGVFcnJvcjtcbiAgICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiLi91dGlsXCIpLmluaGVyaXRzO1xuICAgIHZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG4gICAgdmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbiAgICB2YXIgTlVMTCA9IHt9O1xuXG4gICAgZnVuY3Rpb24gdGhyb3dlcihlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBlO30sIDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhc3RQcmVzZXJ2aW5nRGlzcG9zYWJsZSh0aGVuYWJsZSkge1xuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGVuYWJsZSk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgIT09IHRoZW5hYmxlICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhlbmFibGUuX2lzRGlzcG9zYWJsZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhlbmFibGUuX2dldERpc3Bvc2VyID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHRoZW5hYmxlLl9pc0Rpc3Bvc2FibGUoKSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9zZXREaXNwb3NhYmxlKHRoZW5hYmxlLl9nZXREaXNwb3NlcigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwb3NlKHJlc291cmNlcywgaW5zcGVjdGlvbikge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSByZXNvdXJjZXMubGVuZ3RoO1xuICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgICAgICAgIGlmIChpID49IGxlbikgcmV0dXJuIHJldC5fZnVsZmlsbCgpO1xuICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGNhc3RQcmVzZXJ2aW5nRGlzcG9zYWJsZShyZXNvdXJjZXNbaSsrXSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSAmJlxuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5faXNEaXNwb3NhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9nZXREaXNwb3NlcigpLnRyeURpc3Bvc2UoaW5zcGVjdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXMucHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dlcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZS5fdGhlbihpdGVyYXRvciwgdGhyb3dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVyYXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdG9yKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRGlzcG9zZXIoZGF0YSwgcHJvbWlzZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLnByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUucmVzb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb21pc2UoKS5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlKCkudmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTlVMTDtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLnRyeURpc3Bvc2UgPSBmdW5jdGlvbihpbnNwZWN0aW9uKSB7XG4gICAgICAgIHZhciByZXNvdXJjZSA9IHRoaXMucmVzb3VyY2UoKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSBjb250ZXh0Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICB2YXIgcmV0ID0gcmVzb3VyY2UgIT09IE5VTExcbiAgICAgICAgICAgID8gdGhpcy5kb0Rpc3Bvc2UocmVzb3VyY2UsIGluc3BlY3Rpb24pIDogbnVsbDtcbiAgICAgICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkgY29udGV4dC5fcG9wQ29udGV4dCgpO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl91bnNldERpc3Bvc2FibGUoKTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLmlzRGlzcG9zZXIgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gKGQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkLnJlc291cmNlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZC50cnlEaXNwb3NlID09PSBcImZ1bmN0aW9uXCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBGdW5jdGlvbkRpc3Bvc2VyKGZuLCBwcm9taXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IkKGZuLCBwcm9taXNlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaW5oZXJpdHMoRnVuY3Rpb25EaXNwb3NlciwgRGlzcG9zZXIpO1xuXG4gICAgRnVuY3Rpb25EaXNwb3Nlci5wcm90b3R5cGUuZG9EaXNwb3NlID0gZnVuY3Rpb24gKHJlc291cmNlLCBpbnNwZWN0aW9uKSB7XG4gICAgICAgIHZhciBmbiA9IHRoaXMuZGF0YSgpO1xuICAgICAgICByZXR1cm4gZm4uY2FsbChyZXNvdXJjZSwgcmVzb3VyY2UsIGluc3BlY3Rpb24pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYXliZVVud3JhcERpc3Bvc2VyKHZhbHVlKSB7XG4gICAgICAgIGlmIChEaXNwb3Nlci5pc0Rpc3Bvc2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNbdGhpcy5pbmRleF0uX3NldERpc3Bvc2FibGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnByb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUmVzb3VyY2VMaXN0KGxlbmd0aCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpc1tsZW5ndGgtMV0gPSBudWxsO1xuICAgIH1cblxuICAgIFJlc291cmNlTGlzdC5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUHJvbWlzZS51c2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPCAyKSByZXR1cm4gYXBpUmVqZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ5b3UgbXVzdCBwYXNzIGF0IGxlYXN0IDIgYXJndW1lbnRzIHRvIFByb21pc2UudXNpbmdcIik7XG4gICAgICAgIHZhciBmbiA9IGFyZ3VtZW50c1tsZW4gLSAxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXQ7XG4gICAgICAgIHZhciBzcHJlYWRBcmdzID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbiA9PT0gMiAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgbGVuID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgc3ByZWFkQXJncyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXQgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzb3VyY2VzID0gbmV3IFJlc291cmNlTGlzdChsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBpbnB1dFtpXTtcbiAgICAgICAgICAgIGlmIChEaXNwb3Nlci5pc0Rpc3Bvc2VyKHJlc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNwb3NlciA9IHJlc291cmNlO1xuICAgICAgICAgICAgICAgIHJlc291cmNlID0gcmVzb3VyY2UucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHJlc291cmNlLl9zZXREaXNwb3NhYmxlKGRpc3Bvc2VyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihtYXliZVVud3JhcERpc3Bvc2VyLCBudWxsLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzOiByZXNvdXJjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICAgICAgfSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvdXJjZXNbaV0gPSByZXNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWZsZWN0ZWRSZXNvdXJjZXMgPSBuZXcgQXJyYXkocmVzb3VyY2VzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVmbGVjdGVkUmVzb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZWZsZWN0ZWRSZXNvdXJjZXNbaV0gPSBQcm9taXNlLnJlc29sdmUocmVzb3VyY2VzW2ldKS5yZWZsZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0UHJvbWlzZSA9IFByb21pc2UuYWxsKHJlZmxlY3RlZFJlc291cmNlcylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGluc3BlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnNwZWN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zcGVjdGlvbiA9IGluc3BlY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zcGVjdGlvbi5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yT2JqLmUgPSBpbnNwZWN0aW9uLmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWluc3BlY3Rpb24uaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnNwZWN0aW9uc1tpXSA9IGluc3BlY3Rpb24udmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcblxuICAgICAgICAgICAgICAgIGZuID0gdHJ5Q2F0Y2goZm4pO1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBzcHJlYWRBcmdzXG4gICAgICAgICAgICAgICAgICAgID8gZm4uYXBwbHkodW5kZWZpbmVkLCBpbnNwZWN0aW9ucykgOiBmbihpbnNwZWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgICAgICAgICAgICAgcmV0LCBwcm9taXNlQ3JlYXRlZCwgXCJQcm9taXNlLnVzaW5nXCIsIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IHJlc3VsdFByb21pc2UubGFzdGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGluc3BlY3Rpb24gPSBuZXcgUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbihyZXN1bHRQcm9taXNlKTtcbiAgICAgICAgICAgIHJldHVybiBkaXNwb3NlKHJlc291cmNlcywgaW5zcGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNvdXJjZXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHByb21pc2UuX3NldE9uQ2FuY2VsKHJlc291cmNlcyk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5fc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uIChkaXNwb3Nlcikge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTMxMDcyO1xuICAgICAgICB0aGlzLl9kaXNwb3NlciA9IGRpc3Bvc2VyO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5faXNEaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTMxMDcyKSA+IDA7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl9nZXREaXNwb3NlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VyO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5fdW5zZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH4xMzEwNzIpO1xuICAgICAgICB0aGlzLl9kaXNwb3NlciA9IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuZGlzcG9zZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRGlzcG9zZXIoZm4sIHRoaXMsIGNyZWF0ZUNvbnRleHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH07XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS91c2luZy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBUaW1lb3V0RXJyb3IgPSBQcm9taXNlLlRpbWVvdXRFcnJvcjtcblxuZnVuY3Rpb24gSGFuZGxlV3JhcHBlcihoYW5kbGUpICB7XG4gICAgdGhpcy5oYW5kbGUgPSBoYW5kbGU7XG59XG5cbkhhbmRsZVdyYXBwZXIucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xufTtcblxudmFyIGFmdGVyVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gZGVsYXkoK3RoaXMpLnRoZW5SZXR1cm4odmFsdWUpOyB9O1xudmFyIGRlbGF5ID0gUHJvbWlzZS5kZWxheSA9IGZ1bmN0aW9uIChtcywgdmFsdWUpIHtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBoYW5kbGU7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0ID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKVxuICAgICAgICAgICAgICAgIC5fdGhlbihhZnRlclZhbHVlLCBudWxsLCBudWxsLCBtcywgdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGRlYnVnLmNhbmNlbGxhdGlvbigpICYmIHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIGhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHJldC5fZnVsZmlsbCgpOyB9LCArbXMpO1xuICAgICAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkpIHtcbiAgICAgICAgICAgIHJldC5fc2V0T25DYW5jZWwobmV3IEhhbmRsZVdyYXBwZXIoaGFuZGxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIH1cbiAgICByZXQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIChtcykge1xuICAgIHJldHVybiBkZWxheShtcywgdGhpcyk7XG59O1xuXG52YXIgYWZ0ZXJUaW1lb3V0ID0gZnVuY3Rpb24gKHByb21pc2UsIG1lc3NhZ2UsIHBhcmVudCkge1xuICAgIHZhciBlcnI7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGVyciA9IG1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnIgPSBuZXcgVGltZW91dEVycm9yKFwib3BlcmF0aW9uIHRpbWVkIG91dFwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGVyciA9IG5ldyBUaW1lb3V0RXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHV0aWwubWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKGVycik7XG4gICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShlcnIpO1xuICAgIHByb21pc2UuX3JlamVjdChlcnIpO1xuXG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudC5jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBzdWNjZXNzQ2xlYXIodmFsdWUpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZmFpbHVyZUNsZWFyKHJlYXNvbikge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmhhbmRsZSk7XG4gICAgdGhyb3cgcmVhc29uO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zLCBtZXNzYWdlKSB7XG4gICAgbXMgPSArbXM7XG4gICAgdmFyIHJldCwgcGFyZW50O1xuXG4gICAgdmFyIGhhbmRsZVdyYXBwZXIgPSBuZXcgSGFuZGxlV3JhcHBlcihzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVvdXRUaW1lb3V0KCkge1xuICAgICAgICBpZiAocmV0LmlzUGVuZGluZygpKSB7XG4gICAgICAgICAgICBhZnRlclRpbWVvdXQocmV0LCBtZXNzYWdlLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgfSwgbXMpKTtcblxuICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSkge1xuICAgICAgICBwYXJlbnQgPSB0aGlzLnRoZW4oKTtcbiAgICAgICAgcmV0ID0gcGFyZW50Ll90aGVuKHN1Y2Nlc3NDbGVhciwgZmFpbHVyZUNsZWFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgaGFuZGxlV3JhcHBlciwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbChoYW5kbGVXcmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSB0aGlzLl90aGVuKHN1Y2Nlc3NDbGVhciwgZmFpbHVyZUNsZWFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgaGFuZGxlV3JhcHBlciwgdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufTtcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3RpbWVycy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZWplY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIElOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQcm94eWFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKSB7XG52YXIgZXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIFR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciB5aWVsZEhhbmRsZXJzID0gW107XG5cbmZ1bmN0aW9uIHByb21pc2VGcm9tWWllbGRIYW5kbGVyKHZhbHVlLCB5aWVsZEhhbmRsZXJzLCB0cmFjZVBhcmVudCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeWllbGRIYW5kbGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0cmFjZVBhcmVudC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHlpZWxkSGFuZGxlcnNbaV0pKHZhbHVlKTtcbiAgICAgICAgdHJhY2VQYXJlbnQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIHRyYWNlUGFyZW50Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHJldCA9IFByb21pc2UucmVqZWN0KGVycm9yT2JqLmUpO1xuICAgICAgICAgICAgdHJhY2VQYXJlbnQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmVzdWx0LCB0cmFjZVBhcmVudCk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gbWF5YmVQcm9taXNlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gUHJvbWlzZVNwYXduKGdlbmVyYXRvckZ1bmN0aW9uLCByZWNlaXZlciwgeWllbGRIYW5kbGVyLCBzdGFjaykge1xuICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSkge1xuICAgICAgICB2YXIgaW50ZXJuYWwgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHZhciBfZmluYWxseVByb21pc2UgPSB0aGlzLl9maW5hbGx5UHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZSA9IGludGVybmFsLmxhc3RseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmluYWxseVByb21pc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnRlcm5hbC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgaW50ZXJuYWwuX3NldE9uQ2FuY2VsKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB9XG4gICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmN0aW9uO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fZ2VuZXJhdG9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3lpZWxkSGFuZGxlcnMgPSB0eXBlb2YgeWllbGRIYW5kbGVyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBbeWllbGRIYW5kbGVyXS5jb25jYXQoeWllbGRIYW5kbGVycylcbiAgICAgICAgOiB5aWVsZEhhbmRsZXJzO1xuICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9jYW5jZWxsYXRpb25QaGFzZSA9IGZhbHNlO1xufVxudXRpbC5pbmhlcml0cyhQcm9taXNlU3Bhd24sIFByb3h5YWJsZSk7XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX2lzUmVzb2x2ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZSA9PT0gbnVsbDtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wcm9taXNlID0gdGhpcy5fZ2VuZXJhdG9yID0gbnVsbDtcbiAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkgJiYgdGhpcy5fZmluYWxseVByb21pc2UgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fZmluYWxseVByb21pc2UuX2Z1bGZpbGwoKTtcbiAgICAgICAgdGhpcy5fZmluYWxseVByb21pc2UgPSBudWxsO1xuICAgIH1cbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgdmFyIGltcGxlbWVudHNSZXR1cm4gPSB0eXBlb2YgdGhpcy5fZ2VuZXJhdG9yW1wicmV0dXJuXCJdICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoIWltcGxlbWVudHNSZXR1cm4pIHtcbiAgICAgICAgdmFyIHJlYXNvbiA9IG5ldyBQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yKFxuICAgICAgICAgICAgXCJnZW5lcmF0b3IgLnJldHVybigpIHNlbnRpbmVsXCIpO1xuICAgICAgICBQcm9taXNlLmNvcm91dGluZS5yZXR1cm5TZW50aW5lbCA9IHJlYXNvbjtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3JbXCJ0aHJvd1wiXSkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24pO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yW1wicmV0dXJuXCJdKS5jYWxsKHRoaXMuX2dlbmVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgfVxuICAgIHRoaXMuX2NhbmNlbGxhdGlvblBoYXNlID0gdHJ1ZTtcbiAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3IubmV4dCkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsIHZhbHVlKTtcbiAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHJlYXNvbik7XG4gICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yW1widGhyb3dcIl0pXG4gICAgICAgIC5jYWxsKHRoaXMuX2dlbmVyYXRvciwgcmVhc29uKTtcbiAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl95aWVsZGVkUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl95aWVsZGVkUHJvbWlzZTtcbiAgICAgICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBudWxsO1xuICAgICAgICBwcm9taXNlLmNhbmNlbCgpO1xuICAgIH1cbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3J1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9nZW5lcmF0b3IgPSB0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbi5jYWxsKHRoaXMuX3JlY2VpdmVyKTtcbiAgICB0aGlzLl9yZWNlaXZlciA9XG4gICAgICAgIHRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Byb21pc2VGdWxmaWxsZWQodW5kZWZpbmVkKTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX2NvbnRpbnVlID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZTtcbiAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgIGlmICh0aGlzLl9jYW5jZWxsYXRpb25QaGFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVzdWx0LmUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICBpZiAocmVzdWx0LmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICBpZiAodGhpcy5fY2FuY2VsbGF0aW9uUGhhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmNhbmNlbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZSwgdGhpcy5fcHJvbWlzZSk7XG4gICAgICAgIGlmICghKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPVxuICAgICAgICAgICAgICAgIHByb21pc2VGcm9tWWllbGRIYW5kbGVyKG1heWJlUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl95aWVsZEhhbmRsZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UpO1xuICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2VSZWplY3RlZChcbiAgICAgICAgICAgICAgICAgICAgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQSB2YWx1ZSAlcyB3YXMgeWllbGRlZCB0aGF0IGNvdWxkIG5vdCBiZSB0cmVhdGVkIGFzIGEgcHJvbWlzZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcXHUwMDBhXCIucmVwbGFjZShcIiVzXCIsIFN0cmluZyh2YWx1ZSkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiRnJvbSBjb3JvdXRpbmU6XFx1MDAwYVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDEsIC03KS5qb2luKFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICA7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBtYXliZVByb21pc2U7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuX3Byb3h5KHRoaXMsIG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICBQcm9taXNlLl9hc3luYy5pbnZva2UoXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZCwgdGhpcywgbWF5YmVQcm9taXNlLl92YWx1ZSgpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICBQcm9taXNlLl9hc3luYy5pbnZva2UoXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZVJlamVjdGVkLCB0aGlzLCBtYXliZVByb21pc2UuX3JlYXNvbigpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUNhbmNlbGxlZCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5jb3JvdXRpbmUgPSBmdW5jdGlvbiAoZ2VuZXJhdG9yRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGdlbmVyYXRvckZ1bmN0aW9uICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImdlbmVyYXRvckZ1bmN0aW9uIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciB5aWVsZEhhbmRsZXIgPSBPYmplY3Qob3B0aW9ucykueWllbGRIYW5kbGVyO1xuICAgIHZhciBQcm9taXNlU3Bhd24kID0gUHJvbWlzZVNwYXduO1xuICAgIHZhciBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSBnZW5lcmF0b3JGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgc3Bhd24gPSBuZXcgUHJvbWlzZVNwYXduJCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgeWllbGRIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjayk7XG4gICAgICAgIHZhciByZXQgPSBzcGF3bi5wcm9taXNlKCk7XG4gICAgICAgIHNwYXduLl9nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgIHNwYXduLl9wcm9taXNlRnVsZmlsbGVkKHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn07XG5cblByb21pc2UuY29yb3V0aW5lLmFkZFlpZWxkSGFuZGxlciA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICB5aWVsZEhhbmRsZXJzLnB1c2goZm4pO1xufTtcblxuUHJvbWlzZS5zcGF3biA9IGZ1bmN0aW9uIChnZW5lcmF0b3JGdW5jdGlvbikge1xuICAgIGRlYnVnLmRlcHJlY2F0ZWQoXCJQcm9taXNlLnNwYXduKClcIiwgXCJQcm9taXNlLmNvcm91dGluZSgpXCIpO1xuICAgIGlmICh0eXBlb2YgZ2VuZXJhdG9yRnVuY3Rpb24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZ2VuZXJhdG9yRnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdmFyIHNwYXduID0gbmV3IFByb21pc2VTcGF3bihnZW5lcmF0b3JGdW5jdGlvbiwgdGhpcyk7XG4gICAgdmFyIHJldCA9IHNwYXduLnByb21pc2UoKTtcbiAgICBzcGF3bi5fcnVuKFByb21pc2Uuc3Bhd24pO1xuICAgIHJldHVybiByZXQ7XG59O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2dlbmVyYXRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGFzeW5jID0gUHJvbWlzZS5fYXN5bmM7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuZnVuY3Rpb24gc3ByZWFkQWRhcHRlcih2YWwsIG5vZGViYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIGlmICghdXRpbC5pc0FycmF5KHZhbCkpIHJldHVybiBzdWNjZXNzQWRhcHRlci5jYWxsKHByb21pc2UsIHZhbCwgbm9kZWJhY2spO1xuICAgIHZhciByZXQgPVxuICAgICAgICB0cnlDYXRjaChub2RlYmFjaykuYXBwbHkocHJvbWlzZS5fYm91bmRWYWx1ZSgpLCBbbnVsbF0uY29uY2F0KHZhbCkpO1xuICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIocmV0LmUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3VjY2Vzc0FkYXB0ZXIodmFsLCBub2RlYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgcmVjZWl2ZXIgPSBwcm9taXNlLl9ib3VuZFZhbHVlKCk7XG4gICAgdmFyIHJldCA9IHZhbCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gdHJ5Q2F0Y2gobm9kZWJhY2spLmNhbGwocmVjZWl2ZXIsIG51bGwpXG4gICAgICAgIDogdHJ5Q2F0Y2gobm9kZWJhY2spLmNhbGwocmVjZWl2ZXIsIG51bGwsIHZhbCk7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihyZXQuZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXJyb3JBZGFwdGVyKHJlYXNvbiwgbm9kZWJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcihyZWFzb24gKyBcIlwiKTtcbiAgICAgICAgbmV3UmVhc29uLmNhdXNlID0gcmVhc29uO1xuICAgICAgICByZWFzb24gPSBuZXdSZWFzb247XG4gICAgfVxuICAgIHZhciByZXQgPSB0cnlDYXRjaChub2RlYmFjaykuY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksIHJlYXNvbik7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihyZXQuZSk7XG4gICAgfVxufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hc0NhbGxiYWNrID0gUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChub2RlYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG5vZGViYWNrID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgYWRhcHRlciA9IHN1Y2Nlc3NBZGFwdGVyO1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIE9iamVjdChvcHRpb25zKS5zcHJlYWQpIHtcbiAgICAgICAgICAgIGFkYXB0ZXIgPSBzcHJlYWRBZGFwdGVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RoZW4oXG4gICAgICAgICAgICBhZGFwdGVyLFxuICAgICAgICAgICAgZXJyb3JBZGFwdGVyLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIG5vZGViYWNrXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9ub2RlaWZ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgVEhJUyA9IHt9O1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIG5vZGViYWNrRm9yUHJvbWlzZSA9IHJlcXVpcmUoXCIuL25vZGViYWNrXCIpO1xudmFyIHdpdGhBcHBlbmRlZCA9IHV0aWwud2l0aEFwcGVuZGVkO1xudmFyIG1heWJlV3JhcEFzRXJyb3IgPSB1dGlsLm1heWJlV3JhcEFzRXJyb3I7XG52YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xudmFyIFR5cGVFcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKS5UeXBlRXJyb3I7XG52YXIgZGVmYXVsdFN1ZmZpeCA9IFwiQXN5bmNcIjtcbnZhciBkZWZhdWx0UHJvbWlzaWZpZWQgPSB7X19pc1Byb21pc2lmaWVkX186IHRydWV9O1xudmFyIG5vQ29weVByb3BzID0gW1xuICAgIFwiYXJpdHlcIiwgICAgXCJsZW5ndGhcIixcbiAgICBcIm5hbWVcIixcbiAgICBcImFyZ3VtZW50c1wiLFxuICAgIFwiY2FsbGVyXCIsXG4gICAgXCJjYWxsZWVcIixcbiAgICBcInByb3RvdHlwZVwiLFxuICAgIFwiX19pc1Byb21pc2lmaWVkX19cIlxuXTtcbnZhciBub0NvcHlQcm9wc1BhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgbm9Db3B5UHJvcHMuam9pbihcInxcIikgKyBcIikkXCIpO1xuXG52YXIgZGVmYXVsdEZpbHRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdXRpbC5pc0lkZW50aWZpZXIobmFtZSkgJiZcbiAgICAgICAgbmFtZS5jaGFyQXQoMCkgIT09IFwiX1wiICYmXG4gICAgICAgIG5hbWUgIT09IFwiY29uc3RydWN0b3JcIjtcbn07XG5cbmZ1bmN0aW9uIHByb3BzRmlsdGVyKGtleSkge1xuICAgIHJldHVybiAhbm9Db3B5UHJvcHNQYXR0ZXJuLnRlc3Qoa2V5KTtcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNpZmllZChmbikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbi5fX2lzUHJvbWlzaWZpZWRfXyA9PT0gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFzUHJvbWlzaWZpZWQob2JqLCBrZXksIHN1ZmZpeCkge1xuICAgIHZhciB2YWwgPSB1dGlsLmdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdChvYmosIGtleSArIHN1ZmZpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb21pc2lmaWVkKTtcbiAgICByZXR1cm4gdmFsID8gaXNQcm9taXNpZmllZCh2YWwpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkKHJldCwgc3VmZml4LCBzdWZmaXhSZWdleHApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIga2V5ID0gcmV0W2ldO1xuICAgICAgICBpZiAoc3VmZml4UmVnZXhwLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgdmFyIGtleVdpdGhvdXRBc3luY1N1ZmZpeCA9IGtleS5yZXBsYWNlKHN1ZmZpeFJlZ2V4cCwgXCJcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJldC5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIGlmIChyZXRbal0gPT09IGtleVdpdGhvdXRBc3luY1N1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHByb21pc2lmeSBhbiBBUEkgdGhhdCBoYXMgbm9ybWFsIG1ldGhvZHMgd2l0aCAnJXMnLXN1ZmZpeFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCIlc1wiLCBzdWZmaXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHByb21pc2lmaWFibGVNZXRob2RzKG9iaiwgc3VmZml4LCBzdWZmaXhSZWdleHAsIGZpbHRlcikge1xuICAgIHZhciBrZXlzID0gdXRpbC5pbmhlcml0ZWREYXRhS2V5cyhvYmopO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICB2YXIgcGFzc2VzRGVmYXVsdEZpbHRlciA9IGZpbHRlciA9PT0gZGVmYXVsdEZpbHRlclxuICAgICAgICAgICAgPyB0cnVlIDogZGVmYXVsdEZpbHRlcihrZXksIHZhbHVlLCBvYmopO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICFpc1Byb21pc2lmaWVkKHZhbHVlKSAmJlxuICAgICAgICAgICAgIWhhc1Byb21pc2lmaWVkKG9iaiwga2V5LCBzdWZmaXgpICYmXG4gICAgICAgICAgICBmaWx0ZXIoa2V5LCB2YWx1ZSwgb2JqLCBwYXNzZXNEZWZhdWx0RmlsdGVyKSkge1xuICAgICAgICAgICAgcmV0LnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tWYWxpZChyZXQsIHN1ZmZpeCwgc3VmZml4UmVnZXhwKTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG52YXIgZXNjYXBlSWRlbnRSZWdleCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFskXSkvLCBcIlxcXFwkXCIpO1xufTtcblxudmFyIG1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsO1xuaWYgKCFmYWxzZSkge1xudmFyIHN3aXRjaENhc2VBcmd1bWVudE9yZGVyID0gZnVuY3Rpb24obGlrZWx5QXJndW1lbnRDb3VudCkge1xuICAgIHZhciByZXQgPSBbbGlrZWx5QXJndW1lbnRDb3VudF07XG4gICAgdmFyIG1pbiA9IE1hdGgubWF4KDAsIGxpa2VseUFyZ3VtZW50Q291bnQgLSAxIC0gMyk7XG4gICAgZm9yKHZhciBpID0gbGlrZWx5QXJndW1lbnRDb3VudCAtIDE7IGkgPj0gbWluOyAtLWkpIHtcbiAgICAgICAgcmV0LnB1c2goaSk7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IGxpa2VseUFyZ3VtZW50Q291bnQgKyAxOyBpIDw9IDM7ICsraSkge1xuICAgICAgICByZXQucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbnZhciBhcmd1bWVudFNlcXVlbmNlID0gZnVuY3Rpb24oYXJndW1lbnRDb3VudCkge1xuICAgIHJldHVybiB1dGlsLmZpbGxlZFJhbmdlKGFyZ3VtZW50Q291bnQsIFwiX2FyZ1wiLCBcIlwiKTtcbn07XG5cbnZhciBwYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKHBhcmFtZXRlckNvdW50KSB7XG4gICAgcmV0dXJuIHV0aWwuZmlsbGVkUmFuZ2UoXG4gICAgICAgIE1hdGgubWF4KHBhcmFtZXRlckNvdW50LCAzKSwgXCJfYXJnXCIsIFwiXCIpO1xufTtcblxudmFyIHBhcmFtZXRlckNvdW50ID0gZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oZm4ubGVuZ3RoLCAxMDIzICsgMSksIDApO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5cbm1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsID1cbmZ1bmN0aW9uKGNhbGxiYWNrLCByZWNlaXZlciwgb3JpZ2luYWxOYW1lLCBmbiwgXywgbXVsdGlBcmdzKSB7XG4gICAgdmFyIG5ld1BhcmFtZXRlckNvdW50ID0gTWF0aC5tYXgoMCwgcGFyYW1ldGVyQ291bnQoZm4pIC0gMSk7XG4gICAgdmFyIGFyZ3VtZW50T3JkZXIgPSBzd2l0Y2hDYXNlQXJndW1lbnRPcmRlcihuZXdQYXJhbWV0ZXJDb3VudCk7XG4gICAgdmFyIHNob3VsZFByb3h5VGhpcyA9IHR5cGVvZiBjYWxsYmFjayA9PT0gXCJzdHJpbmdcIiB8fCByZWNlaXZlciA9PT0gVEhJUztcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ2FsbEZvckFyZ3VtZW50Q291bnQoY291bnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudFNlcXVlbmNlKGNvdW50KS5qb2luKFwiLCBcIik7XG4gICAgICAgIHZhciBjb21tYSA9IGNvdW50ID4gMCA/IFwiLCBcIiA6IFwiXCI7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIGlmIChzaG91bGRQcm94eVRoaXMpIHtcbiAgICAgICAgICAgIHJldCA9IFwicmV0ID0gY2FsbGJhY2suY2FsbCh0aGlzLCB7e2FyZ3N9fSwgbm9kZWJhY2spOyBicmVhaztcXG5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IHJlY2VpdmVyID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFwicmV0ID0gY2FsbGJhY2soe3thcmdzfX0sIG5vZGViYWNrKTsgYnJlYWs7XFxuXCJcbiAgICAgICAgICAgICAgICA6IFwicmV0ID0gY2FsbGJhY2suY2FsbChyZWNlaXZlciwge3thcmdzfX0sIG5vZGViYWNrKTsgYnJlYWs7XFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldC5yZXBsYWNlKFwie3thcmdzfX1cIiwgYXJncykucmVwbGFjZShcIiwgXCIsIGNvbW1hKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUFyZ3VtZW50U3dpdGNoQ2FzZSgpIHtcbiAgICAgICAgdmFyIHJldCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRPcmRlci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmV0ICs9IFwiY2FzZSBcIiArIGFyZ3VtZW50T3JkZXJbaV0gK1wiOlwiICtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUNhbGxGb3JBcmd1bWVudENvdW50KGFyZ3VtZW50T3JkZXJbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ICs9IFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgaSA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBhcmdzW2ldID0gbm9kZWJhY2s7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbQ29kZUZvckNhbGxdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBicmVhazsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoXCJbQ29kZUZvckNhbGxdXCIsIChzaG91bGRQcm94eVRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcInJldCA9IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xcblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJyZXQgPSBjYWxsYmFjay5hcHBseShyZWNlaXZlciwgYXJncyk7XFxuXCIpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICB2YXIgZ2V0RnVuY3Rpb25Db2RlID0gdHlwZW9mIGNhbGxiYWNrID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKFwidGhpcyAhPSBudWxsID8gdGhpc1snXCIrY2FsbGJhY2srXCInXSA6IGZuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJmblwiO1xuICAgIHZhciBib2R5ID0gXCIndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgdmFyIHJldCA9IGZ1bmN0aW9uIChQYXJhbWV0ZXJzKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBub2RlYmFjayA9IG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlLCBcIiArIG11bHRpQXJncyArIFwiKTsgICBcXG5cXFxuICAgICAgICAgICAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gdHJ5Q2F0Y2goW0dldEZ1bmN0aW9uQ29kZV0pOyAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgc3dpdGNoKGxlbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtDb2RlRm9yU3dpdGNoQ2FzZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKG1heWJlV3JhcEFzRXJyb3IocmV0LmUpLCB0cnVlLCB0cnVlKTtcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaWYgKCFwcm9taXNlLl9pc0ZhdGVTZWFsZWQoKSkgcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7ICAgICBcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcChyZXQsICdfX2lzUHJvbWlzaWZpZWRfXycsIHRydWUpOyAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICByZXR1cm4gcmV0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgIFwiLnJlcGxhY2UoXCJbQ29kZUZvclN3aXRjaENhc2VdXCIsIGdlbmVyYXRlQXJndW1lbnRTd2l0Y2hDYXNlKCkpXG4gICAgICAgIC5yZXBsYWNlKFwiW0dldEZ1bmN0aW9uQ29kZV1cIiwgZ2V0RnVuY3Rpb25Db2RlKTtcbiAgICBib2R5ID0gYm9keS5yZXBsYWNlKFwiUGFyYW1ldGVyc1wiLCBwYXJhbWV0ZXJEZWNsYXJhdGlvbihuZXdQYXJhbWV0ZXJDb3VudCkpO1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJQcm9taXNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlY2VpdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpdGhBcHBlbmRlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXliZVdyYXBBc0Vycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5vZGViYWNrRm9yUHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cnlDYXRjaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJlcnJvck9ialwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJub3RFbnVtZXJhYmxlUHJvcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJJTlRFUk5BTFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSkoXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIGZuLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlcixcbiAgICAgICAgICAgICAgICAgICAgd2l0aEFwcGVuZGVkLFxuICAgICAgICAgICAgICAgICAgICBtYXliZVdyYXBBc0Vycm9yLFxuICAgICAgICAgICAgICAgICAgICBub2RlYmFja0ZvclByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIHV0aWwudHJ5Q2F0Y2gsXG4gICAgICAgICAgICAgICAgICAgIHV0aWwuZXJyb3JPYmosXG4gICAgICAgICAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AsXG4gICAgICAgICAgICAgICAgICAgIElOVEVSTkFMKTtcbn07XG59XG5cbmZ1bmN0aW9uIG1ha2VOb2RlUHJvbWlzaWZpZWRDbG9zdXJlKGNhbGxiYWNrLCByZWNlaXZlciwgXywgZm4sIF9fLCBtdWx0aUFyZ3MpIHtcbiAgICB2YXIgZGVmYXVsdFRoaXMgPSAoZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXM7fSkoKTtcbiAgICB2YXIgbWV0aG9kID0gY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiBtZXRob2QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBmbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvbWlzaWZpZWQoKSB7XG4gICAgICAgIHZhciBfcmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSBUSElTKSBfcmVjZWl2ZXIgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgdmFyIGNiID0gdHlwZW9mIG1ldGhvZCA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzICE9PSBkZWZhdWx0VGhpc1xuICAgICAgICAgICAgPyB0aGlzW21ldGhvZF0gOiBjYWxsYmFjaztcbiAgICAgICAgdmFyIGZuID0gbm9kZWJhY2tGb3JQcm9taXNlKHByb21pc2UsIG11bHRpQXJncyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYi5hcHBseShfcmVjZWl2ZXIsIHdpdGhBcHBlbmRlZChhcmd1bWVudHMsIGZuKSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2sobWF5YmVXcmFwQXNFcnJvcihlKSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm9taXNlLl9pc0ZhdGVTZWFsZWQoKSkgcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKHByb21pc2lmaWVkLCBcIl9faXNQcm9taXNpZmllZF9fXCIsIHRydWUpO1xuICAgIHJldHVybiBwcm9taXNpZmllZDtcbn1cblxudmFyIG1ha2VOb2RlUHJvbWlzaWZpZWQgPSBjYW5FdmFsdWF0ZVxuICAgID8gbWFrZU5vZGVQcm9taXNpZmllZEV2YWxcbiAgICA6IG1ha2VOb2RlUHJvbWlzaWZpZWRDbG9zdXJlO1xuXG5mdW5jdGlvbiBwcm9taXNpZnlBbGwob2JqLCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIsIG11bHRpQXJncykge1xuICAgIHZhciBzdWZmaXhSZWdleHAgPSBuZXcgUmVnRXhwKGVzY2FwZUlkZW50UmVnZXgoc3VmZml4KSArIFwiJFwiKTtcbiAgICB2YXIgbWV0aG9kcyA9XG4gICAgICAgIHByb21pc2lmaWFibGVNZXRob2RzKG9iaiwgc3VmZml4LCBzdWZmaXhSZWdleHAsIGZpbHRlcik7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWV0aG9kcy5sZW5ndGg7IGkgPCBsZW47IGkrPSAyKSB7XG4gICAgICAgIHZhciBrZXkgPSBtZXRob2RzW2ldO1xuICAgICAgICB2YXIgZm4gPSBtZXRob2RzW2krMV07XG4gICAgICAgIHZhciBwcm9taXNpZmllZEtleSA9IGtleSArIHN1ZmZpeDtcbiAgICAgICAgaWYgKHByb21pc2lmaWVyID09PSBtYWtlTm9kZVByb21pc2lmaWVkKSB7XG4gICAgICAgICAgICBvYmpbcHJvbWlzaWZpZWRLZXldID1cbiAgICAgICAgICAgICAgICBtYWtlTm9kZVByb21pc2lmaWVkKGtleSwgVEhJUywga2V5LCBmbiwgc3VmZml4LCBtdWx0aUFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByb21pc2lmaWVkID0gcHJvbWlzaWZpZXIoZm4sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTm9kZVByb21pc2lmaWVkKGtleSwgVEhJUywga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLCBzdWZmaXgsIG11bHRpQXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AocHJvbWlzaWZpZWQsIFwiX19pc1Byb21pc2lmaWVkX19cIiwgdHJ1ZSk7XG4gICAgICAgICAgICBvYmpbcHJvbWlzaWZpZWRLZXldID0gcHJvbWlzaWZpZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZ5KGNhbGxiYWNrLCByZWNlaXZlciwgbXVsdGlBcmdzKSB7XG4gICAgcmV0dXJuIG1ha2VOb2RlUHJvbWlzaWZpZWQoY2FsbGJhY2ssIHJlY2VpdmVyLCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLCBudWxsLCBtdWx0aUFyZ3MpO1xufVxuXG5Qcm9taXNlLnByb21pc2lmeSA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgaWYgKGlzUHJvbWlzaWZpZWQoZm4pKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9XG4gICAgb3B0aW9ucyA9IE9iamVjdChvcHRpb25zKTtcbiAgICB2YXIgcmVjZWl2ZXIgPSBvcHRpb25zLmNvbnRleHQgPT09IHVuZGVmaW5lZCA/IFRISVMgOiBvcHRpb25zLmNvbnRleHQ7XG4gICAgdmFyIG11bHRpQXJncyA9ICEhb3B0aW9ucy5tdWx0aUFyZ3M7XG4gICAgdmFyIHJldCA9IHByb21pc2lmeShmbiwgcmVjZWl2ZXIsIG11bHRpQXJncyk7XG4gICAgdXRpbC5jb3B5RGVzY3JpcHRvcnMoZm4sIHJldCwgcHJvcHNGaWx0ZXIpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb21pc2lmeUFsbCA9IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSB0YXJnZXQgb2YgcHJvbWlzaWZ5QWxsIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0gT2JqZWN0KG9wdGlvbnMpO1xuICAgIHZhciBtdWx0aUFyZ3MgPSAhIW9wdGlvbnMubXVsdGlBcmdzO1xuICAgIHZhciBzdWZmaXggPSBvcHRpb25zLnN1ZmZpeDtcbiAgICBpZiAodHlwZW9mIHN1ZmZpeCAhPT0gXCJzdHJpbmdcIikgc3VmZml4ID0gZGVmYXVsdFN1ZmZpeDtcbiAgICB2YXIgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgIT09IFwiZnVuY3Rpb25cIikgZmlsdGVyID0gZGVmYXVsdEZpbHRlcjtcbiAgICB2YXIgcHJvbWlzaWZpZXIgPSBvcHRpb25zLnByb21pc2lmaWVyO1xuICAgIGlmICh0eXBlb2YgcHJvbWlzaWZpZXIgIT09IFwiZnVuY3Rpb25cIikgcHJvbWlzaWZpZXIgPSBtYWtlTm9kZVByb21pc2lmaWVkO1xuXG4gICAgaWYgKCF1dGlsLmlzSWRlbnRpZmllcihzdWZmaXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwic3VmZml4IG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IHV0aWwuaW5oZXJpdGVkRGF0YUtleXModGFyZ2V0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGFyZ2V0W2tleXNbaV1dO1xuICAgICAgICBpZiAoa2V5c1tpXSAhPT0gXCJjb25zdHJ1Y3RvclwiICYmXG4gICAgICAgICAgICB1dGlsLmlzQ2xhc3ModmFsdWUpKSB7XG4gICAgICAgICAgICBwcm9taXNpZnlBbGwodmFsdWUucHJvdG90eXBlLCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIsXG4gICAgICAgICAgICAgICAgbXVsdGlBcmdzKTtcbiAgICAgICAgICAgIHByb21pc2lmeUFsbCh2YWx1ZSwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyLCBtdWx0aUFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2lmeUFsbCh0YXJnZXQsIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllciwgbXVsdGlBcmdzKTtcbn07XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNpZnkuanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oXG4gICAgUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG52YXIgZXM1ID0gcmVxdWlyZShcIi4vZXM1XCIpO1xudmFyIEVzNk1hcDtcbmlmICh0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIpIEVzNk1hcCA9IE1hcDtcblxudmFyIG1hcFRvRW50cmllcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzaXplID0gMDtcblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RFbnRyeSh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHRoaXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHRoaXNbaW5kZXggKyBzaXplXSA9IGtleTtcbiAgICAgICAgaW5kZXgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWFwVG9FbnRyaWVzKG1hcCkge1xuICAgICAgICBzaXplID0gbWFwLnNpemU7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBBcnJheShtYXAuc2l6ZSAqIDIpO1xuICAgICAgICBtYXAuZm9yRWFjaChleHRyYWN0RW50cnksIHJldCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn0pKCk7XG5cbnZhciBlbnRyaWVzVG9NYXAgPSBmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgdmFyIHJldCA9IG5ldyBFczZNYXAoKTtcbiAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGggLyAyIHwgMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBlbnRyaWVzW2xlbmd0aCArIGldO1xuICAgICAgICB2YXIgdmFsdWUgPSBlbnRyaWVzW2ldO1xuICAgICAgICByZXQuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gUHJvcGVydGllc1Byb21pc2VBcnJheShvYmopIHtcbiAgICB2YXIgaXNNYXAgPSBmYWxzZTtcbiAgICB2YXIgZW50cmllcztcbiAgICBpZiAoRXM2TWFwICE9PSB1bmRlZmluZWQgJiYgb2JqIGluc3RhbmNlb2YgRXM2TWFwKSB7XG4gICAgICAgIGVudHJpZXMgPSBtYXBUb0VudHJpZXMob2JqKTtcbiAgICAgICAgaXNNYXAgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gZXM1LmtleXMob2JqKTtcbiAgICAgICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICBlbnRyaWVzID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGVudHJpZXNbaV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGVudHJpZXNbaSArIGxlbl0gPSBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQoZW50cmllcyk7XG4gICAgdGhpcy5faXNNYXAgPSBpc01hcDtcbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIGlzTWFwID8gLTYgOiAtMyk7XG59XG51dGlsLmluaGVyaXRzKFByb3BlcnRpZXNQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge307XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgaWYgKHRoaXMuX2lzTWFwKSB7XG4gICAgICAgICAgICB2YWwgPSBlbnRyaWVzVG9NYXAodGhpcy5fdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IHt9O1xuICAgICAgICAgICAgdmFyIGtleU9mZnNldCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5sZW5ndGgoKTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFsW3RoaXMuX3ZhbHVlc1tpICsga2V5T2Zmc2V0XV0gPSB0aGlzLl92YWx1ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh2YWwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5nZXRBY3R1YWxMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgcmV0dXJuIGxlbiA+PiAxO1xufTtcblxuZnVuY3Rpb24gcHJvcHMocHJvbWlzZXMpIHtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBjYXN0VmFsdWUgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHByb21pc2VzKTtcblxuICAgIGlmICghaXNPYmplY3QoY2FzdFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiY2Fubm90IGF3YWl0IHByb3BlcnRpZXMgb2YgYSBub24tb2JqZWN0XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9IGVsc2UgaWYgKGNhc3RWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0ID0gY2FzdFZhbHVlLl90aGVuKFxuICAgICAgICAgICAgUHJvbWlzZS5wcm9wcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBuZXcgUHJvcGVydGllc1Byb21pc2VBcnJheShjYXN0VmFsdWUpLnByb21pc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoY2FzdFZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXQuX3Byb3BhZ2F0ZUZyb20oY2FzdFZhbHVlLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucHJvcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb3BzKHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm9wcyA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIHJldHVybiBwcm9wcyhwcm9taXNlcyk7XG59O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3Byb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFxuICAgIFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIHJhY2VMYXRlciA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihhcnJheSkge1xuICAgICAgICByZXR1cm4gcmFjZShhcnJheSwgcHJvbWlzZSk7XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiByYWNlKHByb21pc2VzLCBwYXJlbnQpIHtcbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShwcm9taXNlcyk7XG5cbiAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gcmFjZUxhdGVyKG1heWJlUHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZXMgPSB1dGlsLmFzQXJyYXkocHJvbWlzZXMpO1xuICAgICAgICBpZiAocHJvbWlzZXMgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGFuIGFycmF5IG9yIGFuIGl0ZXJhYmxlIG9iamVjdCBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhwcm9taXNlcykpO1xuICAgIH1cblxuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgaWYgKHBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldC5fcHJvcGFnYXRlRnJvbShwYXJlbnQsIDMpO1xuICAgIH1cbiAgICB2YXIgZnVsZmlsbCA9IHJldC5fZnVsZmlsbDtcbiAgICB2YXIgcmVqZWN0ID0gcmV0Ll9yZWplY3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb21pc2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciB2YWwgPSBwcm9taXNlc1tpXTtcblxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQgJiYgIShpIGluIHByb21pc2VzKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBQcm9taXNlLmNhc3QodmFsKS5fdGhlbihmdWxmaWxsLCByZWplY3QsIHVuZGVmaW5lZCwgcmV0LCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHJhY2UocHJvbWlzZXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByYWNlKHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvcmFjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlQXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlamVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKSB7XG52YXIgZ2V0RG9tYWluID0gUHJvbWlzZS5fZ2V0RG9tYWluO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcblxuZnVuY3Rpb24gUmVkdWN0aW9uUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHByb21pc2VzKTtcbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgdGhpcy5fZm4gPSBkb21haW4gPT09IG51bGwgPyBmbiA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZuKTtcbiAgICBpZiAoaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5pdGlhbFZhbHVlID0gUHJvbWlzZS5yZXNvbHZlKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIGluaXRpYWxWYWx1ZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB0aGlzLl9jdXJyZW50Q2FuY2VsbGFibGUgPSBudWxsO1xuICAgIGlmKF9lYWNoID09PSBJTlRFUk5BTCkge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzID0gQXJyYXkodGhpcy5fbGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKF9lYWNoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuX3Byb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgdGhpcy5faW5pdCQodW5kZWZpbmVkLCAtNSk7XG59XG51dGlsLmluaGVyaXRzKFJlZHVjdGlvblByb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZ290QWNjdW0gPSBmdW5jdGlvbihhY2N1bSkge1xuICAgIGlmICh0aGlzLl9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQgJiYgXG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMgIT09IG51bGwgJiYgXG4gICAgICAgIGFjY3VtICE9PSBJTlRFUk5BTCkge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzLnB1c2goYWNjdW0pO1xuICAgIH1cbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2VhY2hDb21wbGV0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2VhY2hWYWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VhY2hWYWx1ZXM7XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7fTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZUVtcHR5QXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCA/IHRoaXMuX2VhY2hWYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2luaXRpYWxWYWx1ZSk7XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oc2VuZGVyKSB7XG4gICAgaWYgKHNlbmRlciA9PT0gdGhpcy5faW5pdGlhbFZhbHVlKSByZXR1cm4gdGhpcy5fY2FuY2VsKCk7XG4gICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSkgcmV0dXJuO1xuICAgIHRoaXMuX3Jlc3VsdENhbmNlbGxlZCQoKTtcbiAgICBpZiAodGhpcy5fY3VycmVudENhbmNlbGxhYmxlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50Q2FuY2VsbGFibGUuY2FuY2VsKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pbml0aWFsVmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxWYWx1ZS5jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pdGVyYXRlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5faW5pdGlhbFZhbHVlO1xuICAgICAgICBpID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNbMF0pO1xuICAgICAgICBpID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50Q2FuY2VsbGFibGUgPSB2YWx1ZTtcblxuICAgIGlmICghdmFsdWUuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB7XG4gICAgICAgICAgICAgICAgYWNjdW06IG51bGwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpXSxcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgICAgICAgICBhcnJheTogdGhpc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuX3RoZW4oZ290QWNjdW0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjdHgsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgIC5fdGhlbih0aGlzLl9lYWNoQ29tcGxldGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0aGlzLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICB2YWx1ZS5fdGhlbihjb21wbGV0ZWQsIGNvbXBsZXRlZCwgdW5kZWZpbmVkLCB2YWx1ZSwgdGhpcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWxWYWx1ZSkge1xuICAgIHJldHVybiByZWR1Y2UodGhpcywgZm4sIGluaXRpYWxWYWx1ZSwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnJlZHVjZSA9IGZ1bmN0aW9uIChwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpIHtcbiAgICByZXR1cm4gcmVkdWNlKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCk7XG59O1xuXG5mdW5jdGlvbiBjb21wbGV0ZWQodmFsdWVPclJlYXNvbiwgYXJyYXkpIHtcbiAgICBpZiAodGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgIGFycmF5Ll9yZXNvbHZlKHZhbHVlT3JSZWFzb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5Ll9yZWplY3QodmFsdWVPclJlYXNvbik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2UocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICB2YXIgYXJyYXkgPSBuZXcgUmVkdWN0aW9uUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCk7XG4gICAgcmV0dXJuIGFycmF5LnByb21pc2UoKTtcbn1cblxuZnVuY3Rpb24gZ290QWNjdW0oYWNjdW0pIHtcbiAgICB0aGlzLmFjY3VtID0gYWNjdW07XG4gICAgdGhpcy5hcnJheS5fZ290QWNjdW0oYWNjdW0pO1xuICAgIHZhciB2YWx1ZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodGhpcy52YWx1ZSwgdGhpcy5hcnJheS5fcHJvbWlzZSk7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB0aGlzLmFycmF5Ll9jdXJyZW50Q2FuY2VsbGFibGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLl90aGVuKGdvdFZhbHVlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ290VmFsdWUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnb3RWYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgdmFyIHByb21pc2UgPSBhcnJheS5fcHJvbWlzZTtcbiAgICB2YXIgZm4gPSB0cnlDYXRjaChhcnJheS5fZm4pO1xuICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHJldDtcbiAgICBpZiAoYXJyYXkuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXQgPSBmbi5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSwgdmFsdWUsIHRoaXMuaW5kZXgsIHRoaXMubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBmbi5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWNjdW0sIHZhbHVlLCB0aGlzLmluZGV4LCB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIGFycmF5Ll9jdXJyZW50Q2FuY2VsbGFibGUgPSByZXQ7XG4gICAgfVxuICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHByb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoXG4gICAgICAgIHJldCxcbiAgICAgICAgcHJvbWlzZUNyZWF0ZWQsXG4gICAgICAgIGFycmF5Ll9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQgPyBcIlByb21pc2UuZWFjaFwiIDogXCJQcm9taXNlLnJlZHVjZVwiLFxuICAgICAgICBwcm9taXNlXG4gICAgKTtcbiAgICByZXR1cm4gcmV0O1xufVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3JlZHVjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuICAgIGZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgZGVidWcpIHtcbnZhciBQcm9taXNlSW5zcGVjdGlvbiA9IFByb21pc2UuUHJvbWlzZUluc3BlY3Rpb247XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbmZ1bmN0aW9uIFNldHRsZWRQcm9taXNlQXJyYXkodmFsdWVzKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQodmFsdWVzKTtcbn1cbnV0aWwuaW5oZXJpdHMoU2V0dGxlZFByb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuU2V0dGxlZFByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZXNvbHZlZCA9IGZ1bmN0aW9uIChpbmRleCwgaW5zcGVjdGlvbikge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSBpbnNwZWN0aW9uO1xuICAgIHZhciB0b3RhbFJlc29sdmVkID0gKyt0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgIGlmICh0b3RhbFJlc29sdmVkID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5TZXR0bGVkUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VJbnNwZWN0aW9uKCk7XG4gICAgcmV0Ll9iaXRGaWVsZCA9IDMzNTU0NDMyO1xuICAgIHJldC5fc2V0dGxlZFZhbHVlRmllbGQgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZVJlc29sdmVkKGluZGV4LCByZXQpO1xufTtcblNldHRsZWRQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uLCBpbmRleCkge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZUluc3BlY3Rpb24oKTtcbiAgICByZXQuX2JpdEZpZWxkID0gMTY3NzcyMTY7XG4gICAgcmV0Ll9zZXR0bGVkVmFsdWVGaWVsZCA9IHJlYXNvbjtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZVJlc29sdmVkKGluZGV4LCByZXQpO1xufTtcblxuUHJvbWlzZS5zZXR0bGUgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiLnNldHRsZSgpXCIsIFwiLnJlZmxlY3QoKVwiKTtcbiAgICByZXR1cm4gbmV3IFNldHRsZWRQcm9taXNlQXJyYXkocHJvbWlzZXMpLnByb21pc2UoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNldHRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5zZXR0bGUodGhpcyk7XG59O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL3NldHRsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBSYW5nZUVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpLlJhbmdlRXJyb3I7XG52YXIgQWdncmVnYXRlRXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvcnNcIikuQWdncmVnYXRlRXJyb3I7XG52YXIgaXNBcnJheSA9IHV0aWwuaXNBcnJheTtcbnZhciBDQU5DRUxMQVRJT04gPSB7fTtcblxuXG5mdW5jdGlvbiBTb21lUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHZhbHVlcyk7XG4gICAgdGhpcy5faG93TWFueSA9IDA7XG4gICAgdGhpcy5fdW53cmFwID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn1cbnV0aWwuaW5oZXJpdHMoU29tZVByb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9ob3dNYW55ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUoW10pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTUpO1xuICAgIHZhciBpc0FycmF5UmVzb2x2ZWQgPSBpc0FycmF5KHRoaXMuX3ZhbHVlcyk7XG4gICAgaWYgKCF0aGlzLl9pc1Jlc29sdmVkKCkgJiZcbiAgICAgICAgaXNBcnJheVJlc29sdmVkICYmXG4gICAgICAgIHRoaXMuX2hvd01hbnkgPiB0aGlzLl9jYW5Qb3NzaWJseUZ1bGZpbGwoKSkge1xuICAgICAgICB0aGlzLl9yZWplY3QodGhpcy5fZ2V0UmFuZ2VFcnJvcih0aGlzLmxlbmd0aCgpKSk7XG4gICAgfVxufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5faW5pdCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuc2V0VW53cmFwID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Vud3JhcCA9IHRydWU7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5ob3dNYW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9ob3dNYW55O1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuc2V0SG93TWFueSA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIHRoaXMuX2hvd01hbnkgPSBjb3VudDtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fYWRkRnVsZmlsbGVkKHZhbHVlKTtcbiAgICBpZiAodGhpcy5fZnVsZmlsbGVkKCkgPT09IHRoaXMuaG93TWFueSgpKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSB0aGlzLmhvd01hbnkoKTtcbiAgICAgICAgaWYgKHRoaXMuaG93TWFueSgpID09PSAxICYmIHRoaXMuX3Vud3JhcCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG5cbn07XG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX2FkZFJlamVjdGVkKHJlYXNvbik7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrT3V0Y29tZSgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3ZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UgfHwgdGhpcy5fdmFsdWVzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbCgpO1xuICAgIH1cbiAgICB0aGlzLl9hZGRSZWplY3RlZChDQU5DRUxMQVRJT04pO1xuICAgIHJldHVybiB0aGlzLl9jaGVja091dGNvbWUoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9jaGVja091dGNvbWUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ob3dNYW55KCkgPiB0aGlzLl9jYW5Qb3NzaWJseUZ1bGZpbGwoKSkge1xuICAgICAgICB2YXIgZSA9IG5ldyBBZ2dyZWdhdGVFcnJvcigpO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGgoKTsgaSA8IHRoaXMuX3ZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlc1tpXSAhPT0gQ0FOQ0VMTEFUSU9OKSB7XG4gICAgICAgICAgICAgICAgZS5wdXNoKHRoaXMuX3ZhbHVlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9mdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsUmVzb2x2ZWQ7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGggLSB0aGlzLmxlbmd0aCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2FkZFJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHJlYXNvbik7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fYWRkRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWVzW3RoaXMuX3RvdGFsUmVzb2x2ZWQrK10gPSB2YWx1ZTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9jYW5Qb3NzaWJseUZ1bGZpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgLSB0aGlzLl9yZWplY3RlZCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2dldFJhbmdlRXJyb3IgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICB2YXIgbWVzc2FnZSA9IFwiSW5wdXQgYXJyYXkgbXVzdCBjb250YWluIGF0IGxlYXN0IFwiICtcbiAgICAgICAgICAgIHRoaXMuX2hvd01hbnkgKyBcIiBpdGVtcyBidXQgY29udGFpbnMgb25seSBcIiArIGNvdW50ICsgXCIgaXRlbXNcIjtcbiAgICByZXR1cm4gbmV3IFJhbmdlRXJyb3IobWVzc2FnZSk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZUVtcHR5QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVqZWN0KHRoaXMuX2dldFJhbmdlRXJyb3IoMCkpO1xufTtcblxuZnVuY3Rpb24gc29tZShwcm9taXNlcywgaG93TWFueSkge1xuICAgIGlmICgoaG93TWFueSB8IDApICE9PSBob3dNYW55IHx8IGhvd01hbnkgPCAwKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBwb3NpdGl2ZSBpbnRlZ2VyXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdmFyIHJldCA9IG5ldyBTb21lUHJvbWlzZUFycmF5KHByb21pc2VzKTtcbiAgICB2YXIgcHJvbWlzZSA9IHJldC5wcm9taXNlKCk7XG4gICAgcmV0LnNldEhvd01hbnkoaG93TWFueSk7XG4gICAgcmV0LmluaXQoKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuUHJvbWlzZS5zb21lID0gZnVuY3Rpb24gKHByb21pc2VzLCBob3dNYW55KSB7XG4gICAgcmV0dXJuIHNvbWUocHJvbWlzZXMsIGhvd01hbnkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uIChob3dNYW55KSB7XG4gICAgcmV0dXJuIHNvbWUodGhpcywgaG93TWFueSk7XG59O1xuXG5Qcm9taXNlLl9Tb21lUHJvbWlzZUFycmF5ID0gU29tZVByb21pc2VBcnJheTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmx1ZWJpcmQvanMvcmVsZWFzZS9zb21lLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgUHJvbWlzZU1hcCA9IFByb21pc2UubWFwO1xuXG5Qcm9taXNlLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUHJvbWlzZU1hcCh0aGlzLCBmbiwgb3B0aW9ucywgSU5URVJOQUwpO1xufTtcblxuUHJvbWlzZS5maWx0ZXIgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFByb21pc2VNYXAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBJTlRFUk5BTCk7XG59O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2ZpbHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFByb21pc2VSZWR1Y2UgPSBQcm9taXNlLnJlZHVjZTtcbnZhciBQcm9taXNlQWxsID0gUHJvbWlzZS5hbGw7XG5cbmZ1bmN0aW9uIHByb21pc2VBbGxUaGlzKCkge1xuICAgIHJldHVybiBQcm9taXNlQWxsKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBQcm9taXNlTWFwU2VyaWVzKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgSU5URVJOQUwsIElOVEVSTkFMKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHRoaXMsIGZuLCBJTlRFUk5BTCwgMClcbiAgICAgICAgICAgICAgLl90aGVuKHByb21pc2VBbGxUaGlzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm1hcFNlcmllcyA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHRoaXMsIGZuLCBJTlRFUk5BTCwgSU5URVJOQUwpO1xufTtcblxuUHJvbWlzZS5lYWNoID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgSU5URVJOQUwsIDApXG4gICAgICAgICAgICAgIC5fdGhlbihwcm9taXNlQWxsVGhpcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb21pc2VzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5tYXBTZXJpZXMgPSBQcm9taXNlTWFwU2VyaWVzO1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JsdWViaXJkL2pzL3JlbGVhc2UvZWFjaC5qc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgU29tZVByb21pc2VBcnJheSA9IFByb21pc2UuX1NvbWVQcm9taXNlQXJyYXk7XG5mdW5jdGlvbiBhbnkocHJvbWlzZXMpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFNvbWVQcm9taXNlQXJyYXkocHJvbWlzZXMpO1xuICAgIHZhciBwcm9taXNlID0gcmV0LnByb21pc2UoKTtcbiAgICByZXQuc2V0SG93TWFueSgxKTtcbiAgICByZXQuc2V0VW53cmFwKCk7XG4gICAgcmV0LmluaXQoKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuUHJvbWlzZS5hbnkgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gYW55KHByb21pc2VzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYW55KHRoaXMpO1xufTtcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibHVlYmlyZC9qcy9yZWxlYXNlL2FueS5qc1xuLy8gbW9kdWxlIGlkID0gMTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4gICAgLy9wb2x5ZmlsbCBiaW5kXHJcbiAgICBpZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XHJcbiAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihvVGhpcykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1IGludGVybmFsIElzQ2FsbGFibGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuICAgICAgICAgICAgICAgIGZUb0JpbmQgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgZk5PUCA9IGZ1bmN0aW9uKCkge30sXHJcbiAgICAgICAgICAgICAgICBmQm91bmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseSh0aGlzIGluc3RhbmNlb2YgZk5PUCAmJiBvVGhpcyA/IHRoaXMgOiBvVGhpcyB8fCB3aW5kb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcclxuICAgICAgICAgICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZkJvdW5kO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy9wb2x5ZmlsbCByZW1vdmVcclxuICAgIGlmICghKCdyZW1vdmUnIGluIEVsZW1lbnQucHJvdG90eXBlKSkge1xyXG4gICAgICAgIEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aCkge1xyXG4gICAgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aCA9IGZ1bmN0aW9uKHNlYXJjaFN0cmluZywgcG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgc3ViamVjdFN0cmluZyA9IHRoaXMudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJyB8fCAhaXNGaW5pdGUocG9zaXRpb24pIHx8IE1hdGguZmxvb3IocG9zaXRpb24pICE9PSBwb3NpdGlvbiB8fCBwb3NpdGlvbiA+IHN1YmplY3RTdHJpbmcubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uID0gc3ViamVjdFN0cmluZy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IHN1YmplY3RTdHJpbmcuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKTtcclxuICAgICAgICByZXR1cm4gbGFzdEluZGV4ICE9PSAtMSAmJiBsYXN0SW5kZXggPT09IHBvc2l0aW9uO1xyXG4gICAgfTtcclxuICAgIH1cclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9wb2x5ZmlsbC5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoXCIuL2dyYXBoaWNcIik7XG5cbnZhciBfenJlbmRlciA9IHJlcXVpcmUoXCIuLi96cmVuZGVyXCIpO1xuXG52YXIgcmVnaXN0ZXJQYWludGVyID0gX3pyZW5kZXIucmVnaXN0ZXJQYWludGVyO1xuXG52YXIgUGFpbnRlciA9IHJlcXVpcmUoXCIuL1BhaW50ZXJcIik7XG5cbnJlZ2lzdGVyUGFpbnRlcigndm1sJywgUGFpbnRlcik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3ZtbC92bWwuanNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZW52ID0gcmVxdWlyZShcIi4uL2NvcmUvZW52XCIpO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIGFwcGx5VHJhbnNmb3JtID0gX3ZlY3Rvci5hcHBseVRyYW5zZm9ybTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuLi9jb3JlL0JvdW5kaW5nUmVjdFwiKTtcblxudmFyIGNvbG9yVG9vbCA9IHJlcXVpcmUoXCIuLi90b29sL2NvbG9yXCIpO1xuXG52YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwiLi4vY29udGFpbi90ZXh0XCIpO1xuXG52YXIgdGV4dEhlbHBlciA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL2hlbHBlci90ZXh0XCIpO1xuXG52YXIgUmVjdFRleHQgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9taXhpbi9SZWN0VGV4dFwiKTtcblxudmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvRGlzcGxheWFibGVcIik7XG5cbnZhciBaSW1hZ2UgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9JbWFnZVwiKTtcblxudmFyIFRleHQgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9UZXh0XCIpO1xuXG52YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL1BhdGhcIik7XG5cbnZhciBQYXRoUHJveHkgPSByZXF1aXJlKFwiLi4vY29yZS9QYXRoUHJveHlcIik7XG5cbnZhciBHcmFkaWVudCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL0dyYWRpZW50XCIpO1xuXG52YXIgdm1sQ29yZSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL05PVEUtVk1MXG4vLyBUT0RPIFVzZSBwcm94eSBsaWtlIHN2ZyBpbnN0ZWFkIG9mIG92ZXJ3cml0ZSBicnVzaCBtZXRob2RzXG52YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgc3FydCA9IE1hdGguc3FydDtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBjb3MgPSBNYXRoLmNvcztcbnZhciBzaW4gPSBNYXRoLnNpbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG5cbmlmICghZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICB2YXIgY29tbWEgPSAnLCc7XG4gIHZhciBpbWFnZVRyYW5zZm9ybVByZWZpeCA9ICdwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQnO1xuICB2YXIgWiA9IDIxNjAwO1xuICB2YXIgWjIgPSBaIC8gMjtcbiAgdmFyIFpMRVZFTF9CQVNFID0gMTAwMDAwO1xuICB2YXIgWl9CQVNFID0gMTAwMDtcblxuICB2YXIgaW5pdFJvb3RFbFN0eWxlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgZWwuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7d2lkdGg6MXB4O2hlaWdodDoxcHg7JztcbiAgICBlbC5jb29yZHNpemUgPSBaICsgJywnICsgWjtcbiAgICBlbC5jb29yZG9yaWdpbiA9ICcwLDAnO1xuICB9O1xuXG4gIHZhciBlbmNvZGVIdG1sQXR0cmlidXRlID0gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gU3RyaW5nKHMpLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICB9O1xuXG4gIHZhciByZ2IyU3RyID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICByZXR1cm4gJ3JnYignICsgW3IsIGcsIGJdLmpvaW4oJywnKSArICcpJztcbiAgfTtcblxuICB2YXIgYXBwZW5kID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgJiYgcGFyZW50ICYmIGNoaWxkLnBhcmVudE5vZGUgIT09IHBhcmVudCkge1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJlbW92ZSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkICYmIHBhcmVudCAmJiBjaGlsZC5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRaSW5kZXggPSBmdW5jdGlvbiAoemxldmVsLCB6LCB6Mikge1xuICAgIC8vIHog55qE5Y+W5YC86IyD5Zu05Li6IFswLCAxMDAwXVxuICAgIHJldHVybiAocGFyc2VGbG9hdCh6bGV2ZWwpIHx8IDApICogWkxFVkVMX0JBU0UgKyAocGFyc2VGbG9hdCh6KSB8fCAwKSAqIFpfQkFTRSArIHoyO1xuICB9O1xuXG4gIHZhciBwYXJzZVBlcmNlbnQgPSBmdW5jdGlvbiAodmFsdWUsIG1heFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh2YWx1ZS5sYXN0SW5kZXhPZignJScpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogbWF4VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogUEFUSFxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICB2YXIgc2V0Q29sb3JBbmRPcGFjaXR5ID0gZnVuY3Rpb24gKGVsLCBjb2xvciwgb3BhY2l0eSkge1xuICAgIHZhciBjb2xvckFyciA9IGNvbG9yVG9vbC5wYXJzZShjb2xvcik7XG4gICAgb3BhY2l0eSA9ICtvcGFjaXR5O1xuXG4gICAgaWYgKGlzTmFOKG9wYWNpdHkpKSB7XG4gICAgICBvcGFjaXR5ID0gMTtcbiAgICB9XG5cbiAgICBpZiAoY29sb3JBcnIpIHtcbiAgICAgIGVsLmNvbG9yID0gcmdiMlN0cihjb2xvckFyclswXSwgY29sb3JBcnJbMV0sIGNvbG9yQXJyWzJdKTtcbiAgICAgIGVsLm9wYWNpdHkgPSBvcGFjaXR5ICogY29sb3JBcnJbM107XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRDb2xvckFuZEFscGhhID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdmFyIGNvbG9yQXJyID0gY29sb3JUb29sLnBhcnNlKGNvbG9yKTtcbiAgICByZXR1cm4gW3JnYjJTdHIoY29sb3JBcnJbMF0sIGNvbG9yQXJyWzFdLCBjb2xvckFyclsyXSksIGNvbG9yQXJyWzNdXTtcbiAgfTtcblxuICB2YXIgdXBkYXRlRmlsbE5vZGUgPSBmdW5jdGlvbiAoZWwsIHN0eWxlLCB6ckVsKSB7XG4gICAgLy8gVE9ETyBwYXR0ZXJuXG4gICAgdmFyIGZpbGwgPSBzdHlsZS5maWxsO1xuXG4gICAgaWYgKGZpbGwgIT0gbnVsbCkge1xuICAgICAgLy8gTW9kaWZpZWQgZnJvbSBleGNhbnZhc1xuICAgICAgaWYgKGZpbGwgaW5zdGFuY2VvZiBHcmFkaWVudCkge1xuICAgICAgICB2YXIgZ3JhZGllbnRUeXBlO1xuICAgICAgICB2YXIgYW5nbGUgPSAwO1xuICAgICAgICB2YXIgZm9jdXMgPSBbMCwgMF07IC8vIGFkZGl0aW9uYWwgb2Zmc2V0XG5cbiAgICAgICAgdmFyIHNoaWZ0ID0gMDsgLy8gc2NhbGUgZmFjdG9yIGZvciBvZmZzZXRcblxuICAgICAgICB2YXIgZXhwYW5zaW9uID0gMTtcbiAgICAgICAgdmFyIHJlY3QgPSB6ckVsLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB2YXIgcmVjdFdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgdmFyIHJlY3RIZWlnaHQgPSByZWN0LmhlaWdodDtcblxuICAgICAgICBpZiAoZmlsbC50eXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgIGdyYWRpZW50VHlwZSA9ICdncmFkaWVudCc7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHpyRWwudHJhbnNmb3JtO1xuICAgICAgICAgIHZhciBwMCA9IFtmaWxsLnggKiByZWN0V2lkdGgsIGZpbGwueSAqIHJlY3RIZWlnaHRdO1xuICAgICAgICAgIHZhciBwMSA9IFtmaWxsLngyICogcmVjdFdpZHRoLCBmaWxsLnkyICogcmVjdEhlaWdodF07XG5cbiAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMCwgcDAsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMSwgcDEsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGR4ID0gcDFbMF0gLSBwMFswXTtcbiAgICAgICAgICB2YXIgZHkgPSBwMVsxXSAtIHAwWzFdO1xuICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihkeCwgZHkpICogMTgwIC8gTWF0aC5QSTsgLy8gVGhlIGFuZ2xlIHNob3VsZCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuXG5cbiAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICBhbmdsZSArPSAzNjA7XG4gICAgICAgICAgfSAvLyBWZXJ5IHNtYWxsIGFuZ2xlcyBwcm9kdWNlIGFuIHVuZXhwZWN0ZWQgcmVzdWx0IGJlY2F1c2UgdGhleSBhcmVcbiAgICAgICAgICAvLyBjb252ZXJ0ZWQgdG8gYSBzY2llbnRpZmljIG5vdGF0aW9uIHN0cmluZy5cblxuXG4gICAgICAgICAgaWYgKGFuZ2xlIDwgMWUtNikge1xuICAgICAgICAgICAgYW5nbGUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmFkaWVudFR5cGUgPSAnZ3JhZGllbnRyYWRpYWwnO1xuICAgICAgICAgIHZhciBwMCA9IFtmaWxsLnggKiByZWN0V2lkdGgsIGZpbGwueSAqIHJlY3RIZWlnaHRdO1xuICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB6ckVsLnRyYW5zZm9ybTtcbiAgICAgICAgICB2YXIgc2NhbGUgPSB6ckVsLnNjYWxlO1xuICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3RXaWR0aDtcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdEhlaWdodDtcbiAgICAgICAgICBmb2N1cyA9IFsvLyBQZXJjZW50IGluIGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICAocDBbMF0gLSByZWN0LngpIC8gd2lkdGgsIChwMFsxXSAtIHJlY3QueSkgLyBoZWlnaHRdO1xuXG4gICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdpZHRoIC89IHNjYWxlWzBdICogWjtcbiAgICAgICAgICBoZWlnaHQgLz0gc2NhbGVbMV0gKiBaO1xuICAgICAgICAgIHZhciBkaW1lbnNpb24gPSBtYXRoTWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIHNoaWZ0ID0gMiAqIDAgLyBkaW1lbnNpb247XG4gICAgICAgICAgZXhwYW5zaW9uID0gMiAqIGZpbGwuciAvIGRpbWVuc2lvbiAtIHNoaWZ0O1xuICAgICAgICB9IC8vIFdlIG5lZWQgdG8gc29ydCB0aGUgY29sb3Igc3RvcHMgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IG9mZnNldCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIElFIHdvbid0IGludGVycHJldCBpdCBjb3JyZWN0bHkuXG5cblxuICAgICAgICB2YXIgc3RvcHMgPSBmaWxsLmNvbG9yU3RvcHMuc2xpY2UoKTtcbiAgICAgICAgc3RvcHMuc29ydChmdW5jdGlvbiAoY3MxLCBjczIpIHtcbiAgICAgICAgICByZXR1cm4gY3MxLm9mZnNldCAtIGNzMi5vZmZzZXQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbGVuZ3RoID0gc3RvcHMubGVuZ3RoOyAvLyBDb2xvciBhbmQgYWxwaGEgbGlzdCBvZiBmaXJzdCBhbmQgbGFzdCBzdG9wXG5cbiAgICAgICAgdmFyIGNvbG9yQW5kQWxwaGFMaXN0ID0gW107XG4gICAgICAgIHZhciBjb2xvcnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0b3AgPSBzdG9wc1tpXTtcbiAgICAgICAgICB2YXIgY29sb3JBbmRBbHBoYSA9IGdldENvbG9yQW5kQWxwaGEoc3RvcC5jb2xvcik7XG4gICAgICAgICAgY29sb3JzLnB1c2goc3RvcC5vZmZzZXQgKiBleHBhbnNpb24gKyBzaGlmdCArICcgJyArIGNvbG9yQW5kQWxwaGFbMF0pO1xuXG4gICAgICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgY29sb3JBbmRBbHBoYUxpc3QucHVzaChjb2xvckFuZEFscGhhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoID49IDIpIHtcbiAgICAgICAgICB2YXIgY29sb3IxID0gY29sb3JBbmRBbHBoYUxpc3RbMF1bMF07XG4gICAgICAgICAgdmFyIGNvbG9yMiA9IGNvbG9yQW5kQWxwaGFMaXN0WzFdWzBdO1xuICAgICAgICAgIHZhciBvcGFjaXR5MSA9IGNvbG9yQW5kQWxwaGFMaXN0WzBdWzFdICogc3R5bGUub3BhY2l0eTtcbiAgICAgICAgICB2YXIgb3BhY2l0eTIgPSBjb2xvckFuZEFscGhhTGlzdFsxXVsxXSAqIHN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgZWwudHlwZSA9IGdyYWRpZW50VHlwZTtcbiAgICAgICAgICBlbC5tZXRob2QgPSAnbm9uZSc7XG4gICAgICAgICAgZWwuZm9jdXMgPSAnMTAwJSc7XG4gICAgICAgICAgZWwuYW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICBlbC5jb2xvciA9IGNvbG9yMTtcbiAgICAgICAgICBlbC5jb2xvcjIgPSBjb2xvcjI7XG4gICAgICAgICAgZWwuY29sb3JzID0gY29sb3JzLmpvaW4oJywnKTsgLy8gV2hlbiBjb2xvcnMgYXR0cmlidXRlIGlzIHVzZWQsIHRoZSBtZWFuaW5ncyBvZiBvcGFjaXR5IGFuZCBvOm9wYWNpdHkyXG4gICAgICAgICAgLy8gYXJlIHJldmVyc2VkLlxuXG4gICAgICAgICAgZWwub3BhY2l0eSA9IG9wYWNpdHkyOyAvLyBGSVhNRSBnX29fOm9wYWNpdHkgP1xuXG4gICAgICAgICAgZWwub3BhY2l0eTIgPSBvcGFjaXR5MTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChncmFkaWVudFR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgICAgZWwuZm9jdXNwb3NpdGlvbiA9IGZvY3VzLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRklYTUUgQ2hhbmdlIGZyb20gR3JhZGllbnQgZmlsbCB0byBjb2xvciBmaWxsXG4gICAgICAgIHNldENvbG9yQW5kT3BhY2l0eShlbCwgZmlsbCwgc3R5bGUub3BhY2l0eSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciB1cGRhdGVTdHJva2VOb2RlID0gZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xuICAgIC8vIGlmIChzdHlsZS5saW5lSm9pbiAhPSBudWxsKSB7XG4gICAgLy8gICAgIGVsLmpvaW5zdHlsZSA9IHN0eWxlLmxpbmVKb2luO1xuICAgIC8vIH1cbiAgICAvLyBpZiAoc3R5bGUubWl0ZXJMaW1pdCAhPSBudWxsKSB7XG4gICAgLy8gICAgIGVsLm1pdGVybGltaXQgPSBzdHlsZS5taXRlckxpbWl0ICogWjtcbiAgICAvLyB9XG4gICAgLy8gaWYgKHN0eWxlLmxpbmVDYXAgIT0gbnVsbCkge1xuICAgIC8vICAgICBlbC5lbmRjYXAgPSBzdHlsZS5saW5lQ2FwO1xuICAgIC8vIH1cbiAgICBpZiAoc3R5bGUubGluZURhc2ggIT0gbnVsbCkge1xuICAgICAgZWwuZGFzaHN0eWxlID0gc3R5bGUubGluZURhc2guam9pbignICcpO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS5zdHJva2UgIT0gbnVsbCAmJiAhKHN0eWxlLnN0cm9rZSBpbnN0YW5jZW9mIEdyYWRpZW50KSkge1xuICAgICAgc2V0Q29sb3JBbmRPcGFjaXR5KGVsLCBzdHlsZS5zdHJva2UsIHN0eWxlLm9wYWNpdHkpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdXBkYXRlRmlsbEFuZFN0cm9rZSA9IGZ1bmN0aW9uICh2bWxFbCwgdHlwZSwgc3R5bGUsIHpyRWwpIHtcbiAgICB2YXIgaXNGaWxsID0gdHlwZSA9PSAnZmlsbCc7XG4gICAgdmFyIGVsID0gdm1sRWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUodHlwZSlbMF07IC8vIFN0cm9rZSBtdXN0IGhhdmUgbGluZVdpZHRoXG5cbiAgICBpZiAoc3R5bGVbdHlwZV0gIT0gbnVsbCAmJiBzdHlsZVt0eXBlXSAhPT0gJ25vbmUnICYmIChpc0ZpbGwgfHwgIWlzRmlsbCAmJiBzdHlsZS5saW5lV2lkdGgpKSB7XG4gICAgICB2bWxFbFtpc0ZpbGwgPyAnZmlsbGVkJyA6ICdzdHJva2VkJ10gPSAndHJ1ZSc7IC8vIEZJWE1FIFJlbW92ZSBiZWZvcmUgdXBkYXRpbmcsIG9yIHNldCBgY29sb3JzYCB3aWxsIHRocm93IGVycm9yXG5cbiAgICAgIGlmIChzdHlsZVt0eXBlXSBpbnN0YW5jZW9mIEdyYWRpZW50KSB7XG4gICAgICAgIHJlbW92ZSh2bWxFbCwgZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIGVsID0gdm1sQ29yZS5jcmVhdGVOb2RlKHR5cGUpO1xuICAgICAgfVxuXG4gICAgICBpc0ZpbGwgPyB1cGRhdGVGaWxsTm9kZShlbCwgc3R5bGUsIHpyRWwpIDogdXBkYXRlU3Ryb2tlTm9kZShlbCwgc3R5bGUpO1xuICAgICAgYXBwZW5kKHZtbEVsLCBlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtbEVsW2lzRmlsbCA/ICdmaWxsZWQnIDogJ3N0cm9rZWQnXSA9ICdmYWxzZSc7XG4gICAgICByZW1vdmUodm1sRWwsIGVsKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBvaW50cyA9IFtbXSwgW10sIFtdXTtcblxuICB2YXIgcGF0aERhdGFUb1N0cmluZyA9IGZ1bmN0aW9uIChwYXRoLCBtKSB7XG4gICAgdmFyIE0gPSBDTUQuTTtcbiAgICB2YXIgQyA9IENNRC5DO1xuICAgIHZhciBMID0gQ01ELkw7XG4gICAgdmFyIEEgPSBDTUQuQTtcbiAgICB2YXIgUSA9IENNRC5RO1xuICAgIHZhciBzdHIgPSBbXTtcbiAgICB2YXIgblBvaW50O1xuICAgIHZhciBjbWRTdHI7XG4gICAgdmFyIGNtZDtcbiAgICB2YXIgaTtcbiAgICB2YXIgeGk7XG4gICAgdmFyIHlpO1xuICAgIHZhciBkYXRhID0gcGF0aC5kYXRhO1xuICAgIHZhciBkYXRhTGVuZ3RoID0gcGF0aC5sZW4oKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOykge1xuICAgICAgY21kID0gZGF0YVtpKytdO1xuICAgICAgY21kU3RyID0gJyc7XG4gICAgICBuUG9pbnQgPSAwO1xuXG4gICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlIE06XG4gICAgICAgICAgY21kU3RyID0gJyBtICc7XG4gICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBwb2ludHNbMF1bMF0gPSB4aTtcbiAgICAgICAgICBwb2ludHNbMF1bMV0gPSB5aTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEw6XG4gICAgICAgICAgY21kU3RyID0gJyBsICc7XG4gICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBwb2ludHNbMF1bMF0gPSB4aTtcbiAgICAgICAgICBwb2ludHNbMF1bMV0gPSB5aTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFE6XG4gICAgICAgIGNhc2UgQzpcbiAgICAgICAgICBjbWRTdHIgPSAnIGMgJztcbiAgICAgICAgICBuUG9pbnQgPSAzO1xuICAgICAgICAgIHZhciB4MSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgeTEgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHgyID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB5MiA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgeDM7XG4gICAgICAgICAgdmFyIHkzO1xuXG4gICAgICAgICAgaWYgKGNtZCA9PT0gUSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBxdWFkcmF0aWMgdG8gY3ViaWMgdXNpbmcgZGVncmVlIGVsZXZhdGlvblxuICAgICAgICAgICAgeDMgPSB4MjtcbiAgICAgICAgICAgIHkzID0geTI7XG4gICAgICAgICAgICB4MiA9ICh4MiArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgeTIgPSAoeTIgKyAyICogeTEpIC8gMztcbiAgICAgICAgICAgIHgxID0gKHhpICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICB5MSA9ICh5aSArIDIgKiB5MSkgLyAzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4MyA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgIHkzID0gZGF0YVtpKytdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvaW50c1swXVswXSA9IHgxO1xuICAgICAgICAgIHBvaW50c1swXVsxXSA9IHkxO1xuICAgICAgICAgIHBvaW50c1sxXVswXSA9IHgyO1xuICAgICAgICAgIHBvaW50c1sxXVsxXSA9IHkyO1xuICAgICAgICAgIHBvaW50c1syXVswXSA9IHgzO1xuICAgICAgICAgIHBvaW50c1syXVsxXSA9IHkzO1xuICAgICAgICAgIHhpID0geDM7XG4gICAgICAgICAgeWkgPSB5MztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEE6XG4gICAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgICB2YXIgc3ggPSAxO1xuICAgICAgICAgIHZhciBzeSA9IDE7XG4gICAgICAgICAgdmFyIGFuZ2xlID0gMDtcblxuICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IFNSVCBmcm9tIG1hdHJpeFxuICAgICAgICAgICAgeCA9IG1bNF07XG4gICAgICAgICAgICB5ID0gbVs1XTtcbiAgICAgICAgICAgIHN4ID0gc3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgICAgICAgIHN5ID0gc3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IGRhdGFbaSsrXSArIGFuZ2xlO1xuICAgICAgICAgIHZhciBlbmRBbmdsZSA9IGRhdGFbaSsrXSArIHN0YXJ0QW5nbGUgKyBhbmdsZTsgLy8gRklYTUVcbiAgICAgICAgICAvLyB2YXIgcHNpID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHgwID0gY3ggKyBjb3Moc3RhcnRBbmdsZSkgKiByeDtcbiAgICAgICAgICB2YXIgeTAgPSBjeSArIHNpbihzdGFydEFuZ2xlKSAqIHJ5O1xuICAgICAgICAgIHZhciB4MSA9IGN4ICsgY29zKGVuZEFuZ2xlKSAqIHJ4O1xuICAgICAgICAgIHZhciB5MSA9IGN5ICsgc2luKGVuZEFuZ2xlKSAqIHJ5O1xuICAgICAgICAgIHZhciB0eXBlID0gY2xvY2t3aXNlID8gJyB3YSAnIDogJyBhdCAnO1xuXG4gICAgICAgICAgaWYgKE1hdGguYWJzKHgwIC0geDEpIDwgMWUtNCkge1xuICAgICAgICAgICAgLy8gSUUgd29uJ3QgcmVuZGVyIGFyY2hlcyBkcmF3biBjb3VudGVyIGNsb2Nrd2lzZSBpZiB4MCA9PSB4MS5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpID4gMWUtMikge1xuICAgICAgICAgICAgICAvLyBPZmZzZXQgeDAgYnkgMS84MCBvZiBhIHBpeGVsLiBVc2Ugc29tZXRoaW5nXG4gICAgICAgICAgICAgIC8vIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGluIGJpbmFyeVxuICAgICAgICAgICAgICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICAgICAgeDAgKz0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gQXZvaWQgY2FzZSBkcmF3IGZ1bGwgY2lyY2xlXG4gICAgICAgICAgICAgIGlmIChNYXRoLmFicyh5MCAtIGN5KSA8IDFlLTQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xvY2t3aXNlICYmIHgwIDwgY3ggfHwgIWNsb2Nrd2lzZSAmJiB4MCA+IGN4KSB7XG4gICAgICAgICAgICAgICAgICB5MSAtPSAyNzAgLyBaO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB5MSArPSAyNzAgLyBaO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjbG9ja3dpc2UgJiYgeTAgPCBjeSB8fCAhY2xvY2t3aXNlICYmIHkwID4gY3kpIHtcbiAgICAgICAgICAgICAgICB4MSArPSAyNzAgLyBaO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHgxIC09IDI3MCAvIFo7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdHIucHVzaCh0eXBlLCByb3VuZCgoKGN4IC0gcngpICogc3ggKyB4KSAqIFogLSBaMiksIGNvbW1hLCByb3VuZCgoKGN5IC0gcnkpICogc3kgKyB5KSAqIFogLSBaMiksIGNvbW1hLCByb3VuZCgoKGN4ICsgcngpICogc3ggKyB4KSAqIFogLSBaMiksIGNvbW1hLCByb3VuZCgoKGN5ICsgcnkpICogc3kgKyB5KSAqIFogLSBaMiksIGNvbW1hLCByb3VuZCgoeDAgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCh5MCAqIHN5ICsgeSkgKiBaIC0gWjIpLCBjb21tYSwgcm91bmQoKHgxICogc3ggKyB4KSAqIFogLSBaMiksIGNvbW1hLCByb3VuZCgoeTEgKiBzeSArIHkpICogWiAtIFoyKSk7XG4gICAgICAgICAgeGkgPSB4MTtcbiAgICAgICAgICB5aSA9IHkxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgdmFyIHAwID0gcG9pbnRzWzBdO1xuICAgICAgICAgIHZhciBwMSA9IHBvaW50c1sxXTsgLy8geDAsIHkwXG5cbiAgICAgICAgICBwMFswXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBwMFsxXSA9IGRhdGFbaSsrXTsgLy8geDEsIHkxXG5cbiAgICAgICAgICBwMVswXSA9IHAwWzBdICsgZGF0YVtpKytdO1xuICAgICAgICAgIHAxWzFdID0gcDBbMV0gKyBkYXRhW2krK107XG5cbiAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCBtKTtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgbSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcDBbMF0gPSByb3VuZChwMFswXSAqIFogLSBaMik7XG4gICAgICAgICAgcDFbMF0gPSByb3VuZChwMVswXSAqIFogLSBaMik7XG4gICAgICAgICAgcDBbMV0gPSByb3VuZChwMFsxXSAqIFogLSBaMik7XG4gICAgICAgICAgcDFbMV0gPSByb3VuZChwMVsxXSAqIFogLSBaMik7XG4gICAgICAgICAgc3RyLnB1c2goIC8vIHgwLCB5MFxuICAgICAgICAgICcgbSAnLCBwMFswXSwgY29tbWEsIHAwWzFdLCAvLyB4MSwgeTBcbiAgICAgICAgICAnIGwgJywgcDFbMF0sIGNvbW1hLCBwMFsxXSwgLy8geDEsIHkxXG4gICAgICAgICAgJyBsICcsIHAxWzBdLCBjb21tYSwgcDFbMV0sIC8vIHgwLCB5MVxuICAgICAgICAgICcgbCAnLCBwMFswXSwgY29tbWEsIHAxWzFdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgIC8vIEZJWE1FIFVwZGF0ZSB4aSwgeWlcbiAgICAgICAgICBzdHIucHVzaCgnIHggJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuUG9pbnQgPiAwKSB7XG4gICAgICAgIHN0ci5wdXNoKGNtZFN0cik7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuUG9pbnQ7IGsrKykge1xuICAgICAgICAgIHZhciBwID0gcG9pbnRzW2tdO1xuICAgICAgICAgIG0gJiYgYXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7IC8vIOS4jSByb3VuZCDkvJrpnZ7luLjmhaJcblxuICAgICAgICAgIHN0ci5wdXNoKHJvdW5kKHBbMF0gKiBaIC0gWjIpLCBjb21tYSwgcm91bmQocFsxXSAqIFogLSBaMiksIGsgPCBuUG9pbnQgLSAxID8gY29tbWEgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLmpvaW4oJycpO1xuICB9OyAvLyBSZXdyaXRlIHRoZSBvcmlnaW5hbCBwYXRoIG1ldGhvZFxuXG5cbiAgUGF0aC5wcm90b3R5cGUuYnJ1c2hWTUwgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIHZtbEVsID0gdGhpcy5fdm1sRWw7XG5cbiAgICBpZiAoIXZtbEVsKSB7XG4gICAgICB2bWxFbCA9IHZtbENvcmUuY3JlYXRlTm9kZSgnc2hhcGUnKTtcbiAgICAgIGluaXRSb290RWxTdHlsZSh2bWxFbCk7XG4gICAgICB0aGlzLl92bWxFbCA9IHZtbEVsO1xuICAgIH1cblxuICAgIHVwZGF0ZUZpbGxBbmRTdHJva2Uodm1sRWwsICdmaWxsJywgc3R5bGUsIHRoaXMpO1xuICAgIHVwZGF0ZUZpbGxBbmRTdHJva2Uodm1sRWwsICdzdHJva2UnLCBzdHlsZSwgdGhpcyk7XG4gICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICB2YXIgbmVlZFRyYW5zZm9ybSA9IG0gIT0gbnVsbDtcbiAgICB2YXIgc3Ryb2tlRWwgPSB2bWxFbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3Ryb2tlJylbMF07XG5cbiAgICBpZiAoc3Ryb2tlRWwpIHtcbiAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7IC8vIEdldCB0aGUgbGluZSBzY2FsZS5cbiAgICAgIC8vIERldGVybWluYW50IG9mIHRoaXMubV8gbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXG4gICAgICAvLyB0cmFuc2Zvcm1hdGlvbi4gU28gaXRzIHNxdWFyZSByb290IGNhbiBiZSB1c2VkIGFzIGEgc2NhbGUgZmFjdG9yXG4gICAgICAvLyBmb3Igd2lkdGguXG5cbiAgICAgIGlmIChuZWVkVHJhbnNmb3JtICYmICFzdHlsZS5zdHJva2VOb1NjYWxlKSB7XG4gICAgICAgIHZhciBkZXQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgICAgICBsaW5lV2lkdGggKj0gc3FydChhYnMoZGV0KSk7XG4gICAgICB9XG5cbiAgICAgIHN0cm9rZUVsLndlaWdodCA9IGxpbmVXaWR0aCArICdweCc7XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSB0aGlzLnBhdGggfHwgKHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKSk7XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCkge1xuICAgICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMuYnVpbGRQYXRoKHBhdGgsIHRoaXMuc2hhcGUpO1xuICAgICAgcGF0aC50b1N0YXRpYygpO1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZtbEVsLnBhdGggPSBwYXRoRGF0YVRvU3RyaW5nKHBhdGgsIHRoaXMudHJhbnNmb3JtKTtcbiAgICB2bWxFbC5zdHlsZS56SW5kZXggPSBnZXRaSW5kZXgodGhpcy56bGV2ZWwsIHRoaXMueiwgdGhpcy56Mik7IC8vIEFwcGVuZCB0byByb290XG5cbiAgICBhcHBlbmQodm1sUm9vdCwgdm1sRWwpOyAvLyBUZXh0XG5cbiAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRyYXdSZWN0VGV4dCh2bWxSb290LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgICB9XG4gIH07XG5cbiAgUGF0aC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHJlbW92ZSh2bWxSb290LCB0aGlzLl92bWxFbCk7XG4gICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgfTtcblxuICBQYXRoLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgYXBwZW5kKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcbiAgICB0aGlzLmFwcGVuZFJlY3RUZXh0KHZtbFJvb3QpO1xuICB9O1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIElNQUdFXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gIHZhciBpc0ltYWdlID0gZnVuY3Rpb24gKGltZykge1xuICAgIC8vIEZJWE1FIGltZyBpbnN0YW5jZW9mIEltYWdlIOWmguaenCBpbWcg5piv5LiA5Liq5a2X56ym5Liy55qE5pe25YCZ77yMSUU4IOS4i+S8muaKpemUmVxuICAgIHJldHVybiB0eXBlb2YgaW1nID09PSAnb2JqZWN0JyAmJiBpbWcudGFnTmFtZSAmJiBpbWcudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnSU1HJzsgLy8gcmV0dXJuIGltZyBpbnN0YW5jZW9mIEltYWdlO1xuICB9OyAvLyBSZXdyaXRlIHRoZSBvcmlnaW5hbCBwYXRoIG1ldGhvZFxuXG5cbiAgWkltYWdlLnByb3RvdHlwZS5icnVzaFZNTCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgaW1hZ2UgPSBzdHlsZS5pbWFnZTsgLy8gSW1hZ2Ugb3JpZ2luYWwgd2lkdGgsIGhlaWdodFxuXG4gICAgdmFyIG93O1xuICAgIHZhciBvaDtcblxuICAgIGlmIChpc0ltYWdlKGltYWdlKSkge1xuICAgICAgdmFyIHNyYyA9IGltYWdlLnNyYztcblxuICAgICAgaWYgKHNyYyA9PT0gdGhpcy5faW1hZ2VTcmMpIHtcbiAgICAgICAgb3cgPSB0aGlzLl9pbWFnZVdpZHRoO1xuICAgICAgICBvaCA9IHRoaXMuX2ltYWdlSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGltYWdlUnVudGltZVN0eWxlID0gaW1hZ2UucnVudGltZVN0eWxlO1xuICAgICAgICB2YXIgb2xkUnVudGltZVdpZHRoID0gaW1hZ2VSdW50aW1lU3R5bGUud2lkdGg7XG4gICAgICAgIHZhciBvbGRSdW50aW1lSGVpZ2h0ID0gaW1hZ2VSdW50aW1lU3R5bGUuaGVpZ2h0O1xuICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS53aWR0aCA9ICdhdXRvJztcbiAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUuaGVpZ2h0ID0gJ2F1dG8nOyAvLyBnZXQgdGhlIG9yaWdpbmFsIHNpemVcblxuICAgICAgICBvdyA9IGltYWdlLndpZHRoO1xuICAgICAgICBvaCA9IGltYWdlLmhlaWdodDsgLy8gYW5kIHJlbW92ZSBvdmVyaWRlc1xuXG4gICAgICAgIGltYWdlUnVudGltZVN0eWxlLndpZHRoID0gb2xkUnVudGltZVdpZHRoO1xuICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS5oZWlnaHQgPSBvbGRSdW50aW1lSGVpZ2h0OyAvLyBDYWNoaW5nIGltYWdlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHQgYW5kIHNyY1xuXG4gICAgICAgIHRoaXMuX2ltYWdlU3JjID0gc3JjO1xuICAgICAgICB0aGlzLl9pbWFnZVdpZHRoID0gb3c7XG4gICAgICAgIHRoaXMuX2ltYWdlSGVpZ2h0ID0gb2g7XG4gICAgICB9XG5cbiAgICAgIGltYWdlID0gc3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW1hZ2UgPT09IHRoaXMuX2ltYWdlU3JjKSB7XG4gICAgICAgIG93ID0gdGhpcy5faW1hZ2VXaWR0aDtcbiAgICAgICAgb2ggPSB0aGlzLl9pbWFnZUhlaWdodDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWltYWdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgdmFyIGR3ID0gc3R5bGUud2lkdGg7XG4gICAgdmFyIGRoID0gc3R5bGUuaGVpZ2h0O1xuICAgIHZhciBzdyA9IHN0eWxlLnNXaWR0aDtcbiAgICB2YXIgc2ggPSBzdHlsZS5zSGVpZ2h0O1xuICAgIHZhciBzeCA9IHN0eWxlLnN4IHx8IDA7XG4gICAgdmFyIHN5ID0gc3R5bGUuc3kgfHwgMDtcbiAgICB2YXIgaGFzQ3JvcCA9IHN3ICYmIHNoO1xuICAgIHZhciB2bWxFbCA9IHRoaXMuX3ZtbEVsO1xuXG4gICAgaWYgKCF2bWxFbCkge1xuICAgICAgLy8gRklYTUUg5L2/55SoIGdyb3VwIOWcqCBsZWZ0LCB0b3Ag6YO95LiN5pivIDAg55qE5pe25YCZ5bCx5peg5rOV5pi+56S65LqG44CCXG4gICAgICAvLyB2bWxFbCA9IHZtbENvcmUuY3JlYXRlTm9kZSgnZ3JvdXAnKTtcbiAgICAgIHZtbEVsID0gdm1sQ29yZS5kb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBpbml0Um9vdEVsU3R5bGUodm1sRWwpO1xuICAgICAgdGhpcy5fdm1sRWwgPSB2bWxFbDtcbiAgICB9XG5cbiAgICB2YXIgdm1sRWxTdHlsZSA9IHZtbEVsLnN0eWxlO1xuICAgIHZhciBoYXNSb3RhdGlvbiA9IGZhbHNlO1xuICAgIHZhciBtO1xuICAgIHZhciBzY2FsZVggPSAxO1xuICAgIHZhciBzY2FsZVkgPSAxO1xuXG4gICAgaWYgKHRoaXMudHJhbnNmb3JtKSB7XG4gICAgICBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICBzY2FsZVggPSBzcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgc2NhbGVZID0gc3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcbiAgICAgIGhhc1JvdGF0aW9uID0gbVsxXSB8fCBtWzJdO1xuICAgIH1cblxuICAgIGlmIChoYXNSb3RhdGlvbikge1xuICAgICAgLy8gSWYgZmlsdGVycyBhcmUgbmVjZXNzYXJ5IChyb3RhdGlvbiBleGlzdHMpLCBjcmVhdGUgdGhlbVxuICAgICAgLy8gZmlsdGVycyBhcmUgYm9nLXNsb3csIHNvIG9ubHkgY3JlYXRlIHRoZW0gaWYgYWJic29sdXRlbHkgbmVjZXNzYXJ5XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIGNoZWNrIGRvZXNuJ3QgYWNjb3VudCBmb3Igc2tld3MgKHdoaWNoIGRvbid0IGV4aXN0XG4gICAgICAvLyBpbiB0aGUgY2FudmFzIHNwZWMgKHlldCkgYW55d2F5LlxuICAgICAgLy8gRnJvbSBleGNhbnZhc1xuICAgICAgdmFyIHAwID0gW3gsIHldO1xuICAgICAgdmFyIHAxID0gW3ggKyBkdywgeV07XG4gICAgICB2YXIgcDIgPSBbeCwgeSArIGRoXTtcbiAgICAgIHZhciBwMyA9IFt4ICsgZHcsIHkgKyBkaF07XG4gICAgICBhcHBseVRyYW5zZm9ybShwMCwgcDAsIG0pO1xuICAgICAgYXBwbHlUcmFuc2Zvcm0ocDEsIHAxLCBtKTtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKHAyLCBwMiwgbSk7XG4gICAgICBhcHBseVRyYW5zZm9ybShwMywgcDMsIG0pO1xuICAgICAgdmFyIG1heFggPSBtYXRoTWF4KHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdKTtcbiAgICAgIHZhciBtYXhZID0gbWF0aE1heChwMFsxXSwgcDFbMV0sIHAyWzFdLCBwM1sxXSk7XG4gICAgICB2YXIgdHJhbnNmb3JtRmlsdGVyID0gW107XG4gICAgICB0cmFuc2Zvcm1GaWx0ZXIucHVzaCgnTTExPScsIG1bMF0gLyBzY2FsZVgsIGNvbW1hLCAnTTEyPScsIG1bMl0gLyBzY2FsZVksIGNvbW1hLCAnTTIxPScsIG1bMV0gLyBzY2FsZVgsIGNvbW1hLCAnTTIyPScsIG1bM10gLyBzY2FsZVksIGNvbW1hLCAnRHg9Jywgcm91bmQoeCAqIHNjYWxlWCArIG1bNF0pLCBjb21tYSwgJ0R5PScsIHJvdW5kKHkgKiBzY2FsZVkgKyBtWzVdKSk7XG4gICAgICB2bWxFbFN0eWxlLnBhZGRpbmcgPSAnMCAnICsgcm91bmQobWF4WCkgKyAncHggJyArIHJvdW5kKG1heFkpICsgJ3B4IDAnOyAvLyBGSVhNRSBEWEltYWdlVHJhbnNmb3JtIOWcqCBJRTExIOeahOWFvOWuueaooeW8j+S4i+S4jei1t+S9nOeUqFxuXG4gICAgICB2bWxFbFN0eWxlLmZpbHRlciA9IGltYWdlVHJhbnNmb3JtUHJlZml4ICsgJy5NYXRyaXgoJyArIHRyYW5zZm9ybUZpbHRlci5qb2luKCcnKSArICcsIFNpemluZ01ldGhvZD1jbGlwKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtKSB7XG4gICAgICAgIHggPSB4ICogc2NhbGVYICsgbVs0XTtcbiAgICAgICAgeSA9IHkgKiBzY2FsZVkgKyBtWzVdO1xuICAgICAgfVxuXG4gICAgICB2bWxFbFN0eWxlLmZpbHRlciA9ICcnO1xuICAgICAgdm1sRWxTdHlsZS5sZWZ0ID0gcm91bmQoeCkgKyAncHgnO1xuICAgICAgdm1sRWxTdHlsZS50b3AgPSByb3VuZCh5KSArICdweCc7XG4gICAgfVxuXG4gICAgdmFyIGltYWdlRWwgPSB0aGlzLl9pbWFnZUVsO1xuICAgIHZhciBjcm9wRWwgPSB0aGlzLl9jcm9wRWw7XG5cbiAgICBpZiAoIWltYWdlRWwpIHtcbiAgICAgIGltYWdlRWwgPSB2bWxDb3JlLmRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuX2ltYWdlRWwgPSBpbWFnZUVsO1xuICAgIH1cblxuICAgIHZhciBpbWFnZUVMU3R5bGUgPSBpbWFnZUVsLnN0eWxlO1xuXG4gICAgaWYgKGhhc0Nyb3ApIHtcbiAgICAgIC8vIE5lZWRzIGtub3cgaW1hZ2Ugb3JpZ2luYWwgd2lkdGggYW5kIGhlaWdodFxuICAgICAgaWYgKCEob3cgJiYgb2gpKSB7XG4gICAgICAgIHZhciB0bXBJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdG1wSW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRtcEltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgb3cgPSB0bXBJbWFnZS53aWR0aDtcbiAgICAgICAgICBvaCA9IHRtcEltYWdlLmhlaWdodDsgLy8gQWRqdXN0IGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgdG8gZml0IHRoZSByYXRpbyBkZXN0aW5hdGlvblNpemUgLyBzb3VyY2VTaXplXG5cbiAgICAgICAgICBpbWFnZUVMU3R5bGUud2lkdGggPSByb3VuZChzY2FsZVggKiBvdyAqIGR3IC8gc3cpICsgJ3B4JztcbiAgICAgICAgICBpbWFnZUVMU3R5bGUuaGVpZ2h0ID0gcm91bmQoc2NhbGVZICogb2ggKiBkaCAvIHNoKSArICdweCc7IC8vIENhY2hpbmcgaW1hZ2Ugb3JpZ2luYWwgd2lkdGgsIGhlaWdodCBhbmQgc3JjXG5cbiAgICAgICAgICBzZWxmLl9pbWFnZVdpZHRoID0gb3c7XG4gICAgICAgICAgc2VsZi5faW1hZ2VIZWlnaHQgPSBvaDtcbiAgICAgICAgICBzZWxmLl9pbWFnZVNyYyA9IGltYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRtcEltYWdlLnNyYyA9IGltYWdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1hZ2VFTFN0eWxlLndpZHRoID0gcm91bmQoc2NhbGVYICogb3cgKiBkdyAvIHN3KSArICdweCc7XG4gICAgICAgIGltYWdlRUxTdHlsZS5oZWlnaHQgPSByb3VuZChzY2FsZVkgKiBvaCAqIGRoIC8gc2gpICsgJ3B4JztcbiAgICAgIH1cblxuICAgICAgaWYgKCFjcm9wRWwpIHtcbiAgICAgICAgY3JvcEVsID0gdm1sQ29yZS5kb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNyb3BFbC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB0aGlzLl9jcm9wRWwgPSBjcm9wRWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjcm9wRWxTdHlsZSA9IGNyb3BFbC5zdHlsZTtcbiAgICAgIGNyb3BFbFN0eWxlLndpZHRoID0gcm91bmQoKGR3ICsgc3ggKiBkdyAvIHN3KSAqIHNjYWxlWCk7XG4gICAgICBjcm9wRWxTdHlsZS5oZWlnaHQgPSByb3VuZCgoZGggKyBzeSAqIGRoIC8gc2gpICogc2NhbGVZKTtcbiAgICAgIGNyb3BFbFN0eWxlLmZpbHRlciA9IGltYWdlVHJhbnNmb3JtUHJlZml4ICsgJy5NYXRyaXgoRHg9JyArIC1zeCAqIGR3IC8gc3cgKiBzY2FsZVggKyAnLER5PScgKyAtc3kgKiBkaCAvIHNoICogc2NhbGVZICsgJyknO1xuXG4gICAgICBpZiAoIWNyb3BFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHZtbEVsLmFwcGVuZENoaWxkKGNyb3BFbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbWFnZUVsLnBhcmVudE5vZGUgIT0gY3JvcEVsKSB7XG4gICAgICAgIGNyb3BFbC5hcHBlbmRDaGlsZChpbWFnZUVsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW1hZ2VFTFN0eWxlLndpZHRoID0gcm91bmQoc2NhbGVYICogZHcpICsgJ3B4JztcbiAgICAgIGltYWdlRUxTdHlsZS5oZWlnaHQgPSByb3VuZChzY2FsZVkgKiBkaCkgKyAncHgnO1xuICAgICAgdm1sRWwuYXBwZW5kQ2hpbGQoaW1hZ2VFbCk7XG5cbiAgICAgIGlmIChjcm9wRWwgJiYgY3JvcEVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdm1sRWwucmVtb3ZlQ2hpbGQoY3JvcEVsKTtcbiAgICAgICAgdGhpcy5fY3JvcEVsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyU3RyID0gJyc7XG4gICAgdmFyIGFscGhhID0gc3R5bGUub3BhY2l0eTtcblxuICAgIGlmIChhbHBoYSA8IDEpIHtcbiAgICAgIGZpbHRlclN0ciArPSAnLkFscGhhKG9wYWNpdHk9JyArIHJvdW5kKGFscGhhICogMTAwKSArICcpICc7XG4gICAgfVxuXG4gICAgZmlsdGVyU3RyICs9IGltYWdlVHJhbnNmb3JtUHJlZml4ICsgJy5BbHBoYUltYWdlTG9hZGVyKHNyYz0nICsgaW1hZ2UgKyAnLCBTaXppbmdNZXRob2Q9c2NhbGUpJztcbiAgICBpbWFnZUVMU3R5bGUuZmlsdGVyID0gZmlsdGVyU3RyO1xuICAgIHZtbEVsLnN0eWxlLnpJbmRleCA9IGdldFpJbmRleCh0aGlzLnpsZXZlbCwgdGhpcy56LCB0aGlzLnoyKTsgLy8gQXBwZW5kIHRvIHJvb3RcblxuICAgIGFwcGVuZCh2bWxSb290LCB2bWxFbCk7IC8vIFRleHRcblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgIH1cbiAgfTtcblxuICBaSW1hZ2UucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICByZW1vdmUodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgIHRoaXMuX3ZtbEVsID0gbnVsbDtcbiAgICB0aGlzLl9jcm9wRWwgPSBudWxsO1xuICAgIHRoaXMuX2ltYWdlRWwgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG5cbiAgWkltYWdlLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgYXBwZW5kKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcbiAgICB0aGlzLmFwcGVuZFJlY3RUZXh0KHZtbFJvb3QpO1xuICB9O1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIFRFWFRcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgdmFyIERFRkFVTFRfU1RZTEVfTk9STUFMID0gJ25vcm1hbCc7XG4gIHZhciBmb250U3R5bGVDYWNoZSA9IHt9O1xuICB2YXIgZm9udFN0eWxlQ2FjaGVDb3VudCA9IDA7XG4gIHZhciBNQVhfRk9OVF9DQUNIRV9TSVpFID0gMTAwO1xuICB2YXIgZm9udEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgdmFyIGdldEZvbnRTdHlsZSA9IGZ1bmN0aW9uIChmb250U3RyaW5nKSB7XG4gICAgdmFyIGZvbnRTdHlsZSA9IGZvbnRTdHlsZUNhY2hlW2ZvbnRTdHJpbmddO1xuXG4gICAgaWYgKCFmb250U3R5bGUpIHtcbiAgICAgIC8vIENsZWFyIGNhY2hlXG4gICAgICBpZiAoZm9udFN0eWxlQ2FjaGVDb3VudCA+IE1BWF9GT05UX0NBQ0hFX1NJWkUpIHtcbiAgICAgICAgZm9udFN0eWxlQ2FjaGVDb3VudCA9IDA7XG4gICAgICAgIGZvbnRTdHlsZUNhY2hlID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHlsZSA9IGZvbnRFbC5zdHlsZTtcbiAgICAgIHZhciBmb250RmFtaWx5O1xuXG4gICAgICB0cnkge1xuICAgICAgICBzdHlsZS5mb250ID0gZm9udFN0cmluZztcbiAgICAgICAgZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHkuc3BsaXQoJywnKVswXTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIGZvbnRTdHlsZSA9IHtcbiAgICAgICAgc3R5bGU6IHN0eWxlLmZvbnRTdHlsZSB8fCBERUZBVUxUX1NUWUxFX05PUk1BTCxcbiAgICAgICAgdmFyaWFudDogc3R5bGUuZm9udFZhcmlhbnQgfHwgREVGQVVMVF9TVFlMRV9OT1JNQUwsXG4gICAgICAgIHdlaWdodDogc3R5bGUuZm9udFdlaWdodCB8fCBERUZBVUxUX1NUWUxFX05PUk1BTCxcbiAgICAgICAgc2l6ZTogcGFyc2VGbG9hdChzdHlsZS5mb250U2l6ZSB8fCAxMikgfCAwLFxuICAgICAgICBmYW1pbHk6IGZvbnRGYW1pbHkgfHwgJ01pY3Jvc29mdCBZYUhlaSdcbiAgICAgIH07XG4gICAgICBmb250U3R5bGVDYWNoZVtmb250U3RyaW5nXSA9IGZvbnRTdHlsZTtcbiAgICAgIGZvbnRTdHlsZUNhY2hlQ291bnQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZm9udFN0eWxlO1xuICB9O1xuXG4gIHZhciB0ZXh0TWVhc3VyZUVsOyAvLyBPdmVyd3JpdGUgbWVhc3VyZSB0ZXh0IG1ldGhvZFxuXG4gIHRleHRDb250YWluLiRvdmVycmlkZSgnbWVhc3VyZVRleHQnLCBmdW5jdGlvbiAodGV4dCwgdGV4dEZvbnQpIHtcbiAgICB2YXIgZG9jID0gdm1sQ29yZS5kb2M7XG5cbiAgICBpZiAoIXRleHRNZWFzdXJlRWwpIHtcbiAgICAgIHRleHRNZWFzdXJlRWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0ZXh0TWVhc3VyZUVsLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7dG9wOi0yMDAwMHB4O2xlZnQ6MDsnICsgJ3BhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6bm9uZTt3aGl0ZS1zcGFjZTpwcmU7JztcbiAgICAgIHZtbENvcmUuZG9jLmJvZHkuYXBwZW5kQ2hpbGQodGV4dE1lYXN1cmVFbCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRleHRNZWFzdXJlRWwuc3R5bGUuZm9udCA9IHRleHRGb250O1xuICAgIH0gY2F0Y2ggKGV4KSB7Ly8gSWdub3JlIGZhaWx1cmVzIHRvIHNldCB0byBpbnZhbGlkIGZvbnQuXG4gICAgfVxuXG4gICAgdGV4dE1lYXN1cmVFbC5pbm5lckhUTUwgPSAnJzsgLy8gRG9uJ3QgdXNlIGlubmVySFRNTCBvciBpbm5lclRleHQgYmVjYXVzZSB0aGV5IGFsbG93IG1hcmt1cC93aGl0ZXNwYWNlLlxuXG4gICAgdGV4dE1lYXN1cmVFbC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGV4dE1lYXN1cmVFbC5vZmZzZXRXaWR0aFxuICAgIH07XG4gIH0pO1xuICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoKTtcblxuICB2YXIgZHJhd1JlY3RUZXh0ID0gZnVuY3Rpb24gKHZtbFJvb3QsIHJlY3QsIHRleHRSZWN0LCBmcm9tVGV4dEVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTsgLy8gT3B0aW1pemUsIGF2b2lkIG5vcm1hbGl6ZSBldmVyeSB0aW1lLlxuXG4gICAgdGhpcy5fX2RpcnR5ICYmIHRleHRIZWxwZXIubm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlLCB0cnVlKTtcbiAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7IC8vIENvbnZlcnQgdG8gc3RyaW5nXG5cbiAgICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuXG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDb252ZXJ0IHJpY2ggdGV4dCB0byBwbGFpbiB0ZXh0LiBSaWNoIHRleHQgaXMgbm90IHN1cHBvcnRlZCBpblxuICAgIC8vIElFOC0sIGJ1dCB0YWdzIGluIHJpY2ggdGV4dCB0ZW1wbGF0ZSB3aWxsIGJlIHJlbW92ZWQuXG5cblxuICAgIGlmIChzdHlsZS5yaWNoKSB7XG4gICAgICB2YXIgY29udGVudEJsb2NrID0gdGV4dENvbnRhaW4ucGFyc2VSaWNoVGV4dCh0ZXh0LCBzdHlsZSk7XG4gICAgICB0ZXh0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEJsb2NrLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSBjb250ZW50QmxvY2subGluZXNbaV0udG9rZW5zO1xuICAgICAgICB2YXIgdGV4dExpbmUgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRleHRMaW5lLnB1c2godG9rZW5zW2pdLnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dC5wdXNoKHRleHRMaW5lLmpvaW4oJycpKTtcbiAgICAgIH1cblxuICAgICAgdGV4dCA9IHRleHQuam9pbignXFxuJyk7XG4gICAgfVxuXG4gICAgdmFyIHg7XG4gICAgdmFyIHk7XG4gICAgdmFyIGFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgIHZhciB2ZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ247XG4gICAgdmFyIGZvbnRTdHlsZSA9IGdldEZvbnRTdHlsZShzdHlsZS5mb250KTsgLy8gRklYTUUgZW5jb2RlSHRtbEF0dHJpYnV0ZSA/XG5cbiAgICB2YXIgZm9udCA9IGZvbnRTdHlsZS5zdHlsZSArICcgJyArIGZvbnRTdHlsZS52YXJpYW50ICsgJyAnICsgZm9udFN0eWxlLndlaWdodCArICcgJyArIGZvbnRTdHlsZS5zaXplICsgJ3B4IFwiJyArIGZvbnRTdHlsZS5mYW1pbHkgKyAnXCInO1xuICAgIHRleHRSZWN0ID0gdGV4dFJlY3QgfHwgdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRleHQsIGZvbnQsIGFsaWduLCB2ZXJ0aWNhbEFsaWduKTsgLy8gVHJhbnNmb3JtIHJlY3QgdG8gdmlldyBzcGFjZVxuXG4gICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTsgLy8gSWdub3JlIHRyYW5zZm9ybSBmb3IgdGV4dCBpbiBvdGhlciBlbGVtZW50XG5cbiAgICBpZiAobSAmJiAhZnJvbVRleHRFbCkge1xuICAgICAgdG1wUmVjdC5jb3B5KHJlY3QpO1xuICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybShtKTtcbiAgICAgIHJlY3QgPSB0bXBSZWN0O1xuICAgIH1cblxuICAgIGlmICghZnJvbVRleHRFbCkge1xuICAgICAgdmFyIHRleHRQb3NpdGlvbiA9IHN0eWxlLnRleHRQb3NpdGlvbjtcbiAgICAgIHZhciBkaXN0YW5jZSA9IHN0eWxlLnRleHREaXN0YW5jZTsgLy8gVGV4dCBwb3NpdGlvbiByZXByZXNlbnRlZCBieSBjb29yZFxuXG4gICAgICBpZiAodGV4dFBvc2l0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgeCA9IHJlY3QueCArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMF0sIHJlY3Qud2lkdGgpO1xuICAgICAgICB5ID0gcmVjdC55ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblsxXSwgcmVjdC5oZWlnaHQpO1xuICAgICAgICBhbGlnbiA9IGFsaWduIHx8ICdsZWZ0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXMgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0UG9zaXRpb25PblJlY3QodGV4dFBvc2l0aW9uLCByZWN0LCBkaXN0YW5jZSk7XG4gICAgICAgIHggPSByZXMueDtcbiAgICAgICAgeSA9IHJlcy55OyAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cblxuICAgICAgICBhbGlnbiA9IGFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICAgIHZlcnRpY2FsQWxpZ24gPSB2ZXJ0aWNhbEFsaWduIHx8IHJlcy50ZXh0VmVydGljYWxBbGlnbjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHJlY3QueDtcbiAgICAgIHkgPSByZWN0Lnk7XG4gICAgfVxuXG4gICAgeCA9IHRleHRDb250YWluLmFkanVzdFRleHRYKHgsIHRleHRSZWN0LndpZHRoLCBhbGlnbik7XG4gICAgeSA9IHRleHRDb250YWluLmFkanVzdFRleHRZKHksIHRleHRSZWN0LmhlaWdodCwgdmVydGljYWxBbGlnbik7IC8vIEZvcmNlIGJhc2VsaW5lICdtaWRkbGUnXG5cbiAgICB5ICs9IHRleHRSZWN0LmhlaWdodCAvIDI7IC8vIHZhciBmb250U2l6ZSA9IGZvbnRTdHlsZS5zaXplO1xuICAgIC8vIDEuNzUgaXMgYW4gYXJiaXRyYXJ5IG51bWJlciwgYXMgdGhlcmUgaXMgbm8gaW5mbyBhYm91dCB0aGUgdGV4dCBiYXNlbGluZVxuICAgIC8vIHN3aXRjaCAoYmFzZWxpbmUpIHtcbiAgICAvLyBjYXNlICdoYW5naW5nJzpcbiAgICAvLyBjYXNlICd0b3AnOlxuICAgIC8vICAgICB5ICs9IGZvbnRTaXplIC8gMS43NTtcbiAgICAvLyAgICAgYnJlYWs7XG4gICAgLy8gICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgLy8gICAgICAgICBicmVhaztcbiAgICAvLyAgICAgZGVmYXVsdDpcbiAgICAvLyAgICAgLy8gY2FzZSBudWxsOlxuICAgIC8vICAgICAvLyBjYXNlICdhbHBoYWJldGljJzpcbiAgICAvLyAgICAgLy8gY2FzZSAnaWRlb2dyYXBoaWMnOlxuICAgIC8vICAgICAvLyBjYXNlICdib3R0b20nOlxuICAgIC8vICAgICAgICAgeSAtPSBmb250U2l6ZSAvIDIuMjU7XG4gICAgLy8gICAgICAgICBicmVhaztcbiAgICAvLyB9XG4gICAgLy8gc3dpdGNoIChhbGlnbikge1xuICAgIC8vICAgICBjYXNlICdsZWZ0JzpcbiAgICAvLyAgICAgICAgIGJyZWFrO1xuICAgIC8vICAgICBjYXNlICdjZW50ZXInOlxuICAgIC8vICAgICAgICAgeCAtPSB0ZXh0UmVjdC53aWR0aCAvIDI7XG4gICAgLy8gICAgICAgICBicmVhaztcbiAgICAvLyAgICAgY2FzZSAncmlnaHQnOlxuICAgIC8vICAgICAgICAgeCAtPSB0ZXh0UmVjdC53aWR0aDtcbiAgICAvLyAgICAgICAgIGJyZWFrO1xuICAgIC8vIGNhc2UgJ2VuZCc6XG4gICAgLy8gYWxpZ24gPSBlbGVtZW50U3R5bGUuZGlyZWN0aW9uID09ICdsdHInID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAvLyBicmVhaztcbiAgICAvLyBjYXNlICdzdGFydCc6XG4gICAgLy8gYWxpZ24gPSBlbGVtZW50U3R5bGUuZGlyZWN0aW9uID09ICdydGwnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAvLyBicmVhaztcbiAgICAvLyBkZWZhdWx0OlxuICAgIC8vICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICAvLyB9XG5cbiAgICB2YXIgY3JlYXRlTm9kZSA9IHZtbENvcmUuY3JlYXRlTm9kZTtcbiAgICB2YXIgdGV4dFZtbEVsID0gdGhpcy5fdGV4dFZtbEVsO1xuICAgIHZhciBwYXRoRWw7XG4gICAgdmFyIHRleHRQYXRoRWw7XG4gICAgdmFyIHNrZXdFbDtcblxuICAgIGlmICghdGV4dFZtbEVsKSB7XG4gICAgICB0ZXh0Vm1sRWwgPSBjcmVhdGVOb2RlKCdsaW5lJyk7XG4gICAgICBwYXRoRWwgPSBjcmVhdGVOb2RlKCdwYXRoJyk7XG4gICAgICB0ZXh0UGF0aEVsID0gY3JlYXRlTm9kZSgndGV4dHBhdGgnKTtcbiAgICAgIHNrZXdFbCA9IGNyZWF0ZU5vZGUoJ3NrZXcnKTsgLy8gRklYTUUgV2h5IGhlcmUgaXMgbm90IGNhbW1lbCBjYXNlXG4gICAgICAvLyBBbGlnbiAnY2VudGVyJyBzZWVtcyB3cm9uZ1xuXG4gICAgICB0ZXh0UGF0aEVsLnN0eWxlWyd2LXRleHQtYWxpZ24nXSA9ICdsZWZ0JztcbiAgICAgIGluaXRSb290RWxTdHlsZSh0ZXh0Vm1sRWwpO1xuICAgICAgcGF0aEVsLnRleHRwYXRob2sgPSB0cnVlO1xuICAgICAgdGV4dFBhdGhFbC5vbiA9IHRydWU7XG4gICAgICB0ZXh0Vm1sRWwuZnJvbSA9ICcwIDAnO1xuICAgICAgdGV4dFZtbEVsLnRvID0gJzEwMDAgMC4wNSc7XG4gICAgICBhcHBlbmQodGV4dFZtbEVsLCBza2V3RWwpO1xuICAgICAgYXBwZW5kKHRleHRWbWxFbCwgcGF0aEVsKTtcbiAgICAgIGFwcGVuZCh0ZXh0Vm1sRWwsIHRleHRQYXRoRWwpO1xuICAgICAgdGhpcy5fdGV4dFZtbEVsID0gdGV4dFZtbEVsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyDov5nph4zmmK/lnKjliY3pnaIgYXBwZW5kQ2hpbGQg5L+d6K+B6aG65bqP55qE5YmN5o+Q5LiLXG4gICAgICBza2V3RWwgPSB0ZXh0Vm1sRWwuZmlyc3RDaGlsZDtcbiAgICAgIHBhdGhFbCA9IHNrZXdFbC5uZXh0U2libGluZztcbiAgICAgIHRleHRQYXRoRWwgPSBwYXRoRWwubmV4dFNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNvb3JkcyA9IFt4LCB5XTtcbiAgICB2YXIgdGV4dFZtbEVsU3R5bGUgPSB0ZXh0Vm1sRWwuc3R5bGU7IC8vIElnbm9yZSB0cmFuc2Zvcm0gZm9yIHRleHQgaW4gb3RoZXIgZWxlbWVudFxuXG4gICAgaWYgKG0gJiYgZnJvbVRleHRFbCkge1xuICAgICAgYXBwbHlUcmFuc2Zvcm0oY29vcmRzLCBjb29yZHMsIG0pO1xuICAgICAgc2tld0VsLm9uID0gdHJ1ZTtcbiAgICAgIHNrZXdFbC5tYXRyaXggPSBtWzBdLnRvRml4ZWQoMykgKyBjb21tYSArIG1bMl0udG9GaXhlZCgzKSArIGNvbW1hICsgbVsxXS50b0ZpeGVkKDMpICsgY29tbWEgKyBtWzNdLnRvRml4ZWQoMykgKyAnLDAsMCc7IC8vIFRleHQgcG9zaXRpb25cblxuICAgICAgc2tld0VsLm9mZnNldCA9IChyb3VuZChjb29yZHNbMF0pIHx8IDApICsgJywnICsgKHJvdW5kKGNvb3Jkc1sxXSkgfHwgMCk7IC8vIExlZnQgdG9wIHBvaW50IGFzIG9yaWdpblxuXG4gICAgICBza2V3RWwub3JpZ2luID0gJzAgMCc7XG4gICAgICB0ZXh0Vm1sRWxTdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgICB0ZXh0Vm1sRWxTdHlsZS50b3AgPSAnMHB4JztcbiAgICB9IGVsc2Uge1xuICAgICAgc2tld0VsLm9uID0gZmFsc2U7XG4gICAgICB0ZXh0Vm1sRWxTdHlsZS5sZWZ0ID0gcm91bmQoeCkgKyAncHgnO1xuICAgICAgdGV4dFZtbEVsU3R5bGUudG9wID0gcm91bmQoeSkgKyAncHgnO1xuICAgIH1cblxuICAgIHRleHRQYXRoRWwuc3RyaW5nID0gZW5jb2RlSHRtbEF0dHJpYnV0ZSh0ZXh0KTsgLy8gVE9ET1xuXG4gICAgdHJ5IHtcbiAgICAgIHRleHRQYXRoRWwuc3R5bGUuZm9udCA9IGZvbnQ7XG4gICAgfSAvLyBFcnJvciBmb250IGZvcm1hdFxuICAgIGNhdGNoIChlKSB7fVxuXG4gICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh0ZXh0Vm1sRWwsICdmaWxsJywge1xuICAgICAgZmlsbDogc3R5bGUudGV4dEZpbGwsXG4gICAgICBvcGFjaXR5OiBzdHlsZS5vcGFjaXR5XG4gICAgfSwgdGhpcyk7XG4gICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh0ZXh0Vm1sRWwsICdzdHJva2UnLCB7XG4gICAgICBzdHJva2U6IHN0eWxlLnRleHRTdHJva2UsXG4gICAgICBvcGFjaXR5OiBzdHlsZS5vcGFjaXR5LFxuICAgICAgbGluZURhc2g6IHN0eWxlLmxpbmVEYXNoXG4gICAgfSwgdGhpcyk7XG4gICAgdGV4dFZtbEVsLnN0eWxlLnpJbmRleCA9IGdldFpJbmRleCh0aGlzLnpsZXZlbCwgdGhpcy56LCB0aGlzLnoyKTsgLy8gQXR0YWNoZWQgdG8gcm9vdFxuXG4gICAgYXBwZW5kKHZtbFJvb3QsIHRleHRWbWxFbCk7XG4gIH07XG5cbiAgdmFyIHJlbW92ZVJlY3RUZXh0ID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICByZW1vdmUodm1sUm9vdCwgdGhpcy5fdGV4dFZtbEVsKTtcbiAgICB0aGlzLl90ZXh0Vm1sRWwgPSBudWxsO1xuICB9O1xuXG4gIHZhciBhcHBlbmRSZWN0VGV4dCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgYXBwZW5kKHZtbFJvb3QsIHRoaXMuX3RleHRWbWxFbCk7XG4gIH07XG5cbiAgdmFyIGxpc3QgPSBbUmVjdFRleHQsIERpc3BsYXlhYmxlLCBaSW1hZ2UsIFBhdGgsIFRleHRdOyAvLyBJbiBjYXNlIERpc3BsYXlhYmxlIGhhcyBiZWVuIG1peGVkIGluIFJlY3RUZXh0XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3RvID0gbGlzdFtpXS5wcm90b3R5cGU7XG4gICAgcHJvdG8uZHJhd1JlY3RUZXh0ID0gZHJhd1JlY3RUZXh0O1xuICAgIHByb3RvLnJlbW92ZVJlY3RUZXh0ID0gcmVtb3ZlUmVjdFRleHQ7XG4gICAgcHJvdG8uYXBwZW5kUmVjdFRleHQgPSBhcHBlbmRSZWN0VGV4dDtcbiAgfVxuXG4gIFRleHQucHJvdG90eXBlLmJydXNoVk1MID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQodm1sUm9vdCwge1xuICAgICAgICB4OiBzdHlsZS54IHx8IDAsXG4gICAgICAgIHk6IHN0eWxlLnkgfHwgMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfSwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfVxuICB9O1xuXG4gIFRleHQucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICB9O1xuXG4gIFRleHQucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICB0aGlzLmFwcGVuZFJlY3RUZXh0KHZtbFJvb3QpO1xuICB9O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi92bWwvZ3JhcGhpYy5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBlbnYgPSByZXF1aXJlKFwiLi4vY29yZS9lbnZcIik7XG5cbnZhciB1cm4gPSAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnO1xudmFyIHdpbiA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdztcbnZhciB2bWxJbml0ZWQgPSBmYWxzZTtcbnZhciBkb2MgPSB3aW4gJiYgd2luLmRvY3VtZW50O1xuXG5mdW5jdGlvbiBjcmVhdGVOb2RlKHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvQ3JlYXRlTm9kZSh0YWdOYW1lKTtcbn0gLy8gQXZvaWQgYXNzaWduIHRvIGFuIGV4cG9ydGVkIHZhcmlhYmxlLCBmb3IgdHJhbnNmb3JtaW5nIHRvIGNqcy5cblxuXG52YXIgZG9DcmVhdGVOb2RlO1xuXG5pZiAoZG9jICYmICFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gIHRyeSB7XG4gICAgIWRvYy5uYW1lc3BhY2VzLnpydm1sICYmIGRvYy5uYW1lc3BhY2VzLmFkZCgnenJ2bWwnLCB1cm4pO1xuXG4gICAgZG9DcmVhdGVOb2RlID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICAgIHJldHVybiBkb2MuY3JlYXRlRWxlbWVudCgnPHpydm1sOicgKyB0YWdOYW1lICsgJyBjbGFzcz1cInpydm1sXCI+Jyk7XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRvQ3JlYXRlTm9kZSA9IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQoJzwnICsgdGFnTmFtZSArICcgeG1sbnM9XCInICsgdXJuICsgJ1wiIGNsYXNzPVwienJ2bWxcIj4nKTtcbiAgICB9O1xuICB9XG59IC8vIEZyb20gcmFwaGFlbFxuXG5cbmZ1bmN0aW9uIGluaXRWTUwoKSB7XG4gIGlmICh2bWxJbml0ZWQgfHwgIWRvYykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZtbEluaXRlZCA9IHRydWU7XG4gIHZhciBzdHlsZVNoZWV0cyA9IGRvYy5zdHlsZVNoZWV0cztcblxuICBpZiAoc3R5bGVTaGVldHMubGVuZ3RoIDwgMzEpIHtcbiAgICBkb2MuY3JlYXRlU3R5bGVTaGVldCgpLmFkZFJ1bGUoJy56cnZtbCcsICdiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKScpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzMTE5NCUyOFZTLjg1JTI5LmFzcHhcbiAgICBzdHlsZVNoZWV0c1swXS5hZGRSdWxlKCcuenJ2bWwnLCAnYmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCknKTtcbiAgfVxufVxuXG5leHBvcnRzLmRvYyA9IGRvYztcbmV4cG9ydHMuY3JlYXRlTm9kZSA9IGNyZWF0ZU5vZGU7XG5leHBvcnRzLmluaXRWTUwgPSBpbml0Vk1MO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi96cmVuZGVyL2xpYi92bWwvY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB6ckxvZyA9IHJlcXVpcmUoXCIuLi9jb3JlL2xvZ1wiKTtcblxudmFyIHZtbENvcmUgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgZWFjaCA9IF91dGlsLmVhY2g7XG5cbi8qKlxuICogVk1MIFBhaW50ZXIuXG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL3ZtbC9QYWludGVyXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSW50MTAodmFsKSB7XG4gIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbn1cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3ZtbC9QYWludGVyXG4gKi9cblxuXG5mdW5jdGlvbiBWTUxQYWludGVyKHJvb3QsIHN0b3JhZ2UpIHtcbiAgdm1sQ29yZS5pbml0Vk1MKCk7XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG4gIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gIHZhciB2bWxWaWV3cG9ydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgdm1sUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2bWxWaWV3cG9ydC5zdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDozMDBweDtoZWlnaHQ6MTUwcHg7JztcbiAgdm1sUm9vdC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDsnO1xuICByb290LmFwcGVuZENoaWxkKHZtbFZpZXdwb3J0KTtcbiAgdGhpcy5fdm1sUm9vdCA9IHZtbFJvb3Q7XG4gIHRoaXMuX3ZtbFZpZXdwb3J0ID0gdm1sVmlld3BvcnQ7XG4gIHRoaXMucmVzaXplKCk7IC8vIE1vZGlmeSBzdG9yYWdlXG5cbiAgdmFyIG9sZERlbEZyb21TdG9yYWdlID0gc3RvcmFnZS5kZWxGcm9tU3RvcmFnZTtcbiAgdmFyIG9sZEFkZFRvU3RvcmFnZSA9IHN0b3JhZ2UuYWRkVG9TdG9yYWdlO1xuXG4gIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBvbGREZWxGcm9tU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcblxuICAgIGlmIChlbCkge1xuICAgICAgZWwub25SZW1vdmUgJiYgZWwub25SZW1vdmUodm1sUm9vdCk7XG4gICAgfVxuICB9O1xuXG4gIHN0b3JhZ2UuYWRkVG9TdG9yYWdlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgLy8gRGlzcGxheWFibGUgYWxyZWFkeSBoYXMgYSB2bWwgbm9kZVxuICAgIGVsLm9uQWRkICYmIGVsLm9uQWRkKHZtbFJvb3QpO1xuICAgIG9sZEFkZFRvU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgfTtcblxuICB0aGlzLl9maXJzdFBhaW50ID0gdHJ1ZTtcbn1cblxuVk1MUGFpbnRlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBWTUxQYWludGVyLFxuICBnZXRUeXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICd2bWwnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRGl2RWxlbWVudH1cbiAgICovXG4gIGdldFZpZXdwb3J0Um9vdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92bWxWaWV3cG9ydDtcbiAgfSxcbiAgZ2V0Vmlld3BvcnRSb290T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpZXdwb3J0Um9vdCA9IHRoaXMuZ2V0Vmlld3BvcnRSb290KCk7XG5cbiAgICBpZiAodmlld3BvcnRSb290KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXRMZWZ0OiB2aWV3cG9ydFJvb3Qub2Zmc2V0TGVmdCB8fCAwLFxuICAgICAgICBvZmZzZXRUb3A6IHZpZXdwb3J0Um9vdC5vZmZzZXRUb3AgfHwgMFxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIt+aWsFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUsIHRydWUpO1xuXG4gICAgdGhpcy5fcGFpbnRMaXN0KGxpc3QpO1xuICB9LFxuICBfcGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCkge1xuICAgIHZhciB2bWxSb290ID0gdGhpcy5fdm1sUm9vdDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsID0gbGlzdFtpXTtcblxuICAgICAgaWYgKGVsLmludmlzaWJsZSB8fCBlbC5pZ25vcmUpIHtcbiAgICAgICAgaWYgKCFlbC5fX2FscmVhZHlOb3RWaXNpYmxlKSB7XG4gICAgICAgICAgZWwub25SZW1vdmUodm1sUm9vdCk7XG4gICAgICAgIH0gLy8gU2V0IGFzIGFscmVhZHkgaW52aXNpYmxlXG5cblxuICAgICAgICBlbC5fX2FscmVhZHlOb3RWaXNpYmxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbC5fX2FscmVhZHlOb3RWaXNpYmxlKSB7XG4gICAgICAgICAgZWwub25BZGQodm1sUm9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbC5fX2FscmVhZHlOb3RWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaCgpO1xuICAgICAgICAgIChlbC5icnVzaFZNTCB8fCBlbC5icnVzaCkuY2FsbChlbCwgdm1sUm9vdCk7XG4gICAgICAgICAgZWwuYWZ0ZXJCcnVzaCAmJiBlbC5hZnRlckJydXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9maXJzdFBhaW50KSB7XG4gICAgICAvLyBEZXRhY2hlZCBmcm9tIGRvY3VtZW50IGF0IGZpcnN0IHRpbWVcbiAgICAgIC8vIHRvIGF2b2lkIHBhZ2UgcmVmcmVzaGluZyB0b28gbWFueSB0aW1lc1xuICAgICAgLy8gRklYTUUg5aaC5p6c5q+P5qyh6YO95YWIIHJlbW92ZUNoaWxkIOWPr+iDveS8muWvvOiHtOS4gOS6m+Whq+WFheWSjOaPj+i+ueeahOaViOaenOaUueWPmFxuICAgICAgdGhpcy5fdm1sVmlld3BvcnQuYXBwZW5kQ2hpbGQodm1sUm9vdCk7XG5cbiAgICAgIHRoaXMuX2ZpcnN0UGFpbnQgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgd2lkdGggPSB3aWR0aCA9PSBudWxsID8gdGhpcy5fZ2V0V2lkdGgoKSA6IHdpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBoZWlnaHQgPT0gbnVsbCA/IHRoaXMuX2dldEhlaWdodCgpIDogaGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMuX3dpZHRoICE9IHdpZHRoIHx8IHRoaXMuX2hlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB2YXIgdm1sVmlld3BvcnRTdHlsZSA9IHRoaXMuX3ZtbFZpZXdwb3J0LnN0eWxlO1xuICAgICAgdm1sVmlld3BvcnRTdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIHZtbFZpZXdwb3J0U3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gIH0sXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG4gICAgdGhpcy5fdm1sUm9vdCA9IHRoaXMuX3ZtbFZpZXdwb3J0ID0gdGhpcy5zdG9yYWdlID0gbnVsbDtcbiAgfSxcbiAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH0sXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3ZtbFZpZXdwb3J0KSB7XG4gICAgICB0aGlzLnJvb3QucmVtb3ZlQ2hpbGQodGhpcy5fdm1sVmlld3BvcnQpO1xuICAgIH1cbiAgfSxcbiAgX2dldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgdmFyIHN0bCA9IHJvb3QuY3VycmVudFN0eWxlO1xuICAgIHJldHVybiAocm9vdC5jbGllbnRXaWR0aCB8fCBwYXJzZUludDEwKHN0bC53aWR0aCkpIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ0xlZnQpIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ1JpZ2h0KSB8IDA7XG4gIH0sXG4gIF9nZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICB2YXIgc3RsID0gcm9vdC5jdXJyZW50U3R5bGU7XG4gICAgcmV0dXJuIChyb290LmNsaWVudEhlaWdodCB8fCBwYXJzZUludDEwKHN0bC5oZWlnaHQpKSAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdUb3ApIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ0JvdHRvbSkgfCAwO1xuICB9XG59OyAvLyBOb3Qgc3VwcG9ydGVkIG1ldGhvZHNcblxuZnVuY3Rpb24gY3JlYXRlTWV0aG9kTm90U3VwcG9ydChtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB6ckxvZygnSW4gSUU4LjAgVk1MIG1vZGUgcGFpbnRlciBub3Qgc3VwcG9ydCBtZXRob2QgXCInICsgbWV0aG9kICsgJ1wiJyk7XG4gIH07XG59IC8vIFVuc3VwcG9ydGVkIG1ldGhvZHNcblxuXG5lYWNoKFsnZ2V0TGF5ZXInLCAnaW5zZXJ0TGF5ZXInLCAnZWFjaExheWVyJywgJ2VhY2hCdWlsdGluTGF5ZXInLCAnZWFjaE90aGVyTGF5ZXInLCAnZ2V0TGF5ZXJzJywgJ21vZExheWVyJywgJ2RlbExheWVyJywgJ2NsZWFyTGF5ZXInLCAndG9EYXRhVVJMJywgJ3BhdGhUb0ltYWdlJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFZNTFBhaW50ZXIucHJvdG90eXBlW25hbWVdID0gY3JlYXRlTWV0aG9kTm90U3VwcG9ydChuYW1lKTtcbn0pO1xudmFyIF9kZWZhdWx0ID0gVk1MUGFpbnRlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3pyZW5kZXIvbGliL3ZtbC9QYWludGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==